{"sha": "ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWY3ODI3YjBiZDdjZDk4MGRhNjI1ZmNkMTJlNmM1NmY1MWExNjZjMg==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2019-12-14T00:48:06Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2020-01-14T23:47:22Z"}, "message": "analyzer: purge state for unknown function calls\n\nWhilst analyzing the reproducer for detecting CVE-2005-1689\n(krb5-1.4.1's src/lib/krb5/krb/recvauth.c), the analyzer reports\na false double-free of the form:\n\n  krb5_xfree(inbuf.data);\n  krb5_read_message(..., &inbuf);\n  krb5_xfree(inbuf.data); /* false diagnostic here.  */\n\nwhere the call to krb5_read_message overwrites inbuf.data with\na freshly-malloced buffer.\n\nThis patch fixes the issue by purging state more thorougly when\nhandling a call with unknown behavior, by walking the graph of\nmemory regions that are reachable from the call.\n\ngcc/analyzer/ChangeLog:\n\t* analyzer.h (fndecl_has_gimple_body_p): New decl.\n\t* engine.cc (impl_region_model_context::on_unknown_change): New\n\tfunction.\n\t(fndecl_has_gimple_body_p): Make non-static.\n\t(exploded_node::on_stmt): Treat __analyzer_dump_exploded_nodes as\n\tknown.  Track whether we have a call with unknown side-effects and\n\tpass it to on_call_post.\n\t* exploded-graph.h (impl_region_model_context::on_unknown_change):\n\tNew decl.\n\t* program-state.cc (sm_state_map::on_unknown_change): New function.\n\t* program-state.h (sm_state_map::on_unknown_change): New decl.\n\t* region-model.cc: Include \"bitmap.h\".\n\t(region_model::on_call_pre): Return a bool, capturing whether the\n\tcall has unknown side effects.\n\t(region_model::on_call_post): Add arg \"bool unknown_side_effects\"\n\tand if true, call handle_unrecognized_call.\n\t(class reachable_regions): New class.\n\t(region_model::handle_unrecognized_call): New function.\n\t* region-model.h (region_model::on_call_pre): Return a bool.\n\t(region_model::on_call_post): Add arg \"bool unknown_side_effects\".\n\t(region_model::handle_unrecognized_call): New decl.\n\t(region_model_context::on_unknown_change): New vfunc.\n\t(test_region_model_context::on_unknown_change): New function.\n\ngcc/testsuite/ChangeLog:\n\t* gcc.dg/analyzer/data-model-1.c: Remove xfail.\n\t* gcc.dg/analyzer/data-model-5b.c: Likewise.\n\t* gcc.dg/analyzer/data-model-5c.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-3.c: Mark \"foo\" as pure.\n\t* gcc.dg/analyzer/setjmp-4.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-6.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-7.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-7a.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-8.c: Likewise.\n\t* gcc.dg/analyzer/setjmp-9.c: Likewise.\n\t* gcc.dg/analyzer/unknown-fns.c: New test.", "tree": {"sha": "7b501f4af72a1259ff2454de2b4569a221c6bbc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b501f4af72a1259ff2454de2b4569a221c6bbc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "14f9d7b9a708ebca57257059bda40986bb1e82a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/14f9d7b9a708ebca57257059bda40986bb1e82a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/14f9d7b9a708ebca57257059bda40986bb1e82a7"}], "stats": {"total": 461, "additions": 423, "deletions": 38}, "files": [{"sha": "96d5ce99538e353b0ca01b154f1b5cbc5d91c8ce", "filename": "gcc/analyzer/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2FChangeLog?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -1,3 +1,29 @@\n+2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* analyzer.h (fndecl_has_gimple_body_p): New decl.\n+\t* engine.cc (impl_region_model_context::on_unknown_change): New\n+\tfunction.\n+\t(fndecl_has_gimple_body_p): Make non-static.\n+\t(exploded_node::on_stmt): Treat __analyzer_dump_exploded_nodes as\n+\tknown.  Track whether we have a call with unknown side-effects and\n+\tpass it to on_call_post.\n+\t* exploded-graph.h (impl_region_model_context::on_unknown_change):\n+\tNew decl.\n+\t* program-state.cc (sm_state_map::on_unknown_change): New function.\n+\t* program-state.h (sm_state_map::on_unknown_change): New decl.\n+\t* region-model.cc: Include \"bitmap.h\".\n+\t(region_model::on_call_pre): Return a bool, capturing whether the\n+\tcall has unknown side effects.\n+\t(region_model::on_call_post): Add arg \"bool unknown_side_effects\"\n+\tand if true, call handle_unrecognized_call.\n+\t(class reachable_regions): New class.\n+\t(region_model::handle_unrecognized_call): New function.\n+\t* region-model.h (region_model::on_call_pre): Return a bool.\n+\t(region_model::on_call_post): Add arg \"bool unknown_side_effects\".\n+\t(region_model::handle_unrecognized_call): New decl.\n+\t(region_model_context::on_unknown_change): New vfunc.\n+\t(test_region_model_context::on_unknown_change): New function.\n+\n 2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* diagnostic-manager.cc (saved_diagnostic::operator==): Move here"}, {"sha": "7fc6959c4607d11a1886412a2083c741a4157452", "filename": "gcc/analyzer/analyzer.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fanalyzer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fanalyzer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fanalyzer.h?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -80,6 +80,8 @@ extern void register_analyzer_pass ();\n \n extern label_text make_label_text (bool can_colorize, const char *fmt, ...);\n \n+extern bool fndecl_has_gimple_body_p (tree fndecl);\n+\n /* An RAII-style class for pushing/popping cfun within a scope.\n    Doing so ensures we get \"In function \" announcements\n    from the diagnostics subsystem.  */"}, {"sha": "573f9f6e35bd7d2f5c80c29d85758c9a1d716c92", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -135,6 +135,15 @@ impl_region_model_context::on_svalue_purge (svalue_id first_unused_sid,\n   return total;\n }\n \n+void\n+impl_region_model_context::on_unknown_change (svalue_id sid)\n+{\n+  int sm_idx;\n+  sm_state_map *smap;\n+  FOR_EACH_VEC_ELT (m_new_state->m_checker_states, sm_idx, smap)\n+    smap->on_unknown_change (sid);\n+}\n+\n /* class setjmp_svalue : public svalue.  */\n \n /* Compare the fields of this setjmp_svalue with OTHER, returning true\n@@ -876,7 +885,7 @@ exploded_node::dump (const extrinsic_state &ext_state) const\n /* Return true if FNDECL has a gimple body.  */\n // TODO: is there a pre-canned way to do this?\n \n-static bool\n+bool\n fndecl_has_gimple_body_p (tree fndecl)\n {\n   if (fndecl == NULL_TREE)\n@@ -935,6 +944,10 @@ exploded_node::on_stmt (exploded_graph &eg,\n   if (const greturn *return_ = dyn_cast <const greturn *> (stmt))\n     state->m_region_model->on_return (return_, &ctxt);\n \n+  /* Track whether we have a gcall to a function that's not recognized by\n+     anything, for which we don't have a function body, or for which we\n+     don't know the fndecl.  */\n+  bool unknown_side_effects = false;\n   if (const gcall *call = dyn_cast <const gcall *> (stmt))\n     {\n       /* Debugging/test support.  */\n@@ -977,6 +990,11 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t  /* TODO: is there a good cross-platform way to do this?  */\n \t  raise (SIGINT);\n \t}\n+      else if (is_special_named_call_p (call, \"__analyzer_dump_exploded_nodes\",\n+\t\t\t\t\t1))\n+\t{\n+\t  /* This is handled elsewhere.  */\n+\t}\n       else if (is_setjmp_call_p (stmt))\n \tstate->m_region_model->on_setjmp (call, this, &ctxt);\n       else if (is_longjmp_call_p (call))\n@@ -985,7 +1003,7 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t  return on_stmt_flags::terminate_path ();\n \t}\n       else\n-\tstate->m_region_model->on_call_pre (call, &ctxt);\n+\tunknown_side_effects = state->m_region_model->on_call_pre (call, &ctxt);\n     }\n \n   bool any_sm_changes = false;\n@@ -1001,7 +1019,9 @@ exploded_node::on_stmt (exploded_graph &eg,\n \t\t\t    change,\n \t\t\t    old_smap, new_smap);\n       /* Allow the state_machine to handle the stmt.  */\n-      if (!sm.on_stmt (&ctxt, snode, stmt))\n+      if (sm.on_stmt (&ctxt, snode, stmt))\n+\tunknown_side_effects = false;\n+      else\n \t{\n \t  /* For those stmts that were not handled by the state machine.  */\n \t  if (const gcall *call = dyn_cast <const gcall *> (stmt))\n@@ -1019,7 +1039,7 @@ exploded_node::on_stmt (exploded_graph &eg,\n     }\n \n   if (const gcall *call = dyn_cast <const gcall *> (stmt))\n-    state->m_region_model->on_call_post (call, &ctxt);\n+    state->m_region_model->on_call_post (call, unknown_side_effects, &ctxt);\n \n   return on_stmt_flags (any_sm_changes);\n }"}, {"sha": "357a1b478f0525983bd7d679457ed55b75e0684a", "filename": "gcc/analyzer/exploded-graph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fexploded-graph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fexploded-graph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fexploded-graph.h?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -70,6 +70,8 @@ class impl_region_model_context : public region_model_context\n \n   void on_condition (tree lhs, enum tree_code op, tree rhs) FINAL OVERRIDE;\n \n+  void on_unknown_change (svalue_id sid ATTRIBUTE_UNUSED) FINAL OVERRIDE;\n+\n   exploded_graph *m_eg;\n   log_user m_logger;\n   const exploded_node *m_enode_for_diag;"}, {"sha": "c9b595eca2b4f8448b53e8a3aece2f88ffb11838", "filename": "gcc/analyzer/program-state.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fprogram-state.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fprogram-state.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.cc?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -480,6 +480,14 @@ sm_state_map::on_cast (svalue_id src_sid,\n   impl_set_state (dst_sid, state, get_origin (src_sid));\n }\n \n+/* Purge state from SID (in response to a call to an unknown function).  */\n+\n+void\n+sm_state_map::on_unknown_change (svalue_id sid)\n+{\n+  impl_set_state (sid, (state_machine::state_t)0, svalue_id::null ());\n+}\n+\n /* Assert that this object is sane.  */\n \n void"}, {"sha": "155eaf877eff65879b81049265063a5aa0a36cbe", "filename": "gcc/analyzer/program-state.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fprogram-state.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fprogram-state.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fprogram-state.h?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -184,6 +184,8 @@ class sm_state_map\n   void on_cast (svalue_id src_sid,\n \t\tsvalue_id dst_sid);\n \n+  void on_unknown_change (svalue_id sid);\n+\n   void validate (const state_machine &sm, int num_svalues) const;\n \n   iterator_t begin () const { return m_map.begin (); }"}, {"sha": "b492222d64d6e7cabc3d202383eae6448bd40e6e", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 205, "deletions": 12, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -39,6 +39,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"diagnostic-metadata.h\"\n #include \"diagnostic-core.h\"\n #include \"tristate.h\"\n+#include \"bitmap.h\"\n #include \"selftest.h\"\n #include \"function.h\"\n #include \"analyzer/analyzer.h\"\n@@ -4115,9 +4116,13 @@ region_model::on_assignment (const gassign *assign, region_model_context *ctxt)\n \n    Updates to the region_model that should be made *before* sm-states\n    are updated are done here; other updates to the region_model are done\n-   in region_model::on_call_post.  */\n+   in region_model::on_call_post.\n \n-void\n+   Return true if the function call has unknown side effects (it wasn't\n+   recognized and we don't have a body for it, or are unable to tell which\n+   fndecl it is).  */\n+\n+bool\n region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n {\n   region_id lhs_rid;\n@@ -4135,6 +4140,8 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n     for (unsigned i = 0; i < gimple_call_num_args (call); i++)\n       check_for_poison (gimple_call_arg (call, i), ctxt);\n \n+  bool unknown_side_effects = false;\n+\n   if (tree callee_fndecl = get_fndecl_for_call (call, ctxt))\n     {\n       if (is_named_call_p (callee_fndecl, \"malloc\", call, 1))\n@@ -4147,7 +4154,7 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n \t\t= get_or_create_ptr_svalue (lhs_type, new_rid);\n \t      set_value (lhs_rid, ptr_sid, ctxt);\n \t    }\n-\t  return;\n+\t  return false;\n \t}\n       else if (is_named_call_p (callee_fndecl, \"__builtin_alloca\", call, 1))\n \t{\n@@ -4160,7 +4167,7 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n \t\t= get_or_create_ptr_svalue (lhs_type, new_rid);\n \t      set_value (lhs_rid, ptr_sid, ctxt);\n \t    }\n-\t  return;\n+\t  return false;\n \t}\n       else if (is_named_call_p (callee_fndecl, \"strlen\", call, 1))\n \t{\n@@ -4179,7 +4186,7 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n \t\t  svalue_id result_sid\n \t\t    = get_or_create_constant_svalue (t_cst);\n \t\t  set_value (lhs_rid, result_sid, ctxt);\n-\t\t  return;\n+\t\t  return false;\n \t\t}\n \t    }\n \t  /* Otherwise an unknown value.  */\n@@ -4199,29 +4206,36 @@ region_model::on_call_pre (const gcall *call, region_model_context *ctxt)\n \t  /* Use quotes to ensure the output isn't truncated.  */\n \t  warning_at (call->location, 0,\n \t\t      \"num heap regions: %qi\", num_heap_regions);\n+\t  return false;\n \t}\n+      else if (!fndecl_has_gimple_body_p (callee_fndecl)\n+\t       && !DECL_PURE_P (callee_fndecl))\n+\tunknown_side_effects = true;\n     }\n-\n-  /* Unrecognized call.  */\n+  else\n+    unknown_side_effects = true;\n \n   /* Unknown return value.  */\n   if (!lhs_rid.null_p ())\n     set_to_new_unknown_value (lhs_rid, lhs_type, ctxt);\n \n-  /* TODO: also, any pointer arguments might have been written through,\n-     or the things they point to (implying a graph traversal, which\n-     presumably we need to do before overwriting the old value).  */\n+  return unknown_side_effects;\n }\n \n /* Update this model for the CALL stmt, using CTXT to report any\n    diagnostics - the second half.\n \n    Updates to the region_model that should be made *after* sm-states\n    are updated are done here; other updates to the region_model are done\n-   in region_model::on_call_pre.  */\n+   in region_model::on_call_pre.\n+\n+   If UNKNOWN_SIDE_EFFECTS is true, also call handle_unrecognized_call\n+   to purge state.  */\n \n void\n-region_model::on_call_post (const gcall *call, region_model_context *ctxt)\n+region_model::on_call_post (const gcall *call,\n+\t\t\t    bool unknown_side_effects,\n+\t\t\t    region_model_context *ctxt)\n {\n   /* Update for \"free\" here, after sm-handling.\n \n@@ -4264,6 +4278,185 @@ region_model::on_call_post (const gcall *call, region_model_context *ctxt)\n \t  }\n \treturn;\n       }\n+\n+  if (unknown_side_effects)\n+    handle_unrecognized_call (call, ctxt);\n+}\n+\n+/* Helper class for region_model::handle_unrecognized_call, for keeping\n+   track of all regions that are reachable, and, of those, which are\n+   mutable.  */\n+\n+class reachable_regions\n+{\n+public:\n+  reachable_regions (region_model *model)\n+  : m_model (model), m_reachable_rids (), m_mutable_rids ()\n+  {}\n+\n+  /* Lazily mark RID as being reachable, recursively adding regions\n+     reachable from RID.  */\n+  void add (region_id rid, bool is_mutable)\n+  {\n+    gcc_assert (!rid.null_p ());\n+\n+    unsigned idx = rid.as_int ();\n+    /* Bail out if this region is already in the sets at the IS_MUTABLE\n+       level of mutability.  */\n+    if (!is_mutable && bitmap_bit_p (m_reachable_rids, idx))\n+      return;\n+    bitmap_set_bit (m_reachable_rids, idx);\n+\n+    if (is_mutable)\n+      {\n+\tif (bitmap_bit_p (m_mutable_rids, idx))\n+\t  return;\n+\telse\n+\t  bitmap_set_bit (m_mutable_rids, idx);\n+      }\n+\n+    /* If this region's value is a pointer, add the pointee.  */\n+    region *reg = m_model->get_region (rid);\n+    svalue_id sid = reg->get_value_direct ();\n+    svalue *sval = m_model->get_svalue (sid);\n+    if (sval)\n+      if (region_svalue *ptr = sval->dyn_cast_region_svalue ())\n+\t{\n+\t  region_id pointee_rid = ptr->get_pointee ();\n+\t  /* Use const-ness of pointer type to affect mutability.  */\n+\t  bool ptr_is_mutable = true;\n+\t  if (ptr->get_type ()\n+\t      && TREE_CODE (ptr->get_type ()) == POINTER_TYPE\n+\t      && TYPE_READONLY (TREE_TYPE (ptr->get_type ())))\n+\t    ptr_is_mutable = false;\n+\t  add (pointee_rid, ptr_is_mutable);\n+\t}\n+\n+    /* Add descendents of this region.  */\n+    region_id_set descendents (m_model);\n+    m_model->get_descendents (rid, &descendents, region_id::null ());\n+    for (unsigned i = 0; i < m_model->get_num_regions (); i++)\n+      {\n+\tregion_id iter_rid = region_id::from_int (i);\n+\tif (descendents.region_p (iter_rid))\n+\t  add (iter_rid, is_mutable);\n+      }\n+  }\n+\n+  bool mutable_p (region_id rid)\n+  {\n+    gcc_assert (!rid.null_p ());\n+    return bitmap_bit_p (m_mutable_rids, rid.as_int ());\n+  }\n+\n+private:\n+  region_model *m_model;\n+\n+  /* The region ids already seen.  This has to be an auto_bitmap rather than\n+     an auto_sbitmap as new regions can be created within the model during\n+     the traversal.  */\n+  auto_bitmap m_reachable_rids;\n+\n+  /* The region_ids that can be changed (accessed via non-const pointers).  */\n+  auto_bitmap m_mutable_rids;\n+};\n+\n+/* Handle a call CALL to a function with unknown behavior.\n+\n+   Traverse the regions in this model, determining what regions are\n+   reachable from pointer arguments to CALL and from global variables,\n+   recursively.\n+\n+   Set all reachable regions to new unknown values and purge sm-state\n+   from their values, and from values that point to them.  */\n+\n+void\n+region_model::handle_unrecognized_call (const gcall *call,\n+\t\t\t\t\tregion_model_context *ctxt)\n+{\n+  tree fndecl = get_fndecl_for_call (call, ctxt);\n+\n+  reachable_regions reachable_regions (this);\n+\n+  /* Determine the reachable regions and their mutability.  */\n+  {\n+    /* Globals.  */\n+    region_id globals_rid = get_globals_region_id ();\n+    if (!globals_rid.null_p ())\n+      reachable_regions.add (globals_rid, true);\n+\n+    /* Params that are pointers.  */\n+    tree iter_param_types = NULL_TREE;\n+    if (fndecl)\n+      iter_param_types = TYPE_ARG_TYPES (TREE_TYPE (fndecl));\n+    for (unsigned arg_idx = 0; arg_idx < gimple_call_num_args (call); arg_idx++)\n+      {\n+\t/* Track expected param type, where available.  */\n+\ttree param_type = NULL_TREE;\n+\tif (iter_param_types)\n+\t  {\n+\t    param_type = TREE_VALUE (iter_param_types);\n+\t    gcc_assert (param_type);\n+\t    iter_param_types = TREE_CHAIN (iter_param_types);\n+\t  }\n+\n+\ttree parm = gimple_call_arg (call, arg_idx);\n+\tsvalue_id parm_sid = get_rvalue (parm, NULL);\n+\tsvalue *parm_sval = get_svalue (parm_sid);\n+\tif (parm_sval)\n+\t  if (region_svalue *parm_ptr = parm_sval->dyn_cast_region_svalue ())\n+\t    {\n+\t      region_id pointee_rid = parm_ptr->get_pointee ();\n+\t      bool is_mutable = true;\n+\t      if (param_type\n+\t\t  && TREE_CODE (param_type) == POINTER_TYPE\n+\t\t  &&  TYPE_READONLY (TREE_TYPE (param_type)))\n+\t\tis_mutable = false;\n+\t      reachable_regions.add (pointee_rid, is_mutable);\n+\t    }\n+\t// FIXME: what about compound parms that contain ptrs?\n+      }\n+  }\n+\n+  /* OK: we now have all reachable regions.\n+     Set them all to new unknown values.  */\n+  for (unsigned i = 0; i < get_num_regions (); i++)\n+    {\n+      region_id iter_rid = region_id::from_int (i);\n+      if (reachable_regions.mutable_p (iter_rid))\n+\t{\n+\t  region *reg = get_region (iter_rid);\n+\n+\t  /* Purge any sm-state for any underlying svalue.  */\n+\t  svalue_id curr_sid = reg->get_value_direct ();\n+\t  if (!curr_sid.null_p ())\n+\t    ctxt->on_unknown_change (curr_sid);\n+\n+\t  set_to_new_unknown_value (iter_rid,\n+\t\t\t\t    reg->get_type (),\n+\t\t\t\t    ctxt);\n+\t}\n+    }\n+\n+  /* Purge sm-state for any remaining svalues that point to regions that\n+     were reachable.  This helps suppress leak false-positives.\n+\n+     For example, if we had a malloc call that was cast to a \"foo *\" type,\n+     we could have a temporary void * for the result of malloc which has its\n+     own svalue, not reachable from the function call, but for which the\n+     \"foo *\" svalue was reachable.  If we don't purge it, the temporary will\n+     be reported as a leak.  */\n+  int i;\n+  svalue *svalue;\n+  FOR_EACH_VEC_ELT (m_svalues, i, svalue)\n+    if (region_svalue *ptr = svalue->dyn_cast_region_svalue ())\n+      {\n+\tregion_id pointee_rid = ptr->get_pointee ();\n+\tif (reachable_regions.mutable_p (pointee_rid))\n+\t  ctxt->on_unknown_change (svalue_id::from_int (i));\n+      }\n+\n+  validate ();\n }\n \n /* Update this model for the RETURN_STMT, using CTXT to report any"}, {"sha": "2d0c0618bd0b7b243b6613365bb577db06648357", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -1578,8 +1578,12 @@ class region_model\n \n   void check_for_poison (tree expr, region_model_context *ctxt);\n   void on_assignment (const gassign *stmt, region_model_context *ctxt);\n-  void on_call_pre (const gcall *stmt, region_model_context *ctxt);\n-  void on_call_post (const gcall *stmt, region_model_context *ctxt);\n+  bool on_call_pre (const gcall *stmt, region_model_context *ctxt);\n+  void on_call_post (const gcall *stmt,\n+\t\t     bool unknown_side_effects,\n+\t\t     region_model_context *ctxt);\n+  void handle_unrecognized_call (const gcall *call,\n+\t\t\t\t region_model_context *ctxt);\n   void on_return (const greturn *stmt, region_model_context *ctxt);\n   void on_setjmp (const gcall *stmt, const exploded_node *enode,\n \t\t  region_model_context *ctxt);\n@@ -1827,6 +1831,10 @@ class region_model_context\n      to ptrs becoming known to be NULL or non-NULL, rather than just\n      \"unchecked\") */\n   virtual void on_condition (tree lhs, enum tree_code op, tree rhs) = 0;\n+\n+  /* Hooks for clients to be notified when an unknown change happens\n+     to SID (in response to a call to an unknown function).  */\n+  virtual void on_unknown_change (svalue_id sid) = 0;\n };\n \n /* A bundle of data for use when attempting to merge two region_model\n@@ -1993,6 +2001,10 @@ class test_region_model_context : public region_model_context\n   {\n   }\n \n+  void on_unknown_change (svalue_id sid ATTRIBUTE_UNUSED) FINAL OVERRIDE\n+  {\n+  }\n+\n private:\n   /* Implicitly delete any diagnostics in the dtor.  */\n   auto_delete_vec<pending_diagnostic> m_diagnostics;"}, {"sha": "efff14c4141694665082f68bfbcbb6c1d24af23d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -1,3 +1,17 @@\n+2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gcc.dg/analyzer/data-model-1.c: Remove xfail.\n+\t* gcc.dg/analyzer/data-model-5b.c: Likewise.\n+\t* gcc.dg/analyzer/data-model-5c.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-3.c: Mark \"foo\" as pure.\n+\t* gcc.dg/analyzer/setjmp-4.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-6.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-7.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-7a.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-8.c: Likewise.\n+\t* gcc.dg/analyzer/setjmp-9.c: Likewise.\n+\t* gcc.dg/analyzer/unknown-fns.c: New test.\n+\n 2020-01-14  David Malcolm  <dmalcolm@redhat.com>\n \n \t* gcc.dg/analyzer/CVE-2005-1689-dedupe-issue.c: New test."}, {"sha": "a5840a25944639e257b3f2d97b5f9ecd34eaafef", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-1.c", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-1.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -326,9 +326,7 @@ void test_16e (int i)\n   __analyzer_eval (j == i); /* { dg-warning \"TRUE\" } */\n \n   might_write_to (&j);\n-  __analyzer_eval (j == i); /* { dg-warning \"UNKNOWN\" \"\" { xfail *-*-* } } */\n-  /* { dg-warning \"TRUE\" \"\" { target *-*-* } .-1 } */\n-  // TODO(xfail)\n+  __analyzer_eval (j == i); /* { dg-warning \"UNKNOWN\" } */\n }\n \n /* TODO: and more complicated graph-like examples, where anything that's"}, {"sha": "6866f5bf4696dc2f163e5aa0006d39f6467b9cbe", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5b.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5b.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -87,5 +87,4 @@ void test_1 (const char *str)\n   //__analyzer_dump();\n   if (obj)\n     unref (obj);\n-} /* { dg-bogus \"leak of 'obj'\" \"\" { xfail *-*-* } } */\n-// TODO (xfail): not sure why this is treated as leaking\n+}"}, {"sha": "4dc559c1fcd6d7b628bb1237067a06ae9f697aca", "filename": "gcc/testsuite/gcc.dg/analyzer/data-model-5c.c", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fdata-model-5c.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -66,19 +66,13 @@ string_obj *new_string_obj (const char *str)\n \n void unref (string_obj *obj)\n {\n-  //__analyzer_dump();\n   if (--obj->str_base.ob_refcnt == 0)\n-    {\n-      //__analyzer_dump();\n-      free (obj);\n-    }\n+    free (obj);\n }\n \n void test_1 (const char *str)\n {\n   string_obj *obj = new_string_obj (str);\n-  //__analyzer_dump();\n   if (obj)\n     unref (obj);\n-} /* { dg-bogus \"leak of 'obj'\" \"\" { xfail *-*-* } } */\n-// TODO (xfail): not sure why this is treated as leaking\n+}"}, {"sha": "0c082b82a7086c8914f0c07e3482dff618d47c54", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-3.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -5,7 +5,7 @@\n #include <stddef.h>\n #include \"analyzer-decls.h\"\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "bfac6170d910f12793feb7b260bf9f34896d4a96", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-4.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-4.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -4,7 +4,7 @@\n #include <setjmp.h>\n #include \"analyzer-decls.h\"\n \n-extern int foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n static jmp_buf buf;\n \n void inner (int x)"}, {"sha": "d7319129070e2d0d441089e4e48dd49537a3c758", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-6.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -2,7 +2,7 @@\n #include <stddef.h>\n #include <stdlib.h>\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "3a14534434d8541827770bdee43219bcbecaa1a2", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-7.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -2,7 +2,7 @@\n #include <stddef.h>\n #include <stdlib.h>\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "1e2c348af3e4c90df2db10166d4dc363e5a612b3", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-7a.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-7a.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -4,7 +4,7 @@\n #include <setjmp.h>\n #include <stdlib.h>\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "fb93165380392985940562748cd090e42d9d52cb", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-8.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-8.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -5,7 +5,7 @@\n #include <stddef.h>\n #include \"analyzer-decls.h\"\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "fa2d3152c27cbeb5e031c3fea20a8c1f0ada1b9a", "filename": "gcc/testsuite/gcc.dg/analyzer/setjmp-9.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fsetjmp-9.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -5,7 +5,7 @@\n #include <stddef.h>\n #include \"analyzer-decls.h\"\n \n-extern void foo (int);\n+extern int foo (int) __attribute__ ((__pure__));\n \n static jmp_buf env;\n "}, {"sha": "76cb68eaa569b1db2cf6fecd81a44fc7f5019fcd", "filename": "gcc/testsuite/gcc.dg/analyzer/unknown-fns.c", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef7827b0bd7cd980da625fcd12e6c56f51a166c2/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Funknown-fns.c?ref=ef7827b0bd7cd980da625fcd12e6c56f51a166c2", "patch": "@@ -0,0 +1,115 @@\n+/* Verify that the analyzer correctly purges state when it sees a call to\n+   an unknown function.  */\n+\n+#include <stdlib.h>\n+\n+/* Verify fix for false-positive when checking for CVE-2005-1689.  */\n+\n+typedef struct _krb5_data {\n+  char *data;\n+} krb5_data;\n+\n+extern void krb5_read_message(krb5_data *buf);\n+\n+void\n+test_1 (krb5_data inbuf)\n+{\n+  free(inbuf.data);\n+  krb5_read_message(&inbuf); \n+  free(inbuf.data); /* { dg-bogus \"double-'free'\" } */\n+}\n+\n+/* Verify that __pure__ functions are treated as not having side-effects.  */\n+\n+extern int called_by_test_1a (void *)\n+  __attribute__ ((__pure__));\n+void test_1a (krb5_data inbuf)\n+{\n+  free (inbuf.data);\n+  called_by_test_1a (&inbuf);\n+  free (inbuf.data); /* { dg-warning \"double-'free'\" } */\n+}\n+\n+/* Verify that global pointers can be affected by an unknown function.  */\n+\n+void *global_ptr;\n+extern void unknown_side_effects (void);\n+\n+void test_2 (void)\n+{\n+  free (global_ptr);\n+  unknown_side_effects ();\n+  free (global_ptr);\n+}\n+\n+extern void called_by_test_3 (void *);\n+\n+void test_3a (void)\n+{\n+  void *ptr = malloc (1024);\n+  called_by_test_3 (ptr);\n+}  /* { dg-bogus \"leak\" } */\n+\n+void test_3b (void)\n+{\n+  krb5_data k;\n+  k.data = malloc (1024);\n+  called_by_test_3 (&k);\n+} /* { dg-bogus \"leak\" } */\n+\n+/* Verify that we traverse the graph of regions that are reachable from\n+   the call.  */\n+\n+struct foo\n+{\n+  struct foo *next;\n+  int *ptr;\n+};\n+\n+/* First, without a call to an unknown function.  */\n+\n+void test_4a (void)\n+{\n+  struct foo node_a;\n+  struct foo node_b;\n+  node_a.next = &node_b;\n+  node_b.ptr = malloc (sizeof (int));\n+  global_ptr = &node_a;\n+  *node_b.ptr = 42; /* { dg-warning \"possibly-NULL\" } */\n+  /* { dg-warning \"leak\" \"\" { target *-*-* } .-1 } */\n+  /* FIXME: the above leak report is correct, but is reported at the wrong\n+     location.  */\n+} /* { dg-warning \"leak\" } */\n+\n+/* With a call to an unknown function.  */\n+\n+void test_4b (void)\n+{\n+  struct foo node_a;\n+  struct foo node_b;\n+  node_a.next = &node_b;\n+  node_b.ptr = malloc (sizeof (int));\n+  global_ptr = &node_a;\n+  unknown_side_effects (); /* everything potentially visible through global_ptr.  */\n+  *node_b.ptr = 42; /* { dg-bogus \"possibly-NULL\" } */\n+} /* { dg-bogus \"leak\" } */\n+\n+extern void called_by_test_5 (const char *);\n+void test_5 (void)\n+{\n+  called_by_test_5 (\"???\");\n+}\n+\n+extern void called_by_test_6 (const struct foo *);\n+void test_6 (void)\n+{\n+  struct foo node;\n+  node.next = NULL;\n+  node.ptr = malloc (sizeof (int));\n+\n+  /* This is a const ptr, but struct foo's ptr is non-const,\n+     so we ought to assume it could be written to.  */\n+  called_by_test_6 (&node);\n+} /* { dg-bogus \"leak\" } */\n+\n+/* TODO: things reachable from \"outside\" i.e. by params to caller to entrypoint.  */"}]}