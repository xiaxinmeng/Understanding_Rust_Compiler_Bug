{"sha": "13dbaefefbab04d5137e718262d4b81cb9035784", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTNkYmFlZmVmYmFiMDRkNTEzN2U3MTgyNjJkNGI4MWNiOTAzNTc4NA==", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-26T06:25:36Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-05-27T08:37:49Z"}, "message": "Move global range code to value-query.cc.\n\nThis patch moves all the global range code from gimple-range.cc into\nvalue-query.cc.  It also moves get_range_info and get_ptr_nonnull from\ntree-ssanames.c into their only uses, and removes external access to them.\n\ngcc/ChangeLog:\n\n\t* gimple-range.cc (get_range_global): Move to value-query.cc.\n\t(gimple_range_global): Same.\n\t(get_global_range_query): Same.\n\t(global_range_query::range_of_expr): Same.\n\t* gimple-range.h (class global_range_query): Move to\n\tvalue-query.h.\n\t(gimple_range_global): Same.\n\t* tree-ssanames.c (get_range_info): Move to value-query.cc.\n\t(get_ptr_nonnull): Same.\n\t* tree-ssanames.h (get_range_info): Remove.\n\t(get_ptr_nonnull): Remove.\n\t* value-query.cc (get_ssa_name_range_info): Move from\n\ttree-ssanames.c.\n\t(get_ssa_name_ptr_info_nonnull): Same.\n\t(get_range_global): Move from gimple-range.cc.\n\t(gimple_range_global): Same.\n\t(get_global_range_query): Same.\n\t(global_range_query::range_of_expr): Same.\n\t* value-query.h (class global_range_query): Move from\n\tgimple-range.h.\n\t(gimple_range_global): Same.", "tree": {"sha": "10bd8974fbd0de0e2d24809141685d726fa2aae1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10bd8974fbd0de0e2d24809141685d726fa2aae1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/13dbaefefbab04d5137e718262d4b81cb9035784", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13dbaefefbab04d5137e718262d4b81cb9035784", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13dbaefefbab04d5137e718262d4b81cb9035784", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13dbaefefbab04d5137e718262d4b81cb9035784/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "95bef94c6c6c6cb7bf640068aea77c209bca7c65", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95bef94c6c6c6cb7bf640068aea77c209bca7c65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95bef94c6c6c6cb7bf640068aea77c209bca7c65"}], "stats": {"total": 319, "additions": 158, "deletions": 161}, "files": [{"sha": "b4dfaa921687f9e09f945b99b85afb97bb492761", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -1441,109 +1441,6 @@ trace_ranger::range_of_expr (irange &r, tree name, gimple *s)\n   return trailer (idx, \"range_of_expr\", res, name, r);\n }\n \n-// Return the legacy global range for NAME if it has one, otherwise\n-// return VARYING.\n-\n-static void\n-get_range_global (irange &r, tree name)\n-{\n-  tree type = TREE_TYPE (name);\n-\n-  if (SSA_NAME_IS_DEFAULT_DEF (name))\n-    {\n-      tree sym = SSA_NAME_VAR (name);\n-      // Adapted from vr_values::get_lattice_entry().\n-      // Use a range from an SSA_NAME's available range.\n-      if (TREE_CODE (sym) == PARM_DECL)\n-\t{\n-\t  // Try to use the \"nonnull\" attribute to create ~[0, 0]\n-\t  // anti-ranges for pointers.  Note that this is only valid with\n-\t  // default definitions of PARM_DECLs.\n-\t  if (POINTER_TYPE_P (type)\n-\t      && ((cfun && nonnull_arg_p (sym)) || get_ptr_nonnull (name)))\n-\t    r.set_nonzero (type);\n-\t  else if (INTEGRAL_TYPE_P (type))\n-\t    {\n-\t      get_range_info (name, r);\n-\t      if (r.undefined_p ())\n-\t\tr.set_varying (type);\n-\t    }\n-\t  else\n-\t    r.set_varying (type);\n-\t}\n-      // If this is a local automatic with no definition, use undefined.\n-      else if (TREE_CODE (sym) != RESULT_DECL)\n-\tr.set_undefined ();\n-      else\n-\tr.set_varying (type);\n-   }\n-  else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n-    {\n-      get_range_info (name, r);\n-      if (r.undefined_p ())\n-\tr.set_varying (type);\n-    }\n-  else if (POINTER_TYPE_P (type) && SSA_NAME_PTR_INFO (name))\n-    {\n-      if (get_ptr_nonnull (name))\n-\tr.set_nonzero (type);\n-      else\n-\tr.set_varying (type);\n-    }\n-  else\n-    r.set_varying (type);\n-}\n-\n-// ?? Like above, but only for default definitions of NAME.  This is\n-// so VRP passes using ranger do not start with known ranges,\n-// otherwise we'd eliminate builtin_unreachables too early because of\n-// inlining.\n-//\n-// Without this restriction, the test in g++.dg/tree-ssa/pr61034.C has\n-// all of its unreachable calls removed too early.  We should\n-// investigate whether we should just adjust the test above.\n-\n-value_range\n-gimple_range_global (tree name)\n-{\n-  gcc_checking_assert (gimple_range_ssa_p (name));\n-  tree type = TREE_TYPE (name);\n-\n-  if (SSA_NAME_IS_DEFAULT_DEF (name))\n-    {\n-      value_range vr;\n-      get_range_global (vr, name);\n-      return vr;\n-    }\n-  return value_range (type);\n-}\n-\n-// ----------------------------------------------\n-// global_range_query implementation.\n-\n-global_range_query global_ranges;\n-\n-// Like get_range_query, but for accessing global ranges.\n-\n-range_query *\n-get_global_range_query ()\n-{\n-  return &global_ranges;\n-}\n-\n-bool\n-global_range_query::range_of_expr (irange &r, tree expr, gimple *)\n-{\n-  tree type = TREE_TYPE (expr);\n-\n-  if (!irange::supports_type_p (type) || !gimple_range_ssa_p (expr))\n-    return get_tree_range (r, expr);\n-\n-  get_range_global (r, expr);\n-\n-  return true;\n-}\n-\n gimple_ranger *\n enable_ranger (struct function *fun)\n {"}, {"sha": "ecd332a3c541c4d7407543194403924e85670c8d", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -252,17 +252,6 @@ class trace_ranger : public gimple_ranger\n // Flag to enable debugging the various internal Caches.\n #define DEBUG_RANGE_CACHE (dump_file && (param_evrp_mode & EVRP_MODE_DEBUG))\n \n-// Global ranges for SSA names using SSA_NAME_RANGE_INFO.\n-\n-class global_range_query : public range_query\n-{\n-public:\n-  bool range_of_expr (irange &r, tree expr, gimple * = NULL) OVERRIDE;\n-};\n-\n-extern global_range_query global_ranges;\n-extern value_range gimple_range_global (tree name);\n-\n extern gimple_ranger *enable_ranger (struct function *);\n extern void disable_ranger (struct function *);\n "}, {"sha": "2165ad71cf3040b11608e0a48fd2105023bb2522", "filename": "gcc/tree-ssanames.c", "status": "modified", "additions": 0, "deletions": 44, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Ftree-ssanames.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Ftree-ssanames.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.c?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -423,31 +423,6 @@ set_range_info (tree name, const value_range &vr)\n   set_range_info (name, vr.kind (), min, max);\n }\n \n-/* Gets range information corresponding to ssa_name NAME and stores it\n-   in a value_range VR.  Returns the value_range_kind.  */\n-\n-enum value_range_kind\n-get_range_info (const_tree name, irange &vr)\n-{\n-  tree type = TREE_TYPE (name);\n-  gcc_checking_assert (!POINTER_TYPE_P (type));\n-  gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n-\n-  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n-\n-  /* Return VR_VARYING for SSA_NAMEs with NULL RANGE_INFO or SSA_NAMEs\n-     with integral types width > 2 * HOST_BITS_PER_WIDE_INT precision.  */\n-  if (!ri || (GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (TREE_TYPE (name)))\n-\t      > 2 * HOST_BITS_PER_WIDE_INT))\n-    vr.set_varying (type);\n-  else\n-    vr.set (wide_int_to_tree (type, ri->get_min ()),\n-\t    wide_int_to_tree (type, ri->get_max ()),\n-\t    SSA_NAME_RANGE_TYPE (name));\n-\n-  return vr.kind ();\n-}\n-\n /* Set nonnull attribute to pointer NAME.  */\n \n void\n@@ -458,25 +433,6 @@ set_ptr_nonnull (tree name)\n   pi->pt.null = 0;\n }\n \n-/* Return nonnull attribute of pointer NAME.  */\n-bool\n-get_ptr_nonnull (const_tree name)\n-{\n-  gcc_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n-  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (name);\n-  if (pi == NULL)\n-    return false;\n-  /* TODO Now pt->null is conservatively set to true in PTA\n-     analysis. vrp is the only pass (including ipa-vrp)\n-     that clears pt.null via set_ptr_nonull when it knows\n-     for sure. PTA will preserves the pt.null value set by VRP.\n-\n-     When PTA analysis is improved, pt.anything, pt.nonlocal\n-     and pt.escaped may also has to be considered before\n-     deciding that pointer cannot point to NULL.  */\n-  return !pi->pt.null;\n-}\n-\n /* Change non-zero bits bitmask of NAME.  */\n \n void"}, {"sha": "ac880f3a67a979e8c6171aef95e6ad21ff35ee60", "filename": "gcc/tree-ssanames.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Ftree-ssanames.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Ftree-ssanames.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssanames.h?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -70,8 +70,6 @@ struct GTY ((variable_size)) range_info_def {\n extern void set_range_info (tree, enum value_range_kind, const wide_int_ref &,\n \t\t\t    const wide_int_ref &);\n extern void set_range_info (tree, const value_range &);\n-/* Gets the value range from SSA.  */\n-extern enum value_range_kind get_range_info (const_tree, irange &);\n extern void set_nonzero_bits (tree, const wide_int_ref &);\n extern wide_int get_nonzero_bits (const_tree);\n extern bool ssa_name_has_boolean_range (tree);\n@@ -90,7 +88,6 @@ extern void set_ptr_info_alignment (struct ptr_info_def *, unsigned int,\n extern void adjust_ptr_info_misalignment (struct ptr_info_def *, poly_uint64);\n extern struct ptr_info_def *get_ptr_info (tree);\n extern void set_ptr_nonnull (tree);\n-extern bool get_ptr_nonnull (const_tree);\n \n extern tree copy_ssa_name_fn (struct function *, tree, gimple *);\n extern void duplicate_ssa_name_ptr_info (tree, struct ptr_info_def *);"}, {"sha": "f8b457d362c79f07128cfee588874c44059e3e5c", "filename": "gcc/value-query.cc", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -31,6 +31,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-range-equiv.h\"\n #include \"value-query.h\"\n #include \"alloc-pool.h\"\n+#include \"gimple-range.h\"\n \n // value_query default methods.\n \n@@ -180,3 +181,149 @@ range_query::~range_query ()\n   equiv_alloc->release ();\n   delete equiv_alloc;\n }\n+\n+// Return the range for NAME from SSA_NAME_RANGE_INFO.\n+\n+static inline void\n+get_ssa_name_range_info (irange &r, const_tree name)\n+{\n+  tree type = TREE_TYPE (name);\n+  gcc_checking_assert (!POINTER_TYPE_P (type));\n+  gcc_checking_assert (TREE_CODE (name) == SSA_NAME);\n+\n+  range_info_def *ri = SSA_NAME_RANGE_INFO (name);\n+\n+  // Return VR_VARYING for SSA_NAMEs with NULL RANGE_INFO or SSA_NAMEs\n+  // with integral types width > 2 * HOST_BITS_PER_WIDE_INT precision.\n+  if (!ri || (GET_MODE_PRECISION (SCALAR_INT_TYPE_MODE (TREE_TYPE (name)))\n+\t      > 2 * HOST_BITS_PER_WIDE_INT))\n+    r.set_varying (type);\n+  else\n+    r.set (wide_int_to_tree (type, ri->get_min ()),\n+\t   wide_int_to_tree (type, ri->get_max ()),\n+\t   SSA_NAME_RANGE_TYPE (name));\n+}\n+\n+// Return nonnull attribute of pointer NAME from SSA_NAME_PTR_INFO.\n+\n+static inline bool\n+get_ssa_name_ptr_info_nonnull (const_tree name)\n+{\n+  gcc_assert (POINTER_TYPE_P (TREE_TYPE (name)));\n+  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (name);\n+  if (pi == NULL)\n+    return false;\n+  /* TODO Now pt->null is conservatively set to true in PTA\n+     analysis. vrp is the only pass (including ipa-vrp)\n+     that clears pt.null via set_ptr_nonull when it knows\n+     for sure. PTA will preserves the pt.null value set by VRP.\n+\n+     When PTA analysis is improved, pt.anything, pt.nonlocal\n+     and pt.escaped may also has to be considered before\n+     deciding that pointer cannot point to NULL.  */\n+  return !pi->pt.null;\n+}\n+\n+// Return the legacy global range for NAME if it has one, otherwise\n+// return VARYING.\n+\n+static void\n+get_range_global (irange &r, tree name)\n+{\n+  tree type = TREE_TYPE (name);\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+    {\n+      tree sym = SSA_NAME_VAR (name);\n+      // Adapted from vr_values::get_lattice_entry().\n+      // Use a range from an SSA_NAME's available range.\n+      if (TREE_CODE (sym) == PARM_DECL)\n+\t{\n+\t  // Try to use the \"nonnull\" attribute to create ~[0, 0]\n+\t  // anti-ranges for pointers.  Note that this is only valid with\n+\t  // default definitions of PARM_DECLs.\n+\t  if (POINTER_TYPE_P (type)\n+\t      && ((cfun && nonnull_arg_p (sym))\n+\t\t  || get_ssa_name_ptr_info_nonnull (name)))\n+\t    r.set_nonzero (type);\n+\t  else if (INTEGRAL_TYPE_P (type))\n+\t    {\n+\t      get_ssa_name_range_info (r, name);\n+\t      if (r.undefined_p ())\n+\t\tr.set_varying (type);\n+\t    }\n+\t  else\n+\t    r.set_varying (type);\n+\t}\n+      // If this is a local automatic with no definition, use undefined.\n+      else if (TREE_CODE (sym) != RESULT_DECL)\n+\tr.set_undefined ();\n+      else\n+\tr.set_varying (type);\n+   }\n+  else if (!POINTER_TYPE_P (type) && SSA_NAME_RANGE_INFO (name))\n+    {\n+      get_ssa_name_range_info (r, name);\n+      if (r.undefined_p ())\n+\tr.set_varying (type);\n+    }\n+  else if (POINTER_TYPE_P (type) && SSA_NAME_PTR_INFO (name))\n+    {\n+      if (get_ssa_name_ptr_info_nonnull (name))\n+\tr.set_nonzero (type);\n+      else\n+\tr.set_varying (type);\n+    }\n+  else\n+    r.set_varying (type);\n+}\n+\n+// ?? Like above, but only for default definitions of NAME.  This is\n+// so VRP passes using ranger do not start with known ranges,\n+// otherwise we'd eliminate builtin_unreachables too early because of\n+// inlining.\n+//\n+// Without this restriction, the test in g++.dg/tree-ssa/pr61034.C has\n+// all of its unreachable calls removed too early.  We should\n+// investigate whether we should just adjust the test above.\n+\n+value_range\n+gimple_range_global (tree name)\n+{\n+  gcc_checking_assert (gimple_range_ssa_p (name));\n+  tree type = TREE_TYPE (name);\n+\n+  if (SSA_NAME_IS_DEFAULT_DEF (name))\n+    {\n+      value_range vr;\n+      get_range_global (vr, name);\n+      return vr;\n+    }\n+  return value_range (type);\n+}\n+\n+// ----------------------------------------------\n+// global_range_query implementation.\n+\n+global_range_query global_ranges;\n+\n+// Like get_range_query, but for accessing global ranges.\n+\n+range_query *\n+get_global_range_query ()\n+{\n+  return &global_ranges;\n+}\n+\n+bool\n+global_range_query::range_of_expr (irange &r, tree expr, gimple *)\n+{\n+  tree type = TREE_TYPE (expr);\n+\n+  if (!irange::supports_type_p (type) || !gimple_range_ssa_p (expr))\n+    return get_tree_range (r, expr);\n+\n+  get_range_global (r, expr);\n+\n+  return true;\n+}"}, {"sha": "97da663774746b8cb5523d41b45961fc89ed6cf8", "filename": "gcc/value-query.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fvalue-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/13dbaefefbab04d5137e718262d4b81cb9035784/gcc%2Fvalue-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.h?ref=13dbaefefbab04d5137e718262d4b81cb9035784", "patch": "@@ -105,4 +105,15 @@ class range_query : public value_query\n   class equiv_allocator *equiv_alloc;\n };\n \n+// Global ranges for SSA names using SSA_NAME_RANGE_INFO.\n+\n+class global_range_query : public range_query\n+{\n+public:\n+  bool range_of_expr (irange &r, tree expr, gimple * = NULL) OVERRIDE;\n+};\n+\n+extern global_range_query global_ranges;\n+extern value_range gimple_range_global (tree name);\n+\n #endif // GCC_QUERY_H"}]}