{"sha": "3e20cb680fae4486f196dcc807237d573ad6d207", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2UyMGNiNjgwZmFlNDQ4NmYxOTZkY2M4MDcyMzdkNTczYWQ2ZDIwNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:44:09Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-18T10:44:09Z"}, "message": "[multiple changes]\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_prag.adb (Build_Pragma_Check_Equivalent): The mapping\n\tthat relates operations of the parent type to the operations of\n\tthe derived type has three distinct sources:\n\ta) explicit operations of the derived type carry an\n\tOverridden_Operation that designates the operation in the\n\tancestor.\n\tb) Implicit operations that are inherited by the derived type\n\tcarry an alias that may be an explicit subprogram (in which case\n\tit may have an Overridden_ Operation indicator) or may also be\n\tinherited and carry its own alias.\n\tc) If the parent type is an interface, the operation of the\n\tderived type does not override, but the interface operation\n\tindicates the operation that implements it.\n\t* sem_prag.adb: Minor reformatting.\n\t* sem_prag.adb (Check_External_Property): Update\n\tthe comment on usage. Reimplement.\n\n2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch5.adb (Expand_Assignment_Statement): In restricted\n\tprofiles such as ZFP, ceiling priority is not available.\n\n2016-04-18  Bob Duff  <duff@adacore.com>\n\n\t* namet-sp.ads: Minor typo fix, ironically in 'Spelling_Checker'.\n\n2016-04-18  Bob Duff  <duff@adacore.com>\n\n\t* sem_elab.adb (Output_Calls): Use\n\tGet_Name_String, to clearly indicate that the global Name_Buffer\n\tis being used. The previous code used Is_Internal_Name, which\n\treturns a Boolean, but also has a side effect of setting the\n\tName_Buffer. Then it called the other Is_Internal_Name, which uses\n\tthe Name_Buffer for its input. And then it called Error_Msg_N,\n\tagain using the Name_Buffer. We haven't eliminated the global\n\tusage here, but we've made it a bit clearer.\n\tThis also allows us to have a side-effect-free version of\n\tIs_Internal_Name.\n\t* namet.ads, namet.adb: Provide a type Bounded_String, along with\n\troutines that can be used without using global variables. Provide\n\tGlobal_Name_Buffer so existing code can continue to use the\n\tglobal. Mark the routines that use globals as obsolete.  New code\n\tshouldn't call the obsolete ones, and we should clean up existing\n\tcode from time to time.\n\tName_Find_Str is renamed as Name_Find.\n\t* namet.h: Changed as necessary to interface to the new version\n\tof Namet.\n\t* bindgen.adb, exp_unst.adb: Name_Find_Str is renamed as\n\tName_Find.\n\nFrom-SVN: r235123", "tree": {"sha": "dfe52b487e1b48a7b4d25170ac1661d0d4d33e22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dfe52b487e1b48a7b4d25170ac1661d0d4d33e22"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3e20cb680fae4486f196dcc807237d573ad6d207", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e20cb680fae4486f196dcc807237d573ad6d207", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e20cb680fae4486f196dcc807237d573ad6d207", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e20cb680fae4486f196dcc807237d573ad6d207/comments", "author": null, "committer": null, "parents": [{"sha": "1f55088db5038881cc4836ba600edb1bb8fe0141", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f55088db5038881cc4836ba600edb1bb8fe0141", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f55088db5038881cc4836ba600edb1bb8fe0141"}], "stats": {"total": 1724, "additions": 960, "deletions": 764}, "files": [{"sha": "96cac54c0382bcbddfcf78e8548ecaf3aa71ceac", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -1,3 +1,55 @@\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_prag.adb (Build_Pragma_Check_Equivalent): The mapping\n+\tthat relates operations of the parent type to the operations of\n+\tthe derived type has three distinct sources:\n+\ta) explicit operations of the derived type carry an\n+\tOverridden_Operation that designates the operation in the\n+\tancestor.\n+\tb) Implicit operations that are inherited by the derived type\n+\tcarry an alias that may be an explicit subprogram (in which case\n+\tit may have an Overridden_ Operation indicator) or may also be\n+\tinherited and carry its own alias.\n+\tc) If the parent type is an interface, the operation of the\n+\tderived type does not override, but the interface operation\n+\tindicates the operation that implements it.\n+\t* sem_prag.adb: Minor reformatting.\n+\t* sem_prag.adb (Check_External_Property): Update\n+\tthe comment on usage. Reimplement.\n+\n+2016-04-18  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch5.adb (Expand_Assignment_Statement): In restricted\n+\tprofiles such as ZFP, ceiling priority is not available.\n+\n+2016-04-18  Bob Duff  <duff@adacore.com>\n+\n+\t* namet-sp.ads: Minor typo fix, ironically in 'Spelling_Checker'.\n+\n+2016-04-18  Bob Duff  <duff@adacore.com>\n+\n+\t* sem_elab.adb (Output_Calls): Use\n+\tGet_Name_String, to clearly indicate that the global Name_Buffer\n+\tis being used. The previous code used Is_Internal_Name, which\n+\treturns a Boolean, but also has a side effect of setting the\n+\tName_Buffer. Then it called the other Is_Internal_Name, which uses\n+\tthe Name_Buffer for its input. And then it called Error_Msg_N,\n+\tagain using the Name_Buffer. We haven't eliminated the global\n+\tusage here, but we've made it a bit clearer.\n+\tThis also allows us to have a side-effect-free version of\n+\tIs_Internal_Name.\n+\t* namet.ads, namet.adb: Provide a type Bounded_String, along with\n+\troutines that can be used without using global variables. Provide\n+\tGlobal_Name_Buffer so existing code can continue to use the\n+\tglobal. Mark the routines that use globals as obsolete.  New code\n+\tshouldn't call the obsolete ones, and we should clean up existing\n+\tcode from time to time.\n+\tName_Find_Str is renamed as Name_Find.\n+\t* namet.h: Changed as necessary to interface to the new version\n+\tof Namet.\n+\t* bindgen.adb, exp_unst.adb: Name_Find_Str is renamed as\n+\tName_Find.\n+\n 2016-04-18  Yannick Moy  <moy@adacore.com>\n \n \t* sem_util.adb, sem_util.ads (Has_Full_Default_Initialization): used"}, {"sha": "5388fbb287ddd85efbf5cae4fd946cb243f60387", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -2922,7 +2922,7 @@ package body Bindgen is\n          Osint.Fail (\"bind environment value \"\"\" & Value & \"\"\" too long\");\n       end if;\n \n-      Bind_Environment.Set (Name_Find_Str (Key), Name_Find_Str (Value));\n+      Bind_Environment.Set (Name_Find (Key), Name_Find (Value));\n    end Set_Bind_Env;\n \n    -----------------"}, {"sha": "25a9fe0df245f8582d35e2dbe6003059b77db419", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -1693,9 +1693,10 @@ package body Exp_Ch5 is\n \n             --  The attribute Priority applied to protected objects has been\n             --  previously expanded into a call to the Get_Ceiling run-time\n-            --  subprogram.\n+            --  subprogram. In restricted profiles this is not available.\n \n             if Nkind (Ent) = N_Function_Call\n+              and then RTE_Available (RE_Get_Ceiling)\n               and then (Entity (Name (Ent)) = RTE (RE_Get_Ceiling)\n                           or else\n                         Entity (Name (Ent)) = RTE (RO_PE_Get_Ceiling))"}, {"sha": "fbc6a7b535e3c71a7a44538e67b34a59a9708f4c", "filename": "gcc/ada/exp_unst.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fexp_unst.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fexp_unst.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_unst.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -161,7 +161,7 @@ package body Exp_Unst is\n \n       function AREC_Name (J : Pos; S : String) return Name_Id is\n       begin\n-         return Name_Find_Str (\"AREC\" & Img_Pos (J) & S);\n+         return Name_Find (\"AREC\" & Img_Pos (J) & S);\n       end AREC_Name;\n \n       --------------------\n@@ -244,7 +244,7 @@ package body Exp_Unst is\n             if No (C) then\n                return Chars (Ent);\n             elsif Chars (Defining_Identifier (C)) = Chars (Ent) then\n-               return Name_Find_Str\n+               return Name_Find\n                         (Get_Name_String (Chars (Ent)) & Img_Pos (Index));\n             else\n                Next (C);"}, {"sha": "1f42029f01ad27474d9e74035ce1177bae9cc18d", "filename": "gcc/ada/namet-sp.ads", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet-sp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet-sp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet-sp.ads?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012 Free Software Foundation, Inc.          --\n+--          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -31,7 +31,7 @@\n \n --  This child package contains a spell checker for Name_Id values. It is\n --  separated off as a child package, because of the extra dependencies,\n---  in particular on GNAT.UTF_32_ Spelling_Checker. There are a number of\n+--  in particular on GNAT.UTF_32_Spelling_Checker. There are a number of\n --  packages that use Namet that do not need the spell checking feature,\n --  and this separation helps in dealing with older versions of GNAT.\n "}, {"sha": "20359f607f4b1c964eb94bc90491365882d5d4bb", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 560, "deletions": 518, "changes": 1078, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -73,27 +73,22 @@ package body Namet is\n    -- Local Subprograms --\n    -----------------------\n \n-   function Hash return Hash_Index_Type;\n+   function Hash (Buf : Bounded_String) return Hash_Index_Type;\n    pragma Inline (Hash);\n-   --  Compute hash code for name stored in Name_Buffer (length in Name_Len)\n+   --  Compute hash code for name stored in Buf\n \n-   procedure Strip_Qualification_And_Suffixes;\n-   --  Given an encoded entity name in Name_Buffer, remove package body\n+   procedure Strip_Qualification_And_Suffixes (Buf : in out Bounded_String);\n+   --  Given an encoded entity name in Buf, remove package body\n    --  suffix as described for Strip_Package_Body_Suffix, and also remove\n-   --  all qualification, i.e. names followed by two underscores. The\n-   --  contents of Name_Buffer is modified by this call, and on return\n-   --  Name_Buffer and Name_Len reflect the stripped name.\n+   --  all qualification, i.e. names followed by two underscores.\n \n    -----------------------------\n    -- Add_Char_To_Name_Buffer --\n    -----------------------------\n \n    procedure Add_Char_To_Name_Buffer (C : Character) is\n    begin\n-      if Name_Len < Name_Buffer'Last then\n-         Name_Len := Name_Len + 1;\n-         Name_Buffer (Name_Len) := C;\n-      end if;\n+      Append (Global_Name_Buffer, C);\n    end Add_Char_To_Name_Buffer;\n \n    ----------------------------\n@@ -102,11 +97,7 @@ package body Namet is\n \n    procedure Add_Nat_To_Name_Buffer (V : Nat) is\n    begin\n-      if V >= 10 then\n-         Add_Nat_To_Name_Buffer (V / 10);\n-      end if;\n-\n-      Add_Char_To_Name_Buffer (Character'Val (Character'Pos ('0') + V rem 10));\n+      Append (Global_Name_Buffer, V);\n    end Add_Nat_To_Name_Buffer;\n \n    ----------------------------\n@@ -115,171 +106,56 @@ package body Namet is\n \n    procedure Add_Str_To_Name_Buffer (S : String) is\n    begin\n-      for J in S'Range loop\n-         Add_Char_To_Name_Buffer (S (J));\n-      end loop;\n+      Append (Global_Name_Buffer, S);\n    end Add_Str_To_Name_Buffer;\n \n-   --------------\n-   -- Finalize --\n-   --------------\n-\n-   procedure Finalize is\n-      F : array (Int range 0 .. 50) of Int;\n-      --  N'th entry is the number of chains of length N, except last entry,\n-      --  which is the number of chains of length F'Last or more.\n-\n-      Max_Chain_Length : Int := 0;\n-      --  Maximum length of all chains\n-\n-      Probes : Int := 0;\n-      --  Used to compute average number of probes\n-\n-      Nsyms : Int := 0;\n-      --  Number of symbols in table\n-\n-      Verbosity : constant Int range 1 .. 3 := 1;\n-      pragma Warnings (Off, Verbosity);\n-      --  This constant indicates the level of verbosity in the output from\n-      --  this procedure. Currently this can only be changed by editing the\n-      --  declaration above and recompiling. That's good enough in practice,\n-      --  since we very rarely need to use this debug option. Settings are:\n-      --\n-      --    1 => print basic summary information\n-      --    2 => in addition print number of entries per hash chain\n-      --    3 => in addition print content of entries\n-\n-      Zero : constant Int := Character'Pos ('0');\n+   ------------\n+   -- Append --\n+   ------------\n \n+   procedure Append (Buf : in out Bounded_String; C : Character) is\n    begin\n-      if not Debug_Flag_H then\n-         return;\n+      if Buf.Length < Buf.Chars'Last then\n+         Buf.Length := Buf.Length + 1;\n+         Buf.Chars (Buf.Length) := C;\n       end if;\n+   end Append;\n \n-      for J in F'Range loop\n-         F (J) := 0;\n-      end loop;\n-\n-      for J in Hash_Index_Type loop\n-         if Hash_Table (J) = No_Name then\n-            F (0) := F (0) + 1;\n-\n-         else\n-            declare\n-               C : Int;\n-               N : Name_Id;\n-               S : Int;\n-\n-            begin\n-               C := 0;\n-               N := Hash_Table (J);\n-\n-               while N /= No_Name loop\n-                  N := Name_Entries.Table (N).Hash_Link;\n-                  C := C + 1;\n-               end loop;\n-\n-               Nsyms := Nsyms + 1;\n-               Probes := Probes + (1 + C) * 100;\n-\n-               if C > Max_Chain_Length then\n-                  Max_Chain_Length := C;\n-               end if;\n-\n-               if Verbosity >= 2 then\n-                  Write_Str (\"Hash_Table (\");\n-                  Write_Int (J);\n-                  Write_Str (\") has \");\n-                  Write_Int (C);\n-                  Write_Str (\" entries\");\n-                  Write_Eol;\n-               end if;\n-\n-               if C < F'Last then\n-                  F (C) := F (C) + 1;\n-               else\n-                  F (F'Last) := F (F'Last) + 1;\n-               end if;\n-\n-               if Verbosity >= 3 then\n-                  N := Hash_Table (J);\n-                  while N /= No_Name loop\n-                     S := Name_Entries.Table (N).Name_Chars_Index;\n-\n-                     Write_Str (\"      \");\n-\n-                     for J in 1 .. Name_Entries.Table (N).Name_Len loop\n-                        Write_Char (Name_Chars.Table (S + Int (J)));\n-                     end loop;\n+   procedure Append (Buf : in out Bounded_String; V : Nat) is\n+   begin\n+      if V >= 10 then\n+         Append (Buf, V / 10);\n+      end if;\n \n-                     Write_Eol;\n+      Append (Buf, Character'Val (Character'Pos ('0') + V rem 10));\n+   end Append;\n \n-                     N := Name_Entries.Table (N).Hash_Link;\n-                  end loop;\n-               end if;\n-            end;\n-         end if;\n+   procedure Append (Buf : in out Bounded_String; S : String) is\n+   begin\n+      for J in S'Range loop\n+         Append (Buf, S (J));\n       end loop;\n+   end Append;\n \n-      Write_Eol;\n-\n-      for J in F'Range loop\n-         if F (J) /= 0 then\n-            Write_Str (\"Number of hash chains of length \");\n-\n-            if J < 10 then\n-               Write_Char (' ');\n-            end if;\n-\n-            Write_Int (J);\n-\n-            if J = F'Last then\n-               Write_Str (\" or greater\");\n-            end if;\n-\n-            Write_Str (\" = \");\n-            Write_Int (F (J));\n-            Write_Eol;\n-         end if;\n+   procedure Append (Buf : in out Bounded_String; Id : Name_Id) is\n+      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n+      S : constant Int := Name_Entries.Table (Id).Name_Chars_Index;\n+   begin\n+      for J in 1 .. Natural (Name_Entries.Table (Id).Name_Len) loop\n+         Append (Buf, Name_Chars.Table (S + Int (J)));\n       end loop;\n+   end Append;\n \n-      --  Print out average number of probes, in the case where Name_Find is\n-      --  called for a string that is already in the table.\n-\n-      Write_Eol;\n-      Write_Str (\"Average number of probes for lookup = \");\n-      Probes := Probes / Nsyms;\n-      Write_Int (Probes / 200);\n-      Write_Char ('.');\n-      Probes := (Probes mod 200) / 2;\n-      Write_Char (Character'Val (Zero + Probes / 10));\n-      Write_Char (Character'Val (Zero + Probes mod 10));\n-      Write_Eol;\n-\n-      Write_Str (\"Max_Chain_Length = \");\n-      Write_Int (Max_Chain_Length);\n-      Write_Eol;\n-      Write_Str (\"Name_Chars'Length = \");\n-      Write_Int (Name_Chars.Last - Name_Chars.First + 1);\n-      Write_Eol;\n-      Write_Str (\"Name_Entries'Length = \");\n-      Write_Int (Int (Name_Entries.Last - Name_Entries.First + 1));\n-      Write_Eol;\n-      Write_Str (\"Nsyms = \");\n-      Write_Int (Nsyms);\n-      Write_Eol;\n-   end Finalize;\n-\n-   -----------------------------\n-   -- Get_Decoded_Name_String --\n-   -----------------------------\n+   --------------------\n+   -- Append_Decoded --\n+   --------------------\n \n-   procedure Get_Decoded_Name_String (Id : Name_Id) is\n+   procedure Append_Decoded (Buf : in out Bounded_String; Id : Name_Id) is\n       C : Character;\n       P : Natural;\n \n    begin\n-      Get_Name_String (Id);\n+      Append (Buf, Id);\n \n       --  Skip scan if we already know there are no encodings\n \n@@ -291,12 +167,12 @@ package body Namet is\n \n       P := 1;\n       loop\n-         if P = Name_Len then\n+         if P = Buf.Length then\n             Name_Entries.Table (Id).Name_Has_No_Encodings := True;\n             return;\n \n          else\n-            C := Name_Buffer (P);\n+            C := Buf.Chars (P);\n \n             exit when\n               C = 'U' or else\n@@ -313,10 +189,10 @@ package body Namet is\n       Decode : declare\n          New_Len : Natural;\n          Old     : Positive;\n-         New_Buf : String (1 .. Name_Buffer'Last);\n+         New_Buf : String (1 .. Buf.Chars'Last);\n \n          procedure Copy_One_Character;\n-         --  Copy a character from Name_Buffer to New_Buf. Includes case\n+         --  Copy a character from Buf.Chars to New_Buf. Includes case\n          --  of copying a Uhh,Whhhh,WWhhhhhhhh sequence and decoding it.\n \n          function Hex (N : Natural) return Word;\n@@ -333,14 +209,14 @@ package body Namet is\n             C : Character;\n \n          begin\n-            C := Name_Buffer (Old);\n+            C := Buf.Chars (Old);\n \n             --  U (upper half insertion case)\n \n             if C = 'U'\n-              and then Old < Name_Len\n-              and then Name_Buffer (Old + 1) not in 'A' .. 'Z'\n-              and then Name_Buffer (Old + 1) /= '_'\n+              and then Old < Buf.Length\n+              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Buf.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n \n@@ -360,18 +236,18 @@ package body Namet is\n             --  WW (wide wide character insertion)\n \n             elsif C = 'W'\n-              and then Old < Name_Len\n-              and then Name_Buffer (Old + 1) = 'W'\n+              and then Old < Buf.Length\n+              and then Buf.Chars (Old + 1) = 'W'\n             then\n                Old := Old + 2;\n                Widechar.Set_Wide (Char_Code (Hex (8)), New_Buf, New_Len);\n \n             --  W (wide character insertion)\n \n             elsif C = 'W'\n-              and then Old < Name_Len\n-              and then Name_Buffer (Old + 1) not in 'A' .. 'Z'\n-              and then Name_Buffer (Old + 1) /= '_'\n+              and then Old < Buf.Length\n+              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Buf.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n                Widechar.Set_Wide (Char_Code (Hex (4)), New_Buf, New_Len);\n@@ -394,7 +270,7 @@ package body Namet is\n \n          begin\n             for J in 1 .. N loop\n-               C := Name_Buffer (Old);\n+               C := Buf.Chars (Old);\n                Old := Old + 1;\n \n                pragma Assert (C in '0' .. '9' or else C in 'a' .. 'f');\n@@ -427,12 +303,12 @@ package body Namet is\n \n          --  Loop through characters of name\n \n-         while Old <= Name_Len loop\n+         while Old <= Buf.Length loop\n \n             --  Case of character literal, put apostrophes around character\n \n-            if Name_Buffer (Old) = 'Q'\n-              and then Old < Name_Len\n+            if Buf.Chars (Old) = 'Q'\n+              and then Old < Buf.Length\n             then\n                Old := Old + 1;\n                Insert_Character (''');\n@@ -441,10 +317,10 @@ package body Namet is\n \n             --  Case of operator name\n \n-            elsif Name_Buffer (Old) = 'O'\n-              and then Old < Name_Len\n-              and then Name_Buffer (Old + 1) not in 'A' .. 'Z'\n-              and then Name_Buffer (Old + 1) /= '_'\n+            elsif Buf.Chars (Old) = 'O'\n+              and then Old < Buf.Length\n+              and then Buf.Chars (Old + 1) not in 'A' .. 'Z'\n+              and then Buf.Chars (Old + 1) /= '_'\n             then\n                Old := Old + 1;\n \n@@ -483,145 +359,393 @@ package body Namet is\n                   --  not we have some kind of internal error, and a constraint\n                   --  error may be raised.\n \n-                  J := Map'First;\n-                  loop\n-                     exit when Name_Buffer (Old) = Map (J)\n-                       and then Name_Buffer (Old + 1) = Map (J + 1);\n-                     J := J + 4;\n-                  end loop;\n+                  J := Map'First;\n+                  loop\n+                     exit when Buf.Chars (Old) = Map (J)\n+                       and then Buf.Chars (Old + 1) = Map (J + 1);\n+                     J := J + 4;\n+                  end loop;\n+\n+                  --  Special operator name\n+\n+                  if Map (J + 2) /= ' ' then\n+                     Insert_Character (Map (J + 2));\n+\n+                     if Map (J + 3) /= ' ' then\n+                        Insert_Character (Map (J + 3));\n+                     end if;\n+\n+                     Insert_Character ('\"');\n+\n+                     --  Skip past original operator name in input\n+\n+                     while Old <= Buf.Length\n+                       and then Buf.Chars (Old) in 'a' .. 'z'\n+                     loop\n+                        Old := Old + 1;\n+                     end loop;\n+\n+                  --  For other operator names, leave them in lower case,\n+                  --  surrounded by apostrophes\n+\n+                  else\n+                     --  Copy original operator name from input to output\n+\n+                     while Old <= Buf.Length\n+                        and then Buf.Chars (Old) in 'a' .. 'z'\n+                     loop\n+                        Copy_One_Character;\n+                     end loop;\n+\n+                     Insert_Character ('\"');\n+                  end if;\n+               end;\n+\n+            --  Else copy one character and keep going\n+\n+            else\n+               Copy_One_Character;\n+            end if;\n+         end loop;\n+\n+         --  Copy new buffer as result\n+\n+         Buf.Length := New_Len;\n+         Buf.Chars (1 .. New_Len) := New_Buf (1 .. New_Len);\n+      end Decode;\n+   end Append_Decoded;\n+\n+   ----------------------------------\n+   -- Append_Decoded_With_Brackets --\n+   ----------------------------------\n+\n+   procedure Append_Decoded_With_Brackets\n+     (Buf : in out Bounded_String; Id : Name_Id) is\n+      P : Natural;\n+\n+   begin\n+      --  Case of operator name, normal decoding is fine\n+\n+      if Buf.Chars (1) = 'O' then\n+         Append_Decoded (Buf, Id);\n+\n+      --  For character literals, normal decoding is fine\n+\n+      elsif Buf.Chars (1) = 'Q' then\n+         Append_Decoded (Buf, Id);\n+\n+      --  Only remaining issue is U/W/WW sequences\n+\n+      else\n+         Append (Buf, Id);\n+\n+         P := 1;\n+         while P < Buf.Length loop\n+            if Buf.Chars (P + 1) in 'A' .. 'Z' then\n+               P := P + 1;\n+\n+            --  Uhh encoding\n+\n+            elsif Buf.Chars (P) = 'U' then\n+               for J in reverse P + 3 .. P + Buf.Length loop\n+                  Buf.Chars (J + 3) := Buf.Chars (J);\n+               end loop;\n+\n+               Buf.Length := Buf.Length + 3;\n+               Buf.Chars (P + 3) := Buf.Chars (P + 2);\n+               Buf.Chars (P + 2) := Buf.Chars (P + 1);\n+               Buf.Chars (P)     := '[';\n+               Buf.Chars (P + 1) := '\"';\n+               Buf.Chars (P + 4) := '\"';\n+               Buf.Chars (P + 5) := ']';\n+               P := P + 6;\n+\n+            --  WWhhhhhhhh encoding\n+\n+            elsif Buf.Chars (P) = 'W'\n+              and then P + 9 <= Buf.Length\n+              and then Buf.Chars (P + 1) = 'W'\n+              and then Buf.Chars (P + 2) not in 'A' .. 'Z'\n+              and then Buf.Chars (P + 2) /= '_'\n+            then\n+               Buf.Chars (P + 12 .. Buf.Length + 2) :=\n+                 Buf.Chars (P + 10 .. Buf.Length);\n+               Buf.Chars (P)     := '[';\n+               Buf.Chars (P + 1) := '\"';\n+               Buf.Chars (P + 10) := '\"';\n+               Buf.Chars (P + 11) := ']';\n+               Buf.Length := Buf.Length + 2;\n+               P := P + 12;\n+\n+            --  Whhhh encoding\n+\n+            elsif Buf.Chars (P) = 'W'\n+              and then P < Buf.Length\n+              and then Buf.Chars (P + 1) not in 'A' .. 'Z'\n+              and then Buf.Chars (P + 1) /= '_'\n+            then\n+               Buf.Chars (P + 8 .. P + Buf.Length + 3) :=\n+                 Buf.Chars (P + 5 .. Buf.Length);\n+               Buf.Chars (P + 2 .. P + 5) := Buf.Chars (P + 1 .. P + 4);\n+               Buf.Chars (P)     := '[';\n+               Buf.Chars (P + 1) := '\"';\n+               Buf.Chars (P + 6) := '\"';\n+               Buf.Chars (P + 7) := ']';\n+               Buf.Length := Buf.Length + 3;\n+               P := P + 8;\n+\n+            else\n+               P := P + 1;\n+            end if;\n+         end loop;\n+      end if;\n+   end Append_Decoded_With_Brackets;\n+\n+   --------------------\n+   -- Append_Encoded --\n+   --------------------\n+\n+   procedure Append_Encoded (Buf : in out Bounded_String; C : Char_Code) is\n+      procedure Set_Hex_Chars (C : Char_Code);\n+      --  Stores given value, which is in the range 0 .. 255, as two hex\n+      --  digits (using lower case a-f) in Buf.Chars, incrementing Buf.Length.\n+\n+      -------------------\n+      -- Set_Hex_Chars --\n+      -------------------\n+\n+      procedure Set_Hex_Chars (C : Char_Code) is\n+         Hexd : constant String := \"0123456789abcdef\";\n+         N    : constant Natural := Natural (C);\n+      begin\n+         Buf.Chars (Buf.Length + 1) := Hexd (N / 16 + 1);\n+         Buf.Chars (Buf.Length + 2) := Hexd (N mod 16 + 1);\n+         Buf.Length := Buf.Length + 2;\n+      end Set_Hex_Chars;\n+\n+   --  Start of processing for Append_Encoded\n+\n+   begin\n+      Buf.Length := Buf.Length + 1;\n+\n+      if In_Character_Range (C) then\n+         declare\n+            CC : constant Character := Get_Character (C);\n+         begin\n+            if CC in 'a' .. 'z' or else CC in '0' .. '9' then\n+               Buf.Chars (Buf.Length) := CC;\n+            else\n+               Buf.Chars (Buf.Length) := 'U';\n+               Set_Hex_Chars (C);\n+            end if;\n+         end;\n+\n+      elsif In_Wide_Character_Range (C) then\n+         Buf.Chars (Buf.Length) := 'W';\n+         Set_Hex_Chars (C / 256);\n+         Set_Hex_Chars (C mod 256);\n+\n+      else\n+         Buf.Chars (Buf.Length) := 'W';\n+         Buf.Length := Buf.Length + 1;\n+         Buf.Chars (Buf.Length) := 'W';\n+         Set_Hex_Chars (C / 2 ** 24);\n+         Set_Hex_Chars ((C / 2 ** 16) mod 256);\n+         Set_Hex_Chars ((C / 256) mod 256);\n+         Set_Hex_Chars (C mod 256);\n+      end if;\n+   end Append_Encoded;\n+\n+   ------------------------\n+   -- Append_Unqualified --\n+   ------------------------\n+\n+   procedure Append_Unqualified\n+     (Buf : in out Bounded_String; Id : Name_Id) is\n+   begin\n+      Append (Buf, Id);\n+      Strip_Qualification_And_Suffixes (Buf);\n+   end Append_Unqualified;\n+\n+   --------------------------------\n+   -- Append_Unqualified_Decoded --\n+   --------------------------------\n+\n+   procedure Append_Unqualified_Decoded\n+     (Buf : in out Bounded_String; Id : Name_Id) is\n+   begin\n+      Append_Decoded (Buf, Id);\n+      Strip_Qualification_And_Suffixes (Buf);\n+   end Append_Unqualified_Decoded;\n+\n+   --------------\n+   -- Finalize --\n+   --------------\n+\n+   procedure Finalize is\n+      F : array (Int range 0 .. 50) of Int;\n+      --  N'th entry is the number of chains of length N, except last entry,\n+      --  which is the number of chains of length F'Last or more.\n+\n+      Max_Chain_Length : Int := 0;\n+      --  Maximum length of all chains\n+\n+      Probes : Int := 0;\n+      --  Used to compute average number of probes\n+\n+      Nsyms : Int := 0;\n+      --  Number of symbols in table\n+\n+      Verbosity : constant Int range 1 .. 3 := 1;\n+      pragma Warnings (Off, Verbosity);\n+      --  This constant indicates the level of verbosity in the output from\n+      --  this procedure. Currently this can only be changed by editing the\n+      --  declaration above and recompiling. That's good enough in practice,\n+      --  since we very rarely need to use this debug option. Settings are:\n+      --\n+      --    1 => print basic summary information\n+      --    2 => in addition print number of entries per hash chain\n+      --    3 => in addition print content of entries\n+\n+      Zero : constant Int := Character'Pos ('0');\n+\n+   begin\n+      if not Debug_Flag_H then\n+         return;\n+      end if;\n+\n+      for J in F'Range loop\n+         F (J) := 0;\n+      end loop;\n+\n+      for J in Hash_Index_Type loop\n+         if Hash_Table (J) = No_Name then\n+            F (0) := F (0) + 1;\n+\n+         else\n+            declare\n+               C : Int;\n+               N : Name_Id;\n+               S : Int;\n+\n+            begin\n+               C := 0;\n+               N := Hash_Table (J);\n+\n+               while N /= No_Name loop\n+                  N := Name_Entries.Table (N).Hash_Link;\n+                  C := C + 1;\n+               end loop;\n+\n+               Nsyms := Nsyms + 1;\n+               Probes := Probes + (1 + C) * 100;\n+\n+               if C > Max_Chain_Length then\n+                  Max_Chain_Length := C;\n+               end if;\n+\n+               if Verbosity >= 2 then\n+                  Write_Str (\"Hash_Table (\");\n+                  Write_Int (J);\n+                  Write_Str (\") has \");\n+                  Write_Int (C);\n+                  Write_Str (\" entries\");\n+                  Write_Eol;\n+               end if;\n+\n+               if C < F'Last then\n+                  F (C) := F (C) + 1;\n+               else\n+                  F (F'Last) := F (F'Last) + 1;\n+               end if;\n+\n+               if Verbosity >= 3 then\n+                  N := Hash_Table (J);\n+                  while N /= No_Name loop\n+                     S := Name_Entries.Table (N).Name_Chars_Index;\n+\n+                     Write_Str (\"      \");\n \n-                  --  Special operator name\n+                     for J in 1 .. Name_Entries.Table (N).Name_Len loop\n+                        Write_Char (Name_Chars.Table (S + Int (J)));\n+                     end loop;\n \n-                  if Map (J + 2) /= ' ' then\n-                     Insert_Character (Map (J + 2));\n+                     Write_Eol;\n \n-                     if Map (J + 3) /= ' ' then\n-                        Insert_Character (Map (J + 3));\n-                     end if;\n+                     N := Name_Entries.Table (N).Hash_Link;\n+                  end loop;\n+               end if;\n+            end;\n+         end if;\n+      end loop;\n \n-                     Insert_Character ('\"');\n+      Write_Eol;\n \n-                     --  Skip past original operator name in input\n+      for J in F'Range loop\n+         if F (J) /= 0 then\n+            Write_Str (\"Number of hash chains of length \");\n \n-                     while Old <= Name_Len\n-                       and then Name_Buffer (Old) in 'a' .. 'z'\n-                     loop\n-                        Old := Old + 1;\n-                     end loop;\n+            if J < 10 then\n+               Write_Char (' ');\n+            end if;\n \n-                  --  For other operator names, leave them in lower case,\n-                  --  surrounded by apostrophes\n+            Write_Int (J);\n \n-                  else\n-                     --  Copy original operator name from input to output\n+            if J = F'Last then\n+               Write_Str (\" or greater\");\n+            end if;\n \n-                     while Old <= Name_Len\n-                        and then Name_Buffer (Old) in 'a' .. 'z'\n-                     loop\n-                        Copy_One_Character;\n-                     end loop;\n+            Write_Str (\" = \");\n+            Write_Int (F (J));\n+            Write_Eol;\n+         end if;\n+      end loop;\n \n-                     Insert_Character ('\"');\n-                  end if;\n-               end;\n+      --  Print out average number of probes, in the case where Name_Find is\n+      --  called for a string that is already in the table.\n \n-            --  Else copy one character and keep going\n+      Write_Eol;\n+      Write_Str (\"Average number of probes for lookup = \");\n+      Probes := Probes / Nsyms;\n+      Write_Int (Probes / 200);\n+      Write_Char ('.');\n+      Probes := (Probes mod 200) / 2;\n+      Write_Char (Character'Val (Zero + Probes / 10));\n+      Write_Char (Character'Val (Zero + Probes mod 10));\n+      Write_Eol;\n \n-            else\n-               Copy_One_Character;\n-            end if;\n-         end loop;\n+      Write_Str (\"Max_Chain_Length = \");\n+      Write_Int (Max_Chain_Length);\n+      Write_Eol;\n+      Write_Str (\"Name_Chars'Length = \");\n+      Write_Int (Name_Chars.Last - Name_Chars.First + 1);\n+      Write_Eol;\n+      Write_Str (\"Name_Entries'Length = \");\n+      Write_Int (Int (Name_Entries.Last - Name_Entries.First + 1));\n+      Write_Eol;\n+      Write_Str (\"Nsyms = \");\n+      Write_Int (Nsyms);\n+      Write_Eol;\n+   end Finalize;\n \n-         --  Copy new buffer as result\n+   -----------------------------\n+   -- Get_Decoded_Name_String --\n+   -----------------------------\n \n-         Name_Len := New_Len;\n-         Name_Buffer (1 .. New_Len) := New_Buf (1 .. New_Len);\n-      end Decode;\n+   procedure Get_Decoded_Name_String (Id : Name_Id) is\n+   begin\n+      Global_Name_Buffer.Length := 0;\n+      Append_Decoded (Global_Name_Buffer, Id);\n    end Get_Decoded_Name_String;\n \n    -------------------------------------------\n    -- Get_Decoded_Name_String_With_Brackets --\n    -------------------------------------------\n \n    procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id) is\n-      P : Natural;\n-\n    begin\n-      --  Case of operator name, normal decoding is fine\n-\n-      if Name_Buffer (1) = 'O' then\n-         Get_Decoded_Name_String (Id);\n-\n-      --  For character literals, normal decoding is fine\n-\n-      elsif Name_Buffer (1) = 'Q' then\n-         Get_Decoded_Name_String (Id);\n-\n-      --  Only remaining issue is U/W/WW sequences\n-\n-      else\n-         Get_Name_String (Id);\n-\n-         P := 1;\n-         while P < Name_Len loop\n-            if Name_Buffer (P + 1) in 'A' .. 'Z' then\n-               P := P + 1;\n-\n-            --  Uhh encoding\n-\n-            elsif Name_Buffer (P) = 'U' then\n-               for J in reverse P + 3 .. P + Name_Len loop\n-                  Name_Buffer (J + 3) := Name_Buffer (J);\n-               end loop;\n-\n-               Name_Len := Name_Len + 3;\n-               Name_Buffer (P + 3) := Name_Buffer (P + 2);\n-               Name_Buffer (P + 2) := Name_Buffer (P + 1);\n-               Name_Buffer (P)     := '[';\n-               Name_Buffer (P + 1) := '\"';\n-               Name_Buffer (P + 4) := '\"';\n-               Name_Buffer (P + 5) := ']';\n-               P := P + 6;\n-\n-            --  WWhhhhhhhh encoding\n-\n-            elsif Name_Buffer (P) = 'W'\n-              and then P + 9 <= Name_Len\n-              and then Name_Buffer (P + 1) = 'W'\n-              and then Name_Buffer (P + 2) not in 'A' .. 'Z'\n-              and then Name_Buffer (P + 2) /= '_'\n-            then\n-               Name_Buffer (P + 12 .. Name_Len + 2) :=\n-                 Name_Buffer (P + 10 .. Name_Len);\n-               Name_Buffer (P)     := '[';\n-               Name_Buffer (P + 1) := '\"';\n-               Name_Buffer (P + 10) := '\"';\n-               Name_Buffer (P + 11) := ']';\n-               Name_Len := Name_Len + 2;\n-               P := P + 12;\n-\n-            --  Whhhh encoding\n-\n-            elsif Name_Buffer (P) = 'W'\n-              and then P < Name_Len\n-              and then Name_Buffer (P + 1) not in 'A' .. 'Z'\n-              and then Name_Buffer (P + 1) /= '_'\n-            then\n-               Name_Buffer (P + 8 .. P + Name_Len + 3) :=\n-                 Name_Buffer (P + 5 .. Name_Len);\n-               Name_Buffer (P + 2 .. P + 5) := Name_Buffer (P + 1 .. P + 4);\n-               Name_Buffer (P)     := '[';\n-               Name_Buffer (P + 1) := '\"';\n-               Name_Buffer (P + 6) := '\"';\n-               Name_Buffer (P + 7) := ']';\n-               Name_Len := Name_Len + 3;\n-               P := P + 8;\n-\n-            else\n-               P := P + 1;\n-            end if;\n-         end loop;\n-      end if;\n+      Global_Name_Buffer.Length := 0;\n+      Append_Decoded_With_Brackets (Global_Name_Buffer, Id);\n    end Get_Decoded_Name_String_With_Brackets;\n \n    ------------------------\n@@ -650,63 +774,26 @@ package body Namet is\n    -- Get_Name_String --\n    ---------------------\n \n-   --  Procedure version leaving result in Name_Buffer, length in Name_Len\n-\n    procedure Get_Name_String (Id : Name_Id) is\n-      S : Int;\n-\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n-\n-      S := Name_Entries.Table (Id).Name_Chars_Index;\n-      Name_Len := Natural (Name_Entries.Table (Id).Name_Len);\n-\n-      for J in 1 .. Name_Len loop\n-         Name_Buffer (J) := Name_Chars.Table (S + Int (J));\n-      end loop;\n+      Global_Name_Buffer.Length := 0;\n+      Append (Global_Name_Buffer, Id);\n    end Get_Name_String;\n \n-   ---------------------\n-   -- Get_Name_String --\n-   ---------------------\n-\n-   --  Function version returning a string\n-\n    function Get_Name_String (Id : Name_Id) return String is\n-      S : Int;\n-\n+      Buf : Bounded_String;\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n-      S := Name_Entries.Table (Id).Name_Chars_Index;\n-\n-      declare\n-         R : String (1 .. Natural (Name_Entries.Table (Id).Name_Len));\n-\n-      begin\n-         for J in R'Range loop\n-            R (J) := Name_Chars.Table (S + Int (J));\n-         end loop;\n-\n-         return R;\n-      end;\n+      Append (Buf, Id);\n+      return +Buf;\n    end Get_Name_String;\n \n    --------------------------------\n    -- Get_Name_String_And_Append --\n    --------------------------------\n \n    procedure Get_Name_String_And_Append (Id : Name_Id) is\n-      S : Int;\n-\n    begin\n-      pragma Assert (Id in Name_Entries.First .. Name_Entries.Last);\n-\n-      S := Name_Entries.Table (Id).Name_Chars_Index;\n-\n-      for J in 1 .. Natural (Name_Entries.Table (Id).Name_Len) loop\n-         Name_Len := Name_Len + 1;\n-         Name_Buffer (Name_Len) := Name_Chars.Table (S + Int (J));\n-      end loop;\n+      Append (Global_Name_Buffer, Id);\n    end Get_Name_String_And_Append;\n \n    -----------------------------\n@@ -765,8 +852,8 @@ package body Namet is\n \n    procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id) is\n    begin\n-      Get_Decoded_Name_String (Id);\n-      Strip_Qualification_And_Suffixes;\n+      Global_Name_Buffer.Length := 0;\n+      Append_Unqualified_Decoded (Global_Name_Buffer, Id);\n    end Get_Unqualified_Decoded_Name_String;\n \n    ---------------------------------\n@@ -775,15 +862,15 @@ package body Namet is\n \n    procedure Get_Unqualified_Name_String (Id : Name_Id) is\n    begin\n-      Get_Name_String (Id);\n-      Strip_Qualification_And_Suffixes;\n+      Global_Name_Buffer.Length := 0;\n+      Append_Unqualified (Global_Name_Buffer, Id);\n    end Get_Unqualified_Name_String;\n \n    ----------\n    -- Hash --\n    ----------\n \n-   function Hash return Hash_Index_Type is\n+   function Hash (Buf : Bounded_String) return Hash_Index_Type is\n \n       --  This hash function looks at every character, in order to make it\n       --  likely that similar strings get different hash values. The rotate by\n@@ -800,8 +887,8 @@ package body Namet is\n       Result : Unsigned_16 := 0;\n \n    begin\n-      for J in 1 .. Name_Len loop\n-         Result := Rotate_Left (Result, 7) xor Character'Pos (Name_Buffer (J));\n+      for J in 1 .. Buf.Length loop\n+         Result := Rotate_Left (Result, 7) xor Character'Pos (Buf.Chars (J));\n       end loop;\n \n       return Hash_Index_Type (Result);\n@@ -816,55 +903,47 @@ package body Namet is\n       null;\n    end Initialize;\n \n+   ----------------\n+   -- Insert_Str --\n+   ----------------\n+\n+   procedure Insert_Str\n+     (Buf : in out Bounded_String; S : String; Index : Positive) is\n+      SL : constant Natural := S'Length;\n+   begin\n+      Buf.Chars (Index + SL .. Buf.Length + SL) :=\n+        Buf.Chars (Index .. Buf.Length);\n+      Buf.Chars (Index .. Index + SL - 1) := S;\n+      Buf.Length := Buf.Length + SL;\n+   end Insert_Str;\n+\n    -------------------------------\n    -- Insert_Str_In_Name_Buffer --\n    -------------------------------\n \n    procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive) is\n-      SL : constant Natural := S'Length;\n    begin\n-      Name_Buffer (Index + SL .. Name_Len + SL) :=\n-        Name_Buffer (Index .. Name_Len);\n-      Name_Buffer (Index .. Index + SL - 1) := S;\n-      Name_Len := Name_Len + SL;\n+      Insert_Str (Global_Name_Buffer, S, Index);\n    end Insert_Str_In_Name_Buffer;\n \n    ----------------------\n    -- Is_Internal_Name --\n    ----------------------\n \n-   --  Version taking an argument\n-\n-   function Is_Internal_Name (Id : Name_Id) return Boolean is\n-   begin\n-      if Id in Error_Name_Or_No_Name then\n-         return False;\n-      else\n-         Get_Name_String (Id);\n-         return Is_Internal_Name;\n-      end if;\n-   end Is_Internal_Name;\n-\n-   ----------------------\n-   -- Is_Internal_Name --\n-   ----------------------\n-\n-   --  Version taking its input from Name_Buffer\n-\n-   function Is_Internal_Name return Boolean is\n+   function Is_Internal_Name (Buf : Bounded_String) return Boolean is\n       J : Natural;\n \n    begin\n-      --  AAny name starting with underscore is internal\n+      --  Any name starting or ending with underscore is internal\n \n-      if Name_Buffer (1) = '_'\n-        or else Name_Buffer (Name_Len) = '_'\n+      if Buf.Chars (1) = '_'\n+        or else Buf.Chars (Buf.Length) = '_'\n       then\n          return True;\n \n       --  Allow quoted character\n \n-      elsif Name_Buffer (1) = ''' then\n+      elsif Buf.Chars (1) = ''' then\n          return False;\n \n       --  All other cases, scan name\n@@ -873,30 +952,30 @@ package body Namet is\n          --  Test backwards, because we only want to test the last entity\n          --  name if the name we have is qualified with other entities.\n \n-         J := Name_Len;\n+         J := Buf.Length;\n          while J /= 0 loop\n \n             --  Skip stuff between brackets (A-F OK there)\n \n-            if Name_Buffer (J) = ']' then\n+            if Buf.Chars (J) = ']' then\n                loop\n                   J := J - 1;\n-                  exit when J = 1 or else Name_Buffer (J) = '[';\n+                  exit when J = 1 or else Buf.Chars (J) = '[';\n                end loop;\n \n             --  Test for internal letter\n \n-            elsif Is_OK_Internal_Letter (Name_Buffer (J)) then\n+            elsif Is_OK_Internal_Letter (Buf.Chars (J)) then\n                return True;\n \n             --  Quit if we come to terminating double underscore (note that\n             --  if the current character is an underscore, we know that\n             --  there is a previous character present, since we already\n-            --  filtered out the case of Name_Buffer (1) = '_' above.\n+            --  filtered out the case of Buf.Chars (1) = '_' above.\n \n-            elsif Name_Buffer (J) = '_'\n-              and then Name_Buffer (J - 1) = '_'\n-              and then Name_Buffer (J - 2) /= '_'\n+            elsif Buf.Chars (J) = '_'\n+              and then Buf.Chars (J - 1) = '_'\n+              and then Buf.Chars (J - 2) /= '_'\n             then\n                return False;\n             end if;\n@@ -908,6 +987,22 @@ package body Namet is\n       return False;\n    end Is_Internal_Name;\n \n+   function Is_Internal_Name (Id : Name_Id) return Boolean is\n+      Buf : Bounded_String;\n+   begin\n+      if Id in Error_Name_Or_No_Name then\n+         return False;\n+      else\n+         Append (Buf, Id);\n+         return Is_Internal_Name (Buf);\n+      end if;\n+   end Is_Internal_Name;\n+\n+   function Is_Internal_Name return Boolean is\n+   begin\n+      return Is_Internal_Name (Global_Name_Buffer);\n+   end Is_Internal_Name;\n+\n    ---------------------------\n    -- Is_OK_Internal_Letter --\n    ---------------------------\n@@ -979,11 +1074,13 @@ package body Namet is\n    -- Name_Enter --\n    ----------------\n \n-   function Name_Enter return Name_Id is\n+   function Name_Enter\n+     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id\n+   is\n    begin\n       Name_Entries.Append\n         ((Name_Chars_Index      => Name_Chars.Last,\n-          Name_Len              => Short (Name_Len),\n+          Name_Len              => Short (Buf.Length),\n           Byte_Info             => 0,\n           Int_Info              => 0,\n           Boolean1_Info         => False,\n@@ -994,8 +1091,8 @@ package body Namet is\n \n       --  Set corresponding string entry in the Name_Chars table\n \n-      for J in 1 .. Name_Len loop\n-         Name_Chars.Append (Name_Buffer (J));\n+      for J in 1 .. Buf.Length loop\n+         Name_Chars.Append (Buf.Chars (J));\n       end loop;\n \n       Name_Chars.Append (ASCII.NUL);\n@@ -1025,7 +1122,9 @@ package body Namet is\n    -- Name_Find --\n    ---------------\n \n-   function Name_Find return Name_Id is\n+   function Name_Find\n+     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id\n+   is\n       New_Id : Name_Id;\n       --  Id of entry in hash search, and value to be returned\n \n@@ -1038,30 +1137,30 @@ package body Namet is\n    begin\n       --  Quick handling for one character names\n \n-      if Name_Len = 1 then\n-         return Name_Id (First_Name_Id + Character'Pos (Name_Buffer (1)));\n+      if Buf.Length = 1 then\n+         return Name_Id (First_Name_Id + Character'Pos (Buf.Chars (1)));\n \n       --  Otherwise search hash table for existing matching entry\n \n       else\n-         Hash_Index := Namet.Hash;\n+         Hash_Index := Namet.Hash (Buf);\n          New_Id := Hash_Table (Hash_Index);\n \n          if New_Id = No_Name then\n             Hash_Table (Hash_Index) := Name_Entries.Last + 1;\n \n          else\n             Search : loop\n-               if Name_Len /=\n+               if Buf.Length /=\n                  Integer (Name_Entries.Table (New_Id).Name_Len)\n                then\n                   goto No_Match;\n                end if;\n \n                S := Name_Entries.Table (New_Id).Name_Chars_Index;\n \n-               for J in 1 .. Name_Len loop\n-                  if Name_Chars.Table (S + Int (J)) /= Name_Buffer (J) then\n+               for J in 1 .. Buf.Length loop\n+                  if Name_Chars.Table (S + Int (J)) /= Buf.Chars (J) then\n                      goto No_Match;\n                   end if;\n                end loop;\n@@ -1087,7 +1186,7 @@ package body Namet is\n \n          Name_Entries.Append\n            ((Name_Chars_Index      => Name_Chars.Last,\n-             Name_Len              => Short (Name_Len),\n+             Name_Len              => Short (Buf.Length),\n              Hash_Link             => No_Name,\n              Name_Has_No_Encodings => False,\n              Int_Info              => 0,\n@@ -1098,8 +1197,8 @@ package body Namet is\n \n          --  Set corresponding string entry in the Name_Chars table\n \n-         for J in 1 .. Name_Len loop\n-            Name_Chars.Append (Name_Buffer (J));\n+         for J in 1 .. Buf.Length loop\n+            Name_Chars.Append (Buf.Chars (J));\n          end loop;\n \n          Name_Chars.Append (ASCII.NUL);\n@@ -1108,16 +1207,12 @@ package body Namet is\n       end if;\n    end Name_Find;\n \n-   -------------------\n-   -- Name_Find_Str --\n-   -------------------\n-\n-   function Name_Find_Str (S : String) return Name_Id is\n+   function Name_Find (S : String) return Name_Id is\n+      Buf : Bounded_String;\n    begin\n-      Name_Len := S'Length;\n-      Name_Buffer (1 .. Name_Len) := S;\n-      return Name_Find;\n-   end Name_Find_Str;\n+      Append (Buf, S);\n+      return Name_Find (Buf);\n+   end Name_Find;\n \n    -------------\n    -- Nam_In --\n@@ -1319,29 +1414,7 @@ package body Namet is\n \n    function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean is\n    begin\n-      if N1 = N2 then\n-         return True;\n-      end if;\n-\n-      declare\n-         L1 : constant Int := Int (Name_Entries.Table (N1).Name_Len);\n-         L2 : constant Int := Int (Name_Entries.Table (N2).Name_Len);\n-\n-      begin\n-         if L1 /= L2 then\n-            return False;\n-         end if;\n-\n-         declare\n-            use Name_Chars;\n-            I1 : constant Int := Name_Entries.Table (N1).Name_Chars_Index;\n-            I2 : constant Int := Name_Entries.Table (N2).Name_Chars_Index;\n-\n-         begin\n-            return (Name_Chars.Table (1 + I1 .. I1 + L1) =\n-                    Name_Chars.Table (1 + I2 .. I2 + L2));\n-         end;\n-      end;\n+      return N1 = N2 or else Get_Name_String (N1) = Get_Name_String (N2);\n    end Name_Equals;\n \n    ------------------\n@@ -1394,11 +1467,17 @@ package body Namet is\n    -- Set_Character_Literal_Name --\n    --------------------------------\n \n+   procedure Set_Character_Literal_Name\n+     (Buf : in out Bounded_String; C : Char_Code) is\n+   begin\n+      Buf.Length := 0;\n+      Append (Buf, 'Q');\n+      Append_Encoded (Buf, C);\n+   end Set_Character_Literal_Name;\n+\n    procedure Set_Character_Literal_Name (C : Char_Code) is\n    begin\n-      Name_Buffer (1) := 'Q';\n-      Name_Len := 1;\n-      Store_Encoded_Character (C);\n+      Set_Character_Literal_Name (Global_Name_Buffer, C);\n    end Set_Character_Literal_Name;\n \n    -----------------------------\n@@ -1456,89 +1535,43 @@ package body Namet is\n    -----------------------------\n \n    procedure Store_Encoded_Character (C : Char_Code) is\n-      procedure Set_Hex_Chars (C : Char_Code);\n-      --  Stores given value, which is in the range 0 .. 255, as two hex\n-      --  digits (using lower case a-f) in Name_Buffer, incrementing Name_Len.\n-\n-      -------------------\n-      -- Set_Hex_Chars --\n-      -------------------\n-\n-      procedure Set_Hex_Chars (C : Char_Code) is\n-         Hexd : constant String := \"0123456789abcdef\";\n-         N    : constant Natural := Natural (C);\n-      begin\n-         Name_Buffer (Name_Len + 1) := Hexd (N / 16 + 1);\n-         Name_Buffer (Name_Len + 2) := Hexd (N mod 16 + 1);\n-         Name_Len := Name_Len + 2;\n-      end Set_Hex_Chars;\n-\n-   --  Start of processing for Store_Encoded_Character\n-\n    begin\n-      Name_Len := Name_Len + 1;\n-\n-      if In_Character_Range (C) then\n-         declare\n-            CC : constant Character := Get_Character (C);\n-         begin\n-            if CC in 'a' .. 'z' or else CC in '0' .. '9' then\n-               Name_Buffer (Name_Len) := CC;\n-            else\n-               Name_Buffer (Name_Len) := 'U';\n-               Set_Hex_Chars (C);\n-            end if;\n-         end;\n-\n-      elsif In_Wide_Character_Range (C) then\n-         Name_Buffer (Name_Len) := 'W';\n-         Set_Hex_Chars (C / 256);\n-         Set_Hex_Chars (C mod 256);\n-\n-      else\n-         Name_Buffer (Name_Len) := 'W';\n-         Name_Len := Name_Len + 1;\n-         Name_Buffer (Name_Len) := 'W';\n-         Set_Hex_Chars (C / 2 ** 24);\n-         Set_Hex_Chars ((C / 2 ** 16) mod 256);\n-         Set_Hex_Chars ((C / 256) mod 256);\n-         Set_Hex_Chars (C mod 256);\n-      end if;\n+      Append_Encoded (Global_Name_Buffer, C);\n    end Store_Encoded_Character;\n \n    --------------------------------------\n    -- Strip_Qualification_And_Suffixes --\n    --------------------------------------\n \n-   procedure Strip_Qualification_And_Suffixes is\n+   procedure Strip_Qualification_And_Suffixes (Buf : in out Bounded_String) is\n       J : Integer;\n \n    begin\n       --  Strip package body qualification string off end\n \n-      for J in reverse 2 .. Name_Len loop\n-         if Name_Buffer (J) = 'X' then\n-            Name_Len := J - 1;\n+      for J in reverse 2 .. Buf.Length loop\n+         if Buf.Chars (J) = 'X' then\n+            Buf.Length := J - 1;\n             exit;\n          end if;\n \n-         exit when Name_Buffer (J) /= 'b'\n-           and then Name_Buffer (J) /= 'n'\n-           and then Name_Buffer (J) /= 'p';\n+         exit when Buf.Chars (J) /= 'b'\n+           and then Buf.Chars (J) /= 'n'\n+           and then Buf.Chars (J) /= 'p';\n       end loop;\n \n       --  Find rightmost __ or $ separator if one exists. First we position\n       --  to start the search. If we have a character constant, position\n       --  just before it, otherwise position to last character but one\n \n-      if Name_Buffer (Name_Len) = ''' then\n-         J := Name_Len - 2;\n-         while J > 0 and then Name_Buffer (J) /= ''' loop\n+      if Buf.Chars (Buf.Length) = ''' then\n+         J := Buf.Length - 2;\n+         while J > 0 and then Buf.Chars (J) /= ''' loop\n             J := J - 1;\n          end loop;\n \n       else\n-         J := Name_Len - 1;\n+         J := Buf.Length - 1;\n       end if;\n \n       --  Loop to search for rightmost __ or $ (homonym) separator\n@@ -1547,28 +1580,28 @@ package body Namet is\n \n          --  If $ separator, homonym separator, so strip it and keep looking\n \n-         if Name_Buffer (J) = '$' then\n-            Name_Len := J - 1;\n-            J := Name_Len - 1;\n+         if Buf.Chars (J) = '$' then\n+            Buf.Length := J - 1;\n+            J := Buf.Length - 1;\n \n          --  Else check for __ found\n \n-         elsif Name_Buffer (J) = '_' and then Name_Buffer (J + 1) = '_' then\n+         elsif Buf.Chars (J) = '_' and then Buf.Chars (J + 1) = '_' then\n \n             --  Found __ so see if digit follows, and if so, this is a\n             --  homonym separator, so strip it and keep looking.\n \n-            if Name_Buffer (J + 2) in '0' .. '9' then\n-               Name_Len := J - 1;\n-               J := Name_Len - 1;\n+            if Buf.Chars (J + 2) in '0' .. '9' then\n+               Buf.Length := J - 1;\n+               J := Buf.Length - 1;\n \n             --  If not a homonym separator, then we simply strip the\n             --  separator and everything that precedes it, and we are done\n \n             else\n-               Name_Buffer (1 .. Name_Len - J - 1) :=\n-                 Name_Buffer (J + 2 .. Name_Len);\n-               Name_Len := Name_Len - J - 1;\n+               Buf.Chars (1 .. Buf.Length - J - 1) :=\n+                 Buf.Chars (J + 2 .. Buf.Length);\n+               Buf.Length := Buf.Length - J - 1;\n                exit;\n             end if;\n \n@@ -1578,6 +1611,15 @@ package body Namet is\n       end loop;\n    end Strip_Qualification_And_Suffixes;\n \n+   ---------------\n+   -- To_String --\n+   ---------------\n+\n+   function To_String (X : Bounded_String) return String is\n+   begin\n+      return X.Chars (1 .. X.Length);\n+   end To_String;\n+\n    ---------------\n    -- Tree_Read --\n    ---------------\n@@ -1625,10 +1667,8 @@ package body Namet is\n    --------\n \n    procedure wn (Id : Name_Id) is\n-      S : Int;\n-\n    begin\n-      if not Id'Valid then\n+      if Id not in Name_Entries.First .. Name_Entries.Last then\n          Write_Str (\"<invalid name_id>\");\n \n       elsif Id = No_Name then\n@@ -1638,12 +1678,12 @@ package body Namet is\n          Write_Str (\"<Error_Name>\");\n \n       else\n-         S := Name_Entries.Table (Id).Name_Chars_Index;\n-         Name_Len := Natural (Name_Entries.Table (Id).Name_Len);\n-\n-         for J in 1 .. Name_Len loop\n-            Write_Char (Name_Chars.Table (S + Int (J)));\n-         end loop;\n+         declare\n+            Buf : Bounded_String;\n+         begin\n+            Append (Buf, Id);\n+            Write_Str (Buf.Chars (1 .. Buf.Length));\n+         end;\n       end if;\n \n       Write_Eol;\n@@ -1654,10 +1694,11 @@ package body Namet is\n    ----------------\n \n    procedure Write_Name (Id : Name_Id) is\n+      Buf : Bounded_String;\n    begin\n       if Id >= First_Name_Id then\n-         Get_Name_String (Id);\n-         Write_Str (Name_Buffer (1 .. Name_Len));\n+         Append (Buf, Id);\n+         Write_Str (Buf.Chars (1 .. Buf.Length));\n       end if;\n    end Write_Name;\n \n@@ -1666,10 +1707,11 @@ package body Namet is\n    ------------------------\n \n    procedure Write_Name_Decoded (Id : Name_Id) is\n+      Buf : Bounded_String;\n    begin\n       if Id >= First_Name_Id then\n-         Get_Decoded_Name_String (Id);\n-         Write_Str (Name_Buffer (1 .. Name_Len));\n+         Append_Decoded (Buf, Id);\n+         Write_Str (Buf.Chars (1 .. Buf.Length));\n       end if;\n    end Write_Name_Decoded;\n "}, {"sha": "873897f7ea12bfd785819d840cc3a15402830ad4", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 205, "deletions": 181, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -51,7 +51,7 @@ package Namet is\n --                       Upper half (16#80# bit set) and wide characters are\n --                       stored in an encoded form (Uhh for upper half char,\n --                       Whhhh for wide characters, WWhhhhhhhh as provided by\n---                       the routine Store_Encoded_Character, where hh are hex\n+--                       the routine Append_Encoded, where hh are hex\n --                       digits for the character code using lower case a-f).\n --                       Normally the use of U or W in other internal names is\n --                       avoided, but these letters may be used in internal\n@@ -149,21 +149,30 @@ package Namet is\n --  and the Boolean field is initialized to False, when a new Name table entry\n --  is created.\n \n-   Name_Buffer : String (1 .. 4 * Max_Line_Length);\n-   --  This buffer is used to set the name to be stored in the table for the\n-   --  Name_Find call, and to retrieve the name for the Get_Name_String call.\n-   --  The limit here is intended to be an infinite value that ensures that we\n-   --  never overflow the buffer (names this long are too absurd to worry).\n-\n-   Name_Len : Natural := 0;\n-   --  Length of name stored in Name_Buffer. Used as an input parameter for\n-   --  Name_Find, and as an output value by Get_Name_String, or Write_Name.\n-   --  Note: in normal usage, all users of Name_Buffer/Name_Len are expected\n-   --  to initialize Name_Len appropriately. The reason we preinitialize to\n-   --  zero here is that some circuitry (e.g. Osint.Write_Program_Name) does\n-   --  a save/restore on Name_Len and Name_Buffer (1 .. Name_Len), and we do\n-   --  not want some arbitrary junk value to result in saving an arbitrarily\n-   --  long slice which would waste time and blow the stack.\n+   type Bounded_String (Max_Length : Natural := 4 * Max_Line_Length) is limited\n+   --  The default here is intended to be an infinite value that ensures that\n+   --  we never overflow the buffer (names this long are too absurd to worry).\n+      record\n+         Length : Natural := 0;\n+         Chars  : String (1 .. Max_Length);\n+      end record;\n+\n+   --  To create a Name_Id, you can declare a Bounded_String as a local\n+   --  variable, and Append things onto it, and finally call Name_Find.\n+   --  You can also use a String, as in:\n+   --     X := Name_Find (Some_String & \"_some_suffix\");\n+\n+   --  For historical reasons, we also have the Global_Name_Buffer below,\n+   --  which is used by most of the code via the renamings. New code ought\n+   --  to avoid the global.\n+\n+   Global_Name_Buffer : Bounded_String;\n+   Name_Buffer : String renames Global_Name_Buffer.Chars;\n+   Name_Len : Natural renames Global_Name_Buffer.Length;\n+\n+   --  Note that there is some circuitry (e.g. Osint.Write_Program_Name) that\n+   --  does a save/restore on Name_Len and Name_Buffer (1 .. Name_Len). This\n+   --  works in part because Name_Len is default-initialized to 0.\n \n    -----------------------------\n    -- Types for Namet Package --\n@@ -309,41 +318,106 @@ package Namet is\n    -- Subprograms --\n    -----------------\n \n-   procedure Add_Char_To_Name_Buffer (C : Character);\n-   pragma Inline (Add_Char_To_Name_Buffer);\n-   --  Add given character to the end of the string currently stored in the\n-   --  Name_Buffer, incrementing Name_Len.\n+   function To_String (X : Bounded_String) return String;\n+   function \"+\" (X : Bounded_String) return String renames To_String;\n+\n+   function Name_Find\n+     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n+   function Name_Find (S : String) return Name_Id;\n+   --  Name_Find searches the names table to see if the string has already been\n+   --  stored. If so, the Id of the existing entry is returned. Otherwise a new\n+   --  entry is created with its Name_Table_Int fields set to zero/false. Note\n+   --  that it is permissible for Buf.Length to be zero to lookup the empty\n+   --  name string.\n+\n+   function Name_Enter\n+     (Buf : Bounded_String := Global_Name_Buffer) return Name_Id;\n+   --  Name_Enter is similar to Name_Find. The difference is that it does not\n+   --  search the table for an existing match, and also subsequent Name_Find\n+   --  calls using the same name will not locate the entry created by this\n+   --  call. Thus multiple calls to Name_Enter with the same name will create\n+   --  multiple entries in the name table with different Name_Id values. This\n+   --  is useful in the case of created names, which are never expected to be\n+   --  looked up. Note: Name_Enter should never be used for one character\n+   --  names, since these are efficiently located without hashing by Name_Find\n+   --  in any case.\n \n-   procedure Add_Nat_To_Name_Buffer (V : Nat);\n-   --  Add decimal representation of given value to the end of the string\n-   --  currently stored in Name_Buffer, incrementing Name_Len as required.\n+   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean;\n+   --  Return whether N1 and N2 denote the same character sequence\n \n-   procedure Add_Str_To_Name_Buffer (S : String);\n-   --  Add characters of string S to the end of the string currently stored in\n-   --  the Name_Buffer, incrementing Name_Len by the length of the string.\n+   function Get_Name_String (Id : Name_Id) return String;\n+   --  Returns the characters of Id as a String. The lower bound is 1.\n+\n+   --  The following Append procedures ignore any characters that don't fit in\n+   --  Buf.\n+\n+   procedure Append (Buf : in out Bounded_String; C : Character);\n+   --  Append C onto Buf\n+   pragma Inline (Append);\n+\n+   procedure Append (Buf : in out Bounded_String; V : Nat);\n+   --  Append decimal representation of V onto Buf\n+\n+   procedure Append (Buf : in out Bounded_String; S : String);\n+   --  Append S onto Buf\n+\n+   procedure Append (Buf : in out Bounded_String; Id : Name_Id);\n+   --  Append the characters of Id onto Buf. It is an error to call this with\n+   --  one of the special name Id values (No_Name or Error_Name).\n+\n+   procedure Append_Decoded (Buf : in out Bounded_String; Id : Name_Id);\n+   --  Same as Append, except that the result is decoded, so that upper half\n+   --  characters and wide characters appear as originally found in the source\n+   --  program text, operators have their source forms (special characters and\n+   --  enclosed in quotes), and character literals appear surrounded by\n+   --  apostrophes.\n+\n+   procedure Append_Decoded_With_Brackets\n+     (Buf : in out Bounded_String; Id : Name_Id);\n+   --  Same as Append_Decoded, except that the brackets notation (Uhh\n+   --  replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"], WWhhhhhhhh replaced by\n+   --  [\"hhhhhhhh\"]) is used for all non-lower half characters, regardless of\n+   --  how Opt.Wide_Character_Encoding_Method is set, and also in that\n+   --  characters in the range 16#80# .. 16#FF# are converted to brackets\n+   --  notation in all cases. This routine can be used when there is a\n+   --  requirement for a canonical representation not affected by the\n+   --  character set options (e.g. in the binder generation of symbols).\n+\n+   procedure Append_Unqualified\n+     (Buf : in out Bounded_String; Id : Name_Id);\n+   --  Same as Append, except that qualification (as defined in unit\n+   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n+   --  also the suffixes used to indicate package body entities and to\n+   --  distinguish between overloaded entities). Note that names are not\n+   --  qualified until just before the call to gigi, so this routine is only\n+   --  needed by processing that occurs after gigi has been called. This\n+   --  includes all ASIS processing, since ASIS works on the tree written\n+   --  after gigi has been called.\n \n-   procedure Finalize;\n-   --  Called at the end of a use of the Namet package (before a subsequent\n-   --  call to Initialize). Currently this routine is only used to generate\n-   --  debugging output.\n+   procedure Append_Unqualified_Decoded\n+     (Buf : in out Bounded_String; Id : Name_Id);\n+   --  Same as Append_Unqualified, but decoded as for Append_Decoded\n+\n+   procedure Append_Encoded (Buf : in out Bounded_String; C : Char_Code);\n+   --  Appends given character code at the end of Buf. Lower case letters and\n+   --  digits are stored unchanged. Other 8-bit characters are stored using the\n+   --  Uhh encoding (hh = hex code), other 16-bit wide character values are\n+   --  stored using the Whhhh (hhhh = hex code) encoding, and other 32-bit wide\n+   --  wide character values are stored using the WWhhhhhhhh (hhhhhhhh = hex\n+   --  code).  Note that this procedure does not fold upper case letters (they\n+   --  are stored using the Uhh encoding).\n+\n+   procedure Set_Character_Literal_Name\n+     (Buf : in out Bounded_String; C : Char_Code);\n+   --  This procedure sets the proper encoded name for the character literal\n+   --  for the given character code.\n \n-   procedure Get_Decoded_Name_String (Id : Name_Id);\n-   --  Same calling sequence an interface as Get_Name_String, except that the\n-   --  result is decoded, so that upper half characters and wide characters\n-   --  appear as originally found in the source program text, operators have\n-   --  their source forms (special characters and enclosed in quotes), and\n-   --  character literals appear surrounded by apostrophes.\n+   procedure Insert_Str\n+     (Buf : in out Bounded_String; S : String; Index : Positive);\n+   --  Inserts S in Buf, starting at Index. Any existing characters at or past\n+   --  this location get moved beyond the inserted string.\n \n-   procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id);\n-   --  This routine is similar to Decoded_Name, except that the brackets\n-   --  notation (Uhh replaced by [\"hh\"], Whhhh replaced by [\"hhhh\"],\n-   --  WWhhhhhhhh replaced by [\"hhhhhhhh\"]) is used for all non-lower half\n-   --  characters, regardless of how Opt.Wide_Character_Encoding_Method is\n-   --  set, and also in that characters in the range 16#80# .. 16#FF# are\n-   --  converted to brackets notation in all cases. This routine can be used\n-   --  when there is a requirement for a canonical representation not affected\n-   --  by the character set options (e.g. in the binder generation of\n-   --  symbols).\n+   function Is_Internal_Name (Buf : Bounded_String) return Boolean;\n \n    procedure Get_Last_Two_Chars\n      (N  : Name_Id;\n@@ -353,21 +427,6 @@ package Namet is\n    --  C2 is last character. If name is less than two characters long then both\n    --  C1 and C2 are set to ASCII.NUL on return.\n \n-   procedure Get_Name_String (Id : Name_Id);\n-   --  Get_Name_String is used to retrieve the string associated with an entry\n-   --  in the names table. The resulting string is stored in Name_Buffer and\n-   --  Name_Len is set. It is an error to call Get_Name_String with one of the\n-   --  special name Id values (No_Name or Error_Name).\n-\n-   function Get_Name_String (Id : Name_Id) return String;\n-   --  This functional form returns the result as a string without affecting\n-   --  the contents of either Name_Buffer or Name_Len. The lower bound is 1.\n-\n-   procedure Get_Name_String_And_Append (Id : Name_Id);\n-   --  Like Get_Name_String but the resulting characters are appended to the\n-   --  current contents of the entry stored in Name_Buffer, and Name_Len is\n-   --  incremented to include the added characters.\n-\n    function Get_Name_Table_Boolean1 (Id : Name_Id) return Boolean;\n    function Get_Name_Table_Boolean2 (Id : Name_Id) return Boolean;\n    function Get_Name_Table_Boolean3 (Id : Name_Id) return Boolean;\n@@ -381,48 +440,23 @@ package Namet is\n    pragma Inline (Get_Name_Table_Int);\n    --  Fetches the Int value associated with the given name\n \n-   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id);\n-   --  Similar to the above except that qualification (as defined in unit\n-   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n-   --  also the suffix used to indicate package body entities). Note that\n-   --  names are not qualified until just before the call to gigi, so this\n-   --  routine is only needed by processing that occurs after gigi has been\n-   --  called. This includes all ASIS processing, since ASIS works on the tree\n-   --  written after gigi has been called.\n-\n-   procedure Get_Unqualified_Name_String (Id : Name_Id);\n-   --  Similar to the above except that qualification (as defined in unit\n-   --  Exp_Dbug) is removed (including both preceding __ delimited names, and\n-   --  also the suffixes used to indicate package body entities and to\n-   --  distinguish between overloaded entities). Note that names are not\n-   --  qualified until just before the call to gigi, so this routine is only\n-   --  needed by processing that occurs after gigi has been called. This\n-   --  includes all ASIS processing, since ASIS works on the tree written\n-   --  after gigi has been called.\n-\n-   procedure Initialize;\n-   --  This is a dummy procedure. It is retained for easy compatibility with\n-   --  clients who used to call Initialize when this call was required. Now\n-   --  initialization is performed automatically during package elaboration.\n-   --  Note that this change fixes problems which existed prior to the change\n-   --  of Initialize being called more than once. See also Reinitialize which\n-   --  allows reinitialization of the tables.\n+   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean);\n+   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean);\n+   --  Sets the Boolean value associated with the given name\n \n-   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n-   --  Inserts given string in name buffer, starting at Index. Any existing\n-   --  characters at or past this location get moved beyond the inserted string\n-   --  and Name_Len is incremented by the length of the string.\n+   procedure Set_Name_Table_Byte (Id : Name_Id; Val : Byte);\n+   pragma Inline (Set_Name_Table_Byte);\n+   --  Sets the Byte value associated with the given name\n \n-   function Is_Internal_Name return Boolean;\n-   --  Like the form with an Id argument, except that the name to be tested is\n-   --  passed in Name_Buffer and Name_Len (which are not affected by the call).\n-   --  Name_Buffer (it loads these as for Get_Name_String).\n+   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int);\n+   pragma Inline (Set_Name_Table_Int);\n+   --  Sets the Int value associated with the given name\n \n    function Is_Internal_Name (Id : Name_Id) return Boolean;\n    --  Returns True if the name is an internal name (i.e. contains a character\n    --  for which Is_OK_Internal_Letter is true, or if the name starts or ends\n-   --  with an underscore. This call destroys the value of Name_Len and\n-   --  Name_Buffer (it loads these as for Get_Name_String).\n+   --  with an underscore.\n    --\n    --  Note: if the name is qualified (has a double underscore), then only the\n    --  final entity name is considered, not the qualifying names. Consider for\n@@ -454,52 +488,15 @@ package Namet is\n    function Length_Of_Name (Id : Name_Id) return Nat;\n    pragma Inline (Length_Of_Name);\n    --  Returns length of given name in characters. This is the length of the\n-   --  encoded name, as stored in the names table, the result is equivalent to\n-   --  calling Get_Name_String and reading Name_Len, except that a call to\n-   --  Length_Of_Name does not affect the contents of Name_Len and Name_Buffer.\n-\n-   procedure Lock;\n-   --  Lock name tables before calling back end. We reserve some extra space\n-   --  before locking to avoid unnecessary inefficiencies when we unlock.\n-\n-   function Name_Chars_Address return System.Address;\n-   --  Return starting address of name characters table (used in Back_End call\n-   --  to Gigi).\n-\n-   function Name_Enter return Name_Id;\n-   --  Name_Enter has the same calling interface as Name_Find. The difference\n-   --  is that it does not search the table for an existing match, and also\n-   --  subsequent Name_Find calls using the same name will not locate the\n-   --  entry created by this call. Thus multiple calls to Name_Enter with the\n-   --  same name will create multiple entries in the name table with different\n-   --  Name_Id values. This is useful in the case of created names, which are\n-   --  never expected to be looked up. Note: Name_Enter should never be used\n-   --  for one character names, since these are efficiently located without\n-   --  hashing by Name_Find in any case.\n-\n-   function Name_Entries_Address return System.Address;\n-   --  Return starting address of Names table (used in Back_End call to Gigi)\n-\n-   function Name_Entries_Count return Nat;\n-   --  Return current number of entries in the names table\n-\n-   function Name_Equals (N1 : Name_Id; N2 : Name_Id) return Boolean;\n-   --  Return whether N1 and N2 denote the same character sequence\n+   --  encoded name, as stored in the names table.\n \n-   function Name_Find return Name_Id;\n-   --  Name_Find is called with a string stored in Name_Buffer whose length is\n-   --  in Name_Len (i.e. the characters of the name are in subscript positions\n-   --  1 to Name_Len in Name_Buffer). It searches the names table to see if the\n-   --  string has already been stored. If so the Id of the existing entry is\n-   --  returned. Otherwise a new entry is created with its Name_Table_Int\n-   --  fields set to zero/false. The contents of Name_Buffer and Name_Len are\n-   --  not modified by this call. Note that it is permissible for Name_Len to\n-   --  be set to zero to lookup the null name string.\n-\n-   function Name_Find_Str (S : String) return Name_Id;\n-   --  Similar to Name_Find, except that the string is provided as an argument.\n-   --  This call destroys the contents of Name_Buffer and Name_Len (by storing\n-   --  the given string there.\n+   procedure Initialize;\n+   --  This is a dummy procedure. It is retained for easy compatibility with\n+   --  clients who used to call Initialize when this call was required. Now\n+   --  initialization is performed automatically during package elaboration.\n+   --  Note that this change fixes problems which existed prior to the change\n+   --  of Initialize being called more than once. See also Reinitialize which\n+   --  allows reinitialization of the tables.\n \n    procedure Reinitialize;\n    --  Clears the name tables and removes all existing entries from the table.\n@@ -511,34 +508,18 @@ package Namet is\n    --  compilation to another, but we can't keep the entity info, since this\n    --  refers to tree nodes, which are destroyed between each main source file.\n \n-   procedure Set_Character_Literal_Name (C : Char_Code);\n-   --  This procedure sets the proper encoded name for the character literal\n-   --  for the given character code. On return Name_Buffer and Name_Len are\n-   --  set to reflect the stored name.\n-\n-   procedure Set_Name_Table_Byte (Id : Name_Id; Val : Byte);\n-   pragma Inline (Set_Name_Table_Byte);\n-   --  Sets the Byte value associated with the given name\n-\n-   procedure Set_Name_Table_Int (Id : Name_Id; Val : Int);\n-   pragma Inline (Set_Name_Table_Int);\n-   --  Sets the Int value associated with the given name\n+   procedure Finalize;\n+   --  Called at the end of a use of the Namet package (before a subsequent\n+   --  call to Initialize). Currently this routine is only used to generate\n+   --  debugging output.\n \n-   procedure Set_Name_Table_Boolean1 (Id : Name_Id; Val : Boolean);\n-   procedure Set_Name_Table_Boolean2 (Id : Name_Id; Val : Boolean);\n-   procedure Set_Name_Table_Boolean3 (Id : Name_Id; Val : Boolean);\n-   --  Sets the Boolean value associated with the given name\n+   procedure Lock;\n+   --  Lock name tables before calling back end. We reserve some extra space\n+   --  before locking to avoid unnecessary inefficiencies when we unlock.\n \n-   procedure Store_Encoded_Character (C : Char_Code);\n-   --  Stores given character code at the end of Name_Buffer, updating the\n-   --  value in Name_Len appropriately. Lower case letters and digits are\n-   --  stored unchanged. Other 8-bit characters are stored using the Uhh\n-   --  encoding (hh = hex code), other 16-bit wide character values are stored\n-   --  using the Whhhh (hhhh = hex code) encoding, and other 32-bit wide wide\n-   --  character values are stored using the WWhhhhhhhh (hhhhhhhh = hex code).\n-   --  Note that this procedure does not fold upper case letters (they are\n-   --  stored using the Uhh encoding). If folding is required, it must be done\n-   --  by the caller prior to the call.\n+   procedure Unlock;\n+   --  Unlocks the name table to allow use of the extra space reserved by the\n+   --  call to Lock. See gnat1drv for details of the need for this.\n \n    procedure Tree_Read;\n    --  Initializes internal tables from current tree file using the relevant\n@@ -549,22 +530,65 @@ package Namet is\n    --  Writes out internal tables to current tree file using the relevant\n    --  Table.Tree_Write routines.\n \n-   procedure Unlock;\n-   --  Unlocks the name table to allow use of the extra space reserved by the\n-   --  call to Lock. See gnat1drv for details of the need for this.\n-\n    procedure Write_Name (Id : Name_Id);\n    --  Write_Name writes the characters of the specified name using the\n-   --  standard output procedures in package Output. No end of line is\n-   --  written, just the characters of the name. On return Name_Buffer and\n-   --  Name_Len are set as for a call to Get_Name_String. The name is written\n+   --  standard output procedures in package Output. The name is written\n    --  in encoded form (i.e. including Uhh, Whhh, Qx, _op as they appear in\n    --  the name table). If Id is Error_Name, or No_Name, no text is output.\n \n    procedure Write_Name_Decoded (Id : Name_Id);\n    --  Like Write_Name, except that the name written is the decoded name, as\n-   --  described for Get_Decoded_Name_String, and the resulting value stored\n-   --  in Name_Len and Name_Buffer is the decoded name.\n+   --  described for Append_Decoded.\n+\n+   function Name_Chars_Address return System.Address;\n+   --  Return starting address of name characters table (used in Back_End call\n+   --  to Gigi).\n+\n+   function Name_Entries_Address return System.Address;\n+   --  Return starting address of Names table (used in Back_End call to Gigi)\n+\n+   function Name_Entries_Count return Nat;\n+   --  Return current number of entries in the names table\n+\n+   --------------------------\n+   -- Obsolete Subprograms --\n+   --------------------------\n+\n+   --  The following routines operate on Global_Name_Buffer. New code should\n+   --  use the routines above, and declare Bounded_Strings as local\n+   --  variables. Existing code can be improved incrementally by removing calls\n+   --  to the following. ???If we eliminate all of these, we can remove\n+   --  Global_Name_Buffer. But be sure to look at namet.h first.\n+\n+   --  To see what these do, look at the bodies. They are all trivially defined\n+   --  in terms of routines above.\n+\n+   procedure Add_Char_To_Name_Buffer (C : Character);\n+   pragma Inline (Add_Char_To_Name_Buffer);\n+\n+   procedure Add_Nat_To_Name_Buffer (V : Nat);\n+\n+   procedure Add_Str_To_Name_Buffer (S : String);\n+\n+   procedure Get_Decoded_Name_String (Id : Name_Id);\n+\n+   procedure Get_Decoded_Name_String_With_Brackets (Id : Name_Id);\n+\n+   procedure Get_Name_String (Id : Name_Id);\n+\n+   procedure Get_Name_String_And_Append (Id : Name_Id);\n+\n+   procedure Get_Unqualified_Decoded_Name_String (Id : Name_Id);\n+\n+   procedure Get_Unqualified_Name_String (Id : Name_Id);\n+\n+   procedure Insert_Str_In_Name_Buffer (S : String; Index : Positive);\n+\n+   function Is_Internal_Name return Boolean;\n+\n+   procedure Set_Character_Literal_Name (C : Char_Code);\n+\n+   procedure Store_Encoded_Character (C : Char_Code);\n \n    ------------------------------\n    -- File and Unit Name Types --\n@@ -629,6 +653,8 @@ package Namet is\n    --  <No_Name>, <invalid name>). Unlike Write_Name, this call does not affect\n    --  the contents of Name_Buffer or Name_Len.\n \n+private\n+\n    ---------------------------\n    -- Table Data Structures --\n    ---------------------------\n@@ -637,8 +663,6 @@ package Namet is\n    --  names. The definitions are in the private part of the package spec,\n    --  rather than the body, since they are referenced directly by gigi.\n \n-private\n-\n    --  This table stores the actual string names. Although logically there is\n    --  no need for a terminating character (since the length is stored in the\n    --  name entry table), we still store a NUL character at the end of every\n@@ -673,8 +697,8 @@ private\n       Name_Has_No_Encodings : Boolean;\n       --  This flag is set True if the name entry is known not to contain any\n       --  special character encodings. This is used to speed up repeated calls\n-      --  to Get_Decoded_Name_String. A value of False means that it is not\n-      --  known whether the name contains any such encodings.\n+      --  to Append_Decoded. A value of False means that it is not known\n+      --  whether the name contains any such encodings.\n \n       Hash_Link : Name_Id;\n       --  Link to next entry in names table for same hash code"}, {"sha": "32d110b2d275ded53416b292b75818377406373f", "filename": "gcc/ada/namet.h", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fnamet.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.h?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -25,7 +25,7 @@\n \n /* This is the C file that corresponds to the Ada package specification\n    Namet.  It was created manually from files namet.ads and namet.adb.\n-   Some subprograms from Sinput are also made acessable here.  */\n+   Some subprograms from Sinput are also made accessible here.  */\n \n #ifdef __cplusplus\n extern \"C\" {\n@@ -52,16 +52,26 @@ extern struct Name_Entry *Names_Ptr;\n #define Name_Chars_Ptr namet__name_chars__table\n extern char *Name_Chars_Ptr;\n \n-#define Name_Buffer namet__name_buffer\n-extern char Name_Buffer[];\n+/* The global name buffer. */\n+struct Bounded_String\n+{\n+  Nat Max_Length;\n+  Nat Length;\n+  char Chars[1];\n+  /* The 1 here is wrong, but it doesn't matter, because all the code either\n+     goes by Length, or NUL-terminates the string before processing it. */\n+};\n+\n+#define Global_Name_Buffer namet__global_name_buffer\n+extern struct Bounded_String Global_Name_Buffer;\n \n-extern Int namet__name_len;\n-#define Name_Len namet__name_len\n+#define Name_Buffer Global_Name_Buffer.Chars\n+#define Name_Len Global_Name_Buffer.Length\n \n-/* Get_Name_String returns a null terminated C string for the specified name.\n+/* Get_Name_String returns a NUL terminated C string for the specified name.\n    We could use the official Ada routine for this purpose, but since the\n    strings we want are sitting in the name strings table in exactly the form\n-   we need them (null terminated), we just point to the name directly. */\n+   we need them (NUL terminated), we just point to the name directly. */\n \n static char *Get_Name_String (Name_Id);\n "}, {"sha": "1dd350a8b3cc432be8e0e12c9e2b2a406257dee7", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -3287,11 +3287,11 @@ package body Sem_Elab is\n       --  Determine whether to emit an error message based on the combination\n       --  of flags Check_Elab_Flag and Flag.\n \n-      function Is_Printable_Error_Name (Nm : Name_Id) return Boolean;\n-      --  An internal function, used to determine if a name, Nm, is either\n-      --  a non-internal name, or is an internal name that is printable\n-      --  by the error message circuits (i.e. it has a single upper\n-      --  case letter at the end).\n+      function Is_Printable_Error_Name return Boolean;\n+      --  An internal function, used to determine if a name, stored in the\n+      --  Name_Buffer, is either a non-internal name, or is an internal name\n+      --  that is printable by the error message circuits (i.e. it has a single\n+      --  upper case letter at the end).\n \n       ----------\n       -- Emit --\n@@ -3310,9 +3310,9 @@ package body Sem_Elab is\n       -- Is_Printable_Error_Name --\n       -----------------------------\n \n-      function Is_Printable_Error_Name (Nm : Name_Id) return Boolean is\n+      function Is_Printable_Error_Name return Boolean is\n       begin\n-         if not Is_Internal_Name (Nm) then\n+         if not Is_Internal_Name then\n             return True;\n \n          elsif Name_Len = 1 then\n@@ -3335,6 +3335,7 @@ package body Sem_Elab is\n          Error_Msg_Sloc := Elab_Call.Table (J).Cloc;\n \n          Ent := Elab_Call.Table (J).Ent;\n+         Get_Name_String (Chars (Ent));\n \n          --  Dynamic elaboration model, warnings controlled by -gnatwl\n \n@@ -3344,7 +3345,7 @@ package body Sem_Elab is\n                   Error_Msg_NE (\"\\\\?l?& instantiated #\", N, Ent);\n                elsif Is_Init_Proc (Ent) then\n                   Error_Msg_N (\"\\\\?l?initialization procedure called #\", N);\n-               elsif Is_Printable_Error_Name (Chars (Ent)) then\n+               elsif Is_Printable_Error_Name then\n                   Error_Msg_NE (\"\\\\?l?& called #\", N, Ent);\n                else\n                   Error_Msg_N (\"\\\\?l?called #\", N);\n@@ -3359,7 +3360,7 @@ package body Sem_Elab is\n                   Error_Msg_NE (\"\\\\?$?& instantiated #\", N, Ent);\n                elsif Is_Init_Proc (Ent) then\n                   Error_Msg_N (\"\\\\?$?initialization procedure called #\", N);\n-               elsif Is_Printable_Error_Name (Chars (Ent)) then\n+               elsif Is_Printable_Error_Name then\n                   Error_Msg_NE (\"\\\\?$?& called #\", N, Ent);\n                else\n                   Error_Msg_N (\"\\\\?$?called #\", N);"}, {"sha": "c55054b4565e4d5bba8e9b246536d6b56dade3c0", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 109, "deletions": 43, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3e20cb680fae4486f196dcc807237d573ad6d207/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=3e20cb680fae4486f196dcc807237d573ad6d207", "patch": "@@ -25188,9 +25188,10 @@ package body Sem_Prag is\n             Enabled  : Boolean;\n             Constit  : Entity_Id);\n          --  Determine whether a property denoted by name Prop_Nam is present\n-         --  in both the refined state and constituent Constit. Flag Enabled\n-         --  should be set when the property applies to the refined state. If\n-         --  this is not the case, emit an error message.\n+         --  in the refined state. Emit an error if this is not the case. Flag\n+         --  Enabled should be set when the property applies to the refined\n+         --  state. Constit denotes the constituent (if any) which introduces\n+         --  the property in the refinement.\n \n          procedure Match_State;\n          --  Determine whether the state being refined appears in list\n@@ -25511,27 +25512,21 @@ package body Sem_Prag is\n             Constit  : Entity_Id)\n          is\n          begin\n-            Error_Msg_Name_1 := Prop_Nam;\n-\n-            --  The property is enabled in the related Abstract_State pragma\n-            --  that defines the state (SPARK RM 7.2.8(2)).\n-\n-            if Enabled then\n-               if No (Constit) then\n-                  SPARK_Msg_NE\n-                    (\"external state & requires at least one constituent with \"\n-                     & \"property %\", State, State_Id);\n-               end if;\n-\n             --  The property is missing in the declaration of the state, but\n             --  a constituent is introducing it in the state refinement\n             --  (SPARK RM 7.2.8(2)).\n \n-            elsif Present (Constit) then\n-               Error_Msg_Name_2 := Chars (Constit);\n+            if not Enabled and then Present (Constit) then\n+               Error_Msg_Name_1 := Prop_Nam;\n+               Error_Msg_Name_2 := Chars (State_Id);\n                SPARK_Msg_NE\n-                 (\"external state & lacks property % set by constituent %\",\n-                  State, State_Id);\n+                 (\"constituent & introduces external property % in refinement \"\n+                  & \"of state %\", State, Constit);\n+\n+               Error_Msg_Sloc := Sloc (State_Id);\n+               SPARK_Msg_N\n+                 (\"\\property is missing in abstract state declaration #\",\n+                  State);\n             end if;\n          end Check_External_Property;\n \n@@ -25746,10 +25741,8 @@ package body Sem_Prag is\n             Analyze_Constituent (Constit);\n          end if;\n \n-         --  The set of properties that all external constituents yield must\n-         --  match that of the refined state. There are two cases to detect:\n-         --  the refined state lacks a property or has an extra property\n-         --  (SPARK RM 7.2.8(2)).\n+         --  Verify that external constituents do not introduce new external\n+         --  property in the state refinement (SPARK RM 7.2.8(2)).\n \n          if Is_External_State (State_Id) then\n             Check_External_Property\n@@ -26050,14 +26043,20 @@ package body Sem_Prag is\n             if Present (New_E) then\n                Rewrite (N, New_Occurrence_Of (New_E, Sloc (N)));\n             end if;\n-         end if;\n \n-         if not Is_Abstract_Subprogram (Inher_Id)\n-           and then Nkind (N) = N_Function_Call\n-           and then Present (Entity (Name (N)))\n-           and then Is_Abstract_Subprogram (Entity (Name (N)))\n-         then\n-            Error_Msg_N (\"cannot call abstract subprogram\", N);\n+            --  Check that there are no calls left to abstract operations\n+            --  if the current subprogram is not abstract.\n+\n+            if Nkind (Parent (N)) = N_Function_Call\n+              and then N = Name (Parent (N))\n+              and then not Is_Abstract_Subprogram (Subp_Id)\n+              and then Is_Abstract_Subprogram (Entity (N))\n+            then\n+               Error_Msg_Sloc := Sloc (Current_Scope);\n+               Error_Msg_NE\n+                 (\"cannot call abstract subprogram in inherited condition \"\n+                   & \"for&#\", N, Current_Scope);\n+            end if;\n \n          --  The whole expression will be reanalyzed\n \n@@ -26140,13 +26139,47 @@ package body Sem_Prag is\n          --  operations of the descendant. Note that the descendant type may\n          --  not be frozen yet, so we cannot use the dispatch table directly.\n \n-         declare\n+         --  Note : the construction of the map involves a full traversal of\n+         --  the list of primitive operations, as well as a scan of the\n+         --  declarations in the scope of the operation. Given that class-wide\n+         --  conditions are typically short expressions, it might be much more\n+         --  efficient to collect the identifiers in the expression first, and\n+         --  then determine the ones that have to be mapped. Optimization ???\n+\n+         Primitive_Mapping : declare\n+            function Overridden_Ancestor (S : Entity_Id) return Entity_Id;\n+            --  Given the controlling type of the overridden operation and a\n+            --  primitive of the current type, find the corresponding operation\n+            --  of the parent type.\n+\n+            -------------------------\n+            -- Overridden_Ancestor --\n+            -------------------------\n+\n+            function Overridden_Ancestor (S : Entity_Id) return Entity_Id is\n+               Anc : Entity_Id;\n+\n+            begin\n+               Anc := S;\n+               while Present (Overridden_Operation (Anc)) loop\n+                  exit when Scope (Anc) = Scope (Inher_Id);\n+                  Anc := Overridden_Operation (Anc);\n+               end loop;\n+\n+               return Anc;\n+            end Overridden_Ancestor;\n+\n+            --  Local variables\n+\n             Old_Typ  : constant Entity_Id := Find_Dispatching_Type (Inher_Id);\n             Typ      : constant Entity_Id := Find_Dispatching_Type (Subp_Id);\n             Decl     : Node_Id;\n+            Old_Elmt : Elmt_Id;\n             Old_Prim : Entity_Id;\n             Prim     : Entity_Id;\n \n+         --  Start of processing for Primitive_Mapping\n+\n          begin\n             Decl := First (List_Containing (Unit_Declaration_Node (Subp_Id)));\n \n@@ -26163,12 +26196,7 @@ package body Sem_Prag is\n                     and then Present (Overridden_Operation (Prim))\n                     and then Find_Dispatching_Type (Prim) = Typ\n                   then\n-                     Old_Prim := Overridden_Operation (Prim);\n-                     while Present (Overridden_Operation (Old_Prim))\n-                       and then Scope (Old_Prim) /= Scope (Inher_Id)\n-                     loop\n-                        Old_Prim := Overridden_Operation (Old_Prim);\n-                     end loop;\n+                     Old_Prim := Overridden_Ancestor (Prim);\n \n                      Append_Elmt (Old_Prim, Map);\n                      Append_Elmt (Prim,     Map);\n@@ -26178,18 +26206,36 @@ package body Sem_Prag is\n                Next (Decl);\n             end loop;\n \n+            --  Now examine inherited operations. These do not override, but\n+            --  have an alias, which is the entity used in a call. In turn\n+            --  that alias may be inherited or comes from source, in which\n+            --  case it may override an earlier operation. We only need to\n+            --  examine inherited functions, that may appear within the\n+            --  inherited expression.\n+\n             Prim := First_Entity (Scope (Subp_Id));\n             while Present (Prim) loop\n                if not Comes_From_Source (Prim)\n                  and then Ekind (Prim) = E_Function\n                  and then Present (Alias (Prim))\n                then\n                   Old_Prim := Alias (Prim);\n-                  while Present (Alias (Old_Prim))\n-                    and then Scope (Old_Prim) /= Scope (Inher_Id)\n-                  loop\n-                     Old_Prim := Alias (Old_Prim);\n-                  end loop;\n+\n+                  if Comes_From_Source (Old_Prim) then\n+                     Old_Prim := Overridden_Ancestor (Old_Prim);\n+\n+                  else\n+                     while Present (Alias (Old_Prim))\n+                       and then Scope (Old_Prim) /= Scope (Inher_Id)\n+                     loop\n+                        Old_Prim := Alias (Old_Prim);\n+\n+                        if Comes_From_Source (Old_Prim) then\n+                           Old_Prim := Overridden_Ancestor (Old_Prim);\n+                           exit;\n+                        end if;\n+                     end loop;\n+                  end if;\n \n                   Append_Elmt (Old_Prim, Map);\n                   Append_Elmt (Prim,     Map);\n@@ -26198,11 +26244,31 @@ package body Sem_Prag is\n                Next_Entity (Prim);\n             end loop;\n \n+            --  If the parent operation is an interface operation, the\n+            --  overriding indicator is not present. Instead, we get from\n+            --  the interface operation the primitive of the current type\n+            --  that implements it.\n+\n+            if Is_Interface (Old_Typ) then\n+               Old_Elmt := First_Elmt (Collect_Primitive_Operations (Old_Typ));\n+               while Present (Old_Elmt) loop\n+                  Old_Prim := Node (Old_Elmt);\n+                  Prim := Find_Primitive_Covering_Interface (Typ, Old_Prim);\n+\n+                  if Present (Prim) then\n+                     Append_Elmt (Old_Prim, Map);\n+                     Append_Elmt (Prim,     Map);\n+                  end if;\n+\n+                  Next_Elmt (Old_Elmt);\n+               end loop;\n+            end if;\n+\n             if Map /= No_Elist then\n                Append_Elmt (Old_Typ, Map);\n                Append_Elmt (Typ,     Map);\n             end if;\n-         end;\n+         end Primitive_Mapping;\n       end if;\n \n       --  Copy the original pragma while performing substitutions (if"}]}