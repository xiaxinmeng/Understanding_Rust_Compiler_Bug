{"sha": "ea8b5640551ee7cbecf5c3ce30f0268963de3039", "node_id": "C_kwDOANBUbNoAKGVhOGI1NjQwNTUxZWU3Y2JlY2Y1YzNjZTMwZjAyNjg5NjNkZTMwMzk", "commit": {"author": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-12-27T17:56:19Z"}, "committer": {"name": "John David Anglin", "email": "danglin@gcc.gnu.org", "date": "2021-12-27T17:56:19Z"}, "message": "Improve atomic store implementation on hppa-linux.\n\n2021-12-27  John David Anglin  <danglin@gcc.gnu.org>\n\ngcc/ChangeLog:\n\n\t* config/pa/pa-protos.h: Delete\n\tpa_maybe_emit_compare_and_swap_exchange_loop() declaration.\n\t* config/pa/pa.c (pa_expand_compare_and_swap_loop): Delete.\n\t(pa_maybe_emit_compare_and_swap_exchange_loop): Delete.\n\t* config/pa/pa.md (atomic_storeq): Use __sync_lock_test_and_set\n\tinstead of pa_maybe_emit_compare_and_swap_exchange_loop.\n\t(atomic_storehi, atomic_storesi, atomic_storedi): Likewise.", "tree": {"sha": "a74fe47f5f105b6c0688cc5d06b81fad74a2e696", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a74fe47f5f105b6c0688cc5d06b81fad74a2e696"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea8b5640551ee7cbecf5c3ce30f0268963de3039", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea8b5640551ee7cbecf5c3ce30f0268963de3039", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea8b5640551ee7cbecf5c3ce30f0268963de3039", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea8b5640551ee7cbecf5c3ce30f0268963de3039/comments", "author": null, "committer": null, "parents": [{"sha": "916ec36d0a3ef3fe44c1657746922a5f18b60326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/916ec36d0a3ef3fe44c1657746922a5f18b60326", "html_url": "https://github.com/Rust-GCC/gccrs/commit/916ec36d0a3ef3fe44c1657746922a5f18b60326"}], "stats": {"total": 117, "additions": 24, "deletions": 93}, "files": [{"sha": "69377db45c5d29d0ff56e9007ea6f28fbf3003f1", "filename": "gcc/config/pa/pa-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa-protos.h?ref=ea8b5640551ee7cbecf5c3ce30f0268963de3039", "patch": "@@ -73,7 +73,6 @@ extern rtx pa_return_addr_rtx (int, rtx);\n \n extern int pa_insn_refs_are_delayed (rtx_insn *);\n extern rtx pa_get_deferred_plabel (rtx);\n-extern rtx pa_maybe_emit_compare_and_swap_exchange_loop (rtx, rtx, rtx);\n #endif /* RTX_CODE */\n \n extern int pa_and_mask_p (unsigned HOST_WIDE_INT);"}, {"sha": "895978aea1ccb2398491cb0171f57f8934202d3f", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 76, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=ea8b5640551ee7cbecf5c3ce30f0268963de3039", "patch": "@@ -11023,82 +11023,6 @@ pa_output_addr_diff_vec (rtx lab, rtx body)\n     fputs (\"\\t.end_brtab\\n\", asm_out_file);\n }\n \n-/* This is a helper function for the other atomic operations.  This function\n-   emits a loop that contains SEQ that iterates until a compare-and-swap\n-   operation at the end succeeds.  MEM is the memory to be modified.  SEQ is\n-   a set of instructions that takes a value from OLD_REG as an input and\n-   produces a value in NEW_REG as an output.  Before SEQ, OLD_REG will be\n-   set to the current contents of MEM.  After SEQ, a compare-and-swap will\n-   attempt to update MEM with NEW_REG.  The function returns true when the\n-   loop was generated successfully.  */\n-\n-static bool\n-pa_expand_compare_and_swap_loop (rtx mem, rtx old_reg, rtx new_reg, rtx seq)\n-{\n-  machine_mode mode = GET_MODE (mem);\n-  rtx_code_label *label;\n-  rtx cmp_reg, success, oldval;\n-\n-  /* The loop we want to generate looks like\n-\n-        cmp_reg = mem;\n-      label:\n-        old_reg = cmp_reg;\n-        seq;\n-        (success, cmp_reg) = compare-and-swap(mem, old_reg, new_reg)\n-        if (success)\n-          goto label;\n-\n-     Note that we only do the plain load from memory once.  Subsequent\n-     iterations use the value loaded by the compare-and-swap pattern.  */\n-\n-  label = gen_label_rtx ();\n-  cmp_reg = gen_reg_rtx (mode);\n-\n-  emit_move_insn (cmp_reg, mem);\n-  emit_label (label);\n-  emit_move_insn (old_reg, cmp_reg);\n-  if (seq)\n-    emit_insn (seq);\n-\n-  success = NULL_RTX;\n-  oldval = cmp_reg;\n-  if (!expand_atomic_compare_and_swap (&success, &oldval, mem, old_reg,\n-                                       new_reg, false, MEMMODEL_SYNC_SEQ_CST,\n-                                       MEMMODEL_RELAXED))\n-    return false;\n-\n-  if (oldval != cmp_reg)\n-    emit_move_insn (cmp_reg, oldval);\n-\n-  /* Mark this jump predicted not taken.  */\n-  emit_cmp_and_jump_insns (success, const0_rtx, EQ, const0_rtx,\n-                           GET_MODE (success), 1, label,\n-\t\t\t   profile_probability::guessed_never ());\n-  return true;\n-}\n-\n-/* This function tries to implement an atomic exchange operation using a \n-   compare_and_swap loop. VAL is written to *MEM.  The previous contents of\n-   *MEM are returned, using TARGET if possible.  No memory model is required\n-   since a compare_and_swap loop is seq-cst.  */\n-\n-rtx\n-pa_maybe_emit_compare_and_swap_exchange_loop (rtx target, rtx mem, rtx val)\n-{\n-  machine_mode mode = GET_MODE (mem);\n-\n-  if (can_compare_and_swap_p (mode, true))\n-    {\n-      if (!target || !register_operand (target, mode))\n-        target = gen_reg_rtx (mode);\n-      if (pa_expand_compare_and_swap_loop (mem, target, val, NULL_RTX))\n-        return target;\n-    }\n-\n-  return NULL_RTX;\n-}\n-\n /* Implement TARGET_CALLEE_COPIES.  The callee is responsible for copying\n    arguments passed by hidden reference in the 32-bit HP runtime.  Users\n    can override this behavior for better compatibility with openmp at the"}, {"sha": "af5449a9ea3becd221a674b5bda37f827b2d95d9", "filename": "gcc/config/pa/pa.md", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea8b5640551ee7cbecf5c3ce30f0268963de3039/gcc%2Fconfig%2Fpa%2Fpa.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.md?ref=ea8b5640551ee7cbecf5c3ce30f0268963de3039", "patch": "@@ -10366,10 +10366,12 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   if (TARGET_SYNC_LIBCALL)\n     {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n+      rtx libfunc = init_one_libfunc (\"__sync_lock_test_and_set_1\");\n+\n+      emit_library_call (libfunc, LCT_NORMAL, VOIDmode,\n+\t\t\t XEXP (operands[0], 0), Pmode,\n+\t\t\t operands[1], QImode);\n+      DONE;\n     }\n   FAIL;\n })\n@@ -10384,10 +10386,12 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   if (TARGET_SYNC_LIBCALL)\n     {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n+      rtx libfunc = init_one_libfunc (\"__sync_lock_test_and_set_2\");\n+\n+      emit_library_call (libfunc, LCT_NORMAL, VOIDmode,\n+\t\t\t XEXP (operands[0], 0), Pmode,\n+\t\t\t operands[1], HImode);\n+      DONE;\n     }\n   FAIL;\n })\n@@ -10402,10 +10406,12 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n {\n   if (TARGET_SYNC_LIBCALL)\n     {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n+      rtx libfunc = init_one_libfunc (\"__sync_lock_test_and_set_4\");\n+\n+      emit_library_call (libfunc, LCT_NORMAL, VOIDmode,\n+\t\t\t XEXP (operands[0], 0), Pmode,\n+\t\t\t operands[1], SImode);\n+      DONE;\n     }\n   FAIL;\n })\n@@ -10453,10 +10459,12 @@ add,l %2,%3,%3\\;bv,n %%r0(%3)\"\n \n   if (TARGET_SYNC_LIBCALL)\n     {\n-      rtx mem = operands[0];\n-      rtx val = operands[1];\n-      if (pa_maybe_emit_compare_and_swap_exchange_loop (NULL_RTX, mem, val))\n-\tDONE;\n+      rtx libfunc = init_one_libfunc (\"__sync_lock_test_and_set_8\");\n+\n+      emit_library_call (libfunc, LCT_NORMAL, VOIDmode,\n+\t\t\t XEXP (operands[0], 0), Pmode,\n+\t\t\t operands[1], DImode);\n+      DONE;\n     }\n \n   if (TARGET_64BIT || TARGET_SOFT_FLOAT)"}]}