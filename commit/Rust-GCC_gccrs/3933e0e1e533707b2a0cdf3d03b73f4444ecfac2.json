{"sha": "3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkzM2UwZTFlNTMzNzA3YjJhMGNkZjNkMDNiNzNmNDQ0NGVjZmFjMg==", "commit": {"author": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-22T18:57:01Z"}, "committer": {"name": "Michael Meissner", "email": "meissner@gcc.gnu.org", "date": "1995-05-22T18:57:01Z"}, "message": "Add -mno-toc; Support block moves if -mno-string.\n\nFrom-SVN: r9763", "tree": {"sha": "cfbb2fb4d8512c46f9bddae8c49cc89ffc71c6d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cfbb2fb4d8512c46f9bddae8c49cc89ffc71c6d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/comments", "author": null, "committer": null, "parents": [{"sha": "15c8ec1ccde96eb39e9cced074149b8828ef5a49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15c8ec1ccde96eb39e9cced074149b8828ef5a49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15c8ec1ccde96eb39e9cced074149b8828ef5a49"}], "stats": {"total": 329, "additions": 224, "deletions": 105}, "files": [{"sha": "b3d07461701fd0d4f91bc780b9157a017c9cb23b", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 183, "deletions": 92, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "patch": "@@ -202,6 +202,10 @@ rs6000_override_options ()\n \t  warning (\"-mstring is not supported on little endian systems\");\n \t}\n     }\n+\n+#ifdef SUBTARGET_OVERRIDE_OPTIONS\n+  SUBTARGET_OVERRIDE_OPTIONS;\n+#endif\n }\n \f\n /* Create a CONST_DOUBLE like immed_double_const, except reverse the\n@@ -641,127 +645,204 @@ input_operand (op, mode)\n    operands[2] is the length\n    operands[3] is the alignment */\n \n+#define MAX_MOVE_REG 4\n+\n int\n expand_block_move (operands)\n      rtx operands[];\n {\n   rtx bytes_rtx\t= operands[2];\n-  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n-  int bytes\t= (constp ? INTVAL (bytes_rtx) : 0);\n   rtx align_rtx = operands[3];\n+  int constp\t= (GET_CODE (bytes_rtx) == CONST_INT);\n   int align\t= XINT (align_rtx, 0);\n+  int bytes;\n+  int offset;\n+  int num_reg;\n+  int i;\n   rtx src_reg;\n   rtx dest_reg;\n+  rtx src_addr;\n+  rtx dest_addr;\n   rtx tmp_reg;\n+  rtx stores[MAX_MOVE_REG];\n   int move_bytes;\n \n+  /* If this is not a fixed size move, just call memcpy */\n+  if (!constp)\n+    return 0;\n+\n   /* Anything to move? */\n-  if (constp && bytes <= 0)\n+  bytes = INTVAL (bytes_rtx);\n+  if (bytes <= 0)\n     return 1;\n \n-  /* If we don't want to use multiple string instructions, quit now and\n-     generate the normal code.  */\n-  if (!TARGET_STRING)\n-    return 0;\n-\n-  /* We don't support variable sized moves at this time or real large moves */\n-  if (!constp || bytes > 64)\n+  /* Don't support real large moves.  If string instructions are not used,\n+     then don't generate more than 8 loads.  */\n+  if (TARGET_STRING)\n+    {\n+      if (bytes > 64)\n+\treturn 0;\n+    }\n+  else if (!STRICT_ALIGNMENT)\n+    {\n+      if (bytes > 4*8)\n+\treturn 0;\n+    }\n+  else if (bytes > 8*align)\n     return 0;\n \n   /* Move the address into scratch registers.  */\n   dest_reg = copy_addr_to_reg (XEXP (operands[0], 0));\n   src_reg  = copy_addr_to_reg (XEXP (operands[1], 0));\n \n-  for ( ; bytes > 0; bytes -= move_bytes)\n+  if (TARGET_STRING)\t/* string instructions are available */\n     {\n-      if (bytes > 24\t\t/* move up to 32 bytes at a time */\n-\t  && !fixed_regs[5]\n-\t  && !fixed_regs[6]\n-\t  && !fixed_regs[7]\n-\t  && !fixed_regs[8]\n-\t  && !fixed_regs[9]\n-\t  && !fixed_regs[10]\n-\t  && !fixed_regs[11]\n-\t  && !fixed_regs[12])\n-\t{\n-\t  move_bytes = (bytes > 32) ? 32 : bytes;\n-\t  emit_insn (gen_movstrsi_8reg (dest_reg,\n-\t\t\t\t\tsrc_reg,\n-\t\t\t\t\tGEN_INT ((move_bytes == 32) ? 0 : move_bytes),\n-\t\t\t\t\talign_rtx,\n-\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n-\t}\n-      else if (bytes > 16\t/* move up to 24 bytes at a time */\n-\t  && !fixed_regs[7]\n-\t  && !fixed_regs[8]\n-\t  && !fixed_regs[9]\n-\t  && !fixed_regs[10]\n-\t  && !fixed_regs[11]\n-\t  && !fixed_regs[12])\n+      for ( ; bytes > 0; bytes -= move_bytes)\n \t{\n-\t  move_bytes = (bytes > 24) ? 24 : bytes;\n-\t  emit_insn (gen_movstrsi_6reg (dest_reg,\n-\t\t\t\t\tsrc_reg,\n-\t\t\t\t\tGEN_INT (move_bytes),\n-\t\t\t\t\talign_rtx,\n-\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t  if (bytes > 24\t\t/* move up to 32 bytes at a time */\n+\t      && !fixed_regs[5]\n+\t      && !fixed_regs[6]\n+\t      && !fixed_regs[7]\n+\t      && !fixed_regs[8]\n+\t      && !fixed_regs[9]\n+\t      && !fixed_regs[10]\n+\t      && !fixed_regs[11]\n+\t      && !fixed_regs[12])\n+\t    {\n+\t      move_bytes = (bytes > 32) ? 32 : bytes;\n+\t      emit_insn (gen_movstrsi_8reg (dest_reg,\n+\t\t\t\t\t    src_reg,\n+\t\t\t\t\t    GEN_INT ((move_bytes == 32) ? 0 : move_bytes),\n+\t\t\t\t\t    align_rtx,\n+\t\t\t\t\t    GEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t    }\n+\t  else if (bytes > 16\t/* move up to 24 bytes at a time */\n+\t\t   && !fixed_regs[7]\n+\t\t   && !fixed_regs[8]\n+\t\t   && !fixed_regs[9]\n+\t\t   && !fixed_regs[10]\n+\t\t   && !fixed_regs[11]\n+\t\t   && !fixed_regs[12])\n+\t    {\n+\t      move_bytes = (bytes > 24) ? 24 : bytes;\n+\t      emit_insn (gen_movstrsi_6reg (dest_reg,\n+\t\t\t\t\t    src_reg,\n+\t\t\t\t\t    GEN_INT (move_bytes),\n+\t\t\t\t\t    align_rtx,\n+\t\t\t\t\t    GEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t    }\n+\t  else if (bytes > 8\t/* move up to 16 bytes at a time */\n+\t\t   && !fixed_regs[9]\n+\t\t   && !fixed_regs[10]\n+\t\t   && !fixed_regs[11]\n+\t\t   && !fixed_regs[12])\n+\t    {\n+\t      move_bytes = (bytes > 16) ? 16 : bytes;\n+\t      emit_insn (gen_movstrsi_4reg (dest_reg,\n+\t\t\t\t\t    src_reg,\n+\t\t\t\t\t    GEN_INT (move_bytes),\n+\t\t\t\t\t    align_rtx,\n+\t\t\t\t\t    GEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t    }\n+\t  else if (bytes > 4 && !TARGET_64BIT)\n+\t    {\t\t\t/* move up to 8 bytes at a time */\n+\t      move_bytes = (bytes > 8) ? 8 : bytes;\n+\t      emit_insn (gen_movstrsi_2reg (dest_reg,\n+\t\t\t\t\t    src_reg,\n+\t\t\t\t\t    GEN_INT (move_bytes),\n+\t\t\t\t\t    align_rtx,\n+\t\t\t\t\t    GEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t    }\n+\t  else if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n+\t    {\t\t\t/* move 4 bytes */\n+\t      move_bytes = 4;\n+\t      tmp_reg = gen_reg_rtx (SImode);\n+\t      emit_move_insn (tmp_reg, gen_rtx (MEM, SImode, src_reg));\n+\t      emit_move_insn (gen_rtx (MEM, SImode, dest_reg), tmp_reg);\n+\t      if (bytes > move_bytes)\n+\t\t{\n+\t\t  emit_insn (gen_addsi3 (src_reg, src_reg, GEN_INT (move_bytes)));\n+\t\t  emit_insn (gen_addsi3 (dest_reg, dest_reg, GEN_INT (move_bytes)));\n+\t\t}\n+\t    }\n+\t  else if (bytes == 2 && (align >= 2 || !STRICT_ALIGNMENT))\n+\t    {\t\t\t/* move 2 bytes */\n+\t      move_bytes = 2;\n+\t      tmp_reg = gen_reg_rtx (HImode);\n+\t      emit_move_insn (tmp_reg, gen_rtx (MEM, HImode, src_reg));\n+\t      emit_move_insn (gen_rtx (MEM, HImode, dest_reg), tmp_reg);\n+\t    }\n+\t  else if (bytes == 1)\t/* move 1 byte */\n+\t    {\n+\t      move_bytes = 1;\n+\t      tmp_reg = gen_reg_rtx (QImode);\n+\t      emit_move_insn (tmp_reg, gen_rtx (MEM, QImode, src_reg));\n+\t      emit_move_insn (gen_rtx (MEM, QImode, dest_reg), tmp_reg);\n+\t    }\n+\t  else\n+\t    {\t\t\t/* move up to 4 bytes at a time */\n+\t      move_bytes = (bytes > 4) ? 4 : bytes;\n+\t      emit_insn (gen_movstrsi_1reg (dest_reg,\n+\t\t\t\t\t    src_reg,\n+\t\t\t\t\t    GEN_INT (move_bytes),\n+\t\t\t\t\t    align_rtx,\n+\t\t\t\t\t    GEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t    }\n \t}\n-      else if (bytes > 8\t/* move up to 16 bytes at a time */\n-\t       && !fixed_regs[9]\n-\t       && !fixed_regs[10]\n-\t       && !fixed_regs[11]\n-\t       && !fixed_regs[12])\n+    }\n+\n+  else\t\t\t/* string instructions not available */\n+    {\n+      num_reg = offset = 0;\n+      for ( ; bytes > 0; (bytes -= move_bytes), (offset += move_bytes))\n \t{\n-\t  move_bytes = (bytes > 16) ? 16 : bytes;\n-\t  emit_insn (gen_movstrsi_4reg (dest_reg,\n-\t\t\t\t\tsrc_reg,\n-\t\t\t\t\tGEN_INT (move_bytes),\n-\t\t\t\t\talign_rtx,\n-\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n-\t}\n-      else if (bytes > 4 && !TARGET_64BIT)\n-\t{\t\t\t/* move up to 8 bytes at a time */\n-\t  move_bytes = (bytes > 8) ? 8 : bytes;\n-\t  emit_insn (gen_movstrsi_2reg (dest_reg,\n-\t\t\t\t\tsrc_reg,\n-\t\t\t\t\tGEN_INT (move_bytes),\n-\t\t\t\t\talign_rtx,\n-\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n-\t}\n-      else if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n-\t{\t\t\t/* move 4 bytes */\n-\t  move_bytes = 4;\n-\t  tmp_reg = gen_reg_rtx (SImode);\n-\t  emit_move_insn (tmp_reg, gen_rtx (MEM, SImode, src_reg));\n-\t  emit_move_insn (gen_rtx (MEM, SImode, dest_reg), tmp_reg);\n-\t  if (bytes > move_bytes)\n+\t  /* Calculate the correct offset for src/dest */\n+\t  if (offset == 0)\n \t    {\n-\t      emit_insn (gen_addsi3 (src_reg, src_reg, GEN_INT (move_bytes)));\n-\t      emit_insn (gen_addsi3 (dest_reg, dest_reg, GEN_INT (move_bytes)));\n+\t      src_addr  = src_reg;\n+\t      dest_addr = dest_reg;\n+\t    }\n+\t  else\n+\t    {\n+\t      src_addr  = gen_rtx (PLUS, Pmode, src_reg,  GEN_INT (offset));\n+\t      dest_addr = gen_rtx (PLUS, Pmode, dest_reg, GEN_INT (offset));\n+\t    }\n+\n+\t  /* Generate the appropriate load and store, saving the stores for later */\n+\t  if (bytes >= 4 && (align >= 4 || !STRICT_ALIGNMENT))\n+\t    {\n+\t      move_bytes = 4;\n+\t      tmp_reg = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_movsi (tmp_reg, gen_rtx (MEM, SImode, src_addr)));\n+\t      stores[ num_reg++ ] = gen_movsi (gen_rtx (MEM, SImode, dest_addr), tmp_reg);\n+\t    }\n+\t  else if (bytes >= 2 && (align >= 2 || !STRICT_ALIGNMENT))\n+\t    {\n+\t      move_bytes = 2;\n+\t      tmp_reg = gen_reg_rtx (HImode);\n+\t      emit_insn (gen_movhi (tmp_reg, gen_rtx (MEM, HImode, src_addr)));\n+\t      stores[ num_reg++ ] = gen_movhi (gen_rtx (MEM, HImode, dest_addr), tmp_reg);\n+\t    }\n+\t  else\n+\t    {\n+\t      move_bytes = 1;\n+\t      tmp_reg = gen_reg_rtx (QImode);\n+\t      emit_insn (gen_movqi (tmp_reg, gen_rtx (MEM, QImode, src_addr)));\n+\t      stores[ num_reg++ ] = gen_movqi (gen_rtx (MEM, QImode, dest_addr), tmp_reg);\n+\t    }\n+\n+\t  if (num_reg >= MAX_MOVE_REG)\n+\t    {\n+\t      for (i = 0; i < num_reg; i++)\n+\t\temit_insn (stores[i]);\n+\t      num_reg = 0;\n \t    }\n \t}\n-      else if (bytes == 2 && (align >= 2 || !STRICT_ALIGNMENT))\n-\t{\t\t\t/* move 2 bytes */\n-\t  move_bytes = 2;\n-\t  tmp_reg = gen_reg_rtx (HImode);\n-\t  emit_move_insn (tmp_reg, gen_rtx (MEM, HImode, src_reg));\n-\t  emit_move_insn (gen_rtx (MEM, HImode, dest_reg), tmp_reg);\n-\t}\n-      else if (bytes == 1)\t/* move 1 byte */\n+\n+      if (num_reg > 0)\n \t{\n-\t  move_bytes = 1;\n-\t  tmp_reg = gen_reg_rtx (QImode);\n-\t  emit_move_insn (tmp_reg, gen_rtx (MEM, QImode, src_reg));\n-\t  emit_move_insn (gen_rtx (MEM, QImode, dest_reg), tmp_reg);\n-\t}\n-      else\n-\t{\t\t\t/* move up to 4 bytes at a time */\n-\t  move_bytes = (bytes > 4) ? 4 : bytes;\n-\t  emit_insn (gen_movstrsi_1reg (dest_reg,\n-\t\t\t\t\tsrc_reg,\n-\t\t\t\t\tGEN_INT (move_bytes),\n-\t\t\t\t\talign_rtx,\n-\t\t\t\t\tGEN_INT ((bytes > move_bytes) ? move_bytes : 0)));\n+\t  for (i = 0; i < num_reg; i++)\n+\t    emit_insn (stores[i]);\n \t}\n     }\n \n@@ -1936,6 +2017,16 @@ output_prolog (file, size)\n \t  asm_fprintf (file, \"\\t{cax|add} 30,0,30\\n\");\n \t  rs6000_pic_labelno++;\n \t}\n+      else if (TARGET_NO_TOC)\n+\t{\n+\t  ASM_GENERATE_INTERNAL_LABEL (buf, \"LCTOC\", 1);\n+\t  asm_fprintf (file, \"\\t{cau|addis} 30,0,\");\n+\t  assemble_name (file, buf);\n+\t  asm_fprintf (file, \"@ha\\n\");\n+\t  asm_fprintf (file, \"\\t{cal|addi} 30,30,\");\n+\t  assemble_name (file, buf);\n+\t  asm_fprintf (file, \"@l\\n\");\n+\t}\n       else\n #endif /* USING_SVR4_H */\n \t{"}, {"sha": "353b4a471d55ef98b5b845d6da58eb7c763965ba", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "patch": "@@ -279,16 +279,7 @@ extern char *rs6000_cpu_string;\n \n    On the RS/6000 this is used to define the target cpu type.  */\n \n-#define OVERRIDE_OPTIONS \\\n-do {\t\t\t\t\\\n-  rs6000_override_options ();\t\\\n-  SUBTARGET_OVERRIDE_OPTIONS;\t\\\n-} while (0)\n-\n-/* For OS-dependent options */\n-#ifndef SUBTARGET_OVERRIDE_OPTIONS\n-#define SUBTARGET_OVERRIDE_OPTIONS\n-#endif\n+#define OVERRIDE_OPTIONS rs6000_override_options ()\n \n /* Show we can debug even without a frame pointer.  */\n #define CAN_DEBUG_WITHOUT_FP"}, {"sha": "0da08d59ef007c82e3a5a5876ead20c02033951c", "filename": "gcc/config/rs6000/sysv4.h", "status": "modified", "additions": 38, "deletions": 3, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Fsysv4.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fsysv4.h?ref=3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "patch": "@@ -26,16 +26,19 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define MASK_RELOCATABLE\t0x10000000\t/* GOT pointers are PC relative */\n #define\tMASK_NO_TRACEBACK\t0x08000000\t/* eliminate traceback words */\n #define MASK_LITTLE_ENDIAN\t0x04000000\t/* target is little endian */\n+#define MASK_NO_TOC\t\t0x02000000\t/* do not use TOC for loading addresses */\n \n #define\tTARGET_NO_BITFIELD_TYPE\t(target_flags & MASK_NO_BITFIELD_TYPE)\n #define TARGET_STRICT_ALIGN\t(target_flags & MASK_STRICT_ALIGN)\n #define TARGET_RELOCATABLE\t(target_flags & MASK_RELOCATABLE)\n #define TARGET_NO_TRACEBACK\t(target_flags & MASK_NO_TRACEBACK)\n #define TARGET_LITTLE_ENDIAN\t(target_flags & MASK_LITTLE_ENDIAN)\n+#define TARGET_NO_TOC\t\t(target_flags & MASK_NO_TOC)\n \n #define\tTARGET_BITFIELD_TYPE\t(! TARGET_NO_BITFIELD_TYPE)\n #define\tTARGET_TRACEBACK\t(! TARGET_NO_TRACEBACK)\n #define TARGET_BIG_ENDIAN\t(! TARGET_LITTLE_ENDIAN)\n+#define TARGET_TOC\t\t(! TARGET_NO_TOC)\n \n #undef\tSUBTARGET_SWITCHES\n #define SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n@@ -50,7 +53,39 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n   { \"little-endian\",\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"little\",\t\t MASK_LITTLE_ENDIAN },\t\t\t\t\\\n   { \"big-endian\",\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n-  { \"big\",\t\t-MASK_LITTLE_ENDIAN },\n+  { \"big\",\t\t-MASK_LITTLE_ENDIAN },\t\t\t\t\\\n+  { \"no-toc\",\t\t MASK_NO_TOC | MASK_MINIMAL_TOC },\t\t\\\n+  { \"toc\",\t\t-MASK_NO_TOC },\n+\n+/* Sometimes certain combinations of command options do not make sense\n+   on a particular target machine.  You can define a macro\n+   `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n+   defined, is executed once just after all the command options have\n+   been parsed.\n+\n+   The macro SUBTARGET_OVERRIDE_OPTIONS is provided for subtargets, to\n+   get control.  */\n+\n+#define SUBTARGET_OVERRIDE_OPTIONS\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE && TARGET_NO_TOC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags &= ~ MASK_NO_TOC;\t\t\t\t\t\\\n+      error (\"-mrelocatable and -mno-toc are incompatible.\");\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_RELOCATABLE && !TARGET_MINIMAL_TOC)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n+      error (\"-mrelocatable and -mno-minimal-toc are incompatible.\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  if (TARGET_NO_TOC && !TARGET_MINIMAL_TOC)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      target_flags |= MASK_MINIMAL_TOC;\t\t\t\t\t\\\n+      error (\"-mno-toc and -mno-minimal-toc are incompatible.\");\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+} while (0)\n \n #include \"rs6000/powerpc.h\"\n \n@@ -152,12 +187,12 @@ toc_section ()\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       if (! toc_initialized)\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n-\t  if (!TARGET_RELOCATABLE)\t\t\t\t\t\\\n+\t  if (!TARGET_RELOCATABLE && !TARGET_NO_TOC)\t\t\t\\\n \t    fprintf (asm_out_file, \"%s\\n\", TOC_SECTION_ASM_OP);\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n \t  if (TARGET_MINIMAL_TOC)\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n-\t      if (!TARGET_RELOCATABLE)\t\t\t\t\t\\\n+\t      if (!TARGET_RELOCATABLE && !TARGET_NO_TOC)\t\t\\\n \t\t{\t\t\t\t\t\t\t\\\n \t\t  ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, \"LCTOC\", 0);\t\\\n \t\t  fprintf (asm_out_file, \"\\t.tc \");\t\t\t\\"}, {"sha": "aa87b5ee59d250818efac95eee2ceb077541f950", "filename": "gcc/config/rs6000/t-ppcgas", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3933e0e1e533707b2a0cdf3d03b73f4444ecfac2/gcc%2Fconfig%2Frs6000%2Ft-ppcgas", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-ppcgas?ref=3933e0e1e533707b2a0cdf3d03b73f4444ecfac2", "patch": "@@ -16,9 +16,11 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n # Build libgcc.a with different options.\n \n MULTILIB_OPTIONS\t= msoft-float \\\n+\t\t\t  mno-toc \\\n \t\t\t  mlittle/mbig\n \n MULTILIB_DIRNAMES\t= soft-float \\\n+\t\t\t  no-toc \\\n \t\t\t  little-endian big-endian\n \n MULTILIB_MATCHES\t= mlittle=mlittle-endian \\"}]}