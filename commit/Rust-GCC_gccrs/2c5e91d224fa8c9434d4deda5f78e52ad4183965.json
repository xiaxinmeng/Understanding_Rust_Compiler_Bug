{"sha": "2c5e91d224fa8c9434d4deda5f78e52ad4183965", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM1ZTkxZDIyNGZhOGM5NDM0ZDRkZWRhNWY3OGU1MmFkNDE4Mzk2NQ==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@cam.ac.uk", "date": "2001-01-27T21:29:53Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-01-27T21:29:53Z"}, "message": "* extend.texi (Attribute Syntax): New section.\n\nFrom-SVN: r39305", "tree": {"sha": "62993da9d282f83b81d04b435bea9fc7ec898532", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/62993da9d282f83b81d04b435bea9fc7ec898532"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c5e91d224fa8c9434d4deda5f78e52ad4183965", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5e91d224fa8c9434d4deda5f78e52ad4183965", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c5e91d224fa8c9434d4deda5f78e52ad4183965", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c5e91d224fa8c9434d4deda5f78e52ad4183965/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "825ac7041957e20307fd5a20ddd140b82d6899df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/825ac7041957e20307fd5a20ddd140b82d6899df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/825ac7041957e20307fd5a20ddd140b82d6899df"}], "stats": {"total": 190, "additions": 190, "deletions": 0}, "files": [{"sha": "ff12a3b855e101348c977b2c2249499796d7de3f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5e91d224fa8c9434d4deda5f78e52ad4183965/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5e91d224fa8c9434d4deda5f78e52ad4183965/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c5e91d224fa8c9434d4deda5f78e52ad4183965", "patch": "@@ -1,3 +1,7 @@\n+2001-01-27  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* extend.texi (Attribute Syntax): New section.\n+\n 2001-01-27  Michael Sokolov  <msokolov@ivan.Harhan.ORG>\n \n \t* fixproto: Correctly install synthesised unistd.h and stdlib.h when"}, {"sha": "0c42d959b3265581e99fe09339812cc2b910fd62", "filename": "gcc/extend.texi", "status": "modified", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c5e91d224fa8c9434d4deda5f78e52ad4183965/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c5e91d224fa8c9434d4deda5f78e52ad4183965/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=2c5e91d224fa8c9434d4deda5f78e52ad4183965", "patch": "@@ -56,6 +56,7 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n * Case Ranges::\t\t`case 1 ... 9' and such.\n * Function Attributes:: Declaring that functions have no side effects,\n                          or that they can never return.\n+* Attribute Syntax::    Formal syntax for attributes.\n * Function Prototypes:: Prototype declarations and old-style definitions.\n * C++ Comments::        C++ comments are recognized.\n * Dollar Signs::        Dollar sign is allowed in identifiers.\n@@ -105,6 +106,7 @@ C++ Language}, for extensions that apply @emph{only} to C++.\n * Case Ranges::\t\t`case 1 ... 9' and such.\n * Function Attributes:: Declaring that functions have no side effects,\n                          or that they can never return.\n+* Attribute Syntax::    Formal syntax for attributes.\n * Function Prototypes:: Prototype declarations and old-style definitions.\n * C++ Comments::        C++ comments are recognized.\n * Dollar Signs::        Dollar sign is allowed in identifiers.\n@@ -1505,6 +1507,9 @@ each keyword.  This allows you to use them in header files without\n being concerned about a possible macro of the same name.  For example,\n you may use @code{__noreturn__} instead of @code{noreturn}.\n \n+@xref{Attribute Syntax}, for details of the exact syntax for using\n+attributes.\n+\n @table @code\n @cindex @code{noreturn} function attribute\n @item noreturn\n@@ -1979,6 +1984,181 @@ attachment of attributes to their corresponding declarations, whereas\n part of the grammar.  @xref{Other Directives,,Miscellaneous\n Preprocessing Directives, cpp, The C Preprocessor}.\n \n+@node Attribute Syntax\n+@section Attribute Syntax\n+@cindex attribute syntax\n+\n+This section describes the syntax with which @code{__attribute__} may be\n+used, and the constructs to which attribute specifiers bind, for the C\n+language.  Some details may vary for C++ and Objective C.  Because of\n+infelicities in the grammar for attributes, some forms described here\n+may not be successfully parsed in all cases.\n+\n+@xref{Function Attributes}, for details of the semantics of attributes\n+applying to functions.  @xref{Variable Attributes}, for details of the\n+semantics of attributes applying to variables.  @xref{Type Attributes},\n+for details of the semantics of attributes applying to structure, union\n+and enumerated types.\n+\n+An @dfn{attribute specifier} is of the form\n+@code{__attribute__ ((@var{attribute-list}))}.  An @dfn{attribute list}\n+is a possibly empty comma-separated sequence of @dfn{attributes}, where\n+each attribute is one of the following:\n+\n+@itemize @bullet\n+@item\n+Empty.  Empty attributes are ignored.\n+\n+@item\n+A word (which may be an identifier such as @code{unused}, or a reserved\n+word such as @code{const}).\n+\n+@item\n+A word, followed by, in parentheses, parameters for the attribute.\n+These parameters take one of the following forms:\n+\n+@itemize @bullet\n+@item\n+An identifier.  For example, @code{mode} attributes use this form.\n+\n+@item\n+An identifier followed by a comma and a non-empty comma-separated list\n+of expressions.  For example, @code{format} attributes use this form.\n+\n+@item\n+A possibly empty comma-separated list of expressions.  For example,\n+@code{format_arg} attributes use this form with the list being a single\n+integer constant expression, and @code{alias} attributes use this form\n+with the list being a single string constant.\n+@end itemize\n+@end itemize\n+\n+An @dfn{attribute specifier list} is a sequence of one or more attribute\n+specifiers, not separated by any other tokens.\n+\n+An attribute specifier list may appear after the colon following a\n+label, other than a @code{case} or @code{default} label.  The only\n+attribute it makes sense to use after a label is @code{unused}.  This\n+feature is intended for code generated by programs which contains labels\n+that may be unused but which is compiled with @option{-Wall}.  It would\n+not normally be appropriate to use in it human-written code, though it\n+could be useful in cases where the code that jumps to the label is\n+contained within an @code{#ifdef} conditional.\n+\n+An attribute specifier list may appear as part of a @code{struct},\n+@code{union} or @code{enum} specifier.  It may go either immediately\n+after the @code{struct}, @code{union} or @code{enum} keyword, or after\n+the closing brace.  It is ignored if the content of the structure, union\n+or enumerated type is not defined in the specifier in which the\n+attribute specifier list is used---that is, in usages such as\n+@code{struct __attribute__((foo)) bar} with no following opening brace.\n+Where attribute specifiers follow the closing brace, they are considered\n+to relate to the structure, union or enumerated type defined, not to any\n+enclosing declaration the type specifier appears in, and the type\n+defined is not complete until after the attribute specifiers.\n+@c Otherwise, there would be the following problems: a shift/reduce\n+@c conflict between attributes binding the the struct/union/enum and\n+@c binding to the list of specifiers/qualifiers; and \"aligned\"\n+@c attributes could use sizeof for the structure, but the size could be\n+@c changed later by \"packed\" attributes.\n+\n+Otherwise, an attribute specifier appears as part of a declaration,\n+counting declarations of unnamed parameters and type names, and relates\n+to that declaration (which may be nested in another declaration, for\n+example in the case of a parameter declaration).  In future, attribute\n+specifiers in some places may however apply to a particular declarator\n+within a declaration instead; these cases are noted below.\n+\n+Any list of specifiers and qualifiers at the start of a declaration may\n+contain attribute specifiers, whether or not such a list may in that\n+context contain storage class specifiers.  (Some attributes, however,\n+are essentially in the nature of storage class specifiers, and only make\n+sense where storage class specifiers may be used; for example,\n+@code{section}.)  There is one necessary limitation to this syntax: the\n+first old-style parameter declaration in a function definition cannot\n+begin with an attribute specifier, because such an attribute applies to\n+the function instead by syntax described below (which, however, is not\n+yet implemented in this case).  In some other cases, attribute\n+specifiers are permitted by this grammar but not yet supported by the\n+compiler.  All attribute specifiers in this place relate to the\n+declaration as a whole.  In the obsolencent usage where a type of\n+@code{int} is implied by the absence of type specifiers, such a list of\n+specifiers and qualifiers may be an attribute specifier list with no\n+other specifiers or qualifiers.\n+\n+An attribute specifier list may appear immediately before a declarator\n+(other than the first) in a comma-separated list of declarators in a\n+declaration of more than one identifier using a single list of\n+specifiers and qualifiers.  At present, such attribute specifiers apply\n+not only to the identifier before whose declarator they appear, but to\n+all subsequent identifiers declared in that declaration, but in future\n+they may apply only to that single identifier.  For example, in\n+@code{__attribute__((noreturn)) void d0 (void),\n+__attribute__((format(printf, 1, 2))) d1 (const char *, ...), d2\n+(void)}, the @code{noreturn} attribute applies to all the functions\n+declared; the @code{format} attribute should only apply to @code{d1},\n+but at present applies to @code{d2} as well (and so causes an error).\n+\n+An attribute specifier list may appear immediately before the comma,\n+@code{=} or semicolon terminating the declaration of an identifier other\n+than a function definition.  At present, such attribute specifiers apply\n+to the declared object or function, but in future they may attach to the\n+outermost adjacent declarator.  In simple cases there is no difference,\n+but, for example, in @code{void (****f)(void)\n+__attribute__((noreturn));}, at present the @code{noreturn} attribute\n+applies to @code{f}, which causes a warning since @code{f} is not a\n+function, but in future it may apply to the function @code{****f}.  The\n+precise semantics of what attributes in such cases will apply to are not\n+yet specified.  Where an assembler name for an object or function is\n+specified (@pxref{Asm Labels}), at present the attribute must follow the\n+@code{asm} specification; in future, attributes before the @code{asm}\n+specification may apply to the adjacent declarator, and those after it\n+to the declared object or function.\n+\n+An attribute specifier list may, in future, be permitted to appear after\n+the declarator in a function definition (before any old-style parameter\n+declarations or the function body).\n+\n+An attribute specifier list may appear at the start of a nested\n+declarator.  At present, there are some limitations in this usage: the\n+attributes apply to the identifer declared, and to all subsequent\n+identifiers declared in that declaration (if it includes a\n+comma-separated list of declarators), rather than to a specific\n+declarator.  When attribute specifiers follow the @code{*} of a pointer\n+declarator, they must presently follow any type qualifiers present, and\n+cannot be mixed with them.  The following describes intended future\n+semantics which make this syntax more useful only.  It will make the\n+most sense if you are familiar with the formal specification of\n+declarators in the ISO C standard.\n+\n+Consider (as in C99 subclause 6.7.5 paragraph 4) a declaration @code{T\n+D1}, where @code{T} contains declaration specifiers that specify a type\n+@var{Type} (such as @code{int}) and @code{D1} is a declarator that\n+contains an identifier @var{ident}.  The type specified for @var{ident}\n+for derived declarators whose type does not include an attribute\n+specifier is as in the ISO C standard.\n+\n+If @code{D1} has the form @code{( @var{attribute-specifier-list} D )},\n+and the declaration @code{T D} specifies the type\n+``@var{derived-declarator-type-list} @var{Type}'' for @var{ident}, then\n+@code{T D1} specifies the type ``@var{derived-declarator-type-list}\n+@var{attribute-specifier-list} @var{Type}'' for @var{ident}.\n+\n+If @code{D1} has the form @code{*\n+@var{type-qualifier-and-attribute-specifier-list} D}, and the\n+declaration @code{T D} specifies the type\n+``@var{derived-declarator-type-list} @var{Type}'' for @var{ident}, then\n+@code{T D1} specifies the type ``@var{derived-declarator-type-list}\n+@var{type-qualifier-and-attribute-specifier-list} @var{Type}'' for\n+@var{ident}.\n+\n+For example, @code{void (__attribute__((noreturn)) ****f)();} specifies\n+the type ``pointer to pointer to pointer to pointer to non-returning\n+function returning @code{void}''.  As another example, @code{char\n+*__attribute__((aligned(8))) *f;} specifies the type ``pointer to\n+8-byte-aligned pointer to @code{char}''.  Note again that this describes\n+intended future semantics, not current implementation.\n+\n @node Function Prototypes\n @section Prototypes and Old-Style Function Definitions\n @cindex function prototype declarations\n@@ -2129,6 +2309,9 @@ each keyword.  This allows you to use them in header files without\n being concerned about a possible macro of the same name.  For example,\n you may use @code{__aligned__} instead of @code{aligned}.\n \n+@xref{Attribute Syntax}, for details of the exact syntax for using\n+attributes.\n+\n @table @code\n @cindex @code{aligned} attribute\n @item aligned (@var{alignment})\n@@ -2369,6 +2552,9 @@ brace of a definition.\n You may also specify attributes between the enum, struct or union\n tag and the name of the type rather than after the closing brace.\n \n+@xref{Attribute Syntax}, for details of the exact syntax for using\n+attributes.\n+\n @table @code\n @cindex @code{aligned} attribute\n @item aligned (@var{alignment})"}]}