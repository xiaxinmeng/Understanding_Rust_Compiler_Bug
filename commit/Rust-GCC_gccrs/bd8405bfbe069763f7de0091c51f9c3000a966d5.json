{"sha": "bd8405bfbe069763f7de0091c51f9c3000a966d5", "node_id": "C_kwDOANBUbNoAKGJkODQwNWJmYmUwNjk3NjNmN2RlMDA5MWM1MWY5YzMwMDBhOTY2ZDU", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2022-07-22T14:10:25Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-05T07:21:04Z"}, "message": "[Ada] Fix bogus discriminant check failure for type with predicate\n\nThis reorders the processing in Freeze_Entity_Checks so that building the\npredicate functions, which first requires building discriminated checking\nfunctions for record types with a variant part, is done after processing\nand checking this variant part.\n\ngcc/ada/\n\n\t* sem_ch13.adb (Freeze_Entity_Checks): Build predicate functions\n\tonly after checking the variant part of a record type, if any.", "tree": {"sha": "92f8fc530a1507e76c465ec977bb53126140fae9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92f8fc530a1507e76c465ec977bb53126140fae9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bd8405bfbe069763f7de0091c51f9c3000a966d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8405bfbe069763f7de0091c51f9c3000a966d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bd8405bfbe069763f7de0091c51f9c3000a966d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bd8405bfbe069763f7de0091c51f9c3000a966d5/comments", "author": null, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f3561c06465c9f4110bd483f35b97201825eec44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3561c06465c9f4110bd483f35b97201825eec44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3561c06465c9f4110bd483f35b97201825eec44"}], "stats": {"total": 267, "additions": 134, "deletions": 133}, "files": [{"sha": "2cdd1573e2173ad274f318b86d1385f32462ef65", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 134, "deletions": 133, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bd8405bfbe069763f7de0091c51f9c3000a966d5/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bd8405bfbe069763f7de0091c51f9c3000a966d5/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=bd8405bfbe069763f7de0091c51f9c3000a966d5", "patch": "@@ -12901,139 +12901,6 @@ package body Sem_Ch13 is\n \n       Inside_Freezing_Actions := Inside_Freezing_Actions - 1;\n \n-      --  If we have a type with predicates, build predicate function. This is\n-      --  not needed in the generic case, nor within e.g. TSS subprograms and\n-      --  other predefined primitives. For a derived type, ensure that the\n-      --  parent type is already frozen so that its predicate function has been\n-      --  constructed already. This is necessary if the parent is declared\n-      --  in a nested package and its own freeze point has not been reached.\n-\n-      if Is_Type (E)\n-        and then Nongeneric_Case\n-        and then Has_Predicates (E)\n-        and then Predicate_Check_In_Scope (N)\n-      then\n-         declare\n-            Atyp : constant Entity_Id := Nearest_Ancestor (E);\n-         begin\n-            if Present (Atyp)\n-              and then Has_Predicates (Atyp)\n-              and then not Is_Frozen (Atyp)\n-            then\n-               Freeze_Before (N, Atyp);\n-            end if;\n-         end;\n-\n-         --  Before we build a predicate function, ensure that discriminant\n-         --  checking functions are available. The predicate function might\n-         --  need to call these functions if the predicate references\n-         --  any components declared in a variant part.\n-         if Ekind (E) = E_Record_Type and then Has_Discriminants (E) then\n-            Build_Or_Copy_Discr_Checking_Funcs (Parent (E));\n-         end if;\n-\n-         Build_Predicate_Function (E, N);\n-      end if;\n-\n-      --  If type has delayed aspects, this is where we do the preanalysis at\n-      --  the freeze point, as part of the consistent visibility check. Note\n-      --  that this must be done after calling Build_Predicate_Function or\n-      --  Build_Invariant_Procedure since these subprograms fix occurrences of\n-      --  the subtype name in the saved expression so that they will not cause\n-      --  trouble in the preanalysis.\n-\n-      --  This is also not needed in the generic case\n-\n-      if Nongeneric_Case\n-        and then Has_Delayed_Aspects (E)\n-        and then Scope (E) = Current_Scope\n-      then\n-         declare\n-            Ritem : Node_Id;\n-\n-         begin\n-            --  Look for aspect specification entries for this entity\n-\n-            Ritem := First_Rep_Item (E);\n-            while Present (Ritem) loop\n-               if Nkind (Ritem) = N_Aspect_Specification\n-                 and then Entity (Ritem) = E\n-                 and then Is_Delayed_Aspect (Ritem)\n-               then\n-                  if Get_Aspect_Id (Ritem) in Aspect_CPU\n-                                            | Aspect_Dynamic_Predicate\n-                                            | Aspect_Predicate\n-                                            | Aspect_Static_Predicate\n-                                            | Aspect_Priority\n-                  then\n-                    --  Retrieve the visibility to components and discriminants\n-                    --  in order to properly analyze the aspects.\n-\n-                     Push_Type (E);\n-                     Check_Aspect_At_Freeze_Point (Ritem);\n-\n-                     --  In the case of predicate aspects, there will be\n-                     --  a corresponding Predicate pragma associated with\n-                     --  the aspect, and the expression of the pragma also\n-                     --  needs to be analyzed at this point, to ensure that\n-                     --  Save_Global_References will capture global refs in\n-                     --  expressions that occur in generic bodies, for proper\n-                     --  later resolution of the pragma in instantiations.\n-\n-                     if Is_Type (E)\n-                       and then Inside_A_Generic\n-                       and then Has_Predicates (E)\n-                       and then Present (Aspect_Rep_Item (Ritem))\n-                     then\n-                        declare\n-                           Pragma_Args : constant List_Id :=\n-                             Pragma_Argument_Associations\n-                               (Aspect_Rep_Item (Ritem));\n-                           Pragma_Expr : constant Node_Id :=\n-                             Expression (Next (First (Pragma_Args)));\n-                        begin\n-                           if Present (Pragma_Expr) then\n-                              Analyze_And_Resolve\n-                                (Pragma_Expr, Standard_Boolean);\n-                           end if;\n-                        end;\n-                     end if;\n-\n-                     Pop_Type (E);\n-\n-                  else\n-                     Check_Aspect_At_Freeze_Point (Ritem);\n-                  end if;\n-\n-               --  A pragma Predicate should be checked like one of the\n-               --  corresponding aspects, wrt possible misuse of ghost\n-               --  entities.\n-\n-               elsif Nkind (Ritem) = N_Pragma\n-                 and then No (Corresponding_Aspect (Ritem))\n-                 and then\n-                   Get_Pragma_Id (Pragma_Name (Ritem)) = Pragma_Predicate\n-               then\n-                  --  Retrieve the visibility to components and discriminants\n-                  --  in order to properly analyze the pragma.\n-\n-                  declare\n-                     Arg : constant Node_Id :=\n-                        Next (First (Pragma_Argument_Associations (Ritem)));\n-                  begin\n-                     Push_Type (E);\n-                     Preanalyze_Spec_Expression\n-                       (Expression (Arg), Standard_Boolean);\n-                     Pop_Type (E);\n-                  end;\n-               end if;\n-\n-               Next_Rep_Item (Ritem);\n-            end loop;\n-         end;\n-\n-      end if;\n-\n       --  For a record type, deal with variant parts. This has to be delayed to\n       --  this point, because of the issue of statically predicated subtypes,\n       --  which we have to ensure are frozen before checking choices, since we\n@@ -13199,6 +13066,140 @@ package body Sem_Ch13 is\n          end Check_Variant_Part;\n       end if;\n \n+      --  If we have a type with predicates, build predicate function. This is\n+      --  not needed in the generic case, nor within e.g. TSS subprograms and\n+      --  other predefined primitives. For a derived type, ensure that the\n+      --  parent type is already frozen so that its predicate function has been\n+      --  constructed already. This is necessary if the parent is declared\n+      --  in a nested package and its own freeze point has not been reached.\n+\n+      if Is_Type (E)\n+        and then Nongeneric_Case\n+        and then Has_Predicates (E)\n+        and then Predicate_Check_In_Scope (N)\n+      then\n+         declare\n+            Atyp : constant Entity_Id := Nearest_Ancestor (E);\n+\n+         begin\n+            if Present (Atyp)\n+              and then Has_Predicates (Atyp)\n+              and then not Is_Frozen (Atyp)\n+            then\n+               Freeze_Before (N, Atyp);\n+            end if;\n+         end;\n+\n+         --  Before we build a predicate function, ensure that discriminant\n+         --  checking functions are available. The predicate function might\n+         --  need to call these functions if the predicate references any\n+         --  components declared in a variant part.\n+\n+         if Ekind (E) = E_Record_Type and then Has_Discriminants (E) then\n+            Build_Or_Copy_Discr_Checking_Funcs (Parent (E));\n+         end if;\n+\n+         Build_Predicate_Function (E, N);\n+      end if;\n+\n+      --  If type has delayed aspects, this is where we do the preanalysis at\n+      --  the freeze point, as part of the consistent visibility check. Note\n+      --  that this must be done after calling Build_Predicate_Function or\n+      --  Build_Invariant_Procedure since these subprograms fix occurrences of\n+      --  the subtype name in the saved expression so that they will not cause\n+      --  trouble in the preanalysis.\n+\n+      --  This is also not needed in the generic case\n+\n+      if Nongeneric_Case\n+        and then Has_Delayed_Aspects (E)\n+        and then Scope (E) = Current_Scope\n+      then\n+         declare\n+            Ritem : Node_Id;\n+\n+         begin\n+            --  Look for aspect specification entries for this entity\n+\n+            Ritem := First_Rep_Item (E);\n+            while Present (Ritem) loop\n+               if Nkind (Ritem) = N_Aspect_Specification\n+                 and then Entity (Ritem) = E\n+                 and then Is_Delayed_Aspect (Ritem)\n+               then\n+                  if Get_Aspect_Id (Ritem) in Aspect_CPU\n+                                            | Aspect_Dynamic_Predicate\n+                                            | Aspect_Predicate\n+                                            | Aspect_Static_Predicate\n+                                            | Aspect_Priority\n+                  then\n+                    --  Retrieve the visibility to components and discriminants\n+                    --  in order to properly analyze the aspects.\n+\n+                     Push_Type (E);\n+                     Check_Aspect_At_Freeze_Point (Ritem);\n+\n+                     --  In the case of predicate aspects, there will be\n+                     --  a corresponding Predicate pragma associated with\n+                     --  the aspect, and the expression of the pragma also\n+                     --  needs to be analyzed at this point, to ensure that\n+                     --  Save_Global_References will capture global refs in\n+                     --  expressions that occur in generic bodies, for proper\n+                     --  later resolution of the pragma in instantiations.\n+\n+                     if Is_Type (E)\n+                       and then Inside_A_Generic\n+                       and then Has_Predicates (E)\n+                       and then Present (Aspect_Rep_Item (Ritem))\n+                     then\n+                        declare\n+                           Pragma_Args : constant List_Id :=\n+                             Pragma_Argument_Associations\n+                               (Aspect_Rep_Item (Ritem));\n+                           Pragma_Expr : constant Node_Id :=\n+                             Expression (Next (First (Pragma_Args)));\n+                        begin\n+                           if Present (Pragma_Expr) then\n+                              Analyze_And_Resolve\n+                                (Pragma_Expr, Standard_Boolean);\n+                           end if;\n+                        end;\n+                     end if;\n+\n+                     Pop_Type (E);\n+\n+                  else\n+                     Check_Aspect_At_Freeze_Point (Ritem);\n+                  end if;\n+\n+               --  A pragma Predicate should be checked like one of the\n+               --  corresponding aspects, wrt possible misuse of ghost\n+               --  entities.\n+\n+               elsif Nkind (Ritem) = N_Pragma\n+                 and then No (Corresponding_Aspect (Ritem))\n+                 and then\n+                   Get_Pragma_Id (Pragma_Name (Ritem)) = Pragma_Predicate\n+               then\n+                  --  Retrieve the visibility to components and discriminants\n+                  --  in order to properly analyze the pragma.\n+\n+                  declare\n+                     Arg : constant Node_Id :=\n+                        Next (First (Pragma_Argument_Associations (Ritem)));\n+                  begin\n+                     Push_Type (E);\n+                     Preanalyze_Spec_Expression\n+                       (Expression (Arg), Standard_Boolean);\n+                     Pop_Type (E);\n+                  end;\n+               end if;\n+\n+               Next_Rep_Item (Ritem);\n+            end loop;\n+         end;\n+      end if;\n+\n       if not In_Generic_Scope (E)\n         and then Ekind (E) = E_Record_Type\n         and then Is_Tagged_Type (E)"}]}