{"sha": "f19dd7b634dd0bfde776dd94db71e96fac162984", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE5ZGQ3YjYzNGRkMGJmZGU3NzZkZDk0ZGI3MWU5NmZhYzE2Mjk4NA==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-12-23T10:26:47Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2016-12-23T10:26:47Z"}, "message": "class_assign_1.f08: New test.\n\ngcc/testsuite/ChangeLog:\n\n2016-12-23  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.dg/class_assign_1.f08: New test.\n\n\ngcc/fortran/ChangeLog:\n\n2016-12-23  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* trans-expr.c (trans_class_assignment): Allocate memory of _vptr->size\n        before assigning an allocatable class object.\n\t(gfc_trans_assignment_1): Flag that (re-)alloc of the class object\n\tshall be done.\n\nFrom-SVN: r243909", "tree": {"sha": "d21bd72ca8eb170488bc606c6e10af7247000657", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d21bd72ca8eb170488bc606c6e10af7247000657"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f19dd7b634dd0bfde776dd94db71e96fac162984", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19dd7b634dd0bfde776dd94db71e96fac162984", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f19dd7b634dd0bfde776dd94db71e96fac162984", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f19dd7b634dd0bfde776dd94db71e96fac162984/comments", "author": null, "committer": null, "parents": [{"sha": "cca8d0b26549b5f3813178443a3a600aef104181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cca8d0b26549b5f3813178443a3a600aef104181", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cca8d0b26549b5f3813178443a3a600aef104181"}], "stats": {"total": 131, "additions": 115, "deletions": 16}, "files": [{"sha": "f34ec9aae64fd434a20db3aa7ccd3b9cbd9a7a15", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f19dd7b634dd0bfde776dd94db71e96fac162984", "patch": "@@ -1,3 +1,10 @@\n+2016-12-23  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* trans-expr.c (trans_class_assignment): Allocate memory of _vptr->size\n+        before assigning an allocatable class object.\n+\t(gfc_trans_assignment_1): Flag that (re-)alloc of the class object\n+\tshall be done.\n+\n 2016-12-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/78866"}, {"sha": "00fddfeda2289bda78791454cc86c5a65bc72728", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f19dd7b634dd0bfde776dd94db71e96fac162984", "patch": "@@ -9625,17 +9625,38 @@ is_runtime_conformable (gfc_expr *expr1, gfc_expr *expr2)\n \n static tree\n trans_class_assignment (stmtblock_t *block, gfc_expr *lhs, gfc_expr *rhs,\n-\t\t\tgfc_se *lse, gfc_se *rse, bool use_vptr_copy)\n+\t\t\tgfc_se *lse, gfc_se *rse, bool use_vptr_copy,\n+\t\t\tbool class_realloc)\n {\n-  tree tmp;\n-  tree fcn;\n-  tree stdcopy, to_len, from_len;\n+  tree tmp, fcn, stdcopy, to_len, from_len, vptr;\n   vec<tree, va_gc> *args = NULL;\n \n-  tmp = trans_class_vptr_len_assignment (block, lhs, rhs, rse, &to_len,\n+  vptr = trans_class_vptr_len_assignment (block, lhs, rhs, rse, &to_len,\n \t\t\t\t\t &from_len);\n \n-  fcn = gfc_vptr_copy_get (tmp);\n+  /* Generate allocation of the lhs.  */\n+  if (class_realloc)\n+    {\n+      stmtblock_t alloc;\n+      tree class_han;\n+\n+      tmp = gfc_vptr_size_get (vptr);\n+      class_han = GFC_CLASS_TYPE_P (TREE_TYPE (lse->expr))\n+\t  ? gfc_class_data_get (lse->expr) : lse->expr;\n+      gfc_init_block (&alloc);\n+      gfc_allocate_using_malloc (&alloc, class_han, tmp, NULL_TREE);\n+      tmp = fold_build2_loc (input_location, EQ_EXPR,\n+\t\t\t     boolean_type_node, class_han,\n+\t\t\t     build_int_cst (prvoid_type_node, 0));\n+      tmp = fold_build3_loc (input_location, COND_EXPR, void_type_node,\n+\t\t\t     gfc_unlikely (tmp,\n+\t\t\t\t\t   PRED_FORTRAN_FAIL_ALLOC),\n+\t\t\t     gfc_finish_block (&alloc),\n+\t\t\t     build_empty_stmt (input_location));\n+      gfc_add_expr_to_block (&lse->pre, tmp);\n+    }\n+\n+  fcn = gfc_vptr_copy_get (vptr);\n \n   tmp = GFC_CLASS_TYPE_P (TREE_TYPE (rse->expr))\n       ? gfc_class_data_get (rse->expr) : rse->expr;\n@@ -9961,15 +9982,10 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n     }\n \n   if (is_poly_assign)\n-    {\n-      tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n-\t\t\t\t    use_vptr_copy || (lhs_attr.allocatable\n-\t\t\t\t\t\t      && !lhs_attr.dimension));\n-      /* Modify the expr1 after the assignment, to allow the realloc below.\n-\t Therefore only needed, when realloc_lhs is enabled.  */\n-      if (flag_realloc_lhs && !lhs_attr.pointer)\n-\tgfc_add_data_component (expr1);\n-    }\n+    tmp = trans_class_assignment (&body, expr1, expr2, &lse, &rse,\n+\t\t\t\t  use_vptr_copy || (lhs_attr.allocatable\n+\t\t\t\t\t\t    && !lhs_attr.dimension),\n+\t\t\t\t  flag_realloc_lhs && !lhs_attr.pointer);\n   else if (flag_coarray == GFC_FCOARRAY_LIB\n \t   && lhs_caf_attr.codimension && rhs_caf_attr.codimension\n \t   && ((lhs_caf_attr.allocatable && lhs_refs_comp)\n@@ -10011,7 +10027,8 @@ gfc_trans_assignment_1 (gfc_expr * expr1, gfc_expr * expr2, bool init_flag,\n   if (lss == gfc_ss_terminator)\n     {\n       /* F2003: Add the code for reallocation on assignment.  */\n-      if (flag_realloc_lhs && is_scalar_reallocatable_lhs (expr1))\n+      if (flag_realloc_lhs && is_scalar_reallocatable_lhs (expr1)\n+\t  && !is_poly_assign)\n \talloc_scalar_allocatable_for_assignment (&block, string_length,\n \t\t\t\t\t\t expr1, expr2);\n "}, {"sha": "969c896af40bb7983b61a5b1438fc8692c65fae3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f19dd7b634dd0bfde776dd94db71e96fac162984", "patch": "@@ -1,3 +1,7 @@\n+2016-12-23  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.dg/class_assign_1.f08: New test.\n+\n 2016-12-23  Toma Tabacu  <toma.tabacu@imgtec.com>\n \n \t* gcc.target/mips/oddspreg-2.c (dg-options): Remove dg-skip-if for"}, {"sha": "fb1f655464e54f291b3d5b5af47384bd5d084a9a", "filename": "gcc/testsuite/gfortran.dg/class_assign_1.f08", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f19dd7b634dd0bfde776dd94db71e96fac162984/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fclass_assign_1.f08?ref=f19dd7b634dd0bfde776dd94db71e96fac162984", "patch": "@@ -0,0 +1,71 @@\n+! { dg-do run }\n+!\n+! Check that reallocation of the lhs is done with the correct memory size.\n+\n+\n+module base_mod\n+\n+  type, abstract :: base\n+  contains\n+    procedure(base_add), deferred :: add\n+    generic :: operator(+) => add\n+  end type base\n+\n+  abstract interface\n+    module function base_add(l, r) result(res)\n+      class(base), intent(in) :: l\n+      integer, intent(in) :: r\n+      class(base), allocatable :: res\n+    end function base_add\n+  end interface\n+\n+contains\n+\n+  subroutine foo(x)\n+    class(base), intent(inout), allocatable :: x\n+    class(base), allocatable :: t\n+\n+    t = x + 2\n+    x = t + 40\n+  end subroutine foo\n+\n+end module base_mod\n+\n+module extend_mod\n+  use base_mod\n+\n+  type, extends(base) :: extend\n+    integer :: i\n+  contains\n+    procedure :: add\n+  end type extend\n+\n+contains\n+  module function add(l, r) result(res)\n+    class(extend), intent(in) :: l\n+    integer, intent(in) :: r\n+    class(base), allocatable :: res\n+    select type (l)\n+      class is (extend)\n+        res = extend(l%i + r)\n+      class default\n+        error stop \"Unkown class to add to.\"\n+    end select\n+  end function\n+end module extend_mod\n+\n+program test_poly_ass\n+  use extend_mod\n+  use base_mod\n+\n+  class(base), allocatable :: obj\n+  obj = extend(0)\n+  call foo(obj)\n+  select type (obj)\n+    class is (extend)\n+      if (obj%i /= 42) error stop\n+    class default\n+      error stop \"Result's type wrong.\"\n+  end select\n+end program test_poly_ass\n+"}]}