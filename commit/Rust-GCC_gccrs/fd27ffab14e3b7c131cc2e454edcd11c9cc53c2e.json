{"sha": "fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmQyN2ZmYWIxNGUzYjdjMTMxY2MyZTQ1NGVkY2QxMWM5Y2M1M2MyZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2014-11-24T10:41:18Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2014-11-24T10:41:18Z"}, "message": "[PATCH 1/2] Negative numbers added for sreal class.\n\n\t* predict.c (propagate_freq): More elegant sreal API is used.\n\t(estimate_bb_frequencies): Precomputed constants replaced by integer\n\tconstants.\n\t* sreal.c (sreal::normalize): New function.\n\t(sreal::to_int): Likewise.\n\t(sreal::operator+): Likewise.\n\t(sreal::operator-): Likewise.\n\t(sreal::signedless_plus): Likewise.\n\t(sreal::signedless_minus): Likewise.\n\t(sreal::operator/): Negative number support is added.\n\t* sreal.h: Definition of new functions added.\n\t(inline sreal operator<<): New function.\n\t(inline sreal operator>>): Likewise.\n\nFrom-SVN: r218008", "tree": {"sha": "fc054fc4a4670f251324a07ce04dee2b8dc12fa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc054fc4a4670f251324a07ce04dee2b8dc12fa8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6a569cdda92269d42ae8e2cccd8c0f07d39b5d0c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a569cdda92269d42ae8e2cccd8c0f07d39b5d0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a569cdda92269d42ae8e2cccd8c0f07d39b5d0c"}], "stats": {"total": 242, "additions": 190, "deletions": 52}, "files": [{"sha": "48dccf32d8e890aee83063292064f28f2cb96a92", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "patch": "@@ -1,3 +1,19 @@\n+2014-11-24  Martin Liska  <mliska@suse.cz>\n+\n+\t* predict.c (propagate_freq): More elegant sreal API is used.\n+\t(estimate_bb_frequencies): Precomputed constants replaced by integer\n+\tconstants.\n+\t* sreal.c (sreal::normalize): New function.\n+\t(sreal::to_int): Likewise.\n+\t(sreal::operator+): Likewise.\n+\t(sreal::operator-): Likewise.\n+\t(sreal::signedless_plus): Likewise.\n+\t(sreal::signedless_minus): Likewise.\n+\t(sreal::operator/): Negative number support is added.\n+\t* sreal.h: Definition of new functions added.\n+\t(inline sreal operator<<): New function.\n+\t(inline sreal operator>>): Likewise.\n+\n 2014-11-24  Kyrylo Tkachov  <kyrylo.tkachov@arm.com>\n \n \t* config/aarch64/aarch64-protos.h (struct tune_params): Add"}, {"sha": "0cfe4a93a31b67c32cfc5f9be6a12d63bd9e3858", "filename": "gcc/predict.c", "status": "modified", "additions": 14, "deletions": 16, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "patch": "@@ -82,7 +82,7 @@ along with GCC; see the file COPYING3.  If not see\n \n /* real constants: 0, 1, 1-1/REG_BR_PROB_BASE, REG_BR_PROB_BASE,\n \t\t   1/REG_BR_PROB_BASE, 0.5, BB_FREQ_MAX.  */\n-static sreal real_zero, real_one, real_almost_one, real_br_prob_base,\n+static sreal real_almost_one, real_br_prob_base,\n \t     real_inv_br_prob_base, real_one_half, real_bb_freq_max;\n \n static void combine_predictions_for_insn (rtx_insn *, basic_block);\n@@ -2541,13 +2541,13 @@ propagate_freq (basic_block head, bitmap tovisit)\n \tbb->count = bb->frequency = 0;\n     }\n \n-  BLOCK_INFO (head)->frequency = real_one;\n+  BLOCK_INFO (head)->frequency = 1;\n   last = head;\n   for (bb = head; bb; bb = nextbb)\n     {\n       edge_iterator ei;\n-      sreal cyclic_probability = real_zero;\n-      sreal frequency = real_zero;\n+      sreal cyclic_probability = 0;\n+      sreal frequency = 0;\n \n       nextbb = BLOCK_INFO (bb)->next;\n       BLOCK_INFO (bb)->next = NULL;\n@@ -2572,13 +2572,13 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t\t\t\t  * BLOCK_INFO (e->src)->frequency /\n \t\t\t\t  REG_BR_PROB_BASE);  */\n \n-\t\tsreal tmp (e->probability, 0);\n+\t\tsreal tmp = e->probability;\n \t\ttmp *= BLOCK_INFO (e->src)->frequency;\n \t\ttmp *= real_inv_br_prob_base;\n \t\tfrequency += tmp;\n \t      }\n \n-\t  if (cyclic_probability == real_zero)\n+\t  if (cyclic_probability == 0)\n \t    {\n \t      BLOCK_INFO (bb)->frequency = frequency;\n \t    }\n@@ -2590,7 +2590,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t      /* BLOCK_INFO (bb)->frequency = frequency\n \t\t\t\t\t      / (1 - cyclic_probability) */\n \n-\t      cyclic_probability = real_one - cyclic_probability;\n+\t      cyclic_probability = sreal (1) - cyclic_probability;\n \t      BLOCK_INFO (bb)->frequency = frequency / cyclic_probability;\n \t    }\n \t}\n@@ -2604,7 +2604,7 @@ propagate_freq (basic_block head, bitmap tovisit)\n \t     = ((e->probability * BLOCK_INFO (bb)->frequency)\n \t     / REG_BR_PROB_BASE); */\n \n-\t  sreal tmp (e->probability, 0);\n+\t  sreal tmp = e->probability;\n \t  tmp *= BLOCK_INFO (bb)->frequency;\n \t  EDGE_INFO (e)->back_edge_prob = tmp * real_inv_br_prob_base;\n \t}\n@@ -2886,13 +2886,11 @@ estimate_bb_frequencies (bool force)\n       if (!real_values_initialized)\n         {\n \t  real_values_initialized = 1;\n-\t  real_zero = sreal (0, 0);\n-\t  real_one = sreal (1, 0);\n-\t  real_br_prob_base = sreal (REG_BR_PROB_BASE, 0);\n-\t  real_bb_freq_max = sreal (BB_FREQ_MAX, 0);\n+\t  real_br_prob_base = REG_BR_PROB_BASE;\n+\t  real_bb_freq_max = BB_FREQ_MAX;\n \t  real_one_half = sreal (1, -1);\n-\t  real_inv_br_prob_base = real_one / real_br_prob_base;\n-\t  real_almost_one = real_one - real_inv_br_prob_base;\n+\t  real_inv_br_prob_base = sreal (1) / real_br_prob_base;\n+\t  real_almost_one = sreal (1) - real_inv_br_prob_base;\n \t}\n \n       mark_dfs_back_edges ();\n@@ -2910,7 +2908,7 @@ estimate_bb_frequencies (bool force)\n \n \t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      EDGE_INFO (e)->back_edge_prob = sreal (e->probability, 0);\n+\t      EDGE_INFO (e)->back_edge_prob = e->probability;\n \t      EDGE_INFO (e)->back_edge_prob *= real_inv_br_prob_base;\n \t    }\n \t}\n@@ -2919,7 +2917,7 @@ estimate_bb_frequencies (bool force)\n          to outermost to examine frequencies for back edges.  */\n       estimate_loops ();\n \n-      freq_max = real_zero;\n+      freq_max = 0;\n       FOR_EACH_BB_FN (bb, cfun)\n \tif (freq_max < BLOCK_INFO (bb)->frequency)\n \t  freq_max = BLOCK_INFO (bb)->frequency;"}, {"sha": "0337f9e540c694ac255d90ad2049261318be563b", "filename": "gcc/sreal.c", "status": "modified", "additions": 87, "deletions": 27, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fsreal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fsreal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.c?ref=fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "patch": "@@ -1,4 +1,4 @@\n-/* Simple data type for positive real numbers for the GNU compiler.\n+/* Simple data type for real numbers for the GNU compiler.\n    Copyright (C) 2002-2014 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -17,7 +17,7 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* This library supports positive real numbers and 0;\n+/* This library supports real numbers;\n    inf and nan are NOT supported.\n    It is written to be simple and fast.\n \n@@ -82,12 +82,12 @@ debug (sreal *ptr)\n void\n sreal::shift_right (int s)\n {\n-  gcc_assert (s > 0);\n-  gcc_assert (s <= SREAL_BITS);\n+  gcc_checking_assert (s > 0);\n+  gcc_checking_assert (s <= SREAL_BITS);\n   /* Exponent should never be so large because shift_right is used only by\n      sreal_add and sreal_sub ant thus the number cannot be shifted out from\n      exponent range.  */\n-  gcc_assert (m_exp + s <= SREAL_MAX_EXP);\n+  gcc_checking_assert (m_exp + s <= SREAL_MAX_EXP);\n \n   m_exp += s;\n \n@@ -102,6 +102,7 @@ sreal::normalize ()\n {\n   if (m_sig == 0)\n     {\n+      m_negative = 0;\n       m_exp = -SREAL_MAX_EXP;\n     }\n   else if (m_sig < SREAL_MIN_SIG)\n@@ -153,34 +154,58 @@ sreal::normalize ()\n int64_t\n sreal::to_int () const\n {\n+  int64_t sign = m_negative ? -1 : 1;\n+\n   if (m_exp <= -SREAL_BITS)\n     return 0;\n   if (m_exp >= SREAL_PART_BITS)\n-    return INTTYPE_MAXIMUM (int64_t);\n+    return sign * INTTYPE_MAXIMUM (int64_t);\n   if (m_exp > 0)\n-    return m_sig << m_exp;\n+    return sign * (m_sig << m_exp);\n   if (m_exp < 0)\n-    return m_sig >> -m_exp;\n-  return m_sig;\n+    return sign * (m_sig >> -m_exp);\n+  return sign * m_sig;\n }\n \n /* Return *this + other.  */\n \n sreal\n sreal::operator+ (const sreal &other) const\n {\n-  int dexp;\n-  sreal tmp, r;\n-const sreal *a_p = this, *b_p = &other, *bb;\n+  const sreal *a_p = this, *b_p = &other;\n \n-  if (*a_p < *b_p)\n+  if (a_p->m_negative && !b_p->m_negative)\n+    std::swap (a_p, b_p);\n+\n+  /* a + -b => a - b.  */\n+  if (!a_p->m_negative && b_p->m_negative)\n     {\n-      const sreal *swap;\n-      swap = a_p;\n-      a_p = b_p;\n-      b_p = swap;\n+      sreal tmp = -(*b_p);\n+      if (*a_p < tmp)\n+\treturn signedless_minus (tmp, *a_p, false);\n+      else\n+\treturn signedless_minus (*a_p, tmp, true);\n     }\n \n+  gcc_checking_assert (a_p->m_negative == b_p->m_negative);\n+\n+  sreal r = signedless_plus (*a_p, *b_p, a_p->m_negative);\n+\n+  return r;\n+}\n+\n+sreal\n+sreal::signedless_plus (const sreal &a, const sreal &b, bool negative)\n+{\n+  const sreal *bb;\n+  sreal r, tmp;\n+  int dexp;\n+  const sreal *a_p = &a;\n+  const sreal *b_p = &b;\n+\n+  if (*a_p < *b_p)\n+    std::swap (a_p, b_p);\n+\n   dexp = a_p->m_exp - b_p->m_exp;\n   r.m_exp = a_p->m_exp;\n   if (dexp > SREAL_BITS)\n@@ -200,38 +225,70 @@ const sreal *a_p = this, *b_p = &other, *bb;\n \n   r.m_sig = a_p->m_sig + bb->m_sig;\n   r.normalize ();\n+\n+  r.m_negative = negative;\n   return r;\n }\n \n /* Return *this - other.  */\n \n sreal\n sreal::operator- (const sreal &other) const\n+{\n+  /* -a - b => -a + (-b).  */\n+  if (m_negative && !other.m_negative)\n+    return signedless_plus (*this, -other, true);\n+\n+  /* a - (-b) => a + b.  */\n+  if (!m_negative && other.m_negative)\n+    return signedless_plus (*this, -other, false);\n+\n+  gcc_checking_assert (m_negative == other.m_negative);\n+\n+  /* We want to substract a smaller number from bigger\n+    for nonegative numbers.  */\n+  if (!m_negative && *this < other)\n+    return -signedless_minus (other, *this, true);\n+\n+  /* Example: -2 - (-3) => 3 - 2 */\n+  if (m_negative && *this > other)\n+    return signedless_minus (-other, -(*this), true);\n+\n+  sreal r = signedless_minus (*this, other, m_negative);\n+\n+  return r;\n+}\n+\n+sreal\n+sreal::signedless_minus (const sreal &a, const sreal &b, bool negative)\n {\n   int dexp;\n   sreal tmp, r;\n   const sreal *bb;\n+  const sreal *a_p = &a;\n+  const sreal *b_p = &b;\n \n-  gcc_assert (*this >= other);\n+  dexp = a_p->m_exp - b_p->m_exp;\n \n-  dexp = m_exp - other.m_exp;\n-  r.m_exp = m_exp;\n+  r.m_exp = a_p->m_exp;\n   if (dexp > SREAL_BITS)\n     {\n-      r.m_sig = m_sig;\n+      r.m_sig = a_p->m_sig;\n       return r;\n     }\n   if (dexp == 0)\n-    bb = &other;\n+    bb = b_p;\n   else\n     {\n-      tmp = other;\n+      tmp = *b_p;\n       tmp.shift_right (dexp);\n       bb = &tmp;\n     }\n \n-  r.m_sig = m_sig - bb->m_sig;\n+  r.m_sig = a_p->m_sig - bb->m_sig;\n   r.normalize ();\n+\n+  r.m_negative = negative;\n   return r;\n }\n \n@@ -240,7 +297,7 @@ sreal::operator- (const sreal &other) const\n sreal\n sreal::operator* (const sreal &other) const\n {\n-sreal r;\n+  sreal r;\n   if (m_sig < SREAL_MIN_SIG || other.m_sig < SREAL_MIN_SIG)\n     {\n       r.m_sig = 0;\n@@ -252,6 +309,8 @@ sreal r;\n       r.m_exp = m_exp + other.m_exp;\n       r.normalize ();\n     }\n+\n+  r.m_negative = m_negative ^ other.m_negative;\n   return r;\n }\n \n@@ -260,10 +319,11 @@ sreal r;\n sreal\n sreal::operator/ (const sreal &other) const\n {\n-  gcc_assert (other.m_sig != 0);\n-sreal r;\n+  gcc_checking_assert (other.m_sig != 0);\n+  sreal r;\n   r.m_sig = (m_sig << SREAL_PART_BITS) / other.m_sig;\n   r.m_exp = m_exp - other.m_exp - SREAL_PART_BITS;\n+  r.m_negative = m_negative ^ other.m_negative;\n   r.normalize ();\n   return r;\n }"}, {"sha": "1362bf66866af2083148f29dce4dfb3190269988", "filename": "gcc/sreal.h", "status": "modified", "additions": 73, "deletions": 9, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fsreal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e/gcc%2Fsreal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsreal.h?ref=fd27ffab14e3b7c131cc2e454edcd11c9cc53c2e", "patch": "@@ -1,4 +1,4 @@\n-/* Definitions for simple data type for positive real numbers.\n+/* Definitions for simple data type for real numbers.\n    Copyright (C) 2002-2014 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n /* SREAL_PART_BITS has to be an even number.  */\n #define SREAL_PART_BITS 32\n \n+#define UINT64_BITS\t64\n+\n #define SREAL_MIN_SIG ((uint64_t) 1 << (SREAL_PART_BITS - 1))\n #define SREAL_MAX_SIG (((uint64_t) 1 << SREAL_PART_BITS) - 1)\n #define SREAL_MAX_EXP (INT_MAX / 4)\n@@ -34,36 +36,88 @@ class sreal\n {\n public:\n   /* Construct an uninitialized sreal.  */\n-  sreal () : m_sig (-1), m_exp (-1) {}\n+  sreal () : m_sig (-1), m_exp (-1), m_negative (0) {}\n \n   /* Construct a sreal.  */\n-  sreal (uint64_t sig, int exp) : m_sig (sig), m_exp (exp) { normalize (); }\n+  sreal (int64_t sig, int exp = 0) : m_exp (exp)\n+  {\n+    m_negative = sig < 0;\n+\n+    if (sig < 0)\n+      sig = -sig;\n+\n+    m_sig = (uint64_t) sig;\n+\n+    normalize ();\n+  }\n \n   void dump (FILE *) const;\n   int64_t to_int () const;\n-\n   sreal operator+ (const sreal &other) const;\n   sreal operator- (const sreal &other) const;\n   sreal operator* (const sreal &other) const;\n   sreal operator/ (const sreal &other) const;\n \n   bool operator< (const sreal &other) const\n   {\n-    return m_exp < other.m_exp\n+    if (m_negative != other.m_negative)\n+      return m_negative > other.m_negative;\n+\n+    bool r = m_exp < other.m_exp\n       || (m_exp == other.m_exp && m_sig < other.m_sig);\n+\n+    return m_negative ? !r : r;\n   }\n \n   bool operator== (const sreal &other) const\n   {\n-    return m_exp == other.m_exp && m_sig == other.m_sig;\n+    return m_exp == other.m_exp && m_sig == other.m_sig\n+\t\t    && m_negative == other.m_negative;\n+  }\n+\n+  sreal operator- () const\n+  {\n+    if (m_sig == 0)\n+      return *this;\n+\n+    sreal tmp = *this;\n+    tmp.m_negative = !tmp.m_negative;\n+\n+    return tmp;\n+  }\n+\n+  sreal shift (int sig) const\n+  {\n+    sreal tmp = *this;\n+    tmp.m_sig += sig;\n+\n+    return tmp;\n+  }\n+\n+  /* Global minimum sreal can hold.  */\n+  inline static sreal min ()\n+  {\n+    static sreal min = sreal (-SREAL_MAX_SIG, SREAL_MAX_EXP);\n+    return min;\n+  }\n+\n+  /* Global minimum sreal can hold.  */\n+  inline static sreal max ()\n+  {\n+    static sreal max = sreal (SREAL_MAX_SIG, SREAL_MAX_EXP);\n+    return max;\n   }\n \n private:\n   void normalize ();\n   void shift_right (int amount);\n \n-  uint64_t m_sig;\t\t/* Significant.  */\n+  static sreal signedless_plus (const sreal &a, const sreal &b, bool negative);\n+  static sreal signedless_minus (const sreal &a, const sreal &b, bool negative);\n+\n+  uint64_t m_sig;\t\t\t/* Significant.  */\n   signed int m_exp;\t\t\t/* Exponent.  */\n+  bool m_negative;\t\t\t/* Negative sign.  */\n };\n \n extern void debug (sreal &ref);\n@@ -76,12 +130,12 @@ inline sreal &operator+= (sreal &a, const sreal &b)\n \n inline sreal &operator-= (sreal &a, const sreal &b)\n {\n-return a = a - b;\n+  return a = a - b;\n }\n \n inline sreal &operator/= (sreal &a, const sreal &b)\n {\n-return a = a / b;\n+  return a = a / b;\n }\n \n inline sreal &operator*= (sreal &a, const sreal &b)\n@@ -109,4 +163,14 @@ inline bool operator>= (const sreal &a, const sreal &b)\n   return a == b || a > b;\n }\n \n+inline sreal operator<< (const sreal &a, int exp)\n+{\n+  return a.shift (exp);\n+}\n+\n+inline sreal operator>> (const sreal &a, int exp)\n+{\n+  return a.shift (-exp);\n+}\n+\n #endif"}]}