{"sha": "4c9db6e07aba115c21ab02068ccc332ce691775e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM5ZGI2ZTA3YWJhMTE1YzIxYWIwMjA2OGNjYzMzMmNlNjkxNzc1ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2008-04-14T19:18:31Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2008-04-14T19:18:31Z"}, "message": "flags.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Define.\n\ngcc/:\n\t* flags.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Define.\n\t* fold-const.c (fold_comparison): If appropriate, test\n\tPOINTER_TYPE_OVERFLOW_UNDEFINED, and issue an overflow warning.\n\t(fold_binary): Test POINTER_TYPE_OVERFLOW_UNDEFINED when\n\treassociating a pointer type.\n\t* doc/invoke.texi (Optimize Options): Document that\n\t-fstrict-overflow applies to pointer wraparound.\ngcc/testsuite/:\n\t* gcc.dg/strict-overflow-6.c: New.\n\t* gcc.dg/no-strict-overflow-7.c: New.\n\t* gcc.dg/Wstrict-overflow-22.c: New.\n\nFrom-SVN: r134287", "tree": {"sha": "5476839d99a5b4e7b501ffa138ec06b5cc5cb144", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5476839d99a5b4e7b501ffa138ec06b5cc5cb144"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c9db6e07aba115c21ab02068ccc332ce691775e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9db6e07aba115c21ab02068ccc332ce691775e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c9db6e07aba115c21ab02068ccc332ce691775e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c9db6e07aba115c21ab02068ccc332ce691775e/comments", "author": null, "committer": null, "parents": [{"sha": "3a5a8be12000125f4c12efea8bd6a466049a688d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a5a8be12000125f4c12efea8bd6a466049a688d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a5a8be12000125f4c12efea8bd6a466049a688d"}], "stats": {"total": 95, "additions": 88, "deletions": 7}, "files": [{"sha": "d6c2be3715a4ae9f2469f53cf2be1a3255ecf254", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -1,3 +1,13 @@\n+2008-04-14  Ian Lance Taylor  <iant@google.com>\n+\n+\t* flags.h (POINTER_TYPE_OVERFLOW_UNDEFINED): Define.\n+\t* fold-const.c (fold_comparison): If appropriate, test\n+\tPOINTER_TYPE_OVERFLOW_UNDEFINED, and issue an overflow warning.\n+\t(fold_binary): Test POINTER_TYPE_OVERFLOW_UNDEFINED when\n+\treassociating a pointer type.\n+\t* doc/invoke.texi (Optimize Options): Document that\n+\t-fstrict-overflow applies to pointer wraparound.\n+\n 2008-04-13  Jan Hubicka  <jh@suse.cz>\n \n \t* m32.c (m32c_pushm_popm): Use crtl->retrun_rtx."}, {"sha": "bb7be99e7d23a3c0d3d79cd5bfae576e2d495b70", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -6161,13 +6161,22 @@ using twos complement arithmetic.  When this option is in effect any\n attempt to determine whether an operation on signed numbers will\n overflow must be written carefully to not actually involve overflow.\n \n+This option also allows the compiler to assume strict pointer\n+semantics: given a pointer to an object, if adding an offset to that\n+pointer does not produce a pointer to the same object, the addition is\n+undefined.  This permits the compiler to conclude that @code{p + u >\n+p} is always true for a pointer @code{p} and unsigned integer\n+@code{u}.  This assumption is only valid because pointer wraparound is\n+undefined, as the expression is false if @code{p + u} overflows using\n+twos complement arithmetic.\n+\n See also the @option{-fwrapv} option.  Using @option{-fwrapv} means\n-that signed overflow is fully defined: it wraps.  When\n+that integer signed overflow is fully defined: it wraps.  When\n @option{-fwrapv} is used, there is no difference between\n-@option{-fstrict-overflow} and @option{-fno-strict-overflow}.  With\n-@option{-fwrapv} certain types of overflow are permitted.  For\n-example, if the compiler gets an overflow when doing arithmetic on\n-constants, the overflowed value can still be used with\n+@option{-fstrict-overflow} and @option{-fno-strict-overflow} for\n+integers.  With @option{-fwrapv} certain types of overflow are\n+permitted.  For example, if the compiler gets an overflow when doing\n+arithmetic on constants, the overflowed value can still be used with\n @option{-fwrapv}, but not otherwise.\n \n The @option{-fstrict-overflow} option is enabled at levels"}, {"sha": "e7596957d82a827538b3e37727cc38db98ba8ecd", "filename": "gcc/flags.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -332,6 +332,9 @@ extern bool flag_instrument_functions_exclude_p (tree fndecl);\n #define TYPE_OVERFLOW_TRAPS(TYPE) \\\n   (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n \n+/* True if pointer types have undefined overflow.  */\n+#define POINTER_TYPE_OVERFLOW_UNDEFINED (flag_strict_overflow)\n+\n /* Names for the different levels of -Wstrict-overflow=N.  The numeric\n    values here correspond to N.  */\n "}, {"sha": "ce5673e087cd82bf0791bcfda0558aa064bc4a14", "filename": "gcc/fold-const.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -8568,7 +8568,9 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t     because pointer arithmetic is restricted to retain within an\n \t     object and overflow on pointer differences is undefined as of\n \t     6.5.6/8 and /9 with respect to the signed ptrdiff_t.  */\n-\t  else if (bitpos0 == bitpos1)\n+\t  else if (bitpos0 == bitpos1\n+\t\t   && ((code == EQ_EXPR || code == NE_EXPR)\n+\t\t       || POINTER_TYPE_OVERFLOW_UNDEFINED))\n \t    {\n \t      tree signed_size_type_node;\n \t      signed_size_type_node = signed_type_for (size_type_node);\n@@ -8587,6 +8589,12 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t      else\n \t\toffset1 = fold_convert (signed_size_type_node, offset1);\n \n+\t      if (code != EQ_EXPR && code != NE_EXPR)\n+\t\tfold_overflow_warning ((\"assuming pointer wraparound does not \"\n+\t\t\t\t\t\"occur when comparing P +- C1 with \"\n+\t\t\t\t\t\"P +- C2\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_COMPARISON);\n+\n \t      return fold_build2 (code, type, offset0, offset1);\n \t    }\n \t}\n@@ -9711,7 +9719,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n \t  /* With undefined overflow we can only associate constants\n \t     with one variable.  */\n-\t  if ((POINTER_TYPE_P (type)\n+\t  if (((POINTER_TYPE_P (type) && POINTER_TYPE_OVERFLOW_UNDEFINED)\n \t       || (INTEGRAL_TYPE_P (type) && !TYPE_OVERFLOW_WRAPS (type)))\n \t      && var0 && var1)\n \t    {"}, {"sha": "d87b121e885a9d2e61ad0000d059b32071466342", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -1,3 +1,9 @@\n+2008-04-14  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/strict-overflow-6.c: New.\n+\t* gcc.dg/no-strict-overflow-7.c: New.\n+\t* gcc.dg/Wstrict-overflow-22.c: New.\n+\n 2008-04-14  Samuel Tardieu  <sam@rfc1149.net>\n \n \t* gnat.dg/specs/storage.ads: Fix expected error message."}, {"sha": "4b8438733e0a72b3e0e4a35a2f3ed8ae4a0ce619", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-22.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-22.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-22.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-22.c?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=3\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-6.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (char* p)\n+{\n+  return p + 1000 < p; /* { dg-warning \"assuming pointer wraparound does not occur\" \"correct warning\" } */\n+}"}, {"sha": "07ad27b1f870fbdd7ba5c26749a80aac4c92bc00", "filename": "gcc/testsuite/gcc.dg/no-strict-overflow-7.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fno-strict-overflow-7.c?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-strict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of strict-overflow-6.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (char* p)\n+{\n+  return p + 1000 < p;\n+}\n+\n+/* { dg-final { scan-tree-dump \"\\[+\\]\\[ \\]*1000\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}, {"sha": "ec1266d1b4942f9d2a78e334f4fea367f354bf74", "filename": "gcc/testsuite/gcc.dg/strict-overflow-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c9db6e07aba115c21ab02068ccc332ce691775e/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrict-overflow-6.c?ref=4c9db6e07aba115c21ab02068ccc332ce691775e", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -fdump-tree-final_cleanup\" } */\n+\n+/* Source: Ian Lance Taylor.  Dual of no-strict-overflow-7.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (char* p)\n+{\n+  return p + 1000 < p;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"\\[+\\]\\[ \\]*1000\" \"final_cleanup\" } } */\n+/* { dg-final { cleanup-tree-dump \"final_cleanup\" } } */"}]}