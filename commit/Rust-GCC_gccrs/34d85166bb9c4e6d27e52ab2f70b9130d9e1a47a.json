{"sha": "34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzRkODUxNjZiYjljNGU2ZDI3ZTUyYWIyZjcwYjkxMzBkOWUxYTQ3YQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2006-12-11T14:19:11Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2006-12-11T14:19:11Z"}, "message": "value-prof.c (tree_stringops_transform): New.\n\n\n\t* value-prof.c (tree_stringops_transform): New.\n\t(tree_value_profile_transformations): Require count to be non-zero;\n\tcall stringop transform; reset stmt BSI after BB changed.\n\t(tree_divmod_fixed_value, tree_mod_pow2): Don't emit unnecesary label.\n\t(interesting_stringop_to_profile_p, tree_stringop_fixed_value): New.\n\t(tree_stringops_values_to_profile): New.\n\t(tree_values_to_profile): Call tree_stringops_values_to_profile.\n\t* tree.h (build_string_literal): Tidy prototype.\n\t(validate_arglist, builtin_memset_read_str, get_pointer_alignment):\n\tDeclare.\n\t* builtins.c (validate_arglist, builtin_memset_read_str,\n\tget_pointer_alignment): Export.\n\nFrom-SVN: r119735", "tree": {"sha": "77f1ba617455cbee2a407e6f38b6978a81655463", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77f1ba617455cbee2a407e6f38b6978a81655463"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/comments", "author": null, "committer": null, "parents": [{"sha": "fa283935def9d8589b50e651a6a9a3af774fe9a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa283935def9d8589b50e651a6a9a3af774fe9a3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa283935def9d8589b50e651a6a9a3af774fe9a3"}], "stats": {"total": 367, "additions": 347, "deletions": 20}, "files": [{"sha": "4a0a98338096eefcc4adbafb4e0afa9e0b4596e0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -1,3 +1,18 @@\n+2006-12-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* value-prof.c (tree_stringops_transform): New.\n+\t(tree_value_profile_transformations): Require count to be non-zero;\n+\tcall stringop transform; reset stmt BSI after BB changed.\n+\t(tree_divmod_fixed_value, tree_mod_pow2): Don't emit unnecesary label.\n+\t(interesting_stringop_to_profile_p, tree_stringop_fixed_value): New.\n+\t(tree_stringops_values_to_profile): New.\n+\t(tree_values_to_profile): Call tree_stringops_values_to_profile.\n+\t* tree.h (build_string_literal): Tidy prototype.\n+\t(validate_arglist, builtin_memset_read_str, get_pointer_alignment):\n+\tDeclare.\n+\t* builtins.c (validate_arglist, builtin_memset_read_str,\n+\tget_pointer_alignment): Export.\n+\n 2006-12-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/30120"}, {"sha": "a6f1402c456b3022a6437601a97c39f71902d796", "filename": "gcc/builtins.c", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -72,7 +72,6 @@ tree built_in_decls[(int) END_BUILTINS];\n    required to implement the function call in all cases).  */\n tree implicit_built_in_decls[(int) END_BUILTINS];\n \n-static int get_pointer_alignment (tree, unsigned int);\n static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n static int target_char_cast (tree, char *);\n@@ -118,7 +117,6 @@ static rtx expand_builtin_strcpy (tree, tree, rtx, enum machine_mode);\n static rtx expand_builtin_stpcpy (tree, rtx, enum machine_mode);\n static rtx builtin_strncpy_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n static rtx expand_builtin_strncpy (tree, rtx, enum machine_mode);\n-static rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n static rtx builtin_memset_gen_str (void *, HOST_WIDE_INT, enum machine_mode);\n static rtx expand_builtin_memset (tree, rtx, enum machine_mode, tree);\n static rtx expand_builtin_bzero (tree);\n@@ -141,7 +139,6 @@ static tree fold_builtin_classify_type (tree);\n static tree fold_builtin_strlen (tree);\n static tree fold_builtin_inf (tree, int);\n static tree fold_builtin_nan (tree, tree, int);\n-static int validate_arglist (tree, ...);\n static bool integer_valued_real_p (tree);\n static tree fold_trunc_transparent_mathfn (tree, tree);\n static bool readonly_data_expr (tree);\n@@ -235,7 +232,7 @@ static bool called_as_built_in (tree node)\n    Otherwise, look at the expression to see if we can do better, i.e., if the\n    expression is actually pointing at an object whose alignment is tighter.  */\n \n-static int\n+int\n get_pointer_alignment (tree exp, unsigned int max_align)\n {\n   unsigned int align, inner;\n@@ -3486,7 +3483,7 @@ expand_builtin_strncpy (tree exp, rtx target, enum machine_mode mode)\n    bytes from constant string DATA + OFFSET and return it as target\n    constant.  */\n \n-static rtx\n+rtx\n builtin_memset_read_str (void *data, HOST_WIDE_INT offset ATTRIBUTE_UNUSED,\n \t\t\t enum machine_mode mode)\n {\n@@ -9503,7 +9500,7 @@ build_function_call_expr (tree fn, tree arglist)\n    of tree_codes.  If the last specifier is a 0, that represents an\n    ellipses, otherwise the last specifier must be a VOID_TYPE.  */\n \n-static int\n+int\n validate_arglist (tree arglist, ...)\n {\n   enum tree_code code;"}, {"sha": "28e27511a33ee34000c6619e37559bfc4c379dac", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -1,3 +1,8 @@\n+2006-12-11  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.dg/tree-prof/stringop-1.c: New test.\n+\t* gcc.dg/tree-prof/stringop-2.c: New test.\n+\n 2006-12-11  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/30120"}, {"sha": "eca3de169675af3c3e4033a266894215a940f931", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-1.c?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+int a[1000];\n+int b[1000];\n+int size=1;\n+int max=10000;\n+main()\n+{\n+  int i;\n+  for (i=0;i<max; i++)\n+    {\n+      __builtin_memcpy (a, b, size * sizeof (a[0]));\n+      asm(\"\");\n+    }\n+   return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n+/* Really this ought to simplify into assignment, but we are not there yet.  */\n+/* { dg-final-use { scan-tree-dump \"memcpy.*4\\\\)\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "3e7bd542e7ac46cb432f87f6439e5e20f7a687a1", "filename": "gcc/testsuite/gcc.dg/tree-prof/stringop-2.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-prof%2Fstringop-2.c?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-options \"-O2 -fdump-tree-optimized -fdump-tree-tree_profile\" } */\n+int a[1000];\n+int b[1000];\n+int size=1;\n+int max=10000;\n+main()\n+{\n+  int i;\n+  for (i=0;i<max; i++)\n+    {\n+      __builtin_memset (a, 10, size * sizeof (a[0]));\n+      asm(\"\");\n+    }\n+   return 0;\n+}\n+/* { dg-final-use { scan-tree-dump \"Single value 4 stringop\" \"tree_profile\"} } */\n+/* Really this ought to simplify into assignment, but we are not there yet.  */\n+/* { dg-final-use { scan-tree-dump \"memset.*4\\\\)\" \"optimized\"} } */\n+/* { dg-final-use { cleanup-tree-dump \"optimized\" } } */\n+/* { dg-final-use { cleanup-tree-dump \"tree_profile\" } } */"}, {"sha": "6a000edce83ec1c8353f0d748cb7a2d6e2828b54", "filename": "gcc/tree.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -4362,7 +4362,10 @@ extern tree strip_float_extensions (tree);\n extern tree c_strlen (tree, int);\n extern tree std_gimplify_va_arg_expr (tree, tree, tree *, tree *);\n extern tree build_va_arg_indirect_ref (tree);\n-tree build_string_literal (int, const char *);\n+extern tree build_string_literal (int, const char *);\n+extern int validate_arglist (tree, ...);\n+extern rtx builtin_memset_read_str (void *, HOST_WIDE_INT, enum machine_mode);\n+extern int get_pointer_alignment (tree, unsigned int);\n \n /* In convert.c */\n extern tree strip_float_extensions (tree);"}, {"sha": "61786b814c5e4bd6a66c68675f73962f0ae949db", "filename": "gcc/value-prof.c", "status": "modified", "additions": 280, "deletions": 13, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=34d85166bb9c4e6d27e52ab2f70b9130d9e1a47a", "patch": "@@ -79,6 +79,7 @@ static tree tree_mod_subtract (tree, tree, tree, tree, int, int, int,\n static bool tree_divmod_fixed_value_transform (tree);\n static bool tree_mod_pow2_value_transform (tree);\n static bool tree_mod_subtract_transform (tree);\n+static bool tree_stringops_transform (block_stmt_iterator *);\n \n /* The overall number of invocations of the counter should match execution count\n    of basic block.  Report it as error rather than internal error as it might\n@@ -110,7 +111,7 @@ tree_value_profile_transformations (void)\n   FOR_EACH_BB (bb)\n     {\n       /* Ignore cold areas -- we are enlarging the code.  */\n-      if (!maybe_hot_bb_p (bb))\n+      if (!bb->count || !maybe_hot_bb_p (bb))\n \tcontinue;\n \n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n@@ -137,8 +138,10 @@ tree_value_profile_transformations (void)\n \t  if (flag_value_profile_transformations\n \t      && (tree_mod_subtract_transform (stmt)\n \t\t  || tree_divmod_fixed_value_transform (stmt)\n-\t\t  || tree_mod_pow2_value_transform (stmt)))\n+\t\t  || tree_mod_pow2_value_transform (stmt)\n+\t\t  || tree_stringops_transform (&bsi)))\n \t    {\n+\t      stmt = bsi_stmt (bsi);\n \t      changed = true;\n \t      /* Original statement may no longer be in the same block. */\n \t      if (bb != bb_for_stmt (stmt))\n@@ -180,8 +183,7 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n   tree tmp1, tmp2, tmpv;\n   tree label_decl1 = create_artificial_label ();\n   tree label_decl2 = create_artificial_label ();\n-  tree label_decl3 = create_artificial_label ();\n-  tree label1, label2, label3;\n+  tree label1, label2;\n   tree bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype = TREE_TYPE (operation);\n@@ -220,9 +222,6 @@ tree_divmod_fixed_value (tree stmt, tree operation,\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb3end = stmt1;\n \n-  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n-  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n-\n   /* Fix CFG. */\n   /* Edge e23 connects bb2 to bb3, etc. */\n   e12 = split_block (bb, bb1end);\n@@ -344,8 +343,7 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n   tree tmp2, tmp3;\n   tree label_decl1 = create_artificial_label ();\n   tree label_decl2 = create_artificial_label ();\n-  tree label_decl3 = create_artificial_label ();\n-  tree label1, label2, label3;\n+  tree label1, label2;\n   tree bb1end, bb2end, bb3end;\n   basic_block bb, bb2, bb3, bb4;\n   tree optype = TREE_TYPE (operation);\n@@ -387,9 +385,6 @@ tree_mod_pow2 (tree stmt, tree operation, tree op1, tree op2, int prob,\n   bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n   bb3end = stmt1;\n \n-  label3 = build1 (LABEL_EXPR, void_type_node, label_decl3);\n-  bsi_insert_before (&bsi, label3, BSI_SAME_STMT);\n-\n   /* Fix CFG. */\n   /* Edge e23 connects bb2 to bb3, etc. */\n   e12 = split_block (bb, bb1end);\n@@ -691,6 +686,236 @@ tree_mod_subtract_transform (tree stmt)\n   return true;\n }\n \n+/* Return true if the stringop FNDECL with ARGLIST shall be profiled.  */\n+static bool\n+interesting_stringop_to_profile_p (tree fndecl, tree arglist)\n+{\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+\n+  if (fcode != BUILT_IN_MEMSET && fcode != BUILT_IN_MEMCPY\n+      && fcode != BUILT_IN_BZERO)\n+    return false;\n+\n+  switch (fcode)\n+    {\n+     case BUILT_IN_MEMCPY:\n+     case BUILT_IN_MEMPCPY:\n+\treturn validate_arglist (arglist,\n+\t\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t\t VOID_TYPE);\n+     case BUILT_IN_MEMSET:\n+\treturn validate_arglist (arglist,\n+\t\t\t\t POINTER_TYPE, INTEGER_TYPE, INTEGER_TYPE,\n+\t\t\t\t VOID_TYPE);\n+     case BUILT_IN_BZERO:\n+        return validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE,\n+\t\t\t\t VOID_TYPE);\n+     default:\n+\tgcc_unreachable ();\n+    }\n+}\n+\n+/* Convert   stringop (..., size)\n+   into \n+   if (size == VALUE)\n+     stringop (...., VALUE);\n+   else\n+     stringop (...., size);\n+   assuming constant propagation of VALUE will happen later.\n+*/\n+static void\n+tree_stringop_fixed_value (tree stmt, tree value, int prob, gcov_type count,\n+\t\t\t   gcov_type all)\n+{\n+  tree stmt1, stmt2, stmt3;\n+  tree tmp1, tmpv;\n+  tree label_decl1 = create_artificial_label ();\n+  tree label_decl2 = create_artificial_label ();\n+  tree label1, label2;\n+  tree bb1end, bb2end;\n+  basic_block bb, bb2, bb3, bb4;\n+  edge e12, e13, e23, e24, e34;\n+  block_stmt_iterator bsi;\n+  tree call = get_call_expr_in (stmt);\n+  tree arglist = TREE_OPERAND (call, 1);\n+  tree blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  tree optype = TREE_TYPE (blck_size);\n+  int region;\n+\n+  bb = bb_for_stmt (stmt);\n+  bsi = bsi_for_stmt (stmt);\n+\n+  if (bsi_end_p (bsi))\n+    {\n+      edge_iterator ei;\n+      for (ei = ei_start (bb->succs); (e34 = ei_safe_edge (ei)); )\n+\tif (!e34->flags & EDGE_ABNORMAL)\n+\t  break;\n+    }\n+  else\n+    {\n+      e34 = split_block (bb, stmt);\n+      bsi = bsi_for_stmt (stmt);\n+    }\n+  bb4 = e34->dest;\n+\n+  tmpv = create_tmp_var (optype, \"PROF\");\n+  tmp1 = create_tmp_var (optype, \"PROF\");\n+  stmt1 = build2 (GIMPLE_MODIFY_STMT, optype, tmpv,\n+\t\t  fold_convert (optype, value));\n+  stmt2 = build2 (GIMPLE_MODIFY_STMT, optype, tmp1, blck_size);\n+  stmt3 = build3 (COND_EXPR, void_type_node,\n+\t    build2 (NE_EXPR, boolean_type_node, tmp1, tmpv),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl2),\n+\t    build1 (GOTO_EXPR, void_type_node, label_decl1));\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt2, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt3, BSI_SAME_STMT);\n+  bb1end = stmt3;\n+\n+  label1 = build1 (LABEL_EXPR, void_type_node, label_decl1);\n+  stmt1 = unshare_expr (stmt);\n+  call = get_call_expr_in (stmt1);\n+  arglist = TREE_OPERAND (call, 1);\n+  TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist))) = value;\n+  bsi_insert_before (&bsi, label1, BSI_SAME_STMT);\n+  bsi_insert_before (&bsi, stmt1, BSI_SAME_STMT);\n+  region = lookup_stmt_eh_region (stmt);\n+  if (region >= 0)\n+    add_stmt_to_eh_region (stmt1, region);\n+  bb2end = stmt1;\n+  label2 = build1 (LABEL_EXPR, void_type_node, label_decl2);\n+  bsi_insert_before (&bsi, label2, BSI_SAME_STMT);\n+\n+  /* Fix CFG. */\n+  /* Edge e23 connects bb2 to bb3, etc. */\n+  e12 = split_block (bb, bb1end);\n+  bb2 = e12->dest;\n+  bb2->count = count;\n+  e23 = split_block (bb2, bb2end);\n+  bb3 = e23->dest;\n+  bb3->count = all - count;\n+\n+  e12->flags &= ~EDGE_FALLTHRU;\n+  e12->flags |= EDGE_FALSE_VALUE;\n+  e12->probability = prob;\n+  e12->count = count;\n+\n+  e13 = make_edge (bb, bb3, EDGE_TRUE_VALUE);\n+  e13->probability = REG_BR_PROB_BASE - prob;\n+  e13->count = all - count;\n+\n+  remove_edge (e23);\n+  \n+  e24 = make_edge (bb2, bb4, EDGE_FALLTHRU);\n+  e24->probability = REG_BR_PROB_BASE;\n+  e24->count = count;\n+\n+  e34->probability = REG_BR_PROB_BASE;\n+  e34->count = all - count;\n+}\n+\n+/* Find values inside STMT for that we want to measure histograms for\n+   division/modulo optimization.  */\n+static bool\n+tree_stringops_transform (block_stmt_iterator *bsi)\n+{\n+  tree stmt = bsi_stmt (*bsi);\n+  tree call = get_call_expr_in (stmt);\n+  tree fndecl;\n+  tree arglist;\n+  tree blck_size;\n+  enum built_in_function fcode;\n+  stmt_ann_t ann = get_stmt_ann (stmt);\n+  histogram_value histogram;\n+  gcov_type count, all, val;\n+  tree value;\n+  tree dest, src;\n+  unsigned int dest_align, src_align;\n+  int prob;\n+  tree tree_val;\n+\n+  if (!call)\n+    return false;\n+  fndecl = get_callee_fndecl (call);\n+  if (!fndecl)\n+    return false;\n+  fcode = DECL_FUNCTION_CODE (fndecl);\n+  arglist = TREE_OPERAND (call, 1);\n+  if (!interesting_stringop_to_profile_p (fndecl, arglist))\n+    return false;\n+\n+  if (fcode == BUILT_IN_BZERO)\n+    blck_size = TREE_VALUE (TREE_CHAIN (arglist));\n+  else\n+    blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+  if (TREE_CODE (blck_size) == INTEGER_CST)\n+    return false;\n+\n+  if (!ann->histograms)\n+    return false;\n+\n+  all = bb_for_stmt (stmt)->count;\n+  if (!all)\n+    return false;\n+  for (histogram = ann->histograms; histogram;\n+       histogram = histogram->hvalue.next)\n+    if (histogram->type == HIST_TYPE_SINGLE_VALUE)\n+      break;\n+  if (!histogram)\n+    return false;\n+  value = histogram->hvalue.value;\n+  val = histogram->hvalue.counters[0];\n+  count = histogram->hvalue.counters[1];\n+  all = histogram->hvalue.counters[2];\n+  /* We require that count is at least half of all; this means\n+     that for the transformation to fire the value must be constant\n+     at least 80% of time.  */\n+  if ((6 * count / 5) < all)\n+    return false;\n+  if (check_counter (stmt, \"value\", all, bb_for_stmt (stmt)->count))\n+    return false;\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+  dest = TREE_VALUE (arglist);\n+  dest_align = get_pointer_alignment (dest, BIGGEST_ALIGNMENT);\n+  switch (fcode)\n+    {\n+    case BUILT_IN_MEMCPY:\n+    case BUILT_IN_MEMPCPY:\n+      src = TREE_VALUE (TREE_CHAIN (arglist));\n+      src_align = get_pointer_alignment (src, BIGGEST_ALIGNMENT);\n+      if (!can_move_by_pieces (val, MIN (dest_align, src_align)))\n+\treturn false;\n+      break;\n+    case BUILT_IN_MEMSET:\n+      if (!can_store_by_pieces (val, builtin_memset_read_str,\n+\t\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t\tdest_align))\n+\treturn false;\n+      break;\n+    case BUILT_IN_BZERO:\n+      if (!can_store_by_pieces (val, builtin_memset_read_str,\n+\t\t\t\tinteger_zero_node,\n+\t\t\t\tdest_align))\n+\treturn false;\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+  tree_val = build_int_cst_wide (get_gcov_type (),\n+\t\t\t\t (unsigned HOST_WIDE_INT) val,\n+\t\t\t\t val >> (HOST_BITS_PER_WIDE_INT - 1) >> 1);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Single value %i stringop transformation on \",\n+\t       (int)val);\n+      print_generic_stmt (dump_file, stmt, TDF_SLIM);\n+    }\n+  tree_stringop_fixed_value (stmt, tree_val, prob, count, all);\n+  \n+  return true;\n+}\n+\n struct value_prof_hooks {\n   /* Find list of values for which we want to measure histograms.  */\n   void (*find_values_to_profile) (histogram_values *);\n@@ -770,14 +995,56 @@ tree_divmod_values_to_profile (tree stmt, histogram_values *values)\n     }\n }\n \n+/* Find values inside STMT for that we want to measure histograms for\n+   division/modulo optimization.  */\n+static void\n+tree_stringops_values_to_profile (tree stmt, histogram_values *values)\n+{\n+  tree call = get_call_expr_in (stmt);\n+  tree fndecl;\n+  tree arglist;\n+  tree blck_size;\n+  enum built_in_function fcode;\n+  histogram_value hist;\n+\n+  if (!call)\n+    return;\n+  fndecl = get_callee_fndecl (call);\n+  if (!fndecl)\n+    return;\n+  fcode = DECL_FUNCTION_CODE (fndecl);\n+  arglist = TREE_OPERAND (call, 1);\n+\n+  if (!interesting_stringop_to_profile_p (fndecl, arglist))\n+    return;\n+\n+  if (fcode == BUILT_IN_BZERO)\n+    blck_size = TREE_VALUE (TREE_CHAIN (arglist));\n+  else\n+    blck_size = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  if (TREE_CODE (blck_size) != INTEGER_CST)\n+    {\n+      VEC_reserve (histogram_value, heap, *values, 3);\n+      hist = ggc_alloc (sizeof (*hist));\n+      hist->hvalue.value = blck_size;\n+      hist->hvalue.stmt = stmt;\n+      hist->type = HIST_TYPE_SINGLE_VALUE;\n+      VEC_quick_push (histogram_value, *values, hist);\n+    }\n+}\n+\n /* Find values inside STMT for that we want to measure histograms and adds\n    them to list VALUES.  */\n \n static void\n tree_values_to_profile (tree stmt, histogram_values *values)\n {\n   if (flag_value_profile_transformations)\n-    tree_divmod_values_to_profile (stmt, values);\n+    {\n+      tree_divmod_values_to_profile (stmt, values);\n+      tree_stringops_values_to_profile (stmt, values);\n+    }\n }\n \n static void"}]}