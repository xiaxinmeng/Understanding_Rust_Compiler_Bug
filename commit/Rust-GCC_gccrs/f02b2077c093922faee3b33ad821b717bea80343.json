{"sha": "f02b2077c093922faee3b33ad821b717bea80343", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjAyYjIwNzdjMDkzOTIyZmFlZTNiMzNhZDgyMWI3MTdiZWE4MDM0Mw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-16T09:24:23Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-09-16T10:28:10Z"}, "message": "remove STMT_VINFO_NUM_SLP_USES\n\nThis removes STMT_VINFO_NUM_SLP_USES by pushing the setting of\nthe shared stmt_vec_info vector type to where we actually need it\nwhich is alignment analysis and vectorizable_* analysis (where\nwe could eventually elide it for non-load/store operations).\n\nIn particular \"uses\" in the cache and in disqualified SLP\nsubgraphs should no longer provide conflicting vector types\nthis way.\n\n2020-09-16  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vectorizer.h (_stmt_vec_info::num_slp_uses): Remove.\n\t(STMT_VINFO_NUM_SLP_USES): Likewise.\n\t(vect_free_slp_instance): Adjust.\n\t(vect_update_shared_vectype): Declare.\n\t* tree-vectorizer.c (vec_info::~vec_info): Adjust.\n\t* tree-vect-loop.c (vect_analyze_loop_2): Likewise.\n\t(vectorizable_live_operation): Use vector type from\n\tSLP_TREE_REPRESENTATIVE.\n\t(vect_transform_loop): Adjust.\n\t* tree-vect-data-refs.c (vect_slp_analyze_node_alignment):\n\tSet the shared vector type.\n\t* tree-vect-slp.c (vect_free_slp_tree): Remove final_p\n\tparameter, remove STMT_VINFO_NUM_SLP_USES updating.\n\t(vect_free_slp_instance): Adjust.\n\t(vect_create_new_slp_node): Remove STMT_VINFO_NUM_SLP_USES\n\tupdating.\n\t(vect_update_shared_vectype): Always compare with the\n\tpresent vector type, update if NULL.\n\t(vect_build_slp_tree_1): Do not update the shared vector\n\ttype here.\n\t(vect_build_slp_tree_2): Adjust.\n\t(slp_copy_subtree): Likewise.\n\t(vect_attempt_slp_rearrange_stmts): Likewise.\n\t(vect_analyze_slp_instance): Likewise.\n\t(vect_analyze_slp): Likewise.\n\t(vect_slp_analyze_node_operations_1): Update the shared\n\tvector type.\n\t(vect_slp_analyze_operations): Adjust.\n\t(vect_slp_analyze_bb_1): Likewise.", "tree": {"sha": "3f94d738749b696efe6d8bd836a9f3cc0bd8c1e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f94d738749b696efe6d8bd836a9f3cc0bd8c1e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f02b2077c093922faee3b33ad821b717bea80343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02b2077c093922faee3b33ad821b717bea80343", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f02b2077c093922faee3b33ad821b717bea80343", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f02b2077c093922faee3b33ad821b717bea80343/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a4f343aa3639f2358b44c24f0dc0f016c0b1451", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a4f343aa3639f2358b44c24f0dc0f016c0b1451", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a4f343aa3639f2358b44c24f0dc0f016c0b1451"}], "stats": {"total": 108, "additions": 41, "deletions": 67}, "files": [{"sha": "5bf93e2942bdbfd8eb6524cfa4508a7ca2fbe564", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=f02b2077c093922faee3b33ad821b717bea80343", "patch": "@@ -2380,6 +2380,11 @@ vect_slp_analyze_node_alignment (vec_info *vinfo, slp_tree node)\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n     first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n \n+  /* We need to commit to a vector type for the group now.  */\n+  if (is_a <bb_vec_info> (vinfo)\n+      && !vect_update_shared_vectype (first_stmt_info, SLP_TREE_VECTYPE (node)))\n+    return false;\n+\n   dr_vec_info *dr_info = STMT_VINFO_DR_INFO (first_stmt_info);\n   vect_compute_data_ref_alignment (vinfo, dr_info);\n   /* In several places we need alignment of the first element anyway.  */"}, {"sha": "3af4cf74659668505c1012da3414337ee0f984c9", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=f02b2077c093922faee3b33ad821b717bea80343", "patch": "@@ -2467,7 +2467,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = saved_vectorization_factor;\n   /* Free the SLP instances.  */\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), j, instance)\n-    vect_free_slp_instance (instance, false);\n+    vect_free_slp_instance (instance);\n   LOOP_VINFO_SLP_INSTANCES (loop_vinfo).release ();\n   /* Reset SLP type to loop_vect on all stmts.  */\n   for (i = 0; i < LOOP_VINFO_LOOP (loop_vinfo)->num_nodes; ++i)\n@@ -8031,7 +8031,9 @@ vectorizable_live_operation (vec_info *vinfo,\n   loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo);\n   imm_use_iterator imm_iter;\n   tree lhs, lhs_type, bitsize, vec_bitsize;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vectype = (slp_node\n+\t\t  ? SLP_TREE_VECTYPE (SLP_TREE_REPRESENTATIVE (slp_node))\n+\t\t  : STMT_VINFO_VECTYPE (stmt_info));\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   int ncopies;\n   gimple *use_stmt;\n@@ -9260,7 +9262,7 @@ vect_transform_loop (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n      won't work.  */\n   slp_instance instance;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (loop_vinfo), i, instance)\n-    vect_free_slp_instance (instance, true);\n+    vect_free_slp_instance (instance);\n   LOOP_VINFO_SLP_INSTANCES (loop_vinfo).release ();\n   /* Clear-up safelen field since its value is invalid after vectorization\n      since vectorized loop can have loop-carried dependencies.  */"}, {"sha": "ecce7a982ddbd294b41cf88c44d07d4c929967db", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 28, "deletions": 58, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=f02b2077c093922faee3b33ad821b717bea80343", "patch": "@@ -84,12 +84,10 @@ _slp_tree::~_slp_tree ()\n   SLP_TREE_LANE_PERMUTATION (this).release ();\n }\n \n-/* Recursively free the memory allocated for the SLP tree rooted at NODE.\n-   FINAL_P is true if we have vectorized the instance or if we have\n-   made a final decision not to vectorize the statements in any way.  */\n+/* Recursively free the memory allocated for the SLP tree rooted at NODE.  */\n \n static void\n-vect_free_slp_tree (slp_tree node, bool final_p)\n+vect_free_slp_tree (slp_tree node)\n {\n   int i;\n   slp_tree child;\n@@ -98,21 +96,7 @@ vect_free_slp_tree (slp_tree node, bool final_p)\n     return;\n \n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n-    vect_free_slp_tree (child, final_p);\n-\n-  /* Don't update STMT_VINFO_NUM_SLP_USES if it isn't relevant.\n-     Some statements might no longer exist, after having been\n-     removed by vect_transform_stmt.  Updating the remaining\n-     statements would be redundant.  */\n-  if (!final_p)\n-    {\n-      stmt_vec_info stmt_info;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-\t{\n-\t  gcc_assert (STMT_VINFO_NUM_SLP_USES (stmt_info) > 0);\n-\t  STMT_VINFO_NUM_SLP_USES (stmt_info)--;\n-\t}\n-    }\n+    vect_free_slp_tree (child);\n \n   delete node;\n }\n@@ -129,14 +113,12 @@ _slp_instance::location () const\n }\n \n \n-/* Free the memory allocated for the SLP instance.  FINAL_P is true if we\n-   have vectorized the instance or if we have made a final decision not\n-   to vectorize the statements in any way.  */\n+/* Free the memory allocated for the SLP instance.  */\n \n void\n-vect_free_slp_instance (slp_instance instance, bool final_p)\n+vect_free_slp_instance (slp_instance instance)\n {\n-  vect_free_slp_tree (SLP_INSTANCE_TREE (instance), final_p);\n+  vect_free_slp_tree (SLP_INSTANCE_TREE (instance));\n   SLP_INSTANCE_LOADS (instance).release ();\n   instance->subgraph_entries.release ();\n   instance->cost_vec.release ();\n@@ -155,12 +137,6 @@ vect_create_new_slp_node (vec<stmt_vec_info> scalar_stmts, unsigned nops)\n   SLP_TREE_DEF_TYPE (node) = vect_internal_def;\n   SLP_TREE_REPRESENTATIVE (node) = scalar_stmts[0];\n   SLP_TREE_LANES (node) = scalar_stmts.length ();\n-\n-  unsigned i;\n-  stmt_vec_info stmt_info;\n-  FOR_EACH_VEC_ELT (scalar_stmts, i, stmt_info)\n-    STMT_VINFO_NUM_SLP_USES (stmt_info)++;\n-\n   return node;\n }\n \n@@ -614,23 +590,23 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n    Return true if we can, meaning that this choice doesn't conflict with\n    existing SLP nodes that use STMT_INFO.  */\n \n-static bool\n+bool\n vect_update_shared_vectype (stmt_vec_info stmt_info, tree vectype)\n {\n   tree old_vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  if (old_vectype && useless_type_conversion_p (vectype, old_vectype))\n-    return true;\n+  if (old_vectype)\n+    return useless_type_conversion_p (vectype, old_vectype);\n \n-  if (STMT_VINFO_GROUPED_ACCESS (stmt_info)\n-      && DR_IS_READ (STMT_VINFO_DATA_REF (stmt_info)))\n+  if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       /* We maintain the invariant that if any statement in the group is\n \t used, all other members of the group have the same vector type.  */\n       stmt_vec_info first_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       stmt_vec_info member_info = first_info;\n       for (; member_info; member_info = DR_GROUP_NEXT_ELEMENT (member_info))\n-\tif (STMT_VINFO_NUM_SLP_USES (member_info) > 0\n-\t    || is_pattern_stmt_p (member_info))\n+\tif (is_pattern_stmt_p (member_info)\n+\t    && !useless_type_conversion_p (vectype,\n+\t\t\t\t\t   STMT_VINFO_VECTYPE (member_info)))\n \t  break;\n \n       if (!member_info)\n@@ -641,8 +617,7 @@ vect_update_shared_vectype (stmt_vec_info stmt_info, tree vectype)\n \t  return true;\n \t}\n     }\n-  else if (STMT_VINFO_NUM_SLP_USES (stmt_info) == 0\n-\t   && !is_pattern_stmt_p (stmt_info))\n+  else if (!is_pattern_stmt_p (stmt_info))\n     {\n       STMT_VINFO_VECTYPE (stmt_info) = vectype;\n       return true;\n@@ -824,10 +799,6 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \n       gcc_assert (vectype);\n \n-      if (is_a <bb_vec_info> (vinfo)\n-\t  && !vect_update_shared_vectype (stmt_info, vectype))\n-\tcontinue;\n-\n       gcall *call_stmt = dyn_cast <gcall *> (stmt);\n       if (call_stmt)\n \t{\n@@ -1561,7 +1532,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n       gcc_assert (child == NULL);\n       FOR_EACH_VEC_ELT (children, j, child)\n-\tvect_free_slp_tree (child, false);\n+\tvect_free_slp_tree (child);\n       vect_free_oprnd_info (oprnds_info);\n       return NULL;\n     }\n@@ -1589,7 +1560,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \t  /* Roll back.  */\n \t  matches[0] = false;\n \t  FOR_EACH_VEC_ELT (children, j, child)\n-\t    vect_free_slp_tree (child, false);\n+\t    vect_free_slp_tree (child);\n \n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1833,12 +1804,7 @@ slp_copy_subtree (slp_tree node, hash_map<slp_tree, slp_tree> &map)\n   copy->max_nunits = node->max_nunits;\n   copy->refcnt = 0;\n   if (SLP_TREE_SCALAR_STMTS (node).exists ())\n-    {\n-      SLP_TREE_SCALAR_STMTS (copy) = SLP_TREE_SCALAR_STMTS (node).copy ();\n-      stmt_vec_info stmt_info;\n-      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), i, stmt_info)\n-\tSTMT_VINFO_NUM_SLP_USES (stmt_info)++;\n-    }\n+    SLP_TREE_SCALAR_STMTS (copy) = SLP_TREE_SCALAR_STMTS (node).copy ();\n   if (SLP_TREE_SCALAR_OPS (node).exists ())\n     SLP_TREE_SCALAR_OPS (copy) = SLP_TREE_SCALAR_OPS (node).copy ();\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n@@ -1968,7 +1934,7 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   /* We have to unshare the SLP tree we modify.  */\n   hash_map<slp_tree, slp_tree> map;\n   slp_tree unshared = slp_copy_subtree (SLP_INSTANCE_TREE (slp_instn), map);\n-  vect_free_slp_tree (SLP_INSTANCE_TREE (slp_instn), false);\n+  vect_free_slp_tree (SLP_INSTANCE_TREE (slp_instn));\n   unshared->refcnt++;\n   SLP_INSTANCE_TREE (slp_instn) = unshared;\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n@@ -2280,7 +2246,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t\t \"Build SLP failed: store group \"\n \t\t\t\t \"size not a multiple of the vector size \"\n \t\t\t\t \"in basic block SLP\\n\");\n-\t      vect_free_slp_tree (node, false);\n+\t      vect_free_slp_tree (node);\n \t      return false;\n \t    }\n \t  /* Fatal mismatch.  */\n@@ -2290,7 +2256,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t\t     \"splitting\\n\");\n \t  matches[0] = true;\n \t  matches[group_size / const_max_nunits * const_max_nunits] = false;\n-\t  vect_free_slp_tree (node, false);\n+\t  vect_free_slp_tree (node);\n \t}\n       else\n \t{\n@@ -2351,7 +2317,7 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"Built SLP cancelled: can use \"\n \t\t\t\t     \"load/store-lanes\\n\");\n-\t\t  vect_free_slp_instance (new_instance, false);\n+\t\t  vect_free_slp_instance (new_instance);\n \t\t  return false;\n \t\t}\n \t    }\n@@ -2517,7 +2483,7 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n   for (scalar_stmts_to_slp_tree_map_t::iterator it = bst_map->begin ();\n        it != bst_map->end (); ++it)\n     if ((*it).second)\n-      vect_free_slp_tree ((*it).second, false);\n+      vect_free_slp_tree ((*it).second);\n   delete bst_map;\n \n   /* Optimize permutations in SLP reductions.  */\n@@ -2839,6 +2805,10 @@ vect_slp_analyze_node_operations_1 (vec_info *vinfo, slp_tree node,\n   if (SLP_TREE_CODE (node) == VEC_PERM_EXPR)\n     return vectorizable_slp_permutation (vinfo, NULL, node, cost_vec);\n \n+  if (is_a <bb_vec_info> (vinfo)\n+      && !vect_update_shared_vectype (stmt_info, SLP_TREE_VECTYPE (node)))\n+    return false;\n+\n   bool dummy;\n   return vect_analyze_stmt (vinfo, stmt_info, &dummy,\n \t\t\t    node, node_instance, cost_vec);\n@@ -3164,7 +3134,7 @@ vect_slp_analyze_operations (vec_info *vinfo)\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"removing SLP instance operations starting from: %G\",\n \t\t\t     stmt_info->stmt);\n-\t  vect_free_slp_instance (instance, false);\n+\t  vect_free_slp_instance (instance);\n           vinfo->slp_instances.ordered_remove (i);\n \t  cost_vec.release ();\n \t}\n@@ -3590,7 +3560,7 @@ vect_slp_analyze_bb_1 (bb_vec_info bb_vinfo, int n_stmts, bool &fatal,\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t     \"removing SLP instance operations starting from: %G\",\n \t\t\t     stmt_info->stmt);\n-\t  vect_free_slp_instance (instance, false);\n+\t  vect_free_slp_instance (instance);\n \t  BB_VINFO_SLP_INSTANCES (bb_vinfo).ordered_remove (i);\n \t  continue;\n \t}"}, {"sha": "37e36f556e54662e329d22d2ebff7162451f54a3", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=f02b2077c093922faee3b33ad821b717bea80343", "patch": "@@ -473,7 +473,7 @@ vec_info::~vec_info ()\n   unsigned int i;\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n-    vect_free_slp_instance (instance, true);\n+    vect_free_slp_instance (instance);\n \n   destroy_cost_data (target_cost_data);\n   free_stmt_vec_infos ();"}, {"sha": "9dffc5570e51b21c2f5c02b80a9f49d25a183284", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f02b2077c093922faee3b33ad821b717bea80343/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=f02b2077c093922faee3b33ad821b717bea80343", "patch": "@@ -1223,9 +1223,6 @@ class _stmt_vec_info {\n   /* Whether on this stmt reduction meta is recorded.  */\n   bool is_reduc_info;\n \n-  /* The number of scalar stmt references from active SLP instances.  */\n-  unsigned int num_slp_uses;\n-\n   /* If nonzero, the lhs of the statement could be truncated to this\n      many bits without affecting any users of the result.  */\n   unsigned int min_output_precision;\n@@ -1340,7 +1337,6 @@ struct gather_scatter_info {\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_BASE_UNCHANGED(S) (S)->loop_phi_evolution_base_unchanged\n #define STMT_VINFO_LOOP_PHI_EVOLUTION_PART(S) (S)->loop_phi_evolution_part\n #define STMT_VINFO_MIN_NEG_DIST(S)\t(S)->min_neg_dist\n-#define STMT_VINFO_NUM_SLP_USES(S)\t(S)->num_slp_uses\n #define STMT_VINFO_REDUC_TYPE(S)\t(S)->reduc_type\n #define STMT_VINFO_REDUC_CODE(S)\t(S)->reduc_code\n #define STMT_VINFO_REDUC_FN(S)\t\t(S)->reduc_fn\n@@ -2024,7 +2020,7 @@ extern int vect_get_known_peeling_cost (loop_vec_info, int, int *,\n extern tree cse_and_gimplify_to_preheader (loop_vec_info, tree);\n \n /* In tree-vect-slp.c.  */\n-extern void vect_free_slp_instance (slp_instance, bool);\n+extern void vect_free_slp_instance (slp_instance);\n extern bool vect_transform_slp_perm_load (vec_info *, slp_tree, vec<tree>,\n \t\t\t\t\t  gimple_stmt_iterator *, poly_uint64,\n \t\t\t\t\t  bool, unsigned *);\n@@ -2047,6 +2043,7 @@ extern bool can_duplicate_and_interleave_p (vec_info *, unsigned int, tree,\n extern void duplicate_and_interleave (vec_info *, gimple_seq *, tree,\n \t\t\t\t      vec<tree>, unsigned int, vec<tree> &);\n extern int vect_get_place_in_interleaving_chain (stmt_vec_info, stmt_vec_info);\n+extern bool vect_update_shared_vectype (stmt_vec_info, tree);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}