{"sha": "aa265568fec8d266353508bb56148af08242400d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWEyNjU1NjhmZWM4ZDI2NjM1MzUwOGJiNTYxNDhhZjA4MjQyNDAwZA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-07-21T19:30:11Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-07-21T19:30:11Z"}, "message": "entered into RCS\n\nFrom-SVN: r1656", "tree": {"sha": "934b78966672629693156005e0081ed32b357203", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/934b78966672629693156005e0081ed32b357203"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aa265568fec8d266353508bb56148af08242400d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa265568fec8d266353508bb56148af08242400d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa265568fec8d266353508bb56148af08242400d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa265568fec8d266353508bb56148af08242400d/comments", "author": null, "committer": null, "parents": [{"sha": "2d6fda9cee388788c1b84fe055cc426e53fe8166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d6fda9cee388788c1b84fe055cc426e53fe8166", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d6fda9cee388788c1b84fe055cc426e53fe8166"}], "stats": {"total": 111, "additions": 35, "deletions": 76}, "files": [{"sha": "819eb878412dfbc8dafa363ddda128c06ca96fa2", "filename": "gcc/sched.c", "status": "modified", "additions": 35, "deletions": 76, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aa265568fec8d266353508bb56148af08242400d/gcc%2Fsched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aa265568fec8d266353508bb56148af08242400d/gcc%2Fsched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched.c?ref=aa265568fec8d266353508bb56148af08242400d", "patch": "@@ -2397,73 +2397,6 @@ schedule_block (b, file)\n     return;\n #endif\n \n-  /* Exclude certain insns at the end of the basic block by advancing TAIL.  */\n-  /* This isn't correct.  Instead of advancing TAIL, should assign very\n-     high priorities to these insns to guarantee that they get scheduled last.\n-     If these insns are ignored, as is currently done, the register life info\n-     may be incorrectly computed.  */\n-  if (GET_CODE (tail) == INSN && GET_CODE (PATTERN (tail)) == USE)\n-    {\n-      /* Don't try to reorder any USE insns at the end of any block.\n-\t They must be last to ensure proper register allocation.\n-\t Exclude them all from scheduling.  */\n-      do\n-\t{\n-\t  /* If we are down to one USE insn, then there are no insns to\n-\t     schedule.  */\n-\t  if (head == tail)\n-\t    return;\n-\n-\t  tail = prev_nonnote_insn (tail);\n-\t}\n-      while (GET_CODE (tail) == INSN\n-\t     && GET_CODE (PATTERN (tail)) == USE);\n-\n-#if 0\n-      /* This short-cut does not work.  See comment above.  */\n-      if (head == tail)\n-\treturn;\n-#endif\n-    }\n-  else if (GET_CODE (tail) == JUMP_INSN\n-\t   && SCHED_GROUP_P (tail) == 0\n-\t   && GET_CODE (PREV_INSN (tail)) == INSN\n-\t   && GET_CODE (PATTERN (PREV_INSN (tail))) == USE\n-\t   && REG_FUNCTION_VALUE_P (XEXP (PATTERN (PREV_INSN (tail)), 0)))\n-    {\n-      /* Don't let the setting of the function's return value register\n-\t move from this jump.  For the same reason we want to get the\n-\t parameters into pseudo registers as quickly as possible, we\n-\t want to set the function's return value register as late as\n-\t possible.  */\n-\n-      /* If this is the only insn in the block, then there is no need to\n-\t schedule the block.  */\n-      if (head == tail)\n-\treturn;\n-\t\n-      tail = PREV_INSN (tail);\n-      if (head == tail)\n-\treturn;\n-\n-      tail = prev_nonnote_insn (tail);\n-\n-#if 0\n-      /* This shortcut does not work.  See comment above.  */\n-      if (head == tail)\n-\treturn;\n-#endif\n-    }\n-\n-#ifdef HAVE_cc0\n-  /* This is probably wrong.  Instead of doing this, should give this insn\n-     a very high priority to guarantee that it gets scheduled last.  */\n-  /* Can not separate an insn that sets the condition code from one that\n-     uses it.  So we must leave an insn that sets cc0 where it is.  */\n-  if (sets_cc0_p (PATTERN (tail)))\n-    tail = PREV_INSN (tail);\n-#endif\n-\n   /* Now HEAD through TAIL are the insns actually to be rearranged;\n      Let PREV_HEAD and NEXT_TAIL enclose them.  */\n   prev_head = PREV_INSN (head);\n@@ -2499,16 +2432,42 @@ schedule_block (b, file)\n      Put those insns into the READY vector.  */\n   insn = tail;\n \n-  /* If the last insn is a branch, force it to be the last insn after\n-     scheduling.  Also, don't try to reorder calls at the ends the basic\n-     block -- this will only lead to worse register allocation.  */\n-  if (GET_CODE (tail) == CALL_INSN || GET_CODE (tail) == JUMP_INSN)\n+  /* For all branches, calls, uses, and cc0 setters, force them to remain\n+     in order at the end of the block by giving them high priorities.\n+     There may be notes present, and prev_head may also be a note.\n+\n+     Branches must obviously remain at the end.  Calls should remain at the\n+     end since moving them results in worse register allocation.  Uses remain\n+     at the end to ensure proper register allocation.  cc0 setters remaim\n+     at the end because they can't be moved away from their cc0 user.  */\n+  i = 0;\n+  while (GET_CODE (insn) == CALL_INSN || GET_CODE (insn) == JUMP_INSN\n+\t || (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == USE)\n+#ifdef HAVE_cc0\n+\t || sets_cc0_p (PATTERN (insn))\n+#endif\n+\t || GET_CODE (insn) == NOTE)\n     {\n-      priority (tail);\n-      ready[n_ready++] = tail;\n-      INSN_PRIORITY (tail) = TAIL_PRIORITY;\n-      INSN_REF_COUNT (tail) = 0;\n-      insn = PREV_INSN (tail);\n+      if (GET_CODE (insn) != NOTE)\n+\t{\n+\t  priority (insn);\n+\t  ready[n_ready++] = insn;\n+\t  INSN_PRIORITY (insn) = TAIL_PRIORITY - i;\n+\t  i++;\n+\t  INSN_REF_COUNT (insn) = 0;\n+\n+\t  /* Skip over insns that are part of a group.  */\n+\t  while (SCHED_GROUP_P (insn))\n+\t    {\n+\t      insn = prev_nonnote_insn (insn);\n+\t      priority (insn);\n+\t    }\n+\t}\n+\n+      insn = PREV_INSN (insn);\n+      /* Don't overrun the bounds of the basic block.  */\n+      if (insn == prev_head)\n+\tbreak;\n     }\n \n   /* Assign priorities to instructions.  Also check whether they"}]}