{"sha": "92348f098dd10358538932275a1196bd5c9caaac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIzNDhmMDk4ZGQxMDM1ODUzODkzMjI3NWExMTk2YmQ1YzljYWFhYw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2016-03-11T22:38:41Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2016-03-11T22:38:41Z"}, "message": "re PR target/70123 (Miscompilation of cfitsio testcase on s390x-linux starting with r222144)\n\n\tPR target/70123\n\t* lra-remat.c (operand_to_remat): Disallow hard regs in the value t\n\tbe rematerialized.\n\t(reg_overlap_for_remat_p): Renamed from input_regno_present_p.\n\tArguments swapped.  All callers changed.  Take reg_renumber into\n\taccount, and Calculate and compare register ranges for hard regs.\n\n\tPR target/70123\n\t* gcc.dg/torture/pr70123.c: New test.\n\nFrom-SVN: r234152", "tree": {"sha": "5c2021263c63fea09f73bc34d5d8853f0d87d0d3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c2021263c63fea09f73bc34d5d8853f0d87d0d3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92348f098dd10358538932275a1196bd5c9caaac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92348f098dd10358538932275a1196bd5c9caaac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92348f098dd10358538932275a1196bd5c9caaac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92348f098dd10358538932275a1196bd5c9caaac/comments", "author": null, "committer": null, "parents": [{"sha": "cebde9e9ebb9b9a29f2b6cd07b14fd88089f088f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cebde9e9ebb9b9a29f2b6cd07b14fd88089f088f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cebde9e9ebb9b9a29f2b6cd07b14fd88089f088f"}], "stats": {"total": 263, "additions": 252, "deletions": 11}, "files": [{"sha": "ee80171f5b701392043f60a6c8e2cf2d7802e8ff", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92348f098dd10358538932275a1196bd5c9caaac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92348f098dd10358538932275a1196bd5c9caaac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92348f098dd10358538932275a1196bd5c9caaac", "patch": "@@ -1,3 +1,12 @@\n+2016-03-11  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR target/70123\n+\t* lra-remat.c (operand_to_remat): Disallow hard regs in the value t\n+\tbe rematerialized.\n+\t(reg_overlap_for_remat_p): Renamed from input_regno_present_p.\n+\tArguments swapped.  All callers changed.  Take reg_renumber into\n+\taccount, and Calculate and compare register ranges for hard regs.\n+\n 2016-03-11  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/70190"}, {"sha": "187ee3e7752d1ebe15ba8e8014620c0a94e11424", "filename": "gcc/lra-remat.c", "status": "modified", "additions": 40, "deletions": 11, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Flra-remat.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Flra-remat.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-remat.c?ref=92348f098dd10358538932275a1196bd5c9caaac", "patch": "@@ -413,6 +413,10 @@ operand_to_remat (rtx_insn *insn)\n       if (reg->regno >= FIRST_PSEUDO_REGISTER\n \t  && bitmap_bit_p (&subreg_regs, reg->regno))\n \treturn -1;\n+\n+      /* Don't allow hard registers to be rematerialized.  */\n+      if (reg->regno < FIRST_PSEUDO_REGISTER)\n+\treturn -1;\n     }\n   if (found_reg == NULL)\n     return -1;\n@@ -718,21 +722,46 @@ calculate_local_reg_remat_bb_data (void)\n \n \f\n \n-/* Return true if REGNO is an input operand of INSN.  */\n+/* Return true if REG overlaps an input operand of INSN.  */\n static bool\n-input_regno_present_p (rtx_insn *insn, int regno)\n+reg_overlap_for_remat_p (lra_insn_reg *reg, rtx_insn *insn)\n {\n   int iter;\n   lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n   struct lra_static_insn_data *static_id = id->insn_static_data;\n-  struct lra_insn_reg *reg;\n-  \n+  unsigned regno = reg->regno;\n+  int nregs;\n+\n+  if (regno >= FIRST_PSEUDO_REGISTER && reg_renumber[regno] >= 0)\n+    regno = reg_renumber[regno];\n+  if (regno >= FIRST_PSEUDO_REGISTER)\n+    nregs = 1;\n+  else\n+    nregs = hard_regno_nregs[regno][reg->biggest_mode];\n+\n+  struct lra_insn_reg *reg2;\n+\n   for (iter = 0; iter < 2; iter++)\n-    for (reg = (iter == 0 ? id->regs : static_id->hard_regs);\n-\t reg != NULL;\n-\t reg = reg->next)\n-      if (reg->type == OP_IN && reg->regno == regno)\n-\treturn true;\n+    for (reg2 = (iter == 0 ? id->regs : static_id->hard_regs);\n+\t reg2 != NULL;\n+\t reg2 = reg2->next)\n+      {\n+\tif (reg2->type != OP_IN)\n+\t  continue;\n+\tunsigned regno2 = reg2->regno;\n+\tint nregs2;\n+\n+\tif (regno2 >= FIRST_PSEUDO_REGISTER && reg_renumber[regno2] >= 0)\n+\t  regno2 = reg_renumber[regno2];\n+\tif (regno >= FIRST_PSEUDO_REGISTER)\n+\t  nregs2 = 1;\n+\telse\n+\t  nregs2 = hard_regno_nregs[regno2][reg->biggest_mode];\n+\n+\tif ((regno2 + nregs2 - 1 >= regno && regno2 < regno + nregs)\n+\t    || (regno + nregs - 1 >= regno2 && regno < regno2 + nregs2))\n+\t  return true;\n+      }\n   return false;\n }\n \n@@ -833,7 +862,7 @@ calculate_gen_cands (void)\n \t\t\t  && dst_regno == cand->regno)\n \t\t\tcontinue;\n \t\t      if (cand->regno == reg->regno\n-\t\t\t  || input_regno_present_p (insn2, reg->regno))\n+\t\t\t  || reg_overlap_for_remat_p (reg, insn2))\n \t\t\t{\n \t\t\t  bitmap_clear_bit (gen_cands, cand->index);\n \t\t\t  bitmap_set_bit (&temp_bitmap, uid);\n@@ -1219,7 +1248,7 @@ do_remat (void)\n \t\t\t&& dst_regno == cand->regno)\n \t\t      continue;\n \t\t    if (cand->regno == reg->regno\n-\t\t\t|| input_regno_present_p (cand->insn, reg->regno))\n+\t\t\t|| reg_overlap_for_remat_p (reg, cand->insn))\n \t\t      bitmap_set_bit (&temp_bitmap, cand->index);\n \t\t  }\n "}, {"sha": "9198d81f75977bca366e66b9f7b8d302614ae076", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92348f098dd10358538932275a1196bd5c9caaac", "patch": "@@ -1,3 +1,8 @@\n+2016-03-11  Bernd Schmidt  <bschmidt@redhat.com>\n+\n+\tPR target/70123\n+\t* gcc.dg/torture/pr70123.c: New test.\n+\n 2016-03-11  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/70190"}, {"sha": "55b60779e96cffa2f95234ab2f7858ab02effeea", "filename": "gcc/testsuite/gcc.dg/torture/pr70123.c", "status": "added", "additions": 198, "deletions": 0, "changes": 198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70123.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92348f098dd10358538932275a1196bd5c9caaac/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70123.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr70123.c?ref=92348f098dd10358538932275a1196bd5c9caaac", "patch": "@@ -0,0 +1,198 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fPIC\" { target fpic } } */\n+__attribute__ ((noinline, noclone)) int\n+bar (int flag, const char *__restrict format, ...)\n+{\n+  asm volatile (\"\" : : \"r\" (flag), \"r\" (format) : \"memory\");\n+  return 0;\n+}\n+\n+extern inline __attribute__ ((__always_inline__, __gnu_inline__, __artificial__)) int\n+baz (const char *__restrict fmt, ...)\n+{\n+  return bar (1, fmt, __builtin_va_arg_pack ());\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f1 (void **a, const char *b, int *c)\n+{\n+  *a = 0;\n+  *c = 0;\n+  asm volatile (\"\" : : \"r\" (&a), \"r\" (b), \"r\" (&c) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f2 (void *a, int b, int c, long d[], int *e)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d), \"r\" (e) : \"memory\");\n+  return 1;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f3 (void *a, int *b)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f4 (void *a, const char *b, int c, int d, double *e, int f, char **g, int *h)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f5 (void *a, long long b, int c, char **d, char **e, char **f, const char *g, long long h, int *i)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (i) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f6 (void *a, int b, int *c, int *d)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f7 (void *a, int b, long long c, long long d, long long e, double *f, int *g)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f8 (void *a, int b, long long c, long long d, long long e, char *f, const char **g, int *h, int *i)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (i) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f9 (void *a, int b, long long c, long long d, long long e, char *f, int *g)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f10 (void *a, int b, long long c, long long d, long long e, unsigned char f, unsigned char *g, int *h, int *i)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (i) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f11 (void *a, int b, long long c, long long d, long long e, long f, long *g, int *h, int *i)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (i) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f12 (void *a, int b, long long c, long long d, long long e, float f, float *g, int *h, int *i)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f), \"r\" (g), \"r\" (h) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (i) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f13 (void *a, int b, long long c, long *d, long *e, int *f)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  asm volatile (\"\" : : \"r\" (e), \"r\" (f) : \"memory\");\n+  return 0;\n+}\n+\n+__attribute__ ((noinline, noclone)) int\n+f14 (void *a, int b, int *c, int *d)\n+{\n+  asm volatile (\"\" : : \"r\" (a), \"r\" (b), \"r\" (c), \"r\" (d) : \"memory\");\n+  return 0;\n+}\n+\n+volatile int a;\n+\n+int\n+main ()\n+{\n+  int b, c, d = 0, e, f = 0;\n+  long g, h;\n+  int j = 0;\n+  long k, l;\n+  int m;\n+  unsigned char n[21];\n+  long o[21];\n+  float p[21];\n+  double q[21];\n+  long r[3], s = 0;\n+  char t[42];\n+  char u[21];\n+  char *v[3];\n+  const char *w[21];\n+  double x[3] = { 15.1515151515151515, 16.1616161616161616, 17.1717171717171717 };\n+  char y[40], z[81];\n+  void *a2;\n+  char *b2[10], *c2[10], *d2[10];\n+  char e2[] = \"abcdefghijklm\";\n+  for (g = 0; g < 21; g++)\n+    w[g] = \"\";\n+  f1 (&a2, y, &b);\n+  if (b)\n+    goto lab;\n+  c = 32;\n+  if (f2 (a2, c, d, r, &b) > 0)\n+    __builtin_strcpy (z, \"12345678901234567890123478901234567\");\n+  if (f3 (a2, &b) > 0)\n+    goto lab;\n+  if (f4 (a2, \"abcdefg\", 1, j, x, 14, v, &b) > 0)\n+    goto lab;\n+  for (g = 0; g < a; g++)\n+    goto lab;\n+  f5 (a2, s, f, b2, c2, d2, e2, 0L, &b);\n+  if (f6 (a2, -1, &e, &b) > 0)\n+    goto lab;\n+  if (b > 0)\n+    goto lab;\n+  if (f6 (a2, 1, &e, &b) > 0)\n+    goto lab;\n+  f7 (a2, 8, g, 1, g, q, &b);\n+  for (g = 1; g <= 20; g++)\n+    {\n+      for (h = 0; h < g; h++)\n+\t{\n+\t  t[h] = 0;\n+\t  q[h] = 0;\n+\t}\n+      f8 (a2, 1, g, 1, 1, u, w, &m, &b);\n+      for (h = 0; h < g; h++)\n+\tbaz (\" %2d\", t[h]);\n+      baz (\" %d\\nX\", b);\n+      f9 (a2, 3, g, 1, g, t, &b);\n+      for (h = 0; h < g; h++)\n+\tbaz (\" %2d\", t[h]);\n+      f10 (a2, 4, g, 1, g, 99, n, &m, &b);\n+      f11 (a2, 6, g, 1, g, 99, o, &m, &b);\n+      f12 (a2, 7, g, 1, g, 99., p, &m, &b);\n+      f13 (a2, 8, g, &k, &l, &b);\n+    }\n+  f14 (a2, 1, &e, &b);\n+lab:\n+  return 0;\n+}"}]}