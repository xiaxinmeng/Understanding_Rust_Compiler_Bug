{"sha": "66713d62863188a9c2f64388043c1dc0213d6f98", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjY3MTNkNjI4NjMxODhhOWMyZjY0Mzg4MDQzYzFkYzAyMTNkNmY5OA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T09:22:32Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T09:22:32Z"}, "message": "[multiple changes]\n\n2009-04-29  Bob Duff  <duff@adacore.com>\n\n\t* exp_ch7.adb (Build_Final_List): For an access type that designates a\n\tTaft Amendment type, if the access type needs finalization, make sure\n\tthe implicit with clause for List_Controller occurs on the package spec.\n\n\t* rtsfind.adb (Text_IO_Kludge): Fine tune the creation of implicit\n\twith's created for the pseudo-children of Text_IO and friends. In\n\tparticular, avoid cycles, such as Ada.Wide_Text_IO.Integer_IO and\n\tAda.Text_IO.Integer_IO both with-ing each other.\n\n\t* sem.adb (Walk_Library_Items): Suppress assertion failure in certain\n\toddball cases when pragma Extend_System is used.\n\n\t* sem_ch12.adb (Get_Associated_Node): Prevent direct 'with' cycles in\n\tthe case where a package spec instantiates a generic whose body with's\n\tthis package, so Walk_Library_Items won't complain about cyclic with's.\n\n2009-04-29  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, prj-proc.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads,\n\tprj-pp.adb, prj-pp.ads, makeutl.adb, clean.adb, prj-nmsc.adb,\n\tmlib-tgt.adb, mlib-tgt.ads, prj-util.adb, prj-env.adb, prj-env.ads\n\t(Project_Id): now a real pointer to Project_Data, instead of an index\n\tinto the Projects_Table. This simplifies the API significantly, avoiding\n\textra lookups in this table and the need to pass the Project_Tree_Ref\n\tparameter in several cases\n\nFrom-SVN: r146931", "tree": {"sha": "beaafba67917b53f8d130ea623f45ab511d739a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/beaafba67917b53f8d130ea623f45ab511d739a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/66713d62863188a9c2f64388043c1dc0213d6f98", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66713d62863188a9c2f64388043c1dc0213d6f98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/66713d62863188a9c2f64388043c1dc0213d6f98", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/66713d62863188a9c2f64388043c1dc0213d6f98/comments", "author": null, "committer": null, "parents": [{"sha": "059caa3e91991b39866b6fa22bc69836ae9a9013", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/059caa3e91991b39866b6fa22bc69836ae9a9013", "html_url": "https://github.com/Rust-GCC/gccrs/commit/059caa3e91991b39866b6fa22bc69836ae9a9013"}], "stats": {"total": 3106, "additions": 1453, "deletions": 1653}, "files": [{"sha": "94f9eb7bd98dcc1f1bc6a0bd0bec659bfa4e841f", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -1,3 +1,31 @@\n+2009-04-29  Bob Duff  <duff@adacore.com>\n+\n+\t* exp_ch7.adb (Build_Final_List): For an access type that designates a\n+\tTaft Amendment type, if the access type needs finalization, make sure\n+\tthe implicit with clause for List_Controller occurs on the package spec.\n+\n+\t* rtsfind.adb (Text_IO_Kludge): Fine tune the creation of implicit\n+\twith's created for the pseudo-children of Text_IO and friends. In\n+\tparticular, avoid cycles, such as Ada.Wide_Text_IO.Integer_IO and\n+\tAda.Text_IO.Integer_IO both with-ing each other.\n+\n+\t* sem.adb (Walk_Library_Items): Suppress assertion failure in certain\n+\toddball cases when pragma Extend_System is used.\n+\n+\t* sem_ch12.adb (Get_Associated_Node): Prevent direct 'with' cycles in\n+\tthe case where a package spec instantiates a generic whose body with's\n+\tthis package, so Walk_Library_Items won't complain about cyclic with's.\n+\n+2009-04-29  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, prj-proc.adb, make.adb, mlib-prj.adb, prj.adb, prj.ads,\n+\tprj-pp.adb, prj-pp.ads, makeutl.adb, clean.adb, prj-nmsc.adb,\n+\tmlib-tgt.adb, mlib-tgt.ads, prj-util.adb, prj-env.adb, prj-env.ads\n+\t(Project_Id): now a real pointer to Project_Data, instead of an index\n+\tinto the Projects_Table. This simplifies the API significantly, avoiding\n+\textra lookups in this table and the need to pass the Project_Tree_Ref\n+\tparameter in several cases\n+\n 2009-04-29  Nicolas Setton  <setton@adacore.com>\n \n \t* gcc-interface/Makefile.in: Produce .dSYM files for shared libs on"}, {"sha": "54b408affe0791e1ce8fee56cb3d612b26d38eff", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 74, "deletions": 75, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -336,8 +336,6 @@ package body Clean is\n    procedure Clean_Archive (Project : Project_Id; Global : Boolean) is\n       Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n \n-      Data : constant Project_Data := Project_Tree.Projects.Table (Project);\n-\n       Lib_Prefix : String_Access;\n       Archive_Name : String_Access;\n       --  The name of the archive file for this project\n@@ -346,7 +344,7 @@ package body Clean is\n       --  The name of the archive dependency file for this project\n \n       Obj_Dir : constant String :=\n-                  Get_Name_String (Data.Object_Directory.Display_Name);\n+                  Get_Name_String (Project.Object_Directory.Display_Name);\n \n    begin\n       Change_Dir (Obj_Dir);\n@@ -356,10 +354,10 @@ package body Clean is\n \n       if Global then\n          Lib_Prefix :=\n-           new String'(\"lib\" & Get_Name_String (Data.Display_Name));\n+           new String'(\"lib\" & Get_Name_String (Project.Display_Name));\n       else\n          Lib_Prefix :=\n-           new String'(\"lib\" & Get_Name_String (Data.Library_Name));\n+           new String'(\"lib\" & Get_Name_String (Project.Library_Name));\n       end if;\n \n       Archive_Name := new String'(Lib_Prefix.all & '.' & Archive_Ext);\n@@ -540,7 +538,6 @@ package body Clean is\n \n    procedure Clean_Interface_Copy_Directory (Project : Project_Id) is\n       Current : constant String := Get_Current_Dir;\n-      Data    : constant Project_Data := Project_Tree.Projects.Table (Project);\n \n       Direc : Dir_Type;\n \n@@ -551,10 +548,12 @@ package body Clean is\n       Unit        : Unit_Data;\n \n    begin\n-      if Data.Library and then Data.Library_Src_Dir /= No_Path_Information then\n+      if Project.Library\n+        and then Project.Library_Src_Dir /= No_Path_Information\n+      then\n          declare\n             Directory : constant String :=\n-                          Get_Name_String (Data.Library_Src_Dir.Display_Name);\n+                        Get_Name_String (Project.Library_Src_Dir.Display_Name);\n \n          begin\n             Change_Dir (Directory);\n@@ -634,9 +633,8 @@ package body Clean is\n \n    procedure Clean_Library_Directory (Project : Project_Id) is\n       Current : constant String := Get_Current_Dir;\n-      Data    : constant Project_Data := Project_Tree.Projects.Table (Project);\n \n-      Lib_Filename : constant String := Get_Name_String (Data.Library_Name);\n+      Lib_Filename : constant String := Get_Name_String (Project.Library_Name);\n       DLL_Name     : String :=\n                        DLL_Prefix & Lib_Filename & \".\" & DLL_Ext;\n       Archive_Name : String :=\n@@ -652,22 +650,22 @@ package body Clean is\n       Major : String_Access := Empty_String'Access;\n \n    begin\n-      if Data.Library then\n-         if Data.Library_Kind /= Static\n+      if Project.Library then\n+         if Project.Library_Kind /= Static\n            and then MLib.Tgt.Library_Major_Minor_Id_Supported\n-           and then Data.Lib_Internal_Name /= No_Name\n+           and then Project.Lib_Internal_Name /= No_Name\n          then\n-            Minor := new String'(Get_Name_String (Data.Lib_Internal_Name));\n+            Minor := new String'(Get_Name_String (Project.Lib_Internal_Name));\n             Major := new String'(MLib.Major_Id_Name (DLL_Name, Minor.all));\n          end if;\n \n          declare\n             Lib_Directory     : constant String :=\n                                   Get_Name_String\n-                                    (Data.Library_Dir.Display_Name);\n+                                    (Project.Library_Dir.Display_Name);\n             Lib_ALI_Directory : constant String :=\n                                   Get_Name_String\n-                                    (Data.Library_ALI_Dir.Display_Name);\n+                                    (Project.Library_ALI_Dir.Display_Name);\n \n          begin\n             Canonical_Case_File_Name (Archive_Name);\n@@ -686,22 +684,26 @@ package body Clean is\n \n                declare\n                   Filename : constant String := Name (1 .. Last);\n+\n                begin\n                   if Is_Regular_File (Filename)\n                     or else Is_Symbolic_Link (Filename)\n                   then\n                      Canonical_Case_File_Name (Name (1 .. Last));\n                      Delete_File := False;\n \n-                     if (Data.Library_Kind = Static\n-                         and then Name (1 .. Last) =  Archive_Name)\n+                     if (Project.Library_Kind = Static\n+                          and then Name (1 .. Last) =  Archive_Name)\n                        or else\n-                         ((Data.Library_Kind = Dynamic or else\n-                             Data.Library_Kind = Relocatable)\n+                         ((Project.Library_Kind = Dynamic\n+                             or else\n+                           Project.Library_Kind = Relocatable)\n                           and then\n                             (Name (1 .. Last) = DLL_Name\n-                             or else Name (1 .. Last) = Minor.all\n-                             or else Name (1 .. Last) = Major.all))\n+                               or else\n+                             Name (1 .. Last) = Minor.all\n+                               or else\n+                             Name (1 .. Last) = Major.all))\n                      then\n                         if not Do_Nothing then\n                            Set_Writable (Filename);\n@@ -747,7 +749,7 @@ package body Clean is\n                               if Unit.File_Names (Body_Part).Project /=\n                                 No_Project\n                               then\n-                                 if  Ultimate_Extension_Of\n+                                 if Ultimate_Extension_Of\n                                    (Unit.File_Names (Body_Part).Project) =\n                                    Project\n                                  then\n@@ -817,8 +819,6 @@ package body Clean is\n       --  Name of the executable file\n \n       Current_Dir : constant Dir_Name_Str := Get_Current_Dir;\n-      Data        : constant Project_Data :=\n-                      Project_Tree.Projects.Table (Project);\n       U_Data      : Unit_Data;\n       File_Name1  : File_Name_Type;\n       Index1      : Int;\n@@ -834,25 +834,25 @@ package body Clean is\n \n       if Project = Main_Project\n         and then Osint.Number_Of_Files /= 0\n-        and then Data.Library\n+        and then Project.Library\n       then\n          Osint.Fail\n            (\"Cannot specify executable(s) for a Library Project File\");\n       end if;\n \n       --  Nothing to clean in an externally built project\n \n-      if Data.Externally_Built then\n+      if Project.Externally_Built then\n          if Verbose_Mode then\n             Put (\"Nothing to do to clean externally built project \"\"\");\n-            Put (Get_Name_String (Data.Name));\n+            Put (Get_Name_String (Project.Name));\n             Put_Line (\"\"\"\");\n          end if;\n \n       else\n          if Verbose_Mode then\n             Put (\"Cleaning project \"\"\");\n-            Put (Get_Name_String (Data.Name));\n+            Put (Get_Name_String (Project.Name));\n             Put_Line (\"\"\"\");\n          end if;\n \n@@ -861,11 +861,11 @@ package body Clean is\n          Processed_Projects.Increment_Last;\n          Processed_Projects.Table (Processed_Projects.Last) := Project;\n \n-         if Data.Object_Directory /= No_Path_Information then\n+         if Project.Object_Directory /= No_Path_Information then\n             declare\n                Obj_Dir : constant String :=\n                            Get_Name_String\n-                             (Data.Object_Directory.Display_Name);\n+                             (Project.Object_Directory.Display_Name);\n \n             begin\n                Change_Dir (Obj_Dir);\n@@ -878,8 +878,8 @@ package body Clean is\n                --  Source_Dirs or Source_Files is specified as an empty list,\n                --  so always look for Ada units in extending projects.\n \n-               if Has_Ada_Sources (Data)\n-                 or else Data.Extends /= No_Project\n+               if Has_Ada_Sources (Project)\n+                 or else Project.Extends /= No_Project\n                then\n                   for Unit in Unit_Table.First ..\n                     Unit_Table.Last (Project_Tree.Units)\n@@ -1022,19 +1022,23 @@ package body Clean is\n                --  Check if a global archive and it dependency file could have\n                --  been created and, if they exist, delete them.\n \n-               if Project = Main_Project and then not Data.Library then\n+               if Project = Main_Project and then not Project.Library then\n                   Global_Archive := False;\n \n-                  for Proj in Project_Table.First ..\n-                    Project_Table.Last (Project_Tree.Projects)\n-                  loop\n-                     if Has_Foreign_Sources\n-                          (Project_Tree.Projects.Table (Proj))\n-                     then\n-                        Global_Archive := True;\n-                        exit;\n-                     end if;\n-                  end loop;\n+                  declare\n+                     Proj : Project_List;\n+\n+                  begin\n+                     Proj := Project_Tree.Projects;\n+                     while Proj /= null loop\n+                        if Has_Foreign_Sources (Proj.Project) then\n+                           Global_Archive := True;\n+                           exit;\n+                        end if;\n+\n+                        Proj := Proj.Next;\n+                     end loop;\n+                  end;\n \n                   if Global_Archive then\n                      Clean_Archive (Project, Global => True);\n@@ -1050,21 +1054,21 @@ package body Clean is\n \n          --  The directories are cleaned only if switch -c is not specified\n \n-         if Data.Library then\n+         if Project.Library then\n             if not Compile_Only then\n                Clean_Library_Directory (Project);\n \n-               if Data.Library_Src_Dir /= No_Path_Information then\n+               if Project.Library_Src_Dir /= No_Path_Information then\n                   Clean_Interface_Copy_Directory (Project);\n                end if;\n             end if;\n \n-            if Data.Standalone_Library and then\n-              Data.Object_Directory /= No_Path_Information\n+            if Project.Standalone_Library and then\n+              Project.Object_Directory /= No_Path_Information\n             then\n                Delete_Binder_Generated_Files\n-                 (Get_Name_String (Data.Object_Directory.Display_Name),\n-                  File_Name_Type (Data.Library_Name));\n+                 (Get_Name_String (Project.Object_Directory.Display_Name),\n+                  File_Name_Type (Project.Library_Name));\n             end if;\n          end if;\n \n@@ -1085,7 +1089,7 @@ package body Clean is\n             --  For each imported project, call Clean_Project if the project\n             --  has not been processed already.\n \n-            Imported := Data.Imported_Projects;\n+            Imported := Project.Imported_Projects;\n             while Imported /= null loop\n                Process := True;\n \n@@ -1110,8 +1114,8 @@ package body Clean is\n             --  called before, because no other project may import or extend\n             --  this project.\n \n-            if Data.Extends /= No_Project then\n-               Clean_Project (Data.Extends);\n+            if Project.Extends /= No_Project then\n+               Clean_Project (Project.Extends);\n             end if;\n          end;\n       end if;\n@@ -1122,11 +1126,11 @@ package body Clean is\n          --  The executables are deleted only if switch -c is not specified\n \n       if Project = Main_Project\n-        and then Data.Exec_Directory /= No_Path_Information\n+        and then Project.Exec_Directory /= No_Path_Information\n       then\n          declare\n             Exec_Dir : constant String :=\n-                         Get_Name_String (Data.Exec_Directory.Display_Name);\n+                         Get_Name_String (Project.Exec_Directory.Display_Name);\n \n          begin\n             Change_Dir (Exec_Dir);\n@@ -1160,9 +1164,9 @@ package body Clean is\n                   end;\n                end if;\n \n-               if Data.Object_Directory /= No_Path_Information then\n+               if Project.Object_Directory /= No_Path_Information then\n                   Delete_Binder_Generated_Files\n-                    (Get_Name_String (Data.Object_Directory.Display_Name),\n+                    (Get_Name_String (Project.Object_Directory.Display_Name),\n                      Strip_Suffix (Main_Source_File));\n                end if;\n             end loop;\n@@ -1391,7 +1395,7 @@ package body Clean is\n          --  Add source directories and object directories to the search paths\n \n          Add_Source_Directories (Main_Project, Project_Tree);\n-         Add_Object_Directories (Main_Project, Project_Tree);\n+         Add_Object_Directories (Main_Project);\n       end if;\n \n       Osint.Add_Default_Search_Dirs;\n@@ -1402,9 +1406,8 @@ package body Clean is\n \n       if Main_Project /= No_Project and then Osint.Number_Of_Files = 0 then\n          declare\n-            Value : String_List_Id :=\n-                      Project_Tree.Projects.Table (Main_Project).Mains;\n             Main  : String_Element;\n+            Value : String_List_Id := Main_Project.Mains;\n          begin\n             while Value /= Prj.Nil_String loop\n                Main := Project_Tree.String_Elements.Table (Value);\n@@ -1466,7 +1469,7 @@ package body Clean is\n      (Of_Project : Project_Id;\n       Prj        : Project_Id) return Boolean\n    is\n-      Data : Project_Data;\n+      Proj : Project_Id;\n \n    begin\n       if Prj = No_Project or else Of_Project = No_Project then\n@@ -1477,24 +1480,22 @@ package body Clean is\n          return True;\n       end if;\n \n-      Data := Project_Tree.Projects.Table (Of_Project);\n-\n-      while Data.Extends /= No_Project loop\n-         if Data.Extends = Prj then\n+      Proj := Of_Project;\n+      while Proj.Extends /= No_Project loop\n+         if Proj.Extends = Prj then\n             return True;\n          end if;\n \n-         Data := Project_Tree.Projects.Table (Data.Extends);\n+         Proj := Proj.Extends;\n       end loop;\n \n-      Data := Project_Tree.Projects.Table (Prj);\n-\n-      while Data.Extends /= No_Project loop\n-         if Data.Extends = Of_Project then\n+      Proj := Prj;\n+      while Proj.Extends /= No_Project loop\n+         if Proj.Extends = Of_Project then\n             return True;\n          end if;\n \n-         Data := Project_Tree.Projects.Table (Data.Extends);\n+         Proj := Proj.Extends;\n       end loop;\n \n       return False;\n@@ -1910,14 +1911,12 @@ package body Clean is\n \n    function Ultimate_Extension_Of (Project : Project_Id) return Project_Id is\n       Result : Project_Id := Project;\n-      Data   : Project_Data;\n \n    begin\n       if Project /= No_Project then\n          loop\n-            Data := Project_Tree.Projects.Table (Result);\n-            exit when Data.Extended_By = No_Project;\n-            Result := Data.Extended_By;\n+            exit when Result.Extended_By = No_Project;\n+            Result := Result.Extended_By;\n          end loop;\n       end if;\n "}, {"sha": "5eeae1e4c7c80595561027c0e0e2b093834d132c", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -442,6 +442,37 @@ package body Exp_Ch7 is\n             New_Reference_To\n               (RTE (RE_List_Controller), Loc));\n \n+      if Has_Completion_In_Body (Directly_Designated_Type (Typ))\n+        and then In_Package_Body (Current_Scope)\n+        and then\n+          Nkind (Parent (Declaration_Node (Typ))) = N_Package_Specification\n+      then\n+         --  The type is declared in a package declaration and designates a\n+         --  Taft amendment type that requires finalization. In general we\n+         --  assume that TA types are controlled, but we inhibit this\n+         --  worst-case assumption for runtime files, for efficiency reasons\n+         --  (see exp_ch3.adb). The reference to RE_List_Controller may have\n+         --  added a with_clause to the current body. Formally the spec needs\n+         --  the with_clause as well, so we add it now, for use by codepeer.\n+\n+         declare\n+            Loc         : constant Source_Ptr := Sloc (Typ);\n+            Spec_Unit   : constant Node_Id :=\n+                            Library_Unit (Cunit (Current_Sem_Unit));\n+            List_Scope  : constant Entity_Id :=\n+                            Scope (RTE (RE_List_Controller));\n+            With_Clause : constant Node_Id :=\n+                            Make_With_Clause (Loc,\n+                              Name => New_Occurrence_Of (List_Scope, Loc));\n+         begin\n+            Set_Library_Unit\n+              (With_Clause, Parent (Unit_Declaration_Node (List_Scope)));\n+            Set_Corresponding_Spec (With_Clause, List_Scope);\n+            Set_Implicit_With (With_Clause);\n+            Append (With_Clause, Context_Items (Spec_Unit));\n+         end;\n+      end if;\n+\n       --  The type may have been frozen already, and this is a late freezing\n       --  action, in which case the declaration must be elaborated at once.\n       --  If the call is for an allocator, the chain must also be created now,"}, {"sha": "899f71db5771b4611e50f5e8932ec04145b02bc0", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 55, "deletions": 92, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -327,20 +327,19 @@ procedure GNATCmd is\n       if Add_Sources then\n          declare\n             Current_Last : constant Integer := Last_Switches.Last;\n+            Proj         : Project_List;\n+\n          begin\n             --  Gnatstack needs to add the .ci file for the binder\n             --  generated files corresponding to all of the library projects\n             --  and main units belonging to the application.\n \n             if The_Command = Stack then\n-               for Proj in Project_Table.First ..\n-                           Project_Table.Last (Project_Tree.Projects)\n-               loop\n-                  if Check_Project (Proj, Project) then\n+               Proj := Project_Tree.Projects;\n+               while Proj /= null loop\n+                  if Check_Project (Proj.Project, Project) then\n                      declare\n-                        Data : Project_Data renames\n-                                 Project_Tree.Projects.Table (Proj);\n-                        Main : String_List_Id := Data.Mains;\n+                        Main : String_List_Id := Proj.Project.Mains;\n                         File : String_Access;\n \n                      begin\n@@ -349,7 +348,8 @@ procedure GNATCmd is\n                         while Main /= Nil_String loop\n                            File :=\n                              new String'\n-                               (Get_Name_String (Data.Object_Directory.Name) &\n+                               (Get_Name_String\n+                                    (Proj.Project.Object_Directory.Name)     &\n                                 Directory_Separator                          &\n                                 B_Start.all                                  &\n                                 MLib.Fil.Ext_To\n@@ -367,18 +367,19 @@ procedure GNATCmd is\n                              Project_Tree.String_Elements.Table (Main).Next;\n                         end loop;\n \n-                        if Data.Library then\n+                        if Proj.Project.Library then\n \n                            --  Include the .ci file for the binder generated\n                            --  files that contains the initialization and\n                            --  finalization of the library.\n \n                            File :=\n                              new String'\n-                               (Get_Name_String (Data.Object_Directory.Name) &\n+                               (Get_Name_String\n+                                    (Proj.Project.Object_Directory.Name)     &\n                                 Directory_Separator                          &\n                                 B_Start.all                                  &\n-                                Get_Name_String (Data.Library_Name)          &\n+                                Get_Name_String (Proj.Project.Library_Name)  &\n                                 \".ci\");\n \n                            if Is_Regular_File (File.all) then\n@@ -388,6 +389,8 @@ procedure GNATCmd is\n                         end if;\n                      end;\n                   end if;\n+\n+                  Proj := Proj.Next;\n                end loop;\n             end if;\n \n@@ -516,9 +519,8 @@ procedure GNATCmd is\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'\n                                (Get_Name_String\n-                                    (Project_Tree.Projects.Table\n-                                         (Unit_Data.File_Names\n-                                              (Body_Part).Project).\n+                                    (Unit_Data.File_Names\n+                                       (Body_Part).Project.\n                                          Object_Directory.Name)      &\n                                 Directory_Separator                  &\n                                 MLib.Fil.Ext_To\n@@ -546,9 +548,8 @@ procedure GNATCmd is\n                         Last_Switches.Table (Last_Switches.Last) :=\n                           new String'\n                             (Get_Name_String\n-                                 (Project_Tree.Projects.Table\n-                                      (Unit_Data.File_Names\n-                                           (Specification).Project).\n+                                 (Unit_Data.File_Names\n+                                   (Specification).Project.\n                                       Object_Directory.Name)         &\n                              Dir_Separator                           &\n                              MLib.Fil.Ext_To\n@@ -646,6 +647,8 @@ procedure GNATCmd is\n      (Project      : Project_Id;\n       Root_Project : Project_Id) return Boolean\n    is\n+      Proj : Project_Id;\n+\n    begin\n       if Project = No_Project then\n          return False;\n@@ -654,19 +657,14 @@ procedure GNATCmd is\n          return True;\n \n       elsif The_Command = Metric then\n-         declare\n-            Data : Project_Data;\n-\n-         begin\n-            Data := Project_Tree.Projects.Table (Root_Project);\n-            while Data.Extends /= No_Project loop\n-               if Project = Data.Extends then\n-                  return True;\n-               end if;\n+         Proj := Root_Project;\n+         while Proj.Extends /= No_Project loop\n+            if Project = Proj.Extends then\n+               return True;\n+            end if;\n \n-               Data := Project_Tree.Projects.Table (Data.Extends);\n-            end loop;\n-         end;\n+            Proj := Proj.Extends;\n+         end loop;\n       end if;\n \n       return False;\n@@ -690,8 +688,7 @@ procedure GNATCmd is\n             end if;\n          end loop;\n \n-         Get_Name_String (Project_Tree.Projects.Table\n-                            (Project).Exec_Directory.Name);\n+         Get_Name_String (Project.Exec_Directory.Name);\n \n          if Name_Buffer (Name_Len) /= Directory_Separator then\n             Name_Len := Name_Len + 1;\n@@ -714,7 +711,7 @@ procedure GNATCmd is\n    begin\n       Prj.Env.Create_Config_Pragmas_File\n         (Project, Project, Project_Tree, Include_Config_Files => False);\n-      return Project_Tree.Projects.Table (Project).Config_File_Name;\n+      return Project.Config_File_Name;\n    end Configuration_Pragmas_File;\n \n    ------------------------------\n@@ -723,6 +720,7 @@ procedure GNATCmd is\n \n    procedure Delete_Temp_Config_Files is\n       Success : Boolean;\n+      Proj    : Project_List;\n       pragma Warnings (Off, Success);\n \n    begin\n@@ -731,27 +729,22 @@ procedure GNATCmd is\n       pragma Assert (not Keep_Temporary_Files);\n \n       if Project /= No_Project then\n-         for Prj in Project_Table.First ..\n-                    Project_Table.Last (Project_Tree.Projects)\n-         loop\n-            if\n-              Project_Tree.Projects.Table (Prj).Config_File_Temp\n-            then\n+         Proj := Project_Tree.Projects;\n+         while Proj /= null loop\n+            if Proj.Project.Config_File_Temp then\n                if Verbose_Mode then\n                   Output.Write_Str (\"Deleting temp configuration file \"\"\");\n                   Output.Write_Str\n-                    (Get_Name_String\n-                       (Project_Tree.Projects.Table\n-                          (Prj).Config_File_Name));\n+                    (Get_Name_String (Proj.Project.Config_File_Name));\n                   Output.Write_Line (\"\"\"\");\n                end if;\n \n                Delete_File\n-                 (Name =>\n-                    Get_Name_String\n-                      (Project_Tree.Projects.Table (Prj).Config_File_Name),\n+                 (Name    => Get_Name_String (Proj.Project.Config_File_Name),\n                   Success => Success);\n             end if;\n+\n+            Proj := Proj.Next;\n          end loop;\n       end if;\n \n@@ -946,7 +939,7 @@ procedure GNATCmd is\n       --  Check if there are library project files\n \n       if MLib.Tgt.Support_For_Libraries /= None then\n-         Set_Libraries (Project, Project_Tree, Libraries_Present);\n+         Set_Libraries (Project, Libraries_Present);\n       end if;\n \n       --  If there are, add the necessary additional switches\n@@ -1129,9 +1122,7 @@ procedure GNATCmd is\n                      Project_Loop : loop\n                         declare\n                            Dir : constant String :=\n-                                   Get_Name_String\n-                                     (Project_Tree.Projects.Table\n-                                        (Prj).Object_Directory.Name);\n+                                   Get_Name_String (Prj.Object_Directory.Name);\n                         begin\n                            if Is_Regular_File\n                                 (Dir &\n@@ -1154,8 +1145,7 @@ procedure GNATCmd is\n \n                         --  Go to the project being extended, if any\n \n-                        Prj :=\n-                          Project_Tree.Projects.Table (Prj).Extends;\n+                        Prj := Prj.Extends;\n                         exit Project_Loop when Prj = No_Project;\n                      end loop Project_Loop;\n                   end if;\n@@ -1210,9 +1200,7 @@ procedure GNATCmd is\n                   Last_Switches.Increment_Last;\n                   Last_Switches.Table (Last_Switches.Last) :=\n                     new String'(\"-o\");\n-                  Get_Name_String\n-                    (Project_Tree.Projects.Table\n-                       (Project).Exec_Directory.Name);\n+                  Get_Name_String (Project.Exec_Directory.Name);\n                   Last_Switches.Increment_Last;\n                   Last_Switches.Table (Last_Switches.Last) :=\n                     new String'(Name_Buffer (1 .. Name_Len) &\n@@ -1240,39 +1228,30 @@ procedure GNATCmd is\n    begin\n       --  Case of library project\n \n-      if Project_Tree.Projects.Table (Project).Library then\n+      if Project.Library then\n          Libraries_Present := True;\n \n          --  Add the -L switch\n \n          Last_Switches.Increment_Last;\n          Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-L\" &\n-                       Get_Name_String\n-                         (Project_Tree.Projects.Table\n-                            (Project).Library_Dir.Name));\n+           new String'(\"-L\" & Get_Name_String (Project.Library_Dir.Name));\n \n          --  Add the -l switch\n \n          Last_Switches.Increment_Last;\n          Last_Switches.Table (Last_Switches.Last) :=\n-           new String'(\"-l\" &\n-                       Get_Name_String\n-                         (Project_Tree.Projects.Table\n-                            (Project).Library_Name));\n+           new String'(\"-l\" & Get_Name_String (Project.Library_Name));\n \n          --  Add the directory to table Library_Paths, to be processed later\n          --  if library is not static and if Path_Option is not null.\n \n-         if Project_Tree.Projects.Table (Project).Library_Kind /=\n-              Static\n+         if Project.Library_Kind /= Static\n            and then Path_Option /= null\n          then\n             Library_Paths.Increment_Last;\n             Library_Paths.Table (Library_Paths.Last) :=\n-              new String'(Get_Name_String\n-                            (Project_Tree.Projects.Table\n-                               (Project).Library_Dir.Name));\n+              new String'(Get_Name_String (Project.Library_Dir.Name));\n          end if;\n       end if;\n    end Set_Library_For;\n@@ -1915,13 +1894,10 @@ begin\n          --  file and if there is one, get the switches, if any, and scan them.\n \n          declare\n-            Data : constant Prj.Project_Data :=\n-                     Project_Tree.Projects.Table (Project);\n-\n             Pkg : constant Prj.Package_Id :=\n                     Prj.Util.Value_Of\n                       (Name        => Tool_Package_Name,\n-                       In_Packages => Data.Decl.Packages,\n+                       In_Packages => Project.Decl.Packages,\n                        In_Tree     => Project_Tree);\n \n             Element : Package_Element;\n@@ -2019,10 +1995,7 @@ begin\n            or else The_Command = Link\n            or else The_Command = Elim\n          then\n-            Change_Dir\n-              (Get_Name_String\n-                 (Project_Tree.Projects.Table\n-                    (Project).Object_Directory.Name));\n+            Change_Dir (Get_Name_String (Project.Object_Directory.Name));\n          end if;\n \n          --  Set up the env vars for project path files\n@@ -2044,13 +2017,10 @@ begin\n             --  Carg_Switches table.\n \n             declare\n-               Data : constant Prj.Project_Data :=\n-                        Project_Tree.Projects.Table (Project);\n-\n                Pkg  : constant Prj.Package_Id :=\n                         Prj.Util.Value_Of\n                           (Name        => Name_Compiler,\n-                           In_Packages => Data.Decl.Packages,\n+                           In_Packages => Project.Decl.Packages,\n                            In_Tree     => Project_Tree);\n \n                Element : Package_Element;\n@@ -2234,8 +2204,7 @@ begin\n                  (Last_Switches.Table (J), Current_Work_Dir);\n             end loop;\n \n-            Get_Name_String\n-              (Project_Tree.Projects.Table (Project).Directory.Name);\n+            Get_Name_String (Project.Directory.Name);\n \n             declare\n                Project_Dir : constant String := Name_Buffer (1 .. Name_Len);\n@@ -2248,8 +2217,6 @@ begin\n \n          elsif The_Command = Stub then\n             declare\n-               Data       : constant Prj.Project_Data :=\n-                              Project_Tree.Projects.Table (Project);\n                File_Index : Integer := 0;\n                Dir_Index  : Integer := 0;\n                Last       : constant Integer := Last_Switches.Last;\n@@ -2269,7 +2236,7 @@ begin\n                --  indicate to gnatstub the name of the body file with\n                --  a -o switch.\n \n-               if Body_Suffix_Id_Of (Project_Tree, Name_Ada, Data.Naming) /=\n+               if Body_Suffix_Id_Of (Project_Tree, Name_Ada, Project.Naming) /=\n                     Prj.Default_Ada_Spec_Suffix\n                then\n                   if File_Index /= 0 then\n@@ -2281,7 +2248,7 @@ begin\n                      begin\n                         Get_Name_String\n                           (Spec_Suffix_Id_Of\n-                             (Project_Tree, Name_Ada, Data.Naming));\n+                             (Project_Tree, Name_Ada, Project.Naming));\n \n                         if Spec'Length > Name_Len\n                           and then Spec (Last - Name_Len + 1 .. Last) =\n@@ -2290,7 +2257,7 @@ begin\n                            Last := Last - Name_Len;\n                            Get_Name_String\n                              (Body_Suffix_Id_Of\n-                                (Project_Tree, Name_Ada, Data.Naming));\n+                                (Project_Tree, Name_Ada, Project.Naming));\n                            Last_Switches.Increment_Last;\n                            Last_Switches.Table (Last_Switches.Last) :=\n                              new String'(\"-o\");\n@@ -2334,18 +2301,14 @@ begin\n          --  if there is no object directory available.\n \n          if The_Command = Metric\n-           and then\n-             Project_Tree.Projects.Table (Project).Object_Directory /=\n-               No_Path_Information\n+           and then Project.Object_Directory /= No_Path_Information\n          then\n             First_Switches.Increment_Last;\n             First_Switches.Table (2 .. First_Switches.Last) :=\n               First_Switches.Table (1 .. First_Switches.Last - 1);\n             First_Switches.Table (1) :=\n               new String'(\"-d=\" &\n-                          Get_Name_String\n-                            (Project_Tree.Projects.Table\n-                               (Project).Object_Directory.Name));\n+                          Get_Name_String (Project.Object_Directory.Name));\n          end if;\n \n          --  For gnat check, -rules and the following switches need to be the"}, {"sha": "0e274e81a0729738c7831eee7cd956f03681a193", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 298, "deletions": 362, "changes": 660, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -64,6 +64,7 @@ with Ada.Exceptions;            use Ada.Exceptions;\n with Ada.Command_Line;          use Ada.Command_Line;\n \n with GNAT.Directory_Operations; use GNAT.Directory_Operations;\n+with GNAT.Dynamic_HTables;      use GNAT.Dynamic_HTables;\n with GNAT.Case_Util;            use GNAT.Case_Util;\n with GNAT.OS_Lib;               use GNAT.OS_Lib;\n \n@@ -795,32 +796,41 @@ package body Make is\n    --  Mapping files\n    -----------------\n \n-   type Temp_Path_Names is\n-     array (Project_Id range <>, Positive range <>) of Path_Name_Type;\n-\n+   type Temp_Path_Names is array (Positive range <>) of Path_Name_Type;\n    type Temp_Path_Ptr is access Temp_Path_Names;\n \n-   type Indices is array (Project_Id range <>) of Natural;\n+   type Free_File_Indices is array (Positive range <>) of Positive;\n+   type Free_Indices_Ptr is access Free_File_Indices;\n \n-   type Indices_Ptr is access Indices;\n+   type Project_Compilation_Data is record\n+      Mapping_File_Names : Temp_Path_Ptr;\n+      --  The name ids of the temporary mapping files used. This is indexed\n+      --  on the maximum number of compilation processes we will be spawning\n+      --  (-j parameter)\n \n-   type Free_File_Indices is array\n-     (Project_Id range <>, Positive range <>) of Positive;\n+      Last_Mapping_File_Names : Natural;\n+      --  Index of the last mapping file created for this project\n \n-   type Free_Indices_Ptr is access Free_File_Indices;\n+      Free_Mapping_File_Indices : Free_Indices_Ptr;\n+      --  Indices in Mapping_File_Names of the mapping file names that can be\n+      --  reused for subsequent compilations.\n \n-   The_Mapping_File_Names : Temp_Path_Ptr;\n-   --  For each project, the name ids of the temporary mapping files used\n+      Last_Free_Indices : Natural;\n+      --  Number of mapping files that can be reused\n+   end record;\n+   --  Information necessary when compiling a project\n \n-   Last_Mapping_File_Names : Indices_Ptr;\n-   --  For each project, the index of the last mapping file created\n+   type Project_Compilation_Access is access Project_Compilation_Data;\n \n-   The_Free_Mapping_File_Indices : Free_Indices_Ptr;\n-   --  For each project, the indices in The_Mapping_File_Names of the mapping\n-   --  file names that can be reused for subsequent compilations.\n+   package Project_Compilation_Htable is new Simple_HTable\n+     (Header_Num => Prj.Header_Num,\n+      Element    => Project_Compilation_Access,\n+      No_Element => null,\n+      Key        => Project_Id,\n+      Hash       => Prj.Hash,\n+      Equal      => \"=\");\n \n-   Last_Free_Indices : Indices_Ptr;\n-   --  For each project, the number of mapping files that can be reused\n+   Project_Compilation : Project_Compilation_Htable.Instance;\n \n    Gnatmake_Mapping_File : String_Access := null;\n    --  The path name of a mapping file specified by switch -C=\n@@ -830,7 +840,8 @@ package body Make is\n    --  which ensures that Debug_Flag_N is False.\n \n    procedure Init_Mapping_File\n-     (Project : Project_Id;\n+     (Project    : Project_Id;\n+      Data       : in out Project_Compilation_Data;\n       File_Index : in out Natural);\n    --  Create a new temporary mapping file, and fill it with the project file\n    --  mappings, when using project file(s). The out parameter File_Index is\n@@ -1074,8 +1085,7 @@ package body Make is\n          Add_Lib_Search_Dir (Normalize_Pathname (Path));\n \n       else\n-         Get_Name_String\n-           (Project_Tree.Projects.Table (Main_Project).Directory.Display_Name);\n+         Get_Name_String (Main_Project.Directory.Display_Name);\n          Add_Lib_Search_Dir\n            (Normalize_Pathname (Path, Name_Buffer (1 .. Name_Len)));\n       end if;\n@@ -1126,8 +1136,7 @@ package body Make is\n          Add_Src_Search_Dir (Normalize_Pathname (Path));\n \n       else\n-         Get_Name_String\n-           (Project_Tree.Projects.Table (Main_Project).Directory.Display_Name);\n+         Get_Name_String (Main_Project.Directory.Display_Name);\n          Add_Src_Search_Dir\n            (Normalize_Pathname (Path, Name_Buffer (1 .. Name_Len)));\n       end if;\n@@ -1265,8 +1274,7 @@ package body Make is\n              (Source_File      => Name_Find,\n               Source_File_Name => File_Name,\n               Source_Index     => Index,\n-              Naming           => Project_Tree.Projects.Table\n-                                   (Main_Project).Naming,\n+              Naming           => Main_Project.Naming,\n               In_Package       => The_Package,\n               Allow_ALI        => Program = Binder or else Program = Linker);\n \n@@ -1388,16 +1396,14 @@ package body Make is\n \n       if Project_Of_Current_Object_Directory /= Actual_Project then\n          Project_Of_Current_Object_Directory := Actual_Project;\n-         Object_Directory :=\n-           Project_Tree.Projects.Table (Actual_Project).Object_Directory.Name;\n+         Object_Directory := Actual_Project.Object_Directory.Name;\n \n          --  Set the working directory to the object directory of the actual\n          --  project.\n \n          if Verbose_Mode then\n             Write_Str  (\"Changing to object directory of \"\"\");\n-            Write_Name\n-              (Project_Tree.Projects.Table (Actual_Project).Display_Name);\n+            Write_Name (Actual_Project.Display_Name);\n             Write_Str  (\"\"\": \"\"\");\n             Write_Name (Object_Directory);\n             Write_Line (\"\"\"\");\n@@ -1412,11 +1418,9 @@ package body Make is\n       when Directory_Error =>\n          Make_Failed (\"unable to change to object directory \"\"\" &\n                       Path_Or_File_Name\n-                        (Project_Tree.Projects.Table\n-                           (Actual_Project).Object_Directory.Name) &\n+                        (Actual_Project.Object_Directory.Name) &\n                       \"\"\" of project \" &\n-                      Get_Name_String (Project_Tree.Projects.Table\n-                                         (Actual_Project).Display_Name));\n+                      Get_Name_String (Actual_Project.Display_Name));\n    end Change_To_Object_Directory;\n \n    -----------\n@@ -1982,13 +1986,10 @@ package body Make is\n \n                   Obj_Dir := Name_Find;\n \n-                  while ALI_Project /= No_Project and then\n-                    Obj_Dir /=\n-                      Project_Tree.Projects.Table\n-                        (ALI_Project).Object_Directory.Name\n+                  while ALI_Project /= No_Project\n+                    and then Obj_Dir /= ALI_Project.Object_Directory.Name\n                   loop\n-                     ALI_Project :=\n-                       Project_Tree.Projects.Table (ALI_Project).Extended_By;\n+                     ALI_Project := ALI_Project.Extended_By;\n                   end loop;\n                end;\n \n@@ -2003,9 +2004,7 @@ package body Make is\n                --  If the ALI project is not extended, then it must be in\n                --  the correct object directory.\n \n-               if Project_Tree.Projects.Table (ALI_Project).Extended_By =\n-                 No_Project\n-               then\n+               if ALI_Project.Extended_By = No_Project then\n                   return;\n                end if;\n \n@@ -2019,7 +2018,7 @@ package body Make is\n                   Num_Ext := 0;\n                   Proj := ALI_Project;\n                   loop\n-                     Proj := Project_Tree.Projects.Table (Proj).Extended_By;\n+                     Proj := Proj.Extended_By;\n                      exit when Proj = No_Project;\n                      Num_Ext := Num_Ext + 1;\n                   end loop;\n@@ -2034,7 +2033,7 @@ package body Make is\n                   begin\n                      Proj := ALI_Project;\n                      for J in Projects'Range loop\n-                        Proj := Project_Tree.Projects.Table (Proj).Extended_By;\n+                        Proj := Proj.Extended_By;\n                         Projects (J) := Proj;\n                      end loop;\n \n@@ -2328,7 +2327,6 @@ package body Make is\n                                  Get_Name_String (Source_File);\n             Compiler_Package : Prj.Package_Id;\n             Switches         : Prj.Variable_Value;\n-            Data             : Project_Data;\n \n          begin\n             Prj.Env.\n@@ -2345,20 +2343,19 @@ package body Make is\n             if Arguments_Project = No_Project then\n                Add_Arguments (The_Saved_Gcc_Switches.all);\n \n-            elsif not Project_Tree.Projects.Table\n-                        (Arguments_Project).Externally_Built\n-            then\n+            elsif not Arguments_Project.Externally_Built then\n                --  We get the project directory for the relative path\n                --  switches and arguments.\n \n                Arguments_Project := Ultimate_Extending_Project_Of\n-                 (Arguments_Project, Project_Tree);\n-               Data := Project_Tree.Projects.Table (Arguments_Project);\n+                 (Arguments_Project);\n \n                --  If building a dynamic or relocatable library, compile with\n                --  PIC option, if it exists.\n \n-               if Data.Library and then Data.Library_Kind /= Static then\n+               if Arguments_Project.Library\n+                 and then Arguments_Project.Library_Kind /= Static\n+               then\n                   declare\n                      PIC : constant String := MLib.Tgt.PIC_Option;\n \n@@ -2375,7 +2372,7 @@ package body Make is\n                Compiler_Package :=\n                  Prj.Util.Value_Of\n                    (Name        => Name_Compiler,\n-                    In_Packages => Data.Decl.Packages,\n+                    In_Packages => Arguments_Project.Decl.Packages,\n                     In_Tree     => Project_Tree);\n \n                if Compiler_Package /= No_Package then\n@@ -2389,7 +2386,7 @@ package body Make is\n                       (Source_File      => Source_File,\n                        Source_File_Name => Source_File_Name,\n                        Source_Index     => Source_Index,\n-                       Naming           => Data.Naming,\n+                       Naming           => Arguments_Project.Naming,\n                        In_Package       => Compiler_Package,\n                        Allow_ALI        => False);\n \n@@ -2418,8 +2415,8 @@ package body Make is\n                         declare\n                            New_Args : Argument_List (1 .. Number);\n                            Last_New : Natural := 0;\n-                           Dir_Path : constant String :=\n-                             Get_Name_String (Data.Directory.Name);\n+                           Dir_Path : constant String := Get_Name_String\n+                             (Arguments_Project.Directory.Name);\n \n                         begin\n                            Current := Switches.Values;\n@@ -2461,7 +2458,7 @@ package body Make is\n                                      (1 => new String'\n                                             (Name_Buffer (1 .. Name_Len)));\n                         Dir_Path : constant String :=\n-                          Get_Name_String (Data.Directory.Name);\n+                          Get_Name_String (Arguments_Project.Directory.Name);\n \n                      begin\n                         Test_If_Relative_Path\n@@ -2705,6 +2702,7 @@ package body Make is\n       is\n          Pid     : Process_Id;\n          Project : Project_Id;\n+         Data    : Project_Compilation_Access;\n \n       begin\n          pragma Assert (Outstanding_Compiles > 0);\n@@ -2740,10 +2738,10 @@ package body Make is\n                   --  get its file name for reuse by a subsequent compilation\n \n                   if Running_Compile (J).Mapping_File /= No_Mapping_File then\n-                     Last_Free_Indices (Project) :=\n-                       Last_Free_Indices (Project) + 1;\n-                     The_Free_Mapping_File_Indices\n-                       (Project, Last_Free_Indices (Project)) :=\n+                     Data := Project_Compilation_Htable.Get\n+                       (Project_Compilation, Project);\n+                     Data.Last_Free_Indices := Data.Last_Free_Indices + 1;\n+                     Data.Free_Mapping_File_Indices (Data.Last_Free_Indices) :=\n                        Running_Compile (J).Mapping_File;\n                   end if;\n \n@@ -2853,33 +2851,23 @@ package body Make is\n          --  check for an eventual library project, and use the full path.\n \n          if Arguments_Project /= No_Project then\n-            if not Project_Tree.Projects.Table\n-                     (Arguments_Project).Externally_Built\n-            then\n+            if not Arguments_Project.Externally_Built then\n                Prj.Env.Set_Ada_Paths (Arguments_Project, Project_Tree, True);\n \n                if not Unique_Compile\n                  and then MLib.Tgt.Support_For_Libraries /= Prj.None\n                then\n                   declare\n-                     The_Data : Project_Data :=\n-                                  Project_Tree.Projects.Table\n-                                    (Arguments_Project);\n-\n-                     Prj : Project_Id := Arguments_Project;\n+                     Prj : constant Project_Id :=\n+                             Ultimate_Extending_Project_Of (Arguments_Project);\n \n                   begin\n-                     while The_Data.Extended_By /= No_Project loop\n-                        Prj := The_Data.Extended_By;\n-                        The_Data := Project_Tree.Projects.Table (Prj);\n-                     end loop;\n-\n-                     if The_Data.Library\n-                       and then not The_Data.Externally_Built\n-                       and then not The_Data.Need_To_Build_Lib\n+                     if Prj.Library\n+                       and then not Prj.Externally_Built\n+                       and then not Prj.Need_To_Build_Lib\n                      then\n                         --  Add to the Q all sources of the project that\n-                        --  have not been marked\n+                        --  have not been marked.\n \n                         Insert_Project_Sources\n                           (The_Project  => Prj,\n@@ -2888,8 +2876,7 @@ package body Make is\n \n                         --  Now mark the project as processed\n \n-                        Project_Tree.Projects.Table\n-                          (Prj).Need_To_Build_Lib := True;\n+                        Prj.Need_To_Build_Lib := True;\n                      end if;\n                   end;\n                end if;\n@@ -3130,18 +3117,22 @@ package body Make is\n       ----------------------\n \n       procedure Get_Mapping_File (Project : Project_Id) is\n+         Data : Project_Compilation_Access;\n+\n       begin\n+         Data := Project_Compilation_Htable.Get (Project_Compilation, Project);\n+\n          --  If there is a mapping file ready to be reused, reuse it\n \n-         if Last_Free_Indices (Project) > 0 then\n-            Mfile := The_Free_Mapping_File_Indices\n-                       (Project, Last_Free_Indices (Project));\n-            Last_Free_Indices (Project) := Last_Free_Indices (Project) - 1;\n+         if Data.Last_Free_Indices > 0 then\n+            Mfile := Data.Free_Mapping_File_Indices (Data.Last_Free_Indices);\n+            Data.Last_Free_Indices := Data.Last_Free_Indices - 1;\n \n          --  Otherwise, create and initialize a new one\n \n          else\n-            Init_Mapping_File (Project => Project, File_Index => Mfile);\n+            Init_Mapping_File\n+              (Project => Project, Data => Data.all, File_Index => Mfile);\n          end if;\n \n          --  Put the name in the mapping file argument for the invocation\n@@ -3150,9 +3141,7 @@ package body Make is\n          Free (Mapping_File_Arg);\n          Mapping_File_Arg :=\n            new String'(\"-gnatem=\" &\n-                       Get_Name_String\n-                         (The_Mapping_File_Names (Project, Mfile)));\n-\n+                       Get_Name_String (Data.Mapping_File_Names (Mfile)));\n       end Get_Mapping_File;\n \n       -----------------------\n@@ -3355,8 +3344,7 @@ package body Make is\n                   --  Do nothing if project of source is externally built\n \n                   if Arguments_Project = No_Project\n-                    or else not Project_Tree.Projects.Table\n-                                  (Arguments_Project).Externally_Built\n+                    or else not Arguments_Project.Externally_Built\n                   then\n                      --  Don't waste any time if we have to recompile anyway\n \n@@ -3748,9 +3736,7 @@ package body Make is\n             else\n                declare\n                   Parent_Directory : constant String :=\n-                    Get_Name_String\n-                      (Project_Tree.Projects.Table\n-                           (Project).Directory.Display_Name);\n+                    Get_Name_String (Project.Directory.Display_Name);\n \n                begin\n                   if Parent_Directory (Parent_Directory'Last) =\n@@ -3772,27 +3758,20 @@ package body Make is\n       Prj.Env.Create_Config_Pragmas_File\n         (For_Project, Main_Project, Project_Tree);\n \n-      if Project_Tree.Projects.Table\n-           (For_Project).Config_File_Name /= No_Path\n-      then\n-         Temporary_Config_File :=\n-           Project_Tree.Projects.Table (For_Project).Config_File_Temp;\n+      if For_Project.Config_File_Name /= No_Path then\n+         Temporary_Config_File := For_Project.Config_File_Temp;\n          Last := 1;\n          Result (1) :=\n            new String'\n-                 (\"-gnatec=\" &\n-                  Get_Name_String\n-                    (Project_Tree.Projects.Table\n-                       (For_Project).Config_File_Name));\n+                 (\"-gnatec=\" & Get_Name_String (For_Project.Config_File_Name));\n \n       else\n          Temporary_Config_File := False;\n       end if;\n \n       --  Check for attribute Builder'Global_Configuration_Pragmas\n \n-      The_Packages := Project_Tree.Projects.Table\n-                        (Main_Project).Decl.Packages;\n+      The_Packages := Main_Project.Decl.Packages;\n       Gnatmake :=\n         Prj.Util.Value_Of\n           (Name        => Name_Builder,\n@@ -3835,8 +3814,7 @@ package body Make is\n \n       --  Check for attribute Compiler'Local_Configuration_Pragmas\n \n-      The_Packages :=\n-        Project_Tree.Projects.Table (For_Project).Decl.Packages;\n+      The_Packages := For_Project.Decl.Packages;\n       Compiler :=\n         Prj.Util.Value_Of\n           (Name        => Name_Compiler,\n@@ -3927,21 +3905,29 @@ package body Make is\n       Success : Boolean;\n       pragma Warnings (Off, Success);\n \n+      Proj : Project_List;\n+      Data : Project_Compilation_Access;\n+\n    begin\n       --  The caller is responsible for ensuring that Debug_Flag_N is False\n \n       pragma Assert (not Debug.Debug_Flag_N);\n \n-      if The_Mapping_File_Names /= null then\n-         for Project in The_Mapping_File_Names'Range (1) loop\n-            for Index in 1 .. Last_Mapping_File_Names (Project) loop\n+      Proj := Project_Tree.Projects;\n+      while Proj /= null loop\n+         Data := Project_Compilation_Htable.Get\n+           (Project_Compilation, Proj.Project);\n+\n+         if Data /= null and then Data.Mapping_File_Names /= null then\n+            for Index in 1 .. Data.Last_Mapping_File_Names loop\n                Delete_File\n-                 (Name => Get_Name_String\n-                            (The_Mapping_File_Names (Project, Index)),\n+                 (Name => Get_Name_String (Data.Mapping_File_Names (Index)),\n                   Success => Success);\n             end loop;\n-         end loop;\n-      end if;\n+         end if;\n+\n+         Proj := Proj.Next;\n+      end loop;\n    end Delete_Mapping_Files;\n \n    ------------------------------\n@@ -3950,6 +3936,7 @@ package body Make is\n \n    procedure Delete_Temp_Config_Files is\n       Success : Boolean;\n+      Proj    : Project_List;\n       pragma Warnings (Off, Success);\n \n    begin\n@@ -3958,38 +3945,29 @@ package body Make is\n       pragma Assert (not Debug.Debug_Flag_N);\n \n       if Main_Project /= No_Project then\n-         for Project in Project_Table.First ..\n-                        Project_Table.Last (Project_Tree.Projects)\n-         loop\n-            if\n-              Project_Tree.Projects.Table (Project).Config_File_Temp\n-            then\n+         Proj := Project_Tree.Projects;\n+         while Proj /= null loop\n+            if Proj.Project.Config_File_Temp then\n                if Verbose_Mode then\n                   Write_Str (\"Deleting temp configuration file \"\"\");\n-                  Write_Str (Get_Name_String\n-                               (Project_Tree.Projects.Table\n-                                  (Project).Config_File_Name));\n+                  Write_Str (Get_Name_String (Proj.Project.Config_File_Name));\n                   Write_Line (\"\"\"\");\n                end if;\n \n                Delete_File\n-                 (Name    => Get_Name_String\n-                               (Project_Tree.Projects.Table\n-                                  (Project).Config_File_Name),\n+                 (Name    => Get_Name_String (Proj.Project.Config_File_Name),\n                   Success => Success);\n \n                --  Make sure that we don't have a config file for this project,\n                --  in case there are several mains. In this case, we will\n                --  recreate another config file: we cannot reuse the one that\n                --  we just deleted!\n \n-               Project_Tree.Projects.Table (Project).\n-                 Config_Checked := False;\n-               Project_Tree.Projects.Table (Project).\n-                 Config_File_Name := No_Path;\n-               Project_Tree.Projects.Table (Project).\n-                 Config_File_Temp := False;\n+               Proj.Project.Config_Checked := False;\n+               Proj.Project.Config_File_Name := No_Path;\n+               Proj.Project.Config_File_Temp := False;\n             end if;\n+            Proj := Proj.Next;\n          end loop;\n       end if;\n    end Delete_Temp_Config_Files;\n@@ -4247,8 +4225,6 @@ package body Make is\n          Proj              : Project_Id := No_Project;\n          --  The project of the current main\n \n-         Data              : Project_Data;\n-\n          Real_Path         : String_Access;\n \n       begin\n@@ -4286,25 +4262,23 @@ package body Make is\n                   --  is the actual path of a source of a project.\n \n                   if Main /= File_Name then\n-                     Data :=\n-                       Project_Tree.Projects.Table (Main_Project);\n-\n                      Real_Path :=\n                        Locate_Regular_File\n                          (Main &\n-                          Body_Suffix_Of (Project_Tree, \"ada\", Data.Naming),\n+                          Body_Suffix_Of\n+                            (Project_Tree, \"ada\", Main_Project.Naming),\n                           \"\");\n                      if Real_Path = null then\n                         Real_Path :=\n                           Locate_Regular_File\n                             (Main &\n-                             Spec_Suffix_Of (Project_Tree, \"ada\", Data.Naming),\n+                             Spec_Suffix_Of\n+                               (Project_Tree, \"ada\", Main_Project.Naming),\n                              \"\");\n                      end if;\n \n                      if Real_Path = null then\n-                        Real_Path :=\n-                          Locate_Regular_File (Main, \"\");\n+                        Real_Path := Locate_Regular_File (Main, \"\");\n                      end if;\n \n                      --  Fail if the file cannot be found\n@@ -4365,9 +4339,7 @@ package body Make is\n                         Make_Failed\n                           (\"\"\"\" & Main &\n                            \"\"\" is not a source of project \" &\n-                           Get_Name_String\n-                             (Project_Tree.Projects.Table\n-                                (Real_Main_Project).Name));\n+                           Get_Name_String (Real_Main_Project.Name));\n                      end if;\n                   end if;\n                end if;\n@@ -4470,30 +4442,25 @@ package body Make is\n                      --  extending project obj dir.\n \n                      if ALI_Name /= No_File\n-                       and then\n-                         Project_Tree.Projects.Table\n-                           (ALI_Project).Extended_By = No_Project\n-                         and then\n-                           Project_Tree.Projects.Table\n-                             (ALI_Project).Extends = No_Project\n+                       and then ALI_Project.Extended_By = No_Project\n+                       and then ALI_Project.Extends = No_Project\n                      then\n                         --  First check if the ALI file exists. If it does not,\n                         --  do not put the unit in the mapping file.\n \n                         declare\n                            ALI : constant String :=\n                                    Get_Name_String (ALI_Name);\n-                           PD  : Project_Data renames\n-                             Project_Tree.Projects.Table (ALI_Project);\n \n                         begin\n                            --  For library projects, use the library directory,\n                            --  for other projects, use the object directory.\n \n-                           if PD.Library then\n-                              Get_Name_String (PD.Library_Dir.Name);\n+                           if ALI_Project.Library then\n+                              Get_Name_String (ALI_Project.Library_Dir.Name);\n                            else\n-                              Get_Name_String (PD.Object_Directory.Name);\n+                              Get_Name_String\n+                                (ALI_Project.Object_Directory.Name);\n                            end if;\n \n                            if Name_Buffer (Name_Len) /=\n@@ -4623,7 +4590,7 @@ package body Make is\n \n          --  And the project file cannot be a library project file\n \n-         elsif Project_Tree.Projects.Table (Main_Project).Library then\n+         elsif Main_Project.Library then\n             Make_Failed (\"-B cannot be used for a library project file\");\n \n          else\n@@ -4664,7 +4631,7 @@ package body Make is\n          --  cannot be specified on the command line.\n \n          if Osint.Number_Of_Files /= 0 then\n-            if Project_Tree.Projects.Table (Main_Project).Library\n+            if Main_Project.Library\n               and then not Unique_Compile\n               and then ((not Make_Steps) or else Bind_Only or else Link_Only)\n             then\n@@ -4691,8 +4658,7 @@ package body Make is\n             end if;\n \n             declare\n-               Value : String_List_Id :=\n-                         Project_Tree.Projects.Table (Main_Project).Mains;\n+               Value : String_List_Id := Main_Project.Mains;\n \n             begin\n                --  The attribute Main is an empty list or not specified,\n@@ -4701,8 +4667,7 @@ package body Make is\n                if Value = Prj.Nil_String or else Unique_Compile then\n \n                   if (not Make_Steps) or else Compile_Only\n-                    or else not Project_Tree.Projects.Table\n-                                  (Main_Project).Library\n+                    or else not Main_Project.Library\n                   then\n                      --  First make sure that the binder and the linker\n                      --  will not be invoked.\n@@ -4740,13 +4705,10 @@ package body Make is\n                   --  all the sources of the project.\n \n                   declare\n-                     Data : constant Project_Data :=\n-                           Project_Tree.Projects.Table (Main_Project);\n-\n                      Languages : constant Variable_Value :=\n                                    Prj.Util.Value_Of\n                                     (Name_Languages,\n-                                     Data.Decl.Attributes,\n+                                     Main_Project.Decl.Attributes,\n                                      Project_Tree);\n \n                      Current : String_List_Id;\n@@ -4832,20 +4794,18 @@ package body Make is\n       end if;\n \n       if Main_Project /= No_Project\n-        and then Project_Tree.Projects.Table\n-                   (Main_Project).Externally_Built\n+        and then Main_Project.Externally_Built\n       then\n          Make_Failed\n            (\"nothing to do for a main project that is externally built\");\n       end if;\n \n       if Osint.Number_Of_Files = 0 then\n          if Main_Project /= No_Project\n-           and then Project_Tree.Projects.Table (Main_Project).Library\n+           and then Main_Project.Library\n          then\n             if Do_Bind_Step\n-              and then not Project_Tree.Projects.Table\n-                             (Main_Project).Standalone_Library\n+              and then not Main_Project.Standalone_Library\n             then\n                Make_Failed (\"only stand-alone libraries may be bound\");\n             end if;\n@@ -4939,9 +4899,7 @@ package body Make is\n \n       if Main_Project /= No_Project then\n \n-         if Project_Tree.Projects.Table\n-              (Main_Project).Object_Directory /= No_Path_Information\n-         then\n+         if Main_Project.Object_Directory /= No_Path_Information then\n             --  Change current directory to object directory of main project\n \n             Project_Of_Current_Object_Directory := No_Project;\n@@ -4967,8 +4925,7 @@ package body Make is\n                                            not Unique_Compile);\n \n             The_Packages : constant Package_Id :=\n-                             Project_Tree.Projects.Table\n-                               (Main_Project).Decl.Packages;\n+                             Main_Project.Decl.Packages;\n \n             Builder_Package : constant Prj.Package_Id :=\n                                 Prj.Util.Value_Of\n@@ -5316,51 +5273,52 @@ package body Make is\n          if not Unique_Compile\n            and then MLib.Tgt.Support_For_Libraries /= Prj.None\n          then\n-            for Proj in Project_Table.First ..\n-                        Project_Table.Last (Project_Tree.Projects)\n-            loop\n-               if Project_Tree.Projects.Table (Proj).Library then\n-                  Project_Tree.Projects.Table\n-                    (Proj).Need_To_Build_Lib :=\n-                      (not MLib.Tgt.Library_Exists_For (Proj, Project_Tree))\n-                    and then (not Project_Tree.Projects.Table\n-                                (Proj).Externally_Built);\n-\n-                  if Project_Tree.Projects.Table (Proj).Need_To_Build_Lib then\n+            declare\n+               Proj : Project_List;\n \n-                     --  If there is no object directory, then it will be\n-                     --  impossible to build the library. So fail immediately.\n+            begin\n+               Proj := Project_Tree.Projects;\n+               while Proj /= null loop\n+                  if Proj.Project.Library then\n+                     Proj.Project.Need_To_Build_Lib :=\n+                       not MLib.Tgt.Library_Exists_For\n+                         (Proj.Project, Project_Tree)\n+                       and then not Proj.Project.Externally_Built;\n+\n+                     if Proj.Project.Need_To_Build_Lib then\n+\n+                        --  If there is no object directory, then it will be\n+                        --  impossible to build the library. So fail\n+                        --  immediately.\n+\n+                        if\n+                          Proj.Project.Object_Directory = No_Path_Information\n+                        then\n+                           Make_Failed\n+                             (\"no object files to build library for project \"\"\"\n+                              & Get_Name_String (Proj.Project.Name)\n+                              & \"\"\"\");\n+                           Proj.Project.Need_To_Build_Lib := False;\n \n-                     if Project_Tree.Projects.Table (Proj).Object_Directory =\n-                                                        No_Path_Information\n-                     then\n-                        Make_Failed\n-                          (\"no object files to build library for project \"\"\"\n-                           & Get_Name_String\n-                              (Project_Tree.Projects.Table (Proj).Name)\n-                           & \"\"\"\");\n-                        Project_Tree.Projects.Table\n-                          (Proj).Need_To_Build_Lib := False;\n+                        else\n+                           if Verbose_Mode then\n+                              Write_Str\n+                                (\"Library file does not exist for project \"\"\");\n+                              Write_Str (Get_Name_String (Proj.Project.Name));\n+                              Write_Line (\"\"\"\");\n+                           end if;\n \n-                     else\n-                        if Verbose_Mode then\n-                           Write_Str\n-                             (\"Library file does not exist for project \"\"\");\n-                           Write_Str\n-                             (Get_Name_String\n-                                (Project_Tree.Projects.Table\n-                                   (Proj).Name));\n-                           Write_Line (\"\"\"\");\n+                           Insert_Project_Sources\n+                             (The_Project  => Proj.Project,\n+                              All_Projects => False,\n+                              Into_Q       => True);\n                         end if;\n-\n-                        Insert_Project_Sources\n-                          (The_Project  => Proj,\n-                           All_Projects => False,\n-                           Into_Q       => True);\n                      end if;\n                   end if;\n-               end if;\n-            end loop;\n+\n+                  Proj := Proj.Next;\n+               end loop;\n+            end;\n          end if;\n \n          --  If a relative path output file has been specified, we add\n@@ -5374,9 +5332,7 @@ package body Make is\n \n                begin\n                   if not Is_Absolute_Path (Exec_File_Name) then\n-                     Get_Name_String\n-                       (Project_Tree.Projects.Table\n-                          (Main_Project).Exec_Directory.Name);\n+                     Get_Name_String (Main_Project.Exec_Directory.Name);\n \n                      if Name_Buffer (Name_Len) /= Directory_Separator then\n                         Name_Len := Name_Len + 1;\n@@ -5403,9 +5359,7 @@ package body Make is\n \n          declare\n             Dir_Path : constant String :=\n-                         Get_Name_String\n-                           (Project_Tree.Projects.Table\n-                              (Main_Project).Directory.Name);\n+                         Get_Name_String (Main_Project.Directory.Name);\n          begin\n             for J in 1 .. Binder_Switches.Last loop\n                Test_If_Relative_Path\n@@ -5525,29 +5479,40 @@ package body Make is\n       --  Allocate as many temporary mapping file names as the maximum\n       --  number of compilation processed, for each possible project.\n \n-      The_Mapping_File_Names :=\n-        new Temp_Path_Names\n-          (No_Project .. Project_Table.Last (Project_Tree.Projects),\n-           1 .. Saved_Maximum_Processes);\n-      Last_Mapping_File_Names :=\n-        new Indices'\n-          (No_Project .. Project_Table.Last (Project_Tree.Projects)\n-            => 0);\n-\n-      The_Free_Mapping_File_Indices :=\n-        new Free_File_Indices\n-          (No_Project .. Project_Table.Last (Project_Tree.Projects),\n-           1 .. Saved_Maximum_Processes);\n-      Last_Free_Indices :=\n-        new Indices'(No_Project .. Project_Table.Last\n-                                     (Project_Tree.Projects) => 0);\n+      declare\n+         Data : Project_Compilation_Access;\n+         Proj : Project_List := Project_Tree.Projects;\n+      begin\n+         while Proj /= null loop\n+            Data := new Project_Compilation_Data'\n+              (Mapping_File_Names        => new Temp_Path_Names\n+                 (1 .. Saved_Maximum_Processes),\n+               Last_Mapping_File_Names   => 0,\n+               Free_Mapping_File_Indices => new Free_File_Indices\n+                 (1 .. Saved_Maximum_Processes),\n+               Last_Free_Indices         => 0);\n+            Project_Compilation_Htable.Set\n+              (Project_Compilation, Proj.Project, Data);\n+            Proj := Proj.Next;\n+         end loop;\n+\n+         Data := new Project_Compilation_Data'\n+           (Mapping_File_Names        => new Temp_Path_Names\n+              (1 .. Saved_Maximum_Processes),\n+            Last_Mapping_File_Names   => 0,\n+            Free_Mapping_File_Indices => new Free_File_Indices\n+              (1 .. Saved_Maximum_Processes),\n+            Last_Free_Indices         => 0);\n+         Project_Compilation_Htable.Set\n+           (Project_Compilation, No_Project, Data);\n+      end;\n \n       Bad_Compilation.Init;\n \n-      --  If project files are used, create the mapping of all the sources,\n-      --  so that the correct paths will be found. Otherwise, if there is\n-      --  a file which is not a source with the same name in a source directory\n-      --  this file may be incorrectly found.\n+      --  If project files are used, create the mapping of all the sources, so\n+      --  that the correct paths will be found. Otherwise, if there is a file\n+      --  which is not a source with the same name in a source directory this\n+      --  file may be incorrectly found.\n \n       if Main_Project /= No_Project then\n          Prj.Env.Create_Mapping (Project_Tree);\n@@ -5617,19 +5582,15 @@ package body Make is\n          end if;\n \n          if Main_Project /= No_Project\n-           and then\n-             Project_Tree.Projects.Table\n-               (Main_Project).Exec_Directory /= No_Path_Information\n+           and then Main_Project.Exec_Directory /= No_Path_Information\n          then\n             declare\n                Exec_File_Name : constant String :=\n                                   Get_Name_String (Executable);\n \n             begin\n                if not Is_Absolute_Path (Exec_File_Name) then\n-                  Get_Name_String\n-                    (Project_Tree.Projects.Table\n-                       (Main_Project).Exec_Directory.Display_Name);\n+                  Get_Name_String (Main_Project.Exec_Directory.Display_Name);\n \n                   if Name_Buffer (Name_Len) /= Directory_Separator then\n                      Name_Len := Name_Len + 1;\n@@ -5721,6 +5682,7 @@ package body Make is\n                   declare\n                      Depth   : Natural;\n                      Current : Natural;\n+                     Proj1   : Project_List;\n \n                      procedure Add_To_Library_Projs (Proj : Project_Id);\n                      --  Add project Project to table Library_Projs in\n@@ -5735,16 +5697,15 @@ package body Make is\n \n                      begin\n                         Library_Projs.Increment_Last;\n-                        Depth := Project_Tree.Projects.Table (Proj).Depth;\n+                        Depth := Proj.Depth;\n \n                         --  Put the projects in decreasing depth order, so that\n                         --  if libA depends on libB, libB is first in order.\n \n                         Current := Library_Projs.Last;\n                         while Current > 1 loop\n                            Prj := Library_Projs.Table (Current - 1);\n-                           exit when Project_Tree.Projects.Table\n-                             (Prj).Depth >= Depth;\n+                           exit when Prj.Depth >= Depth;\n                            Library_Projs.Table (Current) := Prj;\n                            Current := Current - 1;\n                         end loop;\n@@ -5759,66 +5720,52 @@ package body Make is\n                      --  Put in Library_Projs table all library project\n                      --  file ids when the library need to be rebuilt.\n \n-                     for Proj1 in Project_Table.First ..\n-                                  Project_Table.Last (Project_Tree.Projects)\n-                     loop\n-                        if Project_Tree.Projects.Table\n-                          (Proj1).Standalone_Library\n-                        then\n+                     Proj1 := Project_Tree.Projects;\n+                     while Proj1 /= null loop\n+                        if Proj1.Project.Standalone_Library then\n                            Stand_Alone_Libraries := True;\n                         end if;\n \n-                        if Project_Tree.Projects.Table (Proj1).Library then\n-                           MLib.Prj.Check_Library (Proj1, Project_Tree);\n+                        if Proj1.Project.Library then\n+                           MLib.Prj.Check_Library\n+                             (Proj1.Project, Project_Tree);\n                         end if;\n \n-                        if Project_Tree.Projects.Table\n-                             (Proj1).Need_To_Build_Lib\n-                        then\n-                           Add_To_Library_Projs (Proj1);\n+                        if Proj1.Project.Need_To_Build_Lib then\n+                           Add_To_Library_Projs (Proj1.Project);\n                         end if;\n+\n+                        Proj1 := Proj1.Next;\n                      end loop;\n \n                      --  Check if importing libraries should be regenerated\n                      --  because at least an imported library will be\n                      --  regenerated or is more recent.\n \n-                     for Proj1 in Project_Table.First ..\n-                                  Project_Table.Last (Project_Tree.Projects)\n-                     loop\n-                        if Project_Tree.Projects.Table (Proj1).Library\n-                          and then\n-                            Project_Tree.Projects.Table (Proj1).Library_Kind /=\n-                                                                        Static\n-                          and then not Project_Tree.Projects.Table\n-                                         (Proj1).Need_To_Build_Lib\n-                          and then not Project_Tree.Projects.Table\n-                                         (Proj1).Externally_Built\n+                     Proj1 := Project_Tree.Projects;\n+                     while Proj1 /= null loop\n+                        if Proj1.Project.Library\n+                          and then Proj1.Project.Library_Kind /= Static\n+                          and then not Proj1.Project.Need_To_Build_Lib\n+                          and then not Proj1.Project.Externally_Built\n                         then\n                            declare\n                               List    : Project_List;\n                               Proj2   : Project_Id;\n                               Rebuild : Boolean := False;\n \n                               Lib_Timestamp1 : constant Time_Stamp_Type :=\n-                                                 Project_Tree.Projects.Table\n-                                                   (Proj1).Library_TS;\n+                                                 Proj1.Project.Library_TS;\n \n                            begin\n-                              List := Project_Tree.Projects.Table (Proj1).\n-                                                      All_Imported_Projects;\n+                              List := Proj1.Project.All_Imported_Projects;\n                               while List /= null loop\n                                  Proj2 := List.Project;\n \n-                                 if\n-                                   Project_Tree.Projects.Table (Proj2).Library\n-                                 then\n-                                    if Project_Tree.Projects.Table (Proj2).\n-                                          Need_To_Build_Lib\n+                                 if Proj2.Library then\n+                                    if Proj2.Need_To_Build_Lib\n                                       or else\n-                                        (Lib_Timestamp1 <\n-                                             Project_Tree.Projects.Table\n-                                               (Proj2).Library_TS)\n+                                        (Lib_Timestamp1 < Proj2.Library_TS)\n                                     then\n                                        Rebuild := True;\n                                        exit;\n@@ -5829,22 +5776,22 @@ package body Make is\n                               end loop;\n \n                               if Rebuild then\n-                                 Project_Tree.Projects.Table\n-                                   (Proj1).Need_To_Build_Lib := True;\n-                                 Add_To_Library_Projs (Proj1);\n+                                 Proj1.Project.Need_To_Build_Lib := True;\n+                                 Add_To_Library_Projs (Proj1.Project);\n                               end if;\n                            end;\n                         end if;\n+\n+                        Proj1 := Proj1.Next;\n                      end loop;\n \n                      --  Reset the flags Need_To_Build_Lib for the next main,\n                      --  to avoid rebuilding libraries uselessly.\n \n-                     for Proj1 in Project_Table.First ..\n-                                  Project_Table.Last (Project_Tree.Projects)\n-                     loop\n-                        Project_Tree.Projects.Table\n-                          (Proj1).Need_To_Build_Lib := False;\n+                     Proj1 := Project_Tree.Projects;\n+                     while Proj1 /= null loop\n+                        Proj1.Project.Need_To_Build_Lib := False;\n+                        Proj1 := Proj1.Next;\n                      end loop;\n                   end;\n \n@@ -6051,6 +5998,8 @@ package body Make is\n                --  Set to True when there are shared library project files or\n                --  when gnatbind is invoked with -shared.\n \n+               Proj : Project_List;\n+\n             begin\n                --  Check if there are shared libraries, so that gnatbind is\n                --  called with -shared. Check also if gnatbind is called with\n@@ -6060,17 +6009,16 @@ package body Make is\n                if Main_Project /= No_Project\n                  and then MLib.Tgt.Support_For_Libraries /= Prj.None\n                then\n-                  for Proj in Project_Table.First ..\n-                        Project_Table.Last (Project_Tree.Projects)\n-                  loop\n-                     if Project_Tree.Projects.Table (Proj).Library\n-                       and then Project_Tree.Projects.Table\n-                                  (Proj).Library_Kind /= Static\n+                  Proj := Project_Tree.Projects;\n+                  while Proj /= null loop\n+                     if Proj.Project.Library\n+                       and then Proj.Project.Library_Kind /= Static\n                      then\n                         Shared_Libs := True;\n                         Bind_Shared := Shared_Switch'Access;\n                         exit;\n                      end if;\n+                     Proj := Proj.Next;\n                   end loop;\n                end if;\n \n@@ -6157,6 +6105,7 @@ package body Make is\n                Current              : Natural;\n                Proj2                : Project_Id;\n                Depth                : Natural;\n+               Proj1                : Project_List;\n \n             begin\n                if not Run_Path_Option then\n@@ -6173,17 +6122,15 @@ package body Make is\n \n                      --  Check for library projects\n \n-                     for Proj1 in Project_Table.First ..\n-                           Project_Table.Last (Project_Tree.Projects)\n-                     loop\n-                        if Proj1 /= Main_Project\n-                          and then\n-                            Project_Tree.Projects.Table (Proj1).Library\n+                     Proj1 := Project_Tree.Projects;\n+                     while Proj1 /= null loop\n+                        if Proj1.Project /= Main_Project\n+                          and then Proj1.Project.Library\n                         then\n                            --  Add this project to table Library_Projs\n \n                            Libraries_Present := True;\n-                           Depth := Project_Tree.Projects.Table (Proj1).Depth;\n+                           Depth := Proj1.Project.Depth;\n                            Library_Projs.Increment_Last;\n                            Current := Library_Projs.Last;\n \n@@ -6192,29 +6139,28 @@ package body Make is\n \n                            while Current > 1 loop\n                               Proj2 := Library_Projs.Table (Current - 1);\n-                              exit when Project_Tree.Projects.Table\n-                                          (Proj2).Depth <= Depth;\n+                              exit when Proj2.Depth <= Depth;\n                               Library_Projs.Table (Current) := Proj2;\n                               Current := Current - 1;\n                            end loop;\n \n-                           Library_Projs.Table (Current) := Proj1;\n+                           Library_Projs.Table (Current) := Proj1.Project;\n \n                            --  If it is not a static library and path option\n                            --  is set, add it to the Library_Paths table.\n \n-                           if Project_Tree.Projects.Table\n-                                (Proj1).Library_Kind /= Static\n+                           if Proj1.Project.Library_Kind /= Static\n                              and then Path_Option /= null\n                            then\n                               Library_Paths.Increment_Last;\n                               Library_Paths.Table (Library_Paths.Last) :=\n                                 new String'\n                                   (Get_Name_String\n-                                       (Project_Tree.Projects.Table\n-                                            (Proj1).Library_Dir.Display_Name));\n+                                     (Proj1.Project.Library_Dir.Display_Name));\n                            end if;\n                         end if;\n+\n+                        Proj1 := Proj1.Next;\n                      end loop;\n \n                      for Index in 1 .. Library_Projs.Last loop\n@@ -6225,19 +6171,17 @@ package body Make is\n                         Linker_Switches.Table (Linker_Switches.Last) :=\n                           new String'(\"-L\" &\n                                       Get_Name_String\n-                                        (Project_Tree.Projects.Table\n-                                           (Library_Projs.Table (Index)).\n-                                              Library_Dir.Display_Name));\n+                                        (Library_Projs.Table (Index).\n+                                            Library_Dir.Display_Name));\n \n                         --  Add the -l switch\n \n                         Linker_Switches.Increment_Last;\n                         Linker_Switches.Table (Linker_Switches.Last) :=\n                           new String'(\"-l\" &\n                                       Get_Name_String\n-                                        (Project_Tree.Projects.Table\n-                                           (Library_Projs.Table (Index)).\n-                                              Library_Name));\n+                                        (Library_Projs.Table (Index).\n+                                           Library_Name));\n                      end loop;\n                   end if;\n \n@@ -6471,8 +6415,7 @@ package body Make is\n                                                  not Unique_Compile);\n \n                   The_Packages : constant Package_Id :=\n-                    Project_Tree.Projects.Table\n-                      (Main_Project).Decl.Packages;\n+                    Main_Project.Decl.Packages;\n \n                   Binder_Package : constant Prj.Package_Id :=\n                                Prj.Util.Value_Of\n@@ -6572,8 +6515,7 @@ package body Make is\n                   declare\n                      Dir_Path : constant String :=\n                                   Get_Name_String\n-                                    (Project_Tree.Projects.Table\n-                                      (Main_Project).Directory.Name);\n+                                    (Main_Project.Directory.Name);\n \n                   begin\n                      for\n@@ -6687,6 +6629,7 @@ package body Make is\n \n    procedure Init_Mapping_File\n      (Project    : Project_Id;\n+      Data       : in out Project_Compilation_Data;\n       File_Index : in out Natural)\n    is\n       FD     : File_Descriptor;\n@@ -6696,8 +6639,7 @@ package body Make is\n    begin\n       --  Increase the index of the last mapping file for this project\n \n-      Last_Mapping_File_Names (Project) :=\n-        Last_Mapping_File_Names (Project) + 1;\n+      Data.Last_Mapping_File_Names := Data.Last_Mapping_File_Names + 1;\n \n       --  If there is a project file, call Create_Mapping_File with\n       --  the project id.\n@@ -6707,24 +6649,22 @@ package body Make is\n            (Project,\n             In_Tree  => Project_Tree,\n             Language => No_Name,\n-            Name     => The_Mapping_File_Names\n-                          (Project, Last_Mapping_File_Names (Project)));\n+            Name     => Data.Mapping_File_Names\n+                          (Data.Last_Mapping_File_Names));\n \n       --  Otherwise, just create an empty file\n \n       else\n          Tempdir.Create_Temp_File\n            (FD,\n-            The_Mapping_File_Names\n-              (No_Project, Last_Mapping_File_Names (No_Project)));\n+            Data.Mapping_File_Names (Data.Last_Mapping_File_Names));\n \n          if FD = Invalid_FD then\n             Make_Failed (\"disk full\");\n \n          else\n             Record_Temp_File\n-              (The_Mapping_File_Names\n-                 (No_Project, Last_Mapping_File_Names (No_Project)));\n+              (Data.Mapping_File_Names (Data.Last_Mapping_File_Names));\n          end if;\n \n          Close (FD, Status);\n@@ -6736,7 +6676,7 @@ package body Make is\n \n       --  And return the index of the newly created file\n \n-      File_Index := Last_Mapping_File_Names (Project);\n+      File_Index := Data.Last_Mapping_File_Names;\n    end Init_Mapping_File;\n \n    ------------\n@@ -6958,18 +6898,22 @@ package body Make is\n          --  to the search paths.\n \n          Add_Source_Directories (Main_Project, Project_Tree);\n-         Add_Object_Directories (Main_Project, Project_Tree);\n+         Add_Object_Directories (Main_Project);\n \n          Recursive_Compute_Depth (Main_Project);\n \n          --  For each project compute the list of the projects it imports\n          --  directly or indirectly.\n \n-         for Proj in Project_Table.First ..\n-                     Project_Table.Last (Project_Tree.Projects)\n-         loop\n-            Compute_All_Imported_Projects (Proj, Project_Tree);\n-         end loop;\n+         declare\n+            Proj : Project_List;\n+         begin\n+            Proj := Project_Tree.Projects;\n+            while Proj /= null loop\n+               Compute_All_Imported_Projects (Proj.Project);\n+               Proj := Proj.Next;\n+            end loop;\n+         end;\n \n       else\n \n@@ -7015,9 +6959,7 @@ package body Make is\n       Sfile    : File_Name_Type;\n       Index    : Int;\n \n-      Extending : constant Boolean :=\n-                    Project_Tree.Projects.Table\n-                      (The_Project).Extends /= No_Project;\n+      Extending : constant Boolean := The_Project.Extends /= No_Project;\n \n       function Check_Project (P : Project_Id) return Boolean;\n       --  Returns True if P is The_Project or a project extended by The_Project\n@@ -7033,17 +6975,16 @@ package body Make is\n \n          elsif Extending then\n             declare\n-               Data : Project_Data :=\n-                        Project_Tree.Projects.Table (The_Project);\n+               Proj : Project_Id;\n \n             begin\n-               loop\n-                  if P = Data.Extends then\n+               Proj := The_Project;\n+               while Proj /= null loop\n+                  if P = Proj.Extends then\n                      return True;\n                   end if;\n \n-                  Data := Project_Tree.Projects.Table (Data.Extends);\n-                  exit when Data.Extends = No_Project;\n+                  Proj := Proj.Extends;\n                end loop;\n             end;\n          end if;\n@@ -7064,7 +7005,7 @@ package body Make is\n          Index := 0;\n \n          --  If there is a source for the body, and the body has not been\n-         --  locally removed,\n+         --  locally removed.\n \n          if Unit.File_Names (Body_Part).Name /= No_File\n            and then Unit.File_Names (Body_Part).Path.Name /= Slash\n@@ -7074,7 +7015,7 @@ package body Make is\n             if Check_Project (Unit.File_Names (Body_Part).Project) then\n \n                --  If we don't have a spec, we cannot consider the source\n-               --  if it is a subunit\n+               --  if it is a subunit.\n \n                if Unit.File_Names (Specification).Name = No_File then\n                   declare\n@@ -7261,7 +7202,6 @@ package body Make is\n                                  Get_Name_String (Source_File);\n             Saved_Verbosity  : constant Verbosity := Current_Verbosity;\n             Project          : Project_Id         := No_Project;\n-            Data             : Project_Data;\n \n             Path_Name : Path_Name_Type := No_Path;\n             pragma Warnings (Off, Path_Name);\n@@ -7284,13 +7224,12 @@ package body Make is\n             --  ALI file will not be skipped.\n \n             if Project /= No_Project then\n-               Data := Project_Tree.Projects.Table (Project);\n-\n                declare\n                   Object_Directory : constant String :=\n                                        Normalize_Pathname\n                                         (Get_Name_String\n-                                         (Data.Object_Directory.Display_Name));\n+                                         (Project.\n+                                            Object_Directory.Display_Name));\n \n                   Olast : Natural := Object_Directory'Last;\n \n@@ -7482,10 +7421,7 @@ package body Make is\n          declare\n             Real_Path : constant String :=\n               Normalize_Pathname\n-                (Dir,\n-                 Get_Name_String\n-                   (Project_Tree.Projects.Table\n-                                   (Main_Project).Directory.Display_Name));\n+                (Dir, Get_Name_String (Main_Project.Directory.Display_Name));\n \n          begin\n             if Real_Path'Length = 0 then\n@@ -7528,13 +7464,12 @@ package body Make is\n       -------------\n \n       procedure Recurse (Prj : Project_Id; Depth : Natural) is\n-         Data : Project_Data renames Project_Tree.Projects.Table (Prj);\n          List : Project_List;\n          Proj : Project_Id;\n \n       begin\n-         if Data.Depth >= Depth\n-           or Get (Seen, Prj)\n+         if Prj.Depth >= Depth\n+           or Get (Seen, Prj)    -- or needed instead of or else ???\n          then\n             return;\n          end if;\n@@ -7545,11 +7480,11 @@ package body Make is\n \n          Set (Seen, Prj, True);\n \n-         Data.Depth := Depth;\n+         Prj.Depth := Depth;\n \n          --  Visit each imported project\n \n-         List := Data.Imported_Projects;\n+         List := Prj.Imported_Projects;\n          while List /= null loop\n             Proj := List.Project;\n             List := List.Next;\n@@ -7564,11 +7499,12 @@ package body Make is\n \n    --  Start of processing for Recursive_Compute_Depth\n \n+      Proj : Project_List;\n    begin\n-      for Proj in Project_Table.First ..\n-        Project_Table.Last (Project_Tree.Projects)\n-      loop\n-         Project_Tree.Projects.Table (Proj).Depth := 0;\n+      Proj := Project_Tree.Projects;\n+      while Proj /= null loop\n+         Proj.Project.Depth := 0;\n+         Proj := Proj.Next;\n       end loop;\n \n       Recurse (Project, Depth => 1);"}, {"sha": "50b9fe23b1de190e3c5f8103791dba9d628982d1", "filename": "gcc/ada/makeutl.adb", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmakeutl.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmakeutl.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmakeutl.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -373,15 +373,14 @@ package body Makeutl is\n       procedure Recursive_Add (Proj : Project_Id; Dummy : in out Boolean) is\n          pragma Unreferenced (Dummy);\n \n-         Data           : Project_Data renames In_Tree.Projects.Table (Proj);\n          Linker_Package : Package_Id;\n          Options        : Variable_Value;\n \n       begin\n          Linker_Package :=\n            Prj.Util.Value_Of\n              (Name        => Name_Linker,\n-              In_Packages => Data.Decl.Packages,\n+              In_Packages => Proj.Decl.Packages,\n               In_Tree     => In_Tree);\n \n          Options :=\n@@ -412,20 +411,21 @@ package body Makeutl is\n    begin\n       Linker_Opts.Init;\n \n-      For_All_Projects (Project, In_Tree, Dummy, Imported_First => True);\n+      For_All_Projects (Project, Dummy, Imported_First => True);\n \n       Last_Linker_Option := 0;\n \n       for Index in reverse 1 .. Linker_Opts.Last loop\n          declare\n-            Options : String_List_Id := Linker_Opts.Table (Index).Options;\n+            Options : String_List_Id;\n             Proj    : constant Project_Id :=\n                         Linker_Opts.Table (Index).Project;\n             Option  : Name_Id;\n             Dir_Path : constant String :=\n-              Get_Name_String (In_Tree.Projects.Table (Proj).Directory.Name);\n+                         Get_Name_String (Proj.Directory.Name);\n \n          begin\n+            Options := Linker_Opts.Table (Index).Options;\n             while Options /= Nil_String loop\n                Option := In_Tree.String_Elements.Table (Options).Value;\n                Get_Name_String (Option);\n@@ -444,8 +444,7 @@ package body Makeutl is\n                      Including_L_Switch => True);\n                end if;\n \n-               Options :=\n-                 In_Tree.String_Elements.Table (Options).Next;\n+               Options := In_Tree.String_Elements.Table (Options).Next;\n             end loop;\n          end;\n       end loop;"}, {"sha": "d08257e00d6ef253883afd79d82962f6e9798f41", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 85, "deletions": 130, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -229,12 +229,6 @@ package body MLib.Prj is\n    --  Indicate if Stand-Alone Libraries are automatically initialized using\n    --  the constructor mechanism.\n \n-   function Ultimate_Extension_Of\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Project_Id;\n-   --  Returns the Project_Id of project Project. Returns No_Project\n-   --  if Project is No_Project.\n-\n    ------------------\n    -- Add_Argument --\n    ------------------\n@@ -309,9 +303,9 @@ package body MLib.Prj is\n       --  Set to True for the first warning about a unit missing from the\n       --  interface set.\n \n-      Data : Project_Data := In_Tree.Projects.Table (For_Project);\n+      Current_Proj : Project_Id;\n \n-      Libgnarl_Needed   : Yes_No_Unknown := Data.Libgnarl_Needed;\n+      Libgnarl_Needed   : Yes_No_Unknown := For_Project.Libgnarl_Needed;\n       --  Set to True if library needs to be linked with libgnarl\n \n       Libdecgnat_Needed : Boolean := False;\n@@ -323,11 +317,11 @@ package body MLib.Prj is\n \n       Object_Directory_Path : constant String :=\n                                 Get_Name_String\n-                                  (Data.Object_Directory.Display_Name);\n+                                  (For_Project.Object_Directory.Display_Name);\n \n-      Standalone   : constant Boolean := Data.Standalone_Library;\n+      Standalone   : constant Boolean := For_Project.Standalone_Library;\n \n-      Project_Name : constant String := Get_Name_String (Data.Name);\n+      Project_Name : constant String := Get_Name_String (For_Project.Name);\n \n       Current_Dir  : constant String := Get_Current_Dir;\n \n@@ -486,15 +480,14 @@ package body MLib.Prj is\n \n          elsif P /= No_Project then\n             declare\n-               Data : Project_Data :=\n-                        In_Tree.Projects.Table (For_Project);\n+               Proj : Project_Id := For_Project;\n             begin\n-               while Data.Extends /= No_Project loop\n-                  if P = Data.Extends then\n+               while Proj.Extends /= No_Project loop\n+                  if P = Proj.Extends then\n                      return True;\n                   end if;\n \n-                  Data := In_Tree.Projects.Table (Data.Extends);\n+                  Proj := Proj.Extends;\n                end loop;\n             end;\n          end if;\n@@ -542,8 +535,7 @@ package body MLib.Prj is\n                   Libgnarl_Needed := Yes;\n \n                   if Main_Project then\n-                     In_Tree.Projects.Table (For_Project).Libgnarl_Needed :=\n-                       Yes;\n+                     For_Project.Libgnarl_Needed := Yes;\n                   else\n                      exit;\n                   end if;\n@@ -619,7 +611,7 @@ package body MLib.Prj is\n                            if not Interface_ALIs.Get (Afile) then\n                               if not Warning_For_Library then\n                                  Write_Str (\"Warning: In library project \"\"\");\n-                                 Get_Name_String (Data.Name);\n+                                 Get_Name_String (Current_Proj.Name);\n                                  To_Mixed (Name_Buffer (1 .. Name_Len));\n                                  Write_Str (Name_Buffer (1 .. Name_Len));\n                                  Write_Line (\"\"\"\");\n@@ -678,20 +670,19 @@ package body MLib.Prj is\n          ---------------------\n \n          procedure Process_Project (Project : Project_Id) is\n-            Data     : Project_Data := In_Tree.Projects.Table (Project);\n             Imported : Project_List;\n \n          begin\n             --  Nothing to do if process has already been processed\n \n-            if not Processed_Projects.Get (Data.Name) then\n-               Processed_Projects.Set (Data.Name, True);\n+            if not Processed_Projects.Get (Project.Name) then\n+               Processed_Projects.Set (Project.Name, True);\n \n                --  Call Process_Project recursively for any imported project.\n                --  We first process the imported projects to guarantee that\n                --  we have a proper reverse order for the libraries.\n \n-               Imported := Data.Imported_Projects;\n+               Imported := Project.Imported_Projects;\n                while Imported /= null loop\n                   if Imported.Project /= No_Project then\n                      Process_Project (Imported.Project);\n@@ -702,22 +693,22 @@ package body MLib.Prj is\n \n                --  If it is a library project, add it to Library_Projs\n \n-               if Project /= For_Project and then Data.Library then\n+               if Project /= For_Project and then Project.Library then\n                   Library_Projs.Increment_Last;\n                   Library_Projs.Table (Library_Projs.Last) := Project;\n \n                   --  Check if because of this library we need to use libgnarl\n \n                   if Libgnarl_Needed = Unknown then\n-                     if Data.Libgnarl_Needed = Unknown\n-                       and then Data.Object_Directory /= No_Path_Information\n+                     if Project.Libgnarl_Needed = Unknown\n+                       and then Project.Object_Directory /= No_Path_Information\n                      then\n                         --  Check if libgnarl is needed for this library\n \n                         declare\n                            Object_Dir_Path : constant String :=\n                                                Get_Name_String\n-                                                 (Data.Object_Directory.\n+                                                 (Project.Object_Directory.\n                                                     Display_Name);\n                            Object_Dir      : Dir_Type;\n                            Filename        : String (1 .. 255);\n@@ -755,10 +746,8 @@ package body MLib.Prj is\n                                          (ALI_File, Main_Project => False);\n \n                                        if Libgnarl_Needed = Yes then\n-                                          Data.Libgnarl_Needed := Yes;\n-                                          In_Tree.Projects.Table\n-                                            (For_Project).Libgnarl_Needed :=\n-                                            Yes;\n+                                          Project.Libgnarl_Needed := Yes;\n+                                          For_Project.Libgnarl_Needed := Yes;\n                                           exit;\n                                        end if;\n                                     end if;\n@@ -770,10 +759,9 @@ package body MLib.Prj is\n                         end;\n                      end if;\n \n-                     if Data.Libgnarl_Needed = Yes then\n+                     if Project.Libgnarl_Needed = Yes then\n                         Libgnarl_Needed := Yes;\n-                        In_Tree.Projects.Table (For_Project).Libgnarl_Needed :=\n-                          Yes;\n+                        For_Project.Libgnarl_Needed := Yes;\n                      end if;\n                   end if;\n                end if;\n@@ -795,8 +783,7 @@ package body MLib.Prj is\n          for Index in reverse 1 .. Library_Projs.Last loop\n             Current := Library_Projs.Table (Index);\n \n-            Get_Name_String\n-              (In_Tree.Projects.Table (Current).Library_Dir.Display_Name);\n+            Get_Name_String (Current.Library_Dir.Display_Name);\n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n               new String'(\"-L\" & Name_Buffer (1 .. Name_Len));\n@@ -807,11 +794,7 @@ package body MLib.Prj is\n \n             Opts.Increment_Last;\n             Opts.Table (Opts.Last) :=\n-              new String'\n-                (\"-l\" &\n-                 Get_Name_String\n-                   (In_Tree.Projects.Table\n-                      (Current).Library_Name));\n+              new String'(\"-l\" & Get_Name_String (Current.Library_Name));\n          end loop;\n       end Process_Imported_Libraries;\n \n@@ -822,13 +805,13 @@ package body MLib.Prj is\n \n       --  Fail if project is not a library project\n \n-      if not Data.Library then\n+      if not For_Project.Library then\n          Com.Fail (\"project \"\"\" & Project_Name & \"\"\" has no library\");\n       end if;\n \n       --  Do not attempt to build the library if it is externally built\n \n-      if Data.Externally_Built then\n+      if For_Project.Externally_Built then\n          return;\n       end if;\n \n@@ -888,10 +871,11 @@ package body MLib.Prj is\n             end if;\n \n             Add_Argument\n-              (B_Start.all & Get_Name_String (Data.Library_Name) & \".adb\");\n-            Add_Argument (\"-L\" & Get_Name_String (Data.Library_Name));\n+              (B_Start.all\n+               & Get_Name_String (For_Project.Library_Name) & \".adb\");\n+            Add_Argument (\"-L\" & Get_Name_String (For_Project.Library_Name));\n \n-            if Data.Lib_Auto_Init and then SALs_Use_Constructors then\n+            if For_Project.Lib_Auto_Init and then SALs_Use_Constructors then\n                Add_Argument (Auto_Initialize);\n             end if;\n \n@@ -902,7 +886,7 @@ package body MLib.Prj is\n                Binder_Package : constant Package_Id :=\n                                   Value_Of\n                                     (Name        => Name_Binder,\n-                                     In_Packages => Data.Decl.Packages,\n+                                     In_Packages => For_Project.Decl.Packages,\n                                      In_Tree     => In_Tree);\n \n             begin\n@@ -1172,7 +1156,7 @@ package body MLib.Prj is\n \n             if not Success then\n                Com.Fail (\"could not bind standalone library \"\n-                         & Get_Name_String (Data.Library_Name));\n+                         & Get_Name_String (For_Project.Library_Name));\n             end if;\n          end if;\n \n@@ -1204,7 +1188,8 @@ package body MLib.Prj is\n             end if;\n \n             Add_Argument\n-              (B_Start.all & Get_Name_String (Data.Library_Name) & \".adb\");\n+              (B_Start.all\n+               & Get_Name_String (For_Project.Library_Name) & \".adb\");\n \n             --  If necessary, add the PIC option\n \n@@ -1264,7 +1249,7 @@ package body MLib.Prj is\n             if not Success then\n                Com.Fail\n                 (\"could not compile binder generated file for library \"\n-                  & Get_Name_String (Data.Library_Name));\n+                  & Get_Name_String (For_Project.Library_Name));\n             end if;\n \n             --  Process binder generated file for pragmas Linker_Options\n@@ -1280,15 +1265,15 @@ package body MLib.Prj is\n          --  If attributes Library_GCC or Linker'Driver were specified, get the\n          --  driver name.\n \n-         if Data.Config.Shared_Lib_Driver /= No_File then\n-            Driver_Name := Name_Id (Data.Config.Shared_Lib_Driver);\n+         if For_Project.Config.Shared_Lib_Driver /= No_File then\n+            Driver_Name := Name_Id (For_Project.Config.Shared_Lib_Driver);\n          end if;\n \n          --  If attribute Library_Options was specified, add these additional\n          --  options.\n \n-         Library_Options :=\n-           Value_Of (Name_Library_Options, Data.Decl.Attributes, In_Tree);\n+         Library_Options := Value_Of\n+           (Name_Library_Options, For_Project.Decl.Attributes, In_Tree);\n \n          if not Library_Options.Default then\n             declare\n@@ -1313,10 +1298,11 @@ package body MLib.Prj is\n          end if;\n \n          Lib_Dirpath  :=\n-           new String'(Get_Name_String (Data.Library_Dir.Display_Name));\n-         Lib_Filename := new String'(Get_Name_String (Data.Library_Name));\n+           new String'(Get_Name_String (For_Project.Library_Dir.Display_Name));\n+         Lib_Filename := new String'\n+           (Get_Name_String (For_Project.Library_Name));\n \n-         case Data.Library_Kind is\n+         case For_Project.Library_Kind is\n             when Static =>\n                The_Build_Mode := Static;\n \n@@ -1334,9 +1320,9 @@ package body MLib.Prj is\n \n          --  Get the library version, if any\n \n-         if Data.Lib_Internal_Name /= No_Name then\n+         if For_Project.Lib_Internal_Name /= No_Name then\n             Lib_Version :=\n-              new String'(Get_Name_String (Data.Lib_Internal_Name));\n+              new String'(Get_Name_String (For_Project.Lib_Internal_Name));\n          end if;\n \n          --  Add the objects found in the object directory and the object\n@@ -1347,14 +1333,16 @@ package body MLib.Prj is\n \n          In_Main_Object_Directory := True;\n \n-         Foreign_Sources := Has_Foreign_Sources (Data);\n+         Foreign_Sources := Has_Foreign_Sources (For_Project);\n+         Current_Proj := For_Project;\n \n          loop\n-            if Data.Object_Directory /= No_Path_Information then\n+            if Current_Proj.Object_Directory /= No_Path_Information then\n                declare\n                   Object_Dir_Path : constant String :=\n                                       Get_Name_String\n-                                        (Data.Object_Directory.Display_Name);\n+                                        (Current_Proj.Object_Directory\n+                                         .Display_Name);\n                   Object_Dir      : Dir_Type;\n                   Filename        : String (1 .. 255);\n                   Last            : Natural;\n@@ -1527,15 +1515,15 @@ package body MLib.Prj is\n                   when Directory_Error =>\n                      Com.Fail (\"cannot find object directory \"\"\"\n                                & Get_Name_String\n-                                  (Data.Object_Directory.Display_Name)\n+                                  (Current_Proj.Object_Directory.Display_Name)\n                                & \"\"\"\");\n                end;\n             end if;\n \n-            exit when Data.Extends = No_Project;\n+            exit when Current_Proj.Extends = No_Project;\n \n             In_Main_Object_Directory  := False;\n-            Data := In_Tree.Projects.Table (Data.Extends);\n+            Current_Proj := Current_Proj.Extends;\n          end loop;\n \n          --  Add the -L and -l switches for the imported Library Project Files,\n@@ -1743,10 +1731,10 @@ package body MLib.Prj is\n          --  the library directory (by Copy_ALI_Files, below).\n \n          if Standalone then\n-            Data := In_Tree.Projects.Table (For_Project);\n+            Current_Proj := For_Project;\n \n             declare\n-               Iface : String_List_Id := Data.Lib_Interface_ALIs;\n+               Iface : String_List_Id := For_Project.Lib_Interface_ALIs;\n                ALI   : File_Name_Type;\n \n             begin\n@@ -1761,7 +1749,7 @@ package body MLib.Prj is\n                   Iface := In_Tree.String_Elements.Table (Iface).Next;\n                end loop;\n \n-               Iface := Data.Lib_Interface_ALIs;\n+               Iface := For_Project.Lib_Interface_ALIs;\n \n                if not Opt.Quiet_Output then\n \n@@ -1803,8 +1791,7 @@ package body MLib.Prj is\n             --  the library file and any ALI file of a source of the project.\n \n             begin\n-               Get_Name_String\n-                 (In_Tree.Projects.Table (For_Project).Library_Dir.Name);\n+               Get_Name_String (For_Project.Library_Dir.Name);\n                Change_Dir (Name_Buffer (1 .. Name_Len));\n \n             exception\n@@ -1856,9 +1843,9 @@ package body MLib.Prj is\n                               if Unit.File_Names (Body_Part).Project /=\n                                 No_Project\n                               then\n-                                 if  Ultimate_Extension_Of\n-                                   (Unit.File_Names (Body_Part).Project,\n-                                    In_Tree) = For_Project\n+                                 if Ultimate_Extending_Project_Of\n+                                   (Unit.File_Names (Body_Part).Project) =\n+                                    For_Project\n                                  then\n                                     Get_Name_String\n                                       (Unit.File_Names (Body_Part).Name);\n@@ -1873,9 +1860,9 @@ package body MLib.Prj is\n                                     end if;\n                                  end if;\n \n-                              elsif Ultimate_Extension_Of\n-                                (Unit.File_Names (Specification).Project,\n-                                 In_Tree) = For_Project\n+                              elsif Ultimate_Extending_Project_Of\n+                                (Unit.File_Names (Specification).Project) =\n+                                 For_Project\n                               then\n                                  Get_Name_String\n                                    (Unit.File_Names (Specification).Name);\n@@ -1918,10 +1905,10 @@ package body MLib.Prj is\n                   Interfaces    => Arguments (1 .. Argument_Number),\n                   Lib_Filename  => Lib_Filename.all,\n                   Lib_Dir       => Lib_Dirpath.all,\n-                  Symbol_Data   => Data.Symbol_Data,\n+                  Symbol_Data   => Current_Proj.Symbol_Data,\n                   Driver_Name   => Driver_Name,\n                   Lib_Version   => Lib_Version.all,\n-                  Auto_Init     => Data.Lib_Auto_Init);\n+                  Auto_Init     => Current_Proj.Lib_Auto_Init);\n \n             when Static =>\n                MLib.Build_Library\n@@ -1944,22 +1931,19 @@ package body MLib.Prj is\n \n          Copy_ALI_Files\n            (Files      => Ali_Files.all,\n-            To         => In_Tree.Projects.Table\n-                            (For_Project).Library_ALI_Dir.Name,\n+            To         => For_Project.Library_ALI_Dir.Name,\n             Interfaces => Arguments (1 .. Argument_Number));\n \n          --  Copy interface sources if Library_Src_Dir specified\n \n          if Standalone\n-           and then In_Tree.Projects.Table\n-                      (For_Project).Library_Src_Dir /= No_Path_Information\n+           and then For_Project.Library_Src_Dir /= No_Path_Information\n          then\n             --  Clean the interface copy directory: remove any source that\n             --  could be a source of the project.\n \n             begin\n-               Get_Name_String\n-                 (In_Tree.Projects.Table (For_Project).Library_Src_Dir.Name);\n+               Get_Name_String (For_Project.Library_Src_Dir.Name);\n                Change_Dir (Name_Buffer (1 .. Name_Len));\n \n             exception\n@@ -1997,9 +1981,8 @@ package body MLib.Prj is\n                      for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n                         Unit := In_Tree.Units.Table (Index);\n \n-                        if Ultimate_Extension_Of\n-                            (Unit.File_Names (Body_Part).Project, In_Tree) =\n-                            For_Project\n+                        if Ultimate_Extending_Project_Of\n+                            (Unit.File_Names (Body_Part).Project) = For_Project\n                           and then\n                             Get_Name_String\n                               (Unit.File_Names (Body_Part).Name) =\n@@ -2009,9 +1992,9 @@ package body MLib.Prj is\n                            exit;\n                         end if;\n \n-                        if Ultimate_Extension_Of\n-                           (Unit.File_Names (Specification).Project, In_Tree) =\n-                           For_Project\n+                        if Ultimate_Extending_Project_Of\n+                          (Unit.File_Names (Specification).Project) =\n+                             For_Project\n                           and then\n                            Get_Name_String\n                              (Unit.File_Names (Specification).Name) =\n@@ -2036,8 +2019,7 @@ package body MLib.Prj is\n               (For_Project => For_Project,\n                In_Tree     => In_Tree,\n                Interfaces  => Arguments (1 .. Argument_Number),\n-               To_Dir      => In_Tree.Projects.Table\n-                                (For_Project).Library_Src_Dir.Display_Name);\n+               To_Dir      => For_Project.Library_Src_Dir.Display_Name);\n          end if;\n       end if;\n \n@@ -2077,28 +2059,26 @@ package body MLib.Prj is\n    procedure Check_Library\n      (For_Project : Project_Id; In_Tree : Project_Tree_Ref)\n    is\n-      Data    : constant Project_Data :=\n-                  In_Tree.Projects.Table (For_Project);\n       Lib_TS  : Time_Stamp_Type;\n       Current : constant Dir_Name_Str := Get_Current_Dir;\n \n    begin\n       --  No need to build the library if there is no object directory,\n       --  hence no object files to build the library.\n \n-      if Data.Library then\n+      if For_Project.Library then\n          declare\n             Lib_Name : constant File_Name_Type :=\n               Library_File_Name_For (For_Project, In_Tree);\n          begin\n-            Change_Dir (Get_Name_String (Data.Library_Dir.Name));\n+            Change_Dir (Get_Name_String (For_Project.Library_Dir.Name));\n             Lib_TS := File_Stamp (Lib_Name);\n-            In_Tree.Projects.Table (For_Project).Library_TS := Lib_TS;\n+            For_Project.Library_TS := Lib_TS;\n          end;\n \n-         if not Data.Externally_Built\n-           and then not Data.Need_To_Build_Lib\n-           and then Data.Object_Directory /= No_Path_Information\n+         if not For_Project.Externally_Built\n+           and then not For_Project.Need_To_Build_Lib\n+           and then For_Project.Object_Directory /= No_Path_Information\n          then\n             declare\n                Obj_TS     : Time_Stamp_Type;\n@@ -2112,7 +2092,8 @@ package body MLib.Prj is\n                --  If the library file does not exist, then the time stamp will\n                --  be Empty_Time_Stamp, earlier than any other time stamp.\n \n-               Change_Dir (Get_Name_String (Data.Object_Directory.Name));\n+               Change_Dir\n+                 (Get_Name_String (For_Project.Object_Directory.Name));\n                Open (Dir => Object_Dir, Dir_Name => \".\");\n \n                --  For all entries in the object directory\n@@ -2141,8 +2122,7 @@ package body MLib.Prj is\n \n                         --  Library must be rebuilt\n \n-                        In_Tree.Projects.Table\n-                          (For_Project).Need_To_Build_Lib := True;\n+                        For_Project.Need_To_Build_Lib := True;\n                         exit;\n                      end if;\n                   end if;\n@@ -2244,7 +2224,7 @@ package body MLib.Prj is\n                return True;\n             end if;\n \n-            Ext := In_Tree.Projects.Table (Ext).Extends;\n+            Ext := Ext.Extends;\n          end loop;\n \n          return False;\n@@ -2255,9 +2235,7 @@ package body MLib.Prj is\n    begin\n       --  Change the working directory to the object directory\n \n-      Change_Dir\n-        (Get_Name_String\n-           (In_Tree.Projects.Table (For_Project).Object_Directory.Name));\n+      Change_Dir (Get_Name_String (For_Project.Object_Directory.Name));\n \n       for Index in Interfaces'Range loop\n \n@@ -2533,27 +2511,4 @@ package body MLib.Prj is\n       return C_SALs_Init_Using_Constructors /= 0;\n    end SALs_Use_Constructors;\n \n-   ---------------------------\n-   -- Ultimate_Extension_Of --\n-   ---------------------------\n-\n-   function Ultimate_Extension_Of\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Project_Id\n-   is\n-      Result : Project_Id := Project;\n-      Data   : Project_Data;\n-\n-   begin\n-      if Project /= No_Project then\n-         loop\n-            Data := In_Tree.Projects.Table (Result);\n-            exit when Data.Extended_By = No_Project;\n-            Result := Data.Extended_By;\n-         end loop;\n-      end if;\n-\n-      return Result;\n-   end Ultimate_Extension_Of;\n-\n end MLib.Prj;"}, {"sha": "164d4dc91676568e6047e0af11937cfe388fe5a8", "filename": "gcc/ada/mlib-tgt.adb", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-tgt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-tgt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2001-2008, AdaCore                     --\n+--                     Copyright (C) 2001-2009, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -330,23 +330,22 @@ package body MLib.Tgt is\n    function Library_Exists_For_Default\n      (Project : Project_Id; In_Tree : Project_Tree_Ref) return Boolean\n    is\n+      pragma Unreferenced (In_Tree);\n    begin\n-      if not In_Tree.Projects.Table (Project).Library then\n+      if not Project.Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_Exists_For called \" &\n                        \"for non library project\");\n          return False;\n \n       else\n          declare\n             Lib_Dir  : constant String :=\n-                         Get_Name_String\n-                           (In_Tree.Projects.Table (Project).Library_Dir.Name);\n+                         Get_Name_String (Project.Library_Dir.Name);\n             Lib_Name : constant String :=\n-                         Get_Name_String\n-                           (In_Tree.Projects.Table (Project).Library_Name);\n+                         Get_Name_String (Project.Library_Name);\n \n          begin\n-            if In_Tree.Projects.Table (Project).Library_Kind = Static then\n+            if Project.Library_Kind = Static then\n                return Is_Regular_File\n                  (Lib_Dir & Directory_Separator & \"lib\" &\n                   Fil.Append_To (Lib_Name, Archive_Ext));\n@@ -380,20 +379,20 @@ package body MLib.Tgt is\n      (Project : Project_Id;\n       In_Tree : Project_Tree_Ref) return File_Name_Type\n    is\n+      pragma Unreferenced (In_Tree);\n    begin\n-      if not In_Tree.Projects.Table (Project).Library then\n+      if not Project.Library then\n          Prj.Com.Fail (\"INTERNAL ERROR: Library_File_Name_For called \" &\n                        \"for non library project\");\n          return No_File;\n \n       else\n          declare\n             Lib_Name : constant String :=\n-                         Get_Name_String\n-                           (In_Tree.Projects.Table (Project).Library_Name);\n+                         Get_Name_String (Project.Library_Name);\n \n          begin\n-            if In_Tree.Projects.Table (Project).Library_Kind =\n+            if Project.Library_Kind =\n                  Static\n             then\n                Name_Len := 3;"}, {"sha": "b418745c8c3be28ad744c4c5792c6a678bd08228", "filename": "gcc/ada/mlib-tgt.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-tgt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fmlib-tgt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-tgt.ads?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -238,8 +238,7 @@ private\n                               Library_Exists_For_Default'Access;\n \n    function Library_File_Name_For_Default\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return File_Name_Type;\n+     (Project : Project_Id; In_Tree : Project_Tree_Ref) return File_Name_Type;\n    Library_File_Name_For_Ptr : Library_File_Name_For_Function :=\n                                  Library_File_Name_For_Default'Access;\n "}, {"sha": "25a23291b3bdd0519ff2e861287a315e5aebd719", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 130, "deletions": 158, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -65,8 +65,7 @@ package body Prj.Env is\n    --  Call Setenv, after calling To_Host_File_Spec\n \n    function Ultimate_Extension_Of\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Project_Id;\n+     (Project : Project_Id) return Project_Id;\n    --  Return a project that is either Project or an extended ancestor of\n    --  Project that itself is not extended.\n \n@@ -88,7 +87,7 @@ package body Prj.Env is\n       procedure Add (Project : Project_Id; Dummy : in out Boolean) is\n          pragma Unreferenced (Dummy);\n       begin\n-         Add_To_Path (In_Tree.Projects.Table (Project).Source_Dirs, In_Tree);\n+         Add_To_Path (Project.Source_Dirs, In_Tree);\n       end Add;\n \n       procedure For_All_Projects is\n@@ -101,17 +100,17 @@ package body Prj.Env is\n       --  If it is the first time we call this function for\n       --  this project, compute the source path\n \n-      if In_Tree.Projects.Table (Project).Ada_Include_Path = null then\n+      if Project.Ada_Include_Path = null then\n          In_Tree.Private_Part.Ada_Path_Length := 0;\n-         For_All_Projects (Project, In_Tree, Dummy);\n+         For_All_Projects (Project, Dummy);\n \n-         In_Tree.Projects.Table (Project).Ada_Include_Path :=\n+         Project.Ada_Include_Path :=\n            new String'\n              (In_Tree.Private_Part.Ada_Path_Buffer\n                   (1 .. In_Tree.Private_Part.Ada_Path_Length));\n       end if;\n \n-      return In_Tree.Projects.Table (Project).Ada_Include_Path;\n+      return Project.Ada_Include_Path;\n    end Ada_Include_Path;\n \n    ----------------------\n@@ -128,8 +127,7 @@ package body Prj.Env is\n          return Ada_Include_Path (Project, In_Tree).all;\n       else\n          In_Tree.Private_Part.Ada_Path_Length := 0;\n-         Add_To_Path\n-           (In_Tree.Projects.Table (Project).Source_Dirs, In_Tree);\n+         Add_To_Path (Project.Source_Dirs, In_Tree);\n          return\n            In_Tree.Private_Part.Ada_Path_Buffer\n              (1 .. In_Tree.Private_Part.Ada_Path_Length);\n@@ -156,7 +154,7 @@ package body Prj.Env is\n          pragma Unreferenced (Dummy);\n          Path : constant Path_Name_Type :=\n                   Get_Object_Directory\n-                    (In_Tree, Project,\n+                    (Project,\n                      Including_Libraries => Including_Libraries,\n                      Only_If_Ada         => False);\n       begin\n@@ -175,17 +173,17 @@ package body Prj.Env is\n       --  If it is the first time we call this function for\n       --  this project, compute the objects path\n \n-      if In_Tree.Projects.Table (Project).Ada_Objects_Path = null then\n+      if Project.Ada_Objects_Path = null then\n          In_Tree.Private_Part.Ada_Path_Length := 0;\n-         For_All_Projects (Project, In_Tree, Dummy);\n+         For_All_Projects (Project, Dummy);\n \n-         In_Tree.Projects.Table (Project).Ada_Objects_Path :=\n+         Project.Ada_Objects_Path :=\n            new String'\n              (In_Tree.Private_Part.Ada_Path_Buffer\n                   (1 .. In_Tree.Private_Part.Ada_Path_Length));\n       end if;\n \n-      return In_Tree.Projects.Table (Project).Ada_Objects_Path;\n+      return Project.Ada_Objects_Path;\n    end Ada_Objects_Path;\n \n    ------------------------\n@@ -435,13 +433,10 @@ package body Prj.Env is\n       -----------\n \n       procedure Check (Project : Project_Id) is\n-         Data : constant Project_Data :=\n-           In_Tree.Projects.Table (Project);\n-\n       begin\n          if Current_Verbosity = High then\n             Write_Str (\"Checking project file \"\"\");\n-            Write_Str (Namet.Get_Name_String (Data.Name));\n+            Write_Str (Namet.Get_Name_String (Project.Name));\n             Write_Str (\"\"\".\");\n             Write_Eol;\n          end if;\n@@ -469,7 +464,7 @@ package body Prj.Env is\n                     Naming_Table.Last (In_Tree.Private_Part.Namings)\n               and then not Same_Naming_Scheme\n               (Left => In_Tree.Private_Part.Namings.Table (Current_Naming),\n-               Right => Data.Naming) loop\n+               Right => Project.Naming) loop\n                Current_Naming := Current_Naming + 1;\n             end loop;\n \n@@ -481,7 +476,7 @@ package body Prj.Env is\n                Naming_Table.Increment_Last (In_Tree.Private_Part.Namings);\n                In_Tree.Private_Part.Namings.Table\n                  (Naming_Table.Last (In_Tree.Private_Part.Namings)) :=\n-                    Data.Naming;\n+                    Project.Naming;\n \n                --  We need a temporary file to be created\n \n@@ -495,14 +490,14 @@ package body Prj.Env is\n                  (File, \"pragma Source_File_Name_Project\");\n                Put_Line\n                  (File, \"  (Spec_File_Name  => \"\"*\" &\n-                  Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming) &\n+                  Spec_Suffix_Of (In_Tree, \"ada\", Project.Naming) &\n                   \"\"\",\");\n                Put_Line\n                  (File, \"   Casing          => \" &\n-                  Image (Data.Naming.Casing) & \",\");\n+                  Image (Project.Naming.Casing) & \",\");\n                Put_Line\n                  (File, \"   Dot_Replacement => \"\"\" &\n-                 Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                 Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n                   \"\"\");\");\n \n                --  and body\n@@ -511,44 +506,44 @@ package body Prj.Env is\n                  (File, \"pragma Source_File_Name_Project\");\n                Put_Line\n                  (File, \"  (Body_File_Name  => \"\"*\" &\n-                  Body_Suffix_Of (In_Tree, \"ada\", Data.Naming) &\n+                  Body_Suffix_Of (In_Tree, \"ada\", Project.Naming) &\n                   \"\"\",\");\n                Put_Line\n                  (File, \"   Casing          => \" &\n-                  Image (Data.Naming.Casing) & \",\");\n+                  Image (Project.Naming.Casing) & \",\");\n                Put_Line\n                  (File, \"   Dot_Replacement => \"\"\" &\n-                  Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                  Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n                   \"\"\");\");\n \n                --  and maybe separate\n \n-               if Body_Suffix_Of (In_Tree, \"ada\", Data.Naming) /=\n-                  Get_Name_String (Data.Naming.Separate_Suffix)\n+               if Body_Suffix_Of (In_Tree, \"ada\", Project.Naming) /=\n+                  Get_Name_String (Project.Naming.Separate_Suffix)\n                then\n                   Put_Line\n                     (File, \"pragma Source_File_Name_Project\");\n                   Put_Line\n                     (File, \"  (Subunit_File_Name  => \"\"*\" &\n-                     Namet.Get_Name_String (Data.Naming.Separate_Suffix) &\n+                     Namet.Get_Name_String (Project.Naming.Separate_Suffix) &\n                      \"\"\",\");\n                   Put_Line\n                     (File, \"   Casing          => \" &\n-                     Image (Data.Naming.Casing) &\n+                     Image (Project.Naming.Casing) &\n                      \",\");\n                   Put_Line\n                     (File, \"   Dot_Replacement => \"\"\" &\n-                     Namet.Get_Name_String (Data.Naming.Dot_Replacement) &\n+                     Namet.Get_Name_String (Project.Naming.Dot_Replacement) &\n                      \"\"\");\");\n                end if;\n             end if;\n \n-            if Data.Extends /= No_Project then\n-               Check (Data.Extends);\n+            if Project.Extends /= No_Project then\n+               Check (Project.Extends);\n             end if;\n \n             declare\n-               Current : Project_List := Data.Imported_Projects;\n+               Current : Project_List := Project.Imported_Projects;\n             begin\n                while Current /= null loop\n                   Check (Current.Project);\n@@ -666,9 +661,7 @@ package body Prj.Env is\n    --  Start of processing for Create_Config_Pragmas_File\n \n    begin\n-      if not\n-        In_Tree.Projects.Table (For_Project).Config_Checked\n-      then\n+      if not For_Project.Config_Checked then\n \n          --  Remove any memory of processed naming schemes, if any\n \n@@ -738,13 +731,9 @@ package body Prj.Env is\n             Write_Line (\"\"\"\");\n          end if;\n \n-         In_Tree.Projects.Table (For_Project).Config_File_Name :=\n-           File_Name;\n-         In_Tree.Projects.Table (For_Project).Config_File_Temp :=\n-           True;\n-\n-         In_Tree.Projects.Table (For_Project).Config_Checked :=\n-           True;\n+         For_Project.Config_File_Name := File_Name;\n+         For_Project.Config_File_Temp := True;\n+         For_Project.Config_Checked   := True;\n       end if;\n    end Create_Config_Pragmas_File;\n \n@@ -811,8 +800,7 @@ package body Prj.Env is\n       File   : File_Descriptor := Invalid_FD;\n       Status : Boolean;\n \n-      Present : array (No_Project .. Project_Table.Last (In_Tree.Projects))\n-                  of Boolean := (others => False);\n+      Present : Project_Boolean_Htable.Instance;\n       --  For each project in the closure of Project, the corresponding flag\n       --  will be set to True.\n \n@@ -893,16 +881,18 @@ package body Prj.Env is\n          --  Nothing to do for non existent project or project that has already\n          --  been flagged.\n \n-         if Prj /= No_Project and then not Present (Prj) then\n-            Present (Prj) := True;\n+         if Prj /= No_Project\n+           and then not Project_Boolean_Htable.Get (Present, Prj)\n+         then\n+            Project_Boolean_Htable.Set (Present, Prj, True);\n \n-            Imported := In_Tree.Projects.Table (Prj).Imported_Projects;\n+            Imported := Prj.Imported_Projects;\n             while Imported /= null loop\n                Recursive_Flag (Imported.Project);\n                Imported := Imported.Next;\n             end loop;\n \n-            Recursive_Flag (In_Tree.Projects.Table (Prj).Extends);\n+            Recursive_Flag (Prj.Extends);\n          end if;\n       end Recursive_Flag;\n \n@@ -943,7 +933,9 @@ package body Prj.Env is\n                   --  If there is a spec, put it mapping in the file if it is\n                   --  from a project in the closure of Project.\n \n-                  if Data.Name /= No_File and then Present (Data.Project) then\n+                  if Data.Name /= No_File\n+                    and then Project_Boolean_Htable.Get (Present, Data.Project)\n+                  then\n                      Put_Data (Spec => True);\n                   end if;\n \n@@ -952,7 +944,9 @@ package body Prj.Env is\n                   --  If there is a body (or subunit) put its mapping in the\n                   --  file if it is from a project in the closure of Project.\n \n-                  if Data.Name /= No_File and then Present (Data.Project) then\n+                  if Data.Name /= No_File\n+                    and then Project_Boolean_Htable.Get (Present, Data.Project)\n+                  then\n                      Put_Data (Spec => False);\n                   end if;\n                end if;\n@@ -963,48 +957,56 @@ package body Prj.Env is\n       else\n          --  For all source of the Language of all projects in the closure\n \n-         for Proj in Present'Range loop\n-            if Present (Proj) then\n-\n-               Iter := For_Each_Source (In_Tree, Proj);\n-               loop\n-                  Source := Prj.Element (Iter);\n-                  exit when Source = No_Source;\n-\n-                  if Source.Language.Name = Language\n-                    and then not Source.Locally_Removed\n-                    and then Source.Replaced_By = No_Source\n-                    and then Source.Path.Name /= No_Path\n-                  then\n-                     if Source.Unit /= No_Name then\n-                        Get_Name_String (Source.Unit);\n-\n-                        if Source.Kind = Spec then\n-                           Suffix :=\n-                             Source.Language.Config.Mapping_Spec_Suffix;\n-                        else\n-                           Suffix :=\n-                             Source.Language.Config.Mapping_Body_Suffix;\n+         declare\n+            P : Project_List;\n+         begin\n+            P := In_Tree.Projects;\n+            while P /= null loop\n+               if Project_Boolean_Htable.Get (Present, P.Project) then\n+\n+                  Iter := For_Each_Source (In_Tree, P.Project);\n+                  loop\n+                     Source := Prj.Element (Iter);\n+                     exit when Source = No_Source;\n+\n+                     if Source.Language.Name = Language\n+                       and then not Source.Locally_Removed\n+                       and then Source.Replaced_By = No_Source\n+                       and then Source.Path.Name /= No_Path\n+                     then\n+                        if Source.Unit /= No_Name then\n+                           Get_Name_String (Source.Unit);\n+\n+                           if Source.Kind = Spec then\n+                              Suffix :=\n+                                Source.Language.Config.Mapping_Spec_Suffix;\n+                           else\n+                              Suffix :=\n+                                Source.Language.Config.Mapping_Body_Suffix;\n+                           end if;\n+\n+                           if Suffix /= No_File then\n+                              Add_Str_To_Name_Buffer\n+                                (Get_Name_String (Suffix));\n+                           end if;\n+\n+                           Put_Name_Buffer;\n                         end if;\n \n-                        if Suffix /= No_File then\n-                           Add_Str_To_Name_Buffer (Get_Name_String (Suffix));\n-                        end if;\n+                        Get_Name_String (Source.File);\n+                        Put_Name_Buffer;\n \n+                        Get_Name_String (Source.Path.Name);\n                         Put_Name_Buffer;\n                      end if;\n \n-                     Get_Name_String (Source.File);\n-                     Put_Name_Buffer;\n-\n-                     Get_Name_String (Source.Path.Name);\n-                     Put_Name_Buffer;\n-                  end if;\n+                     Next (Iter);\n+                  end loop;\n+               end if;\n \n-                  Next (Iter);\n-               end loop;\n-            end if;\n-         end loop;\n+               P := P.Next;\n+            end loop;\n+         end;\n       end if;\n \n       GNAT.OS_Lib.Close (File, Status);\n@@ -1017,6 +1019,8 @@ package body Prj.Env is\n \n          Prj.Com.Fail (\"disk full, could not write mapping file\");\n       end if;\n+\n+      Project_Boolean_Htable.Reset (Present);\n    end Create_Mapping_File;\n \n    --------------------------\n@@ -1092,16 +1096,14 @@ package body Prj.Env is\n       Full_Path         : Boolean := False) return String\n    is\n       The_Project   : Project_Id := Project;\n-      Data          : Project_Data :=\n-                        In_Tree.Projects.Table (Project);\n       Original_Name : String := Name;\n \n       Extended_Spec_Name : String :=\n                              Name &\n-                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n+                             Spec_Suffix_Of (In_Tree, \"ada\", Project.Naming);\n       Extended_Body_Name : String :=\n                              Name &\n-                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n+                             Body_Suffix_Of (In_Tree, \"ada\", Project.Naming);\n \n       Unit : Unit_Data;\n \n@@ -1281,12 +1283,12 @@ package body Prj.Env is\n \n          --  If we are not in an extending project, give up\n \n-         exit when (not Main_Project_Only) or else Data.Extends = No_Project;\n+         exit when not Main_Project_Only\n+           or else The_Project.Extends = No_Project;\n \n          --  Otherwise, look in the project we are extending\n \n-         The_Project := Data.Extends;\n-         Data := In_Tree.Projects.Table (The_Project);\n+         The_Project := The_Project.Extends;\n       end loop;\n \n       --  We don't know this file name, return an empty string\n@@ -1298,10 +1300,7 @@ package body Prj.Env is\n    -- For_All_Object_Dirs --\n    -------------------------\n \n-   procedure For_All_Object_Dirs\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref)\n-   is\n+   procedure For_All_Object_Dirs (Project : Project_Id) is\n       procedure For_Project (Prj : Project_Id; Dummy : in out Integer);\n       --  Get all object directories of Prj\n \n@@ -1311,15 +1310,12 @@ package body Prj.Env is\n \n       procedure For_Project (Prj : Project_Id; Dummy : in out Integer) is\n          pragma Unreferenced (Dummy);\n-\n-         Data : Project_Data renames In_Tree.Projects.Table (Prj);\n-\n       begin\n          --  ??? Set_Ada_Paths has a different behavior for library project\n          --  files, should we have the same ?\n \n-         if Data.Object_Directory /= No_Path_Information then\n-            Get_Name_String (Data.Object_Directory.Display_Name);\n+         if Prj.Object_Directory /= No_Path_Information then\n+            Get_Name_String (Prj.Object_Directory.Display_Name);\n             Action (Name_Buffer (1 .. Name_Len));\n          end if;\n       end For_Project;\n@@ -1331,7 +1327,7 @@ package body Prj.Env is\n    --  Start of processing for For_All_Object_Dirs\n \n    begin\n-      Get_Object_Dirs (Project, In_Tree, Dummy);\n+      Get_Object_Dirs (Project, Dummy);\n    end For_All_Object_Dirs;\n \n    -------------------------\n@@ -1351,16 +1347,14 @@ package body Prj.Env is\n \n       procedure For_Project (Prj : Project_Id; Dummy : in out Integer) is\n          pragma Unreferenced (Dummy);\n-\n-         Data       : Project_Data renames In_Tree.Projects.Table (Prj);\n-         Current    : String_List_Id := Data.Source_Dirs;\n+         Current    : String_List_Id := Prj.Source_Dirs;\n          The_String : String_Element;\n \n       begin\n          --  If there are Ada sources, call action with the name of every\n          --  source directory.\n \n-         if Has_Ada_Sources (In_Tree.Projects.Table (Project)) then\n+         if Has_Ada_Sources (Project) then\n             while Current /= Nil_String loop\n                The_String := In_Tree.String_Elements.Table (Current);\n                Action (Get_Name_String (The_String.Display_Value));\n@@ -1376,7 +1370,7 @@ package body Prj.Env is\n    --  Start of processing for For_All_Source_Dirs\n \n    begin\n-      Get_Source_Dirs (Project, In_Tree, Dummy);\n+      Get_Source_Dirs (Project, Dummy);\n    end For_All_Source_Dirs;\n \n    -------------------\n@@ -1422,8 +1416,7 @@ package body Prj.Env is\n                                                               Original_Name)\n             then\n                Project := Ultimate_Extension_Of\n-                           (Project => Unit.File_Names (Specification).Project,\n-                            In_Tree => In_Tree);\n+                          (Project => Unit.File_Names (Specification).Project);\n                Path := Unit.File_Names (Specification).Path.Display_Name;\n \n                if Current_Verbosity > Default then\n@@ -1443,8 +1436,7 @@ package body Prj.Env is\n                                                              Original_Name)\n             then\n                Project := Ultimate_Extension_Of\n-                            (Project => Unit.File_Names (Body_Part).Project,\n-                             In_Tree => In_Tree);\n+                            (Project => Unit.File_Names (Body_Part).Project);\n                Path := Unit.File_Names (Body_Part).Path.Display_Name;\n \n                if Current_Verbosity > Default then\n@@ -1503,8 +1495,7 @@ package body Prj.Env is\n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (In_Tree.Projects.Table\n-                   (Unit.File_Names (Specification).Project).Path.Name);\n+                 (Unit.File_Names (Specification).Project.Path.Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n \n@@ -1521,8 +1512,7 @@ package body Prj.Env is\n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (In_Tree.Projects.Table\n-                   (Unit.File_Names (Body_Part).Project).Path.Name);\n+                 (Unit.File_Names (Body_Part).Project.Path.Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n \n@@ -1549,15 +1539,10 @@ package body Prj.Env is\n \n       Original_Name : String := Name;\n \n-      Data   : constant Project_Data :=\n-        In_Tree.Projects.Table (Main_Project);\n-\n       Extended_Spec_Name : String :=\n-                             Name &\n-                             Spec_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n+        Name & Spec_Suffix_Of (In_Tree, \"ada\", Main_Project.Naming);\n       Extended_Body_Name : String :=\n-                             Name &\n-                             Body_Suffix_Of (In_Tree, \"ada\", Data.Naming);\n+        Name & Body_Suffix_Of (In_Tree, \"ada\", Main_Project.Naming);\n \n       Unit : Unit_Data;\n \n@@ -1629,10 +1614,8 @@ package body Prj.Env is\n       --  Get the ultimate extending project\n \n       if Result /= No_Project then\n-         while In_Tree.Projects.Table (Result).Extended_By /=\n-           No_Project\n-         loop\n-            Result := In_Tree.Projects.Table (Result).Extended_By;\n+         while Result.Extended_By /= No_Project loop\n+            Result := Result.Extended_By;\n          end loop;\n       end if;\n \n@@ -1671,7 +1654,6 @@ package body Prj.Env is\n       procedure Recursive_Add (Project : Project_Id; Dummy : in out Boolean) is\n          pragma Unreferenced (Dummy);\n \n-         Data : constant Project_Data := In_Tree.Projects.Table (Project);\n          Path : Path_Name_Type;\n \n       begin\n@@ -1682,14 +1664,14 @@ package body Prj.Env is\n             --  Add to path all source directories of this project if there are\n             --  Ada sources.\n \n-            if Has_Ada_Sources (In_Tree.Projects.Table (Project)) then\n-               Add_To_Source_Path (Data.Source_Dirs, In_Tree);\n+            if Has_Ada_Sources (Project) then\n+               Add_To_Source_Path (Project.Source_Dirs, In_Tree);\n             end if;\n          end if;\n \n          if Process_Object_Dirs then\n             Path := Get_Object_Directory\n-              (In_Tree, Project,\n+              (Project,\n                Including_Libraries => Including_Libraries,\n                Only_If_Ada         => True);\n \n@@ -1709,34 +1691,27 @@ package body Prj.Env is\n       --  If it is the first time we call this procedure for this project,\n       --  compute the source path and/or the object path.\n \n-      if In_Tree.Projects.Table (Project).Include_Path_File = No_Path then\n+      if Project.Include_Path_File = No_Path then\n          Process_Source_Dirs := True;\n          Create_New_Path_File\n-           (In_Tree, Source_FD,\n-            In_Tree.Projects.Table (Project).Include_Path_File);\n+           (In_Tree, Source_FD, Project.Include_Path_File);\n       end if;\n \n       --  For the object path, we make a distinction depending on\n       --  Including_Libraries.\n \n       if Including_Libraries then\n-         if In_Tree.Projects.Table\n-           (Project).Objects_Path_File_With_Libs = No_Path\n-         then\n+         if Project.Objects_Path_File_With_Libs = No_Path then\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n-              (In_Tree, Object_FD, In_Tree.Projects.Table (Project).\n-                                           Objects_Path_File_With_Libs);\n+              (In_Tree, Object_FD, Project.Objects_Path_File_With_Libs);\n          end if;\n \n       else\n-         if In_Tree.Projects.Table\n-              (Project).Objects_Path_File_Without_Libs = No_Path\n-         then\n+         if Project.Objects_Path_File_Without_Libs = No_Path then\n             Process_Object_Dirs := True;\n             Create_New_Path_File\n-              (In_Tree, Object_FD, In_Tree.Projects.Table (Project).\n-                                           Objects_Path_File_Without_Libs);\n+              (In_Tree, Object_FD, Project.Objects_Path_File_Without_Libs);\n          end if;\n       end if;\n \n@@ -1746,7 +1721,7 @@ package body Prj.Env is\n       if Process_Source_Dirs or Process_Object_Dirs then\n          Source_Path_Table.Set_Last (In_Tree.Private_Part.Source_Paths, 0);\n          Object_Path_Table.Set_Last (In_Tree.Private_Part.Object_Paths, 0);\n-         For_All_Projects (Project, In_Tree, Dummy);\n+         For_All_Projects (Project, Dummy);\n       end if;\n \n       --  Write and close any file that has been created\n@@ -1799,10 +1774,10 @@ package body Prj.Env is\n       --  corresponding flags.\n \n       if In_Tree.Private_Part.Current_Source_Path_File /=\n-           In_Tree.Projects.Table (Project).Include_Path_File\n+           Project.Include_Path_File\n       then\n          In_Tree.Private_Part.Current_Source_Path_File :=\n-           In_Tree.Projects.Table (Project).Include_Path_File;\n+           Project.Include_Path_File;\n          Set_Path_File_Var\n            (Project_Include_Path_File,\n             Get_Name_String (In_Tree.Private_Part.Current_Source_Path_File));\n@@ -1811,11 +1786,10 @@ package body Prj.Env is\n \n       if Including_Libraries then\n          if In_Tree.Private_Part.Current_Object_Path_File /=\n-            In_Tree.Projects.Table (Project).Objects_Path_File_With_Libs\n+            Project.Objects_Path_File_With_Libs\n          then\n             In_Tree.Private_Part.Current_Object_Path_File :=\n-              In_Tree.Projects.Table\n-                (Project).Objects_Path_File_With_Libs;\n+              Project.Objects_Path_File_With_Libs;\n             Set_Path_File_Var\n               (Project_Objects_Path_File,\n                Get_Name_String\n@@ -1825,11 +1799,10 @@ package body Prj.Env is\n \n       else\n          if In_Tree.Private_Part.Current_Object_Path_File /=\n-            In_Tree.Projects.Table (Project).Objects_Path_File_Without_Libs\n+            Project.Objects_Path_File_Without_Libs\n          then\n             In_Tree.Private_Part.Current_Object_Path_File :=\n-              In_Tree.Projects.Table\n-                (Project).Objects_Path_File_Without_Libs;\n+              Project.Objects_Path_File_Without_Libs;\n             Set_Path_File_Var\n               (Project_Objects_Path_File,\n                Get_Name_String\n@@ -1871,14 +1844,13 @@ package body Prj.Env is\n    ---------------------------\n \n    function Ultimate_Extension_Of\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Project_Id\n+     (Project : Project_Id) return Project_Id\n    is\n       Result : Project_Id := Project;\n \n    begin\n-      while In_Tree.Projects.Table (Result).Extended_By /= No_Project loop\n-         Result := In_Tree.Projects.Table (Result).Extended_By;\n+      while Result.Extended_By /= No_Project loop\n+         Result := Result.Extended_By;\n       end loop;\n \n       return Result;"}, {"sha": "3a92d9967433664aebe52100356a51ee83da6e47", "filename": "gcc/ada/prj-env.ads", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-env.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-env.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.ads?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -166,9 +166,7 @@ package Prj.Env is\n \n    generic\n       with procedure Action (Path : String);\n-   procedure For_All_Object_Dirs\n-     (Project : Project_Id;\n-      In_Tree : Project_Tree_Ref);\n+   procedure For_All_Object_Dirs (Project : Project_Id);\n    --  Iterate through all the object directories of a project, including\n    --  those of imported or modified projects.\n "}, {"sha": "1f347a95d24db22ce1cb9de055d04e05863b84de", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 471, "deletions": 521, "changes": 992, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98"}, {"sha": "5ddafbc7799717266cdb7ba3043562b5594c52f6", "filename": "gcc/ada/prj-pp.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-pp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-pp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -74,8 +74,7 @@ package body Prj.PP is\n       W_Eol                              : Write_Eol_Ap  := null;\n       W_Str                              : Write_Str_Ap  := null;\n       Backward_Compatibility             : Boolean;\n-      Id                                 : Prj.Project_Id := Prj.No_Project;\n-      Id_Tree                            : Prj.Project_Tree_Ref := null)\n+      Id                                 : Prj.Project_Id := Prj.No_Project)\n    is\n       procedure Print (Node : Project_Node_Id; Indent : Natural);\n       --  A recursive procedure that traverses a project file tree and outputs\n@@ -339,7 +338,7 @@ package body Prj.PP is\n                   Write_String (\"project \");\n \n                   if Id /= Prj.No_Project then\n-                     Output_Name (Id_Tree.Projects.Table (Id).Display_Name);\n+                     Output_Name (Id.Display_Name);\n                   else\n                      Output_Name (Name_Of (Node, In_Tree));\n                   end if;\n@@ -372,7 +371,7 @@ package body Prj.PP is\n                   Write_String (\"end \");\n \n                   if Id /= Prj.No_Project then\n-                     Output_Name (Id_Tree.Projects.Table (Id).Display_Name);\n+                     Output_Name (Id.Display_Name);\n                   else\n                      Output_Name (Name_Of (Node, In_Tree));\n                   end if;"}, {"sha": "ac6c03db3263391763a18573e337effe091bd4b9", "filename": "gcc/ada/prj-pp.ads", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-pp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-pp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-pp.ads?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -53,8 +53,7 @@ package Prj.PP is\n       W_Eol                              : Write_Eol_Ap  := null;\n       W_Str                              : Write_Str_Ap  := null;\n       Backward_Compatibility             : Boolean;\n-      Id                                 : Prj.Project_Id := Prj.No_Project;\n-      Id_Tree                            : Prj.Project_Tree_Ref := null);\n+      Id                                 : Prj.Project_Id := Prj.No_Project);\n    --  Output a project file, using either the default output routines, or the\n    --  ones specified by W_Char, W_Eol and W_Str.\n    --"}, {"sha": "0ddc9ced559e5a5bbbea535ab854d05e2cde8c14", "filename": "gcc/ada/prj-proc.adb", "status": "modified", "additions": 100, "deletions": 157, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-proc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-proc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-proc.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -111,7 +111,6 @@ package body Prj.Proc is\n \n    function Imported_Or_Extended_Project_From\n      (Project   : Project_Id;\n-      In_Tree   : Project_Tree_Ref;\n       With_Name : Name_Id) return Project_Id;\n    --  Find an imported or extended project of Project whose name is With_Name\n \n@@ -295,7 +294,7 @@ package body Prj.Proc is\n       Data.When_No_Sources := When_No_Sources;\n       Initialize (Data.Proc_Data);\n \n-      Check_All_Projects (Project, In_Tree, Data, Imported_First => True);\n+      Check_All_Projects (Project, Data, Imported_First => True);\n \n       --  Set the Other_Part field for the units\n \n@@ -683,7 +682,6 @@ package body Prj.Proc is\n                        Name_Of (Term_Project, From_Project_Node_Tree);\n                      The_Project := Imported_Or_Extended_Project_From\n                                       (Project   => Project,\n-                                       In_Tree   => In_Tree,\n                                        With_Name => The_Name);\n                   end if;\n \n@@ -693,8 +691,7 @@ package body Prj.Proc is\n \n                      The_Name :=\n                        Name_Of (Term_Package, From_Project_Node_Tree);\n-                     The_Package := In_Tree.Projects.Table\n-                                      (The_Project).Decl.Packages;\n+                     The_Package := The_Project.Decl.Packages;\n \n                      while The_Package /= No_Package\n                        and then In_Tree.Packages.Table\n@@ -767,13 +764,9 @@ package body Prj.Proc is\n                         if Kind_Of (The_Current_Term, From_Project_Node_Tree) =\n                              N_Variable_Reference\n                         then\n-                           The_Variable_Id :=\n-                             In_Tree.Projects.Table\n-                               (The_Project).Decl.Variables;\n+                           The_Variable_Id := The_Project.Decl.Variables;\n                         else\n-                           The_Variable_Id :=\n-                             In_Tree.Projects.Table\n-                               (The_Project).Decl.Attributes;\n+                           The_Variable_Id := The_Project.Decl.Attributes;\n                         end if;\n \n                         while The_Variable_Id /= No_Variable\n@@ -811,9 +804,7 @@ package body Prj.Proc is\n                              In_Tree.Packages.Table\n                                (The_Package).Decl.Arrays;\n                         else\n-                           The_Array :=\n-                             In_Tree.Projects.Table\n-                               (The_Project).Decl.Arrays;\n+                           The_Array := The_Project.Decl.Arrays;\n                         end if;\n \n                         while The_Array /= No_Array\n@@ -1137,36 +1128,34 @@ package body Prj.Proc is\n \n    function Imported_Or_Extended_Project_From\n      (Project   : Project_Id;\n-      In_Tree   : Project_Tree_Ref;\n       With_Name : Name_Id) return Project_Id\n    is\n-      Data        : constant Project_Data := In_Tree.Projects.Table (Project);\n       List        : Project_List;\n       Result      : Project_Id;\n       Temp_Result : Project_Id;\n \n    begin\n       --  First check if it is the name of an extended project\n \n-      Result := Data.Extends;\n+      Result := Project.Extends;\n       while Result /= No_Project loop\n-         if In_Tree.Projects.Table (Result).Name = With_Name then\n+         if Result.Name = With_Name then\n             return Result;\n          else\n-            Result := In_Tree.Projects.Table (Result).Extends;\n+            Result := Result.Extends;\n          end if;\n       end loop;\n \n       --  Then check the name of each imported project\n \n       Temp_Result := No_Project;\n-      List := Data.Imported_Projects;\n+      List := Project.Imported_Projects;\n       while List /= null loop\n          Result := List.Project;\n \n          --  If the project is directly imported, then returns its ID\n \n-         if In_Tree.Projects.Table (Result).Name = With_Name then\n+         if Result.Name = With_Name then\n             return Result;\n          end if;\n \n@@ -1175,16 +1164,16 @@ package body Prj.Proc is\n          --  if the project is not imported directly.\n \n          declare\n-            Proj : Project_Id := In_Tree.Projects.Table (Result).Extends;\n+            Proj : Project_Id := Result.Extends;\n \n          begin\n             while Proj /= No_Project loop\n-               if In_Tree.Projects.Table (Proj).Name = With_Name then\n+               if Proj.Name = With_Name then\n                   Temp_Result := Result;\n                   exit;\n                end if;\n \n-               Proj := In_Tree.Projects.Table (Proj).Extends;\n+               Proj := Proj.Extends;\n             end loop;\n          end;\n \n@@ -1204,9 +1193,7 @@ package body Prj.Proc is\n       In_Tree   : Project_Tree_Ref;\n       With_Name : Name_Id) return Package_Id\n    is\n-      Data   : constant Project_Data :=\n-        In_Tree.Projects.Table (Project);\n-      Result : Package_Id := Data.Decl.Packages;\n+      Result : Package_Id := Project.Decl.Packages;\n \n    begin\n       --  Check the name of each existing package of Project\n@@ -1342,10 +1329,8 @@ package body Prj.Proc is\n                           New_Pkg;\n \n                      else\n-                        The_New_Package.Next :=\n-                          In_Tree.Projects.Table (Project).Decl.Packages;\n-                        In_Tree.Projects.Table (Project).Decl.Packages :=\n-                          New_Pkg;\n+                        The_New_Package.Next  := Project.Decl.Packages;\n+                        Project.Decl.Packages := New_Pkg;\n                      end if;\n \n                      In_Tree.Packages.Table (New_Pkg) :=\n@@ -1364,7 +1349,7 @@ package body Prj.Proc is\n                            Renamed_Project :\n                              constant Project_Id :=\n                                Imported_Or_Extended_Project_From\n-                               (Project, In_Tree, Project_Name);\n+                               (Project, Project_Name);\n \n                            Renamed_Package : constant Package_Id :=\n                                                Package_From\n@@ -1398,9 +1383,8 @@ package body Prj.Proc is\n \n                         Add_Attributes\n                           (Project,\n-                           In_Tree.Projects.Table (Project).Name,\n-                           Name_Id\n-                             (In_Tree.Projects.Table (Project).Directory.Name),\n+                           Project.Name,\n+                           Name_Id (Project.Directory.Name),\n                            In_Tree,\n                            In_Tree.Packages.Table (New_Pkg).Decl,\n                            First_Attribute_Of\n@@ -1488,6 +1472,8 @@ package body Prj.Proc is\n                      --  associative array attribute may already have been\n                      --  declared, and the array elements declared are reused.\n \n+                     Prj : Project_List;\n+\n                   begin\n                      --  First find if the associative array attribute already\n                      --  has elements declared.\n@@ -1497,8 +1483,7 @@ package body Prj.Proc is\n                                        (Pkg).Decl.Arrays;\n \n                      else\n-                        New_Array := In_Tree.Projects.Table\n-                                       (Project).Decl.Arrays;\n+                        New_Array := Project.Decl.Arrays;\n                      end if;\n \n                      while New_Array /= No_Array\n@@ -1531,11 +1516,9 @@ package body Prj.Proc is\n                              (Name     => Current_Item_Name,\n                               Location => Current_Location,\n                               Value    => No_Array_Element,\n-                              Next     => In_Tree.Projects.Table\n-                                            (Project).Decl.Arrays);\n+                              Next     => Project.Decl.Arrays);\n \n-                           In_Tree.Projects.Table (Project).Decl.Arrays :=\n-                             New_Array;\n+                           Project.Decl.Arrays := New_Array;\n                         end if;\n                      end if;\n \n@@ -1547,16 +1530,13 @@ package body Prj.Proc is\n                               (Current_Item, From_Project_Node_Tree),\n                           From_Project_Node_Tree);\n \n-                     for Index in Project_Table.First ..\n-                                  Project_Table.Last\n-                                    (In_Tree.Projects)\n-                     loop\n-                        if In_Tree.Projects.Table (Index).Name =\n-                                                           Orig_Project_Name\n-                        then\n-                           Orig_Project := Index;\n+                     Prj := In_Tree.Projects;\n+                     while Prj /= null loop\n+                        if Prj.Project.Name = Orig_Project_Name then\n+                           Orig_Project := Prj.Project;\n                            exit;\n                         end if;\n+                        Prj := Prj.Next;\n                      end loop;\n \n                      pragma Assert (Orig_Project /= No_Project,\n@@ -1565,9 +1545,7 @@ package body Prj.Proc is\n                      if No (Associative_Package_Of\n                               (Current_Item, From_Project_Node_Tree))\n                      then\n-                        Orig_Array :=\n-                          In_Tree.Projects.Table\n-                            (Orig_Project).Decl.Arrays;\n+                        Orig_Array := Orig_Project.Decl.Arrays;\n \n                      else\n                         --  If in a package, find the package where the value\n@@ -1579,9 +1557,7 @@ package body Prj.Proc is\n                                  (Current_Item, From_Project_Node_Tree),\n                              From_Project_Node_Tree);\n \n-                        Orig_Package :=\n-                          In_Tree.Projects.Table\n-                            (Orig_Project).Decl.Packages;\n+                        Orig_Package := Orig_Project.Decl.Packages;\n                         pragma Assert (Orig_Package /= No_Package,\n                                        \"original package not found\");\n \n@@ -1848,9 +1824,7 @@ package body Prj.Proc is\n                                 In_Tree.Packages.Table\n                                   (Pkg).Decl.Attributes;\n                            else\n-                              The_Variable :=\n-                                In_Tree.Projects.Table\n-                                  (Project).Decl.Attributes;\n+                              The_Variable := Project.Decl.Attributes;\n                            end if;\n \n                         else\n@@ -1859,9 +1833,7 @@ package body Prj.Proc is\n                                 In_Tree.Packages.Table\n                                   (Pkg).Decl.Variables;\n                            else\n-                              The_Variable :=\n-                                In_Tree.Projects.Table\n-                                  (Project).Decl.Variables;\n+                              The_Variable := Project.Decl.Variables;\n                            end if;\n \n                         end if;\n@@ -1911,14 +1883,10 @@ package body Prj.Proc is\n \n                            else\n                               In_Tree.Variable_Elements.Table (The_Variable) :=\n-                                (Next   =>\n-                                   In_Tree.Projects.Table\n-                                     (Project).Decl.Variables,\n+                                (Next   => Project.Decl.Variables,\n                                  Name   => Current_Item_Name,\n                                  Value  => New_Value);\n-                              In_Tree.Projects.Table\n-                                (Project).Decl.Variables :=\n-                                  The_Variable;\n+                              Project.Decl.Variables := The_Variable;\n                            end if;\n \n                         --  If the variable/attribute has already been\n@@ -1986,8 +1954,7 @@ package body Prj.Proc is\n                                 In_Tree.Packages.Table (Pkg).Decl.Arrays;\n \n                            else\n-                              The_Array :=\n-                                In_Tree.Projects.Table (Project).Decl.Arrays;\n+                              The_Array := Project.Decl.Arrays;\n                            end if;\n \n                            while\n@@ -2025,11 +1992,9 @@ package body Prj.Proc is\n                                    (Name     => Current_Item_Name,\n                                     Location => Current_Location,\n                                     Value    => No_Array_Element,\n-                                    Next     => In_Tree.Projects.Table\n-                                                  (Project).Decl.Arrays);\n+                                    Next     => Project.Decl.Arrays);\n \n-                                 In_Tree.Projects.Table\n-                                   (Project).Decl.Arrays := The_Array;\n+                                 Project.Decl.Arrays := The_Array;\n                               end if;\n \n                            --  Otherwise initialize The_Array_Element as the\n@@ -2131,8 +2096,7 @@ package body Prj.Proc is\n                                (Variable_Node, From_Project_Node_Tree),\n                              From_Project_Node_Tree);\n                         The_Project :=\n-                          Imported_Or_Extended_Project_From\n-                            (Project, In_Tree, Name);\n+                          Imported_Or_Extended_Project_From (Project, Name);\n                      end if;\n \n                      --  If a package were specified for the case variable,\n@@ -2178,8 +2142,7 @@ package body Prj.Proc is\n                         No (Package_Node_Of\n                               (Variable_Node, From_Project_Node_Tree))\n                      then\n-                        Var_Id := In_Tree.Projects.Table\n-                                    (The_Project).Decl.Variables;\n+                        Var_Id := The_Project.Decl.Variables;\n                         while Var_Id /= No_Variable\n                           and then\n                             In_Tree.Variable_Elements.Table\n@@ -2309,7 +2272,7 @@ package body Prj.Proc is\n \n          --  Make sure there are no projects in the data structure\n \n-         Project_Table.Set_Last (In_Tree.Projects, No_Project);\n+         Free_List (In_Tree.Projects, Free_Project => True);\n       end if;\n \n       Processed_Projects.Reset;\n@@ -2347,6 +2310,7 @@ package body Prj.Proc is\n       Obj_Dir    : Path_Name_Type;\n       Extending  : Project_Id;\n       Extending2 : Project_Id;\n+      Prj        : Project_List;\n \n    --  Start of processing for Process_Project_Tree_Phase_2\n \n@@ -2368,16 +2332,14 @@ package body Prj.Proc is\n       then\n          declare\n             Object_Dir : constant Path_Name_Type :=\n-                           In_Tree.Projects.Table\n-                             (Project).Object_Directory.Name;\n+                           Project.Object_Directory.Name;\n          begin\n-            for Index in\n-              Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n-            loop\n-               if In_Tree.Projects.Table (Index).Virtual then\n-                  In_Tree.Projects.Table (Index).Object_Directory.Name :=\n-                    Object_Dir;\n+            Prj := In_Tree.Projects;\n+            while Prj /= null loop\n+               if Prj.Project.Virtual then\n+                  Prj.Project.Object_Directory.Name := Object_Dir;\n                end if;\n+               Prj := Prj.Next;\n             end loop;\n          end;\n       end if;\n@@ -2386,13 +2348,12 @@ package body Prj.Proc is\n       --  the project(s) it extends.\n \n       if Project /= No_Project then\n-         for Proj in\n-           Project_Table.First .. Project_Table.Last (In_Tree.Projects)\n-         loop\n-            Extending := In_Tree.Projects.Table (Proj).Extended_By;\n+         Prj := In_Tree.Projects;\n+         while Prj /= null loop\n+            Extending := Prj.Project.Extended_By;\n \n             if Extending /= No_Project then\n-               Obj_Dir := In_Tree.Projects.Table (Proj).Object_Directory.Name;\n+               Obj_Dir := Prj.Project.Object_Directory.Name;\n \n                --  Check that a project being extended does not share its\n                --  object directory with any project that extends it, directly\n@@ -2402,20 +2363,17 @@ package body Prj.Proc is\n \n                Extending2 := Extending;\n                while Extending2 /= No_Project loop\n-                  if Has_Ada_Sources (In_Tree.Projects.Table (Extending2))\n-                    and then\n-                      In_Tree.Projects.Table\n-                        (Extending2).Object_Directory.Name = Obj_Dir\n+                  if Has_Ada_Sources (Extending2)\n+                    and then Extending2.Object_Directory.Name = Obj_Dir\n                   then\n-                     if In_Tree.Projects.Table (Extending2).Virtual then\n-                        Error_Msg_Name_1 :=\n-                          In_Tree.Projects.Table (Proj).Display_Name;\n+                     if Extending2.Virtual then\n+                        Error_Msg_Name_1 := Prj.Project.Display_Name;\n \n                         if Error_Report = null then\n                            Error_Msg\n                              (\"project %% cannot be extended by a virtual\" &\n                               \" project with the same object directory\",\n-                              In_Tree.Projects.Table (Proj).Location);\n+                              Prj.Project.Location);\n                         else\n                            Error_Report\n                              (\"project \"\"\" &\n@@ -2426,18 +2384,16 @@ package body Prj.Proc is\n                         end if;\n \n                      else\n-                        Error_Msg_Name_1 :=\n-                          In_Tree.Projects.Table (Extending2).Display_Name;\n-                        Error_Msg_Name_2 :=\n-                          In_Tree.Projects.Table (Proj).Display_Name;\n+                        Error_Msg_Name_1 := Extending2.Display_Name;\n+                        Error_Msg_Name_2 := Prj.Project.Display_Name;\n \n                         if Error_Report = null then\n                            Error_Msg\n                              (\"project %% cannot extend project %%\",\n-                              In_Tree.Projects.Table (Extending2).Location);\n+                              Extending2.Location);\n                            Error_Msg\n                              (\"\\they share the same object directory\",\n-                              In_Tree.Projects.Table (Extending2).Location);\n+                              Extending2.Location);\n \n                         else\n                            Error_Report\n@@ -2455,10 +2411,11 @@ package body Prj.Proc is\n \n                   --  Continue with the next extending project, if any\n \n-                  Extending2 :=\n-                    In_Tree.Projects.Table (Extending2).Extended_By;\n+                  Extending2 := Extending2.Extended_By;\n                end loop;\n             end if;\n+\n+            Prj := Prj.Next;\n          end loop;\n       end if;\n \n@@ -2479,8 +2436,7 @@ package body Prj.Proc is\n    begin\n       if Verbose_Mode then\n          Write_Str (\"Checking project file \"\"\");\n-         Write_Str\n-           (Get_Name_String (Data.In_Tree.Projects.Table (Project).Name));\n+         Write_Str (Get_Name_String (Project.Name));\n          Write_Line (\"\"\"\");\n       end if;\n \n@@ -2546,12 +2502,11 @@ package body Prj.Proc is\n                --  it is nil, then this imported project is our first.\n \n                if Imported = null then\n-                  In_Tree.Projects.Table (Project).Imported_Projects :=\n+                  Project.Imported_Projects :=\n                     new Project_List_Element'\n                       (Project => New_Project,\n                        Next    => null);\n-                  Imported :=\n-                    In_Tree.Projects.Table (Project).Imported_Projects;\n+                  Imported := Project.Imported_Projects;\n                else\n                   Imported.Next := new Project_List_Element'\n                     (Project => New_Project,\n@@ -2573,7 +2528,6 @@ package body Prj.Proc is\n \n       else\n          declare\n-            Processed_Data   : Project_Data     := Empty_Project (In_Tree);\n             Imported         : Project_List;\n             Declaration_Node : Project_Node_Id  := Empty_Node;\n             Tref             : Source_Buffer_Ptr;\n@@ -2595,22 +2549,22 @@ package body Prj.Proc is\n                --  This is for virtually extended projects.\n \n                if Extended_By /= No_Project then\n-                  In_Tree.Projects.Table (Project).Extended_By := Extended_By;\n+                  Project.Extended_By := Extended_By;\n                end if;\n \n                return;\n             end if;\n \n-            Project_Table.Increment_Last (In_Tree.Projects);\n-            Project := Project_Table.Last (In_Tree.Projects);\n+            Project := new Project_Data'(Empty_Project (In_Tree));\n+            In_Tree.Projects := new Project_List_Element'\n+              (Project => Project,\n+               Next    => In_Tree.Projects);\n+\n             Processed_Projects.Set (Name, Project);\n \n-            Processed_Data.Name := Name;\n-            Processed_Data.Qualifier :=\n+            Project.Name := Name;\n+            Project.Qualifier :=\n               Project_Qualifier_Of (From_Project_Node, From_Project_Node_Tree);\n-            In_Tree.Projects.Table (Project).Name := Name;\n-            In_Tree.Projects.Table (Project).Qualifier :=\n-              Processed_Data.Qualifier;\n \n             Get_Name_String (Name);\n \n@@ -2621,15 +2575,15 @@ package body Prj.Proc is\n               and then Name_Buffer (1 .. Virtual_Prefix'Length) =\n                          Virtual_Prefix\n             then\n-               Processed_Data.Virtual := True;\n-               Processed_Data.Display_Name := Name;\n+               Project.Virtual := True;\n+               Project.Display_Name := Name;\n \n             --  If there is no file, for example when the project node tree is\n             --  built in memory by GPS, the Display_Name cannot be found in\n             --  the source, so its value is the same as Name.\n \n             elsif Location = No_Location then\n-               Processed_Data.Display_Name := Name;\n+               Project.Display_Name := Name;\n \n             --  Get the spelling of the project name from the project file\n \n@@ -2641,37 +2595,35 @@ package body Prj.Proc is\n                   Location := Location + 1;\n                end loop;\n \n-               Processed_Data.Display_Name := Name_Find;\n+               Project.Display_Name := Name_Find;\n             end if;\n \n-            Processed_Data.Path.Display_Name :=\n+            Project.Path.Display_Name :=\n               Path_Name_Of (From_Project_Node, From_Project_Node_Tree);\n-            Get_Name_String (Processed_Data.Path.Display_Name);\n+            Get_Name_String (Project.Path.Display_Name);\n             Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-            Processed_Data.Path.Name := Name_Find;\n+            Project.Path.Name := Name_Find;\n \n-            Processed_Data.Location :=\n+            Project.Location :=\n               Location_Of (From_Project_Node, From_Project_Node_Tree);\n \n-            Processed_Data.Directory.Display_Name :=\n+            Project.Directory.Display_Name :=\n               Directory_Of (From_Project_Node, From_Project_Node_Tree);\n-            Get_Name_String (Processed_Data.Directory.Display_Name);\n+            Get_Name_String (Project.Directory.Display_Name);\n             Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n-            Processed_Data.Directory.Name := Name_Find;\n+            Project.Directory.Name := Name_Find;\n \n-            Processed_Data.Extended_By := Extended_By;\n+            Project.Extended_By := Extended_By;\n \n             Add_Attributes\n               (Project,\n                Name,\n-               Name_Id (Processed_Data.Directory.Name),\n+               Name_Id (Project.Directory.Name),\n                In_Tree,\n-               Processed_Data.Decl,\n+               Project.Decl,\n                Prj.Attr.Attribute_First,\n                Project_Level => True);\n \n-            In_Tree.Projects.Table (Project) := Processed_Data;\n-\n             Process_Imported_Projects (Imported, Limited_With => False);\n \n             Declaration_Node :=\n@@ -2680,7 +2632,7 @@ package body Prj.Proc is\n \n             Recursive_Process\n               (In_Tree                => In_Tree,\n-               Project            => In_Tree.Projects.Table (Project).Extends,\n+               Project                => Project.Extends,\n                From_Project_Node      => Extended_Project_Of\n                                           (Declaration_Node,\n                                            From_Project_Node_Tree),\n@@ -2702,27 +2654,22 @@ package body Prj.Proc is\n             --  or renamed. Also inherit the languages, if attribute Languages\n             --  is not explicitly defined.\n \n-            Processed_Data := In_Tree.Projects.Table (Project);\n-\n-            if Processed_Data.Extends /= No_Project then\n+            if Project.Extends /= No_Project then\n                declare\n                   Extended_Pkg : Package_Id;\n                   Current_Pkg  : Package_Id;\n                   Element      : Package_Element;\n                   First        : constant Package_Id :=\n-                                   Processed_Data.Decl.Packages;\n+                                   Project.Decl.Packages;\n                   Attribute1   : Variable_Id;\n                   Attribute2   : Variable_Id;\n                   Attr_Value1  : Variable;\n                   Attr_Value2  : Variable;\n \n                begin\n-                  Extended_Pkg :=\n-                    In_Tree.Projects.Table\n-                      (Processed_Data.Extends).Decl.Packages;\n+                  Extended_Pkg := Project.Extends.Decl.Packages;\n                   while Extended_Pkg /= No_Package loop\n-                     Element :=\n-                       In_Tree.Packages.Table (Extended_Pkg);\n+                     Element := In_Tree.Packages.Table (Extended_Pkg);\n \n                      Current_Pkg := First;\n                      while Current_Pkg /= No_Package\n@@ -2741,8 +2688,8 @@ package body Prj.Proc is\n                           (Name   => Element.Name,\n                            Decl   => No_Declarations,\n                            Parent => No_Package,\n-                           Next   => Processed_Data.Decl.Packages);\n-                        Processed_Data.Decl.Packages := Current_Pkg;\n+                           Next   => Project.Decl.Packages);\n+                        Project.Decl.Packages := Current_Pkg;\n                         Copy_Package_Declarations\n                           (From              => Element.Decl,\n                            To                =>\n@@ -2759,7 +2706,7 @@ package body Prj.Proc is\n                   --  Check if attribute Languages is declared in the\n                   --  extending project.\n \n-                  Attribute1 := Processed_Data.Decl.Attributes;\n+                  Attribute1 := Project.Decl.Attributes;\n                   while Attribute1 /= No_Variable loop\n                      Attr_Value1 := In_Tree.Variable_Elements.\n                                       Table (Attribute1);\n@@ -2774,9 +2721,7 @@ package body Prj.Proc is\n                      --  project. Check if it is declared in the project being\n                      --  extended.\n \n-                     Attribute2 :=\n-                       In_Tree.Projects.Table\n-                         (Processed_Data.Extends).Decl.Attributes;\n+                     Attribute2 := Project.Extends.Decl.Attributes;\n                      while Attribute2 /= No_Variable loop\n                         Attr_Value2 := In_Tree.Variable_Elements.\n                                          Table (Attribute2);\n@@ -2796,8 +2741,8 @@ package body Prj.Proc is\n                              (In_Tree.Variable_Elements);\n                            Attribute1 := Variable_Element_Table.Last\n                              (In_Tree.Variable_Elements);\n-                           Attr_Value1.Next := Processed_Data.Decl.Attributes;\n-                           Processed_Data.Decl.Attributes := Attribute1;\n+                           Attr_Value1.Next := Project.Decl.Attributes;\n+                           Project.Decl.Attributes := Attribute1;\n                         end if;\n \n                         Attr_Value1.Name := Snames.Name_Languages;\n@@ -2807,8 +2752,6 @@ package body Prj.Proc is\n                      end if;\n                   end if;\n                end;\n-\n-               In_Tree.Projects.Table (Project) := Processed_Data;\n             end if;\n \n             Process_Imported_Projects (Imported, Limited_With => True);"}, {"sha": "cd7696fdfed8ccaaf6e899d906d8977acca2e083", "filename": "gcc/ada/prj-util.adb", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-util.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2008, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2009, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -114,8 +114,7 @@ package body Prj.Util is\n    is\n       pragma Assert (Project /= No_Project);\n \n-      The_Packages : constant Package_Id :=\n-                       In_Tree.Projects.Table (Project).Decl.Packages;\n+      The_Packages : constant Package_Id := Project.Decl.Packages;\n \n       Builder_Package : constant Prj.Package_Id :=\n                           Prj.Util.Value_Of\n@@ -135,7 +134,7 @@ package body Prj.Util is\n \n       Executable_Suffix_Name : Name_Id := No_Name;\n \n-      Naming : constant Naming_Data := In_Tree.Projects.Table (Project).Naming;\n+      Naming : constant Naming_Data := Project.Naming;\n \n       Spec_Suffix : Name_Id := No_Name;\n       Body_Suffix : Name_Id := No_Name;\n@@ -188,8 +187,7 @@ package body Prj.Util is\n \n       if Builder_Package /= No_Package then\n          if Get_Mode = Multi_Language then\n-            Executable_Suffix_Name :=\n-              In_Tree.Projects.Table (Project).Config.Executable_Suffix;\n+            Executable_Suffix_Name := Project.Config.Executable_Suffix;\n \n          else\n             Executable_Suffix := Prj.Util.Value_Of\n@@ -330,11 +328,9 @@ package body Prj.Util is\n             Result     : File_Name_Type;\n \n          begin\n-            if In_Tree.Projects.Table (Project).Config.Executable_Suffix /=\n-              No_Name\n-            then\n+            if Project.Config.Executable_Suffix /= No_Name then\n                Executable_Extension_On_Target :=\n-                 In_Tree.Projects.Table (Project).Config.Executable_Suffix;\n+                 Project.Config.Executable_Suffix;\n             end if;\n \n             Result := Executable_Name (Name_Find);"}, {"sha": "f79716944f5be33dd397ece9ba85b1f9e45d61cc", "filename": "gcc/ada/prj.adb", "status": "modified", "additions": 75, "deletions": 81, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -143,12 +143,11 @@ package body Prj is\n    --  Table to store the path name of all the created temporary files, so that\n    --  they can be deleted at the end, or when the program is interrupted.\n \n-   procedure Free (Project : in out Project_Data; Reset_Only : Boolean);\n+   procedure Free (Project : in out Project_Id; Reset_Only : Boolean);\n    --  Free memory allocated for Project\n \n    procedure Free_List (Languages : in out Language_Ptr);\n    procedure Free_List (Source : in out Source_Id);\n-   procedure Free_List (List : in out Project_List);\n    procedure Free_List (Languages : in out Language_List);\n    --  Free memory allocated for the list of languages or sources\n \n@@ -396,7 +395,7 @@ package body Prj is\n \n    procedure Project_Changed (Iter : in out Source_Iterator) is\n    begin\n-      Iter.Language := Iter.In_Tree.Projects.Table (Iter.Project).Languages;\n+      Iter.Language := Iter.Project.Project.Languages;\n       Language_Changed (Iter);\n    end Project_Changed;\n \n@@ -420,16 +419,14 @@ package body Prj is\n \n       if Iter.Language = No_Language_Index then\n          if Iter.All_Projects then\n-            Iter.Project := Iter.Project + 1;\n+            Iter.Project := Iter.Project.Next;\n \n-            if Iter.Project > Project_Table.Last (Iter.In_Tree.Projects) then\n-               Iter.Project := No_Project;\n-            else\n+            if Iter.Project /= null then\n                Project_Changed (Iter);\n             end if;\n \n          else\n-            Iter.Project := No_Project;\n+            Iter.Project := null;\n          end if;\n \n       else\n@@ -455,14 +452,18 @@ package body Prj is\n    begin\n       Iter := Source_Iterator'\n         (In_Tree       => In_Tree,\n-         Project       => Project,\n+         Project       => In_Tree.Projects,\n          All_Projects  => Project = No_Project,\n          Language_Name => Language,\n          Language      => No_Language_Index,\n          Current       => No_Source);\n \n-      if Iter.Project = No_Project then\n-         Iter.Project  := Project_Table.First;\n+      if Project /= null then\n+         while Iter.Project /= null\n+           and then Iter.Project.Project /= Project\n+         loop\n+            Iter.Project := Iter.Project.Next;\n+         end loop;\n       end if;\n \n       Project_Changed (Iter);\n@@ -498,7 +499,6 @@ package body Prj is\n \n    procedure For_Every_Project_Imported\n      (By             : Project_Id;\n-      In_Tree        : Project_Tree_Ref;\n       With_State     : in out State;\n       Imported_First : Boolean := False)\n    is\n@@ -514,7 +514,6 @@ package body Prj is\n       ---------------------\n \n       procedure Recursive_Check (Project : Project_Id) is\n-         Data : Project_Data renames In_Tree.Projects.Table (Project);\n          List : Project_List;\n \n       begin\n@@ -527,13 +526,13 @@ package body Prj is\n \n             --  Visited all extended projects\n \n-            if Data.Extends /= No_Project then\n-               Recursive_Check (Data.Extends);\n+            if Project.Extends /= No_Project then\n+               Recursive_Check (Project.Extends);\n             end if;\n \n             --  Visited all imported projects\n \n-            List := Data.Imported_Projects;\n+            List := Project.Imported_Projects;\n             while List /= null loop\n                Recursive_Check (List.Project);\n                List := List.Next;\n@@ -585,7 +584,11 @@ package body Prj is\n \n    function Hash (Project : Project_Id) return Header_Num is\n    begin\n-      return Header_Num (Project mod Max_Header_Num);\n+      if Project = No_Project then\n+         return Header_Num'First;\n+      else\n+         return Hash (Get_Name_String (Project.Name));\n+      end if;\n    end Hash;\n \n    -----------\n@@ -645,13 +648,13 @@ package body Prj is\n    -------------------\n \n    function Is_A_Language\n-     (Data          : Project_Data;\n+     (Project       : Project_Id;\n       Language_Name : Name_Id) return Boolean\n    is\n       Lang_Ind : Language_Ptr;\n \n    begin\n-      Lang_Ind := Data.Languages;\n+      Lang_Ind := Project.Languages;\n       while Lang_Ind /= No_Language_Index loop\n          if Lang_Ind.Name = Language_Name then\n             return True;\n@@ -669,8 +672,7 @@ package body Prj is\n \n    function Is_Extending\n      (Extending : Project_Id;\n-      Extended  : Project_Id;\n-      In_Tree   : Project_Tree_Ref) return Boolean\n+      Extended  : Project_Id) return Boolean\n    is\n       Proj : Project_Id;\n \n@@ -681,7 +683,7 @@ package body Prj is\n             return True;\n          end if;\n \n-         Proj := In_Tree.Projects.Table (Proj).Extends;\n+         Proj := Proj.Extends;\n       end loop;\n \n       return False;\n@@ -823,18 +825,24 @@ package body Prj is\n    -- Free --\n    ----------\n \n-   procedure Free (Project : in out Project_Data; Reset_Only : Boolean) is\n+   procedure Free (Project : in out Project_Id; Reset_Only : Boolean) is\n+      procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n+        (Project_Data, Project_Id);\n    begin\n-      Free (Project.Include_Path);\n-      Free (Project.Ada_Include_Path);\n-      Free (Project.Objects_Path);\n-      Free (Project.Ada_Objects_Path);\n+      if Project /= null then\n+         Free (Project.Include_Path);\n+         Free (Project.Ada_Include_Path);\n+         Free (Project.Objects_Path);\n+         Free (Project.Ada_Objects_Path);\n \n-      Free_List (Project.Imported_Projects);\n-      Free_List (Project.All_Imported_Projects);\n+         Free_List (Project.Imported_Projects, Free_Project => False);\n+         Free_List (Project.All_Imported_Projects, Free_Project => False);\n \n-      if not Reset_Only then\n-         Free_List (Project.Languages);\n+         if not Reset_Only then\n+            Free_List (Project.Languages);\n+         end if;\n+\n+         Unchecked_Free (Project);\n       end if;\n    end Free;\n \n@@ -875,13 +883,21 @@ package body Prj is\n    -- Free_List --\n    ---------------\n \n-   procedure Free_List (List : in out Project_List) is\n+   procedure Free_List\n+     (List         : in out Project_List;\n+      Free_Project : Boolean;\n+      Reset_Only   : Boolean := True)\n+   is\n       procedure Unchecked_Free is new Ada.Unchecked_Deallocation\n         (Project_List_Element, Project_List);\n       Tmp : Project_List;\n    begin\n       while List /= null loop\n          Tmp := List.Next;\n+         if Free_Project then\n+            Free (List.Project, Reset_Only => Reset_Only);\n+         end if;\n+\n          Unchecked_Free (List);\n          List := Tmp;\n       end loop;\n@@ -925,13 +941,7 @@ package body Prj is\n          Source_Paths_Htable.Reset (Tree.Source_Paths_HT);\n          Unit_Sources_Htable.Reset (Tree.Unit_Sources_HT);\n \n-         for P in Project_Table.First ..\n-           Project_Table.Last (Tree.Projects)\n-         loop\n-            Free (Tree.Projects.Table (P), Reset_Only => False);\n-         end loop;\n-\n-         Project_Table.Free (Tree.Projects);\n+         Free_List (Tree.Projects, Free_Project => True, Reset_Only => False);\n \n          --  Private part\n \n@@ -966,15 +976,7 @@ package body Prj is\n       Source_Paths_Htable.Reset     (Tree.Source_Paths_HT);\n       Unit_Sources_Htable.Reset     (Tree.Unit_Sources_HT);\n \n-      if not Project_Table.\"=\" (Tree.Projects.Table, null) then\n-         for P in Project_Table.First ..\n-           Project_Table.Last (Tree.Projects)\n-         loop\n-            Free (Tree.Projects.Table (P), Reset_Only => True);\n-         end loop;\n-      end if;\n-\n-      Project_Table.Init            (Tree.Projects);\n+      Free_List (Tree.Projects, Free_Project => True, Reset_Only => True);\n \n       --  Private part table\n \n@@ -1235,7 +1237,7 @@ package body Prj is\n    -- Has_Ada_Sources --\n    ---------------------\n \n-   function Has_Ada_Sources (Data : Project_Data) return Boolean is\n+   function Has_Ada_Sources (Data : Project_Id) return Boolean is\n       Lang : Language_Ptr;\n \n    begin\n@@ -1254,7 +1256,7 @@ package body Prj is\n    -- Has_Foreign_Sources --\n    -------------------------\n \n-   function Has_Foreign_Sources (Data : Project_Data) return Boolean is\n+   function Has_Foreign_Sources (Data : Project_Id) return Boolean is\n       Lang : Language_Ptr;\n \n    begin\n@@ -1317,30 +1319,27 @@ package body Prj is\n    --------------------------\n \n    function Get_Object_Directory\n-     (In_Tree             : Project_Tree_Ref;\n-      Project             : Project_Id;\n+     (Project             : Project_Id;\n       Including_Libraries : Boolean;\n       Only_If_Ada         : Boolean := False) return Path_Name_Type\n    is\n-      Data : Project_Data renames In_Tree.Projects.Table (Project);\n-\n    begin\n-      if (Data.Library and Including_Libraries)\n+      if (Project.Library and Including_Libraries)\n         or else\n-          (Data.Object_Directory /= No_Path_Information\n-            and then (not Including_Libraries or else not Data.Library))\n+          (Project.Object_Directory /= No_Path_Information\n+            and then (not Including_Libraries or else not Project.Library))\n       then\n          --  For a library project, add the library ALI directory if there is\n          --  no object directory or if the library ALI directory contains ALI\n          --  files; otherwise add the object directory.\n \n-         if Data.Library then\n-            if Data.Object_Directory = No_Path_Information\n-              or else Contains_ALI_Files (Data.Library_ALI_Dir.Name)\n+         if Project.Library then\n+            if Project.Object_Directory = No_Path_Information\n+              or else Contains_ALI_Files (Project.Library_ALI_Dir.Name)\n             then\n-               return Data.Library_ALI_Dir.Name;\n+               return Project.Library_ALI_Dir.Name;\n             else\n-               return Data.Object_Directory.Name;\n+               return Project.Object_Directory.Name;\n             end if;\n \n             --  For a non-library project, add object directory if it is not a\n@@ -1349,7 +1348,7 @@ package body Prj is\n             --  adding the object directory could disrupt the order of the\n             --  object dirs in the path.\n \n-         elsif not Data.Virtual then\n+         elsif not Project.Virtual then\n             declare\n                Add_Object_Dir : Boolean;\n                Prj            : Project_Id;\n@@ -1358,15 +1357,15 @@ package body Prj is\n                Add_Object_Dir := not Only_If_Ada;\n                Prj := Project;\n                while not Add_Object_Dir and then Prj /= No_Project loop\n-                  if Has_Ada_Sources (In_Tree.Projects.Table (Prj)) then\n+                  if Has_Ada_Sources (Prj) then\n                      Add_Object_Dir := True;\n                   else\n-                     Prj := In_Tree.Projects.Table (Prj).Extends;\n+                     Prj := Prj.Extends;\n                   end if;\n                end loop;\n \n                if Add_Object_Dir then\n-                  return Data.Object_Directory.Name;\n+                  return Project.Object_Directory.Name;\n                end if;\n             end;\n          end if;\n@@ -1380,15 +1379,14 @@ package body Prj is\n    -----------------------------------\n \n    function Ultimate_Extending_Project_Of\n-     (Proj    : Project_Id;\n-      In_Tree : Project_Tree_Ref) return Project_Id\n+     (Proj : Project_Id) return Project_Id\n    is\n       Prj : Project_Id;\n \n    begin\n       Prj := Proj;\n-      while In_Tree.Projects.Table (Prj).Extended_By /= No_Project loop\n-         Prj := In_Tree.Projects.Table (Prj).Extended_By;\n+      while Prj.Extended_By /= No_Project loop\n+         Prj := Prj.Extended_By;\n       end loop;\n \n       return Prj;\n@@ -1398,11 +1396,7 @@ package body Prj is\n    -- Compute_All_Imported_Projects --\n    -----------------------------------\n \n-   procedure Compute_All_Imported_Projects\n-     (Project : Project_Id; In_Tree : Project_Tree_Ref)\n-   is\n-      Data : Project_Data renames In_Tree.Projects.Table (Project);\n-\n+   procedure Compute_All_Imported_Projects (Project : Project_Id) is\n       procedure Recursive_Add (Prj : Project_Id; Dummy : in out Boolean);\n       --  Recursively add the projects imported by project Project, but not\n       --  those that are extended.\n@@ -1420,13 +1414,13 @@ package body Prj is\n          --  A project is not importing itself\n \n          if Project /= Prj then\n-            Prj2 := Ultimate_Extending_Project_Of (Prj, In_Tree);\n+            Prj2 := Ultimate_Extending_Project_Of (Prj);\n \n             --  Check that the project is not already in the list. We know the\n             --  one passed to Recursive_Add have never been visited before, but\n             --  the one passed it are the extended projects.\n \n-            List := Data.All_Imported_Projects;\n+            List := Project.All_Imported_Projects;\n             while List /= null loop\n                if List.Project = Prj2 then\n                   return;\n@@ -1436,10 +1430,10 @@ package body Prj is\n \n             --  Add it to the list\n \n-            Data.All_Imported_Projects :=\n+            Project.All_Imported_Projects :=\n               new Project_List_Element'\n                 (Project => Prj2,\n-                 Next    => Data.All_Imported_Projects);\n+                 Next    => Project.All_Imported_Projects);\n          end if;\n       end Recursive_Add;\n \n@@ -1448,8 +1442,8 @@ package body Prj is\n       Dummy : Boolean := False;\n \n    begin\n-      Free_List (Data.All_Imported_Projects);\n-      For_All_Projects (Project, In_Tree, Dummy);\n+      Free_List (Project.All_Imported_Projects, Free_Project => False);\n+      For_All_Projects (Project, Dummy);\n    end Compute_All_Imported_Projects;\n \n begin"}, {"sha": "a0ccdbecd14d2a63bc050b5d8208332ecd0e9b90", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 22, "deletions": 27, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -160,8 +160,9 @@ package Prj is\n \n    No_Path_Information : constant Path_Information := (No_Path, No_Path);\n \n-   type Project_Id is new Nat;\n-   No_Project : constant Project_Id := 0;\n+   type Project_Data;\n+   type Project_Id is access Project_Data;\n+   No_Project : constant Project_Id := null;\n    --  Id of a Project File\n \n    type String_List_Id is new Nat;\n@@ -323,10 +324,8 @@ package Prj is\n    function Hash (Name : Name_Id)        return Header_Num;\n    function Hash (Name : File_Name_Type) return Header_Num;\n    function Hash (Name : Path_Name_Type) return Header_Num;\n-   --  Used for computing hash values for names put into above hash table\n-\n    function Hash (Project : Project_Id) return Header_Num;\n-   --  Used for hash tables where Project_Id is the Key\n+   --  Used for computing hash values for names put into above hash table\n \n    type Language_Kind is (File_Based, Unit_Based);\n    --  Type for the kind of language. All languages are file based, except Ada\n@@ -896,8 +895,7 @@ package Prj is\n       Suffix   : File_Name_Type);\n \n    function Get_Object_Directory\n-     (In_Tree             : Project_Tree_Ref;\n-      Project             : Project_Id;\n+     (Project             : Project_Id;\n       Including_Libraries : Boolean;\n       Only_If_Ada         : Boolean := False) return Path_Name_Type;\n    --  Return the object directory to use for the project. This depends on\n@@ -908,13 +906,12 @@ package Prj is\n    --  If Only_If_Ada is True, then No_Name will be returned when the project\n    --  doesn't Ada sources.\n \n-   procedure Compute_All_Imported_Projects\n-     (Project : Project_Id; In_Tree : Project_Tree_Ref);\n+   procedure Compute_All_Imported_Projects (Project : Project_Id);\n    --  Compute, the list of the projects imported directly or indirectly by\n    --  project Project. The result is stored in Project.All_Imported_Projects\n \n    function Ultimate_Extending_Project_Of\n-     (Proj : Project_Id; In_Tree : Project_Tree_Ref) return Project_Id;\n+     (Proj : Project_Id) return Project_Id;\n    --  Returns the ultimate extending project of project Proj. If project Proj\n    --  is not extended, returns Proj.\n \n@@ -938,6 +935,14 @@ package Prj is\n    end record;\n    --  A list of projects\n \n+   procedure Free_List\n+     (List         : in out Project_List;\n+      Free_Project : Boolean;\n+      Reset_Only   : Boolean := True);\n+   --  Free the list of projects. If Free_Project, each project is also freed.\n+   --  When Free_Project is True, Reset_Only indicates whether the specific\n+   --  languages should also be freed.\n+\n    type Response_File_Format is\n      (None,\n       GNU,\n@@ -1317,33 +1322,24 @@ package Prj is\n \n    function Is_Extending\n      (Extending : Project_Id;\n-      Extended  : Project_Id;\n-      In_Tree   : Project_Tree_Ref) return Boolean;\n-   --  ??? needs comment\n+      Extended  : Project_Id) return Boolean;\n+   --  Return True if Extending is extending the Extended project.\n \n    function Is_A_Language\n-     (Data          : Project_Data;\n+     (Project       : Project_Id;\n       Language_Name : Name_Id) return Boolean;\n    --  Return True when Language_Name (which must be lower case) is one of the\n    --  languages used for the project.\n \n-   function Has_Ada_Sources (Data : Project_Data) return Boolean;\n+   function Has_Ada_Sources (Data : Project_Id) return Boolean;\n    --  Return True if the project has Ada sources\n \n-   function Has_Foreign_Sources (Data : Project_Data) return Boolean;\n+   function Has_Foreign_Sources (Data : Project_Id) return Boolean;\n    --  Return True if the project has foreign sources\n \n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr\n \n-   package Project_Table is new GNAT.Dynamic_Tables (\n-     Table_Component_Type => Project_Data,\n-     Table_Index_Type     => Project_Id,\n-     Table_Low_Bound      => 1,\n-     Table_Initial        => 100,\n-     Table_Increment      => 100);\n-   --  The set of all project files\n-\n    type Spec_Or_Body is (Specification, Body_Part);\n \n    type File_Name_Data is record\n@@ -1427,7 +1423,7 @@ package Prj is\n          Array_Elements    : Array_Element_Table.Instance;\n          Arrays            : Array_Table.Instance;\n          Packages          : Package_Table.Instance;\n-         Projects          : Project_Table.Instance;\n+         Projects          : Project_List;\n          Units             : Unit_Table.Instance;\n          Units_HT          : Units_Htable.Instance;\n          Source_Paths_HT   : Source_Paths_Htable.Instance;\n@@ -1486,7 +1482,6 @@ package Prj is\n          With_State : in out State);\n    procedure For_Every_Project_Imported\n      (By             : Project_Id;\n-      In_Tree        : Project_Tree_Ref;\n       With_State     : in out State;\n       Imported_First : Boolean := False);\n    --  Call Action for each project imported directly or indirectly by project\n@@ -1560,7 +1555,7 @@ private\n    type Source_Iterator is record\n       In_Tree : Project_Tree_Ref;\n \n-      Project      : Project_Id;\n+      Project      : Project_List;\n       All_Projects : Boolean;\n       --  Current project and whether we should move on to the next\n "}, {"sha": "45c9370456a4141873c0017aab7ff55e927ee642", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -1396,7 +1396,7 @@ package body Rtsfind is\n \n    begin\n       --  Nothing to do if name is not an identifier or a selected component\n-      --  whose selector_name is not an identifier.\n+      --  whose selector_name is an identifier.\n \n       if Nkind (Nam) = N_Identifier then\n          Chrs := Chars (Nam);\n@@ -1448,8 +1448,40 @@ package body Rtsfind is\n                Load_RTU\n                  (To_Load,\n                   Use_Setting => In_Use (Cunit_Entity (U)));\n-               Set_Is_Visible_Child_Unit\n-                 (RT_Unit_Table (To_Load).Entity);\n+               Set_Is_Visible_Child_Unit (RT_Unit_Table (To_Load).Entity);\n+\n+               --  Prevent creation of an implicit 'with' from (for example)\n+               --  Ada.Wide_Text_IO.Integer_IO to Ada.Text_IO.Integer_IO,\n+               --  because these could create cycles. First check whether the\n+               --  simple names match (\"integer_io\" = \"integer_io\"), and then\n+               --  check whether the parent is indeed one of the\n+               --  [[Wide_]Wide_]Text_IO packages.\n+\n+               if Chrs = Chars (Cunit_Entity (Current_Sem_Unit)) then\n+                  declare\n+                     Parent_Name : constant Unit_Name_Type\n+                       := Get_Parent_Spec_Name (Unit_Name (Current_Sem_Unit));\n+                  begin\n+                     if Parent_Name /= No_Unit_Name then\n+                        Get_Name_String (Parent_Name);\n+\n+                        declare\n+                           P : String renames Name_Buffer (1 .. Name_Len);\n+                        begin\n+                           if P = \"ada.text_io%s\"\n+                             or else P = \"ada.wide_text_io%s\"\n+                             or else P = \"ada.wide_wide_text_io%s\"\n+                           then\n+                              goto Continue;\n+                           end if;\n+                        end;\n+                     end if;\n+                  end;\n+               end if;\n+\n+               --  Add an implicit with clause from the current unit to the\n+               --  [[Wide_]Wide_]Text_IO child (if necessary).\n+\n                Maybe_Add_With (RT_Unit_Table (To_Load));\n             end if;\n "}, {"sha": "084a7200a064fda6b50a4e650e508c8298ed9577", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -1618,9 +1618,12 @@ package body Sem is\n                   Write_Unit_Info (Unit_Num, Item, Withs => True);\n                end if;\n \n-               --  Main unit should come last\n+               --  Main unit should come last (except in the case where we\n+               --  skipped System_Aux_Id, in which case we missed the things it\n+               --  depends on).\n \n-               pragma Assert (not Done (Main_Unit));\n+               pragma Assert\n+                 (not Done (Main_Unit) or else Present (System_Aux_Id));\n \n                --  We shouldn't do the same thing twice\n "}, {"sha": "efd4ec4b3ecd9dac02b22518f893e3a7004000cd", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/66713d62863188a9c2f64388043c1dc0213d6f98/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=66713d62863188a9c2f64388043c1dc0213d6f98", "patch": "@@ -634,8 +634,8 @@ package body Sem_Ch12 is\n    --  loaded. In that case a missing body is acceptable.\n \n    procedure Inherit_Context (Gen_Decl : Node_Id; Inst : Node_Id);\n-   --  Add the context clause of the unit containing a generic unit to an\n-   --  instantiation that is a compilation unit.\n+   --  Add the context clause of the unit containing a generic unit to a\n+   --  compilation unit that is, or contains, an instantiation.\n \n    function Get_Associated_Node (N : Node_Id) return Node_Id;\n    --  In order to propagate semantic information back from the analyzed copy\n@@ -6935,9 +6935,19 @@ package body Sem_Ch12 is\n          Item := First (Context_Items (Parent (Gen_Decl)));\n          while Present (Item) loop\n             if Nkind (Item) = N_With_Clause then\n-               New_I := New_Copy (Item);\n-               Set_Implicit_With (New_I, True);\n-               Append (New_I, Current_Context);\n+\n+               --  Take care to prevent direct cyclic with's, which can happen\n+               --  if the generic body with's the current unit. Such a case\n+               --  would result in binder errors (or run-time errors if the\n+               --  -gnatE switch is in effect), but we want to prevent it here,\n+               --  because Sem.Walk_Library_Items doesn't like cycles. Note\n+               --  that we don't bother to detect indirect cycles.\n+\n+               if Library_Unit (Item) /= Current_Unit then\n+                  New_I := New_Copy (Item);\n+                  Set_Implicit_With (New_I, True);\n+                  Append (New_I, Current_Context);\n+               end if;\n             end if;\n \n             Next (Item);"}]}