{"sha": "1d24950977c730f5e955060057b1dd0b5c051adb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWQyNDk1MDk3N2M3MzBmNWU5NTUwNjAwNTdiMWRkMGI1YzA1MWFkYg==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-11-15T22:53:57Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2018-11-15T22:53:57Z"}, "message": "PR c++/87541 - ICE using a constant decl as an attribute alloc_size argument\n\nPR c++/87541 - ICE using a constant decl as an attribute alloc_size argument\nPR c++/87542 - bogus error on attribute format with a named constant argument\n\ngcc/ChangeLog:\n\n\tPR c++/87541\n\tPR c++/87542\n\t* tree.c (type_argument_type): New function.\n\t* tree.h (type_argument_type): Declare it.\n\t* gcc/doc/extend.texi (alloc_align): Update and clarify.\n\t(alloc_size, nonnull, sentinel): Same.\n\ngcc/c-family/ChangeLog:\n\n\tPR c++/87541\n\tPR c++/87542\n\t* c-attribs.c (positional_argument): New function.\n\t(handle_alloc_size_attribute): Use it and simplify.\n\t(handle_alloc_align_attribute): Same.\n\t(handle_assume_aligned_attribute): Same.\n\t(handle_nonnull_attribute): Same.\n\t* c-common.c (check_function_arguments): Pass fntype to\n\tcheck_function_format.\n\t* c-common.h (check_function_format): Add an argument.\n\t(PosArgFlags, positional_argument): Declare new type and function.\n\t* c-format.c (decode_format_attr): Add arguments.\n\t(check_format_string, get_constant): Same.\n\t(convert_format_name_to_system_name): Adjust.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/87541\n\tPR c++/87542\n\t* g++.dg/ext/attr-alloc_size.C: New test.\n\t* c-c++-common/pr71574.c: Adjust diagnostics.\n\t* c-c++-common/attributes-1.c: Same.\n\t* gcc.dg/attr-alloc_align-2.c: Same.\n\t* gcc.dg/attr-alloc_align-4.c: New test.\n\t* gcc.dg/attr-alloc_size-2.c: Adjust diagnostics.\n\t* gcc.dg/attr-alloc_size.c: Same.\n\t* gcc.dg/attr-assume_aligned-4.c: New test.\n\t* gcc.dg/format/attr-3.c: Adjust diagnostics.\n\t* gcc.dg/nonnull-2.c: Same.\n\t* gcc.dg/torture/pr80612.c: Same.\n\t* obj-c++.dg/attributes/method-format-1.mm: Same.\n\t* obj-c++.dg/attributes/method-nonnull-1.mm: Same.\n\t* objc.dg/attributes/method-format-1.m: same.\n\t* objc.dg/attributes/method-nonnull-1.m: Same.\n\nFrom-SVN: r266195", "tree": {"sha": "aecd56593f283b79ac0939bd57a5555c6b93239f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aecd56593f283b79ac0939bd57a5555c6b93239f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d24950977c730f5e955060057b1dd0b5c051adb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d24950977c730f5e955060057b1dd0b5c051adb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d24950977c730f5e955060057b1dd0b5c051adb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d24950977c730f5e955060057b1dd0b5c051adb/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cd5da9837b26d77136d3a9394747ce4325a95118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd5da9837b26d77136d3a9394747ce4325a95118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd5da9837b26d77136d3a9394747ce4325a95118"}], "stats": {"total": 939, "additions": 730, "deletions": 209}, "files": [{"sha": "04d2166e501c4f15150767404df0d786bbab335d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,3 +1,12 @@\n+2018-11-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/87541\n+\tPR c++/87542\n+\t* tree.c (type_argument_type): New function.\n+\t* tree.h (type_argument_type): Declare it.\n+\t* gcc/doc/extend.texi (alloc_align): Update and clarify.\n+\t(alloc_size, nonnull, sentinel): Same.\n+\n 2018-11-15  Andrew Stubbs  <ams@codesourcery.com>\n             Kwok Cheung Yeung  <kcy@codesourcery.com>\n "}, {"sha": "057009b9d42406793e24cd4aa96dd1410523c8db", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,3 +1,20 @@\n+2018-11-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/87541\n+\tPR c++/87542\n+\t* c-attribs.c (positional_argument): New function.\n+\t(handle_alloc_size_attribute): Use it and simplify.\n+\t(handle_alloc_align_attribute): Same.\n+\t(handle_assume_aligned_attribute): Same.\n+\t(handle_nonnull_attribute): Same.\n+\t* c-common.c (check_function_arguments): Pass fntype to\n+\tcheck_function_format.\n+\t* c-common.h (check_function_format): Add an argument.\n+\t(PosArgFlags, positional_argument): Declare new type and function.\n+\t* c-format.c (decode_format_attr): Add arguments.\n+\t(check_format_string, get_constant): Same.\n+\t(convert_format_name_to_system_name): Adjust.\n+\n 2018-11-15  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR other/19165"}, {"sha": "c9afa1f78f416c921161f9f0fc38fb6eb7c6c569", "filename": "gcc/c-family/c-attribs.c", "status": "modified", "additions": 280, "deletions": 80, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-attribs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-attribs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-attribs.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -44,6 +44,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-iterator.h\"\n #include \"opts.h\"\n #include \"gimplify.h\"\n+#include \"tree-pretty-print.h\"\n \n static tree handle_packed_attribute (tree *, tree, tree, int, bool *);\n static tree handle_nocommon_attribute (tree *, tree, tree, int, bool *);\n@@ -495,6 +496,188 @@ attribute_takes_identifier_p (const_tree attr_id)\n     return targetm.attribute_takes_identifier_p (attr_id);\n }\n \n+/* Verify that argument value POS at position ARGNO to attribute NAME\n+   applied to function TYPE refers to a function parameter at position\n+   POS and the expected type CODE.  If so, return POS after default\n+   conversions, if any.  Otherwise, issue appropriate warnings and\n+   return null.  A non-zero 1-based ARGNO should be passed ib by\n+   callers only for attributes with more than one argument.  */\n+\n+tree\n+positional_argument (const_tree fntype, const_tree atname, tree pos,\n+\t\t     tree_code code, int argno /* = 0 */,\n+\t\t     int flags /* = posargflags () */)\n+{\n+  if (pos && TREE_CODE (pos) != IDENTIFIER_NODE\n+      && TREE_CODE (pos) != FUNCTION_DECL)\n+    pos = default_conversion (pos);\n+\n+  tree postype = TREE_TYPE (pos);\n+  if (pos == error_mark_node || !postype)\n+    {\n+      /* Only mention the positional argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument is invalid\", atname);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i is invalid\", atname, argno);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (!INTEGRAL_TYPE_P (postype))\n+    {\n+      /* Handle this case specially to avoid mentioning the value\n+\t of pointer constants in diagnostics.  Only mention\n+\t the positional argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument has type %qT\",\n+\t\t atname, postype);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i has type %qT\",\n+\t\t atname, argno, postype);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (TREE_CODE (pos) != INTEGER_CST)\n+    {\n+      /* Only mention the argument number when it's non-zero.  */\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE is not an integer \"\n+\t\t \"constant\",\n+\t\t atname, pos);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE is not an integer \"\n+\t\t \"constant\",\n+\t\t atname, argno, pos);\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Argument positions are 1-based.  */\n+  if (integer_zerop (pos))\n+    {\n+      if (flags & POSARG_ZERO)\n+\t/* Zero is explicitly allowed.  */\n+\treturn pos;\n+\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE does not refer to \"\n+\t\t \"a function parameter\",\n+\t\t atname, pos);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE does not refer to \"\n+\t\t \"a function parameter\",\n+\t\t atname, argno, pos);\n+\n+      return NULL_TREE;\n+    }\n+\n+  if (!prototype_p (fntype))\n+    return pos;\n+\n+  /* Verify that the argument position does not exceed the number\n+     of formal arguments to the function.  When POSARG_ELLIPSIS\n+     is set, ARGNO may be beyond the last argument of a vararg\n+     function.  */\n+  unsigned nargs = type_num_arguments (fntype);\n+  if (!nargs\n+      || !tree_fits_uhwi_p (pos)\n+      || ((flags & POSARG_ELLIPSIS) == 0\n+\t  && !IN_RANGE (tree_to_uhwi (pos), 1, nargs)))\n+    {\n+\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE exceeds the number \"\n+\t\t \"of function parameters %u\",\n+\t\t atname, pos, nargs);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE exceeds the number \"\n+\t\t \"of function parameters %u\",\n+\t\t atname, argno, pos, nargs);\n+      return NULL_TREE;\n+    }\n+\n+  /* Verify that the type of the referenced formal argument matches\n+     the expected type.  */\n+  unsigned HOST_WIDE_INT ipos = tree_to_uhwi (pos);\n+\n+  /* Zero was handled above.  */\n+  gcc_assert (ipos != 0);\n+\n+  if (tree argtype = type_argument_type (fntype, ipos))\n+    {\n+      if (flags & POSARG_ELLIPSIS)\n+\t{\n+\t  if (argno < 1)\n+\t    error (\"%qE attribute argument value %qE does not refer to \"\n+\t\t   \"a variable argument list\",\n+\t\t   atname, pos);\n+\t  else\n+\t    error (\"%qE attribute argument %i value %qE does not refer to \"\n+\t\t   \"a variable argument list\",\n+\t\t   atname, argno, pos);\n+\t  return NULL_TREE;\n+\t}\n+\n+      /* Where the expected code is STRING_CST accept any pointer\n+\t to a narrow character type, qualified or otherwise.  */\n+      bool type_match;\n+      if (code == STRING_CST && POINTER_TYPE_P (argtype))\n+\t{\n+\t  tree type = TREE_TYPE (argtype);\n+\t  type = TYPE_MAIN_VARIANT (type);\n+\t  type_match = (type == char_type_node\n+\t\t\t|| type == signed_char_type_node\n+\t\t\t|| type == unsigned_char_type_node);\n+\t}\n+      else\n+\ttype_match = TREE_CODE (argtype) == code;\n+\n+      if (!type_match)\n+\t{\n+\t  if (argno < 1)\n+\t    warning (OPT_Wattributes,\n+\t\t     \"%qE attribute argument value %qE refers to \"\n+\t\t     \"parameter type %qT\",\n+\t\t     atname, pos, argtype);\n+\t  else\n+\t    warning (OPT_Wattributes,\n+\t\t   \"%qE attribute argument %i value %qE refers to \"\n+\t\t     \"parameter type %qT\",\n+\t\t     atname, argno, pos, argtype);\n+\t  return NULL_TREE;\n+\t}\n+    }\n+  else if (!(flags & POSARG_ELLIPSIS))\n+    {\n+      if (argno < 1)\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument value %qE refers to \"\n+\t\t \"a variadic function parameter of unknown type\",\n+\t\t atname, pos);\n+      else\n+\twarning (OPT_Wattributes,\n+\t\t \"%qE attribute argument %i value %qE refers to \"\n+\t\t \"a variadic function parameter of unknown type\",\n+\t\t atname, argno, pos);\n+      return NULL_TREE;\n+    }\n+\n+  return pos;\n+}\n+\n+\n /* Attribute handlers common to C front ends.  */\n \n /* Handle a \"packed\" attribute; arguments as in\n@@ -2563,73 +2746,125 @@ handle_malloc_attribute (tree *node, tree name, tree ARG_UNUSED (args),\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_alloc_size_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+handle_alloc_size_attribute (tree *node, tree name, tree args,\n \t\t\t     int ARG_UNUSED (flags), bool *no_add_attrs)\n {\n-  unsigned arg_count = type_num_arguments (*node);\n-  for (; args; args = TREE_CHAIN (args))\n+  tree decl = *node;\n+  tree rettype = TREE_TYPE (decl);\n+  if (!POINTER_TYPE_P (rettype))\n     {\n-      tree position = TREE_VALUE (args);\n-      if (position && TREE_CODE (position) != IDENTIFIER_NODE\n-\t  && TREE_CODE (position) != FUNCTION_DECL)\n-\tposition = default_conversion (position);\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute ignored on a function returning %qT\",\n+\t       name, rettype);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n \n-      if (!tree_fits_uhwi_p (position)\n-\t  || !arg_count\n-\t  || !IN_RANGE (tree_to_uhwi (position), 1, arg_count))\n+  for (int i = 1; args; ++i)\n+    {\n+      tree pos = TREE_VALUE (args);\n+      /* NEXT is null when the attribute includes just one argument.\n+\t That's used to tell positional_argument to avoid mentioning\n+\t the argument number in diagnostics (since there's just one\n+\t mentioning it is unnecessary and coule be confusing).  */\n+      tree next = TREE_CHAIN (args);\n+      if (tree val = positional_argument (decl, name, pos, INTEGER_TYPE,\n+\t\t\t\t\t  next || i > 1 ? i : 0))\n+\tTREE_VALUE (args) = val;\n+      else\n \t{\n-\t  warning (OPT_Wattributes,\n-\t           \"alloc_size parameter outside range\");\n \t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n+\t  break;\n \t}\n+\n+      args = next;\n     }\n+\n   return NULL_TREE;\n }\n \n /* Handle a \"alloc_align\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_alloc_align_attribute (tree *node, tree, tree args, int,\n+handle_alloc_align_attribute (tree *node, tree name, tree args, int,\n \t\t\t      bool *no_add_attrs)\n {\n-  unsigned arg_count = type_num_arguments (*node);\n-  tree position = TREE_VALUE (args);\n-  if (position && TREE_CODE (position) != IDENTIFIER_NODE\n-      && TREE_CODE (position) != FUNCTION_DECL)\n-    position = default_conversion (position);\n-\n-  if (!tree_fits_uhwi_p (position)\n-      || !arg_count\n-      || !IN_RANGE (tree_to_uhwi (position), 1, arg_count))\n+  tree decl = *node;\n+  tree rettype = TREE_TYPE (decl);\n+  if (!POINTER_TYPE_P (rettype))\n     {\n       warning (OPT_Wattributes,\n-\t       \"alloc_align parameter outside range\");\n+\t       \"%qE attribute ignored on a function returning %qT\",\n+\t       name, rettype);\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n+\n+  if (!positional_argument (*node, name, TREE_VALUE (args), INTEGER_TYPE))\n+    *no_add_attrs = true;\n+\n   return NULL_TREE;\n }\n \n /* Handle a \"assume_aligned\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n \n static tree\n-handle_assume_aligned_attribute (tree *, tree, tree args, int,\n+handle_assume_aligned_attribute (tree *node, tree name, tree args, int,\n \t\t\t\t bool *no_add_attrs)\n {\n+  tree decl = *node;\n+  tree rettype = TREE_TYPE (decl);\n+  if (TREE_CODE (rettype) != POINTER_TYPE)\n+    {\n+      warning (OPT_Wattributes,\n+\t       \"%qE attribute ignored on a function returning %qT\",\n+\t       name, rettype);\n+      *no_add_attrs = true;\n+      return NULL_TREE;\n+    }\n+\n+  /* The alignment specified by the first argument.  */\n+  tree align = NULL_TREE;\n+\n   for (; args; args = TREE_CHAIN (args))\n     {\n-      tree position = TREE_VALUE (args);\n-      if (position && TREE_CODE (position) != IDENTIFIER_NODE\n-\t  && TREE_CODE (position) != FUNCTION_DECL)\n-\tposition = default_conversion (position);\n+      tree val = TREE_VALUE (args);\n+      if (val && TREE_CODE (val) != IDENTIFIER_NODE\n+\t  && TREE_CODE (val) != FUNCTION_DECL)\n+\tval = default_conversion (val);\n \n-      if (TREE_CODE (position) != INTEGER_CST)\n+      if (!tree_fits_shwi_p (val))\n \t{\n \t  warning (OPT_Wattributes,\n-\t\t   \"assume_aligned parameter not integer constant\");\n+\t\t   \"%qE attribute %E is not an integer constant\",\n+\t\t   name, val);\n+\t  *no_add_attrs = true;\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (!align)\n+\t{\n+\t  /* Validate and save the alignment.  */\n+\t  if (!integer_pow2p (val))\n+\t    {\n+\t      warning (OPT_Wattributes,\n+\t\t       \"%qE attribute argument %E is not a power of 2\",\n+\t\t       name, val);\n+\t      *no_add_attrs = true;\n+\t      return NULL_TREE;\n+\t    }\n+\n+\t  align = val;\n+\t}\n+      else if (tree_int_cst_sgn (val) < 0 || tree_int_cst_le (align, val))\n+\t{\n+\t  /* The misalignment specified by the second argument\n+\t     must be non-negative and less than the alignment.  */\n+\t  warning (OPT_Wattributes,\n+\t\t   \"%qE attribute argument %E is not in the range [0, %E)\",\n+\t\t   name, val, align);\n \t  *no_add_attrs = true;\n \t  return NULL_TREE;\n \t}\n@@ -3262,12 +3497,11 @@ handle_vector_size_attribute (tree *node, tree name, tree args,\n /* Handle the \"nonnull\" attribute.  */\n \n static tree\n-handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n+handle_nonnull_attribute (tree *node, tree name,\n \t\t\t  tree args, int ARG_UNUSED (flags),\n \t\t\t  bool *no_add_attrs)\n {\n   tree type = *node;\n-  unsigned HOST_WIDE_INT attr_arg_num;\n \n   /* If no arguments are specified, all pointer arguments should be\n      non-null.  Verify a full prototype is given so that the arguments\n@@ -3286,57 +3520,23 @@ handle_nonnull_attribute (tree *node, tree ARG_UNUSED (name),\n       return NULL_TREE;\n     }\n \n-  /* Argument list specified.  Verify that each argument number references\n-     a pointer argument.  */\n-  for (attr_arg_num = 1; args; attr_arg_num++, args = TREE_CHAIN (args))\n+  for (int i = 1; args; ++i)\n     {\n-      unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n-\n-      tree arg = TREE_VALUE (args);\n-      if (arg && TREE_CODE (arg) != IDENTIFIER_NODE\n-\t  && TREE_CODE (arg) != FUNCTION_DECL)\n-\tTREE_VALUE (args) = arg = default_conversion (arg);\n-\n-      if (!get_nonnull_operand (arg, &arg_num))\n+      tree pos = TREE_VALUE (args);\n+      /* NEXT is null when the attribute includes just one argument.\n+\t That's used to tell positional_argument to avoid mentioning\n+\t the argument number in diagnostics (since there's just one\n+\t mentioning it is unnecessary and coule be confusing).  */\n+      tree next = TREE_CHAIN (args);\n+      if (tree val = positional_argument (type, name, pos, POINTER_TYPE,\n+\t\t\t\t\t  next || i > 1 ? i : 0))\n+\tTREE_VALUE (args) = val;\n+      else\n \t{\n-\t  error (\"nonnull argument has invalid operand number (argument %lu)\",\n-\t\t (unsigned long) attr_arg_num);\n \t  *no_add_attrs = true;\n-\t  return NULL_TREE;\n-\t}\n-\n-      if (prototype_p (type))\n-\t{\n-\t  function_args_iterator iter;\n-\t  tree argument;\n-\n-\t  function_args_iter_init (&iter, type);\n-\t  for (ck_num = 1; ; ck_num++, function_args_iter_next (&iter))\n-\t    {\n-\t      argument = function_args_iter_cond (&iter);\n-\t      if (argument == NULL_TREE || ck_num == arg_num)\n-\t\tbreak;\n-\t    }\n-\n-\t  if (!argument\n-\t      || TREE_CODE (argument) == VOID_TYPE)\n-\t    {\n-\t      error (\"nonnull argument with out-of-range operand number \"\n-\t\t     \"(argument %lu, operand %lu)\",\n-\t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n-\t      *no_add_attrs = true;\n-\t      return NULL_TREE;\n-\t    }\n-\n-\t  if (TREE_CODE (argument) != POINTER_TYPE)\n-\t    {\n-\t      error (\"nonnull argument references non-pointer operand \"\n-\t\t     \"(argument %lu, operand %lu)\",\n-\t\t     (unsigned long) attr_arg_num, (unsigned long) arg_num);\n-\t      *no_add_attrs = true;\n-\t      return NULL_TREE;\n-\t    }\n+\t  break;\n \t}\n+      args = next;\n     }\n \n   return NULL_TREE;"}, {"sha": "69be3d3b2a0d002277be9426a7ae6c9be2631b55", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -5658,7 +5658,8 @@ check_function_arguments (location_t loc, const_tree fndecl, const_tree fntype,\n   /* Check for errors in format strings.  */\n \n   if (warn_format || warn_suggest_attribute_format)\n-    check_function_format (TYPE_ATTRIBUTES (fntype), nargs, argarray, arglocs);\n+    check_function_format (fntype, TYPE_ATTRIBUTES (fntype), nargs, argarray,\n+\t\t\t   arglocs);\n \n   if (warn_format)\n     check_function_sentinel (fntype, nargs, argarray);"}, {"sha": "8eeeba7531921f3dd19dff565989532b32120445", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -808,7 +808,8 @@ extern void check_function_arguments_recurse (void (*)\n \t\t\t\t\t      unsigned HOST_WIDE_INT);\n extern bool check_builtin_function_arguments (location_t, vec<location_t>,\n \t\t\t\t\t      tree, int, tree *);\n-extern void check_function_format (tree, int, tree *, vec<location_t> *);\n+extern void check_function_format (const_tree, tree, int, tree *,\n+\t\t\t\t   vec<location_t> *);\n extern bool attribute_fallthrough_p (tree);\n extern tree handle_format_attribute (tree *, tree, tree, int, bool *);\n extern tree handle_format_arg_attribute (tree *, tree, tree, int, bool *);\n@@ -1330,6 +1331,18 @@ extern int tm_attr_to_mask (tree);\n extern tree tm_mask_to_attr (int);\n extern tree find_tm_attribute (tree);\n \n+/* A bitmap of flags to positional_argument.  */\n+enum posargflags {\n+  /* Consider positional attribute argument value zero valid.  */\n+  POSARG_ZERO = 1,\n+  /* Consider positional attribute argument value valid if it refers\n+     to the ellipsis (i.e., beyond the last typed argument).  */\n+  POSARG_ELLIPSIS = 2\n+};\n+\n+extern tree positional_argument (const_tree, const_tree, tree, tree_code,\n+\t\t\t\t int = 0, int = posargflags ());\n+\n extern enum flt_eval_method\n excess_precision_mode_join (enum flt_eval_method, enum flt_eval_method);\n "}, {"sha": "8b17f5399744163e5fe116236814e86e234ee26c", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 50, "deletions": 38, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -63,15 +63,17 @@ static GTY(()) tree local_gimple_ptr_node;\n static GTY(()) tree local_cgraph_node_ptr_node;\n static GTY(()) tree locus;\n \n-static bool decode_format_attr (tree, function_format_info *, int);\n+static bool decode_format_attr (const_tree, tree, tree, function_format_info *,\n+\t\t\t\tbool);\n static int decode_format_type (const char *);\n \n-static bool check_format_string (tree argument,\n+static bool check_format_string (const_tree argument,\n \t\t\t\t unsigned HOST_WIDE_INT format_num,\n \t\t\t\t int flags, bool *no_add_attrs,\n \t\t\t\t int expected_format_type);\n-static bool get_constant (tree expr, unsigned HOST_WIDE_INT *value,\n-\t\t\t  int validated_p);\n+static tree get_constant (const_tree fntype, const_tree atname, tree expr,\n+\t\t\t  int argno, unsigned HOST_WIDE_INT *value,\n+\t\t\t  int flags, bool validated_p);\n static const char *convert_format_name_to_system_name (const char *attr_name);\n \n static int first_target_format_type;\n@@ -133,16 +135,19 @@ valid_stringptr_type_p (tree strref)\n /* Handle a \"format_arg\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n-handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n+handle_format_arg_attribute (tree *node, tree atname,\n \t\t\t     tree args, int flags, bool *no_add_attrs)\n {\n   tree type = *node;\n-  tree format_num_expr = TREE_VALUE (args);\n+  /* Note that TREE_VALUE (args) is changed in place below.  */\n+  tree *format_num_expr = &TREE_VALUE (args);\n   unsigned HOST_WIDE_INT format_num = 0;\n \n-  if (!get_constant (format_num_expr, &format_num, 0))\n+  if (tree val = get_constant (type, atname, *format_num_expr, 0, &format_num,\n+\t\t\t       0, false))\n+    *format_num_expr = val;\n+  else\n     {\n-      error (\"format string has invalid operand number\");\n       *no_add_attrs = true;\n       return NULL_TREE;\n     }\n@@ -171,7 +176,7 @@ handle_format_arg_attribute (tree *node, tree ARG_UNUSED (name),\n    error).  When we know the specific reference type expected, this is also \n    checked.  */\n static bool\n-check_format_string (tree fntype, unsigned HOST_WIDE_INT format_num,\n+check_format_string (const_tree fntype, unsigned HOST_WIDE_INT format_num,\n \t\t     int flags, bool *no_add_attrs, int expected_format_type)\n {\n   unsigned HOST_WIDE_INT i;\n@@ -264,19 +269,20 @@ check_format_string (tree fntype, unsigned HOST_WIDE_INT format_num,\n \n /* Verify EXPR is a constant, and store its value.\n    If validated_p is true there should be no errors.\n-   Returns true on success, false otherwise.  */\n-static bool\n-get_constant (tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n+   Returns the converted constant value on success, null otherwise.  */\n+static tree\n+get_constant (const_tree fntype, const_tree atname, tree expr, int argno,\n+\t      unsigned HOST_WIDE_INT *value, int flags, bool validated_p)\n {\n-  if (!tree_fits_uhwi_p (expr))\n+  if (tree val = positional_argument (fntype, atname, expr, STRING_CST,\n+\t\t\t\t      argno, flags))\n     {\n-      gcc_assert (!validated_p);\n-      return false;\n+      *value = TREE_INT_CST_LOW (val);\n+      return val;\n     }\n \n-  *value = TREE_INT_CST_LOW (expr);\n-\n-  return true;\n+  gcc_assert (!validated_p);\n+  return NULL_TREE;\n }\n \n /* Decode the arguments to a \"format\" attribute into a\n@@ -287,12 +293,14 @@ get_constant (tree expr, unsigned HOST_WIDE_INT *value, int validated_p)\n    attributes are successfully decoded, false otherwise.  */\n \n static bool\n-decode_format_attr (tree args, function_format_info *info, int validated_p)\n+decode_format_attr (const_tree fntype, tree atname, tree args,\n+\t\t    function_format_info *info, bool validated_p)\n {\n   tree format_type_id = TREE_VALUE (args);\n-  tree format_num_expr = TREE_VALUE (TREE_CHAIN (args));\n-  tree first_arg_num_expr\n-    = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n+  /* Note that TREE_VALUE (args) is changed in place below.  Ditto\n+     for the value of the next element on the list.  */\n+  tree *format_num_expr = &TREE_VALUE (TREE_CHAIN (args));\n+  tree *first_arg_num_expr = &TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n \n   if (TREE_CODE (format_type_id) != IDENTIFIER_NODE)\n     {\n@@ -327,17 +335,18 @@ decode_format_attr (tree args, function_format_info *info, int validated_p)\n \t}\n     }\n \n-  if (!get_constant (format_num_expr, &info->format_num, validated_p))\n-    {\n-      error (\"format string has invalid operand number\");\n-      return false;\n-    }\n+  if (tree val = get_constant (fntype, atname, *format_num_expr,\n+\t\t\t       2, &info->format_num, 0, validated_p))\n+    *format_num_expr = val;\n+  else\n+    return false;\n \n-  if (!get_constant (first_arg_num_expr, &info->first_arg_num, validated_p))\n-    {\n-      error (\"%<...%> has invalid operand number\");\n-      return false;\n-    }\n+  if (tree val = get_constant (fntype, atname, *first_arg_num_expr,\n+\t\t\t       3, &info->first_arg_num,\n+\t\t\t       (POSARG_ZERO | POSARG_ELLIPSIS), validated_p))\n+    *first_arg_num_expr = val;\n+  else\n+    return false;\n \n   if (info->first_arg_num != 0 && info->first_arg_num <= info->format_num)\n     {\n@@ -1083,19 +1092,22 @@ decode_format_type (const char *s)\n    attribute themselves.  */\n \n void\n-check_function_format (tree attrs, int nargs, tree *argarray,\n-\t\t       vec<location_t> *arglocs)\n+check_function_format (const_tree fntype, tree attrs, int nargs,\n+\t\t       tree *argarray, vec<location_t> *arglocs)\n {\n   tree a;\n \n+  tree atname = get_identifier (\"format\");\n+\n   /* See if this function has any format attributes.  */\n   for (a = attrs; a; a = TREE_CHAIN (a))\n     {\n       if (is_attribute_p (\"format\", TREE_PURPOSE (a)))\n \t{\n \t  /* Yup; check it.  */\n \t  function_format_info info;\n-\t  decode_format_attr (TREE_VALUE (a), &info, /*validated=*/true);\n+\t  decode_format_attr (fntype, atname, TREE_VALUE (a), &info,\n+\t\t\t      /*validated=*/true);\n \t  if (warn_format)\n \t    {\n \t      /* FIXME: Rewrite all the internal functions in this file\n@@ -4124,10 +4136,10 @@ convert_format_name_to_system_name (const char *attr_name)\n /* Handle a \"format\" attribute; arguments as in\n    struct attribute_spec.handler.  */\n tree\n-handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n+handle_format_attribute (tree *node, tree atname, tree args,\n \t\t\t int flags, bool *no_add_attrs)\n {\n-  tree type = *node;\n+  const_tree type = *node;\n   function_format_info info;\n \n #ifdef TARGET_FORMAT_TYPES\n@@ -4153,7 +4165,7 @@ handle_format_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n   if (TREE_CODE (TREE_VALUE (args)) == IDENTIFIER_NODE)\n     TREE_VALUE (args) = canonicalize_attr_name (TREE_VALUE (args));\n \n-  if (!decode_format_attr (args, &info, 0))\n+  if (!decode_format_attr (type, atname, args, &info, /* validated_p = */false))\n     {\n       *no_add_attrs = true;\n       return NULL_TREE;"}, {"sha": "d0146baa06f097789993834302ca21965442d4e8", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 46, "deletions": 34, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -2406,33 +2406,39 @@ further information.\n The @code{aligned} attribute can also be used for variables and fields\n (@pxref{Variable Attributes}.)\n \n-@item alloc_align\n+@item alloc_align (@var{position})\n @cindex @code{alloc_align} function attribute\n-The @code{alloc_align} attribute is used to tell the compiler that the\n-function return value points to memory, where the returned pointer minimum\n-alignment is given by one of the functions parameters.  GCC uses this\n-information to improve pointer alignment analysis.\n+The @code{alloc_align} attribute may be applied to a function that\n+returns a pointer and takes at least one argument of an integer type.\n+It indicates that the returned pointer is aligned on a boundary given\n+by the function argument at @var{position}.  Meaningful alignments are\n+powers of 2 greater than one.  GCC uses this information to improve\n+pointer alignment analysis.\n \n The function parameter denoting the allocated alignment is specified by\n-one integer argument, whose number is the argument of the attribute.\n+one constant integer argument whose number is the argument of the attribute.\n Argument numbering starts at one.\n \n For instance,\n \n @smallexample\n-void* my_memalign(size_t, size_t) __attribute__((alloc_align(1)))\n+void* my_memalign (size_t, size_t) __attribute__ ((alloc_align (1)));\n @end smallexample\n \n @noindent\n declares that @code{my_memalign} returns memory with minimum alignment\n given by parameter 1.\n \n-@item alloc_size\n+@item alloc_size (@var{position})\n+@itemx alloc_size (@var{position-1}, @var{position-2})\n @cindex @code{alloc_size} function attribute\n-The @code{alloc_size} attribute is used to tell the compiler that the\n-function return value points to memory, where the size is given by\n-one or two of the functions parameters.  GCC uses this\n-information to improve the correctness of @code{__builtin_object_size}.\n+The @code{alloc_size} attribute may be applied to a function that\n+returns a pointer and takes at least one argument of an integer type.\n+It indicates that the returned pointer points to memory whose size is\n+given by the function argument at @var{position-1}, or by the product\n+of the arguments at @var{position-1} and @var{position-2}.  Meaningful\n+sizes are positive values less than @code{PTRDIFF_MAX}.  GCC uses this\n+information to improve the results of @code{__builtin_object_size}.\n \n The function parameter(s) denoting the allocated size are specified by\n one or two integer arguments supplied to the attribute.  The allocated size\n@@ -2443,8 +2449,8 @@ one.\n For instance,\n \n @smallexample\n-void* my_calloc(size_t, size_t) __attribute__((alloc_size(1,2)))\n-void* my_realloc(void*, size_t) __attribute__((alloc_size(2)))\n+void* my_calloc (size_t, size_t) __attribute__ ((alloc_size (1, 2)));\n+void* my_realloc (void*, size_t) __attribute__ ((alloc_size (2)));\n @end smallexample\n \n @noindent\n@@ -2470,22 +2476,25 @@ info format it either means marking the function as artificial\n or using the caller location for all instructions within the inlined\n body.\n \n-@item assume_aligned\n+@item assume_aligned (@var{alignment})\n+@itemx assume_aligned (@var{alignment}, @var{offset})\n @cindex @code{assume_aligned} function attribute\n-The @code{assume_aligned} attribute is used to tell the compiler that the\n-function return value points to memory, where the returned pointer minimum\n-alignment is given by the first argument.\n-If the attribute has two arguments, the second argument is misalignment offset.\n+The @code{assume_aligned} attribute may be applied to a function that\n+returns a pointer.  It indicates that the returned pointer is aligned\n+on a boundary given by @var{alignment}.  If the attribute has two\n+arguments, the second argument is misalignment @var{offset}.  Meaningful\n+values of @var{alignment} are powers of 2 greater than one.  Meaningful\n+values of @var{offset} are greater than zero and less than @var{alignment}.\n \n For instance\n \n @smallexample\n-void* my_alloc1(size_t) __attribute__((assume_aligned(16)))\n-void* my_alloc2(size_t) __attribute__((assume_aligned(32, 8)))\n+void* my_alloc1 (size_t) __attribute__((assume_aligned (16)));\n+void* my_alloc2 (size_t) __attribute__((assume_aligned (32, 8)));\n @end smallexample\n \n @noindent\n-declares that @code{my_alloc1} returns 16-byte aligned pointer and\n+declares that @code{my_alloc1} returns 16-byte aligned pointers and\n that @code{my_alloc2} returns a pointer whose value modulo 32 is equal\n to 8.\n \n@@ -3118,8 +3127,9 @@ of testing the compiler.\n @itemx nonnull (@var{arg-index}, @dots{})\n @cindex @code{nonnull} function attribute\n @cindex functions with non-null pointer arguments\n-The @code{nonnull} attribute specifies that some function parameters should\n-be non-null pointers.  For instance, the declaration:\n+The @code{nonnull} attribute may be applied to a function that takes at\n+least one argument of a pointer type.  It indicates that the referenced\n+arguments must be non-null pointers.  For instance, the declaration:\n \n @smallexample\n extern void *\n@@ -3354,13 +3364,14 @@ If you need to map the entire contents of a module to a particular\n section, consider using the facilities of the linker instead.\n \n @item sentinel\n+@itemx sentinel (@var{position})\n @cindex @code{sentinel} function attribute\n-This function attribute ensures that a parameter in a function call is\n-an explicit @code{NULL}.  The attribute is only valid on variadic\n-functions.  By default, the sentinel is located at position zero, the\n-last parameter of the function call.  If an optional integer position\n-argument P is supplied to the attribute, the sentinel must be located at\n-position P counting backwards from the end of the argument list.\n+This function attribute indicates that an argument in a call to the function\n+is expected to be an explicit @code{NULL}.  The attribute is only valid on\n+variadic functions.  By default, the sentinel is expected to be the last\n+argument of the function call.  If the optional @var{position} argument\n+is specified to the attribute, the sentinel must be located at\n+@var{position} counting backwards from the end of the argument list.\n \n @smallexample\n __attribute__ ((sentinel))\n@@ -3372,10 +3383,11 @@ The attribute is automatically set with a position of 0 for the built-in\n functions @code{execl} and @code{execlp}.  The built-in function\n @code{execle} has the attribute set with a position of 1.\n \n-A valid @code{NULL} in this context is defined as zero with any pointer\n-type.  If your system defines the @code{NULL} macro with an integer type\n-then you need to add an explicit cast.  GCC replaces @code{stddef.h}\n-with a copy that redefines NULL appropriately.\n+A valid @code{NULL} in this context is defined as zero with any object\n+pointer type.  If your system defines the @code{NULL} macro with\n+an integer type then you need to add an explicit cast.  During\n+installation GCC replaces the system @code{<stddef.h>} header with\n+a copy that redefines NULL appropriately.\n \n The warnings for missing or incorrect sentinels are enabled with\n @option{-Wformat}."}, {"sha": "a31b59d2cc9a42ba35ff0aefe0e1785aef614440", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,3 +1,23 @@\n+2018-11-15  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR c++/87541\n+\tPR c++/87542\n+\t* g++.dg/ext/attr-alloc_size.C: New test.\n+\t* c-c++-common/pr71574.c: Adjust diagnostics.\n+\t* c-c++-common/attributes-1.c: Same.\n+\t* gcc.dg/attr-alloc_align-2.c: Same.\n+\t* gcc.dg/attr-alloc_align-4.c: New test.\n+\t* gcc.dg/attr-alloc_size-2.c: Adjust diagnostics.\n+\t* gcc.dg/attr-alloc_size.c: Same.\n+\t* gcc.dg/attr-assume_aligned-4.c: New test.\n+\t* gcc.dg/format/attr-3.c: Adjust diagnostics.\n+\t* gcc.dg/nonnull-2.c: Same.\n+\t* gcc.dg/torture/pr80612.c: Same.\n+\t* obj-c++.dg/attributes/method-format-1.mm: Same.\n+\t* obj-c++.dg/attributes/method-nonnull-1.mm: Same.\n+\t* objc.dg/attributes/method-format-1.m: same.\n+\t* objc.dg/attributes/method-nonnull-1.m: Same.\n+\n 2018-11-15  Martin Sebor  <msebor@redhat.com>\n \n \tPR c/83656"}, {"sha": "c4b232dad002aef244bbb5a0542627b6c5657a39", "filename": "gcc/testsuite/c-c++-common/attributes-1.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fattributes-1.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,21 +1,22 @@\n /* { dg-do compile } */\n /* { dg-prune-output \"undeclared here \\\\(not in a function\\\\)|\\[^\\n\\r\\]* was not declared in this scope\" } */\n \n-void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,bar))); /* { dg-warning \"outside range\" } */\n-void* my_realloc(void*, unsigned) __attribute__((alloc_size(bar))); /* { dg-warning \"outside range\" } */\n+void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,bar))); /* { dg-warning \".alloc_size. attribute argument 2 is invalid\" } */\n+void* my_realloc(void*, unsigned) __attribute__((alloc_size(bar))); /* { dg-warning \".alloc_size. attribute argument is invalid\" } */\n \n typedef char vec __attribute__((vector_size(bar))); /* { dg-warning \"ignored\" } */\n \n-void f1(char*) __attribute__((nonnull(bar))); /* { dg-error \"invalid operand\" } */\n-void f2(char*) __attribute__((nonnull(1,bar))); /* { dg-error \"invalid operand\" } */\n+void f1(char*) __attribute__((nonnull(bar))); /* { dg-warning \".nonnull. attribute argument is invalid\" } */\n \n-void foo(void);\n-void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,foo))); /* { dg-warning \"outside range\" } */\n-void* my_realloc(void*, unsigned) __attribute__((alloc_size(foo))); /* { dg-warning \"outside range\" } */\n+void f2(char*) __attribute__((nonnull(1,bar))); /* { dg-warning \".nonnull. attribute argument 2 is invalid\" } */\n+\n+void foo(int);\n+void* my_calloc(unsigned, unsigned) __attribute__((alloc_size(1,foo))); /* { dg-warning \".alloc_size. attribute argument 2 has type .void\\\\\\(int\\\\\\).\" } */\n+void* my_realloc(void*, unsigned) __attribute__((alloc_size(foo))); /* { dg-warning \".alloc_size. attribute argument has type .void ?\\\\\\(int\\\\\\)\" } */\n \n typedef char vec __attribute__((vector_size(foo))); /* { dg-warning \"ignored\" } */\n \n-void f1(char*) __attribute__((nonnull(foo))); /* { dg-error \"invalid operand\" } */\n-void f2(char*) __attribute__((nonnull(1,foo))); /* { dg-error \"invalid operand\" } */\n+void f1(char*) __attribute__((nonnull(foo))); /* { dg-warning \".nonnull. attribute argument has type .void ?\\\\\\(int\\\\\\).\" } */\n+void f2(char*) __attribute__((nonnull(1,foo))); /* { dg-warning \".nonnull. attribute argument 2 has type .void ?\\\\\\(int\\\\\\).\" } */\n \n void g() __attribute__((aligned(foo))); /* { dg-error \"invalid value|not an integer\" } */"}, {"sha": "f06624c2d77cad0e3cebd235d3d470aa4bda65fd", "filename": "gcc/testsuite/c-c++-common/pr71574.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr71574.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,12 +1,15 @@\n-/* PR c/71574 */\n+/* PR c/71574 - ICE on code with alloc_align attribute */\n /* { dg-do compile } */\n \n-int fn1 (void);\n-int fn2 (void) __attribute__ ((alloc_align (fn1))); /* { dg-warning \"parameter outside range\" } */\n-int fn3 (void) __attribute__ ((alloc_size (fn1))); /* { dg-warning \"parameter outside range\" } */\n-int fn4 (void) __attribute__ ((assume_aligned (fn1))); /* { dg-warning \"not integer constant\" } */\n-int fn5 (char *, char *) __attribute__((nonnull (fn1))); /* { dg-error \"nonnull argument has invalid operand\" } */\n+int fn1 (int);\n+int fn2 (void) __attribute__ ((alloc_align (fn1))); /* { dg-warning \".alloc_align. attribute ignored on a function returning .int.\" } */\n+int fn3 (void) __attribute__ ((alloc_size (fn1))); /* { dg-warning \".alloc_size. attribute ignored on a function returning .int.\" } */\n+int fn4 (void) __attribute__ ((assume_aligned (fn1))); /* { dg-warning \".assume_aligned. attribute ignored on a function returning .int.\" } */\n+int fn5 (char *, char *) __attribute__((nonnull (fn1))); /* { dg-warning \".nonnull. attribute argument has type .int\\\\\\(int\\\\\\).\" } */\n int fn6 (const char *, ...) __attribute__ ((sentinel (fn1))); /* { dg-warning \"not an integer constant\" } */\n \n+void* fn7 (void) __attribute__ ((alloc_align (fn1))); /* { dg-warning \".alloc_align. attribute argument has type .int\\\\\\(int\\\\\\).\" } */\n+void* fn8 (void) __attribute__ ((assume_aligned (fn1))); /* { dg-warning \"not an integer constant\" } */\n+\n typedef int __attribute__((vector_size (fn1))) v4si; /* { dg-warning \"attribute ignored\" } */\n typedef int T __attribute__((aligned (fn1))); /* { dg-error \"requested alignment is not\" } */"}, {"sha": "9a421109bdb7cb328e2aa4ce48766e667356314b", "filename": "gcc/testsuite/g++.dg/ext/attr-alloc_size.C", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fattr-alloc_size.C?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -0,0 +1,53 @@\n+/* PR c++/87541 - ICE using a constant decl as an attribute alloc_size argument\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall\" } */\n+\n+#define ALLOC_SIZE(N)   __attribute__ ((alloc_size (N)))\n+\n+const int i1 = 1;\n+ALLOC_SIZE (i1) void* fcst (int);\n+\n+void* call_fcst (void)\n+{\n+  void *p = fcst (1);\n+  __builtin___memset_chk (p, 0, 2, __builtin_object_size (p, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow=\" }\n+  return p;\n+}\n+\n+\n+enum { e1 = 1 };\n+ALLOC_SIZE (e1) void* fenum (int);\n+\n+void* call_fenum (void)\n+{\n+  void *p = fenum (1);\n+  __builtin___memset_chk (p, 0, 2, __builtin_object_size (p, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow=\" }\n+  return p;\n+}\n+\n+\n+template <class T>\n+struct A\n+{\n+  ALLOC_SIZE (T::N1) static void* ftemplarg_1 (int);\n+  ALLOC_SIZE (T::N2) static void*\n+  ftemplarg_2 (int); // { dg-warning \"attribute argument value .2. exceeds the number of function parameters 1\" }\n+};\n+\n+struct B { static const int N1 = 1; static const int N2 = 1; };\n+\n+void* call_ftemplarg_1 (A<B> *pa)\n+{\n+  void *p = pa->ftemplarg_1 (1);\n+  __builtin___memset_chk (p, 0, 2, __builtin_object_size (p, 1));   // { dg-warning \"\\\\\\[-Wstringop-overflow=\" }\n+  return p;\n+}\n+\n+struct C { static const int N1 = 1; static const int N2 = 2; };\n+\n+void* call_ftemplarg_2 (A<C> *pa)\n+{\n+  void *p = pa->ftemplarg_2 (1);\n+  __builtin___memset_chk (p, 0, 2, __builtin_object_size (p, 1));\n+  return p;\n+}"}, {"sha": "01321e7785dddbfab312a199e87b9ab282d8508b", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-2.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -5,6 +5,6 @@ void *f1 (int) __attribute__((alloc_align (1)));\n void *f2 (int, int, int) __attribute__((alloc_align (3)));\n void *f3 (void) __attribute__((alloc_align)); /* { dg-error \"wrong number of arguments specified\" } */\n void *f4 (int, int) __attribute__((alloc_align (1, 2))); /* { dg-error \"wrong number of arguments specified\" } */\n-void *f5 (void) __attribute__((alloc_align (i))); /* { dg-warning \"outside range\" } */\n-void *f6 (int) __attribute__((alloc_align (0))); /* { dg-warning \"outside range\" } */\n-void *f7 (int) __attribute__((alloc_align (2))); /* { dg-warning \"outside range\" } */\n+void *f5 (void) __attribute__((alloc_align (i))); /* { dg-warning \".alloc_align. attribute argument value .i. is not an integer constant\" } */\n+void *f6 (int) __attribute__((alloc_align (0))); /* { dg-warning \".alloc_align. attribute argument value .0. does not refer to a function parameter\" } */\n+void *f7 (int) __attribute__((alloc_align (2))); /* { dg-warning \".alloc_align. attribute argument value .2. exceeds the number of function parameters 1\" } */"}, {"sha": "7cdfc7d840fac38bd575ccd5f3b4ea0bee9125b2", "filename": "gcc/testsuite/gcc.dg/attr-alloc_align-4.c", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_align-4.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -0,0 +1,43 @@\n+/* PR middle-end/81871 - bogus attribute alloc_align accepted\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define ALIGN(N)   __attribute__ ((alloc_align (N)))\n+#define SIZE_MAX  __SIZE_MAX__\n+\n+ALIGN (1) void fvv_m1 (void);     /* { dg-warning \".alloc_align. attribute ignored on a function returning .void.\" } */\n+\n+ALIGN (1) int fiv_1 (void);       /* { dg-warning \".alloc_align. attribute ignored on a function returning .int.\" } */\n+\n+ALIGN (0) void* fpvv_0 (void);    /* { dg-warning \".alloc_align. attribute argument value .0. does not refer to a function parameter\" } */\n+\n+ALIGN (1) void* fpvv_1 (void);    /* { dg-warning \".alloc_align. attribute argument value .1. exceeds the number of function parameters 0\" } */\n+\n+ALIGN (2) void* fii_2 (int);      /* { dg-warning \".alloc_align. attribute argument value .2. exceeds the number of function parameters 1\" } */\n+\n+ALIGN (1) void fvi_1 (int);       /* { dg-warning \".alloc_align. attribute ignored on a function returning .void.\" } */\n+\n+/* Using alloc_align with a function returning a pointer to a function\n+   should perhaps trigger a warning.  */\n+typedef void (F)(void);\n+ALIGN (1) F* fpF_i_1 (int);\n+\n+ALIGN (SIZE_MAX) void*\n+fpvi_szmax (int);                 /* { dg-warning \".alloc_align. attribute argument value .\\[0-9\\]+. exceeds the number of function parameters 1\" } */\n+\n+ALIGN (\"1\") void*\n+fpvi_str_1 (int);                 /* { dg-warning \".alloc_align. attribute argument has type .char\\\\\\[2]\" } */\n+\n+ALIGN ((void*)0) void*\n+fpvi_pv0 (int);                   /* { dg-warning \".alloc_align. attribute argument has type .void \\\\\\*.\" } */\n+\n+ALIGN ((double*)1) void*\n+fpvi_pd1 (int);                   /* { dg-warning \".alloc_align. attribute argument has type .double \\\\\\*.\" } */\n+\n+ALIGN (1) void*\n+fpvi_pv_1 (void*);                /* { dg-warning \".alloc_align. attribute argument value .1. refers to parameter type .void \\\\\\*.\" } */\n+\n+struct S { int i; };\n+ALIGN (2) void*\n+fpvi_S_2 (int, struct S);         /* { dg-warning \".alloc_align. attribute argument value .2. refers to parameter type .struct S.\" } */\n+"}, {"sha": "2e9be1e78646fcab9627de5e0662c74d044bfdb0", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-12.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-12.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -0,0 +1,60 @@\n+/* PR middle-end/81871 - bogus attribute alloc_align accepted\n+   Test exercising the problem with attribute alloc_size.\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define ASIZE(...)   __attribute__ ((alloc_size (__VA_ARGS__)))\n+#define SIZE_MAX  __SIZE_MAX__\n+\n+ASIZE (-1) void fvv_m1 (void);    /* { dg-warning \".alloc_size. attribute ignored on a function returning .void.\" } */\n+\n+ASIZE (1) int fiv_1 (void);       /* { dg-warning \".alloc_size. attribute ignored on a function returning .int.\" } */\n+\n+ASIZE (1, 2) int fiv_1_2 (void);  /* { dg-warning \".alloc_size. attribute ignored on a function returning .int.\" } */\n+\n+ASIZE (0) void* fpvv_0 (void);    /* { dg-warning \".alloc_size. attribute argument value .0. does not refer to a function parameter\" } */\n+\n+ASIZE (1, 0) void*\n+fpvv_1_0 (int);                   /* { dg-warning \".alloc_size. attribute argument 2 value .0. does not refer to a function parameter\" } */\n+\n+ASIZE (1) void* fpvv_1 (void);    /* { dg-warning \".alloc_size. attribute argument value .1. exceeds the number of function parameters 0\" } */\n+\n+ASIZE (1, 9) void*\n+fpvv_1_9 (int);                   /* { dg-warning \".alloc_size. attribute argument 2 value .9. exceeds the number of function parameters 1\" } */\n+\n+ASIZE (2) void* fii_2 (int);      /* { dg-warning \".alloc_size. attribute argument value .2. exceeds the number of function parameters 1\" } */\n+\n+ASIZE (1) void fvi_1 (int);       /* { dg-warning \".alloc_size. attribute ignored on a function returning .void.\" } */\n+\n+/* Using alloc_size with a function returning a pointer to a function\n+   should perhaps trigger a warning.  */\n+typedef void (F)(void);\n+ASIZE (1) F* fpF_i_1 (int);\n+\n+ASIZE (SIZE_MAX) void*\n+fpvi_szmax (int);                 /* { dg-warning \".alloc_size. attribute argument value .\\[0-9\\]+. exceeds the number of function parameters 1\" } */\n+\n+ASIZE (\"12\") void*\n+fpvi_str_1 (int);                 /* { dg-warning \".alloc_size. attribute argument has type .char\\\\\\[3].\" } */\n+\n+ASIZE (1, \"123\") void*\n+fpvi_str_2 (int, int);            /* { dg-warning \".alloc_size. attribute argument 2 has type .char\\\\\\[4].\" } */\n+\n+ASIZE ((void*)0) void*\n+fpvi_pv0 (int);                   /* { dg-warning \".alloc_size. attribute argument has type .void \\\\\\*.\" } */\n+\n+ASIZE ((double*)sizeof (double)) void*\n+fpvi_pd1 (int);                   /* { dg-warning \".alloc_size. attribute argument has type .double \\\\\\*.\" } */\n+\n+ASIZE (1) void*\n+fpvi_pv_1 (void*);                /* { dg-warning \".alloc_size. attribute argument value .1. refers to parameter type .void \\\\\\*.\" } */\n+\n+struct S { int i; };\n+ASIZE (2) void*\n+fpvi_S_2 (int, struct S);         /* { dg-warning \".alloc_size. attribute argument value .2. refers to parameter type .struct S.\" } */\n+\n+ASIZE ((struct S){ 1 }) void*\n+fpvi_S (int);                     /* { dg-warning \".alloc_size. attribute argument has type .struct S.\" } */\n+\n+ASIZE (1, (struct S){ 1 }) void*\n+fpvi_1_S (int);                   /* { dg-warning \".alloc_size. attribute argument 2 has type .struct S.\" } */"}, {"sha": "3bbd3e2b987917c2f8ed733abe05d80ed740ce6e", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size-2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size-2.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -1,4 +1,5 @@\n-/* { dg-do compile } */\n-\n-char *foo() __attribute__((alloc_size(1))); /* { dg-warning \"outside range\" } */\n+/* PR c/36021 - __attribute__((alloc_size(n))) with function of no\n+   arguments causes gcc to segfault\n+   { dg-do compile } */\n \n+char *foo() __attribute__((alloc_size(1)));"}, {"sha": "88a777158054f95b9e850dc684edc427f5d6a254", "filename": "gcc/testsuite/gcc.dg/attr-alloc_size.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-alloc_size.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -5,13 +5,13 @@ extern void abort (void);\n \n #include \"../gcc.c-torture/execute/builtins/chk.h\"\n \n-extern char *mallocminus1(int size) __attribute__((alloc_size(-1))); /* { dg-warning \"parameter outside range\" } */\n-extern char *malloc0(int size) __attribute__((alloc_size(0))); /* { dg-warning \"parameter outside range\" } */\n+extern char *mallocminus1(int size) __attribute__((alloc_size(-1))); /* { dg-warning \".alloc_size. attribute argument value .-1. exceeds the number of function parameters 1\" } */\n+extern char *malloc0(int size) __attribute__((alloc_size(0))); /* { dg-warning \".alloc_size. attribute argument value .0. does not refer to a function parameter\" } */\n extern char *malloc1(int size) __attribute__((alloc_size(1)));\n extern char *malloc2(int empty, int size) __attribute__((alloc_size(2)));\n extern char *calloc1(int size, int elements) __attribute__((alloc_size(1,2)));\n extern char *calloc2(int size, int empty, int elements) __attribute__((alloc_size(1,3)));\n-extern char *balloc1(void *size) __attribute__((alloc_size(1)));\n+extern char *balloc1(void *size) __attribute__((alloc_size(1)));   /* { dg-warning \".alloc_size. attribute argument value .1. refers to parameter type .void *.\" } */\n \n void\n test (void)"}, {"sha": "84f4523e58ed24e0eeb5650460ba262bf9e1574d", "filename": "gcc/testsuite/gcc.dg/attr-assume_aligned-4.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fattr-assume_aligned-4.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -0,0 +1,36 @@\n+/* PR middle-end/87533 - bogus assume_aligned attribute silently accepted\n+   { dg-do compile }\n+   { dg-options \"-Wall\" } */\n+\n+#define A(...)  __attribute__ ((assume_aligned (__VA_ARGS__)))\n+\n+A (1) void fv_1 (void);       /* { dg-warning \".assume_aligned. attribute ignored on a function returning .void.\" } */\n+\n+A (1) int fi_1 (void);        /* { dg-warning \".assume_aligned. attribute ignored on a function returning .int.\" } */\n+\n+A (-1) void* fpv_m1 (void);   /* { dg-warning \".assume_aligned. attribute argument -1 is not a power of 2\" } */\n+\n+A (0) void* fpv_0 (void);     /* { dg-warning \".assume_aligned. attribute argument 0 is not a power of 2\" } */\n+\n+/* Alignment of 1 is fine, it just doesn't offer any benefits.  */\n+A (1) void* fpv_1 (void);\n+\n+A (3) void* fpv_3 (void);     /* { dg-warning \".assume_aligned. attribute argument 3 is not a power of 2\" } */\n+\n+A (16383) void* fpv_16km1 (void);     /* { dg-warning \".assume_aligned. attribute argument 16383 is not a power of 2\" } */\n+A (16384) void* fpv_16k (void);\n+A (16385) void* fpv_16kp1 (void);    /* { dg-warning \".assume_aligned. attribute argument 16385 is not a power of 2\" } */\n+\n+A (32767) void* fpv_32km1 (void);     /* { dg-warning \".assume_aligned. attribute argument 32767 is not a power of 2\" } */\n+\n+A (4, -1) void* fpv_4_m1 (void);      /* { dg-warning \".assume_aligned. attribute argument -1 is not in the range \\\\\\[0, 4\\\\\\)\" } */\n+\n+A (4, 0) void* fpv_4_0 (void);\n+A (4, 1) void* fpv_4_1 (void);\n+A (4, 2) void* fpv_4_2 (void);\n+A (4, 3) void* fpv_4_3 (void);\n+\n+A (4, 4) void* fpv_4_3 (void);        /* { dg-warning \".assume_aligned. attribute argument 4 is not in the range \\\\\\[0, 4\\\\\\)\" } */\n+\n+A (4) void* gpv_4_3 (void);\n+A (2) void* gpv_4_3 (void);"}, {"sha": "31cc05ec5270a609f36e239459d216806e3bcedf", "filename": "gcc/testsuite/gcc.dg/format/attr-3.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fformat%2Fattr-3.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -41,10 +41,10 @@ extern void fe1 (const char *, ...) __attribute__((format(nosuch, 1, 2))); /* {\n /* Both the numbers must be integer constant expressions.  */\n extern void ff0 (const char *, ...) __attribute__((format(gnu_attr_printf, 3-2, (long long)(10/5))));\n int foo;\n-extern void ff1 (const char *, ...) __attribute__((format(gnu_attr_printf, foo, 10/5))); /* { dg-error \"invalid operand\" \"bad number\" } */\n-extern void ff2 (const char *, ...) __attribute__((format(gnu_attr_printf, 3-2, foo))); /* { dg-error \"invalid operand\" \"bad number\" } */\n+extern void ff1 (const char *, ...) __attribute__((format(gnu_attr_printf, foo, 10/5))); /* { dg-warning \".format. attribute argument 2 value .foo. is not an integer constant\" \"bad number\" } */\n+extern void ff2 (const char *, ...) __attribute__((format(gnu_attr_printf, 3-2, foo))); /* { dg-warning \".format. attribute argument 3 value .foo. is not an integer constant\" \"bad number\" } */\n extern char *ff3 (const char *) __attribute__((format_arg(3-2)));\n-extern char *ff4 (const char *) __attribute__((format_arg(foo))); /* { dg-error \"invalid operand\" \"bad format_arg number\" } */\n+extern char *ff4 (const char *) __attribute__((format_arg(foo))); /* { dg-warning \".format_arg. attribute argument value .foo. is not an integer constant\" \"bad format_arg number\" } */\n \n /* The format string argument must precede the arguments to be formatted.\n    This includes if no parameter types are specified (which is not valid ISO\n@@ -56,14 +56,14 @@ extern void fg3 () __attribute__((format(gnu_attr_printf, 2, 1))); /* { dg-error\n \n /* The format string argument must be a string type, and the arguments to\n    be formatted must be the \"...\".  */\n-extern void fh0 (int, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-error \"not a string\" \"format int string\" } */\n+extern void fh0 (int, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-warning \".format. attribute argument 2 value .1. refers to parameter type .int.\" \"format int string\" } */\n extern void fh1 (signed char *, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-error \"not a string\" \"signed char string\" } */\n extern void fh2 (unsigned char *, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-error \"not a string\" \"unsigned char string\" } */\n extern void fh3 (const char *, ...) __attribute__((format(gnu_attr_printf, 1, 3))); /* { dg-error \"is not\" \"not ...\" } */\n-extern void fh4 (const char *, int, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-error \"is not\" \"not ...\" } */\n+extern void fh4 (const char *, int, ...) __attribute__((format(gnu_attr_printf, 1, 2))); /* { dg-error \".format. attribute argument 3 value .2. does not refer to a variable argument list\" \"not ...\" } */\n \n /* format_arg formats must take and return a string.  */\n-extern char *fi0 (int) __attribute__((format_arg(1))); /* { dg-error \"not a string\" \"format_arg int string\" } */\n+extern char *fi0 (int) __attribute__((format_arg(1))); /* { dg-warning \".format_arg. attribute argument value .1. refers to parameter type .int.\" } */\n extern char *fi1 (signed char *) __attribute__((format_arg(1))); /* { dg-error \"not a string\" \"format_arg signed char string\" } */\n extern char *fi2 (unsigned char *) __attribute__((format_arg(1))); /* { dg-error \"not a string\" \"format_arg unsigned char string\" } */\n extern int fi3 (const char *) __attribute__((format_arg(1))); /* { dg-error \"not return string\" \"format_arg ret int string\" } */"}, {"sha": "4e3e48dd88de275d5b19797456fc304ebc0c09c4", "filename": "gcc/testsuite/gcc.dg/nonnull-2.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fnonnull-2.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -4,11 +4,12 @@\n \n extern void func1 () __attribute__((nonnull)); /* { dg-error \"without arguments\" } */\n \n-extern void func2 (char *) __attribute__((nonnull(2))); /* { dg-error \"out-of-range operand\" } */\n+extern void func2 (char *) __attribute__((nonnull(2))); /* { dg-warning \".nonnull. attribute argument value .2. exceeds the number of function parameters 1\" } */\n \n-extern void func3 (char *) __attribute__((nonnull(foo))); /* { dg-error \"invalid operand number|undeclared\" } */\n+extern void func3 (char *) __attribute__((nonnull (foo))); /* { dg-warning \".nonnull. attribute argument is invalid\" } */\n+/* { dg-error \".foo. undeclared\" \"undeclared argument\" { target *-*-* } .-1 } */\n \n-extern void func4 (int) __attribute__((nonnull(1))); /* { dg-error \"references non-pointer\" } */\n+extern void func4 (int) __attribute__((nonnull(1))); /* { dg-warning \".nonnull. attribute argument value .1. refers to parameter type .int.\" } */\n \n void\n foo (void)"}, {"sha": "e648e82559c26f75d22f93c1af7c06b70c963534", "filename": "gcc/testsuite/gcc.dg/torture/pr80612.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80612.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80612.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr80612.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -13,3 +13,5 @@ struct obstack {\n }\n void fn2(int) __attribute__((__alloc_size__(1)));\n void fn3() { fn1(fn2); }\n+\n+/* { dg-prune-output \"attribute ignored\" } */"}, {"sha": "9ff34f92fb179545b4c97ba0094981c164352ac4", "filename": "gcc/testsuite/obj-c++.dg/attributes/method-format-1.mm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-format-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-format-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-format-1.mm?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -19,8 +19,8 @@ - (void) debug: (const char *) my_format, ...  __attribute__ ((format (printf, 1\n - (void) log2: (int)level  message: (const char *) my_format, ...  __attribute__ ((format (printf, 2)));    /* { dg-error \"wrong\" } */\n + (void) debug2: (const char *) my_format, ...  __attribute__ ((format (printf))); /* { dg-error \"wrong\" } */\n - (void) debug2: (const char *) my_format, ...  __attribute__ ((format (printf))); /* { dg-error \"wrong\" } */\n-+ (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"args to be formatted is not ...\" } */\n-- (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"args to be formatted is not ...\" } */\n++ (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"does not refer to a variable argument list\" } */\n+- (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"does not refer to a variable argument list\" } */\n @end\n \n void test (LogObject *object)"}, {"sha": "f83c85377066821bfdecfc3e8d407bca8d292449", "filename": "gcc/testsuite/obj-c++.dg/attributes/method-nonnull-1.mm", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-nonnull-1.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-nonnull-1.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fattributes%2Fmethod-nonnull-1.mm?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -19,17 +19,19 @@ + (void) insertObject: (id)object  atIndex: (size_t)index  andObject: (id)anothe\n - (void) insertObject: (id)object  atIndex: (size_t)index  andObject: (id)anotherObject  atIndex: (size_t)anotherIndex __attribute__ ((nonnull (1, 3)));\n \n /* Test the behavior with invalid code.  */\n-+ (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-error \"out-of-range\" } */\n-- (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-error \"out-of-range\" } */\n++ (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-warning \"does not refer to a function parameter\" } */\n+- (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-warning \"does not refer to a function parameter\" } */\n \n-+ (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-error \"out-of-range\" } */\n-- (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-error \"out-of-range\" } */\n++ (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-warning \"exceeds the number of function parameters 3\" } */\n+- (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-warning \"exceeds the number of function parameters 3\" } */\n \n-+ (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-error \"non-pointer operand\" } */\n-- (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-error \"non-pointer operand\" } */\n++ (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-warning \"refers to parameter type .size_t.\" } */\n+- (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-warning \"refers to parameter type .size_t.\" } */\n \n + (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-error \"\" } */\n+  /* { dg-warning \"attribute argument is invalid\" \"\" { target *-*-* } .-1 } */\n - (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-error \"\" } */\n+  /* { dg-warning \"attribute argument is invalid\" \"\" { target *-*-* } .-1 } */\n @end\n \n void test (MyArray *object)"}, {"sha": "9ff34f92fb179545b4c97ba0094981c164352ac4", "filename": "gcc/testsuite/objc.dg/attributes/method-format-1.m", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-format-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-format-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-format-1.m?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -19,8 +19,8 @@ - (void) debug: (const char *) my_format, ...  __attribute__ ((format (printf, 1\n - (void) log2: (int)level  message: (const char *) my_format, ...  __attribute__ ((format (printf, 2)));    /* { dg-error \"wrong\" } */\n + (void) debug2: (const char *) my_format, ...  __attribute__ ((format (printf))); /* { dg-error \"wrong\" } */\n - (void) debug2: (const char *) my_format, ...  __attribute__ ((format (printf))); /* { dg-error \"wrong\" } */\n-+ (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"args to be formatted is not ...\" } */\n-- (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"args to be formatted is not ...\" } */\n++ (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"does not refer to a variable argument list\" } */\n+- (void) alert: (const char *) my_format __attribute__ ((format (printf, 1, 2))); /* { dg-error \"does not refer to a variable argument list\" } */\n @end\n \n void test (LogObject *object)"}, {"sha": "e1974aa3caeba84cab23edcbcd6089a34dc2ab02", "filename": "gcc/testsuite/objc.dg/attributes/method-nonnull-1.m", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-nonnull-1.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-nonnull-1.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fattributes%2Fmethod-nonnull-1.m?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -19,17 +19,17 @@ + (void) insertObject: (id)object  atIndex: (size_t)index  andObject: (id)anothe\n - (void) insertObject: (id)object  atIndex: (size_t)index  andObject: (id)anotherObject  atIndex: (size_t)anotherIndex __attribute__ ((nonnull (1, 3)));\n \n /* Test the behavior with invalid code.  */\n-+ (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-error \"out-of-range\" } */\n-- (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-error \"out-of-range\" } */\n++ (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-warning \"does not refer to a function parameter\" } */\n+- (void) removeObject: (id)object __attribute__ ((nonnull (0))); /* { dg-warning \"does not refer to a function parameter\" } */\n \n-+ (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-error \"out-of-range\" } */\n-- (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-error \"out-of-range\" } */\n++ (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-warning \"exceeds the number of function parameters 3\" } */\n+- (void) removeObject: (id)object __attribute__ ((nonnull (2))); /* { dg-warning \"exceeds the number of function parameters 3\" } */\n \n-+ (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-error \"non-pointer operand\" } */\n-- (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-error \"non-pointer operand\" } */\n++ (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-warning \"refers to parameter type .size_t.\" } */\n+- (void) removeObjectAtIndex: (size_t)object __attribute__ ((nonnull (1))); /* { dg-warning \"refers to parameter type .size_t.\" } */\n \n-+ (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-error \"invalid operand\" } */\n-- (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-error \"invalid operand\" } */\n++ (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-warning \"is invalid\" } */\n+- (void) removeObject: (id)object __attribute__ ((nonnull (MyArray))); /* { dg-warning \"is invalid\" } */\n @end\n \n void test (MyArray *object)"}, {"sha": "be89897d43a9bb0080a84aa59dad7bd57e5b97c8", "filename": "gcc/tree.c", "status": "modified", "additions": 38, "deletions": 4, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -4955,7 +4955,8 @@ build_nt_call_vec (tree fn, vec<tree, va_gc> *args)\n   return ret;\n }\n \f\n-/* Create a DECL_... node of code CODE, name NAME and data type TYPE.\n+/* Create a DECL_... node of code CODE, name NAME  (if non-null)\n+   and data type TYPE.\n    We do NOT enter this node in any sort of symbol table.\n \n    LOC is the location of the decl.\n@@ -6944,12 +6945,11 @@ type_list_equal (const_tree l1, const_tree l2)\n    then this function counts only the ordinary arguments.  */\n \n int\n-type_num_arguments (const_tree type)\n+type_num_arguments (const_tree fntype)\n {\n   int i = 0;\n-  tree t;\n \n-  for (t = TYPE_ARG_TYPES (type); t; t = TREE_CHAIN (t))\n+  for (tree t = TYPE_ARG_TYPES (fntype); t; t = TREE_CHAIN (t))\n     /* If the function does not take a variable number of arguments,\n        the last element in the list will have type `void'.  */\n     if (VOID_TYPE_P (TREE_VALUE (t)))\n@@ -6960,6 +6960,40 @@ type_num_arguments (const_tree type)\n   return i;\n }\n \n+/* Return the type of the function TYPE's argument ARGNO if known.\n+   For vararg function's where ARGNO refers to one of the variadic\n+   arguments return null.  Otherwise, return a void_type_node for\n+   out-of-bounds ARGNO.  */\n+\n+tree\n+type_argument_type (const_tree fntype, unsigned argno)\n+{\n+  /* Treat zero the same as an out-of-bounds argument number.  */\n+  if (!argno)\n+    return void_type_node;\n+\n+  function_args_iterator iter;\n+\n+  tree argtype;\n+  unsigned i = 1;\n+  FOREACH_FUNCTION_ARGS (fntype, argtype, iter)\n+    {\n+      /* A vararg function's argument list ends in a null.  Otherwise,\n+\t an ordinary function's argument list ends with void.  Return\n+\t null if ARGNO refers to a vararg argument, void_type_node if\n+\t it's out of bounds, and the formal argument type otherwise.  */\n+      if (!argtype)\n+\tbreak;\n+\n+      if (i == argno || VOID_TYPE_P (argtype))\n+\treturn argtype;\n+\n+      ++i;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n /* Nonzero if integer constants T1 and T2\n    represent the same constant value.  */\n "}, {"sha": "c21af9ff6d9781262aa0de0b84628180329939f1", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d24950977c730f5e955060057b1dd0b5c051adb/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=1d24950977c730f5e955060057b1dd0b5c051adb", "patch": "@@ -4834,6 +4834,7 @@ extern tree get_file_function_name (const char *);\n extern tree get_callee_fndecl (const_tree);\n extern combined_fn get_call_combined_fn (const_tree);\n extern int type_num_arguments (const_tree);\n+extern tree type_argument_type (const_tree, unsigned) ATTRIBUTE_NONNULL (1);\n extern bool associative_tree_code (enum tree_code);\n extern bool commutative_tree_code (enum tree_code);\n extern bool commutative_ternary_tree_code (enum tree_code);"}]}