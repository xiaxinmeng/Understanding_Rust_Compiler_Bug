{"sha": "91b4415af4fafcd53f44b671003e917dd7ec0cfd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFiNDQxNWFmNGZhZmNkNTNmNDRiNjcxMDAzZTkxN2RkN2VjMGNmZA==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2006-02-09T19:17:09Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2006-02-09T19:17:09Z"}, "message": "re PR inline-asm/16194 (global register with inline-asm and clobered)\n\nPR inline-asm/16194\n\ngcc:\n\t* tree.h (decl_overlaps_hard_reg_set_p) Don't declare.\n\t(tree_overlaps_hard_reg_set): Declare.\n\t* stmt.c (decl_overlaps_hard_reg_set_p): Now static.  Change return\n\ttype and signature to match function type expected by walk_tree.\n\t(tree_overlaps_hard_reg_set): New function.\n\t(decl_conflicts_with_clobbers_p): Rename to:\n\t(tree_conflicts_with_clobbers_p).  Take HARD_REG_SET * argument.\n\tUse tree_overlaps_hard_reg_set.  Changed caller.\n\t* doc/tm.texi (TARGET_MD_ASM_CLOBBERS): Replace\n\tdecl_overlaps_hard_reg_set_p with tree_overlaps_hard_reg_set.\n\t* cris.c (cris_md_asm_clobbers): Likewise.\n\ngcc/testsuite:\n\t* gcc.dg/pr16194.c: New test.\n\nFrom-SVN: r110810", "tree": {"sha": "7fcf4d414c6e351a2b6ddc6cf557386db43b8be6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fcf4d414c6e351a2b6ddc6cf557386db43b8be6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91b4415af4fafcd53f44b671003e917dd7ec0cfd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b4415af4fafcd53f44b671003e917dd7ec0cfd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91b4415af4fafcd53f44b671003e917dd7ec0cfd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91b4415af4fafcd53f44b671003e917dd7ec0cfd/comments", "author": null, "committer": null, "parents": [{"sha": "0e692cc0bfb3d8209ee6bfe2e3467f444df860d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e692cc0bfb3d8209ee6bfe2e3467f444df860d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e692cc0bfb3d8209ee6bfe2e3467f444df860d9"}], "stats": {"total": 168, "additions": 136, "deletions": 32}, "files": [{"sha": "763e081d178d92c8fe2de05d9ae320b6db8da5d0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -1,3 +1,18 @@\n+2006-02-09  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR inline-asm/16194\n+\t* tree.h (decl_overlaps_hard_reg_set_p) Don't declare.\n+\t(tree_overlaps_hard_reg_set): Declare.\n+\t* stmt.c (decl_overlaps_hard_reg_set_p): Now static.  Change return\n+\ttype and signature to match function type expected by walk_tree.\n+\t(tree_overlaps_hard_reg_set): New function.\n+\t(decl_conflicts_with_clobbers_p): Rename to:\n+\t(tree_conflicts_with_clobbers_p).  Take HARD_REG_SET * argument.\n+\tUse tree_overlaps_hard_reg_set.  Changed caller.\n+\t* doc/tm.texi (TARGET_MD_ASM_CLOBBERS): Replace\n+\tdecl_overlaps_hard_reg_set_p with tree_overlaps_hard_reg_set.\n+\t* cris.c (cris_md_asm_clobbers): Likewise.\n+\n 2006-02-09  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* reload1.c (emit_input_reload_insns): Delete code that tries to"}, {"sha": "dc0c163fc0cb9a7104717d3e23c84957ca3e441f", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -3462,7 +3462,7 @@ cris_md_asm_clobbers (tree outputs, tree inputs, tree in_clobbers)\n \t impossible constraints.  */\n       if (strchr (TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t))),\n \t\t  'h') != NULL\n-\t  || decl_overlaps_hard_reg_set_p (val, mof_set))\n+\t  || tree_overlaps_hard_reg_set (val, &mof_set) != NULL_TREE)\n \treturn clobbers;\n     }\n \n@@ -3472,7 +3472,7 @@ cris_md_asm_clobbers (tree outputs, tree inputs, tree in_clobbers)\n \n       if (strchr (TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (t))),\n \t\t  'h') != NULL\n-\t  || decl_overlaps_hard_reg_set_p (val, mof_set))\n+\t  || tree_overlaps_hard_reg_set (val, &mof_set) != NULL_TREE)\n \treturn clobbers;\n     }\n "}, {"sha": "5a04430dc30bd1d81afdb45afe2bf6a4cfc23b4d", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -9337,7 +9337,7 @@ It should return the result of the last @code{tree_cons} used to add a\n clobber.  The @var{outputs}, @var{inputs} and @var{clobber} lists are the\n corresponding parameters to the asm and may be inspected to avoid\n clobbering a register that is an input or output of the asm.  You can use\n-@code{decl_overlaps_hard_reg_set_p}, declared in @file{tree.h}, to test\n+@code{tree_overlaps_hard_reg_set}, declared in @file{tree.h}, to test\n for overlap with regards to asm-declared registers.\n @end deftypefn\n "}, {"sha": "3bb4f42c2da8597d36c55d7f59ae6e947446b9e8", "filename": "gcc/stmt.c", "status": "modified", "additions": 45, "deletions": 28, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -105,7 +105,7 @@ static int cost_table_initialized;\n #define COST_TABLE(I)  cost_table_[(unsigned HOST_WIDE_INT) ((I) + 1)]\n \f\n static int n_occurrences (int, const char *);\n-static bool decl_conflicts_with_clobbers_p (tree, const HARD_REG_SET);\n+static bool tree_conflicts_with_clobbers_p (tree, HARD_REG_SET *);\n static void expand_nl_goto_receiver (void);\n static bool check_operand_nalternatives (tree, tree);\n static bool check_unique_operand_names (tree, tree);\n@@ -558,49 +558,66 @@ parse_input_constraint (const char **constraint_p, int input_num,\n   return true;\n }\n \n-/* Return true iff there's an overlap between REGS and DECL, where DECL\n-   can be an asm-declared register.  */\n+/* Return DECL iff there's an overlap between *REGS and DECL, where DECL\n+   can be an asm-declared register.  Called via walk_tree.  */\n \n-bool\n-decl_overlaps_hard_reg_set_p (tree decl, const HARD_REG_SET regs)\n+static tree\n+decl_overlaps_hard_reg_set_p (tree *declp, int *walk_subtrees ATTRIBUTE_UNUSED,\n+\t\t\t      void *data)\n {\n-  if ((TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n-      && DECL_REGISTER (decl)\n-      && REG_P (DECL_RTL (decl))\n-      && REGNO (DECL_RTL (decl)) < FIRST_PSEUDO_REGISTER)\n+  tree decl = *declp;\n+  const HARD_REG_SET *regs = data;\n+\n+  if (TREE_CODE (decl) == VAR_DECL || TREE_CODE (decl) == PARM_DECL)\n     {\n-      rtx reg = DECL_RTL (decl);\n-      unsigned int regno;\n-\n-      for (regno = REGNO (reg);\n-\t   regno < (REGNO (reg)\n-\t\t    + hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]);\n-\t   regno++)\n-\tif (TEST_HARD_REG_BIT (regs, regno))\n-\t  return true;\n+      if (DECL_REGISTER (decl)\n+\t  && REG_P (DECL_RTL (decl))\n+\t  && REGNO (DECL_RTL (decl)) < FIRST_PSEUDO_REGISTER)\n+\t{\n+\t  rtx reg = DECL_RTL (decl);\n+\t  unsigned int regno;\n+\n+\t  for (regno = REGNO (reg);\n+\t       regno < (REGNO (reg)\n+\t\t\t+ hard_regno_nregs[REGNO (reg)][GET_MODE (reg)]);\n+\t       regno++)\n+\t    if (TEST_HARD_REG_BIT (*regs, regno))\n+\t      return decl;\n+\t}\n+      walk_subtrees = 0;\n     }\n-\n-  return false;\n+  else if (TYPE_P (decl))\n+    walk_subtrees = 0;\n+  return NULL_TREE;\n }\n \n+/* If there is an overlap between *REGS and DECL, return the first overlap\n+   found.  */\n+tree\n+tree_overlaps_hard_reg_set (tree decl, HARD_REG_SET *regs)\n+{\n+  return walk_tree (&decl, decl_overlaps_hard_reg_set_p, regs, NULL);\n+}\n \n /* Check for overlap between registers marked in CLOBBERED_REGS and\n-   anything inappropriate in DECL.  Emit error and return TRUE for error,\n-   FALSE for ok.  */\n+   anything inappropriate in T.  Emit error and return the register\n+   variable definition for error, NULL_TREE for ok.  */\n \n static bool\n-decl_conflicts_with_clobbers_p (tree decl, const HARD_REG_SET clobbered_regs)\n+tree_conflicts_with_clobbers_p (tree t, HARD_REG_SET *clobbered_regs)\n {\n   /* Conflicts between asm-declared register variables and the clobber\n      list are not allowed.  */\n-  if (decl_overlaps_hard_reg_set_p (decl, clobbered_regs))\n+  tree overlap = tree_overlaps_hard_reg_set (t, clobbered_regs);\n+\n+  if (overlap)\n     {\n       error (\"asm-specifier for variable %qs conflicts with asm clobber list\",\n-\t     IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t     IDENTIFIER_POINTER (DECL_NAME (overlap)));\n \n       /* Reset registerness to stop multiple errors emitted for a single\n \t variable.  */\n-      DECL_REGISTER (decl) = 0;\n+      DECL_REGISTER (overlap) = 0;\n       return true;\n     }\n \n@@ -827,7 +844,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t  inout_opnum[ninout++] = i;\n \t}\n \n-      if (decl_conflicts_with_clobbers_p (val, clobbered_regs))\n+      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n \tclobber_conflict_found = 1;\n     }\n \n@@ -923,7 +940,7 @@ expand_asm_operands (tree string, tree outputs, tree inputs,\n \t= gen_rtx_ASM_INPUT (TYPE_MODE (type), \n \t\t\t     ggc_strdup (constraints[i + noutputs]));\n \n-      if (decl_conflicts_with_clobbers_p (val, clobbered_regs))\n+      if (tree_conflicts_with_clobbers_p (val, &clobbered_regs))\n \tclobber_conflict_found = 1;\n     }\n "}, {"sha": "59778df2f870c19d2346ce7ea9c0ac6f280fdd8e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -1,3 +1,8 @@\n+2006-02-09  J\"orn Rennecke <joern.rennecke@st.com>\n+\n+\tPR inline-asm/16194\n+\t* gcc.dg/pr16194.c: New test.\n+\n 2006-02-09  Rainer Orth  <ro@TechFak.Uni-Bielefeld.DE>\n \n \t* ada/acats/run_acats: Use portable variant of \"$@\"."}, {"sha": "44f34a41008b203277a986ef09e92d35024d3275", "filename": "gcc/testsuite/gcc.dg/pr16194.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16194.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16194.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr16194.c?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O\" } */\n+/* { dg-bogus \"internal compiler error\" \"ICE\" { target *-*-* } 0 } */\n+\n+#define ASMDECL __asm (REG);\n+#define CLOBBER_LIST : REG\n+#define INP_CLOBBER_LIST : CLOBBER_LIST\n+#if defined (__alpha__)\n+# define REG \"$1\"\n+#elif defined (__CRIS__) || defined (__sh__)\n+# define REG \"r10\"\n+#elif defined (__i386__)\n+# define REG \"%eax\"\n+#elif defined (__MMIX__)\n+# define REG \"$8\"\n+#elif defined (__powerpc__) || defined (__PPC__) || defined (__ppc__) \\\n+        || defined (__POWERPC__) || defined (PPC) || defined (_IBMR2)\n+# define REG \"6\"\n+#elif defined (__x86_64__)\n+# define REG \"rax\"\n+#else\n+  /* Make this test harmless for any target not recognized above.  */\n+# undef ASMDECL\n+# define ASMDECL\n+# define REG \"conflict\"\n+# undef CLOBBER_LIST\n+# define CLOBBER_LIST\n+# undef INP_CLOBBER_LIST\n+# define INP_CLOBBER_LIST\n+#endif\n+\n+struct A\n+{\n+  int a;\n+};\n+\n+struct B\n+{\n+  struct A b[3];\n+};\n+\n+struct C\n+{\n+  struct B c;\n+};\n+\n+void bug (void)\n+{\n+  register char* dst ASMDECL;\n+  __asm__ (\"\":\"=g\"(*dst): : REG); /* { dg-error \"conflict\" } */\n+}\n+\n+/* The tree optimizers currently prevent us from finding an overlap -\n+   we end up using a copy of dst rather than dst.\n+   But at least make sure we don't get an ICE.  */\n+void bug2 (void)\n+{\n+  register char* dst ASMDECL;\n+  __asm__ (\"\": :\"g\"(*dst) CLOBBER_LIST);\n+}\n+\n+void\n+foo (void)\n+{\n+  register struct C *dst ASMDECL;\n+  __asm__ (\"\" : \"=g\"(dst->c.b[1].a) INP_CLOBBER_LIST);\n+}"}, {"sha": "7d17dafe865470f926d602efed98f5f28f53837b", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91b4415af4fafcd53f44b671003e917dd7ec0cfd/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=91b4415af4fafcd53f44b671003e917dd7ec0cfd", "patch": "@@ -4382,7 +4382,7 @@ extern void expand_decl (tree);\n extern void expand_anon_union_decl (tree, tree, tree);\n #ifdef HARD_CONST\n /* Silly ifdef to avoid having all includers depend on hard-reg-set.h.  */\n-extern bool decl_overlaps_hard_reg_set_p (tree, const HARD_REG_SET);\n+extern tree tree_overlaps_hard_reg_set (tree, HARD_REG_SET *);\n #endif\n \n /* In gimplify.c.  */"}]}