{"sha": "0e22465644731d86e2d317bf5fbfab2a76eccc9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGUyMjQ2NTY0NDczMWQ4NmUyZDMxN2JmNWZiZmFiMmE3NmVjY2M5Yw==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2012-02-25T12:09:27Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2012-02-25T12:09:27Z"}, "message": "re PR debug/52001 (Huge compile-time regression with var-tracking)\n\nPR debug/52001\n* cselib.c (preserve_only_constants): Rename to...\n(preserve_constants_and_equivs): ... this.  Split out...\n(invariant_or_equiv_p): ... this.  Preserve plus expressions\nof other preserved expressions too.\n(cselib_reset_table): Adjust.\n* var-tracking.c (reverse_op): Use canonical value to build\nreverse operation.\n\nFrom-SVN: r184571", "tree": {"sha": "6ab41affb99d878e95476613024ed2c4536fa5c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6ab41affb99d878e95476613024ed2c4536fa5c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0e22465644731d86e2d317bf5fbfab2a76eccc9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e22465644731d86e2d317bf5fbfab2a76eccc9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e22465644731d86e2d317bf5fbfab2a76eccc9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e22465644731d86e2d317bf5fbfab2a76eccc9c/comments", "author": null, "committer": null, "parents": [{"sha": "2ef7cdff1ee32d6fd8397d6229cc6410cb475ee0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ef7cdff1ee32d6fd8397d6229cc6410cb475ee0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ef7cdff1ee32d6fd8397d6229cc6410cb475ee0"}], "stats": {"total": 71, "additions": 49, "deletions": 22}, "files": [{"sha": "4a2c9fb6c2fe9be1f55877cb88de3917c5442c15", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0e22465644731d86e2d317bf5fbfab2a76eccc9c", "patch": "@@ -1,3 +1,14 @@\n+2012-02-25  Alexandre Oliva  <aoliva@redhat.com>\n+\n+\tPR debug/52001\n+\t* cselib.c (preserve_only_constants): Rename to...\n+\t(preserve_constants_and_equivs): ... this.  Split out...\n+\t(invariant_or_equiv_p): ... this.  Preserve plus expressions\n+\tof other preserved expressions too.\n+\t(cselib_reset_table): Adjust.\n+\t* var-tracking.c (reverse_op): Use canonical value to build\n+\treverse operation.\n+\n 2012-02-23  Kai Tietz  <ktietz@redhat.com>\n \n \t* config/i386/i386.c (ix86_delegitimize_address): Handle"}, {"sha": "4985357c83a40d14456e774395ed2f3211be8d46", "filename": "gcc/cselib.c", "status": "modified", "additions": 34, "deletions": 22, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=0e22465644731d86e2d317bf5fbfab2a76eccc9c", "patch": "@@ -383,47 +383,59 @@ cselib_clear_table (void)\n   cselib_reset_table (1);\n }\n \n-/* Remove from hash table all VALUEs except constants\n-   and function invariants.  */\n+/* Return TRUE if V is a constant, a function invariant or a VALUE\n+   equivalence; FALSE otherwise.  */\n \n-static int\n-preserve_only_constants (void **x, void *info ATTRIBUTE_UNUSED)\n+static bool\n+invariant_or_equiv_p (cselib_val *v)\n {\n-  cselib_val *v = (cselib_val *)*x;\n   struct elt_loc_list *l;\n \n+  if (v == cfa_base_preserved_val)\n+    return true;\n+\n+  /* Keep VALUE equivalences around.  */\n+  for (l = v->locs; l; l = l->next)\n+    if (GET_CODE (l->loc) == VALUE)\n+      return true;\n+\n   if (v->locs != NULL\n       && v->locs->next == NULL)\n     {\n       if (CONSTANT_P (v->locs->loc)\n \t  && (GET_CODE (v->locs->loc) != CONST\n \t      || !references_value_p (v->locs->loc, 0)))\n-\treturn 1;\n+\treturn true;\n       /* Although a debug expr may be bound to different expressions,\n \t we can preserve it as if it was constant, to get unification\n \t and proper merging within var-tracking.  */\n       if (GET_CODE (v->locs->loc) == DEBUG_EXPR\n \t  || GET_CODE (v->locs->loc) == DEBUG_IMPLICIT_PTR\n \t  || GET_CODE (v->locs->loc) == ENTRY_VALUE\n \t  || GET_CODE (v->locs->loc) == DEBUG_PARAMETER_REF)\n-\treturn 1;\n-      if (cfa_base_preserved_val)\n-\t{\n-\t  if (v == cfa_base_preserved_val)\n-\t    return 1;\n-\t  if (GET_CODE (v->locs->loc) == PLUS\n-\t      && CONST_INT_P (XEXP (v->locs->loc, 1))\n-\t      && XEXP (v->locs->loc, 0) == cfa_base_preserved_val->val_rtx)\n-\t    return 1;\n-\t}\n+\treturn true;\n+\n+      /* (plus (value V) (const_int C)) is invariant iff V is invariant.  */\n+      if (GET_CODE (v->locs->loc) == PLUS\n+\t  && CONST_INT_P (XEXP (v->locs->loc, 1))\n+\t  && GET_CODE (XEXP (v->locs->loc, 0)) == VALUE\n+\t  && invariant_or_equiv_p (CSELIB_VAL_PTR (XEXP (v->locs->loc, 0))))\n+\treturn true;\n     }\n \n-  /* Keep VALUE equivalences around.  */\n-  for (l = v->locs; l; l = l->next)\n-    if (GET_CODE (l->loc) == VALUE)\n-      return 1;\n+  return false;\n+}\n+\n+/* Remove from hash table all VALUEs except constants, function\n+   invariants and VALUE equivalences.  */\n+\n+static int\n+preserve_constants_and_equivs (void **x, void *info ATTRIBUTE_UNUSED)\n+{\n+  cselib_val *v = (cselib_val *)*x;\n \n-  htab_clear_slot (cselib_hash_table, x);\n+  if (!invariant_or_equiv_p (v))\n+    htab_clear_slot (cselib_hash_table, x);\n   return 1;\n }\n \n@@ -463,7 +475,7 @@ cselib_reset_table (unsigned int num)\n     }\n \n   if (cselib_preserve_constants)\n-    htab_traverse (cselib_hash_table, preserve_only_constants, NULL);\n+    htab_traverse (cselib_hash_table, preserve_constants_and_equivs, NULL);\n   else\n     htab_empty (cselib_hash_table);\n "}, {"sha": "c6280e2c1f185121c08852b901187ab508f26ef1", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0e22465644731d86e2d317bf5fbfab2a76eccc9c/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=0e22465644731d86e2d317bf5fbfab2a76eccc9c", "patch": "@@ -5334,6 +5334,10 @@ reverse_op (rtx val, const_rtx expr, rtx insn)\n   if (!v || !cselib_preserved_value_p (v))\n     return;\n \n+  /* Use canonical V to avoid creating multiple redundant expressions\n+     for different VALUES equivalent to V.  */\n+  v = canonical_cselib_val (v);\n+\n   /* Adding a reverse op isn't useful if V already has an always valid\n      location.  Ignore ENTRY_VALUE, while it is always constant, we should\n      prefer non-ENTRY_VALUE locations whenever possible.  */"}]}