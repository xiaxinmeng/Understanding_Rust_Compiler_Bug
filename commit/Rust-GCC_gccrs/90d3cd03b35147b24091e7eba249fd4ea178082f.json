{"sha": "90d3cd03b35147b24091e7eba249fd4ea178082f", "node_id": "C_kwDOANBUbNoAKDkwZDNjZDAzYjM1MTQ3YjI0MDkxZTdlYmEyNDlmZDRlYTE3ODA4MmY", "commit": {"author": {"name": "Ronan Desplanques", "email": "desplanques@adacore.com", "date": "2022-12-14T14:10:44Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2023-01-05T14:29:59Z"}, "message": "ada: Adjust handling of \"%g\" in GNAT.Formatted_String\n\nThe way the \"%g\" specifier was handled by GNAT.Formatted_String\nbefore this patch was very different from the behavior of C's printf.\nThis patch makes the handling of \"%g\" in GNAT.Formatted_String closer\nto the behavior described in the specification of the C language.\n\ngcc/ada/\n\n\t* libgnat/g-forstr.adb (F_Kind): Rename enumeration literal.\n\t(P_Flt_Format): Adjust handling of \"%g\".\n\t(Determine_Notation_And_Aft): New procedure.\n\t(Decimal_Exponent): New function.\n\t(Increment_Integral_Part): New procedure.\n\t(Remove_Extraneous_Decimal_Digit): New procedure.\n\t(Trim_Fractional_Part): New procedure.\n\t* libgnat/g-forstr.ads: Change description of \"%g\" specifier.", "tree": {"sha": "74386f7ffc310e4bf1c9d77594249fea911c5934", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74386f7ffc310e4bf1c9d77594249fea911c5934"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/90d3cd03b35147b24091e7eba249fd4ea178082f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d3cd03b35147b24091e7eba249fd4ea178082f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/90d3cd03b35147b24091e7eba249fd4ea178082f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/90d3cd03b35147b24091e7eba249fd4ea178082f/comments", "author": {"login": "ronan-d", "id": 14870758, "node_id": "MDQ6VXNlcjE0ODcwNzU4", "avatar_url": "https://avatars.githubusercontent.com/u/14870758?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ronan-d", "html_url": "https://github.com/ronan-d", "followers_url": "https://api.github.com/users/ronan-d/followers", "following_url": "https://api.github.com/users/ronan-d/following{/other_user}", "gists_url": "https://api.github.com/users/ronan-d/gists{/gist_id}", "starred_url": "https://api.github.com/users/ronan-d/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ronan-d/subscriptions", "organizations_url": "https://api.github.com/users/ronan-d/orgs", "repos_url": "https://api.github.com/users/ronan-d/repos", "events_url": "https://api.github.com/users/ronan-d/events{/privacy}", "received_events_url": "https://api.github.com/users/ronan-d/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "912d1e184a4f6c66bc57893e5745ec74009b4fd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/912d1e184a4f6c66bc57893e5745ec74009b4fd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/912d1e184a4f6c66bc57893e5745ec74009b4fd1"}], "stats": {"total": 347, "additions": 313, "deletions": 34}, "files": [{"sha": "a58b1702eca89a2686c5382ca80602b500d5f046", "filename": "gcc/ada/libgnat/g-forstr.adb", "status": "modified", "additions": 309, "deletions": 32, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d3cd03b35147b24091e7eba249fd4ea178082f/gcc%2Fada%2Flibgnat%2Fg-forstr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d3cd03b35147b24091e7eba249fd4ea178082f/gcc%2Fada%2Flibgnat%2Fg-forstr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-forstr.adb?ref=90d3cd03b35147b24091e7eba249fd4ea178082f", "patch": "@@ -34,6 +34,7 @@ with Ada.Float_Text_IO;\n with Ada.Integer_Text_IO;\n with Ada.Long_Float_Text_IO;\n with Ada.Long_Integer_Text_IO;\n+with Ada.Strings;\n with Ada.Strings.Fixed;\n with Ada.Unchecked_Deallocation;\n \n@@ -49,16 +50,16 @@ package body GNAT.Formatted_String is\n                    Decimal_Float,               -- %f %F\n                    Decimal_Scientific_Float,    -- %e\n                    Decimal_Scientific_Float_Up, -- %E\n-                   Shortest_Decimal_Float,      -- %g\n-                   Shortest_Decimal_Float_Up,   -- %G\n+                   G_Specifier,                 -- %g\n+                   G_Specifier_Up,              -- %G\n                    Char,                        -- %c\n                    Str,                         -- %s\n                    Pointer                      -- %p\n                   );\n \n    type Sign_Kind is (Neg, Zero, Pos);\n \n-   subtype Is_Number is F_Kind range Decimal_Int .. Shortest_Decimal_Float_Up;\n+   subtype Is_Number is F_Kind range Decimal_Int .. G_Specifier_Up;\n \n    type F_Sign is (If_Neg, Forced, Space) with Default_Value => If_Neg;\n \n@@ -77,6 +78,8 @@ package body GNAT.Formatted_String is\n       Value_Needed : Natural range 0 .. 2 := 0;\n    end record;\n \n+   type Notation is (Decimal, Scientific);\n+\n    procedure Advance_And_Accumulate_Until_Next_Specifier\n      (Format : Formatted_String);\n    --  Advance Format.D.Index until either the next format specifier is\n@@ -90,12 +93,30 @@ package body GNAT.Formatted_String is\n    --  Parse the next format specifier, a format specifier has the following\n    --  syntax: %[flags][width][.precision][length]specifier\n \n+   procedure Determine_Notation_And_Aft\n+     (Exponent                : Integer;\n+      Precision               : Text_IO.Field;\n+      Nota                    : out Notation;\n+      Aft                     : out Text_IO.Field);\n+   --  Determine whether to use scientific or decimal notation and the value of\n+   --  Aft given the exponent and precision of a real number, as described in\n+   --  the C language specification, section 7.21.6.1.\n+\n    function Get_Formatted\n      (F_Spec : F_Data;\n       Value  : String;\n       Len    : Positive) return String;\n    --  Returns Value formatted given the information in F_Spec\n \n+   procedure Increment_Integral_Part\n+     (Buffer              : in out String;\n+      First_Non_Blank     : in out Positive;\n+      Last_Digit_Position : Positive);\n+   --  Buffer must contain the textual representation of a number.\n+   --  Last_Digit_Position must be the position of the rightmost digit of the\n+   --  integral part. Buffer must have at least one padding blank. Increment\n+   --  the integral part.\n+\n    procedure Raise_Wrong_Format (Format : Formatted_String) with No_Return;\n    --  Raise the Format_Error exception which information about the context\n \n@@ -128,6 +149,18 @@ package body GNAT.Formatted_String is\n       Var    : Int) return Formatted_String;\n    --  Generic routine which handles all the integer numbers\n \n+   procedure Remove_Extraneous_Decimal_Digit\n+     (Textual_Rep     : in out String;\n+      First_Non_Blank : in out Positive);\n+   --  Remove the unique digit to the right of the point in Textual_Rep\n+\n+   procedure Trim_Fractional_Part\n+     (Textual_Rep     : in out String;\n+      First_Non_Blank : in out Positive);\n+   --  Remove trailing zeros from Textual_Rep, which must be the textual\n+   --  representation of a real number. If the fractional part only contains\n+   --  zeros, also remove the point.\n+\n    ---------\n    -- \"+\" --\n    ---------\n@@ -335,6 +368,30 @@ package body GNAT.Formatted_String is\n       end loop;\n    end Advance_And_Accumulate_Until_Next_Specifier;\n \n+   --------------------------------\n+   -- Determine_Notation_And_Aft --\n+   --------------------------------\n+\n+   procedure Determine_Notation_And_Aft\n+     (Exponent  : Integer;\n+      Precision : Text_IO.Field;\n+      Nota      : out Notation;\n+      Aft       : out Text_IO.Field)\n+   is\n+      --  The constants use the same names as those from the C specification\n+      --  in order to match the description of the predicate.\n+      P : constant Text_IO.Field := (if Precision /= 0 then Precision else 1);\n+      X : constant Integer       := Exponent;\n+   begin\n+      if P > X and X >= -4 then\n+         Nota := Decimal;\n+         Aft  := P - (X + 1);\n+      else\n+         Nota := Scientific;\n+         Aft  := P - 1;\n+      end if;\n+   end Determine_Notation_And_Aft;\n+\n    --------------------\n    -- Decimal_Format --\n    --------------------\n@@ -462,6 +519,35 @@ package body GNAT.Formatted_String is\n       end;\n    end Get_Formatted;\n \n+   -----------------------------\n+   -- Increment_Integral_Part --\n+   -----------------------------\n+\n+   procedure Increment_Integral_Part\n+     (Buffer              : in out String;\n+      First_Non_Blank     : in out Positive;\n+      Last_Digit_Position : Positive)\n+   is\n+      Cursor : Natural := Last_Digit_Position;\n+   begin\n+      while Buffer (Cursor) = '9' loop\n+         Buffer (Cursor) := '0';\n+         Cursor          := Cursor - 1;\n+      end loop;\n+\n+      pragma Assert (Cursor > 0);\n+\n+      if Buffer (Cursor) in '0' .. '8' then\n+         Buffer (Cursor) := Character'Succ (Buffer (Cursor));\n+      else\n+         Ada.Strings.Fixed.Insert\n+           (Buffer,\n+            Cursor + 1,\n+            \"1\");\n+         First_Non_Blank := First_Non_Blank - 1;\n+      end if;\n+   end Increment_Integral_Part;\n+\n    ----------------\n    -- Int_Format --\n    ----------------\n@@ -639,8 +725,8 @@ package body GNAT.Formatted_String is\n          when 'f' | 'F' => F_Spec.Kind := Decimal_Float;\n          when 'e'       => F_Spec.Kind := Decimal_Scientific_Float;\n          when 'E'       => F_Spec.Kind := Decimal_Scientific_Float_Up;\n-         when 'g'       => F_Spec.Kind := Shortest_Decimal_Float;\n-         when 'G'       => F_Spec.Kind := Shortest_Decimal_Float_Up;\n+         when 'g'       => F_Spec.Kind := G_Specifier;\n+         when 'G'       => F_Spec.Kind := G_Specifier_Up;\n          when 'o'       => F_Spec.Kind := Unsigned_Octal;\n          when 'x'       => F_Spec.Kind := Unsigned_Hexadecimal_Int;\n          when 'X'       => F_Spec.Kind := Unsigned_Hexadecimal_Int_Up;\n@@ -677,12 +763,156 @@ package body GNAT.Formatted_String is\n      (Format : Formatted_String;\n       Var    : Flt) return Formatted_String\n    is\n+      procedure Compute_Exponent\n+        (Var      : Flt;\n+         Valid    : out Boolean;\n+         Exponent : out Integer);\n+      --  If Var is invalid (for example, a NaN of an inf), set Valid False and\n+      --  set Exponent to 0. Otherwise, set Valid True, and store the exponent\n+      --  of the scientific notation representation of Var in Exponent. The\n+      --  exponent can also be defined as:\n+      --  - If Var = 0, 0.\n+      --  - Otherwise, Floor (Log_10 (Abs (Var))).\n+\n+      procedure Format_With_Notation\n+        (Var : Flt;\n+         Nota : Notation;\n+         Aft : Text_IO.Field;\n+         Buffer : out String);\n+      --  Fill buffer with the formatted value of Var following the notation\n+      --  specified through Nota.\n+\n+      procedure Handle_G_Specifier\n+        (Buffer          : out String;\n+         First_Non_Blank : out Positive;\n+         Aft             : Text_IO.Field);\n+      --  Fill Buffer with the formatted value of Var according to the rules of\n+      --  the \"%g\" specifier. Buffer is right-justified and padded with blanks.\n+\n+      ----------------------\n+      -- Compute_Exponent --\n+      ----------------------\n+\n+      procedure Compute_Exponent\n+        (Var      : Flt;\n+         Valid    : out Boolean;\n+         Exponent : out Integer)\n+      is\n+         --  The way the exponent is computed is convoluted. It is not possible\n+         --  to use the logarithm in base 10 of Var and floor it, because the\n+         --  math functions for this are not available for fixed point types.\n+         --  Instead, use the generic Put procedure to produce a scientific\n+         --  representation of Var, and parse the exponent part of that back\n+         --  into an Integer.\n+         Scientific_Rep : String (1 .. 50);\n+\n+         E_Position : Natural;\n+      begin\n+         Put (Scientific_Rep, Var, Aft => 1, Exp => 1);\n+\n+         E_Position := Ada.Strings.Fixed.Index (Scientific_Rep, \"E\");\n+\n+         if E_Position = 0 then\n+            Valid    := False;\n+            Exponent := 0;\n+         else\n+            Valid    := True;\n+            Exponent :=\n+              Integer'Value\n+                (Scientific_Rep (E_Position + 1 .. Scientific_Rep'Last));\n+         end if;\n+      end Compute_Exponent;\n+\n+      --------------------------\n+      -- Format_With_Notation --\n+      --------------------------\n+\n+      procedure Format_With_Notation\n+        (Var : Flt;\n+         Nota : Notation;\n+         Aft : Text_IO.Field;\n+         Buffer : out String)\n+      is\n+         Exp : constant Text_IO.Field :=\n+           (case Nota is when Decimal => 0, when Scientific => 3);\n+      begin\n+         Put (Buffer, Var, Aft, Exp);\n+      end Format_With_Notation;\n+\n+      ------------------------\n+      -- Handle_G_Specifier --\n+      ------------------------\n+\n+      procedure Handle_G_Specifier\n+        (Buffer          : out String;\n+         First_Non_Blank : out Positive;\n+         Aft             : Text_IO.Field)\n+      is\n+         --  There is nothing that is directly equivalent to the \"%g\" specifier\n+         --  in the standard Ada functionality provided by Ada.Text_IO. The\n+         --  procedure Put will still be used, but significant postprocessing\n+         --  will be performed on the output of that procedure.\n+\n+         --  The following code is intended to match the behavior of C's printf\n+         --  for %g, as described by paragraph \"7.21.6.1 The fprintf function\"\n+         --  of the C language specification.\n+\n+         --  As explained in the C specification, we're going to have to make a\n+         --  choice between decimal notation and scientific notation. One of\n+         --  the elements we need in order to make that choice is the value of\n+         --  the exponent in the decimal representation of Var. We will store\n+         --  that value in Exponent.\n+         Exponent : Integer;\n+         Valid    : Boolean;\n+\n+         Nota : Notation;\n+\n+         --  The value of the formal Aft comes from the precision specifier in\n+         --  the format string. For %g, the precision specifier corresponds to\n+         --  the number of significant figures desired, whereas the formal Aft\n+         --  in Put corresponds to the number of digits after the point.\n+         --  Effective_Aft is what will be passed to Put as Aft in order to\n+         --  respect the semantics of %g.\n+         Effective_Aft : Text_IO.Field;\n+\n+         Textual_Rep : String (Buffer'Range);\n+      begin\n+         Compute_Exponent (Var, Valid, Exponent);\n+\n+         Determine_Notation_And_Aft\n+           (Exponent, Aft, Nota, Effective_Aft);\n+\n+         Format_With_Notation (Var, Nota, Effective_Aft, Textual_Rep);\n+\n+         First_Non_Blank := Strings.Fixed.Index_Non_Blank (Textual_Rep);\n+\n+         if not Valid then\n+            null;\n+         elsif Effective_Aft = 0 then\n+            --  Special case: it is possible at this point that Effective_Aft\n+            --  is zero. But when Put is passed zero through Aft, it still\n+            --  outputs one digit after the point. See the reference manual,\n+            --  A.10.9.25.\n+\n+            Remove_Extraneous_Decimal_Digit (Textual_Rep, First_Non_Blank);\n+         else\n+            Trim_Fractional_Part\n+              (Textual_Rep, First_Non_Blank);\n+         end if;\n+\n+         Buffer := Textual_Rep;\n+      end Handle_G_Specifier;\n+\n+      --  Local variables\n+\n       F      : F_Data;\n       Buffer : String (1 .. 50);\n       S, E   : Positive := 1;\n       Start  : Positive;\n       Aft    : Text_IO.Field;\n \n+   --  Start of processing for P_Flt_Format\n+\n    begin\n       Next_Format (Format, F, Start);\n \n@@ -716,36 +946,13 @@ package body GNAT.Formatted_String is\n                  Characters.Handling.To_Lower (Buffer (S .. E));\n             end if;\n \n-         when Shortest_Decimal_Float\n-            | Shortest_Decimal_Float_Up\n+         when G_Specifier\n+            | G_Specifier_Up\n          =>\n-            --  Without exponent\n-\n-            Put (Buffer, Var, Aft, Exp => 0);\n-            S := Strings.Fixed.Index_Non_Blank (Buffer);\n+            Handle_G_Specifier (Buffer, S, Aft);\n             E := Buffer'Last;\n \n-            --  Check with exponent\n-\n-            declare\n-               Buffer2 : String (1 .. 50);\n-               S2, E2  : Positive;\n-\n-            begin\n-               Put (Buffer2, Var, Aft, Exp => 3);\n-               S2 := Strings.Fixed.Index_Non_Blank (Buffer2);\n-               E2 := Buffer2'Last;\n-\n-               --  If with exponent it is shorter, use it\n-\n-               if (E2 - S2) < (E - S) then\n-                  Buffer := Buffer2;\n-                  S := S2;\n-                  E := E2;\n-               end if;\n-            end;\n-\n-            if F.Kind = Shortest_Decimal_Float then\n+            if F.Kind = G_Specifier then\n                Buffer (S .. E) :=\n                  Characters.Handling.To_Lower (Buffer (S .. E));\n             end if;\n@@ -988,4 +1195,74 @@ package body GNAT.Formatted_String is\n         & Positive'Image (Format.D.Current);\n    end Raise_Wrong_Format;\n \n+   -------------------------------------\n+   -- Remove_Extraneous_Decimal_Digit --\n+   -------------------------------------\n+\n+   procedure Remove_Extraneous_Decimal_Digit\n+     (Textual_Rep     : in out String;\n+      First_Non_Blank : in out Positive)\n+   is\n+      Point_Position : constant Positive := Ada.Strings.Fixed.Index\n+        (Textual_Rep,\n+         \".\",\n+         First_Non_Blank);\n+\n+      Integral_Part_Needs_Increment : constant Boolean :=\n+        Textual_Rep (Point_Position + 1) in '5' .. '9';\n+   begin\n+      Ada.Strings.Fixed.Delete\n+        (Textual_Rep,\n+         Point_Position,\n+         Point_Position + 1,\n+         Ada.Strings.Right);\n+\n+      First_Non_Blank := First_Non_Blank + 2;\n+\n+      if Integral_Part_Needs_Increment then\n+         Increment_Integral_Part\n+           (Textual_Rep,\n+            First_Non_Blank,\n+            Last_Digit_Position => Point_Position + 1);\n+      end if;\n+   end Remove_Extraneous_Decimal_Digit;\n+\n+   --------------------------\n+   -- Trim_Fractional_Part --\n+   --------------------------\n+\n+   procedure Trim_Fractional_Part\n+     (Textual_Rep     : in out String;\n+      First_Non_Blank : in out Positive)\n+   is\n+      Cursor : Positive :=\n+        Ada.Strings.Fixed.Index (Textual_Rep, \".\", First_Non_Blank);\n+\n+      First_To_Trim : Positive;\n+      Fractional_Part_Last : Positive;\n+   begin\n+      while Cursor + 1 <= Textual_Rep'Last\n+        and then Textual_Rep (Cursor + 1) in '0' .. '9' loop\n+         Cursor := Cursor + 1;\n+      end loop;\n+\n+      Fractional_Part_Last := Cursor;\n+\n+      while Textual_Rep (Cursor) = '0' loop\n+         Cursor := Cursor - 1;\n+      end loop;\n+\n+      if Textual_Rep (Cursor) = '.' then\n+         Cursor := Cursor - 1;\n+      end if;\n+\n+      First_To_Trim := Cursor + 1;\n+\n+      Ada.Strings.Fixed.Delete\n+        (Textual_Rep, First_To_Trim, Fractional_Part_Last, Ada.Strings.Right);\n+\n+      First_Non_Blank :=\n+        First_Non_Blank + (Fractional_Part_Last - First_To_Trim + 1);\n+   end Trim_Fractional_Part;\n+\n end GNAT.Formatted_String;"}, {"sha": "423d7794c343bb138a92bb60df96adc3e0975f68", "filename": "gcc/ada/libgnat/g-forstr.ads", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/90d3cd03b35147b24091e7eba249fd4ea178082f/gcc%2Fada%2Flibgnat%2Fg-forstr.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/90d3cd03b35147b24091e7eba249fd4ea178082f/gcc%2Fada%2Flibgnat%2Fg-forstr.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-forstr.ads?ref=90d3cd03b35147b24091e7eba249fd4ea178082f", "patch": "@@ -70,8 +70,10 @@\n --    F         Decimal floating point, uppercase\n --    e         Scientific notation (mantissa/exponent), lowercase\n --    E         Scientific notation (mantissa/exponent), uppercase\n---    g         Use the shortest representation: %e or %f\n---    G         Use the shortest representation: %E or %F\n+--    g         Interpret the precision as the number of significant figures,\n+--              choose the most adequate of decimal or scientific notation, and\n+--              trim trailing zeroes and point. Letters are in lowercase.\n+--    G         Same as g, except that letters are in uppercase\n --    c         Character\n --    s         String of characters\n --    p         Pointer address"}]}