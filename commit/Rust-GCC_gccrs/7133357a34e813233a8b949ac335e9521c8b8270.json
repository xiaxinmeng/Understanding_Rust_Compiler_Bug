{"sha": "7133357a34e813233a8b949ac335e9521c8b8270", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzEzMzM1N2EzNGU4MTMyMzNhOGI5NDlhYzMzNWU5NTIxYzhiODI3MA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-05-21T15:42:55Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-05-21T15:42:55Z"}, "message": "typeck.c (build_ptrmemfunc): Handle PTRMEM_CSTs carefully to reveal optimization opportunities.\n\n\t* typeck.c (build_ptrmemfunc): Handle PTRMEM_CSTs carefully to\n\treveal optimization opportunities.\n\nFrom-SVN: r27084", "tree": {"sha": "fc199c8b2911ca2c87554555dd763a57ece65409", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fc199c8b2911ca2c87554555dd763a57ece65409"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7133357a34e813233a8b949ac335e9521c8b8270", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7133357a34e813233a8b949ac335e9521c8b8270", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7133357a34e813233a8b949ac335e9521c8b8270", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7133357a34e813233a8b949ac335e9521c8b8270/comments", "author": null, "committer": null, "parents": [{"sha": "41e0e0cdbb616973f569e53c0e82056469afdd64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41e0e0cdbb616973f569e53c0e82056469afdd64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41e0e0cdbb616973f569e53c0e82056469afdd64"}], "stats": {"total": 49, "additions": 39, "deletions": 10}, "files": [{"sha": "6ff46de2a62f911e7b1b668dd5d1456897b9e59c", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7133357a34e813233a8b949ac335e9521c8b8270/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7133357a34e813233a8b949ac335e9521c8b8270/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=7133357a34e813233a8b949ac335e9521c8b8270", "patch": "@@ -1,5 +1,8 @@\n 1999-05-21  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* typeck.c (build_ptrmemfunc): Handle PTRMEM_CSTs carefully to\n+\treveal optimization opportunities.\n+\n \t* pt.c (tsubst): Don't issue error messages when we're not\n \tcomplaining, even if we see a qualified function type.\n \t(check_cv_quals_for_unify): Don't allow a qualified function"}, {"sha": "17147b909f71014f978569c91adade6990b41d41", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7133357a34e813233a8b949ac335e9521c8b8270/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7133357a34e813233a8b949ac335e9521c8b8270/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=7133357a34e813233a8b949ac335e9521c8b8270", "patch": "@@ -6515,15 +6515,15 @@ build_ptrmemfunc (type, pfn, force)\n      tree type, pfn;\n      int force;\n {\n-  tree idx = integer_zero_node;\n-  tree delta = integer_zero_node;\n-  tree delta2 = integer_zero_node;\n-  tree npfn = NULL_TREE;\n   tree fn;\n   \n   /* Handle multiple conversions of pointer to member functions.  */\n   if (TYPE_PTRMEMFUNC_P (TREE_TYPE (pfn)))\n     {\n+      tree idx = integer_zero_node;\n+      tree delta = integer_zero_node;\n+      tree delta2 = integer_zero_node;\n+      tree npfn = NULL_TREE;\n       tree ndelta, ndelta2;\n       tree e1, e2, e3, n;\n       tree pfn_type;\n@@ -6537,27 +6537,53 @@ build_ptrmemfunc (type, pfn, force)\n \t  && comp_target_types (type, pfn_type, 1) != 1)\n \tcp_error (\"conversion to `%T' from `%T'\", type, pfn_type);\n \n-      ndelta = cp_convert (ptrdiff_type_node, build_component_ref (pfn, delta_identifier, NULL_TREE, 0));\n-      ndelta2 = cp_convert (ptrdiff_type_node, DELTA2_FROM_PTRMEMFUNC (pfn));\n-      idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n+      if (TREE_CODE (pfn) == PTRMEM_CST)\n+\t{\n+\t  /* We could just build the resulting CONSTRUCTOR now, but we\n+\t     don't, relying on the general machinery below, together\n+\t     with constant-folding, to do the right thing.  We don't\n+\t     want to return a PTRMEM_CST here, even though we could,\n+\t     because a pointer-to-member constant ceases to be a\n+\t     constant (from the point of view of the language) when it\n+\t     is cast to another type.  */\n+\n+\t  expand_ptrmemfunc_cst (pfn, &ndelta, &idx, &npfn, &ndelta2);\n+\t  if (npfn)\n+\t    /* This constant points to a non-virtual function.\n+\t       NDELTA2 will be NULL, but it's value doesn't really\n+\t       matter since we won't use it anyhow.  */\n+\t    ndelta2 = integer_zero_node;\n+\t}\n+      else\n+\t{\n+\t  ndelta = cp_convert (ptrdiff_type_node, \n+\t\t\t       build_component_ref (pfn, \n+\t\t\t\t\t\t    delta_identifier, \n+\t\t\t\t\t\t    NULL_TREE, 0));\n+\t  ndelta2 = cp_convert (ptrdiff_type_node, \n+\t\t\t\tDELTA2_FROM_PTRMEMFUNC (pfn));\n+\t  idx = build_component_ref (pfn, index_identifier, NULL_TREE, 0);\n+\t}\n \n       n = get_delta_difference (TYPE_METHOD_BASETYPE (TREE_TYPE (pfn_type)),\n \t\t\t\tTYPE_METHOD_BASETYPE (TREE_TYPE (type)),\n \t\t\t\tforce);\n-\n       delta = build_binary_op (PLUS_EXPR, ndelta, n);\n       delta2 = build_binary_op (PLUS_EXPR, ndelta2, n);\n       e1 = fold (build (GT_EXPR, boolean_type_node, idx, integer_zero_node));\n \t  \n+      /* If it's a virtual function, this is what we want.  */\n       e2 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx,\n \t\t\t      NULL_TREE, delta2);\n \n       pfn = PFN_FROM_PTRMEMFUNC (pfn);\n       npfn = build1 (NOP_EXPR, type, pfn);\n       TREE_CONSTANT (npfn) = TREE_CONSTANT (pfn);\n \n-      e3 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta, idx, npfn,\n-\t\t\t      NULL_TREE);\n+      /* But if it's a non-virtual function, or NULL, we use this\n+\t instead.  */\n+      e3 = build_ptrmemfunc1 (TYPE_GET_PTRMEMFUNC_TYPE (type), delta,\n+\t\t\t      idx, npfn, NULL_TREE);\n       return build_conditional_expr (e1, e2, e3);\n     }\n "}]}