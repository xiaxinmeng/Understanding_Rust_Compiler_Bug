{"sha": "b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNiYTFjMDlhOGIwMTc1MzljMzZhYWQzODY0Y2FkYWIxOWNhMmFiMQ==", "commit": {"author": {"name": "Anatoly Sokolov", "email": "aesok@post.ru", "date": "2015-07-10T21:31:19Z"}, "committer": {"name": "Anatoly Sokolov", "email": "aesok@gcc.gnu.org", "date": "2015-07-10T21:31:19Z"}, "message": "[V850] Hookize GO_IF_LEGITIMATE_ADDRESS\n\nFrom-SVN: r225690", "tree": {"sha": "0b6df089defca1ad9941a68f7f50f5382360e1c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b6df089defca1ad9941a68f7f50f5382360e1c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/comments", "author": null, "committer": null, "parents": [{"sha": "5d85afe92a654f846fed544c176f86c6225eaf1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d85afe92a654f846fed544c176f86c6225eaf1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d85afe92a654f846fed544c176f86c6225eaf1d"}], "stats": {"total": 154, "additions": 72, "deletions": 82}, "files": [{"sha": "e45616eceadb02bdd573b8f1364ea059274011ba", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "patch": "@@ -1,3 +1,12 @@\n+2015-07-10  Anatoly Sokolov  <aesok@post.ru>\n+\n+\t* config/v850/v850.h (REG_OK_FOR_BASE_P, REG_OK_FOR_INDEX_P,\n+\tREG_OK_FOR_BASE_P_STRICT, REG_OK_FOR_INDEX_P_STRICT, STRICT,\n+\tRTX_OK_FOR_BASE_P, GO_IF_LEGITIMATE_ADDRESS): Remove macros.\n+\t* config/v850/v850.c (v850_reg_ok_for_base_, v850_rtx_ok_for_base_p,\n+\tv850_legitimate_address_p): New functions.\n+\t(TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P): Define.\n+\n 2015-07-10  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR target/66819"}, {"sha": "2474e756d47889586b55102d1b75197e8f5b30da", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "patch": "@@ -3078,6 +3078,66 @@ v850_legitimate_constant_p (machine_mode mode ATTRIBUTE_UNUSED, rtx x)\n \t       && !CONST_OK_FOR_K (INTVAL (XEXP (XEXP (x, 0), 1)))));\n }\n \n+/* Helper function for `v850_legitimate_address_p'.  */\n+\n+static bool\n+v850_reg_ok_for_base_p (const_rtx reg, bool strict_p)\n+{\n+  if (strict_p)\n+  {\n+    return REGNO_OK_FOR_BASE_P (REGNO (reg));\n+  } else {\n+    return true;\n+  }\n+}\n+\n+/* Accept either REG or SUBREG where a register is valid.  */\n+\n+static bool\n+v850_rtx_ok_for_base_p (const_rtx x, bool strict_p)\n+{\n+  return ((REG_P (x) && v850_reg_ok_for_base_p  (x, strict_p))\n+\t  || (SUBREG_P (x) && REG_P (SUBREG_REG (x))\n+\t      && v850_reg_ok_for_base_p (SUBREG_REG (x), strict_p)));\n+}\n+\n+/* Implement TARGET_LEGITIMATE_ADDRESS_P.  */\n+\n+static bool\n+v850_legitimate_address_p (machine_mode mode, rtx x, bool strict_p,\n+\t\t\t   addr_space_t as ATTRIBUTE_UNUSED)\n+{\n+  gcc_assert (ADDR_SPACE_GENERIC_P (as));\n+\n+  if (v850_rtx_ok_for_base_p (x, strict_p))\n+    return true;\n+  if (CONSTANT_ADDRESS_P (x)\n+      && (mode == QImode || INTVAL (x) % 2 == 0)\n+      && (GET_MODE_SIZE (mode) <= 4 || INTVAL (x) % 4 == 0))\n+    return true;\n+  if (GET_CODE (x) == LO_SUM\n+      && REG_P (XEXP (x, 0))\n+      && v850_reg_ok_for_base_p (XEXP (x, 0), strict_p)\n+      && CONSTANT_P (XEXP (x, 1))\n+      && (!CONST_INT_P (XEXP (x, 1))\n+\t  || ((mode == QImode || INTVAL (XEXP (x, 1)) % 2 == 0)\n+\t      && constraint_satisfied_p (XEXP (x, 1), CONSTRAINT_K)))\n+      && GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode))\n+    return true;\n+  if (special_symbolref_operand (x, mode)\n+      && (GET_MODE_SIZE (mode) <= GET_MODE_SIZE (word_mode)))\n+    return true;\n+  if (GET_CODE (x) == PLUS\n+      && v850_rtx_ok_for_base_p (XEXP (x, 0), strict_p)\n+      && constraint_satisfied_p (XEXP (x,1), CONSTRAINT_K)\n+      && ((mode == QImode || INTVAL (XEXP (x, 1)) % 2 == 0)\n+\t   && CONST_OK_FOR_K (INTVAL (XEXP (x, 1))\n+\t\t\t      + (GET_MODE_NUNITS (mode) * UNITS_PER_WORD))))\n+    return true;\n+\n+  return false;  \n+}\n+\n static int\n v850_memory_move_cost (machine_mode mode,\n \t\t       reg_class_t reg_class ATTRIBUTE_UNUSED,\n@@ -3280,6 +3340,9 @@ v850_gen_movdi (rtx * operands)\n #undef  TARGET_LEGITIMATE_CONSTANT_P\n #define TARGET_LEGITIMATE_CONSTANT_P v850_legitimate_constant_p\n \n+#undef  TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P\n+#define TARGET_ADDR_SPACE_LEGITIMATE_ADDRESS_P v850_legitimate_address_p\n+\n #undef  TARGET_CAN_USE_DOLOOP_P\n #define TARGET_CAN_USE_DOLOOP_P can_use_doloop_if_innermost\n "}, {"sha": "dcc169bcdfdd099e2b416ca8e1dd72d0a9b8e6c0", "filename": "gcc/config/v850/v850.h", "status": "modified", "additions": 0, "deletions": 82, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2Fconfig%2Fv850%2Fv850.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3ba1c09a8b017539c36aad3864cadab19ca2ab1/gcc%2Fconfig%2Fv850%2Fv850.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.h?ref=b3ba1c09a8b017539c36aad3864cadab19ca2ab1", "patch": "@@ -592,88 +592,6 @@ struct cum_arg { int nbytes; };\n /* Maximum number of registers that can appear in a valid memory address.  */\n \n #define MAX_REGS_PER_ADDRESS 1\n-\n-/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n-   and check its validity for a certain class.\n-   We have two alternate definitions for each of them.\n-   The usual definition accepts all pseudo regs; the other rejects\n-   them unless they have been allocated suitable hard regs.\n-   The symbol REG_OK_STRICT causes the latter definition to be used.\n-\n-   Most source files want to accept pseudo regs in the hope that\n-   they will get allocated to the class that the insn wants them to be in.\n-   Source files for reload pass need to be strict.\n-   After reload, it makes no difference, since pseudo regs have\n-   been eliminated by then.  */\n-\n-#ifndef REG_OK_STRICT\n-\n-/* Nonzero if X is a hard reg that can be used as an index\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_INDEX_P(X) 0\n-/* Nonzero if X is a hard reg that can be used as a base reg\n-   or if it is a pseudo reg.  */\n-#define REG_OK_FOR_BASE_P(X) 1\n-#define REG_OK_FOR_INDEX_P_STRICT(X) 0\n-#define REG_OK_FOR_BASE_P_STRICT(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define STRICT 0\n-\n-#else\n-\n-/* Nonzero if X is a hard reg that can be used as an index.  */\n-#define REG_OK_FOR_INDEX_P(X) 0\n-/* Nonzero if X is a hard reg that can be used as a base reg.  */\n-#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n-#define STRICT 1\n-\n-#endif\n-\n-\f\n-/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n-   that is a valid memory address for an instruction.\n-   The MODE argument is the machine mode for the MEM expression\n-   that wants to use this address.\n-\n-   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n-   except for CONSTANT_ADDRESS_P which is actually\n-   machine-independent.  */\n-\n-/* Accept either REG or SUBREG where a register is valid.  */\n-  \n-#define RTX_OK_FOR_BASE_P(X)\t\t\t\t\t\t\\\n-  ((REG_P (X) && REG_OK_FOR_BASE_P (X))\t\t\t\t\t\\\n-   || (GET_CODE (X) == SUBREG && REG_P (SUBREG_REG (X))\t\t\t\\\n-       && REG_OK_FOR_BASE_P (SUBREG_REG (X))))\n-\n-#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\t\\\n-  if (RTX_OK_FOR_BASE_P (X)) \t\t\t\t\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (CONSTANT_ADDRESS_P (X)\t\t\t\t\t\t\\\n-      && (MODE == QImode || INTVAL (X) % 2 == 0)\t\t\t\\\n-      && (GET_MODE_SIZE (MODE) <= 4 || INTVAL (X) % 4 == 0))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == LO_SUM\t\t\t\t\t\t\\\n-      && REG_P (XEXP (X, 0))\t\t\t\t\t\t\\\n-      && REG_OK_FOR_BASE_P (XEXP (X, 0))\t\t\t\t\\\n-      && CONSTANT_P (XEXP (X, 1))\t\t\t\t\t\\\n-      && (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n-\t  || ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n-\t      && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)))))\t\t\\\n-      && GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode))\t\t\\\n-    goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (special_symbolref_operand (X, MODE)\t\t\t\t\\\n-      && (GET_MODE_SIZE (MODE) <= GET_MODE_SIZE (word_mode)))\t\t\\\n-     goto ADDR;\t\t\t\t\t\t\t\t\\\n-  if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n-      && RTX_OK_FOR_BASE_P (XEXP (X, 0)) \t\t\t\t\\\n-      && constraint_satisfied_p (XEXP (X,1), CONSTRAINT_K)\t\t\\\n-      && ((MODE == QImode || INTVAL (XEXP (X, 1)) % 2 == 0)\t\t\\\n-\t   && CONST_OK_FOR_K (INTVAL (XEXP (X, 1)) \t\t\t\\\n-                              + (GET_MODE_NUNITS (MODE) * UNITS_PER_WORD)))) \\\n-    goto ADDR;\t\t\t\\\n-} while (0)\n-\n \f\n /* Given a comparison code (EQ, NE, etc.) and the first operand of a COMPARE,\n    return the mode to be used for the comparison."}]}