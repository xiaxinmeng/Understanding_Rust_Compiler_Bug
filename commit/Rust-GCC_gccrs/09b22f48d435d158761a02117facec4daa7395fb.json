{"sha": "09b22f48d435d158761a02117facec4daa7395fb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDliMjJmNDhkNDM1ZDE1ODc2MWEwMjExN2ZhY2VjNGRhYTczOTVmYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-01-29T11:02:46Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-01-29T11:02:46Z"}, "message": "re PR middle-end/59917 (ICE in calc_dfs_tree, at dominance.c:401)\n\n\tPR middle-end/59917\n\tPR tree-optimization/59920\n\t* tree.c (build_common_builtin_nodes): Remove\n\t__builtin_setjmp_dispatcher initialization.\n\t* omp-low.h (make_gimple_omp_edges): Add a new int * argument.\n\t* profile.c (branch_prob): Use gsi_start_nondebug_after_labels_bb\n\tinstead of gsi_after_labels + manually skipping debug stmts.\n\tDon't ignore bbs with BUILT_IN_SETJMP_DISPATCHER, instead\n\tignore bbs with IFN_ABNORMAL_DISPATCHER.\n\t* tree-inline.c (copy_edges_for_bb): Remove\n\tcan_make_abnormal_goto argument, instead add abnormal_goto_dest\n\targument.  Ignore computed_goto_p stmts.  Don't call\n\tmake_abnormal_goto_edges.  If a call might need abnormal edges\n\tfor non-local gotos, see if it already has an edge to\n\tIFN_ABNORMAL_DISPATCHER or if it is IFN_ABNORMAL_DISPATCHER\n\twith true argument, don't do anything then, otherwise add\n\tEDGE_ABNORMAL from the call's bb to abnormal_goto_dest.\n\t(copy_cfg_body): Compute abnormal_goto_dest, adjust copy_edges_for_bb\n\tcaller.\n\t* gimple-low.c (struct lower_data): Remove calls_builtin_setjmp.\n\t(lower_function_body): Don't emit __builtin_setjmp_dispatcher.\n\t(lower_stmt): Don't set data->calls_builtin_setjmp.\n\t(lower_builtin_setjmp): Adjust comment.\n\t* builtins.def (BUILT_IN_SETJMP_DISPATCHER): Remove.\n\t* tree-cfg.c (found_computed_goto): Remove.\n\t(factor_computed_gotos): Remove.\n\t(make_goto_expr_edges): Return bool, true for computed gotos.\n\tDon't call make_abnormal_goto_edges.\n\t(build_gimple_cfg): Don't set found_computed_goto, don't call\n\tfactor_computed_gotos.\n\t(computed_goto_p): No longer static.\n\t(make_blocks): Don't set found_computed_goto.\n\t(get_abnormal_succ_dispatcher, handle_abnormal_edges): New functions.\n\t(make_edges): If make_goto_expr_edges returns true, push bb\n\tinto ab_edge_goto vector, for stmt_can_make_abnormal_goto calls\n\tinstead of calling make_abnormal_goto_edges push bb into ab_edge_call\n\tvector.  Record mapping between bbs and OpenMP regions if there\n\tare any, adjust make_gimple_omp_edges caller.  Call\n\thandle_abnormal_edges.\n\t(make_abnormal_goto_edges): Remove.\n\t* tree-cfg.h (make_abnormal_goto_edges): Remove.\n\t(computed_goto_p, get_abnormal_succ_dispatcher): New prototypes.\n\t* internal-fn.c (expand_ABNORMAL_DISPATCHER): New function.\n\t* builtins.c (expand_builtin): Don't handle\n\tBUILT_IN_SETJMP_DISPATCHER.\n\t* internal-fn.def (ABNORMAL_DISPATCHER): New.\n\t* omp-low.c (make_gimple_omp_edges): Add region_idx argument, when\n\tfilling *region also set *region_idx to (*region)->entry->index.\n\n\t* gcc.dg/pr59920-1.c: New test.\n\t* gcc.dg/pr59920-2.c: New test.\n\t* gcc.dg/pr59920-3.c: New test.\n\t* c-c++-common/gomp/pr59917-1.c: New test.\n\t* c-c++-common/gomp/pr59917-2.c: New test.\n\nFrom-SVN: r207231", "tree": {"sha": "4b721b57c74c1349afc462b869e17ae0bdb8fa90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b721b57c74c1349afc462b869e17ae0bdb8fa90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/09b22f48d435d158761a02117facec4daa7395fb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b22f48d435d158761a02117facec4daa7395fb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/09b22f48d435d158761a02117facec4daa7395fb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/09b22f48d435d158761a02117facec4daa7395fb/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "42eb8bd17982621ad29ec491053851fd2d0d740e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42eb8bd17982621ad29ec491053851fd2d0d740e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42eb8bd17982621ad29ec491053851fd2d0d740e"}], "stats": {"total": 734, "additions": 499, "deletions": 235}, "files": [{"sha": "14f0cfb6e18c2d7770974a19db2b128d98cd08f7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -1,5 +1,54 @@\n 2014-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/59917\n+\tPR tree-optimization/59920\n+\t* tree.c (build_common_builtin_nodes): Remove\n+\t__builtin_setjmp_dispatcher initialization.\n+\t* omp-low.h (make_gimple_omp_edges): Add a new int * argument.\n+\t* profile.c (branch_prob): Use gsi_start_nondebug_after_labels_bb\n+\tinstead of gsi_after_labels + manually skipping debug stmts.\n+\tDon't ignore bbs with BUILT_IN_SETJMP_DISPATCHER, instead\n+\tignore bbs with IFN_ABNORMAL_DISPATCHER.\n+\t* tree-inline.c (copy_edges_for_bb): Remove\n+\tcan_make_abnormal_goto argument, instead add abnormal_goto_dest\n+\targument.  Ignore computed_goto_p stmts.  Don't call\n+\tmake_abnormal_goto_edges.  If a call might need abnormal edges\n+\tfor non-local gotos, see if it already has an edge to\n+\tIFN_ABNORMAL_DISPATCHER or if it is IFN_ABNORMAL_DISPATCHER\n+\twith true argument, don't do anything then, otherwise add\n+\tEDGE_ABNORMAL from the call's bb to abnormal_goto_dest.\n+\t(copy_cfg_body): Compute abnormal_goto_dest, adjust copy_edges_for_bb\n+\tcaller.\n+\t* gimple-low.c (struct lower_data): Remove calls_builtin_setjmp.\n+\t(lower_function_body): Don't emit __builtin_setjmp_dispatcher.\n+\t(lower_stmt): Don't set data->calls_builtin_setjmp.\n+\t(lower_builtin_setjmp): Adjust comment.\n+\t* builtins.def (BUILT_IN_SETJMP_DISPATCHER): Remove.\n+\t* tree-cfg.c (found_computed_goto): Remove.\n+\t(factor_computed_gotos): Remove.\n+\t(make_goto_expr_edges): Return bool, true for computed gotos.\n+\tDon't call make_abnormal_goto_edges.\n+\t(build_gimple_cfg): Don't set found_computed_goto, don't call\n+\tfactor_computed_gotos.\n+\t(computed_goto_p): No longer static.\n+\t(make_blocks): Don't set found_computed_goto.\n+\t(get_abnormal_succ_dispatcher, handle_abnormal_edges): New functions.\n+\t(make_edges): If make_goto_expr_edges returns true, push bb\n+\tinto ab_edge_goto vector, for stmt_can_make_abnormal_goto calls\n+\tinstead of calling make_abnormal_goto_edges push bb into ab_edge_call\n+\tvector.  Record mapping between bbs and OpenMP regions if there\n+\tare any, adjust make_gimple_omp_edges caller.  Call\n+\thandle_abnormal_edges.\n+\t(make_abnormal_goto_edges): Remove.\n+\t* tree-cfg.h (make_abnormal_goto_edges): Remove.\n+\t(computed_goto_p, get_abnormal_succ_dispatcher): New prototypes.\n+\t* internal-fn.c (expand_ABNORMAL_DISPATCHER): New function.\n+\t* builtins.c (expand_builtin): Don't handle\n+\tBUILT_IN_SETJMP_DISPATCHER.\n+\t* internal-fn.def (ABNORMAL_DISPATCHER): New.\n+\t* omp-low.c (make_gimple_omp_edges): Add region_idx argument, when\n+\tfilling *region also set *region_idx to (*region)->entry->index.\n+\n \tPR other/58712\n \t* read-rtl.c (read_rtx_code): Clear all of RTX_CODE_SIZE (code).\n \tFor REGs set ORIGINAL_REGNO."}, {"sha": "a45380ce8776f482f168803c73d29153092e42ab", "filename": "gcc/builtins.c", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -6205,20 +6205,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \t}\n       break;\n \n-    case BUILT_IN_SETJMP_DISPATCHER:\n-       /* __builtin_setjmp_dispatcher is passed the dispatcher label.  */\n-      if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n-\t{\n-\t  tree label = TREE_OPERAND (CALL_EXPR_ARG (exp, 0), 0);\n-\t  rtx label_r = label_rtx (label);\n-\n-\t  /* Remove the dispatcher label from the list of non-local labels\n-\t     since the receiver labels have been added to it above.  */\n-\t  remove_node_from_expr_list (label_r, &nonlocal_goto_handler_labels);\n-\t  return const0_rtx;\n-\t}\n-      break;\n-\n     case BUILT_IN_SETJMP_RECEIVER:\n        /* __builtin_setjmp_receiver is passed the receiver label.  */\n       if (validate_arglist (exp, POINTER_TYPE, VOID_TYPE))"}, {"sha": "2443a45751b5bfc475a571b7ccc3268dea2fd03e", "filename": "gcc/builtins.def", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -783,7 +783,6 @@ DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, \"__builtin_nonlocal_goto\")\n \n /* Implementing __builtin_setjmp.  */\n DEF_BUILTIN_STUB (BUILT_IN_SETJMP_SETUP, \"__builtin_setjmp_setup\")\n-DEF_BUILTIN_STUB (BUILT_IN_SETJMP_DISPATCHER, \"__builtin_setjmp_dispatcher\")\n DEF_BUILTIN_STUB (BUILT_IN_SETJMP_RECEIVER, \"__builtin_setjmp_receiver\")\n \n /* Implementing variable sized local variables.  */"}, {"sha": "c60e8177d389b263171232d450dde19419d5231d", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 7, "deletions": 44, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -76,9 +76,6 @@ struct lower_data\n \n   /* True if the current statement cannot fall through.  */\n   bool cannot_fallthru;\n-\n-  /* True if the function calls __builtin_setjmp.  */\n-  bool calls_builtin_setjmp;\n };\n \n static void lower_stmt (gimple_stmt_iterator *, struct lower_data *);\n@@ -99,7 +96,6 @@ lower_function_body (void)\n   gimple_seq lowered_body;\n   gimple_stmt_iterator i;\n   gimple bind;\n-  tree t;\n   gimple x;\n \n   /* The gimplifier should've left a body of exactly one statement,\n@@ -146,34 +142,6 @@ lower_function_body (void)\n       gsi_insert_after (&i, t.stmt, GSI_CONTINUE_LINKING);\n     }\n \n-  /* If the function calls __builtin_setjmp, we need to emit the computed\n-     goto that will serve as the unique dispatcher for all the receivers.  */\n-  if (data.calls_builtin_setjmp)\n-    {\n-      tree disp_label, disp_var, arg;\n-\n-      /* Build 'DISP_LABEL:' and insert.  */\n-      disp_label = create_artificial_label (cfun->function_end_locus);\n-      /* This mark will create forward edges from every call site.  */\n-      DECL_NONLOCAL (disp_label) = 1;\n-      cfun->has_nonlocal_label = 1;\n-      x = gimple_build_label (disp_label);\n-      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n-\n-      /* Build 'DISP_VAR = __builtin_setjmp_dispatcher (DISP_LABEL);'\n-\t and insert.  */\n-      disp_var = create_tmp_var (ptr_type_node, \"setjmpvar\");\n-      arg = build_addr (disp_label, current_function_decl);\n-      t = builtin_decl_implicit (BUILT_IN_SETJMP_DISPATCHER);\n-      x = gimple_build_call (t, 1, arg);\n-      gimple_call_set_lhs (x, disp_var);\n-\n-      /* Build 'goto DISP_VAR;' and insert.  */\n-      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n-      x = gimple_build_goto (disp_var);\n-      gsi_insert_after (&i, x, GSI_CONTINUE_LINKING);\n-    }\n-\n   /* Once the old body has been lowered, replace it with the new\n      lowered sequence.  */\n   gimple_set_body (current_function_decl, lowered_body);\n@@ -364,7 +332,6 @@ lower_stmt (gimple_stmt_iterator *gsi, struct lower_data *data)\n \t  {\n \t    lower_builtin_setjmp (gsi);\n \t    data->cannot_fallthru = false;\n-\t    data->calls_builtin_setjmp = true;\n \t    return;\n \t  }\n \n@@ -689,15 +656,12 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n    all will be used on all machines).  It operates similarly to the C\n    library function of the same name, but is more efficient.\n \n-   It is lowered into 3 other builtins, namely __builtin_setjmp_setup,\n-   __builtin_setjmp_dispatcher and __builtin_setjmp_receiver, but with\n-   __builtin_setjmp_dispatcher shared among all the instances; that's\n-   why it is only emitted at the end by lower_function_body.\n+   It is lowered into 2 other builtins, namely __builtin_setjmp_setup,\n+   __builtin_setjmp_receiver.\n \n    After full lowering, the body of the function should look like:\n \n     {\n-      void * setjmpvar.0;\n       int D.1844;\n       int D.2844;\n \n@@ -727,14 +691,13 @@ lower_gimple_return (gimple_stmt_iterator *gsi, struct lower_data *data)\n \n       <D3850>:;\n       return;\n-      <D3853>: [non-local];\n-      setjmpvar.0 = __builtin_setjmp_dispatcher (&<D3853>);\n-      goto setjmpvar.0;\n     }\n \n-   The dispatcher block will be both the unique destination of all the\n-   abnormal call edges and the unique source of all the abnormal edges\n-   to the receivers, thus keeping the complexity explosion localized.  */\n+   During cfg creation an extra per-function (or per-OpenMP region)\n+   block with ABNORMAL_DISPATCHER internal call will be added, unique\n+   destination of all the abnormal call edges and the unique source of\n+   all the abnormal edges to the receivers, thus keeping the complexity\n+   explosion localized.  */\n \n static void\n lower_builtin_setjmp (gimple_stmt_iterator *gsi)"}, {"sha": "43aaecba9718df0d045b4dd2dcb421625284c626", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -857,6 +857,11 @@ expand_MASK_STORE (gimple stmt)\n   expand_insn (optab_handler (maskstore_optab, TYPE_MODE (type)), 3, ops);\n }\n \n+static void\n+expand_ABNORMAL_DISPATCHER (gimple)\n+{\n+}\n+\n /* Routines to expand each internal function, indexed by function number.\n    Each routine has the prototype:\n "}, {"sha": "379b35241b51f263cf6a93999ceba4c7d156c92a", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -51,3 +51,4 @@ DEF_INTERNAL_FN (UBSAN_NULL, ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_ADD, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_SUB, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n DEF_INTERNAL_FN (UBSAN_CHECK_MUL, ECF_CONST | ECF_LEAF | ECF_NOTHROW)\n+DEF_INTERNAL_FN (ABNORMAL_DISPATCHER, ECF_NORETURN)"}, {"sha": "d7589aa9ec14e9b544b5e056966ec437a4028276", "filename": "gcc/omp-low.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -10449,7 +10449,8 @@ diagnose_sb_2 (gimple_stmt_iterator *gsi_p, bool *handled_ops_p,\n /* Called from tree-cfg.c::make_edges to create cfg edges for all GIMPLE_OMP\n    codes.  */\n bool\n-make_gimple_omp_edges (basic_block bb, struct omp_region **region)\n+make_gimple_omp_edges (basic_block bb, struct omp_region **region,\n+\t\t       int *region_idx)\n {\n   gimple last = last_stmt (bb);\n   enum gimple_code code = gimple_code (last);\n@@ -10556,7 +10557,13 @@ make_gimple_omp_edges (basic_block bb, struct omp_region **region)\n     }\n \n   if (*region != cur_region)\n-    *region = cur_region;\n+    {\n+      *region = cur_region;\n+      if (cur_region)\n+\t*region_idx = cur_region->entry->index;\n+      else\n+\t*region_idx = 0;\n+    }\n \n   return fallthru;\n }"}, {"sha": "d80c2d6f5c08566b9025ea48e7ebe698c3984baa", "filename": "gcc/omp-low.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fomp-low.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fomp-low.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.h?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -26,6 +26,6 @@ extern tree find_omp_clause (tree, enum omp_clause_code);\n extern void omp_expand_local (basic_block);\n extern void free_omp_regions (void);\n extern tree omp_reduction_init (tree, tree);\n-extern bool make_gimple_omp_edges (basic_block, struct omp_region **);\n+extern bool make_gimple_omp_edges (basic_block, struct omp_region **, int *);\n \n #endif /* GCC_OMP_LOW_H */"}, {"sha": "752d89fc3d87f3ffaf0fab1f06ebbd77e30ba916", "filename": "gcc/profile.c", "status": "modified", "additions": 7, "deletions": 12, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -1106,27 +1106,22 @@ branch_prob (void)\n \t      gimple first;\n \t      tree fndecl;\n \n-\t      gsi = gsi_after_labels (bb);\n+\t      gsi = gsi_start_nondebug_after_labels_bb (bb);\n \t      gcc_checking_assert (!gsi_end_p (gsi));\n \t      first = gsi_stmt (gsi);\n-\t      if (is_gimple_debug (first))\n-\t\t{\n-\t\t  gsi_next_nondebug (&gsi);\n-\t\t  gcc_checking_assert (!gsi_end_p (gsi));\n-\t\t  first = gsi_stmt (gsi);\n-\t\t}\n \t      /* Don't split the bbs containing __builtin_setjmp_receiver\n-\t\t or __builtin_setjmp_dispatcher calls.  These are very\n+\t\t or ABNORMAL_DISPATCHER calls.  These are very\n \t\t special and don't expect anything to be inserted before\n \t\t them.  */\n \t      if (is_gimple_call (first)\n \t\t  && (((fndecl = gimple_call_fndecl (first)) != NULL\n \t\t       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL\n \t\t       && (DECL_FUNCTION_CODE (fndecl)\n-\t\t\t   == BUILT_IN_SETJMP_RECEIVER\n-\t\t\t   || (DECL_FUNCTION_CODE (fndecl)\n-\t\t\t       == BUILT_IN_SETJMP_DISPATCHER)))\n-\t\t      || gimple_call_flags (first) & ECF_RETURNS_TWICE))\n+\t\t\t   == BUILT_IN_SETJMP_RECEIVER))\n+\t\t      || (gimple_call_flags (first) & ECF_RETURNS_TWICE)\n+\t\t      || (gimple_call_internal_p (first)\n+\t\t\t  && (gimple_call_internal_fn (first)\n+\t\t\t      == IFN_ABNORMAL_DISPATCHER))))\n \t\tcontinue;\n \n \t      if (dump_file)"}, {"sha": "a4684473ab7b1c08e4484301071b157c1fc786a1", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -1,5 +1,13 @@\n 2014-01-29  Jakub Jelinek  <jakub@redhat.com>\n \n+\tPR middle-end/59917\n+\tPR tree-optimization/59920\n+\t* gcc.dg/pr59920-1.c: New test.\n+\t* gcc.dg/pr59920-2.c: New test.\n+\t* gcc.dg/pr59920-3.c: New test.\n+\t* c-c++-common/gomp/pr59917-1.c: New test.\n+\t* c-c++-common/gomp/pr59917-2.c: New test.\n+\n \tPR tree-optimization/59594\n \t* gcc.dg/vect/no-vfa-vect-depend-2.c: New test.\n \t* gcc.dg/vect/no-vfa-vect-depend-3.c: New test."}, {"sha": "cca3976ccb74831a55fa4241f45a27fe6417d25f", "filename": "gcc/testsuite/c-c++-common/gomp/pr59917-1.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-1.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -0,0 +1,22 @@\n+/* PR middle-end/59917 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+struct J { long buf[8]; };\n+extern int setjmp (struct J[1]);\n+extern struct J j[1];\n+void foo (int);\n+\n+void\n+bar (void)\n+{\n+  if (setjmp (j) == 0)\n+    {\n+      int k;\n+      foo (-1);\n+#pragma omp parallel\n+      for (k = 0; k < 10; ++k)\n+\tfoo (k);\n+      foo (-2);\n+    }\n+}"}, {"sha": "1d603422f6640c17cf5fff8da88e28c0c51458f2", "filename": "gcc/testsuite/c-c++-common/gomp/pr59917-2.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Fpr59917-2.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -0,0 +1,22 @@\n+/* PR middle-end/59917 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fopenmp\" } */\n+\n+struct J { long buf[8]; };\n+extern int setjmp (struct J[1]);\n+void foo (int);\n+\n+void\n+bar (void)\n+{\n+  int k;\n+  foo (-1);\n+#pragma omp parallel\n+  for (k = 0; k < 10; ++k)\n+    {\n+      struct J j[1];\n+      if (setjmp (j) == 0)\n+\tfoo (k);\n+    }\n+  foo (-2);\n+}"}, {"sha": "3e60d37ae2050a670b70548d40916a629ce79371", "filename": "gcc/testsuite/gcc.dg/pr59920-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-1.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -0,0 +1,20 @@\n+/* PR tree-optimization/59920 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+#include <setjmp.h>\n+\n+int bar (void);\n+void baz (int);\n+\n+#define A { int x = bar (); if (setjmp (buf) == 0) baz (x); }\n+#define B A A A A A A A A A A\n+#define C B B B B B B B B B B\n+\n+extern jmp_buf buf;\n+\n+void\n+foo (void)\n+{\n+  C C\n+}"}, {"sha": "bee5542748b0cb3c491f064ec900432f117d384a", "filename": "gcc/testsuite/gcc.dg/pr59920-2.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-2.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -0,0 +1,30 @@\n+/* PR tree-optimization/59920 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+void *bar (void **);\n+void *baz (int, void **);\n+\n+#define A(n) \\\n+  { __label__ l1_##n, l2_##n, l3_##n;\t\t\t\\\n+    static void *a[] = { &&l1_##n, &&l2_##n, &&l3_##n };\\\n+    void *b = bar (a);\t\t\t\t\t\\\n+    goto *b;\t\t\t\t\t\t\\\n+   l1_##n:\t\t\t\t\t\t\\\n+    b = baz (1, a);\t\t\t\t\t\\\n+    goto *b;\t\t\t\t\t\t\\\n+   l2_##n:\t\t\t\t\t\t\\\n+    b = baz (2, a);\t\t\t\t\t\\\n+    goto *b;\t\t\t\t\t\t\\\n+   l3_##n:;\t\t\t\t\t\t\\\n+  }\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) \\\n+\t     A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) \\\n+\t     B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)\n+\n+void\n+foo (void)\n+{\n+  C(1)\n+}"}, {"sha": "2159504e363c9af57ee6d0e68668c7fa76bcb892", "filename": "gcc/testsuite/gcc.dg/pr59920-3.c", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr59920-3.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -0,0 +1,47 @@\n+/* PR tree-optimization/59920 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O0\" } */\n+\n+void *bar (void **);\n+void *baz (int, void **);\n+\n+#define A(n) __label__ l##n;\n+#define B(n) A(n##0) A(n##1) A(n##2) A(n##3) A(n##4) \\\n+\t     A(n##5) A(n##6) A(n##7) A(n##8) A(n##9)\n+#define C(n) B(n##0) B(n##1) B(n##2) B(n##3) B(n##4) \\\n+\t     B(n##5) B(n##6) B(n##7) B(n##8) B(n##9)\n+#define D C(1)\n+\n+int\n+foo (void)\n+{\n+  D\n+  int bar (int i)\n+  {\n+    switch (i)\n+      {\n+#undef A\n+#define A(n) \\\n+      case n: goto l##n;\n+      D\n+      }\n+    return i;\n+  }\n+  int w = 0;\n+#undef A\n+#define A(n) int w##n = 0;\n+  D\n+#undef A\n+#define A(n) \\\n+  { l##n:; \t\t\t\t\\\n+    w##n += bar (10000 + n) - 10000;\t\\\n+    w##n += bar (10001 + n) - 10000;\t\\\n+    bar (n + 1);\t\t\t\\\n+    return w##n;\t\t\t\\\n+  }\n+  D\n+#undef A\n+#define A(n) w += w##n;\n+  D\n+  return w;\n+}"}, {"sha": "dfc9b7b4cef14add84b2c8570ff9c57eee3cb8a2", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 234, "deletions": 147, "changes": 381, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -106,9 +106,6 @@ struct cfg_stats_d\n \n static struct cfg_stats_d cfg_stats;\n \n-/* Nonzero if we found a computed goto while building basic blocks.  */\n-static bool found_computed_goto;\n-\n /* Hash table to store last discriminator assigned for each locus.  */\n struct locus_discrim_map\n {\n@@ -148,14 +145,13 @@ static hash_table <locus_discrim_hasher> discriminator_per_locus;\n \n /* Basic blocks and flowgraphs.  */\n static void make_blocks (gimple_seq);\n-static void factor_computed_gotos (void);\n \n /* Edges.  */\n static void make_edges (void);\n static void assign_discriminators (void);\n static void make_cond_expr_edges (basic_block);\n static void make_gimple_switch_edges (basic_block);\n-static void make_goto_expr_edges (basic_block);\n+static bool make_goto_expr_edges (basic_block);\n static void make_gimple_asm_edges (basic_block);\n static edge gimple_redirect_edge_and_branch (edge, basic_block);\n static edge gimple_try_redirect_by_replacing_jump (edge, basic_block);\n@@ -225,17 +221,8 @@ build_gimple_cfg (gimple_seq seq)\n \n   init_empty_tree_cfg ();\n \n-  found_computed_goto = 0;\n   make_blocks (seq);\n \n-  /* Computed gotos are hell to deal with, especially if there are\n-     lots of them with a large number of destinations.  So we factor\n-     them to a common computed goto location before we build the\n-     edge list.  After we convert back to normal form, we will un-factor\n-     the computed gotos since factoring introduces an unwanted jump.  */\n-  if (found_computed_goto)\n-    factor_computed_gotos ();\n-\n   /* Make sure there is always at least one block, even if it's empty.  */\n   if (n_basic_blocks_for_fn (cfun) == NUM_FIXED_BLOCKS)\n     create_empty_bb (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n@@ -385,7 +372,7 @@ make_pass_build_cfg (gcc::context *ctxt)\n \n /* Return true if T is a computed goto.  */\n \n-static bool\n+bool\n computed_goto_p (gimple t)\n {\n   return (gimple_code (t) == GIMPLE_GOTO\n@@ -437,82 +424,6 @@ assert_unreachable_fallthru_edge_p (edge e)\n }\n \n \n-/* Search the CFG for any computed gotos.  If found, factor them to a\n-   common computed goto site.  Also record the location of that site so\n-   that we can un-factor the gotos after we have converted back to\n-   normal form.  */\n-\n-static void\n-factor_computed_gotos (void)\n-{\n-  basic_block bb;\n-  tree factored_label_decl = NULL;\n-  tree var = NULL;\n-  gimple factored_computed_goto_label = NULL;\n-  gimple factored_computed_goto = NULL;\n-\n-  /* We know there are one or more computed gotos in this function.\n-     Examine the last statement in each basic block to see if the block\n-     ends with a computed goto.  */\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n-    {\n-      gimple_stmt_iterator gsi = gsi_last_bb (bb);\n-      gimple last;\n-\n-      if (gsi_end_p (gsi))\n-\tcontinue;\n-\n-      last = gsi_stmt (gsi);\n-\n-      /* Ignore the computed goto we create when we factor the original\n-\t computed gotos.  */\n-      if (last == factored_computed_goto)\n-\tcontinue;\n-\n-      /* If the last statement is a computed goto, factor it.  */\n-      if (computed_goto_p (last))\n-\t{\n-\t  gimple assignment;\n-\n-\t  /* The first time we find a computed goto we need to create\n-\t     the factored goto block and the variable each original\n-\t     computed goto will use for their goto destination.  */\n-\t  if (!factored_computed_goto)\n-\t    {\n-\t      basic_block new_bb = create_empty_bb (bb);\n-\t      gimple_stmt_iterator new_gsi = gsi_start_bb (new_bb);\n-\n-\t      /* Create the destination of the factored goto.  Each original\n-\t\t computed goto will put its desired destination into this\n-\t\t variable and jump to the label we create immediately\n-\t\t below.  */\n-\t      var = create_tmp_var (ptr_type_node, \"gotovar\");\n-\n-\t      /* Build a label for the new block which will contain the\n-\t\t factored computed goto.  */\n-\t      factored_label_decl = create_artificial_label (UNKNOWN_LOCATION);\n-\t      factored_computed_goto_label\n-\t\t= gimple_build_label (factored_label_decl);\n-\t      gsi_insert_after (&new_gsi, factored_computed_goto_label,\n-\t\t\t\tGSI_NEW_STMT);\n-\n-\t      /* Build our new computed goto.  */\n-\t      factored_computed_goto = gimple_build_goto (var);\n-\t      gsi_insert_after (&new_gsi, factored_computed_goto, GSI_NEW_STMT);\n-\t    }\n-\n-\t  /* Copy the original computed goto's destination into VAR.  */\n-\t  assignment = gimple_build_assign (var, gimple_goto_dest (last));\n-\t  gsi_insert_before (&gsi, assignment, GSI_SAME_STMT);\n-\n-\t  /* And re-vector the computed goto to the new destination.  */\n-\t  gimple_goto_set_dest (last, factored_label_decl);\n-\t}\n-    }\n-}\n-\n-\n /* Build a flowgraph for the sequence of stmts SEQ.  */\n \n static void\n@@ -546,9 +457,6 @@ make_blocks (gimple_seq seq)\n \t codes.  */\n       gimple_set_bb (stmt, bb);\n \n-      if (computed_goto_p (stmt))\n-\tfound_computed_goto = true;\n-\n       /* If STMT is a basic block terminator, set START_NEW_BLOCK for the\n \t next iteration.  */\n       if (stmt_ends_bb_p (stmt))\n@@ -666,13 +574,155 @@ fold_cond_expr_cond (void)\n     }\n }\n \n+/* If basic block BB has an abnormal edge to a basic block\n+   containing IFN_ABNORMAL_DISPATCHER internal call, return\n+   that the dispatcher's basic block, otherwise return NULL.  */\n+\n+basic_block\n+get_abnormal_succ_dispatcher (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_EDGE (e, ei, bb->succs)\n+    if ((e->flags & (EDGE_ABNORMAL | EDGE_EH)) == EDGE_ABNORMAL)\n+      {\n+\tgimple_stmt_iterator gsi\n+\t  = gsi_start_nondebug_after_labels_bb (e->dest);\n+\tgimple g = gsi_stmt (gsi);\n+\tif (g\n+\t    && is_gimple_call (g)\n+\t    && gimple_call_internal_p (g)\n+\t    && gimple_call_internal_fn (g) == IFN_ABNORMAL_DISPATCHER)\n+\t  return e->dest;\n+      }\n+  return NULL;\n+}\n+\n+/* Helper function for make_edges.  Create a basic block with\n+   with ABNORMAL_DISPATCHER internal call in it if needed, and\n+   create abnormal edges from BBS to it and from it to FOR_BB\n+   if COMPUTED_GOTO is false, otherwise factor the computed gotos.  */\n+\n+static void\n+handle_abnormal_edges (basic_block *dispatcher_bbs,\n+\t\t       basic_block for_bb, int *bb_to_omp_idx,\n+\t\t       auto_vec<basic_block> *bbs, bool computed_goto)\n+{\n+  basic_block *dispatcher = dispatcher_bbs + (computed_goto ? 1 : 0);\n+  unsigned int idx = 0;\n+  basic_block bb;\n+  bool inner = false;\n+\n+  if (bb_to_omp_idx)\n+    {\n+      dispatcher = dispatcher_bbs + 2 * bb_to_omp_idx[for_bb->index];\n+      if (bb_to_omp_idx[for_bb->index] != 0)\n+\tinner = true;\n+    }\n+\n+  /* If the dispatcher has been created already, then there are basic\n+     blocks with abnormal edges to it, so just make a new edge to\n+     for_bb.  */\n+  if (*dispatcher == NULL)\n+    {\n+      /* Check if there are any basic blocks that need to have\n+\t abnormal edges to this dispatcher.  If there are none, return\n+\t early.  */\n+      if (bb_to_omp_idx == NULL)\n+\t{\n+\t  if (bbs->is_empty ())\n+\t    return;\n+\t}\n+      else\n+\t{\n+\t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n+\t    if (bb_to_omp_idx[bb->index] == bb_to_omp_idx[for_bb->index])\n+\t      break;\n+\t  if (bb == NULL)\n+\t    return;\n+\t}\n+\n+      /* Create the dispatcher bb.  */\n+      *dispatcher = create_basic_block (NULL, NULL, for_bb);\n+      if (computed_goto)\n+\t{\n+\t  /* Factor computed gotos into a common computed goto site.  Also\n+\t     record the location of that site so that we can un-factor the\n+\t     gotos after we have converted back to normal form.  */\n+\t  gimple_stmt_iterator gsi = gsi_start_bb (*dispatcher);\n+\n+\t  /* Create the destination of the factored goto.  Each original\n+\t     computed goto will put its desired destination into this\n+\t     variable and jump to the label we create immediately below.  */\n+\t  tree var = create_tmp_var (ptr_type_node, \"gotovar\");\n+\n+\t  /* Build a label for the new block which will contain the\n+\t     factored computed goto.  */\n+\t  tree factored_label_decl\n+\t    = create_artificial_label (UNKNOWN_LOCATION);\n+\t  gimple factored_computed_goto_label\n+\t    = gimple_build_label (factored_label_decl);\n+\t  gsi_insert_after (&gsi, factored_computed_goto_label, GSI_NEW_STMT);\n+\n+\t  /* Build our new computed goto.  */\n+\t  gimple factored_computed_goto = gimple_build_goto (var);\n+\t  gsi_insert_after (&gsi, factored_computed_goto, GSI_NEW_STMT);\n+\n+\t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n+\t    {\n+\t      if (bb_to_omp_idx\n+\t\t  && bb_to_omp_idx[bb->index] != bb_to_omp_idx[for_bb->index])\n+\t\tcontinue;\n+\n+\t      gsi = gsi_last_bb (bb);\n+\t      gimple last = gsi_stmt (gsi);\n+\n+\t      gcc_assert (computed_goto_p (last));\n+\n+\t      /* Copy the original computed goto's destination into VAR.  */\n+\t      gimple assignment\n+\t\t= gimple_build_assign (var, gimple_goto_dest (last));\n+\t      gsi_insert_before (&gsi, assignment, GSI_SAME_STMT);\n+\n+\t      edge e = make_edge (bb, *dispatcher, EDGE_FALLTHRU);\n+\t      e->goto_locus = gimple_location (last);\n+\t      gsi_remove (&gsi, true);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree arg = inner ? boolean_true_node : boolean_false_node;\n+\t  gimple g = gimple_build_call_internal (IFN_ABNORMAL_DISPATCHER,\n+\t\t\t\t\t\t 1, arg);\n+\t  gimple_stmt_iterator gsi = gsi_after_labels (*dispatcher);\n+\t  gsi_insert_after (&gsi, g, GSI_NEW_STMT);\n+\n+\t  /* Create predecessor edges of the dispatcher.  */\n+\t  FOR_EACH_VEC_ELT (*bbs, idx, bb)\n+\t    {\n+\t      if (bb_to_omp_idx\n+\t\t  && bb_to_omp_idx[bb->index] != bb_to_omp_idx[for_bb->index])\n+\t\tcontinue;\n+\t      make_edge (bb, *dispatcher, EDGE_ABNORMAL);\n+\t    }\n+\t}\n+    }\n+\n+  make_edge (*dispatcher, for_bb, EDGE_ABNORMAL);\n+}\n+\n /* Join all the blocks in the flowgraph.  */\n \n static void\n make_edges (void)\n {\n   basic_block bb;\n   struct omp_region *cur_region = NULL;\n+  auto_vec<basic_block> ab_edge_goto;\n+  auto_vec<basic_block> ab_edge_call;\n+  int *bb_to_omp_idx = NULL;\n+  int cur_omp_region_idx = 0;\n \n   /* Create an edge from entry to the first block with executable\n      statements in it.  */\n@@ -686,13 +736,17 @@ make_edges (void)\n       gimple last = last_stmt (bb);\n       bool fallthru;\n \n+      if (bb_to_omp_idx)\n+\tbb_to_omp_idx[bb->index] = cur_omp_region_idx;\n+\n       if (last)\n \t{\n \t  enum gimple_code code = gimple_code (last);\n \t  switch (code)\n \t    {\n \t    case GIMPLE_GOTO:\n-\t      make_goto_expr_edges (bb);\n+\t      if (make_goto_expr_edges (bb))\n+\t\tab_edge_goto.safe_push (bb);\n \t      fallthru = false;\n \t      break;\n \t    case GIMPLE_RETURN:\n@@ -720,16 +774,18 @@ make_edges (void)\n \t\t make edges from this call site to all the nonlocal goto\n \t\t handlers.  */\n \t      if (stmt_can_make_abnormal_goto (last))\n-\t\tmake_abnormal_goto_edges (bb, true);\n+\t\tab_edge_call.safe_push (bb);\n \n \t      /* If this statement has reachable exception handlers, then\n \t\t create abnormal edges to them.  */\n \t      make_eh_edges (last);\n \n \t      /* BUILTIN_RETURN is really a return statement.  */\n \t      if (gimple_call_builtin_p (last, BUILT_IN_RETURN))\n-\t\tmake_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0), fallthru =\n-\t     false;\n+\t\t{\n+\t\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+\t\t  fallthru = false;\n+\t\t}\n \t      /* Some calls are known not to return.  */\n \t      else\n \t        fallthru = !(gimple_call_flags (last) & ECF_NORETURN);\n@@ -749,7 +805,10 @@ make_edges (void)\n \t      break;\n \n \t    CASE_GIMPLE_OMP:\n-\t      fallthru = make_gimple_omp_edges (bb, &cur_region);\n+\t      fallthru = make_gimple_omp_edges (bb, &cur_region,\n+\t\t\t\t\t\t&cur_omp_region_idx);\n+\t      if (cur_region && bb_to_omp_idx == NULL)\n+\t\tbb_to_omp_idx = XCNEWVEC (int, n_basic_blocks_for_fn (cfun));\n \t      break;\n \n \t    case GIMPLE_TRANSACTION:\n@@ -773,6 +832,77 @@ make_edges (void)\n \tmake_edge (bb, bb->next_bb, EDGE_FALLTHRU);\n     }\n \n+  /* Computed gotos are hell to deal with, especially if there are\n+     lots of them with a large number of destinations.  So we factor\n+     them to a common computed goto location before we build the\n+     edge list.  After we convert back to normal form, we will un-factor\n+     the computed gotos since factoring introduces an unwanted jump.\n+     For non-local gotos and abnormal edges from calls to calls that return\n+     twice or forced labels, factor the abnormal edges too, by having all\n+     abnormal edges from the calls go to a common artificial basic block\n+     with ABNORMAL_DISPATCHER internal call and abnormal edges from that\n+     basic block to all forced labels and calls returning twice.\n+     We do this per-OpenMP structured block, because those regions\n+     are guaranteed to be single entry single exit by the standard,\n+     so it is not allowed to enter or exit such regions abnormally this way,\n+     thus all computed gotos, non-local gotos and setjmp/longjmp calls\n+     must not transfer control across SESE region boundaries.  */\n+  if (!ab_edge_goto.is_empty () || !ab_edge_call.is_empty ())\n+    {\n+      gimple_stmt_iterator gsi;\n+      basic_block dispatcher_bb_array[2] = { NULL, NULL };\n+      basic_block *dispatcher_bbs = dispatcher_bb_array;\n+      int count = n_basic_blocks_for_fn (cfun);\n+\n+      if (bb_to_omp_idx)\n+\tdispatcher_bbs = XCNEWVEC (basic_block, 2 * count);\n+\n+      FOR_EACH_BB_FN (bb, cfun)\n+\t{\n+\t  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+\t    {\n+\t      gimple label_stmt = gsi_stmt (gsi);\n+\t      tree target;\n+\n+\t      if (gimple_code (label_stmt) != GIMPLE_LABEL)\n+\t\tbreak;\n+\n+\t      target = gimple_label_label (label_stmt);\n+\n+\t      /* Make an edge to every label block that has been marked as a\n+\t\t potential target for a computed goto or a non-local goto.  */\n+\t      if (FORCED_LABEL (target))\n+\t\thandle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n+\t\t\t\t       &ab_edge_goto, true);\n+\t      if (DECL_NONLOCAL (target))\n+\t\t{\n+\t\t  handle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n+\t\t\t\t\t &ab_edge_call, false);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (!gsi_end_p (gsi) && is_gimple_debug (gsi_stmt (gsi)))\n+\t    gsi_next_nondebug (&gsi);\n+\t  if (!gsi_end_p (gsi))\n+\t    {\n+\t      /* Make an edge to every setjmp-like call.  */\n+\t      gimple call_stmt = gsi_stmt (gsi);\n+\t      if (is_gimple_call (call_stmt)\n+\t\t  && ((gimple_call_flags (call_stmt) & ECF_RETURNS_TWICE)\n+\t\t      || gimple_call_builtin_p (call_stmt,\n+\t\t\t\t\t\tBUILT_IN_SETJMP_RECEIVER)))\n+\t\thandle_abnormal_edges (dispatcher_bbs, bb, bb_to_omp_idx,\n+\t\t\t\t       &ab_edge_call, false);\n+\t    }\n+\t}\n+\n+      if (bb_to_omp_idx)\n+\tXDELETE (dispatcher_bbs);\n+    }\n+\n+  XDELETE (bb_to_omp_idx);\n+\n   free_omp_regions ();\n \n   /* Fold COND_EXPR_COND of each COND_EXPR.  */\n@@ -1045,53 +1175,10 @@ label_to_block_fn (struct function *ifun, tree dest)\n   return (*ifun->cfg->x_label_to_block_map)[uid];\n }\n \n-/* Create edges for an abnormal goto statement at block BB.  If FOR_CALL\n-   is true, the source statement is a CALL_EXPR instead of a GOTO_EXPR.  */\n-\n-void\n-make_abnormal_goto_edges (basic_block bb, bool for_call)\n-{\n-  basic_block target_bb;\n-  gimple_stmt_iterator gsi;\n-\n-  FOR_EACH_BB_FN (target_bb, cfun)\n-    {\n-      for (gsi = gsi_start_bb (target_bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-\t{\n-\t  gimple label_stmt = gsi_stmt (gsi);\n-\t  tree target;\n-\n-\t  if (gimple_code (label_stmt) != GIMPLE_LABEL)\n-\t    break;\n-\n-\t  target = gimple_label_label (label_stmt);\n-\n-\t  /* Make an edge to every label block that has been marked as a\n-\t     potential target for a computed goto or a non-local goto.  */\n-\t  if ((FORCED_LABEL (target) && !for_call)\n-\t      || (DECL_NONLOCAL (target) && for_call))\n-\t    {\n-\t      make_edge (bb, target_bb, EDGE_ABNORMAL);\n-\t      break;\n-\t    }\n-\t}\n-      if (!gsi_end_p (gsi)\n-\t  && is_gimple_debug (gsi_stmt (gsi)))\n-\tgsi_next_nondebug (&gsi);\n-      if (!gsi_end_p (gsi))\n-\t{\n-\t  /* Make an edge to every setjmp-like call.  */\n-\t  gimple call_stmt = gsi_stmt (gsi);\n-\t  if (is_gimple_call (call_stmt)\n-\t      && (gimple_call_flags (call_stmt) & ECF_RETURNS_TWICE))\n-\t    make_edge (bb, target_bb, EDGE_ABNORMAL);\n-\t}\n-    }\n-}\n-\n-/* Create edges for a goto statement at block BB.  */\n+/* Create edges for a goto statement at block BB.  Returns true\n+   if abnormal edges should be created.  */\n \n-static void\n+static bool\n make_goto_expr_edges (basic_block bb)\n {\n   gimple_stmt_iterator last = gsi_last_bb (bb);\n@@ -1105,11 +1192,11 @@ make_goto_expr_edges (basic_block bb)\n       edge e = make_edge (bb, label_bb, EDGE_FALLTHRU);\n       e->goto_locus = gimple_location (goto_t);\n       gsi_remove (&last, true);\n-      return;\n+      return false;\n     }\n \n   /* A computed GOTO creates abnormal edges.  */\n-  make_abnormal_goto_edges (bb, false);\n+  return true;\n }\n \n /* Create edges for an asm statement with labels at block BB.  */"}, {"sha": "a115df58b9d5c77f023465c8465080fe2bde8216", "filename": "gcc/tree-cfg.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-cfg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-cfg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.h?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -31,7 +31,6 @@ extern void start_recording_case_labels (void);\n extern void end_recording_case_labels (void);\n extern basic_block label_to_block_fn (struct function *, tree);\n #define label_to_block(t) (label_to_block_fn (cfun, t))\n-extern void make_abnormal_goto_edges (basic_block, bool);\n extern void cleanup_dead_labels (void);\n extern void group_case_labels_stmt (gimple);\n extern void group_case_labels (void);\n@@ -46,7 +45,9 @@ extern void gimple_debug_cfg (int);\n extern void gimple_dump_cfg (FILE *, int);\n extern void dump_cfg_stats (FILE *);\n extern void debug_cfg_stats (void);\n+extern bool computed_goto_p (gimple);\n extern bool stmt_can_make_abnormal_goto (gimple);\n+extern basic_block get_abnormal_succ_dispatcher (basic_block);\n extern bool is_ctrl_stmt (gimple);\n extern bool is_ctrl_altering_stmt (gimple);\n extern bool simple_goto_p (gimple);"}, {"sha": "79a39bca136c71bccea6122fca358c9165e15a89", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 35, "deletions": 7, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -1967,7 +1967,7 @@ update_ssa_across_abnormal_edges (basic_block bb, basic_block ret_bb,\n \n static bool\n copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n-\t\t   bool can_make_abnormal_goto)\n+\t\t   basic_block abnormal_goto_dest)\n {\n   basic_block new_bb = (basic_block) bb->aux;\n   edge_iterator ei;\n@@ -2021,7 +2021,9 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n          into a COMPONENT_REF which doesn't.  If the copy\n          can throw, the original could also throw.  */\n       can_throw = stmt_can_throw_internal (copy_stmt);\n-      nonlocal_goto = stmt_can_make_abnormal_goto (copy_stmt);\n+      nonlocal_goto\n+\t= (stmt_can_make_abnormal_goto (copy_stmt)\n+\t   && !computed_goto_p (copy_stmt));\n \n       if (can_throw || nonlocal_goto)\n \t{\n@@ -2052,9 +2054,26 @@ copy_edges_for_bb (basic_block bb, gcov_type count_scale, basic_block ret_bb,\n       /* If the call we inline cannot make abnormal goto do not add\n          additional abnormal edges but only retain those already present\n \t in the original function body.  */\n-      nonlocal_goto &= can_make_abnormal_goto;\n+      if (abnormal_goto_dest == NULL)\n+\tnonlocal_goto = false;\n       if (nonlocal_goto)\n-\tmake_abnormal_goto_edges (gimple_bb (copy_stmt), true);\n+\t{\n+\t  basic_block copy_stmt_bb = gimple_bb (copy_stmt);\n+\n+\t  if (get_abnormal_succ_dispatcher (copy_stmt_bb))\n+\t    nonlocal_goto = false;\n+\t  /* ABNORMAL_DISPATCHER (1) is for longjmp/setjmp or nonlocal gotos\n+\t     in OpenMP regions which aren't allowed to be left abnormally.\n+\t     So, no need to add abnormal edge in that case.  */\n+\t  else if (is_gimple_call (copy_stmt)\n+\t\t   && gimple_call_internal_p (copy_stmt)\n+\t\t   && (gimple_call_internal_fn (copy_stmt)\n+\t\t       == IFN_ABNORMAL_DISPATCHER)\n+\t\t   && gimple_call_arg (copy_stmt, 0) == boolean_true_node)\n+\t    nonlocal_goto = false;\n+\t  else\n+\t    make_edge (copy_stmt_bb, abnormal_goto_dest, EDGE_ABNORMAL);\n+\t}\n \n       if ((can_throw || nonlocal_goto)\n \t  && gimple_in_ssa_p (cfun))\n@@ -2493,13 +2512,22 @@ copy_cfg_body (copy_body_data * id, gcov_type count, int frequency_scale,\n   last = last_basic_block_for_fn (cfun);\n \n   /* Now that we've duplicated the blocks, duplicate their edges.  */\n-  bool can_make_abormal_goto\n-    = id->gimple_call && stmt_can_make_abnormal_goto (id->gimple_call);\n+  basic_block abnormal_goto_dest = NULL;\n+  if (id->gimple_call\n+      && stmt_can_make_abnormal_goto (id->gimple_call))\n+    {\n+      gimple_stmt_iterator gsi = gsi_for_stmt (id->gimple_call);\n+\n+      bb = gimple_bb (id->gimple_call);\n+      gsi_next (&gsi);\n+      if (gsi_end_p (gsi))\n+\tabnormal_goto_dest = get_abnormal_succ_dispatcher (bb);\n+    }\n   FOR_ALL_BB_FN (bb, cfun_to_copy)\n     if (!id->blocks_to_copy\n \t|| (bb->index > 0 && bitmap_bit_p (id->blocks_to_copy, bb->index)))\n       need_debug_cleanup |= copy_edges_for_bb (bb, count_scale, exit_block_map,\n-\t\t\t\t\t       can_make_abormal_goto);\n+\t\t\t\t\t       abnormal_goto_dest);\n \n   if (new_entry)\n     {"}, {"sha": "5fdd491a97de672dd9c9ec76a77013c04fe9e4a6", "filename": "gcc/tree.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/09b22f48d435d158761a02117facec4daa7395fb/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=09b22f48d435d158761a02117facec4daa7395fb", "patch": "@@ -9977,12 +9977,6 @@ build_common_builtin_nodes (void)\n \t\t\tBUILT_IN_SETJMP_SETUP,\n \t\t\t\"__builtin_setjmp_setup\", ECF_NOTHROW);\n \n-  ftype = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);\n-  local_define_builtin (\"__builtin_setjmp_dispatcher\", ftype,\n-\t\t\tBUILT_IN_SETJMP_DISPATCHER,\n-\t\t\t\"__builtin_setjmp_dispatcher\",\n-\t\t\tECF_PURE | ECF_NOTHROW);\n-\n   ftype = build_function_type_list (void_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_setjmp_receiver\", ftype,\n \t\t\tBUILT_IN_SETJMP_RECEIVER,"}]}