{"sha": "47747e5377c0a560d55b85c0d2494301f78d6df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDc3NDdlNTM3N2MwYTU2MGQ1NWI4NWMwZDI0OTQzMDFmNzhkNmRmMQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@cygnus.com", "date": "1998-04-14T23:50:17Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "1998-04-14T23:50:17Z"}, "message": "alpha.md: Revert Oct 27 change...\n\n* alpha.md: Revert Oct 27 change, as it is superceeded by Kenner's\nNov 8 find_replacement change.  Move decls of get_unaligned_address\n* alpha.h: ... here.\n\nFrom-SVN: r19216", "tree": {"sha": "239f30089ebcbdec67bcf0a8030e9464052abbc4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/239f30089ebcbdec67bcf0a8030e9464052abbc4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47747e5377c0a560d55b85c0d2494301f78d6df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47747e5377c0a560d55b85c0d2494301f78d6df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47747e5377c0a560d55b85c0d2494301f78d6df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47747e5377c0a560d55b85c0d2494301f78d6df1/comments", "author": null, "committer": null, "parents": [{"sha": "7940255dd6ab541b5e6ab7780f151d0ec8af537c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7940255dd6ab541b5e6ab7780f151d0ec8af537c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7940255dd6ab541b5e6ab7780f151d0ec8af537c"}], "stats": {"total": 118, "additions": 30, "deletions": 88}, "files": [{"sha": "a55457324d369d4fca7393ffbeb58c182feb2ec3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=47747e5377c0a560d55b85c0d2494301f78d6df1", "patch": "@@ -1,3 +1,9 @@\n+Tue Apr 14 23:39:13 1998  Richard Henderson  <rth@cygnus.com>\n+\n+\t* alpha.md: Revert Oct 27 change, as it is superceeded by Kenner's\n+\tNov 8 find_replacement change.  Move decls of get_unaligned_address\n+\t* alpha.h: ... here.\n+\n Tue Apr 14 22:00:39 1998  John Carr <jfc@mit.edu>\n \n \t* function.c (assign_parms): Initialize unsignedp before passing"}, {"sha": "7823d1c3224465ea2ea83380339bcb29e9d5ca65", "filename": "gcc/config/alpha/alpha.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2Fconfig%2Falpha%2Falpha.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2Fconfig%2Falpha%2Falpha.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.h?ref=47747e5377c0a560d55b85c0d2494301f78d6df1", "patch": "@@ -2378,3 +2378,7 @@ do {\t\t\t\t\t\t\t\\\n \n /* The system headers under Alpha systems are generally C++-aware.  */\n #define NO_IMPLICIT_EXTERN_C\n+\n+/* Prototypes for alpha.c functions used in the md file.  */\n+extern struct rtx_def *get_unaligned_address ();\n+ "}, {"sha": "f644168b4a1c9bc3dadbfd7dc6d79effed48589f", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 20, "deletions": 88, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47747e5377c0a560d55b85c0d2494301f78d6df1/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=47747e5377c0a560d55b85c0d2494301f78d6df1", "patch": "@@ -1321,8 +1321,7 @@\n \t\t     (const_int 56)))]\n   \"\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n+{\n   if (TARGET_BWX)\n     {\n       emit_insn (gen_extendqidi2x (operands[0],\n@@ -1387,8 +1386,7 @@\n \t\t     (const_int 48)))]\n   \"\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n+{\n   if (TARGET_BWX)\n     {\n       emit_insn (gen_extendhidi2x (operands[0],\n@@ -4487,8 +4485,7 @@\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n+{\n   if (TARGET_BWX)\n     {\n       if (GET_CODE (operands[0]) == MEM\n@@ -4532,18 +4529,6 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  /* ??? This code creates a new MEM rtx.  If we were called during\n-\t     reload, then we must be careful to make sure that the new rtx\n-\t     will not need reloading.  */\n-\t  if (reload_in_progress\n-\t      && GET_CODE (operands[1]) == MEM\n-\t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n-\t    {\n-\t      rtx tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n-\t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n-\t      XEXP (operands[1], 0) = tmp;\n-\t    }\n-\n \t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadqi (operands[0], aligned_mem, bitnum,\n@@ -4611,8 +4596,7 @@\n \t(match_operand:HI 1 \"general_operand\" \"\"))]\n   \"\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n+{\n   if (TARGET_BWX)\n     {\n       if (GET_CODE (operands[0]) == MEM\n@@ -4656,18 +4640,6 @@\n \t\t\t ? gen_rtx_REG (SImode, REGNO (operands[0]))\n \t\t\t : gen_reg_rtx (SImode));\n \n-\t  /* ??? This code creates a new MEM rtx.  If we were called during\n-\t     reload, then we must be careful to make sure that the new rtx\n-\t     will not need reloading.  */\n-\t  if (reload_in_progress\n-\t      && GET_CODE (operands[1]) == MEM\n-\t      && ! strict_memory_address_p (SImode, XEXP (operands[1], 0)))\n-\t    {\n-\t      rtx tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n-\t      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n-\t      XEXP (operands[1], 0) = tmp;\n-\t    }\n-\n \t  get_aligned_mem (operands[1], &aligned_mem, &bitnum);\n \n \t  emit_insn (gen_aligned_loadhi (operands[0], aligned_mem, bitnum,\n@@ -4741,28 +4713,18 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-  rtx addr, scratch, seq, tmp;\n+{\n+  rtx addr = get_unaligned_address (operands[1], 0);\n \n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  scratch = gen_rtx_REG (DImode,\n-\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n-\n-  /* We must be careful to make sure that the new rtx won't need reloading.  */\n-  if (GET_CODE (operands[1]) == MEM &&\n-      ! strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n-    {\n-      tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n-      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n-      XEXP (operands[1], 0) = tmp;\n-    }\n-  addr = get_unaligned_address (operands[1], 0);\n+  rtx scratch = gen_rtx_REG (DImode,\n+\t\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n \n-  seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n-\t\t\t      gen_rtx_REG (DImode, REGNO (operands[0])));\n+  rtx seq = gen_unaligned_loadqi (operands[0], addr, scratch,\n+\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4775,28 +4737,18 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-  rtx scratch, seq, tmp, addr;\n+{\n+  rtx addr = get_unaligned_address (operands[1], 0);\n \n   /* It is possible that one of the registers we got for operands[2]\n      might coincide with that of operands[0] (which is why we made\n      it TImode).  Pick the other one to use as our scratch.  */\n-  scratch = gen_rtx_REG (DImode,\n-\t\t\t REGNO (operands[0]) == REGNO (operands[2]) \n-\t\t\t ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n-\n-  /* We must be careful to make sure that the new rtx won't need reloading.  */\n-  if (GET_CODE (operands[1]) == MEM &&\n-      ! strict_memory_address_p (DImode, XEXP (operands[1], 0)))\n-    {\n-      tmp = gen_rtx_REG (Pmode, REGNO (operands[0]));\n-      emit_insn (gen_move_insn (tmp, XEXP (operands[1], 0)));\n-      XEXP (operands[1], 0) = tmp;\n-    }\n-  addr = get_unaligned_address (operands[1], 0);\n+  rtx scratch = gen_rtx_REG (DImode,\n+\t\t\t     REGNO (operands[0]) == REGNO (operands[2]) \n+\t\t\t     ? REGNO (operands[2]) + 1 : REGNO (operands[2]));\n \n-  seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n-\t\t\t      gen_rtx_REG (DImode, REGNO (operands[0])));\n+  rtx seq = gen_unaligned_loadhi (operands[0], addr, scratch,\n+\t\t\t\t  gen_rtx_REG (DImode, REGNO (operands[0])));\n \n   alpha_set_memflags (seq, operands[1]);\n   emit_insn (seq);\n@@ -4809,17 +4761,7 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n-  /* Note that any_memory_operand allows pseudos during reload.  */\n-  if (GET_CODE (operands[0]) == MEM &&\n-      ! strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n-    {\n-      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n-      emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n-      XEXP (operands[0], 0) = scratch1;\n-    }\n-\n+{\n   if (aligned_memory_operand (operands[0], QImode))\n     {\n       rtx aligned_mem, bitnum;\n@@ -4857,17 +4799,7 @@\n \t      (match_operand:TI 2 \"register_operand\" \"=&r\")])]\n   \"! TARGET_BWX\"\n   \"\n-{ extern rtx get_unaligned_address ();\n-\n-  /* Note that any_memory_operand allows pseudos during reload.  */\n-  if (GET_CODE (operands[0]) == MEM &&\n-      ! strict_memory_address_p (DImode, XEXP (operands[0], 0)))\n-    {\n-      rtx scratch1 = gen_rtx_REG (DImode, REGNO (operands[2]));\n-      emit_insn (gen_move_insn (scratch1, XEXP (operands[0], 0)));\n-      XEXP (operands[0], 0) = scratch1;\n-    }\n-\n+{\n   if (aligned_memory_operand (operands[0], HImode))\n     {\n       rtx aligned_mem, bitnum;"}]}