{"sha": "f65586dcd19846071fd94fed4fb1bf91843887d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjY1NTg2ZGNkMTk4NDYwNzFmZDk0ZmVkNGZiMWJmOTE4NDM4ODdkMQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2014-09-05T08:23:32Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2014-09-05T08:23:32Z"}, "message": "re PR tree-optimization/63148 (r187042 causes auto-vectorization failure for X86 for -m32.)\n\n2014-09-05  Richard Biener  <rguenther@suse.de>\n\n\tPR middle-end/63148\n\t* fold-const.c (try_move_mult_to_index): Remove.\n\t(fold_binary_loc): Do not call it.\n\t* tree-data-ref.c (dr_analyze_indices): Strip conversions\n\tfrom the base object again.\n\n\tc-family/\n\t* c-format.c (check_format_arg): Properly handle\n\teffectively signed POINTER_PLUS_EXPR offset.\n\n\t* gcc.dg/vect/pr63148.c: New testcase.\n\t* c-c++-common/pr19807-1.c: Likewise.\n\t* g++.dg/tree-ssa/pr19807.C: Adjust.\n\t* g++.dg/tree-ssa/tmmti-2.C: Remove.\n\nFrom-SVN: r214941", "tree": {"sha": "8e4e5406e368bf468ff117207d295e346a08f02a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e4e5406e368bf468ff117207d295e346a08f02a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f65586dcd19846071fd94fed4fb1bf91843887d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65586dcd19846071fd94fed4fb1bf91843887d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f65586dcd19846071fd94fed4fb1bf91843887d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f65586dcd19846071fd94fed4fb1bf91843887d1/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "aaea00aa78750b8294842dd07fdf6a426e1c48b2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaea00aa78750b8294842dd07fdf6a426e1c48b2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaea00aa78750b8294842dd07fdf6a426e1c48b2"}], "stats": {"total": 396, "additions": 140, "deletions": 256}, "files": [{"sha": "51c8a08df6907edb526e1492ceacec0a089c489f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -1,3 +1,11 @@\n+2014-09-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/63148\n+\t* fold-const.c (try_move_mult_to_index): Remove.\n+\t(fold_binary_loc): Do not call it.\n+\t* tree-data-ref.c (dr_analyze_indices): Strip conversions\n+\tfrom the base object again.\n+\n 2014-09-05  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/aarch64.md (sibcall_value_insn): Give operand 1"}, {"sha": "4f2cdd1d72eaa41d62ff6366a360a2ccb5ad463c", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -1,3 +1,9 @@\n+2014-09-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/63148\n+\t* c-format.c (check_format_arg): Properly handle\n+\teffectively signed POINTER_PLUS_EXPR offset.\n+\n 2014-09-04  Manuel L\u00f3pez-Ib\u00e1\u00f1ez  <manu@gcc.gnu.org>\n \n \t* c.opt (Wc90-c99-compat,Wc++-compat,Wcomment,Wendif-labels,"}, {"sha": "6b0bbce84f10477ce73420f9641e31d3111f4152", "filename": "gcc/c-family/c-format.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Fc-family%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Fc-family%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-format.c?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -1473,12 +1473,13 @@ check_format_arg (void *ctx, tree format_tree,\n \t  res->number_non_literal++;\n \t  return;\n \t}\n-      if (!tree_fits_shwi_p (arg1)\n-\t  || (offset = tree_to_shwi (arg1)) < 0)\n+      /* POINTER_PLUS_EXPR offsets are to be interpreted signed.  */\n+      if (!cst_and_fits_in_hwi (arg1))\n \t{\n \t  res->number_non_literal++;\n \t  return;\n \t}\n+      offset = int_cst_value (arg1);\n     }\n   if (TREE_CODE (format_tree) != ADDR_EXPR)\n     {\n@@ -1524,6 +1525,11 @@ check_format_arg (void *ctx, tree format_tree,\n       && tree_fits_shwi_p (TREE_OPERAND (format_tree, 1))\n       && (offset += tree_to_shwi (TREE_OPERAND (format_tree, 1))) >= 0)\n     format_tree = TREE_OPERAND (format_tree, 0);\n+  if (offset < 0)\n+    {\n+      res->number_non_literal++;\n+      return;\n+    }\n   if (TREE_CODE (format_tree) == VAR_DECL\n       && TREE_CODE (TREE_TYPE (format_tree)) == ARRAY_TYPE\n       && (array_init = decl_constant_value (format_tree)) != format_tree"}, {"sha": "d1b59a1efd81ee46910e7971a2f0cd1b6e3e10b0", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 223, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -6829,217 +6829,6 @@ fold_sign_changed_comparison (location_t loc, enum tree_code code, tree type,\n   return fold_build2_loc (loc, code, type, arg0_inner, arg1);\n }\n \n-/* Tries to replace &a[idx] p+ s * delta with &a[idx + delta], if s is\n-   step of the array.  Reconstructs s and delta in the case of s *\n-   delta being an integer constant (and thus already folded).  ADDR is\n-   the address. MULT is the multiplicative expression.  If the\n-   function succeeds, the new address expression is returned.\n-   Otherwise NULL_TREE is returned.  LOC is the location of the\n-   resulting expression.  */\n-\n-static tree\n-try_move_mult_to_index (location_t loc, tree addr, tree op1)\n-{\n-  tree s, delta, step;\n-  tree ref = TREE_OPERAND (addr, 0), pref;\n-  tree ret, pos;\n-  tree itype;\n-  bool mdim = false;\n-\n-  /*  Strip the nops that might be added when converting op1 to sizetype. */\n-  STRIP_NOPS (op1);\n-\n-  /* Canonicalize op1 into a possibly non-constant delta\n-     and an INTEGER_CST s.  */\n-  if (TREE_CODE (op1) == MULT_EXPR)\n-    {\n-      tree arg0 = TREE_OPERAND (op1, 0), arg1 = TREE_OPERAND (op1, 1);\n-\n-      STRIP_NOPS (arg0);\n-      STRIP_NOPS (arg1);\n-\n-      if (TREE_CODE (arg0) == INTEGER_CST)\n-        {\n-          s = arg0;\n-          delta = arg1;\n-        }\n-      else if (TREE_CODE (arg1) == INTEGER_CST)\n-        {\n-          s = arg1;\n-          delta = arg0;\n-        }\n-      else\n-        return NULL_TREE;\n-    }\n-  else if (TREE_CODE (op1) == INTEGER_CST)\n-    {\n-      delta = op1;\n-      s = NULL_TREE;\n-    }\n-  else\n-    {\n-      /* Simulate we are delta * 1.  */\n-      delta = op1;\n-      s = integer_one_node;\n-    }\n-\n-  /* Handle &x.array the same as we would handle &x.array[0].  */\n-  if (TREE_CODE (ref) == COMPONENT_REF\n-      && TREE_CODE (TREE_TYPE (ref)) == ARRAY_TYPE)\n-    {\n-      tree domain;\n-\n-      /* Remember if this was a multi-dimensional array.  */\n-      if (TREE_CODE (TREE_OPERAND (ref, 0)) == ARRAY_REF)\n-\tmdim = true;\n-\n-      domain = TYPE_DOMAIN (TREE_TYPE (ref));\n-      if (! domain)\n-\tgoto cont;\n-      itype = TREE_TYPE (domain);\n-\n-      step = TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (ref)));\n-      if (TREE_CODE (step) != INTEGER_CST)\n-\tgoto cont;\n-\n-      if (s)\n-\t{\n-\t  if (! tree_int_cst_equal (step, s))\n-\t    goto cont;\n-\t}\n-      else\n-\t{\n-\t  /* Try if delta is a multiple of step.  */\n-\t  tree tmp = div_if_zero_remainder (op1, step);\n-\t  if (! tmp)\n-\t    goto cont;\n-\t  delta = tmp;\n-\t}\n-\n-      /* Only fold here if we can verify we do not overflow one\n-\t dimension of a multi-dimensional array.  */\n-      if (mdim)\n-\t{\n-\t  tree tmp;\n-\n-\t  if (!TYPE_MIN_VALUE (domain)\n-\t      || !TYPE_MAX_VALUE (domain)\n-\t      || TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST)\n-\t    goto cont;\n-\n-\t  tmp = fold_binary_loc (loc, PLUS_EXPR, itype,\n-\t\t\t\t fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t   TYPE_MIN_VALUE (domain)),\n-\t\t\t\t fold_convert_loc (loc, itype, delta));\n-\t  if (TREE_CODE (tmp) != INTEGER_CST\n-\t      || tree_int_cst_lt (TYPE_MAX_VALUE (domain), tmp))\n-\t    goto cont;\n-\t}\n-\n-      /* We found a suitable component reference.  */\n-\n-      pref = TREE_OPERAND (addr, 0);\n-      ret = copy_node (pref);\n-      SET_EXPR_LOCATION (ret, loc);\n-\n-      ret = build4_loc (loc, ARRAY_REF, TREE_TYPE (TREE_TYPE (ref)), ret,\n-\t\t\tfold_build2_loc\n-\t\t\t  (loc, PLUS_EXPR, itype,\n-\t\t\t   fold_convert_loc (loc, itype,\n-\t\t\t\t\t     TYPE_MIN_VALUE\n-\t\t\t\t\t       (TYPE_DOMAIN (TREE_TYPE (ref)))),\n-\t\t\t   fold_convert_loc (loc, itype, delta)),\n-\t\t\tNULL_TREE, NULL_TREE);\n-      return build_fold_addr_expr_loc (loc, ret);\n-    }\n-\n-cont:\n-\n-  for (;; ref = TREE_OPERAND (ref, 0))\n-    {\n-      if (TREE_CODE (ref) == ARRAY_REF)\n-\t{\n-\t  tree domain;\n-\n-\t  /* Remember if this was a multi-dimensional array.  */\n-\t  if (TREE_CODE (TREE_OPERAND (ref, 0)) == ARRAY_REF)\n-\t    mdim = true;\n-\n-\t  domain = TYPE_DOMAIN (TREE_TYPE (TREE_OPERAND (ref, 0)));\n-\t  if (! domain)\n-\t    continue;\n-\t  itype = TREE_TYPE (domain);\n-\n-\t  step = array_ref_element_size (ref);\n-\t  if (TREE_CODE (step) != INTEGER_CST)\n-\t    continue;\n-\n-\t  if (s)\n-\t    {\n-\t      if (! tree_int_cst_equal (step, s))\n-                continue;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Try if delta is a multiple of step.  */\n-\t      tree tmp = div_if_zero_remainder (op1, step);\n-\t      if (! tmp)\n-\t\tcontinue;\n-\t      delta = tmp;\n-\t    }\n-\n-\t  /* Only fold here if we can verify we do not overflow one\n-\t     dimension of a multi-dimensional array.  */\n-\t  if (mdim)\n-\t    {\n-\t      tree tmp;\n-\n-\t      if (TREE_CODE (TREE_OPERAND (ref, 1)) != INTEGER_CST\n-\t\t  || !TYPE_MAX_VALUE (domain)\n-\t\t  || TREE_CODE (TYPE_MAX_VALUE (domain)) != INTEGER_CST)\n-\t\tcontinue;\n-\n-\t      tmp = fold_binary_loc (loc, PLUS_EXPR, itype,\n-\t\t\t\t     fold_convert_loc (loc, itype,\n-\t\t\t\t\t\t       TREE_OPERAND (ref, 1)),\n-\t\t\t\t     fold_convert_loc (loc, itype, delta));\n-\t      if (!tmp\n-\t\t  || TREE_CODE (tmp) != INTEGER_CST\n-\t\t  || tree_int_cst_lt (TYPE_MAX_VALUE (domain), tmp))\n-\t\tcontinue;\n-\t    }\n-\n-\t  break;\n-\t}\n-      else\n-\tmdim = false;\n-\n-      if (!handled_component_p (ref))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* We found the suitable array reference.  So copy everything up to it,\n-     and replace the index.  */\n-\n-  pref = TREE_OPERAND (addr, 0);\n-  ret = copy_node (pref);\n-  SET_EXPR_LOCATION (ret, loc);\n-  pos = ret;\n-\n-  while (pref != ref)\n-    {\n-      pref = TREE_OPERAND (pref, 0);\n-      TREE_OPERAND (pos, 0) = copy_node (pref);\n-      pos = TREE_OPERAND (pos, 0);\n-    }\n-\n-  TREE_OPERAND (pos, 1)\n-    = fold_build2_loc (loc, PLUS_EXPR, itype,\n-\t\t       fold_convert_loc (loc, itype, TREE_OPERAND (pos, 1)),\n-\t\t       fold_convert_loc (loc, itype, delta));\n-  return fold_build1_loc (loc, ADDR_EXPR, TREE_TYPE (addr), ret);\n-}\n-\n \n /* Fold A < X && A + 1 > Y to A < X && A >= Y.  Normally A + 1 > Y\n    means A >= Y && A != MAX, but in this case we know that\n@@ -10280,18 +10069,6 @@ fold_binary_loc (location_t loc,\n \treturn fold_build2_loc (loc, PLUS_EXPR, type, arg0,\n \t\t\t    fold_convert_loc (loc, type, arg1));\n \n-     /* Try replacing &a[i1] +p c * i2 with &a[i1 + i2], if c is step\n-\tof the array.  Loop optimizer sometimes produce this type of\n-\texpressions.  */\n-      if (TREE_CODE (arg0) == ADDR_EXPR)\n-\t{\n-\t  tem = try_move_mult_to_index (loc, arg0,\n-\t\t\t\t\tfold_convert_loc (loc,\n-\t\t\t\t\t\t\t  ssizetype, arg1));\n-\t  if (tem)\n-\t    return fold_convert_loc (loc, type, tem);\n-\t}\n-\n       return NULL_TREE;\n \n     case PLUS_EXPR:"}, {"sha": "af842fd08a87dfed1ec28edf45a927c1f190cab6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -1,3 +1,11 @@\n+2014-09-05  Richard Biener  <rguenther@suse.de>\n+\n+\tPR middle-end/63148\n+\t* gcc.dg/vect/pr63148.c: New testcase.\n+\t* c-c++-common/pr19807-1.c: Likewise.\n+\t* g++.dg/tree-ssa/pr19807.C: Adjust.\n+\t* g++.dg/tree-ssa/tmmti-2.C: Remove.\n+\n 2014-09-05  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR target/55701"}, {"sha": "92ee2245bfde84043f7c0c4b63f5186f2abc7873", "filename": "gcc/testsuite/c-c++-common/pr19807-1.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr19807-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr19807-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fpr19807-1.c?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do link } */\n+\n+extern void link_error(void);\n+int main()\n+{\n+  int a[4];\n+  if (&a[2]-1 != &a[1])\n+    link_error();\n+  return 0;\n+}"}, {"sha": "8d7807050dee372932cb8cb00ac25b57068597ad", "filename": "gcc/testsuite/g++.dg/tree-ssa/pr19807.C", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpr19807.C?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -11,20 +11,17 @@ void foo(void)\n \tz = 1 + &a[1];\n }\n \n+/* { dg-final { scan-tree-dump-times \"&MEM\\\\\\[\\\\\\(void .\\\\\\)&a \\\\\\+ 8B\\\\\\]\" 3 \"optimized\" } } */\n+\n+\n void bar(int i)\n {\n \tx = &a[i] - 1;\n \ty = &a[i] + 1;\n \tz = 1 + &a[i];\n }\n \n-/* { dg-final { scan-tree-dump-times \"&a\\\\\\[2\\\\\\]\" 3 \"optimized\" } } */\n-\n-/* We want &a[D.bla + 1] and &a[D.foo - 1] in the final code, but\n-   tuples mean that the offset is calculated in a separate instruction.\n-   Simply test for the existence of +1 and -1 once, which also ensures\n-   the above.  If the addition/subtraction would be applied to the\n-   pointer we would instead see +-4 (or 8, depending on sizeof(int)).  */\n-/* { dg-final { scan-tree-dump \"\\\\\\+ (0x0f*|18446744073709551615|4294967295|-1);\" \"optimized\" } } */\n-/* { dg-final { scan-tree-dump-times \"\\\\\\+ 1;\" 1 \"optimized\" } } */\n+/* We can't get &a[i +- 1] in the final code and it is not clear we\n+   want this.  Instead we get to see &a[i] and pointer offsetting\n+   by 4 and -4U.  */\n /* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "808b5ab275dec4c2a9a7bf66afaeb1ef7a5fc2db", "filename": "gcc/testsuite/g++.dg/tree-ssa/tmmti-2.C", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaea00aa78750b8294842dd07fdf6a426e1c48b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaea00aa78750b8294842dd07fdf6a426e1c48b2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Ftmmti-2.C?ref=aaea00aa78750b8294842dd07fdf6a426e1c48b2", "patch": "@@ -1,22 +0,0 @@\n-/* { dg-do compile } */\n-/* { dg-options { -O -fdump-tree-optimized } } */\n-\n-int a[4][8];\n-\n-int foo(long i)\n-{\n-\treturn *(&a[0][0] + i*8); // a[i][0]\n-}\n-\n-struct Foo { double x, y; };\n-\n-Foo b[4];\n-\n-double bar(long i)\n-{\n-\treturn *(&b[0].x + i*2); // b[i].x\n-}\n-\n-/* { dg-final { scan-tree-dump \"a\\\\\\[.*i.*\\\\\\]\\\\\\[0\\\\\\]\" \"optimized\" { xfail *-*-* } } } */\n-/* { dg-final { scan-tree-dump \"b\\\\\\[.*i.*\\\\\\].x\" \"optimized\" } } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "4967a0d73d4f7b6a1244fc194646b0357ed50afd", "filename": "gcc/testsuite/gcc.dg/vect/pr63148.c", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr63148.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr63148.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr63148.c?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -0,0 +1,93 @@\n+/* { dg-do run } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Extracted from MultiSource/Benchmarks/TSVC/tsc.inc\n+   From LLVM test-suite */\n+\n+#define N 40\n+\n+int dummy(double[N], double[N], double[N], double[N]);\n+\n+double array[256*256] __attribute__((aligned(32)));\n+\n+double x[N] __attribute__((aligned(32)));\n+double temp;\n+int temp_int;\n+struct GlobalData\n+{\n+  __attribute__((aligned(32))) double a[N];\n+  int pad1[3];\n+  __attribute__((aligned(32))) double b[N];\n+  int pad2[5];\n+  __attribute__((aligned(32))) double c[N];\n+  int pad3[7];\n+  __attribute__((aligned(32))) double d[N];\n+  int pad4[11];\n+} global_data;\n+\n+__attribute__((aligned(32))) double * const a = global_data.a;\n+__attribute__((aligned(32))) double * const b = global_data.b;\n+__attribute__((aligned(32))) double * const c = global_data.c;\n+__attribute__((aligned(32))) double * const d = global_data.d;\n+\n+void init(void);\n+void check(double *_a, double *_b);\n+int s221(void)\n+{\n+  int i;\n+\n+  init();\n+  for (i = 1; i < N; i++)\n+    {\n+      a[i] += c[i] * d[i];\n+      b[i] = b[i - 1] + a[i] + d[i];\n+    }\n+  check(a, b);\n+  return 0;\n+}\n+\n+int set1d(double arr[N], double value)\n+{\n+  int i;\n+\n+  for (i = 0; i < N; i++) {\n+    arr[i] = value;\n+  }\n+  return 0;\n+}\n+\n+void init(void)\n+{\n+  set1d(a, 1);\n+  set1d(b, 2);\n+  set1d(c, 3);\n+  set1d(d, 4);\n+}\n+\n+void abort(void);\n+\n+void check(double *_a, double *_b)\n+{\n+  int i;\n+\n+  double suma = 0;\n+  double sumb = 0;\n+  for (i = 0; i < N; i++){\n+    suma += _a[i];\n+    sumb += _b[i];\n+  }\n+  if (suma != 508)\n+    abort();\n+  if (sumb != 13340.00)\n+    abort();\n+}\n+\n+int main(int argc, char *argv[])\n+{\n+  check_vect ();\n+  s221();\n+  return 0;\n+}\n+\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */"}, {"sha": "89aeb30c1e57ad265dc0b5ef421d9cd23f88841a", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f65586dcd19846071fd94fed4fb1bf91843887d1/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=f65586dcd19846071fd94fed4fb1bf91843887d1", "patch": "@@ -962,6 +962,7 @@ dr_analyze_indices (struct data_reference *dr, loop_p nest, loop_p loop)\n \t  orig_type = TREE_TYPE (base);\n \t  STRIP_USELESS_TYPE_CONVERSION (base);\n \t  split_constant_offset (base, &base, &off);\n+\t  STRIP_USELESS_TYPE_CONVERSION (base);\n \t  /* Fold the MEM_REF offset into the evolutions initial\n \t     value to make more bases comparable.  */\n \t  if (!integer_zerop (memoff))"}]}