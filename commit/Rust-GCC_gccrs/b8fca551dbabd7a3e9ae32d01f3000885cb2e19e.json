{"sha": "b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjhmY2E1NTFkYmFiZDdhM2U5YWUzMmQwMWYzMDAwODg1Y2IyZTE5ZQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2007-01-08T23:07:44Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2007-01-08T23:07:44Z"}, "message": "tree.h (force_fit_type_double): Export.\n\n2007-01-08  Richard Guenther  <rguenther@suse.de>\n\n\t* tree.h (force_fit_type_double): Export.\n\t(force_fit_type): Remove.\n\t* fold-const.c (force_fit_type_double): New function.\n\t(force_fit_type): Remove.\n\t(int_const_binop): Use it.\n\t(fold_convert_const_int_from_int): Likewise.\n\t(fold_convert_const_int_from_real): Likewise.\n\t(fold_div_compare): Likewise.\n\t(fold_sign_changed_comparison): Likewise.\n\t(fold_unary): Likewise.\n\t(fold_negate_const): Likewise.\n\t(fold_abs_const): Likewise. \n\t(fold_not_const): Likewise.\n\t* c-common.c (shorten_compare): Use force_fit_type_double.\n\t* convert.c (convert_to_pointer): Likewise.\n\nFrom-SVN: r120597", "tree": {"sha": "b906bda57fe5b087786f0082a6716e47d14d48b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b906bda57fe5b087786f0082a6716e47d14d48b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2ac7cbb53296e6006d7c113d81175dd455fd570b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ac7cbb53296e6006d7c113d81175dd455fd570b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ac7cbb53296e6006d7c113d81175dd455fd570b"}], "stats": {"total": 189, "additions": 100, "deletions": 89}, "files": [{"sha": "13ac72f9b724398cad817554f08440d6c65d280c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "patch": "@@ -1,3 +1,21 @@\n+2007-01-08  Richard Guenther  <rguenther@suse.de>\n+\n+\t* tree.h (force_fit_type_double): Export.\n+\t(force_fit_type): Remove.\n+\t* fold-const.c (force_fit_type_double): New function.\n+\t(force_fit_type): Remove.\n+\t(int_const_binop): Use it.\n+\t(fold_convert_const_int_from_int): Likewise.\n+\t(fold_convert_const_int_from_real): Likewise.\n+\t(fold_div_compare): Likewise.\n+\t(fold_sign_changed_comparison): Likewise.\n+\t(fold_unary): Likewise.\n+\t(fold_negate_const): Likewise.\n+\t(fold_abs_const): Likewise. \n+\t(fold_not_const): Likewise.\n+\t* c-common.c (shorten_compare): Use force_fit_type_double.\n+\t* convert.c (convert_to_pointer): Likewise.\n+\n 2007-01-08  Richard Guenther  <rguenther@suse.de>\n \n \t* tree.h (build_int_cst_wide_type): Export."}, {"sha": "c1661b23a3da91554db977b30e7d5a0ac7aeac1e", "filename": "gcc/c-common.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "patch": "@@ -2316,12 +2316,11 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n \t{\n \t  /* Convert primop1 to target type, but do not introduce\n \t     additional overflow.  We know primop1 is an int_cst.  */\n-\t  tree tmp = build_int_cst_wide (*restype_ptr,\n-\t\t\t\t\t TREE_INT_CST_LOW (primop1),\n-\t\t\t\t\t TREE_INT_CST_HIGH (primop1));\n-\n-\t  primop1 = force_fit_type (tmp, 0, TREE_OVERFLOW (primop1),\n-\t\t\t\t    TREE_CONSTANT_OVERFLOW (primop1));\n+\t  primop1 = force_fit_type_double (*restype_ptr,\n+\t\t\t\t\t   TREE_INT_CST_LOW (primop1),\n+\t\t\t\t\t   TREE_INT_CST_HIGH (primop1), 0,\n+\t\t\t\t\t   TREE_OVERFLOW (primop1),\n+\t\t\t\t\t   TREE_CONSTANT_OVERFLOW (primop1));\n \t}\n       if (type != *restype_ptr)\n \t{"}, {"sha": "11d84921849c19b718b7c85d4fe0546dd4a99dda", "filename": "gcc/convert.c", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "patch": "@@ -44,14 +44,10 @@ convert_to_pointer (tree type, tree expr)\n   if (TREE_TYPE (expr) == type)\n     return expr;\n \n+  /* Propagate overflow to the NULL pointer.  */\n   if (integer_zerop (expr))\n-    {\n-      tree t = build_int_cst (type, 0);\n-      if (TREE_OVERFLOW (expr) || TREE_CONSTANT_OVERFLOW (expr))\n-\tt = force_fit_type (t, 0, TREE_OVERFLOW (expr),\n-\t\t\t    TREE_CONSTANT_OVERFLOW (expr));\n-      return t;\n-    }\n+    return force_fit_type_double (type, 0, 0, 0, TREE_OVERFLOW (expr),\n+\t\t\t\t  TREE_CONSTANT_OVERFLOW (expr));\n \n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {"}, {"sha": "9e1eae31918951da1a66ac53194eca1594937515", "filename": "gcc/fold-const.c", "status": "modified", "additions": 72, "deletions": 75, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "patch": "@@ -263,7 +263,9 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n   return l1 != low0 || h1 != high0;\n }\n \n-/* T is an INT_CST node.  OVERFLOWABLE indicates if we are interested\n+/* We force the double-int HIGH:LOW to the range of the type TYPE by\n+   sign or zero extending it.\n+   OVERFLOWABLE indicates if we are interested\n    in overflow of the value, when >0 we are only interested in signed\n    overflow, for <0 we are interested in any overflow.  OVERFLOWED\n    indicates whether overflow has already occurred.  CONST_OVERFLOWED\n@@ -276,50 +278,54 @@ fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n    We set TREE_CONSTANT_OVERFLOWED if,\n         CONST_OVERFLOWED is nonzero\n \tor we set TREE_OVERFLOWED.\n-  We return either the original T, or a copy.  */\n+   We return a new tree node for the extended double-int.  The node\n+   is shared if no overflow flags are set.  */\n \n tree\n-force_fit_type (tree t, int overflowable,\n-\t\tbool overflowed, bool overflowed_const)\n+force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n+\t\t       HOST_WIDE_INT high, int overflowable,\n+\t\t       bool overflowed, bool overflowed_const)\n {\n-  unsigned HOST_WIDE_INT low;\n-  HOST_WIDE_INT high;\n   int sign_extended_type;\n   bool overflow;\n \n-  gcc_assert (TREE_CODE (t) == INTEGER_CST);\n-\n   /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (TREE_TYPE (t))\n-\t\t\t|| (TREE_CODE (TREE_TYPE (t)) == INTEGER_TYPE\n-\t\t\t    && TYPE_IS_SIZETYPE (TREE_TYPE (t))));\n-\n-  low = TREE_INT_CST_LOW (t);\n-  high = TREE_INT_CST_HIGH (t);\n+  sign_extended_type = (!TYPE_UNSIGNED (type)\n+\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n+\t\t\t    && TYPE_IS_SIZETYPE (type)));\n \n-  overflow = fit_double_type (low, high, &low, &high, TREE_TYPE (t));\n+  overflow = fit_double_type (low, high, &low, &high, type);\n \n-  /* If the value changed, return a new node.  */\n+  /* If we need to set overflow flags, return a new unshared node.  */\n   if (overflowed || overflowed_const || overflow)\n     {\n-      t = build_int_cst_wide (TREE_TYPE (t), low, high);\n-\n       if (overflowed\n \t  || overflowable < 0\n \t  || (overflowable > 0 && sign_extended_type))\n \t{\n-\t  t = copy_node (t);\n+          tree t = make_node (INTEGER_CST);\n+          TREE_INT_CST_LOW (t) = low;\n+          TREE_INT_CST_HIGH (t) = high;\n+          TREE_TYPE (t) = type;\n \t  TREE_OVERFLOW (t) = 1;\n \t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\n+\t  return t;\n \t}\n       else if (overflowed_const)\n \t{\n-\t  t = copy_node (t);\n+          tree t = make_node (INTEGER_CST);\n+          TREE_INT_CST_LOW (t) = low;\n+          TREE_INT_CST_HIGH (t) = high;\n+          TREE_TYPE (t) = type;\n \t  TREE_CONSTANT_OVERFLOW (t) = 1;\n+\n+\t  return t;\n \t}\n     }\n \n-  return t;\n+  /* Else build a shared node.  */\n+  return build_int_cst_wide (type, low, high);\n }\n \f\n /* Add two doubleword integers with doubleword result.\n@@ -1601,10 +1607,10 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n       return NULL_TREE;\n     }\n \n-  t = build_int_cst_wide (TREE_TYPE (arg1), low, hi);\n-\n   if (notrunc)\n     {\n+      t = build_int_cst_wide (TREE_TYPE (arg1), low, hi);\n+\n       /* Propagate overflow flags ourselves.  */\n       if (((!uns || is_sizetype) && overflow)\n \t  | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2))\n@@ -1620,11 +1626,11 @@ int_const_binop (enum tree_code code, tree arg1, tree arg2, int notrunc)\n \t}\n     }\n   else\n-    t = force_fit_type (t, 1,\n-\t\t\t((!uns || is_sizetype) && overflow)\n-\t\t\t| TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n-\t\t\tTREE_CONSTANT_OVERFLOW (arg1)\n-\t\t\t| TREE_CONSTANT_OVERFLOW (arg2));\n+    t = force_fit_type_double (TREE_TYPE (arg1), low, hi, 1,\n+\t\t\t       ((!uns || is_sizetype) && overflow)\n+\t\t\t       | TREE_OVERFLOW (arg1) | TREE_OVERFLOW (arg2),\n+\t\t\t       TREE_CONSTANT_OVERFLOW (arg1)\n+\t\t\t       | TREE_CONSTANT_OVERFLOW (arg2));\n \n   return t;\n }\n@@ -1896,18 +1902,16 @@ fold_convert_const_int_from_int (tree type, tree arg1)\n \n   /* Given an integer constant, make new constant with new type,\n      appropriately sign-extended or truncated.  */\n-  t = build_int_cst_wide (type, TREE_INT_CST_LOW (arg1),\n-\t\t\t  TREE_INT_CST_HIGH (arg1));\n-\n-  t = force_fit_type (t,\n-\t\t      /* Don't set the overflow when\n-\t\t      \t converting a pointer  */\n-\t\t      !POINTER_TYPE_P (TREE_TYPE (arg1)),\n-\t\t      (TREE_INT_CST_HIGH (arg1) < 0\n-\t\t       && (TYPE_UNSIGNED (type)\n-\t\t\t   < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n-\t\t      | TREE_OVERFLOW (arg1),\n-\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n+  t = force_fit_type_double (type, TREE_INT_CST_LOW (arg1),\n+\t\t\t     TREE_INT_CST_HIGH (arg1),\n+\t\t             /* Don't set the overflow when\n+\t\t      \t\tconverting a pointer  */\n+\t\t\t     !POINTER_TYPE_P (TREE_TYPE (arg1)),\n+\t\t\t     (TREE_INT_CST_HIGH (arg1) < 0\n+\t\t \t      && (TYPE_UNSIGNED (type)\n+\t\t\t\t  < TYPE_UNSIGNED (TREE_TYPE (arg1))))\n+\t\t\t     | TREE_OVERFLOW (arg1),\n+\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n \n   return t;\n }\n@@ -1985,10 +1989,9 @@ fold_convert_const_int_from_real (enum tree_code code, tree type, tree arg1)\n   if (! overflow)\n     REAL_VALUE_TO_INT (&low, &high, r);\n \n-  t = build_int_cst_wide (type, low, high);\n-\n-  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg1),\n-\t\t      TREE_CONSTANT_OVERFLOW (arg1));\n+  t = force_fit_type_double (type, low, high, -1,\n+\t\t\t     overflow | TREE_OVERFLOW (arg1),\n+\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n   return t;\n }\n \n@@ -6172,8 +6175,8 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t   TREE_INT_CST_LOW (arg1),\n \t\t\t\t   TREE_INT_CST_HIGH (arg1),\n \t\t\t\t   &lpart, &hpart, unsigned_p);\n-  prod = build_int_cst_wide (TREE_TYPE (arg00), lpart, hpart);\n-  prod = force_fit_type (prod, -1, overflow, false);\n+  prod = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n+\t\t\t\t-1, overflow, false);\n   neg_overflow = false;\n \n   if (unsigned_p)\n@@ -6188,9 +6191,9 @@ fold_div_compare (enum tree_code code, tree type, tree arg0, tree arg1)\n \t\t\t\t       TREE_INT_CST_LOW (tmp),\n \t\t\t\t       TREE_INT_CST_HIGH (tmp),\n \t\t\t\t       &lpart, &hpart, unsigned_p);\n-      hi = build_int_cst_wide (TREE_TYPE (arg00), lpart, hpart);\n-      hi = force_fit_type (hi, -1, overflow | TREE_OVERFLOW (prod),\n-\t\t\t   TREE_CONSTANT_OVERFLOW (prod));\n+      hi = force_fit_type_double (TREE_TYPE (arg00), lpart, hpart,\n+\t\t\t\t  -1, overflow | TREE_OVERFLOW (prod),\n+\t\t\t\t  TREE_CONSTANT_OVERFLOW (prod));\n     }\n   else if (tree_int_cst_sgn (arg01) >= 0)\n     {\n@@ -6589,7 +6592,7 @@ static tree\n fold_sign_changed_comparison (enum tree_code code, tree type,\n \t\t\t      tree arg0, tree arg1)\n {\n-  tree arg0_inner, tmp;\n+  tree arg0_inner;\n   tree inner_type, outer_type;\n \n   if (TREE_CODE (arg0) != NOP_EXPR\n@@ -6624,14 +6627,10 @@ fold_sign_changed_comparison (enum tree_code code, tree type,\n     return NULL_TREE;\n \n   if (TREE_CODE (arg1) == INTEGER_CST)\n-    {\n-      tmp = build_int_cst_wide (inner_type,\n-\t\t\t\tTREE_INT_CST_LOW (arg1),\n-\t\t\t\tTREE_INT_CST_HIGH (arg1));\n-      arg1 = force_fit_type (tmp, 0,\n-\t\t\t     TREE_OVERFLOW (arg1),\n-\t\t\t     TREE_CONSTANT_OVERFLOW (arg1));\n-    }\n+    arg1 = force_fit_type_double (inner_type, TREE_INT_CST_LOW (arg1),\n+\t\t\t\t  TREE_INT_CST_HIGH (arg1), 0,\n+\t\t\t\t  TREE_OVERFLOW (arg1),\n+\t\t\t\t  TREE_CONSTANT_OVERFLOW (arg1));\n   else\n     arg1 = fold_convert (inner_type, arg1);\n \n@@ -7563,10 +7562,10 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t    }\n \t  if (change)\n \t    {\n-\t      tem = build_int_cst_wide (type, TREE_INT_CST_LOW (and1),\n-\t\t\t\t\tTREE_INT_CST_HIGH (and1));\n-\t      tem = force_fit_type (tem, 0, TREE_OVERFLOW (and1),\n-\t\t\t\t    TREE_CONSTANT_OVERFLOW (and1));\n+\t      tem = force_fit_type_double (type, TREE_INT_CST_LOW (and1),\n+\t\t\t\t\t   TREE_INT_CST_HIGH (and1), 0,\n+\t\t\t\t\t   TREE_OVERFLOW (and1),\n+\t\t\t\t\t   TREE_CONSTANT_OVERFLOW (and1));\n \t      return fold_build2 (BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert (type, and0), tem);\n \t    }\n@@ -13056,11 +13055,10 @@ fold_negate_const (tree arg0, tree type)\n \tint overflow = neg_double (TREE_INT_CST_LOW (arg0),\n \t\t\t\t   TREE_INT_CST_HIGH (arg0),\n \t\t\t\t   &low, &high);\n-\tt = build_int_cst_wide (type, low, high);\n-\tt = force_fit_type (t, 1,\n-\t\t\t    (overflow | TREE_OVERFLOW (arg0))\n-\t\t\t    && !TYPE_UNSIGNED (type),\n-\t\t\t    TREE_CONSTANT_OVERFLOW (arg0));\n+\tt = force_fit_type_double (type, low, high, 1,\n+\t\t\t\t   (overflow | TREE_OVERFLOW (arg0))\n+\t\t\t\t   && !TYPE_UNSIGNED (type),\n+\t\t\t\t   TREE_CONSTANT_OVERFLOW (arg0));\n \tbreak;\n       }\n \n@@ -13104,9 +13102,9 @@ fold_abs_const (tree arg0, tree type)\n \t  int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n \t\t\t\t     TREE_INT_CST_HIGH (arg0),\n \t\t\t\t     &low, &high);\n-\t  t = build_int_cst_wide (type, low, high);\n-\t  t = force_fit_type (t, -1, overflow | TREE_OVERFLOW (arg0),\n-\t\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n+\t  t = force_fit_type_double (type, low, high, -1,\n+\t\t\t\t     overflow | TREE_OVERFLOW (arg0),\n+\t\t\t\t     TREE_CONSTANT_OVERFLOW (arg0));\n \t}\n       break;\n \n@@ -13134,11 +13132,10 @@ fold_not_const (tree arg0, tree type)\n \n   gcc_assert (TREE_CODE (arg0) == INTEGER_CST);\n \n-  t = build_int_cst_wide (type,\n-\t\t\t  ~ TREE_INT_CST_LOW (arg0),\n-\t\t\t  ~ TREE_INT_CST_HIGH (arg0));\n-  t = force_fit_type (t, 0, TREE_OVERFLOW (arg0),\n-\t\t      TREE_CONSTANT_OVERFLOW (arg0));\n+  t = force_fit_type_double (type, ~TREE_INT_CST_LOW (arg0),\n+\t\t\t     ~TREE_INT_CST_HIGH (arg0), 0,\n+\t\t\t     TREE_OVERFLOW (arg0),\n+\t\t\t     TREE_CONSTANT_OVERFLOW (arg0));\n \n   return t;\n }"}, {"sha": "2e3c087fa3122b93c78e2b9ce6269ee210f6485b", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b8fca551dbabd7a3e9ae32d01f3000885cb2e19e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=b8fca551dbabd7a3e9ae32d01f3000885cb2e19e", "patch": "@@ -4321,7 +4321,8 @@ extern tree fold_ignored_result (tree);\n extern tree fold_abs_const (tree, tree);\n extern tree fold_indirect_ref_1 (tree, tree);\n \n-extern tree force_fit_type (tree, int, bool, bool);\n+extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t   int, bool, bool);\n \n extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, tree);"}]}