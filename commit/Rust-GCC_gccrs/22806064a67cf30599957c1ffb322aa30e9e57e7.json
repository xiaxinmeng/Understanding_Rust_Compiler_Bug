{"sha": "22806064a67cf30599957c1ffb322aa30e9e57e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI4MDYwNjRhNjdjZjMwNTk5OTU3YzFmZmIzMjJhYTMwZTllNTdlNw==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-15T22:41:21Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2021-09-15T22:41:21Z"}, "message": "c++: shortcut bad convs during overload resolution, part 2 [PR101904]\n\nThe r12-3346 change makes us avoid computing excess argument conversions\nduring overload resolution, but only when it turns out there's a\nstrictly viable candidate in the overload set.  If there's no such\ncandidate then we still need to compute more conversions than strictly\nnecessary because subsequent conversions after the first bad conversion\ncan turn a non-strictly viable candidate into an unviable one, and that\naffects the outcome of overload resolution and the behavior of its\ncallers (because of -fpermissive).\n\nBut at least in a SFINAE context, the distinction between a non-strictly\nviable and an unviable candidate shouldn't matter all that much since\nperforming a bad conversion is always an error (even with -fpermissive),\nand so forming a call to a non-strictly viable candidate will end up\nbeing a SFINAE error anyway, just like in the unviable case.  Hence a\nnon-strictly viable candidate is effectively unviable (in a SFINAE\ncontext), and we don't really need to distinguish between the two kinds.\nWe can take advantage of this observation to avoid computing excess\nargument conversions even when there's no strictly viable candidate in\nthe overload set.\n\nThis patch implements this idea.  We usually detect a SFINAE context by\nlooking for the absence of the tf_error flag, but that's not specific\nenough: we can also get here from build_user_type_conversion with\ntf_error cleared, and there the distinction between a non-strictly\nviable candidate and an unviable candidate still matters (it determines\nwhether a user-defined conversion is bad or just doesn't exist).  So this\npatch sets and checks for the tf_conv flag to detect this situation too,\nwhich avoids regressing conv2.C below.\n\nUnlike the previous change, this one does affect the outcome of overload\nresolution, but it should do so only in a way that preserves backwards\ncompatibility with -fpermissive.\n\n\tPR c++/101904\n\ngcc/cp/ChangeLog:\n\n\t* call.c (build_user_type_conversion_1): Add tf_conv to complain.\n\t(add_candidates): When in a SFINAE context, instead of adding a\n\tcandidate to bad_fns just mark it unviable.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/ext/conv2.C: New test.\n\t* g++.dg/template/conv17.C: Extend test.", "tree": {"sha": "63443dba89c13e6f2da87be743c7f4552c476ceb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/63443dba89c13e6f2da87be743c7f4552c476ceb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22806064a67cf30599957c1ffb322aa30e9e57e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22806064a67cf30599957c1ffb322aa30e9e57e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22806064a67cf30599957c1ffb322aa30e9e57e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22806064a67cf30599957c1ffb322aa30e9e57e7/comments", "author": null, "committer": null, "parents": [{"sha": "f5ae6447bd8a551689021e8884726f1d0d077ec2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5ae6447bd8a551689021e8884726f1d0d077ec2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5ae6447bd8a551689021e8884726f1d0d077ec2"}], "stats": {"total": 37, "additions": 35, "deletions": 2}, "files": [{"sha": "c5601d96ab84d0739be90baa73af4a54f677e0b2", "filename": "gcc/cp/call.c", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=22806064a67cf30599957c1ffb322aa30e9e57e7", "patch": "@@ -4175,6 +4175,9 @@ build_user_type_conversion_1 (tree totype, tree expr, int flags,\n   flags |= LOOKUP_NO_CONVERSION;\n   if (BRACE_ENCLOSED_INITIALIZER_P (expr))\n     flags |= LOOKUP_NO_NARROWING;\n+  /* Prevent add_candidates from treating a non-strictly viable candidate\n+     as unviable.  */\n+  complain |= tf_conv;\n \n   /* It's OK to bind a temporary for converting constructor arguments, but\n      not in converting the return value of a conversion operator.  */\n@@ -6232,8 +6235,18 @@ add_candidates (tree fns, tree first_arg, const vec<tree, va_gc> *args,\n \t     stopped at the first bad conversion).  Add the function to BAD_FNS\n \t     to fully reconsider later if we don't find any strictly viable\n \t     candidates.  */\n-\t  bad_fns = lookup_add (fn, bad_fns);\n-\t  *candidates = (*candidates)->next;\n+\t  if (complain & (tf_error | tf_conv))\n+\t    {\n+\t      bad_fns = lookup_add (fn, bad_fns);\n+\t      *candidates = (*candidates)->next;\n+\t    }\n+\t  else\n+\t    /* But if we're in a SFINAE context, just mark this candidate as\n+\t       unviable outright and avoid potentially reconsidering it.\n+\t       This is safe to do because in a SFINAE context, performing a bad\n+\t       conversion is always an error (even with -fpermissive), so a\n+\t       non-strictly viable candidate is effectively unviable anyway.  */\n+\t    cand->viable = 0;\n \t}\n     }\n   if (which == non_templates && !seen_perfect)"}, {"sha": "baf2a43b2ae66348ee7d8842c825f6922642ee53", "filename": "gcc/testsuite/g++.dg/ext/conv2.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fconv2.C?ref=22806064a67cf30599957c1ffb322aa30e9e57e7", "patch": "@@ -0,0 +1,13 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-additional-options \"-fpermissive\" }\n+\n+struct A {\n+  A(int*, int);\n+};\n+\n+void f(A);\n+\n+int main() {\n+  const int n = 0;\n+  f({&n, 42}); // { dg-warning \"invalid conversion from 'const int\\\\*' to 'int\\\\*'\" }\n+}"}, {"sha": "f0f10f2ef4f1a8831ff2c211613e4d1db41620c8", "filename": "gcc/testsuite/g++.dg/template/conv17.C", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22806064a67cf30599957c1ffb322aa30e9e57e7/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv17.C?ref=22806064a67cf30599957c1ffb322aa30e9e57e7", "patch": "@@ -53,4 +53,11 @@ concept D = requires (const T t) {\n };\n \n static_assert(D<C>);\n+\n+// Test that when there's no strictly viable candidate and we're in a\n+// SFINAE context, we still stop at the first bad argument conversion.\n+template<class T>\n+concept E = requires { T().h(nullptr); };\n+\n+static_assert(!E<C>);\n #endif"}]}