{"sha": "6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ3MGU2YmVlMGRjNmU5ZDBhZDU1MmVlNzA3ODFhZTg0NzJiNTM0YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-05-11T19:21:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-05-11T19:21:32Z"}, "message": "coverage.h (coverage_counter_alloc): New function.\n\n\t* coverage.h (coverage_counter_alloc): New function.\n\t* function.h (struct function): Remove arc_profile flag.\n\t* coverage.c (fn_ident): Remove.\n\t(fn_b_ctrs, no_coverage): New.\n\t(get_coverage_counts): Use current_function_funcdef_no.\n\t(coverage_counter_alloc): New.\n\t(coverage_counter_ref): Adjust.\n\t(coverage_begin_output): Check no_coverage. Use\n\tcurrent_function_funcdef_no.\n\t(coverage_end_function): Likewise.\n\t(create_coverage): Set no_coverage. Set DECL_UNINLINEABLE rather\n\tthan clearing flag_inline_functions. Do not clear arc_profile\n\tflag.\n\t* function.c (prepare_function_start): Do not set arc_profile\n\tflag.\n\t* profile.c (instrument_edges): Return number of instrumented\n\tedges. Use a for loop.\n\t(branch_prob): Call coverage_counter_alloc. Make BB_TO_GCOV_INDEX\n\tlocal to here and simplify. Use profile_arc_flag not arc_profile\n\tflag.\n\t(find_spanning_tree): Reformat.\n\t* toplev.c (rest_of_compilation): Use profile_arc_flags and\n\tflag_test_coverage rather than arc_profile flag.\n\nFrom-SVN: r66695", "tree": {"sha": "7bb4591d4cb260837d08eabc2712f9e7d5068a6f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bb4591d4cb260837d08eabc2712f9e7d5068a6f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/comments", "author": null, "committer": null, "parents": [{"sha": "afb19ffb2929b64f49194b671adf7c02abcb4e76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afb19ffb2929b64f49194b671adf7c02abcb4e76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afb19ffb2929b64f49194b671adf7c02abcb4e76"}], "stats": {"total": 196, "additions": 127, "deletions": 69}, "files": [{"sha": "f9104ce0cf6beb2b8957ee2261c4479077d545ab", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -1,3 +1,29 @@\n+2003-05-11  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* coverage.h (coverage_counter_alloc): New function.\n+\t* function.h (struct function): Remove arc_profile flag.\n+\t* coverage.c (fn_ident): Remove.\n+\t(fn_b_ctrs, no_coverage): New.\n+\t(get_coverage_counts): Use current_function_funcdef_no.\n+\t(coverage_counter_alloc): New.\n+\t(coverage_counter_ref): Adjust.\n+\t(coverage_begin_output): Check no_coverage. Use\n+\tcurrent_function_funcdef_no.\n+\t(coverage_end_function): Likewise.\n+\t(create_coverage): Set no_coverage. Set DECL_UNINLINEABLE rather\n+\tthan clearing flag_inline_functions. Do not clear arc_profile\n+\tflag.\n+\t* function.c (prepare_function_start): Do not set arc_profile\n+\tflag.\n+\t* profile.c (instrument_edges): Return number of instrumented\n+\tedges. Use a for loop.\n+\t(branch_prob): Call coverage_counter_alloc. Make BB_TO_GCOV_INDEX\n+\tlocal to here and simplify. Use profile_arc_flag not arc_profile\n+\tflag.\n+\t(find_spanning_tree): Reformat.\n+\t* toplev.c (rest_of_compilation): Use profile_arc_flags and\n+\tflag_test_coverage rather than arc_profile flag.\n+\n 2003-05-11  Gabriel Dos Reis <gdr@integrable-solutions.net>\n \n \t* doc/invoke.texi (Wctor-dtor-privacy): Update documentation."}, {"sha": "5926a7ea7a5a22ab44062238340283a42540ed97", "filename": "gcc/coverage.c", "status": "modified", "additions": 42, "deletions": 33, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -72,17 +72,18 @@ typedef struct counts_entry\n   \n } counts_entry_t;\n \n-static unsigned fn_ident = 1;\n static struct function_list *functions_head = 0;\n static struct function_list **functions_tail = &functions_head;\n+static unsigned no_coverage = 0;\n \n /* Cumulative counter information for whole program.  */\n static unsigned prg_ctr_mask; /* Mask of counter types generated.  */\n-static unsigned prg_n_ctrs[GCOV_COUNTERS];\n+static unsigned prg_n_ctrs[GCOV_COUNTERS]; /* Total counters allocated.  */\n \n /* Counter information for current function.  */\n-static unsigned fn_ctr_mask;\n-static unsigned fn_n_ctrs[GCOV_COUNTERS];\n+static unsigned fn_ctr_mask; /* Mask of counters used. */\n+static unsigned fn_n_ctrs[GCOV_COUNTERS]; /* Counters allocated.  */\n+static unsigned fn_b_ctrs[GCOV_COUNTERS]; /* Allocation base.  */\n \n /* Name of the output file for coverage output file.  */\n static char *bbg_file_name;\n@@ -313,7 +314,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n       return NULL;\n     }\n \n-  elt.ident = fn_ident;\n+  elt.ident = current_function_funcdef_no + 1;\n   elt.ctr = counter;\n   entry = htab_find (counts_hash, &elt);\n   if (!entry)\n@@ -337,15 +338,18 @@ get_coverage_counts (unsigned counter, unsigned expected,\n   return entry->counts;\n }\n \n-/* Generate a MEM rtl to access COUNTER NO .  */\n+/* Allocate NUM counters of type COUNTER. Returns non-zero if the\n+   allocation succeeded.  */\n \n-rtx\n-coverage_counter_ref (unsigned counter, unsigned no)\n+int\n+coverage_counter_alloc (unsigned counter, unsigned num)\n {\n-  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n-  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n-  rtx ref;\n-\n+  if (no_coverage)\n+    return 0;\n+  \n+  if (!num)\n+    return 1;\n+  \n   if (!ctr_labels[counter])\n     {\n       /* Generate and save a copy of this so it can be shared.  */\n@@ -354,13 +358,24 @@ coverage_counter_ref (unsigned counter, unsigned no)\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n       ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n     }\n-  if (no + 1 > fn_n_ctrs[counter])\n-    {\n-      fn_n_ctrs[counter] = no + 1;\n-      fn_ctr_mask |= 1 << counter;\n-    }\n+  fn_b_ctrs[counter] = fn_n_ctrs[counter];\n+  fn_n_ctrs[counter] += num;\n+  fn_ctr_mask |= 1 << counter;\n+  return 1;\n+}\n \n-  no += prg_n_ctrs[counter];\n+/* Generate a MEM rtl to access COUNTER NO.  */\n+\n+rtx\n+coverage_counter_ref (unsigned counter, unsigned no)\n+{\n+  unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n+  enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n+  rtx ref;\n+\n+  if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n+    abort ();\n+  no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n   ref = plus_constant (ctr_labels[counter], gcov_size / BITS_PER_UNIT * no);\n   ref = gen_rtx_MEM (mode, ref);\n   set_mem_alias_set (ref, new_alias_set ());\n@@ -415,6 +430,9 @@ compute_checksum ()\n int\n coverage_begin_output ()\n {\n+  if (no_coverage)\n+    return 0;\n+  \n   if (!bbg_function_announced)\n     {\n       const char *file = DECL_SOURCE_FILE (current_function_decl);\n@@ -435,7 +453,7 @@ coverage_begin_output ()\n       \n       /* Announce function */\n       offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n-      gcov_write_unsigned (fn_ident);\n+      gcov_write_unsigned (current_function_funcdef_no + 1);\n       gcov_write_unsigned (compute_checksum ());\n       gcov_write_string (IDENTIFIER_POINTER\n \t\t\t (DECL_ASSEMBLER_NAME (current_function_decl)));\n@@ -472,20 +490,18 @@ coverage_end_function ()\n       functions_tail = &item->next;\n \t\n       item->next = 0;\n-      /* It would be nice to use the unique source location. */\n-      item->ident = fn_ident;\n+      item->ident = current_function_funcdef_no + 1;\n       item->checksum = compute_checksum ();\n       for (i = 0; i != GCOV_COUNTERS; i++)\n \t{\n \t  item->n_ctrs[i] = fn_n_ctrs[i];\n \t  prg_n_ctrs[i] += fn_n_ctrs[i];\n-\t  fn_n_ctrs[i] = 0;\n+\t  fn_n_ctrs[i] = fn_b_ctrs[i] = 0;\n \t}\n       prg_ctr_mask |= fn_ctr_mask;\n       fn_ctr_mask = 0;\n     }\n   bbg_function_announced = 0;\n-  fn_ident++;\n }\n \n /* Creates the gcov_fn_info RECORD_TYPE.  */\n@@ -799,8 +815,9 @@ create_coverage ()\n   char *ctor_name;\n   tree ctor;\n   rtx gcov_info_address;\n-  int save_flag_inline_functions = flag_inline_functions;\n \n+  no_coverage = 1; /* Disable any further coverage.  */\n+  \n   if (!prg_ctr_mask)\n     return;\n   \n@@ -830,6 +847,7 @@ create_coverage ()\n   TREE_PUBLIC (ctor) = ! targetm.have_ctors_dtors;\n   TREE_USED (ctor) = 1;\n   DECL_RESULT (ctor) = build_decl (RESULT_DECL, NULL_TREE, void_type_node);\n+  DECL_UNINLINABLE (ctor) = 1;\n \n   ctor = (*lang_hooks.decls.pushdecl) (ctor);\n   rest_of_decl_compilation (ctor, 0, 1, 0);\n@@ -840,7 +858,6 @@ create_coverage ()\n   init_function_start (ctor, input_filename, input_line);\n   (*lang_hooks.decls.pushlevel) (0);\n   expand_function_start (ctor, 0);\n-  cfun->arc_profile = 0;\n \n   /* Actually generate the code to call __gcov_init.  */\n   gcov_info_address = force_reg (Pmode, XEXP (DECL_RTL (gcov_info), 0));\n@@ -850,16 +867,8 @@ create_coverage ()\n   expand_function_end (input_filename, input_line, 0);\n   (*lang_hooks.decls.poplevel) (1, 0, 1);\n \n-  /* Since ctor isn't in the list of globals, it would never be emitted\n-     when it's considered to be 'safe' for inlining, so turn off\n-     flag_inline_functions.  */\n-  flag_inline_functions = 0;\n-\n   rest_of_compilation (ctor);\n \n-  /* Reset flag_inline_functions to its original value.  */\n-  flag_inline_functions = save_flag_inline_functions;\n-\n   if (! quiet_flag)\n     fflush (asm_out_file);\n   current_function_decl = NULL_TREE;"}, {"sha": "5ae27f805f278cff5ad0bcbeee37ac76db68e36b", "filename": "gcc/coverage.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -25,10 +25,21 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n extern void coverage_init (const char *);\n extern void coverage_finish (void);\n+\n+/* Complete the coverage information for the current function. Once\n+   per function.  */\n extern void coverage_end_function (void);\n+\n+/* Start outputting coverage information for the current\n+   function. Repeatable per function.  */\n extern int coverage_begin_output (void);\n \n+/* Allocate some counters. Repeatable per function.  */\n+extern int coverage_counter_alloc (unsigned /*counter*/, unsigned/*num*/);\n+/* Use a counter from the most recent allocation.  */\n extern rtx coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n+\n+/* Get all the counters for the current function.  */\n extern gcov_type *get_coverage_counts (unsigned /*counter*/,\n \t\t\t\t       unsigned /*expected*/,\n \t\t\t\t       const struct gcov_ctr_summary **);"}, {"sha": "e2fbd9a62773625146aadecbdc8c032f23de56fb", "filename": "gcc/function.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -6434,8 +6434,6 @@ prepare_function_start ()\n \n   current_function_funcdef_no = funcdef_no++;\n \n-  cfun->arc_profile = profile_arc_flag || flag_test_coverage;\n-\n   cfun->function_frequency = FUNCTION_FREQUENCY_NORMAL;\n \n   cfun->max_jumptable_ents = 0;"}, {"sha": "d29b40c44692a331f3f6c0356fb0414eadd6ecce", "filename": "gcc/function.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -452,9 +452,6 @@ struct function GTY(())\n      generated.  */\n   unsigned int instrument_entry_exit : 1;\n \n-  /* Nonzero if arc profiling should be done for the function.  */\n-  unsigned int arc_profile : 1;\n-\n   /* Nonzero if profiling code should be generated.  */\n   unsigned int profile : 1;\n "}, {"sha": "310277f61fd07d89cd987fa8bfb3cecd1672d7a9", "filename": "gcc/profile.c", "status": "modified", "additions": 45, "deletions": 29, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -84,12 +84,6 @@ struct bb_info {\n #define EDGE_INFO(e)  ((struct edge_info *) (e)->aux)\n #define BB_INFO(b)  ((struct bb_info *) (b)->aux)\n \n-/* Keep all basic block indexes nonnegative in the gcov output.  Index 0\n-   is used for entry block, last block exit block.  */\n-#define BB_TO_GCOV_INDEX(bb)  ((bb) == ENTRY_BLOCK_PTR ? 0\t\t\\\n-\t\t\t       : ((bb) == EXIT_BLOCK_PTR\t\t\\\n-\t\t\t\t  ? last_basic_block + 1 : (bb)->index + 1))\n-\n /* Counter summary from the last set of coverage counts read. */\n \n const struct gcov_ctr_summary *profile_info;\n@@ -111,7 +105,7 @@ static int total_num_branches;\n /* Forward declarations.  */\n static void find_spanning_tree PARAMS ((struct edge_list *));\n static rtx gen_edge_profiler PARAMS ((int));\n-static void instrument_edges PARAMS ((struct edge_list *));\n+static unsigned instrument_edges PARAMS ((struct edge_list *));\n static void compute_branch_probabilities PARAMS ((void));\n static gcov_type * get_exec_counts PARAMS ((void));\n static basic_block find_group PARAMS ((basic_block));\n@@ -123,40 +117,45 @@ static void union_groups PARAMS ((basic_block, basic_block));\n    F is the first insn of the chain.\n    NUM_BLOCKS is the number of basic blocks found in F.  */\n \n-static void\n+static unsigned\n instrument_edges (el)\n      struct edge_list *el;\n {\n-  int num_instr_edges = 0;\n+  unsigned num_instr_edges = 0;\n   int num_edges = NUM_EDGES (el);\n   basic_block bb;\n+  \n   remove_fake_edges ();\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     {\n-      edge e = bb->succ;\n-      while (e)\n+      edge e;\n+\n+      for (e = bb->succ; e; e = e->succ_next)\n \t{\n \t  struct edge_info *inf = EDGE_INFO (e);\n+\t  \n \t  if (!inf->ignore && !inf->on_tree)\n \t    {\n+\t      rtx edge_profile;\n+\t      \n \t      if (e->flags & EDGE_ABNORMAL)\n \t\tabort ();\n \t      if (rtl_dump_file)\n \t\tfprintf (rtl_dump_file, \"Edge %d to %d instrumented%s\\n\",\n \t\t\t e->src->index, e->dest->index,\n \t\t\t EDGE_CRITICAL_P (e) ? \" (and split)\" : \"\");\n-\t      insert_insn_on_edge (\n-\t\t\t gen_edge_profiler (num_instr_edges++), e);\n+\t      edge_profile = gen_edge_profiler (num_instr_edges++);\n+\t      insert_insn_on_edge (edge_profile, e);\n \t      rebuild_jump_labels (e->insns);\n \t    }\n-\t  e = e->succ_next;\n \t}\n     }\n \n   total_num_blocks_created += num_edges;\n   if (rtl_dump_file)\n     fprintf (rtl_dump_file, \"%d edges instrumented\\n\", num_instr_edges);\n+  return num_instr_edges;\n }\n \f\n \n@@ -353,9 +352,9 @@ compute_branch_probabilities ()\n \t\t  for (e = bb->pred; e; e = e->pred_next)\n \t\t    total += e->count;\n \n-\t\t  /* Seedgeh for the invalid edge, and set its count.  */\n+\t\t  /* Search for the invalid edge, and set its count.  */\n \t\t  for (e = bb->pred; e; e = e->pred_next)\n-\t\t    if (! EDGE_INFO (e)->count_valid && ! EDGE_INFO (e)->ignore)\n+\t\t    if (!EDGE_INFO (e)->count_valid && !EDGE_INFO (e)->ignore)\n \t\t      break;\n \n \t\t  /* Calculate count for remaining edge by conservation.  */\n@@ -552,6 +551,7 @@ branch_prob ()\n   basic_block bb;\n   unsigned i;\n   unsigned num_edges, ignored_edges;\n+  unsigned num_instrumented;\n   struct edge_list *el;\n \n   total_num_times_called++;\n@@ -644,18 +644,23 @@ branch_prob ()\n      as possible to minimize number of edge splits necessary.  */\n \n   find_spanning_tree (el);\n-\n+  \n   /* Fake edges that are not on the tree will not be instrumented, so\n      mark them ignored.  */\n-  for (i = 0; i < num_edges; i++)\n+  for (num_instrumented = i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n       struct edge_info *inf = EDGE_INFO (e);\n-      if ((e->flags & EDGE_FAKE) && !inf->ignore && !inf->on_tree)\n+\n+      if (inf->ignore || inf->on_tree)\n+\t/*NOP*/;\n+      else if (e->flags & EDGE_FAKE)\n \t{\n \t  inf->ignore = 1;\n \t  ignored_edges++;\n \t}\n+      else\n+\tnum_instrumented++;\n     }\n \n   total_num_blocks += n_basic_blocks + 2;\n@@ -684,6 +689,13 @@ branch_prob ()\n       gcov_write_length (offset);\n     }\n \n+   /* Keep all basic block indexes nonnegative in the gcov output.\n+      Index 0 is used for entry block, last index is for exit block.\n+      */\n+  ENTRY_BLOCK_PTR->index = -1;\n+  EXIT_BLOCK_PTR->index = last_basic_block;\n+#define BB_TO_GCOV_INDEX(bb)  ((bb)->index + 1)\n+  \n   /* Arcs */\n   if (coverage_begin_output ())\n     {\n@@ -788,15 +800,21 @@ branch_prob ()\n \t    }\n \t}\n     }\n+  ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n+  EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n+#undef BB_TO_GCOV_INDEX\n \n   if (flag_branch_probabilities)\n     compute_branch_probabilities ();\n \n   /* For each edge not on the spanning tree, add counting code as rtl.  */\n-\n-  if (cfun->arc_profile && profile_arc_flag)\n+  if (profile_arc_flag\n+      && coverage_counter_alloc (GCOV_COUNTER_ARCS, num_instrumented))\n     {\n-      instrument_edges (el);\n+      unsigned n_instrumented = instrument_edges (el);\n+\n+      if (n_instrumented != num_instrumented)\n+\tabort ();\n \n       /* Commit changes done by instrumentation.  */\n       commit_edge_insertions_watch_calls ();\n@@ -880,8 +898,7 @@ find_spanning_tree (el)\n     {\n       edge e = INDEX_EDGE (el, i);\n       if (((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_FAKE))\n-\t   || e->dest == EXIT_BLOCK_PTR\n-\t   )\n+\t   || e->dest == EXIT_BLOCK_PTR)\n \t  && !EDGE_INFO (e)->ignore\n \t  && (find_group (e->src) != find_group (e->dest)))\n \t{\n@@ -897,9 +914,8 @@ find_spanning_tree (el)\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      if ((EDGE_CRITICAL_P (e))\n-\t  && !EDGE_INFO (e)->ignore\n-\t  && (find_group (e->src) != find_group (e->dest)))\n+      if (EDGE_CRITICAL_P (e) && !EDGE_INFO (e)->ignore\n+\t  && find_group (e->src) != find_group (e->dest))\n \t{\n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \"Critical edge %d to %d put to tree\\n\",\n@@ -913,8 +929,8 @@ find_spanning_tree (el)\n   for (i = 0; i < num_edges; i++)\n     {\n       edge e = INDEX_EDGE (el, i);\n-      if (find_group (e->src) != find_group (e->dest)\n-\t  && !EDGE_INFO (e)->ignore)\n+      if (!EDGE_INFO (e)->ignore\n+\t  && find_group (e->src) != find_group (e->dest))\n \t{\n \t  if (rtl_dump_file)\n \t    fprintf (rtl_dump_file, \"Normal edge %d to %d put to tree\\n\","}, {"sha": "22cd711798a5f4e7bb11db58d220b46ffc4711b0", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d70e6bee0dc6e9d0ad552ee70781ae8472b534a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6d70e6bee0dc6e9d0ad552ee70781ae8472b534a", "patch": "@@ -3087,13 +3087,14 @@ rest_of_compilation (decl)\n   close_dump_file (DFI_cfg, print_rtl_with_bb, insns);\n \n   /* Do branch profiling and static profile estimation passes.  */\n-  if (optimize > 0 || cfun->arc_profile || flag_branch_probabilities)\n+  if (optimize > 0\n+      || profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n     {\n       struct loops loops;\n \n       timevar_push (TV_BRANCH_PROB);\n       open_dump_file (DFI_bp, decl);\n-      if (cfun->arc_profile || flag_branch_probabilities)\n+      if (profile_arc_flag || flag_test_coverage || flag_branch_probabilities)\n \tbranch_prob ();\n \n       /* Discover and record the loop depth at the head of each basic"}]}