{"sha": "5707e389d37b785a78137d7bd668fc7ea8f6e252", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTcwN2UzODlkMzdiNzg1YTc4MTM3ZDdiZDY2OGZjN2VhOGY2ZTI1Mg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-05T14:21:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-10-05T14:21:21Z"}, "message": "[multiple changes]\n\n2012-10-05  Yannick Moy  <moy@adacore.com>\n\n\t* switch-c.adb, checks.adb, checks.ads, sem_prag.adb, exp_ch4.adb,\n\tosint.adb: Minor correction of typos, and special case for Alfa mode.\n\n2012-10-05  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* s-spsufi.adb: Add with clause for Ada.Unchecked_Deallocation.\n\tAdd with and use clauses for System.Finalization_Masters.\n\t(Finalize_And_Deallocate): Add an instance of\n\tAda.Unchecked_Deallocation. Merge the code from the now obsolete\n\tFinalize_Subpool into this routine.\n\t* s-spsufi.ads: Add pragma Preelaborate.\n\t* s-stposu.adb: Remove with clause for\n\tAda.Unchecked_Deallocation; Add with and use clauses for\n\tSystem.Storage_Pools.Subpools.Finalization; (Finalize_Pool):\n\tUpdate the comment on all actions takes with respect to a subpool\n\tfinalization. Finalize and deallocate each individual subpool.\n\t(Finalize_Subpool): Removed.\n\t(Free): Removed;\n\t(Detach): Move from package body to spec.\n\t* s-stposu.ads (Detach): Move from package body to spec.\n\t(Finalize_Subpool): Removed.\n\n2012-10-05  Arnaud Charlet  <charlet@adacore.com>\n\n\t* s-tassta.adb: Update comments.\n\t(Vulnerable_Complete_Master): If Free_On_Termination is set, do\n\tnothing, and let the task free itself if not already done.\n\nFrom-SVN: r192124", "tree": {"sha": "e30a3273ca8c8b3dbeac16e03a5145a5ef49fc86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e30a3273ca8c8b3dbeac16e03a5145a5ef49fc86"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5707e389d37b785a78137d7bd668fc7ea8f6e252", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5707e389d37b785a78137d7bd668fc7ea8f6e252", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5707e389d37b785a78137d7bd668fc7ea8f6e252", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5707e389d37b785a78137d7bd668fc7ea8f6e252/comments", "author": null, "committer": null, "parents": [{"sha": "686750d25df6b870f11f7744b2a3f631d998952a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/686750d25df6b870f11f7744b2a3f631d998952a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/686750d25df6b870f11f7744b2a3f631d998952a"}], "stats": {"total": 309, "additions": 168, "deletions": 141}, "files": [{"sha": "7936d18be8fdaad5cdbe193eca2a48ace750ec95", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -1,3 +1,33 @@\n+2012-10-05  Yannick Moy  <moy@adacore.com>\n+\n+\t* switch-c.adb, checks.adb, checks.ads, sem_prag.adb, exp_ch4.adb,\n+\tosint.adb: Minor correction of typos, and special case for Alfa mode.\n+\n+2012-10-05  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* s-spsufi.adb: Add with clause for Ada.Unchecked_Deallocation.\n+\tAdd with and use clauses for System.Finalization_Masters.\n+\t(Finalize_And_Deallocate): Add an instance of\n+\tAda.Unchecked_Deallocation. Merge the code from the now obsolete\n+\tFinalize_Subpool into this routine.\n+\t* s-spsufi.ads: Add pragma Preelaborate.\n+\t* s-stposu.adb: Remove with clause for\n+\tAda.Unchecked_Deallocation; Add with and use clauses for\n+\tSystem.Storage_Pools.Subpools.Finalization; (Finalize_Pool):\n+\tUpdate the comment on all actions takes with respect to a subpool\n+\tfinalization. Finalize and deallocate each individual subpool.\n+\t(Finalize_Subpool): Removed.\n+\t(Free): Removed;\n+\t(Detach): Move from package body to spec.\n+\t* s-stposu.ads (Detach): Move from package body to spec.\n+\t(Finalize_Subpool): Removed.\n+\n+2012-10-05  Arnaud Charlet  <charlet@adacore.com>\n+\n+\t* s-tassta.adb: Update comments.\n+\t(Vulnerable_Complete_Master): If Free_On_Termination is set, do\n+\tnothing, and let the task free itself if not already done.\n+\n 2012-10-04  Robert Dewar  <dewar@adacore.com>\n \n \t* sem_res.adb (Resolve_Set_Membership): Warn on duplicates."}, {"sha": "8ec1b2ec5880b0e864366d9cf4d8cb2c0e5eff9f", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 66, "deletions": 68, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -765,19 +765,19 @@ package body Checks is\n    procedure Apply_Arithmetic_Overflow_Check (N : Node_Id) is\n    begin\n       --  Use old routine in almost all cases (the only case we are treating\n-      --  specially is the case of an signed integer arithmetic op with the\n+      --  specially is the case of a signed integer arithmetic op with the\n       --  Do_Overflow_Check flag set on the node, and the overflow checking\n-      --  mode is either Minimized_Or_Eliminated.\n+      --  mode is MINIMIZED or ELIMINATED).\n \n       if Overflow_Check_Mode (Etype (N)) not in Minimized_Or_Eliminated\n         or else not Do_Overflow_Check (N)\n         or else not Is_Signed_Integer_Arithmetic_Op (N)\n       then\n          Apply_Arithmetic_Overflow_Checked_Suppressed (N);\n \n-      --  Otherwise use the new routine for MINIMIZED/ELIMINATED modes for\n-      --  the case of a signed integer arithmetic op, with Do_Overflow_Check\n-      --  set True, and the checking mode is Minimized_Or_Eliminated.\n+      --  Otherwise use the new routine for the case of a signed integer\n+      --  arithmetic op, with Do_Overflow_Check set to True, and the checking\n+      --  mode is MINIMIZED or ELIMINATED.\n \n       else\n          Apply_Arithmetic_Overflow_Minimized_Eliminated (N);\n@@ -797,17 +797,17 @@ package body Checks is\n \n    --  This is used in SUPPRESSED/CHECKED modes. It is identical to the\n    --  code for these cases before the big overflow earthquake, thus ensuring\n-   --  that in these modes we have compatible behavior (and realibility) to\n+   --  that in these modes we have compatible behavior (and reliability) to\n    --  what was there before. It is also called for types other than signed\n    --  integers, and if the Do_Overflow_Check flag is off.\n \n    --  Note: we also call this routine if we decide in the MINIMIZED case\n    --  to give up and just generate an overflow check without any fuss.\n \n    procedure Apply_Arithmetic_Overflow_Checked_Suppressed (N : Node_Id) is\n-      Loc   : constant Source_Ptr := Sloc (N);\n-      Typ   : constant Entity_Id  := Etype (N);\n-      Rtyp  : constant Entity_Id  := Root_Type (Typ);\n+      Loc  : constant Source_Ptr := Sloc (N);\n+      Typ  : constant Entity_Id  := Etype (N);\n+      Rtyp : constant Entity_Id  := Root_Type (Typ);\n \n    begin\n       --  An interesting special case. If the arithmetic operation appears as\n@@ -1117,10 +1117,11 @@ package body Checks is\n       end if;\n \n       --  Otherwise, we have a top level arithmetic operation node, and this\n-      --  is where we commence the special processing for minimize/eliminate.\n-      --  This is the case where we tell the machinery not to move into Bignum\n-      --  mode at this top level (of course the top level operation will still\n-      --  be in Bignum mode if either of its operands are of type Bignum).\n+      --  is where we commence the special processing for MINIMIZED/ELIMINATED\n+      --  modes. This is the case where we tell the machinery not to move into\n+      --  Bignum mode at this top level (of course the top level operation\n+      --  will still be in Bignum mode if either of its operands are of type\n+      --  Bignum).\n \n       Minimize_Eliminate_Overflow_Checks (Op, Lo, Hi, Top_Level => True);\n \n@@ -1164,8 +1165,8 @@ package body Checks is\n          --      X := Long_Long_Integer'Base (A * (B ** C));\n \n          --  Now the product may fit in Long_Long_Integer but not in Integer.\n-         --  In Minimize/Eliminate mode, we don't want to introduce an overflow\n-         --  exception for this intermediate value.\n+         --  In MINIMIZED/ELIMINATED mode, we don't want to introduce an\n+         --  overflow exception for this intermediate value.\n \n          declare\n             Blk : constant Node_Id  := Make_Bignum_Block (Loc);\n@@ -1206,9 +1207,10 @@ package body Checks is\n             Analyze_And_Resolve (Op);\n          end;\n \n-         --  Here we know the result is Long_Long_Integer'Base, or that it\n-         --  has been rewritten because the parent is a conversion (see\n-         --  Apply_Arithmetic_Overflow_Check.Conversion_Optimization).\n+      --  Here we know the result is Long_Long_Integer'Base,\n+      --  or that it has been rewritten because the parent\n+      --  is a conversion (see Conversion_Optimization in\n+      --  Apply_Arithmetic_Overflow_Checked_Suppressed).\n \n       else\n          pragma Assert\n@@ -3813,8 +3815,8 @@ package body Checks is\n       if Is_RTE (Etype (N), RE_Bignum) then\n          return Relocate_Node (N);\n \n-         --  Otherwise construct call to To_Bignum, converting the operand to\n-         --  the required Long_Long_Integer form.\n+      --  Otherwise construct call to To_Bignum, converting the operand to the\n+      --  required Long_Long_Integer form.\n \n       else\n          pragma Assert (Is_Signed_Integer_Type (Etype (N)));\n@@ -4442,13 +4444,14 @@ package body Checks is\n          return;\n       end if;\n \n-      --  This is the point at which processing for CHECKED mode diverges from\n-      --  processing for MINIMIZED/ELIMINATED mode. This divergence is probably\n-      --  more extreme that it needs to be, but what is going on here is that\n-      --  when we introduced MINIMIZED/ELININATED modes, we wanted to leave the\n-      --  processing for CHECKED mode untouched. There were two reasons for\n-      --  this. First it avoided any incomptible change of behavior. Second,\n-      --  it guaranteed that CHECKED mode continued to be legacy reliable.\n+      --  This is the point at which processing for CHECKED mode diverges\n+      --  from processing for MINIMIZED/ELIMINATED modes. This divergence is\n+      --  probably more extreme that it needs to be, but what is going on here\n+      --  is that when we introduced MINIMIZED/ELIMINATED modes, we wanted\n+      --  to leave the processing for CHECKED mode untouched. There were\n+      --  two reasons for this. First it avoided any incompatible change of\n+      --  behavior. Second, it guaranteed that CHECKED mode continued to be\n+      --  legacy reliable.\n \n       --  The big difference is that in CHECKED mode there is a fair amount of\n       --  circuitry to try to avoid setting the Do_Overflow_Check flag if we\n@@ -6691,9 +6694,9 @@ package body Checks is\n    --  recursive calls to process operands. This processing may involve the use\n    --  of bignum or long long integer arithmetic, which will change the types\n    --  of operands and results. That's why we can't do this bottom up (since\n-   --  it would intefere with semantic analysis).\n+   --  it would interfere with semantic analysis).\n \n-   --  What happens is that if Minimized/Eliminated mode is in effect then\n+   --  What happens is that if MINIMIZED/ELIMINATED mode is in effect then\n    --  the operator expansion routines, as well as the expansion routines\n    --  for if/case expression test the Do_Overflow_Check flag and if it is\n    --  set they (for the moment) do nothing except call the routine to apply\n@@ -6710,12 +6713,12 @@ package body Checks is\n \n    --  After possible rewriting of a constituent subexpression node, a call is\n    --  made to either reexpand the node (if nothing has changed) or reanalyze\n-   --  the node (if it has been modified by the overflow check processing).\n-   --  The Analyzed_flag is set False before the reexpand/reanalyze. To avoid\n-   --  a recursive call into the whole overflow apparatus, and important rule\n+   --  the node (if it has been modified by the overflow check processing). The\n+   --  Analyzed_Flag is set to False before the reexpand/reanalyze. To avoid\n+   --  a recursive call into the whole overflow apparatus, an important rule\n    --  for this call is that either Do_Overflow_Check must be False, or if\n    --  it is set, then the overflow checking mode must be temporarily set\n-   --  to Checked/Suppressed. Either step will avoid the unwanted recursion.\n+   --  to CHECKED/SUPPRESSED. Either step will avoid the unwanted recursion.\n \n    procedure Minimize_Eliminate_Overflow_Checks\n      (N         : Node_Id;\n@@ -6755,33 +6758,33 @@ package body Checks is\n       --  Set True if one or more operands is already of type Bignum, meaning\n       --  that for sure (regardless of Top_Level setting) we are committed to\n       --  doing the operation in Bignum mode (or in the case of a case or if\n-      --  expression, converting all the dependent expressions to bignum).\n+      --  expression, converting all the dependent expressions to Bignum).\n \n       Long_Long_Integer_Operands : Boolean;\n-      --  Set True if one r more operands is already of type Long_Loong_Integer\n+      --  Set True if one or more operands is already of type Long_Long_Integer\n       --  which means that if the result is known to be in the result type\n       --  range, then we must convert such operands back to the result type.\n       --  This switch is properly set only when Bignum_Operands is False.\n \n       procedure Reexpand (C : Suppressed_Or_Checked);\n-      --  This is called when we have not modifed the node, so we do not need\n-      --  to reanalyze it. But we do want to reexpand it in either CHECKED\n-      --  or SUPPRESSED mode (as indicated by the argument C) to get proper\n+      --  This is called when we have not modified the node, so we do not need\n+      --  to reanalyze it. But we do want to reexpand it in either SUPPRESSED\n+      --  or CHECKED mode (as indicated by the argument C) to get proper\n       --  expansion. It is important that we reset the mode to SUPPRESSED or\n       --  CHECKED, since if we leave it in MINIMIZED or ELIMINATED mode we\n       --  would reenter this routine recursively which would not be good!\n       --  Note that this is not just an optimization, testing has showed up\n-      --  several complex cases in which renalyzing an already analyzed node\n+      --  several complex cases in which reanalyzing an already analyzed node\n       --  causes incorrect behavior.\n \n       function In_Result_Range return Boolean;\n       --  Returns True iff Lo .. Hi are within range of the result type\n \n       procedure Max (A : in out Uint; B : Uint);\n-      --  If A is No_Uint, sets A to B, else to UI_Max (A, B);\n+      --  If A is No_Uint, sets A to B, else to UI_Max (A, B)\n \n       procedure Min (A : in out Uint; B : Uint);\n-      --  If A is No_Uint, sets A to B, else to UI_Min (A, B);\n+      --  If A is No_Uint, sets A to B, else to UI_Min (A, B)\n \n       ---------------------\n       -- In_Result_Range --\n@@ -6858,7 +6861,7 @@ package body Checks is\n \n          Determine_Range (N, OK, Lo, Hi, Assume_Valid => False);\n \n-         --  If Deterine_Range did not work (can this in fact happen? Not\n+         --  If Determine_Range did not work (can this in fact happen? Not\n          --  clear but might as well protect), use type bounds.\n \n          if not OK then\n@@ -6901,8 +6904,8 @@ package body Checks is\n                Max (Hi, Rhi);\n             end if;\n \n-            --  If at least one of our operands is now bignum, we must rebuild\n-            --  the if expression to use bignum operands. We will analyze the\n+            --  If at least one of our operands is now Bignum, we must rebuild\n+            --  the if expression to use Bignum operands. We will analyze the\n             --  rebuilt if expression with overflow checks off, since once we\n             --  are in bignum mode, we are all done with overflow checks!\n \n@@ -6952,8 +6955,6 @@ package body Checks is\n       elsif Nkind (N) = N_Case_Expression then\n          Bignum_Operands := False;\n          Long_Long_Integer_Operands := False;\n-         Lo := No_Uint;\n-         Hi := No_Uint;\n \n          declare\n             Alt : Node_Id;\n@@ -6986,7 +6987,7 @@ package body Checks is\n             --  resetting the overflow flag, since we are done with overflow\n             --  checks for this node. We will reexpand to get the needed\n             --  expansion for the case expression, but we do not need to\n-            --  renalyze, since nothing has changed.\n+            --  reanalyze, since nothing has changed.\n \n             if not (Bignum_Operands or Long_Long_Integer_Operands) then\n                Set_Do_Overflow_Check (N, False);\n@@ -7057,7 +7058,7 @@ package body Checks is\n       --  don't need to do any range analysis. As previously discussed we could\n       --  do range analysis in such cases, but it could mean working with giant\n       --  numbers at compile time for very little gain (the number of cases\n-      --  in which we could slip back from bignum mode are small).\n+      --  in which we could slip back from bignum mode is small).\n \n       if Rlo = No_Uint or else (Binary and then Llo = No_Uint) then\n          Lo := No_Uint;\n@@ -7069,10 +7070,6 @@ package body Checks is\n       else\n          Bignum_Operands := False;\n \n-         Long_Long_Integer_Operands :=\n-           Etype (Right_Opnd (N)) = LLIB\n-             or else (Binary and then Etype (Left_Opnd (N)) = LLIB);\n-\n          case Nkind (N) is\n \n             --  Absolute value\n@@ -7297,13 +7294,13 @@ package body Checks is\n                   --  Result can only be negative if base can be negative\n \n                   if Llo < 0 then\n-                     if UI_Mod (Rhi, 2) = 0 then\n+                     if Rhi mod 2 = 0 then\n                         Lo := Llo ** (Rhi - 1);\n                      else\n                         Lo := Llo ** Rhi;\n                      end if;\n \n-                  --  Otherwise low bound is minimium ** minimum\n+                  --  Otherwise low bound is minimum ** minimum\n \n                   else\n                      Lo := Llo ** Rlo;\n@@ -7412,13 +7409,13 @@ package body Checks is\n       end if;\n \n       --  Here for the case where we have not rewritten anything (no bignum\n-      --  operands or long long integer operands), and we know the result If we\n-      --  know we are in the result range, and we do not have Bignum operands\n-      --  or Long_Long_Integer operands, we can just reexpand with overflow\n-      --  checks turned off (since we know we cannot have overflow). As always\n-      --  the reexpansion is required to complete expansion of the operator,\n-      --  but we do not need to reanalyze, and we prevent recursion by\n-      --  suppressing the check,\n+      --  operands or long long integer operands), and we know the result.\n+      --  If we know we are in the result range, and we do not have Bignum\n+      --  operands or Long_Long_Integer operands, we can just reexpand with\n+      --  overflow checks turned off (since we know we cannot have overflow).\n+      --  As always the reexpansion is required to complete expansion of the\n+      --  operator, but we do not need to reanalyze, and we prevent recursion\n+      --  by suppressing the check.\n \n       if not (Bignum_Operands or Long_Long_Integer_Operands)\n         and then In_Result_Range\n@@ -7428,11 +7425,12 @@ package body Checks is\n          return;\n \n       --  Here we know that we are not in the result range, and in the general\n-      --  we will move into either the Bignum or Long_Long_Integer domain to\n-      --  compute the result. However, there is one exception. If we are at the\n-      --  top level, and we do not have Bignum or Long_Long_Integer operands,\n-      --  we will have to immediately convert the result back to the result\n-      --  type, so there is no point in Bignum/Long_Long_Integer fiddling.\n+      --  case we will move into either the Bignum or Long_Long_Integer domain\n+      --  to compute the result. However, there is one exception. If we are\n+      --  at the top level, and we do not have Bignum or Long_Long_Integer\n+      --  operands, we will have to immediately convert the result back to\n+      --  the result type, so there is no point in Bignum/Long_Long_Integer\n+      --  fiddling.\n \n       elsif Top_Level\n         and then not (Bignum_Operands or Long_Long_Integer_Operands)\n@@ -7455,8 +7453,8 @@ package body Checks is\n          Set_Analyzed (N, False);\n \n          --  One subtlety. We can't just go ahead and do an analyze operation\n-         --  here because it will cause recursion into the whole minimized/\n-         --  eliminated overflow processing which is not what we want. Here\n+         --  here because it will cause recursion into the whole MINIMIZED/\n+         --  ELIMINATED overflow processing which is not what we want. Here\n          --  we are at the top level, and we need a check against the result\n          --  mode (i.e. we want to use Checked mode). So do exactly that!\n          --  Also, we have not modified the node, so this is a case where"}, {"sha": "a989cfac05f1bf0d44d5f9449100ede4bed55f85", "filename": "gcc/ada/checks.ads", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fchecks.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fchecks.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.ads?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -223,7 +223,7 @@ package Checks is\n    --  Returns result of converting node N to Bignum. The returned value is not\n    --  analyzed, the caller takes responsibility for this. Node N must be a\n    --  subexpression node of a signed integer type or Bignum type (if it is\n-   --  already a Bignnum, the returned value is Relocate_Node (N).\n+   --  already a Bignum, the returned value is Relocate_Node (N)).\n \n    procedure Determine_Range\n      (N            : Node_Id;\n@@ -273,7 +273,7 @@ package Checks is\n       Top_Level : Boolean);\n    --  This is the main routine for handling MINIMIZED and ELIMINATED overflow\n    --  checks. On entry N is a node whose result is a signed integer subtype.\n-   --  If the node is an artihmetic operation, then a range analysis is carried\n+   --  If the node is an arithmetic operation, then a range analysis is carried\n    --  out, and there are three possibilities:\n    --\n    --    The node is left unchanged (apart from expansion of an exponentiation\n@@ -289,13 +289,13 @@ package Checks is\n    --\n    --  In the first two cases, Lo and Hi are set to the bounds of the possible\n    --  range of results, computed as accurately as possible. In the third case\n-   --  Lo and Hi are set to No_Uint (there are some cases where we cold get an\n+   --  Lo and Hi are set to No_Uint (there are some cases where we could get an\n    --  advantage from keeping result ranges for Bignum values, but it could use\n    --  a lot of space and is very unlikely to be valuable).\n    --\n    --  If the node is not an arithmetic operation, then it is unchanged but\n    --  Lo and Hi are still set (to the bounds of the result subtype if nothing\n-   --  better can be determined.\n+   --  better can be determined).\n    --\n    --  Note: this function is recursive, if called with an arithmetic operator,\n    --  recursive calls are made to process the operands using this procedure.\n@@ -310,8 +310,8 @@ package Checks is\n    --  with a Long_Long_Integer left operand and an Integer right operand, and\n    --  we would get a semantic error.\n    --\n-   --  The routine is called in three situations if we are operating in\n-   --  either MINIMIZED or ELIMINATED modes.\n+   --  The routine is called in three situations if we are operating in either\n+   --  MINIMIZED or ELIMINATED modes.\n    --\n    --    Overflow checks applied to the top node of an expression tree when\n    --    that node is an arithmetic operator. In this case the result is\n@@ -320,15 +320,15 @@ package Checks is\n    --\n    --    Overflow checks are applied to the operands of a comparison operation.\n    --    In this case, the comparison is done on the result Long_Long_Integer\n-   --    or Bignum values, without raising any exceptions.\n+   --    or Bignum values, without raising any exception.\n    --\n    --    Overflow checks are applied to the left operand of a membership test.\n    --    In this case no exception is raised if a Long_Long_Integer or Bignum\n    --    result is outside the range of the type of that left operand (it is\n    --    just that the result of IN is false in that case).\n    --\n    --  Note that if Bignum values appear, the caller must take care of doing\n-   --  the appropriate mark/release operation on the secondary stack.\n+   --  the appropriate mark/release operations on the secondary stack.\n    --\n    --  Top_Level is used to avoid inefficient unnecessary transitions into the\n    --  Bignum domain. If Top_Level is True, it means that the caller will have"}, {"sha": "9e28fc6d01c1c39c3d5b6c97e37b035c8357ffb7", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -141,8 +141,8 @@ package body Exp_Ch4 is\n    --  Common expansion processing for short-circuit boolean operators\n \n    procedure Expand_Compare_Minimize_Eliminate_Overflow (N : Node_Id);\n-   --  Deal with comparison in Minimize/Eliminate overflow mode. This is where\n-   --  we allow comparison of \"out of range\" values.\n+   --  Deal with comparison in MINIMIZED/ELIMINATED overflow mode. This is\n+   --  where we allow comparison of \"out of range\" values.\n \n    function Expand_Composite_Equality\n      (Nod    : Node_Id;\n@@ -165,10 +165,10 @@ package body Exp_Ch4 is\n    --  include both arrays and singleton elements.\n \n    procedure Expand_Membership_Minimize_Eliminate_Overflow (N : Node_Id);\n-   --  N is an N_In membership test mode, with the overflow check mode\n-   --  set to Minimized or Eliminated, and the type of the left operand\n-   --  is a signed integer type. This is a case where top level processing\n-   --  is required to handle overflow checks in subtrees.\n+   --  N is an N_In membership test mode, with the overflow check mode set to\n+   --  MINIMIZED or ELIMINATED, and the type of the left operand is a signed\n+   --  integer type. This is a case where top level processing is required to\n+   --  handle overflow checks in subtrees.\n \n    procedure Fixup_Universal_Fixed_Operation (N : Node_Id);\n    --  N is a N_Op_Divide or N_Op_Multiply node whose result is universal\n@@ -5524,7 +5524,7 @@ package body Exp_Ch4 is\n       Ltyp := Etype (Left_Opnd  (N));\n       Rtyp := Etype (Right_Opnd (N));\n \n-      --  If Minimize/Eliminate overflow mode and type is a signed integer\n+      --  If MINIMIZED/ELIMINATED overflow mode and type is a signed integer\n       --  type, then expand with a separate procedure. Note the use of the\n       --  flag No_Minimize_Eliminate to prevent infinite recursion.\n \n@@ -7084,7 +7084,7 @@ package body Exp_Ch4 is\n       Typl := Base_Type (Typl);\n \n       --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n-      --  results in not having a comparison operation any more, we are done.\n+      --  results in not having a comparison operation anymore, we are done.\n \n       Expand_Compare_Minimize_Eliminate_Overflow (N);\n \n@@ -7678,7 +7678,7 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n-      --  results in not having a comparison operation any more, we are done.\n+      --  results in not having a comparison operation anymore, we are done.\n \n       Expand_Compare_Minimize_Eliminate_Overflow (N);\n \n@@ -7728,7 +7728,7 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n-      --  results in not having a comparison operation any more, we are done.\n+      --  results in not having a comparison operation anymore, we are done.\n \n       Expand_Compare_Minimize_Eliminate_Overflow (N);\n \n@@ -7778,7 +7778,7 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n-      --  results in not having a comparison operation any more, we are done.\n+      --  results in not having a comparison operation anymore, we are done.\n \n       Expand_Compare_Minimize_Eliminate_Overflow (N);\n \n@@ -7828,7 +7828,7 @@ package body Exp_Ch4 is\n       Binary_Op_Validity_Checks (N);\n \n       --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if that\n-      --  results in not having a comparison operation any more, we are done.\n+      --  results in not having a comparison operation anymore, we are done.\n \n       Expand_Compare_Minimize_Eliminate_Overflow (N);\n \n@@ -8263,7 +8263,7 @@ package body Exp_Ch4 is\n          Binary_Op_Validity_Checks (N);\n \n          --  Deal with overflow checks in MINIMIZED/ELIMINATED mode and if\n-         --  that results in not having a /= opertion any more, we are done.\n+         --  that results in not having a /= operation anymore, we are done.\n \n          Expand_Compare_Minimize_Eliminate_Overflow (N);\n "}, {"sha": "8765b4cb60e10df6427421e9ce3913f42f663545", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -1658,7 +1658,7 @@ package body Osint is\n       --  Start off by setting all suppress options, to False. The special\n       --  overflow fields are set to Not_Set (they will be set by -gnatp, or\n       --  by -gnato, or, if neither of these appear, in Adjust_Global_Switches\n-      --  in Gnat1drv.\n+      --  in Gnat1drv).\n \n       Suppress_Options := ((others => False), Not_Set, Not_Set);\n "}, {"sha": "9ed8e3ee5eca2065a6ecc1f113b6be2325e55a45", "filename": "gcc/ada/s-spsufi.adb", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-spsufi.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-spsufi.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-spsufi.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--           Copyright (C) 2011-2012, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -30,13 +30,18 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Ada.Unchecked_Deallocation;\n+with System.Finalization_Masters; use System.Finalization_Masters;\n+\n package body System.Storage_Pools.Subpools.Finalization is\n \n    -----------------------------\n    -- Finalize_And_Deallocate --\n    -----------------------------\n \n    procedure Finalize_And_Deallocate (Subpool : in out Subpool_Handle) is\n+      procedure Free is new Ada.Unchecked_Deallocation (SP_Node, SP_Node_Ptr);\n+\n    begin\n       --  Do nothing if the subpool was never created or never used. The latter\n       --  case may arise with an array of subpool implementations.\n@@ -48,9 +53,18 @@ package body System.Storage_Pools.Subpools.Finalization is\n          return;\n       end if;\n \n-      --  Clean up all controlled objects allocated through the subpool\n+      --  Clean up all controlled objects chained on the subpool's master\n+\n+      Finalize (Subpool.Master);\n+\n+      --  Remove the subpool from its owner's list of subpools\n+\n+      Detach (Subpool.Node);\n+\n+      --  Destroy the associated doubly linked list node which was created in\n+      --  Set_Pool_Of_Subpools.\n \n-      Finalize_Subpool (Subpool);\n+      Free (Subpool.Node);\n \n       --  Dispatch to the user-defined implementation of Deallocate_Subpool\n "}, {"sha": "c1f4d641eaacdde679d9636c9dbf17590ea0f2fd", "filename": "gcc/ada/s-spsufi.ads", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-spsufi.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-spsufi.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-spsufi.ads?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -7,7 +7,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---             Copyright (C) 2011, Free Software Foundation, Inc.           --\n+--           Copyright (C) 2011-2012, Free Software Foundation, Inc.        --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,6 +33,7 @@\n pragma Compiler_Unit;\n \n package System.Storage_Pools.Subpools.Finalization is\n+   pragma Preelaborate;\n \n    procedure Finalize_And_Deallocate (Subpool : in out Subpool_Handle);\n    --  This routine performs the following actions:"}, {"sha": "99a61174e0f8a714c2abd714af02c79e5cb427a2", "filename": "gcc/ada/s-stposu.adb", "status": "modified", "additions": 4, "deletions": 33, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-stposu.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-stposu.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -31,12 +31,13 @@\n \n with Ada.Exceptions;              use Ada.Exceptions;\n with Ada.Unchecked_Conversion;\n-with Ada.Unchecked_Deallocation;\n with System.Address_Image;\n with System.Finalization_Masters; use System.Finalization_Masters;\n with System.IO;                   use System.IO;\n with System.Soft_Links;           use System.Soft_Links;\n with System.Storage_Elements;     use System.Storage_Elements;\n+with System.Storage_Pools.Subpools.Finalization;\n+use  System.Storage_Pools.Subpools.Finalization;\n \n package body System.Storage_Pools.Subpools is\n \n@@ -51,11 +52,6 @@ package body System.Storage_Pools.Subpools is\n    procedure Attach (N : not null SP_Node_Ptr; L : not null SP_Node_Ptr);\n    --  Attach a subpool node to a pool\n \n-   procedure Free is new Ada.Unchecked_Deallocation (SP_Node, SP_Node_Ptr);\n-\n-   procedure Detach (N : not null SP_Node_Ptr);\n-   --  Unhook a subpool node from an arbitrary subpool list\n-\n    -----------------------------------\n    -- Adjust_Controlled_Dereference --\n    -----------------------------------\n@@ -544,9 +540,10 @@ package body System.Storage_Pools.Subpools is\n          --    2) Remove the the subpool from the owner's list of subpools\n          --    3) Deallocate the doubly linked list node associated with the\n          --       subpool.\n+         --    4) Call Deallocate_Subpool\n \n          begin\n-            Finalize_Subpool (Curr_Ptr.Subpool);\n+            Finalize_And_Deallocate (Curr_Ptr.Subpool);\n \n          exception\n             when Fin_Occur : others =>\n@@ -565,32 +562,6 @@ package body System.Storage_Pools.Subpools is\n       end if;\n    end Finalize_Pool;\n \n-   ----------------------\n-   -- Finalize_Subpool --\n-   ----------------------\n-\n-   procedure Finalize_Subpool (Subpool : not null Subpool_Handle) is\n-   begin\n-      --  Do nothing if the subpool was never used\n-\n-      if Subpool.Owner = null or else Subpool.Node = null then\n-         return;\n-      end if;\n-\n-      --  Clean up all controlled objects chained on the subpool's master\n-\n-      Finalize (Subpool.Master);\n-\n-      --  Remove the subpool from its owner's list of subpools\n-\n-      Detach (Subpool.Node);\n-\n-      --  Destroy the associated doubly linked list node which was created in\n-      --  Set_Pool_Of_Subpool.\n-\n-      Free (Subpool.Node);\n-   end Finalize_Subpool;\n-\n    ------------------------------\n    -- Header_Size_With_Padding --\n    ------------------------------"}, {"sha": "c80dd9e3446277802ba5a32bd9d843b0acb78acc", "filename": "gcc/ada/s-stposu.ads", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-stposu.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-stposu.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-stposu.ads?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -325,6 +325,9 @@ private\n    --    is controlled. When set to True, the machinery generates additional\n    --    data.\n \n+   procedure Detach (N : not null SP_Node_Ptr);\n+   --  Unhook a subpool node from an arbitrary subpool list\n+\n    overriding procedure Finalize (Controller : in out Pool_Controller);\n    --  Buffer routine, calls Finalize_Pool\n \n@@ -333,11 +336,6 @@ private\n    --  their masters. This action first detaches a controlled object from a\n    --  particular master, then invokes its Finalize_Address primitive.\n \n-   procedure Finalize_Subpool (Subpool : not null Subpool_Handle);\n-   --  Finalize all controlled objects chained on Subpool's master. Remove the\n-   --  subpool from its owner's list. Deallocate the associated doubly linked\n-   --  list node.\n-\n    function Header_Size_With_Padding\n      (Alignment : System.Storage_Elements.Storage_Count)\n       return System.Storage_Elements.Storage_Count;"}, {"sha": "0b4a742ec1f55f6f309052c2acdda6e9111c41c0", "filename": "gcc/ada/s-tassta.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-tassta.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fs-tassta.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-tassta.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -1905,7 +1905,16 @@ package body System.Tasking.Stages is\n       C := All_Tasks_List;\n       P := null;\n       while C /= null loop\n-         if C.Common.Parent = Self_ID and then C.Master_of_Task >= CM then\n+         --  If Free_On_Termination is set, do nothing here, and let\n+         --  the task free itself if not already done, otherwise we\n+         --  risk a race condition where Vulnerable_Free_Task is called\n+         --  in the loop below, while the task calls Free_Task itself,\n+         --  in Terminate_Task.\n+\n+         if C.Common.Parent = Self_ID\n+           and then C.Master_of_Task >= CM\n+           and then not C.Free_On_Termination\n+         then\n             if P /= null then\n                P.Common.All_Tasks_Link := C.Common.All_Tasks_Link;\n             else\n@@ -2088,9 +2097,7 @@ package body System.Tasking.Stages is\n    --  is called from Expunge_Unactivated_Tasks.\n \n    --  For tasks created by elaboration of task object declarations it is\n-   --  called from the finalization code of the Task_Wrapper procedure. It is\n-   --  also called from Ada.Unchecked_Deallocation, for objects that are or\n-   --  contain tasks.\n+   --  called from the finalization code of the Task_Wrapper procedure.\n \n    procedure Vulnerable_Free_Task (T : Task_Id) is\n    begin"}, {"sha": "c791c3344a75a4615b91a8841fc8d424ca32fa8c", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -11798,8 +11798,16 @@ package body Sem_Prag is\n                Check_Optional_Identifier (Arg, Name);\n                Check_Arg_Is_Identifier (Argx);\n \n+               --  Do not suppress overflow checks for formal verification.\n+               --  Instead, require that a check is inserted so that formal\n+               --  verification can detect wraparound errors.\n+\n                if Chars (Argx) = Name_Suppressed then\n-                  return Suppressed;\n+                  if Alfa_Mode then\n+                     return Checked;\n+                  else\n+                     return Suppressed;\n+                  end if;\n \n                elsif Chars (Argx) = Name_Checked then\n                   return Checked;"}, {"sha": "2a96c06d11a89a82d110cd95180902e5d4b0a51b", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5707e389d37b785a78137d7bd668fc7ea8f6e252/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=5707e389d37b785a78137d7bd668fc7ea8f6e252", "patch": "@@ -53,7 +53,7 @@ package body Switch.C is\n \n    function Get_Overflow_Mode (C : Character) return Overflow_Check_Type;\n    --  Given a digit in the range 0 .. 3, returns the corresponding value of\n-   --  Overflow_Check_Type. Raises program error if C is outside this range.\n+   --  Overflow_Check_Type. Raises Program_Error if C is outside this range.\n \n    function Switch_Subsequently_Cancelled\n      (C        : String;\n@@ -867,11 +867,11 @@ package body Switch.C is\n                      then\n                         Suppress_Options.Suppress (J) := True;\n                      end if;\n-\n-                     Suppress_Options.Overflow_Checks_General    := Suppressed;\n-                     Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n                   end loop;\n \n+                  Suppress_Options.Overflow_Checks_General    := Suppressed;\n+                  Suppress_Options.Overflow_Checks_Assertions := Suppressed;\n+\n                   Validity_Checks_On  := False;\n                   Opt.Suppress_Checks := True;\n                end if;"}]}