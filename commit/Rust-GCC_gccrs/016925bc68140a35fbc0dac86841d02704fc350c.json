{"sha": "016925bc68140a35fbc0dac86841d02704fc350c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE2OTI1YmM2ODE0MGEzNWZiYzBkYWM4Njg0MWQwMjcwNGZjMzUwYw==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-02-03T00:24:50Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2006-02-03T00:24:50Z"}, "message": "tree-tailcall.c (arg_needs_copy_p): New function.\n\n2006-02-02  Zdenek Dvorak <dvorakz@suse.cz>\n\t    Daniel Berlin  <dberlin@dberlin.org>\n\n\t* tree-tailcall.c (arg_needs_copy_p): New function.\n\t(eliminate_tail_call): Use arg_needs_copy_p.\n\t(tree_optimize_tail_calls_1): Ditto. Also call add_virtual_phis.\n\t(add_virtual_phis): New function.\n\n\nCo-Authored-By: Daniel Berlin <dberlin@dberlin.org>\n\nFrom-SVN: r110530", "tree": {"sha": "a29bc7c72528536c6d857894bb9932dff5f9d9a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a29bc7c72528536c6d857894bb9932dff5f9d9a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/016925bc68140a35fbc0dac86841d02704fc350c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016925bc68140a35fbc0dac86841d02704fc350c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/016925bc68140a35fbc0dac86841d02704fc350c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/016925bc68140a35fbc0dac86841d02704fc350c/comments", "author": null, "committer": null, "parents": [{"sha": "d3d4b28fb7ccde42de203bf1a83db8d40c7c3741", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3d4b28fb7ccde42de203bf1a83db8d40c7c3741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3d4b28fb7ccde42de203bf1a83db8d40c7c3741"}], "stats": {"total": 212, "additions": 142, "deletions": 70}, "files": [{"sha": "7525f4c825809435ca15ac4f5e36103cfe554fc3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=016925bc68140a35fbc0dac86841d02704fc350c", "patch": "@@ -1,3 +1,11 @@\n+2006-02-02  Zdenek Dvorak <dvorakz@suse.cz>\n+\t    Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* tree-tailcall.c (arg_needs_copy_p): New function.\n+\t(eliminate_tail_call): Use arg_needs_copy_p.\n+\t(tree_optimize_tail_calls_1): Ditto. Also call add_virtual_phis.\n+\t(add_virtual_phis): New function.\n+\n 2006-02-02  Jakub Jelinek  <jakub@redhat.com>\n \n \t* config/sparc/sparc.c (sparc_output_scratch_registers): Use"}, {"sha": "9d440741c6bbf0f9572731a51d41681d22f68fc5", "filename": "gcc/testsuite/gcc.c-torture/compile/20060202-1.c", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060202-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060202-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fcompile%2F20060202-1.c?ref=016925bc68140a35fbc0dac86841d02704fc350c", "patch": "@@ -0,0 +1,54 @@\n+typedef unsigned int size_t;\n+typedef const struct objc_selector\n+{\n+  void *sel_id;\n+}\n+ *SEL;\n+typedef struct objc_object\n+{\n+}\n+ *id;\n+typedef struct objc_class *Class;\n+struct objc_class\n+{\n+  struct sarray *dtable;\n+};\n+typedef size_t sidx;\n+struct soffset\n+{\n+  unsigned int boffset:(sizeof (size_t) * 8) / 2;\n+  unsigned int eoffset:(sizeof (size_t) * 8) / 2;\n+};\n+union sofftype\n+{\n+  struct soffset off;\n+  sidx idx;\n+};\n+struct sarray\n+{\n+  size_t capacity;\n+};\n+static __inline__ unsigned int\n+soffset_decode (sidx indx)\n+{\n+  union sofftype x;\n+  x.idx = indx;\n+  return x.off.eoffset + (x.off.boffset * (1 << 5));\n+}\n+static __inline__ void *\n+sarray_get_safe (struct sarray *array, sidx indx)\n+{\n+  if (soffset_decode (indx) < array->capacity)\n+    return (void *)sarray_get (array, indx);\n+}\n+void *\n+get_imp (Class class, SEL sel)\n+{\n+  void *res = sarray_get_safe (class->dtable, (size_t) sel->sel_id);\n+  if (res == 0)\n+    {\n+\t{\n+\t  res = get_imp (class, sel);\n+\t}\n+    }\n+}"}, {"sha": "b0f74ffbc706c35a39e2c93b39bf48b8a818b44b", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 80, "deletions": 70, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/016925bc68140a35fbc0dac86841d02704fc350c/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=016925bc68140a35fbc0dac86841d02704fc350c", "patch": "@@ -690,6 +690,25 @@ decrease_profile (basic_block bb, gcov_type count, int frequency)\n     e->count = 0;\n }\n \n+/* Returns true if argument PARAM of the tail recursive call needs to be copied\n+   when the call is eliminated.  */\n+\n+static bool\n+arg_needs_copy_p (tree param)\n+{\n+  tree def;\n+\n+  if (!is_gimple_reg (param) || !var_ann (param))\n+    return false;\n+\t\t\n+  /* Parameters that are only defined but never used need not be copied.  */\n+  def = default_def (param);\n+  if (!def)\n+    return false;\n+\n+  return true;\n+}\n+\n /* Eliminates tail call described by T.  TMP_VARS is a list of\n    temporary variables used to copy the function arguments.  */\n \n@@ -701,9 +720,6 @@ eliminate_tail_call (struct tailcall *t)\n   edge e;\n   tree phi;\n   block_stmt_iterator bsi;\n-  use_operand_p mayuse;\n-  def_operand_p maydef;\n-  ssa_op_iter iter;\n   tree orig_stmt;\n \n   stmt = orig_stmt = bsi_stmt (t->call_bsi);\n@@ -751,65 +767,21 @@ eliminate_tail_call (struct tailcall *t)\n   gcc_assert (e);\n   PENDING_STMT (e) = NULL_TREE;\n \n-  /* Add phi node entries for arguments.  Not every PHI node corresponds to\n-     a function argument (there may be PHI nodes for virtual definitions of the\n-     eliminated calls), so we search for a PHI corresponding to each argument\n-     rather than searching for which argument a PHI node corresponds to.  */\n-  \n+  /* Add phi node entries for arguments.  The ordering of the phi nodes should\n+     be the same as the ordering of the arguments.  */\n   for (param = DECL_ARGUMENTS (current_function_decl),\n-       args = TREE_OPERAND (stmt, 1);\n+       args = TREE_OPERAND (stmt, 1),\n+       phi = phi_nodes (first);\n        param;\n        param = TREE_CHAIN (param),\n        args = TREE_CHAIN (args))\n     {\n-      \n-      for (phi = phi_nodes (first); phi; phi = PHI_CHAIN (phi))\n-\tif (param == SSA_NAME_VAR (PHI_RESULT (phi)))\n-\t  break;\n-\n-      /* The phi node indeed does not have to be there, in case the operand is\n-\t invariant in the function.  */\n-      if (!phi)\n+      if (!arg_needs_copy_p (param))\n \tcontinue;\n+      gcc_assert (param == SSA_NAME_VAR (PHI_RESULT (phi)));\n \n       add_phi_arg (phi, TREE_VALUE (args), e);\n-    }\n-\n-  /* Add phi nodes for the call clobbered variables.  */\n-  FOR_EACH_SSA_MAYDEF_OPERAND (maydef, mayuse, orig_stmt, iter)\n-    {\n-      param = SSA_NAME_VAR (DEF_FROM_PTR (maydef));\n-      for (phi = phi_nodes (first); phi; phi = PHI_CHAIN (phi))\n-\tif (param == SSA_NAME_VAR (PHI_RESULT (phi)))\n-\t  break;\n-\n-      if (!phi)\n-\t{\n-\t  tree name = default_def (param);\n-\t  tree new_name;\n-\n-\t  if (!name)\n-\t    {\n-\t      /* It may happen that the tag does not have a default_def in case\n-\t\t when all uses of it are dominated by a MUST_DEF.  This however\n-\t\t means that it is not necessary to add a phi node for this\n-\t\t tag.  */\n-\t      continue;\n-\t    }\n-\t  new_name = make_ssa_name (param, SSA_NAME_DEF_STMT (name));\n-\n-\t  set_default_def (param, new_name);\n-\t  phi = create_phi_node (name, first);\n-\t  SSA_NAME_DEF_STMT (name) = phi;\n-\t  add_phi_arg (phi, new_name, single_succ_edge (ENTRY_BLOCK_PTR));\n-\n-\t  /* For all calls the same set of variables should be clobbered.  This\n-\t     means that there always should be the appropriate phi node except\n-\t     for the first time we eliminate the call.  */\n-\t  gcc_assert (EDGE_COUNT (first->preds) <= 2);\n-\t}\n-\n-      add_phi_arg (phi, USE_FROM_PTR (mayuse), e);\n+      phi = PHI_CHAIN (phi);\n     }\n \n   /* Update the values of accumulators.  */\n@@ -829,6 +801,38 @@ eliminate_tail_call (struct tailcall *t)\n   release_defs (call);\n }\n \n+/* Add phi nodes for the virtual operands defined in the function to the\n+   header of the loop created by tail recursion elimination.\n+\n+   Originally, we used to add phi nodes only for call clobbered variables,\n+   as the value of the non-call clobbered ones obviously cannot be used\n+   or changed within the recursive call.  However, the local variables\n+   from multiple calls now share the same location, so the virtual ssa form\n+   requires us to say that the location dies on further iterations of the loop,\n+   which requires adding phi nodes.\n+*/\n+static void\n+add_virtual_phis (void)\n+{\n+  referenced_var_iterator rvi;\n+  tree var;\n+\n+  /* The problematic part is that there is no way how to know what\n+     to put into phi nodes (there in fact does not have to be such\n+     ssa name available).  A solution would be to have an artificial\n+     use/kill for all virtual operands in EXIT node.  Unless we have\n+     this, we cannot do much better than to rebuild the ssa form for\n+     possibly affected virtual ssa names from scratch.  */\n+\n+  FOR_EACH_REFERENCED_VAR (var, rvi)\n+    {\n+      if (!is_gimple_reg (var) && default_def (var) != NULL_TREE)\n+\tmark_sym_for_renaming (var);\n+    }\n+\n+  update_ssa (TODO_update_ssa_only_virtuals);\n+}\n+\n /* Optimizes the tailcall described by T.  If OPT_TAILCALLS is true, also\n    mark the tailcalls for the sibcall optimization.  */\n \n@@ -897,7 +901,6 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \n       if (!phis_constructed)\n \t{\n-\t  tree name;\n \t  /* Ensure that there is only one predecessor of the block.  */\n \t  if (!single_pred_p (first))\n \t    first = split_edge (single_succ_edge (ENTRY_BLOCK_PTR));\n@@ -906,21 +909,17 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t  for (param = DECL_ARGUMENTS (current_function_decl);\n \t       param;\n \t       param = TREE_CHAIN (param))\n-\t    if (is_gimple_reg (param)\n-\t\t&& var_ann (param)\n-\t\t/* Also parameters that are only defined but never used need not\n-\t\t   be copied.  */\n-\t\t&& ((name = default_def (param))\n-\t\t    && TREE_CODE (name) == SSA_NAME))\n-\t    {\n-\t      tree new_name = make_ssa_name (param, SSA_NAME_DEF_STMT (name));\n-\t      tree phi;\n-\n-\t      set_default_def (param, new_name);\n-\t      phi = create_phi_node (name, first);\n-\t      SSA_NAME_DEF_STMT (name) = phi;\n-\t      add_phi_arg (phi, new_name, single_pred_edge (first));\n-\t    }\n+\t    if (arg_needs_copy_p (param))\n+\t      {\n+\t\ttree name = default_def (param);\n+\t\ttree new_name = make_ssa_name (param, SSA_NAME_DEF_STMT (name));\n+\t\ttree phi;\n+\n+\t\tset_default_def (param, new_name);\n+\t\tphi = create_phi_node (name, first);\n+\t\tSSA_NAME_DEF_STMT (name) = phi;\n+\t\tadd_phi_arg (phi, new_name, single_pred_edge (first));\n+\t      }\n \t  phis_constructed = true;\n \t}\n \n@@ -957,6 +956,14 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n \t}\n     }\n \n+\n+  if (phis_constructed)\n+    {\n+      /* Reverse the order of the phi nodes, so that it matches the order\n+\t of operands of the function, as assumed by eliminate_tail_call.  */\n+      set_phi_nodes (first, phi_reverse (phi_nodes (first)));\n+    }\n+\n   for (; tailcalls; tailcalls = next)\n     {\n       next = tailcalls->next;\n@@ -982,6 +989,9 @@ tree_optimize_tail_calls_1 (bool opt_tailcalls)\n       free_dominance_info (CDI_DOMINATORS);\n       cleanup_tree_cfg ();\n     }\n+\n+  if (phis_constructed)\n+    add_virtual_phis ();\n }\n \n static void"}]}