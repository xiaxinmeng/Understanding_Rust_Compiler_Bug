{"sha": "10e5650699725d2549ca31701da6f45089e311e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTBlNTY1MDY5OTcyNWQyNTQ5Y2EzMTcwMWRhNmY0NTA4OWUzMTFlMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@wolery.cumb.org", "date": "2000-05-01T20:05:11Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-05-01T20:05:11Z"}, "message": "cppfiles.c (open_include_file): Open file in blocking mode.\n\n\t* cppfiles.c (open_include_file): Open file in blocking mode.\n\t(read_include_file): Don't fcntl(fd, F_SETFL, 0) anymore.\n\tOnly exclude block devices and directories.\n\nFrom-SVN: r33583", "tree": {"sha": "a19038ee9727c1fea14ad6f84ba696acc2cc1158", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a19038ee9727c1fea14ad6f84ba696acc2cc1158"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10e5650699725d2549ca31701da6f45089e311e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e5650699725d2549ca31701da6f45089e311e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10e5650699725d2549ca31701da6f45089e311e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10e5650699725d2549ca31701da6f45089e311e1/comments", "author": null, "committer": null, "parents": [{"sha": "cc93392367215ad4791f0c3572253e542db51d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cc93392367215ad4791f0c3572253e542db51d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cc93392367215ad4791f0c3572253e542db51d48"}], "stats": {"total": 48, "additions": 24, "deletions": 24}, "files": [{"sha": "b0583b48993c58cf2cdec4aefa313fbca46b275f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e5650699725d2549ca31701da6f45089e311e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e5650699725d2549ca31701da6f45089e311e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=10e5650699725d2549ca31701da6f45089e311e1", "patch": "@@ -1,5 +1,9 @@\n 2000-05-01  Zack Weinberg  <zack@wolery.cumb.org>\n \n+\t* cppfiles.c (open_include_file): Open file in blocking mode.\n+\t(read_include_file): Don't fcntl(fd, F_SETFL, 0) anymore.\n+\tOnly exclude block devices and directories.\n+\n \t* cpphash.c (_cpp_make_hashnode): Rename make_HASHNODE, now\n \tstatic.  Allocate the hashnode and its string in the same\n \tblock of memory."}, {"sha": "8fb2e0ee05d2bee2d0deb521971ce3ead89d9982", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10e5650699725d2549ca31701da6f45089e311e1/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10e5650699725d2549ca31701da6f45089e311e1/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=10e5650699725d2549ca31701da6f45089e311e1", "patch": "@@ -218,11 +218,10 @@ file_cleanup (pbuf, pfile)\n    with calling open is in one place, and if we ever need more, it'll\n    be in one place too.\n \n-   Open files in nonblocking mode, so we don't get stuck if someone\n-   clever has asked cpp to process /dev/rmt0.  read_include_file\n-   will check that we have a real file to work with.  Also take care\n-   not to acquire a controlling terminal by mistake (this can't happen\n-   on sane systems, but paranoia is a virtue).\n+   We used to open files in nonblocking mode, but that caused more\n+   problems than it solved.  Do take care not to acquire a controlling\n+   terminal by mistake (this can't happen on sane systems, but\n+   paranoia is a virtue).\n \n    Use the three-argument form of open even though we aren't\n    specifying O_CREAT, to defend against broken system headers.  */\n@@ -232,7 +231,7 @@ open_include_file (pfile, filename)\n      cpp_reader *pfile ATTRIBUTE_UNUSED;\n      const char *filename;\n {\n-  return open (filename, O_RDONLY|O_NONBLOCK|O_NOCTTY, 0666);\n+  return open (filename, O_RDONLY|O_NOCTTY, 0666);\n }\n \n /* Search for include file FNAME in the include chain starting at\n@@ -708,19 +707,18 @@ read_include_file (pfile, fd, ihash)\n \n   if (fstat (fd, &st) < 0)\n     goto perror_fail;\n-  if (fcntl (fd, F_SETFL, 0) == -1)  /* turn off nonblocking mode */\n-    goto perror_fail;\n \n   /* If fd points to a plain file, we know how big it is, so we can\n      allocate the buffer all at once.  If fd is a pipe or terminal, we\n      can't.  Most C source files are 4k or less, so we guess that.  If\n-     fd is something weird, like a block device or a directory, we\n-     don't want to read it at all.\n+     fd is something weird, like a directory, we don't want to read it\n+     at all.\n \n      Unfortunately, different systems use different st.st_mode values\n      for pipes: some have S_ISFIFO, some S_ISSOCK, some are buggy and\n-     zero the entire struct stat except a couple fields.  Hence the\n-     mess below.\n+     zero the entire struct stat except a couple fields.  Hence we don't\n+     even try to figure out what something is, except for plain files,\n+     directories, and block devices.\n \n      In all cases, read_and_prescan will resize the buffer if it\n      turns out there's more data than we thought.  */\n@@ -740,23 +738,21 @@ read_include_file (pfile, fd, ihash)\n \t  goto fail;\n \t}\n     }\n-  else if (S_ISFIFO (st.st_mode) || S_ISSOCK (st.st_mode)\n-\t   /* Permit any kind of character device: the sensible ones are\n-\t      ttys and /dev/null, but weeding out the others is too hard.  */\n-\t   || S_ISCHR (st.st_mode)\n-\t   /* Some 4.x (x<4) derivatives have a bug that makes fstat() of a\n-\t      socket or pipe return a stat struct with most fields zeroed.  */\n-\t   || (st.st_mode == 0 && st.st_nlink == 0 && st.st_size == 0))\n+  else if (S_ISBLK (st.st_mode))\n     {\n-      /* Cannot get its file size before reading.  4k is a decent\n-         first guess. */\n-      st_size = 4096;\n+      cpp_error (pfile, \"%s is a block device\", ihash->name);\n+      goto fail;\n     }\n-  else\n+  else if (S_ISDIR (st.st_mode))\n     {\n-      cpp_error (pfile, \"`%s' is not a file, pipe, or tty\", ihash->name);\n+      cpp_error (pfile, \"%s is a directory\", ihash->name);\n       goto fail;\n     }\n+  else\n+    {\n+      /* We don't know how big this is.  4k is a decent first guess.  */\n+      st_size = 4096;\n+    }\n \n   /* Read the file, converting end-of-line characters and trigraphs\n      (if enabled). */"}]}