{"sha": "c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "node_id": "C_kwDOANBUbNoAKGM2YmIxZGI3NmIzYWMxMjdhZmY3ZGFjZjM5MWZjMTc5OGE5NGJiN2Q", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-02-07T20:52:16Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2022-02-09T14:09:54Z"}, "message": "Register non-null side effects properly.\n\nThis patch adjusts uses of nonnull to accurately reflect \"somewhere in block\".\nIt also adds the ability to register statement side effects within a block\nfor ranger which will apply for the rest of the block.\n\n\tPR tree-optimization/104288\n\tgcc/\n\t* gimple-range-cache.cc (non_null_ref::set_nonnull): New.\n\t(non_null_ref::adjust_range): Move to header.\n\t(ranger_cache::range_of_def): Don't check non-null.\n\t(ranger_cache::entry_range): Don't check non-null.\n\t(ranger_cache::range_on_edge): Check for nonnull on normal edges.\n\t(ranger_cache::update_to_nonnull): New.\n\t(non_null_loadstore): New.\n\t(ranger_cache::block_apply_nonnull): New.\n\t* gimple-range-cache.h (class non_null_ref): Update prototypes.\n\t(non_null_ref::adjust_range): Move to here and inline.\n\t(class ranger_cache): Update prototypes.\n\t* gimple-range-path.cc (path_range_query::range_defined_in_block): Do\n\tnot search dominators.\n\t(path_range_query::adjust_for_non_null_uses): Ditto.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): Check on-entry for\n\tdef overrides.  Do not check nonnull.\n\t(gimple_ranger::range_on_entry): Check dominators for nonnull.\n\t(gimple_ranger::range_on_edge): Check for nonnull on normal edges..\n\t(gimple_ranger::register_side_effects): New.\n\t* gimple-range.h (gimple_ranger::register_side_effects): New.\n\t* tree-vrp.cc (rvrp_folder::fold_stmt): Call register_side_effects.\n\n\tgcc/testsuite/\n\t* gcc.dg/pr104288.c: New.", "tree": {"sha": "ece35b744603236671d2ee0e8cc8fdf1c8f06828", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ece35b744603236671d2ee0e8cc8fdf1c8f06828"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/comments", "author": null, "committer": null, "parents": [{"sha": "da2bf62d9e2a25f2d6a99176144c250b51fbdee7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da2bf62d9e2a25f2d6a99176144c250b51fbdee7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da2bf62d9e2a25f2d6a99176144c250b51fbdee7"}], "stats": {"total": 229, "additions": 187, "deletions": 42}, "files": [{"sha": "613135266a48d0171516ab681ef1fb57a8fb0bcb", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 101, "deletions": 34, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -29,6 +29,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gimple-pretty-print.h\"\n #include \"gimple-range.h\"\n #include \"tree-cfg.h\"\n+#include \"target.h\"\n+#include \"attribs.h\"\n+#include \"gimple-iterator.h\"\n+#include \"gimple-walk.h\"\n \n #define DEBUG_RANGE_CACHE (dump_file\t\t\t\t\t\\\n \t\t\t   && (param_ranger_debug & RANGER_DEBUG_CACHE))\n@@ -50,6 +54,21 @@ non_null_ref::~non_null_ref ()\n   m_nn.release ();\n }\n \n+// This routine will update NAME in BB to be nonnull if it is not already.\n+// return TRUE if the update happens.\n+\n+bool\n+non_null_ref::set_nonnull (basic_block bb, tree name)\n+{\n+  gcc_checking_assert (gimple_range_ssa_p (name)\n+\t\t       && POINTER_TYPE_P (TREE_TYPE (name)));\n+  // Only process when its not already set.\n+  if (non_null_deref_p  (name, bb, false))\n+    return false;\n+  bitmap_set_bit (m_nn[SSA_NAME_VERSION (name)], bb->index);\n+  return true;\n+}\n+\n // Return true if NAME has a non-null dereference in block bb.  If this is the\n // first query for NAME, calculate the summary first.\n // If SEARCH_DOM is true, the search the dominator tree as well.\n@@ -87,35 +106,6 @@ non_null_ref::non_null_deref_p (tree name, basic_block bb, bool search_dom)\n   return false;\n }\n \n-// If NAME has a non-null dereference in block BB, adjust R with the\n-// non-zero information from non_null_deref_p, and return TRUE.  If\n-// SEARCH_DOM is true, non_null_deref_p should search the dominator tree.\n-\n-bool\n-non_null_ref::adjust_range (irange &r, tree name, basic_block bb,\n-\t\t\t    bool search_dom)\n-{\n-  // Non-call exceptions mean we could throw in the middle of the\n-  // block, so just punt on those for now.\n-  if (cfun->can_throw_non_call_exceptions)\n-    return false;\n-\n-  // We only care about the null / non-null property of pointers.\n-  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n-    return false;\n-  if (r.undefined_p () || r.lower_bound () != 0 || r.upper_bound () == 0)\n-    return false;\n-  // Check if pointers have any non-null dereferences.\n-  if (non_null_deref_p (name, bb, search_dom))\n-    {\n-      // Remove zero from the range.\n-      unsigned prec = TYPE_PRECISION (TREE_TYPE (name));\n-      r.intersect (wi::one (prec), wi::max_value (prec, UNSIGNED));\n-      return true;\n-    }\n-  return false;\n-}\n-\n // Allocate an populate the bitmap for NAME.  An ON bit for a block\n // index indicates there is a non-null reference in that block.  In\n // order to populate the bitmap, a quick run of all the immediate uses\n@@ -1014,9 +1004,6 @@ ranger_cache::range_of_def (irange &r, tree name, basic_block bb)\n       else\n \tr = gimple_range_global (name);\n     }\n-\n-  if (bb)\n-    m_non_null.adjust_range (r, name, bb, false);\n }\n \n // Get the range of NAME as it occurs on entry to block BB.\n@@ -1034,8 +1021,6 @@ ranger_cache::entry_range (irange &r, tree name, basic_block bb)\n   // Otherwise pick up the best available global value.\n   if (!m_on_entry.get_bb_range (r, name, bb))\n     range_of_def (r, name);\n-\n-  m_non_null.adjust_range (r, name, bb, false);\n }\n \n // Get the range of NAME as it occurs on exit from block BB.\n@@ -1089,6 +1074,9 @@ ranger_cache::range_of_expr (irange &r, tree name, gimple *stmt)\n    if (gimple_range_ssa_p (expr))\n     {\n       exit_range (r, expr, e->src);\n+      // If this is not an abnormal edge, check for a non-null exit.\n+      if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n+\tm_non_null.adjust_range (r, expr, e->src, false);\n       int_range_max edge_range;\n       if (m_gori.outgoing_edge_range_p (edge_range, e, expr, *this))\n \tr.intersect (edge_range);\n@@ -1467,3 +1455,82 @@ ranger_cache::range_from_dom (irange &r, tree name, basic_block bb)\n     }\n   return true;\n }\n+\n+// This routine will update NAME in block BB to the nonnull state.\n+// It will then update the on-entry cache for this block to be non-null\n+// if it isn't already.\n+\n+void\n+ranger_cache::update_to_nonnull (basic_block bb, tree name)\n+{\n+  tree type = TREE_TYPE (name);\n+  if (gimple_range_ssa_p (name) && POINTER_TYPE_P (type))\n+    {\n+      m_non_null.set_nonnull (bb, name);\n+      // Update the on-entry cache for BB to be non-zero.  Note this can set\n+      // the on entry value in the DEF block, which can override the def.\n+      int_range_max r;\n+      exit_range (r, name, bb);\n+      if (r.varying_p ())\n+\t{\n+\t  r.set_nonzero (type);\n+\t  m_on_entry.set_bb_range (name, bb, r);\n+\t}\n+    }\n+}\n+\n+// Adapted from infer_nonnull_range_by_dereference and check_loadstore\n+// to process nonnull ssa_name OP in S.  DATA contains the ranger_cache.\n+\n+static bool\n+non_null_loadstore (gimple *s, tree op, tree, void *data)\n+{\n+  if (TREE_CODE (op) == MEM_REF || TREE_CODE (op) == TARGET_MEM_REF)\n+    {\n+      /* Some address spaces may legitimately dereference zero.  */\n+      addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (op));\n+      if (!targetm.addr_space.zero_address_valid (as))\n+\t{\n+\t  tree ssa = TREE_OPERAND (op, 0);\n+\t  basic_block bb = gimple_bb (s);\n+\t  ((ranger_cache *)data)->update_to_nonnull (bb, ssa);\n+\t}\n+    }\n+  return false;\n+}\n+\n+// This routine is used during a block walk to move the state of non-null for\n+// any operands on stmt S to nonnull.\n+\n+void\n+ranger_cache::block_apply_nonnull (gimple *s)\n+{\n+  if (!flag_delete_null_pointer_checks)\n+    return;\n+  if (is_a<gphi *> (s))\n+    return;\n+  if (gimple_code (s) == GIMPLE_ASM || gimple_clobber_p (s))\n+    return;\n+  if (is_a<gcall *> (s))\n+    {\n+      tree fntype = gimple_call_fntype (s);\n+      bitmap nonnullargs = get_nonnull_args (fntype);\n+      // Process any non-null arguments\n+      if (nonnullargs)\n+\t{\n+\t  basic_block bb = gimple_bb (s);\n+\t  for (unsigned i = 0; i < gimple_call_num_args (s); i++)\n+\t    {\n+\t      if (bitmap_empty_p (nonnullargs) || bitmap_bit_p (nonnullargs, i))\n+\t\t{\n+\t\t  tree op = gimple_call_arg (s, i);\n+\t\t  update_to_nonnull (bb, op);\n+\t\t}\n+\t    }\n+\t  BITMAP_FREE (nonnullargs);\n+\t}\n+      // Fallthru and walk load/store ops now.\n+    }\n+  walk_stmt_load_store_ops (s, (void *)this, non_null_loadstore,\n+\t\t\t    non_null_loadstore);\n+}"}, {"sha": "589b649da26e97f76d52cfdaa0eb0a48fd8f702e", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -36,12 +36,41 @@ class non_null_ref\n   bool non_null_deref_p (tree name, basic_block bb, bool search_dom = true);\n   bool adjust_range (irange &r, tree name, basic_block bb,\n \t\t     bool search_dom = true);\n+  bool set_nonnull (basic_block bb, tree name);\n private:\n   vec <bitmap> m_nn;\n   void process_name (tree name);\n   bitmap_obstack m_bitmaps;\n };\n \n+// If NAME has a non-null dereference in block BB, adjust R with the\n+// non-zero information from non_null_deref_p, and return TRUE.  If\n+// SEARCH_DOM is true, non_null_deref_p should search the dominator tree.\n+\n+inline bool\n+non_null_ref::adjust_range (irange &r, tree name, basic_block bb,\n+\t\t\t    bool search_dom)\n+{\n+  // Non-call exceptions mean we could throw in the middle of the\n+  // block, so just punt on those for now.\n+  if (cfun->can_throw_non_call_exceptions)\n+    return false;\n+  // We only care about the null / non-null property of pointers.\n+  if (!POINTER_TYPE_P (TREE_TYPE (name)))\n+    return false;\n+  if (r.undefined_p () || r.lower_bound () != 0 || r.upper_bound () == 0)\n+    return false;\n+  // Check if pointers have any non-null dereferences.\n+  if (non_null_deref_p (name, bb, search_dom))\n+    {\n+      // Remove zero from the range.\n+      unsigned prec = TYPE_PRECISION (TREE_TYPE (name));\n+      r.intersect (wi::one (prec), wi::max_value (prec, UNSIGNED));\n+      return true;\n+    }\n+  return false;\n+}\n+\n // This class manages a vector of pointers to ssa_block ranges.  It\n // provides the basis for the \"range on entry\" cache for all\n // SSA names.\n@@ -106,6 +135,8 @@ class ranger_cache : public range_query\n \n   void propagate_updated_value (tree name, basic_block bb);\n \n+  void block_apply_nonnull (gimple *s);\n+  void update_to_nonnull (basic_block bb, tree name);\n   non_null_ref m_non_null;\n   gori_compute m_gori;\n "}, {"sha": "483bcd2e5823267f86ec82bdfaa6ef835894ca50", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -358,7 +358,7 @@ path_range_query::range_defined_in_block (irange &r, tree name, basic_block bb)\n     }\n \n   if (bb)\n-    m_non_null.adjust_range (r, name, bb);\n+    m_non_null.adjust_range (r, name, bb, false);\n \n   if (DEBUG_SOLVER && (bb || !r.varying_p ()))\n     {\n@@ -528,7 +528,7 @@ path_range_query::adjust_for_non_null_uses (basic_block bb)\n       else\n \tr.set_varying (TREE_TYPE (name));\n \n-      if (m_non_null.adjust_range (r, name, bb))\n+      if (m_non_null.adjust_range (r, name, bb, false))\n \tset_cache (r, name);\n     }\n }"}, {"sha": "04075a98a807e58281a6163951a1b395040c889a", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -35,6 +35,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-scalar-evolution.h\"\n #include \"gimple-range.h\"\n #include \"gimple-fold.h\"\n+#include \"gimple-walk.h\"\n \n gimple_ranger::gimple_ranger () :\n \tnon_executable_edge_flag (cfun),\n@@ -117,8 +118,10 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n       // If name is defined in this block, try to get an range from S.\n       if (def_stmt && gimple_bb (def_stmt) == bb)\n \t{\n-\t  range_of_stmt (r, def_stmt, expr);\n-\t  m_cache.m_non_null.adjust_range (r, expr, bb, true);\n+\t  // Check for a definition override from a block walk.\n+\t  if (!POINTER_TYPE_P (TREE_TYPE (expr))\n+\t      || !m_cache.block_range (r, bb, expr, false))\n+\t    range_of_stmt (r, def_stmt, expr);\n \t}\n       // Otherwise OP comes from outside this block, use range on entry.\n       else\n@@ -151,7 +154,12 @@ gimple_ranger::range_on_entry (irange &r, basic_block bb, tree name)\n   if (m_cache.block_range (entry_range, bb, name))\n     r.intersect (entry_range);\n \n-  m_cache.m_non_null.adjust_range (r, name, bb, true);\n+  if (dom_info_available_p (CDI_DOMINATORS))\n+    {\n+      basic_block dom_bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+      if (dom_bb)\n+\tm_cache.m_non_null.adjust_range (r, name, dom_bb, true);\n+    }\n \n   if (idx)\n     tracer.trailer (idx, \"range_on_entry\", true, name, r);\n@@ -227,6 +235,9 @@ gimple_ranger::range_on_edge (irange &r, edge e, tree name)\n   else\n     {\n       range_on_exit (r, e->src, name);\n+      // If this is not an abnormal edge, check for a non-null exit .\n+      if ((e->flags & (EDGE_EH | EDGE_ABNORMAL)) == 0)\n+\tm_cache.m_non_null.adjust_range (r, name, e->src, false);\n       gcc_checking_assert  (r.undefined_p ()\n \t\t\t    || range_compatible_p (r.type(), TREE_TYPE (name)));\n \n@@ -436,6 +447,16 @@ gimple_ranger::fold_stmt (gimple_stmt_iterator *gsi, tree (*valueize) (tree))\n   return ret;\n }\n \n+// Called during dominator walks to register any side effects that take effect\n+// from this point forward.  Current release is only for tracking non-null\n+// within a block.\n+\n+void\n+gimple_ranger::register_side_effects (gimple *s)\n+{\n+  m_cache.block_apply_nonnull (s);\n+}\n+\n // This routine will export whatever global ranges are known to GCC\n // SSA_RANGE_NAME_INFO and SSA_NAME_PTR_INFO fields.\n "}, {"sha": "0733a534853b8e53baa0183441de4ee8fda44de5", "filename": "gcc/gimple-range.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Fgimple-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.h?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -60,6 +60,7 @@ class gimple_ranger : public range_query\n   void dump_bb (FILE *f, basic_block bb);\n   auto_edge_flag non_executable_edge_flag;\n   bool fold_stmt (gimple_stmt_iterator *gsi, tree (*) (tree));\n+  void register_side_effects (gimple *s);\n protected:\n   bool fold_range_internal (irange &r, gimple *s, tree name);\n   void prefill_name (irange &r, tree name);"}, {"sha": "95eb196f9e41f87c58d0d95a21bebb339f1ecd57", "filename": "gcc/testsuite/gcc.dg/pr104288.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104288.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104288.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr104288.c?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-evrp -fdelete-null-pointer-checks\" } */\n+/* { dg-skip-if \"\" { keeps_null_pointer_checks } } */\n+\n+void keep(int result) __attribute__((noipa));\n+void keep(int result)\n+{\n+    if (result)\n+        __builtin_exit(0);\n+}\n+\n+void foo (void *p) __attribute__((nonnull(1)));\n+\n+void bar (void *p)\n+{\n+  keep (p == 0);\n+  foo (p);\n+  if (!p)\n+    __builtin_abort ();\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"abort\" \"evrp\" } } */\n+/* { dg-final { scan-tree-dump-times  \"== 0B;\" 1 \"evrp\" } } */"}, {"sha": "e9f19d0c8b9afa73eea30d802f5acdc40f791e42", "filename": "gcc/tree-vrp.cc", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Ftree-vrp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6bb1db76b3ac127aff7dacf391fc1798a94bb7d/gcc%2Ftree-vrp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.cc?ref=c6bb1db76b3ac127aff7dacf391fc1798a94bb7d", "patch": "@@ -4309,9 +4309,11 @@ class rvrp_folder : public substitute_and_fold_engine\n \n   bool fold_stmt (gimple_stmt_iterator *gsi) OVERRIDE\n   {\n-    if (m_simplifier.simplify (gsi))\n-      return true;\n-    return m_ranger->fold_stmt (gsi, follow_single_use_edges);\n+    bool ret = m_simplifier.simplify (gsi);\n+    if (!ret)\n+      ret = m_ranger->fold_stmt (gsi, follow_single_use_edges);\n+    m_ranger->register_side_effects (gsi_stmt (*gsi));\n+    return ret;\n   }\n \n private:"}]}