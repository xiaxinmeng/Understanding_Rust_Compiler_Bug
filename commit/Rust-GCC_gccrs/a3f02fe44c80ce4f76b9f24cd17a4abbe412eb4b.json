{"sha": "a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmMDJmZTQ0YzgwY2U0Zjc2YjlmMjRjZDE3YTRhYmJlNDEyZWI0Yg==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-04-29T14:56:02Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2011-04-29T14:56:02Z"}, "message": "re PR libfortran/48488 (Wrong default format for real numbers)\n\n2011-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\t    Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR libgfortran/48488\n\tPR libgfortran/48602\n\tPR libgfortran/48615\n\tPR libgfortran/48684\n\tPR libgfortran/48787\n\t* io/write.c (write_d, write_e, write_f, write_en,\n\twrite_es): Add precision compemsation parameter to call.\n\t(set_fnode_default): Adjust default widths to assure\n\tround trip on write and read. (write_real): Adjust call to write_float.\n\t(write_real_g0): Calculate compensation for extra precision and adjust\n\tcall to write_float. \n\t* io/write_float.def (output_float_FMT_G_): Use volatile rather than\n\tasm volatile to avoid optimization issue. Correctly calculate the\n\tnumber of blanks (nb) to be appended and simplify calculation logic.\n\t(write_float): Increase MIN_FIELD_WIDTH by one to accomodate the new\n\tdefault widths. Eliminate the code that attempted to reduce the\n\tthe precision used in later sprintf functions.  Add call parameter to\n\tcompensate for extra precision.\n\nCo-Authored-By: Janne Blomqvist <jb@gcc.gnu.org>\n\nFrom-SVN: r173166", "tree": {"sha": "7c17b1373c610a14b69aea91b26798d2921a7d89", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c17b1373c610a14b69aea91b26798d2921a7d89"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/comments", "author": null, "committer": null, "parents": [{"sha": "eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb6c3df1a0e34edc7a243c781a1b8842e3fc285c"}], "stats": {"total": 120, "additions": 63, "deletions": 57}, "files": [{"sha": "8a199fe2d15496234bb2180d0dcf398843c6d73f", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "patch": "@@ -1,3 +1,25 @@\n+2011-04-29  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\t    Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR libgfortran/48488\n+\tPR libgfortran/48602\n+\tPR libgfortran/48615\n+\tPR libgfortran/48684\n+\tPR libgfortran/48787\n+\t* io/write.c (write_d, write_e, write_f, write_en,\n+\twrite_es): Add precision compemsation parameter to call.\n+\t(set_fnode_default): Adjust default widths to assure\n+\tround trip on write and read. (write_real): Adjust call to write_float.\n+\t(write_real_g0): Calculate compensation for extra precision and adjust\n+\tcall to write_float. \n+\t* io/write_float.def (output_float_FMT_G_): Use volatile rather than\n+\tasm volatile to avoid optimization issue. Correctly calculate the\n+\tnumber of blanks (nb) to be appended and simplify calculation logic.\n+\t(write_float): Increase MIN_FIELD_WIDTH by one to accomodate the new\n+\tdefault widths. Eliminate the code that attempted to reduce the\n+\tthe precision used in later sprintf functions.  Add call parameter to\n+\tcompensate for extra precision.\n+\t\n 2011-04-20  Jim Meyering  <meyering@redhat.com>\n \n \t* intrinsics/move_alloc.c (move_alloc): Remove useless"}, {"sha": "bf02ad8b1aa0dc618a43ecd80266119977677399", "filename": "libgfortran/io/write.c", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2Fio%2Fwrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2Fio%2Fwrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite.c?ref=a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "patch": "@@ -1155,35 +1155,35 @@ write_z (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n void\n write_d (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (dtp, f, p, len);\n+  write_float (dtp, f, p, len, 0);\n }\n \n \n void\n write_e (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (dtp, f, p, len);\n+  write_float (dtp, f, p, len, 0);\n }\n \n \n void\n write_f (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (dtp, f, p, len);\n+  write_float (dtp, f, p, len, 0);\n }\n \n \n void\n write_en (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (dtp, f, p, len);\n+  write_float (dtp, f, p, len, 0);\n }\n \n \n void\n write_es (st_parameter_dt *dtp, const fnode *f, const char *p, int len)\n {\n-  write_float (dtp, f, p, len);\n+  write_float (dtp, f, p, len, 0);\n }\n \n \n@@ -1432,8 +1432,8 @@ set_fnode_default (st_parameter_dt *dtp, fnode *f, int length)\n   switch (length)\n     {\n     case 4:\n-      f->u.real.w = 15;\n-      f->u.real.d = 8;\n+      f->u.real.w = 16;\n+      f->u.real.d = 9;\n       f->u.real.e = 2;\n       break;\n     case 8:\n@@ -1442,13 +1442,13 @@ set_fnode_default (st_parameter_dt *dtp, fnode *f, int length)\n       f->u.real.e = 3;\n       break;\n     case 10:\n-      f->u.real.w = 29;\n-      f->u.real.d = 20;\n+      f->u.real.w = 30;\n+      f->u.real.d = 21;\n       f->u.real.e = 4;\n       break;\n     case 16:\n-      f->u.real.w = 44;\n-      f->u.real.d = 35;\n+      f->u.real.w = 45;\n+      f->u.real.d = 36;\n       f->u.real.e = 4;\n       break;\n     default:\n@@ -1468,20 +1468,28 @@ write_real (st_parameter_dt *dtp, const char *source, int length)\n   int org_scale = dtp->u.p.scale_factor;\n   dtp->u.p.scale_factor = 1;\n   set_fnode_default (dtp, &f, length);\n-  write_float (dtp, &f, source , length);\n+  write_float (dtp, &f, source , length, 1);\n   dtp->u.p.scale_factor = org_scale;\n }\n \n \n void\n write_real_g0 (st_parameter_dt *dtp, const char *source, int length, int d)\n {\n-  fnode f ;\n+  fnode f;\n+  int comp_d; \n   set_fnode_default (dtp, &f, length);\n   if (d > 0)\n     f.u.real.d = d;\n+\n+  /* Compensate for extra digits when using scale factor, d is not\n+     specified, and the magnitude is such that E editing is used.  */\n+  if (dtp->u.p.scale_factor > 0 && d == 0)\n+    comp_d = 1;\n+  else\n+    comp_d = 0;\n   dtp->u.p.g0_no_blanks = 1;\n-  write_float (dtp, &f, source , length);\n+  write_float (dtp, &f, source , length, comp_d);\n   dtp->u.p.g0_no_blanks = 0;\n }\n "}, {"sha": "2e2b4d87bf478a4432e2bdd6c2c722ddcf990a01", "filename": "libgfortran/io/write_float.def", "status": "modified", "additions": 19, "deletions": 43, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2Fio%2Fwrite_float.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b/libgfortran%2Fio%2Fwrite_float.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Fwrite_float.def?ref=a3f02fe44c80ce4f76b9f24cd17a4abbe412eb4b", "patch": "@@ -289,8 +289,9 @@ output_float (st_parameter_dt *dtp, const fnode *f, char *buffer, size_t size,\n     }\n   else if (nbefore + nafter < ndigits)\n     {\n-      ndigits = nbefore + nafter;\n-      i = ndigits;\n+      i = ndigits = nbefore + nafter;\n+      if (d == 0 && digits[1] == '0')\n+\tgoto skip;\n       if (digits[i] >= rchar)\n \t{\n \t  /* Propagate the carry.  */\n@@ -812,7 +813,8 @@ CALCULATE_EXP(16)\n static void \\\n output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \t\t      GFC_REAL_ ## x m, char *buffer, size_t size, \\\n-\t\t      int sign_bit, bool zero_flag, int ndigits, int edigits) \\\n+\t\t      int sign_bit, bool zero_flag, int ndigits, \\\n+                      int edigits, int comp_d) \\\n { \\\n   int e = f->u.real.e;\\\n   int d = f->u.real.d;\\\n@@ -850,7 +852,7 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n     { \\\n       newf->format = FMT_E;\\\n       newf->u.real.w = w;\\\n-      newf->u.real.d = d;\\\n+      newf->u.real.d = d - comp_d;\\\n       newf->u.real.e = e;\\\n       nb = 0;\\\n       goto finish;\\\n@@ -864,11 +866,10 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \\\n   while (low <= high)\\\n     { \\\n-      GFC_REAL_ ## x temp;\\\n+      volatile GFC_REAL_ ## x temp;\\\n       mid = (low + high) / 2;\\\n \\\n       temp = (calculate_exp_ ## x (mid - 1) * (1 - r * rexp_d));\\\n-      asm volatile (\"\" : \"+m\" (temp));\\\n \\\n       if (m < temp)\\\n         { \\\n@@ -894,22 +895,11 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \t}\\\n     }\\\n \\\n-  if (e > 4)\\\n-    e = 4;\\\n-  if (e < 0)\\\n-    nb = 4;\\\n-  else\\\n-    nb = e + 2;\\\n-\\\n-  nb = nb >= w ? 0 : nb;\\\n+  nb = e <= 0 ? 4 : e + 2;\\\n+  nb = nb >= w ? w - 1 : nb;\\\n   newf->format = FMT_F;\\\n-  newf->u.real.w = f->u.real.w - nb;\\\n-\\\n-  if (m == 0.0)\\\n-    newf->u.real.d = d - 1;\\\n-  else\\\n-    newf->u.real.d = - (mid - d - 1);\\\n-\\\n+  newf->u.real.w = w - nb;\\\n+  newf->u.real.d = m == 0.0 ? d - 1 : -(mid - d - 1) ;\\\n   dtp->u.p.scale_factor = 0;\\\n \\\n  finish:\\\n@@ -931,7 +921,7 @@ output_float_FMT_G_ ## x (st_parameter_dt *dtp, const fnode *f, \\\n \t  gfc_char4_t *p4 = (gfc_char4_t *) p;\\\n \t  memset4 (p4, pad, nb);\\\n \t}\\\n-      else\\\n+      else \\\n \tmemset (p, pad, nb);\\\n     }\\\n }\\\n@@ -1010,19 +1000,20 @@ __qmath_(quadmath_snprintf) (buffer, sizeof buffer, \\\n \t\t\tedigits);\\\n \telse \\\n \t  output_float_FMT_G_ ## x (dtp, f, tmp, buffer, size, sign_bit, \\\n-\t\t\t\t    zero_flag, ndigits, edigits);\\\n+\t\t\t\t    zero_flag, ndigits, edigits, comp_d);\\\n }\\\n \n /* Output a real number according to its format.  */\n \n static void\n-write_float (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n+write_float (st_parameter_dt *dtp, const fnode *f, const char *source, \\\n+            int len, int comp_d)\n {\n \n #if defined(HAVE_GFC_REAL_16) || __LDBL_DIG__ > 18\n-# define MIN_FIELD_WIDTH 48\n+# define MIN_FIELD_WIDTH 49\n #else\n-# define MIN_FIELD_WIDTH 31\n+# define MIN_FIELD_WIDTH 32\n #endif\n #define STR(x) STR1(x)\n #define STR1(x) #x\n@@ -1039,23 +1030,8 @@ write_float (st_parameter_dt *dtp, const fnode *f, const char *source, int len)\n      to handle the largest number of exponent digits expected.  */\n   edigits=4;\n \n-  if (f->format == FMT_F || f->format == FMT_EN || f->format == FMT_G \n-      || ((f->format == FMT_D || f->format == FMT_E)\n-      && dtp->u.p.scale_factor != 0))\n-    {\n-      /* Always convert at full precision to avoid double rounding.  */\n-      ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n-    }\n-  else\n-    {\n-      /* The number of digits is known, so let printf do the rounding.  */\n-      if (f->format == FMT_ES)\n-\tndigits = f->u.real.d + 1;\n-      else\n-\tndigits = f->u.real.d;\n-      if (ndigits > MIN_FIELD_WIDTH - 4 - edigits)\n-\tndigits = MIN_FIELD_WIDTH - 4 - edigits;\n-    }\n+  /* Always convert at full precision to avoid double rounding.  */\n+    ndigits = MIN_FIELD_WIDTH - 4 - edigits;\n \n   switch (len)\n     {"}]}