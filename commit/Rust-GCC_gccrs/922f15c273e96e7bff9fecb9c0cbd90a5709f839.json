{"sha": "922f15c273e96e7bff9fecb9c0cbd90a5709f839", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIyZjE1YzI3M2U5NmU3YmZmOWZlY2I5YzBjYmQ5MGE1NzA5ZjgzOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2010-05-17T23:02:47Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2010-05-17T23:02:47Z"}, "message": "cgraph.h (struct ipa_replace_map): Add parm_num parameter.\n\n\n\t* cgraph.h (struct ipa_replace_map): Add parm_num parameter.\n\t* lto-cgraph.c (output_cgraph_opt_summary, input_cgraph_opt_summary):\n\tNew functions.\n\t(output_cgraph): Call output_cgraph_opt_summary.\n\t(input_cgrpah): Call input_cgraph_opt_summary.\n\t(output_cgraph_opt_summary_p, output_node_opt_summary,\n\tinput_node_opt_summary, input_cgraph_opt_section): New functions.\n\t* lto-section-in.c (lto_section_name): Add cgraphopt.\n\t* tree-inline.c (tree_function_versioning): Handle parm_num.\n\t* lto-streamer.c (lto_get_section_name): Handle cgraphopt.\n\t* lto-streamer.h (lto_section_type): Add LTO_section_cgraph_opt_sum.\n\nFrom-SVN: r159517", "tree": {"sha": "8dc7afe7cb29c4f8a1378cea118b057dbc8b8444", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8dc7afe7cb29c4f8a1378cea118b057dbc8b8444"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/922f15c273e96e7bff9fecb9c0cbd90a5709f839", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922f15c273e96e7bff9fecb9c0cbd90a5709f839", "html_url": "https://github.com/Rust-GCC/gccrs/commit/922f15c273e96e7bff9fecb9c0cbd90a5709f839", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/922f15c273e96e7bff9fecb9c0cbd90a5709f839/comments", "author": null, "committer": null, "parents": [{"sha": "28632d639518d2d98347218a1269548fa2c22765", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28632d639518d2d98347218a1269548fa2c22765", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28632d639518d2d98347218a1269548fa2c22765"}], "stats": {"total": 234, "additions": 233, "deletions": 1}, "files": [{"sha": "9a7b3c6c52d923398dcd090699db571a0f360c96", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -1,3 +1,17 @@\n+2010-05-17  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h (struct ipa_replace_map): Add parm_num parameter.\n+\t* lto-cgraph.c (output_cgraph_opt_summary, input_cgraph_opt_summary):\n+\tNew functions.\n+\t(output_cgraph): Call output_cgraph_opt_summary.\n+\t(input_cgrpah): Call input_cgraph_opt_summary.\n+\t(output_cgraph_opt_summary_p, output_node_opt_summary,\n+\tinput_node_opt_summary, input_cgraph_opt_section): New functions.\n+\t* lto-section-in.c (lto_section_name): Add cgraphopt.\n+\t* tree-inline.c (tree_function_versioning): Handle parm_num.\n+\t* lto-streamer.c (lto_get_section_name): Handle cgraphopt.\n+\t* lto-streamer.h (lto_section_type): Add LTO_section_cgraph_opt_sum.\n+\n 2010-05-17  Changpeng Fang  <changpeng.fang@amd.com>\n \n \t* doc/invoke.texi: Update documentation for min-insn-to-prefetch-ratio."}, {"sha": "b0923019c711c9e97ab2e280e4d4d7d2a0b97eba", "filename": "gcc/cgraph.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -157,6 +157,8 @@ struct GTY(()) ipa_replace_map\n   tree old_tree;\n   /* The new (replacing) tree.  */\n   tree new_tree;\n+  /* Parameter number to replace, when old_tree is NULL.  */\n+  int parm_num;\n   /* True when a substitution should be done, false otherwise.  */\n   bool replace_p;\n   /* True when we replace a reference to old_tree.  */"}, {"sha": "8b0f8e105f7c87e9d85765cfa03858b132d55f91", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 202, "deletions": 0, "changes": 202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -47,6 +47,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcov-io.h\"\n \n static void output_varpool (cgraph_node_set, varpool_node_set);\n+static void output_cgraph_opt_summary (void);\n+static void input_cgraph_opt_summary (VEC (cgraph_node_ptr, heap) * nodes);\n+\n \n /* Cgraph streaming is organized as set of record whose type\n    is indicated by a tag.  */\n@@ -840,6 +843,9 @@ output_cgraph (cgraph_node_set set, varpool_node_set vset)\n   lto_varpool_encoder_t varpool_encoder;\n   struct cgraph_asm_node *can;\n \n+  if (flag_wpa)\n+    output_cgraph_opt_summary ();\n+\n   ob = lto_create_simple_output_block (LTO_section_cgraph);\n \n   output_profile_summary (ob);\n@@ -1403,6 +1409,8 @@ input_cgraph (void)\n       input_refs (ib, nodes, varpool);\n       lto_destroy_simple_input_block (file_data, LTO_section_refs,\n \t\t\t\t      ib, data, len);\n+      if (flag_ltrans)\n+\tinput_cgraph_opt_summary (nodes);\n       VEC_free (cgraph_node_ptr, heap, nodes);\n       VEC_free (varpool_node_ptr, heap, varpool);\n     }\n@@ -1420,3 +1428,197 @@ input_cgraph (void)\n \tnode->aux = NULL;\n     }\n }\n+\n+/* True when we need optimization summary for NODE.  */\n+\n+static int\n+output_cgraph_opt_summary_p (struct cgraph_node *node)\n+{\n+  if (!node->clone_of)\n+    return false;\n+  return (node->clone.tree_map\n+          || node->clone.args_to_skip\n+          || node->clone.combined_args_to_skip);\n+}\n+\n+/* Output optimization summary for NODE to OB.  */\n+\n+static void\n+output_node_opt_summary (struct output_block *ob,\n+\t\t\t struct cgraph_node *node)\n+{\n+  unsigned int index;\n+  bitmap_iterator bi;\n+  struct ipa_replace_map *map;\n+  struct bitpack_d *bp;\n+  int i;\n+\n+  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t     bitmap_count_bits (node->clone.args_to_skip));\n+  EXECUTE_IF_SET_IN_BITMAP (node->clone.args_to_skip, 0, index, bi)\n+    lto_output_uleb128_stream (ob->main_stream, index);\n+  lto_output_uleb128_stream (ob->main_stream,\n+\t\t\t     bitmap_count_bits (node->clone.combined_args_to_skip));\n+  EXECUTE_IF_SET_IN_BITMAP (node->clone.combined_args_to_skip, 0, index, bi)\n+    lto_output_uleb128_stream (ob->main_stream, index);\n+  lto_output_uleb128_stream (ob->main_stream,\n+\t\t             VEC_length (ipa_replace_map_p, node->clone.tree_map));\n+  for (i = 0; VEC_iterate (ipa_replace_map_p, node->clone.tree_map, i, map); i++)\n+    {\n+      int parm_num;\n+      tree parm;\n+\n+      for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm;\n+\t   parm = TREE_CHAIN (parm), parm_num++)\n+\tif (map->old_tree == parm)\n+\t  break;\n+      /* At the moment we assume all old trees to be PARM_DECLs, because we have no\n+         mechanism to store function local declarations into summaries.  */\n+      gcc_assert (parm);\n+      lto_output_uleb128_stream (ob->main_stream, parm_num);\n+      lto_output_tree (ob, map->new_tree, true);\n+      bp = bitpack_create ();\n+      bp_pack_value (bp, map->replace_p, 1);\n+      bp_pack_value (bp, map->ref_p, 1);\n+      lto_output_bitpack (ob->main_stream, bp);\n+      bitpack_delete (bp);\n+    }\n+}\n+\n+/* Output optimization summaries stored in callgraph.\n+   At the moment it is the clone info structure.  */\n+\n+static void\n+output_cgraph_opt_summary (void)\n+{\n+  struct cgraph_node *node;\n+  int i, n_nodes;\n+  lto_cgraph_encoder_t encoder;\n+  struct output_block *ob = create_output_block (LTO_section_cgraph_opt_sum);\n+  unsigned count = 0;\n+\n+  ob->cgraph_node = NULL;\n+  encoder = ob->decl_state->cgraph_node_encoder;\n+  n_nodes = lto_cgraph_encoder_size (encoder);\n+  for (i = 0; i < n_nodes; i++)\n+    if (output_cgraph_opt_summary_p (lto_cgraph_encoder_deref (encoder, i)))\n+      count++;\n+  lto_output_uleb128_stream (ob->main_stream, count);\n+  for (i = 0; i < n_nodes; i++)\n+    {\n+      node = lto_cgraph_encoder_deref (encoder, i);\n+      if (output_cgraph_opt_summary_p (node))\n+\t{\n+\t  lto_output_uleb128_stream (ob->main_stream, i);\n+\t  output_node_opt_summary (ob, node);\n+\t}\n+    }\n+  produce_asm (ob, NULL);\n+  destroy_output_block (ob);\n+}\n+\n+/* Input optimiation summary of NODE.  */\n+\n+static void\n+input_node_opt_summary (struct cgraph_node *node,\n+\t\t\tstruct lto_input_block *ib_main,\n+\t\t\tstruct data_in *data_in)\n+{\n+  int i;\n+  int count;\n+  int bit;\n+  struct bitpack_d *bp;\n+\n+  count = lto_input_uleb128 (ib_main);\n+  if (count)\n+    node->clone.args_to_skip = BITMAP_GGC_ALLOC ();\n+  for (i = 0; i < count; i++)\n+    {\n+      bit = lto_input_uleb128 (ib_main);\n+      bitmap_set_bit (node->clone.args_to_skip, bit);\n+    }\n+  count = lto_input_uleb128 (ib_main);\n+  if (count)\n+    node->clone.combined_args_to_skip = BITMAP_GGC_ALLOC ();\n+  for (i = 0; i < count; i++)\n+    {\n+      bit = lto_input_uleb128 (ib_main);\n+      bitmap_set_bit (node->clone.combined_args_to_skip, bit);\n+    }\n+  count = lto_input_uleb128 (ib_main);\n+  for (i = 0; i < count; i++)\n+    {\n+      int parm_num;\n+      tree parm;\n+      struct ipa_replace_map *map = GGC_NEW (struct ipa_replace_map);\n+\n+      VEC_safe_push (ipa_replace_map_p, gc, node->clone.tree_map, map);\n+      for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm_num;\n+\t   parm = TREE_CHAIN (parm))\n+\tparm_num --;\n+      map->parm_num = lto_input_uleb128 (ib_main);\n+      map->old_tree = NULL;\n+      map->new_tree = lto_input_tree (ib_main, data_in);\n+      bp = lto_input_bitpack (ib_main);\n+      map->replace_p = bp_unpack_value (bp, 1);\n+      map->ref_p = bp_unpack_value (bp, 1);\n+      bitpack_delete (bp);\n+    }\n+}\n+\n+/* Read section in file FILE_DATA of length LEN with data DATA.  */\n+\n+static void\n+input_cgraph_opt_section (struct lto_file_decl_data *file_data,\n+\t\t\t  const char *data, size_t len, VEC (cgraph_node_ptr,\n+\t\t\t\t\t\t\t     heap) * nodes)\n+{\n+  const struct lto_function_header *header =\n+    (const struct lto_function_header *) data;\n+  const int32_t cfg_offset = sizeof (struct lto_function_header);\n+  const int32_t main_offset = cfg_offset + header->cfg_size;\n+  const int32_t string_offset = main_offset + header->main_size;\n+  struct data_in *data_in;\n+  struct lto_input_block ib_main;\n+  unsigned int i;\n+  unsigned int count;\n+\n+  LTO_INIT_INPUT_BLOCK (ib_main, (const char *) data + main_offset, 0,\n+\t\t\theader->main_size);\n+\n+  data_in =\n+    lto_data_in_create (file_data, (const char *) data + string_offset,\n+\t\t\theader->string_size, NULL);\n+  count = lto_input_uleb128 (&ib_main);\n+\n+  for (i = 0; i < count; i++)\n+    {\n+      int ref = lto_input_uleb128 (&ib_main);\n+      input_node_opt_summary (VEC_index (cgraph_node_ptr, nodes, ref),\n+\t\t\t      &ib_main, data_in);\n+    }\n+  lto_free_section_data (file_data, LTO_section_jump_functions, NULL, data,\n+\t\t\t len);\n+  lto_data_in_delete (data_in);\n+}\n+\n+/* Input optimization summary of cgraph.  */\n+\n+static void\n+input_cgraph_opt_summary (VEC (cgraph_node_ptr, heap) * nodes)\n+{\n+  struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n+  struct lto_file_decl_data *file_data;\n+  unsigned int j = 0;\n+\n+  while ((file_data = file_data_vec[j++]))\n+    {\n+      size_t len;\n+      const char *data =\n+\tlto_get_section_data (file_data, LTO_section_cgraph_opt_sum, NULL,\n+\t\t\t      &len);\n+\n+      if (data)\n+\tinput_cgraph_opt_section (file_data, data, len, nodes);\n+    }\n+}"}, {"sha": "6d081d8c1977adaac9969b070d31b1dee7495dfe", "filename": "gcc/lto-section-in.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-section-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-section-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-section-in.c?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -58,7 +58,8 @@ const char *lto_section_name[LTO_N_SECTION_TYPES] =\n   \"ipa_pure_const\",\n   \"ipa_reference\",\n   \"symtab\",\n-  \"opts\"\n+  \"opts\",\n+  \"cgraphopt\"\n };\n \n unsigned char"}, {"sha": "20ce0751d3d53f193a8e553f0a1219088c3deba2", "filename": "gcc/lto-streamer.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-streamer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-streamer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.c?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -178,6 +178,9 @@ lto_get_section_name (int section_type, const char *name)\n     case LTO_section_opts:\n       return concat (LTO_SECTION_NAME_PREFIX, \".opts\", NULL);\n \n+    case LTO_section_cgraph_opt_sum:\n+      return concat (LTO_SECTION_NAME_PREFIX, \".cgraphopt\", NULL);\n+\n     default:\n       internal_error (\"bytecode stream: unexpected LTO section %s\", name);\n     }"}, {"sha": "b7c0c367d0cf35b6a952ea3d8f590f06535e1d9e", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -264,6 +264,7 @@ enum lto_section_type\n   LTO_section_ipa_reference,\n   LTO_section_symtab,\n   LTO_section_opts,\n+  LTO_section_cgraph_opt_sum,\n   LTO_N_SECTION_TYPES\t\t/* Must be last.  */\n };\n "}, {"sha": "bb2ee237ff3323ab424579cdce32962b1be5dc4b", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/922f15c273e96e7bff9fecb9c0cbd90a5709f839/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=922f15c273e96e7bff9fecb9c0cbd90a5709f839", "patch": "@@ -4945,6 +4945,15 @@ tree_function_versioning (tree old_decl, tree new_decl,\n \tif (replace_info->replace_p)\n \t  {\n \t    tree op = replace_info->new_tree;\n+\t    if (!replace_info->old_tree)\n+\t      {\n+\t\tint i = replace_info->parm_num;\n+\t\ttree parm;\n+\t\tfor (parm = DECL_ARGUMENTS (old_decl); i; parm = TREE_CHAIN (parm))\n+\t\t  i --;\n+\t\treplace_info->old_tree = parm;\n+\t      }\n+\t\t\n \n \t    STRIP_NOPS (op);\n "}]}