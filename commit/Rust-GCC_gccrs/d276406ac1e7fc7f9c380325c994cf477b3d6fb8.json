{"sha": "d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI3NjQwNmFjMWU3ZmM3ZjljMzgwMzI1Yzk5NGNmNDc3YjNkNmZiOA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-09T13:03:28Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-09T13:03:28Z"}, "message": "Support profile (BB counts and edge probabilities) in GIMPLE FE.\n\n2019-05-09  Martin Liska  <mliska@suse.cz>\n\n\t* tree-cfg.c (dump_function_to_file): Dump entry BB count.\n\t* gimple-pretty-print.c (dump_gimple_bb_header):\n\tDump BB count.\n\t(pp_cfg_jump): Dump edge probability.\n\t* profile-count.c (profile_quality_as_string): Simplify\n\twith a static array.\n\t(parse_profile_quality): New function.\n\t(profile_count::dump): Simplify with a static array.\n\t(profile_count::from_gcov_type): Add new argument.\n\t* profile-count.h (parse_profile_quality): Likewise.\n\t* predict.h (set_hot_bb_threshold): New.\n\t* params.def (PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD):\n\tNew param.\n\t* predict.c (get_hot_bb_threshold): Set from the new param.\n\t(set_hot_bb_threshold): New.\n2019-05-09  Martin Liska  <mliska@suse.cz>\n\n\t* gimple-parser.c (struct gimple_parser): Add probability.\n\tfor gimple_parser_edge.\n\t(gimple_parser::push_edge): Add new argument probability.\n\t(c_parser_gimple_parse_bb_spec): Parse also probability\n\tif present.\n\t(c_parser_parse_gimple_body): Set edge probability.\n\t(c_parser_gimple_compound_statement): Consume token\n\tbefore calling c_parser_gimple_goto_stmt.\n\tParse BB counts.\n\t(c_parser_gimple_statement): Pass new argument.\n\t(c_parser_gimple_goto_stmt): Likewise.\n\t(c_parser_gimple_if_stmt): Likewise.\n\t(c_parser_gimple_or_rtl_pass_list): Parse hot_bb_threshold.\n\t* c-parser.c (c_parser_declaration_or_fndef): Pass\n\thot_bb_threshold argument.\n\t* c-tree.h (struct c_declspecs): Add hot_bb_threshold\n\tfield.\n\t(c_parser_gimple_parse_bb_spec_edge_probability): New.\n2019-05-09  Martin Liska  <mliska@suse.cz>\n\n\t* gcc.dg/gimplefe-37.c: New test.\n\t* gcc.dg/gimplefe-33.c: Likewise.\n\nFrom-SVN: r271034", "tree": {"sha": "aaacbcded0429a0522a06ff2c662c5f3910bcaf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aaacbcded0429a0522a06ff2c662c5f3910bcaf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "555dbc42b2dfed0c9e70e9e53fcd569f82aeae02", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/555dbc42b2dfed0c9e70e9e53fcd569f82aeae02", "html_url": "https://github.com/Rust-GCC/gccrs/commit/555dbc42b2dfed0c9e70e9e53fcd569f82aeae02"}], "stats": {"total": 448, "additions": 377, "deletions": 71}, "files": [{"sha": "45360fa18ffe3e1efb69c1fae5c2f8b3d0b9379d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -1,3 +1,21 @@\n+2019-05-09  Martin Liska  <mliska@suse.cz>\n+\n+\t* tree-cfg.c (dump_function_to_file): Dump entry BB count.\n+\t* gimple-pretty-print.c (dump_gimple_bb_header):\n+\tDump BB count.\n+\t(pp_cfg_jump): Dump edge probability.\n+\t* profile-count.c (profile_quality_as_string): Simplify\n+\twith a static array.\n+\t(parse_profile_quality): New function.\n+\t(profile_count::dump): Simplify with a static array.\n+\t(profile_count::from_gcov_type): Add new argument.\n+\t* profile-count.h (parse_profile_quality): Likewise.\n+\t* predict.h (set_hot_bb_threshold): New.\n+\t* params.def (PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD):\n+\tNew param.\n+\t* predict.c (get_hot_bb_threshold): Set from the new param.\n+\t(set_hot_bb_threshold): New.\n+\n 2019-05-09  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/90395"}, {"sha": "67f0e082f000f8332cc6f4e9731f9bc5f778052a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -1,3 +1,24 @@\n+2019-05-09  Martin Liska  <mliska@suse.cz>\n+\n+\t* gimple-parser.c (struct gimple_parser): Add probability.\n+\tfor gimple_parser_edge.\n+\t(gimple_parser::push_edge): Add new argument probability.\n+\t(c_parser_gimple_parse_bb_spec): Parse also probability\n+\tif present.\n+\t(c_parser_parse_gimple_body): Set edge probability.\n+\t(c_parser_gimple_compound_statement): Consume token\n+\tbefore calling c_parser_gimple_goto_stmt.\n+\tParse BB counts.\n+\t(c_parser_gimple_statement): Pass new argument.\n+\t(c_parser_gimple_goto_stmt): Likewise.\n+\t(c_parser_gimple_if_stmt): Likewise.\n+\t(c_parser_gimple_or_rtl_pass_list): Parse hot_bb_threshold.\n+\t* c-parser.c (c_parser_declaration_or_fndef): Pass\n+\thot_bb_threshold argument.\n+\t* c-tree.h (struct c_declspecs): Add hot_bb_threshold\n+\tfield.\n+\t(c_parser_gimple_parse_bb_spec_edge_probability): New.\n+\n 2019-04-26  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR debug/90197"}, {"sha": "3aa85125cf1a06a227a53032b09f779905bae38f", "filename": "gcc/c/c-parser.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -2347,7 +2347,8 @@ c_parser_declaration_or_fndef (c_parser *parser, bool fndef_ok,\n \t  bool saved = in_late_binary_op;\n \t  in_late_binary_op = true;\n \t  c_parser_parse_gimple_body (parser, specs->gimple_or_rtl_pass,\n-\t\t\t\t      specs->declspec_il);\n+\t\t\t\t      specs->declspec_il,\n+\t\t\t\t      specs->entry_bb_count);\n \t  in_late_binary_op = saved;\n \t}\n       else"}, {"sha": "346f46a5207a41465467665f57558f40430ef9d4", "filename": "gcc/c/c-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-tree.h?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -317,6 +317,8 @@ struct c_declspecs {\n   tree attrs;\n   /* The pass to start compiling a __GIMPLE or __RTL function with.  */\n   char *gimple_or_rtl_pass;\n+  /* ENTRY BB count.  */\n+  profile_count entry_bb_count;\n   /* The base-2 log of the greatest alignment required by an _Alignas\n      specifier, in bytes, or -1 if no such specifiers with nonzero\n      alignment.  */"}, {"sha": "ede5a927c3de9bf039b857bd892014a87cf41e6f", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 161, "deletions": 22, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-phinodes.h\"\n #include \"tree-into-ssa.h\"\n #include \"bitmap.h\"\n+#include \"params.h\"\n \n \n /* GIMPLE parser state.  */\n@@ -81,20 +82,23 @@ struct gimple_parser\n     int src;\n     int dest;\n     int flags;\n+    profile_probability probability;\n   };\n   auto_vec<gimple_parser_edge> edges;\n   basic_block current_bb;\n \n-  void push_edge (int, int, int);\n+  void push_edge (int, int, int, profile_probability);\n };\n \n void\n-gimple_parser::push_edge (int src, int dest, int flags)\n+gimple_parser::push_edge (int src, int dest, int flags,\n+\t\t\t  profile_probability prob)\n {\n   gimple_parser_edge e;\n   e.src = src;\n   e.dest = dest;\n   e.flags = flags;\n+  e.probability = prob;\n   edges.safe_push (e);\n }\n \n@@ -120,7 +124,7 @@ static void c_parser_gimple_expr_list (gimple_parser &, vec<tree> *);\n \n \n /* See if VAL is an identifier matching __BB<num> and return <num>\n-   in *INDEX.  Return true if so.  */\n+   in *INDEX.  */\n \n static bool\n c_parser_gimple_parse_bb_spec (tree val, int *index)\n@@ -134,11 +138,77 @@ c_parser_gimple_parse_bb_spec (tree val, int *index)\n   return *index > 0;\n }\n \n+/* See if VAL is an identifier matching __BB<num> and return <num>\n+   in *INDEX.  Return true if so and parse also FREQUENCY of\n+   the edge.  */\n+\n+\n+static bool\n+c_parser_gimple_parse_bb_spec_edge_probability (tree val,\n+\t\t\t\t\t\tgimple_parser &parser,\n+\t\t\t\t\t\tint *index,\n+\t\t\t\t\t\tprofile_probability *probablity)\n+{\n+  bool return_p = c_parser_gimple_parse_bb_spec (val, index);\n+  if (return_p)\n+    {\n+      *probablity = profile_probability::uninitialized ();\n+      /* Parse frequency if provided.  */\n+      if (c_parser_next_token_is (parser, CPP_OPEN_PAREN))\n+\t{\n+\t  tree f;\n+\t  c_parser_consume_token (parser);\n+\t  if (!c_parser_next_token_is (parser, CPP_NAME))\n+\t    {\n+\t      c_parser_error (parser, \"expected frequency quality\");\n+\t      return false;\n+\t    }\n+\n+\t  profile_quality quality;\n+\t  const char *v\n+\t    = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n+\t  if (!parse_profile_quality (v, &quality))\n+\t    {\n+\t      c_parser_error (parser, \"unknown profile quality\");\n+\t      return false;\n+\t    }\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t    return false;\n+\n+\t  if (!c_parser_next_token_is (parser, CPP_NUMBER)\n+\t      || (TREE_CODE (f = c_parser_peek_token (parser)->value)\n+\t\t  != INTEGER_CST))\n+\t    {\n+\t      c_parser_error (parser, \"expected frequency value\");\n+\t      return false;\n+\t    }\n+\n+\t  unsigned int value = TREE_INT_CST_LOW (f);\n+\t  *probablity = profile_probability (value, quality);\n+\n+\t  c_parser_consume_token (parser);\n+\t  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\t    return false;\n+\n+\t  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\t    return false;\n+\t}\n+\n+      return true;\n+    }\n+\n+  return false;\n+\n+}\n+\n /* Parse the body of a function declaration marked with \"__GIMPLE\".  */\n \n void\n c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n-\t\t\t    enum c_declspec_il cdil)\n+\t\t\t    enum c_declspec_il cdil,\n+\t\t\t    profile_count entry_bb_count)\n {\n   gimple_parser parser (cparser);\n   gimple_seq seq = NULL;\n@@ -209,9 +279,12 @@ c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n \t  add_local_decl (cfun, var);\n       /* We have a CFG.  Build the edges.  */\n       for (unsigned i = 0; i < parser.edges.length (); ++i)\n-\tmake_edge (BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].src),\n-\t\t   BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].dest),\n-\t\t   parser.edges[i].flags);\n+\t{\n+\t  edge e = make_edge (BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].src),\n+\t\t\t      BASIC_BLOCK_FOR_FN (cfun, parser.edges[i].dest),\n+\t\t\t      parser.edges[i].flags);\n+\t  e->probability = parser.edges[i].probability;\n+\t}\n       /* Add edges for case labels.  */\n       basic_block bb;\n       FOR_EACH_BB_FN (bb, cfun)\n@@ -274,6 +347,13 @@ c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n       fix_loop_structure (NULL);\n     }\n \n+  if (cfun->curr_properties & PROP_cfg)\n+    {\n+      ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = entry_bb_count;\n+      gcov_type t = PARAM_VALUE (PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD);\n+      set_hot_bb_threshold (t);\n+      update_max_bb_count ();\n+    }\n   dump_function (TDI_gimple, current_function_decl);\n }\n \n@@ -337,11 +417,9 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\tc_parser_consume_token (parser);\n \t\tif (c_parser_next_token_is (parser, CPP_NAME))\n \t\t  {\n-\t\t    c_parser_gimple_goto_stmt (parser, loc,\n-\t\t\t\t\t       c_parser_peek_token\n-\t\t\t\t\t       (parser)->value,\n-\t\t\t\t\t       seq);\n+\t\t    tree label = c_parser_peek_token (parser)->value;\n \t\t    c_parser_consume_token (parser);\n+\t\t    c_parser_gimple_goto_stmt (parser, loc, label, seq);\n \t\t    if (! c_parser_require (parser, CPP_SEMICOLON,\n \t\t\t\t\t    \"expected %<;%>\"))\n \t\t      return return_p;\n@@ -355,7 +433,8 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t\t\t      \"expected %<;%>\"))\n \t\treturn return_p;\n \t      if (cfun->curr_properties & PROP_cfg)\n-\t\tparser.push_edge (parser.current_bb->index, EXIT_BLOCK, 0);\n+\t\tparser.push_edge (parser.current_bb->index, EXIT_BLOCK, 0,\n+\t\t\t\t  profile_probability::uninitialized ());\n \t      break;\n \t    default:\n \t      goto expr_stmt;\n@@ -397,6 +476,7 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t  return return_p;\n \t\t}\n \t      int is_loop_header_of = -1;\n+\t      profile_count bb_count = profile_count::uninitialized ();\n \t      c_parser_consume_token (parser);\n \t      while (c_parser_next_token_is (parser, CPP_COMMA))\n \t\t{\n@@ -430,10 +510,39 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t\t\t\t      \"expected %<)%>\"))\n \t\t\treturn return_p;\n \t\t    }\n+\t\t  /* Parse profile: quality(value) */\n \t\t  else\n \t\t    {\n-\t\t      c_parser_error (parser, \"unknown block specifier\");\n-\t\t      return return_p;\n+\t\t      tree q;\n+\t\t      profile_quality quality;\n+\t\t      tree v = c_parser_peek_token (parser)->value;\n+\t\t      if (!parse_profile_quality (IDENTIFIER_POINTER (v),\n+\t\t\t\t\t\t  &quality))\n+\t\t\t{\n+\t\t\t  c_parser_error (parser, \"unknown block specifier\");\n+\t\t\t  return false;\n+\t\t\t}\n+\n+\t\t      c_parser_consume_token (parser);\n+\t\t      if (!c_parser_require (parser, CPP_OPEN_PAREN,\n+\t\t\t\t\t     \"expected %<(%>\"))\n+\t\t\treturn false;\n+\n+\t\t      if (!c_parser_next_token_is (parser, CPP_NUMBER)\n+\t\t\t  || (TREE_CODE (q = c_parser_peek_token (parser)->value)\n+\t\t\t      != INTEGER_CST))\n+\t\t\t{\n+\t\t\t  c_parser_error (parser, \"expected count value\");\n+\t\t\t  return false;\n+\t\t\t}\n+\n+\t\t      bb_count\n+\t\t\t= profile_count::from_gcov_type (TREE_INT_CST_LOW (q),\n+\t\t\t\t\t\t\t quality);\n+\t\t      c_parser_consume_token (parser);\n+\t\t      if (! c_parser_require (parser, CPP_CLOSE_PAREN,\n+\t\t\t\t\t      \"expected %<)%>\"))\n+\t\t\treturn return_p;\n \t\t    }\n \t\t}\n \t      if (! c_parser_require (parser, CPP_CLOSE_PAREN,\n@@ -470,7 +579,8 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\tlast_basic_block_for_fn (cfun) = index + 1;\n \t      n_basic_blocks_for_fn (cfun)++;\n \t      if (!parser.current_bb)\n-\t\tparser.push_edge (ENTRY_BLOCK, bb->index, EDGE_FALLTHRU);\n+\t\tparser.push_edge (ENTRY_BLOCK, bb->index, EDGE_FALLTHRU,\n+\t\t\t\t  profile_probability::always ());\n \n \t      /* We leave the proper setting to fixup.  */\n \t      struct loop *loop_father = loops_for_fn (cfun)->tree_root;\n@@ -498,6 +608,7 @@ c_parser_gimple_compound_statement (gimple_parser &parser, gimple_seq *seq)\n \t\t  loop_father = get_loop (cfun, is_loop_header_of);\n \t\t}\n \t      bb->loop_father = loop_father;\n+\t      bb->count = bb_count;\n \n \t      /* Stmts now go to the new block.  */\n \t      parser.current_bb = bb;\n@@ -1609,8 +1720,10 @@ c_parser_gimple_or_rtl_pass_list (c_parser *parser, c_declspecs *specs)\n     return;\n   c_parser_consume_token (parser);\n \n+  specs->entry_bb_count = profile_count::uninitialized ();\n   while (c_parser_next_token_is (parser, CPP_NAME))\n     {\n+      profile_quality quality;\n       const char *op = IDENTIFIER_POINTER (c_parser_peek_token (parser)->value);\n       c_parser_consume_token (parser);\n       if (! strcmp (op, \"startwith\"))\n@@ -1629,6 +1742,26 @@ c_parser_gimple_or_rtl_pass_list (c_parser *parser, c_declspecs *specs)\n \t  if (! c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<(%>\"))\n \t    return;\n \t}\n+      else if (parse_profile_quality (op, &quality))\n+\t{\n+\t  tree q;\n+\t  if (!c_parser_require (parser, CPP_OPEN_PAREN, \"expected %<(%>\"))\n+\t    return;\n+\n+\t  if (!c_parser_next_token_is (parser, CPP_NUMBER)\n+\t      || (TREE_CODE (q = c_parser_peek_token (parser)->value)\n+\t\t  != INTEGER_CST))\n+\t    {\n+\t      c_parser_error (parser, \"expected count value\");\n+\t      return;\n+\t    }\n+\n+\t  specs->entry_bb_count\n+\t    = profile_count::from_gcov_type (TREE_INT_CST_LOW (q), quality);\n+\t  c_parser_consume_token (parser);\n+\t  if (!c_parser_require (parser, CPP_CLOSE_PAREN, \"expected %<)%>\"))\n+\t    return;\n+\t}\n       else if (specs->declspec_il != cdil_gimple)\n \t/* Allow only one IL specifier and none on RTL.  */\n \t;\n@@ -1757,10 +1890,12 @@ c_parser_gimple_goto_stmt (gimple_parser &parser,\n   if (cfun->curr_properties & PROP_cfg)\n     {\n       int dest_index;\n-      if (c_parser_gimple_parse_bb_spec (label, &dest_index))\n+      profile_probability prob;\n+      if (c_parser_gimple_parse_bb_spec_edge_probability (label, parser,\n+\t\t\t\t\t\t\t  &dest_index, &prob))\n \t{\n \t  parser.push_edge (parser.current_bb->index, dest_index,\n-\t\t\t    EDGE_FALLTHRU);\n+\t\t\t    EDGE_FALLTHRU, prob);\n \t  return;\n \t}\n     }\n@@ -1811,10 +1946,12 @@ c_parser_gimple_if_stmt (gimple_parser &parser, gimple_seq *seq)\n       label = c_parser_peek_token (parser)->value;\n       c_parser_consume_token (parser);\n       int dest_index;\n+      profile_probability prob;\n       if ((cfun->curr_properties & PROP_cfg)\n-\t  && c_parser_gimple_parse_bb_spec (label, &dest_index))\n+\t  && c_parser_gimple_parse_bb_spec_edge_probability (label, parser,\n+\t\t\t\t\t\t\t     &dest_index, &prob))\n \tparser.push_edge (parser.current_bb->index, dest_index,\n-\t\t\t  EDGE_TRUE_VALUE);\n+\t\t\t  EDGE_TRUE_VALUE, prob);\n       else\n \tt_label = lookup_label_for_goto (loc, label);\n       if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n@@ -1844,14 +1981,16 @@ c_parser_gimple_if_stmt (gimple_parser &parser, gimple_seq *seq)\n \t  return;\n \t}\n       label = c_parser_peek_token (parser)->value;\n+      c_parser_consume_token (parser);\n       int dest_index;\n+      profile_probability prob;\n       if ((cfun->curr_properties & PROP_cfg)\n-\t  && c_parser_gimple_parse_bb_spec (label, &dest_index))\n+\t  && c_parser_gimple_parse_bb_spec_edge_probability (label, parser,\n+\t\t\t\t\t\t\t     &dest_index, &prob))\n \tparser.push_edge (parser.current_bb->index, dest_index,\n-\t\t\t  EDGE_FALSE_VALUE);\n+\t\t\t  EDGE_FALSE_VALUE, prob);\n       else\n \tf_label = lookup_label_for_goto (loc, label);\n-      c_parser_consume_token (parser);\n       if (! c_parser_require (parser, CPP_SEMICOLON, \"expected %<;%>\"))\n \treturn;\n     }"}, {"sha": "cc28c0f7bf934e4fadc7991183c84b53f6137d60", "filename": "gcc/c/gimple-parser.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fgimple-parser.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fc%2Fgimple-parser.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.h?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -22,7 +22,8 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Gimple parsing functions.  */\n extern void c_parser_parse_gimple_body (c_parser *, char *,\n-\t\t\t\t\tenum c_declspec_il);\n+\t\t\t\t\tenum c_declspec_il,\n+\t\t\t\t\tprofile_count);\n extern void c_parser_gimple_or_rtl_pass_list (c_parser *, c_declspecs *);\n \n #endif"}, {"sha": "7e3916bff86f9d2c7b03a250a61fca6368af9e1e", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -2704,6 +2704,10 @@ dump_gimple_bb_header (FILE *outf, basic_block bb, int indent,\n \t  fprintf (outf, \"%*s__BB(%d\", indent, \"\", bb->index);\n \t  if (bb->loop_father->header == bb)\n \t    fprintf (outf, \",loop_header(%d)\", bb->loop_father->num);\n+\t  if (bb->count.initialized_p ())\n+\t    fprintf (outf, \",%s(%d)\",\n+\t\t     profile_quality_as_string (bb->count.quality ()),\n+\t\t     bb->count.value ());\n \t  fprintf (outf, \"):\\n\");\n \t}\n       else\n@@ -2760,6 +2764,15 @@ pp_cfg_jump (pretty_printer *buffer, edge e, dump_flags_t flags)\n     {\n       pp_string (buffer, \"goto __BB\");\n       pp_decimal_int (buffer, e->dest->index);\n+      if (e->probability.initialized_p ())\n+\t{\n+\t  pp_string (buffer, \"(\");\n+\t  pp_string (buffer,\n+\t\t     profile_quality_as_string (e->probability.quality ()));\n+\t  pp_string (buffer, \"(\");\n+\t  pp_decimal_int (buffer, e->probability.value ());\n+\t  pp_string (buffer, \"))\");\n+\t}\n       pp_semicolon (buffer);\n     }\n   else"}, {"sha": "5830cb5d6e4b5dad77448d3ecbbf3e58a1a1eba8", "filename": "gcc/params.def", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -1419,6 +1419,12 @@ DEFPARAM(PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS,\n \t \" loops.\",\n \t 100, 0, 0)\n \n+DEFPARAM(PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD,\n+\t \"gimple-fe-computed-hot-bb-threshold\",\n+\t \"The number of executions of a basic block which is considered hot.\"\n+\t \" The parameters is used only in GIMPLE FE.\",\n+\t 0, 0, 0)\n+\n /*\n \n Local variables:"}, {"sha": "ad19d1295e030b4d18e5424237be26460ee2b510", "filename": "gcc/predict.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -132,8 +132,8 @@ get_hot_bb_threshold ()\n {\n   if (min_count == -1)\n     {\n-      min_count\n-\t= profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION);\n+      gcov_type t = profile_info->sum_max / PARAM_VALUE (HOT_BB_COUNT_FRACTION);\n+      set_hot_bb_threshold (t);\n       if (dump_file)\n \tfprintf (dump_file, \"Setting hotness threshold to %\" PRId64 \".\\n\",\n \t\t min_count);"}, {"sha": "4f0bac002d7932a616d74ab71b5cd1bacd415e61", "filename": "gcc/profile-count.c", "status": "modified", "additions": 48, "deletions": 40, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -33,34 +33,57 @@ along with GCC; see the file COPYING3.  If not see\n #include \"wide-int.h\"\n #include \"sreal.h\"\n \n+/* Names from profile_quality enum values.  */\n+\n+const char *profile_quality_names[] =\n+{\n+  \"uninitialized\",\n+  \"guessed_local\",\n+  \"guessed_global0\",\n+  \"guessed_global0adjusted\",\n+  \"guessed\",\n+  \"afdo\",\n+  \"adjusted\",\n+  \"precise\"\n+};\n+\n /* Get a string describing QUALITY.  */\n \n const char *\n profile_quality_as_string (enum profile_quality quality)\n {\n-  switch (quality)\n-    {\n-    default:\n-      gcc_unreachable ();\n-    case profile_uninitialized:\n-      return \"uninitialized\";\n-    case profile_guessed_local:\n-      return \"guessed_local\";\n-    case profile_guessed_global0:\n-      return \"guessed_global0\";\n-    case profile_guessed_global0adjusted:\n-      return \"guessed_global0adjusted\";\n-    case profile_guessed:\n-      return \"guessed\";\n-    case profile_afdo:\n-      return \"afdo\";\n-    case profile_adjusted:\n-      return \"adjusted\";\n-    case profile_precise:\n-      return \"precise\";\n-    }\n+  return profile_quality_names[quality];\n+}\n+\n+/* Parse VALUE as profile quality and return true when a valid QUALITY.  */\n+\n+bool\n+parse_profile_quality (const char *value, profile_quality *quality)\n+{\n+  for (unsigned i = 0; i < ARRAY_SIZE (profile_quality_names); i++)\n+    if (strcmp (profile_quality_names[i], value) == 0)\n+      {\n+\t*quality = (profile_quality)i;\n+\treturn true;\n+      }\n+\n+  return false;\n }\n \n+/* Display names from profile_quality enum values.  */\n+\n+const char *profile_quality_display_names[] =\n+{\n+  NULL,\n+  \"estimated locally\",\n+  \"estimated locally, globally 0\",\n+  \"estimated locally, globally 0 adjusted\",\n+  \"adjusted\",\n+  \"auto FDO\",\n+  \"guessed\",\n+  \"precise\"\n+};\n+\n /* Dump THIS to F.  */\n \n void\n@@ -69,23 +92,8 @@ profile_count::dump (FILE *f) const\n   if (!initialized_p ())\n     fprintf (f, \"uninitialized\");\n   else\n-    {\n-      fprintf (f, \"%\" PRId64, m_val);\n-      if (m_quality == profile_guessed_local)\n-\tfprintf (f, \" (estimated locally)\");\n-      else if (m_quality == profile_guessed_global0)\n-\tfprintf (f, \" (estimated locally, globally 0)\");\n-      else if (m_quality == profile_guessed_global0adjusted)\n-\tfprintf (f, \" (estimated locally, globally 0 adjusted)\");\n-      else if (m_quality == profile_adjusted)\n-\tfprintf (f, \" (adjusted)\");\n-      else if (m_quality == profile_afdo)\n-\tfprintf (f, \" (auto FDO)\");\n-      else if (m_quality == profile_guessed)\n-\tfprintf (f, \" (guessed)\");\n-      else if (m_quality == profile_precise)\n-\tfprintf (f, \" (precise)\");\n-    }\n+    fprintf (f, \"%\" PRId64 \" (%s)\", m_val,\n+\t     profile_quality_display_names[m_quality]);\n }\n \n /* Dump THIS to stderr.  */\n@@ -362,7 +370,7 @@ profile_count::combine_with_ipa_count (profile_count ipa)\n    Conversions back and forth are used to read the coverage and get it\n    into internal representation.  */\n profile_count\n-profile_count::from_gcov_type (gcov_type v)\n+profile_count::from_gcov_type (gcov_type v, profile_quality quality)\n   {\n     profile_count ret;\n     gcc_checking_assert (v >= 0);\n@@ -371,7 +379,7 @@ profile_count::from_gcov_type (gcov_type v)\n \t       \"Capping gcov count %\" PRId64 \" to max_count %\" PRId64 \"\\n\",\n \t       (int64_t) v, (int64_t) max_count);\n     ret.m_val = MIN (v, (gcov_type)max_count);\n-    ret.m_quality = profile_precise;\n+    ret.m_quality = quality;\n     return ret;\n   }\n "}, {"sha": "2669f0d5fff30adcd91bb2ae6faf79a5b62a3888", "filename": "gcc/profile-count.h", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -60,6 +60,8 @@ enum profile_quality {\n };\n \n extern const char *profile_quality_as_string (enum profile_quality);\n+extern bool parse_profile_quality (const char *value,\n+\t\t\t\t   profile_quality *quality);\n \n /* The base value for branch probability notes and edge probabilities.  */\n #define REG_BR_PROB_BASE  10000\n@@ -149,6 +151,13 @@ class GTY((user)) profile_probability\n \n   friend class profile_count;\n public:\n+  profile_probability (): m_val (uninitialized_probability),\n+    m_quality (profile_guessed)\n+  {}\n+\n+  profile_probability (uint32_t val, profile_quality quality):\n+    m_val (val), m_quality (quality)\n+  {}\n \n   /* Named probabilities.  */\n   static profile_probability never ()\n@@ -558,6 +567,12 @@ class GTY((user)) profile_probability\n       return initialized_p () && other.initialized_p () && m_val >= other.m_val;\n     }\n \n+  /* Get the value of the count.  */\n+  uint32_t value () const { return m_val; }\n+\n+  /* Get the quality of the count.  */\n+  enum profile_quality quality () const { return m_quality; }\n+\n   /* Output THIS to F.  */\n   void dump (FILE *f) const;\n \n@@ -675,7 +690,6 @@ class GTY(()) profile_count\n       return ipa_p () == other.ipa_p ();\n     }\n public:\n-\n   /* Used for counters which are expected to be never executed.  */\n   static profile_count zero ()\n     {\n@@ -737,6 +751,9 @@ class GTY(()) profile_count\n       return m_quality == profile_precise;\n     }\n \n+  /* Get the value of the count.  */\n+  uint32_t value () const { return m_val; }\n+\n   /* Get the quality of the count.  */\n   enum profile_quality quality () const { return m_quality; }\n \n@@ -1136,7 +1153,8 @@ class GTY(()) profile_count\n   /* The profiling runtime uses gcov_type, which is usually 64bit integer.\n      Conversions back and forth are used to read the coverage and get it\n      into internal representation.  */\n-  static profile_count from_gcov_type (gcov_type v);\n+  static profile_count from_gcov_type (gcov_type v,\n+\t\t\t\t       profile_quality quality = profile_precise);\n \n   /* LTO streaming support.  */\n   static profile_count stream_in (struct lto_input_block *);"}, {"sha": "4c384eac044894783e3488790cf4714cdf596f51", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -1,3 +1,8 @@\n+2019-05-09  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc.dg/gimplefe-37.c: New test.\n+\t* gcc.dg/gimplefe-33.c: Likewise.\n+\n 2019-05-09  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/90382"}, {"sha": "d3ea186d7f955ae16eab6b7c8c9848f17a33e7c9", "filename": "gcc/testsuite/gcc.dg/gimplefe-37.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-37.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-37.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-37.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fgimple -fdump-tree-optimized --param=gimple-fe-computed-hot-bb-threshold=10 \" } */\n+\n+int __GIMPLE (ssa,startwith(\"slsr\"),precise(3))\n+main (int argc)\n+{\n+  int _1;\n+\n+  __BB(2,precise(3)):\n+  if (argc_2(D) == 2)\n+    goto __BB3(precise(44739243));\n+  else\n+    goto __BB4(precise(89478485));\n+\n+  __BB(3,precise(1)):\n+  goto __BB4(precise(134217728));\n+\n+  __BB(4,precise(3)):\n+  _1 = __PHI (__BB2: 0, __BB3: 12);\n+  return _1;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"<bb \\[0-9\\]> \\\\\\[count: 3\" 2 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"<bb \\[0-9\\]> \\\\\\[count: 2\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"goto <bb \\[0-9\\]>; \\\\\\[33\\\\\\.33%\\\\\\]\" 1 \"optimized\" } } */\n+/* { dg-final { scan-tree-dump-times \"goto <bb \\[0-9\\]>; \\\\\\[66\\\\\\.67%\\\\\\]\" 1 \"optimized\" } } */"}, {"sha": "64532d87da55f148985ee947167f2c387aa9096d", "filename": "gcc/testsuite/gcc.dg/gimplefe-38.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-38.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-38.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fgimplefe-38.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fgimple -fdump-tree-slsr\" } */\n+\n+int __GIMPLE (ssa,startwith(\"slsr\"),guessed_local(1073741824))\n+main (int argc)\n+{\n+  int _1;\n+\n+  __BB(2,guessed_local(1073741824)):\n+  if (argc_2(D) == 2)\n+    goto __BB3(guessed(16777216));\n+  else\n+    goto __BB4(guessed(117440512));\n+\n+  __BB(3,guessed_local(134217728)):\n+  goto __BB4(precise(134217728));\n+\n+  __BB(4,guessed_local(1073741824)):\n+  _1 = __PHI (__BB2: 0, __BB3: 12);\n+  return _1;\n+}\n+\n+\n+/* { dg-final { scan-tree-dump-times \"<bb \\[0-9\\]> \\\\\\[local count: 1073741824\" 2 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"<bb \\[0-9\\]> \\\\\\[local count: 134217728\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"goto <bb \\[0-9\\]>; \\\\\\[12\\\\\\.50%\\\\\\]\" 1 \"slsr\" } } */\n+/* { dg-final { scan-tree-dump-times \"goto <bb \\[0-9\\]>; \\\\\\[87\\\\\\.50%\\\\\\]\" 1 \"slsr\" } } */"}, {"sha": "966ce5a373c405684eae5ee0b908426c4f93d092", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d276406ac1e7fc7f9c380325c994cf477b3d6fb8/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=d276406ac1e7fc7f9c380325c994cf477b3d6fb8", "patch": "@@ -62,6 +62,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"selftest.h\"\n #include \"opts.h\"\n #include \"asan.h\"\n+#include \"profile.h\"\n \n /* This file contains functions for building the Control Flow Graph (CFG)\n    for a function tree.  */\n@@ -7872,13 +7873,32 @@ dump_function_to_file (tree fndecl, FILE *file, dump_flags_t flags)\n   current_function_decl = fndecl;\n   if (flags & TDF_GIMPLE)\n     {\n+      static bool hotness_bb_param_printed = false;\n+      if (profile_info != NULL\n+\t  && !hotness_bb_param_printed)\n+\t{\n+\t  hotness_bb_param_printed = true;\n+\t  fprintf (file,\n+\t\t   \"/* --param=gimple-fe-computed-hot-bb-threshold=%\" PRId64\n+\t\t   \" */\\n\", get_hot_bb_threshold ());\n+\t}\n+\n       print_generic_expr (file, TREE_TYPE (TREE_TYPE (fndecl)),\n \t\t\t  dump_flags | TDF_SLIM);\n-      fprintf (file, \" __GIMPLE (%s)\\n%s (\",\n+      fprintf (file, \" __GIMPLE (%s\",\n \t       (fun->curr_properties & PROP_ssa) ? \"ssa\"\n \t       : (fun->curr_properties & PROP_cfg) ? \"cfg\"\n-\t       : \"\",\n-\t       function_name (fun));\n+\t       : \"\");\n+\n+      if (cfun->cfg)\n+\t{\n+\t  basic_block bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+\t  if (bb->count.initialized_p ())\n+\t    fprintf (file, \",%s(%d)\",\n+\t\t     profile_quality_as_string (bb->count.quality ()),\n+\t\t     bb->count.value ());\n+\t  fprintf (file, \")\\n%s (\", function_name (fun));\n+\t}\n     }\n   else\n     fprintf (file, \"%s %s(\", function_name (fun), tmclone ? \"[tm-clone] \" : \"\");"}]}