{"sha": "7194767cdf77212e8c736f41b426e3f636f52ca3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzE5NDc2N2NkZjc3MjEyZThjNzM2ZjQxYjQyNmUzZjYzNmY1MmNhMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2015-05-26T19:18:15Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2015-05-26T19:18:15Z"}, "message": "gigi.h (gnat_stabilize_reference): Adjust prototype.\n\n\t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust prototype.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not rely on const_flag\n \tto detect constant renamings.  Be prepared for specific pattern of\n\trenamed object based on function calls.  Create a constant object\n\tfor the renaming of a NULL_EXPR or of a CONSTRUCTOR.  Adjust calls\n\tto gnat_stabilize_reference and tidy up.  Remove redundant tests.\n\t(elaborate_expression_1): Remove obsolete test and tidy up.\n\t* gcc-interface/trans.c (Call_to_gnu): Do not stabilize In/Out or Out\n\tparameters passed by reference.\n\t(gnat_to_gnu) <N_Selected_Component>: Remove redundant protection again\n\tside-effects.\n\tUse gnat_protect_expr instead of gnat_stabilize_reference for general\n\tprotection against side-effects.\n\t* gcc-interface/utils2.c (gnat_stable_expr_p): New predicate.\n\t(gnat_save_expr): Invoke it.\n\t(gnat_protect_expr): Likewise.\n\t(gnat_stabilize_reference_1): Likewise.  Remove useless propagation\n\tof TREE_THIS_NOTRAP.\n\t(gnat_stabilize_reference): Remove parameter and adjust throughout.\n\tDelete ADDR_EXDR, COMPOUND_EXPR and CONSTRUCTOR cases.\n\tRestrict CALL_EXPR case to atomic loads and tweak ERROR_MARK case.\n\nFrom-SVN: r223708", "tree": {"sha": "f122b2e6ed989a86921cf79b73be23a226e14688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f122b2e6ed989a86921cf79b73be23a226e14688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7194767cdf77212e8c736f41b426e3f636f52ca3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7194767cdf77212e8c736f41b426e3f636f52ca3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7194767cdf77212e8c736f41b426e3f636f52ca3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7194767cdf77212e8c736f41b426e3f636f52ca3/comments", "author": null, "committer": null, "parents": [{"sha": "517d07c980163ac34d7bf41e3e8d8dbaa38843df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517d07c980163ac34d7bf41e3e8d8dbaa38843df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517d07c980163ac34d7bf41e3e8d8dbaa38843df"}], "stats": {"total": 366, "additions": 148, "deletions": 218}, "files": [{"sha": "951d64cff9715f00b8b46d815672e81f431b6bbb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7194767cdf77212e8c736f41b426e3f636f52ca3", "patch": "@@ -1,3 +1,27 @@\n+2015-05-26  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (gnat_stabilize_reference): Adjust prototype.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not rely on const_flag\n+ \tto detect constant renamings.  Be prepared for specific pattern of\n+\trenamed object based on function calls.  Create a constant object\n+\tfor the renaming of a NULL_EXPR or of a CONSTRUCTOR.  Adjust calls\n+\tto gnat_stabilize_reference and tidy up.  Remove redundant tests.\n+\t(elaborate_expression_1): Remove obsolete test and tidy up.\n+\t* gcc-interface/trans.c (Call_to_gnu): Do not stabilize In/Out or Out\n+\tparameters passed by reference.\n+\t(gnat_to_gnu) <N_Selected_Component>: Remove redundant protection again\n+\tside-effects.\n+\tUse gnat_protect_expr instead of gnat_stabilize_reference for general\n+\tprotection against side-effects.\n+\t* gcc-interface/utils2.c (gnat_stable_expr_p): New predicate.\n+\t(gnat_save_expr): Invoke it.\n+\t(gnat_protect_expr): Likewise.\n+\t(gnat_stabilize_reference_1): Likewise.  Remove useless propagation\n+\tof TREE_THIS_NOTRAP.\n+\t(gnat_stabilize_reference): Remove parameter and adjust throughout.\n+\tDelete ADDR_EXDR, COMPOUND_EXPR and CONSTRUCTOR cases.\n+\tRestrict CALL_EXPR case to atomic loads and tweak ERROR_MARK case.\n+\n 2015-05-26  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sinfo.ads: Minor reformatting."}, {"sha": "0a1f58aaa95da25dd9fbf8812debaf639d21f951", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 73, "deletions": 122, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=7194767cdf77212e8c736f41b426e3f636f52ca3", "patch": "@@ -955,13 +955,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* If this is a renaming, avoid as much as possible to create a new\n-\t   object.  However, in several cases, creating it is required.\n-\t   This processing needs to be applied to the raw expression so\n-\t   as to make it more likely to rename the underlying object.  */\n+\t   object.  However, in some cases, creating it is required because\n+\t   renaming can be applied to objects that are not names in Ada.\n+\t   This processing needs to be applied to the raw expression so as\n+\t   to make it more likely to rename the underlying object.  */\n \tif (Present (Renamed_Object (gnat_entity)))\n \t  {\n-\t    bool create_normal_object = false;\n-\n \t    /* If the renamed object had padding, strip off the reference\n \t       to the inner object and reset our type.  */\n \t    if ((TREE_CODE (gnu_expr) == COMPONENT_REF\n@@ -981,112 +980,84 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t     && CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n \t      gnu_type = TREE_TYPE (gnu_expr);\n \n-\t    /* Case 1: If this is a constant renaming stemming from a function\n-\t       call, treat it as a normal object whose initial value is what is\n-\t       being renamed.  RM 3.3 says that the result of evaluating a\n-\t       function call is a constant object.  Treat constant literals\n-\t       the same way.  As a consequence, it can be the inner object of\n-\t       a constant renaming.  In this case, the renaming must be fully\n-\t       instantiated, i.e. it cannot be a mere reference to (part of) an\n-\t       existing object.  */\n-\t    if (const_flag)\n-\t      {\n-\t        tree inner_object = gnu_expr;\n-\t\twhile (handled_component_p (inner_object))\n-\t\t  inner_object = TREE_OPERAND (inner_object, 0);\n-\t\tif (TREE_CODE (inner_object) == CALL_EXPR\n-\t\t    || CONSTANT_CLASS_P (inner_object))\n-\t\t  create_normal_object = true;\n-\t      }\n+\t    /* Case 1: if this is a constant renaming stemming from a function\n+\t       call, treat it as a normal object whose initial value is what\n+\t       is being renamed.  RM 3.3 says that the result of evaluating a\n+\t       function call is a constant object.  Therefore, it can be the\n+\t       inner object of a constant renaming and the renaming must be\n+\t       fully instantiated, i.e. it cannot be a reference to (part of)\n+\t       an existing object.  And treat null expressions, constructors\n+\t       and literals the same way.  */\n+\t    tree inner = gnu_expr;\n+\t    while (handled_component_p (inner) || CONVERT_EXPR_P (inner))\n+\t      inner = TREE_OPERAND (inner, 0);\n+\t    /* Expand_Dispatching_Call can prepend a comparison of the tags\n+\t       before the call to \"=\".  */\n+\t    if (TREE_CODE (inner) == TRUTH_ANDIF_EXPR)\n+\t      inner = TREE_OPERAND (inner, 1);\n+\t    if (TREE_CODE (inner) == CALL_EXPR\n+\t        || TREE_CODE (inner) == NULL_EXPR\n+\t        || TREE_CODE (inner) == CONSTRUCTOR\n+\t\t|| CONSTANT_CLASS_P (inner))\n+\t      ;\n \n-\t    /* Otherwise, see if we can proceed with a stabilized version of\n-\t       the renamed entity or if we need to make a new object.  */\n-\t    if (!create_normal_object)\n+\t    /* Case 2: if the renaming entity need not be materialized, use\n+\t       the stabilized renamed expression for the renaming.  At the\n+\t       global level, we can do this only if we know no SAVE_EXPRs\n+\t       need be made, because otherwise the expression would be tied\n+\t       to a specific elaboration routine.  */\n+\t    else if (!Materialize_Entity (gnat_entity)\n+\t\t     && (!global_bindings_p ()\n+\t\t\t || (staticp (gnu_expr)\n+\t\t\t     && !TREE_SIDE_EFFECTS (gnu_expr))))\n \t      {\n-\t\ttree maybe_stable_expr = NULL_TREE;\n-\t\tbool stable = false;\n-\n-\t\t/* Case 2: If the renaming entity need not be materialized and\n-\t\t   the renamed expression is something we can stabilize, use\n-\t\t   that for the renaming.  At the global level, we can only do\n-\t\t   this if we know no SAVE_EXPRs need be made, because the\n-\t\t   expression we return might be used in arbitrary conditional\n-\t\t   branches so we must force the evaluation of the SAVE_EXPRs\n-\t\t   immediately and this requires a proper function context.\n-\t\t   Note that an external constant is at the global level.  */\n-\t\tif (!Materialize_Entity (gnat_entity)\n-\t\t    && (!((!definition && kind == E_Constant)\n-\t\t\t  || global_bindings_p ())\n-\t\t\t|| (staticp (gnu_expr)\n-\t\t\t    && !TREE_SIDE_EFFECTS (gnu_expr))))\n-\t\t  {\n-\t\t    maybe_stable_expr\n-\t\t      = gnat_stabilize_reference (gnu_expr, true, &stable);\n+\t\tgnu_decl = gnat_stabilize_reference (gnu_expr, true);\n \n-\t\t    if (stable)\n-\t\t      {\n-\t\t\t/* ??? No DECL_EXPR is created so we need to mark\n-\t\t\t   the expression manually lest it is shared.  */\n-\t\t\tif ((!definition && kind == E_Constant)\n-\t\t\t    || global_bindings_p ())\n-\t\t\t  MARK_VISITED (maybe_stable_expr);\n-\t\t\tgnu_decl = maybe_stable_expr;\n-\t\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n-\t\t\tsaved = true;\n-\t\t\tannotate_object (gnat_entity, gnu_type, NULL_TREE,\n-\t\t\t\t\t false);\n-\t\t\t/* This assertion will fail if the renamed object\n-\t\t\t   isn't aligned enough as to make it possible to\n-\t\t\t   honor the alignment set on the renaming.  */\n-\t\t\tif (align)\n-\t\t\t  {\n-\t\t\t    unsigned int renamed_align\n-\t\t\t      = DECL_P (gnu_decl)\n-\t\t\t\t? DECL_ALIGN (gnu_decl)\n-\t\t\t\t: TYPE_ALIGN (TREE_TYPE (gnu_decl));\n-\t\t\t    gcc_assert (renamed_align >= align);\n-\t\t\t  }\n-\t\t\tbreak;\n-\t\t      }\n+\t\t/* ??? No DECL_EXPR is created so we need to mark\n+\t\t   the expression manually lest it is shared.  */\n+\t\tif (global_bindings_p ())\n+\t\t  MARK_VISITED (gnu_decl);\n \n-\t\t    /* The stabilization failed.  Keep maybe_stable_expr\n-\t\t       untouched here to let the pointer case below know\n-\t\t       about that failure.  */\n+\t\t/* This assertion will fail if the renamed object isn't\n+\t\t   aligned enough as to make it possible to honor the\n+\t\t   alignment set on the renaming.  */\n+\t\tif (align)\n+\t\t  {\n+\t\t    unsigned int ralign = DECL_P (gnu_decl)\n+\t\t\t\t\t  ? DECL_ALIGN (gnu_decl)\n+\t\t\t\t\t  : TYPE_ALIGN (TREE_TYPE (gnu_decl));\n+\t\t    gcc_assert (ralign >= align);\n \t\t  }\n \n-\t\t/* Case 3: Make this into a constant pointer to the object we\n-\t\t   are to rename and attach the object to the pointer if it is\n-\t\t   something we can stabilize.\n+\t\tsave_gnu_tree (gnat_entity, gnu_decl, true);\n+\t\tsaved = true;\n+\t\tannotate_object (gnat_entity, gnu_type, NULL_TREE, false);\n+\t\tbreak;\n+\t      }\n \n-\t\t   From the proper scope, attached objects will be referenced\n-\t\t   directly instead of indirectly via the pointer to avoid\n-\t\t   subtle aliasing problems with non-addressable entities.\n-\t\t   They have to be stable because we must not evaluate the\n-\t\t   variables in the expression every time the renaming is used.\n-\t\t   The pointer is called a \"renaming\" pointer in this case.\n+\t    /* Case 3: otherwise, make a constant pointer to the object we\n+\t       are to rename and attach the object to the pointer after it\n+\t       is stabilized.\n \n-\t\t   In the rare cases where we cannot stabilize the renamed\n-\t\t   object, we just make a \"bare\" pointer and the renamed\n-\t\t   object will always be accessed indirectly through it.\n+\t       From the proper scope, attached objects will be referenced\n+\t       directly instead of indirectly via the pointer to avoid\n+\t       subtle aliasing problems with non-addressable entities.\n+\t       They have to be stable because we must not evaluate the\n+\t       variables in the expression every time the renaming is used.\n+\t       The pointer is called a \"renaming\" pointer in this case.\n \n-\t\t   Note that we need to preserve the volatility of the renamed\n-\t\t   object through the indirection.  */\n+\t       Note that we need to preserve the volatility of the renamed\n+\t       object through the indirection.  */\n+\t    else\n+\t      {\n \t\tif (TREE_THIS_VOLATILE (gnu_expr) && !TYPE_VOLATILE (gnu_type))\n \t\t  gnu_type\n \t\t    = change_qualified_type (gnu_type, TYPE_QUAL_VOLATILE);\n \t\tgnu_type = build_reference_type (gnu_type);\n \t\tinner_const_flag = TREE_READONLY (gnu_expr);\n \t\tconst_flag = true;\n \n-\t\t/* If the previous attempt at stabilizing failed, there is\n-\t\t   no point in trying again and we reuse the result without\n-\t\t   attaching it to the pointer.  In this case it will only\n-\t\t   be used as the initializing expression of the pointer and\n-\t\t   thus needs no special treatment with regard to multiple\n-\t\t   evaluations.\n-\n-\t\t   Otherwise, try to stabilize and attach the expression to\n-\t\t   the pointer if the stabilization succeeds.\n+\t\t/* Stabilize and attach the expression to the pointer.\n \n \t\t   Note that this might introduce SAVE_EXPRs and we don't\n \t\t   check whether we are at the global level or not.  This\n@@ -1100,21 +1071,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t   non-global case or the elaboration code for the global\n \t\t   case, and will be attached to the elaboration procedure\n \t\t   in the latter case.  */\n-\t\tif (!maybe_stable_expr)\n-\t\t  {\n-\t\t    maybe_stable_expr\n-\t\t      = gnat_stabilize_reference (gnu_expr, true, &stable);\n-\n-\t\t    if (stable)\n-\t\t      renamed_obj = maybe_stable_expr;\n-\t\t  }\n+\t\trenamed_obj = gnat_stabilize_reference (gnu_expr, true);\n \n \t\tif (type_annotate_only\n- \t\t    && TREE_CODE (maybe_stable_expr) == ERROR_MARK)\n+ \t\t    && TREE_CODE (renamed_obj) == ERROR_MARK)\n \t\t  gnu_expr = NULL_TREE;\n \t\telse\n \t\t  gnu_expr\n-\t\t    = build_unary_op (ADDR_EXPR, gnu_type, maybe_stable_expr);\n+\t\t    = build_unary_op (ADDR_EXPR, gnu_type, renamed_obj);\n \n \t\tgnu_size = NULL_TREE;\n \t\tused_by_ref = true;\n@@ -1519,13 +1483,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* If this is a renaming pointer, attach the renamed object to it and\n \t   register it if we are at the global level and the renamed object\n-\t   is a non-constant reference.  Note that an external constant is at\n-\t   the global level.  */\n+\t   is a non-constant reference.  */\n \tif (renamed_obj)\n \t  {\n \t    SET_DECL_RENAMED_OBJECT (gnu_decl, renamed_obj);\n \n-\t    if (((!definition && kind == E_Constant) || global_bindings_p ())\n+\t    if (global_bindings_p ()\n \t\t&& !gnat_constant_reference_p (renamed_obj))\n \t      {\n \t\tDECL_GLOBAL_NONCONSTANT_RENAMING_P (gnu_decl) = 1;\n@@ -6197,16 +6160,6 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n   const bool expr_global_p = expr_public_p || global_bindings_p ();\n   bool expr_variable_p, use_variable;\n \n-  /* In most cases, we won't see a naked FIELD_DECL because a discriminant\n-     reference will have been replaced with a COMPONENT_REF when the type\n-     is being elaborated.  However, there are some cases involving child\n-     types where we will.  So convert it to a COMPONENT_REF.  We hope it\n-     will be at the highest level of the expression in these cases.  */\n-  if (TREE_CODE (gnu_expr) == FIELD_DECL)\n-    gnu_expr = build3 (COMPONENT_REF, TREE_TYPE (gnu_expr),\n-\t\t       build0 (PLACEHOLDER_EXPR, DECL_CONTEXT (gnu_expr)),\n-\t\t       gnu_expr, NULL_TREE);\n-\n   /* If GNU_EXPR contains a placeholder, just return it.  We rely on the fact\n      that an expression cannot contain both a discriminant and a variable.  */\n   if (CONTAINS_PLACEHOLDER_P (gnu_expr))\n@@ -6217,14 +6170,12 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, const char *s,\n      containing the definition is elaborated.  If this entity is defined at top\n      level, replace the expression by the variable; otherwise use a SAVE_EXPR\n      if this is necessary.  */\n-  if (CONSTANT_CLASS_P (gnu_expr))\n+  if (TREE_CONSTANT (gnu_expr))\n     expr_variable_p = false;\n   else\n     {\n       /* Skip any conversions and simple constant arithmetics to see if the\n-\t expression is based on a read-only variable.\n-\t ??? This really should remain read-only, but we have to think about\n-\t the typing of the tree here.  */\n+\t expression is based on a read-only variable.  */\n       tree inner = remove_conversions (gnu_expr, true);\n \n       inner = skip_simple_constant_arithmetic (inner);"}, {"sha": "2a964d2139e53404b14b78d63cc8307aaa035294", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=7194767cdf77212e8c736f41b426e3f636f52ca3", "patch": "@@ -965,9 +965,8 @@ extern tree gnat_protect_expr (tree exp);\n \n /* This is equivalent to stabilize_reference in tree.c but we know how to\n    handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  We set SUCCESS to true unless we walk\n-   through something we don't know how to stabilize.  */\n-extern tree gnat_stabilize_reference (tree ref, bool force, bool *success);\n+   force evaluation of everything.  */\n+extern tree gnat_stabilize_reference (tree ref, bool force);\n \n /* This is equivalent to get_inner_reference in expr.c but it returns the\n    ultimate containing object only if the reference (lvalue) is constant,"}, {"sha": "a506c633d9d303bcac15714dadf4790d5e9060ff", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=7194767cdf77212e8c736f41b426e3f636f52ca3", "patch": "@@ -4241,11 +4241,11 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n       /* If it's possible we may need to use this expression twice, make sure\n \t that any side-effects are handled via SAVE_EXPRs; likewise if we need\n-\t to force side-effects before the call.\n-\t ??? This is more conservative than we need since we don't need to do\n-\t this for pass-by-ref with no conversion.  */\n-      if (Ekind (gnat_formal) != E_In_Parameter)\n-\tgnu_name = gnat_stabilize_reference (gnu_name, true, NULL);\n+\t to force side-effects before the call.  */\n+      if (Ekind (gnat_formal) != E_In_Parameter\n+\t  && !is_by_ref_formal_parm\n+\t  && TREE_CODE (gnu_name) != NULL_EXPR)\n+\tgnu_name = gnat_stabilize_reference (gnu_name, true);\n \n       /* If we are passing a non-addressable parameter by reference, pass the\n \t address of a copy.  In the Out or In Out case, set up to copy back\n@@ -6099,14 +6099,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t  {\n \t    gnu_field = gnat_to_gnu_field_decl (gnat_field);\n \n-\t    /* If there are discriminants, the prefix might be evaluated more\n-\t       than once, which is a problem if it has side-effects.  */\n-\t    if (Has_Discriminants (Is_Access_Type (Etype (Prefix (gnat_node)))\n-\t\t\t\t   ? Designated_Type (Etype\n-\t\t\t\t\t\t      (Prefix (gnat_node)))\n-\t\t\t\t   : Etype (Prefix (gnat_node))))\n-\t      gnu_prefix = gnat_stabilize_reference (gnu_prefix, false, NULL);\n-\n \t    gnu_result\n \t      = build_component_ref (gnu_prefix, NULL_TREE, gnu_field,\n \t\t\t\t     (Nkind (Parent (gnat_node))\n@@ -7313,7 +7305,6 @@ gnat_to_gnu (Node_Id gnat_node)\n \t gets inserted there as well.  This ensures that the type elaboration\n \t code is issued past the actions computing values on which it might\n \t depend.  */\n-\n       start_stmt_group ();\n       add_stmt_list (Actions (gnat_node));\n       gnu_expr = gnat_to_gnu (Expression (gnat_node));\n@@ -7498,7 +7489,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t   && TYPE_IS_PADDING_P (TREE_TYPE (gnu_result)))\n       && (TREE_CODE (gnu_result_type) == UNCONSTRAINED_ARRAY_TYPE\n \t  || CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_result_type))))\n-    gnu_result = gnat_stabilize_reference (gnu_result, false, NULL);\n+    gnu_result = gnat_protect_expr (gnu_result);\n \n   /* Now convert the result to the result type, unless we are in one of the\n      following cases:"}, {"sha": "7f7a30d172b9a366e4fd4daa055717636a770c46", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 43, "deletions": 78, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7194767cdf77212e8c736f41b426e3f636f52ca3/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=7194767cdf77212e8c736f41b426e3f636f52ca3", "patch": "@@ -2563,6 +2563,17 @@ gnat_mark_addressable (tree t)\n     }\n }\n \f\n+/* Return true if EXP is a stable expression for the purpose of the functions\n+   below and, therefore, can be returned unmodified by them.  We accept things\n+   that are actual constants or that have already been handled.  */\n+\n+static bool\n+gnat_stable_expr_p (tree exp)\n+{\n+  enum tree_code code = TREE_CODE (exp);\n+  return TREE_CONSTANT (exp) || code == NULL_EXPR || code == SAVE_EXPR;\n+}\n+\n /* Save EXP for later use or reuse.  This is equivalent to save_expr in tree.c\n    but we know how to handle our own nodes.  */\n \n@@ -2572,7 +2583,7 @@ gnat_save_expr (tree exp)\n   tree type = TREE_TYPE (exp);\n   enum tree_code code = TREE_CODE (exp);\n \n-  if (TREE_CONSTANT (exp) || code == SAVE_EXPR || code == NULL_EXPR)\n+  if (gnat_stable_expr_p (exp))\n     return exp;\n \n   if (code == UNCONSTRAINED_ARRAY_REF)\n@@ -2603,7 +2614,7 @@ gnat_protect_expr (tree exp)\n   tree type = TREE_TYPE (exp);\n   enum tree_code code = TREE_CODE (exp);\n \n-  if (TREE_CONSTANT (exp) || code == SAVE_EXPR || code == NULL_EXPR)\n+  if (gnat_stable_expr_p (exp))\n     return exp;\n \n   /* If EXP has no side effects, we theoretically don't need to do anything.\n@@ -2669,11 +2680,7 @@ gnat_stabilize_reference_1 (tree e, bool force)\n   tree type = TREE_TYPE (e);\n   tree result;\n \n-  /* We cannot ignore const expressions because it might be a reference\n-     to a const array but whose index contains side-effects.  But we can\n-     ignore things that are actual constant or that already have been\n-     handled by this function.  */\n-  if (TREE_CONSTANT (e) || code == SAVE_EXPR)\n+  if (gnat_stable_expr_p (e))\n     return e;\n \n   switch (TREE_CODE_CLASS (code))\n@@ -2722,36 +2729,24 @@ gnat_stabilize_reference_1 (tree e, bool force)\n       gcc_unreachable ();\n     }\n \n-  /* See similar handling in gnat_stabilize_reference.  */\n   TREE_READONLY (result) = TREE_READONLY (e);\n   TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n \n-  if (code == INDIRECT_REF\n-      || code == UNCONSTRAINED_ARRAY_REF\n-      || code == ARRAY_REF\n-      || code == ARRAY_RANGE_REF)\n-    TREE_THIS_NOTRAP (result) = TREE_THIS_NOTRAP (e);\n-\n   return result;\n }\n \n /* This is equivalent to stabilize_reference in tree.c but we know how to\n    handle our own nodes and we take extra arguments.  FORCE says whether to\n-   force evaluation of everything.  We set SUCCESS to true unless we walk\n-   through something we don't know how to stabilize.  */\n+   force evaluation of everything.  */\n \n tree\n-gnat_stabilize_reference (tree ref, bool force, bool *success)\n+gnat_stabilize_reference (tree ref, bool force)\n {\n   tree type = TREE_TYPE (ref);\n   enum tree_code code = TREE_CODE (ref);\n   tree result;\n \n-  /* Assume we'll success unless proven otherwise.  */\n-  if (success)\n-    *success = true;\n-\n   switch (code)\n     {\n     case CONST_DECL:\n@@ -2761,15 +2756,13 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n       /* No action is needed in this case.  */\n       return ref;\n \n-    case ADDR_EXPR:\n     CASE_CONVERT:\n     case FLOAT_EXPR:\n     case FIX_TRUNC_EXPR:\n     case VIEW_CONVERT_EXPR:\n       result\n \t= build1 (code, type,\n-\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t    success));\n+\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force));\n       break;\n \n     case INDIRECT_REF:\n@@ -2781,79 +2774,51 @@ gnat_stabilize_reference (tree ref, bool force, bool *success)\n \n     case COMPONENT_REF:\n       result = build3 (COMPONENT_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t success),\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n \t\t       TREE_OPERAND (ref, 1), NULL_TREE);\n       break;\n \n     case BIT_FIELD_REF:\n       result = build3 (BIT_FIELD_REF, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t success),\n+\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n \t\t       TREE_OPERAND (ref, 1), TREE_OPERAND (ref, 2));\n       break;\n \n     case ARRAY_REF:\n     case ARRAY_RANGE_REF:\n-      result = build4 (code, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t success),\n-\t\t       gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1),\n-\t\t\t\t\t\t   force),\n-\t\t       NULL_TREE, NULL_TREE);\n+      result\n+\t= build4 (code, type,\n+\t\t  gnat_stabilize_reference (TREE_OPERAND (ref, 0), force),\n+\t\t  gnat_stabilize_reference_1 (TREE_OPERAND (ref, 1), force),\n+\t\t  TREE_OPERAND (ref, 2), TREE_OPERAND (ref, 3));\n       break;\n \n     case CALL_EXPR:\n-      if (call_is_atomic_load (ref))\n-\tresult\n-\t  = build_call_expr (TREE_OPERAND (CALL_EXPR_FN (ref), 0), 2,\n-\t\t\t     gnat_stabilize_reference (CALL_EXPR_ARG (ref, 0),\n-\t\t\t\t\t\t       force, success),\n-\t\t\t     CALL_EXPR_ARG (ref, 1));\n-      else\n-\tresult = gnat_stabilize_reference_1 (ref, force);\n-      break;\n-\n-    case COMPOUND_EXPR:\n-      result = build2 (COMPOUND_EXPR, type,\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 0), force,\n-\t\t\t\t\t\t success),\n-\t\t       gnat_stabilize_reference (TREE_OPERAND (ref, 1), force,\n-\t\t\t\t\t\t success));\n-      break;\n+      {\n+\t/* This can only be an atomic load.  */\n+\tgcc_assert (call_is_atomic_load (ref));\n+\n+\t/* An atomic load is an INDIRECT_REF of its first argument.  */\n+\ttree t = CALL_EXPR_ARG (ref, 0);\n+\tif (TREE_CODE (t) == NOP_EXPR)\n+\t  t = TREE_OPERAND (t, 0);\n+\tif (TREE_CODE (t) == ADDR_EXPR)\n+\t  t = build1 (ADDR_EXPR, TREE_TYPE (t),\n+\t\t      gnat_stabilize_reference (TREE_OPERAND (t, 0), force));\n+\telse\n+\t  t = gnat_stabilize_reference_1 (t, force);\n+\tt = fold_convert (TREE_TYPE (CALL_EXPR_ARG (ref, 0)), t);\n \n-    case CONSTRUCTOR:\n-      /* Constructors with 1 element are used extensively to formally\n-\t convert objects to special wrapping types.  */\n-      if (TREE_CODE (type) == RECORD_TYPE\n-\t  && vec_safe_length (CONSTRUCTOR_ELTS (ref)) == 1)\n-\t{\n-\t  tree index = (*CONSTRUCTOR_ELTS (ref))[0].index;\n-\t  tree value = (*CONSTRUCTOR_ELTS (ref))[0].value;\n-\t  result\n-\t    = build_constructor_single (type, index,\n-\t\t\t\t\tgnat_stabilize_reference_1 (value,\n-\t\t\t\t\t\t\t\t    force));\n-\t}\n-      else\n-\t{\n-\t  if (success)\n-\t    *success = false;\n-\t  return ref;\n-\t}\n+\tresult = build_call_expr (TREE_OPERAND (CALL_EXPR_FN (ref), 0), 2,\n+\t\t\t\t  t, CALL_EXPR_ARG (ref, 1));\n+      }\n       break;\n \n     case ERROR_MARK:\n-      ref = error_mark_node;\n-\n-      /* ...  fall through to failure ... */\n+      return error_mark_node;\n \n-      /* If arg isn't a kind of lvalue we recognize, make no change.\n-\t Caller should recognize the error for an invalid lvalue.  */\n     default:\n-      if (success)\n-\t*success = false;\n-      return ref;\n+      gcc_unreachable ();\n     }\n \n   /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS set on the initial expression"}]}