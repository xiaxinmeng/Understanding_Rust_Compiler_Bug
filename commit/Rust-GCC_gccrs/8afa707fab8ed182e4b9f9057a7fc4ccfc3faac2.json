{"sha": "8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGFmYTcwN2ZhYjhlZDE4MmU0YjlmOTA1N2E3ZmM0Y2NmYzNmYWFjMg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-01-11T03:10:12Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-01-11T03:10:12Z"}, "message": "pt.c (copy_default_args_to_explicit_spec_1): New function.\n\n\t* pt.c (copy_default_args_to_explicit_spec_1): New function.\n\t(copy_default_args_to_explicit_spec): Likewise.\n\t(check_explicit_specialization): Use it.\n\nFrom-SVN: r38893", "tree": {"sha": "dad9e6c6064b524089852c1284e19fe30da188d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dad9e6c6064b524089852c1284e19fe30da188d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/comments", "author": null, "committer": null, "parents": [{"sha": "7e1376a14cd5b2a8d1bd75524262b725ffe07f86", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1376a14cd5b2a8d1bd75524262b725ffe07f86", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1376a14cd5b2a8d1bd75524262b725ffe07f86"}], "stats": {"total": 153, "additions": 128, "deletions": 25}, "files": [{"sha": "66c05b27f456ee92321b1ccb40cb854617d591d3", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "patch": "@@ -1,5 +1,9 @@\n 2001-01-10  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* pt.c (copy_default_args_to_explicit_spec_1): New function.\n+\t(copy_default_args_to_explicit_spec): Likewise.\n+\t(check_explicit_specialization): Use it.\n+\n \t* class.c (finish_struct_1):  Remove last argument in call to\n \tmake_decl_rtl; use make_function_rtl instead of make_decl_rtl.\n \t* decl.c (builtin_function): Likewise."}, {"sha": "13f9d203bfe5762287993f4dfd95845c317dcbb4", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 111, "deletions": 25, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "patch": "@@ -167,6 +167,8 @@ static int template_args_equal PARAMS ((tree, tree));\n static void tsubst_default_arguments PARAMS ((tree));\n static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n static tree instantiate_clone PARAMS ((tree, tree));\n+static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n+static void copy_default_args_to_explicit_spec PARAMS ((tree));\n \n /* Called once to initialize pt.c.  */\n \n@@ -1151,7 +1153,112 @@ determine_specialization (template_id, decl, targs_out,\n     *targs_out = TREE_PURPOSE (templates);\n   return TREE_VALUE (templates);\n }\n+\n+/* Returns a chain of parameter types, exactly like the SPEC_TYPES,\n+   but with the default argument values filled in from those in the\n+   TMPL_TYPES.  */\n       \n+static tree\n+copy_default_args_to_explicit_spec_1 (spec_types,\n+\t\t\t\t      tmpl_types)\n+     tree spec_types;\n+     tree tmpl_types;\n+{\n+  tree new_spec_types;\n+\n+  if (!spec_types)\n+    return NULL_TREE;\n+\n+  if (spec_types == void_list_node)\n+    return void_list_node;\n+\n+  /* Substitute into the rest of the list.  */\n+  new_spec_types =\n+    copy_default_args_to_explicit_spec_1 (TREE_CHAIN (spec_types),\n+\t\t\t\t\t  TREE_CHAIN (tmpl_types));\n+  \n+  /* Add the default argument for this parameter.  */\n+  return hash_tree_cons (TREE_PURPOSE (tmpl_types),\n+\t\t\t TREE_VALUE (spec_types),\n+\t\t\t new_spec_types);\n+}\n+\n+/* DECL is an explicit specialization.  Replicate default arguments\n+   from the template it specializes.  (That way, code like:\n+\n+     template <class T> void f(T = 3);\n+     template <> void f(double);\n+     void g () { f (); } \n+\n+   works, as required.)  An alternative approach would be to look up\n+   the correct default arguments at the call-site, but this approach\n+   is consistent with how implicit instantiations are handled.  */\n+\n+static void\n+copy_default_args_to_explicit_spec (decl)\n+     tree decl;\n+{\n+  tree tmpl;\n+  tree spec_types;\n+  tree tmpl_types;\n+  tree new_spec_types;\n+  tree old_type;\n+  tree new_type;\n+  tree t;\n+\n+  /* See if there's anything we need to do.  */\n+  tmpl = DECL_TI_TEMPLATE (decl);\n+  tmpl_types = TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (tmpl)));\n+  for (t = tmpl_types; t; t = TREE_CHAIN (t))\n+    if (TREE_PURPOSE (t))\n+      break;\n+  if (!t)\n+    return;\n+\n+  old_type = TREE_TYPE (decl);\n+  spec_types = TYPE_ARG_TYPES (old_type);\n+  \n+  /* DECL may contain more parameters than TMPL due to the extra\n+     in-charge parameter in constructors and destructors.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n+    {\n+      spec_types = TREE_CHAIN (spec_types);\n+      tmpl_types = TREE_CHAIN (tmpl_types);\n+      if (DECL_HAS_IN_CHARGE_PARM_P (decl))\n+\tspec_types = TREE_CHAIN (spec_types);\n+    }\n+\n+  /* Compute the merged default arguments.  */\n+  new_spec_types = \n+    copy_default_args_to_explicit_spec_1 (spec_types, tmpl_types);\n+\n+  /* Put the extra parameters back together -- but note that\n+     build_cplus_method_type will automatically add the `this'\n+     pointer.  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl)\n+      && DECL_HAS_IN_CHARGE_PARM_P (decl))\n+    {\n+      tree t = TREE_CHAIN (TYPE_ARG_TYPES (old_type));\n+      new_spec_types = hash_tree_cons (TREE_PURPOSE (t),\n+\t\t\t\t       TREE_VALUE (t),\n+\t\t\t\t       new_spec_types);\n+    }\n+  \n+  /* Compute the new FUNCTION_TYPE.  */\n+  if (TREE_CODE (old_type) == METHOD_TYPE)\n+    new_type = build_cplus_method_type (TYPE_METHOD_BASETYPE (old_type),\n+\t\t\t\t\tTREE_TYPE (old_type),\n+\t\t\t\t\tnew_spec_types);\n+  else\n+    new_type = build_function_type (TREE_TYPE (old_type),\n+\t\t\t\t  new_spec_types);\n+  new_type = build_type_attribute_variant (new_type,\n+\t\t\t\t\t   TYPE_ATTRIBUTES (old_type));\n+  new_type = build_exception_variant (new_type,\n+\t\t\t\t      TYPE_RAISES_EXCEPTIONS (old_type));\n+  TREE_TYPE (decl) = new_type;\n+}\n+\n /* Check to see if the function just declared, as indicated in\n    DECLARATOR, and in DECL, is a specialization of a function\n    template.  We may also discover that the declaration is an explicit\n@@ -1542,34 +1649,13 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      last_function_parms = TREE_CHAIN (last_function_parms);\n \t    }\n \n-\t  /* Inherit default function arguments from the template\n-\t     DECL is specializing.  */\n-\t  {\n-\t    tree t1 = TYPE_ARG_TYPES (TREE_TYPE (decl));\n-\t    tree t2 = TYPE_ARG_TYPES (TREE_TYPE (DECL_TEMPLATE_RESULT (tmpl)));\n-\n-\t    /* DECL may contain more parameters than TMPL due to the extra\n-\t       in-charge parameter in constructors and destructors.  */\n-\t    if (DECL_NONSTATIC_MEMBER_FUNCTION_P (decl))\n-\t      t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2);\n-\t    if (DECL_HAS_IN_CHARGE_PARM_P (decl))\n-\t      t1 = TREE_CHAIN (t1);\n-\n-\t     /* Note that we do not need to reparse default arguments, \n-\t\tsince explicit specialization cannot be declared in \n-\t\tclass scope as in [temp.expl.spec].  */\n-\t    for (; t1 && t2; t1 = TREE_CHAIN (t1), t2 = TREE_CHAIN (t2))\n-\t      {\n-\t\tif (TREE_PURPOSE (t2))\n-\t\t  TREE_PURPOSE (t1) = TREE_PURPOSE (t2);\n-\t      }\n-\n-\t    my_friendly_assert (t1 == NULL_TREE && t2 == NULL_TREE, 20001211);\n-\t  }\n-\n \t  /* Set up the DECL_TEMPLATE_INFO for DECL.  */\n \t  DECL_TEMPLATE_INFO (decl) = tree_cons (tmpl, targs, NULL_TREE);\n \n+\t  /* Inherit default function arguments from the template\n+\t     DECL is specializing.  */\n+\t  copy_default_args_to_explicit_spec (decl);\n+\n \t  /* Mangle the function name appropriately.  Note that we do\n \t     not mangle specializations of non-template member\n \t     functions of template classes, e.g. with"}, {"sha": "6eebc291e4b8d95282afb37bf678661a118dac92", "filename": "gcc/testsuite/g++.old-deja/g++.other/defarg6.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fdefarg6.C?ref=8afa707fab8ed182e4b9f9057a7fc4ccfc3faac2", "patch": "@@ -0,0 +1,13 @@\n+// Build don't link:\n+// Origin: Gerald Pfeifer <pfeifer@dbai.tuwien.ac.at>\n+\n+#include <vector>\n+#include <fstream>\n+\n+class STACK {\n+public:\n+  std::vector<int> data;\n+\n+  STACK() : data()\n+    { }\n+};"}]}