{"sha": "2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmZmMGY0ODgxOWM4YTdlZDVkN2MwM2UyYmZjMDJlNTkwN2UyZmYxYQ==", "commit": {"author": {"name": "Jos\u00e9 Rui Faustino de Sousa", "email": "jrfsousa@gmail.com", "date": "2020-06-11T12:14:30Z"}, "committer": {"name": "Thomas Koenig", "email": "tkoenig@gcc.gnu.org", "date": "2020-06-11T12:21:38Z"}, "message": "Wrong array section bounds when passing to an intent-in pointer dummy.\n\nAdd code to allow for the creation a new descriptor for array\nsections with the correct one based indexing.\n\nRework the generated descriptors indexing (hopefully) fixing the\nwrong offsets generated.\n\ngcc/fortran/ChangeLog:\n\n2020-06-11  Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n\n\tPR fortran/52351\n\tPR fortran/85868\n\t* trans-array.c (gfc_conv_expr_descriptor): Enable the\n\tcreation of a new descriptor with the correct one based\n\tindexing for array sections.  Rework array descriptor\n\tindexing offset calculation.\n\ngcc/testsuite/ChangeLog:\n\n2020-06-11  Jos\u00e9 Rui Faustino de Sousa  <jrfsousa@gmail.com>\n\n\tPR fortran/52351\n\tPR fortran/85868\n\t* gfortran.dg/coarray_lib_comm_1.f90: Adjust match test for\n\tthe newly generated descriptor.\n\t* gfortran.dg/PR85868A.f90: New test.\n\t* gfortran.dg/PR85868B.f90: New test.", "tree": {"sha": "8611f3116771c0354cd998a6ccda002912d0475d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8611f3116771c0354cd998a6ccda002912d0475d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/comments", "author": {"login": "jrfsousa", "id": 56982651, "node_id": "MDQ6VXNlcjU2OTgyNjUx", "avatar_url": "https://avatars.githubusercontent.com/u/56982651?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jrfsousa", "html_url": "https://github.com/jrfsousa", "followers_url": "https://api.github.com/users/jrfsousa/followers", "following_url": "https://api.github.com/users/jrfsousa/following{/other_user}", "gists_url": "https://api.github.com/users/jrfsousa/gists{/gist_id}", "starred_url": "https://api.github.com/users/jrfsousa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jrfsousa/subscriptions", "organizations_url": "https://api.github.com/users/jrfsousa/orgs", "repos_url": "https://api.github.com/users/jrfsousa/repos", "events_url": "https://api.github.com/users/jrfsousa/events{/privacy}", "received_events_url": "https://api.github.com/users/jrfsousa/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "be11812eef33786f77676327667bf3885c1f33e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/be11812eef33786f77676327667bf3885c1f33e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/be11812eef33786f77676327667bf3885c1f33e8"}], "stats": {"total": 325, "additions": 219, "deletions": 106}, "files": [{"sha": "3eb0e53e627e12636f860eab860a25c24b46314c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 26, "deletions": 103, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "patch": "@@ -7201,7 +7201,6 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n   tree desc;\n   stmtblock_t block;\n   tree start;\n-  tree offset;\n   int full;\n   bool subref_array_target = false;\n   bool deferred_array_component = false;\n@@ -7272,6 +7271,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \tfull = 1;\n       else if (se->direct_byref)\n \tfull = 0;\n+      else if (info->ref->u.ar.dimen == 0 && !info->ref->next)\n+\tfull = 1;\n+      else if (info->ref->u.ar.type == AR_SECTION && se->want_pointer)\n+\tfull = 0;\n       else\n \tfull = gfc_full_array_ref_p (info->ref, NULL);\n \n@@ -7508,10 +7511,9 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       tree from;\n       tree to;\n       tree base;\n-      bool onebased = false, rank_remap;\n+      tree offset;\n \n       ndim = info->ref ? info->ref->u.ar.dimen : ss->dimen;\n-      rank_remap = ss->dimen < ndim;\n \n       if (se->want_coarray)\n \t{\n@@ -7555,10 +7557,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t    gfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl, tmp);\n \t}\n \n-      /* If we have an array section or are assigning make sure that\n-\t the lower bound is 1.  References to the full\n-\t array should otherwise keep the original bounds.  */\n-      if ((!info->ref || info->ref->u.ar.type != AR_FULL) && !se->want_pointer)\n+      /* If we have an array section, are assigning  or passing an array\n+\t section argument make sure that the lower bound is 1.  References\n+\t to the full array should otherwise keep the original bounds.  */\n+      if (!info->ref || info->ref->u.ar.type != AR_FULL)\n \tfor (dim = 0; dim < loop.dimen; dim++)\n \t  if (!integer_onep (loop.from[dim]))\n \t    {\n@@ -7622,8 +7624,6 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       if (tmp != NULL_TREE)\n \tgfc_conv_descriptor_span_set (&loop.pre, parm, tmp);\n \n-      offset = gfc_index_zero_node;\n-\n       /* The following can be somewhat confusing.  We have two\n          descriptors, a new one and the original array.\n          {parm, parmtype, dim} refer to the new one.\n@@ -7637,22 +7637,17 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       tmp = gfc_conv_descriptor_dtype (parm);\n       gfc_add_modify (&loop.pre, tmp, gfc_get_dtype (parmtype));\n \n-      /* Set offset for assignments to pointer only to zero if it is not\n-         the full array.  */\n-      if ((se->direct_byref || se->use_offset)\n-\t  && ((info->ref && info->ref->u.ar.type != AR_FULL)\n-\t      || (expr->expr_type == EXPR_ARRAY && se->use_offset)))\n-\tbase = gfc_index_zero_node;\n-      else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n-\tbase = gfc_evaluate_now (gfc_conv_array_offset (desc), &loop.pre);\n-      else\n-\tbase = NULL_TREE;\n+      /* The 1st element in the section.  */\n+      base = gfc_index_zero_node;\n+\n+      /* The offset from the 1st element in the section.  */\n+      offset = gfc_index_zero_node;\n \n       for (n = 0; n < ndim; n++)\n \t{\n \t  stride = gfc_conv_array_stride (desc, n);\n \n-\t  /* Work out the offset.  */\n+\t  /* Work out the 1st element in the section.  */\n \t  if (info->ref\n \t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n@@ -7672,13 +7667,14 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t start, tmp);\n \t  tmp = fold_build2_loc (input_location, MULT_EXPR, TREE_TYPE (tmp),\n \t\t\t\t tmp, stride);\n-\t  offset = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (tmp),\n-\t\t\t\t    offset, tmp);\n+\t  base = fold_build2_loc (input_location, PLUS_EXPR, TREE_TYPE (tmp),\n+\t\t\t\t    base, tmp);\n \n \t  if (info->ref\n \t      && info->ref->u.ar.dimen_type[n] == DIMEN_ELEMENT)\n \t    {\n-\t      /* For elemental dimensions, we only need the offset.  */\n+\t      /* For elemental dimensions, we only need the 1st\n+\t\t element in the section.  */\n \t      continue;\n \t    }\n \n@@ -7698,7 +7694,6 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t  from = loop.from[dim];\n \t  to = loop.to[dim];\n \n-\t  onebased = integer_onep (from);\n \t  gfc_conv_descriptor_lbound_set (&loop.pre, parm,\n \t\t\t\t\t  gfc_rank_cst[dim], from);\n \n@@ -7712,35 +7707,10 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t    gfc_array_index_type,\n \t\t\t\t    stride, info->stride[n]);\n \n-\t  if ((se->direct_byref || se->use_offset)\n-\t      && ((info->ref && info->ref->u.ar.type != AR_FULL)\n-\t\t  || (expr->expr_type == EXPR_ARRAY && se->use_offset)))\n-\t    {\n-\t      base = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t      TREE_TYPE (base), base, stride);\n-\t    }\n-\t  else if (GFC_ARRAY_TYPE_P (TREE_TYPE (desc)) || se->use_offset)\n-\t    {\n-\t      bool toonebased;\n-\t      tmp = gfc_conv_array_lbound (desc, n);\n-\t      toonebased = integer_onep (tmp);\n-\t      // lb(arr) - from (- start + 1)\n-\t      tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t     TREE_TYPE (base), tmp, from);\n-\t      if (onebased && toonebased)\n-\t\t{\n-\t\t  tmp = fold_build2_loc (input_location, MINUS_EXPR,\n-\t\t\t\t\t TREE_TYPE (base), tmp, start);\n-\t\t  tmp = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t TREE_TYPE (base), tmp,\n-\t\t\t\t\t gfc_index_one_node);\n-\t\t}\n-\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n-\t\t\t\t     TREE_TYPE (base), tmp,\n-\t\t\t\t     gfc_conv_array_stride (desc, n));\n-\t      base = fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t     TREE_TYPE (base), tmp, base);\n-\t    }\n+\t  tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t TREE_TYPE (offset), stride, from);\n+\t  offset = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t   TREE_TYPE (offset), offset, tmp);\n \n \t  /* Store the new stride.  */\n \t  gfc_conv_descriptor_stride_set (&loop.pre, parm,\n@@ -7763,58 +7733,11 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t      gfc_index_zero_node);\n       else\n \t/* Point the data pointer at the 1st element in the section.  */\n-\tgfc_get_dataptr_offset (&loop.pre, parm, desc, offset,\n+\tgfc_get_dataptr_offset (&loop.pre, parm, desc, base,\n \t\t\t\tsubref_array_target, expr);\n \n-      /* Force the offset to be -1, when the lower bound of the highest\n-\t dimension is one and the symbol is present and is not a\n-\t pointer/allocatable or associated.  */\n-      if (((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n-\t   && !se->data_not_needed)\n-\t  || (se->use_offset && base != NULL_TREE))\n-\t{\n-\t  /* Set the offset depending on base.  */\n-\t  tmp = rank_remap && !se->direct_byref ?\n-\t\tfold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t gfc_array_index_type, base,\n-\t\t\t\t offset)\n-\t      : base;\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n-\t}\n-      else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n-\t       && !se->data_not_needed\n-\t       && (!rank_remap || se->use_offset))\n-\t{\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm,\n-\t\t\t\t\t gfc_conv_descriptor_offset_get (desc));\n-\t}\n-      else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n-\t       && !se->data_not_needed\n-\t       && gfc_expr_attr (expr).select_rank_temporary)\n-\t{\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, gfc_index_zero_node);\n-\t}\n-      else if (onebased && (!rank_remap || se->use_offset)\n-\t  && expr->symtree\n-\t  && !(expr->symtree->n.sym && expr->symtree->n.sym->ts.type == BT_CLASS\n-\t       && !CLASS_DATA (expr->symtree->n.sym)->attr.class_pointer)\n-\t  && !expr->symtree->n.sym->attr.allocatable\n-\t  && !expr->symtree->n.sym->attr.pointer\n-\t  && !expr->symtree->n.sym->attr.host_assoc\n-\t  && !expr->symtree->n.sym->attr.use_assoc)\n-\t{\n-\t  /* Set the offset to -1.  */\n-\t  mpz_t minus_one;\n-\t  mpz_init_set_si (minus_one, -1);\n-\t  tmp = gfc_conv_mpz_to_tree (minus_one, gfc_index_integer_kind);\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n-\t}\n-      else\n-\t{\n-\t  /* Only the callee knows what the correct offset it, so just set\n-\t     it to zero here.  */\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, gfc_index_zero_node);\n-\t}\n+      gfc_conv_descriptor_offset_set (&loop.pre, parm, offset);\n+\n       desc = parm;\n     }\n "}, {"sha": "621b874306bd344a86629a0bea7f7afff13d692a", "filename": "gcc/testsuite/gfortran.dg/PR85868A.f90", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868A.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868A.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868A.f90?ref=2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "patch": "@@ -0,0 +1,47 @@\n+! { dg-do run }\n+!\n+! PR fortran/85868\n+!\n+! Contributed by Harald Anlauf <anlauf@gmx.de>\n+! \n+\n+program test\n+  \n+  implicit none\n+  \n+  integer, parameter :: e(*) = [1, 1, -1, -1, 0, 0, 1]\n+  \n+  integer, pointer :: t(:), u(:)\n+  integer          :: i\n+  \n+  allocate (t(-1:5))\n+  do i = -1, 5\n+    t(i) = i\n+  end do\n+  call p (t, e(1))     ! Pointer with lower bound = -1 from allocation\n+  u     => t           ! Pointer assignment sets same lower bound\n+  call p (u, e(2))\n+  !\n+  u     => t(:)        ! Pointer assignment with implicit lower bound (1)\n+  call p (u, e(3))\n+  call p (t(:), e(4))  ! Full array, behaves the same\n+  !\n+  call p (t(0:), e(5)) ! Array section\n+  u     => t(0:)       ! Pointer assignment with implicit lower bound (1)\n+  call p (u, e(6))\n+  u(0:) => t(0:)       ! Pointer assignment with given lower bound (0)\n+  call p (u, e(7))\n+  stop\n+  \n+contains\n+  \n+  subroutine p (a, v)\n+    integer, pointer, intent(in) :: a(:)\n+    integer,          intent(in) :: v\n+    \n+    if(a(1)/=v) stop 1001\n+    return\n+  end subroutine p\n+  \n+end program test\n+"}, {"sha": "288f29fd73ef3ee055849b7ec61ca3fa12053bf6", "filename": "gcc/testsuite/gfortran.dg/PR85868B.f90", "status": "added", "additions": 144, "deletions": 0, "changes": 144, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868B.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868B.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2FPR85868B.f90?ref=2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "patch": "@@ -0,0 +1,144 @@\n+program main_p\n+\n+  implicit none\n+\n+  integer, parameter :: n = 10\n+  integer, parameter :: m = 5\n+\n+  integer, parameter :: b = 3\n+  integer, parameter :: t = n+b-1\n+  \n+  integer, parameter :: l = 4\n+  integer, parameter :: u = 7\n+  integer, parameter :: s = 3\n+  integer, parameter :: e = (u-l)/s+1\n+  \n+  call test_f()\n+  call test_s()\n+  call test_p()\n+  call test_a()\n+  stop\n+\n+contains\n+\n+  subroutine test_f()\n+    integer, target :: x(n,n)\n+    integer, target :: y(b:t)\n+    integer         :: i\n+    \n+    x = reshape([(i, i=1,n*n)], [n,n])\n+    y = x(:,m)\n+    call sub_s(x(:,m), y, 1, n, n)\n+    call sub_s(y, x(:,m), b, t, n)\n+    return\n+  end subroutine test_f\n+  \n+  subroutine test_s()\n+    integer, target :: x(n,n)\n+    integer, target :: v(e)\n+    integer         :: i\n+    \n+    x = reshape([(i, i=1,n*n)], [n,n])\n+    v = x(l:u:s,m)\n+    call sub_s(v, v, 1, e, e)\n+    call sub_s(x(l:u:s,m), v, 1, e, e)\n+    call sub_s(v, x(l:u:s,m), 1, e, e)\n+    return\n+  end subroutine test_s\n+  \n+  subroutine test_p()\n+    integer,  target :: x(n,n)\n+    integer, pointer :: p(:)\n+    integer          :: v(e)\n+    integer          :: i\n+    \n+    x = reshape([(i, i=1,n*n)], [n,n])\n+    v = x(l:u:s,m)\n+    p => x(:,m)\n+    call sub_s(p(l:u:s), v, 1, e, e)\n+    p => x(l:u:s,m)\n+    call sub_s(p, v, 1, e, e)\n+    p(l:) => x(l:u:s,m)\n+    call sub_s(p, v, l, e+l-1, e)\n+    p(l:l+e-1) => x(l:u:s,m)\n+    call sub_s(p, v, l, e+l-1, e)\n+    allocate(p(n))\n+    p(:) = x(:,m)\n+    call sub_s(p(l:u:s), v, 1, e, e)\n+    deallocate(p)\n+    allocate(p(e))\n+    p(:) = x(l:u:s,m)\n+    call sub_s(p, v, 1, e, e)\n+    deallocate(p)\n+    allocate(p(l:l+e-1))\n+    p(:) = x(l:u:s,m)\n+    call sub_s(p, v, l, e+l-1, e)\n+    deallocate(p)\n+    allocate(p(l:l+e-1))\n+    p(l:) = x(l:u:s,m)\n+    call sub_s(p, v, l, e+l-1, e)\n+    deallocate(p)\n+    allocate(p(l:l+e-1))\n+    p(l:l+e-1) = x(l:u:s,m)\n+    call sub_s(p, v, l, e+l-1, e)\n+    deallocate(p)\n+    return\n+  end subroutine test_p\n+  \n+  subroutine test_a()\n+    integer                      :: x(n,n)\n+    integer, allocatable, target :: a(:)\n+    integer                      :: v(e)\n+    integer                      :: i\n+    \n+    x = reshape([(i, i=1,n*n)], [n,n])\n+    v = x(l:u:s,m)\n+    a = x(:,m)\n+    call sub_s(a(l:u:s), v, 1, e, e)\n+    deallocate(a)\n+    allocate(a(n))\n+    a(:) = x(:,m)\n+    call sub_s(a(l:u:s), v, 1, e, e)\n+    deallocate(a)\n+    a = x(l:u:s,m)\n+    call sub_s(a, v, 1, e, e)\n+    deallocate(a)\n+    allocate(a(e))\n+    a(:) = x(l:u:s,m)\n+    call sub_s(a, v, 1, e, e)\n+    deallocate(a)\n+    allocate(a(l:l+e-1))\n+    a(:) = x(l:u:s,m)\n+    call sub_s(a, v, l, e+l-1, e)\n+    deallocate(a)\n+    allocate(a(l:l+e-1))\n+    a(l:) = x(l:u:s,m)\n+    call sub_s(a, v, l, e+l-1, e)\n+    deallocate(a)\n+    allocate(a(l:l+e-1))\n+    a(l:l+e-1) = x(l:u:s,m)\n+    call sub_s(a, v, l, e+l-1, e)\n+    deallocate(a)\n+    return\n+  end subroutine test_a\n+\n+  subroutine  sub_s(a, b, l, u, e)\n+    integer, pointer, intent(in) :: a(:)\n+    integer,          intent(in) :: b(:)\n+    integer,          intent(in) :: l\n+    integer,          intent(in) :: u\n+    integer,          intent(in) :: e\n+\n+    integer :: i\n+\n+    if(lbound(a,dim=1)/=l) stop 1001\n+    if(ubound(a,dim=1)/=u) stop 1002\n+    if(any(shape(a)/=[e])) stop 1003\n+    if(size(a, dim=1)/=e)  stop 1004\n+    if(size(a)/=size(b))   stop 1005\n+    do i = l, u\n+      if(a(i)/=b(i-l+1)) stop 1006\n+    end do\n+  end subroutine sub_s\n+\n+end program main_p"}, {"sha": "a8954e7afa32c7c981c8d1e984d0fe349d2b0584", "filename": "gcc/testsuite/gfortran.dg/coarray_lib_comm_1.f90", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lib_comm_1.f90?ref=2ff0f48819c8a7ed5d7c03e2bfc02e5907e2ff1a", "patch": "@@ -38,8 +38,7 @@\n if (any (A-B /= 0)) STOP 4\n end\n \n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 1, 0B\\\\\\);\" 2 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.1, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) b, 1, &parm.\\[0-9\\]+, 0B, &p, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 1, 0B\\\\\\);\" 3 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"_gfortran_caf_get \\\\\\(caf_token.1, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) b, 1, &parm.\\[0-9\\]+, 0B, &parm.\\[0-9\\]+, 4, 4, 0, 0B\\\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump-times \"_gfortran_caf_sendget \\\\\\(caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, caf_token.0, \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) parm.\\[0-9\\]+.data - \\\\\\(integer\\\\\\(kind=\\[48\\]\\\\\\)\\\\\\) a, 1, &parm.\\[0-9\\]+, 0B, 4, 4, 1, 0B\\\\\\);\" 1 \"original\" } }\n "}]}