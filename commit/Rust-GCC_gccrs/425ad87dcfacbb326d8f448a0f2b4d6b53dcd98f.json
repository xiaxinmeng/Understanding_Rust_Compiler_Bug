{"sha": "425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI1YWQ4N2RjZmFjYmIzMjZkOGY0NDhhMGYyYjRkNmI1M2RjZDk4Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-15T08:12:11Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2021-05-15T08:12:11Z"}, "message": "regcprop: Fix another cprop_hardreg bug [PR100342]\n\nOn Tue, Jan 19, 2021 at 04:10:33PM +0000, Richard Sandiford via Gcc-patches wrote:\n> Ah, ok, thanks for the extra context.\n>\n> So AIUI the problem when recording xmm2<-di isn't just:\n>\n>  [A] partial_subreg_p (vd->e[sr].mode, GET_MODE (src))\n>\n> but also that:\n>\n>  [B] partial_subreg_p (vd->e[sr].mode, vd->e[vd->e[sr].oldest_regno].mode)\n>\n> For example, all registers in this sequence can be part of the same chain:\n>\n>     (set (reg:HI R1) (reg:HI R0))\n>     (set (reg:SI R2) (reg:SI R1)) // [A]\n>     (set (reg:DI R3) (reg:DI R2)) // [A]\n>     (set (reg:SI R4) (reg:SI R[0-3]))\n>     (set (reg:HI R5) (reg:HI R[0-4]))\n>\n> But:\n>\n>     (set (reg:SI R1) (reg:SI R0))\n>     (set (reg:HI R2) (reg:HI R1))\n>     (set (reg:SI R3) (reg:SI R2)) // [A] && [B]\n>\n> is problematic because it dips below the precision of the oldest regno\n> and then increases again.\n>\n> When this happens, I guess we have two choices:\n>\n> (1) what the patch does: treat R3 as the start of a new chain.\n> (2) pretend that the copy occured in vd->e[sr].mode instead\n>     (i.e. copy vd->e[sr].mode to vd->e[dr].mode)\n>\n> I guess (2) would need to be subject to REG_CAN_CHANGE_MODE_P.\n> Maybe the optimisation provided by (2) compared to (1) isn't common\n> enough to be worth the complication.\n>\n> I think we should test [B] as well as [A] though.  The pass is set\n> up to do some quite elaborate mode changes and I think rejecting\n> [A] on its own would make some of the other code redundant.\n> It also feels like it should be a seperate \u201cif\u201d or \u201celse if\u201d,\n> with its own comment.\n\nUnfortunately, we now have a testcase that shows that testing also [B]\nis a problem (unfortunately now latent on the trunk, only reproduces\non 10 and 11 branches).\n\nThe comment in the patch tries to list just the interesting instructions,\nwe have a 64-bit value, copy low 8 bit of those to another register,\ncopy full 64 bits to another register and then clobber the original register.\nBefore that (set (reg:DI r14) (const_int ...)) we have a chain\nDI r14, QI si, DI bp , that instruction drops the DI r14 from that chain, so\nwe have QI si, DI bp , si being the oldest_regno.\nNext DI si is copied into DI dx.  Only the low 8 bits of that are defined,\nthe rest is unspecified, but we would add DI dx into that same chain at the\nend, so QI si, DI bp, DI dx [*].  Next si is overwritten, so the chain is\nDI bp, DI dx.  And then we see (set (reg:DI dx) (reg:DI bp)) and remove it\nas redundant, because we think bp and dx are already equivalent, when in\nreality that is true only for the lowpart 8 bits.\nI believe the [*] marked step above is where the bug is.\n\nThe committed regcprop.c (copy_value) change (but only committed to\ntrunk/11, not to 10) added\n  else if (partial_subreg_p (vd->e[sr].mode, GET_MODE (src))\n           && partial_subreg_p (vd->e[sr].mode,\n                                vd->e[vd->e[sr].oldest_regno].mode))\n    return;\nand while the first partial_subreg_p call returns true, the second one\ndoesn't; before the (set (reg:DI r14) (const_int ...)) insn it would be\ntrue and we'd return, but as that reg got clobbered, si became the oldest\nregno in the chain and so vd->e[vd->e[sr].oldest_regno].mode is QImode\nand vd->e[sr].mode is QImode too, so the second partial_subreg_p is false.\nBut as the testcase shows, what is the oldest_regno in the chain is\nsomething that changes over time, so relying on it for anything is\nproblematic, something could have a different oldest_regno and later\non get a different oldest_regno (perhaps with different mode) because\nthe oldest_regno got overwritten and it can change both ways.\n\nThe following patch effectively implements your (2) above.\n\n2021-05-15  Jakub Jelinek  <jakub@redhat.com>\n\n\tPR rtl-optimization/100342\n\t* regcprop.c (copy_value): When copying a source reg in a wider\n\tmode than it has recorded for the value, adjust recorded destination\n\tmode too or punt if !REG_CAN_CHANGE_MODE_P.\n\n\t* gcc.target/i386/pr100342.c: New test.", "tree": {"sha": "5e1ab6c954dec03dfe6e7c1c5d3a939ffddb889a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5e1ab6c954dec03dfe6e7c1c5d3a939ffddb889a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "87a7d10c2e9ec34a276e6acb5d2282a35b9cfafb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/87a7d10c2e9ec34a276e6acb5d2282a35b9cfafb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/87a7d10c2e9ec34a276e6acb5d2282a35b9cfafb"}], "stats": {"total": 118, "additions": 90, "deletions": 28}, "files": [{"sha": "7c271e22f47737e97d9989a99eeb4c2208865407", "filename": "gcc/regcprop.c", "status": "modified", "additions": 20, "deletions": 28, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "patch": "@@ -358,34 +358,26 @@ copy_value (rtx dest, rtx src, struct value_data *vd)\n   else if (sn > hard_regno_nregs (sr, vd->e[sr].mode))\n     return;\n \n-  /* It is not safe to link DEST into the chain if SRC was defined in some\n-     narrower mode M and if M is also narrower than the mode of the first\n-     register in the chain.  For example:\n-     (set (reg:DI r1) (reg:DI r0))\n-     (set (reg:HI r2) (reg:HI r1))\n-     (set (reg:SI r3) (reg:SI r2)) //Should be a new chain start at r3\n-     (set (reg:SI r4) (reg:SI r1))\n-     (set (reg:SI r5) (reg:SI r4))\n-\n-     the upper part of r3 is undefined.  If we added it to the chain,\n-     it may be used to replace r5, which has defined upper bits.\n-     See PR98694 for details.\n-\n-     [A] partial_subreg_p (vd->e[sr].mode, GET_MODE (src))\n-     [B] partial_subreg_p (vd->e[sr].mode, vd->e[vd->e[sr].oldest_regno].mode)\n-     Condition B is added to to catch optimization opportunities of\n-\n-     (set (reg:HI R1) (reg:HI R0))\n-     (set (reg:SI R2) (reg:SI R1)) // [A]\n-     (set (reg:DI R3) (reg:DI R2)) // [A]\n-     (set (reg:SI R4) (reg:SI R[0-3]))\n-     (set (reg:HI R5) (reg:HI R[0-4]))\n-\n-     in which all registers have only 16 defined bits.  */\n-  else if (partial_subreg_p (vd->e[sr].mode, GET_MODE (src))\n-\t   && partial_subreg_p (vd->e[sr].mode,\n-\t\t\t\tvd->e[vd->e[sr].oldest_regno].mode))\n-    return;\n+  /* If a narrower value is copied using wider mode, the upper bits\n+     are undefined (could be e.g. a former paradoxical subreg).  Signal\n+     in that case we've only copied value using the narrower mode.\n+     Consider:\n+     (set (reg:DI r14) (mem:DI ...))\n+     (set (reg:QI si) (reg:QI r14))\n+     (set (reg:DI bp) (reg:DI r14))\n+     (set (reg:DI r14) (const_int ...))\n+     (set (reg:DI dx) (reg:DI si))\n+     (set (reg:DI si) (const_int ...))\n+     (set (reg:DI dx) (reg:DI bp))\n+     The last set is not redundant, while the low 8 bits of dx are already\n+     equal to low 8 bits of bp, the other bits are undefined.  */\n+  else if (partial_subreg_p (vd->e[sr].mode, GET_MODE (src)))\n+    {\n+      if (!REG_CAN_CHANGE_MODE_P (sr, GET_MODE (src), vd->e[sr].mode)\n+\t  || !REG_CAN_CHANGE_MODE_P (dr, vd->e[sr].mode, GET_MODE (dest)))\n+\treturn;\n+      set_value_regno (dr, vd->e[sr].mode, vd);\n+    }\n \n   /* Link DR at the end of the value chain used by SR.  */\n "}, {"sha": "8e2ec823748518242ba429d61a91e14ecacaab17", "filename": "gcc/testsuite/gcc.target/i386/pr100342.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100342.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100342.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr100342.c?ref=425ad87dcfacbb326d8f448a0f2b4d6b53dcd98f", "patch": "@@ -0,0 +1,70 @@\n+/* PR rtl-optimization/100342 */\n+/* { dg-do run { target int128 } } */\n+/* { dg-options \"-O2 -fno-dse -fno-forward-propagate -Wno-psabi -mno-sse2\" } */\n+\n+#define SHL(x, y) ((x) << ((y) & (sizeof(x) * 8 - 1)))\n+#define SHR(x, y) ((x) >> ((y) & (sizeof(x) * 8 - 1)))\n+#define ROR(x, y) (SHR(x, y)) | (SHL(x, (sizeof(x) * 8 - (y))))\n+#define SHLV(x, y) ((x) << ((y) & (sizeof((x)[0]) * 8 - 1)))\n+#define SHLSV(x, y) ((x) << ((y) & (sizeof((y)[0]) * 8 - 1)))\n+typedef unsigned char A;\n+typedef unsigned char __attribute__((__vector_size__ (8))) B;\n+typedef unsigned char __attribute__((__vector_size__ (16))) C;\n+typedef unsigned char __attribute__((__vector_size__ (32))) D;\n+typedef unsigned char __attribute__((__vector_size__ (64))) E;\n+typedef unsigned short F;\n+typedef unsigned short __attribute__((__vector_size__ (16))) G;\n+typedef unsigned int H;\n+typedef unsigned int __attribute__((__vector_size__ (32))) I;\n+typedef unsigned long long J;\n+typedef unsigned long long __attribute__((__vector_size__ (8))) K;\n+typedef unsigned long long __attribute__((__vector_size__ (32))) L;\n+typedef unsigned long long __attribute__((__vector_size__ (64))) M;\n+typedef unsigned __int128 N;\n+typedef unsigned __int128 __attribute__((__vector_size__ (16))) O;\n+typedef unsigned __int128 __attribute__((__vector_size__ (32))) P;\n+typedef unsigned __int128 __attribute__((__vector_size__ (64))) Q;\n+B v1;\n+D v2;\n+L v3;\n+K v4;\n+I v5;\n+O v6;\n+\n+B\n+foo (A a, C b, E c, F d, G e, H f, J g, M h, N i, P j, Q k)\n+{\n+  b &= (A) f;\n+  k += a;\n+  G l = e;\n+  D m = v2 >= (A) (J) v1;\n+  J r = a + g;\n+  L n = v3 <= f;\n+  k -= i / f;\n+  l -= (A) g;\n+  c |= (A) d;\n+  b -= (A) i;\n+  J o = ROR (__builtin_clz (r), a);\n+  K p = v4 | f, q = v4 <= f;\n+  P s = SHLV (SHLSV (__builtin_bswap64 (i), (P) (0 < j)) <= 0, j);\n+  n += a <= r;\n+  M t = (M) (a / SHLV (c, 0)) != __builtin_bswap64 (i);\n+  I u = f - v5;\n+  E v = (E) h + (E) t + (E) k;\n+  D w = (union { D b[2]; }) { }.b[0] + ((union { E b; }) v).b[1] + m + (D) u + (D) n + (D) s;\n+  C x = ((union { D b; }) w).b[1] + b + (C) l + (C) v6;\n+  B y = ((union { C a; B b; }) x).b + ((union { C a; B b[2]; }) x).b[1] + (B) p + (B) q;\n+  J z = i + o;\n+  F z2 = z;\n+  A z3 = z2;\n+  return y + z3;\n+}\n+\n+int\n+main ()\n+{\n+  B x = foo (0, (C) { }, (E) { }, 10, (G) { }, 4, 2, (M) { }, 123842323652213865LL, (P) { 1 }, (Q) { });\n+  if ((J) x != 0x2e2c2e2c2e2c2e30ULL)\n+    __builtin_abort();\n+  return 0;\n+}"}]}