{"sha": "a50aa827413db12b5a850b61f5a03546ac0381d3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTUwYWE4Mjc0MTNkYjEyYjVhODUwYjYxZjVhMDM1NDZhYzAzODFkMw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@codesourcery.com", "date": "2007-02-20T02:10:57Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2007-02-20T02:10:57Z"}, "message": "alpha.c, [...]: Follow spelling conventions.\n\n\t* config/alpha/alpha.c, config/alpha/alpha.md,\n\tconfig/alpha/lib1funcs.asm, config/alpha/vms-crt0-64.c,\n\tconfig/alpha/vms-psxcrt0-64.c, config/arc/arc.c,\n\tconfig/arc/arc.h, config/arm/arm.c, config/arm/arm.md,\n\tconfig/arm/lib1funcs.asm: Follow spelling conventions.\n\nFrom-SVN: r122150", "tree": {"sha": "0771e267aa01450814af88276ed12edcd67192aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0771e267aa01450814af88276ed12edcd67192aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a50aa827413db12b5a850b61f5a03546ac0381d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50aa827413db12b5a850b61f5a03546ac0381d3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a50aa827413db12b5a850b61f5a03546ac0381d3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a50aa827413db12b5a850b61f5a03546ac0381d3/comments", "author": null, "committer": null, "parents": [{"sha": "10daf6770623cc576f4b307abb3cceb5cf0de3e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10daf6770623cc576f4b307abb3cceb5cf0de3e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10daf6770623cc576f4b307abb3cceb5cf0de3e7"}], "stats": {"total": 52, "additions": 30, "deletions": 22}, "files": [{"sha": "2861d3f72156c4e6b7db07513adb786373120b58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -1,3 +1,11 @@\n+2007-02-20  Kazu Hirata  <kazu@codesourcery.com>\n+\n+\t* config/alpha/alpha.c, config/alpha/alpha.md,\n+\tconfig/alpha/lib1funcs.asm, config/alpha/vms-crt0-64.c,\n+\tconfig/alpha/vms-psxcrt0-64.c, config/arc/arc.c,\n+\tconfig/arc/arc.h, config/arm/arm.c, config/arm/arm.md,\n+\tconfig/arm/lib1funcs.asm: Follow spelling conventions.\n+\n 2007-02-20  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/29943"}, {"sha": "023bbcc92f7d8fee6e59641e68e04e6ee82c225f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -3343,7 +3343,7 @@ alpha_expand_unaligned_load (rtx tgt, rtx mem, HOST_WIDE_INT size,\n \n       /* We must use tgt here for the target.  Alpha-vms port fails if we use\n \t addr for the target, because addr is marked as a pointer and combine\n-\t knows that pointers are always sign-extended 32 bit values.  */\n+\t knows that pointers are always sign-extended 32-bit values.  */\n       addr = expand_binop (DImode, ior_optab, extl, exth, tgt, 1, OPTAB_WIDEN);\n       addr = expand_binop (DImode, ashr_optab, addr, GEN_INT (48),\n \t\t\t   addr, 1, OPTAB_WIDEN);\n@@ -6580,7 +6580,7 @@ alpha_expand_builtin (tree exp, rtx target,\n #endif\n \n /* Fold the builtin for the CMPBGE instruction.  This is a vector comparison\n-   with an 8 bit output vector.  OPINT contains the integer operands; bit N\n+   with an 8-bit output vector.  OPINT contains the integer operands; bit N\n    of OP_CONST is set if OPINT[N] is valid.  */\n \n static tree"}, {"sha": "2e9e13114054e714c300c098319f6c6ad1e806c5", "filename": "gcc/config/alpha/alpha.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Falpha.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Falpha.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.md?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -6568,7 +6568,7 @@\n     {\n       int ofs;\n \n-      /* Fail 8 bit fields, falling back on a simple byte load.  */\n+      /* Fail 8-bit fields, falling back on a simple byte load.  */\n       if (INTVAL (operands[2]) == 8)\n \tFAIL;\n "}, {"sha": "4c29309583c49d04b5a7a0704c5004755ceff125", "filename": "gcc/config/alpha/lib1funcs.asm", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Flib1funcs.asm?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -200,7 +200,7 @@ FUNCTION_NAME:\n #define N RETREG\n #endif\n \n-/* Perform conversion from 32 bit types to 64 bit types.  */\n+/* Perform conversion from 32-bit types to 64-bit types.  */\n #if SIZE == 32\n #if TYPE == SIGNED\n \t/* If there are problems with the signed case, add these instructions.\n@@ -303,7 +303,7 @@ $46:\n #endif\n \n \n-/* Sign extend an *unsigned* 32 bit result, as required by the Alpha\n+/* Sign extend an *unsigned* 32-bit result, as required by the Alpha\n    conventions.  */\n #if TYPE == UNSIGNED && SIZE == 32\n \t/* This could be avoided by adding some CPP hair to the divide loop."}, {"sha": "d7c8ca4d9720190b1003f7167baec79e8d2b3741", "filename": "gcc/config/alpha/vms-crt0-64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-crt0-64.c?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -77,7 +77,7 @@ __main (arg1, arg2, arg3, image_file_desc, arg5, arg6)\n \n #pragma __pointer_size long\n \n-  /* Reallocate argv with 64 bit pointers.  */\n+  /* Reallocate argv with 64-bit pointers.  */\n   long_argv = (char **) malloc (sizeof (char *) * (argc + 1));\n \n   for (i = 0; i < argc; i++)"}, {"sha": "cf4e8679e11875a63399d865dab2971733fbebc1", "filename": "gcc/config/alpha/vms-psxcrt0-64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Fvms-psxcrt0-64.c?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -79,7 +79,7 @@ __main (arg1, arg2, arg3, image_file_desc, arg5, arg6)\n \n #pragma __pointer_size long\n \n-  /* Reallocate argv with 64 bit pointers.  */\n+  /* Reallocate argv with 64-bit pointers.  */\n   long_argv = (char **) malloc (sizeof (char *) * (argc + 1));\n \n   for (i = 0; i < argc; i++)"}, {"sha": "919f03b39a3e1589df9cb62a2d04c3eddbad803f", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -262,7 +262,7 @@ arc_select_cc_mode (enum rtx_code op,\n    indexed by hard register number, and one indexed by mode.  */\n \n /* The purpose of arc_mode_class is to shrink the range of modes so that\n-   they all fit (as bit numbers) in a 32 bit word (again).  Each real mode is\n+   they all fit (as bit numbers) in a 32-bit word (again).  Each real mode is\n    mapped into one arc_mode_class mode.  */\n \n enum arc_mode_class {\n@@ -479,7 +479,7 @@ long_immediate_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n     case CONST_INT :\n       return !SMALL_INT (INTVAL (op));\n     case CONST_DOUBLE :\n-      /* These can happen because large unsigned 32 bit constants are\n+      /* These can happen because large unsigned 32-bit constants are\n \t represented this way (the multiplication patterns can cause these\n \t to be generated).  They also occur for SFmode values.  */\n       return 1;\n@@ -516,7 +516,7 @@ long_immediate_loadstore_operand (rtx op,\n \t assume that it does.  */\n       return 1;\n     case CONST_DOUBLE :\n-      /* These can happen because large unsigned 32 bit constants are\n+      /* These can happen because large unsigned 32-bit constants are\n \t represented this way (the multiplication patterns can cause these\n \t to be generated).  They also occur for SFmode values.  */\n       return 1;\n@@ -550,10 +550,10 @@ move_src_operand (rtx op, enum machine_mode mode)\n     case CONST_DOUBLE :\n       /* We can handle DImode integer constants in SImode if the value\n \t (signed or unsigned) will fit in 32 bits.  This is needed because\n-\t large unsigned 32 bit constants are represented as CONST_DOUBLEs.  */\n+\t large unsigned 32-bit constants are represented as CONST_DOUBLEs.  */\n       if (mode == SImode)\n \treturn arc_double_limm_p (op);\n-      /* We can handle 32 bit floating point constants.  */\n+      /* We can handle 32-bit floating point constants.  */\n       if (mode == SFmode)\n \treturn GET_MODE (op) == SFmode;\n       return 0;"}, {"sha": "69ec637676490c446a92b512a8c2a96181894eb2", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -430,7 +430,7 @@ extern enum reg_class arc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n    Here VALUE is the CONST_DOUBLE rtx itself.  */\n /* 'G' is used for integer values for the multiplication insns where the\n    operands are extended from 4 bytes to 8 bytes.\n-   'H' is used when any 64 bit constant is allowed.  */\n+   'H' is used when any 64-bit constant is allowed.  */\n #define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) \\\n ((C) == 'G' ? arc_double_limm_p (VALUE) \\\n  : (C) == 'H' ? 1 \\\n@@ -671,7 +671,7 @@ arc_eligible_for_epilogue_delay (TRIAL, SLOTS_FILLED)\n \n /* Output assembler code for a block containing the constant parts\n    of a trampoline, leaving space for the variable parts.  */\n-/* On the ARC, the trampoline is quite simple as we have 32 bit immediate\n+/* On the ARC, the trampoline is quite simple as we have 32-bit immediate\n    constants.\n \n \tmov r24,STATIC\n@@ -714,7 +714,7 @@ do { \\\n  || GET_CODE (X) == CONST_INT || GET_CODE (X) == CONST)\n \n /* Nonzero if the constant value X is a legitimate general operand.\n-   We can handle any 32 or 64 bit constant.  */\n+   We can handle any 32- or 64-bit constant.  */\n /* \"1\" should work since the largest constant should be a 64 bit critter.  */\n /* ??? Not sure what to do for 64x32 compiler.  */\n #define LEGITIMATE_CONSTANT_P(X) 1\n@@ -1060,7 +1060,7 @@ do { if ((LOG) != 0) fprintf (FILE, \"\\t.align %d\\n\", 1 << (LOG)); } while (0)\n /* Specify the machine mode that pointers have.\n    After generation of rtl, the compiler makes no further distinction\n    between pointers and any other objects of this machine mode.  */\n-/* ??? The arc doesn't have full 32 bit pointers, but making this PSImode has\n+/* ??? The arc doesn't have full 32-bit pointers, but making this PSImode has\n    its own problems (you have to add extendpsisi2 and trucnsipsi2 but how does\n    one do it without getting excess code?).  Try to avoid it.  */\n #define Pmode SImode"}, {"sha": "b4c1289075afbce939107712bda4e343b54e301e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -3190,7 +3190,7 @@ current_file_function_operand (rtx sym_ref)\n   return 0;\n }\n \n-/* Return nonzero if a 32 bit \"long_call\" should be generated for\n+/* Return nonzero if a 32-bit \"long_call\" should be generated for\n    this call.  We generate a long_call if the function:\n \n         a.  has an __attribute__((long call))\n@@ -4076,7 +4076,7 @@ thumb1_legitimate_address_p (enum machine_mode mode, rtx x, int strict_p)\n \t       && thumb_legitimate_offset_p (mode, INTVAL (XEXP (x, 1))))\n \treturn 1;\n \n-      /* REG+const has 10 bit offset for SP, but only SImode and\n+      /* REG+const has 10-bit offset for SP, but only SImode and\n \t larger is supported.  */\n       /* ??? Should probably check for DI/DFmode overflow here\n \t just like GO_IF_LEGITIMATE_OFFSET does.  */\n@@ -4385,8 +4385,8 @@ arm_legitimize_address (rtx x, rtx orig_x, enum machine_mode mode)\n       HOST_WIDE_INT mask, base, index;\n       rtx base_reg;\n \n-      /* ldr and ldrb can use a 12 bit index, ldrsb and the rest can only\n-         use a 8 bit index. So let's use a 12 bit index for SImode only and\n+      /* ldr and ldrb can use a 12-bit index, ldrsb and the rest can only\n+         use a 8-bit index. So let's use a 12-bit index for SImode only and\n          hope that arm_gen_constant will enable ldrb to use more bits. */\n       bits = (mode == SImode) ? 12 : 8;\n       mask = (1 << bits) - 1;"}, {"sha": "37bfe886f3b625633cc9f59fec1623e553fe6fd8", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -8152,7 +8152,7 @@\n       operands[2] = const0_rtx;\n       \n     /* This is to decide if we should generate indirect calls by loading the\n-       32 bit address of the callee into a register before performing the\n+       32-bit address of the callee into a register before performing the\n        branch and link.  operand[2] encodes the long_call/short_call\n        attribute of the function being called.  This attribute is set whenever\n        __attribute__((long_call/short_call)) or #pragma long_call/no_long_call"}, {"sha": "4d455aa19176ef797a48369d8a021410f4a4fa44", "filename": "gcc/config/arm/lib1funcs.asm", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a50aa827413db12b5a850b61f5a03546ac0381d3/gcc%2Fconfig%2Farm%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flib1funcs.asm?ref=a50aa827413db12b5a850b61f5a03546ac0381d3", "patch": "@@ -444,7 +444,7 @@ pc\t\t.req\tr15\n \n \t@ Initially shift the divisor left 3 bits if possible,\n \t@ set curbit accordingly.  This allows for curbit to be located\n-\t@ at the left end of each 4 bit nibbles in the division loop\n+\t@ at the left end of each 4-bit nibbles in the division loop\n \t@ to save one loop in most cases.\n \ttst\t\\divisor, #0xe0000000\n \tmoveq\t\\divisor, \\divisor, lsl #3"}]}