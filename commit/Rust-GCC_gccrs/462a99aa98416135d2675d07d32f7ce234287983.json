{"sha": "462a99aa98416135d2675d07d32f7ce234287983", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYyYTk5YWE5ODQxNjEzNWQyNjc1ZDA3ZDMyZjdjZTIzNDI4Nzk4Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-09-12T13:28:08Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-09-12T13:28:08Z"}, "message": "Make more use of REG_NREGS\n\nAn upcoming patch will convert hard_regno_nregs into an inline\nfunction, which in turn allows hard_regno_nregs to be used as the\nname of a targetm field.  This patch rewrites uses that are more\neasily (and efficiently) written as REG_NREGS.\n\n2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* caller-save.c (add_used_regs): Use REG_NREGS instead of\n\thard_regno_nregs.\n\t* config/aarch64/aarch64.c (aarch64_split_combinev16qi): Likewise.\n\t* config/arm/arm.c (output_move_neon): Likewise.\n\t(arm_attr_length_move_neon): Likewise.\n\t(neon_split_vcombine): Likewise.\n\t* config/c6x/c6x.c (c6x_mark_reg_read): Likewise.\n\t(c6x_mark_reg_written): Likewise.\n\t(c6x_dwarf_register_span): Likewise.\n\t* config/i386/i386.c (ix86_save_reg): Likewise.\n\t* config/ia64/ia64.c (mark_reg_gr_used_mask): Likewise.\n\t(rws_access_reg): Likewise.\n\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n\t* mode-switching.c (create_pre_exit): Likewise.\n\t* ree.c (combine_reaching_defs): Likewise.\n\t(add_removable_extension): Likewise.\n\t* regcprop.c (find_oldest_value_reg): Likewise.\n\t(copyprop_hardreg_forward_1): Likewise.\n\t* reload.c (reload_inner_reg_of_subreg): Likewise.\n\t(push_reload): Likewise.\n\t(combine_reloads): Likewise.\n\t(find_dummy_reload): Likewise.\n\t(reload_adjust_reg_for_mode): Likewise.\n\t* reload1.c (find_reload_regs): Likewise.\n\t(forget_old_reloads_1): Likewise.\n\t(reload_reg_free_for_value_p): Likewise.\n\t(reload_adjust_reg_for_temp): Likewise.\n\t(emit_reload_insns): Likewise.\n\t(delete_output_reload): Likewise.\n\t* sel-sched.c (choose_best_reg_1): Likewise.\n\t(choose_best_pseudo_reg): Likewise.\n\nFrom-SVN: r252010", "tree": {"sha": "6a0d7b2184713f09474d42070b1f6e4fa7670a38", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6a0d7b2184713f09474d42070b1f6e4fa7670a38"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/462a99aa98416135d2675d07d32f7ce234287983", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/462a99aa98416135d2675d07d32f7ce234287983", "html_url": "https://github.com/Rust-GCC/gccrs/commit/462a99aa98416135d2675d07d32f7ce234287983", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/462a99aa98416135d2675d07d32f7ce234287983/comments", "author": null, "committer": null, "parents": [{"sha": "e0bd6c9f0aa67d88bbb20019362a4572fc5fac3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bd6c9f0aa67d88bbb20019362a4572fc5fac3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0bd6c9f0aa67d88bbb20019362a4572fc5fac3c"}], "stats": {"total": 134, "additions": 73, "deletions": 61}, "files": [{"sha": "2683d7759d03a6a5cdaa4747eec42194497cba4b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -1,3 +1,37 @@\n+2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* caller-save.c (add_used_regs): Use REG_NREGS instead of\n+\thard_regno_nregs.\n+\t* config/aarch64/aarch64.c (aarch64_split_combinev16qi): Likewise.\n+\t* config/arm/arm.c (output_move_neon): Likewise.\n+\t(arm_attr_length_move_neon): Likewise.\n+\t(neon_split_vcombine): Likewise.\n+\t* config/c6x/c6x.c (c6x_mark_reg_read): Likewise.\n+\t(c6x_mark_reg_written): Likewise.\n+\t(c6x_dwarf_register_span): Likewise.\n+\t* config/i386/i386.c (ix86_save_reg): Likewise.\n+\t* config/ia64/ia64.c (mark_reg_gr_used_mask): Likewise.\n+\t(rws_access_reg): Likewise.\n+\t* config/s390/s390.c (s390_call_saved_register_used): Likewise.\n+\t* mode-switching.c (create_pre_exit): Likewise.\n+\t* ree.c (combine_reaching_defs): Likewise.\n+\t(add_removable_extension): Likewise.\n+\t* regcprop.c (find_oldest_value_reg): Likewise.\n+\t(copyprop_hardreg_forward_1): Likewise.\n+\t* reload.c (reload_inner_reg_of_subreg): Likewise.\n+\t(push_reload): Likewise.\n+\t(combine_reloads): Likewise.\n+\t(find_dummy_reload): Likewise.\n+\t(reload_adjust_reg_for_mode): Likewise.\n+\t* reload1.c (find_reload_regs): Likewise.\n+\t(forget_old_reloads_1): Likewise.\n+\t(reload_reg_free_for_value_p): Likewise.\n+\t(reload_adjust_reg_for_temp): Likewise.\n+\t(emit_reload_insns): Likewise.\n+\t(delete_output_reload): Likewise.\n+\t* sel-sched.c (choose_best_reg_1): Likewise.\n+\t(choose_best_pseudo_reg): Likewise.\n+\n 2017-09-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood <david.sherwood@arm.com>"}, {"sha": "2166dcf5b89a3847a1ba9eee22e59af36b7fc53f", "filename": "gcc/caller-save.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -1354,8 +1354,7 @@ add_used_regs (rtx *loc, void *data)\n \t{\n \t  unsigned int regno = REGNO (x);\n \t  if (HARD_REGISTER_NUM_P (regno))\n-\t    bitmap_set_range ((regset) data, regno,\n-\t\t\t      hard_regno_nregs[regno][GET_MODE (x)]);\n+\t    bitmap_set_range ((regset) data, regno, REG_NREGS (x));\n \t  else\n \t    gcc_checking_assert (reg_renumber[regno] < 0);\n \t}"}, {"sha": "64c03da63a782c0fd204bde5fe8b4cac8224c580", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -13106,7 +13106,7 @@ aarch64_split_combinev16qi (rtx operands[3])\n   unsigned int src1 = REGNO (operands[1]);\n   unsigned int src2 = REGNO (operands[2]);\n   machine_mode halfmode = GET_MODE (operands[1]);\n-  unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n+  unsigned int halfregs = REG_NREGS (operands[1]);\n   rtx destlo, desthi;\n \n   gcc_assert (halfmode == V16QImode);"}, {"sha": "7614bc1f86b8d6a4c558180496bf5b8c1aa8acf7", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -18589,7 +18589,7 @@ output_move_neon (rtx *operands)\n \n   gcc_assert (REG_P (reg));\n   regno = REGNO (reg);\n-  nregs = HARD_REGNO_NREGS (regno, mode) / 2;\n+  nregs = REG_NREGS (reg) / 2;\n   gcc_assert (VFP_REGNO_OK_FOR_DOUBLE (regno)\n \t      || NEON_REGNO_OK_FOR_QUAD (regno));\n   gcc_assert (VALID_NEON_DREG_MODE (mode)\n@@ -18722,7 +18722,6 @@ arm_attr_length_move_neon (rtx_insn *insn)\n \n   gcc_assert (MEM_P (mem));\n \n-  mode = GET_MODE (reg);\n   addr = XEXP (mem, 0);\n \n   /* Strip off const from addresses like (const (plus (...))).  */\n@@ -18731,7 +18730,7 @@ arm_attr_length_move_neon (rtx_insn *insn)\n \n   if (GET_CODE (addr) == LABEL_REF || GET_CODE (addr) == PLUS)\n     {\n-      int insns = HARD_REGNO_NREGS (REGNO (reg), mode) / 2;\n+      int insns = REG_NREGS (reg) / 2;\n       return insns * 4;\n     }\n   else\n@@ -23713,7 +23712,7 @@ neon_split_vcombine (rtx operands[3])\n   unsigned int src1 = REGNO (operands[1]);\n   unsigned int src2 = REGNO (operands[2]);\n   machine_mode halfmode = GET_MODE (operands[1]);\n-  unsigned int halfregs = HARD_REGNO_NREGS (src1, halfmode);\n+  unsigned int halfregs = REG_NREGS (operands[1]);\n   rtx destlo, desthi;\n \n   if (src1 == dest && src2 == dest + halfregs)"}, {"sha": "e7f684143280dc2e05a9606d9b7625c9d450b61a", "filename": "gcc/config/c6x/c6x.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fc6x%2Fc6x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fc6x%2Fc6x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc6x%2Fc6x.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -4025,7 +4025,7 @@ static void\n c6x_mark_reg_read (rtx reg, bool cross)\n {\n   unsigned regno = REGNO (reg);\n-  unsigned nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n+  unsigned nregs = REG_NREGS (reg);\n \n   while (nregs-- > 0)\n     c6x_mark_regno_read (regno + nregs, cross);\n@@ -4037,7 +4037,7 @@ static void\n c6x_mark_reg_written (rtx reg, int cycles)\n {\n   unsigned regno = REGNO (reg);\n-  unsigned nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n+  unsigned nregs = REG_NREGS (reg);\n \n   while (nregs-- > 0)\n     ss.reg_set_in_cycle[regno + nregs] = cycles;\n@@ -6336,7 +6336,7 @@ c6x_dwarf_register_span (rtx rtl)\n     rtx p;\n \n     regno = REGNO (rtl);\n-    nregs = HARD_REGNO_NREGS (regno, GET_MODE (rtl));\n+    nregs = REG_NREGS (rtl);\n     if (nregs == 1)\n       return  NULL_RTX;\n "}, {"sha": "61bca2acb3025c3a377219b662a4a27d89f34424", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -12719,7 +12719,7 @@ ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined)\n       if (reg)\n \t{\n \t  unsigned int i = REGNO (reg);\n-\t  unsigned int nregs = hard_regno_nregs[i][GET_MODE (reg)];\n+\t  unsigned int nregs = REG_NREGS (reg);\n \t  while (nregs-- > 0)\n \t    if ((i + nregs) == regno)\n \t      return false;\n@@ -12728,7 +12728,7 @@ ix86_save_reg (unsigned int regno, bool maybe_eh_return, bool ignore_outlined)\n \t  if (reg)\n \t    {\n \t      i = REGNO (reg);\n-\t      nregs = hard_regno_nregs[i][GET_MODE (reg)];\n+\t      nregs = REG_NREGS (reg);\n \t      while (nregs-- > 0)\n \t\tif ((i + nregs) == regno)\n \t\t  return false;"}, {"sha": "426287081aeb9a58b9f37457a6a1fdcf01c4aba9", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -2653,7 +2653,7 @@ mark_reg_gr_used_mask (rtx reg, void *data ATTRIBUTE_UNUSED)\n   unsigned int regno = REGNO (reg);\n   if (regno < 32)\n     {\n-      unsigned int i, n = hard_regno_nregs[regno][GET_MODE (reg)];\n+      unsigned int i, n = REG_NREGS (reg);\n       for (i = 0; i < n; ++i)\n \tcurrent_frame_info.gr_used_mask |= 1 << (regno + i);\n     }\n@@ -6399,7 +6399,7 @@ static int\n rws_access_reg (rtx reg, struct reg_flags flags, int pred)\n {\n   int regno = REGNO (reg);\n-  int n = HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg));\n+  int n = REG_NREGS (reg);\n \n   if (n == 1)\n     return rws_access_regno (regno, flags, pred);"}, {"sha": "de7f3e577d08385f33522d12ba9bd91878b9b468", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -13241,9 +13241,7 @@ s390_call_saved_register_used (tree call_expr)\n \n        if (REG_P (parm_rtx))\n   \t {\n-\t   for (reg = 0;\n-\t\treg < HARD_REGNO_NREGS (REGNO (parm_rtx), GET_MODE (parm_rtx));\n-\t\treg++)\n+\t   for (reg = 0; reg < REG_NREGS (parm_rtx); reg++)\n \t     if (!call_used_regs[reg + REGNO (parm_rtx)])\n  \t       return true;\n \t }\n@@ -13258,9 +13256,7 @@ s390_call_saved_register_used (tree call_expr)\n \n \t       gcc_assert (REG_P (r));\n \n-\t       for (reg = 0;\n-\t\t    reg < HARD_REGNO_NREGS (REGNO (r), GET_MODE (r));\n-\t\t    reg++)\n+\t       for (reg = 0; reg < REG_NREGS (r); reg++)\n \t\t if (!call_used_regs[reg + REGNO (r)])\n \t\t   return true;\n \t     }"}, {"sha": "59e88888b1cfe0fcbe64597bc143fa87926f2f47", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -440,8 +440,7 @@ create_pre_exit (int n_entities, int *entity_map, const int *num_modes)\n \t\t\t|| short_block\n \t\t\t|| !(targetm.class_likely_spilled_p\n \t\t\t     (REGNO_REG_CLASS (ret_start)))\n-\t\t\t|| (nregs\n-\t\t\t    != hard_regno_nregs[ret_start][GET_MODE (ret_reg)])\n+\t\t\t|| nregs != REG_NREGS (ret_reg)\n \t\t\t/* For multi-hard-register floating point\n \t\t   \t   values, sometimes the likely-spilled part\n \t\t   \t   is ordinarily copied first, then the other"}, {"sha": "9e04954d35b1e96a22e41d4d2dfbbadbb3e8a0cb", "filename": "gcc/ree.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Free.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Free.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Free.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -823,8 +823,7 @@ combine_reaching_defs (ext_cand *cand, const_rtx set_pat, ext_state *state)\n \treturn false;\n \n       /* Ensure the number of hard registers of the copy match.  */\n-      if (HARD_REGNO_NREGS (REGNO (src_reg), dst_mode)\n-\t  != HARD_REGNO_NREGS (REGNO (src_reg), GET_MODE (src_reg)))\n+      if (HARD_REGNO_NREGS (REGNO (src_reg), dst_mode) != REG_NREGS (src_reg))\n \treturn false;\n \n       /* There's only one reaching def.  */\n@@ -1136,8 +1135,7 @@ add_removable_extension (const_rtx expr, rtx_insn *insn,\n \n \t We allow this when the registers are different because the\n \t code in combine_reaching_defs will handle that case correctly.  */\n-      if ((HARD_REGNO_NREGS (REGNO (dest), mode)\n-\t   != HARD_REGNO_NREGS (REGNO (reg), GET_MODE (reg)))\n+      if (HARD_REGNO_NREGS (REGNO (dest), mode) != REG_NREGS (reg)\n \t  && reg_overlap_mentioned_p (dest, reg))\n \treturn;\n "}, {"sha": "39977bec14408a0ab3487ccc59a199a239991a25", "filename": "gcc/regcprop.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fregcprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fregcprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregcprop.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -444,12 +444,9 @@ find_oldest_value_reg (enum reg_class cl, rtx reg, struct value_data *vd)\n \t(set (reg:SI r10) (...))\n \t(set (...) (reg:DI r9))\n      Replacing r9 with r11 is invalid.  */\n-  if (mode != vd->e[regno].mode)\n-    {\n-      if (hard_regno_nregs[regno][mode]\n-\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n-\treturn NULL_RTX;\n-    }\n+  if (mode != vd->e[regno].mode\n+      && REG_NREGS (reg) > hard_regno_nregs[regno][vd->e[regno].mode])\n+    return NULL_RTX;\n \n   for (i = vd->e[regno].oldest_regno; i != regno; i = vd->e[i].next_regno)\n     {\n@@ -871,14 +868,13 @@ copyprop_hardreg_forward_1 (basic_block bb, struct value_data *vd)\n \t     set it in, make sure that the replacement is valid.  */\n \t  if (mode != vd->e[regno].mode)\n \t    {\n-\t      if (hard_regno_nregs[regno][mode]\n+\t      if (REG_NREGS (src)\n \t\t  > hard_regno_nregs[regno][vd->e[regno].mode])\n \t\tgoto no_move_special_case;\n \n \t      /* And likewise, if we are narrowing on big endian the transformation\n \t\t is also invalid.  */\n-\t      if (hard_regno_nregs[regno][mode]\n-\t\t  < hard_regno_nregs[regno][vd->e[regno].mode]\n+\t      if (REG_NREGS (src) < hard_regno_nregs[regno][vd->e[regno].mode]\n \t\t  && (GET_MODE_SIZE (vd->e[regno].mode) > UNITS_PER_WORD\n \t\t      ? WORDS_BIG_ENDIAN : BYTES_BIG_ENDIAN))\n \t\tgoto no_move_special_case;"}, {"sha": "eb67db6c951b5b911f6d50c20e91271a79a11f95", "filename": "gcc/reload.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -862,7 +862,7 @@ reload_inner_reg_of_subreg (rtx x, machine_mode mode, bool output)\n \t  && GET_MODE_SIZE (mode) <= UNITS_PER_WORD\n \t  && GET_MODE_SIZE (GET_MODE (inner)) > UNITS_PER_WORD\n \t  && ((GET_MODE_SIZE (GET_MODE (inner)) / UNITS_PER_WORD)\n-\t      != (int) hard_regno_nregs[REGNO (inner)][GET_MODE (inner)]));\n+\t      != REG_NREGS (inner)));\n }\n \n /* Return nonzero if IN can be reloaded into REGNO with mode MODE without\n@@ -1086,8 +1086,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t\t       > UNITS_PER_WORD)\n \t\t   && ((GET_MODE_SIZE (GET_MODE (SUBREG_REG (in)))\n \t\t\t/ UNITS_PER_WORD)\n-\t\t       != (int) hard_regno_nregs[REGNO (SUBREG_REG (in))]\n-\t\t\t\t\t\t[GET_MODE (SUBREG_REG (in))]))\n+\t\t       != REG_NREGS (SUBREG_REG (in))))\n \t\t  || !targetm.hard_regno_mode_ok (subreg_regno (in), inmode)))\n \t  || (secondary_reload_class (1, rclass, inmode, in) != NO_REGS\n \t      && (secondary_reload_class (1, rclass, GET_MODE (SUBREG_REG (in)),\n@@ -1597,7 +1596,7 @@ push_reload (rtx in, rtx out, rtx *inloc, rtx *outloc,\n \t    && (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n \t\t|| (! bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t\t    ORIGINAL_REGNO (XEXP (note, 0)))\n-\t\t    && hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1))\n+\t\t    && REG_NREGS (XEXP (note, 0)) == 1))\n \t    && ! refers_to_regno_for_reload_p (regno,\n \t\t\t\t\t       end_hard_regno (rel_mode,\n \t\t\t\t\t\t\t       regno),\n@@ -1907,7 +1906,7 @@ combine_reloads (void)\n \t&& TEST_HARD_REG_BIT (reg_class_contents[(int) rld[output_reload].rclass],\n \t\t\t      regno)\n \t&& (hard_regno_nregs[regno][rld[output_reload].outmode]\n-\t    <= hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))])\n+\t    <= REG_NREGS (XEXP (note, 0)))\n \t/* Ensure that a secondary or tertiary reload for this output\n \t   won't want this register.  */\n \t&& ((secondary_out = rld[output_reload].secondary_out_reload) == -1\n@@ -1922,7 +1921,7 @@ combine_reloads (void)\n \t&& (ORIGINAL_REGNO (XEXP (note, 0)) < FIRST_PSEUDO_REGISTER\n \t    || (!bitmap_bit_p (DF_LR_OUT (ENTRY_BLOCK_PTR_FOR_FN (cfun)),\n \t\t\t       ORIGINAL_REGNO (XEXP (note, 0)))\n-\t\t&& hard_regno_nregs[regno][GET_MODE (XEXP (note, 0))] == 1)))\n+\t\t&& REG_NREGS (XEXP (note, 0)) == 1)))\n       {\n \trld[output_reload].reg_rtx\n \t  = gen_rtx_REG (rld[output_reload].outmode, regno);\n@@ -2088,7 +2087,7 @@ find_dummy_reload (rtx real_in, rtx real_out, rtx *inloc, rtx *outloc,\n \t\t because only another subword of the hardreg is actually\n \t\t used in the insn.  This cannot happen if the pseudo has\n \t\t been assigned exactly one hardreg.  See PR 33732.  */\n-\t      && hard_regno_nregs[REGNO (in)][GET_MODE (in)] == 1)))\n+\t      && REG_NREGS (in) == 1)))\n     {\n       unsigned int regno = REGNO (in) + in_offset;\n       unsigned int nwords = hard_regno_nregs[regno][inmode];\n@@ -7254,8 +7253,7 @@ reload_adjust_reg_for_mode (rtx reloadreg, machine_mode mode)\n   regno = REGNO (reloadreg);\n \n   if (REG_WORDS_BIG_ENDIAN)\n-    regno += (int) hard_regno_nregs[regno][GET_MODE (reloadreg)]\n-      - (int) hard_regno_nregs[regno][mode];\n+    regno += (int) REG_NREGS (reloadreg) - (int) hard_regno_nregs[regno][mode];\n \n   return gen_rtx_REG (mode, regno);\n }"}, {"sha": "092995138a6d4ae5bd62961c9ddefaf16e2638fd", "filename": "gcc/reload1.c", "status": "modified", "additions": 8, "deletions": 15, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -1965,10 +1965,8 @@ find_reload_regs (struct insn_chain *chain)\n       /* Show whether this reload already has a hard reg.  */\n       if (chain->rld[i].reg_rtx)\n \t{\n-\t  int regno = REGNO (chain->rld[i].reg_rtx);\n-\t  chain->rld[i].regno = regno;\n-\t  chain->rld[i].nregs\n-\t    = hard_regno_nregs[regno][GET_MODE (chain->rld[i].reg_rtx)];\n+\t  chain->rld[i].regno = REGNO (chain->rld[i].reg_rtx);\n+\t  chain->rld[i].nregs = REG_NREGS (chain->rld[i].reg_rtx);\n \t}\n       else\n \tchain->rld[i].regno = -1;\n@@ -4910,7 +4908,7 @@ forget_old_reloads_1 (rtx x, const_rtx ignored ATTRIBUTE_UNUSED,\n     {\n       unsigned int i;\n \n-      nr = hard_regno_nregs[regno][GET_MODE (x)];\n+      nr = REG_NREGS (x);\n       /* Storing into a spilled-reg invalidates its contents.\n \t This can happen if a block-local pseudo is allocated to that reg\n \t and it wasn't spilled because this block's total need is 0.\n@@ -5874,8 +5872,7 @@ reload_reg_free_for_value_p (int start_regno, int regno, int opnum,\n     {\n       rtx reg = rld[i].reg_rtx;\n       if (reg && REG_P (reg)\n-\t  && ((unsigned) regno - true_regnum (reg)\n-\t      <= hard_regno_nregs[REGNO (reg)][GET_MODE (reg)] - (unsigned) 1)\n+\t  && (unsigned) regno - true_regnum (reg) < REG_NREGS (reg)\n \t  && i != reloadnum)\n \t{\n \t  rtx other_input = rld[i].in;\n@@ -7155,8 +7152,7 @@ reload_adjust_reg_for_temp (rtx *reload_reg, rtx alt_reload_reg,\n \t{\n \t  if (!targetm.hard_regno_mode_ok (regno, new_mode))\n \t    continue;\n-\t  if (hard_regno_nregs[regno][new_mode]\n-\t      > hard_regno_nregs[regno][GET_MODE (reg)])\n+\t  if (hard_regno_nregs[regno][new_mode] > REG_NREGS (reg))\n \t    continue;\n \t  reg = reload_adjust_reg_for_mode (reg, new_mode);\n \t}\n@@ -8236,7 +8232,7 @@ emit_reload_insns (struct insn_chain *chain)\n \t\t{\n \t\t  machine_mode mode = GET_MODE (reg);\n \t\t  int regno = REGNO (reg);\n-\t\t  int nregs = hard_regno_nregs[regno][mode];\n+\t\t  int nregs = REG_NREGS (reg);\n \t\t  rtx out = (REG_P (rld[r].out)\n \t\t\t     ? rld[r].out\n \t\t\t     : rld[r].out_reg\n@@ -8315,7 +8311,7 @@ emit_reload_insns (struct insn_chain *chain)\n \n \t\t  mode = GET_MODE (reg);\n \t\t  regno = REGNO (reg);\n-\t\t  nregs = hard_regno_nregs[regno][mode];\n+\t\t  nregs = REG_NREGS (reg);\n \t\t  if (REG_P (rld[r].in)\n \t\t      && REGNO (rld[r].in) >= FIRST_PSEUDO_REGISTER)\n \t\t    in = rld[r].in;\n@@ -8837,10 +8833,7 @@ delete_output_reload (rtx_insn *insn, int j, int last_reload_reg,\n     return;\n \n   regno = REGNO (reg);\n-  if (regno >= FIRST_PSEUDO_REGISTER)\n-    nregs = 1;\n-  else\n-    nregs = hard_regno_nregs[regno][GET_MODE (reg)];\n+  nregs = REG_NREGS (reg);\n \n   /* If the pseudo-reg we are reloading is no longer referenced\n      anywhere between the store into it and here,"}, {"sha": "ce6a8696ebe2b4ae3258bede72d81b052f3cf78c", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/462a99aa98416135d2675d07d32f7ce234287983/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=462a99aa98416135d2675d07d32f7ce234287983", "patch": "@@ -1348,7 +1348,7 @@ choose_best_reg_1 (HARD_REG_SET hard_regs_used,\n       gcc_assert (mode == GET_MODE (orig_dest));\n \n       regno = REGNO (orig_dest);\n-      for (i = 0, n = hard_regno_nregs[regno][mode]; i < n; i++)\n+      for (i = 0, n = REG_NREGS (orig_dest); i < n; i++)\n         if (TEST_HARD_REG_BIT (hard_regs_used, regno + i))\n           break;\n \n@@ -1463,7 +1463,7 @@ choose_best_pseudo_reg (regset used_regs,\n       if (HARD_REGISTER_NUM_P (orig_regno))\n \t{\n \t  int j, n;\n-\t  for (j = 0, n = hard_regno_nregs[orig_regno][mode]; j < n; j++)\n+\t  for (j = 0, n = REG_NREGS (dest); j < n; j++)\n \t    if (REGNO_REG_SET_P (used_regs, orig_regno + j))\n \t      break;\n \t  if (j < n)"}]}