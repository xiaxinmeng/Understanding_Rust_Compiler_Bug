{"sha": "fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmFlNzc4ZWI2N2JiMGY2NzlmOGRkMzViOGQxZGQyN2FiNDUzYjFlZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2003-07-03T16:25:52Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2003-07-03T16:25:52Z"}, "message": "2064.md: Fix comment typos.\n\n\t* config/s390/2064.md: Fix comment typos.\n\t* config/s390/2084.md: Likewise.\n\t* config/s390/s390.c: Likewise.\n\t* config/s390/s390.md: Likewise.\n\t* config/sh/sh.c: Likewise.\n\t* config/sh/sh.h: Likewise.\n\t* config/sh/sh.md: Likewise.\n\t* config/sparc/sparc.c: Likewise.\n\t* config/sparc/sparc.h: Likewise.\n\t* config/sparc/sparc.md: Likewise.\n\t* config/stormy16/stormy16.c: Likewise.\n\t* config/stormy16/stormy16.h: Likewise.\n\t* config/stormy16/stormy-abi: Fix a typo.\n\nFrom-SVN: r68887", "tree": {"sha": "ec6ec5b6ee5c814bd6171ec74e71729c95d16c07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec6ec5b6ee5c814bd6171ec74e71729c95d16c07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/comments", "author": null, "committer": null, "parents": [{"sha": "8db1028ebab32f0d725be8dc886a6aa335d81575", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db1028ebab32f0d725be8dc886a6aa335d81575", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db1028ebab32f0d725be8dc886a6aa335d81575"}], "stats": {"total": 68, "additions": 42, "deletions": 26}, "files": [{"sha": "277cf33493f327d752be79ac6de3bffac0200bc9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -1,3 +1,19 @@\n+2003-07-03  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/s390/2064.md: Fix comment typos.\n+\t* config/s390/2084.md: Likewise.\n+\t* config/s390/s390.c: Likewise.\n+\t* config/s390/s390.md: Likewise.\n+\t* config/sh/sh.c: Likewise.\n+\t* config/sh/sh.h: Likewise.\n+\t* config/sh/sh.md: Likewise.\n+\t* config/sparc/sparc.c: Likewise.\n+\t* config/sparc/sparc.h: Likewise.\n+\t* config/sparc/sparc.md: Likewise.\n+\t* config/stormy16/stormy16.c: Likewise.\n+\t* config/stormy16/stormy16.h: Likewise.\n+\t* config/stormy16/stormy-abi: Fix a typo.\n+\n 2003-07-03  Kelley Cook  <kelleycook@wideopenwest.org>\n \n \t* Makefile.in (ifcvt.o): Depend on OPTABS_H."}, {"sha": "dc83cb6de6f01577f0ce7777337f96d735f996bd", "filename": "gcc/config/s390/2064.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2F2064.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2F2064.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2064.md?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -98,11 +98,11 @@\n \n ;;\n ;; s390_agen_dep_p returns 1, if a register is set in the \n-;; first insn and used in the dependend insn to form a address.\n+;; first insn and used in the dependent insn to form a address.\n ;;\n \n ;;\n-;; If a intruction uses a register to address memory, it needs\n+;; If an instruction uses a register to address memory, it needs\n ;; to be set 5 cycles in advance.\n ;; \n "}, {"sha": "f14bd21bc94426877c1678fda4c0b9702d1b5600", "filename": "gcc/config/s390/2084.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2F2084.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2F2084.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2F2084.md?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -209,11 +209,11 @@\n \n ;;\n ;; s390_agen_dep_p returns 1, if a register is set in the \n-;; first insn and used in the dependend insn to form a address.\n+;; first insn and used in the dependent insn to form a address.\n ;;\n \n ;;\n-;; If a intruction uses a register to address memory, it needs\n+;; If an instruction uses a register to address memory, it needs\n ;; to be set 5 cycles in advance.\n ;; \n "}, {"sha": "4e771be867df99e864b4f690060634eae72181da", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -896,7 +896,7 @@ s390_split_ok_p (dst, src, mode, first_subword)\n   if (FP_REG_P (src) || FP_REG_P (dst))\n     return false;\n \n-  /* We don't need to split if operands are directly accessable.  */\n+  /* We don't need to split if operands are directly accessible.  */\n   if (s_operand (src, mode) || s_operand (dst, mode))\n     return false;\n \n@@ -5645,7 +5645,7 @@ s390_emit_prologue ()\n \t  insn = emit_insn (gen_move_insn (temp_reg, stack_pointer_rtx));\n \t}\n       \n-      /* Substract frame size from stack pointer.  */\n+      /* Subtract frame size from stack pointer.  */\n \n       if (DISP_IN_RANGE (INTVAL (frame_off)))\n \t{"}, {"sha": "bd7b832039bc25694e268738a7a3c621dfef480a", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -3002,9 +3002,9 @@\n \n \n ;;\n-;; ARITHMETRIC OPERATIONS\n+;; ARITHMETIC OPERATIONS\n ;;\n-;  arithmetric operations set the ConditionCode,\n+;  arithmetic operations set the ConditionCode,\n ;  because of unpredictable Bits in Register for Halfword and Byte\n ;  the ConditionCode can be set wrong in operations for Halfword and Byte\n "}, {"sha": "e1c81c9c178f52f89516da4f67cc28f7740919a9", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -379,7 +379,7 @@ print_operand_address (stream, x)\n    ','  print LOCAL_LABEL_PREFIX\n    '@'  print trap, rte or rts depending upon pragma interruptness\n    '#'  output a nop if there is nothing to put in the delay slot\n-   '''  print likelyhood suffix (/u for unlikely).\n+   '''  print likelihood suffix (/u for unlikely).\n    'O'  print a constant without the #\n    'R'  print the LSW of a dp value - changes if in little endian\n    'S'  print the MSW of a dp value - changes if in little endian\n@@ -3557,7 +3557,7 @@ gen_far_branch (bp)\n     jump = emit_jump_insn_after (gen_return (), insn);\n   /* Emit a barrier so that reorg knows that any following instructions\n      are not reachable via a fall-through path.\n-     But don't do this when not optimizing, since we wouldn't supress the\n+     But don't do this when not optimizing, since we wouldn't suppress the\n      alignment for the barrier then, and could end up with out-of-range\n      pc-relative loads.  */\n   if (optimize)"}, {"sha": "9ab647aff5dce87e451fe2b6c59393dc0866eb3c", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -634,7 +634,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n /* get_mode_alignment assumes complex values are always held in multiple\n    registers, but that is not the case on the SH; CQImode and CHImode are\n    held in a single integer register.  SH5 also holds CSImode and SCmode\n-   values in integer regsters.  This is relevant for argument passing on\n+   values in integer registers.  This is relevant for argument passing on\n    SHcompact as we use a stack temp in order to pass CSImode by reference.  */\n #define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n   ((GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_INT \\\n@@ -1359,7 +1359,7 @@ extern enum reg_class reg_class_from_letter[];\n    unused CONST_INT constraint letters: LO\n    unused EXTRA_CONSTRAINT letters: D T U Y */\n \n-#if 1 /* check that the transistion went well.  */\n+#if 1 /* check that the transition went well.  */\n #define CONSTRAINT_LEN(C,STR) \\\n   (((C) == 'L' || (C) == 'O' || (C) == 'D' || (C) == 'T' || (C) == 'U' \\\n     || (C) == 'Y' \\"}, {"sha": "2af568b772ccc8f889f824835ccb5cb7f553d741", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -3002,8 +3002,8 @@\n     operands[1] = XEXP (operands[1], 0);\n }\")\n \n-;; ??? when a truncated input to a zero_extrend is reloaded, reload will\n-;; reload the entrire truncate expression.\n+;; ??? when a truncated input to a zero_extend is reloaded, reload will\n+;; reload the entire truncate expression.\n (define_insn_and_split \"*loaddi_trunc\"\n   [(set (match_operand 0 \"int_gpr_dest\" \"=r\")\n \t(truncate (match_operand:DI 1 \"memory_operand\" \"m\")))]"}, {"sha": "08b0236cd6692bb35208cd9070a864a1e3343320", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -1368,7 +1368,7 @@ input_operand (op, mode)\n \n \f\n /* We know it can't be done in one insn when we get here,\n-   the movsi expander guarentees this.  */\n+   the movsi expander guarantees this.  */\n void\n sparc_emit_set_const32 (op0, op1)\n      rtx op0;\n@@ -4552,7 +4552,7 @@ static rtx function_arg_record_value\n \tPARAMS ((tree, enum machine_mode, int, int, int));\n \n /* A subroutine of function_arg_record_value.  Traverse the structure\n-   recusively and determine how many registers will be required.  */\n+   recursively and determine how many registers will be required.  */\n \n static void\n function_arg_record_value_1 (type, startbitpos, parms)\n@@ -4959,7 +4959,7 @@ function_arg (cum, mode, type, named, incoming_p)\n \n \t     This is due to locate_and_pad_parm being called in\n \t     expand_call whenever reg_parm_stack_space > 0, which\n-\t     while benefical to our example here, would seem to be\n+\t     while beneficial to our example here, would seem to be\n \t     in error from what had been intended.  Ho hum...  -- r~ */\n #endif\n \t    return reg;\n@@ -6131,7 +6131,7 @@ sparc_splitdi_legitimate (reg, mem)\n }\n \n /* Return 1 if x and y are some kind of REG and they refer to\n-   different hard registers.  This test is guarenteed to be\n+   different hard registers.  This test is guaranteed to be\n    run after reload.  */\n \n int"}, {"sha": "9235f66bf53f27dc766d19735152b055f96a2b5e", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -26,7 +26,7 @@ Boston, MA 02111-1307, USA.  */\n    whatever definitions are necessary.  */\n \n /* Target CPU builtins.  FIXME: Defining sparc is for the benefit of\n-   Solaris only; otheriwse just define __sparc__.  Sadly the headers\n+   Solaris only; otherwise just define __sparc__.  Sadly the headers\n    are such a mess there is no Solaris-specific header.  */\n #define TARGET_CPU_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\\n@@ -1043,7 +1043,7 @@ while (0)\n       : (GET_MODE_SIZE (MODE) + 3) / 4)\t\t\t\t\t\\\n    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n \n-/* Due to the ARCH64 descrepancy above we must override this next\n+/* Due to the ARCH64 discrepancy above we must override this next\n    macro too.  */\n #define REGMODE_NATURAL_SIZE(MODE) \\\n   ((TARGET_ARCH64 && FLOAT_MODE_P (MODE)) ? 4 : UNITS_PER_WORD)\n@@ -1278,7 +1278,7 @@ extern enum reg_class sparc_regno_reg_class[FIRST_PSEUDO_REGISTER];\n \n    We know in this case that we will not end up with a leaf function.\n \n-   The register allocater is given the global and out registers first\n+   The register allocator is given the global and out registers first\n    because these registers are call clobbered and thus less useful to\n    global register allocation.\n "}, {"sha": "07ce71874c6aa65338b3c6a0af9e7a8d254e6d7a", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -3201,7 +3201,7 @@\n                                                    operands[1]));\n     }\n \n-  /* Handle MEM cases first, note that only v9 guarentees\n+  /* Handle MEM cases first, note that only v9 guarantees\n      full 16-byte alignment for quads.  */\n   if (GET_CODE (operands[0]) == MEM)\n     {\n@@ -7771,7 +7771,7 @@\n \n ;; For __builtin_setjmp we need to flush register windows iff the function\n ;; calls alloca as well, because otherwise the register window might be\n-;; saved after %sp adjustement and thus setjmp would crash\n+;; saved after %sp adjustment and thus setjmp would crash\n (define_expand \"builtin_setjmp_setup\"\n   [(match_operand 0 \"register_operand\" \"r\")]\n   \"\""}, {"sha": "01d15796f4e2e1a87967d6247342728a83a681a6", "filename": "gcc/config/stormy16/stormy-abi", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy-abi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy-abi?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -162,6 +162,6 @@ In the 'Overflow' column, 'none' means that any overflow of the\n computation perfomed in the 'Calculation' column is ignored.\n 'signed' means that the overflow is only reported if it happens when\n the values are treated as signed quantities.  'unsigned' is the same,\n-except that the values are treated as unsigned qunatities.  'either'\n+except that the values are treated as unsigned quantities.  'either'\n means that overflow is reported for either signed or unsigned\n overflow."}, {"sha": "8ce526f90d22defbaecac1a333071472afbd5d1b", "filename": "gcc/config/stormy16/stormy16.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.c?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -729,7 +729,7 @@ nonimmediate_nonstack_operand (op, mode)\n \t  && ! xstormy16_extra_constraint_p (op, 'R'));\n }\n \n-/* Splitter for the 'move' patterns, for modes not directly implemeted\n+/* Splitter for the 'move' patterns, for modes not directly implemented\n    by hardware.  Emit insns to copy a value of mode MODE from SRC to\n    DEST.\n "}, {"sha": "c6d1596a4d984e4add6973767949c67978ba2473", "filename": "gcc/config/stormy16/stormy16.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef/gcc%2Fconfig%2Fstormy16%2Fstormy16.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fstormy16%2Fstormy16.h?ref=fae778eb67bb0f679f8dd35b8d1dd27ab453b1ef", "patch": "@@ -496,7 +496,7 @@ enum reg_class\n   if (! SECOND_TIME) \\\n     xstormy16_setup_incoming_varargs (ARGS_SO_FAR, MODE, TYPE, & PRETEND_ARGS_SIZE)\n \n-/* Build up the stdarg/varargs va_list type tree, assinging it to NODE.  If not\n+/* Build up the stdarg/varargs va_list type tree, assigning it to NODE.  If not\n    defined, it is assumed that va_list is a void * pointer.  */\n #define BUILD_VA_LIST_TYPE(NODE) \\\n   ((NODE) = xstormy16_build_va_list ())"}]}