{"sha": "178679809068c72f9f4c63e53afeab651f06b882", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTc4Njc5ODA5MDY4YzcyZjlmNGM2M2U1M2FmZWFiNjUxZjA2Yjg4Mg==", "commit": {"author": {"name": "Douglas Rupp", "email": "rupp@adacore.com", "date": "2020-02-18T09:54:58Z"}, "committer": {"name": "Olivier Hainque", "email": "hainque@adacore.com", "date": "2020-10-21T16:26:37Z"}, "message": "Introduce vxworks7r2 support for ppc and ppc64\n\nThis change introduces support for the most recent versions\nof VxWorks on PowerPC targets, for both 32 and 64 bit thanks\nto a bi-arch setup.\n\nThe system compilers are essentially configured as Linux\ntoolchains with only a few specificities and we replicate\nthat model here.\n\nThe most visible specificities are the use of secureplt by\ndefault, the pre-definition of some macros that the system\nheaders still rely on (_VX_CPU and _VX_CPU_FAMILY, for example),\nand of course some variations related to the so VxWorks typical\nkernel vs RTP mode distinction.\n\nIn addition to the introduction of config.gcc and libgcc\nconfiguration chunks, much inspired by the linux ones, the\nchange\n\n- Reworks rs6000/vxworks.h file to feature bits common to the\n  Vx6 and Vx7 port then a separate section for each, where the\n  Vx7 part is very short as we rely on the Linux definitions\n  for most things.\n\n- Adjusts the CPU macro predefinitions in CPP_SPEC to resort\n  to \"_VX_CPU\" instead of \"CPU\" for Vx7, to better match the\n  more recent system headers expectations,\n\n- Adds a cpu definition case for e6500.\n\n- Changes to the use SUB3TARGET_OVERRIDE_OPTIONS instead of\n  SUBSUBTARGET_OVERRIDE_OPTIONS for specifics, so we don't\n  override the Linux's version of the latter for vx7.\n\n2020-10-20  Douglas Rupp  <rupp@adacore.com>\n\ngcc/\n\t* config.gcc (powerpc*-wrs-vxworks7r*): New case.\n\t* config/rs6000/vxworks.h: Rework to handle VxWorks7.\n\tRefactor as common bits + vx6 vs vx7 ones. For the\n\tlatter, rely essentially on the Linux configuration\n\tand adjust CPU to _VX_CPU in CPP_SPEC. Add a case\n\tfor e6500. Use SUB3TARGET_OVERRIDE_OPTIONS for specifics\n\tto preserve the Linux SUBSUBTARGET_OVERRIDE_OPTIONS\n\tfor vx7.\n\nlibgcc/\n\t* config.host (powerpc*-wrs-vxworks7*): New case.\n\t* configure.ac: Handle powerpc*-*-vxworks7* as\n\tpowerpc*-*-linux* for ppc-fp_type.\n\t* configure: Regenerate.\n\nCo-authored-by: Olivier Hainque <hainque@adacore.com>", "tree": {"sha": "d0afd2c2a9383214fea0ffded5f6c80c8fd19589", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0afd2c2a9383214fea0ffded5f6c80c8fd19589"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/178679809068c72f9f4c63e53afeab651f06b882", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178679809068c72f9f4c63e53afeab651f06b882", "html_url": "https://github.com/Rust-GCC/gccrs/commit/178679809068c72f9f4c63e53afeab651f06b882", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/178679809068c72f9f4c63e53afeab651f06b882/comments", "author": {"login": "Cementitious", "id": 115579865, "node_id": "U_kgDOBuOb2Q", "avatar_url": "https://avatars.githubusercontent.com/u/115579865?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Cementitious", "html_url": "https://github.com/Cementitious", "followers_url": "https://api.github.com/users/Cementitious/followers", "following_url": "https://api.github.com/users/Cementitious/following{/other_user}", "gists_url": "https://api.github.com/users/Cementitious/gists{/gist_id}", "starred_url": "https://api.github.com/users/Cementitious/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Cementitious/subscriptions", "organizations_url": "https://api.github.com/users/Cementitious/orgs", "repos_url": "https://api.github.com/users/Cementitious/repos", "events_url": "https://api.github.com/users/Cementitious/events{/privacy}", "received_events_url": "https://api.github.com/users/Cementitious/received_events", "type": "User", "site_admin": false}, "committer": {"login": "hainque", "id": 18735142, "node_id": "MDQ6VXNlcjE4NzM1MTQy", "avatar_url": "https://avatars.githubusercontent.com/u/18735142?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hainque", "html_url": "https://github.com/hainque", "followers_url": "https://api.github.com/users/hainque/followers", "following_url": "https://api.github.com/users/hainque/following{/other_user}", "gists_url": "https://api.github.com/users/hainque/gists{/gist_id}", "starred_url": "https://api.github.com/users/hainque/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hainque/subscriptions", "organizations_url": "https://api.github.com/users/hainque/orgs", "repos_url": "https://api.github.com/users/hainque/repos", "events_url": "https://api.github.com/users/hainque/events{/privacy}", "received_events_url": "https://api.github.com/users/hainque/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8f795cac6a1325bc6bcba3f47b7d04cb790400c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c8f795cac6a1325bc6bcba3f47b7d04cb790400c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c8f795cac6a1325bc6bcba3f47b7d04cb790400c"}], "stats": {"total": 279, "additions": 194, "deletions": 85}, "files": [{"sha": "03d89d763b9f8434a2f3a8a777525d6fb7509bee", "filename": "gcc/config.gcc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178679809068c72f9f4c63e53afeab651f06b882/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178679809068c72f9f4c63e53afeab651f06b882/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=178679809068c72f9f4c63e53afeab651f06b882", "patch": "@@ -2976,6 +2976,27 @@ powerpc*-*-linux*)\n \t\ttm_file=\"rs6000/secureplt.h ${tm_file}\"\n \tfi\n \t;;\n+powerpc*-wrs-vxworks7r*)\n+\n+\t# Wind River 7 post SR0600 is mostly like Linux so we setup\n+\t# our config in a very similar fashion and adjust to a few\n+\t# specificities.\n+\n+\t# The system compiler is configured with secureplt by default.\n+\ttm_file=\"${tm_file} rs6000/secureplt.h\"\n+\n+\ttm_file=\"${tm_file} elfos.h gnu-user.h linux.h freebsd-spec.h\"\n+\ttm_file=\"${tm_file} rs6000/sysv4.h rs6000/biarch64.h rs6000/default64.h rs6000/linux64.h\"\n+\ttm_file=\"${tm_file} vx-common.h vxworks.h rs6000/vxworks.h\"\n+\n+\textra_options=\"${extra_options} rs6000/sysv4.opt linux.opt rs6000/linux64.opt\"\n+\n+\ttmake_file=\"${tmake_file} t-linux rs6000/t-linux64 rs6000/t-fprules rs6000/t-ppccomm\"\n+\ttmake_file=\"${tmake_file} rs6000/t-vxworks\"\n+\n+\ttm_defines=\"$tm_defines DEFAULT_LIBC=LIBC_GLIBC\"\n+\textra_objs=\"$extra_objs linux.o rs6000-linux.o\"\n+\t;;\n powerpc-wrs-vxworks*)\n \ttm_file=\"${tm_file} elfos.h gnu-user.h freebsd-spec.h rs6000/sysv4.h\"\n \ttmake_file=\"${tmake_file} rs6000/t-fprules rs6000/t-ppccomm rs6000/t-vxworks\""}, {"sha": "87ca3af96e092aab0a3141d8855fd7de89d5019e", "filename": "gcc/config/rs6000/vxworks.h", "status": "modified", "additions": 152, "deletions": 81, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178679809068c72f9f4c63e53afeab651f06b882/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178679809068c72f9f4c63e53afeab651f06b882/gcc%2Fconfig%2Frs6000%2Fvxworks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvxworks.h?ref=178679809068c72f9f4c63e53afeab651f06b882", "patch": "@@ -18,10 +18,21 @@ You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING3.  If not see\n <http://www.gnu.org/licenses/>.  */\n \n-/* Note to future editors: VxWorks is mostly an EABI target.  We do\n-   not use rs6000/eabi.h because we would have to override most of\n-   it anyway.  However, if you change that file, consider making\n-   analogous changes here too.  */\n+/* The port comes in two very different flavors at this stage:\n+\n+   - For 653 (AE) and regular versions prior to VxWorks 7, the port\n+     comes with its own set of definitions, matching a system compiler\n+     configured this way as well as the corresponding run-time\n+     environment.  This is essentially an eabi system, so changes to\n+     eabi.h should usually be reflected here.\n+\n+   - Starting with VxWorks 7 (post SR600), the system environment\n+     was made extremely similar to GNU/Linux and this toolchain is\n+     built on top of the corresponding header files.  */\n+\n+/*-------------------------------------------------------------*/\n+/* Common definitions first.                                   */\n+/*-------------------------------------------------------------*/\n \n /* CPP predefined macros.  */\n \n@@ -86,97 +97,99 @@ along with GCC; see the file COPYING3.  If not see\n     }\t\t\\\n   while (0)\n \n-/* vx6 library path.  */\n-#if !TARGET_VXWORKS7\n-#undef  STARTFILE_PREFIX_SPEC\n-#define STARTFILE_PREFIX_SPEC\t\t\t\t\t\t\\\n- \"%{mrtp:%{!shared:%:getenv(WIND_BASE /target/lib/usr/lib/ppc/PPC32/common)}}\"\n+/* Specific CPU macro definitions expected by the system headers,\n+   inferred from -mcpu requests by the user.  Different versions of\n+   VxWorks expect different forms of macros, such as\n+\n+   -D_VX_CPU=_VX_PPC403 on Vx7 and some variants of Vx6,\n+   -DCPU=PPC403 on all Vx6 and earlier.  */\n+\n+#if TARGET_VXWORKS7\n+#define VX_CPU_PREFIX \"_VX_\"\n+#else\n+#define VX_CPU_PREFIX \"\"\n #endif\n \n-/* Only big endian PPC is supported by VxWorks.  */\n-#undef BYTES_BIG_ENDIAN\n-#define BYTES_BIG_ENDIAN 1\n-#undef WORDS_BIG_ENDIAN\n-#define WORDS_BIG_ENDIAN 1\n+#define VX_CPUDEF(CPUID) \\\n+  \":-D\" VX_CPU_PREFIX \"CPU=\" VX_CPU_PREFIX #CPUID\n \n-/* We have to kill off the entire specs set created by rs6000/sysv4.h\n-   and substitute our own set.  The top level vxworks.h has done some\n-   of this for us.  */\n+#define VX_MCPU(CPU,CPUID) \\\n+  \"mcpu=\" #CPU VX_CPUDEF(CPUID)\n \n-#undef SUBTARGET_EXTRA_SPECS\n #undef CPP_SPEC\n-#undef CC1_SPEC\n-#undef ASM_SPEC\n-\n-#define SUBTARGET_EXTRA_SPECS /* none needed */\n+#define CPP_SPEC\t\t\t\\\n+  \"%{!D\" VX_CPU_PREFIX \"CPU=*:%{\"\t\\\n+  VX_MCPU(403, PPC403)   \";\"\t\t\\\n+  VX_MCPU(405, PPC405)   \";\"\t\t\\\n+  VX_MCPU(440, PPC440)   \";\"\t\t\\\n+  VX_MCPU(464, PPC464)   \";\"\t\t\\\n+  VX_MCPU(476, PPC476)   \";\"\t\t\\\n+  VX_MCPU(603, PPC603)   \";\"\t\t\\\n+  VX_MCPU(604, PPC604)   \";\"\t\t\\\n+  VX_MCPU(860, PPC860)   \";\"\t\t\\\n+  VX_MCPU(e6500, E6500)  \";\"\t\t\\\n+  VX_MCPU(8540, PPC85XX) \";\"\t\t\\\n+  VX_MCPU(8548, PPC85XX) \";\"\t\t\\\n+  VX_CPUDEF(PPC604)\t\t\t\\\n+  \"}}\"\t\t\t\t\t\\\n+  VXWORKS_ADDITIONAL_CPP_SPEC\n \n /* FIXME: The only reason we allow no -mcpu switch at all is because\n-   config-ml.in insists on a \".\" multilib. */\n-#define CPP_SPEC \\\n-\"%{!DCPU=*:\t\t  \\\n-   %{mcpu=403 : -DCPU=PPC403  ; \\\n-     mcpu=405 : -DCPU=PPC405  ; \\\n-     mcpu=440 : -DCPU=PPC440  ; \\\n-     mcpu=464 : -DCPU=PPC464  ; \\\n-     mcpu=476 : -DCPU=PPC476  ; \\\n-     mcpu=603 : -DCPU=PPC603  ; \\\n-     mcpu=604 : -DCPU=PPC604  ; \\\n-     mcpu=860 : -DCPU=PPC860  ; \\\n-     mcpu=8540: -DCPU=PPC85XX ; \\\n-     mcpu=8548: -DCPU=PPC85XX ; \\\n-              : -DCPU=PPC604  }}\" \\\n-VXWORKS_ADDITIONAL_CPP_SPEC\n-\n-#define CC1_SPEC\t\t\t\t\t\t\\\n-\"%{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}\t\\\n- %{mlittle|mlittle-endian:-mstrict-align}\"\n-\n-#define ASM_SPEC \\\n-\"%(asm_cpu) \\\n- %{,assembler|,assembler-with-cpp: %{mregnames} %{mno-regnames}} \\\n- %{mrelocatable} %{mrelocatable-lib} %{\" FPIC_SPEC \":-K PIC} -mbig\"\n+   config-ml.in insists on a \".\" multilib.  */\n \n #undef  LIB_SPEC\n #define LIB_SPEC VXWORKS_LIB_SPEC\n \n-/* For RTPs, leverage linker relaxation.  This helps programs referring\n-   to, typically, kernel services too far away for short calls.  This is more\n-   precise than -mlongcall and can be overriden with -Wl,--no-relax.  */\n-#define VXWORKS_RELAX_LINK_SPEC \"%{mrtp:--relax}\"\n-\n-#undef  LINK_SPEC\n-#define LINK_SPEC VXWORKS_LINK_SPEC \" \" VXWORKS_RELAX_LINK_SPEC\n-\n #undef  STARTFILE_SPEC\n #define STARTFILE_SPEC VXWORKS_STARTFILE_SPEC\n+\n #undef  ENDFILE_SPEC\n #define ENDFILE_SPEC VXWORKS_ENDFILE_SPEC\n \n /* There is no default multilib.  */\n #undef MULTILIB_DEFAULTS\n \n-#undef TARGET_DEFAULT\n-#define TARGET_DEFAULT (MASK_EABI | MASK_STRICT_ALIGN)\n+/* No _mcount profiling on VxWorks.  */\n+#undef FUNCTION_PROFILER\n+#define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)\n \n-#undef PROCESSOR_DEFAULT\n-#define PROCESSOR_DEFAULT PROCESSOR_PPC604\n+/* Initialize library function table.  */\n+#undef TARGET_INIT_LIBFUNCS\n+#define TARGET_INIT_LIBFUNCS rs6000_vxworks_init_libfuncs\n \n /* Nor sdata, for kernel mode.  We use this in\n    SUBSUBTARGET_INITIALIZE_OPTIONS, after rs6000_rtp has been initialized.  */\n #undef SDATA_DEFAULT_SIZE\n #define SDATA_DEFAULT_SIZE (TARGET_VXWORKS_RTP ? 8 : 0)\n \n-/* Enforce 16-byte alignment for the stack pointer, to permit general\n-   compliance with e.g. Altivec instructions requirements.  Make sure\n-   this isn't overruled by the EABI constraints.  */\n+#undef SUB3TARGET_OVERRIDE_OPTIONS\n+#define SUB3TARGET_OVERRIDE_OPTIONS           \\\n+  do {                                          \\\n+  if (!global_options_set.x_g_switch_value)     \\\n+    g_switch_value = SDATA_DEFAULT_SIZE;        \\\n+  VXWORKS_OVERRIDE_OPTIONS;                     \\\n+  } while (0)\n \n-#undef  STACK_BOUNDARY\n-#define STACK_BOUNDARY (16*BITS_PER_UNIT)\n+/* The stack pointer need not be moved while checking the stack.  */\n+#undef STACK_CHECK_MOVING_SP\n \n-#undef  PREFERRED_STACK_BOUNDARY\n-#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+/* Define this to be nonzero if static stack checking is supported.  */\n+#define STACK_CHECK_STATIC_BUILTIN 1\n \n-#undef  ABI_STACK_BOUNDARY\n+/* Room needed to allow exception propagation, from what experiments\n+   and low level observations taught us ...  */\n+#define STACK_CHECK_PROTECT (TARGET_64BIT ? 16 * 1024 : 12 * 1024)\n+\n+/* Leverage linker relaxation for RTPs.  This helps 32bit programs\n+   referring to kernel services too far away for short calls, is more\n+   precise than -mlongcall and can be overriden with -Wl,--no-relax.  */\n+#define VXWORKS_RELAX_LINK_SPEC \"%{mrtp:--relax}\"\n+\n+/*-------------------------------------------------------------*/\n+/* Pre-VxWorks7 configuration.                                 */\n+/*-------------------------------------------------------------*/\n+\n+#if !TARGET_VXWORKS7\n \n #undef RS6000_STARTING_FRAME_OFFSET\n #define RS6000_STARTING_FRAME_OFFSET\t\t\t\t\t\\\n@@ -189,21 +202,79 @@ VXWORKS_ADDITIONAL_CPP_SPEC\n    RS6000_ALIGN (crtl->outgoing_args_size.to_constant ()\t\t\\\n \t\t + STACK_POINTER_OFFSET, 16)\n \n-#undef SUBSUBTARGET_OVERRIDE_OPTIONS\n-#define SUBSUBTARGET_OVERRIDE_OPTIONS\t\t\\\n-  do {\t\t\t\t\t\t\\\n-  if (!global_options_set.x_g_switch_value)\t\\\n-    g_switch_value = SDATA_DEFAULT_SIZE;\t\\\n-  VXWORKS_OVERRIDE_OPTIONS;\t\t\t\\\n-  } while (0)\n+/* Enforce 16-byte alignment for the stack pointer, to permit general\n+   compliance with e.g. Altivec instructions requirements.  Make sure\n+   this isn't overruled by the EABI constraints.  */\n \n-/* No _mcount profiling on VxWorks.  */\n-#undef FUNCTION_PROFILER\n-#define FUNCTION_PROFILER(FILE,LABELNO) VXWORKS_FUNCTION_PROFILER(FILE,LABELNO)\n+#undef  STACK_BOUNDARY\n+#define STACK_BOUNDARY (16*BITS_PER_UNIT)\n \n-/* Define this to be nonzero if static stack checking is supported.  */\n-#define STACK_CHECK_STATIC_BUILTIN 1\n+#undef  PREFERRED_STACK_BOUNDARY\n+#define PREFERRED_STACK_BOUNDARY STACK_BOUNDARY\n+\n+#undef  ABI_STACK_BOUNDARY\n+\n+#undef  STARTFILE_PREFIX_SPEC\n+#define STARTFILE_PREFIX_SPEC\t\t\t\t\t\t\\\n+ \"%{mrtp:%{!shared:%:getenv(WIND_BASE /target/lib/usr/lib/ppc/PPC32/common)}}\"\n+\n+/* For aggregates passing, use the same, consistent ABI as Linux.  */\n+#define AGGREGATE_PADDING_FIXED 0\n+#define AGGREGATES_PAD_UPWARD_ALWAYS 0\n+\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+\"%(asm_cpu) \\\n+ %{,assembler|,assembler-with-cpp: %{mregnames} %{mno-regnames}} \\\n+ %{mrelocatable} %{mrelocatable-lib} %{\" FPIC_SPEC \":-K PIC} -mbig\"\n+\n+#undef CC1_SPEC\n+#define CC1_SPEC VXWORKS_CC1_SPEC \" \\\n+  %{G*} %{mno-sdata:-msdata=none} %{msdata:-msdata=default}      \\\n+ %{mlittle|mlittle-endian:-mstrict-align}\"\n+\n+#undef  LINK_SPEC\n+#define LINK_SPEC VXWORKS_LINK_SPEC \" \" VXWORKS_RELAX_LINK_SPEC\n+\n+#undef TARGET_DEFAULT\n+#define TARGET_DEFAULT (MASK_EABI | MASK_STRICT_ALIGN)\n+\n+#undef PROCESSOR_DEFAULT\n+#define PROCESSOR_DEFAULT PROCESSOR_PPC604\n+\n+/* Only big endian PPC is supported by VxWorks.  */\n+#undef BYTES_BIG_ENDIAN\n+#define BYTES_BIG_ENDIAN 1\n+\n+#undef WORDS_BIG_ENDIAN\n+#define WORDS_BIG_ENDIAN 1\n+\n+#undef SUBTARGET_EXTRA_SPECS\n+#define SUBTARGET_EXTRA_SPECS /* none needed */\n+\n+#else /* TARGET_VXWORKS7 */\n+\n+/*-------------------------------------------------------------*/\n+/* Post-VxWorks7 (SR600) configuration.                        */\n+/*-------------------------------------------------------------*/\n+\n+/* VxWorks does not use local symbols for the function entry point.  */\n+#undef DOT_SYMBOLS\n+#define DOT_SYMBOLS 0\n+\n+#undef LINK_OS_VXWORKS_SPEC\n+#define LINK_OS_VXWORKS_SPEC \\\n+  \" %{!mrtp:-r} %{mrtp:-q -static} %{!Xbind-lazy:-z now}\"\n+\n+#undef LINK_OS_EXTRA_SPEC32\n+#define LINK_OS_EXTRA_SPEC32 LINK_OS_VXWORKS_SPEC \" \" VXWORKS_RELAX_LINK_SPEC\n+\n+#undef LINK_OS_EXTRA_SPEC64\n+#define LINK_OS_EXTRA_SPEC64 LINK_OS_VXWORKS_SPEC\n+\n+/* linux64.h enables this, not supported in vxWorks.  */\n+#undef TARGET_FLOAT128_ENABLE_TYPE\n+#define TARGET_FLOAT128_ENABLE_TYPE 0\n+\n+#endif /* TARGET_VXWORKS7 */\n \n-/* This platform supports the probing method of stack checking (RTP mode).\n-   8K is reserved in the stack to propagate exceptions in case of overflow.  */\n-#define STACK_CHECK_PROTECT 8192"}, {"sha": "fd8e55e92e1a3b2c52af36b5cde2509a801c138c", "filename": "libgcc/config.host", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfig.host", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfig.host", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfig.host?ref=178679809068c72f9f4c63e53afeab651f06b882", "patch": "@@ -1226,6 +1226,23 @@ powerpc*-*-linux*)\n \textra_parts=\"$extra_parts ecrti.o ecrtn.o ncrti.o ncrtn.o\"\n \tmd_unwind_header=rs6000/linux-unwind.h\n \t;;\n+powerpc*-wrs-vxworks7*)\n+        tmake_file=\"$tmake_file rs6000/t-ppccomm rs6000/t-savresfgpr rs6000/t-crtstuff rs6000/t-linux t-dfprules config/rs6000/t-ppc64-fp t-slibgcc-libgcc\"\n+        case $ppc_fp_type in\n+        64)\n+                ;;\n+        hard)\n+                tmake_file=\"${tmake_file} t-hardfp-sfdf\"\n+                ;;\n+        soft)\n+                tmake_file=\"${tmake_file} t-softfp-sfdf t-softfp\"\n+                ;;\n+        *)\n+                echo \"Unknown ppc_fp_type $ppc_fp_type\" 1>&2\n+                exit 1\n+                ;;\n+        esac\n+        ;;\n powerpc-wrs-vxworks*)\n \ttmake_file=\"$tmake_file rs6000/t-ppccomm rs6000/t-savresfgpr t-fdpbit\"\n \textra_parts=\"$extra_parts crtbegin.o crtend.o\""}, {"sha": "78fc22a5784e7c64980e46b7d586139e4317275f", "filename": "libgcc/configure", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure?ref=178679809068c72f9f4c63e53afeab651f06b882", "patch": "@@ -5164,11 +5164,11 @@ fi\n { $as_echo \"$as_me:${as_lineno-$LINENO}: result: $glibc_version_major.$glibc_version_minor\" >&5\n $as_echo \"$glibc_version_major.$glibc_version_minor\" >&6; }\n \n-# Determine floating-point type for powerpc*-*-linux*.\n+# Determine floating-point type for powerpc*-*-linux* or vxworks7*.\n # Single-precision-only FPRs are not a supported configuration for\n # this target, so are not allowed for in this test.\n case ${host} in\n-powerpc*-*-linux*)\n+powerpc*-*-linux* | powerpc*-*-vxworks7*)\n   cat > conftest.c <<EOF\n #ifdef __powerpc64__\n ppc_fp_type=64"}, {"sha": "ed50c0e9b494672babaad7129218b2b8dd82d711", "filename": "libgcc/configure.ac", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/178679809068c72f9f4c63e53afeab651f06b882/libgcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgcc%2Fconfigure.ac?ref=178679809068c72f9f4c63e53afeab651f06b882", "patch": "@@ -383,11 +383,11 @@ AC_COMPUTE_INT([glibc_version_minor], [__GLIBC_MINOR__],\n \t\t\t\t      [glibc_version_minor=0])])\n AC_MSG_RESULT([$glibc_version_major.$glibc_version_minor])\n \n-# Determine floating-point type for powerpc*-*-linux*.\n+# Determine floating-point type for powerpc*-*-linux* or vxworks7*.\n # Single-precision-only FPRs are not a supported configuration for\n # this target, so are not allowed for in this test.\n case ${host} in\n-powerpc*-*-linux*)\n+powerpc*-*-linux* | powerpc*-*-vxworks7*)\n   cat > conftest.c <<EOF\n #ifdef __powerpc64__\n ppc_fp_type=64"}]}