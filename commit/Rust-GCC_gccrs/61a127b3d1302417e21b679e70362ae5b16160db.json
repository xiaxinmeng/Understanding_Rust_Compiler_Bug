{"sha": "61a127b3d1302417e21b679e70362ae5b16160db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjFhMTI3YjNkMTMwMjQxN2UyMWI2NzllNzAzNjJhZTViMTYxNjBkYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-06T14:20:30Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-06T14:20:30Z"}, "message": "cp-tree.def (PTRMEM_CST): New tree node.\n\n\t* cp-tree.def (PTRMEM_CST): New tree node.\n\t* cp-tree.h (ptrmem_cst): New type.\n\t(lang_type): Remove local_typedecls.\n\t(dummy): Increase to 12 bits from 11.\n\t(CLASSTYPE_LOCAL_TYPEDECLS): Remove.\n\t(PTRMEM_CST_CLASS): New macro.\n\t(PTRMEM_CST_MEMBER): Likewise.\n\t(current_access_specifier): New variable.\n\t(current_class_type): Remove duplicate declaration.\n\t(finish_struct): Change prototype.\n\t(unreverse_member_declarations): New function.\n\t(pushdecl_class_level): Change prototype.\n\t(grok_enum_decls): Remove.\n\t(fixup_anonymous_union): New function.\n\t(grok_x_components): Change prototype.\n\t(tsubst_chain): Remove.\n\t(finish_member_template_decl): Likewise.\n\t(check_explicit_specialization): Fix indentation.\n\t(finish_class_definition): Change prototype.\n\t(finish_member_class_template): Likewise.\n\t(finish_member_declaration): New function.\n\t(check_multiple_declarators): Likewise.\n\t* class.c (class_stack_node_t): New type.\n\t(current_class_base): Remove.\n\t(current_class_stack): Change type.\n\t(current_access_specifier): New variable.\n\t(grow_method): Remove.\n\t(check_member_decl_is_same_in_complete_scope): Break out from\n\tfinish_struct.\n\t(make_method_vec): New function.\n\t(free_method_vec): Likewise.\n\t(add_implicitly_declared_members): Break out from finish_struct_1.\n\t(free_method_vecs): New variable.\n\t(add_method): Rework for direct use from parser.\n\t(handle_using_decl): Watch for NULL_TREE while iterating through\n\tCLASSTYPE_METHOD_VEC.\n\t(finish_struct_methods): Don't build CLASSTYPE_METHOD_VEC here;\n\tjust do some error-checking.\n\t(warn_hidden): Change iteration through CLASSTYPE_METHOD_VEC.\n\t(finish_struct_1): Simplify.  Use add_implicitly_declared_members.\n\t(finish_struct): Change prototype.  Simplify; fields and methods\n\tare already set up at this point.\n\t(init_class_processing): Set up current_class_stack.\n\t(pushclass): Save current_access_specifier.\n\t(popclass): Restore it.\n\t(currently_open_class): Simplify.\n\t(build_self_reference): Remove use of CLASSTYPE_LOCAL_TYPEDECLS.\n\t* decl.c (saved_scope): Add access_specifier.\n\t(maybe_push_to_top_level): Save it.\n\t(pop_from_top_level): Restore it.\n\t(maybe_process_template_type_declaration): Use\n\tfinish_member_declaration.\n\t(pushtag): Likewise.\n\t(pushdecl_class_level): Don't return a value.\n\t(fixup_anonymous_union): Break out from grok_x_components.\n\t(shadow_tag): Use it.\n\t(xref_tag): Complain about using an elaborated type specifier to\n\treference a template type parameter or typedef name.\n\t(xref_basetypes): Don't set CLASSTYPE_LOCAL_TYPEDECLS.\n\t(current_local_enum): Remove.\n\t(build_enumerator): Call finish_member_declaration.\n\t(grok_enum_decls): Remove.\n\t* decl2.c (grok_x_components): Simplify.\n\t(check_classfn): Change iteration through CLASSTYPE_METHOD_VEC.\n\t(grokfield): Don't set CLASSTYPE_LOCAL_TYPEDECLS.\n\t(merge_functions): Add to comment.\n\t(arg_assoc_type): Prototype.\n\t(arg_assoc): Pass as many arguments as there are parameters.\n\t* error.c (dump_expr): Handle PTRMEM_CST.  Improve handling of\n\tOFFSET_REF.\n\t* expr.c (cpls_expand_expr): Remove dead code.  Handle\n\tPTRMEM_CST.\n\t* friend.c (do_friend): Lookup friends when in nested classes.\n\tChange comments.\n\t* init.c (build_offset_ref): Do lookup even for classes that are\n\tonly partially defined.\n\t(decl_constant_value): Remove dead code.\n\t* method.c (build_overload_value): Remove hack where by TYPE was\n\tnot a TYPE.  Handle PTRMEM_CST.\n\t(build_template_parm_names): Don't pass a PARM_DECL where a TYPE\n\tshould go.\n\t* parse.y (components, notype_components, component_decl,\n\tcomponent_decl_1, component_declarator, component_declarator0):\n\tNow all are itype rather than ttype.  Rework to add members to\n\tclasses on the fly.\n\t(typesqpecqual_reserved): Use check_multiple_declarators.\n\t(structsp): Update class to finish_class_definition.\n\t(do_xref_defn): Unsplit into named_class_head.\n\t(access_specifier): Set current_access_specifier.\n\t* pt.c (set_current_access_from_decl): New function.\n\t(finish_member_template_decl): Don't take the parameters.\n\t(comp_template_args): Make more robust.\n\t(lookup_template_class): Don't use current_local_enum.\n\t(for_each_template_parm): Handle PTRMEM_CST.\n\t(instantiate_class_template): Use set_current_access_from_decl,\n\tfinish_member_declaration and unreverse_member_declarations.  Set\n\tlineno/input_filename before generating implicit member functions.\n\t(type_unification_real): Don't assume back-unification happens\n\tonly for the last argument.\n\t(regenerate_decl_from_template): Call pushclass a bit earlier.\n\t(tsubst_chain): Remove.\n\t(tsubst_enum): Use set_current_access_from_decl.\n\t(set_mangled_name_for_template_decl): Fix indentation.\n\t* search.c (lookup_fnfields_1): Change iteration through\n\tCLASSTYPE_METHOD_VEC.\n\t(dfs_pushdecls): Likewise.\n\t(dfs_compress_decls): Likewise.\n\t(add_conversions): Likewise.\n\t* semantics.c (finish_class_definition): Don't take components.\n\tChange call to finish_struct.\n\t(finish_member_declaration): New function.\n\t(finish_member_class_template): Don't take template parameters.\n\tChange call to grok_x_components.  Call finish_member_template_decl.\n\t(check_multiple_declarators): New function.\n\t* sig.c (append_signature_fields): Work from the TYPE_METHODS, not\n\ta passed in fieldlist.\n\t* tree.c (search_tree): Handle PTRMEM_CST.\n\t(mapcar): Likewise.\n\t* typeck.c (unary_complex_lvalue): Build PTRMEM_CSTs, not\n\tINTEGER_CSTs, for pointer-to-data members.\n\nFrom-SVN: r22869", "tree": {"sha": "ca926df12cc21f9255b06e75608dc6cf68e8a63e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca926df12cc21f9255b06e75608dc6cf68e8a63e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/61a127b3d1302417e21b679e70362ae5b16160db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a127b3d1302417e21b679e70362ae5b16160db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61a127b3d1302417e21b679e70362ae5b16160db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61a127b3d1302417e21b679e70362ae5b16160db/comments", "author": null, "committer": null, "parents": [{"sha": "1c9a32c2d5e7f60f5092437b3232d83a49702316", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c9a32c2d5e7f60f5092437b3232d83a49702316", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c9a32c2d5e7f60f5092437b3232d83a49702316"}], "stats": {"total": 8842, "additions": 4595, "deletions": 4247}, "files": [{"sha": "1588d2d3da8c92191c3da5d40971f215189bb887", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1,5 +1,126 @@\n 1998-10-06  Mark Mitchell  <mark@markmitchell.com>\n \n+\t* cp-tree.def (PTRMEM_CST): New tree node.\n+\t* cp-tree.h (ptrmem_cst): New type.\n+\t(lang_type): Remove local_typedecls.\n+\t(dummy): Increase to 12 bits from 11.\n+\t(CLASSTYPE_LOCAL_TYPEDECLS): Remove.\n+\t(PTRMEM_CST_CLASS): New macro.\n+\t(PTRMEM_CST_MEMBER): Likewise.\n+\t(current_access_specifier): New variable.\n+\t(current_class_type): Remove duplicate declaration.\n+\t(finish_struct): Change prototype.\n+\t(unreverse_member_declarations): New function.\n+\t(pushdecl_class_level): Change prototype.\n+\t(grok_enum_decls): Remove.\n+\t(fixup_anonymous_union): New function.\n+\t(grok_x_components): Change prototype.\n+\t(tsubst_chain): Remove.\n+\t(finish_member_template_decl): Likewise.\n+\t(check_explicit_specialization): Fix indentation.\n+\t(finish_class_definition): Change prototype.\n+\t(finish_member_class_template): Likewise.\n+\t(finish_member_declaration): New function.\n+\t(check_multiple_declarators): Likewise.\n+\t* class.c (class_stack_node_t): New type.\n+\t(current_class_base): Remove.\n+\t(current_class_stack): Change type.\n+\t(current_access_specifier): New variable.\n+\t(grow_method): Remove.\n+\t(check_member_decl_is_same_in_complete_scope): Break out from\n+\tfinish_struct.\n+\t(make_method_vec): New function.\n+\t(free_method_vec): Likewise.\n+\t(add_implicitly_declared_members): Break out from finish_struct_1.\n+\t(free_method_vecs): New variable.\n+\t(add_method): Rework for direct use from parser.\n+\t(handle_using_decl): Watch for NULL_TREE while iterating through\n+\tCLASSTYPE_METHOD_VEC.\n+\t(finish_struct_methods): Don't build CLASSTYPE_METHOD_VEC here;\n+\tjust do some error-checking.\n+\t(warn_hidden): Change iteration through CLASSTYPE_METHOD_VEC.\n+\t(finish_struct_1): Simplify.  Use add_implicitly_declared_members.\n+\t(finish_struct): Change prototype.  Simplify; fields and methods\n+\tare already set up at this point.\n+\t(init_class_processing): Set up current_class_stack.\n+\t(pushclass): Save current_access_specifier.\n+\t(popclass): Restore it.\n+\t(currently_open_class): Simplify.\n+\t(build_self_reference): Remove use of CLASSTYPE_LOCAL_TYPEDECLS.\n+\t* decl.c (saved_scope): Add access_specifier.\n+\t(maybe_push_to_top_level): Save it.\n+\t(pop_from_top_level): Restore it.\n+\t(maybe_process_template_type_declaration): Use\n+\tfinish_member_declaration. \n+\t(pushtag): Likewise.\n+\t(pushdecl_class_level): Don't return a value.\n+\t(fixup_anonymous_union): Break out from grok_x_components.\n+\t(shadow_tag): Use it.\n+\t(xref_tag): Complain about using an elaborated type specifier to\n+\treference a template type parameter or typedef name.\n+\t(xref_basetypes): Don't set CLASSTYPE_LOCAL_TYPEDECLS.\n+\t(current_local_enum): Remove.\n+\t(build_enumerator): Call finish_member_declaration.\n+\t(grok_enum_decls): Remove.\n+\t* decl2.c (grok_x_components): Simplify.\n+\t(check_classfn): Change iteration through CLASSTYPE_METHOD_VEC.\n+\t(grokfield): Don't set CLASSTYPE_LOCAL_TYPEDECLS.\n+\t(merge_functions): Add to comment.\n+\t(arg_assoc_type): Prototype.\n+\t(arg_assoc): Pass as many arguments as there are parameters.\n+\t* error.c (dump_expr): Handle PTRMEM_CST.  Improve handling of\n+\tOFFSET_REF.\n+\t* expr.c (cpls_expand_expr): Remove dead code.  Handle\n+\tPTRMEM_CST.\n+\t* friend.c (do_friend): Lookup friends when in nested classes.\n+\tChange comments.\n+\t* init.c (build_offset_ref): Do lookup even for classes that are\n+\tonly partially defined.\n+\t(decl_constant_value): Remove dead code.\n+\t* method.c (build_overload_value): Remove hack where by TYPE was\n+\tnot a TYPE.  Handle PTRMEM_CST.\n+\t(build_template_parm_names): Don't pass a PARM_DECL where a TYPE\n+\tshould go.\n+\t* parse.y (components, notype_components, component_decl,\n+\tcomponent_decl_1, component_declarator, component_declarator0):\n+\tNow all are itype rather than ttype.  Rework to add members to\n+\tclasses on the fly.\n+\t(typesqpecqual_reserved): Use check_multiple_declarators.\n+\t(structsp): Update class to finish_class_definition.\n+\t(do_xref_defn): Unsplit into named_class_head.\n+\t(access_specifier): Set current_access_specifier.\n+\t* pt.c (set_current_access_from_decl): New function.\n+\t(finish_member_template_decl): Don't take the parameters.\n+\t(comp_template_args): Make more robust.\n+\t(lookup_template_class): Don't use current_local_enum.\n+\t(for_each_template_parm): Handle PTRMEM_CST.\n+\t(instantiate_class_template): Use set_current_access_from_decl,\n+\tfinish_member_declaration and unreverse_member_declarations.  Set\n+\tlineno/input_filename before generating implicit member functions.  \n+\t(type_unification_real): Don't assume back-unification happens\n+\tonly for the last argument.\n+\t(regenerate_decl_from_template): Call pushclass a bit earlier.\n+\t(tsubst_chain): Remove.\n+\t(tsubst_enum): Use set_current_access_from_decl.\n+\t(set_mangled_name_for_template_decl): Fix indentation.\n+\t* search.c (lookup_fnfields_1): Change iteration through\n+\tCLASSTYPE_METHOD_VEC.\n+\t(dfs_pushdecls): Likewise.\n+\t(dfs_compress_decls): Likewise.\n+\t(add_conversions): Likewise.\n+\t* semantics.c (finish_class_definition): Don't take components.\n+\tChange call to finish_struct.\n+\t(finish_member_declaration): New function.\n+\t(finish_member_class_template): Don't take template parameters.\n+\tChange call to grok_x_components.  Call finish_member_template_decl.\n+\t(check_multiple_declarators): New function.\n+\t* sig.c (append_signature_fields): Work from the TYPE_METHODS, not\n+\ta passed in fieldlist.\n+\t* tree.c (search_tree): Handle PTRMEM_CST.\n+\t(mapcar): Likewise.\n+\t* typeck.c (unary_complex_lvalue): Build PTRMEM_CSTs, not\n+\tINTEGER_CSTs, for pointer-to-data members.\n+\t\n \t* call.c (resolve_args): Resolve template specializations, if\n \tpossible.\n "}, {"sha": "33a443475c2afb440d39366a68adf2c20967f272", "filename": "gcc/cp/class.c", "status": "modified", "additions": 408, "deletions": 403, "changes": 811, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -43,11 +43,32 @@ extern struct obstack permanent_obstack;\n \n extern void set_class_shadows PROTO ((tree));\n \n-/* Way of stacking class types.  */\n-static tree *current_class_base, *current_class_stack;\n-static int current_class_stacksize;\n+/* The number of nested classes being processed.  If we are not in the\n+   scope of any class, this is zero.  */\n+\n int current_class_depth;\n \n+/* In order to deal with nested classes, we keep a stack of classes.\n+   The topmost entry is the innermost class, and is the entry at index\n+   CURRENT_CLASS_DEPTH  */\n+\n+typedef struct class_stack_node {\n+  /* The name of the class.  */\n+  tree name;\n+\n+  /* The _TYPE node for the class.  */\n+  tree type;\n+\n+  /* The access specifier pending for new declarations in the scope of\n+     this class.  */\n+  tree access;\n+}* class_stack_node_t;\n+\n+/* The stack itself.  This is an dynamically resized array.  The\n+   number of elements allocated is CURRENT_CLASS_STACK_SIZE.  */\n+static int current_class_stack_size;\n+static class_stack_node_t current_class_stack;\n+\n /* When we're processing a member function, current_class_ptr is the\n    PARM_DECL for the `this' pointer.  The current_class_ref is an\n    expression for `*this'.  */\n@@ -56,6 +77,7 @@ tree current_class_ptr, current_class_ref;\n /* The following two can be derived from the previous one */\n tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n tree current_class_type;\t/* _TYPE: the type of the current class */\n+tree current_access_specifier;\n tree previous_class_type;\t/* _TYPE: the previous type that was a class */\n tree previous_class_values;\t/* TREE_LIST: copy of the class_shadowed list\n \t\t\t\t   when leaving an outermost class scope.  */\n@@ -74,7 +96,6 @@ static tree build_vtable PROTO((tree, tree));\n static void prepare_fresh_vtable PROTO((tree, tree));\n static void fixup_vtable_deltas1 PROTO((tree, tree));\n static void fixup_vtable_deltas PROTO((tree, int, tree));\n-static void grow_method PROTO((tree, tree *));\n static void finish_vtbls PROTO((tree, int, tree));\n static void modify_vtable_entry PROTO((tree, tree, tree));\n static tree get_vtable_entry_n PROTO((tree, unsigned HOST_WIDE_INT));\n@@ -103,6 +124,10 @@ static void build_class_init_list PROTO((tree));\n static int finish_base_struct PROTO((tree, struct base_info *));\n static void finish_struct_methods PROTO((tree));\n static void maybe_warn_about_overly_private_class PROTO ((tree));\n+static void check_member_decl_is_same_in_complete_scope PROTO((tree, tree));\n+static tree make_method_vec PROTO((int));\n+static void free_method_vec PROTO((tree));\n+static tree add_implicitly_declared_members PROTO((tree, int, int, int));\n \n /* Way of stacking language names.  */\n tree *current_lang_base, *current_lang_stack;\n@@ -1046,6 +1071,46 @@ add_virtual_function (pv, phv, has_virtual, fndecl, t)\n struct obstack class_obstack;\n extern struct obstack *current_obstack;\n \n+/* These are method vectors that were too small for the number of\n+   methods in some class, and so were abandoned.  */\n+static tree free_method_vecs;\n+\n+/* Returns a method vector with enough room for N methods.  N should\n+   be a power of two.  */\n+\n+static tree\n+make_method_vec (n)\n+     int n;\n+{\n+  tree new_vec;\n+  tree* t;\n+  \n+  for (t = &free_method_vecs; *t; t = &(TREE_CHAIN (*t)))\n+    /* Note that we don't use >= n here because we don't want to\n+       allocate a very large vector where it isn't needed.  */\n+    if (TREE_VEC_LENGTH (*t) == n)\n+      {\n+\tnew_vec = *t;\n+\t*t = TREE_CHAIN (new_vec);\n+\tTREE_CHAIN (new_vec) = NULL_TREE;\n+\tbzero (&TREE_VEC_ELT (new_vec, 0), n * sizeof (tree));\n+\treturn new_vec;\n+      }\n+\n+  new_vec = make_tree_vec (n);\n+  return new_vec;\n+}\n+\n+/* Free the method vector VEC.  */\n+\n+static void\n+free_method_vec (vec)\n+     tree vec;\n+{\n+  TREE_CHAIN (vec) = free_method_vecs;\n+  free_method_vecs = vec;\n+}\n+\n /* Add method METHOD to class TYPE.  This is used when a method\n    has been defined which did not initially appear in the class definition,\n    and helps cut down on spurious error messages.\n@@ -1059,109 +1124,127 @@ add_method (type, fields, method)\n {\n   push_obstacks (&permanent_obstack, &permanent_obstack);\n \n+  /* Setting the DECL_CONTEXT and DECL_CLASS_CONTEXT here is probably\n+     redundant.  */\n+  DECL_CONTEXT (method) = type;\n+  DECL_CLASS_CONTEXT (method) = type;\n+  \n   if (fields && *fields)\n-      *fields = build_overload (method, *fields);\n-  else if (CLASSTYPE_METHOD_VEC (type) == 0)\n-    {\n-      tree method_vec = make_node (TREE_VEC);\n-      if (TYPE_IDENTIFIER (type) == DECL_NAME (method))\n-\t{\n-\t  /* ??? Is it possible for there to have been enough room in the\n-\t     current chunk for the tree_vec structure but not a tree_vec\n-\t     plus a tree*?  Will this work in that case?  */\n-\t  obstack_free (current_obstack, method_vec);\n-\t  obstack_blank (current_obstack, sizeof (struct tree_vec) + sizeof (tree *));\n-\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)))\n-\t    TREE_VEC_ELT (method_vec, 1) = method;\n-\t  else\n-\t    TREE_VEC_ELT (method_vec, 0) = method;\n-\t  TREE_VEC_LENGTH (method_vec) = 2;\n-\t}\n-      else\n+    *fields = build_overload (method, *fields);\n+  else \n+    {\n+      int len;\n+      tree method_vec;\n+\n+      if (!CLASSTYPE_METHOD_VEC (type))\n+\t/* Make a new method vector.  We start with 8 entries.  We must\n+\t   allocate at least two (for constructors and destructors), and\n+\t   we're going to end up with an assignment operator at some\n+\t   point as well.  \n+\n+\t   We could use a TREE_LIST for now, and convert it to a\n+\t   TREE_VEC in finish_struct, but we would probably waste more\n+\t   memory making the links in the list than we would by\n+\t   over-allocating the size of the vector here.  Furthermore,\n+\t   we would complicate all the code that expects this to be a\n+\t   vector.  We keep a free list of vectors that we outgrew so\n+\t   that we don't really waste any memory.  */\n+\tCLASSTYPE_METHOD_VEC (type) = make_method_vec (8);\n+\n+      method_vec = CLASSTYPE_METHOD_VEC (type);\n+      len = TREE_VEC_LENGTH (method_vec);\n+\n+      if (DECL_NAME (method) == constructor_name (type))\n \t{\n-\t  /* ??? Is it possible for there to have been enough room in the\n-\t     current chunk for the tree_vec structure but not a tree_vec\n-\t     plus a tree*?  Will this work in that case?  */\n-\t  obstack_free (current_obstack, method_vec);\n-\t  obstack_blank (current_obstack, sizeof (struct tree_vec) + 2*sizeof (tree *));\n-\t  TREE_VEC_ELT (method_vec, 2) = method;\n-\t  TREE_VEC_LENGTH (method_vec) = 3;\n-\t  obstack_finish (current_obstack);\n-\t}\n-      CLASSTYPE_METHOD_VEC (type) = method_vec;\n-    }\n-  else\n-    {\n-      tree method_vec = CLASSTYPE_METHOD_VEC (type);\n-      int len = TREE_VEC_LENGTH (method_vec);\n+\t  /* A new constructor or destructor.  Constructors go in \n+\t     slot 0; destructors go in slot 1.  */\n+\t  int slot \n+\t    = DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method)) ? 1 : 0;\n \n-      /* Adding a new ctor or dtor.  This is easy because our\n-         METHOD_VEC always has a slot for such entries.  */\n-      if (TYPE_IDENTIFIER (type) == DECL_NAME (method))\n-\t{\n-\t  int idx = !!DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (method));\n-\t  /* TREE_VEC_ELT (method_vec, idx) = method; */\n-\t  if (method != TREE_VEC_ELT (method_vec, idx))\n-\t    TREE_VEC_ELT (method_vec, idx) =\n-\t      build_overload (method, TREE_VEC_ELT (method_vec, idx));\n+\t  TREE_VEC_ELT (method_vec, slot)\n+\t    = build_overload (method, TREE_VEC_ELT (method_vec, slot));\n \t}\n       else\n \t{\n-\t  /* This is trickier.  We try to extend the TREE_VEC in-place,\n-\t     but if that does not work, we copy all its data to a new\n-\t     TREE_VEC that's large enough.  */\n-\t  struct obstack *ob = &class_obstack;\n-\t  tree *end = (tree *)obstack_next_free (ob);\n+\t  int i;\n \n-\t  if (end != TREE_VEC_END (method_vec))\n+\t  /* See if we already have an entry with this name.  */\n+\t  for (i = 2; i < len; ++i)\n+\t    if (!TREE_VEC_ELT (method_vec, i)\n+\t\t|| (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i))) \n+\t\t    == DECL_NAME (method)))\n+\t      break;\n+\t\t\n+\t  if (i == len)\n \t    {\n-\t      ob = current_obstack;\n-\t      TREE_VEC_LENGTH (method_vec) += 1;\n-\t      TREE_VEC_ELT (method_vec, len) = NULL_TREE;\n-\t      method_vec = copy_node (method_vec);\n-\t      TREE_VEC_LENGTH (method_vec) -= 1;\n+\t      /* We need a bigger method vector.  */\n+\t      tree new_vec = make_method_vec (2 * len);\n+\t      bcopy (&TREE_VEC_ELT (method_vec, 0),\n+\t\t     &TREE_VEC_ELT (new_vec, 0),\n+\t\t     len * sizeof (tree));\n+\t      free_method_vec (method_vec);\n+\t      len = 2 * len;\n+\t      method_vec = CLASSTYPE_METHOD_VEC (type) = new_vec;\n \t    }\n-\t  else\n+\n+\t  if (IDENTIFIER_TYPENAME_P (DECL_NAME (method)))\n \t    {\n-\t      tree tmp_vec = (tree) obstack_base (ob);\n-\t      if (obstack_room (ob) < sizeof (tree))\n+\t      /* Type conversion operators have to come before\n+\t\t ordinary methods; add_conversions depends on this to\n+\t\t speed up looking for conversion operators.  So, if\n+\t\t necessary, we slide some of the vector elements up.\n+\t\t In theory, this makes this algorithm O(N^2) but we\n+\t\t don't expect many conversion operators.  */\n+\t      for (i = 2; i < len; ++i)\n \t\t{\n-\t\t  obstack_blank (ob, sizeof (struct tree_common)\n-\t\t\t\t + tree_code_length[(int) TREE_VEC]\n-\t\t\t\t   * sizeof (char *)\n-\t\t\t\t + len * sizeof (tree));\n-\t\t  tmp_vec = (tree) obstack_base (ob);\n-\t\t  bcopy ((char *) method_vec, (char *) tmp_vec,\n-\t\t\t (sizeof (struct tree_common)\n-\t\t\t  + tree_code_length[(int) TREE_VEC] * sizeof (char *)\n-\t\t\t  + (len-1) * sizeof (tree)));\n-\t\t  method_vec = tmp_vec;\n+\t\t  tree fn = TREE_VEC_ELT (method_vec, i);\n+\t\t  tree name;\n+\n+\t\t  if (!fn)\n+\t\t    /* There are no more entries in the vector, so we\n+\t\t       can insert the new conversion operator here.  */\n+\t\t    break;\n+\t\t  \n+\t\t  name = DECL_NAME (OVL_CURRENT (fn));\n+\t\t  if (!IDENTIFIER_TYPENAME_P (name))\n+\t\t    /* We can insert the new function right at the Ith\n+\t\t       position.  */\n+\t\t    break;\n \t\t}\n+\n+\t      if (!TREE_VEC_ELT (method_vec, i))\n+\t\t/* There is nothing in the Ith slot, so we can avoid\n+\t\t   moving anything.  */\n+\t\t; \n \t      else\n-\t\tobstack_blank (ob, sizeof (tree));\n+\t\t{\n+\t\t  /* We know the last slot in the vector is empty\n+\t\t     because we know that at this point there's room for\n+\t\t     a new function.  */\n+\t\t  bcopy (&TREE_VEC_ELT (method_vec, i),\n+\t\t\t &TREE_VEC_ELT (method_vec, i + 1),\n+\t\t\t (len - i - 1) * sizeof (tree));\n+\t\t  TREE_VEC_ELT (method_vec, i) = NULL_TREE;\n+\t\t}\n \t    }\n \n-\t  obstack_finish (ob);\n-\t  TREE_VEC_ELT (method_vec, len) = method;\n-\t  TREE_VEC_LENGTH (method_vec) = len + 1;\n-\t  CLASSTYPE_METHOD_VEC (type) = method_vec;\n-\n-\t  if (TYPE_BINFO_BASETYPES (type) && CLASSTYPE_BASELINK_VEC (type))\n-\t    {\n-\t      /* ??? May be better to know whether these can be extended?  */\n-\t      tree baselink_vec = CLASSTYPE_BASELINK_VEC (type);\n-\n-\t      TREE_VEC_LENGTH (baselink_vec) += 1;\n-\t      CLASSTYPE_BASELINK_VEC (type) = copy_node (baselink_vec);\n-\t      TREE_VEC_LENGTH (baselink_vec) -= 1;\n-\n-\t      TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), len) = 0;\n-\t    }\n+\t  /* Actually insert the new method.  */\n+\t  TREE_VEC_ELT (method_vec, i) \n+\t    = build_overload (method, TREE_VEC_ELT (method_vec, i));\n+\t}\n+      \n+      if (TYPE_BINFO_BASETYPES (type) && CLASSTYPE_BASELINK_VEC (type))\n+\t{\n+\t  /* ??? May be better to know whether these can be extended?  */\n+\t  tree baselink_vec = CLASSTYPE_BASELINK_VEC (type);\n+\t  \n+\t  TREE_VEC_LENGTH (baselink_vec) += 1;\n+\t  CLASSTYPE_BASELINK_VEC (type) = copy_node (baselink_vec);\n+\t  TREE_VEC_LENGTH (baselink_vec) -= 1;\n+\t  \n+\t  TREE_VEC_ELT (CLASSTYPE_BASELINK_VEC (type), len) = 0;\n \t}\n     }\n-  DECL_CONTEXT (method) = type;\n-  DECL_CLASS_CONTEXT (method) = type;\n-\n   pop_obstacks ();\n }\n \n@@ -1360,7 +1443,7 @@ handle_using_decl (using_decl, t, method_vec, fields)\n   \n   name = DECL_NAME (fdecl);\n   n_methods = method_vec ? TREE_VEC_LENGTH (method_vec) : 0;\n-  for (i = 2; i < n_methods; i++)\n+  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); i++)\n     if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n \t== name)\n       {\n@@ -1872,33 +1955,6 @@ finish_struct_bits (t, max_has_virtual)\n     }\n }\n \n-/* Add FNDECL to the method_vec growing on the class_obstack.  Used by\n-   finish_struct_methods.  Note, FNDECL cannot be a constructor or\n-   destructor, those cases are handled by the caller.  */\n-\n-static void\n-grow_method (fndecl, method_vec_ptr)\n-     tree fndecl;\n-     tree *method_vec_ptr;\n-{\n-  tree method_vec = (tree)obstack_base (&class_obstack);\n-\n-  /* Start off past the constructors and destructor.  */\n-  tree *testp = &TREE_VEC_ELT (method_vec, 2);\n-\n-  while (testp < (tree *) obstack_next_free (&class_obstack)\n-\t && (*testp == NULL_TREE || DECL_NAME (OVL_CURRENT (*testp)) != DECL_NAME (fndecl)))\n-    testp++;\n-\n-  if (testp < (tree *) obstack_next_free (&class_obstack))\n-    *testp = build_overload (fndecl, *testp);\n-  else\n-    {\n-      obstack_ptr_grow (&class_obstack, fndecl);\n-      *method_vec_ptr = (tree)obstack_base (&class_obstack);\n-    }\n-}\n-\n /* Issue warnings about T having private constructors, but no friends,\n    and so forth.  \n \n@@ -2044,9 +2100,6 @@ maybe_warn_about_overly_private_class (t)\n /* Warn about duplicate methods in fn_fields.  Also compact method\n    lists so that lookup can be made faster.\n \n-   Algorithm: Outer loop builds lists by method name.  Inner loop\n-   checks for redundant method names within a list.\n-\n    Data Structure: List of method lists.  The outer list is a\n    TREE_LIST, whose TREE_PURPOSE field is the field name and the\n    TREE_VALUE is the DECL_CHAIN of the FUNCTION_DECLs.  TREE_CHAIN\n@@ -2069,22 +2122,10 @@ finish_struct_methods (t)\n      tree t;\n {\n   tree fn_fields;\n-  tree method_vec;\n+  tree method_vec = CLASSTYPE_METHOD_VEC (t);\n   tree ctor_name = constructor_name (t);\n   int i, n_baseclasses = CLASSTYPE_N_BASECLASSES (t);\n \n-  /* Now prepare to gather fn_fields into vector.  */\n-  struct obstack *ambient_obstack = current_obstack;\n-  current_obstack = &class_obstack;\n-  method_vec = make_tree_vec (2);\n-  current_obstack = ambient_obstack;\n-\n-  /* Now make this a live vector.  */\n-  obstack_free (&class_obstack, method_vec);\n-\n-  /* Save room for constructors and destructors.  */\n-  obstack_blank (&class_obstack, sizeof (struct tree_vec) + sizeof (struct tree *));\n-\n   /* First fill in entry 0 with the constructors, entry 1 with destructors,\n      and the next few with type conversion operators (if any).  */\n   for (fn_fields = TYPE_METHODS (t); fn_fields; \n@@ -2119,32 +2160,8 @@ finish_struct_methods (t)\n  \t\t    TYPE_HAS_NONPUBLIC_CTOR (t) = 2;\n  \t\t}\n  \t    }\n-\t  if (DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (fn_fields)))\n-\t    {\t    \n-\t      /* Destructors go in slot 1.  */\n-\t      TREE_VEC_ELT (method_vec, 1) = \n-\t\tbuild_overload (fn_fields, TREE_VEC_ELT (method_vec, 1));\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Constructors go in slot 0.  */\n-\t      TREE_VEC_ELT (method_vec, 0) = \n-\t\tbuild_overload (fn_fields, TREE_VEC_ELT (method_vec, 0));\n-\t    }\n- \t}\n-      else if (IDENTIFIER_TYPENAME_P (fn_name))\n-\tgrow_method (fn_fields, &method_vec);\n-    }\n-\n-  for (fn_fields = TYPE_METHODS (t); fn_fields; \n-       fn_fields = TREE_CHAIN (fn_fields))\n-    {\n-      tree fn_name = DECL_NAME (fn_fields);\n-\n-      if (fn_name == ctor_name || IDENTIFIER_TYPENAME_P (fn_name))\n-\tcontinue;\n-\n-      if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n+\t}\n+      else if (fn_name == ansi_opname[(int) MODIFY_EXPR])\n \t{\n \t  tree parmtype = TREE_VALUE (FUNCTION_ARG_CHAIN (fn_fields));\n \n@@ -2156,15 +2173,8 @@ finish_struct_methods (t)\n \t\tTYPE_HAS_NONPUBLIC_ASSIGN_REF (t) = 2;\n \t    }\n \t}\n-\n-      grow_method (fn_fields, &method_vec);\n     }\n \n-  TREE_VEC_LENGTH (method_vec) = (tree *)obstack_next_free (&class_obstack)\n-    - (&TREE_VEC_ELT (method_vec, 0));\n-  obstack_finish (&class_obstack);\n-  CLASSTYPE_METHOD_VEC (t) = method_vec;\n-\n   if (TYPE_HAS_DESTRUCTOR (t) && !TREE_VEC_ELT (method_vec, 1))\n     /* We thought there was a destructor, but there wasn't.  Some\n        parse errors cause this anomalous situation.  */\n@@ -2178,18 +2188,21 @@ finish_struct_methods (t)\n      destructors), compute where member functions of the same\n      name reside in base classes.  */\n   if (n_baseclasses != 0\n+      && method_vec\n       && TREE_VEC_LENGTH (method_vec) > 2)\n     {\n       int len = TREE_VEC_LENGTH (method_vec);\n       tree baselink_vec = make_tree_vec (len);\n       int any_links = 0;\n       tree baselink_binfo = build_tree_list (NULL_TREE, TYPE_BINFO (t));\n \n-      for (i = 2; i < len; i++)\n+      for (i = 2; i < len && TREE_VEC_ELT (method_vec, i); i++)\n \t{\n+\t  tree ovl = TREE_VEC_ELT (method_vec, i);\n+\n \t  TREE_VEC_ELT (baselink_vec, i)\n \t    = get_baselinks (baselink_binfo, t, \n-\t\t\t     DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i))));\n+\t\t\t     DECL_NAME (OVL_CURRENT (ovl)));\n \t  if (TREE_VEC_ELT (baselink_vec, i) != 0)\n \t    any_links = 1;\n \t}\n@@ -2995,7 +3008,7 @@ warn_hidden (t)\n   int i;\n \n   /* We go through each separately named virtual function.  */\n-  for (i = 2; i < n_methods; ++i)\n+  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); ++i)\n     {\n       tree fns = TREE_VEC_ELT (method_vec, i);\n       tree fndecl;\n@@ -3096,6 +3109,90 @@ finish_struct_anon (t)\n \n extern int interface_only, interface_unknown;\n \n+/* Create default constructors, assignment operators, and so forth for\n+   the type indicated by T, if they are needed.\n+   CANT_HAVE_DEFAULT_CTOR, CANT_HAVE_CONST_CTOR, and\n+   CANT_HAVE_ASSIGNMENT are nonzero if, for whatever reason, the class\n+   cannot have a default constructor, copy constructor taking a const\n+   reference argument, or an assignment operator, respectively.  If a\n+   virtual destructor is created, its DECL is returned; otherwise the\n+   return value is NULL_TREE.  */\n+\n+static tree\n+add_implicitly_declared_members (t, cant_have_default_ctor,\n+\t\t\t\t cant_have_const_cctor,\n+\t\t\t\t cant_have_assignment)\n+     tree t;\n+     int cant_have_default_ctor;\n+     int cant_have_const_cctor;\n+     int cant_have_assignment;\n+{\n+  tree default_fn;\n+  tree implicit_fns = NULL_TREE;\n+  tree name = TYPE_IDENTIFIER (t);\n+  tree virtual_dtor = NULL_TREE;\n+  tree *f;\n+\n+  /* Destructor.  */\n+  if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n+      && !IS_SIGNATURE (t))\n+    {\n+      default_fn = cons_up_default_function (t, name, 0);\n+      check_for_override (default_fn, t);\n+\n+      /* If we couldn't make it work, then pretend we didn't need it.  */\n+      if (default_fn == void_type_node)\n+\tTYPE_NEEDS_DESTRUCTOR (t) = 0;\n+      else\n+\t{\n+\t  TREE_CHAIN (default_fn) = implicit_fns;\n+\t  implicit_fns = default_fn;\n+\n+\t  if (DECL_VINDEX (default_fn))\n+\t    virtual_dtor = default_fn;\n+\t}\n+    }\n+  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n+\n+  /* Default constructor.  */\n+  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor\n+      && ! IS_SIGNATURE (t))\n+    {\n+      default_fn = cons_up_default_function (t, name, 2);\n+      TREE_CHAIN (default_fn) = implicit_fns;\n+      implicit_fns = default_fn;\n+    }\n+\n+  /* Copy constructor.  */\n+  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n+    {\n+      /* ARM 12.18: You get either X(X&) or X(const X&), but\n+\t not both.  --Chip  */\n+      default_fn = cons_up_default_function (t, name,\n+\t\t\t\t\t     3 + cant_have_const_cctor);\n+      TREE_CHAIN (default_fn) = implicit_fns;\n+      implicit_fns = default_fn;\n+    }\n+\n+  /* Assignment operator.  */\n+  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n+    {\n+      default_fn = cons_up_default_function (t, name,\n+\t\t\t\t\t     5 + cant_have_assignment);\n+      TREE_CHAIN (default_fn) = implicit_fns;\n+      implicit_fns = default_fn;\n+    }\n+\n+  /* Now, hook all of the new functions on to TYPE_METHODS,\n+     and add them to the CLASSTYPE_METHOD_VEC.  */\n+  for (f = &implicit_fns; *f; f = &TREE_CHAIN (*f))\n+    add_method (t, 0, *f);\n+  *f = TYPE_METHODS (t);\n+  TYPE_METHODS (t) = implicit_fns;\n+\n+  return virtual_dtor;\n+}\n+\n /* Create a RECORD_TYPE or UNION_TYPE node for a C struct or union declaration\n    (or C++ class declaration).\n \n@@ -3121,10 +3218,6 @@ extern int interface_only, interface_unknown;\n    inheritance.  Additional virtual function tables have different\n    DELTAs, which tell how to adjust `this' to point to the right thing.\n \n-   LIST_OF_FIELDLISTS is just that.  The elements of the list are\n-   TREE_LIST elements, whose TREE_PURPOSE field tells what access\n-   the list has, and the TREE_VALUE slot gives the actual fields.\n-\n    ATTRIBUTES is the set of decl attributes to be applied, if any.  */\n \n tree\n@@ -3133,10 +3226,8 @@ finish_struct_1 (t, warn_anon)\n      int warn_anon;\n {\n   int old;\n-  tree name = TYPE_IDENTIFIER (t);\n   enum tree_code code = TREE_CODE (t);\n   tree fields = TYPE_FIELDS (t);\n-  tree fn_fields = TYPE_METHODS (t);\n   tree x, last_x, method_vec;\n   int has_virtual;\n   int max_has_virtual;\n@@ -3145,6 +3236,7 @@ finish_struct_1 (t, warn_anon)\n   tree abstract_virtuals = NULL_TREE;\n   tree vfield;\n   tree vfields;\n+  tree virtual_dtor;\n   int cant_have_default_ctor;\n   int cant_have_const_ctor;\n   int no_const_asn_ref;\n@@ -3262,8 +3354,6 @@ finish_struct_1 (t, warn_anon)\n       if (IDENTIFIER_ERROR_LOCUS (DECL_ASSEMBLER_NAME (x)))\n \tcontinue;\n \n-      DECL_CLASS_CONTEXT (x) = t;\n-\n       /* Do both of these, even though they're in the same union;\n \t if the insn `r' member and the size `i' member are\n \t different sizes, as on the alpha, the larger of the two\n@@ -3626,32 +3716,6 @@ finish_struct_1 (t, warn_anon)\n   CLASSTYPE_REF_FIELDS_NEED_INIT (t) = ref_sans_init;\n   CLASSTYPE_ABSTRACT_VIRTUALS (t) = abstract_virtuals;\n \n-  /* Synthesize any needed methods.  Note that methods will be synthesized\n-     for anonymous unions; grok_x_components undoes that.  */\n-\n-  if (TYPE_NEEDS_DESTRUCTOR (t) && !TYPE_HAS_DESTRUCTOR (t)\n-      && !IS_SIGNATURE (t))\n-    {\n-      /* Here we must cons up a destructor on the fly.  */\n-      tree dtor = cons_up_default_function (t, name, 0);\n-      check_for_override (dtor, t);\n-\n-      /* If we couldn't make it work, then pretend we didn't need it.  */\n-      if (dtor == void_type_node)\n-\tTYPE_NEEDS_DESTRUCTOR (t) = 0;\n-      else\n-\t{\n-\t  /* Link dtor onto end of fn_fields.  */\n-\n-\t  TREE_CHAIN (dtor) = fn_fields;\n-\t  fn_fields = dtor;\n-\n-\t  if (DECL_VINDEX (dtor))\n-\t    add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n-\t\t\t\t  &has_virtual, dtor, t);\n-\t}\n-    }\n-\n   /* Effective C++ rule 11.  */\n   if (has_pointers && warn_ecpp && TYPE_HAS_CONSTRUCTOR (t)\n       && ! (TYPE_HAS_INIT_REF (t) && TYPE_HAS_ASSIGN_REF (t)))\n@@ -3667,9 +3731,9 @@ finish_struct_1 (t, warn_anon)\n       else if (! TYPE_HAS_ASSIGN_REF (t))\n \tcp_warning (\"  but does not override `operator=(const %T&)'\", t);\n     }\n-\n-  TYPE_NEEDS_DESTRUCTOR (t) |= TYPE_HAS_DESTRUCTOR (t);\n-\n+  \n+  /* Do some bookkeeping that will guide the generation of implicitly\n+     declared member functions.  */\n   TYPE_HAS_COMPLEX_INIT_REF (t)\n     |= (TYPE_HAS_INIT_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t)\n \t|| has_virtual || any_default_members);\n@@ -3679,46 +3743,23 @@ finish_struct_1 (t, warn_anon)\n   if (! IS_SIGNATURE (t))\n     CLASSTYPE_NON_AGGREGATE (t)\n       = ! aggregate || has_virtual || TYPE_HAS_CONSTRUCTOR (t);\n-\n-  /* ARM $12.1: A default constructor will be generated for a class X\n-     only if no constructor has been declared for class X.  So we\n-     check TYPE_HAS_CONSTRUCTOR also, to make sure we don't generate\n-     one if they declared a constructor in this class.  */\n-  if (! TYPE_HAS_CONSTRUCTOR (t) && ! cant_have_default_ctor\n-      && ! IS_SIGNATURE (t))\n-    {\n-      tree default_fn = cons_up_default_function (t, name, 2);\n-      TREE_CHAIN (default_fn) = fn_fields;\n-      fn_fields = default_fn;\n-    }\n-\n-  /* Create default copy constructor, if needed.  */\n-  if (! TYPE_HAS_INIT_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n-    {\n-      /* ARM 12.18: You get either X(X&) or X(const X&), but\n-\t not both.  --Chip  */\n-      tree default_fn = cons_up_default_function (t, name,\n-\t\t\t\t\t\t  3 + cant_have_const_ctor);\n-      TREE_CHAIN (default_fn) = fn_fields;\n-      fn_fields = default_fn;\n-    }\n-\n   TYPE_HAS_REAL_ASSIGNMENT (t) |= TYPE_HAS_ASSIGNMENT (t);\n   TYPE_HAS_REAL_ASSIGN_REF (t) |= TYPE_HAS_ASSIGN_REF (t);\n   TYPE_HAS_COMPLEX_ASSIGN_REF (t)\n     |= TYPE_HAS_ASSIGN_REF (t) || TYPE_USES_VIRTUAL_BASECLASSES (t);\n \n-  if (! TYPE_HAS_ASSIGN_REF (t) && ! IS_SIGNATURE (t) && ! TYPE_FOR_JAVA (t))\n-    {\n-      tree default_fn = cons_up_default_function (t, name,\n-\t\t\t\t\t\t  5 + no_const_asn_ref);\n-      TREE_CHAIN (default_fn) = fn_fields;\n-      fn_fields = default_fn;\n-    }\n+  /* Synthesize any needed methods.  Note that methods will be synthesized\n+     for anonymous unions; grok_x_components undoes that.  */\n+  virtual_dtor \n+    = add_implicitly_declared_members (t, cant_have_default_ctor,\n+\t\t\t\t       cant_have_const_ctor,\n+\t\t\t\t       no_const_asn_ref);\n+  if (virtual_dtor)\n+    add_virtual_function (&pending_virtuals, &pending_hard_virtuals,\n+\t\t\t  &has_virtual, virtual_dtor, t);\n \n-  if (fn_fields)\n+  if (TYPE_METHODS (t))\n     {\n-      TYPE_METHODS (t) = fn_fields;\n       finish_struct_methods (t);\n       method_vec = CLASSTYPE_METHOD_VEC (t);\n     }\n@@ -3806,12 +3847,12 @@ finish_struct_1 (t, warn_anon)\n       for (x = fields; x; x = TREE_CHAIN (x))\n \t{\n \t  tree name = DECL_NAME (x);\n-\t  int i = 2;\n+\t  int i;\n \n \t  if (TREE_CODE (x) == TYPE_DECL && DECL_ARTIFICIAL (x))\n \t    continue;\n \n-\t  for (; i < n_methods; ++i)\n+\t  for (i = 2; i < n_methods && TREE_VEC_ELT (method_vec, i); ++i)\n \t    if (DECL_NAME (OVL_CURRENT (TREE_VEC_ELT (method_vec, i)))\n \t\t== name)\n \t      {\n@@ -4229,18 +4270,94 @@ finish_struct_1 (t, warn_anon)\n   return t;\n }\n \n+/* In [basic.scope.class] we have:\n+\n+     A name N used in a class S shall refer to the same declaration in\n+     its context and when re-evaluated in the completed scope of S.\n+     \n+   This function checks this condition for X, which is a member of\n+   T.  */\n+\n+static void\n+check_member_decl_is_same_in_complete_scope (t, x)\n+     tree t;\n+     tree x;\n+{\n+  /* A name N used in a class S shall refer to the same declaration in\n+     its context and when re-evaluated in the completed scope of S.\n+     \n+     Enums, types and static vars have already been checked.  */\n+  if (TREE_CODE (x) != USING_DECL \n+      && TREE_CODE (x) != TYPE_DECL && !DECL_CLASS_TEMPLATE_P (x)\n+      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n+    {\n+      tree name = DECL_NAME (x);\n+      tree icv;\n+\n+      /* Don't get confused by access decls.  */\n+      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n+\ticv = IDENTIFIER_CLASS_VALUE (name);\n+      else\n+\ticv = NULL_TREE;\n+\n+      if (icv\n+\t  /* Don't complain about constructors.  */\n+\t  && name != constructor_name (current_class_type)\n+\t  /* Or inherited names.  */\n+\t  && id_in_current_class (name)\n+\t  /* Or shadowed tags.  */\n+\t  && !(TREE_CODE (icv) == TYPE_DECL && DECL_CONTEXT (icv) == t))\n+\t{\n+\t  cp_pedwarn_at (\"declaration of identifier `%D' as `%+#D'\",\n+\t\t\t name, x);\n+\t  cp_pedwarn_at (\"conflicts with other use in class as `%#D'\",\n+\t\t\t icv);\n+\t}\n+    }\n+}\n+\n+/* When T was built up, the member declarations were added in reverse\n+   order.  Rearrange them to declaration order.  */\n+\n+void\n+unreverse_member_declarations (t)\n+     tree t;\n+{\n+  tree next;\n+  tree prev;\n+  tree x;\n+\n+  /* The TYPE_FIELDS, TYPE_METHODS, and CLASSTYPE_TAGS are all in\n+     reverse order.  Put them in declaration order now.  */\n+  TYPE_METHODS (t) = nreverse (TYPE_METHODS (t));\n+  CLASSTYPE_TAGS (t) = nreverse (CLASSTYPE_TAGS (t));\n+\n+  /* Actually, for the TYPE_FIELDS, only the non TYPE_DECLs are in\n+     reverse order, so we can't just use nreverse.  */\n+  prev = NULL_TREE;\n+  for (x = TYPE_FIELDS (t); \n+       x && TREE_CODE (x) != TYPE_DECL; \n+       x = next)\n+    {\n+      next = TREE_CHAIN (x);\n+      TREE_CHAIN (x) = prev;\n+      prev = x;\n+    }\n+  if (prev)\n+    {\n+      TREE_CHAIN (TYPE_FIELDS (t)) = x;\n+      if (prev)\n+\tTYPE_FIELDS (t) = prev;\n+    }\n+}\n+\n tree\n-finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n-     tree t, list_of_fieldlists, attributes;\n+finish_struct (t, attributes, warn_anon)\n+     tree t, attributes;\n      int warn_anon;\n {\n-  tree fields = NULL_TREE;\n-  tree *tail = &TYPE_METHODS (t);\n   tree name = TYPE_NAME (t);\n-  tree x, last_x = NULL_TREE;\n-  tree access;\n-  tree dummy = NULL_TREE;\n-  tree next_x = NULL_TREE;\n+  tree x;\n \n   if (TREE_CODE (name) == TYPE_DECL)\n     {\n@@ -4260,147 +4377,23 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n \n   /* Append the fields we need for constructing signature tables.  */\n   if (IS_SIGNATURE (t))\n-    append_signature_fields (list_of_fieldlists);\n-\n-  /* Move our self-reference declaration to the end of the field list so\n-     any real field with the same name takes precedence.  */\n-  if (list_of_fieldlists\n-      && TREE_VALUE (list_of_fieldlists)\n-      && DECL_ARTIFICIAL (TREE_VALUE (list_of_fieldlists)))\n-    {\n-      dummy = TREE_VALUE (list_of_fieldlists);\n-      list_of_fieldlists = TREE_CHAIN (list_of_fieldlists);\n-    }\n-\n-  if (last_x && list_of_fieldlists)\n-    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n-\n-  while (list_of_fieldlists)\n-    {\n-      access = TREE_PURPOSE (list_of_fieldlists);\n-\n-      /* For signatures, we made all methods `public' in the parser and\n-\t reported an error if a access specifier was used.  */\n-      if (access == access_default_node)\n-\t{\n-\t  if (CLASSTYPE_DECLARED_CLASS (t) == 0)\n-\t    access = access_public_node;\n-\t  else\n-\t    access = access_private_node;\n-\t}\n-\n-      for (x = TREE_VALUE (list_of_fieldlists); x; x = next_x)\n-\t{\n-\t  next_x = TREE_CHAIN (x);\n-\n-\t  TREE_PRIVATE (x) = access == access_private_node;\n-\t  TREE_PROTECTED (x) = access == access_protected_node;\n-\n-\t  if (TREE_CODE (x) == TEMPLATE_DECL)\n-\t    {\n-\t      TREE_PRIVATE (DECL_RESULT (x)) = TREE_PRIVATE (x);\n-\t      TREE_PROTECTED (DECL_RESULT (x)) = TREE_PROTECTED (x);\n-\t    }\n+    append_signature_fields (t);\n \n-\t  /* A name N used in a class S shall refer to the same declaration\n-\t     in its context and when re-evaluated in the completed scope of S.\n+  /* Now that we've got all the field declarations, reverse everything\n+     as necessary.  */\n+  unreverse_member_declarations (t);\n \n-             Enums, types and static vars have already been checked.  */\n-\t  if (TREE_CODE (x) != TYPE_DECL && TREE_CODE (x) != USING_DECL\n-\t      && ! (TREE_CODE (x) == TEMPLATE_DECL\n-\t\t    && TREE_CODE (DECL_RESULT (x)) == TYPE_DECL)\n-\t      && TREE_CODE (x) != CONST_DECL && TREE_CODE (x) != VAR_DECL)\n-\t    {\n-\t      tree name = DECL_NAME (x);\n-\t      tree icv;\n-\n-\t      /* Don't get confused by access decls.  */\n-\t      if (name && TREE_CODE (name) == IDENTIFIER_NODE)\n-\t\ticv = IDENTIFIER_CLASS_VALUE (name);\n-\t      else\n-\t\ticv = NULL_TREE;\n-\n-\t      if (icv\n-\t\t  && flag_optional_diags\n-\t\t  /* Don't complain about constructors.  */\n-\t\t  && name != constructor_name (current_class_type)\n-\t\t  /* Or inherited names.  */\n-\t\t  && id_in_current_class (name)\n-\t\t  /* Or shadowed tags.  */\n-\t\t  && !(TREE_CODE (icv) == TYPE_DECL\n-\t\t       && DECL_CONTEXT (icv) == t))\n-\t\t{\n-\t\t  cp_pedwarn_at (\"declaration of identifier `%D' as `%+#D'\",\n-\t\t\t\t name, x);\n-\t\t  cp_pedwarn_at (\"conflicts with other use in class as `%#D'\",\n-\t\t\t\t icv);\n-\t\t}\n-\t    }\n-\n-\t  if (TREE_CODE (x) == FUNCTION_DECL \n-\t      || DECL_FUNCTION_TEMPLATE_P (x))\n-\t    {\n-\t      DECL_CLASS_CONTEXT (x) = t;\n-\n-\t      if (last_x)\n-\t\tTREE_CHAIN (last_x) = next_x;\n-\n-\t      /* Link x onto end of TYPE_METHODS.  */\n-\t      *tail = x;\n-\t      tail = &TREE_CHAIN (x);\n-\t      continue;\n-\t    }\n-\n-\t  if (TREE_CODE (x) != TYPE_DECL)\n-\t    DECL_FIELD_CONTEXT (x) = t;\n-\n-\t  if (! fields)\n-\t    fields = x;\n-\t  last_x = x;\n-\t}\n-      list_of_fieldlists = TREE_CHAIN (list_of_fieldlists);\n-      /* link the tail while we have it! */\n-      if (last_x)\n-\t{\n-\t  TREE_CHAIN (last_x) = NULL_TREE;\n-\n-\t  if (list_of_fieldlists\n-\t      && TREE_VALUE (list_of_fieldlists)\n-\t      && TREE_CODE (TREE_VALUE (list_of_fieldlists)) != FUNCTION_DECL)\n-\t    TREE_CHAIN (last_x) = TREE_VALUE (list_of_fieldlists);\n-\t}\n-    }\n-\n-  /* Now add the tags, if any, to the list of TYPE_DECLs\n-     defined for this type.  */\n-  if (CLASSTYPE_TAGS (t) || dummy)\n+  if (flag_optional_diags) \n     {\n-      /* The list of tags was built up in pushtag in reverse order; we need\n-\t to fix that so that enumerators will be processed in forward order\n-\t in template instantiation.  */\n-      CLASSTYPE_TAGS (t) = x = nreverse (CLASSTYPE_TAGS (t));\n-      while (x)\n-\t{\n-\t  tree tag_type = TREE_VALUE (x);\n-\t  tree tag = TYPE_MAIN_DECL (TREE_VALUE (x));\n-\n-\t  if (IS_AGGR_TYPE_CODE (TREE_CODE (tag_type))\n-\t      && CLASSTYPE_IS_TEMPLATE (tag_type))\n-\t    tag = CLASSTYPE_TI_TEMPLATE (tag_type);\n-\n-\t  TREE_NONLOCAL_FLAG (tag_type) = 0;\n-\t  x = TREE_CHAIN (x);\n-\t  last_x = chainon (last_x, tag);\n-\t}\n-      if (dummy)\n-\tlast_x = chainon (last_x, dummy);\n-      if (fields == NULL_TREE)\n-\tfields = last_x;\n-      CLASSTYPE_LOCAL_TYPEDECLS (t) = 1;\n+      for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n+\tcheck_member_decl_is_same_in_complete_scope (t, x);\n+      for (x = TYPE_FIELDS (t); x; x = TREE_CHAIN (x))\n+\tcheck_member_decl_is_same_in_complete_scope (t, x);\n     }\n \n-  *tail = NULL_TREE;\n-  TYPE_FIELDS (t) = fields;\n+  /* Mark all the tags in the class as class-local.  */\n+  for (x = CLASSTYPE_TAGS (t); x; x = TREE_CHAIN (x))\n+    TREE_NONLOCAL_FLAG (TREE_VALUE (x)) = 0;\n \n   cplus_decl_attributes (t, attributes, NULL_TREE);\n \n@@ -4574,9 +4567,10 @@ void\n init_class_processing ()\n {\n   current_class_depth = 0;\n-  current_class_stacksize = 10;\n-  current_class_base = (tree *)xmalloc(current_class_stacksize * sizeof (tree));\n-  current_class_stack = current_class_base;\n+  current_class_stack_size = 10;\n+  current_class_stack \n+    = (class_stack_node_t) xmalloc (current_class_stack_size \n+\t\t\t\t    * sizeof (struct class_stack_node));\n \n   current_lang_stacksize = 10;\n   current_lang_base = (tree *)xmalloc(current_lang_stacksize * sizeof (tree));\n@@ -4639,23 +4633,34 @@ pushclass (type, modify)\n {\n   type = TYPE_MAIN_VARIANT (type);\n \n-  current_class_depth++;\n-  *current_class_stack++ = current_class_name;\n-  *current_class_stack++ = current_class_type;\n-  if (current_class_stack >= current_class_base + current_class_stacksize)\n-    {\n-      current_class_base\n-\t= (tree *)xrealloc (current_class_base,\n-\t\t\t    sizeof (tree) * (current_class_stacksize + 10));\n-      current_class_stack = current_class_base + current_class_stacksize;\n-      current_class_stacksize += 10;\n+  /* Make sure there is enough room for the new entry on the stack.  */\n+  if (current_class_depth + 1 >= current_class_stack_size) \n+    {\n+      current_class_stack_size *= 2;\n+      current_class_stack\n+\t= (class_stack_node_t) xrealloc (current_class_stack,\n+\t\t\t\t\t current_class_stack_size\n+\t\t\t\t\t * sizeof (struct class_stack_node));\n     }\n \n+  /* Insert a new entry on the class stack.  */\n+  current_class_stack[current_class_depth].name = current_class_name;\n+  current_class_stack[current_class_depth].type = current_class_type;\n+  current_class_stack[current_class_depth].access = current_access_specifier;\n+  current_class_depth++;\n+\n+  /* Now set up the new type.  */\n   current_class_name = TYPE_NAME (type);\n   if (TREE_CODE (current_class_name) == TYPE_DECL)\n     current_class_name = DECL_NAME (current_class_name);\n   current_class_type = type;\n \n+  /* By default, things in classes are private, while things in\n+     structures or unions are public.  */\n+  current_access_specifier = (CLASSTYPE_DECLARED_CLASS (type) \n+\t\t\t      ? access_private_node \n+\t\t\t      : access_public_node);\n+\n   if (previous_class_type != NULL_TREE\n       && (type != previous_class_type || TYPE_SIZE (previous_class_type) == NULL_TREE)\n       && current_class_depth == 1)\n@@ -4783,8 +4788,9 @@ popclass (modify)\n     pop_class_decls ();\n \n   current_class_depth--;\n-  current_class_type = *--current_class_stack;\n-  current_class_name = *--current_class_stack;\n+  current_class_name = current_class_stack[current_class_depth].name;\n+  current_class_type = current_class_stack[current_class_depth].type;\n+  current_access_specifier = current_class_stack[current_class_depth].access;\n \n  ret:\n   ;\n@@ -4800,7 +4806,7 @@ currently_open_class (t)\n   if (t == current_class_type)\n     return 1;\n   for (i = 0; i < current_class_depth; ++i)\n-    if (current_class_stack [-i*2 - 1] == t)\n+    if (current_class_stack [i].type == t)\n       return 1;\n   return 0;\n }\n@@ -5505,7 +5511,6 @@ build_self_reference ()\n   DECL_NONLOCAL (value) = 1;\n   DECL_CONTEXT (value) = current_class_type;\n   DECL_CLASS_CONTEXT (value) = current_class_type;\n-  CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n   DECL_ARTIFICIAL (value) = 1;\n \n   pushdecl_class_level (value);"}, {"sha": "20a0117c160121d730d573757219556b80eec34b", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -29,6 +29,11 @@ Boston, MA 02111-1307, USA.  */\n    just won't work for us.  */\n DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n \n+/* A pointer-to-member constant.  For a pointer-to-member constant\n+   `X::Y' The PTRMEM_CST_CLASS is the RECORD_TYPE for `X' and the\n+   PTRMEM_CST_MEMBER is the _DECL for `Y'.  */\n+DEFTREECODE (PTRMEM_CST, \"ptrmem_cst\", 'c', 1)\n+\n /* For NEW_EXPR, operand 0 is the placement list.\n    Operand 1 is the new-declarator.\n    Operand 2 is the initializer.  */"}, {"sha": "bef5e0e8bbdb24ba45fa68ec303cd65744d81e88", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 43, "deletions": 16, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -109,6 +109,12 @@ typedef struct\n   tree decl;\n } template_parm_index;\n \n+typedef struct ptrmem_cst\n+{\n+  char common[sizeof (struct tree_common)];\n+  tree member;\n+}* ptrmem_cst_t;\n+\n /* For a binding between a name and an entity, defines the scope\n    where the binding is declared. Currently always points to a\n    namespace declaration.  */\n@@ -586,7 +592,6 @@ struct lang_type\n       unsigned has_call_overloaded : 1;\n       unsigned has_array_ref_overloaded : 1;\n       unsigned has_arrow_overloaded : 1;\n-      unsigned local_typedecls : 1;\n       unsigned interface_only : 1;\n       unsigned interface_unknown : 1;\n \n@@ -625,7 +630,7 @@ struct lang_type\n       /* The MIPS compiler gets it wrong if this struct also\n \t does not fill out to a multiple of 4 bytes.  Add a\n \t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 11;\n+      unsigned dummy : 12;\n     } type_flags;\n \n   int n_ancestors;\n@@ -786,7 +791,12 @@ struct lang_type\n    hierarchy, then we can use more efficient search techniques.  */\n #define TYPE_USES_VIRTUAL_BASECLASSES(NODE) (TREE_LANG_FLAG_3(NODE))\n \n-/* List of lists of member functions defined in this class.  */\n+/* Vector member functions defined in this class.  Each element is\n+   either a FUNCTION_DECL, a TEMPLATE_DECL, or an OVERLOAD.  The first\n+   two elements are for constructors, and destructors, respectively.\n+   Any user-defined conversion operators follow these.  These are\n+   followed by ordinary member functions.  There may be empty entries\n+   at the end of the vector.  */\n #define CLASSTYPE_METHOD_VEC(NODE) (TYPE_LANG_SPECIFIC(NODE)->methods)\n \n /* The first type conversion operator in the class (the others can be\n@@ -900,9 +910,6 @@ struct lang_type\n    the virtual function table will be written out.  */\n #define CLASSTYPE_VTABLE_NEEDS_WRITING(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.vtable_needs_writing)\n \n-/* Nonzero means that this type defines its own local type declarations.  */\n-#define CLASSTYPE_LOCAL_TYPEDECLS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.local_typedecls)\n-\n /* Nonzero means that this type has an X() constructor.  */\n #define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_ctor)\n \n@@ -1508,6 +1515,17 @@ extern int flag_new_for_scope;\n #define DELTA2_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), delta2_identifier, NULL_TREE, 0))\n #define PFN_FROM_PTRMEMFUNC(NODE) (build_component_ref (build_component_ref ((NODE), pfn_or_delta2_identifier, NULL_TREE, 0), pfn_identifier, NULL_TREE, 0))\n \n+/* For a pointer-to-member constant `X::Y' this is the RECORD_TYPE for\n+   `X'.  */\n+#define PTRMEM_CST_CLASS(NODE)\t\t\t\t\\\n+   (TYPE_PTRMEM_P (TREE_TYPE (NODE)) \t\t\t\\\n+    ? TYPE_OFFSET_BASETYPE (TREE_TYPE (NODE))\t\t\\\n+    : TYPE_PTRMEMFUNC_OBJECT_TYPE (TREE_TYPE (NODE)))\n+\n+/* For a pointer-to-member constant `X::Y' this is the _DECL for \n+   `Y'.  */\n+#define PTRMEM_CST_MEMBER(NODE) (((ptrmem_cst_t) NODE)->member)\n+\n /* Nonzero for VAR_DECL and FUNCTION_DECL node means that `extern' was\n    specified in its declaration.  */\n #define DECL_THIS_EXTERN(NODE) (DECL_LANG_FLAG_2(NODE))\n@@ -1853,6 +1871,7 @@ extern void constant_expression_warning         PROTO((tree));\n extern tree convert_and_check\t\t\tPROTO((tree, tree));\n extern void overflow_warning\t\t\tPROTO((tree));\n extern void unsigned_conversion_warning\t\tPROTO((tree, tree));\n+\n /* Read the rest of the current #-directive line.  */\n #if USE_CPPLIB\n extern char *get_directive_line                 PROTO((void));\n@@ -1957,6 +1976,13 @@ extern int minimal_parse_mode;\n extern void maybe_print_template_context\tPROTO ((void));\n \n /* in class.c */\n+\n+/* When parsing a class definition, the access specifier most recently\n+   given by the user, or, if no access specifier was given, the\n+   default value appropriate for the kind of class (i.e., struct,\n+   class, or union).  */\n+extern tree current_access_specifier;\n+\n extern tree current_class_name;\n extern tree current_class_type;\n extern tree current_class_ptr;\n@@ -2257,7 +2283,6 @@ enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n /* The following two can be derived from the previous one */\n extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n-extern tree current_class_type;\t/* _TYPE: the type of the current class */\n \n /* Some macros for char-based bitfields.  */\n #define B_SET(a,x) (a[x>>3] |= (1 << (x&7)))\n@@ -2414,7 +2439,7 @@ extern void add_method\t\t\t\tPROTO((tree, tree *, tree));\n extern int currently_open_class\t\t\tPROTO((tree));\n extern tree get_vfield_offset\t\t\tPROTO((tree));\n extern void duplicate_tag_error\t\t\tPROTO((tree));\n-extern tree finish_struct\t\t\tPROTO((tree, tree, tree, int));\n+extern tree finish_struct\t\t\tPROTO((tree, tree, int));\n extern tree finish_struct_1\t\t\tPROTO((tree, int));\n extern int resolves_to_fixed_type_p\t\tPROTO((tree, int *));\n extern void init_class_processing\t\tPROTO((void));\n@@ -2433,6 +2458,7 @@ extern tree build_self_reference\t\tPROTO((void));\n extern void warn_hidden\t\t\t\tPROTO((tree));\n extern tree get_enclosing_class\t\t\tPROTO((tree));\n int is_base_of_enclosing_class\t\t\tPROTO((tree, tree));\n+extern void unreverse_member_declarations       PROTO((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -2488,7 +2514,7 @@ extern int decls_match\t\t\t\tPROTO((tree, tree));\n extern int duplicate_decls\t\t\tPROTO((tree, tree));\n extern tree pushdecl\t\t\t\tPROTO((tree));\n extern tree pushdecl_top_level\t\t\tPROTO((tree));\n-extern tree pushdecl_class_level\t\tPROTO((tree));\n+extern void pushdecl_class_level\t\tPROTO((tree));\n #if 0\n extern void pushdecl_nonclass_level\t\tPROTO((tree));\n #endif\n@@ -2551,7 +2577,6 @@ extern void xref_basetypes\t\t\tPROTO((tree, tree, tree, tree));\n extern tree start_enum\t\t\t\tPROTO((tree));\n extern tree finish_enum\t\t\t\tPROTO((tree));\n extern tree build_enumerator\t\t\tPROTO((tree, tree, tree));\n-extern tree grok_enum_decls\t\t\tPROTO((tree));\n extern int start_function\t\t\tPROTO((tree, tree, tree, int));\n extern void expand_start_early_try_stmts\tPROTO((void));\n extern void store_parm_decls\t\t\tPROTO((void));\n@@ -2572,13 +2597,14 @@ extern void replace_defarg\t\t\tPROTO((tree, tree));\n extern void print_other_binding_stack\t\tPROTO((struct binding_level *));\n extern void revert_static_member_fn             PROTO((tree*, tree*, tree*));\n extern void cat_namespace_levels                PROTO((void));\n+extern void fixup_anonymous_union               PROTO((tree));\n \n /* in decl2.c */\n extern int check_java_method\t\t\tPROTO((tree));\n extern int lang_decode_option\t\t\tPROTO((int, char **));\n extern tree grok_method_quals\t\t\tPROTO((tree, tree, tree));\n extern void warn_if_unknown_interface\t\tPROTO((tree));\n-extern tree grok_x_components\t\t\tPROTO((tree, tree));\n+extern void grok_x_components\t\t\tPROTO((tree));\n extern void maybe_retrofit_in_chrg\t\tPROTO((tree));\n extern void maybe_make_one_only\t\t\tPROTO((tree));\n extern void grokclassfn\t\t\t\tPROTO((tree, tree, enum overload_flags, tree));\n@@ -2787,18 +2813,17 @@ extern tree innermost_args\t\t\tPROTO ((tree));\n extern tree tsubst\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_expr\t\t\t\tPROTO ((tree, tree, tree));\n extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, tree));\n-extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n extern void maybe_begin_member_template_processing PROTO((tree));\n extern void maybe_end_member_template_processing PROTO((void));\n-extern tree finish_member_template_decl         PROTO((tree, tree));\n+extern tree finish_member_template_decl         PROTO((tree));\n extern void begin_template_parm_list\t\tPROTO((void));\n extern void begin_specialization                PROTO((void));\n extern void reset_specialization                PROTO((void));\n extern void end_specialization                  PROTO((void));\n extern void begin_explicit_instantiation        PROTO((void));\n extern void end_explicit_instantiation          PROTO((void));\n extern tree determine_specialization            PROTO((tree, tree, tree *, int, int));\n-extern tree check_explicit_specialization        PROTO((tree, tree, int, int));\n+extern tree check_explicit_specialization       PROTO((tree, tree, int, int));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n@@ -2950,14 +2975,16 @@ extern tree finish_template_type_parm           PROTO((tree, tree));\n extern tree finish_template_template_parm       PROTO((tree, tree));\n extern tree finish_parmlist                     PROTO((tree, int));\n extern tree begin_class_definition              PROTO((tree));\n-extern tree finish_class_definition             PROTO((tree, tree, tree, int));\n+extern tree finish_class_definition             PROTO((tree, tree, int));\n extern void finish_default_args                 PROTO((void));\n extern void begin_inline_definitions            PROTO((void));\n-extern tree finish_member_class_template        PROTO((tree, tree));\n+extern tree finish_member_class_template        PROTO((tree));\n extern void finish_template_decl                PROTO((tree));\n extern tree finish_template_type                PROTO((tree, tree, int));\n extern void enter_scope_of                      PROTO((tree));\n extern tree finish_base_specifier               PROTO((tree, tree, int));\n+extern void finish_member_declaration           PROTO((tree));\n+extern void check_multiple_declarators          PROTO((void));\n \n /* in sig.c */\n extern tree build_signature_pointer_type\tPROTO((tree));"}, {"sha": "19cbcf529c2ec978772a14f7c224e91457bb8453", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 84, "deletions": 80, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1896,7 +1896,9 @@ struct saved_scope {\n   tree old_bindings;\n   tree old_namespace;\n   struct saved_scope *prev;\n-  tree class_name, class_type, function_decl;\n+  tree class_name, class_type;\n+  tree access_specifier;\n+  tree function_decl;\n   struct binding_level *class_bindings;\n   tree *lang_base, *lang_stack, lang_name;\n   int lang_stacksize;\n@@ -2010,6 +2012,7 @@ maybe_push_to_top_level (pseudo)\n   s->old_namespace = current_namespace;\n   s->class_name = current_class_name;\n   s->class_type = current_class_type;\n+  s->access_specifier = current_access_specifier;\n   s->function_decl = current_function_decl;\n   s->class_bindings = class_binding_level;\n   s->lang_stack = current_lang_stack;\n@@ -2091,6 +2094,7 @@ pop_from_top_level ()\n   current_namespace = s->old_namespace;\n   current_class_name = s->class_name;\n   current_class_type = s->class_type;\n+  current_access_specifier = s->access_specifier;\n   current_function_decl = s->function_decl;\n   class_binding_level = s->class_bindings;\n   free (current_lang_base);\n@@ -2297,6 +2301,7 @@ maybe_process_template_type_declaration (type, globalize, b)\n \t    {\n \t      pushdecl_with_scope (CLASSTYPE_TI_TEMPLATE (type),\n \t\t\t\t   b->level_chain);\n+\t      finish_member_declaration (CLASSTYPE_TI_TEMPLATE (type));\n \t      /* Put this tag on the list of tags for the class, since\n \t\t that won't happen below because B is not the class\n \t\t binding level, but is instead the pseudo-global level.  */\n@@ -2391,7 +2396,15 @@ pushtag (name, type, globalize)\n \t\t\t\t\t\t       globalize, b);\n \n \t  if (b->parm_flag == 2)\n-\t    d = pushdecl_class_level (d);\n+\t    {\n+\t      pushdecl_class_level (d);\n+\t      if (newdecl && !PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t/* Put this TYPE_DECL on the TYPE_FIELDS list for the\n+\t\t   class.  But if it's a member template class, we\n+\t\t   want the TEMPLATE_DECL, not the TYPE_DECL, so this\n+\t\t   is done later.  */\n+\t\tfinish_member_declaration (d);\n+\t    }\n \t  else\n \t    d = pushdecl_with_scope (d, b);\n \n@@ -3788,7 +3801,7 @@ pushdecl_top_level (x)\n \n /* Make the declaration of X appear in CLASS scope.  */\n \n-tree\n+void\n pushdecl_class_level (x)\n      tree x;\n {\n@@ -3839,7 +3852,6 @@ pushdecl_class_level (x)\n \t  set_identifier_type_value (name, TREE_TYPE (x));\n \t}\n     }\n-  return x;\n }\n \n #if 0\n@@ -6291,6 +6303,48 @@ define_function (name, type, function_code, pfn, library_name)\n   return decl;\n }\n \f\n+/* When we call finish_struct for an anonymous union, we create\n+   default copy constructors and such.  But, an anonymous union\n+   shouldn't have such things; this function undoes the damage to the\n+   anonymous union type T.\n+\n+   (The reason that we create the synthesized methods is that we don't\n+   distinguish `union { int i; }' from `typedef union { int i; } U'.\n+   The first is an anonymous union; the second is just an ordinary\n+   union type.)  */\n+\n+void\n+fixup_anonymous_union (t)\n+     tree t;\n+{\n+  tree *q;\n+\n+  /* Wipe out memory of synthesized methods */\n+  TYPE_HAS_CONSTRUCTOR (t) = 0;\n+  TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n+  TYPE_HAS_INIT_REF (t) = 0;\n+  TYPE_HAS_CONST_INIT_REF (t) = 0;\n+  TYPE_HAS_ASSIGN_REF (t) = 0;\n+  TYPE_HAS_ASSIGNMENT (t) = 0;\n+  TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n+\n+  /* Splice the implicitly generated functions out of the TYPE_METHODS\n+     list.  */\n+  q = &TYPE_METHODS (t);\n+  while (*q)\n+    {\n+      if (DECL_ARTIFICIAL (*q))\n+\t*q = TREE_CHAIN (*q);\n+      else\n+\tq = &TREE_CHAIN (*q);\n+    }\n+\n+  /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n+     function members.  */\n+  if (TYPE_METHODS (t))\n+    error (\"an anonymous union cannot have function members\");\n+}\n+\n /* Called when a declaration is seen that contains no names to declare.\n    If its type is a reference to a structure, union or enum inherited\n    from a containing scope, shadow that tag name for the current scope\n@@ -6349,31 +6403,7 @@ shadow_tag (declspecs)\n \t  || (TREE_CODE (TYPE_NAME (t)) == TYPE_DECL\n \t      && ANON_AGGRNAME_P (TYPE_IDENTIFIER (t)))))\n     {\n-      /* See also grok_x_components.  */\n-      tree *q;\n-\n-      /* Wipe out memory of synthesized methods */\n-      TYPE_HAS_CONSTRUCTOR (t) = 0;\n-      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n-      TYPE_HAS_INIT_REF (t) = 0;\n-      TYPE_HAS_CONST_INIT_REF (t) = 0;\n-      TYPE_HAS_ASSIGN_REF (t) = 0;\n-      TYPE_HAS_ASSIGNMENT (t) = 0;\n-      TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n-\n-      q = &TYPE_METHODS (t);\n-      while (*q)\n-\t{\n-\t  if (DECL_ARTIFICIAL (*q))\n-\t    *q = TREE_CHAIN (*q);\n-\t  else\n-\t    q = &TREE_CHAIN (*q);\n-\t}\n-\n-      /* ANSI C++ June 5 1992 WP 9.5.3.  Anonymous unions may not have\n-\t function members.  */\n-      if (TYPE_METHODS (t))\n-\terror (\"an anonymous union cannot have function members\");\n+      fixup_anonymous_union (t);\n \n       if (TYPE_FIELDS (t))\n \t{\n@@ -9714,6 +9744,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      type = TREE_TYPE (type);\n \t    }\n \n+\t  /* Merge any constancy or volatility into the target type\n+\t     for the pointer.  */\n+\n \t  /* We now know that constp and volatilep don't apply to the\n \t     decl, but to the target of the pointer.  */\n \t  constp = volatilep = 0;\n@@ -10040,6 +10073,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t  && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL\n \t  && ANON_AGGRNAME_P (TYPE_IDENTIFIER (type)))\n \t{\n+\t  /* FIXME: This is bogus; we should not be doing this for\n+\t            cv-qualified types.  */\n+\n \t  /* For anonymous structs that are cv-qualified, need to use\n              TYPE_MAIN_VARIANT so that name will mangle correctly. As\n              type not referenced after this block, don't bother\n@@ -10094,9 +10130,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \tC_TYPEDEF_EXPLICITLY_SIGNED (decl) = 1;\n \n       if (RIDBIT_SETP (RID_MUTABLE, specbits))\n-\t{\n-\t  error (\"non-object member `%s' cannot be declared mutable\", name);\n-\t}\n+\terror (\"non-object member `%s' cannot be declared mutable\", name);\n \n       bad_specifiers (decl, \"type\", virtualp, quals != NULL_TREE,\n \t\t      inlinep, friendp, raises != NULL_TREE);\n@@ -11477,6 +11511,7 @@ xref_tag (code_type_node, name, globalize)\n     }\n   else\n     t = IDENTIFIER_TYPE_VALUE (name);\n+\n   if (t && TREE_CODE (t) != code && TREE_CODE (t) != TEMPLATE_TYPE_PARM\n       && TREE_CODE (t) != TEMPLATE_TEMPLATE_PARM)\n     t = NULL_TREE;\n@@ -11651,6 +11686,19 @@ xref_tag (code_type_node, name, globalize)\n \n   TREE_TYPE (ref) = attributes;\n \n+  if (ref && TYPE_P (ref))\n+    {\n+      /* [dcl.type.elab]\n+\t     \n+\t If the identifier resolves to a typedef-name or a template\n+\t type-parameter, the elaborated-type-specifier is\n+\t ill-formed.  */\n+      if (TYPE_LANG_SPECIFIC (ref) && TYPE_WAS_ANONYMOUS (ref))\n+\tcp_error (\"`%T' is a typedef name\", ref);\n+      else if (TREE_CODE (ref) == TEMPLATE_TYPE_PARM)\n+\tcp_error (\"`%T' is a template type paramter\", ref);\n+    }\n+\n   return ref;\n }\n \n@@ -11791,7 +11839,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n \n \t  TYPE_GETS_NEW (ref) |= TYPE_GETS_NEW (basetype);\n \t  TYPE_GETS_DELETE (ref) |= TYPE_GETS_DELETE (basetype);\n-\t  CLASSTYPE_LOCAL_TYPEDECLS (ref) |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n \t  i += 1;\n \t}\n     }\n@@ -11817,8 +11864,6 @@ xref_basetypes (code_type_node, name, ref, binfo)\n }\n   \n \f\n-tree current_local_enum = NULL_TREE;\n-\n /* Begin compiling the definition of an enumeration type.\n    NAME is its name (or null if anonymous).\n    Returns the type object, as yet incomplete.\n@@ -11858,8 +11903,6 @@ start_enum (name)\n   if (current_class_type)\n     TREE_ADDRESSABLE (b->tags) = 1;\n \n-  current_local_enum = NULL_TREE;\n-\n   /* We don't copy this value because build_enumerator needs to do it.  */\n   enum_next_value = integer_zero_node;\n   enum_overflow = 0;\n@@ -12079,8 +12122,10 @@ build_enumerator (name, value, type)\n  if (context && context == current_class_type)\n    {\n      pushdecl_class_level (decl);\n-     TREE_CHAIN (decl) = current_local_enum;\n-     current_local_enum = decl;\n+     /* In something like `struct S { enum E { i = 7 }; };' we put `i'\n+\ton the TYPE_FIELDS list for `S'.  (That's so that you can say\n+\tthings like `S::i' later.)  */\n+     finish_member_declaration (decl);\n    }\n  else\n    {\n@@ -12100,47 +12145,6 @@ build_enumerator (name, value, type)\n   return result;\n }\n \n-/* Called after we have finished the declaration of an enumeration\n-   type, and, perhaps, some objects whose type involves the\n-   enumeration type.  DECL, if non-NULL, is the declaration of the\n-   first such object.  \n-\n-   If CURRENT_LOCAL_ENUM is NULL, the DECL is returned. \n-\n-   If CURRENT_LOCAL_ENUM is non-NULL, it should be the CONST_DECL for\n-   the last enumeration constant of an enumeration type that is a\n-   member of a class.  The enumeration constants are already chained\n-   together through their TREE_CHAIN fields.  This function sets the\n-   TREE_CHAIN of the last enumeration constant to DECL.  The\n-   CONST_DECL for the last enumeration constant is returned.  \n-\n-   CURRENT_LOCAL_ENUM will always be NULL when this function \n-   returns.  */\n-\n-tree\n-grok_enum_decls (decl)\n-     tree decl;\n-{\n-  tree d = current_local_enum;\n-  \n-  if (d == NULL_TREE)\n-    return decl;\n-  \n-  while (1)\n-    {\n-      if (TREE_CHAIN (d) == NULL_TREE)\n-\t{\n-\t  TREE_CHAIN (d) = decl;\n-\t  break;\n-\t}\n-      d = TREE_CHAIN (d);\n-    }\n-\n-  decl = current_local_enum;\n-  current_local_enum = NULL_TREE;\n-  \n-  return decl;\n-}\n \f\n static int function_depth;\n "}, {"sha": "f70867a9e5a12e0560f9d41adb7e103a6ce3c8af", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 36, "deletions": 122, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -860,123 +860,37 @@ warn_if_unknown_interface (decl)\n \n /* A subroutine of the parser, to handle a component list.  */\n \n-tree\n-grok_x_components (specs, components)\n-     tree specs, components;\n+void\n+grok_x_components (specs)\n+     tree specs;\n {\n-  register tree t, x, tcode;\n-\n-  /* We just got some friends.  They have been recorded elsewhere.  */\n-  if (components == void_type_node)\n-    return NULL_TREE;\n+  struct pending_inline **p;\n+  tree t;\n \n-  if (components == NULL_TREE)\n+  t = groktypename (build_decl_list (strip_attrs (specs), NULL_TREE)); \n+  \n+  if (t == NULL_TREE)\n     {\n-      t = groktypename (build_decl_list (strip_attrs (specs),\n-\t\t\t\t\t NULL_TREE)); \n-\n-      if (t == NULL_TREE)\n-\t{\n-\t  error (\"error in component specification\");\n-\t  return NULL_TREE;\n-\t}\n-\n-      switch (TREE_CODE (t))\n-\t{\n-\tcase VAR_DECL:\n-\t  /* Static anonymous unions come out as VAR_DECLs.  */\n-\t  if (ANON_UNION_TYPE_P (TREE_TYPE (t)))\n-\t    return t;\n-\n-\t  /* We return SPECS here, because in the parser it was ending\n-\t     up with not doing anything to $$, which is what SPECS\n-\t     represents.  */\n-\t  return specs;\n-\t  break;\n-\n-\tcase RECORD_TYPE:\n-\tcase UNION_TYPE:\n-\t  if (TREE_CODE (t) == UNION_TYPE)\n-\t    tcode = union_type_node;\n-\t  else\n-\t    tcode = record_type_node;\n-\t  if (CLASSTYPE_DECLARED_CLASS (t))\n-\t    tcode = class_type_node;\n-\t  else if (IS_SIGNATURE (t))\n-\t    tcode = signature_type_node;\n-\t  \n-\t  if (TYPE_LANG_SPECIFIC (t) \n-\t      && CLASSTYPE_USE_TEMPLATE (t))\n-\t    /* We have already looked up this type.  */\n-\t    ;\n-\t  else\n-\t    {\n-\t      if (CLASSTYPE_IS_TEMPLATE (t))\n-\t\tx = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n-\t      else\n-\t\tx = TYPE_IDENTIFIER (t);\n-\t      t = xref_tag (tcode, x, 0);\n-\t    }\n-\n-\t  if (ANON_UNION_TYPE_P (t))\n-\t    {\n-\t      /* See also shadow_tag.  */\n-\n-\t      struct pending_inline **p;\n-\t      tree *q;\n-\t      x = build_lang_field_decl (FIELD_DECL, NULL_TREE, t);\n-\n-\t      /* Wipe out memory of synthesized methods */\n-\t      TYPE_HAS_CONSTRUCTOR (t) = 0;\n-\t      TYPE_HAS_DEFAULT_CONSTRUCTOR (t) = 0;\n-\t      TYPE_HAS_INIT_REF (t) = 0;\n-\t      TYPE_HAS_CONST_INIT_REF (t) = 0;\n-\t      TYPE_HAS_ASSIGN_REF (t) = 0;\n-\t      TYPE_HAS_ASSIGNMENT (t) = 0;\n-\t      TYPE_HAS_CONST_ASSIGN_REF (t) = 0;\n-\n-\t      q = &TYPE_METHODS (t);\n-\t      while (*q)\n-\t\t{\n-\t\t  if (DECL_ARTIFICIAL (*q))\n-\t\t    *q = TREE_CHAIN (*q);\n-\t\t  else\n-\t\t    q = &TREE_CHAIN (*q);\n-\t\t}\n-\t      if (TYPE_METHODS (t))\n-\t\terror (\"an anonymous union cannot have function members\");\n-\n-\t      p = &pending_inlines;\n-\t      for (; *p; *p = (*p)->next)\n-\t\tif (DECL_CONTEXT ((*p)->fndecl) != t)\n-\t\t  break;\n-\n-\t      return x;\n-\t    }\n-\n-\t  return NULL_TREE;\n-\t  break;\n+      cp_error (\"invalid member declaration\");\n+      return;\n+    }\n \n-\tcase ENUMERAL_TYPE:\n-\t  tcode = enum_type_node;\n-\t  t = xref_tag (tcode, TYPE_IDENTIFIER (t), 0);\n-\t  x = grok_enum_decls (NULL_TREE);\n-\t  return x;\n-\t  break;\n+  /* The only case where we need to do anything additional here is an\n+     anonymous union field, e.g.: `struct S { union { int i; }; };'.  */\n+  if (!ANON_UNION_TYPE_P (t))\n+    return;\n \n-\tdefault:\n-\t  if (t != void_type_node)\n-\t    error (\"empty component declaration\");\n-\t  return NULL_TREE;\n-\t}\n-    }\n-  else\n-    /* There may or may not be any enum decls to grok, but\n-       grok_enum_decls will just return components, if there aren't\n-       any.  We used to try to figure out whether or not there were\n-       any enum decls based on the type of components, but that's too\n-       hard; it might be something like `enum { a } *p;'.  */\n-    return grok_enum_decls (components);\n+  fixup_anonymous_union (t);\n+  finish_member_declaration (build_lang_field_decl (FIELD_DECL,\n+\t\t\t\t\t\t    NULL_TREE,\n+\t\t\t\t\t\t    t)); \n+\n+  /* Ignore any inline function definitions in the anonymous union\n+     since an anonymous union may not have function members.  */\n+  p = &pending_inlines;\n+  for (; *p; *p = (*p)->next)\n+    if (DECL_CONTEXT ((*p)->fndecl) != t)\n+      break;\n }\n \n /* Constructors for types with virtual baseclasses need an \"in-charge\" flag\n@@ -1459,7 +1373,7 @@ check_classfn (ctype, function)\n \t  && DESTRUCTOR_NAME_P (DECL_ASSEMBLER_NAME (function)))\n \tgoto got_it;\n \n-      while (++methods != end)\n+      while (++methods != end && *methods)\n \t{\n \t  fndecl = *methods;\n \t  if (fn_name == DECL_NAME (OVL_CURRENT (*methods)))\n@@ -1530,14 +1444,12 @@ check_classfn (ctype, function)\n \n   if (templates)\n     /* This function might be an instantiation or a specialization.\n-       We should verify that this is possible.  If it is, we must\n-       somehow add the new declaration to the method vector for the\n-       class.  Perhaps we should use add_method?  For now, we simply\n-       return NULL_TREE, which lets the caller know that this\n-       function is new, but we don't print an error message.  */\n+       We should verify that this is possible.  For now, we simply\n+       return NULL_TREE, which lets the caller know that this function\n+       is new, but we don't print an error message.  */\n     return NULL_TREE;\n \n-  if (methods != end)\n+  if (methods != end && *methods)\n     {\n       tree fndecl = *methods;\n       cp_error (\"prototype for `%#D' does not match any in class `%T'\",\n@@ -1640,7 +1552,6 @@ grokfield (declarator, declspecs, init, asmspec_tree, attrlist)\n       DECL_NONLOCAL (value) = 1;\n       DECL_CONTEXT (value) = current_class_type;\n       DECL_CLASS_CONTEXT (value) = current_class_type;\n-      CLASSTYPE_LOCAL_TYPEDECLS (current_class_type) = 1;\n \n       /* Now that we've updated the context, we need to remangle the\n \t name for this TYPE_DECL.  */\n@@ -4129,7 +4040,9 @@ add_using_namespace (user, used, indirect)\n /* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n    duplicates.  The first list becomes the tail of the result.\n \n-   The algorithm is O(n^2).  */\n+   The algorithm is O(n^2).  We could get this down to O(n log n) by\n+   doing a sort on the addresses of the functions, if that becomes\n+   necessary.  */\n \n static tree\n merge_functions (s1, s2)\n@@ -4414,6 +4327,7 @@ struct arg_lookup\n \n static int arg_assoc         PROTO((struct arg_lookup*, tree));\n static int arg_assoc_args    PROTO((struct arg_lookup*, tree));\n+static int arg_assoc_type    PROTO((struct arg_lookup*, tree));\n \n /* Add a function to the lookup structure.\n    Returns 1 on error.  */\n@@ -4662,7 +4576,7 @@ arg_assoc (k, n)\n \t\treturn 1;\n \t    }\n \t  else if (TREE_CODE_CLASS (TREE_CODE (t)) == 't'\n-\t\t   && arg_assoc_type (t) == 1)\n+\t\t   && arg_assoc_type (k, t) == 1)\n \t    return 1;\n \t}\n     }"}, {"sha": "52c519d692a13cad2e3012d471bc5abf76899c3a", "filename": "gcc/cp/error.c", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1265,6 +1265,13 @@ dump_expr (t, nop)\n       OB_PUTCP (digit_buffer);\n       break;\n \n+    case PTRMEM_CST:\n+      OB_PUTC ('&');\n+      dump_type (PTRMEM_CST_CLASS (t), 0);\n+      OB_PUTS (\"::\");\n+      OB_PUTID (DECL_NAME (PTRMEM_CST_MEMBER (t)));\n+      break;\n+\n     case STRING_CST:\n       {\n \tchar *p = TREE_STRING_POINTER (t);\n@@ -1571,10 +1578,14 @@ dump_expr (t, nop)\n       {\n \ttree ob = TREE_OPERAND (t, 0);\n \tif (TREE_CODE (ob) == NOP_EXPR\n-\t    && TREE_OPERAND (ob, 0) == error_mark_node\n-\t    && TREE_CODE (TREE_OPERAND (t, 1)) == FUNCTION_DECL)\n-\t    /* A::f */\n-\t  dump_expr (TREE_OPERAND (t, 1), 0);\n+\t    && TREE_OPERAND (ob, 0) == error_mark_node)\n+\t  {\n+\t    if (TREE_CODE (TREE_OPERAND (t, 1)) == FUNCTION_DECL)\n+\t      /* A::f */\n+\t      dump_expr (TREE_OPERAND (t, 1), 0);\n+\t    else\n+\t      dump_decl (TREE_OPERAND (t, 1), 0);\n+\t  }\n \telse\n \t  {\n \t    dump_expr (TREE_OPERAND (t, 0), 0);"}, {"sha": "056f4d1f16a869c9f7e3efb9ef2bc1109225d77c", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 33, "deletions": 9, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -162,19 +162,43 @@ cplus_expand_expr (exp, target, tmode, modifier)\n \treturn DECL_RTL (slot);\n       }\n \n+    case PTRMEM_CST:\n+      {\n+\ttree member;\n+\ttree offset;\n+\t\n+\t/* Find the member.  */\n+\tmember = PTRMEM_CST_MEMBER (exp);\n+\n+\tif (TREE_CODE (member) == FIELD_DECL) \n+\t  {\n+\t    /* Find the offset for the field.  */\n+\t    offset = convert (sizetype,\n+\t\t\t      size_binop (EASY_DIV_EXPR,\n+\t\t\t\t\t  DECL_FIELD_BITPOS (member),\n+\t\t\t\t\t  size_int (BITS_PER_UNIT)));\n+\n+\t    /* We offset all pointer to data members by 1 so that we\n+\t       can distinguish between a null pointer to data member\n+\t       and the first data member of a structure.  */\n+\t    offset = size_binop (PLUS_EXPR, offset, size_int (1));\n+\t\n+\t    return expand_expr (cp_convert (type, offset), target, tmode,\n+\t\t\t\tmodifier);\n+\t  }\n+\telse\n+\t  {\n+\t    /* We don't yet handle pointer-to-member functions this\n+\t       way.  */\n+\t    my_friendly_abort (0);\n+\t    return 0;\n+\t  }\n+      }\n+\n     case OFFSET_REF:\n       {\n-#if 1\n \treturn expand_expr (default_conversion (resolve_offset_ref (exp)),\n \t\t\t    target, tmode, EXPAND_NORMAL);\n-#else\n-\t/* This is old crusty code, and does not handle all that the\n-\t   resolve_offset_ref function does.  (mrs) */\n-\ttree base = build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 0), 0);\n-\ttree offset = build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 1), 0);\n-\treturn expand_expr (build (PLUS_EXPR, TREE_TYPE (exp), base, offset),\n-\t\t\t    target, tmode, EXPAND_NORMAL);\n-#endif\n       }\n \n     case THUNK_DECL:"}, {"sha": "acb9657d666f89c3b642a1e7a06cbf96ded9f81d", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -372,21 +372,22 @@ do_friend (ctype, declarator, decl, parmdecls, flags, quals, funcdef_flag)\n \t  if (is_friend_template)\n \t    decl = DECL_TI_TEMPLATE (push_template_decl (decl));\n \n-\t  if (TYPE_SIZE (ctype) != 0 && template_class_depth (ctype) == 0)\n-\t    decl = check_classfn (ctype, decl);\n-\n-\t  /* TYPE_BEING_DEFINED is a hack for nested classes having\n-             member functions of the enclosing class as friends. Will\n-             go away as parsing of classes gets rewritten. */\n-\t  if (TREE_TYPE (decl) != error_mark_node)\n+\t  /* A nested class may declare a member of an enclosing class\n+\t     to be a friend, so we do lookup here even if CTYPE is in\n+\t     the process of being defined.  */\n+\t  if (TYPE_SIZE (ctype) != 0 || TYPE_BEING_DEFINED (ctype))\n \t    {\n-\t      if (TYPE_BEING_DEFINED (ctype) ||\n-\t\t  TYPE_SIZE (ctype) || template_class_depth (ctype) > 0)\n+\t      /* But, we defer looup in template specializations until\n+\t\t they are fully specialized.  */\n+\t      if (template_class_depth (ctype) == 0)\n+\t\tdecl = check_classfn (ctype, decl);\n+\n+\t      if (decl)\n \t\tadd_friend (current_class_type, decl);\n-\t      else\n-\t\tcp_error (\"member `%D' declared as friend before type `%T' defined\",\n-\t\t\t  decl, ctype);\n \t    }\n+\t  else\n+\t    cp_error (\"member `%D' declared as friend before type `%T' defined\",\n+\t\t      decl, ctype);\n \t}\n       else\n \t{"}, {"sha": "2386215ba4fc30866c432c509154e3115a1f1974", "filename": "gcc/cp/init.c", "status": "modified", "additions": 6, "deletions": 39, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1561,30 +1561,11 @@ build_offset_ref (type, name)\n     name = ctor_identifier;\n #endif\n \n-  if (TYPE_SIZE (complete_type (type)) == 0)\n+  if (TYPE_SIZE (complete_type (type)) == 0\n+      && !TYPE_BEING_DEFINED (type))\n     {\n-      if (type == current_class_type)\n-\tt = IDENTIFIER_CLASS_VALUE (name);\n-      else\n-\tt = NULL_TREE;\n-      if (t == 0)\n-\t{\n-\t  cp_error (\"incomplete type `%T' does not have member `%D'\", type,\n-\t\t      name);\n-\t  return error_mark_node;\n-\t}\n-      if (TREE_CODE (t) == TYPE_DECL || TREE_CODE (t) == VAR_DECL\n-\t  || TREE_CODE (t) == CONST_DECL)\n-\t{\n-\t  mark_used (t);\n-\t  return t;\n-\t}\n-      if (TREE_CODE (t) == FIELD_DECL)\n-\tsorry (\"use of member in incomplete aggregate type\");\n-      else if (TREE_CODE (t) == FUNCTION_DECL)\n-\tsorry (\"use of member function in incomplete aggregate type\");\n-      else\n-\tmy_friendly_abort (52);\n+      cp_error (\"incomplete type `%T' does not have member `%D'\", type,\n+\t\tname);\n       return error_mark_node;\n     }\n \n@@ -1883,28 +1864,14 @@ decl_constant_value (decl)\n      tree decl;\n {\n   if (! TREE_THIS_VOLATILE (decl)\n-#if 0\n-      /* These may be necessary for C, but they break C++.  */\n-      ! TREE_PUBLIC (decl)\n-      /* Don't change a variable array bound or initial value to a constant\n-\t in a place where a variable is invalid.  */\n-      && ! pedantic\n-#endif /* 0 */\n-      && DECL_INITIAL (decl) != 0\n+      && DECL_INITIAL (decl)\n       && DECL_INITIAL (decl) != error_mark_node\n       /* This is invalid if initial value is not constant.\n \t If it has either a function call, a memory reference,\n \t or a variable, then re-evaluating it could give different results.  */\n       && TREE_CONSTANT (DECL_INITIAL (decl))\n       /* Check for cases where this is sub-optimal, even though valid.  */\n-      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR\n-#if 0\n-      /* We must allow this to work outside of functions so that\n-\t static constants can be used for array sizes.  */\n-      && current_function_decl != 0\n-      && DECL_MODE (decl) != BLKmode\n-#endif\n-      )\n+      && TREE_CODE (DECL_INITIAL (decl)) != CONSTRUCTOR)\n     return DECL_INITIAL (decl);\n   return decl;\n }"}, {"sha": "82a886c2377774b07ff98edce92a1bd2a6810dff", "filename": "gcc/cp/method.c", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -628,15 +628,12 @@ build_overload_value (type, value, in_template)\n      tree type, value;\n      int in_template;\n {\n+  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (type)) == 't', 0);\n+\n   while (TREE_CODE (value) == NON_LVALUE_EXPR\n \t || TREE_CODE (value) == NOP_EXPR)\n     value = TREE_OPERAND (value, 0);\n \n-  if (TREE_CODE (type) == PARM_DECL)\n-    type = TREE_TYPE (type);\n-\n-  my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (type)) == 't', 0);\n-\n   if (numeric_output_need_bar)\n     {\n       OB_PUTC ('_');\n@@ -649,17 +646,20 @@ build_overload_value (type, value, in_template)\n       return;\n     }\n \n-  if (TREE_CODE (type) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (type)) == OFFSET_TYPE)\n+  if (TYPE_PTRMEM_P (type))\n     {\n-      /* Handle a pointer to data member as a template instantiation\n-\t parameter, boy, what fun!  */\n-      type = integer_type_node;\n-      if (TREE_CODE (value) != INTEGER_CST)\n-\t{\n-\t  sorry (\"unknown pointer to member constant\");\n-\t  return;\n-\t}\n+      if (TREE_CODE (value) != PTRMEM_CST)\n+\t/* We should have already rejected this pointer to member,\n+\t   since it is not a constant.  */\n+\tmy_friendly_abort (0);\n+\n+      /* Get the actual FIELD_DECL.  */\n+      value = PTRMEM_CST_MEMBER (value);\n+      my_friendly_assert (TREE_CODE (value) == FIELD_DECL, 0);\n+\n+      /* Output the name of the field.  */\n+      build_overload_identifier (DECL_NAME (value));\n+      return;\n     }\n \n   if (TYPE_PTRMEMFUNC_P (type))\n@@ -898,7 +898,8 @@ build_template_parm_names (parmlist, arglist)\n \t  parm = tsubst (parm, arglist, NULL_TREE);\n \t  /* It's a PARM_DECL.  */\n \t  build_mangled_name_for_type (TREE_TYPE (parm));\n-\t  build_overload_value (parm, arg, uses_template_parms (arglist));\n+\t  build_overload_value (TREE_TYPE (parm), arg, \n+\t\t\t\tuses_template_parms (arglist));\n \t}\n     }\n  }"}, {"sha": "9ac44964ab008730b139a49a94f565a4c72d1dc5", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 3340, "deletions": 3302, "changes": 6642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=61a127b3d1302417e21b679e70362ae5b16160db"}, {"sha": "42af782951607651e5858aa8defde158eaf5a152", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 92, "deletions": 66, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -204,10 +204,9 @@ empty_parms ()\n \n %type <ttype> declarator notype_declarator after_type_declarator\n %type <ttype> direct_notype_declarator direct_after_type_declarator\n-\n-%type <ttype> opt.component_decl_list component_decl_list\n-%type <ttype> component_decl component_decl_1 components notype_components\n-%type <ttype> component_declarator component_declarator0 self_reference\n+%type <itype> components notype_components\n+%type <ttype> component_decl component_decl_1 \n+%type <ttype> component_declarator component_declarator0\n %type <ttype> notype_component_declarator notype_component_declarator0\n %type <ttype> after_type_component_declarator after_type_component_declarator0\n %type <ttype> enumlist enumerator\n@@ -1844,16 +1843,19 @@ typespecqual_reserved:\n initdecls:\n \t  initdcl0\n \t| initdecls ',' initdcl\n+            { check_multiple_declarators (); }\n \t;\n \n notype_initdecls:\n \t  notype_initdcl0\n \t| notype_initdecls ',' initdcl\n+            { check_multiple_declarators (); }\n \t;\n \n nomods_initdecls:\n \t  nomods_initdcl0\n \t| nomods_initdecls ',' initdcl\n+            { check_multiple_declarators (); }\n \t;\n \n maybeasm:\n@@ -2112,7 +2114,7 @@ structsp:\n \t\t    yychar = YYLEX;\n \t\t  semi = yychar == ';';\n \n-\t\t  $<ttype>$ = finish_class_definition ($1, $3, $5, semi); \n+\t\t  $<ttype>$ = finish_class_definition ($1, $5, semi); \n \t\t}\n \t  pending_defargs\n                 { finish_default_args (); }\n@@ -2168,7 +2170,10 @@ aggr:\n \n named_class_head_sans_basetype:\n \t  aggr identifier\n-\t\t{ current_aggr = $$; $$ = $2; }\n+\t\t{ \n+\t\t  current_aggr = $1; \n+\t\t  $$ = $2; \n+\t\t}\n \t;\n \n named_class_head_sans_basetype_defn:\n@@ -2202,15 +2207,11 @@ named_complex_class_head_sans_basetype:\n \t\t{ current_aggr = $$; $$ = $3; }\n \t;\n \n-do_xref_defn:\n-\t  /* empty */  %prec EMPTY\n-\t\t{ $<ttype>$ = xref_tag (current_aggr, $<ttype>0, 0); }\n-\t;\n-\n named_class_head:\n \t  named_class_head_sans_basetype  %prec EMPTY\n \t\t{ $$ = xref_tag (current_aggr, $1, 1); }\n-\t| named_class_head_sans_basetype_defn do_xref_defn\n+\t| named_class_head_sans_basetype_defn \n+                { $<ttype>$ = xref_tag (current_aggr, $1, 0); }\n           maybe_base_class_list  %prec EMPTY\n \t\t{ \n \t\t  $$ = $<ttype>2;\n@@ -2358,64 +2359,45 @@ left_curly:\n self_reference:\n \t  /* empty */\n \t\t{\n-\t\t    $$ = build_self_reference ();\n+\t\t  finish_member_declaration (build_self_reference ());\n \t\t}\n \t;\n \n opt.component_decl_list:\n \t  self_reference\n-\t\t{ if ($$) $$ = build_tree_list (access_public_node, $$); }\n \t| self_reference component_decl_list\n-\t\t{\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    $$ = build_tree_list (access_public_node, $2);\n-\t\t  else\n-\t\t    $$ = build_tree_list (access_default_node, $2);\n-\t\t  if ($1) $$ = tree_cons (access_public_node, $1, $$);\n-\t\t}\n-\t| opt.component_decl_list VISSPEC ':' component_decl_list\n-\t\t{\n-\t\t  tree visspec = $2;\n+\t| opt.component_decl_list access_specifier component_decl_list\n+\t| opt.component_decl_list access_specifier \n+\t;\n \n+access_specifier:\n+\t  VISSPEC ':'\n+                {\n \t\t  if (current_aggr == signature_type_node)\n \t\t    {\n \t\t      error (\"access specifier not allowed in signature\");\n-\t\t      visspec = access_public_node;\n+\t\t      $1 = access_public_node;\n \t\t    }\n-\t\t  $$ = chainon ($$, build_tree_list (visspec, $4));\n-\t\t}\n-\t| opt.component_decl_list VISSPEC ':'\n-\t\t{\n-\t\t  if (current_aggr == signature_type_node)\n-\t\t    error (\"access specifier not allowed in signature\");\n-\t\t}\n+\n+\t\t  current_access_specifier = $1;\n+                }\n \t;\n \n /* Note: we no longer warn about the semicolon after a component_decl_list.\n    ARM $9.2 says that the semicolon is optional, and therefore allowed.  */\n component_decl_list:\n \t  component_decl\n-\t\t{ if ($$ == void_type_node) $$ = NULL_TREE; \n+\t\t{ \n+\t\t  finish_member_declaration ($1);\n \t\t}\n \t| component_decl_list component_decl\n-\t\t{ /* In pushdecl, we created a reverse list of names\n-\t\t     in this binding level.  Make sure that the chain\n-\t\t     of what we're trying to add isn't the item itself\n-\t\t     (which can happen with what pushdecl's doing).  */\n-\t\t  if ($2 != NULL_TREE && $2 != void_type_node\n-\t\t      && $2 != error_mark_node)\n-\t\t    {\n-\t\t      if (TREE_CHAIN ($2) != $$)\n-\t\t\t$$ = chainon ($$, $2);\n-\t\t      else\n-\t\t\t$$ = $2;\n-\t\t    }\n+\t\t{ \n+\t\t  finish_member_declaration ($2);\n \t\t}\n \t;\n \n component_decl:\n \t  component_decl_1 ';'\n-\t\t{ }\n \t| component_decl_1 '}'\n \t\t{ error (\"missing ';' before right brace\");\n \t\t  yyungetc ('}', 0); }\n@@ -2435,19 +2417,53 @@ component_decl:\n \t\t{ $$ = $2;\n \t\t  pedantic = $<itype>1; }\n         | template_header component_decl\n-                { $$ = finish_member_template_decl ($1, $2); }\n+                {  \n+\t\t  if ($2)\n+\t\t    $$ = finish_member_template_decl ($2);\n+\t\t  else\n+\t\t    /* The component was already processed.  */\n+\t\t    $$ = NULL_TREE;\n+\n+\t\t  finish_template_decl ($1);\n+\t\t}\n \t| template_header typed_declspecs ';'\n-                { $$ = finish_member_class_template ($1, $2.t); }\n+                { \n+\t\t  $$ = finish_member_class_template ($2.t); \n+\t\t  finish_template_decl ($1);\n+\t\t}\n \t;\n \n component_decl_1:\n \t/* Do not add a \"typed_declspecs declarator\" rule here for\n \t   speed; we need to call grok_x_components for enums, so the\n \t   speedup would be insignificant.  */\n \t  typed_declspecs components\n-\t\t{ $$ = grok_x_components ($1.t, $2); }\n+\t\t{\n+\t\t  /* Most of the productions for component_decl only\n+\t\t     allow the creation of one new member, so we call\n+\t\t     finish_member_declaration in component_decl_list.\n+\t\t     For this rule and the next, however, there can be\n+\t\t     more than one member, e.g.:\n+\n+\t\t       int i, j;\n+\n+\t\t     and we need the first member to be fully\n+\t\t     registered before the second is processed.\n+\t\t     Therefore, the rules for components take care of\n+\t\t     this processing.  To avoid registering the\n+\t\t     components more than once, we send NULL_TREE up\n+\t\t     here; that lets finish_member_declaration now\n+\t\t     that there is nothing to do.  */\n+\t\t  if (!$2)\n+\t\t    grok_x_components ($1.t);\n+\t\t  $$ = NULL_TREE;\n+\t\t}\n \t| declmods notype_components\n-\t\t{ $$ = grok_x_components ($1, $2); }\n+\t\t{ \n+\t\t  if (!$2)\n+\t\t    grok_x_components ($1);\n+\t\t  $$ = NULL_TREE; \n+\t\t}\n \t| notype_declarator maybeasm maybe_attribute maybe_init\n \t\t{ $$ = grokfield ($$, NULL_TREE, $4, $2,\n \t\t\t\t  build_tree_list ($3, NULL_TREE)); }\n@@ -2482,31 +2498,41 @@ component_decl_1:\n /* ??? Huh? ^^^ */\n components:\n \t  /* empty: possibly anonymous */\n-\t\t{ $$ = NULL_TREE; }\n+                { $$ = 0; }\n \t| component_declarator0\n+                { \n+\t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t    $1 = finish_member_template_decl ($1);\n+\t\t  finish_member_declaration ($1); \n+\t\t  $$ = 1;\n+\t\t}\n \t| components ',' component_declarator\n-\t\t{\n-\t\t  /* In this context, void_type_node encodes\n-\t\t     friends.  They have been recorded elsewhere.  */\n-\t\t  if ($$ == void_type_node)\n-\t\t    $$ = $3;\n-\t\t  else\n-\t\t    $$ = chainon ($$, $3);\n+                { \n+\t\t  check_multiple_declarators ();\n+\t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t    $3 = finish_member_template_decl ($3);\n+\t\t  finish_member_declaration ($3);\n+\t\t  $$ = 2;\n \t\t}\n \t;\n \n notype_components:\n \t  /* empty: possibly anonymous */\n-\t\t{ $$ = NULL_TREE; }\n+                { $$ = 0; }\n \t| notype_component_declarator0\n+                { \n+\t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t    $1 = finish_member_template_decl ($1);\n+\t\t  finish_member_declaration ($1);\n+\t\t  $$ = 1;\n+\t\t}\n \t| notype_components ',' notype_component_declarator\n-\t\t{\n-\t\t  /* In this context, void_type_node encodes\n-\t\t     friends.  They have been recorded elsewhere.  */\n-\t\t  if ($$ == void_type_node)\n-\t\t    $$ = $3;\n-\t\t  else\n-\t\t    $$ = chainon ($$, $3);\n+                { \n+\t\t  check_multiple_declarators ();\n+\t\t  if (PROCESSING_REAL_TEMPLATE_DECL_P ())\n+\t\t    $3 = finish_member_template_decl ($3);\n+\t\t  finish_member_declaration ($3); \n+\t\t  $$ = 2;\n \t\t}\n \t;\n "}, {"sha": "c493bea4f5f77cb1e53677614a75c05432649f80", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 102, "deletions": 104, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -129,6 +129,7 @@ static tree tsubst_decl PROTO((tree, tree, tree, tree));\n static tree tsubst_arg_types PROTO((tree, tree, tree));\n static void check_specialization_scope PROTO((void));\n static tree process_partial_specialization PROTO((tree));\n+static void set_current_access_from_decl PROTO((tree));\n \n /* We use TREE_VECs to hold template arguments.  If there is only one\n    level of template arguments, then the TREE_VEC contains the\n@@ -196,12 +197,9 @@ static tree process_partial_specialization PROTO((tree));\n    it is a specialization, in which case the DECL itself is returned.  */\n \n tree\n-finish_member_template_decl (template_parameters, decl)\n-  tree template_parameters;\n+finish_member_template_decl (decl)\n   tree decl;\n {\n-  finish_template_decl (template_parameters);\n-\n   if (decl == NULL_TREE || decl == void_type_node)\n     return NULL_TREE;\n   else if (decl == error_mark_node)\n@@ -3066,9 +3064,11 @@ comp_template_args (oldargs, newargs)\n \n       if (nt == ot)\n \tcontinue;\n-      if (TREE_CODE (nt) != TREE_CODE (ot))\n+      else if (!nt || !ot)\n+\treturn 0;\n+      else if (TREE_CODE (nt) != TREE_CODE (ot))\n \treturn 0;\n-      if (TREE_CODE (nt) == TREE_VEC)\n+      else if (TREE_CODE (nt) == TREE_VEC)\n         {\n           /* For member templates */\n \t  if (comp_template_args (ot, nt))\n@@ -3382,14 +3382,12 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n     }\n   else \n     {\n-      extern tree current_local_enum;\n       tree template_type = TREE_TYPE (template);\n       tree type_decl;\n       tree found = NULL_TREE;\n       int arg_depth;\n       int parm_depth;\n       int is_partial_instantiation;\n-      tree prev_local_enum = NULL_TREE;\n \n       template = most_general_template (template);\n       parmlist = DECL_TEMPLATE_PARMS (template);\n@@ -3549,10 +3547,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       if (TREE_CODE (template_type) == ENUMERAL_TYPE)\n \t{\n \t  if (!is_partial_instantiation)\n-\t    {\n-\t      prev_local_enum = current_local_enum;\n-\t      t = start_enum (TYPE_IDENTIFIER (template_type));\n-\t    }\n+\t    t = start_enum (TYPE_IDENTIFIER (template_type));\n \t  else\n \t    /* We don't want to call start_enum for this type, since\n \t       the values for the enumeration constants may involve\n@@ -3570,7 +3565,7 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \t  TYPE_FOR_JAVA (t) = TYPE_FOR_JAVA (template_type);\n \t}\n \n-      /* If we called tsubst_enum above, this information will already\n+      /* If we called start_enum above, this information will already\n \t be set up.  */\n       if (!TYPE_NAME (t))\n \t{\n@@ -3599,17 +3594,14 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n \n       if (TREE_CODE (t) == ENUMERAL_TYPE \n \t  && !is_partial_instantiation)\n-\t{\n-\t  /* Now that the type has been registered on the\n-\t     instantiations list, we set up the enumerators.  Because\n-\t     the enumeration constants may involve the enumeration\n-\t     type itself, we make sure to register the type first, and\n-\t     then create the constants.  That way, doing tsubst_expr\n-\t     for the enumeration constants won't result in recursive\n-\t     calls here; we'll find the instantiation and exit above.  */\n-\t  tsubst_enum (template_type, t, arglist);\n-\t  current_local_enum = prev_local_enum;\n-\t}\n+\t/* Now that the type has been registered on the instantiations\n+\t   list, we set up the enumerators.  Because the enumeration\n+\t   constants may involve the enumeration type itself, we make\n+\t   sure to register the type first, and then create the\n+\t   constants.  That way, doing tsubst_expr for the enumeration\n+\t   constants won't result in recursive calls here; we'll find\n+\t   the instantiation and exit above.  */\n+\ttsubst_enum (template_type, t, arglist);\n \n       /* We're done with the permanent obstack, now.  */\n       pop_obstacks ();\n@@ -3814,6 +3806,9 @@ for_each_template_parm (t, fn, data)\n     case TYPENAME_TYPE:\n       return 1;\n \n+    case PTRMEM_CST:\n+      return for_each_template_parm (TREE_TYPE (t), fn, data);\n+\n     case SCOPE_REF:\n       return for_each_template_parm (TREE_OPERAND (t, 0), fn, data);\n \n@@ -4256,7 +4251,7 @@ tree\n instantiate_class_template (type)\n      tree type;\n {\n-  tree template, args, pattern, t, *field_chain;\n+  tree template, args, pattern, t;\n   tree typedecl;\n \n   if (type == error_mark_node)\n@@ -4323,11 +4318,16 @@ instantiate_class_template (type)\n     }\n \n   if (pedantic && uses_template_parms (args))\n-    /* If there are still template parameters amongst the args, then\n-       we can't instantiate the type; there's no telling whether or not one\n-       of the template parameters might eventually be instantiated to some\n-       value that results in a specialization being used.  */\n-    return type;\n+    {\n+      /* If there are still template parameters amongst the args, then\n+\t we can't instantiate the type; there's no telling whether or not one\n+\t of the template parameters might eventually be instantiated to some\n+\t value that results in a specialization being used.  We do the\n+\t type as complete so that, for example, declaring one of its\n+\t members to be a friend will not be rejected.  */\n+      TYPE_SIZE (type) = integer_zero_node;\n+      return type;\n+    }\n \n   TYPE_BEING_DEFINED (type) = 1;\n \n@@ -4394,8 +4394,6 @@ instantiate_class_template (type)\n   TYPE_ALIGN (type) = TYPE_ALIGN (pattern);\n   TYPE_FOR_JAVA (type) = TYPE_FOR_JAVA (pattern); /* For libjava's JArray<T> */\n \n-  CLASSTYPE_LOCAL_TYPEDECLS (type) = CLASSTYPE_LOCAL_TYPEDECLS (pattern);\n-\n   /* If this is a partial instantiation, don't tsubst anything.  We will\n      only use this type for implicit typename, so the actual contents don't\n      matter.  All that matters is whether a particular name is a type.  */\n@@ -4449,53 +4447,21 @@ instantiate_class_template (type)\n \t      }\n \t    TYPE_GETS_NEW (type) |= TYPE_GETS_NEW (basetype);\n \t    TYPE_GETS_DELETE (type) |= TYPE_GETS_DELETE (basetype);\n-\t    CLASSTYPE_LOCAL_TYPEDECLS (type)\n-\t      |= CLASSTYPE_LOCAL_TYPEDECLS (basetype);\n \t  }\n \t/* Don't initialize this until the vector is filled out, or\n \t   lookups will crash.  */\n \tBINFO_BASETYPES (binfo) = bases;\n       }\n   }\n \n-  field_chain = &TYPE_FIELDS (type);\n-\n   for (t = CLASSTYPE_TAGS (pattern); t; t = TREE_CHAIN (t))\n     {\n       tree tag = TREE_VALUE (t);\n       tree name = TYPE_IDENTIFIER (tag);\n       tree newtag;\n \n       newtag = tsubst (tag, args, NULL_TREE);\n-      if (TREE_CODE (newtag) == ENUMERAL_TYPE)\n-\t{\n-\t  extern tree current_local_enum;\n-\t  tree prev_local_enum = current_local_enum;\n-\n-\t  if (TYPE_VALUES (newtag))\n-\t    {\n-\t      tree v;\n-\n-\t      /* We must set things up so that CURRENT_LOCAL_ENUM is the\n-\t\t CONST_DECL for the last enumeration constant, since the\n-\t\t CONST_DECLs are chained backwards.  */\n-\t      for (v = TYPE_VALUES (newtag); TREE_CHAIN (v); \n-\t\t   v = TREE_CHAIN (v))\n-\t\t;\n-\n-\t      current_local_enum \n-\t\t= IDENTIFIER_CLASS_VALUE (TREE_PURPOSE (v));\n-\t      *field_chain = grok_enum_decls (NULL_TREE);\n-\t      current_local_enum = prev_local_enum;\n-\n-\t      while (*field_chain)\n-\t\t{\n-\t\t  DECL_FIELD_CONTEXT (*field_chain) = type;\n-\t\t  field_chain = &TREE_CHAIN (*field_chain);\n-\t\t}\n-\t    }\n-\t}\n-      else\n+      if (TREE_CODE (newtag) != ENUMERAL_TYPE)\n \t{\n \t  /* Now, we call pushtag to put this NEWTAG into the scope of\n \t     TYPE.  We first set up the IDENTIFIER_TYPE_VALUE to avoid\n@@ -4530,12 +4496,27 @@ instantiate_class_template (type)\n \t    DECL_EXTERNAL (r) = 1;\n \t    cp_finish_decl (r, DECL_INITIAL (r), NULL_TREE, 0, 0);\n \t  }\n-\n-\t*field_chain = r;\n-\tfield_chain = &TREE_CHAIN (r);\n+\t\n+\t/* R will have a TREE_CHAIN if and only if it has already been\n+\t   processed by finish_member_declaration.  This can happen\n+\t   if, for example, it is a TYPE_DECL for a class-scoped\n+\t   ENUMERAL_TYPE; such a thing will already have been added to\n+\t   the field list by tsubst_enum above.  */\n+\tif (!TREE_CHAIN (r))\n+\t  {\n+\t    set_current_access_from_decl (r);\n+\t    finish_member_declaration (r);\n+\t  }\n       }\n \n-  TYPE_METHODS (type) = tsubst_chain (TYPE_METHODS (pattern), args);\n+  /* Set up the list (TYPE_METHODS) and vector (CLASSTYPE_METHOD_VEC)\n+     for this instantiation.  */\n+  for (t = TYPE_METHODS (pattern); t; t = TREE_CHAIN (t))\n+    {\n+      tree r = tsubst (t, args, NULL_TREE);\n+      set_current_access_from_decl (r);\n+      finish_member_declaration (r);\n+    }\n \n   /* Construct the DECL_FRIENDLIST for the new class type.  */\n   typedecl = TYPE_MAIN_DECL (type);\n@@ -4627,6 +4608,14 @@ instantiate_class_template (type)\n \trequire_complete_type (t);\n       }\n \n+  /* Set the file and line number information to whatever is given for\n+     the class itself.  This puts error messages involving generated\n+     implicit functions at a predictable point, and the same point\n+     that would be used for non-template classes.  */\n+  lineno = DECL_SOURCE_LINE (typedecl);\n+  input_filename = DECL_SOURCE_FILE (typedecl);\n+\n+  unreverse_member_declarations (type);\n   type = finish_struct_1 (type, 0);\n   CLASSTYPE_GOT_SEMICOLON (type) = 1;\n \n@@ -6787,6 +6776,7 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t    {\n \t      tree targs;\n \t      tree arg_type;\n+\t      int r;\n \n \t      /* Have to back unify here */\n \t      arg = OVL_FUNCTION (arg);\n@@ -6795,10 +6785,14 @@ type_unification_real (tparms, targs, parms, args, subr,\n \t      maybe_adjust_types_for_deduction (strict, &parm, &arg_type);\n \t      parm = expr_tree_cons (NULL_TREE, parm, NULL_TREE);\n \t      arg_type = scratch_tree_cons (NULL_TREE, arg_type, NULL_TREE);\n-\t      return \n-\t\ttype_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n-\t\t\t\t  targs, arg_type, parm, NULL_TREE,\n-\t\t\t\t  DEDUCE_EXACT, allow_incomplete); \n+\t      r = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (arg), \n+\t\t\t\t    targs, arg_type, parm, NULL_TREE,\n+\t\t\t\t    DEDUCE_EXACT, allow_incomplete);\n+\t      if (r)\n+\t\t/* If the back-unification failed, just bail out.  */\n+\t\treturn r;\n+\t      else \n+\t\tcontinue;\n \t    }\n \t  arg = TREE_TYPE (arg);\n \t}\n@@ -7952,16 +7946,22 @@ regenerate_decl_from_template (decl, tmpl)\n      register_specialization for it.  */\n   my_friendly_assert (unregistered, 0);\n \n+  if (TREE_CODE (decl) == VAR_DECL)\n+    /* Make sure that we can see identifiers, and compute access\n+       correctly, for the class members used in the declaration of\n+       this static variable.  */\n+    pushclass (DECL_CONTEXT (decl), 2);\n+\n   /* Do the substitution to get the new declaration.  */\n   new_decl = tsubst (code_pattern, args, NULL_TREE);\n \n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       /* Set up DECL_INITIAL, since tsubst doesn't.  */\n-      pushclass (DECL_CONTEXT (decl), 2);\n       DECL_INITIAL (new_decl) = \n \ttsubst_expr (DECL_INITIAL (code_pattern), args, \n \t\t     DECL_TI_TEMPLATE (decl));\n+      /* Pop the class context we pushed above.  */\n       popclass (1);\n     }\n \n@@ -8228,27 +8228,6 @@ instantiate_decl (d)\n   return d;\n }\n \n-tree\n-tsubst_chain (t, argvec)\n-     tree t, argvec;\n-{\n-  if (t)\n-    {\n-      tree first = tsubst (t, argvec, NULL_TREE);\n-      tree last = first;\n-\n-      for (t = TREE_CHAIN (t); t; t = TREE_CHAIN (t))\n-\t{\n-\t  tree x = tsubst (t, argvec, NULL_TREE);\n-\t  TREE_CHAIN (last) = x;\n-\t  last = x;\n-\t}\n-\n-      return first;\n-    }\n-  return NULL_TREE;\n-}\n-\n static tree\n tsubst_expr_values (t, argvec)\n      tree t, argvec;\n@@ -8321,6 +8300,20 @@ add_maybe_template (d, fns)\n   DECL_MAYBE_TEMPLATE (d) = 1;\n }\n \n+/* Set CURRENT_ACCESS_SPECIFIER based on the protection of DECL.  */\n+\n+static void\n+set_current_access_from_decl (decl)\n+     tree decl;\n+{\n+  if (TREE_PRIVATE (decl))\n+    current_access_specifier = access_private_node;\n+  else if (TREE_PROTECTED (decl))\n+    current_access_specifier = access_protected_node;\n+  else\n+    current_access_specifier = access_public_node;\n+}\n+\n /* Instantiate an enumerated type.  TAG is the template type, NEWTAG\n    is the instantiation (which should have been created with\n    start_enum) and ARGS are the template arguments to use.  */\n@@ -8335,15 +8328,20 @@ tsubst_enum (tag, newtag, args)\n \n   for (e = TYPE_VALUES (tag); e; e = TREE_CHAIN (e))\n     {\n-      tree elt\n-\t= build_enumerator (TREE_PURPOSE (e), \n-\t\t\t    /* Note that in a template enum, the\n-\t\t\t       TREE_VALUE is the CONST_DECL, not the\n-\t\t\t       corresponding INTEGER_CST.  */\n-\t\t\t    tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n+      tree value;\n+      tree elt;\n+\n+      /* Note that in a template enum, the TREE_VALUE is the\n+\t CONST_DECL, not the corresponding INTEGER_CST.  */\n+      value = tsubst_expr (DECL_INITIAL (TREE_VALUE (e)), \n \t\t\t\t\t args,\n-\t\t\t\t\t NULL_TREE),\n-\t\t\t    newtag); \n+\t\t\t\t\t NULL_TREE);\n+\n+      /* Give this enumeration constant the correct access.  */\n+      set_current_access_from_decl (TREE_VALUE (e));\n+\n+      /* Actually build the enumerator itself.  */\n+      elt = build_enumerator (TREE_PURPOSE (e), value, newtag); \n \n       /* We save the enumerators we have built so far in the\n \t TYPE_VALUES so that if the enumeration constants for\n@@ -8420,7 +8418,7 @@ set_mangled_name_for_template_decl (decl)\n      with the innermost level omitted.  */\n   fn_type = TREE_TYPE (tmpl);\n   if (DECL_STATIC_FUNCTION_P (decl))\n-      context = DECL_CLASS_CONTEXT (decl);\n+    context = DECL_CLASS_CONTEXT (decl);\n \n   if (parm_depth == 1)\n     /* No substitution is necessary.  */"}, {"sha": "5f157029ecaf96aefde0d0faf2072473c6225c1d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1289,7 +1289,7 @@ lookup_fnfields_1 (type, name)\n       if (*++methods && name == dtor_identifier)\n \treturn 1;\n \n-      while (++methods != end)\n+      while (++methods != end && *methods)\n \t{\n #ifdef GATHER_STATISTICS\n \t  n_outer_fields_searched++;\n@@ -1301,20 +1301,28 @@ lookup_fnfields_1 (type, name)\n       /* If we didn't find it, it might have been a template\n \t conversion operator.  (Note that we don't look for this case\n \t above so that we will always find specializations first.)  */\n-      if (methods == end \n+      if ((methods == end || !*methods)\n \t  && IDENTIFIER_TYPENAME_P (name)) \n \t{\n \t  methods = &TREE_VEC_ELT (method_vec, 0) + 1;\n \t  \n-\t  while (++methods != end)\n+\t  while (++methods != end && *methods)\n \t    {\n-\t      if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL \n-\t\t  && IDENTIFIER_TYPENAME_P (DECL_NAME (OVL_CURRENT (*methods))))\n+\t      tree method_name = DECL_NAME (OVL_CURRENT (*methods));\n+\n+\t      if (!IDENTIFIER_TYPENAME_P (method_name))\n+\t\t{\n+\t\t  /* Since all conversion operators come first, we know\n+\t\t     there is no such operator.  */\n+\t\t  methods = end;\n+\t\t  break;\n+\t\t}\n+\t      else if (TREE_CODE (OVL_CURRENT (*methods)) == TEMPLATE_DECL)\n \t\tbreak;\n \t    }\n \t}\n \n-      if (methods != end)\n+      if (methods != end && *methods)\n \treturn methods - &TREE_VEC_ELT (method_vec, 0);\n     }\n \n@@ -2962,7 +2970,7 @@ dfs_pushdecls (binfo)\n      tree binfo;\n {\n   tree type = BINFO_TYPE (binfo);\n-  tree fields, *methods, *end;\n+  tree fields;\n   tree method_vec;\n   int dummy = 0;\n \n@@ -3015,16 +3023,24 @@ dfs_pushdecls (binfo)\n   method_vec = CLASSTYPE_METHOD_VEC (type);\n   if (method_vec && ! dummy)\n     {\n+      tree *methods;\n+      tree *end;\n+\n       /* Farm out constructors and destructors.  */\n-      methods = &TREE_VEC_ELT (method_vec, 2);\n       end = TREE_VEC_END (method_vec);\n \n-      while (methods != end)\n+      for (methods = &TREE_VEC_ELT (method_vec, 2);\n+\t   *methods && methods != end;\n+\t   methods++)\n \t{\n \t  /* This will cause lookup_name to return a pointer\n \t     to the tree_list of possible methods of this name.  */\n-\t  tree name = DECL_NAME (OVL_CURRENT (*methods));\n-\t  tree class_value = IDENTIFIER_CLASS_VALUE (name);\n+\t  tree name;\n+\t  tree class_value;\n+\n+\t  \n+\t  name = DECL_NAME (OVL_CURRENT (*methods));\n+\t  class_value = IDENTIFIER_CLASS_VALUE (name);\n \n \t  /* If the class value is not an envelope of the kind described in\n \t     the comment above, we create a new envelope.  */\n@@ -3049,8 +3065,6 @@ dfs_pushdecls (binfo)\n \t  envelope_add_decl (type, OVL_CURRENT (*methods),\n \t\t\t     &TREE_PURPOSE (class_value));\n \t  pop_obstacks ();\n-\n-\t  methods++;\n \t}\n     }\n \n@@ -3074,10 +3088,11 @@ dfs_compress_decls (binfo)\n   else if (method_vec != 0)\n     {\n       /* Farm out constructors and destructors.  */\n-      tree *methods = &TREE_VEC_ELT (method_vec, 2);\n+      tree *methods;\n       tree *end = TREE_VEC_END (method_vec);\n \n-      for (; methods != end; methods++)\n+      for (methods = &TREE_VEC_ELT (method_vec, 2); \n+\t   methods != end && *methods; methods++)\n \t{\n \t  /* This is known to be an envelope of the kind described before\n \t     dfs_pushdecls.  */\n@@ -3269,7 +3284,9 @@ add_conversions (binfo)\n   for (i = 2; i < TREE_VEC_LENGTH (method_vec); ++i)\n     {\n       tree tmp = TREE_VEC_ELT (method_vec, i);\n-      if (! IDENTIFIER_TYPENAME_P (DECL_NAME (OVL_CURRENT (tmp))))\n+\n+      if (!tmp\n+\t  || !IDENTIFIER_TYPENAME_P (DECL_NAME (OVL_CURRENT (tmp))))\n \tbreak;\n       conversions = scratch_tree_cons (binfo, tmp, conversions);\n     }"}, {"sha": "9579d44d96b089768e628882787a71c84d9e174a", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 124, "deletions": 10, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1268,14 +1268,99 @@ begin_class_definition (t)\n   return t;\n }\n \n-/* Finish a class definition T, with the indicated COMPONENTS, and\n-   with the indicate ATTRIBUTES.  If SEMI, the definition is\n-   immediately followed by a semicolon.  Returns the type.  */\n+/* Finish the member declaration given by DECL.  */\n+\n+void\n+finish_member_declaration (decl)\n+     tree decl;\n+{\n+  if (decl == error_mark_node || decl == NULL_TREE)\n+    return;\n+\n+  if (decl == void_type_node)\n+    /* The COMPONENT was a friend, not a member, and so there's\n+       nothing for us to do.  */\n+    return;\n+\n+  /* We should see only one DECL at a time.  */\n+  my_friendly_assert (TREE_CHAIN (decl) == NULL_TREE, 0);\n+\n+  /* Set up access control for DECL.  */\n+  TREE_PRIVATE (decl) \n+    = (current_access_specifier == access_private_node);\n+  TREE_PROTECTED (decl) \n+    = (current_access_specifier == access_protected_node);\n+  if (TREE_CODE (decl) == TEMPLATE_DECL)\n+    {\n+      TREE_PRIVATE (DECL_RESULT (decl)) = TREE_PRIVATE (decl);\n+      TREE_PROTECTED (DECL_RESULT (decl)) = TREE_PROTECTED (decl);\n+    }\n+\n+  /* Mark the DECL as a member of the current class.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL \n+      || DECL_FUNCTION_TEMPLATE_P (decl))\n+    /* Historically, DECL_CONTEXT was not set for a FUNCTION_DECL in\n+       finish_struct.  Presumably it is already set as the function is\n+       parsed.  Perhaps DECL_CLASS_CONTEXT is already set, too?  */\n+    DECL_CLASS_CONTEXT (decl) = current_class_type;\n+  else if (TREE_CODE (decl) == TYPE_DECL)\n+    /* Historically, DECL_CONTEXT was not set for a TYPE_DECL in\n+       finish_struct, so we do not do it here either.  Perhaps we\n+       should, though.  */\n+      ;\n+  else\n+    DECL_CONTEXT (decl) = current_class_type;\n+\n+  /* Put functions on the TYPE_METHODS list and everything else on the\n+     TYPE_FIELDS list.  Note that these are built up in reverse order.\n+     We reverse them (to obtain declaration order) in finish_struct.  */\n+  if (TREE_CODE (decl) == FUNCTION_DECL \n+      || DECL_FUNCTION_TEMPLATE_P (decl))\n+    {\n+      /* We also need to add this function to the\n+\t CLASSTYPE_METHOD_VEC.  */\n+      add_method (current_class_type, 0, decl);\n+\n+      TREE_CHAIN (decl) = TYPE_METHODS (current_class_type);\n+      TYPE_METHODS (current_class_type) = decl;\n+    }\n+  else\n+    {\n+      /* All TYPE_DECLs go at the end of TYPE_FIELDS.  Ordinary fields\n+\t go at the beginning.  The reason is that lookup_field_1\n+\t searches the list in order, and we want a field name to\n+\t override a type name so that the \"struct stat hack\" will\n+\t work.  In particular:\n+\n+\t   struct S { enum E { }; int E } s;\n+\t   s.E = 3;\n+\n+\t is legal.  In addition, the FIELD_DECLs must be maintained in\n+\t declaration order so that class layout works as expected.\n+\t However, we don't need that order until class layout, so we\n+\t save a little time by putting FIELD_DECLs on in reverse order\n+\t here, and then reversing them in finish_struct_1.  (We could\n+\t also keep a pointer to the correct insertion points in the\n+\t list.)  */\n+\n+      if (TREE_CODE (decl) == TYPE_DECL)\n+\tTYPE_FIELDS (current_class_type) \n+\t  = chainon (TYPE_FIELDS (current_class_type), decl);\n+      else\n+\t{\n+\t  TREE_CHAIN (decl) = TYPE_FIELDS (current_class_type);\n+\t  TYPE_FIELDS (current_class_type) = decl;\n+\t}\n+    }\n+}\n+\n+/* Finish a class definition T with the indicate ATTRIBUTES.  If SEMI,\n+   the definition is immediately followed by a semicolon.  Returns the\n+   type.  */\n \n tree\n-finish_class_definition (t, components, attributes, semi)\n+finish_class_definition (t, attributes, semi)\n      tree t;\n-     tree components;\n      tree attributes;\n      int semi;\n {\n@@ -1299,7 +1384,7 @@ finish_class_definition (t, components, attributes, semi)\n     ;\n   else\n     {\n-      t = finish_struct (t, components, attributes, semi);\n+      t = finish_struct (t, attributes, semi);\n       if (semi) \n \tnote_got_semicolon (t);\n     }\n@@ -1342,8 +1427,7 @@ begin_inline_definitions ()\n    TYPES whose template parameters are given by PARMS.  */\n \n tree\n-finish_member_class_template (parms, types)\n-     tree parms;\n+finish_member_class_template (types)\n      tree types;\n {\n   tree t;\n@@ -1356,13 +1440,15 @@ finish_member_class_template (parms, types)\n       maybe_process_partial_specialization (TREE_VALUE (t));\n \n   note_list_got_semicolon (types);\n-  grok_x_components (types, NULL_TREE); \n+  grok_x_components (types);\n   if (TYPE_CONTEXT (TREE_VALUE (types)) != current_class_type)\n     /* The component was in fact a friend declaration.  We avoid\n        finish_member_template_decl performing certain checks by\n        unsetting TYPES.  */\n     types = NULL_TREE;\n-  finish_member_template_decl (parms, types);\n+  \n+  finish_member_template_decl (types);\n+\n   /* As with other component type declarations, we do\n      not store the new DECL on the list of\n      component_decls.  */\n@@ -1480,3 +1566,31 @@ finish_base_specifier (access_specifier, base_class,\n \n   return result;\n }\n+\n+/* Called when multiple declarators are processed.  If that is not\n+   premitted in this context, an error is issued.  */\n+\n+void\n+check_multiple_declarators ()\n+{\n+  /* [temp]\n+     \n+     In a template-declaration, explicit specialization, or explicit\n+     instantiation the init-declarator-list in the declaration shall\n+     contain at most one declarator.  \n+\n+     We don't just use PROCESSING_TEMPLATE_DECL for the first\n+     condition since that would disallow the perfectly legal code, \n+     like `template <class T> struct S { int i, j; };'.  */\n+  tree scope = current_scope ();\n+\n+  if (scope && TREE_CODE (scope) == FUNCTION_DECL)\n+    /* It's OK to write `template <class T> void f() { int i, j;}'.  */\n+    return;\n+     \n+  if (PROCESSING_REAL_TEMPLATE_DECL_P () \n+      || processing_explicit_instantiation\n+      || processing_specialization)\n+    cp_error (\"multiple declarators in template declaration\");\n+}\n+"}, {"sha": "6f8d14dd19d27334dd5afffad9a44db54232a764", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 23, "deletions": 27, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -343,49 +343,45 @@ build_member_function_pointer (member)\n    The new FIELD_DECLs are appended at the end of the last (and only)\n    sublist of `list_of_fieldlists.'\n \n+   T is the signature type.\n+  \n    As a side effect, each member function in the signature gets the\n    `decl.ignored' bit turned on, so we don't output debug info for it.  */\n \n void\n-append_signature_fields (list_of_fieldlists)\n-     tree list_of_fieldlists;\n+append_signature_fields (t)\n+     tree t;\n {\n-  tree l, x;\n-  tree last_x = NULL_TREE;\n+  tree x;\n   tree mfptr;\n   tree last_mfptr = NULL_TREE;\n   tree mfptr_list = NULL_TREE;\n \t      \n-  /* For signatures it should actually be only a list with one element.  */\n-  for (l = list_of_fieldlists; l; l = TREE_CHAIN (l))\n+  for (x = TYPE_METHODS (t); x; x = TREE_CHAIN (x))\n     {\n-      for (x = TREE_VALUE (l); x; x = TREE_CHAIN (x))\n+      if (TREE_CODE (x) == FUNCTION_DECL)\n \t{\n-\t  if (TREE_CODE (x) == FUNCTION_DECL)\n+\t  mfptr = build_member_function_pointer (x);\n+\t  DECL_MEMFUNC_POINTER_TO (x) = mfptr;\n+\t  DECL_MEMFUNC_POINTING_TO (mfptr) = x;\n+\t  DECL_IGNORED_P (x) = 1;\n+\t  DECL_IN_AGGR_P (mfptr) = 1;\n+\t  if (! mfptr_list)\n+\t    mfptr_list = last_mfptr = mfptr;\n+\t  else\n \t    {\n-\t      mfptr = build_member_function_pointer (x);\n-\t      DECL_MEMFUNC_POINTER_TO (x) = mfptr;\n-\t      DECL_MEMFUNC_POINTING_TO (mfptr) = x;\n-\t      DECL_IGNORED_P (x) = 1;\n-\t      DECL_IN_AGGR_P (mfptr) = 1;\n-\t      if (! mfptr_list)\n-\t\tmfptr_list = last_mfptr = mfptr;\n-\t      else\n-\t\t{\n-\t\t  TREE_CHAIN (last_mfptr) = mfptr;\n-\t\t  last_mfptr = mfptr;\n-\t\t}\n+\t      TREE_CHAIN (last_mfptr) = mfptr;\n+\t      last_mfptr = mfptr;\n \t    }\n-\t  last_x = x;\n \t}\n     }\n \n-  /* Append the lists.  */\n-  if (last_x && mfptr_list)\n-    {\n-      TREE_CHAIN (last_x) = mfptr_list;\n-      TREE_CHAIN (last_mfptr) = NULL_TREE;\n-    }\n+  /* The member function pointers must come after the TYPE_DECLs, in\n+     this case, because build_signature_table_constructor depends on\n+     finding opaque TYPE_DECLS before the functions that make use of\n+     them.  */\n+  if (last_mfptr)\n+    TYPE_FIELDS (t) = chainon (TYPE_FIELDS (t), mfptr_list);\n }\n \n /* Compare the types of a signature member function and a class member"}, {"sha": "1f55e56b1d8ba80b221373dee352962728eb374d", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 18, "deletions": 1, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1581,6 +1581,10 @@ search_tree (t, func)\n     case DEFAULT_ARG:\n       break;\n \n+    case PTRMEM_CST:\n+      TRY (TREE_TYPE (t));\n+      break;\n+\n     case COND_EXPR:\n     case TARGET_EXPR:\n     case AGGR_INIT_EXPR:\n@@ -1845,6 +1849,12 @@ mapcar (t, func)\n     case STRING_CST:\n       return copy_node (t);\n \n+    case PTRMEM_CST:\n+      t = copy_node (t);\n+      TREE_TYPE (t) = mapcar (TREE_TYPE (t), func);\n+      PTRMEM_CST_MEMBER (t) = mapcar (PTRMEM_CST_MEMBER (t), func);\n+      return t;\n+\n     case COND_EXPR:\n     case TARGET_EXPR:\n     case AGGR_INIT_EXPR:\n@@ -1908,7 +1918,7 @@ mapcar (t, func)\n       TREE_OPERAND (t, 1) = mapcar (TREE_OPERAND (t, 1), func);\n \n       /* tree.def says that operand two is RTL, but\n-\t build_call_declarator puts trees in there.  */\n+\t make_call_declarator puts trees in there.  */\n       if (TREE_OPERAND (t, 2)\n \t  && TREE_CODE (TREE_OPERAND (t, 2)) == TREE_LIST)\n \tTREE_OPERAND (t, 2) = mapcar (TREE_OPERAND (t, 2), func);\n@@ -2449,6 +2459,13 @@ cp_tree_equal (t1, t2)\n \treturn comptypes (TREE_OPERAND (t1, 0), TREE_OPERAND (t2, 0), 1);\n       break;\n \n+    case PTRMEM_CST:\n+      /* Two pointer-to-members are the same if they point to the same\n+\t field or function in the same class.  */\n+      return (PTRMEM_CST_MEMBER (t1) == PTRMEM_CST_MEMBER (t2)\n+\t      && comptypes (PTRMEM_CST_CLASS (t1), PTRMEM_CST_CLASS (t2),\n+\t\t\t    1));\n+\n     default:\n       break;\n     }"}, {"sha": "02a8c84c06d85960f305edf222cbfd59e69c1a1b", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -4884,7 +4884,6 @@ unary_complex_lvalue (code, arg)\n       else\n \t{\n \t  tree type;\n-\t  tree offset;\n \n \t  if (TREE_OPERAND (arg, 0)\n \t      && (TREE_CODE (TREE_OPERAND (arg, 0)) != NOP_EXPR\n@@ -4896,21 +4895,13 @@ unary_complex_lvalue (code, arg)\n \t      return error_mark_node;\n \t    }\n \n-\t  /* Add in the offset to the field.  */\n-\t  offset = convert (sizetype,\n-\t\t\t    size_binop (EASY_DIV_EXPR,\n-\t\t\t\t\tDECL_FIELD_BITPOS (t),\n-\t\t\t\t\tsize_int (BITS_PER_UNIT)));\n-\n-\t  /* We offset all pointer to data members by 1 so that we can\n-\t     distinguish between a null pointer to data member and the first\n-\t     data member of a structure.  */\n-\t  offset = size_binop (PLUS_EXPR, offset, size_int (1));\n-\n \t  type = build_offset_type (DECL_FIELD_CONTEXT (t), TREE_TYPE (t));\n \t  type = build_pointer_type (type);\n \n-\t  return cp_convert (type, offset);\n+\t  t = make_node (PTRMEM_CST);\n+\t  TREE_TYPE (t) = type;\n+\t  PTRMEM_CST_MEMBER (t) = TREE_OPERAND (arg, 1);\n+\t  return t;\n \t}\n     }\n "}, {"sha": "614e73bac53fc8f483fb0ba3da5fb7aa894ae05f", "filename": "gcc/testsuite/g++.old-deja/g++.other/elab1.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Felab1.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -0,0 +1,9 @@\n+typedef struct {} S;\n+\n+S s1;\n+struct S* s2; // ERROR - S is a typedef name\n+\n+template <class T>\n+struct X {\n+  friend class T; // ERROR - T is a template type parameter\n+};"}, {"sha": "5814251f95e762057a06911173eed6ca67d70383", "filename": "gcc/testsuite/g++.old-deja/g++.pt/decl1.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdecl1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdecl1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fdecl1.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -0,0 +1,19 @@\n+struct S {\n+  template <class T>\n+  int f(T), g(T); // ERROR - more than one declarator\n+};\n+\n+template <class T>\n+void x(T), y(T); // ERROR - more than one declarator\n+\n+template <class T>\n+struct S2 \n+{\n+  static int i, j; // OK.\n+};\n+\n+template <class T>\n+int S2<T>::i, S2<T>::j; // ERROR - more than one declarator\n+\n+template <>\n+int S2<int>::i, S2<double>::i;  // ERROR - more than one declarator"}, {"sha": "c2c22c7634e9fe199ff8b3485bc80a251f157943", "filename": "gcc/testsuite/g++.old-deja/g++.pt/friend35.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend35.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend35.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ffriend35.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1,7 +1,7 @@\n // Build don't link:\n \n class foo {\n-  friend void bar<int>(int); // ERROR - must be declared first - XFAIL *-*-*\n+  friend void bar<int>(int); // ERROR - must be declared first\n };\n \n template <typename T> void bar(T);"}, {"sha": "38cf5c7854979ff298b1d13341d47cf677b87c40", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp71.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp71.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp71.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp71.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -3,4 +3,4 @@\n class A\n {\n   template<class T>T epsilon; // ERROR - invalid member template\n-}; // ERROR - the compiler crashes here\n+};"}, {"sha": "c6927d1947219260d6d2439f61418190d7739f39", "filename": "gcc/testsuite/g++.old-deja/g++.pt/ptrmem2.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fptrmem2.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -0,0 +1,43 @@\n+struct S;\n+\n+template <S* (S::*p)()>\n+struct F {\n+  S* f (S& s)\n+    {\n+      return (s.*p)();\n+    }\n+};\n+\n+template <int S::*p>\n+struct D {\n+  void d (S& s)\n+    {\n+      (s.*p) = 3;\n+    }\n+};\n+\n+struct S {\n+  S* g ();\n+  int i;\n+  F<&S::g> fg;\n+  D<&S::i> di;\n+  S* h(), k(F<&S::h>);\n+  F<&S::g> fg2;\n+  D<&S::i> di2;\n+};\n+\n+S* S::g()\n+{\n+  return this;\n+}\n+\n+int main()\n+{\n+  S s;\n+  s.i = 2;\n+  s.di.d (s);\n+  if (s.i != 3)\n+    return 1;\n+  if (s.fg2.f(s) != &s)\n+    return 1;\n+}"}, {"sha": "5c99f772ad97dc1e03df473082a9f1ded8d68b25", "filename": "gcc/testsuite/g++.old-deja/g++.pt/t05.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Ft05.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -1,9 +1,9 @@\n // Build don't link: \n \n-template <class A> class B {    // ERROR - candidates\n+template <class A> class B {   \n   A a;                          \n  public:\n   B(A&aa);\t\t\t// ERROR - near match\n   ~B();\n-};\n+};  // ERROR - candidates\n static B<int> b_int (3);\t// ERROR - no matching function"}, {"sha": "ccd206b0e2c4e6e1c20eb8b45bd63373170eab17", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb109.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb109.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -17,7 +17,7 @@ inline istream& operator>>(istream& is, Empty& ) { return is;}\n \n template<class VertexType, class EdgeType>\n class Graph\n-{ // ERROR - candidates\n+{ \n   public:\n     // public type interface\n     typedef map<int, EdgeType > Successor;\n@@ -32,7 +32,7 @@ class Graph\n     bool directed;\n     GraphType C;          // container\n     ostream* pOut;\n-};      // class Graph\n+}; // ERROR - candidates\n \n // all graph-methods delet\n template<class VertexType, class EdgeType>"}, {"sha": "95c454eaef139175c4ddd039abd8590e66342fb1", "filename": "gcc/testsuite/g++.old-deja/g++.robertl/eb49.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/61a127b3d1302417e21b679e70362ae5b16160db/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.robertl%2Feb49.C?ref=61a127b3d1302417e21b679e70362ae5b16160db", "patch": "@@ -22,7 +22,7 @@ class X\n {\n public:\n   static T *do_something ();\n-  friend class T;\n+  friend class T; // ERROR - `T' is a template parameter\n   friend class XX<T, U>;\n };\n "}]}