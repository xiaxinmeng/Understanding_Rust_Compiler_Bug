{"sha": "df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGY0MWRiYWY3ZWFlOGRjYjA4NDFiNjI2NDdmNzUwNGVkMTNhMWQ2NA==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-10-23T15:10:09Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-10-23T15:10:09Z"}, "message": "i386.c (dimode_scalar_chain::compute_convert_gain): Use xmm_move instead of sse_move.\n\n\n\t* i386.c (dimode_scalar_chain::compute_convert_gain): Use\n\txmm_move instead of sse_move.\n\t(sse_store_index): New function.\n\t(ix86_register_move_cost): Be more sensible about mismatch stall;\n\tmodel AVX moves correctly; make difference between sse->integer and\n\tinteger->sse.\n\t(ix86_builtin_vectorization_cost): Model correctly aligned and unaligned\n\tmoves; make difference between SSE and AVX.\n\t* i386.h (processor_costs): Remove sse_move; add xmm_move, ymm_move\n\tand zmm_move. Increase size of sse load and store tables;\n\tadd unaligned load and store tables; add ssemmx_to_integer.\n\t* x86-tune-costs.h: Update all entries according to real \n\tmove latencies from Agner Fog's manual and chip documentation.\n\nFrom-SVN: r254012", "tree": {"sha": "231d0369100a82c6aaacef580a138587db0e8b3d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/231d0369100a82c6aaacef580a138587db0e8b3d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/comments", "author": null, "committer": null, "parents": [{"sha": "47a6cc4e2932003063c2b56021f4b31bdeb5f746", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47a6cc4e2932003063c2b56021f4b31bdeb5f746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47a6cc4e2932003063c2b56021f4b31bdeb5f746"}], "stats": {"total": 749, "additions": 456, "deletions": 293}, "files": [{"sha": "be739723a358b0e71a32fd4e16dd14259030d858", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "patch": "@@ -1,3 +1,19 @@\n+2017-10-23  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* i386.c (dimode_scalar_chain::compute_convert_gain): Use\n+\txmm_move instead of sse_move.\n+\t(sse_store_index): New function.\n+\t(ix86_register_move_cost): Be more sensible about mismatch stall;\n+\tmodel AVX moves correctly; make difference between sse->integer and\n+\tinteger->sse.\n+\t(ix86_builtin_vectorization_cost): Model correctly aligned and unaligned\n+\tmoves; make difference between SSE and AVX.\n+\t* i386.h (processor_costs): Remove sse_move; add xmm_move, ymm_move\n+\tand zmm_move. Increase size of sse load and store tables;\n+\tadd unaligned load and store tables; add ssemmx_to_integer.\n+\t* x86-tune-costs.h: Update all entries according to real \n+\tmove latencies from Agner Fog's manual and chip documentation.\n+\n 2017-10-23  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/82628"}, {"sha": "b182cc6c0eeaa48ddb272d18932485cea3f006c4", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 51, "deletions": 24, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "patch": "@@ -1601,7 +1601,7 @@ dimode_scalar_chain::compute_convert_gain ()\n       rtx dst = SET_DEST (def_set);\n \n       if (REG_P (src) && REG_P (dst))\n-\tgain += COSTS_N_INSNS (2) - ix86_cost->sse_move;\n+\tgain += COSTS_N_INSNS (2) - ix86_cost->xmm_move;\n       else if (REG_P (src) && MEM_P (dst))\n \tgain += 2 * ix86_cost->int_store[2] - ix86_cost->sse_store[1];\n       else if (MEM_P (src) && REG_P (dst))\n@@ -38634,6 +38634,28 @@ ix86_can_change_mode_class (machine_mode from, machine_mode to,\n   return true;\n }\n \n+/* Return index of MODE in the sse load/store tables.  */\n+\n+static inline int\n+sse_store_index (machine_mode mode)\n+{\n+      switch (GET_MODE_SIZE (mode))\n+\t{\n+\t  case 4:\n+\t    return 0;\n+\t  case 8:\n+\t    return 1;\n+\t  case 16:\n+\t    return 2;\n+\t  case 32:\n+\t    return 3;\n+\t  case 64:\n+\t    return 4;\n+\t  default:\n+\t    return -1;\n+\t}\n+}\n+\n /* Return the cost of moving data of mode M between a\n    register and memory.  A value of 2 is the default; this cost is\n    relative to those in `REGISTER_MOVE_COST'.\n@@ -38677,21 +38699,9 @@ inline_memory_move_cost (machine_mode mode, enum reg_class regclass,\n     }\n   if (SSE_CLASS_P (regclass))\n     {\n-      int index;\n-      switch (GET_MODE_SIZE (mode))\n-\t{\n-\t  case 4:\n-\t    index = 0;\n-\t    break;\n-\t  case 8:\n-\t    index = 1;\n-\t    break;\n-\t  case 16:\n-\t    index = 2;\n-\t    break;\n-\t  default:\n-\t    return 100;\n-\t}\n+      int index = sse_store_index (mode);\n+      if (index == -1)\n+\treturn 100;\n       if (in == 2)\n         return MAX (ix86_cost->sse_load [index], ix86_cost->sse_store [index]);\n       return in ? ix86_cost->sse_load [index] : ix86_cost->sse_store [index];\n@@ -38794,8 +38804,10 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n       /* In case of copying from general_purpose_register we may emit multiple\n          stores followed by single load causing memory size mismatch stall.\n          Count this as arbitrarily high cost of 20.  */\n-      if (targetm.class_max_nregs (class1, mode)\n-\t  > targetm.class_max_nregs (class2, mode))\n+      if (GET_MODE_BITSIZE (mode) > BITS_PER_WORD\n+\t  && TARGET_MEMORY_MISMATCH_STALL\n+\t  && targetm.class_max_nregs (class1, mode)\n+\t     > targetm.class_max_nregs (class2, mode))\n \tcost += 20;\n \n       /* In the case of FP/MMX moves, the registers actually overlap, and we\n@@ -38817,12 +38829,19 @@ ix86_register_move_cost (machine_mode mode, reg_class_t class1_i,\n        where integer modes in MMX/SSE registers are not tieable\n        because of missing QImode and HImode moves to, from or between\n        MMX/SSE registers.  */\n-    return MAX (8, ix86_cost->mmxsse_to_integer);\n+    return MAX (8, MMX_CLASS_P (class1) || MMX_CLASS_P (class2)\n+\t\t? ix86_cost->mmxsse_to_integer : ix86_cost->ssemmx_to_integer);\n \n   if (MAYBE_FLOAT_CLASS_P (class1))\n     return ix86_cost->fp_move;\n   if (MAYBE_SSE_CLASS_P (class1))\n-    return ix86_cost->sse_move;\n+    {\n+      if (GET_MODE_BITSIZE (mode) <= 128)\n+\treturn ix86_cost->xmm_move;\n+      if (GET_MODE_BITSIZE (mode) <= 256)\n+\treturn ix86_cost->ymm_move;\n+      return ix86_cost->zmm_move;\n+    }\n   if (MAYBE_MMX_CLASS_P (class1))\n     return ix86_cost->mmx_move;\n   return 2;\n@@ -44370,6 +44389,7 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n {\n   bool fp = false;\n   machine_mode mode = TImode;\n+  int index;\n   if (vectype != NULL)\n     {\n       fp = FLOAT_TYPE_P (vectype);\n@@ -44397,13 +44417,16 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \t\t\t      true);\n \n       case vector_load:\n+\tindex = sse_store_index (mode);\n+\tgcc_assert (index >= 0);\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_load[2]) / 2,\n+\t\t\t      COSTS_N_INSNS (ix86_cost->sse_load[index]) / 2,\n \t\t\t      true);\n \n       case vector_store:\n+\tindex = sse_store_index (mode);\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_store[2]) / 2,\n+\t\t\t      COSTS_N_INSNS (ix86_cost->sse_store[index]) / 2,\n \t\t\t      true);\n \n       case vec_to_scalar:\n@@ -44414,14 +44437,18 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \t Do that incrementally.  */\n       case unaligned_load:\n       case vector_gather_load:\n+\tindex = sse_store_index (mode);\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_load[2]),\n+\t\t\t      COSTS_N_INSNS\n+\t\t\t\t (ix86_cost->sse_unaligned_load[index]) / 2,\n \t\t\t      true);\n \n       case unaligned_store:\n       case vector_scatter_store:\n+\tindex = sse_store_index (mode);\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_store[2]),\n+\t\t\t      COSTS_N_INSNS\n+\t\t\t\t (ix86_cost->sse_unaligned_store[index]) / 2,\n \t\t\t      true);\n \n       case cond_branch_taken:"}, {"sha": "27fc9f08cc73ef239b6e62c447e2f1c9204546c2", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "patch": "@@ -242,13 +242,17 @@ struct processor_costs {\n \t\t\t\t   in SImode and DImode */\n   const int mmx_store[2];\t/* cost of storing MMX register\n \t\t\t\t   in SImode and DImode */\n-  const int sse_move;\t\t/* cost of moving SSE register.  */\n-  const int sse_load[3];\t/* cost of loading SSE register\n-\t\t\t\t   in SImode, DImode and TImode*/\n-  const int sse_store[3];\t/* cost of storing SSE register\n-\t\t\t\t   in SImode, DImode and TImode*/\n+  const int xmm_move, ymm_move, /* cost of moving XMM and YMM register.  */\n+\t    zmm_move;\n+  const int sse_load[5];\t/* cost of loading SSE register\n+\t\t\t\t   in 32bit, 64bit, 128bit, 256bit and 512bit */\n+  const int sse_unaligned_load[5];/* cost of unaligned load.  */\n+  const int sse_store[5];\t/* cost of storing SSE register\n+\t\t\t\t   in SImode, DImode and TImode.  */\n+  const int sse_unaligned_store[5];/* cost of unaligned store.  */\n   const int mmxsse_to_integer;\t/* cost of moving mmxsse register to\n-\t\t\t\t   integer and vice versa.  */\n+\t\t\t\t   integer.  */\n+  const int ssemmx_to_integer;  /* cost of moving integer to mmxsse register. */\n   const int l1_cache_size;\t/* size of l1 cache, in kilobytes.  */\n   const int l2_cache_size;\t/* size of l2 cache, in kilobytes.  */\n   const int prefetch_block;\t/* bytes moved to cache for prefetch.  */"}, {"sha": "e31d7cef2ebf488975003a8d8779dcf94ec9ba63", "filename": "gcc/config/i386/x86-tune-costs.h", "status": "modified", "additions": 379, "deletions": 263, "changes": 642, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df41dbaf7eae8dcb0841b62647f7504ed13a1d64/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fx86-tune-costs.h?ref=df41dbaf7eae8dcb0841b62647f7504ed13a1d64", "patch": "@@ -1,4 +1,26 @@\n+/* Costs of operations of individual x86 CPUs.\n+   Copyright (C) 1988-2017 Free Software Foundation, Inc.\n \n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n /* Processor costs (relative to an add) */\n /* We assume COSTS_N_INSNS is defined as (N)*4 and an addition is 2 bytes.  */\n #define COSTS_N_BYTES(N) ((N) * 2)\n@@ -33,6 +55,8 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n   COSTS_N_BYTES (3),\t\t\t/* cost of movzx */\n   0,\t\t\t\t\t/* \"large\" insn */\n   2,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2. */\n   2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -48,12 +72,16 @@ struct processor_costs ix86_size_cost = {/* costs for tuning for size */\n \t\t\t\t\t   in SImode and DImode */\n   {3, 3},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  3,\t\t\t\t\t/* cost of moving SSE register */\n-  {3, 3, 3},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {3, 3, 3},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  3, 3, 3,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of unaligned SSE load\n+\t\t\t\t\t   in 128bit, 256bit and 512bit */\n+  {3, 3, 3, 3, 3},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {3, 3, 3, 3, 3},\t\t\t\t/* cost of unaligned SSE store\n+\t\t\t\t\t   in 128bit, 256bit and 512bit */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   0,\t\t\t\t\t/* size of l1 cache  */\n   0,\t\t\t\t\t/* size of l2 cache  */\n   0,\t\t\t\t\t/* size of prefetch block */\n@@ -112,6 +140,9 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -127,12 +158,14 @@ struct processor_costs i386_cost = {\t/* 386 specific costs */\n \t\t\t\t\t   in SImode and DImode */\n   {4, 8},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   0,\t\t\t\t\t/* size of l1 cache  */\n   0,\t\t\t\t\t/* size of l2 cache  */\n   0,\t\t\t\t\t/* size of prefetch block */\n@@ -190,6 +223,9 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   15,\t\t\t\t\t/* \"large\" insn */\n   3,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -205,12 +241,14 @@ struct processor_costs i486_cost = {\t/* 486 specific costs */\n \t\t\t\t\t   in SImode and DImode */\n   {4, 8},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   4,\t\t\t\t\t/* size of l1 cache.  486 has 8kB cache\n \t\t\t\t\t   shared for code and data, so 4kB is\n \t\t\t\t\t   not really precise.  */\n@@ -270,6 +308,9 @@ struct processor_costs pentium_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -285,12 +326,14 @@ struct processor_costs pentium_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {8, 8},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n   8,\t\t\t\t\t/* size of l2 cache  */\n   0,\t\t\t\t\t/* size of prefetch block */\n@@ -341,6 +384,9 @@ struct processor_costs lakemont_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {2, 4, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -356,12 +402,14 @@ struct processor_costs lakemont_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {8, 8},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 8, 16},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 8, 16},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n   8,\t\t\t\t\t/* size of l2 cache  */\n   0,\t\t\t\t\t/* size of prefetch block */\n@@ -427,6 +475,9 @@ struct processor_costs pentiumpro_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   2,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -442,12 +493,14 @@ struct processor_costs pentiumpro_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {2, 2},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 8, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache  */\n   32,\t\t\t\t\t/* size of prefetch block */\n@@ -504,13 +557,16 @@ struct processor_costs geode_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n-  1,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {1, 1, 1},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {2, 2, 2},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {1, 1, 1},\t\t\t\t/* cost of storing integer registers */\n-  1,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {1, 1, 1},\t\t\t\t/* cost of loading fp registers\n+  {2, 2, 2},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {2, 2, 2},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n   {4, 6, 6},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n@@ -520,12 +576,14 @@ struct processor_costs geode_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {2, 2},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned loads.  */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned stores.  */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   128,\t\t\t\t\t/* size of l2 cache.  */\n   32,\t\t\t\t\t/* size of prefetch block */\n@@ -582,6 +640,9 @@ struct processor_costs k6_cost = {\n   COSTS_N_INSNS (2),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   4,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   3,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -597,12 +658,14 @@ struct processor_costs k6_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {2, 2},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {2, 2, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  6,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned loads.  */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {2, 2, 8, 16, 32},\t\t\t/* cost of unaligned stores.  */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   32,\t\t\t\t\t/* size of l2 cache.  Some models\n \t\t\t\t\t   have integrated l2 cache, but\n@@ -665,6 +728,9 @@ struct processor_costs athlon_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -680,12 +746,14 @@ struct processor_costs athlon_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {4, 4},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 4, 6, 12, 24},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 6, 12, 24},\t\t\t/* cost of unaligned loads.  */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of unaligned stores.  */\n+  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -750,6 +818,9 @@ struct processor_costs k8_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -765,12 +836,14 @@ struct processor_costs k8_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {4, 4},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 3, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 3, 6, 12, 24},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 3, 6, 12, 24},\t\t\t/* cost of unaligned loads.  */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of unaligned stores.  */\n+  5, 5,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -839,6 +912,9 @@ struct processor_costs amdfam10_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -854,12 +930,14 @@ struct processor_costs amdfam10_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {4, 4},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 3},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {4, 4, 3, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 3, 7, 12},\t\t\t/* cost of unaligned loads.  */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {4, 4, 5, 10, 20},\t\t\t/* cost of unaligned stores.  */\n+  3, 3,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   \t\t\t\t\t/* On K8:\n   \t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n \t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n@@ -937,35 +1015,32 @@ const struct processor_costs bdver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {5, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {5, 5, 12},\t\t\t\t/* cost of loading fp registers\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 8},\t\t\t\t/* cost of storing fp registers\n+  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n  \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 4},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 4},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n-  \t\t\t\t\t/* On K8:\n-\t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n-\t\t\t\t\t   On AMDFAM10:\n-\t\t\t\t\t    MOVD reg64, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1 */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n+  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   16,\t\t\t\t\t/* size of l1 cache.  */\n   2048,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1037,35 +1112,32 @@ const struct processor_costs bdver2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {5, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {5, 5, 12},\t\t\t\t/* cost of loading fp registers\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 8},\t\t\t\t/* cost of storing fp registers\n+  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n  \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 4},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 4},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n-  \t\t\t\t\t/* On K8:\n-\t\t\t\t\t    MOVD reg64, xmmreg Double FSTORE 4\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FSTORE 4\n-\t\t\t\t\t   On AMDFAM10:\n-\t\t\t\t\t    MOVD reg64, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1 */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n+  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   16,\t\t\t\t\t/* size of l1 cache.  */\n   2048,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1136,27 +1208,32 @@ struct processor_costs bdver3_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {5, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {5, 5, 12},\t\t\t\t/* cost of loading fp registers\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 8},\t\t\t\t/* cost of storing fp registers\n+  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n  \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 4},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 4},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n+  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   16,\t\t\t\t\t/* size of l1 cache.  */\n   2048,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1226,27 +1303,32 @@ struct processor_costs bdver4_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {5, 5, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {5, 5, 12},\t\t\t\t/* cost of loading fp registers\n+  {8, 8, 8},\t\t\t\t/* cost of storing integer registers */\n+  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 8},\t\t\t\t/* cost of storing fp registers\n+  {10, 10, 18},\t\t\t\t/* cost of storing fp registers\n  \t\t   \t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {4, 4},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {12, 12},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 4},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {12, 12, 10, 20, 30},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 20, 30},\t\t\t/* cost of unaligned stores.  */\n+  16, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   16,\t\t\t\t\t/* size of l1 cache.  */\n   2048,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1321,6 +1403,9 @@ struct processor_costs znver1_cost = {\n   8,\t\t\t\t\t/* \"large\" insn.  */\n   9,\t\t\t\t\t/* MOVE_RATIO.  */\n \n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+\n   /* reg-reg moves are done by renaming and thus they are even cheaper than\n      1 cycle. Becuase reg-reg move cost is 2 and the following tables correspond\n      to doubles of latencies, we do not model this correctly.  It does not\n@@ -1342,12 +1427,14 @@ struct processor_costs znver1_cost = {\n \t\t\t\t\t   in SImode and DImode.  */\n   {8, 8},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode.  */\n-  2,\t\t\t\t\t/* cost of moving SSE register.  */\n-  {6, 6, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode.  */\n-  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode.  */\n-  6,\t\t\t\t\t/* MMX or SSE register to integer.  */\n+  2, 3, 6,\t\t\t\t/* cost of moving XMM,YMM,ZMM register.  */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  {6, 6, 6, 10, 20},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit.  */\n+  {8, 8, 8, 8, 16},\t\t\t/* cost of unaligned stores.  */\n+  6, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves.  */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block.  */\n@@ -1426,35 +1513,32 @@ const struct processor_costs btver1_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {6, 8, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  {6, 8, 6},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {10, 10},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {12, 12},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 3},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n-\t\t\t\t\t/* On K8:\n-\t\t\t\t\t   MOVD reg64, xmmreg Double FSTORE 4\n-\t\t\t\t\t   MOVD reg32, xmmreg Double FSTORE 4\n-\t\t\t\t\t   On AMDFAM10:\n-\t\t\t\t\t   MOVD reg64, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1 */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of unaligned stores.  */\n+  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1514,35 +1598,32 @@ const struct processor_costs btver2_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   9,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t     /* cost for loading QImode using movzbl */\n-  {3, 4, 3},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t     /* cost for loading QImode using movzbl */\n+  {8, 8, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {3, 4, 3},\t\t\t\t/* cost of storing integer registers */\n+  {8, 8, 6},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {4, 4, 12},\t\t\t\t/* cost of loading fp registers\n+  {12, 12, 28},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+  {12, 12, 38},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {3, 3},\t\t\t\t/* cost of loading MMX registers\n+  4,\t\t\t\t\t/* cost of moving MMX register */\n+  {10, 10},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {4, 4},\t\t\t\t/* cost of storing MMX registers\n+  {12, 12},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {4, 4, 3},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {4, 4, 5},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  3,\t\t\t\t\t/* MMX or SSE register to integer */\n-\t\t\t\t\t/* On K8:\n-\t\t\t\t\t   MOVD reg64, xmmreg Double FSTORE 4\n-\t\t\t\t\t   MOVD reg32, xmmreg Double FSTORE 4\n-\t\t\t\t\t   On AMDFAM10:\n-\t\t\t\t\t   MOVD reg64, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1\n-\t\t\t\t\t    MOVD reg32, xmmreg Double FADD 3\n-\t\t\t\t\t\t\t       1/1  1/1 */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of unaligned loads.  */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 12, 24, 48},\t\t\t/* cost of unaligned stores.  */\n+  14, 14,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   2048,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1601,27 +1682,32 @@ struct processor_costs pentium4_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   6,\t\t\t\t\t/* MOVE_RATIO */\n-  2,\t\t\t\t     /* cost for loading QImode using movzbl */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  5,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 5, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {2, 3, 2},\t\t\t\t/* cost of storing integer registers */\n-  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {2, 2, 6},\t\t\t\t/* cost of loading fp registers\n+  12,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {14, 14, 14},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 6},\t\t\t\t/* cost of storing fp registers\n+  {14, 14, 14},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  2,\t\t\t\t\t/* cost of moving MMX register */\n-  {2, 2},\t\t\t\t/* cost of loading MMX registers\n+  12,\t\t\t\t\t/* cost of moving MMX register */\n+  {16, 16},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {2, 2},\t\t\t\t/* cost of storing MMX registers\n+  {16, 16},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  12,\t\t\t\t\t/* cost of moving SSE register */\n-  {12, 12, 12},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {2, 2, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  10,\t\t\t\t\t/* MMX or SSE register to integer */\n+  12, 24, 48,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {32, 32, 32, 64, 128},\t\t/* cost of unaligned loads.  */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {32, 32, 32, 64, 128},\t\t/* cost of unaligned stores.  */\n+  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1683,27 +1769,32 @@ struct processor_costs nocona_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   16,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n   {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  3,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+  12,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {14, 14, 14},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {4, 4, 4},\t\t\t\t/* cost of storing fp registers\n+  {14, 14, 14},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  6,\t\t\t\t\t/* cost of moving MMX register */\n+  14,\t\t\t\t\t/* cost of moving MMX register */\n   {12, 12},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n   {12, 12},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  6,\t\t\t\t\t/* cost of moving SSE register */\n-  {12, 12, 12},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {12, 12, 12},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  8,\t\t\t\t\t/* MMX or SSE register to integer */\n+  6, 12, 24,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {24, 24, 24, 48, 96},\t\t\t/* cost of unaligned loads.  */\n+  {12, 12, 12, 24, 48},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {24, 24, 24, 48, 96},\t\t\t/* cost of unaligned stores.  */\n+  20, 12,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   8,\t\t\t\t\t/* size of l1 cache.  */\n   1024,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1763,27 +1854,32 @@ struct processor_costs atom_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n-  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  6,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {6, 6, 6},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n   4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+  {6, 6, 18},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+  {14, 14, 24},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n   2,\t\t\t\t\t/* cost of moving MMX register */\n   {8, 8},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+  {10, 10},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1843,27 +1939,32 @@ struct processor_costs slm_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n-  4,\t\t\t\t\t/* cost for loading QImode using movzbl */\n-  {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n+  8,\t\t\t\t\t/* cost for loading QImode using movzbl */\n+  {8, 8, 8},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n \t\t\t\t\t   Relative to reg-reg move (2).  */\n-  {4, 4, 4},\t\t\t\t/* cost of storing integer registers */\n-  4,\t\t\t\t\t/* cost of reg,reg fld/fst */\n-  {12, 12, 12},\t\t\t\t/* cost of loading fp registers\n+  {6, 6, 6},\t\t\t\t/* cost of storing integer registers */\n+  2,\t\t\t\t\t/* cost of reg,reg fld/fst */\n+  {8, 8, 18},\t\t\t\t/* cost of loading fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n-  {6, 6, 8},\t\t\t\t/* cost of storing fp registers\n+  {6, 6, 18},\t\t\t\t/* cost of storing fp registers\n \t\t\t\t\t   in SFmode, DFmode and XFmode */\n   2,\t\t\t\t\t/* cost of moving MMX register */\n   {8, 8},\t\t\t\t/* cost of loading MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  {8, 8},\t\t\t\t/* cost of storing MMX registers\n+  {6, 6},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {8, 8, 8},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {8, 8, 8},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  5,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 4, 8,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned loads.  */\n+  {8, 8, 8, 16, 32},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {16, 16, 16, 32, 64},\t\t\t/* cost of unaligned stores.  */\n+  8, 6,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -1923,6 +2024,9 @@ struct processor_costs intel_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -1938,12 +2042,14 @@ struct processor_costs intel_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {6, 6},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {6, 6, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {6, 6, 6},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 2, 2,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 10, 10},\t\t\t/* cost of unaligned loads.  */\n+  {6, 6, 6, 6, 6},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 10, 10},\t\t\t/* cost of unaligned loads.  */\n+  4, 4,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   256,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -2010,6 +2116,9 @@ struct processor_costs generic_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   4,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -2025,12 +2134,14 @@ struct processor_costs generic_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {6, 6},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {6, 6, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {6, 6, 6},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  6,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 3, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 15, 20},\t\t\t/* cost of unaligned loads.  */\n+  {6, 6, 6, 10, 15},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {10, 10, 10, 15, 20},\t\t\t/* cost of unaligned storess.  */\n+  20, 20,\t\t\t\t/* SSE->integer and integer->SSE moves */\n   32,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */\n@@ -2102,6 +2213,9 @@ struct processor_costs core_cost = {\n   COSTS_N_INSNS (1),\t\t\t/* cost of movzx */\n   8,\t\t\t\t\t/* \"large\" insn */\n   17,\t\t\t\t\t/* MOVE_RATIO */\n+\n+  /* All move costs are relative to integer->integer move times 2 and thus\n+     they are latency*2. */\n   6,\t\t\t\t     /* cost for loading QImode using movzbl */\n   {4, 4, 4},\t\t\t\t/* cost of loading integer registers\n \t\t\t\t\t   in QImode, HImode and SImode.\n@@ -2117,12 +2231,14 @@ struct processor_costs core_cost = {\n \t\t\t\t\t   in SImode and DImode */\n   {6, 6},\t\t\t\t/* cost of storing MMX registers\n \t\t\t\t\t   in SImode and DImode */\n-  2,\t\t\t\t\t/* cost of moving SSE register */\n-  {6, 6, 6},\t\t\t\t/* cost of loading SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  {6, 6, 6},\t\t\t\t/* cost of storing SSE registers\n-\t\t\t\t\t   in SImode, DImode and TImode */\n-  2,\t\t\t\t\t/* MMX or SSE register to integer */\n+  2, 2, 4,\t\t\t\t/* cost of moving XMM,YMM,ZMM register */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of loading SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned loads.  */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of storing SSE registers\n+\t\t\t\t\t   in 32,64,128,256 and 512-bit */\n+  {6, 6, 6, 6, 12},\t\t\t/* cost of unaligned stores.  */\n+  2, 2,\t\t\t\t\t/* SSE->integer and integer->SSE moves */\n   64,\t\t\t\t\t/* size of l1 cache.  */\n   512,\t\t\t\t\t/* size of l2 cache.  */\n   64,\t\t\t\t\t/* size of prefetch block */"}]}