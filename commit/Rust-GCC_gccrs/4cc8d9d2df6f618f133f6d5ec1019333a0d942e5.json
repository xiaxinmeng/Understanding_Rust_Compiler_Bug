{"sha": "4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNjOGQ5ZDJkZjZmNjE4ZjEzM2Y2ZDVlYzEwMTkzMzNhMGQ5NDJlNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-05-27T10:06:22Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-27T10:06:22Z"}, "message": "system.h (TEST_BIT): New macro.\n\ngcc/\n\t* system.h (TEST_BIT): New macro.\n\t* recog.h (alternative_mask): New type.\n\t(ALL_ALTERNATIVES, ALTERNATIVE_BIT): New macros.\n\t(recog_data_d): Replace alternative_enabled_p array with\n\tenabled_alternatives.\n\t(target_recog): New structure.\n\t(default_target_recog, this_target_recog): Declare.\n\t(get_enabled_alternatives, recog_init): Likewise.\n\t* recog.c (default_target_recog, this_target_recog): New variables.\n\t(get_enabled_alternatives): New function.\n\t(extract_insn): Use it.\n\t(recog_init): New function.\n\t(preprocess_constraints, constrain_operands): Adjust for change to\n\trecog_data.\n\t* postreload.c (reload_cse_simplify_operands): Likewise.\n\t* reload.c (find_reloads): Likewise.\n\t* ira-costs.c (record_reg_classes): Likewise.\n\t* ira-lives.c (single_reg_class): Likewise.  Fix bug in which\n\tall alternatives after a disabled one would be skipped.\n\t(ira_implicitly_set_insn_hard_regs): Likewise.\n\t* ira.c (ira_setup_alts): Adjust for change to recog_data.\n\t* lra-int.h (lra_insn_recog_data): Replace alternative_enabled_p\n\twith enabled_alternatives.\n\t* lra.c (free_insn_recog_data): Update accordingly.\n\t(lra_update_insn_recog_data): Likewise.\n\t(lra_set_insn_recog_data): Likewise.  Use get_enabled_alternatives.\n\t* lra-constraints.c (process_alt_operands): Likewise.  Handle\n\tonly_alternative as part of the enabled mask.\n\t* target-globals.h (this_target_recog): Declare.\n\t(target_globals): Add a recog field.\n\t(restore_target_globals): Restore this_target_recog.\n\t* target-globals.c: Include recog.h.\n\t(default_target_globals): Initialize recog field.\n\t(save_target_globals): Likewise.\n\t* reginfo.c (reinit_regs): Call recog_init.\n\t* toplev.c (backend_init_target): Likewise.\n\nFrom-SVN: r210964", "tree": {"sha": "5d62ebd89439d627b40ecb8026ad31c4827dbfae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d62ebd89439d627b40ecb8026ad31c4827dbfae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9921417d94eb2b25ed60b1eafaaf5888164221a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9921417d94eb2b25ed60b1eafaaf5888164221a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9921417d94eb2b25ed60b1eafaaf5888164221a4"}], "stats": {"total": 274, "additions": 187, "deletions": 87}, "files": [{"sha": "9343c981c5be2930f42e761e68ac2c64c3ecf577", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -1,3 +1,42 @@\n+2014-05-27  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* system.h (TEST_BIT): New macro.\n+\t* recog.h (alternative_mask): New type.\n+\t(ALL_ALTERNATIVES, ALTERNATIVE_BIT): New macros.\n+\t(recog_data_d): Replace alternative_enabled_p array with\n+\tenabled_alternatives.\n+\t(target_recog): New structure.\n+\t(default_target_recog, this_target_recog): Declare.\n+\t(get_enabled_alternatives, recog_init): Likewise.\n+\t* recog.c (default_target_recog, this_target_recog): New variables.\n+\t(get_enabled_alternatives): New function.\n+\t(extract_insn): Use it.\n+\t(recog_init): New function.\n+\t(preprocess_constraints, constrain_operands): Adjust for change to\n+\trecog_data.\n+\t* postreload.c (reload_cse_simplify_operands): Likewise.\n+\t* reload.c (find_reloads): Likewise.\n+\t* ira-costs.c (record_reg_classes): Likewise.\n+\t* ira-lives.c (single_reg_class): Likewise.  Fix bug in which\n+\tall alternatives after a disabled one would be skipped.\n+\t(ira_implicitly_set_insn_hard_regs): Likewise.\n+\t* ira.c (ira_setup_alts): Adjust for change to recog_data.\n+\t* lra-int.h (lra_insn_recog_data): Replace alternative_enabled_p\n+\twith enabled_alternatives.\n+\t* lra.c (free_insn_recog_data): Update accordingly.\n+\t(lra_update_insn_recog_data): Likewise.\n+\t(lra_set_insn_recog_data): Likewise.  Use get_enabled_alternatives.\n+\t* lra-constraints.c (process_alt_operands): Likewise.  Handle\n+\tonly_alternative as part of the enabled mask.\n+\t* target-globals.h (this_target_recog): Declare.\n+\t(target_globals): Add a recog field.\n+\t(restore_target_globals): Restore this_target_recog.\n+\t* target-globals.c: Include recog.h.\n+\t(default_target_globals): Initialize recog field.\n+\t(save_target_globals): Likewise.\n+\t* reginfo.c (reinit_regs): Call recog_init.\n+\t* toplev.c (backend_init_target): Likewise.\n+\n 2014-05-27  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* gencodes.c (main): Make LAST_INSN_CODE higher than any insn code,"}, {"sha": "46c14ef916140f76662471622d8bd69a57bc0234", "filename": "gcc/ira-costs.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira-costs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira-costs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-costs.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -423,7 +423,7 @@ record_reg_classes (int n_alts, int n_ops, rtx *ops,\n       int alt_fail = 0;\n       int alt_cost = 0, op_cost_add;\n \n-      if (!recog_data.alternative_enabled_p[alt])\n+      if (!TEST_BIT (recog_data.enabled_alternatives, alt))\n \t{\n \t  for (i = 0; i < recog_data.n_operands; i++)\n \t    constraints[i] = skip_alternative (constraints[i]);"}, {"sha": "ffbca3897e16ea969cfe5a402815e0eb7438c03e", "filename": "gcc/ira-lives.c", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira-lives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira-lives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-lives.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -743,22 +743,17 @@ mark_hard_reg_early_clobbers (rtx insn, bool live_p)\n static enum reg_class\n single_reg_class (const char *constraints, rtx op, rtx equiv_const)\n {\n-  int curr_alt, c;\n-  bool ignore_p;\n+  int c;\n   enum reg_class cl, next_cl;\n \n   cl = NO_REGS;\n-  for (ignore_p = false, curr_alt = 0;\n-       (c = *constraints);\n-       constraints += CONSTRAINT_LEN (c, constraints))\n-    if (c == '#' || !recog_data.alternative_enabled_p[curr_alt])\n-      ignore_p = true;\n+  alternative_mask enabled = recog_data.enabled_alternatives;\n+  for (; (c = *constraints); constraints += CONSTRAINT_LEN (c, constraints))\n+    if (c == '#')\n+      enabled &= ~ALTERNATIVE_BIT (0);\n     else if (c == ',')\n-      {\n-\tcurr_alt++;\n-\tignore_p = false;\n-      }\n-    else if (! ignore_p)\n+      enabled >>= 1;\n+    else if (enabled & 1)\n       switch (c)\n \t{\n \tcase ' ':\n@@ -887,8 +882,7 @@ single_reg_operand_class (int op_num)\n void\n ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n {\n-  int i, curr_alt, c, regno = 0;\n-  bool ignore_p;\n+  int i, c, regno = 0;\n   enum reg_class cl;\n   rtx op;\n   enum machine_mode mode;\n@@ -909,17 +903,13 @@ ira_implicitly_set_insn_hard_regs (HARD_REG_SET *set)\n \t  mode = (GET_CODE (op) == SCRATCH\n \t\t  ? GET_MODE (op) : PSEUDO_REGNO_MODE (regno));\n \t  cl = NO_REGS;\n-\t  for (ignore_p = false, curr_alt = 0;\n-\t       (c = *p);\n-\t       p += CONSTRAINT_LEN (c, p))\n-\t    if (c == '#' || !recog_data.alternative_enabled_p[curr_alt])\n-\t      ignore_p = true;\n+\t  alternative_mask enabled = recog_data.enabled_alternatives;\n+\t  for (; (c = *p); p += CONSTRAINT_LEN (c, p))\n+\t    if (c == '#')\n+\t      enabled &= ~ALTERNATIVE_BIT (0);\n \t    else if (c == ',')\n-\t      {\n-\t\tcurr_alt++;\n-\t\tignore_p = false;\n-\t      }\n-\t    else if (! ignore_p)\n+\t      enabled >>= 1;\n+\t    else if (enabled & 1)\n \t      switch (c)\n \t\t{\n \t\tcase 'r':"}, {"sha": "a26f9e42b34320e729407f24a62dba49e5f03e10", "filename": "gcc/ira.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -1844,7 +1844,8 @@ ira_setup_alts (rtx insn, HARD_REG_SET &alts)\n \t}\n       for (nalt = 0; nalt < recog_data.n_alternatives; nalt++)\n \t{\n-\t  if (! recog_data.alternative_enabled_p[nalt] || TEST_HARD_REG_BIT (alts, nalt))\n+\t  if (!TEST_BIT (recog_data.enabled_alternatives, nalt)\n+\t      || TEST_HARD_REG_BIT (alts, nalt))\n \t    continue;\n \n \t  for (nop = 0; nop < recog_data.n_operands; nop++)"}, {"sha": "2df841a97506bee1166472a5fa8acb26bc20fa95", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -1557,19 +1557,16 @@ process_alt_operands (int only_alternative)\n      together, the second alternatives go together, etc.\n \n      First loop over alternatives.  */\n+  alternative_mask enabled = curr_id->enabled_alternatives;\n+  if (only_alternative >= 0)\n+    enabled &= ALTERNATIVE_BIT (only_alternative);\n+\n   for (nalt = 0; nalt < n_alternatives; nalt++)\n     {\n       /* Loop over operands for one constraint alternative.  */\n-#if HAVE_ATTR_enabled\n-      if (curr_id->alternative_enabled_p != NULL\n-\t  && ! curr_id->alternative_enabled_p[nalt])\n-\tcontinue;\n-#endif\n-\n-      if (only_alternative >= 0 && nalt != only_alternative)\n+      if (!TEST_BIT (enabled, nalt))\n \tcontinue;\n \n-            \n       overall = losers = reject = reload_nregs = reload_sum = 0;\n       for (nop = 0; nop < n_operands; nop++)\n \t{"}, {"sha": "41c98492973950f7b232071f2d15ab2c9a22e2d4", "filename": "gcc/lra-int.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -227,7 +227,7 @@ struct lra_insn_recog_data\n      ending with a negative value.  */\n   int *arg_hard_regs;\n   /* Alternative enabled for the insn.\tNULL for debug insns.  */\n-  bool *alternative_enabled_p;\n+  alternative_mask enabled_alternatives;\n   /* The following member value is always NULL for a debug insn.  */\n   struct lra_insn_reg *regs;\n };"}, {"sha": "ecec8908ca9f3123ec7419a0381cba837284697d", "filename": "gcc/lra.c", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -724,8 +724,6 @@ free_insn_recog_data (lra_insn_recog_data_t data)\n     free (data->dup_loc);\n   if (data->arg_hard_regs != NULL)\n     free (data->arg_hard_regs);\n-  if (HAVE_ATTR_enabled && data->alternative_enabled_p != NULL)\n-    free (data->alternative_enabled_p);\n   if (data->icode < 0 && NONDEBUG_INSN_P (data->insn))\n     {\n       if (data->insn_static_data->operand_alternative != NULL)\n@@ -1072,7 +1070,7 @@ lra_set_insn_recog_data (rtx insn)\n       data->insn_static_data = &debug_insn_static_data;\n       data->dup_loc = NULL;\n       data->arg_hard_regs = NULL;\n-      data->alternative_enabled_p = NULL;\n+      data->enabled_alternatives = ALL_ALTERNATIVES;\n       data->operand_loc = XNEWVEC (rtx *, 1);\n       data->operand_loc[0] = &INSN_VAR_LOCATION_LOC (insn);\n       return data;\n@@ -1132,7 +1130,7 @@ lra_set_insn_recog_data (rtx insn)\n \t  = (insn_static_data->operand[i].constraint[0] == '=' ? OP_OUT\n \t     : insn_static_data->operand[i].constraint[0] == '+' ? OP_INOUT\n \t     : OP_IN);\n-      data->alternative_enabled_p = NULL;\n+      data->enabled_alternatives = ALL_ALTERNATIVES;\n     }\n   else\n     {\n@@ -1159,27 +1157,7 @@ lra_set_insn_recog_data (rtx insn)\n \t  memcpy (locs, recog_data.dup_loc, n * sizeof (rtx *));\n \t}\n       data->dup_loc = locs;\n-      if (HAVE_ATTR_enabled)\n-\t{\n-\t  bool *bp;\n-\n-\t  n = insn_static_data->n_alternatives;\n-\t  lra_assert (n >= 0);\n-\t  data->alternative_enabled_p = bp = XNEWVEC (bool, n);\n-\t  /* Cache the insn because we don't want to call extract_insn\n-\t     from get_attr_enabled as extract_insn modifies\n-\t     which_alternative.  The attribute enabled should not depend\n-\t     on insn operands, operand modes, operand types, and operand\n-\t     constraints.  It should depend on the architecture.  If it\n-\t     is not true, we should rewrite this file code to use\n-\t     extract_insn instead of less expensive insn_extract.  */\n-\t  recog_data.insn = insn;\n-\t  for (i = 0; i < n; i++)\n-\t    {\n-\t      which_alternative = i;\n-\t      bp[i] = get_attr_enabled (insn);\n-\t    }\n-\t}\n+      data->enabled_alternatives = get_enabled_alternatives (insn);\n     }\n   if (GET_CODE (PATTERN (insn)) == CLOBBER || GET_CODE (PATTERN (insn)) == USE)\n     insn_static_data->hard_regs = NULL;\n@@ -1370,18 +1348,19 @@ lra_update_insn_recog_data (rtx insn)\n #ifdef ENABLE_CHECKING\n       {\n \tint i;\n-\tbool *bp;\n+\talternative_mask enabled;\n \n \tn = insn_static_data->n_alternatives;\n-\tbp = data->alternative_enabled_p;\n-\tlra_assert (n >= 0 && bp != NULL);\n+\tenabled = data->enabled_alternatives;\n+\tlra_assert (n >= 0);\n \t/* Cache the insn to prevent extract_insn call from\n \t   get_attr_enabled.  */\n \trecog_data.insn = insn;\n \tfor (i = 0; i < n; i++)\n \t  {\n \t    which_alternative = i;\n-\t    lra_assert (bp[i] == get_attr_enabled (insn));\n+\t    lra_assert (TEST_BIT (enabled, i)\n+\t\t\t== (bool) get_attr_enabled (insn));\n \t  }\n       }\n #endif"}, {"sha": "29ba81b41d54b04b9edc451b8582094c2bc0c0d2", "filename": "gcc/postreload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fpostreload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fpostreload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -584,7 +584,7 @@ reload_cse_simplify_operands (rtx insn, rtx testreg)\n \t\t     alternative yet and the operand being replaced is not\n \t\t     a cheap CONST_INT.  */\n \t\t  if (op_alt_regno[i][j] == -1\n-\t\t      && recog_data.alternative_enabled_p[j]\n+\t\t      && TEST_BIT (recog_data.enabled_alternatives, j)\n \t\t      && reg_fits_class_p (testreg, rclass, 0, mode)\n \t\t      && (!CONST_INT_P (recog_data.operand[i])\n \t\t\t  || (set_src_cost (recog_data.operand[i],"}, {"sha": "c4706940bece9aeb29073b987d376d8a8da5c0a4", "filename": "gcc/recog.c", "status": "modified", "additions": 66, "deletions": 15, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -61,6 +61,11 @@ static void validate_replace_rtx_1 (rtx *, rtx, rtx, rtx, bool);\n static void validate_replace_src_1 (rtx *, void *);\n static rtx split_insn (rtx);\n \n+struct target_recog default_target_recog;\n+#if SWITCHABLE_TARGET\n+struct target_recog *this_target_recog = &default_target_recog;\n+#endif\n+\n /* Nonzero means allow operands to be volatile.\n    This should be 0 if you are generating rtl, such as if you are calling\n    the functions in optabs.c and expmed.c (most of the time).\n@@ -2137,6 +2142,48 @@ mode_dependent_address_p (rtx addr, addr_space_t addrspace)\n   return targetm.mode_dependent_address_p (addr, addrspace);\n }\n \f\n+/* Return the mask of operand alternatives that are allowed for INSN.\n+   This mask depends only on INSN and on the current target; it does not\n+   depend on things like the values of operands.  */\n+\n+alternative_mask\n+get_enabled_alternatives (rtx insn)\n+{\n+  /* Quick exit for asms and for targets that don't use the \"enabled\"\n+     attribute.  */\n+  int code = INSN_CODE (insn);\n+  if (code < 0 || !HAVE_ATTR_enabled)\n+    return ALL_ALTERNATIVES;\n+\n+  /* Calling get_attr_enabled can be expensive, so cache the mask\n+     for speed.  */\n+  if (this_target_recog->x_enabled_alternatives[code])\n+    return this_target_recog->x_enabled_alternatives[code];\n+\n+  /* Temporarily install enough information for get_attr_enabled to assume\n+     that the insn operands are already cached.  As above, the attribute\n+     mustn't depend on the values of operands, so we don't provide their\n+     real values here.  */\n+  rtx old_insn = recog_data.insn;\n+  int old_alternative = which_alternative;\n+\n+  recog_data.insn = insn;\n+  alternative_mask enabled = ALL_ALTERNATIVES;\n+  int n_alternatives = insn_data[code].n_alternatives;\n+  for (int i = 0; i < n_alternatives; i++)\n+    {\n+      which_alternative = i;\n+      if (!get_attr_enabled (insn))\n+\tenabled &= ~ALTERNATIVE_BIT (i);\n+    }\n+\n+  recog_data.insn = old_insn;\n+  which_alternative = old_alternative;\n+\n+  this_target_recog->x_enabled_alternatives[code] = enabled;\n+  return enabled;\n+}\n+\n /* Like extract_insn, but save insn extracted and don't extract again, when\n    called again for the same insn expecting that recog_data still contain the\n    valid information.  This is used primary by gen_attr infrastructure that\n@@ -2269,19 +2316,7 @@ extract_insn (rtx insn)\n \n   gcc_assert (recog_data.n_alternatives <= MAX_RECOG_ALTERNATIVES);\n \n-  if (INSN_CODE (insn) < 0)\n-    for (i = 0; i < recog_data.n_alternatives; i++)\n-      recog_data.alternative_enabled_p[i] = true;\n-  else\n-    {\n-      recog_data.insn = insn;\n-      for (i = 0; i < recog_data.n_alternatives; i++)\n-\t{\n-\t  which_alternative = i;\n-\t  recog_data.alternative_enabled_p[i]\n-\t    = HAVE_ATTR_enabled ? get_attr_enabled (insn) : 1;\n-\t}\n-    }\n+  recog_data.enabled_alternatives = get_enabled_alternatives (insn);\n \n   recog_data.insn = NULL;\n   which_alternative = -1;\n@@ -2314,7 +2349,7 @@ preprocess_constraints (void)\n \t  op_alt[j].matches = -1;\n \t  op_alt[j].matched = -1;\n \n-\t  if (!recog_data.alternative_enabled_p[j])\n+\t  if (!TEST_BIT (recog_data.enabled_alternatives, j))\n \t    {\n \t      p = skip_alternative (p);\n \t      continue;\n@@ -2490,7 +2525,7 @@ constrain_operands (int strict)\n       int lose = 0;\n       funny_match_index = 0;\n \n-      if (!recog_data.alternative_enabled_p[which_alternative])\n+      if (!TEST_BIT (recog_data.enabled_alternatives, which_alternative))\n \t{\n \t  int i;\n \n@@ -4164,3 +4199,19 @@ make_pass_split_for_shorten_branches (gcc::context *ctxt)\n {\n   return new pass_split_for_shorten_branches (ctxt);\n }\n+\n+/* (Re)initialize the target information after a change in target.  */\n+\n+void\n+recog_init ()\n+{\n+  /* The information is zero-initialized, so we don't need to do anything\n+     first time round.  */\n+  if (!this_target_recog->x_initialized)\n+    {\n+      this_target_recog->x_initialized = true;\n+      return;\n+    }\n+  memset (this_target_recog->x_enabled_alternatives, 0,\n+\t  sizeof (this_target_recog->x_enabled_alternatives));\n+}"}, {"sha": "8c8d55f3e9f46e63f3c258d7cc5f1aad58075d7b", "filename": "gcc/recog.h", "status": "modified", "additions": 36, "deletions": 6, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Frecog.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Frecog.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.h?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -20,8 +20,17 @@ along with GCC; see the file COPYING3.  If not see\n #ifndef GCC_RECOG_H\n #define GCC_RECOG_H\n \n-/* Random number that should be large enough for all purposes.  */\n+/* Random number that should be large enough for all purposes.  Also define\n+   a type that has at least MAX_RECOG_ALTERNATIVES + 1 bits, with the extra\n+   bit giving an invalid value that can be used to mean \"uninitialized\".  */\n #define MAX_RECOG_ALTERNATIVES 30\n+typedef unsigned int alternative_mask;\n+\n+/* A mask of all alternatives.  */\n+#define ALL_ALTERNATIVES ((alternative_mask) -1)\n+\n+/* A mask containing just alternative X.  */\n+#define ALTERNATIVE_BIT(X) ((alternative_mask) 1 << (X))\n \n /* Types of operands.  */\n enum op_type {\n@@ -235,11 +244,11 @@ struct recog_data_d\n   /* True if insn is ASM_OPERANDS.  */\n   bool is_asm;\n \n-  /* Specifies whether an insn alternative is enabled using the\n-     `enabled' attribute in the insn pattern definition.  For back\n-     ends not using the `enabled' attribute the array fields are\n-     always set to `true' in expand_insn.  */\n-  bool alternative_enabled_p [MAX_RECOG_ALTERNATIVES];\n+  /* Specifies whether an insn alternative is enabled using the `enabled'\n+     attribute in the insn pattern definition.  For back ends not using\n+     the `enabled' attribute the bits are always set to 1 in expand_insn.\n+     Bits beyond the last alternative are also set to 1.  */\n+  alternative_mask enabled_alternatives;\n \n   /* In case we are caching, hold insn data was generated for.  */\n   rtx insn;\n@@ -361,4 +370,25 @@ struct insn_data_d\n extern const struct insn_data_d insn_data[];\n extern int peep2_current_count;\n \n+#ifndef GENERATOR_FILE\n+#include \"insn-codes.h\"\n+\n+/* Target-dependent globals.  */\n+struct target_recog {\n+  bool x_initialized;\n+  alternative_mask x_enabled_alternatives[LAST_INSN_CODE];\n+};\n+\n+extern struct target_recog default_target_recog;\n+#if SWITCHABLE_TARGET\n+extern struct target_recog *this_target_recog;\n+#else\n+#define this_target_recog (&default_target_recog)\n+#endif\n+\n+alternative_mask get_enabled_alternatives (rtx);\n+\n+void recog_init ();\n+#endif\n+\n #endif /* GCC_RECOG_H */"}, {"sha": "edb865ef3f6a259b91b488b56238a859babada5b", "filename": "gcc/reginfo.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Freginfo.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Freginfo.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freginfo.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -534,6 +534,7 @@ reinit_regs (void)\n   /* caller_save needs to be re-initialized.  */\n   caller_save_initialized_p = false;\n   ira_init ();\n+  recog_init ();\n }\n \n /* Initialize some fake stack-frame MEM references for use in"}, {"sha": "87c453c85b85dae472514db55f64cb928fbd8dd4", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -3010,7 +3010,7 @@ find_reloads (rtx insn, int replace, int ind_levels, int live_known,\n     {\n       int swapped;\n \n-      if (!recog_data.alternative_enabled_p[this_alternative_number])\n+      if (!TEST_BIT (recog_data.enabled_alternatives, this_alternative_number))\n \t{\n \t  int i;\n "}, {"sha": "f216230db0a377c3200130e10a13af06ec561dd8", "filename": "gcc/system.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -1071,6 +1071,9 @@ helper_const_non_const_cast (const char *p)\n #define DEBUG_VARIABLE\n #endif\n \n+/* General macro to extract bit Y of X.  */\n+#define TEST_BIT(X, Y) (((X) >> (Y)) & 1)\n+\n /* Get definitions of HOST_WIDE_INT.  */\n #include \"hwint.h\"\n "}, {"sha": "f1bfded397917f4f68402aa04fd4a7f5f7093b99", "filename": "gcc/target-globals.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftarget-globals.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftarget-globals.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -43,12 +43,14 @@ along with GCC; see the file COPYING3.  If not see\n #include \"gcse.h\"\n #include \"bb-reorder.h\"\n #include \"lower-subreg.h\"\n+#include \"recog.h\"\n \n #if SWITCHABLE_TARGET\n struct target_globals default_target_globals = {\n   &default_target_flag_state,\n   &default_target_regs,\n   &default_target_rtl,\n+  &default_target_recog,\n   &default_target_hard_regs,\n   &default_target_reload,\n   &default_target_expmed,\n@@ -84,6 +86,7 @@ save_target_globals (void)\n   g->flag_state = &p->flag_state;\n   g->regs = ggc_internal_cleared_alloc (sizeof (struct target_regs));\n   g->rtl = ggc_cleared_alloc<target_rtl> ();\n+  g->recog = ggc_internal_cleared_alloc (sizeof (struct target_recog));\n   g->hard_regs\n     = ggc_internal_cleared_alloc (sizeof (struct target_hard_regs));\n   g->reload = ggc_internal_cleared_alloc (sizeof (struct target_reload));"}, {"sha": "f4ef91fd21c043cbe4a9a511d84dad4e794b8ae5", "filename": "gcc/target-globals.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftarget-globals.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftarget-globals.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-globals.h?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -24,6 +24,7 @@ along with GCC; see the file COPYING3.  If not see\n extern struct target_flag_state *this_target_flag_state;\n extern struct target_regs *this_target_regs;\n extern struct target_rtl *this_target_rtl;\n+extern struct target_recog *this_target_recog;\n extern struct target_hard_regs *this_target_hard_regs;\n extern struct target_reload *this_target_reload;\n extern struct target_expmed *this_target_expmed;\n@@ -43,6 +44,7 @@ struct GTY(()) target_globals {\n   struct target_flag_state *GTY((skip)) flag_state;\n   void *GTY((atomic)) regs;\n   struct target_rtl *rtl;\n+  void *GTY((atomic)) recog;\n   void *GTY((atomic)) hard_regs;\n   void *GTY((atomic)) reload;\n   void *GTY((atomic)) expmed;\n@@ -70,6 +72,7 @@ restore_target_globals (struct target_globals *g)\n   this_target_flag_state = g->flag_state;\n   this_target_regs = (struct target_regs *) g->regs;\n   this_target_rtl = g->rtl;\n+  this_target_recog = (struct target_recog *) g->recog;\n   this_target_hard_regs = (struct target_hard_regs *) g->hard_regs;\n   this_target_reload = (struct target_reload *) g->reload;\n   this_target_expmed = (struct target_expmed *) g->expmed;"}, {"sha": "fa4c74ef31f09900d5de71dee028edccb33fb77c", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cc8d9d2df6f618f133f6d5ec1019333a0d942e5/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=4cc8d9d2df6f618f133f6d5ec1019333a0d942e5", "patch": "@@ -1601,6 +1601,9 @@ backend_init_target (void)\n   /* Depends on HARD_FRAME_POINTER_REGNUM.  */\n   init_reload ();\n \n+  /* Depends on the enabled attribute.  */\n+  recog_init ();\n+\n   /* The following initialization functions need to generate rtl, so\n      provide a dummy function context for them.  */\n   init_dummy_function_start ();"}]}