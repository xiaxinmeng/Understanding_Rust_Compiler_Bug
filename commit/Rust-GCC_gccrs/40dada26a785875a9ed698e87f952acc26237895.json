{"sha": "40dada26a785875a9ed698e87f952acc26237895", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBkYWRhMjZhNzg1ODc1YTllZDY5OGU4N2Y5NTJhY2MyNjIzNzg5NQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2019-05-21T17:09:13Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2019-05-21T17:09:13Z"}, "message": "preserve more debug stmts in gimple jump threading\n\nGimple jump threading does not duplicate forwarder blocks that might\nbe present before or after the second copied block.  This silently\ndrops debug binds and markers that might be present in them.  This\npatch attempts to preserve them.\n\nFor blocks after either copied block, we attempt to append debug stmts\nto the copied block, if it does not end with a block-ending stmt.\nFailing that, for blocks between both copied blocks, we prepend its\ndebug stmts to the copy of the second block.\n\nIf everything fails, we still drop debug stmts on the floor, though\npreexisting code consolidates debug binds in the block that threading\nflows into, so only markers are really lost.  We can't do much better\nthan that without conditional binds and markers, or debug stmts in\nedges, or somesuch.\n\nIf we append debug stmts to a reusable template block, we copy it\nafter splitting out the debug stmts, and before putting them back.\n\n\nfor  gcc/ChangeLog\n\n\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): Add\n\tfield template_last_to_copy.\n\t(ssa_create_duplicates): Set it, and use it.  Attempt to\n\tpreserve more debug stmts.\n\nFrom-SVN: r271477", "tree": {"sha": "7ed80d7378e9dfeac3d2b03e85a36140e336f670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ed80d7378e9dfeac3d2b03e85a36140e336f670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40dada26a785875a9ed698e87f952acc26237895", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40dada26a785875a9ed698e87f952acc26237895", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40dada26a785875a9ed698e87f952acc26237895", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40dada26a785875a9ed698e87f952acc26237895/comments", "author": null, "committer": null, "parents": [{"sha": "53329d29274fa4af5af7ab155947fe84b9684e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/53329d29274fa4af5af7ab155947fe84b9684e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/53329d29274fa4af5af7ab155947fe84b9684e39"}], "stats": {"total": 75, "additions": 75, "deletions": 0}, "files": [{"sha": "52178fefa7cb3a17b0ee936b2bb8df262124c167", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40dada26a785875a9ed698e87f952acc26237895/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40dada26a785875a9ed698e87f952acc26237895/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40dada26a785875a9ed698e87f952acc26237895", "patch": "@@ -1,3 +1,10 @@\n+2019-05-21  Alexandre Oliva <aoliva@redhat.com>\n+\n+\t* tree-ssa-threadupdate.c (struct ssa_local_info_t): Add\n+\tfield template_last_to_copy.\n+\t(ssa_create_duplicates): Set it, and use it.  Attempt to\n+\tpreserve more debug stmts.\n+\n 2019-05-21  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (VF1_AVX2): New mode iterator."}, {"sha": "d631543177464db23845f60594957c441b6ccd92", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40dada26a785875a9ed698e87f952acc26237895/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40dada26a785875a9ed698e87f952acc26237895/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=40dada26a785875a9ed698e87f952acc26237895", "patch": "@@ -235,6 +235,12 @@ struct ssa_local_info_t\n      and sharing a template for that block is considerably more difficult.  */\n   basic_block template_block;\n \n+  /* If we append debug stmts to the template block after creating it,\n+     this iterator won't be the last one in the block, and further\n+     copies of the template block shouldn't get debug stmts after\n+     it.  */\n+  gimple_stmt_iterator template_last_to_copy;\n+\n   /* Blocks duplicated for the thread.  */\n   bitmap duplicate_blocks;\n \n@@ -1124,21 +1130,83 @@ ssa_create_duplicates (struct redirection_data **slot,\n       create_block_for_threading ((*path)[1]->e->src, rd, 0,\n \t\t\t\t  &local_info->duplicate_blocks);\n       local_info->template_block = rd->dup_blocks[0];\n+      local_info->template_last_to_copy\n+\t= gsi_last_bb (local_info->template_block);\n \n       /* We do not create any outgoing edges for the template.  We will\n \t take care of that in a later traversal.  That way we do not\n \t create edges that are going to just be deleted.  */\n     }\n   else\n     {\n+      gimple_seq seq = NULL;\n+      if (gsi_stmt (local_info->template_last_to_copy)\n+\t  != gsi_stmt (gsi_last_bb (local_info->template_block)))\n+\tseq = gsi_split_seq_after (local_info->template_last_to_copy);\n       create_block_for_threading (local_info->template_block, rd, 0,\n \t\t\t\t  &local_info->duplicate_blocks);\n+      if (seq)\n+\tgsi_insert_seq_after (&local_info->template_last_to_copy,\n+\t\t\t      seq, GSI_SAME_STMT);\n \n       /* Go ahead and wire up outgoing edges and update PHIs for the duplicate\n \t block.   */\n       ssa_fix_duplicate_block_edges (rd, local_info);\n     }\n \n+  if (MAY_HAVE_DEBUG_STMTS)\n+    {\n+      /* Copy debug stmts from each NO_COPY src block to the block\n+\t that would have been its predecessor, if we can append to it\n+\t (we can't add stmts after a block-ending stmt), or prepending\n+\t to the duplicate of the successor, if there is one.  If\n+\t there's no duplicate successor, we'll mostly drop the blocks\n+\t on the floor; propagate_threaded_block_debug_into, called\n+\t elsewhere, will consolidate and preserve the effects of the\n+\t binds, but none of the markers.  */\n+      gimple_stmt_iterator copy_to = gsi_last_bb (rd->dup_blocks[0]);\n+      if (!gsi_end_p (copy_to))\n+\t{\n+\t  if (stmt_ends_bb_p (gsi_stmt (copy_to)))\n+\t    {\n+\t      if (rd->dup_blocks[1])\n+\t\tcopy_to = gsi_after_labels (rd->dup_blocks[1]);\n+\t      else\n+\t\tcopy_to = gsi_none ();\n+\t    }\n+\t  else\n+\t    gsi_next (&copy_to);\n+\t}\n+      for (unsigned int i = 2, j = 0; i < path->length (); i++)\n+\tif ((*path)[i]->type == EDGE_NO_COPY_SRC_BLOCK\n+\t    && gsi_bb (copy_to))\n+\t  {\n+\t    for (gimple_stmt_iterator gsi = gsi_start_bb ((*path)[i]->e->src);\n+\t\t !gsi_end_p (gsi); gsi_next (&gsi))\n+\t      {\n+\t\tif (!is_gimple_debug (gsi_stmt (gsi)))\n+\t\t  continue;\n+\t\tgimple *stmt = gsi_stmt (gsi);\n+\t\tgimple *copy = gimple_copy (stmt);\n+\t\tgsi_insert_before (&copy_to, copy, GSI_SAME_STMT);\n+\t      }\n+\t  }\n+\telse if ((*path)[i]->type == EDGE_COPY_SRC_BLOCK\n+\t\t || (*path)[i]->type == EDGE_COPY_SRC_JOINER_BLOCK)\n+\t  {\n+\t    j++;\n+\t    gcc_assert (j < 2);\n+\t    copy_to = gsi_last_bb (rd->dup_blocks[j]);\n+\t    if (!gsi_end_p (copy_to))\n+\t      {\n+\t\tif (stmt_ends_bb_p (gsi_stmt (copy_to)))\n+\t\t  copy_to = gsi_none ();\n+\t\telse\n+\t\t  gsi_next (&copy_to);\n+\t      }\n+\t  }\n+    }\n+\n   /* Keep walking the hash table.  */\n   return 1;\n }"}]}