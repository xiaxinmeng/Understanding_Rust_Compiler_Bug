{"sha": "aea5e79a63f965a9ed5fd2ef1943e3865495e987", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWVhNWU3OWE2M2Y5NjVhOWVkNWZkMmVmMTk0M2UzODY1NDk1ZTk4Nw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-06-05T17:41:32Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-06-05T17:41:32Z"}, "message": "cfgexpand.c (expand_gimple_tailcall): Initialize profile of new edge.\n\n\n\t* cfgexpand.c (expand_gimple_tailcall): Initialize profile of\n\tnew edge.\n\t* ipa-inline.c (want_inline_self_recursive_call_p): Watch for missing\n\tprofile in callgraph edge.\n\t* profile-count.h (apply_probability): If THIS is 0, then result is 0\n\t(apply_scale): Likewise.\n\t* tree-inline.c (copy_bb, copy_edges_for_bb, copy_cfg_body):\n\tAlso scale profile when inlining function with zero profile.\n\t(initialize_cfun): Update exit block profile even when it is zero.\n\t* tree-ssa-threadupdate.c (clear_counts_path): Handle correctly case\n\twhen profile is read.\n\nFrom-SVN: r248885", "tree": {"sha": "52c60043f6ed486d65cb1a8a38cb71979166465c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52c60043f6ed486d65cb1a8a38cb71979166465c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aea5e79a63f965a9ed5fd2ef1943e3865495e987", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea5e79a63f965a9ed5fd2ef1943e3865495e987", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aea5e79a63f965a9ed5fd2ef1943e3865495e987", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aea5e79a63f965a9ed5fd2ef1943e3865495e987/comments", "author": null, "committer": null, "parents": [{"sha": "2f20e7db2caea4909ddff539b2419c9f34c907c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2f20e7db2caea4909ddff539b2419c9f34c907c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2f20e7db2caea4909ddff539b2419c9f34c907c4"}], "stats": {"total": 58, "additions": 43, "deletions": 15}, "files": [{"sha": "15841daac597611fddce688cc5e3abbfd81b640d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -1,3 +1,17 @@\n+2017-06-05  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* cfgexpand.c (expand_gimple_tailcall): Initialize profile of\n+\tnew edge.\n+\t* ipa-inline.c (want_inline_self_recursive_call_p): Watch for missing\n+\tprofile in callgraph edge.\n+\t* profile-count.h (apply_probability): If THIS is 0, then result is 0\n+\t(apply_scale): Likewise.\n+\t* tree-inline.c (copy_bb, copy_edges_for_bb, copy_cfg_body):\n+\tAlso scale profile when inlining function with zero profile.\n+\t(initialize_cfun): Update exit block profile even when it is zero.\n+\t* tree-ssa-threadupdate.c (clear_counts_path): Handle correctly case\n+\twhen profile is read.\n+\n 2017-06-05  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/rs6000.c (toplevel): Include attribs.h."}, {"sha": "c1f80727d3060f34bdb96cf7f2a9cbb1a93da84e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -3850,8 +3850,8 @@ expand_gimple_tailcall (basic_block bb, gcall *stmt, bool *can_fallthru)\n \n   e = make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_ABNORMAL\n \t\t | EDGE_SIBCALL);\n-  e->probability += probability;\n-  e->count += count;\n+  e->probability = probability;\n+  e->count = count;\n   BB_END (bb) = last;\n   update_bb_for_insn (bb);\n "}, {"sha": "64c9ebd6692f54c253847e8b7a38eadee0818acc", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -912,15 +912,16 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n      methods.  */\n   else\n     {\n-      if (max_count > profile_count::zero ()\n+      if (max_count > profile_count::zero () && edge->count.initialized_p ()\n \t  && (edge->count.to_gcov_type () * 100\n \t      / outer_node->count.to_gcov_type ()\n \t      <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{\n \t  reason = \"profile of recursive call is too small\";\n \t  want_inline = false;\n \t}\n-      else if (max_count == profile_count::zero ()\n+      else if ((max_count == profile_count::zero ()\n+\t        || !edge->count.initialized_p ())\n \t       && (edge->frequency * 100 / caller_freq\n \t           <= PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY)))\n \t{"}, {"sha": "e7815dbcfcb64b57a5cd26d2b3491346b333ed6e", "filename": "gcc/profile-count.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -221,6 +221,8 @@ class GTY(()) profile_count\n   profile_count apply_probability (int prob) const\n     {\n       gcc_checking_assert (prob >= 0 && prob <= REG_BR_PROB_BASE);\n+      if (*this == profile_count::zero ())\n+\treturn *this;\n       if (!initialized_p ())\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n@@ -230,6 +232,8 @@ class GTY(()) profile_count\n   /* Return *THIS * NUM / DEN.  */\n   profile_count apply_scale (int64_t num, int64_t den) const\n     {\n+      if (*this == profile_count::zero ())\n+\treturn *this;\n       if (!initialized_p ())\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n@@ -243,7 +247,7 @@ class GTY(()) profile_count\n     }\n   profile_count apply_scale (profile_count num, profile_count den) const\n     {\n-      if (*this == profile_count::zero ())\n+      if (*this == profile_count::zero () || num == profile_count::zero ())\n \treturn profile_count::zero ();\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n \treturn profile_count::uninitialized ();"}, {"sha": "fb235e2bc9ffb59e2e05a80f4e266537ea0a8d7c", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -561,9 +561,11 @@ handle_simple_exit (edge e)\n       BB_END (old_bb) = end;\n \n       redirect_edge_succ (e, new_bb);\n+      new_bb->count = e->count;\n+      new_bb->frequency = e->frequency;\n       e->flags |= EDGE_FALLTHRU;\n \n-      e = make_edge (new_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n+      e = make_single_succ_edge (new_bb, EXIT_BLOCK_PTR_FOR_FN (cfun), 0);\n     }\n \n   e->flags &= ~EDGE_FALLTHRU;"}, {"sha": "329800185ec6624d77a060323a928a12bbc91130", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -1763,7 +1763,8 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n   tree decl;\n   gcov_type freq;\n   basic_block prev;\n-  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n+  bool scale = num.initialized_p ()\n+\t       && (den > 0 || num == profile_count::zero ());\n \n   /* Search for previous copied basic block.  */\n   prev = bb->prev_bb;\n@@ -2211,7 +2212,8 @@ copy_edges_for_bb (basic_block bb, profile_count num, profile_count den,\n   gimple_stmt_iterator si;\n   int flags;\n   bool need_debug_cleanup = false;\n-  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n+  bool scale = num.initialized_p ()\n+\t       && (den > 0 || num == profile_count::zero ());\n \n   /* Use the indices from the original blocks to create edges for the\n      new ones.  */\n@@ -2472,7 +2474,7 @@ initialize_cfun (tree new_fndecl, tree callee_fndecl, profile_count count)\n    */\n   if (ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ()\n       && count.initialized_p ()\n-      && ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count > 0)\n+      && ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.initialized_p ())\n     {\n       ENTRY_BLOCK_PTR_FOR_FN (cfun)->count =\n \tENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count.apply_scale (count,\n@@ -2683,7 +2685,8 @@ copy_cfg_body (copy_body_data * id, profile_count count, int frequency_scale,\n   profile_count incoming_count = profile_count::zero ();\n   profile_count num = count;\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n-  bool scale = num.initialized_p () && den.initialized_p () && den > 0;\n+  bool scale = num.initialized_p ()\n+\t       && (den > 0 || num == profile_count::zero ());\n \n   /* This can happen for COMDAT routines that end up with 0 counts\n      despite being called (see the comments for handle_missing_profiles()"}, {"sha": "df4c6def78af9cdc6fe8e19caae3c8cb8a2701c1", "filename": "gcc/tree-ssa-threadupdate.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Ftree-ssa-threadupdate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aea5e79a63f965a9ed5fd2ef1943e3865495e987/gcc%2Ftree-ssa-threadupdate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadupdate.c?ref=aea5e79a63f965a9ed5fd2ef1943e3865495e987", "patch": "@@ -1084,16 +1084,20 @@ clear_counts_path (struct redirection_data *rd)\n   vec<jump_thread_edge *> *path = THREAD_PATH (e);\n   edge ein, esucc;\n   edge_iterator ei;\n+  profile_count val = profile_count::uninitialized ();\n+  if (profile_status_for_fn (cfun) == PROFILE_READ)\n+    val = profile_count::zero ();\n+\n   FOR_EACH_EDGE (ein, ei, e->dest->preds)\n-    ein->count = profile_count::uninitialized ();\n+    ein->count = val;\n \n   /* First clear counts along original path.  */\n   for (unsigned int i = 1; i < path->length (); i++)\n     {\n       edge epath = (*path)[i]->e;\n       FOR_EACH_EDGE (esucc, ei, epath->src->succs)\n-\tesucc->count = profile_count::uninitialized ();\n-      epath->src->count = profile_count::uninitialized ();\n+\tesucc->count = val;\n+      epath->src->count = val;\n     }\n   /* Also need to clear the counts along duplicated path.  */\n   for (unsigned int i = 0; i < 2; i++)\n@@ -1102,8 +1106,8 @@ clear_counts_path (struct redirection_data *rd)\n       if (!dup)\n \tcontinue;\n       FOR_EACH_EDGE (esucc, ei, dup->succs)\n-\tesucc->count = profile_count::uninitialized ();\n-      dup->count = profile_count::uninitialized ();\n+\tesucc->count = val;\n+      dup->count = val;\n     }\n }\n "}]}