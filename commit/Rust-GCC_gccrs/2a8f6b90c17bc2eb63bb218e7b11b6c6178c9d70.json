{"sha": "2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmE4ZjZiOTBjMTdiYzJlYjYzYmIyMThlN2IxMWI2YzYxNzhjOWQ3MA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2000-04-13T13:59:00Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2000-04-13T13:59:00Z"}, "message": "alias.c (nonlocal_reference_p): Take a care for CALL_INSNS's fusage field.\n\n\t* alias.c (nonlocal_reference_p): Take a care for\n\tCALL_INSNS's fusage field.\n\t* calls.c (ECF_PURE): New flag.\n\t(emit_call_1): Handle ECF_PURE calls.\n\t(initialize_argument_information): Unset ECF_PURE flag too.\n\t(precompute_arguments): Precompute for ECF_PURE too.\n\t(expand_call): Handle ECF_PURE calls too.\n\t(emit_library_call_value_1): Rename no_queue argument to\n\tfn_type, accept value of 2 as pure function.\n\t(emit_library_call_value, emit_library_call): Rename no_queue argument\n\tto fn_type.\n\t* optabs.c (prepare_cmp_insn): Pass fn_type 2 to memcmp call.\n\n\t* tree.h (DECL_IS_PURE): New macro.\n\t(struct tree_decl): Add pure_flag.\n\t* c-common.c (enum attrs): Add attribute \"pure\".\n\t(init_attributes): Initialize attribute \"pure\"\n\t(decl_attributes): Handle attribute \"pure\".\n\t* extend.texi (Attribute \"pure\"): Document.\n\t* calls.c (expand_call): Add (mem:BLK (scratch)) to \"equal from\"\n\tin pure function.\n\t(flags_from_decl_or_type): Support attribute \"pure\".\n\nFrom-SVN: r33138", "tree": {"sha": "d0cc1485f0444d16267f642aaa62f86e34308a1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0cc1485f0444d16267f642aaa62f86e34308a1e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/comments", "author": null, "committer": null, "parents": [{"sha": "c966901c242442c6ca4d34c8cdc85f5dfd3dbdd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c966901c242442c6ca4d34c8cdc85f5dfd3dbdd3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c966901c242442c6ca4d34c8cdc85f5dfd3dbdd3"}], "stats": {"total": 201, "additions": 143, "deletions": 58}, "files": [{"sha": "ad5c15d867d7d1d1551f87b985e06d9fa0cb025a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -1,3 +1,28 @@\n+Thu Apr 13 15:55:08 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n+\n+\t* alias.c (nonlocal_reference_p): Take a care for\n+\tCALL_INSNS's fusage field.\n+\t* calls.c (ECF_PURE): New flag.\n+\t(emit_call_1): Handle ECF_PURE calls.\n+\t(initialize_argument_information): Unset ECF_PURE flag too.\n+\t(precompute_arguments): Precompute for ECF_PURE too.\n+\t(expand_call): Handle ECF_PURE calls too.\n+\t(emit_library_call_value_1): Rename no_queue argument to\n+\tfn_type, accept value of 2 as pure function.\n+\t(emit_library_call_value, emit_library_call): Rename no_queue argument\n+\tto fn_type.\n+\t* optabs.c (prepare_cmp_insn): Pass fn_type 2 to memcmp call.\n+\n+\t* tree.h (DECL_IS_PURE): New macro.\n+\t(struct tree_decl): Add pure_flag.\n+\t* c-common.c (enum attrs): Add attribute \"pure\".\n+\t(init_attributes): Initialize attribute \"pure\"\n+\t(decl_attributes): Handle attribute \"pure\".\n+\t* extend.texi (Attribute \"pure\"): Document.\n+\t* calls.c (expand_call): Add (mem:BLK (scratch)) to \"equal from\"\n+\tin pure function.\n+\t(flags_from_decl_or_type): Support attribute \"pure\".\n+\n 2000-04-13  Jason Merrill  <jason@casey.cygnus.com>\n \n \t* cpplex.c (_cpp_lex_token): Handle digraphs.  Don't null-terminate"}, {"sha": "fb493f8e7b0a599c476c75a0d4318ad99b68c9a5", "filename": "gcc/alias.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Falias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Falias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falias.c?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -1424,10 +1424,15 @@ nonlocal_reference_p (x)\n \n   if (GET_RTX_CLASS (code) == 'i')\n     {\n-      /* Constant functions are constant.  */\n+      /* Constant functions can be constant if they don't use\n+         scratch memory used to mark function w/o side effects.  */\n       if (code == CALL_INSN && CONST_CALL_P (x))\n-\treturn 0;\n-      x = PATTERN (x);\n+        {\n+\t  x = CALL_INSN_FUNCTION_USAGE (x);\n+\t  if (!x) return 0;\n+        }\n+      else\n+        x = PATTERN (x);\n       code = GET_CODE (x);\n     }\n \n@@ -1520,7 +1525,7 @@ nonlocal_reference_p (x)\n     \n     for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n       {\n-\tif (fmt[i] == 'e')\n+\tif (fmt[i] == 'e' && XEXP (x, i))\n \t  {\n \t    if (nonlocal_reference_p (XEXP (x, i)))\n \t      return 1;"}, {"sha": "1033035db233d004c74d7e070c7ba9dc7c09ec37", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -145,7 +145,7 @@ enum attrs {A_PACKED, A_NOCOMMON, A_COMMON, A_NORETURN, A_CONST, A_T_UNION,\n \t    A_NO_CHECK_MEMORY_USAGE, A_NO_INSTRUMENT_FUNCTION,\n \t    A_CONSTRUCTOR, A_DESTRUCTOR, A_MODE, A_SECTION, A_ALIGNED,\n \t    A_UNUSED, A_FORMAT, A_FORMAT_ARG, A_WEAK, A_ALIAS, A_MALLOC,\n-\t    A_NO_LIMIT_STACK};\n+\t    A_NO_LIMIT_STACK, A_PURE};\n \n enum format_type { printf_format_type, scanf_format_type,\n \t\t   strftime_format_type };\n@@ -457,6 +457,7 @@ init_attributes ()\n   add_attribute (A_NO_CHECK_MEMORY_USAGE, \"no_check_memory_usage\", 0, 0, 1);\n   add_attribute (A_MALLOC, \"malloc\", 0, 0, 1);\n   add_attribute (A_NO_LIMIT_STACK, \"no_stack_limit\", 0, 0, 1);\n+  add_attribute (A_PURE, \"pure\", 0, 0, 1);\n }\n \f\n /* Default implementation of valid_lang_attribute, below.  By default, there\n@@ -596,6 +597,7 @@ decl_attributes (node, attributes, prefix_attributes)\n \tcase A_MALLOC:\n \t  if (TREE_CODE (decl) == FUNCTION_DECL)\n \t    DECL_IS_MALLOC (decl) = 1;\n+\t  /* ??? TODO: Support types.  */\n \t  else\n \t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n \t  break;\n@@ -625,6 +627,15 @@ decl_attributes (node, attributes, prefix_attributes)\n \t    warning ( \"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n \t  break;\n \n+\tcase A_PURE:\n+\t  if (TREE_CODE (decl) == FUNCTION_DECL)\n+\t    DECL_IS_PURE (decl) = 1;\n+\t  /* ??? TODO: Support types.  */\n+\t  else\n+\t    warning (\"`%s' attribute ignored\", IDENTIFIER_POINTER (name));\n+\t  break;\n+\n+\n \tcase A_T_UNION:\n \t  if (is_type\n \t      && TREE_CODE (type) == UNION_TYPE"}, {"sha": "2592a8e7fb30f84dad21870d315d4dc610ca0aea", "filename": "gcc/calls.c", "status": "modified", "additions": 62, "deletions": 39, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -168,6 +168,9 @@ static int calls_function_1\tPARAMS ((tree, int));\n    the current one.  */\n #define ECF_FORK_OR_EXEC\t128\n #define ECF_SIBCALL\t\t256\n+/* Nonzero if this is a call to \"pure\" function (like const function,\n+   but may read memory.  */\n+#define ECF_PURE\t\t512\n \n static void emit_call_1\t\tPARAMS ((rtx, tree, tree, HOST_WIDE_INT,\n \t\t\t\t\t HOST_WIDE_INT, HOST_WIDE_INT, rtx,\n@@ -555,6 +558,15 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n   if (! call_insn)\n     abort ();\n \n+  /* Mark memory as used for \"pure\" function call.  */\n+  if (ecf_flags & ECF_PURE)\n+    {\n+      call_fusage =  gen_rtx_EXPR_LIST (VOIDmode,\n+\tgen_rtx_USE (VOIDmode,\n+\t\t     gen_rtx_MEM (BLKmode,\n+\t\t\t\t  gen_rtx_SCRATCH (VOIDmode))), call_fusage);\n+    }\n+\n   /* Put the register usage information on the CALL.  If there is already\n      some usage information, put ours at the end.  */\n   if (CALL_INSN_FUNCTION_USAGE (call_insn))\n@@ -571,7 +583,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n     CALL_INSN_FUNCTION_USAGE (call_insn) = call_fusage;\n \n   /* If this is a const call, then set the insn's unchanging bit.  */\n-  if (ecf_flags & ECF_CONST)\n+  if (ecf_flags & (ECF_CONST | ECF_PURE))\n     CONST_CALL_P (call_insn) = 1;\n \n   /* If this call can't throw, attach a REG_EH_REGION reg note to that\n@@ -610,7 +622,7 @@ emit_call_1 (funexp, fndecl, funtype, stack_size, rounded_stack_size,\n       if (rounded_stack_size != 0)\n \t{\n \t  if (flag_defer_pop && inhibit_defer_pop == 0\n-\t      && !(ecf_flags & ECF_CONST))\n+\t      && !(ecf_flags & (ECF_CONST | ECF_PURE)))\n \t    pending_stack_adjust += rounded_stack_size;\n \t  else\n \t    adjust_stack (rounded_stack_size_rtx);\n@@ -759,6 +771,10 @@ flags_from_decl_or_type (exp)\n       if (DECL_P (exp) && DECL_IS_MALLOC (exp))\n \tflags |= ECF_MALLOC;\n \n+      /* The function exp may have the `pure' attribute.  */\n+      if (DECL_P (exp) && DECL_IS_PURE (exp))\n+\tflags |= ECF_PURE;\n+\n       if (TREE_NOTHROW (exp))\n \tflags |= ECF_NOTHROW;\n     }\n@@ -1195,7 +1211,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n \t      MEM_SET_IN_STRUCT_P (copy, AGGREGATE_TYPE_P (type));\n \n \t      store_expr (args[i].tree_value, copy, 0);\n-\t      *ecf_flags &= ~ECF_CONST;\n+\t      *ecf_flags &= ~(ECF_CONST | ECF_PURE);\n \n \t      args[i].tree_value = build1 (ADDR_EXPR,\n \t\t\t\t\t   build_pointer_type (type),\n@@ -1254,7 +1270,7 @@ initialize_argument_information (num_actuals, args, args_size, n_named_args,\n       /* If this is an addressable type, we cannot pre-evaluate it.  Thus,\n \t we cannot consider this function call constant.  */\n       if (TREE_ADDRESSABLE (type))\n-\t*ecf_flags &= ~ECF_CONST;\n+\t*ecf_flags &= ~(ECF_CONST | ECF_PURE);\n \n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n@@ -1435,7 +1451,7 @@ precompute_arguments (flags, must_preallocate, num_actuals, args, args_size)\n      which have already been stored into the stack.  */\n \n   for (i = 0; i < num_actuals; i++)\n-    if ((flags & ECF_CONST)\n+    if ((flags & (ECF_CONST | ECF_PURE))\n \t|| ((args_size->var != 0 || args_size->constant != 0)\n \t    && calls_function (args[i].tree_value, 1))\n \t|| (must_preallocate\n@@ -2038,7 +2054,7 @@ expand_call (exp, target, ignore)\n   if (aggregate_value_p (exp))\n     {\n       /* This call returns a big structure.  */\n-      flags &= ~ECF_CONST;\n+      flags &= ~(ECF_CONST | ECF_PURE);\n \n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n@@ -2295,7 +2311,7 @@ expand_call (exp, target, ignore)\n \n       /* When calling a const function, we must pop the stack args right away,\n \t so that the pop is deleted or moved with the call.  */\n-      if (flags & ECF_CONST)\n+      if (flags & (ECF_CONST | ECF_PURE))\n \tNO_DEFER_POP;\n \n       /* Don't let pending stack adjusts add up to too much.\n@@ -2416,7 +2432,7 @@ expand_call (exp, target, ignore)\n \n \t     Also do not make a sibling call.  */\n \n-\t  flags &= ~ECF_CONST;\n+\t  flags &= ~(ECF_CONST | ECF_PURE);\n \t  must_preallocate = 1;\n \t  sibcall_failure = 1;\n \t}\n@@ -2470,7 +2486,7 @@ expand_call (exp, target, ignore)\n \n       /* Now we are about to start emitting insns that can be deleted\n \t if a libcall is deleted.  */\n-      if (flags & (ECF_CONST | ECF_MALLOC))\n+      if (flags & (ECF_CONST | ECF_PURE | ECF_MALLOC))\n \tstart_sequence ();\n \n       old_stack_allocated =  stack_pointer_delta - pending_stack_adjust;\n@@ -2653,7 +2669,7 @@ expand_call (exp, target, ignore)\n \t{\n \t  /* When the stack adjustment is pending, we get better code\n \t     by combining the adjustments.  */\n-\t  if (pending_stack_adjust && ! (flags & ECF_CONST)\n+\t  if (pending_stack_adjust && ! (flags & (ECF_CONST | ECF_PURE))\n \t      && ! inhibit_defer_pop)\n \t    {\n \t      int adjust;\n@@ -2821,7 +2837,8 @@ expand_call (exp, target, ignore)\n \t Test valreg so we don't crash; may safely ignore `const'\n \t if return type is void.  Disable for PARALLEL return values, because\n \t we have no way to move such values into a pseudo register.  */\n-      if ((flags & ECF_CONST) && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n+      if ((flags & (ECF_CONST | ECF_PURE))\n+\t  && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n \t{\n \t  rtx note = 0;\n \t  rtx temp = gen_reg_rtx (GET_MODE (valreg));\n@@ -2840,11 +2857,17 @@ expand_call (exp, target, ignore)\n \t  insns = get_insns ();\n \t  end_sequence ();\n \n+\t  if (flags & ECF_PURE)\n+\t    note = gen_rtx_EXPR_LIST (VOIDmode,\n+\t       gen_rtx_USE (VOIDmode,\n+\t\t\t    gen_rtx_MEM (BLKmode,\n+\t\t\t\t    \t gen_rtx_SCRATCH (VOIDmode))), note);\n+\n \t  emit_libcall_block (insns, temp, valreg, note);\n   \n \t  valreg = temp;\n \t}\n-      else if (flags & ECF_CONST)\n+      else if (flags & (ECF_CONST | ECF_PURE))\n \t{\n \t  /* Otherwise, just write out the sequence without a note.  */\n \t  rtx insns = get_insns ();\n@@ -3171,11 +3194,11 @@ libfunc_nothrow (fun)\n    The RETVAL parameter specifies whether return value needs to be saved, other \n    parameters are documented in the emit_library_call function bellow.  */\n static rtx\n-emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n+emit_library_call_value_1 (retval, orgfun, value, fn_type, outmode, nargs, p)\n      int retval;\n      rtx orgfun;\n      rtx value;\n-     int no_queue;\n+     int fn_type;\n      enum machine_mode outmode;\n      int nargs;\n      va_list p;\n@@ -3223,8 +3246,10 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n #endif\n #endif\n \n-  if (no_queue)\n+  if (fn_type == 1)\n     flags |= ECF_CONST;\n+  else if (fn_type == 2)\n+    flags |= ECF_PURE;\n   fun = orgfun;\n \n   if (libfunc_nothrow (fun))\n@@ -3258,7 +3283,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n #endif\n \n       /* This call returns a big structure.  */\n-      flags &= ~ECF_CONST;\n+      flags &= ~(ECF_CONST | ECF_PURE);\n     }\n \n   /* ??? Unfinished: must pass the memory address as an argument.  */\n@@ -3282,7 +3307,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n \n   /* Now we are about to start emitting insns that can be deleted\n      if a libcall is deleted.  */\n-  if (flags & ECF_CONST)\n+  if (flags & (ECF_CONST | ECF_PURE))\n     start_sequence ();\n \n   push_temp_slots ();\n@@ -3726,7 +3751,7 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n      Test valreg so we don't crash; may safely ignore `const'\n      if return type is void.  Disable for PARALLEL return values, because\n      we have no way to move such values into a pseudo register.  */\n-  if ((flags & ECF_CONST)\n+  if ((flags & (ECF_CONST | ECF_PURE))\n       && valreg != 0 && GET_CODE (valreg) != PARALLEL)\n     {\n       rtx note = 0;\n@@ -3743,11 +3768,17 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n       insns = get_insns ();\n       end_sequence ();\n \n+      if (flags & ECF_PURE)\n+\tnote = gen_rtx_EXPR_LIST (VOIDmode,\n+\t   gen_rtx_USE (VOIDmode,\n+\t\t\tgen_rtx_MEM (BLKmode,\n+\t\t\t\t     gen_rtx_SCRATCH (VOIDmode))), note);\n+\n       emit_libcall_block (insns, temp, valreg, note);\n \n       valreg = temp;\n     }\n-  else if (flags & ECF_CONST)\n+  else if (flags & (ECF_CONST | ECF_PURE))\n     {\n       /* Otherwise, just write out the sequence without a note.  */\n       rtx insns = get_insns ();\n@@ -3830,26 +3861,18 @@ emit_library_call_value_1 (retval, orgfun, value, no_queue, outmode, nargs, p)\n    and machine_modes to convert them to.\n    The rtx values should have been passed through protect_from_queue already.\n \n-   NO_QUEUE will be true if and only if the library call is a `const' call\n-   which will be enclosed in REG_LIBCALL/REG_RETVAL notes; it is equivalent\n-   to the flag ECF_CONST in expand_call.\n-\n-   NO_QUEUE must be true for const calls, because if it isn't, then\n-   any pending increment will be emitted between REG_LIBCALL/REG_RETVAL notes,\n-   and will be lost if the libcall sequence is optimized away.\n-\n-   NO_QUEUE must be false for non-const calls, because if it isn't, the\n-   call insn will have its CONST_CALL_P bit set, and it will be incorrectly\n-   optimized.  For instance, the instruction scheduler may incorrectly\n-   move memory references across the non-const call.  */\n+   FN_TYPE will is zero for `normal' calls, one for `const' calls, wich\n+   which will be enclosed in REG_LIBCALL/REG_RETVAL notes and two for `pure'\n+   calls, that are handled like `const' calls with extra\n+   (use (memory (scratch)).  */\n \n void\n-emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n+emit_library_call VPARAMS((rtx orgfun, int fn_type, enum machine_mode outmode,\n \t\t\t   int nargs, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx orgfun;\n-  int no_queue;\n+  int fn_type;\n   enum machine_mode outmode;\n   int nargs;\n #endif\n@@ -3859,12 +3882,12 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n \n #ifndef ANSI_PROTOTYPES\n   orgfun = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n+  fn_type = va_arg (p, int);\n   outmode = va_arg (p, enum machine_mode);\n   nargs = va_arg (p, int);\n #endif\n \n-  emit_library_call_value_1 (0, orgfun, NULL_RTX, no_queue, outmode, nargs, p);\n+  emit_library_call_value_1 (0, orgfun, NULL_RTX, fn_type, outmode, nargs, p);\n \n   va_end (p);\n }\n@@ -3878,13 +3901,13 @@ emit_library_call VPARAMS((rtx orgfun, int no_queue, enum machine_mode outmode,\n    If VALUE is nonzero, VALUE is returned.  */\n \n rtx\n-emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n+emit_library_call_value VPARAMS((rtx orgfun, rtx value, int fn_type,\n \t\t\t\t enum machine_mode outmode, int nargs, ...))\n {\n #ifndef ANSI_PROTOTYPES\n   rtx orgfun;\n   rtx value;\n-  int no_queue;\n+  int fn_type;\n   enum machine_mode outmode;\n   int nargs;\n #endif\n@@ -3895,12 +3918,12 @@ emit_library_call_value VPARAMS((rtx orgfun, rtx value, int no_queue,\n #ifndef ANSI_PROTOTYPES\n   orgfun = va_arg (p, rtx);\n   value = va_arg (p, rtx);\n-  no_queue = va_arg (p, int);\n+  fn_type = va_arg (p, int);\n   outmode = va_arg (p, enum machine_mode);\n   nargs = va_arg (p, int);\n #endif\n \n-  value = emit_library_call_value_1 (1, orgfun, value, no_queue, outmode, nargs, p);\n+  value = emit_library_call_value_1 (1, orgfun, value, fn_type, outmode, nargs, p);\n \n   va_end (p);\n "}, {"sha": "22fe7414d2e82ff3ba708a1c5650fd0a30b3fbee", "filename": "gcc/extend.texi", "status": "modified", "additions": 28, "deletions": 12, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fextend.texi?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -1379,22 +1379,44 @@ typedef void voidfn ();\n volatile voidfn fatal;\n @end smallexample\n \n-@cindex @code{const} function attribute\n-@item const\n-Many functions do not examine any values except their arguments, and\n-have no effects except the return value.  Such a function can be subject\n+@cindex @code{pure} function attribute\n+@item pure\n+Many functions have no effects except the return value and their\n+return value and depends only on the parameters and/or global variables.\n+Such a function can be subject\n to common subexpression elimination and loop optimization just as an\n arithmetic operator would be.  These functions should be declared\n-with the attribute @code{const}.  For example,\n+with the attribute @code{pure}.  For example,\n \n @smallexample\n-int square (int) __attribute__ ((const));\n+int square (int) __attribute__ ((pure));\n @end smallexample\n \n @noindent\n says that the hypothetical function @code{square} is safe to call\n fewer times than the program says.\n \n+Some of common examples of pure functions are @code{strlen} or @code{memcmp}.\n+Interesting non-pure functions are functions with infinite loops or those\n+depending on volatile memory or other system resource, that may change between\n+two consetuctive calls (such as @code{feof} in multithreding environment).\n+\n+The attribute @code{pure} is not implemented in GNU C versions earlier\n+than 2.96.\n+@cindex @code{const} function attribute\n+@item const\n+Many functions do not examine any values except their arguments, and\n+have no effects except the return value.  Basically this is just slightly\n+more strict class than the \"pure\" attribute above, since function is not\n+alloved to read global memory.\n+\n+@cindex pointer arguments\n+Note that a function that has pointer arguments and examines the data\n+pointed to must @emph{not} be declared @code{const}.  Likewise, a\n+function that calls a non-@code{const} function usually must not be\n+@code{const}.  It does not make sense for a @code{const} function to\n+return @code{void}.\n+\n The attribute @code{const} is not implemented in GNU C versions earlier\n than 2.5.  An alternative way to declare that a function has no side\n effects, which works in the current version and in some older versions,\n@@ -1409,12 +1431,6 @@ extern const intfn square;\n This approach does not work in GNU C++ from 2.6.0 on, since the language\n specifies that the @samp{const} must be attached to the return value.\n \n-@cindex pointer arguments\n-Note that a function that has pointer arguments and examines the data\n-pointed to must @emph{not} be declared @code{const}.  Likewise, a\n-function that calls a non-@code{const} function usually must not be\n-@code{const}.  It does not make sense for a @code{const} function to\n-return @code{void}.\n \n @item format (@var{archetype}, @var{string-index}, @var{first-to-check})\n @cindex @code{format} function attribute"}, {"sha": "85bb24eae616840fb3346af3d4cd534f7319b788", "filename": "gcc/optabs.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -3020,14 +3020,14 @@ prepare_cmp_insn (px, py, pcomparison, size, pmode, punsignedp, align,\n #endif\n \t{\n #ifdef TARGET_MEM_FUNCTIONS\n-\t  emit_library_call (memcmp_libfunc, 0,\n+\t  emit_library_call (memcmp_libfunc, 2,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (sizetype), size,\n \t\t\t\t\t      TREE_UNSIGNED (sizetype)),\n \t\t\t     TYPE_MODE (sizetype));\n #else\n-\t  emit_library_call (bcmp_libfunc, 0,\n+\t  emit_library_call (bcmp_libfunc, 2,\n \t\t\t     TYPE_MODE (integer_type_node), 3,\n \t\t\t     XEXP (x, 0), Pmode, XEXP (y, 0), Pmode,\n \t\t\t     convert_to_mode (TYPE_MODE (integer_type_node),"}, {"sha": "9c426fa727fc9f7c5af5d8c99adb04f0f991529a", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=2a8f6b90c17bc2eb63bb218e7b11b6c6178c9d70", "patch": "@@ -1253,6 +1253,10 @@ struct tree_type\n    not an alias.  */\n #define DECL_IS_MALLOC(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.malloc_flag)\n \n+/* Nonzero in a FUNCTION_DECL means this function should be treated\n+   as \"pure\" function (like const function, but may read global memory).  */\n+#define DECL_IS_PURE(NODE) (FUNCTION_DECL_CHECK (NODE)->decl.pure_flag)\n+\n /* Nonzero in a FIELD_DECL means it is a bit field, and must be accessed\n    specially.  */\n #define DECL_BIT_FIELD(NODE) (FIELD_DECL_CHECK (NODE)->decl.bit_field_flag)\n@@ -1392,6 +1396,7 @@ struct tree_decl\n   unsigned comdat_flag : 1;\n   unsigned malloc_flag : 1;\n   unsigned no_limit_stack : 1;\n+  unsigned pure_flag : 1;\n #ifdef ONLY_INT_FIELDS\n   unsigned int built_in_class : 2;\n #else"}]}