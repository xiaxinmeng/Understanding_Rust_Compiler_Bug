{"sha": "11aaf40c8c88519d6fa47200b1f730baf4037639", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTFhYWY0MGM4Yzg4NTE5ZDZmYTQ3MjAwYjFmNzMwYmFmNDAzNzYzOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-10-03T15:50:32Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-10-03T15:50:32Z"}, "message": "stl_list.h: Trivial formatting fixes.\n\n2004-10-03  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/stl_list.h: Trivial formatting fixes.\n\t* include/bits/stl_tree.h: Likewise.\n\nFrom-SVN: r88451", "tree": {"sha": "75acc6a0a14a7685c11b618e6a8fe6f984cf9314", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/75acc6a0a14a7685c11b618e6a8fe6f984cf9314"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/11aaf40c8c88519d6fa47200b1f730baf4037639", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11aaf40c8c88519d6fa47200b1f730baf4037639", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11aaf40c8c88519d6fa47200b1f730baf4037639", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11aaf40c8c88519d6fa47200b1f730baf4037639/comments", "author": null, "committer": null, "parents": [{"sha": "807e955b1e70ed23f1c15496073432a129312eb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/807e955b1e70ed23f1c15496073432a129312eb1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/807e955b1e70ed23f1c15496073432a129312eb1"}], "stats": {"total": 191, "additions": 104, "deletions": 87}, "files": [{"sha": "bbf654d0f0082c08dccbd7a163fe597e6e21b20e", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=11aaf40c8c88519d6fa47200b1f730baf4037639", "patch": "@@ -1,3 +1,8 @@\n+2004-10-03  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/stl_list.h: Trivial formatting fixes.\n+\t* include/bits/stl_tree.h: Likewise.\n+\n 2004-10-03  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/sstream.tcc (seekpos): In case of success, just"}, {"sha": "07185dd3efde906d25dfd91203d9eacc58c2f6a2", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=11aaf40c8c88519d6fa47200b1f730baf4037639", "patch": "@@ -888,7 +888,7 @@ namespace _GLIBCXX_STD\n        */\n       void\n       swap(list& __x)\n-      { _List_node_base::swap(this->_M_impl._M_node,__x._M_impl._M_node); }\n+      { _List_node_base::swap(this->_M_impl._M_node, __x._M_impl._M_node); }\n \n       /**\n        *  Erases all the elements.  Note that this function only erases\n@@ -1115,7 +1115,7 @@ namespace _GLIBCXX_STD\n \t\t\t   _InputIterator __first, _InputIterator __last,\n \t\t\t   __false_type)\n         {\n-\t  for ( ; __first != __last; ++__first)\n+\t  for (; __first != __last; ++__first)\n \t    _M_insert(__pos, *__first);\n \t}\n \n@@ -1124,15 +1124,15 @@ namespace _GLIBCXX_STD\n       void\n       _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n       {\n-\tfor ( ; __n > 0; --__n)\n+\tfor (; __n > 0; --__n)\n \t  _M_insert(__pos, __x);\n       }\n \n \n       // Moves the elements from [first,last) before position.\n       void\n       _M_transfer(iterator __position, iterator __first, iterator __last)\n-      { __position._M_node->transfer(__first._M_node,__last._M_node); }\n+      { __position._M_node->transfer(__first._M_node, __last._M_node); }\n \n       // Inserts new element at position given and with value given.\n       void\n@@ -1165,9 +1165,9 @@ namespace _GLIBCXX_STD\n   */\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator==(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator==(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     {\n-      typedef typename list<_Tp,_Alloc>::const_iterator const_iterator;\n+      typedef typename list<_Tp, _Alloc>::const_iterator const_iterator;\n       const_iterator __end1 = __x.end();\n       const_iterator __end2 = __y.end();\n \n@@ -1194,32 +1194,32 @@ namespace _GLIBCXX_STD\n   */\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator<(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator<(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return std::lexicographical_compare(__x.begin(), __x.end(),\n \t\t\t\t\t  __y.begin(), __y.end()); }\n \n   /// Based on operator==\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator!=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator!=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator>(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator>(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return __y < __x; }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator<=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator<=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   /// Based on operator<\n   template<typename _Tp, typename _Alloc>\n     inline bool\n-    operator>=(const list<_Tp,_Alloc>& __x, const list<_Tp,_Alloc>& __y)\n+    operator>=(const list<_Tp, _Alloc>& __x, const list<_Tp, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   /// See std::list::swap()."}, {"sha": "5e21ccdbb427d7cee5eaa82e30d5ef3bbbe0f25c", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 88, "deletions": 76, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/11aaf40c8c88519d6fa47200b1f730baf4037639/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=11aaf40c8c88519d6fa47200b1f730baf4037639", "patch": "@@ -461,8 +461,10 @@ namespace std\n \n       _Const_Link_type\n       _M_begin() const\n-      { return static_cast<\n-\t  _Const_Link_type>(this->_M_impl._M_header._M_parent); }\n+      {\n+\treturn static_cast<_Const_Link_type>\n+\t  (this->_M_impl._M_header._M_parent);\n+      }\n \n       _Link_type\n       _M_end()\n@@ -550,7 +552,7 @@ namespace std\n       : _M_impl(__a, __comp)\n       { }\n \n-      _Rb_tree(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n+      _Rb_tree(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n       : _M_impl(__x.get_allocator(), __x._M_impl._M_key_compare)\n       {\n \tif (__x._M_root() != 0)\n@@ -565,8 +567,8 @@ namespace std\n       ~_Rb_tree()\n       { _M_erase(_M_begin()); }\n \n-      _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&\n-      operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x);\n+      _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n+      operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x);\n \n       // Accessors.\n       _Compare\n@@ -579,7 +581,10 @@ namespace std\n \n       const_iterator\n       begin() const\n-      { return static_cast<_Const_Link_type>(this->_M_impl._M_header._M_left); }\n+      {\n+\treturn static_cast<_Const_Link_type>\n+\t  (this->_M_impl._M_header._M_left);\n+      }\n \n       iterator\n       end()\n@@ -618,7 +623,7 @@ namespace std\n       { return size_type(-1); }\n \n       void\n-      swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t);\n+      swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t);\n \n       // Insert/erase.\n       pair<iterator,bool>\n@@ -699,8 +704,8 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator==(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator==(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     {\n       return __x.size() == __y.size()\n \t     && equal(__x.begin(), __x.end(), __y.begin());\n@@ -709,8 +714,8 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator<(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator<(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     {\n       return lexicographical_compare(__x.begin(), __x.end(), \n \t\t\t\t     __y.begin(), __y.end());\n@@ -719,43 +724,43 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator!=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator!=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     { return !(__x == __y); }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator>(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t      const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator>(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t      const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     { return __y < __x; }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator<=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator<=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     { return !(__y < __x); }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline bool\n-    operator>=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t       const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    operator>=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t       const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     { return !(__x < __y); }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline void\n-    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x,\n-\t _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __y)\n+    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x,\n+\t _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __y)\n     { __x.swap(__y); }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>&\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n-    operator=(const _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __x)\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>&\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    operator=(const _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __x)\n     {\n       if (this != &__x)\n \t{\n@@ -775,16 +780,16 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     _M_insert(_Base_ptr __x, _Base_ptr __p, const _Val& __v)\n     {\n       _Link_type __z = _M_create_node(__v);\n       bool __insert_left;\n \n-      __insert_left = __x != 0 || __p == _M_end()\n-\t              || _M_impl._M_key_compare(_KeyOfValue()(__v), \n-\t\t\t\t\t\t_S_key(__p));\n+      __insert_left = (__x != 0 || __p == _M_end()\n+\t\t       || _M_impl._M_key_compare(_KeyOfValue()(__v), \n+\t\t\t\t\t\t _S_key(__p)));\n \n       _Rb_tree_insert_and_rebalance(__insert_left, __z, __p,  \n \t\t\t\t    this->_M_impl._M_header);\n@@ -794,8 +799,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_equal(const _Val& __v)\n     {\n       _Link_type __x = _M_begin();\n@@ -812,8 +817,8 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n-    swap(_Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>& __t)\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    swap(_Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>& __t)\n     {\n       if (_M_root() == 0)\n       {\n@@ -856,9 +861,9 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator,\n-    bool>\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::iterator, bool>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_unique(const _Val& __v)\n     {\n       _Link_type __x = _M_begin();\n@@ -877,8 +882,8 @@ namespace std\n \telse\n \t  --__j;\n       if (_M_impl._M_key_compare(_S_key(__j._M_node), _KeyOfValue()(__v)))\n-\treturn pair<iterator,bool>(_M_insert(__x, __y, __v), true);\n-      return pair<iterator,bool>(__j, false);\n+\treturn pair<iterator, bool>(_M_insert(__x, __y, __v), true);\n+      return pair<iterator, bool>(__j, false);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n@@ -929,8 +934,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     insert_equal(iterator __position, const _Val& __v)\n     {\n       if (__position._M_node == _M_leftmost())\n@@ -977,40 +982,43 @@ namespace std\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n       void\n-      _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n+      _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n       insert_equal(_II __first, _II __last)\n       {\n-\tfor ( ; __first != __last; ++__first)\n+\tfor (; __first != __last; ++__first)\n \t  insert_equal(*__first);\n       }\n \n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Cmp, typename _Alloc>\n     template<class _II>\n     void\n-    _Rb_tree<_Key,_Val,_KoV,_Cmp,_Alloc>::\n+    _Rb_tree<_Key, _Val, _KoV, _Cmp, _Alloc>::\n     insert_unique(_II __first, _II __last)\n     {\n-      for ( ; __first != __last; ++__first)\n+      for (; __first != __last; ++__first)\n \tinsert_unique(*__first);\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline void\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(iterator __position)\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(iterator __position)\n     {\n-      _Link_type __y = static_cast<\n-\t_Link_type>(_Rb_tree_rebalance_for_erase(__position._M_node,\n-\t\t\t\t\t\t this->_M_impl._M_header));\n+      _Link_type __y =\n+\tstatic_cast<_Link_type>(_Rb_tree_rebalance_for_erase\n+\t\t\t\t(__position._M_node,\n+\t\t\t\t this->_M_impl._M_header));\n       destroy_node(__y);\n       --_M_impl._M_node_count;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::erase(const _Key& __x)\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    erase(const _Key& __x)\n     {\n       pair<iterator,iterator> __p = equal_range(__x);\n       size_type __n = std::distance(__p.first, __p.second);\n@@ -1021,7 +1029,7 @@ namespace std\n   template<typename _Key, typename _Val, typename _KoV,\n            typename _Compare, typename _Alloc>\n     typename _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::_Link_type\n-    _Rb_tree<_Key,_Val,_KoV,_Compare,_Alloc>::\n+    _Rb_tree<_Key, _Val, _KoV, _Compare, _Alloc>::\n     _M_copy(_Const_Link_type __x, _Link_type __p)\n     {\n       // Structural copy.  __x and __p must be non-null.\n@@ -1057,7 +1065,8 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::_M_erase(_Link_type __x)\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    _M_erase(_Link_type __x)\n     {\n       // Erase without rebalancing.\n       while (__x != 0)\n@@ -1072,7 +1081,7 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     erase(iterator __first, iterator __last)\n     {\n       if (__first == begin() && __last == end())\n@@ -1084,7 +1093,7 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     void\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     erase(const _Key* __first, const _Key* __last)\n     {\n       while (__first != __last)\n@@ -1093,8 +1102,9 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::find(const _Key& __k)\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n+    find(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n       _Link_type __y = _M_end(); // Last node which is not less than __k.\n@@ -1106,14 +1116,15 @@ namespace std\n \t  __x = _S_right(__x);\n \n       iterator __j = iterator(__y);\n-      return (__j == end() \n-\t  || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;\n+      return (__j == end()\n+\t      || _M_impl._M_key_compare(__k,\n+\t\t\t\t\t_S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     find(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n@@ -1127,14 +1138,15 @@ namespace std\n \t   __x = _S_right(__x);\n        }\n      const_iterator __j = const_iterator(__y);\n-     return (__j == end() \n-\t  || _M_impl._M_key_compare(__k, _S_key(__j._M_node))) ? end() : __j;\n+     return (__j == end()\n+\t     || _M_impl._M_key_compare(__k, \n+\t\t\t\t       _S_key(__j._M_node))) ? end() : __j;\n     }\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::size_type\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::size_type\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     count(const _Key& __k) const\n     {\n       pair<const_iterator, const_iterator> __p = equal_range(__k);\n@@ -1144,8 +1156,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     lower_bound(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n@@ -1162,8 +1174,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     lower_bound(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n@@ -1180,8 +1192,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     upper_bound(const _Key& __k)\n     {\n       _Link_type __x = _M_begin(); // Current node.\n@@ -1198,8 +1210,8 @@ namespace std\n \n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n-    typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::const_iterator\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::const_iterator\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     upper_bound(const _Key& __k) const\n     {\n       _Const_Link_type __x = _M_begin(); // Current node.\n@@ -1217,10 +1229,10 @@ namespace std\n   template<typename _Key, typename _Val, typename _KeyOfValue,\n            typename _Compare, typename _Alloc>\n     inline\n-    pair<typename _Rb_tree<_Key,_Val,_KeyOfValue,\n-\t\t\t   _Compare,_Alloc>::iterator,\n-\t typename _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::iterator>\n-    _Rb_tree<_Key,_Val,_KeyOfValue,_Compare,_Alloc>::\n+    pair<typename _Rb_tree<_Key, _Val, _KeyOfValue,\n+\t\t\t   _Compare, _Alloc>::iterator,\n+\t typename _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::iterator>\n+    _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n     equal_range(const _Key& __k)\n     { return pair<iterator, iterator>(lower_bound(__k), upper_bound(__k)); }\n "}]}