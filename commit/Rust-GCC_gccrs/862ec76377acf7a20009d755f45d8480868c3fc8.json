{"sha": "862ec76377acf7a20009d755f45d8480868c3fc8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODYyZWM3NjM3N2FjZjdhMjAwMDlkNzU1ZjQ1ZDg0ODA4NjhjM2ZjOA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2018-11-27T15:51:01Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2018-11-27T15:51:01Z"}, "message": "compiler: import inlinable functions from package data\n    \n    Start reading the export data generated by the last change in this\n    series.  At this point we will inline direct calls to empty functions\n    and methods defined in different packages.\n    \n    Reviewed-on: https://go-review.googlesource.com/c/150062\n\nFrom-SVN: r266517", "tree": {"sha": "25de4037daed56b9de9e55e305cc684602cef5a2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/25de4037daed56b9de9e55e305cc684602cef5a2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/862ec76377acf7a20009d755f45d8480868c3fc8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862ec76377acf7a20009d755f45d8480868c3fc8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/862ec76377acf7a20009d755f45d8480868c3fc8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/862ec76377acf7a20009d755f45d8480868c3fc8/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "56c79e7f5d21660c2e16b2e17d5b48d1df10d92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56c79e7f5d21660c2e16b2e17d5b48d1df10d92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56c79e7f5d21660c2e16b2e17d5b48d1df10d92f"}], "stats": {"total": 545, "additions": 512, "deletions": 33}, "files": [{"sha": "01781edb50cc1aff42416d980d6c2225ecd4f4f1", "filename": "gcc/go/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2FChangeLog?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -1,3 +1,8 @@\n+2018-11-27  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* go-gcc.cc (Gcc_backend::function): Handle function_only_inline\n+\tflag.\n+\n 2018-11-13  David Malcolm  <dmalcolm@redhat.com>\n \n \t* go-gcc-diagnostics.cc: Replace \"source_location\" with \"location_t\"."}, {"sha": "32b91c1924fd710598317641bac0d51fc05bbc9e", "filename": "gcc/go/go-gcc.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgo-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgo-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgo-gcc.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -3086,6 +3086,11 @@ Gcc_backend::function(Btype* fntype, const std::string& name,\n     TREE_THIS_VOLATILE(decl) = 1;\n   if ((flags & function_in_unique_section) != 0)\n     resolve_unique_section(decl, 0, 1);\n+  if ((flags & function_only_inline) != 0)\n+    {\n+      DECL_EXTERNAL(decl) = 1;\n+      DECL_DECLARED_INLINE_P(decl) = 1;\n+    }\n \n   go_preserve_from_gc(decl);\n   return new Bfunction(decl);"}, {"sha": "df344390eb81f0a34507d4110227a343a1154c10", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -1,4 +1,4 @@\n-3ecc845c337c15d9a19ed8d277e5ee9eaf49c3ad\n+f551ab95f46c3d7bb7c032711e10b03bfa995ee2\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "6bca42e11edce8800fff1b7953c089966e0f9e25", "filename": "gcc/go/gofrontend/backend.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fbackend.h?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -726,6 +726,13 @@ class Backend\n   // possible.  This is used for field tracking.\n   static const unsigned int function_in_unique_section = 1 << 5;\n \n+  // Set if the function should be available for inlining in the\n+  // backend, but should not be emitted as a standalone function.  Any\n+  // call to the function that is not inlined should be treated as a\n+  // call to a function defined in a different compilation unit.  This\n+  // is like a C99 function marked inline but not extern.\n+  static const unsigned int function_only_inline = 1 << 6;\n+\n   // Declare or define a function of FNTYPE.\n   // NAME is the Go name of the function.  ASM_NAME, if not the empty\n   // string, is the name that should be used in the symbol table; this"}, {"sha": "db7c9811d4af275b60fb300e3db926cdd8387fac", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -9785,6 +9785,15 @@ Call_expression::do_lower(Gogo* gogo, Named_object* function,\n \t}\n     }\n \n+  // If this is a call to an imported function for which we have an\n+  // inlinable function body, add it to the list of functions to give\n+  // to the backend as inlining opportunities.\n+  Func_expression* fe = this->fn_->func_expression();\n+  if (fe != NULL\n+      && fe->named_object()->is_function_declaration()\n+      && fe->named_object()->func_declaration_value()->has_imported_body())\n+    gogo->add_imported_inlinable_function(fe->named_object());\n+\n   return this;\n }\n "}, {"sha": "d8da232bbf036ea7a63b88c75b9b6218ed4e2424", "filename": "gcc/go/gofrontend/go.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgo.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -97,8 +97,6 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n \t}\n     }\n \n-  ::gogo->linemap()->stop();\n-\n   ::gogo->clear_file_scope();\n \n   // If the global predeclared names are referenced but not defined,\n@@ -122,6 +120,10 @@ go_parse_input_files(const char** filenames, unsigned int filename_count,\n   // form which is easier to use.\n   ::gogo->lower_parse_tree();\n \n+  // At this point we have handled all inline functions, so we no\n+  // longer need the linemap.\n+  ::gogo->linemap()->stop();\n+\n   // Create function descriptors as needed.\n   ::gogo->create_function_descriptors();\n "}, {"sha": "552de18804daa99981de037112f7cf8ec70fc24e", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 305, "deletions": 18, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -62,7 +62,9 @@ Gogo::Gogo(Backend* backend, Linemap* linemap, int, int pointer_size)\n     specific_type_functions_are_written_(false),\n     named_types_are_converted_(false),\n     analysis_sets_(),\n-    gc_roots_()\n+    gc_roots_(),\n+    imported_inlinable_functions_(),\n+    imported_inline_functions_()\n {\n   const Location loc = Linemap::predeclared_location();\n \n@@ -1557,6 +1559,13 @@ Gogo::write_globals()\n \t}\n     }\n \n+  // Output inline functions, which are in different packages.\n+  for (std::vector<Named_object*>::const_iterator p =\n+\t this->imported_inline_functions_.begin();\n+       p != this->imported_inline_functions_.end();\n+       ++p)\n+    (*p)->get_backend(this, const_decls, type_decls, func_decls);\n+\n   // Register global variables with the garbage collector.\n   this->register_gc_vars(var_gc, init_stmts, init_bfn);\n \n@@ -2234,6 +2243,20 @@ Gogo::declare_package_function(const std::string& name, Function_type* type,\n \t\t\t\t\t\t\t      location);\n }\n \n+// Add a function declaration to the list of functions we may want to\n+// inline.\n+\n+void\n+Gogo::add_imported_inlinable_function(Named_object* no)\n+{\n+  go_assert(no->is_function_declaration());\n+  Function_declaration* fd = no->func_declaration_value();\n+  if (fd->is_on_inlinable_list())\n+    return;\n+  this->imported_inlinable_functions_.push_back(no);\n+  fd->set_is_on_inlinable_list();\n+}\n+\n // Define a type which was already declared.\n \n void\n@@ -2881,6 +2904,17 @@ Gogo::lower_parse_tree()\n   Lower_parse_tree lower_parse_tree(this, NULL);\n   this->traverse(&lower_parse_tree);\n \n+  // If we found any functions defined in other packages that are\n+  // inlinables, import their bodies and turn them into functions.\n+  //\n+  // Note that as we import inlinable functions we may find more\n+  // inlinable functions, so don't use an iterator.\n+  for (size_t i = 0; i < this->imported_inlinable_functions_.size(); i++)\n+    {\n+      Named_object* no = this->imported_inlinable_functions_[i];\n+      no->func_declaration_value()->import_function_body(this, no);\n+    }\n+\n   // There might be type definitions that involve expressions such as the\n   // array length.  Make sure to lower these expressions as well.  Otherwise,\n   // errors hidden within a type can introduce unexpected errors into later\n@@ -5081,7 +5115,8 @@ Function::Function(Function_type* type, Named_object* enclosing, Block* block,\n     results_are_named_(false), is_unnamed_type_stub_method_(false),\n     calls_recover_(false), is_recover_thunk_(false), has_recover_thunk_(false),\n     calls_defer_retaddr_(false), is_type_specific_function_(false),\n-    in_unique_section_(false), export_for_inlining_(false)\n+    in_unique_section_(false), export_for_inlining_(false),\n+    is_inline_only_(false)\n {\n }\n \n@@ -5440,15 +5475,15 @@ Function::export_func(Export* exp, const std::string& name) const\n     block = this->block_;\n   Function::export_func_with_type(exp, name, this->type_,\n \t\t\t\t  this->is_method() && this->nointerface(),\n-\t\t\t\t  block);\n+\t\t\t\t  block, this->location_);\n }\n \n // Export a function with a type.\n \n void\n Function::export_func_with_type(Export* exp, const std::string& name,\n \t\t\t\tconst Function_type* fntype, bool nointerface,\n-\t\t\t\tBlock* block)\n+\t\t\t\tBlock* block, Location loc)\n {\n   exp->write_c_string(\"func \");\n \n@@ -5542,12 +5577,15 @@ Function::export_func_with_type(Export* exp, const std::string& name,\n       efb.indent();\n       efb.write_c_string(\"// \");\n       efb.write_string(Linemap::location_to_file(block->start_location()));\n+      efb.write_char(':');\n+      char buf[100];\n+      snprintf(buf, sizeof buf, \"%d\", Linemap::location_to_line(loc));\n+      efb.write_c_string(buf);\n       efb.write_char('\\n');\n       block->export_block(&efb);\n \n       const std::string& body(efb.body());\n \n-      char buf[100];\n       snprintf(buf, sizeof buf, \" <inl:%lu>\\n\",\n \t       static_cast<unsigned long>(body.length()));\n       exp->write_c_string(buf);\n@@ -5564,7 +5602,8 @@ Function::import_func(Import* imp, std::string* pname,\n \t\t      Typed_identifier_list** pparameters,\n \t\t      Typed_identifier_list** presults,\n \t\t      bool* is_varargs,\n-\t\t      bool* nointerface)\n+\t\t      bool* nointerface,\n+\t\t      std::string* body)\n {\n   imp->require_c_string(\"func \");\n \n@@ -5666,6 +5705,7 @@ Function::import_func(Import* imp, std::string* pname,\n     {\n       imp->require_semicolon_if_old_version();\n       imp->require_c_string(\"\\n\");\n+      body->clear();\n     }\n   else\n     {\n@@ -5694,11 +5734,7 @@ Function::import_func(Import* imp, std::string* pname,\n \t  return;\n \t}\n \n-      imp->read(static_cast<size_t>(llen));\n-\n-      // Here we should record the body for later parsing if we see a\n-      // call to this function.  This is not yet implemented.  For now\n-      // we just discard the information.\n+      *body = imp->read(static_cast<size_t>(llen));\n     }\n }\n \n@@ -5711,7 +5747,6 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n     {\n       unsigned int flags = 0;\n       bool is_init_fn = false;\n-      Type* rtype = NULL;\n       if (no->package() != NULL)\n         ;\n       else if (this->enclosing_ != NULL || Gogo::is_thunk(no))\n@@ -5735,10 +5770,12 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n         {\n \t  if (!this->is_unnamed_type_stub_method_)\n \t    flags |= Backend::function_is_visible;\n-\t  if (this->type_->is_method())\n-\t    rtype = this->type_->receiver()->type();\n         }\n \n+      Type* rtype = NULL;\n+      if (this->type_->is_method())\n+\trtype = this->type_->receiver()->type();\n+\n       std::string asm_name;\n       if (!this->asm_name_.empty())\n \t{\n@@ -5757,7 +5794,7 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t  asm_name = no->name();\n \t}\n       else\n-\tasm_name = gogo->function_asm_name(no->name(), NULL, rtype);\n+\tasm_name = gogo->function_asm_name(no->name(), no->package(), rtype);\n \n       // If a function calls the predeclared recover function, we\n       // can't inline it, because recover behaves differently in a\n@@ -5803,6 +5840,9 @@ Function::get_or_make_decl(Gogo* gogo, Named_object* no)\n \t  || (this->is_method() && this->nointerface()))\n \tflags |= Backend::function_in_unique_section;\n \n+      if (this->is_inline_only_)\n+\tflags |= Backend::function_only_inline;\n+\n       Btype* functype = this->type_->get_backend_fntype(gogo);\n       this->fndecl_ =\n           gogo->backend()->function(functype, no->get_id(gogo), asm_name,\n@@ -6449,6 +6489,108 @@ Block::export_block(Export_function_body* efb)\n     }\n }\n \n+// Add exported block data to SET, reading from BODY starting at OFF.\n+// Returns whether the import succeeded.\n+\n+bool\n+Block::import_block(Block* set, Import_function_body *ifb, Location loc)\n+{\n+  Location eloc = ifb->location();\n+  Location sloc = loc;\n+  const std::string& body(ifb->body());\n+  size_t off = ifb->off();\n+  while (off < body.length())\n+    {\n+      int indent = ifb->indent();\n+      if (off + indent >= body.length())\n+\t{\n+\t  go_error_at(eloc,\n+\t\t      \"invalid export data for %qs: insufficient indentation\",\n+\t\t      ifb->name().c_str());\n+\t  return false;\n+\t}\n+      for (int i = 0; i < indent - 1; i++)\n+\t{\n+\t  if (body[off + i] != ' ')\n+\t    {\n+\t      go_error_at(eloc,\n+\t\t\t  \"invalid export data for %qs: bad indentation\",\n+\t\t\t  ifb->name().c_str());\n+\t      return false;\n+\t    }\n+\t}\n+\n+      bool at_end = false;\n+      if (body[off + indent - 1] == '}')\n+\tat_end = true;\n+      else if (body[off + indent - 1] != ' ')\n+\t{\n+\t  go_error_at(eloc,\n+\t\t      \"invalid export data for %qs: bad indentation\",\n+\t\t      ifb->name().c_str());\n+\t  return false;\n+\t}\n+\n+      off += indent;\n+\n+      size_t nl = body.find('\\n', off);\n+      if (nl == std::string::npos)\n+\t{\n+\t  go_error_at(eloc, \"invalid export data for %qs: missing newline\",\n+\t\t      ifb->name().c_str());\n+\t  return false;\n+\t}\n+\n+      size_t lineno_pos = body.find(\" //\", off);\n+      if (lineno_pos == std::string::npos || lineno_pos >= nl)\n+\t{\n+\t  go_error_at(eloc, \"invalid export data for %qs: missing line number\",\n+\t\t      ifb->name().c_str());\n+\t  return false;\n+\t}\n+\n+      unsigned int lineno = 0;\n+      for (size_t i = lineno_pos + 3; i < nl; ++i)\n+\t{\n+\t  char c = body[i];\n+\t  if (c < '0' || c > '9')\n+\t    {\n+\t      go_error_at(loc,\n+\t\t\t  \"invalid export data for %qs: invalid line number\",\n+\t\t\t  ifb->name().c_str());\n+\t      return false;\n+\t    }\n+\t  lineno = lineno * 10 + c - '0';\n+\t}\n+\n+      ifb->gogo()->linemap()->start_line(lineno, 1);\n+      sloc = ifb->gogo()->linemap()->get_location(0);\n+\n+      if (at_end)\n+\t{\n+\t  off = nl + 1;\n+\t  break;\n+\t}\n+\n+      ifb->set_off(off);\n+      Statement* s = Statement::import_statement(ifb, sloc);\n+      if (s == NULL)\n+\treturn false;\n+\n+      set->add_statement(s);\n+\n+      size_t at = ifb->off();\n+      if (at < nl + 1)\n+\toff = nl + 1;\n+      else\n+\toff = at;\n+    }\n+\n+  ifb->set_off(off);\n+  set->set_end_location(sloc);\n+  return true;\n+}\n+\n // Convert a block to the backend representation.\n \n Bblock*\n@@ -6607,6 +6749,144 @@ Function_declaration::set_nointerface()\n   this->pragmas_ |= GOPRAGMA_NOINTERFACE;\n }\n \n+// Import an inlinable function.  This is used for an inlinable\n+// function whose body is recorded in the export data.  Parse the\n+// export data into a Block and create a regular function using that\n+// Block as its body.  Redeclare this function declaration as the\n+// function.\n+\n+void\n+Function_declaration::import_function_body(Gogo* gogo, Named_object* no)\n+{\n+  go_assert(no->func_declaration_value() == this);\n+  go_assert(no->package() != NULL);\n+  const std::string& body(this->imported_body_);\n+  go_assert(!body.empty());\n+\n+  Location orig_loc = no->location();\n+\n+  // Read the \"//FILE:LINE\" comment starts the export data.\n+\n+  size_t indent = 1;\n+  if (this->is_method())\n+    indent = 2;\n+  size_t i = 0;\n+  for (; i < indent; i++)\n+    {\n+      if (body.at(i) != ' ')\n+\t{\n+\t  go_error_at(this->location_,\n+\t\t      \"invalid export body for %qs: bad initial indentation\",\n+\t\t      no->message_name().c_str());\n+\t  return;\n+\t}\n+    }\n+\n+  if (body.substr(i, 2) != \"//\")\n+    {\n+      go_error_at(this->location_,\n+\t\t  \"invalid export body for %qs: missing file comment\",\n+\t\t  no->message_name().c_str());\n+      return;\n+    }\n+\n+  size_t colon = body.find(':', i + 2);\n+  size_t nl = body.find('\\n', i + 2);\n+  if (nl == std::string::npos)\n+    {\n+      go_error_at(this->location_,\n+\t\t  \"invalid export body for %qs: missing file name\",\n+\t\t  no->message_name().c_str());\n+      return;\n+    }\n+  if (colon == std::string::npos || nl < colon)\n+    {\n+      go_error_at(this->location_,\n+\t\t  \"invalid export body for %qs: missing initial line number\",\n+\t\t  no->message_name().c_str());\n+      return;\n+    }\n+\n+  std::string file = body.substr(i + 2, colon - (i + 2));\n+  std::string linestr = body.substr(colon + 1, nl - (colon + 1));\n+  char* end;\n+  long linenol = strtol(linestr.c_str(), &end, 10);\n+  if (*end != '\\0')\n+    {\n+      go_error_at(this->location_,\n+\t\t  \"invalid export body for %qs: invalid initial line number\",\n+\t\t  no->message_name().c_str());\n+      return;\n+    }\n+  unsigned int lineno = static_cast<unsigned int>(linenol);\n+\n+  // Turn the file/line into a location.\n+\n+  char* alc = new char[file.length() + 1];\n+  memcpy(alc, file.data(), file.length());\n+  alc[file.length()] = '\\0';\n+  gogo->linemap()->start_file(alc, lineno);\n+  gogo->linemap()->start_line(lineno, 1);\n+  Location start_loc = gogo->linemap()->get_location(0);\n+\n+  // Define the function with an outer block that declares the\n+  // parameters.\n+\n+  Function_type* fntype = this->fntype_;\n+\n+  Block* outer = new Block(NULL, start_loc);\n+\n+  Function* fn = new Function(fntype, NULL, outer, start_loc);\n+  fn->set_is_inline_only();\n+\n+  if (fntype->is_method())\n+    {\n+      const Typed_identifier* receiver = fntype->receiver();\n+      Variable* recv_param = new Variable(receiver->type(), NULL, false,\n+\t\t\t\t\t  true, true, start_loc);\n+      outer->bindings()->add_variable(receiver->name(), NULL, recv_param);\n+    }\n+\n+  const Typed_identifier_list* params = fntype->parameters();\n+  bool is_varargs = fntype->is_varargs();\n+  if (params != NULL)\n+    {\n+      for (Typed_identifier_list::const_iterator p = params->begin();\n+\t   p != params->end();\n+\t   ++p)\n+\t{\n+\t  Variable* param = new Variable(p->type(), NULL, false, true, false,\n+\t\t\t\t\t start_loc);\n+\t  if (is_varargs && p + 1 == params->end())\n+\t    param->set_is_varargs_parameter();\n+\t  outer->bindings()->add_variable(p->name(), NULL, param);\n+\t}\n+    }\n+\n+  fn->create_result_variables(gogo);\n+\n+  if (!fntype->is_method())\n+    {\n+      const Package* package = no->package();\n+      no = package->bindings()->add_function(no->name(), package, fn);\n+    }\n+  else\n+    {\n+      Named_type* rtype = fntype->receiver()->type()->deref()->named_type();\n+      go_assert(rtype != NULL);\n+      no = rtype->add_method(no->name(), fn);\n+    }\n+\n+  Import_function_body ifb(gogo, orig_loc, no, body, nl + 1, outer, indent);\n+\n+  if (!Block::import_block(outer, &ifb, start_loc))\n+    return;\n+\n+  gogo->lower_block(no, outer);\n+\n+  gogo->add_imported_inline_function(no);\n+}\n+\n // Return the function descriptor.\n \n Expression*\n@@ -8121,14 +8401,21 @@ Bindings::new_definition(Named_object* old_object, Named_object* new_object)\n       {\n \t// We declare the hash and equality functions before defining\n \t// them, because we sometimes see that we need the declaration\n-\t// while we are in the middle of a different function.  We\n-\t// declare the main function before the user defines it, to\n+\t// while we are in the middle of a different function.\n+\t//\n+\t// We declare the main function before the user defines it, to\n \t// give better error messages.\n+\t//\n+\t// We declare inline functions before we define them, as we\n+\t// only define them if we need them.\n \tif (new_object->is_function()\n \t    && ((Linemap::is_predeclared_location(old_object->location())\n \t\t && Linemap::is_predeclared_location(new_object->location()))\n \t\t|| (Gogo::unpack_hidden_name(old_object->name()) == \"main\"\n-\t\t    && Linemap::is_unknown_location(old_object->location()))))\n+\t\t    && Linemap::is_unknown_location(old_object->location()))\n+\t\t|| (new_object->package() != NULL\n+\t\t    && old_object->func_declaration_value()->has_imported_body()\n+\t\t    && new_object->func_value()->is_inline_only())))\n \t  {\n             Function_type* old_type =\n                 old_object->func_declaration_value()->type();"}, {"sha": "1c79f6fda57e86b54cbc22f64471067c102ae1ea", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 75, "deletions": 9, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -43,6 +43,7 @@ class Backend;\n class Export;\n class Export_function_body;\n class Import;\n+class Import_function_body;\n class Bexpression;\n class Btype;\n class Bstatement;\n@@ -420,6 +421,17 @@ class Gogo\n   Named_object*\n   declare_package_function(const std::string&, Function_type*, Location);\n \n+  // Add a function declaration to the list of functions we may want\n+  // to inline.\n+  void\n+  add_imported_inlinable_function(Named_object*);\n+\n+  // Add a function to the list of functions that we do want to\n+  // inline.\n+  void\n+  add_imported_inline_function(Named_object* no)\n+  { this->imported_inline_functions_.push_back(no); }\n+\n   // Add a label.\n   Label*\n   add_label_definition(const std::string&, Location);\n@@ -661,7 +673,7 @@ class Gogo\n   propagate_escape(Escape_context*, Node*);\n \n   // Add notes about the escape level of a function's input and output\n-  // parameters for exporting and importing top level functions. \n+  // parameters for exporting and importing top level functions.\n   void\n   tag_function(Escape_context*, Named_object*);\n \n@@ -726,7 +738,7 @@ class Gogo\n   void\n   simplify_thunk_statements();\n \n-  // Dump AST if -fgo-dump-ast is set \n+  // Dump AST if -fgo-dump-ast is set.\n   void\n   dump_ast(const char* basename);\n \n@@ -1062,6 +1074,12 @@ class Gogo\n   std::vector<Analysis_set> analysis_sets_;\n   // A list of objects to add to the GC roots.\n   std::vector<Expression*> gc_roots_;\n+  // A list of function declarations with imported bodies that we may\n+  // want to inline.\n+  std::vector<Named_object*> imported_inlinable_functions_;\n+  // A list of functions that we want to inline.  These will be sent\n+  // to the backend.\n+  std::vector<Named_object*> imported_inline_functions_;\n };\n \n // A block of statements.\n@@ -1144,6 +1162,10 @@ class Block\n   void\n   export_block(Export_function_body*);\n \n+  // Turn exported block data into a block.\n+  static bool\n+  import_block(Block*, Import_function_body*, Location);\n+\n   // Convert the block to the backend representation.\n   Bblock*\n   get_backend(Translate_context*);\n@@ -1419,6 +1441,17 @@ class Function\n   set_export_for_inlining()\n   { this->export_for_inlining_ = true; }\n \n+  // Return whether this function is inline only.\n+  bool\n+  is_inline_only() const\n+  { return this->is_inline_only_; }\n+\n+  // Mark the function as inline only: the body should not be emitted\n+  // if it is not inlined.\n+  void\n+  set_is_inline_only()\n+  { this->is_inline_only_ = true; }\n+\n   // Swap with another function.  Used only for the thunk which calls\n   // recover.\n   void\n@@ -1476,14 +1509,15 @@ class Function\n   // Export a function with a type.\n   static void\n   export_func_with_type(Export*, const std::string& name,\n-\t\t\tconst Function_type*, bool nointerface, Block* block);\n+\t\t\tconst Function_type*, bool nointerface, Block* block,\n+\t\t\tLocation);\n \n   // Import a function.\n   static void\n   import_func(Import*, std::string* pname, Typed_identifier** receiver,\n \t      Typed_identifier_list** pparameters,\n \t      Typed_identifier_list** presults, bool* is_varargs,\n-\t      bool* nointerface);\n+\t      bool* nointerface, std::string* body);\n \n  private:\n   // Type for mapping from label names to Label objects.\n@@ -1557,6 +1591,9 @@ class Function\n   // True if we should export the body of this function for\n   // cross-package inlining.\n   bool export_for_inlining_ : 1;\n+  // True if this function is inline only: if it should not be emitted\n+  // if it is not inlined.\n+  bool is_inline_only_ : 1;\n };\n \n // A snapshot of the current binding state.\n@@ -1600,7 +1637,8 @@ class Function_declaration\n  public:\n   Function_declaration(Function_type* fntype, Location location)\n     : fntype_(fntype), location_(location), asm_name_(), descriptor_(NULL),\n-      fndecl_(NULL), pragmas_(0)\n+      fndecl_(NULL), pragmas_(0), imported_body_(),\n+      is_on_inlinable_list_(false)\n   { }\n \n   Function_type*\n@@ -1646,6 +1684,30 @@ class Function_declaration\n   void\n   set_nointerface();\n \n+  // Whether we have an imported function body.\n+  bool\n+  has_imported_body() const\n+  { return !this->imported_body_.empty(); }\n+\n+  // Record the imported body of this function.\n+  void\n+  set_imported_body(const std::string& imported_body)\n+  { this->imported_body_ = imported_body; }\n+\n+  // Whether this declaration is on the list of inlinable functions.\n+  bool\n+  is_on_inlinable_list() const\n+  { return this->is_on_inlinable_list_; }\n+\n+  // Set that this function is on the list of inlinable functions.\n+  void\n+  set_is_on_inlinable_list()\n+  { this->is_on_inlinable_list_ = true; }\n+\n+  // Import the function body, creating a function.\n+  void\n+  import_function_body(Gogo*, Named_object*);\n+\n   // Return an expression for the function descriptor, given the named\n   // object for this function.  This may only be called for functions\n   // without a closure.  This will be an immutable struct with one\n@@ -1673,7 +1735,7 @@ class Function_declaration\n   {\n     Function::export_func_with_type(exp, name, this->fntype_,\n \t\t\t\t    this->is_method() && this->nointerface(),\n-\t\t\t\t    NULL);\n+\t\t\t\t    NULL, this->location_);\n   }\n \n   // Check that the types used in this declaration's signature are defined.\n@@ -1694,6 +1756,10 @@ class Function_declaration\n   Bfunction* fndecl_;\n   // Pragmas for this function.  This is a set of GOPRAGMA bits.\n   unsigned int pragmas_;\n+  // Export data for function body if imported from a different package.\n+  std::string imported_body_;\n+  // Whether this declaration is already on the list of inlinable functions.\n+  bool is_on_inlinable_list_;\n };\n \n // A variable.\n@@ -1789,7 +1855,7 @@ class Variable\n   bool\n   is_in_heap() const\n   {\n-    return this->is_address_taken_ \n+    return this->is_address_taken_\n       && this->escapes_\n       && !this->is_global_;\n   }\n@@ -2103,7 +2169,7 @@ class Result_variable\n   void\n   set_non_escaping_address_taken()\n   { this->is_non_escaping_address_taken_ = true; }\n-  \n+\n   // Return whether this variable escapes the function it is declared in.\n   bool\n   escapes()\n@@ -3200,7 +3266,7 @@ class Package\n \n   // Return the bindings.\n   Bindings*\n-  bindings()\n+  bindings() const\n   { return this->bindings_; }\n \n   // Type used to map import names to package aliases."}, {"sha": "7ee3cb6f991c785bc8de0b9f9303f896d4fa84d5", "filename": "gcc/go/gofrontend/import.cc", "status": "modified", "additions": 15, "deletions": 2, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fimport.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -744,8 +744,9 @@ Import::import_func(Package* package)\n   Typed_identifier_list* results;\n   bool is_varargs;\n   bool nointerface;\n-  Function::import_func(this, &name, &receiver,\n-\t\t\t&parameters, &results, &is_varargs, &nointerface);\n+  std::string body;\n+  Function::import_func(this, &name, &receiver, &parameters, &results,\n+\t\t\t&is_varargs, &nointerface, &body);\n   Function_type *fntype = Type::make_function_type(receiver, parameters,\n \t\t\t\t\t\t   results, this->location_);\n   if (is_varargs)\n@@ -788,6 +789,8 @@ Import::import_func(Package* package)\n \n   if (nointerface)\n     no->func_declaration_value()->set_nointerface();\n+  if (!body.empty() && !no->func_declaration_value()->has_imported_body())\n+    no->func_declaration_value()->set_imported_body(body);\n \n   return no;\n }\n@@ -1395,3 +1398,13 @@ Stream_from_file::do_advance(size_t skip)\n \tthis->data_.clear();\n     }\n }\n+\n+// Class Import_function_body.\n+\n+// The name of the function we are parsing.\n+\n+const std::string&\n+Import_function_body::name() const\n+{\n+  return this->named_object_->name();\n+}"}, {"sha": "3fc05dfcaa788afb2d1f81a3c8b7476049c4afe1", "filename": "gcc/go/gofrontend/import.h", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fimport.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fimport.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fimport.h?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -11,6 +11,7 @@\n #include \"go-linemap.h\"\n \n class Gogo;\n+class Block;\n class Package;\n class Type;\n class Named_object;\n@@ -464,4 +465,74 @@ class Stream_from_string_ref : public Import::Stream\n   size_t end_;\n };\n \n+// Class to manage importing a function body.  This is passed around\n+// to Statements and Expressions.  It parses the function into the IR.\n+\n+class Import_function_body\n+{\n+ public:\n+  Import_function_body(Gogo* gogo, Location loc, Named_object* named_object,\n+\t\t       const std::string& body, size_t off, Block* block,\n+\t\t       int indent)\n+    : gogo_(gogo), loc_(loc), named_object_(named_object), body_(body),\n+      off_(off), block_(block), indent_(indent)\n+  { }\n+\n+  // The IR.\n+  Gogo*\n+  gogo()\n+  { return this->gogo_; }\n+\n+  // The location to report in an error message.\n+  Location\n+  location() const\n+  { return this->loc_; }\n+\n+  // A reference to the body we are reading.\n+  const std::string&\n+  body() const\n+  { return this->body_; }\n+\n+  // The current offset into the body.\n+  size_t\n+  off()\n+  { return this->off_; }\n+\n+  // Update the offset into the body.\n+  void\n+  set_off(size_t off)\n+  { this->off_ = off; }\n+\n+  // The current block.\n+  Block*\n+  block()\n+  { return this->block_; }\n+\n+  // The current indentation.\n+  int\n+  indent() const\n+  { return this->indent_; }\n+\n+  // The name of the function we are parsing.\n+  const std::string&\n+  name() const;\n+\n+ private:\n+  // The IR.\n+  Gogo* gogo_;\n+  // The location to report in an error message.\n+  Location loc_;\n+  // The function we are parsing.\n+  Named_object* named_object_;\n+  // The exported data we are parsing.  Note that this is a reference;\n+  // the body string must laster longer than this object.\n+  const std::string& body_;\n+  // The current offset into body_.\n+  size_t off_;\n+  // Current block.\n+  Block* block_;\n+  // Current expected indentation level.\n+  int indent_;\n+};\n+\n #endif // !defined(GO_IMPORT_H)"}, {"sha": "60b7a701df24384abf7fa31e37490affcac0eb32", "filename": "gcc/go/gofrontend/statements.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fstatements.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -121,6 +121,14 @@ Statement::determine_types()\n   this->do_determine_types();\n }\n \n+// Read a statement from export data.\n+\n+Statement*\n+Statement::import_statement(Import_function_body*, Location)\n+{\n+  go_unreachable();\n+}\n+\n // If this is a thunk statement, return it.\n \n Thunk_statement*"}, {"sha": "eef86463da035dc20101d721c2a74b4e6d356217", "filename": "gcc/go/gofrontend/statements.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Fstatements.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fstatements.h?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -338,6 +338,10 @@ class Statement\n   export_statement(Export_function_body* efb)\n   { this->do_export_statement(efb); }\n \n+  // Read a statement from export data.\n+  static Statement*\n+  import_statement(Import_function_body*, Location);\n+\n   // Return whether this is a block statement.\n   bool\n   is_block_statement() const"}, {"sha": "27502427baa4a8017f0e9c45961acb6e21b1161e", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/862ec76377acf7a20009d755f45d8480868c3fc8/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=862ec76377acf7a20009d755f45d8480868c3fc8", "patch": "@@ -9865,7 +9865,9 @@ Named_type::add_method(const std::string& name, Function* function)\n   go_assert(!this->is_alias_);\n   if (this->local_methods_ == NULL)\n     this->local_methods_ = new Bindings(NULL);\n-  return this->local_methods_->add_function(name, NULL, function);\n+  return this->local_methods_->add_function(name,\n+\t\t\t\t\t    this->named_object_->package(),\n+\t\t\t\t\t    function);\n }\n \n // Add a method declaration to this type."}]}