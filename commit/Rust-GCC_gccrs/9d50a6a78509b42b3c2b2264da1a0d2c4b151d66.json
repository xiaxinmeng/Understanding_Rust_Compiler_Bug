{"sha": "9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWQ1MGE2YTc4NTA5YjQyYjNjMmIyMjY0ZGExYTBkMmM0YjE1MWQ2Ng==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2019-11-29T14:47:03Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2019-11-29T14:47:03Z"}, "message": "libstdc++:: improve how pretty printers find node types (PR 91997)\n\nThis fixes two related problems.\n\nThe iterators for node-based containers use nested typedefs such as\nstd::list<T>::iterator::_Node to denote their node types. As reported in\nhttps://bugzilla.redhat.com/show_bug.cgi?id=1053438 those typedefs are\nnot always present in the debug info. That means the pretty printers\ncannot find them using gdb.lookup_type (via the find_type helper).\nInstead of looking up the nested typedefs this patch makes the printers\nlook up the actual class templates directly.\n\nA related problem (and the original topic of PR 91997) is that GDB fails\nto find types via gdb.lookup_type when printing a backtrace from a\nnon-C++ functiion: https://sourceware.org/bugzilla/show_bug.cgi?id=25234\nThat is also solved by not looking up the nested typedef.\n\n\tPR libstdc++/91997\n\t* python/libstdcxx/v6/printers.py (find_type): Fail more gracefully\n\tif we run out of base classes to look at.\n\t(llokup_templ_spec, lookup_node_type): New utilities to find node\n\ttypes for node-based containers.\n\t(StdListPrinter.children, NodeIteratorPrinter.__init__)\n\t(NodeIteratorPrinter.to_string, StdSlistPrinter.children)\n\t(StdSlistIteratorPrinter.to_string, StdRbtreeIteratorPrinter.__init__)\n\t(StdMapPrinter.children, StdSetPrinter.children)\n\t(StdForwardListPrinter.children): Use lookup_node_type instead of\n\tfind_type.\n\t(StdListIteratorPrinter.__init__, StdFwdListIteratorPrinter.__init__):\n\tPass name of node type to NodeIteratorPrinter constructor.\n\t(Tr1HashtableIterator.__init__): Rename argument.\n\t(StdHashtableIterator.__init__): Likewise. Use lookup_templ_spec\n\tinstead of find_type.\n\t* testsuite/libstdc++-prettyprinters/59161.cc: Remove workaround for\n\t_Node typedef not being present in debuginfo.\n\t* testsuite/libstdc++-prettyprinters/91997.cc: New test.\n\nFrom-SVN: r278846", "tree": {"sha": "2cec3172960f06b33a6c6ab0af00f9c0faa79498", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cec3172960f06b33a6c6ab0af00f9c0faa79498"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9909a05940ccdb4f85be0d26c2966d6373199f63", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9909a05940ccdb4f85be0d26c2966d6373199f63", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9909a05940ccdb4f85be0d26c2966d6373199f63"}], "stats": {"total": 215, "additions": 173, "deletions": 42}, "files": [{"sha": "83deef2e9fb7a244345f3a24f905f451b57c288a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "patch": "@@ -1,3 +1,25 @@\n+2019-11-29  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/91997\n+\t* python/libstdcxx/v6/printers.py (find_type): Fail more gracefully\n+\tif we run out of base classes to look at.\n+\t(llokup_templ_spec, lookup_node_type): New utilities to find node\n+\ttypes for node-based containers.\n+\t(StdListPrinter.children, NodeIteratorPrinter.__init__)\n+\t(NodeIteratorPrinter.to_string, StdSlistPrinter.children)\n+\t(StdSlistIteratorPrinter.to_string, StdRbtreeIteratorPrinter.__init__)\n+\t(StdMapPrinter.children, StdSetPrinter.children)\n+\t(StdForwardListPrinter.children): Use lookup_node_type instead of\n+\tfind_type.\n+\t(StdListIteratorPrinter.__init__, StdFwdListIteratorPrinter.__init__):\n+\tPass name of node type to NodeIteratorPrinter constructor.\n+\t(Tr1HashtableIterator.__init__): Rename argument.\n+\t(StdHashtableIterator.__init__): Likewise. Use lookup_templ_spec\n+\tinstead of find_type.\n+\t* testsuite/libstdc++-prettyprinters/59161.cc: Remove workaround for\n+\t_Node typedef not being present in debuginfo.\n+\t* testsuite/libstdc++-prettyprinters/91997.cc: New test.\n+\n 2019-11-26  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n \n \t* include/debug/helper_functions.h (__valid_range_aux): Use C++98"}, {"sha": "869a828667564fc85fed9b7a24ab56000f16fde8", "filename": "libstdc++-v3/python/libstdcxx/v6/printers.py", "status": "modified", "additions": 98, "deletions": 40, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fpython%2Flibstdcxx%2Fv6%2Fprinters.py?ref=9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "patch": "@@ -94,13 +94,78 @@ def find_type(orig, name):\n         # The type was not found, so try the superclass.  We only need\n         # to check the first superclass, so we don't bother with\n         # anything fancier here.\n-        field = typ.fields()[0]\n-        if not field.is_base_class:\n+        fields = typ.fields()\n+        if len(fields) and fields[0].is_base_class:\n+            typ = fields[0].type\n+        else:\n             raise ValueError(\"Cannot find type %s::%s\" % (str(orig), name))\n-        typ = field.type\n \n _versioned_namespace = '__8::'\n \n+def lookup_templ_spec(templ, *args):\n+    \"\"\"\n+    Lookup template specialization templ<args...>\n+    \"\"\"\n+    t = '{}<{}>'.format(templ, ', '.join([str(a) for a in args]))\n+    try:\n+        return gdb.lookup_type(t)\n+    except gdb.error as e:\n+        # Type not found, try again in versioned namespace.\n+        global _versioned_namespace\n+        if _versioned_namespace and _versioned_namespace not in templ:\n+            t = t.replace('::', '::' + _versioned_namespace, 1)\n+            try:\n+                return gdb.lookup_type(t)\n+            except gdb.error:\n+                # If that also fails, rethrow the original exception\n+                pass\n+        raise e\n+\n+# Use this to find container node types instead of find_type,\n+# see https://gcc.gnu.org/bugzilla/show_bug.cgi?id=91997 for details.\n+def lookup_node_type(nodename, containertype):\n+    \"\"\"\n+    Lookup specialization of template NODENAME corresponding to CONTAINERTYPE.\n+    e.g. if NODENAME is '_List_node' and CONTAINERTYPE is std::list<int>\n+    then return the type std::_List_node<int>.\n+    Returns None if not found.\n+    \"\"\"\n+    # If nodename is unqualified, assume it's in namespace std.\n+    if '::' not in nodename:\n+        nodename = 'std::' + nodename\n+    try:\n+        valtype = find_type(containertype, 'value_type')\n+    except:\n+        valtype = containertype.template_argument(0)\n+    valtype = valtype.strip_typedefs()\n+    try:\n+        return lookup_templ_spec(nodename, valtype)\n+    except gdb.error as e:\n+        # For debug mode containers the node is in std::__cxx1998.\n+        if is_member_of_namespace(nodename, 'std'):\n+            if is_member_of_namespace(containertype, 'std::__cxx1998',\n+                                      'std::__debug', '__gnu_debug'):\n+                nodename = nodename.replace('::', '::__cxx1998::', 1)\n+                return lookup_templ_spec(nodename, valtype)\n+                try:\n+                    return lookup_templ_spec(nodename, valtype)\n+                except gdb.error:\n+                    pass\n+        return None\n+\n+def is_member_of_namespace(typ, *namespaces):\n+    \"\"\"\n+    Test whether a type is a member of one of the specified namespaces.\n+    The type can be specified as a string or a gdb.Type object.\n+    \"\"\"\n+    if type(typ) is gdb.Type:\n+        typ = str(typ)\n+    typ = strip_versioned_namespace(typ)\n+    for namespace in namespaces:\n+        if typ.startswith(namespace + '::'):\n+            return True\n+    return False\n+\n def is_specialization_of(x, template_name):\n     \"Test if a type is a given template instantiation.\"\n     global _versioned_namespace\n@@ -253,40 +318,40 @@ def __init__(self, typename, val):\n         self.val = val\n \n     def children(self):\n-        nodetype = find_type(self.val.type, '_Node')\n-        nodetype = nodetype.strip_typedefs().pointer()\n+        nodetype = lookup_node_type('_List_node', self.val.type).pointer()\n         return self._iterator(nodetype, self.val['_M_impl']['_M_node'])\n \n     def to_string(self):\n-        if self.val['_M_impl']['_M_node'].address == self.val['_M_impl']['_M_node']['_M_next']:\n+        headnode = self.val['_M_impl']['_M_node']\n+        if headnode['_M_next'] == headnode.address:\n             return 'empty %s' % (self.typename)\n         return '%s' % (self.typename)\n \n class NodeIteratorPrinter:\n-    def __init__(self, typename, val, contname):\n+    def __init__(self, typename, val, contname, nodename):\n         self.val = val\n         self.typename = typename\n         self.contname = contname\n+        self.nodetype = lookup_node_type(nodename, val.type)\n \n     def to_string(self):\n         if not self.val['_M_node']:\n             return 'non-dereferenceable iterator for std::%s' % (self.contname)\n-        nodetype = find_type(self.val.type, '_Node')\n-        nodetype = nodetype.strip_typedefs().pointer()\n-        node = self.val['_M_node'].cast(nodetype).dereference()\n+        node = self.val['_M_node'].cast(self.nodetype.pointer()).dereference()\n         return str(get_value_from_list_node(node))\n \n class StdListIteratorPrinter(NodeIteratorPrinter):\n     \"Print std::list::iterator\"\n \n     def __init__(self, typename, val):\n-        NodeIteratorPrinter.__init__(self, typename, val, 'list')\n+        NodeIteratorPrinter.__init__(self, typename, val, 'list', '_List_node')\n \n class StdFwdListIteratorPrinter(NodeIteratorPrinter):\n     \"Print std::forward_list::iterator\"\n \n     def __init__(self, typename, val):\n-        NodeIteratorPrinter.__init__(self, typename, val, 'forward_list')\n+        NodeIteratorPrinter.__init__(self, typename, val, 'forward_list',\n+                                     '_Fwd_list_node')\n \n class StdSlistPrinter:\n     \"Print a __gnu_cxx::slist\"\n@@ -313,9 +378,8 @@ def __init__(self, typename, val):\n         self.val = val\n \n     def children(self):\n-        nodetype = find_type(self.val.type, '_Node')\n-        nodetype = nodetype.strip_typedefs().pointer()\n-        return self._iterator(nodetype, self.val)\n+        nodetype = lookup_node_type('__gnu_cxx::_Slist_node', self.val.type)\n+        return self._iterator(nodetype.pointer(), self.val)\n \n     def to_string(self):\n         if self.val['_M_head']['_M_next'] == 0:\n@@ -331,8 +395,7 @@ def __init__(self, typename, val):\n     def to_string(self):\n         if not self.val['_M_node']:\n             return 'non-dereferenceable iterator for __gnu_cxx::slist'\n-        nodetype = find_type(self.val.type, '_Node')\n-        nodetype = nodetype.strip_typedefs().pointer()\n+        nodetype = lookup_node_type('__gnu_cxx::_Slist_node', self.val.type).pointer()\n         return str(self.val['_M_node'].cast(nodetype).dereference()['_M_data'])\n \n class StdVectorPrinter:\n@@ -583,12 +646,8 @@ class StdRbtreeIteratorPrinter:\n \n     def __init__ (self, typename, val):\n         self.val = val\n-        valtype = self.val.type.template_argument(0).strip_typedefs()\n-        nodetype = '_Rb_tree_node<' + str(valtype) + '>'\n-        if _versioned_namespace and typename.startswith('std::' + _versioned_namespace):\n-            nodetype = _versioned_namespace + nodetype\n-        nodetype = gdb.lookup_type('std::' + nodetype)\n-        self.link_type = nodetype.strip_typedefs().pointer()\n+        nodetype = lookup_node_type('_Rb_tree_node', self.val.type)\n+        self.link_type = nodetype.pointer()\n \n     def to_string (self):\n         if not self.val['_M_node']:\n@@ -653,9 +712,7 @@ def to_string (self):\n                                num_elements(len(RbtreeIterator (self.val))))\n \n     def children (self):\n-        rep_type = find_type(self.val.type, '_Rep_type')\n-        node = find_type(rep_type, '_Link_type')\n-        node = node.strip_typedefs()\n+        node = lookup_node_type('_Rb_tree_node', self.val.type).pointer()\n         return self._iter (RbtreeIterator (self.val), node)\n \n     def display_hint (self):\n@@ -693,9 +750,7 @@ def to_string (self):\n                                num_elements(len(RbtreeIterator (self.val))))\n \n     def children (self):\n-        rep_type = find_type(self.val.type, '_Rep_type')\n-        node = find_type(rep_type, '_Link_type')\n-        node = node.strip_typedefs()\n+        node = lookup_node_type('_Rb_tree_node', self.val.type).pointer()\n         return self._iter (RbtreeIterator (self.val), node)\n \n class StdBitsetPrinter:\n@@ -853,11 +908,11 @@ def display_hint (self):\n         return 'string'\n \n class Tr1HashtableIterator(Iterator):\n-    def __init__ (self, hash):\n-        self.buckets = hash['_M_buckets']\n+    def __init__ (self, hashtable):\n+        self.buckets = hashtable['_M_buckets']\n         self.bucket = 0\n-        self.bucket_count = hash['_M_bucket_count']\n-        self.node_type = find_type(hash.type, '_Node').pointer()\n+        self.bucket_count = hashtable['_M_bucket_count']\n+        self.node_type = find_type(hashtable.type, '_Node').pointer()\n         self.node = 0\n         while self.bucket != self.bucket_count:\n             self.node = self.buckets[self.bucket]\n@@ -884,9 +939,13 @@ def __next__ (self):\n         return result\n \n class StdHashtableIterator(Iterator):\n-    def __init__(self, hash):\n-        self.node = hash['_M_before_begin']['_M_nxt']\n-        self.node_type = find_type(hash.type, '__node_type').pointer()\n+    def __init__(self, hashtable):\n+        self.node = hashtable['_M_before_begin']['_M_nxt']\n+        valtype = hashtable.type.template_argument(1)\n+        cached = hashtable.type.template_argument(9).template_argument(0)\n+        node_type = lookup_templ_spec('std::__detail::_Hash_node', str(valtype),\n+                                      'true' if cached else 'false')\n+        self.node_type = node_type.pointer()\n \n     def __iter__(self):\n         return self\n@@ -901,7 +960,7 @@ def __next__(self):\n         return valptr.dereference()\n \n class Tr1UnorderedSetPrinter:\n-    \"Print a tr1::unordered_set\"\n+    \"Print a std::unordered_set or tr1::unordered_set\"\n \n     def __init__ (self, typename, val):\n         self.typename = strip_versioned_namespace(typename)\n@@ -927,7 +986,7 @@ def children (self):\n         return izip (counter, StdHashtableIterator (self.hashtable()))\n \n class Tr1UnorderedMapPrinter:\n-    \"Print a tr1::unordered_map\"\n+    \"Print a std::unordered_map or tr1::unordered_map\"\n \n     def __init__ (self, typename, val):\n         self.typename = strip_versioned_namespace(typename)\n@@ -998,8 +1057,7 @@ def __init__(self, typename, val):\n         self.typename = strip_versioned_namespace(typename)\n \n     def children(self):\n-        nodetype = find_type(self.val.type, '_Node')\n-        nodetype = nodetype.strip_typedefs().pointer()\n+        nodetype = lookup_node_type('_Fwd_list_node', self.val.type).pointer()\n         return self._iterator(nodetype, self.val['_M_impl']['_M_head'])\n \n     def to_string(self):"}, {"sha": "af629496b4797cc3767db479f812f11f04c75aee", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/59161.cc", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F59161.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F59161.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F59161.cc?ref=9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "patch": "@@ -45,8 +45,6 @@ int main()\n   std::list<C> l;\n   l.push_back(c);\n   std::list<C>::iterator liter = l.begin();\n-  // Need to ensure the list<C>::iterator::_Node typedef is in the debuginfo:\n-  int tmp __attribute__((unused)) = (*liter).ref;\n // { dg-final { regexp-test liter {ref = @0x.*} } }\n \n   __gnu_cxx::slist<C> sl;"}, {"sha": "393c5680e2e562c82b99661c619a42bd63149d65", "filename": "libstdc++-v3/testsuite/libstdc++-prettyprinters/91997.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F91997.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9d50a6a78509b42b3c2b2264da1a0d2c4b151d66/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F91997.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Flibstdc%2B%2B-prettyprinters%2F91997.cc?ref=9d50a6a78509b42b3c2b2264da1a0d2c4b151d66", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++17 -g -O0 -Wno-unused\" }\n+// { dg-do run { target c++17 } }\n+\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <forward_list>\n+#include <list>\n+#include <set>\n+#include <map>\n+#include <string>\n+#include <any>\n+#include <iostream>\n+\n+int main()\n+{\n+  std::list<std::string> list{\"a\"};\n+  std::list<std::string>::iterator lit = list.begin();\n+  // { dg-final { note-test lit {\"a\"} } }\n+\n+  std::forward_list<std::string> flist{\"b\"};\n+  std::forward_list<std::string>::iterator flit = flist.begin();\n+  // { dg-final { note-test flit {\"b\"} } }\n+\n+  std::map<int, int> m{ {1, 2} };\n+  auto mit = m.begin();\n+  // { dg-final { note-test mit {{first = 1, second = 2}} } }\n+\n+  std::any a = m;\n+  // { dg-final { note-test a {std::any containing std::map with 1 element = {[1] = 2}} } }\n+\n+  std::set<int> s{1, 2};\n+  auto sit = s.begin();\n+  // { dg-final { note-test sit {1} } }\n+\n+  std::cout << \"\\n\";\n+  return 0;\t\t\t// Mark SPOT\n+}\n+// { dg-final { gdb-test SPOT } }"}]}