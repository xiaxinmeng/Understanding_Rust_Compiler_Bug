{"sha": "801f5b96775288e55193a66a746caab1ddd56f4a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxZjViOTY3NzUyODhlNTUxOTNhNjZhNzQ2Y2FhYjFkZGQ1NmY0YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-16T15:46:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-01-16T22:40:15Z"}, "message": "PR c++/93280 - ICE with aggregate assignment and DMI.\n\nI recently added an assert to cp-gimplify to catch any\nTARGET_EXPR_DIRECT_INIT_P being expanded without a target object, and this\ntestcase found one.  We started out with a TARGET_EXPR around the\nCONSTRUCTOR, which would normally mean that the member initializer would be\nused to directly initialize the appropriate member of whatever object the\nTARGET_EXPR ends up initializing.  But then gimplify_modify_expr_rhs\nstripped the TARGET_EXPR in order to assign directly from the elements of\nthe CONSTRUCTOR, leaving no object for the TARGET_EXPR_DIRECT_INIT_P to\ninitialize.  I considered setting CONSTRUCTOR_PLACEHOLDER_BOUNDARY in that\ncase, which implies TARGET_EXPR_NO_ELIDE, but decided that there's no\nparticular reason the A initializer needs to initialize a member of a B\nrather than a distinct A object, so let's only set TARGET_EXPR_DIRECT_INIT_P\nwhen we're using the DMI in a constructor.\n\n\t* init.c (get_nsdmi): Set TARGET_EXPR_DIRECT_INIT_P here.\n\t* typeck2.c (digest_nsdmi_init): Not here.", "tree": {"sha": "4ca550165104863c6e01a704dfb637864051b2bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ca550165104863c6e01a704dfb637864051b2bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/801f5b96775288e55193a66a746caab1ddd56f4a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f5b96775288e55193a66a746caab1ddd56f4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/801f5b96775288e55193a66a746caab1ddd56f4a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/801f5b96775288e55193a66a746caab1ddd56f4a/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f48c6014133c8989702458f9082e34ba6dd326d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f48c6014133c8989702458f9082e34ba6dd326d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f48c6014133c8989702458f9082e34ba6dd326d4"}], "stats": {"total": 13, "additions": 10, "deletions": 3}, "files": [{"sha": "3ca5d7a11b43607ffb756ca3977838208aff2a51", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=801f5b96775288e55193a66a746caab1ddd56f4a", "patch": "@@ -1,3 +1,9 @@\n+2020-01-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/93280 - ICE with aggregate assignment and DMI.\n+\t* init.c (get_nsdmi): Set TARGET_EXPR_DIRECT_INIT_P here.\n+\t* typeck2.c (digest_nsdmi_init): Not here.\n+\n 2020-01-15  Paolo Carlini  <paolo.carlini@oracle.com>\n \n \tPR c++/91073"}, {"sha": "543d127abcd8079256385022d0c9d8aee1f6f9f0", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=801f5b96775288e55193a66a746caab1ddd56f4a", "patch": "@@ -655,6 +655,10 @@ get_nsdmi (tree member, bool in_ctor, tsubst_flags_t complain)\n   if (simple_target)\n     init = TARGET_EXPR_INITIAL (init);\n   init = break_out_target_exprs (init, /*loc*/true);\n+  if (in_ctor && init && TREE_CODE (init) == TARGET_EXPR)\n+    /* This expresses the full initialization, prevent perform_member_init from\n+       calling another constructor (58162).  */\n+    TARGET_EXPR_DIRECT_INIT_P (init) = true;\n   if (simple_target && TREE_CODE (init) != CONSTRUCTOR)\n     /* Now put it back so C++17 copy elision works.  */\n     init = get_target_expr (init);"}, {"sha": "371b203c29bd6d208db92794e772179c9569db2f", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/801f5b96775288e55193a66a746caab1ddd56f4a/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=801f5b96775288e55193a66a746caab1ddd56f4a", "patch": "@@ -1369,9 +1369,6 @@ digest_nsdmi_init (tree decl, tree init, tsubst_flags_t complain)\n       && CP_AGGREGATE_TYPE_P (type))\n     init = reshape_init (type, init, complain);\n   init = digest_init_flags (type, init, flags, complain);\n-  if (TREE_CODE (init) == TARGET_EXPR)\n-    /* This represents the whole initialization.  */\n-    TARGET_EXPR_DIRECT_INIT_P (init) = true;\n   return init;\n }\n \f"}]}