{"sha": "67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjdjZTkwOTliYzk1M2YyMmU2YzllOWVlNGM2NDMyOWZkYjA4Mjg2YQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:35Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2020-10-02T16:41:35Z"}, "message": "ipa: Multiple predicates for loop properties, with frequencies\n\nThis patch enhances the ability of IPA to reason under what conditions\nloops in a function have known iteration counts or strides because it\nreplaces single predicates which currently hold conjunction of\npredicates for all loops with vectors capable of holding multiple\npredicates, each with a cumulative frequency of loops with the\nproperty.\n\nThis second property is then used by IPA-CP to much more aggressively\nboost its heuristic score for cloning opportunities which make\niteration counts or strides of frequent loops compile time constant.\n\ngcc/ChangeLog:\n\n2020-09-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* ipa-fnsummary.h (ipa_freqcounting_predicate): New type.\n\t(ipa_fn_summary): Change the type of loop_iterations and loop_strides\n\tto vectors of ipa_freqcounting_predicate.\n\t(ipa_fn_summary::ipa_fn_summary): Construct the new vectors.\n\t(ipa_call_estimates): New fields loops_with_known_iterations and\n\tloops_with_known_strides.\n\t* ipa-cp.c (hint_time_bonus): Multiply param_ipa_cp_loop_hint_bonus\n\twith the expected frequencies of loops with known iteration count or\n\tstride.\n\t* ipa-fnsummary.c (add_freqcounting_predicate): New function.\n\t(ipa_fn_summary::~ipa_fn_summary): Release the new vectors instead of\n\tjust two predicates.\n\t(remap_hint_predicate_after_duplication): Replace with function\n\tremap_freqcounting_preds_after_dup.\n\t(ipa_fn_summary_t::duplicate): Use it or duplicate new vectors.\n\t(ipa_dump_fn_summary): Dump the new vectors.\n\t(analyze_function_body): Compute the loop property vectors.\n\t(ipa_call_context::estimate_size_and_time): Calculate also\n\tloops_with_known_iterations and loops_with_known_strides.  Adjusted\n\tdumping accordinly.\n\t(remap_hint_predicate): Replace with function\n\tremap_freqcounting_predicate.\n\t(ipa_merge_fn_summary_after_inlining): Use it.\n\t(inline_read_section): Stream loopcounting vectors instead of two\n\tsimple predicates.\n\t(ipa_fn_summary_write): Likewise.\n\t* params.opt (ipa-max-loop-predicates): New parameter.\n\t* doc/invoke.texi (ipa-max-loop-predicates): Document new param.\n\ngcc/testsuite/ChangeLog:\n\n2020-09-03  Martin Jambor  <mjambor@suse.cz>\n\n\t* gcc.dg/ipa/ipcp-loophint-1.c: New test.", "tree": {"sha": "f56ef1af5db5e1495e6ade60648c228e0efbafcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f56ef1af5db5e1495e6ade60648c228e0efbafcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e7fdc02cba43e646fb2389e3c79e7c4e5ff772e"}], "stats": {"total": 402, "additions": 288, "deletions": 114}, "files": [{"sha": "f623467b7637af3db67a4834bff883b4e75e1475", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -13453,6 +13453,10 @@ of iterations of a loop known, it adds a bonus of\n @option{ipa-cp-loop-hint-bonus} to the profitability score of\n the candidate.\n \n+@item ipa-max-loop-predicates\n+The maximum number of different predicates IPA will use to describe when\n+loops in a function have known properties.\n+\n @item ipa-max-aa-steps\n During its analysis of function bodies, IPA-CP employs alias analysis\n in order to track values pointed to by function parameters.  In order"}, {"sha": "f6320c787de3eddb1f3dad34904fe30ad24ea3ed", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -3205,6 +3205,15 @@ hint_time_bonus (cgraph_node *node, const ipa_call_estimates &estimates)\n   ipa_hints hints = estimates.hints;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n     result += opt_for_fn (node->decl, param_ipa_cp_loop_hint_bonus);\n+\n+  sreal bonus_for_one = opt_for_fn (node->decl, param_ipa_cp_loop_hint_bonus);\n+\n+  if (hints & INLINE_HINT_loop_iterations)\n+    result += (estimates.loops_with_known_iterations * bonus_for_one).to_int ();\n+\n+  if (hints & INLINE_HINT_loop_stride)\n+    result += (estimates.loops_with_known_strides * bonus_for_one).to_int ();\n+\n   return result;\n }\n "}, {"sha": "771f432ebecac7308e268665da5735748434c3d7", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 213, "deletions": 105, "changes": 318, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -310,6 +310,36 @@ set_hint_predicate (predicate **p, predicate new_predicate)\n     }\n }\n \n+/* Find if NEW_PREDICATE is already in V and if so, increment its freq.\n+   Otherwise add a new item to the vector with this predicate and frerq equal\n+   to add_freq, unless the number of predicates would exceed MAX_NUM_PREDICATES\n+   in which case the function does nothing.  */\n+\n+static void\n+add_freqcounting_predicate (vec<ipa_freqcounting_predicate, va_gc> **v,\n+\t\t\t    const predicate &new_predicate, sreal add_freq,\n+\t\t\t    unsigned max_num_predicates)\n+{\n+  if (new_predicate == false || new_predicate == true)\n+    return;\n+  ipa_freqcounting_predicate *f;\n+  for (int i = 0; vec_safe_iterate (*v, i, &f); i++)\n+    if (new_predicate == f->predicate)\n+      {\n+\tf->freq += add_freq;\n+\treturn;\n+      }\n+  if (vec_safe_length (*v) >= max_num_predicates)\n+    /* Too many different predicates to account for.  */\n+    return;\n+\n+  ipa_freqcounting_predicate fcp;\n+  fcp.predicate = NULL;\n+  set_hint_predicate (&fcp.predicate, new_predicate);\n+  fcp.freq = add_freq;\n+  vec_safe_push (*v, fcp);\n+  return;\n+}\n \n /* Compute what conditions may or may not hold given information about\n    parameters.  RET_CLAUSE returns truths that may hold in a specialized copy,\n@@ -710,13 +740,17 @@ ipa_call_summary::~ipa_call_summary ()\n \n ipa_fn_summary::~ipa_fn_summary ()\n {\n-  if (loop_iterations)\n-    edge_predicate_pool.remove (loop_iterations);\n-  if (loop_stride)\n-    edge_predicate_pool.remove (loop_stride);\n+  unsigned len = vec_safe_length (loop_iterations);\n+  for (unsigned i = 0; i < len; i++)\n+    edge_predicate_pool.remove ((*loop_iterations)[i].predicate);\n+  len = vec_safe_length (loop_strides);\n+  for (unsigned i = 0; i < len; i++)\n+    edge_predicate_pool.remove ((*loop_strides)[i].predicate);\n   vec_free (conds);\n   vec_free (size_time_table);\n   vec_free (call_size_time_table);\n+  vec_free (loop_iterations);\n+  vec_free (loop_strides);\n }\n \n void\n@@ -729,24 +763,33 @@ ipa_fn_summary_t::remove_callees (cgraph_node *node)\n     ipa_call_summaries->remove (e);\n }\n \n-/* Same as remap_predicate_after_duplication but handle hint predicate *P.\n-   Additionally care about allocating new memory slot for updated predicate\n-   and set it to NULL when it becomes true or false (and thus uninteresting).\n- */\n+/* Duplicate predicates in loop hint vector, allocating memory for them and\n+   remove and deallocate any uninteresting (true or false) ones.  Return the\n+   result.  */\n \n-static void\n-remap_hint_predicate_after_duplication (predicate **p,\n-\t\t\t\t\tclause_t possible_truths)\n+static vec<ipa_freqcounting_predicate, va_gc> *\n+remap_freqcounting_preds_after_dup (vec<ipa_freqcounting_predicate, va_gc> *v,\n+\t\t\t\t    clause_t possible_truths)\n {\n-  predicate new_predicate;\n+  if (vec_safe_length (v) == 0)\n+    return NULL;\n \n-  if (!*p)\n-    return;\n+  vec<ipa_freqcounting_predicate, va_gc> *res = v->copy ();\n+  int len = res->length();\n+  for (int i = len - 1; i >= 0; i--)\n+    {\n+      predicate new_predicate\n+\t= (*res)[i].predicate->remap_after_duplication (possible_truths);\n+      /* We do not want to free previous predicate; it is used by node\n+\t origin.  */\n+      (*res)[i].predicate = NULL;\n+      set_hint_predicate (&(*res)[i].predicate, new_predicate);\n+\n+      if (!(*res)[i].predicate)\n+\tres->unordered_remove (i);\n+    }\n \n-  new_predicate = (*p)->remap_after_duplication (possible_truths);\n-  /* We do not want to free previous predicate; it is used by node origin.  */\n-  *p = NULL;\n-  set_hint_predicate (p, new_predicate);\n+  return res;\n }\n \n \n@@ -859,9 +902,11 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n \t    optimized_out_size += es->call_stmt_size * ipa_fn_summary::size_scale;\n \t  edge_set_predicate (edge, &new_predicate);\n \t}\n-      remap_hint_predicate_after_duplication (&info->loop_iterations,\n+      info->loop_iterations\n+\t= remap_freqcounting_preds_after_dup (info->loop_iterations,\n \t\t\t\t\t      possible_truths);\n-      remap_hint_predicate_after_duplication (&info->loop_stride,\n+      info->loop_strides\n+\t= remap_freqcounting_preds_after_dup (info->loop_strides,\n \t\t\t\t\t      possible_truths);\n \n       /* If inliner or someone after inliner will ever start producing\n@@ -873,17 +918,21 @@ ipa_fn_summary_t::duplicate (cgraph_node *src,\n   else\n     {\n       info->size_time_table = vec_safe_copy (info->size_time_table);\n-      if (info->loop_iterations)\n+      info->loop_iterations = vec_safe_copy (info->loop_iterations);\n+      info->loop_strides = vec_safe_copy (info->loop_strides);\n+\n+      ipa_freqcounting_predicate *f;\n+      for (int i = 0; vec_safe_iterate (info->loop_iterations, i, &f); i++)\n \t{\n-\t  predicate p = *info->loop_iterations;\n-\t  info->loop_iterations = NULL;\n-\t  set_hint_predicate (&info->loop_iterations, p);\n+\t  predicate p = *f->predicate;\n+\t  f->predicate = NULL;\n+\t  set_hint_predicate (&f->predicate, p);\n \t}\n-      if (info->loop_stride)\n+      for (int i = 0; vec_safe_iterate (info->loop_strides, i, &f); i++)\n \t{\n-\t  predicate p = *info->loop_stride;\n-\t  info->loop_stride = NULL;\n-\t  set_hint_predicate (&info->loop_stride, p);\n+\t  predicate p = *f->predicate;\n+\t  f->predicate = NULL;\n+\t  set_hint_predicate (&f->predicate, p);\n \t}\n     }\n   if (!dst->inlined_to)\n@@ -1045,15 +1094,28 @@ ipa_dump_fn_summary (FILE *f, struct cgraph_node *node)\n \t\t}\n \t      fprintf (f, \"\\n\");\n \t    }\n-\t  if (s->loop_iterations)\n+\t  ipa_freqcounting_predicate *fcp;\n+\t  bool first_fcp = true;\n+\t  for (int i = 0; vec_safe_iterate (s->loop_iterations, i, &fcp); i++)\n \t    {\n-\t      fprintf (f, \"  loop iterations:\");\n-\t      s->loop_iterations->dump (f, s->conds);\n+\t      if (first_fcp)\n+\t\t{\n+\t\t  fprintf (f, \"  loop iterations:\");\n+\t\t  first_fcp = false;\n+\t\t}\n+\t      fprintf (f, \"  %3.2f for \", fcp->freq.to_double ());\n+\t      fcp->predicate->dump (f, s->conds);\n \t    }\n-\t  if (s->loop_stride)\n+\t  first_fcp = true;\n+\t  for (int i = 0; vec_safe_iterate (s->loop_strides, i, &fcp); i++)\n \t    {\n-\t      fprintf (f, \"  loop stride:\");\n-\t      s->loop_stride->dump (f, s->conds);\n+\t      if (first_fcp)\n+\t\t{\n+\t\t  fprintf (f, \"  loop strides:\");\n+\t\t  first_fcp = false;\n+\t\t}\n+\t      fprintf (f, \"  %3.2f for :\", fcp->freq.to_double ());\n+\t      fcp->predicate->dump (f, s->conds);\n \t    }\n \t  fprintf (f, \"  calls:\\n\");\n \t  dump_ipa_call_summary (f, 4, node, s);\n@@ -2543,12 +2605,13 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \n   if (fbi.info)\n     compute_bb_predicates (&fbi, node, info, params_summary);\n+  const profile_count entry_count = ENTRY_BLOCK_PTR_FOR_FN (cfun)->count;\n   order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   nblocks = pre_and_rev_post_order_compute (NULL, order, false);\n   for (n = 0; n < nblocks; n++)\n     {\n       bb = BASIC_BLOCK_FOR_FN (cfun, order[n]);\n-      freq = bb->count.to_sreal_scale (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count);\n+      freq = bb->count.to_sreal_scale (entry_count);\n       if (clobber_only_eh_bb_p (bb))\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -2790,23 +2853,28 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \n   if (nonconstant_names.exists () && !early)\n     {\n+      ipa_fn_summary *s = ipa_fn_summaries->get (node);\n       class loop *loop;\n-      predicate loop_iterations = true;\n-      predicate loop_stride = true;\n+      unsigned max_loop_predicates = opt_for_fn (node->decl,\n+\t\t\t\t\t\t param_ipa_max_loop_predicates);\n \n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tflow_loops_dump (dump_file, NULL, 0);\n       scev_initialize ();\n       FOR_EACH_LOOP (loop, 0)\n \t{\n+\t  predicate loop_iterations = true;\n+\t  sreal header_freq;\n \t  edge ex;\n \t  unsigned int j;\n \t  class tree_niter_desc niter_desc;\n-\t  if (loop->header->aux)\n-\t    bb_predicate = *(predicate *) loop->header->aux;\n-\t  else\n-\t    bb_predicate = false;\n+\t  if (!loop->header->aux)\n+\t    continue;\n \n+\t  profile_count phdr_count = loop_preheader_edge (loop)->count ();\n+\t  sreal phdr_freq = phdr_count.to_sreal_scale (entry_count);\n+\n+\t  bb_predicate = *(predicate *) loop->header->aux;\n \t  auto_vec<edge> exits = get_loop_exit_edges (loop);\n \t  FOR_EACH_VEC_ELT (exits, j, ex)\n \t    if (number_of_iterations_exit (loop, ex, &niter_desc, false)\n@@ -2821,10 +2889,10 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\twill_be_nonconstant = bb_predicate & will_be_nonconstant;\n \t      if (will_be_nonconstant != true\n \t\t  && will_be_nonconstant != false)\n-\t\t/* This is slightly inprecise.  We may want to represent each\n-\t\t   loop with independent predicate.  */\n \t\tloop_iterations &= will_be_nonconstant;\n \t    }\n+\t  add_freqcounting_predicate (&s->loop_iterations, loop_iterations,\n+\t\t\t\t      phdr_freq, max_loop_predicates);\n \t}\n \n       /* To avoid quadratic behavior we analyze stride predicates only\n@@ -2833,14 +2901,17 @@ analyze_function_body (struct cgraph_node *node, bool early)\n       for (loop = loops_for_fn (cfun)->tree_root->inner;\n \t   loop != NULL; loop = loop->next)\n \t{\n+\t  predicate loop_stride = true;\n \t  basic_block *body = get_loop_body (loop);\n+\t  profile_count phdr_count = loop_preheader_edge (loop)->count ();\n+\t  sreal phdr_freq = phdr_count.to_sreal_scale (entry_count);\n \t  for (unsigned i = 0; i < loop->num_nodes; i++)\n \t    {\n \t      gimple_stmt_iterator gsi;\n-\t      if (body[i]->aux)\n-\t\tbb_predicate = *(predicate *) body[i]->aux;\n-\t      else\n-\t\tbb_predicate = false;\n+\t      if (!body[i]->aux)\n+\t\tcontinue;\n+\n+\t      bb_predicate = *(predicate *) body[i]->aux;\n \t      for (gsi = gsi_start_bb (body[i]); !gsi_end_p (gsi);\n \t\t   gsi_next (&gsi))\n \t\t{\n@@ -2869,16 +2940,13 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t    will_be_nonconstant = bb_predicate & will_be_nonconstant;\n \t\t  if (will_be_nonconstant != true\n \t\t      && will_be_nonconstant != false)\n-\t\t    /* This is slightly inprecise.  We may want to represent\n-\t\t       each loop with independent predicate.  */\n \t\t    loop_stride = loop_stride & will_be_nonconstant;\n \t\t}\n \t    }\n+\t  add_freqcounting_predicate (&s->loop_strides, loop_stride,\n+\t\t\t\t      phdr_freq, max_loop_predicates);\n \t  free (body);\n \t}\n-      ipa_fn_summary *s = ipa_fn_summaries->get (node);\n-      set_hint_predicate (&s->loop_iterations, loop_iterations);\n-      set_hint_predicate (&s->loop_stride, loop_stride);\n       scev_finalize ();\n     }\n   FOR_ALL_BB_FN (bb, my_function)\n@@ -3551,6 +3619,8 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n   sreal time = 0;\n   int min_size = 0;\n   ipa_hints hints = 0;\n+  sreal loops_with_known_iterations = 0;\n+  sreal loops_with_known_strides = 0;\n   int i;\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -3643,29 +3713,43 @@ ipa_call_context::estimate_size_and_time (ipa_call_estimates *estimates,\n \n   if (est_hints)\n     {\n-      if (info->loop_iterations\n-\t  && !info->loop_iterations->evaluate (m_possible_truths))\n-\thints |= INLINE_HINT_loop_iterations;\n-      if (info->loop_stride\n-\t  && !info->loop_stride->evaluate (m_possible_truths))\n-\thints |= INLINE_HINT_loop_stride;\n       if (info->scc_no)\n \thints |= INLINE_HINT_in_scc;\n       if (DECL_DECLARED_INLINE_P (m_node->decl))\n \thints |= INLINE_HINT_declared_inline;\n+\n+      ipa_freqcounting_predicate *fcp;\n+      for (i = 0; vec_safe_iterate (info->loop_iterations, i, &fcp); i++)\n+\tif (!fcp->predicate->evaluate (m_possible_truths))\n+\t  {\n+\t    hints |= INLINE_HINT_loop_iterations;\n+\t    loops_with_known_iterations += fcp->freq;\n+\t  }\n+      estimates->loops_with_known_iterations = loops_with_known_iterations;\n+\n+      for (i = 0; vec_safe_iterate (info->loop_strides, i, &fcp); i++)\n+\tif (!fcp->predicate->evaluate (m_possible_truths))\n+\t  {\n+\t    hints |= INLINE_HINT_loop_stride;\n+\t    loops_with_known_strides += fcp->freq;\n+\t  }\n+      estimates->loops_with_known_strides = loops_with_known_strides;\n     }\n \n   size = RDIV (size, ipa_fn_summary::size_scale);\n   min_size = RDIV (min_size, ipa_fn_summary::size_scale);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n+      fprintf (dump_file, \"\\n   size:%i\", (int) size);\n       if (est_times)\n-\tfprintf (dump_file, \"\\n   size:%i time:%f nonspec time:%f\\n\",\n-\t\t (int) size, time.to_double (),\n-\t\t nonspecialized_time.to_double ());\n-      else\n-\tfprintf (dump_file, \"\\n   size:%i (time not estimated)\\n\", (int) size);\n+\tfprintf (dump_file, \" time:%f nonspec time:%f\",\n+\t\t time.to_double (), nonspecialized_time.to_double ());\n+      if (est_hints)\n+\tfprintf (dump_file, \" loops with known iterations:%f \"\n+\t\t \"known strides:%f\", loops_with_known_iterations.to_double (),\n+\t\t loops_with_known_strides.to_double ());\n+      fprintf (dump_file, \"\\n\");\n     }\n   if (est_times)\n     {\n@@ -3865,32 +3949,29 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n     }\n }\n \n-/* Same as remap_predicate, but set result into hint *HINT.  */\n+/* Run remap_after_inlining on each predicate in V.  */\n \n static void\n-remap_hint_predicate (class ipa_fn_summary *info,\n-\t\t      class ipa_node_params *params_summary,\n-\t\t      class ipa_fn_summary *callee_info,\n-\t\t      predicate **hint,\n-\t\t      vec<int> operand_map,\n-\t\t      vec<int> offset_map,\n-\t\t      clause_t possible_truths,\n-\t\t      predicate *toplev_predicate)\n-{\n-  predicate p;\n+remap_freqcounting_predicate (class ipa_fn_summary *info,\n+\t\t\t      class ipa_node_params *params_summary,\n+\t\t\t      class ipa_fn_summary *callee_info,\n+\t\t\t      vec<ipa_freqcounting_predicate, va_gc> *v,\n+\t\t\t      vec<int> operand_map,\n+\t\t\t      vec<int> offset_map,\n+\t\t\t      clause_t possible_truths,\n+\t\t\t      predicate *toplev_predicate)\n \n-  if (!*hint)\n-    return;\n-  p = (*hint)->remap_after_inlining\n-\t\t\t (info, params_summary, callee_info,\n-\t\t\t  operand_map, offset_map,\n-\t\t\t  possible_truths, *toplev_predicate);\n-  if (p != false && p != true)\n+{\n+  ipa_freqcounting_predicate *fcp;\n+  for (int i = 0; vec_safe_iterate (v, i, &fcp); i++)\n     {\n-      if (!*hint)\n-\tset_hint_predicate (hint, p);\n-      else\n-\t**hint &= p;\n+      predicate p\n+\t= fcp->predicate->remap_after_inlining (info, params_summary,\n+\t\t\t\t\t\tcallee_info, operand_map,\n+\t\t\t\t\t\toffset_map, possible_truths,\n+\t\t\t\t\t\t*toplev_predicate);\n+      if (p != false && p != true)\n+\t*fcp->predicate &= p;\n     }\n }\n \n@@ -3998,12 +4079,12 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   remap_edge_summaries (edge, edge->callee, info, params_summary,\n \t\t \tcallee_info, operand_map,\n \t\t\toffset_map, clause, &toplev_predicate);\n-  remap_hint_predicate (info, params_summary, callee_info,\n-\t\t\t&callee_info->loop_iterations,\n-\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n-  remap_hint_predicate (info, params_summary, callee_info,\n-\t\t\t&callee_info->loop_stride,\n-\t\t\toperand_map, offset_map, clause, &toplev_predicate);\n+  remap_freqcounting_predicate (info, params_summary, callee_info,\n+\t\t\t\tinfo->loop_iterations, operand_map,\n+\t\t\t\toffset_map, clause, &toplev_predicate);\n+  remap_freqcounting_predicate (info, params_summary, callee_info,\n+\t\t\t\tinfo->loop_strides, operand_map,\n+\t\t\t\toffset_map, clause, &toplev_predicate);\n \n   HOST_WIDE_INT stack_frame_offset = ipa_get_stack_frame_offset (edge->callee);\n   HOST_WIDE_INT peak = stack_frame_offset + callee_info->estimated_stack_size;\n@@ -4334,12 +4415,34 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t    info->size_time_table->quick_push (e);\n \t}\n \n-      p.stream_in (&ib);\n-      if (info)\n-        set_hint_predicate (&info->loop_iterations, p);\n-      p.stream_in (&ib);\n-      if (info)\n-        set_hint_predicate (&info->loop_stride, p);\n+      count2 = streamer_read_uhwi (&ib);\n+      for (j = 0; j < count2; j++)\n+\t{\n+\t  p.stream_in (&ib);\n+\t  sreal fcp_freq = sreal::stream_in (&ib);\n+\t  if (info)\n+\t    {\n+\t      ipa_freqcounting_predicate fcp;\n+\t      fcp.predicate = NULL;\n+\t      set_hint_predicate (&fcp.predicate, p);\n+\t      fcp.freq = fcp_freq;\n+\t      vec_safe_push (info->loop_iterations, fcp);\n+\t    }\n+\t}\n+      count2 = streamer_read_uhwi (&ib);\n+      for (j = 0; j < count2; j++)\n+\t{\n+\t  p.stream_in (&ib);\n+\t  sreal fcp_freq = sreal::stream_in (&ib);\n+\t  if (info)\n+\t    {\n+\t      ipa_freqcounting_predicate fcp;\n+\t      fcp.predicate = NULL;\n+\t      set_hint_predicate (&fcp.predicate, p);\n+\t      fcp.freq = fcp_freq;\n+\t      vec_safe_push (info->loop_strides, fcp);\n+\t    }\n+\t}\n       for (e = node->callees; e; e = e->next_callee)\n \tread_ipa_call_summary (&ib, e, info != NULL);\n       for (e = node->indirect_calls; e; e = e->next_callee)\n@@ -4502,14 +4605,19 @@ ipa_fn_summary_write (void)\n \t      e->exec_predicate.stream_out (ob);\n \t      e->nonconst_predicate.stream_out (ob);\n \t    }\n-\t  if (info->loop_iterations)\n-\t    info->loop_iterations->stream_out (ob);\n- \t  else\n-\t    streamer_write_uhwi (ob, 0);\n-\t  if (info->loop_stride)\n-\t    info->loop_stride->stream_out (ob);\n- \t  else\n-\t    streamer_write_uhwi (ob, 0);\n+\t  ipa_freqcounting_predicate *fcp;\n+\t  streamer_write_uhwi (ob, vec_safe_length (info->loop_iterations));\n+\t  for (i = 0; vec_safe_iterate (info->loop_iterations, i, &fcp); i++)\n+\t    {\n+\t      fcp->predicate->stream_out (ob);\n+\t      fcp->freq.stream_out (ob);\n+\t    }\n+\t  streamer_write_uhwi (ob, vec_safe_length (info->loop_strides));\n+\t  for (i = 0; vec_safe_iterate (info->loop_strides, i, &fcp); i++)\n+\t    {\n+\t      fcp->predicate->stream_out (ob);\n+\t      fcp->freq.stream_out (ob);\n+\t    }\n \t  for (edge = cnode->callees; edge; edge = edge->next_callee)\n \t    write_ipa_call_summary (ob, edge);\n \t  for (edge = cnode->indirect_calls; edge; edge = edge->next_callee)"}, {"sha": "f4dd5b85ab9045ff10b86e0e25ecbe6b636e0a6e", "filename": "gcc/ipa-fnsummary.h", "status": "modified", "additions": 29, "deletions": 9, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-fnsummary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fipa-fnsummary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.h?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -101,6 +101,19 @@ class ipa_size_summary\n   }\n };\n \n+/* Structure to capture how frequently some interesting events occur given a\n+   particular predicate.  The structure is used to estimate how often we\n+   encounter loops with known iteration count or stride in various\n+   contexts.  */\n+\n+struct GTY(()) ipa_freqcounting_predicate\n+{\n+  /* The described event happens with this frequency... */\n+  sreal freq;\n+  /* ...when this predicate evaluates to false. */\n+  class predicate * GTY((skip)) predicate;\n+};\n+\n /* Function inlining information.  */\n class GTY(()) ipa_fn_summary\n {\n@@ -112,8 +125,9 @@ class GTY(()) ipa_fn_summary\n       inlinable (false), single_caller (false),\n       fp_expressions (false), estimated_stack_size (false),\n       time (0), conds (NULL),\n-      size_time_table (NULL), call_size_time_table (NULL), loop_iterations (NULL),\n-      loop_stride (NULL), growth (0), scc_no (0)\n+      size_time_table (NULL), call_size_time_table (NULL),\n+      loop_iterations (NULL), loop_strides (NULL),\n+      growth (0), scc_no (0)\n   {\n   }\n \n@@ -125,7 +139,7 @@ class GTY(()) ipa_fn_summary\n     estimated_stack_size (s.estimated_stack_size),\n     time (s.time), conds (s.conds), size_time_table (s.size_time_table),\n     call_size_time_table (NULL),\n-    loop_iterations (s.loop_iterations), loop_stride (s.loop_stride),\n+    loop_iterations (s.loop_iterations), loop_strides (s.loop_strides),\n     growth (s.growth), scc_no (s.scc_no)\n   {}\n \n@@ -164,12 +178,10 @@ class GTY(()) ipa_fn_summary\n   vec<size_time_entry, va_gc> *size_time_table;\n   vec<size_time_entry, va_gc> *call_size_time_table;\n \n-  /* Predicate on when some loop in the function becomes to have known\n-     bounds.   */\n-  predicate * GTY((skip)) loop_iterations;\n-  /* Predicate on when some loop in the function becomes to have known\n-     stride.   */\n-  predicate * GTY((skip)) loop_stride;\n+  /* Predicates on when some loops in the function can have known bounds.  */\n+  vec<ipa_freqcounting_predicate, va_gc> *loop_iterations;\n+  /* Predicates on when some loops in the function can have known strides.  */\n+  vec<ipa_freqcounting_predicate, va_gc> *loop_strides;\n   /* Estimated growth for inlining all copies of the function before start\n      of small functions inlining.\n      This value will get out of date as the callers are duplicated, but\n@@ -308,6 +320,14 @@ struct ipa_call_estimates\n \n   /* Further discovered reasons why to inline or specialize the give calls.  */\n   ipa_hints hints;\n+\n+  /* Frequency how often a loop with known number of iterations is encountered.\n+     Calculated with hints.  */\n+  sreal loops_with_known_iterations;\n+\n+  /* Frequency how often a loop with known strides is encountered.  Calculated\n+     with hints.  */\n+  sreal loops_with_known_strides;\n };\n \n class ipa_cached_call_context;"}, {"sha": "c0b94bbb96cd8e28afa8418348d74daa22d7e5be", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -230,6 +230,10 @@ Maximum number of aggregate content items for a parameter in jump functions and\n Common Joined UInteger Var(param_ipa_max_param_expr_ops) Init(10) Param Optimization\n Maximum number of operations in a parameter expression that can be handled by IPA analysis.\n \n+-param=ipa-max-loop-predicates=\n+Common Joined UInteger Var(param_ipa_max_loop_predicates) Init(16) Param Optimization\n+Maximum number of different predicates used to track properties of loops in IPA analysis.\n+\n -param=ipa-max-switch-predicate-bounds=\n Common Joined UInteger Var(param_ipa_max_switch_predicate_bounds) Init(5) Param Optimization\n Maximal number of boundary endpoints of case ranges of switch statement used during IPA function summary generation."}, {"sha": "6d049af68af73703b3f095a659ce4b3eb9ffa695", "filename": "gcc/testsuite/gcc.dg/ipa/ipcp-loophint-1.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-loophint-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/67ce9099bc953f22e6c9e9ee4c64329fdb08286a/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-loophint-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fipa%2Fipcp-loophint-1.c?ref=67ce9099bc953f22e6c9e9ee4c64329fdb08286a", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O3 -fdump-ipa-cp-details\"  } */\n+\n+extern int *o, *p, *q, *r;\n+\n+#define FUNCTIONS fa(), fb(), fc(), fd(), fe(), ff(), fg()\n+\n+extern void FUNCTIONS;\n+\n+void foo (int c)\n+{\n+  FUNCTIONS;\n+  FUNCTIONS;\n+  for (int i = 0; i < 100; i++)\n+    {\n+      for (int j = 0; j < c; j++)\n+\to[i] = p[i] + q[i] * r[i];\n+    }\n+  FUNCTIONS;\n+  FUNCTIONS;\n+}\n+\n+void bar()\n+{\n+  foo (8);\n+  p[4]++;\n+}\n+\n+/* { dg-final { scan-ipa-dump {with known iterations:[1-9]} \"cp\"  } } */"}]}