{"sha": "8012c98334adc980f8e7ad5ceac47fa19b664662", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAxMmM5ODMzNGFkYzk4MGY4ZTdhZDVjZWFjNDdmYTE5YjY2NDY2Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-09-02T19:14:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-09-02T19:14:06Z"}, "message": "cp-tree.h (cp_function): Move here, from decl.c.\n\n\t* cp-tree.h (cp_function): Move here, from decl.c.\n\t(cp_function_chain): Declare.\n\t(dtor_label): New macro, instead of variable.\n\t(ctor_label): Likewise.\n\t(current_base_init_list): Likewise.\n\t(current_member_init_list): Likewise.\n\t(base_init_expr): Likewise.\n\t(current_class_ptr): Likewise.\n\t(current_class_ref): Likewise.\n\t(last_tree): Likewise.\n\t(last_expr_type): Likewise.\n\t(current_function_returns_value): Likewise.\n\t(current_function_returns_null): Likewise.\n\t(current_function_just_assigned_this): Likewise.\n\t(current_function_parms_stored): Likewise.\n\t(temp_name_counter): Likewise.\n\t(static_labelno): Likewise.\n\t(expanding_p): Likewise.\n\t(stmts_are_full_exprs_p): Likewise.\n\t(in_function_try_handler): Likewise.\n\t(lang_type): Remove nested type_flags.  All uses changed.\n\t* call.c (ctor_label): Remove.\n\t(dtor_label): Likewise.\n\t* class.c (current_class_ptr): Remove.\n\t(current_class_ref): Likewise.\n\t* decl.c (static_labelno): Remove.\n\t(dtor_label): Likewise.\n\t(last_dtor_insn): New macro, instead of variable.\n\t(last_parm_cleanup_insn): Likewise.\n\t(original_result_rtx): Likewise.\n\t(in_function_try_handler): Remove.\n\t(named_label_uses): New macro, instead of variable.\n\t(named_labels): Likewise.\n\t(current_function_returns_value): Remove.\n\t(current_function_returns_null): Likewise.\n\t(current_function_assigns_this): New macro, instead of variable.\n\t(current_function_just_assigned_this): Likewise.\n\t(current_binding_level): Likewise.\n\t(init_decl_processing): Call push_cp_function_context.\n\t(cp_function): Move to cp-tree.h\n\t(cp_function_chain): Make it global.\n\t(temp_name_counter): Remove.\n\t(push_cp_function_context): Simplify.\n\t(pop_cp_function_context): Likewise.\n\t* decl2.c (temp_name_counter): Remove.\n\t* init_c (current_base_init_list): Likewise.\n\t(current_member_init_list): Likewise.\n\t(base_init_expr): Likewise.\n\t* method.c (static_labelno): Likewise.\n\t* pt.c (last_tree): Likewise.\n\t* semantics.c (expanding_p): Likewise.\n\t(stmts_are_full_exprs_p): Likewise.\n\t(last_expr_type): Likewise.\n\t* typeck.c (dtor_label): Likewise.\n\t(ctor_label): Likewise.\n\nFrom-SVN: r29062", "tree": {"sha": "9082c8abf66f4dc342e033e24906599efdd6475d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9082c8abf66f4dc342e033e24906599efdd6475d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8012c98334adc980f8e7ad5ceac47fa19b664662", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8012c98334adc980f8e7ad5ceac47fa19b664662", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8012c98334adc980f8e7ad5ceac47fa19b664662", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8012c98334adc980f8e7ad5ceac47fa19b664662/comments", "author": null, "committer": null, "parents": [{"sha": "e2bef702d6db5181253b7edd7f9ca9c88abedd00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2bef702d6db5181253b7edd7f9ca9c88abedd00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2bef702d6db5181253b7edd7f9ca9c88abedd00"}], "stats": {"total": 624, "additions": 319, "deletions": 305}, "files": [{"sha": "d4396244164f7c06c6ea86bea88923fa151ebfb5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -1,3 +1,61 @@\n+1999-09-02  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (cp_function): Move here, from decl.c.\n+\t(cp_function_chain): Declare.\n+\t(dtor_label): New macro, instead of variable.\n+\t(ctor_label): Likewise.\n+\t(current_base_init_list): Likewise.\n+\t(current_member_init_list): Likewise.\n+\t(base_init_expr): Likewise.\n+\t(current_class_ptr): Likewise.\n+\t(current_class_ref): Likewise.\n+\t(last_tree): Likewise.\n+\t(last_expr_type): Likewise.\n+\t(current_function_returns_value): Likewise.\n+\t(current_function_returns_null): Likewise.\n+\t(current_function_just_assigned_this): Likewise.\n+\t(current_function_parms_stored): Likewise.\n+\t(temp_name_counter): Likewise.\n+\t(static_labelno): Likewise.\n+\t(expanding_p): Likewise.\n+\t(stmts_are_full_exprs_p): Likewise.\n+\t(in_function_try_handler): Likewise.\n+\t(lang_type): Remove nested type_flags.  All uses changed.\n+\t* call.c (ctor_label): Remove.\n+\t(dtor_label): Likewise.\n+\t* class.c (current_class_ptr): Remove.\n+\t(current_class_ref): Likewise.\n+\t* decl.c (static_labelno): Remove.\n+\t(dtor_label): Likewise.\n+\t(last_dtor_insn): New macro, instead of variable.\n+\t(last_parm_cleanup_insn): Likewise.\n+\t(original_result_rtx): Likewise.\n+\t(in_function_try_handler): Remove.\n+\t(named_label_uses): New macro, instead of variable.\n+\t(named_labels): Likewise.\n+\t(current_function_returns_value): Remove.\n+\t(current_function_returns_null): Likewise.\n+\t(current_function_assigns_this): New macro, instead of variable.\n+\t(current_function_just_assigned_this): Likewise.\n+\t(current_binding_level): Likewise.\n+\t(init_decl_processing): Call push_cp_function_context.\n+\t(cp_function): Move to cp-tree.h\n+\t(cp_function_chain): Make it global.\n+\t(temp_name_counter): Remove.\n+\t(push_cp_function_context): Simplify.\n+\t(pop_cp_function_context): Likewise.\n+\t* decl2.c (temp_name_counter): Remove.\n+\t* init_c (current_base_init_list): Likewise.\n+\t(current_member_init_list): Likewise.\n+\t(base_init_expr): Likewise.\n+\t* method.c (static_labelno): Likewise.\n+\t* pt.c (last_tree): Likewise.\n+\t* semantics.c (expanding_p): Likewise.\n+\t(stmts_are_full_exprs_p): Likewise.\n+\t(last_expr_type): Likewise.\n+\t* typeck.c (dtor_label): Likewise.\n+\t(ctor_label): Likewise.\n+\t\n 1999-09-01  Alex Samuel  <samuel@codesourcery.com>\n \n \t* decl2.c (arg_assoc_template_arg): New prototype.  New function."}, {"sha": "dced83b335427ee51b608c0dfac862239447208c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -38,7 +38,6 @@ Boston, MA 02111-1307, USA.  */\n #define obstack_chunk_free free\n \n extern int inhibit_warnings;\n-extern tree ctor_label, dtor_label;\n \n static tree build_new_method_call PROTO((tree, tree, tree, tree, int));\n "}, {"sha": "2a0babbebe758738e1f420cc71133d48e7faeda6", "filename": "gcc/cp/class.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -71,11 +71,6 @@ typedef struct class_stack_node {\n static int current_class_stack_size;\n static class_stack_node_t current_class_stack;\n \n-/* When we're processing a member function, current_class_ptr is the\n-   PARM_DECL for the `this' pointer.  The current_class_ref is an\n-   expression for `*this'.  */\n-tree current_class_ptr, current_class_ref;\n-\n /* The following two can be derived from the previous one */\n tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n tree current_class_type;\t/* _TYPE: the type of the current class */"}, {"sha": "d00cc0069e3a0764500bb8e576f436c983b2d3dd", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 236, "deletions": 122, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -432,10 +432,138 @@ extern tree cp_global_trees[CPTI_MAX];\n #define abort_fndecl\t\t\tcp_global_trees[CPTI_ABORT_FNDECL]\n #define global_delete_fndecl\t\tcp_global_trees[CPTI_GLOBAL_DELETE_FNDECL]\n \n-extern int current_function_returns_value;\n-extern int current_function_returns_null;\n-extern tree current_function_return_value;\n+/* Global state pertinent to the current function.  */\n+\n+struct cp_function\n+{\n+  tree named_labels;\n+  tree ctor_label;\n+  tree dtor_label;\n+  tree base_init_list;\n+  tree member_init_list;\n+  tree base_init_expr;\n+  tree current_class_ptr;\n+  tree current_class_ref;\n+  tree last_tree;\n+  tree last_expr_type;\n+\n+  struct rtx_def *last_dtor_insn;\n+  struct rtx_def *last_parm_cleanup_insn;\n+  struct rtx_def *result_rtx;\n+\n+  int returns_value;\n+  int returns_null;\n+  int assigns_this;\n+  int just_assigned_this;\n+  int parms_stored;\n+  int temp_name_counter;\n+  int static_labelno;\n+  int in_function_try_handler;\n+  int expanding_p;\n+  int stmts_are_full_exprs_p; \n+\n+  struct named_label_list *named_label_uses;\n+  struct binding_level *binding_level;\n+\n+  struct cp_function *next;\n+};\n+\n+/* A stack of cp_functions.  The head is the one that is used for all\n+   the per-function globals.  */\n+\n+extern struct cp_function *cp_function_chain;\n+\n+/* In a destructor, the point at which all derived class destroying\n+   has been done, just before any base class destroying will be done.  */\n+\n+#define dtor_label cp_function_chain->dtor_label\n+\n+/* In a constructor, the point at which we are ready to return\n+   the pointer to the initialized object.  */\n+\n+#define ctor_label cp_function_chain->ctor_label\n+\n+/* In C++, structures with well-defined constructors are initialized by\n+   those constructors, unasked.  CURRENT_BASE_INIT_LIST\n+   holds a list of stmts for a BASE_INIT term in the grammar.\n+   This list has one element for each base class which must be\n+   initialized.  The list elements are [basename, init], with\n+   type basetype.  This allows the possibly anachronistic form\n+   (assuming d : a, b, c) \"d (int a) : c(a+5), b (a-4), a (a+3)\"\n+   where each successive term can be handed down the constructor\n+   line.  Perhaps this was not intended.  */\n+\n+#define current_base_init_list cp_function_chain->base_init_list\n+#define current_member_init_list cp_function_chain->member_init_list\n+\n+/* Sequence of insns which represents base initialization.  */\n+\n+#define base_init_expr cp_function_chain->base_init_expr\n+\n+/* When we're processing a member function, current_class_ptr is the\n+   PARM_DECL for the `this' pointer.  The current_class_ref is an\n+   expression for `*this'.  */\n+\n+#define current_class_ptr cp_function_chain->current_class_ptr\n+#define current_class_ref cp_function_chain->current_class_ref\n+\n+/* When building a statement-tree, this is the last node added to the\n+   tree.  */\n+\n+#define last_tree cp_function_chain->last_tree\n+\n+/* The type of the last expression-statement we have seen.  This is\n+   required because the type of a statement-expression is the type of\n+   the last expression statement.  */\n+\n+#define last_expr_type cp_function_chain->last_expr_type\n \n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement that specifies a return value is seen.  */\n+\n+#define current_function_returns_value cp_function_chain->returns_value\n+\n+/* Set to 0 at beginning of a function definition, set to 1 if\n+   a return statement with no argument is seen.  */\n+\n+#define current_function_returns_null cp_function_chain->returns_null\n+\n+#define current_function_just_assigned_this \\\n+  cp_function_chain->just_assigned_this\n+\n+#define current_function_parms_stored \\\n+  cp_function_chain->parms_stored\n+\n+/* Used to help generate temporary names which are unique within\n+   a function.  Reset to 0 by start_function.  */\n+\n+#define temp_name_counter cp_function_chain->temp_name_counter\n+\n+#define static_labelno cp_function_chain->static_labelno\n+\n+/* Non-zero if we should generate RTL for functions that we process.\n+   When this is zero, we just accumulate tree structure, without\n+   interacting with the back end.  */\n+\n+#define expanding_p cp_function_chain->expanding_p\n+\n+/* Non-zero if we should treat statements as full expressions.  In\n+   particular, this variable is no-zero if at the end of a statement\n+   we should destroy any temporaries created during that statement.\n+   Similarly, if, at the end of a block, we should destroy any local\n+   variables in this block.  Normally, this variable is non-zero,\n+   since those are the normal semantics of C++.\n+\n+   However, in order to represent aggregate initialization code as\n+   tree structure, we use statement-expressions.  The statements\n+   within the statement expression should not result in cleanups being\n+   run until the entire enclosing statement is complete.  */\n+\n+#define stmts_are_full_exprs_p cp_function_chain->stmts_are_full_exprs_p\n+\n+#define in_function_try_handler cp_function_chain->in_function_try_handler\n+\n+extern tree current_function_return_value;\n extern tree current_namespace;\n extern tree global_namespace;\n \n@@ -753,67 +881,64 @@ enum languages { lang_c, lang_cplusplus, lang_java };\n    a minimum.  */\n struct lang_type\n {\n-  struct\n-    {\n-      unsigned has_type_conversion : 1;\n-      unsigned has_init_ref : 1;\n-      unsigned has_default_ctor : 1;\n-      unsigned uses_multiple_inheritance : 1;\n-      unsigned const_needs_init : 1;\n-      unsigned ref_needs_init : 1;\n-      unsigned has_const_assign_ref : 1;\n-      unsigned anon_aggr : 1;\n-\n-      unsigned has_nonpublic_ctor : 2;\n-      unsigned has_nonpublic_assign_ref : 2;\n-      unsigned vtable_needs_writing : 1;\n-      unsigned has_assign_ref : 1;\n-      unsigned gets_new : 2;\n-\n-      unsigned gets_delete : 2;\n-      unsigned has_call_overloaded : 1;\n-      unsigned has_array_ref_overloaded : 1;\n-      unsigned has_arrow_overloaded : 1;\n-      unsigned interface_only : 1;\n-      unsigned interface_unknown : 1;\n-      unsigned needs_virtual_reinit : 1;\n-\n-      unsigned marks: 6;\n-      unsigned vec_delete_takes_size : 1;\n-      unsigned declared_class : 1;\n-\n-      unsigned being_defined : 1;\n-      unsigned redefined : 1;\n-      unsigned debug_requested : 1;\n-      unsigned use_template : 2;\n-      unsigned got_semicolon : 1;\n-      unsigned ptrmemfunc_flag : 1;\n-      unsigned was_anonymous : 1;\n-\n-      unsigned has_real_assign_ref : 1;\n-      unsigned has_const_init_ref : 1;\n-      unsigned has_complex_init_ref : 1;\n-      unsigned has_complex_assign_ref : 1;\n-      unsigned has_abstract_assign_ref : 1;\n-      unsigned non_aggregate : 1;\n-      unsigned is_partial_instantiation : 1;\n-      unsigned has_mutable : 1;\n-\n-      unsigned com_interface : 1;\n-      unsigned non_pod_class : 1;\n-\n-      /* When adding a flag here, consider whether or not it ought to\n-\t apply to a template instance if it applies to the template.\n-\t If so, make sure to copy it in instantiate_class_template!  */\n-\n-      /* The MIPS compiler gets it wrong if this struct also\n-\t does not fill out to a multiple of 4 bytes.  Add a\n-\t member `dummy' with new bits if you go over the edge.  */\n-      unsigned dummy : 6;\n+  unsigned char align;\n+\n+  unsigned has_type_conversion : 1;\n+  unsigned has_init_ref : 1;\n+  unsigned has_default_ctor : 1;\n+  unsigned uses_multiple_inheritance : 1;\n+  unsigned const_needs_init : 1;\n+  unsigned ref_needs_init : 1;\n+  unsigned has_const_assign_ref : 1;\n+  unsigned anon_aggr : 1;\n+\n+  unsigned has_nonpublic_ctor : 2;\n+  unsigned has_nonpublic_assign_ref : 2;\n+  unsigned vtable_needs_writing : 1;\n+  unsigned has_assign_ref : 1;\n+  unsigned gets_new : 2;\n+\n+  unsigned gets_delete : 2;\n+  unsigned has_call_overloaded : 1;\n+  unsigned has_array_ref_overloaded : 1;\n+  unsigned has_arrow_overloaded : 1;\n+  unsigned interface_only : 1;\n+  unsigned interface_unknown : 1;\n+  unsigned needs_virtual_reinit : 1;\n+\n+  unsigned marks: 6;\n+  unsigned vec_delete_takes_size : 1;\n+  unsigned declared_class : 1;\n+\n+  unsigned being_defined : 1;\n+  unsigned redefined : 1;\n+  unsigned debug_requested : 1;\n+  unsigned use_template : 2;\n+  unsigned got_semicolon : 1;\n+  unsigned ptrmemfunc_flag : 1;\n+  unsigned was_anonymous : 1;\n+\n+  unsigned has_real_assign_ref : 1;\n+  unsigned has_const_init_ref : 1;\n+  unsigned has_complex_init_ref : 1;\n+  unsigned has_complex_assign_ref : 1;\n+  unsigned has_abstract_assign_ref : 1;\n+  unsigned non_aggregate : 1;\n+  unsigned is_partial_instantiation : 1;\n+  unsigned has_mutable : 1;\n+\n+  unsigned com_interface : 1;\n+  unsigned non_pod_class : 1;\n+\n+  /* When adding a flag here, consider whether or not it ought to\n+     apply to a template instance if it applies to the template.  If\n+     so, make sure to copy it in instantiate_class_template!  */\n+\n+  /* There are six bits left to fill out a 32-bit word.  Keep track of\n+     this by updating the size of this bitfield whenever you add or\n+     remove a flag.  */\n+  unsigned dummy : 6;\n       \n-      unsigned char align;\n-    } type_flags;\n-\n   int vsize;\n   int vfield_parent;\n \n@@ -842,7 +967,7 @@ struct lang_type\n      1=implicit template instantiation\n      2=explicit template specialization\n      3=explicit template instantiation  */\n-#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.use_template)\n+#define CLASSTYPE_USE_TEMPLATE(NODE) (TYPE_LANG_SPECIFIC(NODE)->use_template)\n \n /* Fields used for storing information before the class is defined.\n    After the class is defined, these fields hold other information.  */\n@@ -852,53 +977,53 @@ struct lang_type\n \n /* Nonzero for _CLASSTYPE means that operator new and delete are defined,\n    respectively.  */\n-#define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_new)\n-#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.gets_delete)\n+#define TYPE_GETS_NEW(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_new)\n+#define TYPE_GETS_DELETE(NODE) (TYPE_LANG_SPECIFIC(NODE)->gets_delete)\n #define TYPE_GETS_REG_DELETE(NODE) (TYPE_GETS_DELETE (NODE) & 1)\n \n /* Nonzero for _CLASSTYPE means that operator vec delete is defined and\n    takes the optional size_t argument.  */\n #define TYPE_VEC_DELETE_TAKES_SIZE(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->type_flags.vec_delete_takes_size)\n+  (TYPE_LANG_SPECIFIC(NODE)->vec_delete_takes_size)\n #define TYPE_VEC_NEW_USES_COOKIE(NODE) \\\n   (TYPE_NEEDS_DESTRUCTOR (NODE) \\\n    || (TYPE_LANG_SPECIFIC (NODE) && TYPE_VEC_DELETE_TAKES_SIZE (NODE)))\n \n /* Nonzero means that this _CLASSTYPE node defines ways of converting\n    itself to other types.  */\n-#define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_type_conversion)\n+#define TYPE_HAS_CONVERSION(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_type_conversion)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator=(X&).  */\n-#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_assign_ref)\n-#define TYPE_HAS_CONST_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_assign_ref)\n+#define TYPE_HAS_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_assign_ref)\n+#define TYPE_HAS_CONST_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_const_assign_ref)\n \n /* Nonzero means that this _CLASSTYPE node has an X(X&) constructor.  */\n-#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_init_ref)\n-#define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_const_init_ref)\n+#define TYPE_HAS_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_init_ref)\n+#define TYPE_HAS_CONST_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_const_init_ref)\n \n /* Nonzero means that this type is being defined.  I.e., the left brace\n    starting the definition of this type has been seen.  */\n-#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.being_defined)\n+#define TYPE_BEING_DEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->being_defined)\n /* Nonzero means that this type has been redefined.  In this case, if\n    convenient, don't reprocess any methods that appear in its redefinition.  */\n-#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.redefined)\n+#define TYPE_REDEFINED(NODE) (TYPE_LANG_SPECIFIC(NODE)->redefined)\n \n /* The is the basetype that contains NODE's rtti.  */\n #define CLASSTYPE_RTTI(NODE) (TYPE_LANG_SPECIFIC(NODE)->rtti)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator().  */\n-#define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_call_overloaded)\n+#define TYPE_OVERLOADS_CALL_EXPR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_call_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator[].  */\n-#define TYPE_OVERLOADS_ARRAY_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_array_ref_overloaded)\n+#define TYPE_OVERLOADS_ARRAY_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_array_ref_overloaded)\n \n /* Nonzero means that this _CLASSTYPE node overloads operator->.  */\n-#define TYPE_OVERLOADS_ARROW(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_arrow_overloaded)\n+#define TYPE_OVERLOADS_ARROW(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_arrow_overloaded)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    multiple inheritance.  If this is 0 for the root of a type\n    hierarchy, then we can use more efficient search techniques.  */\n-#define TYPE_USES_MULTIPLE_INHERITANCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.uses_multiple_inheritance)\n+#define TYPE_USES_MULTIPLE_INHERITANCE(NODE) (TYPE_LANG_SPECIFIC(NODE)->uses_multiple_inheritance)\n \n /* Nonzero means that this _CLASSTYPE (or one of its ancestors) uses\n    virtual base classes.  If this is 0 for the root of a type\n@@ -925,19 +1050,19 @@ struct lang_type\n \n /* Get the value of the Nth mark bit.  */\n #define CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\t\\\n-  (((CLASS_TYPE_P (NODE) ? TYPE_LANG_SPECIFIC (NODE)->type_flags.marks\t\\\n+  (((CLASS_TYPE_P (NODE) ? TYPE_LANG_SPECIFIC (NODE)->marks\t\\\n      : TYPE_ALIAS_SET (NODE)) & (1 << N)) != 0)\n \n /* Set the Nth mark bit.  */\n #define SET_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\t\\\n   (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\t\\\n-   ? (TYPE_LANG_SPECIFIC (NODE)->type_flags.marks |= (1 << (N)))\t\\\n+   ? (TYPE_LANG_SPECIFIC (NODE)->marks |= (1 << (N)))\t\\\n    : (TYPE_ALIAS_SET (NODE) |= (1 << (N))))\n \n /* Clear the Nth mark bit.  */\n #define CLEAR_CLASSTYPE_MARKED_N(NODE, N)\t\t\t\t\\\n   (CLASS_TYPE_P (NODE)\t\t\t\t\t\t\t\\\n-   ? (TYPE_LANG_SPECIFIC (NODE)->type_flags.marks &= ~(1 << (N)))\t\\\n+   ? (TYPE_LANG_SPECIFIC (NODE)->marks &= ~(1 << (N)))\t\\\n    : (TYPE_ALIAS_SET (NODE) &= ~(1 << (N))))\n \n /* Get the value of the mark bits.  */\n@@ -998,47 +1123,47 @@ struct lang_type\n /* These are the size, mode and alignment of the type without its\n    virtual base classes, for when we use this type as a base itself.  */\n #define CLASSTYPE_SIZE(NODE) (TYPE_LANG_SPECIFIC(NODE)->size)\n-#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.align)\n+#define CLASSTYPE_ALIGN(NODE) (TYPE_LANG_SPECIFIC(NODE)->align)\n \n /* A cons list of virtual functions which cannot be inherited by\n    derived classes.  When deriving from this type, the derived\n    class must provide its own definition for each of these functions.  */\n #define CLASSTYPE_ABSTRACT_VIRTUALS(NODE) (TYPE_LANG_SPECIFIC(NODE)->abstract_virtuals)\n \n /* Nonzero means that this aggr type has been `closed' by a semicolon.  */\n-#define CLASSTYPE_GOT_SEMICOLON(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.got_semicolon)\n+#define CLASSTYPE_GOT_SEMICOLON(NODE) (TYPE_LANG_SPECIFIC (NODE)->got_semicolon)\n \n /* Nonzero means that the main virtual function table pointer needs to be\n    set because base constructors have placed the wrong value there.\n    If this is zero, it means that they placed the right value there,\n    and there is no need to change it.  */\n-#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.needs_virtual_reinit)\n+#define CLASSTYPE_NEEDS_VIRTUAL_REINIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->needs_virtual_reinit)\n \n /* Nonzero means that if this type has virtual functions, that\n    the virtual function table will be written out.  */\n-#define CLASSTYPE_VTABLE_NEEDS_WRITING(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.vtable_needs_writing)\n+#define CLASSTYPE_VTABLE_NEEDS_WRITING(NODE) (TYPE_LANG_SPECIFIC(NODE)->vtable_needs_writing)\n \n /* Nonzero means that this type has an X() constructor.  */\n-#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_default_ctor)\n+#define TYPE_HAS_DEFAULT_CONSTRUCTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_default_ctor)\n \n /* Nonzero means the type declared a ctor as private or protected.  We\n    use this to make sure we don't try to generate a copy ctor for a \n    class that has a member of type NODE.  */\n-#define TYPE_HAS_NONPUBLIC_CTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_nonpublic_ctor)\n+#define TYPE_HAS_NONPUBLIC_CTOR(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_nonpublic_ctor)\n \n /* Ditto, for operator=.  */\n-#define TYPE_HAS_NONPUBLIC_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_nonpublic_assign_ref)\n+#define TYPE_HAS_NONPUBLIC_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_nonpublic_assign_ref)\n \n /* Nonzero means that this type contains a mutable member */\n-#define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_mutable)\n+#define CLASSTYPE_HAS_MUTABLE(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_mutable)\n #define TYPE_HAS_MUTABLE_P(NODE) (cp_has_mutable_p (NODE))\n \n /*  Nonzero means that this class type is a non-POD class.  */\n-#define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.non_pod_class)\n+#define CLASSTYPE_NON_POD_P(NODE) (TYPE_LANG_SPECIFIC (NODE)->non_pod_class)\n \n /* Nonzero means that this type is meant for communication via COM.  */\n #define CLASSTYPE_COM_INTERFACE(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->type_flags.com_interface)\n+  (TYPE_LANG_SPECIFIC(NODE)->com_interface)\n \n /* A list of class types of which this type is a friend.  The\n    TREE_VALUE is normally a TYPE, but will be a TEMPLATE_DECL in the\n@@ -1050,27 +1175,27 @@ struct lang_type\n   (TYPE_LANG_SPECIFIC (NODE)->befriending_classes)\n \n /* Say whether this node was declared as a \"class\" or a \"struct\".  */\n-#define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.declared_class)\n+#define CLASSTYPE_DECLARED_CLASS(NODE) (TYPE_LANG_SPECIFIC(NODE)->declared_class)\n \n /* Nonzero if this class has const members which have no specified initialization.  */\n-#define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.const_needs_init)\n+#define CLASSTYPE_READONLY_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->const_needs_init)\n \n /* Nonzero if this class has ref members which have no specified initialization.  */\n-#define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.ref_needs_init)\n+#define CLASSTYPE_REF_FIELDS_NEED_INIT(NODE) (TYPE_LANG_SPECIFIC(NODE)->ref_needs_init)\n \n /* Nonzero if this class is included from a header file which employs\n    `#pragma interface', and it is not included in its implementation file.  */\n-#define CLASSTYPE_INTERFACE_ONLY(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_only)\n+#define CLASSTYPE_INTERFACE_ONLY(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_only)\n \n /* Same as above, but for classes whose purpose we do not know.  */\n-#define CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown)\n-#define CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown == 0)\n-#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = !!(X))\n-#define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = 1)\n-#define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.interface_unknown = 0)\n+#define CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown)\n+#define CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown == 0)\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN_X(NODE,X) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = !!(X))\n+#define SET_CLASSTYPE_INTERFACE_UNKNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 1)\n+#define SET_CLASSTYPE_INTERFACE_KNOWN(NODE) (TYPE_LANG_SPECIFIC(NODE)->interface_unknown = 0)\n \n /* Nonzero if a _DECL node requires us to output debug info for this class.  */\n-#define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.debug_requested)\n+#define CLASSTYPE_DEBUG_REQUESTED(NODE) (TYPE_LANG_SPECIFIC(NODE)->debug_requested)\n \f\n /* Additional macros for inheritance information.  */\n \n@@ -1692,15 +1817,15 @@ extern int flag_new_for_scope;\n /* Nonzero means that an object of this type can not be initialized using\n    an initializer list.  */\n #define CLASSTYPE_NON_AGGREGATE(NODE) \\\n-  (TYPE_LANG_SPECIFIC (NODE)->type_flags.non_aggregate)\n+  (TYPE_LANG_SPECIFIC (NODE)->non_aggregate)\n #define TYPE_NON_AGGREGATE_CLASS(NODE) \\\n   (IS_AGGR_TYPE (NODE) && CLASSTYPE_NON_AGGREGATE (NODE))\n \n /* Nonzero if there is a user-defined X::op=(x&) for this class.  */\n-#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_real_assign_ref)\n-#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_assign_ref)\n-#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_abstract_assign_ref)\n-#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->type_flags.has_complex_init_ref)\n+#define TYPE_HAS_REAL_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_real_assign_ref)\n+#define TYPE_HAS_COMPLEX_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_assign_ref)\n+#define TYPE_HAS_ABSTRACT_ASSIGN_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_abstract_assign_ref)\n+#define TYPE_HAS_COMPLEX_INIT_REF(NODE) (TYPE_LANG_SPECIFIC(NODE)->has_complex_init_ref)\n \n /* Nonzero for _TYPE node means that destroying an object of this type\n    will involve a call to a destructor.  This can apply to objects\n@@ -1740,7 +1865,7 @@ extern int flag_new_for_scope;\n    && TYPE_PTRMEMFUNC_FLAG (NODE))\n \n #define TYPE_PTRMEMFUNC_FLAG(NODE) \\\n-  (TYPE_LANG_SPECIFIC(NODE)->type_flags.ptrmemfunc_flag)\n+  (TYPE_LANG_SPECIFIC(NODE)->ptrmemfunc_flag)\n \n /* A pointer-to-function member type looks like:\n \n@@ -1848,9 +1973,9 @@ extern int flag_new_for_scope;\n    flag for this because \"A union for which objects or pointers are\n    declared is not an anonymous union\" [class.union].  */\n #define ANON_AGGR_TYPE_P(NODE)\t\t\t\t\\\n-  (CLASS_TYPE_P (NODE) && TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_aggr)\n+  (CLASS_TYPE_P (NODE) && TYPE_LANG_SPECIFIC (NODE)->anon_aggr)\n #define SET_ANON_AGGR_TYPE_P(NODE)\t\t\t\\\n-  (TYPE_LANG_SPECIFIC (NODE)->type_flags.anon_aggr = 1)\n+  (TYPE_LANG_SPECIFIC (NODE)->anon_aggr = 1)\n \n #define UNKNOWN_TYPE LANG_TYPE\n \n@@ -1868,7 +1993,7 @@ extern int flag_new_for_scope;\n #define DECL_VPARENT(NODE) ((NODE)->decl.arguments)\n #endif\n \n-#define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->type_flags.was_anonymous)\n+#define TYPE_WAS_ANONYMOUS(NODE) (TYPE_LANG_SPECIFIC (NODE)->was_anonymous)\n \n /* C++: all of these are overloaded!  These apply only to TYPE_DECLs.  */\n \n@@ -2072,7 +2197,7 @@ extern int flag_new_for_scope;\n    i.e., an instantiation whose instantiation arguments involve\n    template types.  */\n #define PARTIAL_INSTANTIATION_P(TYPE) \\\n-  (TYPE_LANG_SPECIFIC (TYPE)->type_flags.is_partial_instantiation)\n+  (TYPE_LANG_SPECIFIC (TYPE)->is_partial_instantiation)\n \n /* Non-zero iff we are currently processing a declaration for an\n    entity with its own template parameter list, and which is not a\n@@ -2265,8 +2390,6 @@ extern tree tag_identifier;\n extern tree vt_off_identifier;\n extern tree empty_except_spec;\n \n-extern int in_function_try_handler;\n-\n /* A node that is a list (length 1) of error_mark_nodes.  */\n extern tree error_mark_list;\n \n@@ -2297,7 +2420,6 @@ typedef enum unification_kind_t {\n \n extern tree current_template_parms;\n extern HOST_WIDE_INT processing_template_decl;\n-extern tree last_tree;\n \n /* The template currently being instantiated, and where the instantiation\n    was triggered.  */\n@@ -2321,9 +2443,7 @@ extern tree current_access_specifier;\n \n extern tree current_class_name;\n extern tree current_class_type;\n-extern tree current_class_ptr;\n extern tree previous_class_type;\n-extern tree current_class_ref;\n extern int current_class_depth;\n \n extern tree current_lang_name;\n@@ -2338,10 +2458,7 @@ extern tree original_function_name;\n \n /* in init.c  */\n extern tree global_base_init_list;\n-extern tree current_base_init_list, current_member_init_list;\n \n-extern int current_function_just_assigned_this;\n-extern int current_function_parms_stored;\n \f\n /* Here's where we control how name mangling takes place.  */\n \n@@ -3402,9 +3519,6 @@ extern tree expand_stmt                         PROTO((tree));\n extern void expand_body                         PROTO((tree));\n extern void begin_stmt_tree                     PROTO((tree));\n extern void finish_stmt_tree                    PROTO((tree));\n-extern int expanding_p;\n-extern int stmts_are_full_exprs_p;\n-extern tree last_expr_type;\n /* Non-zero if we are presently building a statement tree, rather\n    than expanding each statement as we encounter it.  */\n #define building_stmt_tree() \\"}, {"sha": "82b3124a75f2e23a8e2d485258116a3761473cae", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 129, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -55,8 +55,6 @@ extern int current_class_depth;\n \n extern tree static_ctors, static_dtors;\n \n-extern int static_labelno;\n-\n extern tree current_namespace;\n extern tree global_namespace;\n \n@@ -300,36 +298,24 @@ int in_std;\n /* Expect only namespace names now. */\n static int only_namespace_names;\n \n-/* In a destructor, the point at which all derived class destroying\n-   has been done, just before any base class destroying will be done.  */\n-\n-tree dtor_label;\n-\n /* In a destructor, the last insn emitted after the start of the\n    function and the parms.  */\n \n-static rtx last_dtor_insn;\n+#define last_dtor_insn cp_function_chain->last_dtor_insn\n \n /* In a constructor, the last insn emitted after the start of the\n    function and the parms, the exception specification and any\n    function-try-block.  The constructor initializers are emitted after\n    this insn.  */\n \n-static rtx last_parm_cleanup_insn;\n-\n-/* In a constructor, the point at which we are ready to return\n-   the pointer to the initialized object.  */\n-\n-tree ctor_label;\n+#define last_parm_cleanup_insn cp_function_chain->last_parm_cleanup_insn\n \n /* If original DECL_RESULT of current function was a register,\n    but due to being an addressable named return value, would up\n    on the stack, this variable holds the named return value's\n    original location.  */\n-static rtx original_result_rtx;\n \n-/* Sequence of insns which represents base initialization.  */\n-tree base_init_expr;\n+#define original_result_rtx cp_function_chain->result_rtx\n \n /* C++: Keep these around to reduce calls to `get_identifier'.\n    Identifiers for `this' in member functions and the auto-delete\n@@ -344,9 +330,6 @@ tree vt_off_identifier;\n /* Exception specifier used for throw().  */\n tree empty_except_spec;\n \n-/* Nonzero if we're in a handler for a function-try-block.  */\n-int in_function_try_handler;\n-\n struct named_label_list\n {\n   struct binding_level *binding_level;\n@@ -374,7 +357,7 @@ struct named_label_list\n    jumps to defined labels can have their validity checked\n    by stmt.c.  */\n \n-static struct named_label_list *named_label_uses = NULL;\n+#define named_label_uses cp_function_chain->named_label_uses\n \n /* A list of objects which have constructors or destructors\n    which reside in the global scope.  The decl is stored in\n@@ -431,22 +414,12 @@ static tree current_function_parm_tags;\n    at the end of the function.  The TREE_VALUE is a LABEL_DECL; the\n    TREE_PURPOSE is the previous binding of the label.  */\n \n-static tree named_labels;\n+#define named_labels cp_function_chain->named_labels\n \n /* The FUNCTION_DECL for the function currently being compiled,\n    or 0 if between functions.  */\n tree current_function_decl;\n \n-/* Set to 0 at beginning of a function definition, set to 1 if\n-   a return statement that specifies a return value is seen.  */\n-\n-int current_function_returns_value;\n-\n-/* Set to 0 at beginning of a function definition, set to 1 if\n-   a return statement with no argument is seen.  */\n-\n-int current_function_returns_null;\n-\n /* Set to 0 at beginning of a function definition, and whenever\n    a label (case or named) is defined.  Set to value of expression\n    returned from function when that value can be transformed into\n@@ -491,13 +464,9 @@ extern tree *current_lang_base, *current_lang_stack;\n /* Set to 0 at beginning of a constructor, set to 1\n    if that function does an allocation before referencing its\n    instance variable.  */\n-static int current_function_assigns_this;\n-int current_function_just_assigned_this;\n-\n-/* Set to 0 at beginning of a function.  Set non-zero when\n-   store_parm_decls is called.  Don't call store_parm_decls\n-   if this flag is non-zero!  */\n-int current_function_parms_stored;\n+#define current_function_assigns_this cp_function_chain->assigns_this\n+#define current_function_just_assigned_this \\\n+  cp_function_chain->just_assigned_this\n \n /* Flag used when debugging spew.c */\n \n@@ -664,7 +633,7 @@ struct binding_level\n   \n /* The binding level currently in effect.  */\n \n-static struct binding_level *current_binding_level;\n+#define current_binding_level cp_function_chain->binding_level\n \n /* The binding level of the current class, if any.  */\n \n@@ -6204,6 +6173,9 @@ init_decl_processing ()\n   lang_name_c = get_identifier (\"C\");\n   lang_name_java = get_identifier (\"Java\");\n \n+  /* Create the global per-function variables.  */\n+  push_cp_function_context (NULL_TREE);\n+\n   /* Enter the global namespace. */\n   my_friendly_assert (global_namespace == NULL_TREE, 375);\n   my_friendly_assert (current_lang_name == NULL_TREE, 375);\n@@ -14522,39 +14494,7 @@ revert_static_member_fn (decl, fn, argtypes)\n     *argtypes = args;\n }\n \n-struct cp_function\n-{\n-  int returns_value;\n-  int returns_null;\n-  int assigns_this;\n-  int just_assigned_this;\n-  int parms_stored;\n-  int temp_name_counter;\n-  tree named_labels;\n-  struct named_label_list *named_label_uses;\n-  tree ctor_label;\n-  tree dtor_label;\n-  rtx last_dtor_insn;\n-  rtx last_parm_cleanup_insn;\n-  tree base_init_list;\n-  tree member_init_list;\n-  tree base_init_expr;\n-  tree current_class_ptr;\n-  tree current_class_ref;\n-  rtx result_rtx;\n-  struct cp_function *next;\n-  struct binding_level *binding_level;\n-  int static_labelno;\n-  int in_function_try_handler;\n-  int expanding_p;\n-  int stmts_are_full_exprs_p; \n-  tree last_tree;\n-  tree last_expr_type;\n-};\n-\n-static struct cp_function *cp_function_chain;\n-\n-extern int temp_name_counter;\n+struct cp_function *cp_function_chain;\n \n /* Save and reinitialize the variables\n    used during compilation of a C++ function.  */\n@@ -14563,40 +14503,20 @@ void\n push_cp_function_context (context)\n      tree context;\n {\n-  struct cp_function *p\n-    = (struct cp_function *) xmalloc (sizeof (struct cp_function));\n+  struct cp_function *p;\n \n+  /* Push the language-independent context.  */\n   push_function_context_to (context);\n \n+  /* Push the C++-specific context.  */\n+  p = (struct cp_function *) xmalloc (sizeof (struct cp_function));\n+  if (cp_function_chain)\n+    *p = *cp_function_chain;\n+  else\n+    bzero (p, sizeof (struct cp_function));\n   p->next = cp_function_chain;\n   cp_function_chain = p;\n \n-  p->named_labels = named_labels;\n-  p->named_label_uses = named_label_uses;\n-  p->returns_value = current_function_returns_value;\n-  p->returns_null = current_function_returns_null;\n-  p->binding_level = current_binding_level;\n-  p->ctor_label = ctor_label;\n-  p->dtor_label = dtor_label;\n-  p->last_dtor_insn = last_dtor_insn;\n-  p->last_parm_cleanup_insn = last_parm_cleanup_insn;\n-  p->assigns_this = current_function_assigns_this;\n-  p->just_assigned_this = current_function_just_assigned_this;\n-  p->parms_stored = current_function_parms_stored;\n-  p->result_rtx = original_result_rtx;\n-  p->base_init_expr = base_init_expr;\n-  p->temp_name_counter = temp_name_counter;\n-  p->base_init_list = current_base_init_list;\n-  p->member_init_list = current_member_init_list;\n-  p->current_class_ptr = current_class_ptr;\n-  p->current_class_ref = current_class_ref;\n-  p->static_labelno = static_labelno;\n-  p->in_function_try_handler = in_function_try_handler;\n-  p->last_tree = last_tree;\n-  p->last_expr_type = last_expr_type;\n-  p->expanding_p = expanding_p;\n-  p->stmts_are_full_exprs_p = stmts_are_full_exprs_p;\n-\n   /* For now, we always assume we're expanding all the way to RTL\n      unless we're explicitly doing otherwise.  */\n   expanding_p = 1;\n@@ -14612,38 +14532,14 @@ void\n pop_cp_function_context (context)\n      tree context;\n {\n-  struct cp_function *p = cp_function_chain;\n+  struct cp_function *p;\n \n+  /* Pop the language-independent context.  */\n   pop_function_context_from (context);\n \n+  /* Pop the C++-specific context.  */\n+  p = cp_function_chain;\n   cp_function_chain = p->next;\n-\n-  named_labels = p->named_labels;\n-  named_label_uses = p->named_label_uses;\n-  current_function_returns_value = p->returns_value;\n-  current_function_returns_null = p->returns_null;\n-  current_binding_level = p->binding_level;\n-  ctor_label = p->ctor_label;\n-  dtor_label = p->dtor_label;\n-  last_dtor_insn = p->last_dtor_insn;\n-  last_parm_cleanup_insn = p->last_parm_cleanup_insn;\n-  current_function_assigns_this = p->assigns_this;\n-  current_function_just_assigned_this = p->just_assigned_this;\n-  current_function_parms_stored = p->parms_stored;\n-  original_result_rtx = p->result_rtx;\n-  base_init_expr = p->base_init_expr;\n-  temp_name_counter = p->temp_name_counter;\n-  current_base_init_list = p->base_init_list;\n-  current_member_init_list = p->member_init_list;\n-  current_class_ptr = p->current_class_ptr;\n-  current_class_ref = p->current_class_ref;\n-  static_labelno = p->static_labelno;\n-  in_function_try_handler = p->in_function_try_handler;\n-  last_tree = p->last_tree;\n-  last_expr_type = p->last_expr_type;\n-  expanding_p = p->expanding_p;\n-  stmts_are_full_exprs_p = p->stmts_are_full_exprs_p;\n-\n   free (p);\n }\n "}, {"sha": "7dc994930bf05bd84dc94917d17d1c3011ebdcd4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -112,11 +112,6 @@ static size_t pending_statics_used;\n static varray_type saved_inlines;\n static size_t saved_inlines_used;\n \n-/* Used to help generate temporary names which are unique within\n-   a function.  Reset to 0 by start_function.  */\n-\n-int temp_name_counter;\n-\n /* Same, but not reset.  Local temp variables and global temp variables\n    can have the same name.  */\n static int global_temp_name_counter;"}, {"sha": "545610ed574a847bc3c2baa93a7f4927ec423030", "filename": "gcc/cp/init.c", "status": "modified", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -33,17 +33,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"expr.h\"\n #include \"toplev.h\"\n \n-/* In C++, structures with well-defined constructors are initialized by\n-   those constructors, unasked.  CURRENT_BASE_INIT_LIST\n-   holds a list of stmts for a BASE_INIT term in the grammar.\n-   This list has one element for each base class which must be\n-   initialized.  The list elements are [basename, init], with\n-   type basetype.  This allows the possibly anachronistic form\n-   (assuming d : a, b, c) \"d (int a) : c(a+5), b (a-4), a (a+3)\"\n-   where each successive term can be handed down the constructor\n-   line.  Perhaps this was not intended.  */\n-tree current_base_init_list, current_member_init_list;\n-\n static void expand_aggr_vbase_init_1 PROTO((tree, tree, tree, tree));\n static void construct_virtual_bases PROTO((tree, tree, tree, tree, tree));\n static void expand_aggr_init_1 PROTO((tree, tree, tree, tree, int));\n@@ -502,8 +491,6 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n    Note that emit_base_init does *not* initialize virtual base\n    classes.  That is done specially, elsewhere.  */\n \n-extern tree base_init_expr;\n-\n void\n emit_base_init (t)\n      tree t;"}, {"sha": "5ed50da8855784941b5d3b7ac18265cf8b5df1c7", "filename": "gcc/cp/method.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -47,8 +47,6 @@ Boston, MA 02111-1307, USA.  */\n    processed.  */\n struct pending_inline *pending_inlines;\n \n-int static_labelno;\n-\n #define obstack_chunk_alloc xmalloc\n #define obstack_chunk_free free\n "}, {"sha": "b04ce7022e2c87b32dd6efed409f32ab6c3a7915", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -9874,8 +9874,6 @@ tsubst_expr_values (t, argvec)\n   return first;\n }\n \n-tree last_tree;\n-\n void\n add_tree (t)\n      tree t;"}, {"sha": "5502df344e57b57ea07594d0a53f8e2b4c8a9abd", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -45,29 +45,6 @@ static void expand_stmts PROTO((tree));\n static void do_pushlevel PROTO((void));\n static tree do_poplevel PROTO((void));\n \n-/* Non-zero if we should generate RTL for functions that we process.\n-   When this is zero, we just accumulate tree structure, without\n-   interacting with the back end.  */\n-int expanding_p = 1;\n-\n-/* Non-zero if we should treat statements as full expressions.  In\n-   particular, this variable is no-zero if at the end of a statement\n-   we should destroy any temporaries created during that statement.\n-   Similarly, if, at the end of a block, we should destroy any local\n-   variables in this block.  Normally, this variable is non-zero,\n-   since those are the normal semantics of C++.\n-\n-   However, in order to represent aggregate initialization code as\n-   tree structure, we use statement-expressions.  The statements\n-   within the statement expression should not result in cleanups being\n-   run until the entire enclosing statement is complete.  */\n-int stmts_are_full_exprs_p = 1;\n-\n-/* The type of the last expression-statement we have seen.  This is\n-   required because the type of a statement-expression is the type of\n-   the last expression statement.  */\n-tree last_expr_type;\n-\n /* When parsing a template, LAST_TREE contains the last statement\n    parsed.  These are chained together through the TREE_CHAIN field,\n    but often need to be re-organized since the parse is performed\n@@ -1030,8 +1007,6 @@ finish_named_return_value (return_id, init)\n void\n setup_vtbl_ptr ()\n {\n-  extern tree base_init_expr;\n-\n   if (base_init_expr == 0\n       && DECL_CONSTRUCTOR_P (current_function_decl))\n     {"}, {"sha": "d18744535b739f8c5658cededb803d0f9754d916", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8012c98334adc980f8e7ad5ceac47fa19b664662/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8012c98334adc980f8e7ad5ceac47fa19b664662", "patch": "@@ -6773,7 +6773,6 @@ void\n c_expand_return (retval)\n      tree retval;\n {\n-  extern tree dtor_label, ctor_label;\n   tree result = DECL_RESULT (current_function_decl);\n   tree valtype = TREE_TYPE (result);\n "}]}