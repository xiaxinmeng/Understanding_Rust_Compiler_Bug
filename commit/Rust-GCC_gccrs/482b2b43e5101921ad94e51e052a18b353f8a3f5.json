{"sha": "482b2b43e5101921ad94e51e052a18b353f8a3f5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDgyYjJiNDNlNTEwMTkyMWFkOTRlNTFlMDUyYTE4YjM1M2Y4YTNmNQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2020-01-09T15:08:26Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2020-01-09T15:08:26Z"}, "message": "Add a compatible_vector_types_p target hook\n\nOne problem with adding an N-bit vector extension to an existing\narchitecture is to decide how N-bit vectors should be passed to\nfunctions and returned from functions.  Allowing all N-bit vector\ntypes to be passed in registers breaks backwards compatibility,\nsince N-bit vectors could be used (and emulated) before the vector\nextension was added.  But always passing N-bit vectors on the\nstack would be inefficient for things like vector libm functions.\n\nFor SVE we took the compromise position of predefining new SVE vector\ntypes that are distinct from all existing vector types, including\nGNU-style vectors.  The new types are passed and returned in an\nefficient way while existing vector types are passed and returned\nin the traditional way.  In the right circumstances, the two types\nare inter-convertible.\n\nThe SVE types are created using:\n\n      vectype = build_distinct_type_copy (vectype);\n      SET_TYPE_STRUCTURAL_EQUALITY (vectype);\n      TYPE_ARTIFICIAL (vectype) = 1;\n\nThe C frontend maintains this distinction, using VIEW_CONVERT_EXPR\nto convert from one type to the other.  However, the distinction can\nbe lost during gimple, which treats two vector types with the same\nmode, number of elements, and element type as equivalent.  And for\nmost targets that's the right thing to do.\n\nThis patch therefore adds a hook that lets the target choose\nwhether such vector types are indeed equivalent.\n\nNote that the new tests fail for -mabi=ilp32 in the same way as other\nACLE-based tests.  I'm still planning to fix that as a follow-on.\n\n2020-01-09  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* target.def (compatible_vector_types_p): New target hook.\n\t* hooks.h (hook_bool_const_tree_const_tree_true): Declare.\n\t* hooks.c (hook_bool_const_tree_const_tree_true): New function.\n\t* doc/tm.texi.in (TARGET_COMPATIBLE_VECTOR_TYPES_P): New hook.\n\t* doc/tm.texi: Regenerate.\n\t* gimple-expr.c: Include target.h.\n\t(useless_type_conversion_p): Use targetm.compatible_vector_types_p.\n\t* config/aarch64/aarch64.c (aarch64_compatible_vector_types_p): New\n\tfunction.\n\t(TARGET_COMPATIBLE_VECTOR_TYPES_P): Define.\n\t* config/aarch64/aarch64-sve-builtins.cc (gimple_folder::convert_pred):\n\tUse the original predicate if it already has a suitable type.\n\ngcc/testsuite/\n\t* gcc.target/aarch64/sve/pcs/gnu_vectors_1.c: New test.\n\t* gcc.target/aarch64/sve/pcs/gnu_vectors_2.c: Likewise.\n\nFrom-SVN: r280047", "tree": {"sha": "7a5e26df37104db694de370115b38bbb80407fc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a5e26df37104db694de370115b38bbb80407fc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/482b2b43e5101921ad94e51e052a18b353f8a3f5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482b2b43e5101921ad94e51e052a18b353f8a3f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/482b2b43e5101921ad94e51e052a18b353f8a3f5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/482b2b43e5101921ad94e51e052a18b353f8a3f5/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "15df0040707d630b78f4dd34dd4f435026dea56c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15df0040707d630b78f4dd34dd4f435026dea56c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15df0040707d630b78f4dd34dd4f435026dea56c"}], "stats": {"total": 302, "additions": 296, "deletions": 6}, "files": [{"sha": "e61cc9885c44d0b79621aa2e50c083b0e81380e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -1,3 +1,18 @@\n+2020-01-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* target.def (compatible_vector_types_p): New target hook.\n+\t* hooks.h (hook_bool_const_tree_const_tree_true): Declare.\n+\t* hooks.c (hook_bool_const_tree_const_tree_true): New function.\n+\t* doc/tm.texi.in (TARGET_COMPATIBLE_VECTOR_TYPES_P): New hook.\n+\t* doc/tm.texi: Regenerate.\n+\t* gimple-expr.c: Include target.h.\n+\t(useless_type_conversion_p): Use targetm.compatible_vector_types_p.\n+\t* config/aarch64/aarch64.c (aarch64_compatible_vector_types_p): New\n+\tfunction.\n+\t(TARGET_COMPATIBLE_VECTOR_TYPES_P): Define.\n+\t* config/aarch64/aarch64-sve-builtins.cc (gimple_folder::convert_pred):\n+\tUse the original predicate if it already has a suitable type.\n+\n 2020-01-09  Martin Jambor  <mjambor@suse.cz>\n \n \t* cgraph.h (cgraph_edge): Make remove, set_call_stmt, make_direct,"}, {"sha": "d62c50f9a7544df84f7301d3efc94403c937557d", "filename": "gcc/config/aarch64/aarch64-sve-builtins.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-sve-builtins.cc?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -2265,9 +2265,13 @@ tree\n gimple_folder::convert_pred (gimple_seq &stmts, tree vectype,\n \t\t\t     unsigned int argno)\n {\n-  tree predtype = truth_type_for (vectype);\n   tree pred = gimple_call_arg (call, argno);\n-  return gimple_build (&stmts, VIEW_CONVERT_EXPR, predtype, pred);\n+  if (known_eq (TYPE_VECTOR_SUBPARTS (TREE_TYPE (pred)),\n+\t\tTYPE_VECTOR_SUBPARTS (vectype)))\n+    return pred;\n+\n+  return gimple_build (&stmts, VIEW_CONVERT_EXPR,\n+\t\t       truth_type_for (vectype), pred);\n }\n \n /* Return a pointer to the address in a contiguous load or store,"}, {"sha": "afe41832857a366d761323ae5d1b25e107387ab9", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -2098,6 +2098,15 @@ aarch64_fntype_abi (const_tree fntype)\n   return default_function_abi;\n }\n \n+/* Implement TARGET_COMPATIBLE_VECTOR_TYPES_P.  */\n+\n+static bool\n+aarch64_compatible_vector_types_p (const_tree type1, const_tree type2)\n+{\n+  return (aarch64_sve::builtin_type_p (type1)\n+\t  == aarch64_sve::builtin_type_p (type2));\n+}\n+\n /* Return true if we should emit CFI for register REGNO.  */\n \n static bool\n@@ -22099,6 +22108,9 @@ aarch64_libgcc_floating_mode_supported_p\n #undef TARGET_VECTOR_MODE_SUPPORTED_P\n #define TARGET_VECTOR_MODE_SUPPORTED_P aarch64_vector_mode_supported_p\n \n+#undef TARGET_COMPATIBLE_VECTOR_TYPES_P\n+#define TARGET_COMPATIBLE_VECTOR_TYPES_P aarch64_compatible_vector_types_p\n+\n #undef TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT\n #define TARGET_VECTORIZE_SUPPORT_VECTOR_MISALIGNMENT \\\n   aarch64_builtin_support_vector_misalignment"}, {"sha": "4aec468814cafa81d9e9f029a27bbb46c1e4ff77", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -4324,6 +4324,27 @@ insns involving vector mode @var{mode}.  At the very least, it\n must have move patterns for this mode.\n @end deftypefn\n \n+@deftypefn {Target Hook} bool TARGET_COMPATIBLE_VECTOR_TYPES_P (const_tree @var{type1}, const_tree @var{type2})\n+Return true if there is no target-specific reason for treating\n+vector types @var{type1} and @var{type2} as distinct types.  The caller\n+has already checked for target-independent reasons, meaning that the\n+types are known to have the same mode, to have the same number of elements,\n+and to have what the caller considers to be compatible element types.\n+\n+The main reason for defining this hook is to reject pairs of types\n+that are handled differently by the target's calling convention.\n+For example, when a new @var{N}-bit vector architecture is added\n+to a target, the target may want to handle normal @var{N}-bit\n+@code{VECTOR_TYPE} arguments and return values in the same way as\n+before, to maintain backwards compatibility.  However, it may also\n+provide new, architecture-specific @code{VECTOR_TYPE}s that are passed\n+and returned in a more efficient way.  It is then important to maintain\n+a distinction between the ``normal'' @code{VECTOR_TYPE}s and the new\n+architecture-specific ones.\n+\n+The default implementation returns true, which is correct for most targets.\n+@end deftypefn\n+\n @deftypefn {Target Hook} opt_machine_mode TARGET_ARRAY_MODE (machine_mode @var{mode}, unsigned HOST_WIDE_INT @var{nelems})\n Return the mode that GCC should use for an array that has\n @var{nelems} elements, with each element having mode @var{mode}."}, {"sha": "1a16150bfc51c6f570a042add9e2ee420ae7507a", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -3365,6 +3365,8 @@ stack.\n \n @hook TARGET_VECTOR_MODE_SUPPORTED_P\n \n+@hook TARGET_COMPATIBLE_VECTOR_TYPES_P\n+\n @hook TARGET_ARRAY_MODE\n \n @hook TARGET_ARRAY_MODE_SUPPORTED_P"}, {"sha": "44a0b8790f54638846c436f96288c4e7b8f1602f", "filename": "gcc/gimple-expr.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fgimple-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fgimple-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-expr.c?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n+#include \"target.h\"\n \n /* ----- Type related -----  */\n \n@@ -147,10 +148,12 @@ useless_type_conversion_p (tree outer_type, tree inner_type)\n \n   /* Recurse for vector types with the same number of subparts.  */\n   else if (TREE_CODE (inner_type) == VECTOR_TYPE\n-\t   && TREE_CODE (outer_type) == VECTOR_TYPE\n-\t   && TYPE_PRECISION (inner_type) == TYPE_PRECISION (outer_type))\n-    return useless_type_conversion_p (TREE_TYPE (outer_type),\n-\t\t\t\t      TREE_TYPE (inner_type));\n+\t   && TREE_CODE (outer_type) == VECTOR_TYPE)\n+    return (known_eq (TYPE_VECTOR_SUBPARTS (inner_type),\n+\t\t      TYPE_VECTOR_SUBPARTS (outer_type))\n+\t    && useless_type_conversion_p (TREE_TYPE (outer_type),\n+\t\t\t\t\t  TREE_TYPE (inner_type))\n+\t    && targetm.compatible_vector_types_p (inner_type, outer_type));\n \n   else if (TREE_CODE (inner_type) == ARRAY_TYPE\n \t   && TREE_CODE (outer_type) == ARRAY_TYPE)"}, {"sha": "9c493790416b9dbaae98818042f3141f1bdb8cfb", "filename": "gcc/hooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fhooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fhooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.c?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -312,6 +312,12 @@ hook_bool_const_tree_false (const_tree)\n   return false;\n }\n \n+bool\n+hook_bool_const_tree_const_tree_true (const_tree, const_tree)\n+{\n+  return true;\n+}\n+\n bool\n hook_bool_tree_true (tree)\n {"}, {"sha": "a20d5530c9252007c89c5f6984ae636b9e8ba5bb", "filename": "gcc/hooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fhooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Fhooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhooks.h?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -45,6 +45,7 @@ extern bool hook_bool_uint_uint_mode_false (unsigned int, unsigned int,\n extern bool hook_bool_uint_mode_true (unsigned int, machine_mode);\n extern bool hook_bool_tree_false (tree);\n extern bool hook_bool_const_tree_false (const_tree);\n+extern bool hook_bool_const_tree_const_tree_true (const_tree, const_tree);\n extern bool hook_bool_tree_true (tree);\n extern bool hook_bool_const_tree_true (const_tree);\n extern bool hook_bool_gsiptr_false (gimple_stmt_iterator *);"}, {"sha": "81cea0d8bd1e64c94e2f63ad2e1f57a074c93027", "filename": "gcc/target.def", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -3410,6 +3410,29 @@ must have move patterns for this mode.\",\n  bool, (machine_mode mode),\n  hook_bool_mode_false)\n \n+DEFHOOK\n+(compatible_vector_types_p,\n+ \"Return true if there is no target-specific reason for treating\\n\\\n+vector types @var{type1} and @var{type2} as distinct types.  The caller\\n\\\n+has already checked for target-independent reasons, meaning that the\\n\\\n+types are known to have the same mode, to have the same number of elements,\\n\\\n+and to have what the caller considers to be compatible element types.\\n\\\n+\\n\\\n+The main reason for defining this hook is to reject pairs of types\\n\\\n+that are handled differently by the target's calling convention.\\n\\\n+For example, when a new @var{N}-bit vector architecture is added\\n\\\n+to a target, the target may want to handle normal @var{N}-bit\\n\\\n+@code{VECTOR_TYPE} arguments and return values in the same way as\\n\\\n+before, to maintain backwards compatibility.  However, it may also\\n\\\n+provide new, architecture-specific @code{VECTOR_TYPE}s that are passed\\n\\\n+and returned in a more efficient way.  It is then important to maintain\\n\\\n+a distinction between the ``normal'' @code{VECTOR_TYPE}s and the new\\n\\\n+architecture-specific ones.\\n\\\n+\\n\\\n+The default implementation returns true, which is correct for most targets.\",\n+ bool, (const_tree type1, const_tree type2),\n+ hook_bool_const_tree_const_tree_true)\n+\n DEFHOOK\n (vector_alignment,\n  \"This hook can be used to define the alignment for a vector of type\\n\\"}, {"sha": "8bf435d583cffa2e907274c6d6222a9e444719da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -1,3 +1,8 @@\n+2020-01-09  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.target/aarch64/sve/pcs/gnu_vectors_1.c: New test.\n+\t* gcc.target/aarch64/sve/pcs/gnu_vectors_2.c: Likewise.\n+\n 2020-01-09  Tobias Burnus  <tobias@codesourcery.com>\n \n \tPR fortran/84135"}, {"sha": "6bf9e77c97d228ab8fd6d60a7d21fef1cb1fbdbb", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/gnu_vectors_1.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_1.c?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-options \"-O -msve-vector-bits=256 -fomit-frame-pointer\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef float16_t float16x16_t __attribute__((vector_size (32)));\n+typedef float32_t float32x8_t __attribute__((vector_size (32)));\n+typedef float64_t float64x4_t __attribute__((vector_size (32)));\n+typedef int8_t int8x32_t __attribute__((vector_size (32)));\n+typedef int16_t int16x16_t __attribute__((vector_size (32)));\n+typedef int32_t int32x8_t __attribute__((vector_size (32)));\n+typedef int64_t int64x4_t __attribute__((vector_size (32)));\n+typedef uint8_t uint8x32_t __attribute__((vector_size (32)));\n+typedef uint16_t uint16x16_t __attribute__((vector_size (32)));\n+typedef uint32_t uint32x8_t __attribute__((vector_size (32)));\n+typedef uint64_t uint64x4_t __attribute__((vector_size (32)));\n+\n+void float16_callee (float16x16_t);\n+void float32_callee (float32x8_t);\n+void float64_callee (float64x4_t);\n+void int8_callee (int8x32_t);\n+void int16_callee (int16x16_t);\n+void int32_callee (int32x8_t);\n+void int64_callee (int64x4_t);\n+void uint8_callee (uint8x32_t);\n+void uint16_callee (uint16x16_t);\n+void uint32_callee (uint32x8_t);\n+void uint64_callee (uint64x4_t);\n+\n+void\n+float16_caller (void)\n+{\n+  float16_callee (svdup_f16 (1.0));\n+}\n+\n+void\n+float32_caller (void)\n+{\n+  float32_callee (svdup_f32 (2.0));\n+}\n+\n+void\n+float64_caller (void)\n+{\n+  float64_callee (svdup_f64 (3.0));\n+}\n+\n+void\n+int8_caller (void)\n+{\n+  int8_callee (svindex_s8 (0, 1));\n+}\n+\n+void\n+int16_caller (void)\n+{\n+  int16_callee (svindex_s16 (0, 2));\n+}\n+\n+void\n+int32_caller (void)\n+{\n+  int32_callee (svindex_s32 (0, 3));\n+}\n+\n+void\n+int64_caller (void)\n+{\n+  int64_callee (svindex_s64 (0, 4));\n+}\n+\n+void\n+uint8_caller (void)\n+{\n+  uint8_callee (svindex_u8 (1, 1));\n+}\n+\n+void\n+uint16_caller (void)\n+{\n+  uint16_callee (svindex_u16 (1, 2));\n+}\n+\n+void\n+uint32_caller (void)\n+{\n+  uint32_callee (svindex_u32 (1, 3));\n+}\n+\n+void\n+uint64_caller (void)\n+{\n+  uint64_callee (svindex_u64 (1, 4));\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7], \\[x0\\]} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7], \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7], \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7], \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tadd\\tx0, sp, #?16\\n} 11 } } */"}, {"sha": "dc2d00076e32b3a2f0a51bc1ba72d1a8809e018f", "filename": "gcc/testsuite/gcc.target/aarch64/sve/pcs/gnu_vectors_2.c", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/482b2b43e5101921ad94e51e052a18b353f8a3f5/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fpcs%2Fgnu_vectors_2.c?ref=482b2b43e5101921ad94e51e052a18b353f8a3f5", "patch": "@@ -0,0 +1,99 @@\n+/* { dg-options \"-O -msve-vector-bits=256 -fomit-frame-pointer\" } */\n+\n+#include <arm_sve.h>\n+\n+typedef float16_t float16x16_t __attribute__((vector_size (32)));\n+typedef float32_t float32x8_t __attribute__((vector_size (32)));\n+typedef float64_t float64x4_t __attribute__((vector_size (32)));\n+typedef int8_t int8x32_t __attribute__((vector_size (32)));\n+typedef int16_t int16x16_t __attribute__((vector_size (32)));\n+typedef int32_t int32x8_t __attribute__((vector_size (32)));\n+typedef int64_t int64x4_t __attribute__((vector_size (32)));\n+typedef uint8_t uint8x32_t __attribute__((vector_size (32)));\n+typedef uint16_t uint16x16_t __attribute__((vector_size (32)));\n+typedef uint32_t uint32x8_t __attribute__((vector_size (32)));\n+typedef uint64_t uint64x4_t __attribute__((vector_size (32)));\n+\n+void float16_callee (svfloat16_t);\n+void float32_callee (svfloat32_t);\n+void float64_callee (svfloat64_t);\n+void int8_callee (svint8_t);\n+void int16_callee (svint16_t);\n+void int32_callee (svint32_t);\n+void int64_callee (svint64_t);\n+void uint8_callee (svuint8_t);\n+void uint16_callee (svuint16_t);\n+void uint32_callee (svuint32_t);\n+void uint64_callee (svuint64_t);\n+\n+void\n+float16_caller (float16x16_t arg)\n+{\n+  float16_callee (arg);\n+}\n+\n+void\n+float32_caller (float32x8_t arg)\n+{\n+  float32_callee (arg);\n+}\n+\n+void\n+float64_caller (float64x4_t arg)\n+{\n+  float64_callee (arg);\n+}\n+\n+void\n+int8_caller (int8x32_t arg)\n+{\n+  int8_callee (arg);\n+}\n+\n+void\n+int16_caller (int16x16_t arg)\n+{\n+  int16_callee (arg);\n+}\n+\n+void\n+int32_caller (int32x8_t arg)\n+{\n+  int32_callee (arg);\n+}\n+\n+void\n+int64_caller (int64x4_t arg)\n+{\n+  int64_callee (arg);\n+}\n+\n+void\n+uint8_caller (uint8x32_t arg)\n+{\n+  uint8_callee (arg);\n+}\n+\n+void\n+uint16_caller (uint16x16_t arg)\n+{\n+  uint16_callee (arg);\n+}\n+\n+void\n+uint32_caller (uint32x8_t arg)\n+{\n+  uint32_callee (arg);\n+}\n+\n+void\n+uint64_caller (uint64x4_t arg)\n+{\n+  uint64_callee (arg);\n+}\n+\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz0\\.b, p[0-7]/z, \\[x0\\]} 2 } } */\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz0\\.h, p[0-7]/z, \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz0\\.s, p[0-7]/z, \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz0\\.d, p[0-7]/z, \\[x0\\]} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tst1[bhwd]\\t} } } */"}]}