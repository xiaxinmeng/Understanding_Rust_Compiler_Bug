{"sha": "062bf895938ee3130690ac20a8b571f6d61e7dc1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDYyYmY4OTU5MzhlZTMxMzA2OTBhYzIwYThiNTcxZjZkNjFlN2RjMQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-04-24T22:20:31Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-04-24T22:20:31Z"}, "message": "PR libstdc++/15002 (continued)\n\n2004-04-24  Paolo Carlini  <pcarlini@suse.de>\n\t    Petur Runolfsson  <peturr02@ru.is>\n\n\tPR libstdc++/15002 (continued)\n\t* include/bits/istream.tcc (basic_istream<>::getline(char_type*,\n\tstreamsize, char_type)): Use traits::find/copy in a loop to speed\n\tup greatly the function in the common case (I/O buffer size >> 1).\n\n2004-04-24  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/27_io/basic_istream/getline/char/4.cc: New.\n\n\t* include/bits/istream.tcc (getline(basic_istream<>&,\n\tbasic_string<>&, _CharT)): Change to use sgetc()/snextc() instead\n\tof sbumpc(), consistently with the other functions, thus also\n\tdealing correctly with the case of exceeded string::max_size().\n\nCo-Authored-By: Petur Runolfsson <peturr02@ru.is>\n\nFrom-SVN: r81146", "tree": {"sha": "b23fae76c72b1ce16a8979ccd6b959c438a9649c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b23fae76c72b1ce16a8979ccd6b959c438a9649c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/062bf895938ee3130690ac20a8b571f6d61e7dc1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062bf895938ee3130690ac20a8b571f6d61e7dc1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/062bf895938ee3130690ac20a8b571f6d61e7dc1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/062bf895938ee3130690ac20a8b571f6d61e7dc1/comments", "author": null, "committer": null, "parents": [{"sha": "6f0b1fa57ee7bea87c2808546b342452825bad06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f0b1fa57ee7bea87c2808546b342452825bad06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f0b1fa57ee7bea87c2808546b342452825bad06"}], "stats": {"total": 193, "additions": 170, "deletions": 23}, "files": [{"sha": "0f1838ee43bfc63452eb78cf59a09608834dc515", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=062bf895938ee3130690ac20a8b571f6d61e7dc1", "patch": "@@ -1,3 +1,20 @@\n+2004-04-24  Paolo Carlini  <pcarlini@suse.de>\n+\t    Petur Runolfsson  <peturr02@ru.is>\n+\n+\tPR libstdc++/15002 (continued)\n+\t* include/bits/istream.tcc (basic_istream<>::getline(char_type*,\n+\tstreamsize, char_type)): Use traits::find/copy in a loop to speed\n+\tup greatly the function in the common case (I/O buffer size >> 1).\n+\n+2004-04-24  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/27_io/basic_istream/getline/char/4.cc: New.\t\n+\n+\t* include/bits/istream.tcc (getline(basic_istream<>&,\n+\tbasic_string<>&, _CharT)): Change to use sgetc()/snextc() instead\n+\tof sbumpc(), consistently with the other functions, thus also\n+\tdealing correctly with the case of exceeded string::max_size().\n+\n 2004-04-24  Matthias Klose  <doko@debian.org>\n \n \tJonathan Wakely  <cow@compsoc.man.ac.uk>"}, {"sha": "a7cf61e4353b39b4de704412caf69a443817329f", "filename": "libstdc++-v3/include/bits/istream.tcc", "status": "modified", "additions": 47, "deletions": 23, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fistream.tcc?ref=062bf895938ee3130690ac20a8b571f6d61e7dc1", "patch": "@@ -1,6 +1,6 @@\n // istream classes -*- C++ -*-\n \n-// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003\n+// Copyright (C) 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -592,27 +592,45 @@ namespace std\n \t      const int_type __eof = traits_type::eof();\n \t      __streambuf_type* __sb = this->rdbuf();\n \t      int_type __c = __sb->sgetc();\n-\n-\t      while (_M_gcount + 1 < __n\n+\t      --__n;\n+\t      \n+\t      while (_M_gcount < __n\n \t\t     && !traits_type::eq_int_type(__c, __eof)\n \t\t     && !traits_type::eq_int_type(__c, __idelim))\n \t\t{\n-\t\t  *__s++ = traits_type::to_char_type(__c);\n-\t\t  __c = __sb->snextc();\n-\t\t  ++_M_gcount;\n+\t\t  streamsize __size = std::min(streamsize(__sb->egptr()\n+\t\t\t\t\t\t\t  - __sb->gptr()),\n+\t\t\t\t\t       __n - _M_gcount);\n+\t\t  if (__size > 1)\n+\t\t    {\n+\t\t      const char_type* __p = traits_type::find(__sb->gptr(),\n+\t\t\t\t\t\t\t       __size,\n+\t\t\t\t\t\t\t       __delim);\n+\t\t      if (__p)\n+\t\t\t__size = __p - __sb->gptr();\n+\t\t      traits_type::copy(__s, __sb->gptr(), __size);\n+\t\t      __s += __size;\n+\t\t      __sb->gbump(__size);\n+\t\t      _M_gcount += __size;\n+\t\t      __c = __sb->sgetc();\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      *__s++ = traits_type::to_char_type(__c);\n+\t\t      __c = __sb->snextc();\n+\t\t      ++_M_gcount;\n+\t\t    }\n \t\t}\n+\n \t      if (traits_type::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n-\t      else\n+\t      else if (traits_type::eq_int_type(__c, __idelim))\n \t\t{\n-\t\t  if (traits_type::eq_int_type(__c, __idelim))\n-\t\t    {\n-\t\t      __sb->sbumpc();\n-\t\t      ++_M_gcount;\n-\t\t    }\n-\t\t  else\n-\t\t    __err |= ios_base::failbit;\n+\t\t  __sb->sbumpc();\n+\t\t  ++_M_gcount;\n \t\t}\n+\t      else\n+\t\t__err |= ios_base::failbit;\n \t    }\n \t  catch(...)\n \t    { this->_M_setstate(ios_base::badbit); }\n@@ -1085,22 +1103,28 @@ namespace std\n \t  try\n \t    {\n \t      __str.erase();\n-\t      __int_type __idelim = _Traits::to_int_type(__delim);\n-\t      __streambuf_type* __sb = __in.rdbuf();\n-\t      __int_type __c = __sb->sbumpc();\n+\t      const __int_type __idelim = _Traits::to_int_type(__delim);\n \t      const __int_type __eof = _Traits::eof();\n-\t      __testdelim = _Traits::eq_int_type(__c, __idelim);\n+\t      __streambuf_type* __sb = __in.rdbuf();\n+\t      __int_type __c = __sb->sgetc();\n \n-\t      while (!_Traits::eq_int_type(__c, __eof) && !__testdelim\n-\t\t     && __extracted < __n)\n+\t      while (__extracted < __n\n+\t\t     && !_Traits::eq_int_type(__c, __eof)\n+\t\t     && !_Traits::eq_int_type(__c, __idelim))\n \t\t{\n \t\t  __str += _Traits::to_char_type(__c);\n+\t\t  __c = __sb->snextc();\n \t\t  ++__extracted;\n-\t\t  __c = __sb->sbumpc();\n-\t\t  __testdelim = _Traits::eq_int_type(__c, __idelim);\n \t\t}\n \t      if (_Traits::eq_int_type(__c, __eof))\n \t\t__err |= ios_base::eofbit;\n+\t      else if (_Traits::eq_int_type(__c, __idelim))\n+\t\t{\n+\t\t  __sb->sbumpc();\n+\t\t  ++__extracted;\n+\t\t}\n+\t      else\n+\t\t__err |= ios_base::failbit;\n \t    }\n \t  catch(...)\n \t    {\n@@ -1110,7 +1134,7 @@ namespace std\n \t      __in._M_setstate(ios_base::badbit);\n \t    }\n \t}\n-      if ((!__extracted && !__testdelim) || __extracted == __n)\n+      if (!__extracted)\n \t__err |= ios_base::failbit;\n       if (__err)\n \t__in.setstate(__err);"}, {"sha": "0c531873eb93fe52d9e7005d9bf3035b69bb8ddd", "filename": "libstdc++-v3/testsuite/27_io/basic_istream/getline/char/4.cc", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fgetline%2Fchar%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/062bf895938ee3130690ac20a8b571f6d61e7dc1/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fgetline%2Fchar%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F27_io%2Fbasic_istream%2Fgetline%2Fchar%2F4.cc?ref=062bf895938ee3130690ac20a8b571f6d61e7dc1", "patch": "@@ -0,0 +1,106 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <cstring> // for strlen\n+#include <istream>\n+#include <testsuite_hooks.h>\n+\n+class Inbuf : public std::streambuf\n+{\n+  static const char buf[];\n+  const char* current;\n+  int size;\n+\n+public:\n+  Inbuf()\n+  {\n+    current = buf;\n+    size = std::strlen(buf);\n+  }\n+  \n+  int_type underflow()\n+  {\n+    if (current < buf + size)\n+      return traits_type::to_int_type(*current);\n+    return traits_type::eof();\n+  }\n+  \n+  int_type uflow()\n+  {\n+    if (current < buf + size)\n+      return traits_type::to_int_type(*current++);\n+    return traits_type::eof();\n+  }\n+};\n+\n+const char Inbuf::buf[] = \"1234567890abcdefghij\";\n+\n+void test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  typedef char_traits<char>   traits_type;\n+\n+  Inbuf inbuf1;\n+  istream is(&inbuf1);\n+\n+  char buffer[10];\n+  traits_type::assign(buffer, sizeof(buffer), 'X');\n+\n+  is.getline(buffer, sizeof(buffer), '0');\n+  VERIFY( is.rdstate() == ios_base::goodbit );\n+  VERIFY( !traits_type::compare(buffer, \"123456789\\0\", sizeof(buffer)) );\n+  VERIFY( is.gcount() == 10 );\n+\n+  is.clear();\n+  traits_type::assign(buffer, sizeof(buffer), 'X');\n+  is.getline(buffer, sizeof(buffer));\n+  VERIFY( is.rdstate() == ios_base::failbit );\n+  VERIFY( !traits_type::compare(buffer, \"abcdefghi\\0\", sizeof(buffer)) );\n+  VERIFY( is.gcount() == 9 );\n+\n+  is.clear();\n+  traits_type::assign(buffer, sizeof(buffer), 'X');\n+  is.getline(buffer, sizeof(buffer));\n+  VERIFY( is.rdstate() == ios_base::eofbit );\n+  VERIFY( !traits_type::compare(buffer, \"j\\0XXXXXXXX\", sizeof(buffer)) );\n+  VERIFY( is.gcount() == 1 );\n+\n+  is.clear();\n+  traits_type::assign(buffer, sizeof(buffer), 'X');\n+  is.getline(buffer, sizeof(buffer));\n+  VERIFY( is.rdstate() == (ios_base::eofbit | ios_base::failbit) );\n+  VERIFY( !traits_type::compare(buffer, \"\\0XXXXXXXXX\", sizeof(buffer)) );\n+  VERIFY( is.gcount() == 0 );\n+}\n+\n+int main() \n+{\n+  test01();\n+  return 0;\n+}"}]}