{"sha": "f4c200fcfec75b3841640263609d2133ead0c518", "node_id": "C_kwDOANBUbNoAKGY0YzIwMGZjZmVjNzViMzg0MTY0MDI2MzYwOWQyMTMzZWFkMGM1MTg", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-02T17:53:22Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-11-05T11:33:04Z"}, "message": "Support computing the addresses of the object safe items in dyn objects\n\nThis changes the coercion code for the dyn vtable to compute addresses\nfor more complex generic methods such as:\n\n```\nimpl<'a, T> FnLike<&'a T, &'a T> for Identity {\n    fn call(&self, arg: &'a T) -> &'a T {\n        arg\n    }\n}\n```\n\nIn the above example the fntype for the bound FnLike is generic and\nbound to the ParamType 'T' from the generic impl-block. But the bound\nwhich has a signiture which is compatible for the impl block looks like:\n\n```\ntrait FnLike<A, R> {\n    fn call(&self, arg: A) -> R;\n}\n```\n\nThis means when we have the trait-object bound:\n\n```\ntype FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b\n```\n\nWe must be able to figure out that the signiture of the impl block item\n\n```\nfn call(&self, arg: &'a T) -> &'a T;\n```\n\nT must be substituted with &isize from the arguments used in the bound.\n\nFixes #786", "tree": {"sha": "df69a9a457f78df72414ad73a10de5714bdc5086", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/df69a9a457f78df72414ad73a10de5714bdc5086"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f4c200fcfec75b3841640263609d2133ead0c518", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c200fcfec75b3841640263609d2133ead0c518", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4c200fcfec75b3841640263609d2133ead0c518", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4c200fcfec75b3841640263609d2133ead0c518/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "92a24fc3aecc11fc80387479829ea97293c44076", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a24fc3aecc11fc80387479829ea97293c44076", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a24fc3aecc11fc80387479829ea97293c44076"}], "stats": {"total": 377, "additions": 325, "deletions": 52}, "files": [{"sha": "3184e27654aa9409f583b78b93c2e761322819b3", "filename": "gcc/rust/backend/rust-compile-base.h", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Fbackend%2Frust-compile-base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.h?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -209,9 +209,12 @@ class HIRCompileBase : public HIR::HIRVisitor\n \t\t\t\t     const TyTy::DynamicObjectType *ty,\n \t\t\t\t     Location locus);\n \n-  Bexpression *\n-  compute_address_for_trait_item (const Resolver::TraitItemReference *ref,\n-\t\t\t\t  const TyTy::BaseType *receiver);\n+  Bexpression *compute_address_for_trait_item (\n+    const Resolver::TraitItemReference *ref,\n+    const TyTy::TypeBoundPredicate *predicate,\n+    std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+      &receiver_bounds,\n+    const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus);\n };\n \n } // namespace Compile"}, {"sha": "e9aca2c34f13a1fc04c347a5f7263b1f078d9911", "filename": "gcc/rust/backend/rust-compile.cc", "status": "modified", "additions": 153, "deletions": 40, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Fbackend%2Frust-compile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Fbackend%2Frust-compile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile.cc?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -22,6 +22,7 @@\n #include \"rust-compile-struct-field-expr.h\"\n #include \"rust-hir-trait-resolve.h\"\n #include \"rust-hir-path-probe.h\"\n+#include \"rust-hir-type-bounds.h\"\n #include \"rust-hir-dot-operator.h\"\n \n namespace Rust {\n@@ -243,8 +244,9 @@ CompileExpr::visit (HIR::MethodCallExpr &expr)\n \n       size_t offs = 0;\n       const Resolver::TraitItemReference *ref = nullptr;\n-      for (auto &item : dyn->get_object_items ())\n+      for (auto &bound : dyn->get_object_items ())\n \t{\n+\t  const Resolver::TraitItemReference *item = bound.first;\n \t  auto t = item->get_tyty ();\n \t  rust_assert (t->get_kind () == TyTy::TypeKind::FNDEF);\n \t  auto ft = static_cast<TyTy::FnType *> (t);\n@@ -790,18 +792,25 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n   // __trait_object_ptr\n   // [list of function ptrs]\n \n+  auto root = actual->get_root ();\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    probed_bounds_for_receiver = Resolver::TypeBoundsProbe::Probe (root);\n+\n   std::vector<Bexpression *> vals;\n   vals.push_back (compiled_ref);\n-  for (auto &item : ty->get_object_items ())\n+  for (auto &bound : ty->get_object_items ())\n     {\n-      // compute the address of each method item\n-      auto address = compute_address_for_trait_item (item, actual->get_root ());\n+      const Resolver::TraitItemReference *item = bound.first;\n+      const TyTy::TypeBoundPredicate *predicate = bound.second;\n+\n+      auto address = compute_address_for_trait_item (item, predicate,\n+\t\t\t\t\t\t     probed_bounds_for_receiver,\n+\t\t\t\t\t\t     actual, root, locus);\n       vals.push_back (address);\n     }\n \n   Bexpression *constructed_trait_object\n     = ctx->get_backend ()->constructor_expression (dynamic_object, vals, -1,\n-\n \t\t\t\t\t\t   locus);\n \n   fncontext fnctx = ctx->peek_fn ();\n@@ -851,44 +860,148 @@ HIRCompileBase::coerce_to_dyn_object (Bexpression *compiled_ref,\n \n Bexpression *\n HIRCompileBase::compute_address_for_trait_item (\n-  const Resolver::TraitItemReference *trait_item_ref,\n-  const TyTy::BaseType *receiver)\n+  const Resolver::TraitItemReference *ref,\n+  const TyTy::TypeBoundPredicate *predicate,\n+  std::vector<std::pair<Resolver::TraitReference *, HIR::ImplBlock *>>\n+    &receiver_bounds,\n+  const TyTy::BaseType *receiver, const TyTy::BaseType *root, Location locus)\n {\n-  TyTy::BaseType *item_type = trait_item_ref->get_tyty ();\n-  rust_assert (item_type->get_kind () == TyTy::TypeKind::FNDEF);\n-  TyTy::FnType *fntype = static_cast<TyTy::FnType *> (item_type);\n-\n-  auto root = receiver->get_root ();\n-  HIR::PathIdentSegment segment_name (trait_item_ref->get_identifier ());\n-  std::vector<Resolver::PathProbeCandidate> candidates\n-    = Resolver::PathProbeType::Probe (root, segment_name, true, false, true);\n-\n-  // FIXME for default trait item resolution\n+  // There are two cases here one where its an item which has an implementation\n+  // within a trait-impl-block. Then there is the case where there is a default\n+  // implementation for this within the trait.\n   //\n-  // if (candidates.size () == 0)\n-  //   {\n-  //     rust_assert (trait_item_ref->is_optional ()); // has definition\n+  // The awkward part here is that this might be a generic trait and we need to\n+  // figure out the correct monomorphized type for this so we can resolve the\n+  // address of the function , this is stored as part of the\n+  // type-bound-predicate\n   //\n-  //     CompileTraitItem::Compile (self_type,\n-  //       \t\t\t trait_item_ref->get_hir_trait_item (), ctx,\n-  //       \t\t\t fntype);\n-  //     if (!ctx->lookup_function_decl (fntype->get_ty_ref (), &fn))\n-  //       {\n-  //         return ctx->get_backend ()->error_expression ();\n-  //       }\n-  //   }\n-\n-  rust_assert (!candidates.empty ());\n-  rust_assert (candidates.size () == 1);\n-\n-  Resolver::PathProbeCandidate *candidate = &candidates.at (0);\n-  rust_assert (candidate->is_impl_candidate ());\n-\n-  HIR::ImplItem *impl_item = candidate->item.impl.impl_item;\n-\n-  return CompileInherentImplItem::Compile (receiver->get_root (), impl_item,\n-\t\t\t\t\t   ctx, true, fntype, true,\n-\t\t\t\t\t   Location () /* FIXME */);\n+  // Algo:\n+  // check if there is an impl-item for this trait-item-ref first\n+  // else assert that the trait-item-ref has an implementation\n+\n+  TyTy::TypeBoundPredicateItem predicate_item\n+    = predicate->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!predicate_item.is_error ());\n+\n+  // this is the expected end type\n+  TyTy::BaseType *trait_item_type = predicate_item.get_tyty_for_receiver (root);\n+  rust_assert (trait_item_type->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *trait_item_fntype\n+    = static_cast<TyTy::FnType *> (trait_item_type);\n+\n+  // find impl-block for this trait-item-ref\n+  HIR::ImplBlock *associated_impl_block = nullptr;\n+  const Resolver::TraitReference *predicate_trait_ref = predicate->get ();\n+  for (auto &item : receiver_bounds)\n+    {\n+      Resolver::TraitReference *trait_ref = item.first;\n+      HIR::ImplBlock *impl_block = item.second;\n+      if (predicate_trait_ref->is_equal (*trait_ref))\n+\t{\n+\t  associated_impl_block = impl_block;\n+\t  break;\n+\t}\n+    }\n+\n+  // FIXME this probably should just return error_mark_node but this helps\n+  // debug for now since we are wrongly returning early on type-resolution\n+  // failures, until we take advantage of more error types and error_mark_node\n+  rust_assert (associated_impl_block != nullptr);\n+\n+  // lookup self for the associated impl\n+  std::unique_ptr<HIR::Type> &self_type_path\n+    = associated_impl_block->get_type ();\n+  TyTy::BaseType *self = nullptr;\n+  bool ok = ctx->get_tyctx ()->lookup_type (\n+    self_type_path->get_mappings ().get_hirid (), &self);\n+  rust_assert (ok);\n+\n+  // lookup the predicate item from the self\n+  TyTy::TypeBoundPredicate *self_bound = nullptr;\n+  for (auto &bound : self->get_specified_bounds ())\n+    {\n+      const Resolver::TraitReference *bound_ref = bound.get ();\n+      const Resolver::TraitReference *specified_ref = predicate->get ();\n+      if (bound_ref->is_equal (*specified_ref))\n+\t{\n+\t  self_bound = &bound;\n+\t  break;\n+\t}\n+    }\n+  rust_assert (self_bound != nullptr);\n+\n+  // lookup the associated item from the associated impl block\n+  TyTy::TypeBoundPredicateItem associated_self_item\n+    = self_bound->lookup_associated_item (ref->get_identifier ());\n+  rust_assert (!associated_self_item.is_error ());\n+\n+  // apply any generic arguments from this predicate\n+  TyTy::BaseType *mono1 = associated_self_item.get_tyty_for_receiver (self);\n+  TyTy::BaseType *mono2 = nullptr;\n+  if (predicate->has_generic_args ())\n+    {\n+      mono2 = associated_self_item.get_tyty_for_receiver (\n+\tself, predicate->get_generic_args ());\n+    }\n+  else\n+    {\n+      mono2 = associated_self_item.get_tyty_for_receiver (self);\n+    }\n+  rust_assert (mono1 != nullptr);\n+  rust_assert (mono1->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *assocated_item_ty1 = static_cast<TyTy::FnType *> (mono1);\n+\n+  rust_assert (mono2 != nullptr);\n+  rust_assert (mono2->get_kind () == TyTy::TypeKind::FNDEF);\n+  TyTy::FnType *assocated_item_ty2 = static_cast<TyTy::FnType *> (mono2);\n+\n+  // Lookup the impl-block for the associated impl_item if it exists\n+  HIR::Function *associated_function = nullptr;\n+  for (auto &impl_item : associated_impl_block->get_impl_items ())\n+    {\n+      bool is_function = impl_item->get_impl_item_type ()\n+\t\t\t == HIR::ImplItem::ImplItemType::FUNCTION;\n+      if (!is_function)\n+\tcontinue;\n+\n+      HIR::Function *fn = static_cast<HIR::Function *> (impl_item.get ());\n+      bool found_associated_item\n+\t= fn->get_function_name ().compare (ref->get_identifier ()) == 0;\n+      if (found_associated_item)\n+\tassociated_function = fn;\n+    }\n+\n+  // we found an impl_item for this\n+  if (associated_function != nullptr)\n+    {\n+      // lookup the associated type for this item\n+      TyTy::BaseType *lookup = nullptr;\n+      bool ok = ctx->get_tyctx ()->lookup_type (\n+\tassociated_function->get_mappings ().get_hirid (), &lookup);\n+      rust_assert (ok);\n+      rust_assert (lookup->get_kind () == TyTy::TypeKind::FNDEF);\n+      TyTy::FnType *lookup_fntype = static_cast<TyTy::FnType *> (lookup);\n+\n+      if (lookup_fntype->needs_substitution ())\n+\t{\n+\t  TyTy::SubstitutionArgumentMappings mappings\n+\t    = assocated_item_ty1->solve_missing_mappings_from_this (\n+\t      *assocated_item_ty2, *lookup_fntype);\n+\t  lookup_fntype = lookup_fntype->handle_substitions (mappings);\n+\t}\n+\n+      return CompileInherentImplItem::Compile (root, associated_function, ctx,\n+\t\t\t\t\t       true, lookup_fntype, true,\n+\t\t\t\t\t       locus);\n+    }\n+\n+  // we can only compile trait-items with a body\n+  bool trait_item_has_definition = ref->is_optional ();\n+  rust_assert (trait_item_has_definition);\n+\n+  HIR::TraitItem *trait_item = ref->get_hir_trait_item ();\n+  return CompileTraitItem::Compile (root, trait_item, ctx, trait_item_fntype,\n+\t\t\t\t    true, locus);\n }\n \n } // namespace Compile"}, {"sha": "cfb96bbd0e4fe53c3ec161e2859e8335a49c4377", "filename": "gcc/rust/typecheck/rust-tyty-bounds.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-bounds.cc?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -138,7 +138,8 @@ TypeBoundPredicate::lookup_associated_item (const std::string &search) const\n }\n \n BaseType *\n-TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n+TypeBoundPredicateItem::get_tyty_for_receiver (\n+  const TyTy::BaseType *receiver, const HIR::GenericArgs *bound_args)\n {\n   TyTy::BaseType *trait_item_tyty = get_raw_item ()->get_tyty ();\n   if (trait_item_tyty->get_kind () == TyTy::TypeKind::FNDEF)\n@@ -169,7 +170,8 @@ TypeBoundPredicateItem::get_tyty_for_receiver (const TyTy::BaseType *receiver)\n     return trait_item_tyty;\n \n   // FIXME LEAK this should really be const\n-  const HIR::GenericArgs *args = parent->get_generic_args ();\n+  const HIR::GenericArgs *args\n+    = (bound_args != nullptr) ? bound_args : parent->get_generic_args ();\n   HIR::GenericArgs *generic_args = new HIR::GenericArgs (*args);\n   TyTy::BaseType *resolved\n     = Resolver::SubstMapper::Resolve (trait_item_tyty, parent->get_locus (),"}, {"sha": "03ba9fe82a72d7f254db4a9737c7df2dfa398d58", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -585,6 +585,57 @@ SubstitutionRef::solve_mappings_from_receiver_for_self (\n \t\t\t\t       mappings.get_locus ());\n }\n \n+SubstitutionArgumentMappings\n+SubstitutionRef::solve_missing_mappings_from_this (SubstitutionRef &ref,\n+\t\t\t\t\t\t   SubstitutionRef &to)\n+{\n+  rust_assert (!ref.needs_substitution ());\n+  rust_assert (needs_substitution ());\n+  rust_assert (get_num_substitutions () == ref.get_num_substitutions ());\n+\n+  Location locus = used_arguments.get_locus ();\n+  std::vector<SubstitutionArg> resolved_mappings;\n+\n+  std::map<HirId, std::pair<ParamType *, BaseType *>> substs;\n+  for (size_t i = 0; i < get_num_substitutions (); i++)\n+    {\n+      SubstitutionParamMapping &a = substitutions.at (i);\n+      SubstitutionParamMapping &b = ref.substitutions.at (i);\n+\n+      if (a.need_substitution ())\n+\t{\n+\t  const BaseType *root = a.get_param_ty ()->resolve ()->get_root ();\n+\t  rust_assert (root->get_kind () == TyTy::TypeKind::PARAM);\n+\t  const ParamType *p = static_cast<const TyTy::ParamType *> (root);\n+\n+\t  substs[p->get_ty_ref ()] = {static_cast<ParamType *> (p->clone ()),\n+\t\t\t\t      b.get_param_ty ()->resolve ()};\n+\t}\n+    }\n+\n+  for (auto it = substs.begin (); it != substs.end (); it++)\n+    {\n+      HirId param_id = it->first;\n+      BaseType *arg = it->second.second;\n+\n+      const SubstitutionParamMapping *associate_param = nullptr;\n+      for (SubstitutionParamMapping &p : to.substitutions)\n+\t{\n+\t  if (p.get_param_ty ()->get_ty_ref () == param_id)\n+\t    {\n+\t      associate_param = &p;\n+\t      break;\n+\t    }\n+\t}\n+\n+      rust_assert (associate_param != nullptr);\n+      SubstitutionArg argument (associate_param, arg);\n+      resolved_mappings.push_back (std::move (argument));\n+    }\n+\n+  return SubstitutionArgumentMappings (resolved_mappings, locus);\n+}\n+\n void\n ADTType::accept_vis (TyVisitor &vis)\n {\n@@ -1988,7 +2039,7 @@ ParamType::as_string () const\n   bool ok = context->lookup_type (get_ty_ref (), &lookup);\n   rust_assert (ok);\n \n-  return lookup->as_string ();\n+  return get_symbol () + \"=\" + lookup->as_string ();\n }\n \n std::string\n@@ -2513,10 +2564,13 @@ DynamicObjectType::is_equal (const BaseType &other) const\n   return bounds_compatible (other, Location (), false);\n }\n \n-const std::vector<const Resolver::TraitItemReference *>\n+const std::vector<\n+  std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n DynamicObjectType::get_object_items () const\n {\n-  std::vector<const Resolver::TraitItemReference *> items;\n+  std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n+    items;\n   for (auto &bound : get_specified_bounds ())\n     {\n       const Resolver::TraitReference *trait = bound.get ();\n@@ -2525,7 +2579,7 @@ DynamicObjectType::get_object_items () const\n \t  if (item.get_trait_item_type ()\n \t\t== Resolver::TraitItemReference::TraitItemType::FN\n \t      && item.is_object_safe ())\n-\t    items.push_back (&item);\n+\t    items.push_back ({&item, &bound});\n \t}\n \n       for (auto &super_trait : trait->get_super_traits ())\n@@ -2535,7 +2589,7 @@ DynamicObjectType::get_object_items () const\n \t      if (item.get_trait_item_type ()\n \t\t    == Resolver::TraitItemReference::TraitItemType::FN\n \t\t  && item.is_object_safe ())\n-\t\titems.push_back (&item);\n+\t\titems.push_back ({&item, &bound});\n \t    }\n \t}\n     }"}, {"sha": "10bb40d404c864cd34728080428f6fdca42203b5", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -166,12 +166,16 @@ class TypeBoundPredicateItem\n     return parent == nullptr || trait_item_ref == nullptr;\n   }\n \n-  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver);\n+  BaseType *get_tyty_for_receiver (const TyTy::BaseType *receiver,\n+\t\t\t\t   const HIR::GenericArgs *bound_args\n+\t\t\t\t   = nullptr);\n \n   const Resolver::TraitItemReference *get_raw_item () const;\n \n   bool needs_implementation () const;\n \n+  const TypeBoundPredicate *get_parent () const { return parent; }\n+\n private:\n   const TypeBoundPredicate *parent;\n   const Resolver::TraitItemReference *trait_item_ref;\n@@ -992,6 +996,11 @@ class SubstitutionRef\n   SubstitutionArgumentMappings solve_mappings_from_receiver_for_self (\n     SubstitutionArgumentMappings &mappings) const;\n \n+  // TODO comment\n+  SubstitutionArgumentMappings\n+  solve_missing_mappings_from_this (SubstitutionRef &ref, SubstitutionRef &to);\n+\n+  // TODO comment\n   BaseType *infer_substitions (Location locus)\n   {\n     std::vector<SubstitutionArg> args;\n@@ -2228,7 +2237,8 @@ class DynamicObjectType : public BaseType\n   bool is_concrete () const override final { return true; }\n \n   // this returns a flat list of items including super trait bounds\n-  const std::vector<const Resolver::TraitItemReference *>\n+  const std::vector<\n+    std::pair<const Resolver::TraitItemReference *, const TypeBoundPredicate *>>\n   get_object_items () const;\n };\n "}, {"sha": "f14a966bfba1aedc29c199b63026fa670765bf16", "filename": "gcc/testsuite/rust/execute/torture/trait12.rs", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait12.rs?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-output \"3\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+trait FnLike<A, R> {\n+    fn call(&self, arg: A) -> R;\n+    // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+    // { dg-warning \"unused name .arg.\" \"\" { target *-*-* } .-2 }\n+}\n+\n+type FnObject<'b> = dyn for<'a> FnLike<&'a isize, &'a isize> + 'b;\n+\n+struct Identity;\n+\n+impl<'a, T> FnLike<&'a T, &'a T> for Identity {\n+    fn call(&self, arg: &'a T) -> &'a T {\n+        // { dg-warning \"unused name .self.\" \"\" { target *-*-* } .-1 }\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-2 }\n+        arg\n+    }\n+}\n+\n+fn call_repeatedly(f: &FnObject) {\n+    let x = 3;\n+    let y = f.call(&x);\n+\n+    unsafe {\n+        let a = \"%i\\n\\0\";\n+        let b = a as *const str;\n+        let c = b as *const i8;\n+\n+        printf(c, *y);\n+    }\n+}\n+\n+fn main() -> i32 {\n+    call_repeatedly(&Identity);\n+\n+    0\n+}"}, {"sha": "76fb09cae82565d714d57220954ba3c874b7d32f", "filename": "gcc/testsuite/rust/execute/torture/trait13.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f4c200fcfec75b3841640263609d2133ead0c518/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fexecute%2Ftorture%2Ftrait13.rs?ref=f4c200fcfec75b3841640263609d2133ead0c518", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-output \"123\\n456\\n\" } */\n+extern \"C\" {\n+    fn printf(s: *const i8, ...);\n+}\n+\n+struct Foo(i32);\n+trait Bar {\n+    fn baz(&self);\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    fn qux(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, 456);\n+        }\n+    }\n+}\n+\n+impl Bar for Foo {\n+    fn baz(&self) {\n+        // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+        unsafe {\n+            let a = \"%i\\n\\0\";\n+            let b = a as *const str;\n+            let c = b as *const i8;\n+\n+            printf(c, self.0);\n+        }\n+    }\n+}\n+\n+fn dynamic_dispatch(t: &dyn Bar) {\n+    t.baz();\n+    t.qux();\n+}\n+\n+fn main() -> i32 {\n+    let a;\n+    a = Foo(123);\n+\n+    let b: &dyn Bar;\n+    b = &a;\n+    dynamic_dispatch(b);\n+\n+    0\n+}"}]}