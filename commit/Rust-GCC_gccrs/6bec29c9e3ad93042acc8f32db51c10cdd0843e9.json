{"sha": "6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmJlYzI5YzllM2FkOTMwNDJhY2M4ZjMyZGI1MWMxMGNkZDA4NDNlOQ==", "commit": {"author": {"name": "Denis Chertykov", "email": "denisc@overta.ru", "date": "2000-08-29T19:37:45Z"}, "committer": {"name": "Denis Chertykov", "email": "denisc@gcc.gnu.org", "date": "2000-08-29T19:37:45Z"}, "message": "avr-protos.h: (avr_output_ascii) Removed.\n\n\t* config/avr/avr-protos.h: (avr_output_ascii) Removed.\n\t(avr_progmem_p): New prototype.\n\t(output_movsisf): Prototype declaration changed.\n\t(output_movqi): New prototype.\n\t(output_movhi): New prototype.\n\t(call_insn_operand): Likewise.\n\t(final_prescan_insn): Likewise.\n\t(avr_simplify_comparision_p): Likewise.\n\t(avr_normalize_condition): Likewise.\n\t(compare_eq_p): Likewise.\n\t(out_shift_with_cnt): Likewise.\n\t(const_int_pow2_p): Likewise.\n\t(output_reload_inhi): Prototype declaration changed.\n\n\t* config/avr/avr.c: (debug_hard_reg_set): Prototype declared.\n\t(ldi_reg_rtx): New. rtx for r31.\n\t(avr_init_stack): Initialize as \"__stack\".\n\t(function_prologue): Use it.\n\tReplace all TARGET_ENHANCED with AVR_ENHANCED.\n\t(avr_mcu_name): Initialize as \"avr2\".\n\t(avr_enhanced_p, avr_mega_p): New variables.\n\t(mcu_types, avr_override_options): Handle all known MCU types.\n\tAlso handle avr1 (only preprocess, assemble and link).\n\t(print_operand): Using of `%K' in output template removed.\n\t(out_movqi_r_mr): Optimized.\n\t(out_movhi_r_mr): Likewise.\n\t(output_movqi): New function.\n\t(output_movhi): Likewise.\n\t(out_movsi_r_mr): Optimized.\n\t(output_movsisf): Compute insn length for `adjust_insn_length'\n\t(out_movqi_mr_r): Optimized.\n\t(out_movhi_mr_r): Optimized.\n\t(adjust_insn_length): Use output_movsisf, output_movqi,\n\toutput_movhi for insn length adjusting.\n\t(reg_unused_after): Use dead_or_set_p.\n\t(preferred_reload_class): Now havn't any restriction.\n\t(reg_was_0): New function.\n\t(io_address_p): Likewise.\n\t(const_int_pow2_p): Likewise.\n\t(output_reload_inhi): Likewise.\n\t(output_reload_insisf): Likewise.\n\n\t* config/avr/avr.h (MULTILIB_DEFAULTS): Define.\n\t(LIB_SPEC): Use -lc for all supported devices.\n\t(LIBGCC_SPEC): Use -lgcc for all supported devices.\n\t(AVR_MEGA): Define as avr_mega_p.\n\t(AVR_ENHANCED): New, define as avr_enhanced_p.\n\t(TARGET_SWITCHES): Remove -menhanced, now handled by -mmcu=...\n\t(CPP_SPEC, LINK_SPEC): Handle all known MCU types.\n\t(CRT_BINUTILS_SPECS): Handle all known MCU types.\n\tRename gcrt1-*.o to make file names unique on 8.3 filesystems.\n\t(EXTRA_SPECS): Add CPP_AVR[1-5]_SPEC.\n\t(ASM_SPEC): Pass -mmcu=... to the assembler.\n\tChange all -DAVR_* to -D__AVR_*__.\n\t(INIT_TARGET_OPTABS), config/avr/libgcc.S:\n\tRename library functions to start with two underscores.\n\t(ASM_OUTPUT_COMMON): Outputs `.comm VAR,VAR-SIZE,1' to avoid\n\talignment.\n\t(ASM_WEAKEN_LABEL): Declared for __attribute__((weak)).\n\t(SUPPORTS_WEAK): Likewise.\n\t(LDI_REG_REGNO): New. Register r31 will be used as temporary\n\tregister for loading constants to r0-r14.\n\n\t* config/avr/avr.md: Replace all TARGET_ENHANCED with\n\tAVR_ENHANCED.\n\t(*mov_r_sp): Removed. Handled by output_movhi.\n\t(*mov_sp_r): Likewise.\n\t(*mov_sp_r_no_interrupts): Likewise\n\t(*mov_sp_r_tiny): Likewise.\n\t(*movqi): Use output_movqi.\n\t(*reload_inqi): New.\n\t(*movhi): Use output_movhi.\n\t(*reload_inhi): New.\n\t(*negsi2): Optimized.\n\t(*negsf2): Likewise.\n\tAdded peepholes (define_peephole2) for loading constants to r0-r14\n\tand for using `cpse' command.\n\n\t* config/avr/libgcc.S: Rename library functions to start with two\n\tunderscores.\n\tAdd support for enhanced core.\n\t(_moqhi3): Fix typo, now _modqi3.\n\t(__divsi_raw): Use __zero_reg__ as loop counter, smaller by 1 word.\n\t(__prologue_saves__): Remove test for stack adjust by 0.\n\t(__tablejump__): New.\n\n\t* config/avr/t-avr: Build libgcc2 with -mcall-prologues.\n\tAdd multilib support.\n\nFrom-SVN: r36047", "tree": {"sha": "2d3d60a2b499f26faa9af494d2ff3587b9b9e2b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2d3d60a2b499f26faa9af494d2ff3587b9b9e2b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/comments", "author": null, "committer": null, "parents": [{"sha": "20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20bd7bfa3b23a701c35980cf74dd7cc39e3ccc30"}], "stats": {"total": 2016, "additions": 1399, "deletions": 617}, "files": [{"sha": "855819e12f99ad9b03560187569a5b4eb38efde0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -1,3 +1,94 @@\n+Tue Aug 29 22:29:58 2000  Denis Chertykov  <denisc@overta.ru> & Marek Michalkiewicz <marekm@linux.org.pl>\n+\n+\t* config/avr/avr-protos.h: (avr_output_ascii) Removed.\n+\t(avr_progmem_p): New prototype.\n+\t(output_movsisf): Prototype declaration changed.\n+\t(output_movqi): New prototype.\n+\t(output_movhi): New prototype.\n+\t(call_insn_operand): Likewise.\n+\t(final_prescan_insn): Likewise.\t\n+\t(avr_simplify_comparision_p): Likewise.\n+\t(avr_normalize_condition): Likewise.\n+\t(compare_eq_p): Likewise.\n+\t(out_shift_with_cnt): Likewise.\n+\t(const_int_pow2_p): Likewise.\n+\t(output_reload_inhi): Prototype declaration changed.\n+\n+\t* config/avr/avr.c: (debug_hard_reg_set): Prototype declared.\n+\t(ldi_reg_rtx): New. rtx for r31.\n+\t(avr_init_stack): Initialize as \"__stack\".\n+\t(function_prologue): Use it.\n+\tReplace all TARGET_ENHANCED with AVR_ENHANCED.\n+\t(avr_mcu_name): Initialize as \"avr2\".\n+\t(avr_enhanced_p, avr_mega_p): New variables.\n+\t(mcu_types, avr_override_options): Handle all known MCU types.\n+\tAlso handle avr1 (only preprocess, assemble and link).\n+\t(print_operand): Using of `%K' in output template removed.\n+\t(out_movqi_r_mr): Optimized.\n+\t(out_movhi_r_mr): Likewise.\n+\t(output_movqi): New function.\n+\t(output_movhi): Likewise.\n+\t(out_movsi_r_mr): Optimized.\n+\t(output_movsisf): Compute insn length for `adjust_insn_length'\n+\t(out_movqi_mr_r): Optimized.\n+\t(out_movhi_mr_r): Optimized.\n+\t(adjust_insn_length): Use output_movsisf, output_movqi,\n+\toutput_movhi for insn length adjusting.\n+\t(reg_unused_after): Use dead_or_set_p.\n+\t(preferred_reload_class): Now havn't any restriction.\n+\t(reg_was_0): New function.\n+\t(io_address_p): Likewise.\n+\t(const_int_pow2_p): Likewise.\n+\t(output_reload_inhi): Likewise.\n+\t(output_reload_insisf): Likewise.\n+\n+\t* config/avr/avr.h (MULTILIB_DEFAULTS): Define.\n+\t(LIB_SPEC): Use -lc for all supported devices.\n+\t(LIBGCC_SPEC): Use -lgcc for all supported devices.\n+\t(AVR_MEGA): Define as avr_mega_p.\n+\t(AVR_ENHANCED): New, define as avr_enhanced_p.\n+\t(TARGET_SWITCHES): Remove -menhanced, now handled by -mmcu=...\n+\t(CPP_SPEC, LINK_SPEC): Handle all known MCU types.\n+\t(CRT_BINUTILS_SPECS): Handle all known MCU types.\n+\tRename gcrt1-*.o to make file names unique on 8.3 filesystems.\n+\t(EXTRA_SPECS): Add CPP_AVR[1-5]_SPEC.\n+\t(ASM_SPEC): Pass -mmcu=... to the assembler.\n+\tChange all -DAVR_* to -D__AVR_*__.\n+\t(INIT_TARGET_OPTABS), config/avr/libgcc.S:\n+\tRename library functions to start with two underscores.\n+\t(ASM_OUTPUT_COMMON): Outputs `.comm VAR,VAR-SIZE,1' to avoid\n+\talignment.\n+\t(ASM_WEAKEN_LABEL): Declared for __attribute__((weak)).\n+\t(SUPPORTS_WEAK): Likewise.\n+\t(LDI_REG_REGNO): New. Register r31 will be used as temporary\n+\tregister for loading constants to r0-r14.\n+\n+\t* config/avr/avr.md: Replace all TARGET_ENHANCED with\n+\tAVR_ENHANCED.\n+\t(*mov_r_sp): Removed. Handled by output_movhi.\n+\t(*mov_sp_r): Likewise.\n+\t(*mov_sp_r_no_interrupts): Likewise\n+\t(*mov_sp_r_tiny): Likewise.\n+\t(*movqi): Use output_movqi.\n+\t(*reload_inqi): New.\n+\t(*movhi): Use output_movhi.\n+\t(*reload_inhi): New.\n+\t(*negsi2): Optimized.\n+\t(*negsf2): Likewise.\n+\tAdded peepholes (define_peephole2) for loading constants to r0-r14\n+\tand for using `cpse' command.\n+\n+\t* config/avr/libgcc.S: Rename library functions to start with two\n+\tunderscores.\n+\tAdd support for enhanced core.\n+\t(_moqhi3): Fix typo, now _modqi3.\n+\t(__divsi_raw): Use __zero_reg__ as loop counter, smaller by 1 word.\n+\t(__prologue_saves__): Remove test for stack adjust by 0.\n+\t(__tablejump__): New.\n+\n+\t* config/avr/t-avr: Build libgcc2 with -mcall-prologues.\n+\tAdd multilib support.\n+\n Tue Aug 29 15:17:54 EDT 2000  John Wehle  (john@feith.com)\n \n \t* loop.c (prescan_loop): Don't check unknown_address_altered"}, {"sha": "8d08748105a01c7ae4304bb7f168941ebcafc511", "filename": "gcc/config/avr/avr-protos.h", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr-protos.h?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -21,9 +21,6 @@\n    Boston, MA 02111-1307, USA.  */\n \n \n-extern void   avr_output_ascii                  PARAMS ((FILE *file,\n-\t\t\t\t\t\t\tconst char *p,\n-\t\t\t\t\t\t\tint size));\n extern int    function_arg_regno_p              PARAMS ((int r));\n extern void   asm_file_start                    PARAMS ((FILE *file));\n extern void   asm_file_end                      PARAMS ((FILE *file));\n@@ -35,14 +32,17 @@ extern enum reg_class class_likely_spilled_p    PARAMS ((int c));\n extern enum reg_class avr_regno_reg_class       PARAMS ((int r));\n extern enum reg_class avr_reg_class_from_letter PARAMS ((int c));\n extern int    frame_pointer_required_p          PARAMS ((void));\n-extern void   asm_globalize_label               PARAMS ((FILE *file,\n-\t\t\t\t\t\t\tconst char *name));\n-extern void   order_regs_for_local_alloc        PARAMS ((void));\n-extern int    initial_elimination_offset        PARAMS ((int from, int to));\n-extern void   function_prologue                 PARAMS ((FILE *file, int size));\n-extern void   function_epilogue                 PARAMS ((FILE *file, int size));\n-extern void   progmem_section                   PARAMS ((void));\n-extern int    mask_one_bit_p                    PARAMS ((HOST_WIDE_INT mask));\n+extern void   asm_globalize_label         PARAMS ((FILE *file, const char *name));\n+extern void   order_regs_for_local_alloc  PARAMS ((void));\n+extern int    initial_elimination_offset  PARAMS ((int from, int to));\n+extern void   function_prologue           PARAMS ((FILE *file, int size));\n+extern void   function_epilogue           PARAMS ((FILE *file, int size));\n+extern void   progmem_section             PARAMS ((void));\n+extern int    mask_one_bit_p              PARAMS ((HOST_WIDE_INT mask));\n+extern void   gas_output_limited_string   PARAMS ((FILE *file, char *str));\n+extern void   gas_output_ascii            PARAMS ((FILE *file, char * str,\n+\t\t\t\t\t\t\t size_t length));\n+\n \n #ifdef TREE_CODE\n extern void   asm_output_external          PARAMS ((FILE *file, tree decl,\n@@ -58,6 +58,9 @@ extern int    valid_machine_type_attribute PARAMS ((tree type, tree attributes,\n extern int    valid_machine_decl_attribute PARAMS ((tree decl, tree attributes,\n \t\t\t\t\t\t   tree attr, tree args));\n \n+extern int    avr_progmem_p                PARAMS ((tree decl));\n+\n+\n #ifdef RTX_CODE /* inside TREE_CODE */\n extern rtx    avr_function_value           PARAMS ((tree type, tree func));\n extern void   init_cumulative_args         PARAMS ((CUMULATIVE_ARGS *cum,\n@@ -83,14 +86,15 @@ extern int    legitimate_address_p    PARAMS ((enum machine_mode mode, rtx x,\n \t\t\t\t\tint strict));\n extern void   machine_dependent_reorg PARAMS ((rtx first_insn));\n extern int    compare_diff_p  PARAMS ((rtx insn));\n+extern char * output_movqi    PARAMS ((rtx insn, rtx operands[], int *l));\n+extern char * output_movhi    PARAMS ((rtx insn, rtx operands[], int *l));\n extern char * out_movqi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n extern char * out_movqi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n extern char * out_movhi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n extern char * out_movhi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n extern char * out_movsi_r_mr  PARAMS ((rtx insn, rtx op[], int *l));\n extern char * out_movsi_mr_r  PARAMS ((rtx insn, rtx op[], int *l));\n-extern char * output_movsisf  PARAMS ((rtx insn, rtx operands[],\n-\t\t\t      \t      int which_alternative));\n+extern char * output_movsisf  PARAMS ((rtx insn, rtx operands[], int *l));\n extern char * out_tstsi       PARAMS ((rtx insn, int *l));\n extern char * out_tsthi       PARAMS ((rtx insn, int *l));\n extern char * ret_cond_branch PARAMS ((RTX_CODE cond, int len));\n@@ -116,7 +120,7 @@ extern rtx    legitimize_address     PARAMS ((rtx x, rtx oldx,\n extern int    adjust_insn_length     PARAMS ((rtx insn, int len));\n extern rtx    avr_libcall_value      PARAMS ((enum machine_mode mode));\n extern char * output_reload_inhi     PARAMS ((rtx insn, rtx *operands,\n-\t\t\t\t\t     int which_alternative));\n+\t\t\t\t\t     int *len));\n extern char * output_reload_insisf   PARAMS ((rtx insn, rtx *operands,\n \t\t\t\t\t     int which_alternative));\n extern int    default_rtx_costs      PARAMS ((rtx X, RTX_CODE code,\n@@ -140,6 +144,16 @@ extern int    jump_over_one_insn_p   PARAMS ((rtx insn, rtx dest));\n \n extern int    avr_hard_regno_mode_ok PARAMS ((int regno,\n \t\t\t\t\t     enum machine_mode mode));\n+extern int    call_insn_operand      PARAMS ((rtx op, enum machine_mode mode));\n+extern void   final_prescan_insn     PARAMS ((rtx insn, rtx *operand,\n+\t\t\t\t\t      int num_operands));\n+extern int    avr_simplify_comparision_p PARAMS ((enum machine_mode mode,\n+\t\t\t\t\t      RTX_CODE operator, rtx x));\n+extern RTX_CODE avr_normalize_condition  PARAMS ((RTX_CODE condition));\n+extern int    compare_eq_p           PARAMS ((rtx insn));\n+extern void   out_shift_with_cnt     PARAMS ((char * template, rtx insn,\n+\t\t\t\t\t      rtx operands[], int *len));\n+extern int    const_int_pow2_p       PARAMS ((rtx x));\n #endif /* RTX_CODE */\n \n #ifdef HAVE_MACHINE_MODES\n@@ -151,6 +165,4 @@ extern int    class_max_nregs        PARAMS ((enum reg_class class,\n \n extern void   asm_output_float       PARAMS ((FILE *file, REAL_VALUE_TYPE n));\n \n-#endif \n-\n-\n+#endif"}, {"sha": "74bb701429b14d0093a24592f819a5adffe795d3", "filename": "gcc/config/avr/avr.c", "status": "modified", "additions": 955, "deletions": 358, "changes": 1313, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.c?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -52,7 +52,9 @@ static char * cond_string          PARAMS ((enum rtx_code));\n static int    avr_num_arg_regs     PARAMS ((enum machine_mode, tree));\n static int    out_adj_frame_ptr    PARAMS ((FILE *, int));\n static int    out_set_stack_ptr    PARAMS ((FILE *, int, int));\n-\n+static int    reg_was_0            PARAMS ((rtx insn, rtx op));\n+static int    io_address_p         PARAMS ((rtx x, int size));\n+void          debug_hard_reg_set   PARAMS ((HARD_REG_SET set));\n \n /* Allocate registers from r25 to r8 for parameters for function calls */\n #define FIRST_CUM_REG 26\n@@ -63,8 +65,12 @@ rtx tmp_reg_rtx;\n /* Zeroed register RTX (gen_rtx (REG,QImode,ZERO_REGNO)) */\n rtx zero_reg_rtx;\n \n+/* RTX for register which will be used for loading immediate values to\n+   r0-r15 registers.  */\n+rtx ldi_reg_rtx;\n+\n /* AVR register names {\"r0\", \"r1\", ..., \"r31\"} */\n-char * avr_regnames[] = REGISTER_NAMES;\n+const char * avr_regnames[] = REGISTER_NAMES;\n \n /* This holds the last insn address.  */\n static int last_insn_address = 0;\n@@ -83,53 +89,108 @@ static int prologue_size;\n static int epilogue_size;\n \n /* Initial stack value specified by the `-minit-stack=' option */\n-const char *avr_ram_end = NULL;\n-\n-/* Numeric representation */\n-static const char *initial_stack;\n+const char *avr_init_stack = \"__stack\";\n \n /* Default MCU name */\n-const char *avr_mcu_name = \"at90s8515\";\n-\n-/* Default MCU */\n-struct mcu_type_s *avr_mcu_type;\n-\n-/* MCU names, initial stack value, flag 'mega' */\n-static struct mcu_type_s mcu_types[] =\n-{{\"at90s2313\", 224-1, 0},\n- {\"at90s2323\", 224-1, 0},\n- {\"at90s2333\", 224-1, 0},\n- {\"attiny22\",  224-1, 0},\n- {\"at90s2343\", 224-1, 0},\n- {\"at90s4433\", 224-1, 0},\n- {\"at90s4414\", 0x15f, 0},\n- {\"at90s4434\", 0x15f, 0},\n- {\"at90s8515\", 0x25f, 0},\n- {\"at90s8535\", 0x25f, 0},\n- {\"atmega603\", 0x0fff,1},\n- {\"atmega103\", 0x0fff,1},\n- {NULL,0,0}};\n-\n-/* Setup MCU */\n+const char *avr_mcu_name = \"avr2\";\n+\n+/* More than 8K of program memory: use \"call\" and \"jmp\".  */\n+int avr_mega_p = 0;\n+\n+/* Enhanced core: use \"movw\", \"mul\", ...  */\n+int avr_enhanced_p = 0;\n+\n+enum avr_arch {\n+  AVR1 = 1,\n+  AVR2,\n+  AVR3,\n+  AVR4,\n+  AVR5\n+};\n+\n+struct mcu_type_s {\n+  const char *name;\n+  enum avr_arch arch;\n+};\n+\n+/* List of all known AVR MCU types - if updated, it has to be kept\n+   in sync in several places (FIXME: is there a better way?):\n+    - here\n+    - avr.h (CPP_SPEC, LINK_SPEC, CRT_BINUTILS_SPECS)\n+    - t-avr (MULTILIB_MATCHES)\n+    - gas/config/tc-avr.c\n+    - avr-libc  */\n+\n+static const struct mcu_type_s avr_mcu_types[] = {\n+    /* Classic, <= 8K.  */\n+  { \"avr2\",      AVR2 },\n+  { \"at90s2313\", AVR2 },\n+  { \"at90s2323\", AVR2 },\n+  { \"attiny22\",  AVR2 },\n+  { \"at90s2333\", AVR2 },\n+  { \"at90s2343\", AVR2 },\n+  { \"at90s4414\", AVR2 },\n+  { \"at90s4433\", AVR2 },\n+  { \"at90s4434\", AVR2 },\n+  { \"at90s8515\", AVR2 },\n+  { \"at90c8534\", AVR2 },\n+  { \"at90s8535\", AVR2 },\n+    /* Classic, > 8K.  */\n+  { \"avr3\",      AVR3 },\n+  { \"atmega103\", AVR3 },\n+  { \"atmega603\", AVR3 },\n+    /* Enhanced, <= 8K.  */\n+  { \"avr4\",      AVR4 },\n+  { \"atmega83\",  AVR4 },\n+  { \"atmega85\",  AVR4 },\n+    /* Enhanced, > 8K.  */\n+  { \"avr5\",      AVR5 },\n+  { \"atmega161\", AVR5 },\n+  { \"atmega163\", AVR5 },\n+  { \"atmega32\",  AVR5 },\n+  { \"at94k\",     AVR5 },\n+    /* Assembler only.  */\n+  { \"avr1\",      AVR1 },\n+  { \"at90s1200\", AVR1 },\n+  { \"attiny10\",  AVR1 },\n+  { \"attiny11\",  AVR1 },\n+  { \"attiny12\",  AVR1 },\n+  { \"attiny15\",  AVR1 },\n+  { \"attiny28\",  AVR1 },\n+  { NULL, 0 }\n+};\n \n void\n avr_override_options (void)\n {\n-  for (avr_mcu_type = mcu_types; avr_mcu_type->name; ++avr_mcu_type)\n-    if (strcmp (avr_mcu_type->name, avr_mcu_name) == 0)\n+  const struct mcu_type_s *t;\n+\n+  for (t = avr_mcu_types; t->name; t++)\n+    if (strcmp (t->name, avr_mcu_name) == 0)\n       break;\n-  if (!avr_mcu_type->name)\n+\n+  if (!t->name)\n     {\n-      int i;\n-      fprintf (stderr,\n-\t       \"Wrong mcu `%s' specified\\n\"\n-\t       \"Allowed mcu's:\\n\", avr_mcu_name);\n-      for (i = 0; mcu_types[i].name; ++i)\n-\tfprintf (stderr,\"   %s\\n\", mcu_types[i].name);\n-      fatal (\"select right mcu name\");\n+      fprintf (stderr, \"Unknown MCU `%s' specified\\nKnown MCU names:\\n\",\n+\t       avr_mcu_name);\n+      for (t = avr_mcu_types; t->name; t++)\n+\tfprintf (stderr,\"   %s\\n\", t->name);\n+      fatal (\"select right MCU name\");\n+    }\n+\n+  switch (t->arch)\n+    {\n+      case AVR1:\n+      default:\n+      fatal (\"MCU `%s' not supported\", avr_mcu_name);\n+      case AVR2: avr_enhanced_p = 0; avr_mega_p = 0; break;\n+      case AVR3: avr_enhanced_p = 0; avr_mega_p = 1; break;\n+      case AVR4: avr_enhanced_p = 1; avr_mega_p = 0; break;\n+      case AVR5: avr_enhanced_p = 1; avr_mega_p = 1; break;\n     }\n }\n \n+\n /* Initialize TMP_REG_RTX and ZERO_REG_RTX */\n void\n avr_init_once (void)\n@@ -145,6 +206,12 @@ avr_init_once (void)\n   PUT_CODE (zero_reg_rtx, REG);\n   PUT_MODE (zero_reg_rtx, QImode);\n   XINT (zero_reg_rtx, 0) = ZERO_REGNO;\n+\n+  ldi_reg_rtx = xmalloc (sizeof (struct rtx_def) + 1 * sizeof (rtunion));\n+  memset (ldi_reg_rtx, 0, sizeof (struct rtx_def) + 1 * sizeof (rtunion));\n+  PUT_CODE (ldi_reg_rtx, REG);\n+  PUT_MODE (ldi_reg_rtx, QImode);\n+  XINT (ldi_reg_rtx, 0) = LDI_REG_REGNO;\n }\n \n /*  return register class from register number */\n@@ -363,7 +430,7 @@ out_adj_frame_ptr (file, adj)\n \t{\n \t  fprintf (file, (AS2 (subi, r28, lo8(%d)) CR_TAB\n \t\t\t  AS2 (sbci, r29, hi8(%d)) CR_TAB),\n-\t\t\t adj, adj);\n+\t\t   adj, adj);\n \t  size += 2;\n \t}\n       else if (adj < 0)\n@@ -496,11 +563,11 @@ function_prologue (FILE *file, int size)\n   if (main_p)\n     {\n       fprintf (file, (\"\\t\" \n-\t\t      AS2 (ldi, r28, lo8(%s - %d)) CR_TAB\n-\t\t      AS2 (ldi, r29, hi8(%s - %d)) CR_TAB\n-\t\t      AS2 (out, __SP_H__, r29)     CR_TAB\n-\t\t      AS2 (out, __SP_L__, r28) \"\\n\"),\n-\t       initial_stack, size, initial_stack, size);\n+\t\t      AS2 (ldi,r28,lo8(%s - %d)) CR_TAB\n+\t\t      AS2 (ldi,r29,hi8(%s - %d)) CR_TAB\n+\t\t      AS2 (out,__SP_H__,r29)     CR_TAB\n+\t\t      AS2 (out,__SP_L__,r28) \"\\n\"),\n+\t       avr_init_stack, size, avr_init_stack, size);\n       \n       prologue_size += 4;\n     }\n@@ -754,7 +821,8 @@ legitimate_address_p (mode, x, strict)\n       if (fit)\n \t{\n \t  if (! strict\n-\t      || REGNO (XEXP (x,0)) == REG_Y || REGNO (XEXP (x,0)) == REG_Z)\n+\t      || REGNO (XEXP (x,0)) == REG_Y\n+\t      || REGNO (XEXP (x,0)) == REG_Z)\n \t      r = 'Q';\n \t  if (XEXP (x,0) == frame_pointer_rtx\n \t      || XEXP (x,0) == arg_pointer_rtx)\n@@ -931,14 +999,8 @@ print_operand (file, x, code)\n   else if (GET_CODE (x) == MEM)\n     {\n       rtx addr = XEXP (x,0);\n-      if (code == 'K')\n-\t{\n-\t  if (CONSTANT_P (addr))\n-\t    putc ('s', file);\n-\t  else if (GET_CODE (addr) == PLUS)\n-\t    putc ('d', file);\n-\t}\n-      else if (CONSTANT_P (addr) && abcd)\n+\n+      if (CONSTANT_P (addr) && abcd)\n \t{\n \t  fputc ('(', file);\n \t  output_address (addr);\n@@ -964,7 +1026,7 @@ print_operand (file, x, code)\n \tfatal_insn (\"Internal compiler bug. Unknown mode:\", x);\n       REAL_VALUE_FROM_CONST_DOUBLE (rv, x);\n       REAL_VALUE_TO_TARGET_SINGLE (rv, val);\n-      asm_fprintf (file, \"0x%x\", val);\n+      asm_fprintf (file, \"0x%lx\", val);\n     }\n   else if (code == 'j')\n     asm_fprintf (file, cond_string (GET_CODE (x)));\n@@ -974,7 +1036,7 @@ print_operand (file, x, code)\n     print_operand_address (file, x);\n }\n \n-/* Recognise operand OP of mode MODE used in call instructions */\n+/* Recognize operand OP of mode MODE used in call instructions */\n \n int\n call_insn_operand (op, mode)\n@@ -1355,69 +1417,363 @@ function_arg_advance (cum, mode, type, named)\n   Functions for outputting various mov's for a various modes\n ************************************************************************/\n char *\n-out_movqi_r_mr (insn, op, l)\n+output_movqi (insn, operands, l)\n      rtx insn;\n-     rtx op[];\n-     int *l; /* instruction length */\n+     rtx operands[];\n+     int *l;\n {\n-  /* We handle CONSTANT_ADDRESS_P case in adjust_insn_length */\n-  if (l) *l=1;\n-  if (GET_CODE (op[1]) == MEM)\n+  int dummy;\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int *real_l = l;\n+  \n+  if (!l)\n+    l = &dummy;\n+\n+  *l = 1;\n+  \n+  if (register_operand (dest, QImode))\n     {\n-      rtx x = XEXP (op[1],0);\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x,0))\n-\t  && GET_CODE (XEXP (x,1)) == CONST_INT)\n+      if (register_operand (src, QImode)) /* mov r,r */\n \t{\n-\t  if((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[1]))) >= 63)\n+\t  if (test_hard_reg_class (STACK_REG, dest))\n+\t    return AS2 (out,%0,%1);\n+\t  else if (test_hard_reg_class (STACK_REG, src))\n+\t    return AS2 (in,%0,%1);\n+\t  \n+\t  return AS2 (mov,%0,%1);\n+\t}\n+      else if (CONSTANT_P (src))\n+\t{\n+\t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n+\t    return AS2 (ldi,%0,lo8(%1));\n+\t  \n+\t  if (GET_CODE (src) == CONST_INT)\n \t    {\n-\t      int disp = INTVAL (XEXP (x,1));\n-\t      if (REGNO (XEXP (x,0)) != REG_Y)\n-\t\tfatal_insn (\"Incorrect insn:\",insn);\n-\t      if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n+\t      if (src == const0_rtx) /* mov r,L */\n+\t\treturn AS1 (clr,%0);\n+\t      else if (src == const1_rtx)\n \t\t{\n-\t\t  if (l)\n-\t\t    *l = 3;\n-\t\t  else\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    return AS1 (inc,%0 ; reg_was_0);\n+\n+\t\t  *l = 2;\n+\t\t  return (AS1 (clr,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0));\n+\t\t}\n+\t      else if (src == const2_rtx)\n+\t\t{\n+\t\t  if (reg_was_0 (insn, operands[0]))\n \t\t    {\n-\t\t      op[4] = GEN_INT (disp - 63);\n-\t\t      return (AS2 (adiw, r28, %4) CR_TAB\n-\t\t\t      AS2 (ldd, %0,Y+63)  CR_TAB\n-\t\t\t      AS2 (sbiw, r28, %4));\n+\t\t      *l = 2;\n+\t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n+\t\t\t      AS1 (inc,%0));\n \t\t    }\n+\n+\t\t  *l = 3;\n+\t\t  return (AS1 (clr,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0));\n \t\t}\n-\t      else\n+\t      else if (src == constm1_rtx)\n \t\t{\n-\t\t  op[4] = XEXP (x,1);\n-\t\t  if (l)\n-\t\t    *l = 5;\n-\t\t  else\n-\t\t    return (AS2 (subi, r28, lo8(-%4))  CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(-%4)) CR_TAB\n-\t\t\t    AS2 (ld, %0,Y)              CR_TAB\n-\t\t\t    AS2 (subi, r28, lo8(%4))   CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(%4)));\n+\t\t  /* Immediate constants -1 to any register */\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    return AS1 (dec,%0 ; reg_was_0);\n+\n+\t\t  *l = 2;\n+\t\t  return (AS1 (clr,%0) CR_TAB\n+\t\t\t  AS1 (dec,%0));\n \t\t}\n+\t      \n \t    }\n-\t  else if (REGNO (XEXP (x,0)) == REG_X)\n+\t  \n+\t  /* Last resort, larger than loading from memory.  */\n+\t  *l = 4;\n+\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n+\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n+\t\t  AS2 (mov,%0,r31)          CR_TAB\n+\t\t  AS2 (mov,r31,__tmp_reg__));\n+\t}\n+      else if (GET_CODE (src) == MEM)\n+\treturn out_movqi_r_mr (insn, operands, real_l); /* mov r,m */\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      int save = 0;\n+      char *template;\n+      \n+      if (operands[1] == const0_rtx)\n+\t{\n+\t  operands[1] = zero_reg_rtx;\n+\t  save = 1;\n+\t}\n+      \n+      template = out_movqi_mr_r (insn, operands, real_l);\n+\n+      if (!real_l)\n+\toutput_asm_insn (template, operands);\n+      \n+      if (save)\n+\toperands[1] = const0_rtx;\n+    }\n+  return \"\";\n+}\n+\n+\n+char *\n+output_movhi (insn, operands, l)\n+     rtx insn;\n+     rtx operands[];\n+     int *l;\n+{\n+  int dummy;\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int *real_l = l;\n+  \n+  if (!l)\n+    l = &dummy;\n+  \n+  if (register_operand (dest, HImode))\n+    {\n+      if (register_operand (src, HImode)) /* mov r,r */\n+\t{\n+\t  if (test_hard_reg_class (STACK_REG, dest))\n \t    {\n-\t      /* This is a paranoid case LEGITIMIZE_RELOAD_ADDRESS must exclude\n-\t\t it but I have this situation with extremal optimizing options\n-\t      */\n-\t      if (l)\n-\t\t*l=3;\n-\t      else\n+\t      if (TARGET_TINY_STACK)\n+\t\t{\n+\t\t  *l = 1;\n+\t\t  return AS2 (out,__SP_L__,%A1);\n+\t\t}\n+\t      else if (TARGET_NO_INTERRUPTS)\n+\t\t{\n+\t\t  *l = 2;\n+\t\t  return (AS2 (out,__SP_H__,%B1) CR_TAB\n+\t\t\t  AS2 (out,__SP_L__,%A1));\n+\t\t}\n+\n+\t      *l = 5;\n+\t      return (AS2 (in,__tmp_reg__,__SREG__)  CR_TAB\n+\t\t      \"cli\"                          CR_TAB\n+\t\t      AS2 (out,__SP_H__,%B1)         CR_TAB\n+\t\t      AS2 (out,__SREG__,__tmp_reg__) CR_TAB\n+\t\t      AS2 (out,__SP_L__,%A1));\n+\t    }\n+\t  else if (test_hard_reg_class (STACK_REG, src))\n+\t    {\n+\t      *l = 2;\t\n+\t      return (AS2 (in,%A0,__SP_L__) CR_TAB\n+\t\t      AS2 (in,%B0,__SP_H__));\n+\t    }\n+\n+\t  if (AVR_ENHANCED)\n+\t    {\n+\t      *l = 1;\n+\t      return (AS2 (movw,%0,%1));\n+\t    }\n+\n+\t  if (true_regnum (operands[0]) > true_regnum (operands[1]))\n+\t    {\n+\t      *l = 2;\n+\t      return (AS2 (mov,%B0,%B1) CR_TAB\n+\t\t      AS2 (mov,%A0,%A1));\n+\t    }\n+\t  else\n+\t    {\n+\t      *l = 2;\n+\t      return (AS2 (mov,%A0,%A1) CR_TAB\n+\t\t      AS2 (mov,%B0,%B1));\n+\t    }\n+\t}\n+      else if (CONSTANT_P (src))\n+\t{\n+\t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n+\t    {\n+\t      *l = 2;\n+\t      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n+\t\t      AS2 (ldi,%B0,hi8(%1)));\n+\t    }\n+\t  \n+\t  if (GET_CODE (src) == CONST_INT)\n+\t    {\n+\t      if (src == const0_rtx) /* mov r,L */\n+\t\t{\n+\t\t  *l = 2;\n+\t\t  return (AS1 (clr,%A0) CR_TAB\n+\t\t\t  AS1 (clr,%B0));\n+\t\t}\n+\t      else if (src == const1_rtx)\n+\t\t{\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      *l = 1;\n+\t\t      return AS1 (inc,%0 ; reg_was_0);\n+\t\t    }\n+\n+\t\t  *l = 2;\n+\t\t  return (AS1 (clr,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0));\n+\t\t}\n+\t      else if (src == const2_rtx)\n \t\t{\n-\t\t  output_asm_insn (AS2 (adiw, r26, %0),&XEXP (x,1));\n-\t\t  output_asm_insn (AS2 (ld ,%0,X),op);\n-\t\t  if (!reg_overlap_mentioned_p (op[0],XEXP (x,0)))\n-\t\t    output_asm_insn (AS2 (sbiw, r26, %0),&XEXP (x,1));\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      *l = 2;\n+\t\t      return (AS1 (inc,%0 ; reg_was_0) CR_TAB\n+\t\t\t      AS1 (inc,%0));\n+\t\t    }\n+\n+\t\t  *l = 3;\n+\t\t  return (AS1 (clr,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0) CR_TAB\n+\t\t\t  AS1 (inc,%0));\n+\t\t}\n+\t      else if (src == constm1_rtx)\n+\t\t{\n+\t\t  /* Immediate constants -1 to any register */\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      *l = 2;\n+\t\t      return (AS1 (dec,%A0 ; reg_was_0) CR_TAB\n+\t\t\t      AS1 (dec,%B0));\n+\t\t    }\n+\n+\t\t  *l = 3;\n+\t\t  return (AS1 (clr,%0)  CR_TAB\n+\t\t\t  AS1 (dec,%A0) CR_TAB\n+\t\t\t  AS2 (mov,%B0,%A0));\n+\t\t}\n+\t      if ((INTVAL (src) & 0xff) == 0)\n+\t\t{\n+\t\t  *l = 5;\n+\t\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n+\t\t\t  AS1 (clr,%A0)             CR_TAB\n+\t\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n+\t\t\t  AS2 (mov,%B0,r31)         CR_TAB\n+\t\t\t  AS2 (mov,r31,__tmp_reg__));\n+\t\t}\n+\t      else if ((INTVAL (src) & 0xff00) == 0)\n+\t\t{\n+\t\t  *l = 5;\n+\t\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n+\t\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n+\t\t\t  AS2 (mov,%A0,r31)         CR_TAB\n+\t\t\t  AS1 (clr,%B0)             CR_TAB\n+\t\t\t  AS2 (mov,r31,__tmp_reg__));\n \t\t}\n-\t      return \"\";\n \t    }\n+\t  \n+\t  /* Last resort, equal to loading from memory.  */\n+\t  *l = 6;\n+\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n+\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n+\t\t  AS2 (mov,%A0,r31)         CR_TAB\n+\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n+\t\t  AS2 (mov,%B0,r31)         CR_TAB\n+\t\t  AS2 (mov,r31,__tmp_reg__));\n+\t}\n+      else if (GET_CODE (src) == MEM)\n+\treturn out_movhi_r_mr (insn, operands, real_l); /* mov r,m */\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      int save = 0;\n+      char *template;\n+      \n+      if (operands[1] == const0_rtx)\n+\t{\n+\t  operands[1] = zero_reg_rtx;\n+\t  save = 1;\n \t}\n+      \n+      template = out_movhi_mr_r (insn, operands, real_l);\n+\n+      if (!real_l)\n+\toutput_asm_insn (template, operands);\n+      \n+      if (save)\n+\toperands[1] = const0_rtx;\n+      return \"\";\n     }\n-  return AS2 (ld%K1,%0,%1);\n+  fatal_insn (\"Invalid insn:\", insn);\n+  return \"\";\n+}\n+\n+char *\n+out_movqi_r_mr (insn, op, l)\n+     rtx insn;\n+     rtx op[];\n+     int *l; /* instruction length */\n+{\n+  rtx x;\n+  int dummy;\n+  \n+  if (!l)\n+    l = &dummy;\n+  x = XEXP (op[1],0);\n+  \n+  if (CONSTANT_ADDRESS_P (x))\n+    {\n+      if (io_address_p (x, 1))\n+\t{\n+\t  *l = 1;\n+\t  return AS2 (in,%0,%1-0x20);\n+\t}\n+      *l = 2;\n+      return AS2 (lds,%0,%1);\n+    }\n+  /* memory access by reg+disp */\n+  else if (GET_CODE (x) == PLUS\n+      && REG_P (XEXP (x,0))\n+      && GET_CODE (XEXP (x,1)) == CONST_INT)\n+    {\n+      if((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[1]))) >= 63)\n+\t{\n+\t  int disp = INTVAL (XEXP (x,1));\n+\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t    fatal_insn (\"Incorrect insn:\",insn);\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n+\t    {\n+\t      *l = 3;\n+\t      op[4] = XEXP (x, 1);\n+\t      return (AS2 (adiw, r28, %4-63) CR_TAB\n+\t\t      AS2 (ldd, %0,Y+63)  CR_TAB\n+\t\t      AS2 (sbiw, r28, %4-63));\n+\t    }\n+\t  else\n+\t    {\n+\t      *l = 5;\n+\t      op[4] = XEXP (x,1);\n+\t      return (AS2 (subi, r28, lo8(-%4))  CR_TAB\n+\t\t      AS2 (sbci, r29, hi8(-%4)) CR_TAB\n+\t\t      AS2 (ld, %0,Y)              CR_TAB\n+\t\t      AS2 (subi, r28, lo8(%4))   CR_TAB\n+\t\t      AS2 (sbci, r29, hi8(%4)));\n+\t    }\n+\t}\n+      else if (REGNO (XEXP (x,0)) == REG_X)\n+\t{\n+\t  op[4] = XEXP (x, 1);\n+\t  /* This is a paranoid case LEGITIMIZE_RELOAD_ADDRESS must exclude\n+\t     it but I have this situation with extremal optimizing options.  */\n+\t  if (reg_overlap_mentioned_p (op[0],XEXP (x,0))\n+\t      || reg_unused_after (insn, XEXP (x,0)))\n+\t    {\n+\t      *l = 2;\n+\t      return (AS2 (adiw,r26,%4) CR_TAB\n+\t\t      AS2 (ld,%0,X));\n+\t    }\n+\t  *l = 3;\n+\t  return (AS2 (adiw,r26,%4) CR_TAB\n+\t\t  AS2 (ld,%0,X)     CR_TAB\n+\t\t  AS2 (sbiw,r26,%4));\n+\t}\n+      *l = 1;\n+      return AS2 (ldd,%0,%1);\n+    }\n+  *l = 1;\n+  return AS2 (ld,%0,%1);\n }\n \n char *\n@@ -1427,121 +1783,143 @@ out_movhi_r_mr (insn, op, l)\n      int *l; /* instruction length */\n {\n   int reg_dest = true_regnum (op[0]);\n-  int reg_base = true_regnum (XEXP (op[1],0));\n-  int len_p = 1,tmp;\n-  int *real_l=l;\n+  int reg_base = true_regnum (XEXP (op[1], 0));\n+  int tmp;\n \n   if (!l)\n-    l = &tmp, len_p = 0;\n+    l = &tmp;\n \n   if (reg_base > 0)\n     {\n       if (reg_dest == reg_base)         /* R = (R) */\n-        return *l=3, (AS2 (ld,__tmp_reg__,%1+) CR_TAB\n-                      AS2 (ld,%B0,%1) CR_TAB\n-                      AS2 (mov,%A0,__tmp_reg__));\n+\t{\n+\t  *l = 3;\n+\t  return (AS2 (ld,__tmp_reg__,%1+) CR_TAB\n+\t\t  AS2 (ld,%B0,%1) CR_TAB\n+\t\t  AS2 (mov,%A0,__tmp_reg__));\n+\t}\n       else if (reg_base == REG_X)        /* (R26) */\n         {\n           if (reg_unused_after (insn, XEXP (op[1],0)))\n-            return *l=2, (AS2 (ld,%A0,X+) CR_TAB\n-                          AS2 (ld,%B0,X));\n-          else\n-            return *l=3, (AS2 (ld,%A0,X+) CR_TAB\n-                          AS2 (ld,%B0,X) CR_TAB\n-                          AS2 (sbiw,r26,1));\n+\t    {\n+\t      *l = 2;\n+\t      return (AS2 (ld,%A0,X+) CR_TAB\n+\t\t      AS2 (ld,%B0,X));\n+\t    }\n+\t  *l  = 3;\n+\t  return (AS2 (ld,%A0,X+) CR_TAB\n+\t\t  AS2 (ld,%B0,X) CR_TAB\n+\t\t  AS2 (sbiw,r26,1));\n         }\n       else                      /* (R)  */\n-        return  *l=2, (AS2 (ld,%A0,%1)    CR_TAB\n-                       AS2 (ldd,%B0,%1+1));\n+\t{\n+\t  *l = 2;\n+\t  return (AS2 (ld,%A0,%1)    CR_TAB\n+\t\t  AS2 (ldd,%B0,%1+1));\n+\t}\n     }\n   else if (GET_CODE (XEXP (op[1],0)) == PLUS) /* (R + i) */\n     {\n-      int disp = INTVAL(XEXP (XEXP (op[1],0), 1));\n-      int reg_base = true_regnum (XEXP (XEXP (op[1],0), 0));\n+      int disp = INTVAL(XEXP (XEXP (op[1], 0), 1));\n+      int reg_base = true_regnum (XEXP (XEXP (op[1], 0), 0));\n       \n       if (disp > MAX_LD_OFFSET (GET_MODE (op[1])))\n \t{\n-\t  rtx x = XEXP (op[1],0);\n+\t  rtx x = XEXP (op[1], 0);\n+\t  op[4] = XEXP (x, 1);\n+\n \t  if (REGNO (XEXP (x,0)) != REG_Y)\n \t    fatal_insn (\"Incorrect insn:\",insn);\n+\t  \n \t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[1])))\n \t    {\n-\t      op[4] = GEN_INT (disp - 62);\n-\t      return *l=4, (AS2 (adiw, r28, %4) CR_TAB\n-\t\t\t    AS2 (ldd, %A0,Y+62)       CR_TAB\n-\t\t\t    AS2 (ldd, %B0,Y+63)     CR_TAB\n-\t\t\t    AS2 (sbiw, r28, %4));\n+\t      *l = 4;\n+\t      return (AS2 (adiw,r28,%4-62) CR_TAB\n+\t\t      AS2 (ldd,%A0,Y+62)   CR_TAB\n+\t\t      AS2 (ldd,%B0,Y+63)   CR_TAB\n+\t\t      AS2 (sbiw,r28,%4-62));\n \t    }\n \t  else\n \t    {\n-\t      op[4] = XEXP (x,1);\n-\t      return *l=6, (AS2 (subi, r28, lo8(-%4))  CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(-%4)) CR_TAB\n-\t\t\t    AS2 (ld, %A0,Y)             CR_TAB\n-\t\t\t    AS2 (ldd, %B0,Y+1)          CR_TAB\n-\t\t\t    AS2 (subi, r28, lo8(%4))   CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(%4)));\n+\t      *l = 6;\n+\t      return (AS2 (subi,r28,lo8(-%4)) CR_TAB\n+\t\t      AS2 (sbci,r29,hi8(-%4)) CR_TAB\n+\t\t      AS2 (ld,%A0,Y)          CR_TAB\n+\t\t      AS2 (ldd,%B0,Y+1)       CR_TAB\n+\t\t      AS2 (subi,r28,lo8(%4))  CR_TAB\n+\t\t      AS2 (sbci,r29,hi8(%4)));\n \t    }\n \t}\n       if (reg_base == REG_X)\n \t{\n \t  /* This is a paranoid case. LEGITIMIZE_RELOAD_ADDRESS must exclude\n-\t     it but I have this situation with extremal optimization options\n-\t   */\n-\t  rtx ops[1];\n-\t  ops[0] = XEXP (XEXP (op[1],0), 1);\n-\t  if (real_l)\n-\t    *l = 4;\n-\t  else if (reg_base == reg_dest)\n+\t     it but I have this situation with extremal\n+\t     optimization options.  */\n+\t  \n+\t  op[4] = XEXP (XEXP (op[1],0), 1);\n+\t  \n+\t  if (reg_base == reg_dest)\n \t    {\n-\t      output_asm_insn (AS2 (adiw, r26, %0), ops);\n-\t      output_asm_insn (AS2 (ld , __tmp_reg__, X+), op);\n-\t      output_asm_insn (AS2 (ld , %B0, X), op);\n-\t      output_asm_insn (AS2 (mov, %A0, __tmp_reg__),op);\n+\t      *l = 4;\n+\t      return (AS2 (adiw,r26,%4)       CR_TAB\n+\t\t      AS2 (ld,__tmp_reg__,X+) CR_TAB\n+\t\t      AS2 (ld,%B0,X)          CR_TAB\n+\t\t      AS2 (mov,%A0,__tmp_reg__));\n \t    }\n-\t  else\n+\n+\t  if (INTVAL (op[4]) == 63)\n \t    {\n-\t      output_asm_insn (AS2 (adiw, r26, %0), ops);\n-\t      output_asm_insn (AS2 (ld , %A0, X+), op);\n-\t      output_asm_insn (AS2 (ld , %B0, X), op);\n-\t      if (INTVAL (ops[0]) == 63)\n-\t\t{\n-\t\t  output_asm_insn (AS2 (subi, r26, %0+1), ops);\n-\t\t  output_asm_insn (AS2 (sbci, r26, 0), ops);\n-\t\t}\n-\t      else\n-\t\toutput_asm_insn (AS2 (sbiw, r26, %0+1), ops);\n+\t      *l = 5;\n+\t      return (AS2 (adiw,r26,%4)   CR_TAB\n+\t\t      AS2 (ld,%A0,X+)     CR_TAB\n+\t\t      AS2 (ld,%B0,X)      CR_TAB\n+\t\t      AS2 (subi,r26,%4+1) CR_TAB\n+\t\t      AS2 (sbci,r27,0));\n \t    }\n-\t  return \"\";\n+\t  *l = 4;\n+\t  return (AS2 (adiw,r26,%4) CR_TAB\n+\t\t  AS2 (ld,%A0,X+)   CR_TAB\n+\t\t  AS2 (ld,%B0,X)    CR_TAB\n+\t\t  AS2 (sbiw,r26,%4+1));\n+\t}\n+\n+      if (reg_base == reg_dest)\n+\t{\n+\t  *l = 3;\n+\t  return (AS2 (ldd,__tmp_reg__,%A1) CR_TAB\n+\t\t  AS2 (ldd,%B0,%B1)         CR_TAB\n+\t\t  AS2 (mov,%A0,__tmp_reg__));\n \t}\n       \n-      if (reg_base == reg_dest)\t\n-\treturn *l=3, (AS2 (ldd,__tmp_reg__,%A1)    CR_TAB\n-\t\t      AS2 (ldd,%B0,%B1)   CR_TAB\n-\t\t      AS2 (mov,%A0,__tmp_reg__));\n-      else\n-\treturn *l=2, (AS2 (ldd,%A0,%A1)    CR_TAB\n-\t\t      AS2 (ldd,%B0,%B1));\n+      *l = 2;\n+      return (AS2 (ldd,%A0,%A1) CR_TAB\n+\t      AS2 (ldd,%B0,%B1));\n     }\n   else if (GET_CODE (XEXP (op[1],0)) == PRE_DEC) /* (--R) */\n     {\n       if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n \tfatal_insn (\"Incorrect insn:\", insn);\n-      \n-      return *l=2, (AS2 (ld,%B0,%1) CR_TAB\n-\t\t    AS2 (ld,%A0,%1));\n+\n+      *l = 2;\n+      return (AS2 (ld,%B0,%1) CR_TAB\n+\t      AS2 (ld,%A0,%1));\n     }\n   else if (GET_CODE (XEXP (op[1],0)) == POST_INC) /* (R++) */\n     {\n       if (reg_overlap_mentioned_p (op[0], XEXP (XEXP (op[1],0),0)))\n \tfatal_insn (\"Incorrect insn:\", insn);\n-      \n-      return *l=2, (AS2 (ld,%A0,%1)  CR_TAB\n-\t\t    AS2 (ld,%B0,%1));\n+\n+      *l = 2;\n+      return (AS2 (ld,%A0,%1)  CR_TAB\n+\t      AS2 (ld,%B0,%1));\n     }\n   else if (CONSTANT_ADDRESS_P (XEXP (op[1],0)))\n-        return *l=4, (AS2 (lds,%A0,%A1) CR_TAB\n-\t\t      AS2 (lds,%B0,%B1));\n+    {\n+      *l = 4;\n+      return (AS2 (lds,%A0,%A1) CR_TAB\n+\t      AS2 (lds,%B0,%B1));\n+    }\n+  \n   fatal_insn (\"Unknown move insn:\",insn);\n   return \"\";\n }\n@@ -1555,8 +1933,10 @@ out_movsi_r_mr (insn,op,l)\n   int reg_dest=true_regnum (op[0]);\n   int reg_base=true_regnum (XEXP (op[1],0));\n   int tmp;\n+\n   if (!l)\n-    l=&tmp;\n+    l = &tmp;\n+  \n   if (reg_base > 0)\n     {\n       if (reg_base == REG_X)        /* (R26) */\n@@ -1687,8 +2067,10 @@ out_movsi_mr_r (insn,op,l)\n   int reg_base = true_regnum (XEXP (op[0],0));\n   int reg_dest = true_regnum (op[1]);\n   int tmp;\n+  \n   if (!l)\n     l = &tmp;\n+  \n   if (CONSTANT_ADDRESS_P (XEXP (op[0],0)))\n     return *l=8,(AS2 (sts,%A0,%A1) CR_TAB\n \t\t AS2 (sts,%B0,%B1) CR_TAB\n@@ -1797,81 +2179,192 @@ out_movsi_mr_r (insn,op,l)\n }\n \n char *\n-output_movsisf(insn, operands, which_alternative)\n+output_movsisf(insn, operands, l)\n      rtx insn;\n      rtx operands[];\n-     int which_alternative;\n+     int *l;\n {\n-  rtx link;\n-  switch (which_alternative)\n+  int dummy;\n+  rtx dest = operands[0];\n+  rtx src = operands[1];\n+  int *real_l = l;\n+  \n+  if (!l)\n+    l = &dummy;\n+  \n+  if (register_operand (dest, VOIDmode))\n     {\n-    case 0: /* mov r,r */\n-      if (true_regnum (operands[0]) > true_regnum (operands[1]))\n+      if (register_operand (src, VOIDmode)) /* mov r,r */\n \t{\n-\t  if (TARGET_ENHANCED)\n-\t    return (AS2 (movw,%C0,%C1) CR_TAB\n-\t\t    AS2 (movw,%A0,%A1));  /* FIXME: length = 4 -> 2 */\n+\t  if (true_regnum (dest) > true_regnum (src))\n+\t    {\n+\t      if (AVR_ENHANCED)\n+\t\t{\n+\t\t  *l = 2;\n+\t\t  return (AS2 (movw,%C0,%C1) CR_TAB\n+\t\t\t  AS2 (movw,%A0,%A1));\n+\t\t}\n+\t      *l = 4;\n+\t      return (AS2 (mov,%D0,%D1) CR_TAB\n+\t\t      AS2 (mov,%C0,%C1) CR_TAB\n+\t\t      AS2 (mov,%B0,%B1) CR_TAB\n+\t\t      AS2 (mov,%A0,%A1));\n+\t    }\n \t  else\n-\t    return (AS2 (mov,%D0,%D1) CR_TAB\n-\t\t    AS2 (mov,%C0,%C1) CR_TAB\n-\t\t    AS2 (mov,%B0,%B1) CR_TAB\n-\t\t    AS2 (mov,%A0,%A1));\n+\t    {\n+\t      if (AVR_ENHANCED)\n+\t\t{\n+\t\t  *l = 2;\n+\t\t  return (AS2 (movw,%A0,%A1) CR_TAB\n+\t\t\t  AS2 (movw,%C0,%C1));\n+\t\t}\n+\t      *l = 4;\n+\t      return (AS2 (mov,%A0,%A1) CR_TAB\n+\t\t      AS2 (mov,%B0,%B1) CR_TAB\n+\t\t      AS2 (mov,%C0,%C1) CR_TAB\n+\t\t      AS2 (mov,%D0,%D1));\n+\t    }\n \t}\n-      else\n+      else if (CONSTANT_P (src))\n \t{\n-\t  if (TARGET_ENHANCED)\n-\t    return (AS2 (movw,%A0,%A1) CR_TAB\n-\t\t    AS2 (movw,%C0,%C1));  /* FIXME: length = 4 -> 2 */\n-\t  else\n-\t    return (AS2 (mov,%A0,%A1) CR_TAB\n-\t\t    AS2 (mov,%B0,%B1) CR_TAB\n-\t\t    AS2 (mov,%C0,%C1) CR_TAB\n-\t\t    AS2 (mov,%D0,%D1));\n-\t}\n-    case 1:  /* mov r,L */\n-      if (TARGET_ENHANCED)\n-\treturn (AS1 (clr,%A0) CR_TAB\n-\t\tAS1 (clr,%B0) CR_TAB\n-\t\tAS2 (movw,%C0,%A0));  /* FIXME: length = 4 -> 3 */\n-\n-      return (AS1 (clr,%A0) CR_TAB\n-\t      AS1 (clr,%B0) CR_TAB\n-\t      AS1 (clr,%C0) CR_TAB\n-\t      AS1 (clr,%D0));\n-    case 2: /* mov r,d */\n-      if (GET_MODE (operands[0]) == SImode\n-\t  && operands[1] == const1_rtx\n-\t  && (link = find_reg_note (insn, REG_WAS_0, 0))\n-\t  /* Make sure the insn that stored the 0 is still present.  */\n-\t  && ! INSN_DELETED_P (XEXP (link, 0))\n-\t  && GET_CODE (XEXP (link, 0)) != NOTE\n-\t  /* Make sure cross jumping didn't happen here.  */\n-\t  && no_labels_between_p (XEXP (link, 0), insn)\n-\t  /* Make sure the reg hasn't been clobbered.  */\n-\t  && ! reg_set_between_p (operands[0], XEXP (link, 0), insn))\n-      /* Fastest way to change a 0 to a 1.  */\n-        return AS1 (inc,%A0 ; reg_was_0);\n-      return (AS2 (ldi,%A0,lo8(%1))  CR_TAB\n-\t      AS2 (ldi,%B0,hi8(%1)) CR_TAB\n-\t      AS2 (ldi,%C0,hlo8(%1)) CR_TAB\n-\t      AS2 (ldi,%D0,hhi8(%1)));\n-    case 3: /* mov r,m*/\n-    case 5:\n-      return out_movsi_r_mr (insn, operands, NULL);\n-    case 4: /* mov m,r*/\n-    case 6:\n-      {\n-\trtx save1=NULL;\n-\tif (operands[1] == const0_rtx)\n-\t  {\n-\t    save1 = operands[1];\n-\t    operands[1] = zero_reg_rtx;\n-\t  }\n-\toutput_asm_insn (out_movsi_mr_r (insn,operands,NULL), operands);\n-\tif (save1)\n-\t  operands[1] = save1;\n-      }\n+\t  if (test_hard_reg_class (LD_REGS, dest)) /* ldi d,i */\n+\t    {\n+\t      *l = 4;\n+\t      return (AS2 (ldi,%A0,lo8(%1))  CR_TAB\n+\t\t      AS2 (ldi,%B0,hi8(%1))  CR_TAB\n+\t\t      AS2 (ldi,%C0,hlo8(%1)) CR_TAB\n+\t\t      AS2 (ldi,%D0,hhi8(%1)));\n+\t    }\n+\t  \n+\t  if (GET_CODE (src) == CONST_INT)\n+\t    {\n+\t      if (src == const0_rtx) /* mov r,L */\n+\t\t{\n+\t\t  if (AVR_ENHANCED)\n+\t\t    {\n+\t\t      *l = 3;\n+\t\t      return (AS1 (clr,%A0) CR_TAB\n+\t\t\t      AS1 (clr,%B0) CR_TAB\n+\t\t\t      AS2 (movw,%C0,%A0));\n+\t\t    }\n+\t\t  *l = 4;\n+\t\t  return (AS1 (clr,%A0) CR_TAB\n+\t\t\t  AS1 (clr,%B0) CR_TAB\n+\t\t\t  AS1 (clr,%C0) CR_TAB\n+\t\t\t  AS1 (clr,%D0));\n+\t\t}\n+\t      else if (src == const1_rtx)\n+\t\t{\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      *l = 1;\n+\t\t      return AS1 (inc,%A0 ; reg_was_0);\n+\t\t    }\n+\n+\t\t  *l = 4;\n+\t\t  return (AS1 (clr,%D0) CR_TAB\n+\t\t\t  AS1 (clr,%B0) CR_TAB\n+\t\t\t  AS1 (clr,%C0) CR_TAB\n+\t\t\t  AS1 (inc,%A0));\n+\t\t}\n+\t      else if (src == const2_rtx)\n+\t\t{\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      *l = 2;\n+\t\t      return (AS1 (inc,%A0 ; reg_was_0) CR_TAB\n+\t\t\t      AS1 (inc,%A0));\n+\t\t    }\n+\n+\t\t  if (AVR_ENHANCED)\n+\t\t    {\n+\t\t      *l = 5;\n+\t\t      return (AS1 (clr,%D0)      CR_TAB\n+\t\t\t      AS1 (clr,%C0)      CR_TAB\n+\t\t\t      AS2 (movw,%A0,%C0) CR_TAB\n+\t\t\t      AS1 (inc,%A0)      CR_TAB\n+\t\t\t      AS1 (inc,%A0));\n+\t\t    }\n+\t\t  *l = 6;\n+\t\t  return (AS1 (clr,%D0) CR_TAB\n+\t\t\t  AS1 (clr,%B0) CR_TAB\n+\t\t\t  AS1 (clr,%C0) CR_TAB\n+\t\t\t  AS1 (clr,%A0) CR_TAB\n+\t\t\t  AS1 (inc,%A0) CR_TAB\n+\t\t\t  AS1 (inc,%A0));\n+\t\t}\n+\t      else if (src == constm1_rtx)\n+\t\t{\n+\t\t  /* Immediate constants -1 to any register */\n+\t\t  if (reg_was_0 (insn, operands[0]))\n+\t\t    {\n+\t\t      if (AVR_ENHANCED)\n+\t\t\t{\n+\t\t\t  *l = 3;\n+\t\t\t  return (AS1 (dec,%A0) CR_TAB\n+\t\t\t\t  AS1 (dec,%B0) CR_TAB\n+\t\t\t\t  AS2 (movw,%C0,%A0));\n+\t\t\t}\n+\t\t      *l = 4;\n+\t\t      return (AS1 (dec,%D0 ; reg_was_0) CR_TAB\n+\t\t\t      AS1 (dec,%C0)             CR_TAB\n+\t\t\t      AS1 (dec,%B0)             CR_TAB\n+\t\t\t      AS1 (dec,%A0));\n+\t\t    }\n+\t\t  if (AVR_ENHANCED)\n+\t\t    {\n+\t\t      *l = 4;\n+\t\t      return (AS1 (clr,%A0)     CR_TAB\n+\t\t\t      AS1 (dec,%A0)     CR_TAB\n+\t\t\t      AS2 (mov,%B0,%A0) CR_TAB\n+\t\t\t      AS2 (movw,%C0,%A0));\n+\t\t    }\n+\t\t  *l = 5;\n+\t\t  return (AS1 (clr,%A0)     CR_TAB\n+\t\t\t  AS1 (dec,%A0)     CR_TAB\n+\t\t\t  AS2 (mov,%B0,%A0) CR_TAB\n+\t\t\t  AS2 (mov,%C0,%A0) CR_TAB\n+\t\t\t  AS2 (mov,%D0,%A0));\n+\t\t}\n+\t    }\n+\t  \n+\t  /* Last resort, better than loading from memory.  */\n+\t  *l = 10;\n+\t  return (AS2 (mov,__tmp_reg__,r31) CR_TAB\n+\t\t  AS2 (ldi,r31,lo8(%1))     CR_TAB\n+\t\t  AS2 (mov,%A0,r31)         CR_TAB\n+\t\t  AS2 (ldi,r31,hi8(%1))     CR_TAB\n+\t\t  AS2 (mov,%B0,r31)         CR_TAB\n+\t\t  AS2 (ldi,r31,hlo8(%1))    CR_TAB\n+\t\t  AS2 (mov,%C0,r31)         CR_TAB\n+\t\t  AS2 (ldi,r31,hhi8(%1))    CR_TAB\n+\t\t  AS2 (mov,%D0,r31)         CR_TAB\n+\t\t  AS2 (mov,r31,__tmp_reg__));\n+\t}\n+      else if (GET_CODE (src) == MEM)\n+\treturn out_movsi_r_mr (insn, operands, real_l); /* mov r,m */\n+    }\n+  else if (GET_CODE (dest) == MEM)\n+    {\n+      int save = 0;\n+      char *template;\n+      \n+      if (operands[1] == const0_rtx)\n+\t{\n+\t  operands[1] = zero_reg_rtx;\n+\t  save = 1;\n+\t}\n+      \n+      template = out_movsi_mr_r (insn, operands, real_l);\n+\n+      if (!real_l)\n+\toutput_asm_insn (template, operands);\n+      \n+      if (save)\n+\toperands[1] = const0_rtx;\n+      return \"\";\n     }\n+  fatal_insn (\"Invalid insn:\", insn);\n   return \"\";\n }\n \n@@ -1881,66 +2374,90 @@ out_movqi_mr_r (insn, op, l)\n      rtx op[];\n      int *l; /* instruction length */\n {\n-  if (l) *l=1;\n+  rtx x;\n+  int dummy;\n \n-  if (GET_CODE (op[0]) == MEM)\n+  if (!l)\n+    l = &dummy;\n+    \n+  x = XEXP (op[0],0);\n+  \n+  if (CONSTANT_ADDRESS_P (x))\n     {\n-      rtx x = XEXP (op[0],0);\n-      if (GET_CODE (x) == PLUS\n-\t  && REG_P (XEXP (x,0))\n-\t  && GET_CODE (XEXP (x,1)) == CONST_INT)\n+      if (io_address_p (x, 1))\n+\t{\n+\t  *l = 1;\n+\t  return AS2 (out,%0-0x20,%1);\n+\t}\n+      *l = 2;\n+      return AS2 (sts,%0,%1);\n+    }\n+  /* memory access by reg+disp */\n+  else if (GET_CODE (x) == PLUS\t\n+      && REG_P (XEXP (x,0))\n+      && GET_CODE (XEXP (x,1)) == CONST_INT)\n+    {\n+      if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[0]))) >= 63)\n \t{\n-\t  if ((INTVAL (XEXP (x,1)) - GET_MODE_SIZE (GET_MODE (op[0]))) >= 63)\n+\t  int disp = INTVAL (XEXP (x,1));\n+\t  if (REGNO (XEXP (x,0)) != REG_Y)\n+\t    fatal_insn (\"Incorrect insn:\",insn);\n+\t  if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n \t    {\n-\t      int disp = INTVAL (XEXP (x,1));\n-\t      if (REGNO (XEXP (x,0)) != REG_Y)\n-\t\tfatal_insn (\"Incorrect insn:\",insn);\n-\t      if (disp <= 63 + MAX_LD_OFFSET (GET_MODE (op[0])))\n-\t\t{\n-\t\t  if (l)\n-\t\t    *l = 3;\n-\t\t  else\n-\t\t    {\n-\t\t      op[4] = GEN_INT (disp - 63);\n-\t\t      return (AS2 (adiw, r28, %4) CR_TAB\n-\t\t\t      AS2 (std, Y+63,%1)        CR_TAB\n-\t\t\t      AS2 (sbiw, r28, %4));\n-\t\t    }\n-\t\t}\n-\t      else\n+\t      *l = 3;\n+\t      op[4] = XEXP (x, 1);\n+\t      return (AS2 (adiw, r28, %4-63) CR_TAB\n+\t\t      AS2 (std, Y+63,%1)        CR_TAB\n+\t\t      AS2 (sbiw, r28, %4-63));\n+\t    }\n+\t  else\n+\t    {\n+\t      *l = 5;\n+\t      op[4] = XEXP (x,1);\n+\t      return (AS2 (subi, r28, lo8(-%4))  CR_TAB\n+\t\t      AS2 (sbci, r29, hi8(-%4)) CR_TAB\n+\t\t      AS2 (st, Y,%1)              CR_TAB\n+\t\t      AS2 (subi, r28, lo8(%4))   CR_TAB\n+\t\t      AS2 (sbci, r29, hi8(%4)));\n+\t    }\n+\t}\n+      else if (REGNO (XEXP (x,0)) == REG_X)\n+\t{\n+\t  op[4] = XEXP (x,1);\n+\t  if (reg_overlap_mentioned_p (op[1],XEXP (x,0)))\n+\t    {\n+\t      if (reg_unused_after (insn, XEXP (x,0)))\n \t\t{\n-\t\t  op[4] = XEXP (x,1);\n-\t\t  if (l)\n-\t\t    *l = 5;\n-\t\t  else\n-\t\t    return (AS2 (subi, r28, lo8(-%4))  CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(-%4)) CR_TAB\n-\t\t\t    AS2 (st, Y,%1)              CR_TAB\n-\t\t\t    AS2 (subi, r28, lo8(%4))   CR_TAB\n-\t\t\t    AS2 (sbci, r29, hi8(%4)));\n+\t\t  *l = 3;\n+\t\t  return (AS2 (mov,__tmp_reg__,%1) CR_TAB\n+\t\t\t  AS2 (adiw,r26,%4)        CR_TAB\n+\t\t\t  AS2 (st,X,__tmp_reg__));\n \t\t}\n+\t      *l = 4;\n+\t      return (AS2 (mov,__tmp_reg__,%1) CR_TAB\n+\t\t      AS2 (adiw,r26,%4)        CR_TAB\n+\t\t      AS2 (st,X,__tmp_reg__)   CR_TAB\n+\t\t      AS2 (sbiw,r26,%4));\n \t    }\n-\t  else if (REGNO (XEXP (x,0)) == REG_X)\n+\t  else\n \t    {\n-\t      if (l)\n-\t\t*l=4;\n-\t      else\n+\t      if (reg_unused_after (insn, XEXP (x,0)))\n \t\t{\n-\t\t  int overlap_p = reg_overlap_mentioned_p (op[1],XEXP (x,0));\n-\t\t  if (!overlap_p)\n-\t\t    output_asm_insn (AS2 (mov, __tmp_reg__, %1),op);\n-\t\t  output_asm_insn (AS2 (adiw, r26,%0),&XEXP (x,1));\n-\t\t  if (overlap_p)\n-\t\t    output_asm_insn (AS2 (st ,X,__tmp_reg__),op);\n-\t\t  else\n-\t\t    output_asm_insn (AS2 (st ,X,%1),op);\n-\t\t  output_asm_insn (AS2 (sbiw ,r26,%0),&XEXP (x,1));\n+\t\t  *l = 2;\n+\t\t  return (AS2 (adiw,r26,%4) CR_TAB\n+\t\t\t  AS2 (st,X,%1));\n \t\t}\n-\t      return \"\";\n+\t      *l = 3;\n+\t      return (AS2 (adiw,r26,%4) CR_TAB\n+\t\t      AS2 (st,X,%1)      CR_TAB\n+\t\t      AS2 (sbiw,r26,%4));\n \t    }\n \t}\n+      *l = 1;\n+      return AS2 (std,%0,%1);\n     }\n-  return AS2 (st%K0, %0,%1);\n+  *l = 1;\n+  return AS2 (st,%0,%1);\n }\n \n char *\n@@ -2017,7 +2534,7 @@ out_movhi_mr_r (insn,op,l)\n \t}\n       return *l=2, (AS2 (std,%A0,%A1)    CR_TAB\n \t\t    AS2 (std,%B0,%B1));\n-    }  \n+    }\n   else if (GET_CODE (XEXP (op[0],0)) == PRE_DEC) /* (--R) */\n     return *l=2, (AS2 (st,%0,%B1) CR_TAB\n \t\t  AS2 (st,%0,%A1));\n@@ -2412,7 +2929,7 @@ ashlsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len = 4;\n-\t    if (TARGET_ENHANCED && (reg0 + 2 != reg1))\n+\t    if (AVR_ENHANCED && (reg0 + 2 != reg1))\n \t      {\n \t\t*len = 3;\n \t\treturn (AS2 (movw,%C0,%A1) CR_TAB\n@@ -2653,7 +3170,7 @@ ashrsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len=6;\n-\t    if (TARGET_ENHANCED && (reg0 != reg1 + 2))\n+\t    if (AVR_ENHANCED && (reg0 != reg1 + 2))\n \t      {\n \t\t*len = 5;\n \t\treturn (AS2 (movw,%A0,%C1) CR_TAB\n@@ -2912,7 +3429,7 @@ lshrsi3_out (insn,operands,len)\n \t    int reg0 = true_regnum (operands[0]);\n \t    int reg1 = true_regnum (operands[1]);\n \t    *len = 4;\n-\t    if (TARGET_ENHANCED && (reg0 != reg1 + 2))\n+\t    if (AVR_ENHANCED && (reg0 != reg1 + 2))\n \t      {\n \t\t*len = 3;\n \t\treturn (AS2 (movw,%A0,%C1) CR_TAB\n@@ -2971,49 +3488,25 @@ adjust_insn_length (insn,len)\n       rtx op[10];\n       op[1] = SET_SRC (patt);\n       op[0] = SET_DEST (patt);\n-      if (REG_P (op[0]) && GET_CODE (op[1]) == MEM)\n-        {\n-\t  if (CONSTANT_ADDRESS_P (XEXP (op[1],0)))\n-\t    switch (GET_MODE (op[0]))\n-\t      {\n-\t      case QImode: len = 2; break;\n-\t      case HImode: len = 4; break;\n-\t      case SImode:\n-\t      case SFmode: len = 8; break;\n-\t      default: break; \n-\t      }\n-\t  else\n-\t    switch (GET_MODE (op[0]))\n-\t      {\n-\t      case QImode: out_movqi_r_mr (insn,op,&len); break;\n-\t      case HImode: out_movhi_r_mr (insn,op,&len); break;\n-\t      case SImode:\n-\t      case SFmode: out_movsi_r_mr (insn,op,&len); break;\n-\t      default: break;\n-\t      }\n-        }\n-      else if ((REG_P (op[1]) || const0_rtx == op[1])\n-\t       && GET_CODE (op[0]) == MEM)\n-        {\n-\t  if (CONSTANT_ADDRESS_P (XEXP (op[0],0)))\n-\t    switch (GET_MODE (op[0]))\n-\t      {\n-\t      case QImode: len = 2; break;\n-\t      case HImode: len = 4; break;\n-\t      case SImode:\n-\t      case SFmode: len = 8; break;\n-\t      default: break;\n-\t      }\n-\t  else if (GET_CODE (XEXP (op[0],0)) != POST_DEC)\n-\t    switch (GET_MODE (op[0]))\n-\t      {\n-\t      case QImode: out_movqi_mr_r (insn,op,&len); break;\n-\t      case HImode: out_movhi_mr_r (insn,op,&len); break;\n-\t      case SImode:\n-\t      case SFmode: out_movsi_mr_r (insn,op,&len); break;\n-\t      default: break;\n-\t      }\n-        }\n+      if (general_operand (op[1], VOIDmode)\n+\t  && general_operand (op[0], VOIDmode))\n+\t{\n+\t  switch (GET_MODE (op[0]))\n+\t    {\n+\t    case QImode:\n+\t      output_movqi (insn, op, &len);\n+\t      break;\n+\t    case HImode:\n+\t      output_movhi (insn, op, &len);\n+\t      break;\n+\t    case SImode:\n+\t    case SFmode:\n+\t      output_movsisf (insn, op, &len);\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n       else if (op[0] == cc0_rtx && REG_P (op[1]))\n \t{\n \t  switch (GET_MODE (op[1]))\n@@ -3112,13 +3605,7 @@ reg_unused_after (insn, reg)\n      rtx insn;\n      rtx reg;\n {\n-  return (0\n-\t  /* In egcs 1.1.x dead_or_set_p give buggy result after reload \n-#ifdef PRESERVE_DEATH_INFO_REGNO_P\n-\t  || dead_or_set_p (insn,reg)\n-#endif\n-\t  */\n-\t  \n+  return (dead_or_set_p (insn, reg)\n \t  || (REG_P(reg) && _reg_unused_after (insn, reg)));\n }\n \n@@ -3408,7 +3895,7 @@ gas_output_ascii(file, str, length)\n \t      fprintf (file, \"\\\"\\n\");\n \t      bytes_in_chunk = 0;\n \t    }\n-\t  gas_output_limited_string (file, _ascii_bytes);\n+\t  gas_output_limited_string (file, (char*)_ascii_bytes);\n \t  _ascii_bytes = p;\n \t}\n       else\n@@ -3552,20 +4039,11 @@ asm_file_start (file)\n      FILE *file;\n {\n   output_file_directive (file, main_input_filename);\n-  fprintf (file, \"\\t.arch %s\\n\", avr_mcu_type->name);\n+  fprintf (file, \"\\t.arch %s\\n\", avr_mcu_name);\n   fputs (\"__SREG__ = 0x3f\\n\"\n \t \"__SP_H__ = 0x3e\\n\"\n \t \"__SP_L__ = 0x3d\\n\", file);\n   \n-  if (avr_ram_end)\n-    initial_stack = avr_ram_end;\n-  else\n-    {\n-      static char buf[30];\n-      initial_stack = buf;\n-      sprintf (buf, \"0x%x\", avr_mcu_type->stack);\n-    }\n-  \n   fputs (\"__tmp_reg__ = 0\\n\" \n \t \"__zero_reg__ = 1\\n\"\n \t \"_PC_ = 2\\n\", file);\n@@ -3953,17 +4431,9 @@ mask_one_bit_p (mask)\n \n enum reg_class\n preferred_reload_class (x, class)\n-     rtx x;\n+     rtx x ATTRIBUTE_UNUSED;\n      enum reg_class class;\n {\n-  if (GET_CODE (x) == CONST_INT && INTVAL (x) == 0)\n-    return class;\n-  if (CONSTANT_P (x) && (class == NO_LD_REGS\n-  \t\t\t || class == ALL_REGS\n-\t\t\t || class == GENERAL_REGS))\n-    {\n-      return LD_REGS;\n-    }\n   return class;\n }\n \n@@ -3979,7 +4449,8 @@ test_hard_reg_class (class, x)\n }\n \n void\n-debug_hard_reg_set (HARD_REG_SET set)\n+debug_hard_reg_set (set)\n+     HARD_REG_SET set;\n {\n   int i;\n   for (i=0; i < FIRST_PSEUDO_REGISTER; ++i)\n@@ -4017,7 +4488,133 @@ avr_hard_regno_mode_ok (regno, mode)\n {\n   if (mode == QImode)\n     return 1;\n-  if (regno < 24 && !TARGET_ENHANCED)\n+  if (regno < 24 && !AVR_ENHANCED)\n     return 1;\n   return !(regno & 1);\n }\n+\n+/* Returns 1 if we know register operand OP was 0 before INSN.  */\n+\n+static int\n+reg_was_0 (insn, op)\n+     rtx insn;\n+     rtx op;\n+{\n+  rtx link;\n+  return (optimize > 0 && insn && op && REG_P (op)\n+\t  && (link = find_reg_note (insn, REG_WAS_0, 0))\n+\t  /* Make sure the insn that stored the 0 is still present.  */\n+\t  && ! INSN_DELETED_P (XEXP (link, 0))\n+\t  && GET_CODE (XEXP (link, 0)) != NOTE\n+\t  /* Make sure cross jumping didn't happen here.  */\n+\t  && no_labels_between_p (XEXP (link, 0), insn)\n+\t  /* Make sure the reg hasn't been clobbered.  */\n+\t  && ! reg_set_between_p (op, XEXP (link, 0), insn));\n+}\n+\n+/* Returns 1 if X is a valid address for an I/O register of size SIZE\n+   (1 or 2).  Used for lds/sts -> in/out optimization.  */\n+\n+static int\n+io_address_p (x, size)\n+     rtx x;\n+     int size;\n+{\n+  return (optimize > 0 && GET_CODE (x) == CONST_INT\n+\t  && INTVAL (x) >= 0x20 && INTVAL (x) <= 0x60 - size);\n+}\n+\n+/* Returns nonzero (bit number + 1) if X, or -X, is a constant power of 2.  */\n+\n+int\n+const_int_pow2_p (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) == CONST_INT)\n+    {\n+      HOST_WIDE_INT d = INTVAL (x);\n+      HOST_WIDE_INT abs_d = (d >= 0) ? d : -d;\n+      return exact_log2 (abs_d) + 1;\n+    }\n+  return 0;\n+}\n+\n+char *\n+output_reload_inhi (insn, operands, len)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     rtx *operands;\n+     int *len;\n+{\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      int val = INTVAL (operands[1]);\n+      if ((val & 0xff) == 0)\n+\t{\n+\t  *len = 3;\n+\t  return (AS2 (mov,%A0,__zero_reg__) CR_TAB\n+\t\t  AS2 (ldi,%2,hi8(%1))       CR_TAB\n+\t\t  AS2 (mov,%B0,%2));\n+\t}\n+      else if ((val & 0xff00) == 0)\n+\t{\n+\t  *len = 3;\n+\t  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n+\t\t  AS2 (mov,%A0,%2)     CR_TAB\n+\t\t  AS2 (mov,%B0,__zero_reg__));\n+\t}\n+      else if ((val & 0xff) == ((val & 0xff00) >> 8))\n+\t{\n+\t  *len = 3;\n+\t  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n+\t\t  AS2 (mov,%A0,%2)     CR_TAB\n+\t\t  AS2 (mov,%B0,%2));\n+\t}\n+    }\n+  *len = 4;\n+  return (AS2 (ldi,%2,lo8(%1)) CR_TAB\n+\t  AS2 (mov,%A0,%2)     CR_TAB\n+\t  AS2 (ldi,%2,hi8(%1)) CR_TAB\n+\t  AS2 (mov,%B0,%2));\n+}\n+\n+\n+char *\n+output_reload_insisf (insn, operands, which_alternative)\n+     rtx insn ATTRIBUTE_UNUSED;\n+     rtx *operands;\n+     int which_alternative ATTRIBUTE_UNUSED;\n+{\n+  int cnst = (GET_CODE (operands[1]) == CONST_INT);\n+\n+  if (cnst && ((INTVAL (operands[1]) & 0xff) == 0))\n+    output_asm_insn (AS2 (mov, %A0, __zero_reg__), operands);\n+  else\n+    {\n+      output_asm_insn (AS2 (ldi, %2, lo8(%1)), operands);\n+      output_asm_insn (AS2 (mov, %A0, %2), operands);\n+    }\n+  if (cnst && ((INTVAL (operands[1]) & 0xff00) == 0))\n+    output_asm_insn (AS2 (mov, %B0, __zero_reg__), operands);\n+  else\n+    {\n+      output_asm_insn (AS2 (ldi, %2, hi8(%1)), operands);\n+      output_asm_insn (AS2 (mov, %B0, %2), operands);\n+    }\n+  if (cnst && ((INTVAL (operands[1]) & 0xff0000) == 0))\n+    output_asm_insn (AS2 (mov, %C0, __zero_reg__), operands);\n+  else\n+    {\n+      output_asm_insn (AS2 (ldi, %2, hlo8(%1)), operands);\n+      output_asm_insn (AS2 (mov, %C0, %2), operands);\n+    }\n+  if (cnst && ((INTVAL (operands[1]) & 0xff000000U) == 0))\n+    output_asm_insn (AS2 (mov, %D0, __zero_reg__), operands);\n+  else\n+    {\n+      output_asm_insn (AS2 (ldi, %2, hhi8(%1)), operands);\n+      output_asm_insn (AS2 (mov, %D0, %2), operands);\n+    }\n+  return \"\";\n+}\n+\n+"}, {"sha": "fa51e5152e77b6a7e493469f5fd49d531eaeb97a", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 125, "deletions": 71, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -56,7 +56,6 @@ extern int target_flags;\n #define MASK_CALL_PROLOGUES\t0x00040000\n #define MASK_TINY_STACK\t\t0x00080000\n #define MASK_PACK_ARGS\t\t0x00100000\n-#define MASK_ENHANCED\t\t0x00200000\n \n #define TARGET_ORDER_1\t\t(target_flags & MASK_ORDER_1)\n #define TARGET_ORDER_2\t\t(target_flags & MASK_ORDER_2)\n@@ -66,7 +65,6 @@ extern int target_flags;\n #define TARGET_CALL_PROLOGUES\t(target_flags & MASK_CALL_PROLOGUES)\n #define TARGET_TINY_STACK\t(target_flags & MASK_TINY_STACK)\n #define TARGET_PACK_ARGS\t(target_flags & MASK_PACK_ARGS)\n-#define TARGET_ENHANCED\t\t(target_flags & MASK_ENHANCED)\n \n /* Dump each assembler insn's rtl into the output file.\n    This is for debugging the compiler itself.  */\n@@ -108,8 +106,6 @@ extern int target_flags;\n     N_(\"Change only the low 8 bits of the stack pointer\") },\t\t\\\n   { \"pack-args\", MASK_PACK_ARGS,\t\t\t\t\t\\\n     N_(\"Do not align function arguments on even numbered registers\") },\t\\\n-  { \"enhanced\", MASK_ENHANCED,\t\t\t\t\t\t\\\n-    N_(\"Generate code for the enhanced AVR core\") },\t\t\t\\\n   { \"rtl\", MASK_RTL_DUMP, NULL },\t\t\t\t\t\\\n   { \"size\", MASK_INSN_SIZE_DUMP,\t\t\t\t\t\\\n     N_(\"Output instruction sizes to the asm file\") },\t\t\t\\\n@@ -137,20 +133,16 @@ extern int target_flags;\n    { \"68000\", -1},     \\\n    { \"\", 1}}  */\n \n-extern const char *avr_ram_end;\n+extern const char *avr_init_stack;\n extern const char *avr_mcu_name;\n+extern int avr_mega_p;\n+extern int avr_enhanced_p;\n \n-struct mcu_type_s {\n-  char * name;\n-  int stack;\n-  int mega;\n- };\n-\n-extern struct mcu_type_s *avr_mcu_type;\n-#define AVR_MEGA (avr_mcu_type->mega)\n+#define AVR_MEGA (avr_mega_p)\n+#define AVR_ENHANCED (avr_enhanced_p)\n \n #define TARGET_OPTIONS {\t\t\t\t\t\t      \\\n- { \"init-stack=\", &avr_ram_end, N_(\"Specify the initial stack address\") },    \\\n+ { \"init-stack=\", &avr_init_stack, N_(\"Specify the initial stack address\") }, \\\n  { \"mcu=\", &avr_mcu_name, N_(\"Specify the MCU name\") } }\n /* This macro is similar to `TARGET_SWITCHES' but defines names of\n    command options that have values.  Its definition is an\n@@ -2246,7 +2238,7 @@ progmem_section (void)\t\t\t\t\t\t\t      \\\n do {\t\t\t\t\t\t\t\t\t   \\\n      fputs (\"\\t.comm \", (STREAM));\t\t\t\t\t   \\\n      assemble_name ((STREAM), (NAME));\t\t\t\t\t   \\\n-     fprintf ((STREAM), \",%d\\n\", (SIZE));\t\t\t\t   \\\n+     fprintf ((STREAM), \",%d,1\\n\", (SIZE));\t\t\t\t   \\\n } while (0)\n /* A C statement (sans semicolon) to output to the stdio stream\n    STREAM the assembler definition of a common-label named NAME whose\n@@ -2459,8 +2451,16 @@ while (0)\n    and after that, output the additional assembler syntax for making\n    that name global, and a newline.  */\n \n-/* `ASM_WEAKEN_LABEL'\n-   A C statement (sans semicolon) to output to the stdio stream\n+#define ASM_WEAKEN_LABEL(FILE, NAME) \t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      fputs (\"\\t.weak\\t\", (FILE));\t\\\n+      assemble_name ((FILE), (NAME)); \t\\\n+      fputc ('\\n', (FILE));\t\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n+\n+/* A C statement (sans semicolon) to output to the stdio stream\n    STREAM some commands that will make the label NAME weak; that is,\n    available for reference from other files but only used if no other\n    definition is available.  Use the expression `assemble_name\n@@ -2470,9 +2470,10 @@ while (0)\n \n    If you don't define this macro, GNU CC will not support weak\n    symbols and you should not define the `SUPPORTS_WEAK' macro.\n+*/\n \n-   `SUPPORTS_WEAK'\n-   A C expression which evaluates to true if the target supports weak\n+#define SUPPORTS_WEAK 1\n+/* A C expression which evaluates to true if the target supports weak\n    symbols.\n \n    If you don't define this macro, `defaults.h' provides a default\n@@ -2919,19 +2920,36 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    the BSD functions `bcopy' and `bzero'.  */\n \n #define CPP_SPEC \"\\\n-%{!mmcu=*:-DAVR_AT90S8515} \\\n-%{mmcu=at90s2313:-DAVR_AT90S2313} \\\n-%{mmcu=at90s2323:-DAVR_AT90S2323} \\\n-%{mmcu=at90s2333:-DAVR_AT90S2333} \\\n-%{mmcu=at90s2343:-DAVR_AT90S2343} \\\n-%{mmcu=attiny22:-DAVR_ATtiny22} \\\n-%{mmcu=at90s4433:-DAVR_AT90S4433} \\\n-%{mmcu=at90s4414:-DAVR_AT90S4414} \\\n-%{mmcu=at90s4434:-DAVR_AT90S4434} \\\n-%{mmcu=at90s8515:-DAVR_AT90S8515} \\\n-%{mmcu=at90s8535:-DAVR_AT90S8535} \\\n-%{mmcu=atmega603:-DAVR_ATmega603} \\\n-%{mmcu=atmega103:-DAVR_ATmega103} \\\n+%{!mmcu*|mmcu=avr2:%(cpp_avr2)} \\\n+%{mmcu=at90s2313:%(cpp_avr2) -D__AVR_AT90S2313__} \\\n+%{mmcu=at90s2323:%(cpp_avr2) -D__AVR_AT90S2323__} \\\n+%{mmcu=at90s2333:%(cpp_avr2) -D__AVR_AT90S2333__} \\\n+%{mmcu=at90s2343:%(cpp_avr2) -D__AVR_AT90S2343__} \\\n+%{mmcu=attiny22: %(cpp_avr2) -D__AVR_ATtiny22__} \\\n+%{mmcu=at90s4433:%(cpp_avr2) -D__AVR_AT90S4433__} \\\n+%{mmcu=at90s4414:%(cpp_avr2) -D__AVR_AT90S4414__} \\\n+%{mmcu=at90s4434:%(cpp_avr2) -D__AVR_AT90S4434__} \\\n+%{mmcu=at90s8515:%(cpp_avr2) -D__AVR_AT90S8515__} \\\n+%{mmcu=at90s8535:%(cpp_avr2) -D__AVR_AT90S8535__} \\\n+%{mmcu=at90c8534:%(cpp_avr2) -D__AVR_AT90C8534__} \\\n+%{mmcu=avr3:%(cpp_avr3)} \\\n+%{mmcu=atmega603:%(cpp_avr3) -D__AVR_ATmega603__} \\\n+%{mmcu=atmega103:%(cpp_avr3) -D__AVR_ATmega103__} \\\n+%{mmcu=avr4:%(cpp_avr4)} \\\n+%{mmcu=atmega83: %(cpp_avr4) -D__AVR_ATmega83__} \\\n+%{mmcu=atmega85: %(cpp_avr4) -D__AVR_ATmega85__} \\\n+%{mmcu=avr5:%(cpp_avr5)} \\\n+%{mmcu=atmega161:%(cpp_avr5) -D__AVR_ATmega161__} \\\n+%{mmcu=atmega163:%(cpp_avr5) -D__AVR_ATmega163__} \\\n+%{mmcu=atmega32: %(cpp_avr5) -D__AVR_ATmega32__} \\\n+%{mmcu=at94k:    %(cpp_avr5) -D__AVR_AT94K__} \\\n+%{mmcu=avr1:%(cpp_avr1)} \\\n+%{mmcu=at90s1200:%(cpp_avr1) -D__AVR_AT90S1200__} \\\n+%{mmcu=attiny10|mmcu=attiny11: %(cpp_avr1) -D__AVR_ATtiny11__} \\\n+%{mmcu=attiny12: %(cpp_avr1) -D__AVR_ATtiny12__} \\\n+%{mmcu=attiny15: %(cpp_avr1) -D__AVR_ATtiny15__} \\\n+%{mmcu=attiny28: %(cpp_avr1) -D__AVR_ATtiny28__} \\\n+%{mno-interrupts:-D__NO_INTERRUPTS__} \\\n %{mint8:-D__SIZE_TYPE__=long\\\\ unsigned\\\\ int -D__PTRDIFF_TYPE__=long -D__INT_MAX__=127} \\\n %{!mint*:-D__SIZE_TYPE__=unsigned\\\\ int -D__PTRDIFF_TYPE__=int -D__INT_MAX__=32767} \\\n %{posix:-D_POSIX_SOURCE}\"\n@@ -2968,14 +2986,14 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    Do not define this macro unless you need to override the default\n    definition.  */\n \n-#define CC1_SPEC \"%{!mmcu*:-mmcu=at90s8515} %{profile:-p}\"\n+#define CC1_SPEC \"%{profile:-p}\"\n /* A C string constant that tells the GNU CC driver program options to\n    pass to `cc1'.  It can also specify how to translate options you\n    give to GNU CC into options for GNU CC to pass to the `cc1'.\n \n    Do not define this macro if it does not need to do anything.  */\n \n-#define ASM_SPEC \"\"\n+#define ASM_SPEC \"%{mmcu=*:-mmcu=%*}\"\n /* A C string constant that tells the GNU CC driver program options to\n    pass to the assembler.  It can also specify how to translate\n    options you give to GNU CC into options for GNU CC to pass to the\n@@ -2995,6 +3013,14 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n %{!mmcu*:-m avr85xx} \\\n %{mmcu=atmega603:-m avrmega603} \\\n %{mmcu=atmega103:-m avrmega103} \\\n+%{mmcu=atmega161:-m avrmega161} \\\n+%{mmcu=atmega163:-m avrmega161} \\\n+%{mmcu=atmega32:-m avr5} \\\n+%{mmcu=at94k:-m avr5} \\\n+%{mmcu=atmega83:-m avr4} \\\n+%{mmcu=atmega85:-m avr4} \\\n+%{mmcu=at90s1200|mmcu=attiny1*:-m avr1200} \\\n+%{mmcu=attiny28:-m avr1} \\\n %{mmcu=at90s2313:-m avr23xx} \\\n %{mmcu=at90s2323:-m avr23xx} \\\n %{mmcu=attiny22:-m avr23xx} \\\n@@ -3003,6 +3029,7 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n %{mmcu=at90s4433:-m avr4433} \\\n %{mmcu=at90s4414:-m avr44x4} \\\n %{mmcu=at90s4434:-m avr44x4} \\\n+%{mmcu=at90c8534:-m avr85xx} \\\n %{mmcu=at90s8535:-m avr85xx} \\\n %{mmcu=at90s8515:-m avr85xx}\"\n \n@@ -3012,19 +3039,17 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n    Do not define this macro if it does not need to do anything.  */\n \n-#define LIB_SPEC \"\\\n-%{!mmcu*|mmcu=at90s*|mmcu=attiny22: -lc} \\\n-%{mmcu=atmega*: -lc-mega}\"\n+#define LIB_SPEC \\\n+  \"%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lc }}}\"\n /* Another C string constant used much like `LINK_SPEC'.  The\n    difference between the two is that `LIB_SPEC' is used at the end\n    of the command given to the linker.\n \n    If this macro is not defined, a default is provided that loads the\n    standard C library from the usual place.  See `gcc.c'.  */\n \n-#define LIBGCC_SPEC \"\\\n-%{mmcu=atmega*:-lgcc} \\\n-%{!mmcu*|mmcu=at90s*|mmcu=attiny22:-lgcc}\"\n+#define LIBGCC_SPEC \\\n+  \"%{!mmcu=at90s1*:%{!mmcu=attiny1*:%{!mmcu=attiny28: -lgcc }}}\"\n /* Another C string constant that tells the GNU CC driver program how\n    and when to place a reference to `libgcc.a' into the linker\n    command line.  This constant is placed both before and after the\n@@ -3050,21 +3075,43 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    Do not define this macro if it does not need to do anything.  */\n \n #define CRT_BINUTILS_SPECS \"\\\n-%{!mmcu*:gcrt1-8515.o%s} \\\n-%{mmcu=atmega603:gcrt1-mega603.o%s} \\\n-%{mmcu=atmega103:gcrt1-mega103.o%s} \\\n-%{mmcu=at90s2313:gcrt1-2313.o%s} \\\n-%{mmcu=at90s2323:gcrt1-2323.o%s} \\\n-%{mmcu=attiny22:gcrt1-tiny22.o%s} \\\n-%{mmcu=at90s2333:gcrt1-2333.o%s} \\\n-%{mmcu=at90s2343:gcrt1-2343.o%s} \\\n-%{mmcu=at90s4433:gcrt1-4433.o%s} \\\n-%{mmcu=at90s4414:gcrt1-4414.o%s} \\\n-%{mmcu=at90s4434:gcrt1-4434.o%s} \\\n-%{mmcu=at90s8535:gcrt1-8535.o%s} \\\n-%{mmcu=at90s8515:gcrt1-8515.o%s}\"\n-\n-#define EXTRA_SPECS\t\t\t\t\\\n+%{mmcu=at90s1200|mmcu=avr1:crts1200.o%s} \\\n+%{mmcu=attiny10|mmcu=attiny11:crttn11.o%s} \\\n+%{mmcu=attiny12:crttn12.o%s} \\\n+%{mmcu=attiny15:crttn15.o%s} \\\n+%{mmcu=attiny28:crttn28.o%s} \\\n+%{!mmcu*|mmcu=at90s8515|mmcu=avr2:crts8515.o%s} \\\n+%{mmcu=at90s2313:crts2313.o%s} \\\n+%{mmcu=at90s2323:crts2323.o%s} \\\n+%{mmcu=attiny22:crttn22.o%s} \\\n+%{mmcu=at90s2333:crts2333.o%s} \\\n+%{mmcu=at90s2343:crts2343.o%s} \\\n+%{mmcu=at90s4433:crts4433.o%s} \\\n+%{mmcu=at90s4414:crts4414.o%s} \\\n+%{mmcu=at90s4434:crts4434.o%s} \\\n+%{mmcu=at90c8534:crtc8534.o%s} \\\n+%{mmcu=at90s8535:crts8535.o%s} \\\n+%{mmcu=atmega103|mmcu=avr3:crtm103.o%s} \\\n+%{mmcu=atmega603:crtm603.o%s} \\\n+%{mmcu=atmega83|mmcu=avr4:crtm83.o%s} \\\n+%{mmcu=atmega85:crtm85.o%s} \\\n+%{mmcu=atmega161|mmcu=avr5:crtm161.o%s} \\\n+%{mmcu=atmega163:crtm163.o%s} \\\n+%{mmcu=atmega32:crtm32.o%s} \\\n+%{mmcu=at94k:crtat94k.o%s}\"\n+\n+#define CPP_AVR1_SPEC \"-D__AVR_ARCH__=1 -D__AVR_ASM_ONLY__ \"\n+#define CPP_AVR2_SPEC \"-D__AVR_ARCH__=2 \"\n+#define CPP_AVR3_SPEC \"-D__AVR_ARCH__=3 -D__AVR_MEGA__ \"\n+#define CPP_AVR4_SPEC \"-D__AVR_ARCH__=4 -D__AVR_ENHANCED__ \"\n+#define CPP_AVR5_SPEC \"-D__AVR_ARCH__=5 -D__AVR_ENHANCED__ -D__AVR_MEGA__ \"\n+\n+#define EXTRA_SPECS                           \\\n+{\"cpp_avr1\", CPP_AVR1_SPEC},                  \\\n+{\"cpp_avr2\", CPP_AVR2_SPEC},                  \\\n+{\"cpp_avr3\", CPP_AVR3_SPEC},                  \\\n+{\"cpp_avr4\", CPP_AVR4_SPEC},                  \\\n+{\"cpp_avr5\", CPP_AVR5_SPEC},                  \\\n {\"crt_binutils\", CRT_BINUTILS_SPECS},\n /* Define this macro to provide additional specifications to put in\n    the `specs' file that can be used in various specifications like\n@@ -3110,6 +3157,9 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n    #undef CPP_SYSV_DEFAULT\n    #define CPP_SYSV_DEFAULT \"-D_CALL_AIX\"  */\n \n+/* This is the default without any -mmcu=* option (AT90S*).  */\n+#define MULTILIB_DEFAULTS { \"mmcu=avr2\" }\n+\n /* This is undefined macro for collect2 disabling */\n #define LINKER_NAME \"ld\"\n \n@@ -3141,50 +3191,50 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n #define INIT_TARGET_OPTABS\t\t\t\t\\\n {\t\t\t\t\t\t\t\\\n   smul_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_mulqi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__mulqi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   sdiv_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_divqi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__divqi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   smod_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_modqi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__modqi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   udiv_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_udivqi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__udivqi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   umod_optab->handlers[(int) QImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_umodqi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__umodqi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   smul_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_mulhi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__mulhi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   sdiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_divhi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__divhi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   smod_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_modhi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__modhi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   udiv_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_udivhi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__udivhi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   umod_optab->handlers[(int) HImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_umodhi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__umodhi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   smul_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_mulsi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__mulsi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   sdiv_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_divsi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__divsi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   smod_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_modsi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__modsi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   udiv_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_udivsi3\");\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__udivsi3\");\t\t\\\n \t\t\t\t\t\t\t\\\n   umod_optab->handlers[(int) SImode].libfunc\t\t\\\n-    = gen_rtx (SYMBOL_REF, Pmode, \"_umodsi3\");\t\t\\\n-  avr_init_once();\t\t\t\t\t\\\n+    = gen_rtx (SYMBOL_REF, Pmode, \"__umodsi3\");\t\t\\\n+  avr_init_once ();\t\t\t\t\t\\\n }\n \n /* Temporary register r0 */\n@@ -3193,8 +3243,12 @@ valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n /* zero register r1 */\n #define ZERO_REGNO 1\n \n+/* Temporary register which used for load immediate values to r0-r15  */\n+#define LDI_REG_REGNO 31\n+\n extern struct rtx_def *tmp_reg_rtx;\n extern struct rtx_def *zero_reg_rtx;\n+extern struct rtx_def *ldi_reg_rtx;\n \n #define TARGET_FLOAT_FORMAT IEEE_FLOAT_FORMAT\n "}, {"sha": "ace4997fd30d58d64bbdb834ba8512bb282ff13f", "filename": "gcc/config/avr/avr.md", "status": "modified", "additions": 131, "deletions": 148, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Favr.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.md?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -136,91 +136,46 @@\n \tpush %A0\"\n   [(set_attr \"length\" \"4\")])\n \n-(define_insn \"*mov_r_sp\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-        (reg:HI 32))]\n-  \"\"\n-  \"in %A0,__SP_L__\n-\tin %B0,__SP_H__\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*mov_sp_r\"\n-  [(set (reg:HI 32)\n-        (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"(!TARGET_TINY_STACK && !TARGET_NO_INTERRUPTS)\"\n-  \"in __tmp_reg__,__SREG__\n-\tcli\n-\tout __SP_H__,%B0\n-\tout __SREG__,__tmp_reg__\n-\tout __SP_L__,%A0\"\n-  [(set_attr \"length\" \"5\")])\n-\n-(define_insn \"*mov_sp_r_no_interrupts\"\n-  [(set (reg:HI 32)\n-        (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"(!TARGET_TINY_STACK && TARGET_NO_INTERRUPTS)\"\n-  \"out __SP_H__,%B0\n-\tout __SP_L__,%A0\"\n-  [(set_attr \"length\" \"2\")])\n-\n-(define_insn \"*mov_sp_r_tiny\"\n-  [(set (reg:HI 32)\n-        (match_operand:HI 0 \"register_operand\" \"r\"))]\n-  \"TARGET_TINY_STACK\"\n-  \"out __SP_L__,%A0\"\n-  [(set_attr \"length\" \"1\")])\n-\n ;;========================================================================\n ;; move byte\n+;; The last alternative (any immediate constant to any register) is\n+;; very expensive.  It should be optimized by peephole2 if a scratch\n+;; register is available, but then that register could just as well be\n+;; allocated for the variable we are loading.  But, most of NO_LD_REGS\n+;; are call-saved registers, and most of LD_REGS are call-used registers,\n+;; so this may still be a win for registers live across function calls.\n+\n (define_expand \"movqi\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"\")\n \t(match_operand:QI 1 \"general_operand\" \"\"))]\n   \"\"\n-  \"\n-{\n-  /* One of the ops has to be in a register */\n-  if (!register_operand(operand0, QImode)\n-      && ! (register_operand(operand1, QImode) || const0_rtx == operand1))\n-    {\n-      operands[1] = copy_to_mode_reg(QImode, operand1);\n-    }\n- }\"); \n+  \"/* One of the ops has to be in a register */\n+   if (!register_operand(operand0, QImode)\n+       && ! (register_operand(operand1, QImode) || const0_rtx == operand1))\n+       operands[1] = copy_to_mode_reg(QImode, operand1);\n+  \")\n \n (define_insn \"*movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,d,Qm,r,q\")\n-\t(match_operand:QI 1 \"general_operand\"      \"r,L,i,rL,Qm,r\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,d,Qm,r,q,r,*r\")\n+\t(match_operand:QI 1 \"general_operand\"       \"r,i,rL,Qm,r,q,i\"))]\n   \"(register_operand (operands[0],QImode)\n     || register_operand (operands[1], QImode) || const0_rtx == operands[1])\"\n-  \"*{\n-    switch (which_alternative)\n-      {\n-      case 0:\n-\treturn AS2 (mov, %0,%1);\n-      case 1:\n-\treturn AS1 (clr, %0);\n-      case 2:\n-\treturn AS2 (ldi, %0,lo8(%1));\n-      case 3:\n-        {\n-          rtx save1=NULL;\n-          if (operands[1] == const0_rtx)\n-            {\n-              save1 = operands[1];\n-              operands[1] = zero_reg_rtx;\n-            }\n-          output_asm_insn (out_movqi_mr_r (insn,operands,NULL), operands);\n-          if (save1)\n-            operands[1] = save1;\n-        }\n-        return \\\"\\\";\n-      case 4:\n-        return out_movqi_r_mr (insn,operands,NULL);\n-      case 5:\n-        return (AS2 (out,%0,%1));\n-      }\n-}\"\n-  [(set_attr \"length\" \"1,1,1,5,5,1\")\n-   (set_attr \"cc\" \"none,clobber,none,clobber,clobber,none\")])\n+  \"* return output_movqi (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"1,1,5,5,1,1,4\")\n+   (set_attr \"cc\" \"none,none,clobber,clobber,none,none,clobber\")])\n+\n+;; This is used in peephole2 to optimize loading immediate constants\n+;; if a scratch register from LD_REGS happens to be available.\n+\n+(define_insn \"*reload_inqi\"\n+  [(set (match_operand:QI 0 \"register_operand\" \"=l\")\n+\t(match_operand:QI 1 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n+  \"\"\n+  \"ldi %2,lo8(%1)\n+\tmov %0,%2\"\n+  [(set_attr \"length\" \"2\")\n+   (set_attr \"cc\" \"none\")])\n \n ;;============================================================================\n ;; move word (16 bit)\n@@ -239,61 +194,35 @@\n     }\n }\")\n \n+\n+(define_peephole2\n+  [(match_scratch:QI 2 \"d\")\n+   (set (match_operand:HI 0 \"register_operand\" \"\")\n+       (match_operand:HI 1 \"immediate_operand\" \"\"))]\n+  \"(operands[1] != const0_rtx\n+    && test_hard_reg_class (NO_LD_REGS, operands[0]))\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; '*' because it is not used in rtl generation, only in above peephole\n+(define_insn \"*reload_inhi\"\n+  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n+        (match_operand:HI 1 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n+  \"\"\n+  \"* return output_reload_inhi (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"cc\" \"none\")])\n+\n (define_insn \"*movhi\"\n-  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,d,r,m\")\n-        (match_operand:HI 1 \"general_operand\"       \"r,L,i,m,rL\"))]\n+  [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,d,*r,q,r\")\n+        (match_operand:HI 1 \"general_operand\"       \"r,m,rL,i,i,r,q\"))]\n   \"(register_operand (operands[0],HImode)\n     || register_operand (operands[1],HImode) || const0_rtx == operands[1])\"\n-  \"*{\n-  rtx link;\n-  switch (which_alternative)\n-    {\n-    case 0: /* mov r,r */\n-      if (TARGET_ENHANCED)\n-\treturn (AS2 (movw,%0,%1));  /* FIXME: length = 2 -> 1 */\n-\n-      if (true_regnum (operands[0]) > true_regnum (operands[1]))\n-        return (AS2 (mov,%B0,%B1) CR_TAB\n-\t        AS2 (mov,%A0,%A1));\n-      else\n-        return (AS2 (mov,%A0,%A1) CR_TAB\n-\t        AS2 (mov,%B0,%B1));\n-    case 1:  /* mov r,L */\n-      return (AS1 (clr,%A0) CR_TAB\n-\t      AS1 (clr,%B0));\n-    case 2: /* ld d,i */\n-      if (operands[1] == const1_rtx\n-          && (link = find_reg_note (insn, REG_WAS_0, 0))\n-\t  /* Make sure the insn that stored the 0 is still present.  */\n-\t  && ! INSN_DELETED_P (XEXP (link, 0))\n-\t  && GET_CODE (XEXP (link, 0)) != NOTE\n-\t  /* Make sure cross jumping didn't happen here.  */\n-\t  && no_labels_between_p (XEXP (link, 0), insn)\n-\t  /* Make sure the reg hasn't been clobbered.  */\n-\t  && ! reg_set_between_p (operands[0], XEXP (link, 0), insn))\n-      /* Fastest way to change a 0 to a 1.  */\n-        return AS1 (inc,%A0 ; reg_was_0);\n-      return (AS2 (ldi,%A0,lo8(%1)) CR_TAB\n-\t      AS2 (ldi,%B0,hi8(%1)));\n-    case 3: /* mov r,m*/\n-      return out_movhi_r_mr (insn, operands, NULL);\n-    case 4: /* mov m,r*/\n-        {\n-          rtx save1 = NULL;\n-          if (operands[1] == const0_rtx)\n-            {\n-              save1 = operands[1];\n-              operands[1] = zero_reg_rtx;\n-            }\n-          output_asm_insn (out_movhi_mr_r (insn,operands,NULL), operands);\n-          if (save1)\n-            operands[1] = save1;\n-        }\n-        return \\\"\\\";\n-    }\n-}\"\n-  [(set_attr \"length\" \"2,2,2,4,4\")\n-   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+  \"* return output_movhi (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"2,4,4,2,6,5,2\")\n+   (set_attr \"cc\" \"none,clobber,clobber,none,clobber,none,none\")])\n \n ;;==========================================================================\n ;; move double word (32 bit)\n@@ -312,14 +241,37 @@\n     }\n }\")\n \n+\n+\n+(define_peephole2\n+  [(match_scratch:QI 2 \"d\")\n+   (set (match_operand:SI 0 \"register_operand\" \"\")\n+       (match_operand:SI 1 \"immediate_operand\" \"\"))]\n+  \"(operands[1] != const0_rtx\n+    && test_hard_reg_class (NO_LD_REGS, operands[0]))\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (clobber (match_dup 2))])]\n+  \"\")\n+\n+;; '*' because it is not used in rtl generation.\n+(define_insn \"*reload_insi\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operand:SI 1 \"immediate_operand\" \"i\"))\n+   (clobber (match_operand:QI 2 \"register_operand\" \"=&d\"))]\n+  \"\"\n+  \"* return output_reload_insisf (insn, operands, NULL);\"\n+  [(set_attr \"length\" \"8\")\n+   (set_attr \"cc\" \"none\")])\n+\n+\n (define_insn \"*movsi\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,d,r,Qm\")\n-        (match_operand:SI 1 \"general_operand\"      \"r,L,i,Qm,rL\"))]\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n+        (match_operand:SI 1 \"general_operand\"       \"r,L,Qm,rL,i,i\"))]\n   \"(register_operand (operands[0],SImode)\n     || register_operand (operands[1],SImode) || const0_rtx == operands[1])\"\n   \"* return output_movsisf (insn, operands, which_alternative);\"\n-  [(set_attr \"length\" \"4,4,4,8,8\")\n-   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+  [(set_attr \"length\" \"4,4,8,8,4,10\")\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n \n ;; fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n ;; move floating point numbers (32 bit)\n@@ -339,13 +291,13 @@\n }\")\n \n (define_insn \"*movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,d,r,Qm\")\n-        (match_operand:SF 1 \"general_operand\"      \"r,G,F,Qm,r\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,r,r,Qm,!d,r\")\n+        (match_operand:SF 1 \"general_operand\"       \"r,G,Qm,r,F,F\"))]\n   \"register_operand (operands[0], SFmode)\n    || register_operand (operands[1], SFmode)\"\n   \"* return output_movsisf (insn, operands, which_alternative);\"\n-  [(set_attr \"length\" \"4,4,4,8,8\")\n-   (set_attr \"cc\" \"none,set_zn,none,clobber,clobber\")])\n+  [(set_attr \"length\" \"4,4,8,8,4,10\")\n+   (set_attr \"cc\" \"none,set_zn,clobber,clobber,clobber,clobber\")])\n \n ;;=========================================================================\n ;; move string (like memcpy)\n@@ -663,7 +615,7 @@\n   [(set (match_operand:QI 0 \"register_operand\" \"=r\")\n \t(mult:QI (match_operand:QI 1 \"register_operand\" \"r\")\n \t\t (match_operand:QI 2 \"register_operand\" \"r\")))]\n-  \"TARGET_ENHANCED\"\n+  \"AVR_ENHANCED\"\n   \"mul %1,%2\n \tmov %0,r0\n \tclr r1\"\n@@ -674,7 +626,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"d\"))\n \t\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"d\"))))]\n-  \"TARGET_ENHANCED\"\n+  \"AVR_ENHANCED\"\n   \"muls %1,%2\n \tmovw %0,r0\n \tclr r1\"\n@@ -685,7 +637,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"r\"))\n \t\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n-  \"TARGET_ENHANCED\"\n+  \"AVR_ENHANCED\"\n   \"mul %1,%2\n \tmovw %0,r0\n \tclr r1\"\n@@ -696,7 +648,7 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=&r\")\n \t(mult:HI (match_operand:HI 1 \"register_operand\" \"r\")\n \t\t (match_operand:HI 2 \"register_operand\" \"r\")))]\n-  \"TARGET_ENHANCED\"\n+  \"AVR_ENHANCED\"\n   \"mul %A1,%A2\n \tmovw %0,r0\n \tmul %A1,%B2\n@@ -1053,15 +1005,26 @@\n   [(set_attr \"length\" \"3,4\")\n    (set_attr \"cc\" \"set_czn,set_n\")])\n \n-(define_insn \"negsi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=!d,r\")\n-\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0,0\")))]\n+(define_insn \"*negsi2\"\n+  [(set (match_operand:SI 0 \"register_operand\"       \"=!d,r,&r\")\n+\t(neg:SI (match_operand:SI 1 \"register_operand\" \"0,0,r\")))]\n   \"\"\n   \"@\n \tcom %D0\\;com %C0\\;com %B0\\;neg %A0\\;sbci %B0,lo8(-1)\\;sbci %C0,lo8(-1)\\;sbci %D0,lo8(-1)\n-\tcom %D0\\;com %C0\\;com %B0\\;neg %A0\\;brcs _PC_+8\\;sec\\;adc %B0,__zero_reg__\\;adc %C0,__zero_reg__\\;adc %D0,__zero_reg__\"\n-  [(set_attr \"length\" \"7,9\")\n-   (set_attr \"cc\" \"set_czn,clobber\")])\n+\tcom %D0\\;com %C0\\;com %B0\\;com %A0\\;adc %A0,%@\\;adc %B0,%@\\;adc %C0,%@\\;adc %D0,%@\n+\tclr %A0\\;clr %B0\\;clr %C0\\;clr %D0\\;sub %A0,%A1\\;sbc %B0,%B1\\;sbc %C0,%C1\\;sbc %D0,%D1\"\n+  [(set_attr \"length\" \"7,8,8\")\n+   (set_attr \"cc\" \"set_czn,set_n,set_czn\")])\n+\n+(define_insn \"negsf2\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=d,r\")\n+\t(neg:SF (match_operand:SF 1 \"register_operand\" \"0,0\")))]\n+  \"\"\n+  \"@\n+\tsubi %D0,0x80\n+\tbst %D0,7\\;com %D0\\;bld %D0,7\\;com %D0\"\n+  [(set_attr \"length\" \"1,4\")\n+   (set_attr \"cc\" \"set_n,set_n\")])\n \n ;; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n ;; not\n@@ -1659,7 +1622,7 @@\n      return \\\"icall\\\";\n   else if (which_alternative==1)\n     {\n-      if (TARGET_ENHANCED)\n+      if (AVR_ENHANCED)\n \treturn (AS2 (movw, r30, %0) CR_TAB\n \t\t\\\"icall\\\");\n       else\n@@ -1695,7 +1658,7 @@\n      return \\\"icall\\\";\n   else if (which_alternative==1)\n     {\n-      if (TARGET_ENHANCED)\n+      if (AVR_ENHANCED)\n \treturn (AS2 (movw, r30, %1) CR_TAB\n \t\t\\\"icall\\\");\n       else\n@@ -1747,7 +1710,7 @@\n \t       (plus:HI (match_operand:HI 0 \"register_operand\" \"=&z\")\n \t\t\t(label_ref (match_operand 2 \"\" \"\")))))\n     (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_ENHANCED\"\n+  \"AVR_ENHANCED\"\n   \"subi r30,lo8(-(%2))\n \tsbci r31,hi8(-(%2))\n \tlpm __tmp_reg__,Z+\n@@ -1970,3 +1933,23 @@\n \t\t      (pc)))]\n   \"jump_over_one_insn_p (insn, operands[1])\"\n   \"sbrc %D0,7\")\n+\n+(define_peephole\n+  [(set (cc0) (match_operand:QI 0 \"register_operand\" \"\"))\n+   (set (pc)\n+\t(if_then_else (eq (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 1 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"jump_over_one_insn_p (insn, operands[1])\"\n+  \"cpse %0,__zero_reg__\")\n+\n+(define_peephole\n+  [(set (cc0)\n+        (compare (match_operand:QI 0 \"register_operand\" \"\")\n+\t\t (match_operand:QI 1 \"register_operand\" \"\")))\n+   (set (pc)\n+\t(if_then_else (eq (cc0) (const_int 0))\n+\t\t      (label_ref (match_operand 2 \"\" \"\"))\n+\t\t      (pc)))]\n+  \"jump_over_one_insn_p (insn, operands[2])\"\n+  \"cpse %0,%1\")"}, {"sha": "dfc76d1dc821f07db15b3bd6577712f27da6e9a8", "filename": "gcc/config/avr/libgcc.S", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Flibgcc.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Flibgcc.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Flibgcc.S?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -621,18 +621,48 @@ __epilogue_restores__:\n \tout\t__SP_H__,r29\n \tout\t__SREG__,__tmp_reg__\n \tout\t__SP_L__,r28\n+#if defined (__AVR_ENHANCED__)\n+\tmovw\tr28, r26\n+#else\n \tmov\tr28,r26\n \tmov\tr29,r27\n+#endif\n \tret\n-#endif /* defined (Lepilogue) */\n+.endfunc\n+#endif /* defined (L_epilogue) */\n \n-#ifdef L__exit\n+#ifdef L_exit\n \t.weak\t_exit\n \t.func\t_exit\n _exit:\n \trjmp\t_exit\n+.endfunc\n+#endif /* defined (L_exit) */\n+\n+#ifdef L_cleanup\n \t.weak\t_cleanup\n+\t.func\t_cleanup\n _cleanup:\n \tret\n .endfunc\n+#endif /* defined (L_cleanup) */\n+\n+#ifdef L_tablejump\n+\t.global __tablejump__\n+\t.func\t__tablejump__\n+__tablejump__:\n+#if defined (__AVR_ENHANCED__)\n+\tlpm\t__tmp_reg__, Z+\n+\tlpm\tr31, Z\n+\tmov\tr30, __tmp_reg__\n+\tijmp\n+#else\n+\tlpm\n+\tpush\tr0\n+\tadiw\tr30, 1\n+\tlpm\n+\tpush\tr0\n+\tret\n+.endfunc\n #endif\n+#endif /* defined (L_tablejump) */"}, {"sha": "7e4d0335170ebc06d19b157d079482d6fdfc4ddf", "filename": "gcc/config/avr/t-avr", "status": "modified", "additions": 36, "deletions": 21, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Ft-avr", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6bec29c9e3ad93042acc8f32db51c10cdd0843e9/gcc%2Fconfig%2Favr%2Ft-avr", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Ft-avr?ref=6bec29c9e3ad93042acc8f32db51c10cdd0843e9", "patch": "@@ -5,31 +5,34 @@ RANLIB_FOR_TARGET = avr-ranlib\n CROSS_LIBGCC1 = libgcc1-asm.a\n LIB1ASMSRC = avr/libgcc.S\n LIB1ASMFUNCS = \\\n-\tmulqi3 \\\n-\tmulhi3 \\\n-\tmulsi3 \\\n-\tumodqi3 \\\n-\tudivqi3 \\\n-\tmodqi3 \\\n-\tdivqi3 \\\n-\tumodhi3 \\\n-\tudivhi3 \\\n-\tmodhi3 \\\n-\tdivhi3 \\\n-\tumodsi3 \\\n-\tudivsi3 \\\n-\tmodsi3 \\\n-\tdivsi3 \\\n-\tprologue \\\n-\tepilogue \\\n-\t__exit\n+\t_mulqi3 \\\n+\t_mulhi3 \\\n+\t_mulsi3 \\\n+\t_umodqi3 \\\n+\t_udivqi3 \\\n+\t_modqi3 \\\n+\t_divqi3 \\\n+\t_umodhi3 \\\n+\t_udivhi3 \\\n+\t_modhi3 \\\n+\t_divhi3 \\\n+\t_umodsi3 \\\n+\t_udivsi3 \\\n+\t_modsi3 \\\n+\t_divsi3 \\\n+\t_prologue \\\n+\t_epilogue \\\n+\t_exit \\\n+\t_cleanup \\\n+\t_tablejump\n \n # libgcc...\n LIBGCC1_TEST =\n \n-# We do not have DF type\n-TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc\n-#LIBGCC2 = $(LIBGCC1)\n+# We do not have the DF type.\n+# Most of the C functions in libgcc2 use almost all registers,\n+# so use -mcall-prologues for smaller code size.\n+TARGET_LIBGCC2_CFLAGS = -DDF=SF -Dinhibit_libc -mcall-prologues\n \n fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/avr/t-avr\n \techo '#define FLOAT' > fp-bit.c\n@@ -44,5 +47,17 @@ fp-bit.c: $(srcdir)/config/fp-bit.c $(srcdir)/config/avr/t-avr\n \n FPBIT = fp-bit.c\n \n+MULTILIB_OPTIONS = mmcu=avr2/mmcu=avr3/mmcu=avr4/mmcu=avr5\n+MULTILIB_DIRNAMES = avr2 avr3 avr4 avr5\n \n+# The many avr2 matches are not listed here - this is the default.\n+MULTILIB_MATCHES = \\\n+\tmmcu?avr3=mmcu?atmega103 mmcu?avr3=mmcu?atmega603 \\\n+\tmmcu?avr4=mmcu?atmega83  mmcu?avr4=mmcu?atmega85  \\\n+\tmmcu?avr5=mmcu?atmega161 mmcu?avr5=mmcu?atmega163 \\\n+\tmmcu?avr5=mmcu?atmega32  mmcu?avr5=mmcu?at94k\n \n+MULTILIB_EXCEPTIONS =\n+\n+LIBGCC = stmp-multilib\n+INSTALL_LIBGCC = install-multilib"}]}