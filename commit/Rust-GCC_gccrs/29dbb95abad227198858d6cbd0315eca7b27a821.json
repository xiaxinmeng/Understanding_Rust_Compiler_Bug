{"sha": "29dbb95abad227198858d6cbd0315eca7b27a821", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjlkYmI5NWFiYWQyMjcxOTg4NThkNmNiZDAzMTVlY2E3YjI3YTgyMQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-18T18:37:57Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2017-01-18T18:37:57Z"}, "message": "gfortran.texi: Add missing parameters to caf-API functions.\n\ngcc/fortran/ChangeLog:\n\n2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n\n\t* gfortran.texi: Add missing parameters to caf-API functions.  Correct\n\ttypos and clarify some descriptions.\n\nAdjusted date of my previous commit.\n\nFrom-SVN: r244589", "tree": {"sha": "b3eaa9b9b1db3bb094d34a65465c0d2ed63bb72c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b3eaa9b9b1db3bb094d34a65465c0d2ed63bb72c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/29dbb95abad227198858d6cbd0315eca7b27a821", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dbb95abad227198858d6cbd0315eca7b27a821", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29dbb95abad227198858d6cbd0315eca7b27a821", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29dbb95abad227198858d6cbd0315eca7b27a821/comments", "author": null, "committer": null, "parents": [{"sha": "2ae27b7076907aa872ffda98c4cb83b3dad30b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2ae27b7076907aa872ffda98c4cb83b3dad30b40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2ae27b7076907aa872ffda98c4cb83b3dad30b40"}], "stats": {"total": 682, "additions": 359, "deletions": 323}, "files": [{"sha": "8bca98852fc62f7e4c9266eede67cc6c28b6663c", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb95abad227198858d6cbd0315eca7b27a821/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb95abad227198858d6cbd0315eca7b27a821/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=29dbb95abad227198858d6cbd0315eca7b27a821", "patch": "@@ -1,4 +1,9 @@\n-2017-01-17  Andre Vehreschild  <vehre@gcc.gnu.org>\n+2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n+\n+\t* gfortran.texi: Add missing parameters to caf-API functions.  Correct\n+\ttypos and clarify some descriptions.\n+\n+2017-01-18  Andre Vehreschild  <vehre@gcc.gnu.org>\n \n \tPR fortran/70696\n \tMissed some cases, here they are:"}, {"sha": "ed9aa93a84290986290bc5b8449e1819a50e5840", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 353, "deletions": 322, "changes": 675, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/29dbb95abad227198858d6cbd0315eca7b27a821/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/29dbb95abad227198858d6cbd0315eca7b27a821/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=29dbb95abad227198858d6cbd0315eca7b27a821", "patch": "@@ -4046,7 +4046,7 @@ descriptor-less arrays.  The library caf_single has untested support for it.\n * _gfortran_caf_num_images:: Querying the maximal number of images\n * _gfortran_caf_register:: Registering coarrays\n * _gfortran_caf_deregister:: Deregistering coarrays\n-* _gfortran_caf_is_present:: Query whether an allocatable component in a derived type coarray is allocated\n+* _gfortran_caf_is_present:: Query whether an allocatable or pointer component in a derived type coarray is allocated\n * _gfortran_caf_send:: Sending data from a local image to a remote image\n * _gfortran_caf_get:: Getting data from a remote image\n * _gfortran_caf_sendget:: Sending data between remote images\n@@ -4084,7 +4084,7 @@ descriptor-less arrays.  The library caf_single has untested support for it.\n This function is called at startup of the program before the Fortran main\n program, if the latter has been compiled with @option{-fcoarray=lib}.\n It takes as arguments the command-line arguments of the program.  It is\n-permitted to pass to @code{NULL} pointers as argument; if non-@code{NULL},\n+permitted to pass two @code{NULL} pointers as argument; if non-@code{NULL},\n the library is permitted to modify the arguments.\n \n @item @emph{Syntax}:\n@@ -4101,7 +4101,7 @@ command-line arguments or @code{NULL}.\n @item @emph{NOTES}\n The function is modelled after the initialization function of the Message\n Passing Interface (MPI) specification.  Due to the way coarray registration\n-works, it might not be the first call to the libaray.  If the main program is\n+works, it might not be the first call to the library.  If the main program is\n not written in Fortran and only a library uses coarrays, it can happen that\n this function is never called.  Therefore, it is recommended that the library\n does not rely on the passed arguments and whether the call has been done.\n@@ -4144,7 +4144,7 @@ This function returns the current image number, which is a positive number.\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{distance} @tab As specified for the @code{this_image} intrinsic\n-in TS18508. Shall be a nonnegative number.\n+in TS18508.  Shall be a non-negative number.\n @end multitable\n \n @item @emph{NOTES}\n@@ -4178,7 +4178,7 @@ Shall be positive.\n \n @item @emph{NOTES}\n This function follows TS18508. If the num_image intrinsic has no arguments,\n-the the compiler passes @code{distance=0} and @code{failed=-1} to the function.\n+then the compiler passes @code{distance=0} and @code{failed=-1} to the function.\n @end table\n \n \n@@ -4208,6 +4208,14 @@ the passed size is the byte size requested.  For @code{CAF_REGTYPE_LOCK_STATIC},\n @code{CAF_REGTYPE_LOCK_ALLOC} and @code{CAF_REGTYPE_CRITICAL} it is the array\n size or one for a scalar.\n \n+When @code{CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY} is used, then only a token\n+for an allocatable or pointer component is created.  The @code{SIZE} parameter\n+is not used then.  On the contrary when\n+@code{CAF_REGTYPE_COARRAY_ALLOC_ALLOCATE_ONLY} is specified, then the\n+@var{token} needs to be registered by a previous call with regtype\n+@code{CAF_REGTYPE_COARRAY_ALLOC_REGISTER_ONLY} and either the memory specified\n+in the @var{desc}'s data-ptr is registered or allocate when the data-ptr is\n+NULL.\n \n @item @emph{Syntax}:\n @code{void caf_register (size_t size, caf_register_t type, caf_token_t *token,\n@@ -4255,11 +4263,11 @@ be no event, e.g. zero.\n \n @table @asis\n @item @emph{Description}:\n-Called to free the memory of a coarray; the processor calls this function for\n-automatic and explicit deallocation.  In case of an error, this function shall\n-fail with an error message, unless the @var{STAT} variable is not null.  The\n-library is only expected to free memory it allocated itself during a call to\n-@code{_gfortran_caf_register}.\n+Called to free or deregister the memory of a coarray; the processor calls this\n+function for automatic and explicit deallocation.  In case of an error, this\n+function shall fail with an error message, unless the @var{STAT} variable is\n+not null.  The library is only expected to free memory it allocated itself\n+during a call to @code{_gfortran_caf_register}.\n \n @item @emph{Syntax}:\n @code{void caf_deregister (caf_token_t *token, caf_deregister_t type,\n@@ -4269,9 +4277,9 @@ int *stat, char *errmsg, int errmsg_len)}\n @multitable @columnfractions .15 .70\n @item @var{token} @tab the token to free.\n @item @var{type} @tab the type of action to take for the coarray.  A\n-@code{CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY} is allowed only for allocatable\n-components of derived type coarrays.  The action only deallocates the local\n-memory without deleting the token.\n+@code{CAF_DEREGTYPE_COARRAY_DEALLOCATE_ONLY} is allowed only for allocatable or\n+pointer components of derived type coarrays.  The action only deallocates the\n+local memory without deleting the token.\n @item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set\n to an error message; may be NULL\n@@ -4286,7 +4294,7 @@ and via destructors.\n \n \n @node _gfortran_caf_is_present\n-@subsection @code{_gfortran_caf_is_present} --- Query whether an allocatable component in a derived type coarray is allocated\n+@subsection @code{_gfortran_caf_is_present} --- Query whether an allocatable or pointer component in a derived type coarray is allocated\n @cindex Coarray, _gfortran_caf_is_present\n \n @table @asis\n@@ -4303,9 +4311,9 @@ gfc_reference_t *ref)}\n @item @var{token} @tab An opaque pointer identifying the coarray.\n @item @var{image_index} @tab The ID of the remote image; must be a positive\n number.\n-@item @var{ref} @tab A chain of references to address the allocatable component\n-in the derived type coarray.  The object reffed needs to be a scalar or a full\n-array ref, respectively.\n+@item @var{ref} @tab A chain of references to address the allocatable or\n+pointer component in the derived type coarray.  The object reference needs to be\n+a scalar or a full array reference, respectively.\n @end multitable\n \n @end table\n@@ -4316,40 +4324,44 @@ array ref, respectively.\n \n @table @asis\n @item @emph{Description}:\n-Called to send a scalar, an array section or whole array from a local\n+Called to send a scalar, an array section or a whole array from a local\n to a remote image identified by the image_index.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_send (caf_token_t token, size_t offset,\n int image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n-gfc_descriptor_t *src, int dst_kind, int src_kind, bool may_require_tmp)}\n+gfc_descriptor_t *src, int dst_kind, int src_kind, bool may_require_tmp,\n+int *stat)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n-@item @var{dest} @tab intent(in) Array descriptor for the remote image for the\n-bounds and the size. The base_addr shall not be accessed.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n+@item @var{dest} @tab intent(in)  Array descriptor for the remote image for the\n+bounds and the size.  The @code{base_addr} shall not be accessed.\n @item @var{dst_vector} @tab intent(in)  If not NULL, it contains the vector\n subscript of the destination array; the values are relative to the dimension\n triplet of the dest argument.\n-@item @var{src} @tab intent(in) Array descriptor of the local array to be\n+@item @var{src} @tab intent(in)  Array descriptor of the local array to be\n transferred to the remote image\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n+@item @var{stat} @tab intent(out) when non-NULL give the result of the\n+operation, i.e., zero on success and non-zero on error.  When NULL and an error\n+occurs, then an error message is printed and the program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_id equal the current image; the memory of the\n-send-to and the send-from might (partially) overlap in that case. The\n+It is permitted to have @var{image_index} equal the current image; the memory\n+of the send-to and the send-from might (partially) overlap in that case.  The\n implementation has to take care that it handles this case, e.g. using\n @code{memmove} which handles (partially) overlapping memory. If\n @var{may_require_tmp} is true, the library might additionally create a\n@@ -4369,40 +4381,44 @@ and different character kinds.\n \n @table @asis\n @item @emph{Description}:\n-Called to get an array section or whole array from a a remote,\n+Called to get an array section or a whole array from a remote,\n image identified by the image_index.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_get (caf_token_t token, size_t offset,\n int image_index, gfc_descriptor_t *src, caf_vector_t *src_vector,\n-gfc_descriptor_t *dest, int src_kind, int dst_kind, bool may_require_tmp)}\n+gfc_descriptor_t *dest, int src_kind, int dst_kind, bool may_require_tmp,\n+int *stat)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n @item @var{dest} @tab intent(out) Array descriptor of the local array to store\n-the data transferred from the remote image\n+the data retrieved from the remote image\n @item @var{src} @tab intent(in) Array descriptor for the remote image for the\n-bounds and the size. The base_addr shall not be accessed.\n+bounds and the size.  The @code{base_addr} shall not be accessed.\n @item @var{src_vector} @tab intent(in)  If not NULL, it contains the vector\n subscript of the source array; the values are relative to the dimension\n-triplet of the src argument.\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n+triplet of the @var{src} argument.\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n+@item @var{stat} @tab intent(out) When non-NULL give the result of the\n+operation, i.e., zero on success and non-zero on error.  When NULL and an error\n+occurs, then an error message is printed and the program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_id equal the current image; the memory of the\n-send-to and the send-from might (partially) overlap in that case. The\n+It is permitted to have @var{image_index} equal the current image; the memory of\n+the send-to and the send-from might (partially) overlap in that case.  The\n implementation has to take care that it handles this case, e.g. using\n @code{memmove} which handles (partially) overlapping memory. If\n @var{may_require_tmp} is true, the library might additionally create a\n@@ -4421,53 +4437,59 @@ padding and different character kinds.\n \n @table @asis\n @item @emph{Description}:\n-Called to send a scalar, an array section or whole array from a remote image\n-identified by the src_image_index to a remote image identified by the\n-dst_image_index.\n+Called to send a scalar, an array section or a whole array from a remote image\n+identified by the @var{src_image_index} to a remote image identified by the\n+@var{dst_image_index}.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n int dst_image_index, gfc_descriptor_t *dest, caf_vector_t *dst_vector,\n caf_token_t src_token, size_t src_offset, int src_image_index,\n gfc_descriptor_t *src, caf_vector_t *src_vector, int dst_kind, int src_kind,\n-bool may_require_tmp)}\n+bool may_require_tmp, int *stat)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{dst_token} @tab intent(in)  An opaque pointer identifying the\n destination coarray.\n-@item @var{dst_offset} @tab  By which amount of bytes the actual data is\n-shifted compared to the base address of the destination coarray.\n-@item @var{dst_image_index} @tab The ID of the destination remote image; must\n-be a positive number.\n+@item @var{dst_offset} @tab intent(in)  By which amount of bytes the actual data\n+is shifted compared to the base address of the destination coarray.\n+@item @var{dst_image_index} @tab intent(in)  The ID of the destination remote\n+image; must be a positive number.\n @item @var{dest} @tab intent(in) Array descriptor for the destination\n-remote image for the bounds and the size. The base_addr shall not be accessed.\n+remote image for the bounds and the size.  The @code{base_addr} shall not be\n+accessed.\n @item @var{dst_vector} @tab intent(int)  If not NULL, it contains the vector\n subscript of the destination array; the values are relative to the dimension\n-triplet of the dest argument.\n-@item @var{src_token} @tab An opaque pointer identifying the source coarray.\n-@item @var{src_offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the source coarray.\n-@item @var{src_image_index} @tab The ID of the source remote image; must be a\n-positive number.\n+triplet of the @var{dest} argument.\n+@item @var{src_token} @tab intent(in)  An opaque pointer identifying the source\n+coarray.\n+@item @var{src_offset} @tab intent(in)  By which amount of bytes the actual data\n+is shifted compared to the base address of the source coarray.\n+@item @var{src_image_index} @tab intent(in)  The ID of the source remote image;\n+must be a positive number.\n @item @var{src} @tab intent(in) Array descriptor of the local array to be\n transferred to the remote image.\n @item @var{src_vector} @tab intent(in) Array descriptor of the local array to\n be transferred to the remote image\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n+@item @var{stat} @tab intent(out) when non-NULL give the result of the\n+operation, i.e., zero on success and non-zero on error.  When NULL and an error\n+occurs, then an error message is printed and the program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_ids equal; the memory of the send-to and the\n-send-from might (partially) overlap in that case. The implementation has to\n-take care that it handles this case, e.g. using @code{memmove} which handles\n-(partially) overlapping memory. If @var{may_require_tmp} is true, the library\n+It is permitted to have the same image index for both @var{src_image_index} and\n+@var{dst_image_index}; the memory of the send-to and the send-from might\n+(partially) overlap in that case.  The implementation has to take care that it\n+handles this case, e.g. using @code{memmove} which handles (partially)\n+overlapping memory.  If @var{may_require_tmp} is true, the library\n might additionally create a temporary variable, unless additional checks show\n that this is not required (e.g. because walking backward is possible or because\n both arrays are contiguous and @code{memmove} takes care of overlap issues).\n@@ -4483,8 +4505,8 @@ different character kinds.\n \n @table @asis\n @item @emph{Description}:\n-Called to send a scalar, an array section or whole array from a local to a\n-remote image identified by the image_index.\n+Called to send a scalar, an array section or a whole array from a local to a\n+remote image identified by the @var{image_index}.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_send_by_ref (caf_token_t token, int image_index,\n@@ -4494,30 +4516,30 @@ bool may_require_tmp, bool dst_reallocatable, int *stat)}\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n @item @var{src} @tab intent(in) Array descriptor of the local array to be\n transferred to the remote image\n-@item @var{refs} @tab intent(in) the references on the remote array to store\n+@item @var{refs} @tab intent(in) The references on the remote array to store\n the data given by src.  Guaranteed to have at least one entry.\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n-@item @var{dst_reallocatable} @tab set when the destination is of allocatable\n-or pointer type and the refs will allow reallocation, i.e., the ref is a full\n-array or component ref.\n-@item @var{stat} @tab intent(out) when non-@code{NULL} give the result of the\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n+@item @var{dst_reallocatable} @tab intent(in)  Set when the destination is of\n+allocatable or pointer type and the refs will allow reallocation, i.e., the ref\n+is a full array or component ref.\n+@item @var{stat} @tab intent(out) When non-@code{NULL} give the result of the\n operation, i.e., zero on success and non-zero on error.  When @code{NULL} and\n-error occurs, then an error message is printed and the program is terminated.\n+an error occurs, then an error message is printed and the program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_id equal the current image; the memory of the\n-send-to and the send-from might (partially) overlap in that case.  The\n+It is permitted to have @var{image_index} equal the current image; the memory of\n+the send-to and the send-from might (partially) overlap in that case.  The\n implementation has to take care that it handles this case, e.g. using\n @code{memmove} which handles (partially) overlapping memory.  If\n @var{may_require_tmp} is true, the library might additionally create a\n@@ -4541,8 +4563,8 @@ error message why the operation is not permitted.\n \n @table @asis\n @item @emph{Description}:\n-Called to get a scalar, an array section or whole array from a a remote image\n-identified by the image_index.\n+Called to get a scalar, an array section or a whole array from a remote image\n+identified by the @var{image_index}.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_get_by_ref (caf_token_t token, int image_index,\n@@ -4552,31 +4574,31 @@ bool may_require_tmp, bool dst_reallocatable, int *stat)}\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n @item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n-@item @var{refs} @tab intent(in) the references to apply to the remote structure\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n+@item @var{refs} @tab intent(in) The references to apply to the remote structure\n to get the data.\n @item @var{dst} @tab intent(in) Array descriptor of the local array to store\n the data transferred from the remote image.  May be reallocated where needed\n and when @var{DST_REALLOCATABLE} allows it.\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n-@item @var{dst_reallocatable} @tab set when @var{DST} is of allocatable\n-or pointer type and its refs allow reallocation, i.e., the full array or a\n-component is referenced.\n-@item @var{stat} @tab intent(out) when non-@code{NULL} give the result of the\n-operation, i.e., zero on success and non-zero on error.  When @code{NULL} and\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n+@item @var{dst_reallocatable} @tab intent(in)  Set when @var{DST} is of\n+allocatable or pointer type and its refs allow reallocation, i.e., the full\n+array or a component is referenced.\n+@item @var{stat} @tab intent(out) When non-@code{NULL} give the result of the\n+operation, i.e., zero on success and non-zero on error.  When @code{NULL} and an\n error occurs, then an error message is printed and the program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_id equal the current image; the memory of the\n-send-to and the send-from might (partially) overlap in that case.  The\n+It is permitted to have @code{image_index} equal the current image; the memory\n+of the send-to and the send-from might (partially) overlap in that case.  The\n implementation has to take care that it handles this case, e.g. using\n @code{memmove} which handles (partially) overlapping memory.  If\n @var{may_require_tmp} is true, the library might additionally create a\n@@ -4599,9 +4621,9 @@ error message why the operation is not permitted.\n \n @table @asis\n @item @emph{Description}:\n-Called to send a scalar, an array section or whole array from a remote image\n-identified by the src_image_index to a remote image identified by the\n-dst_image_index.\n+Called to send a scalar, an array section or a whole array from a remote image\n+identified by the @var{src_image_index} to a remote image identified by the\n+@var{dst_image_index}.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_sendget_by_ref (caf_token_t dst_token,\n@@ -4613,37 +4635,39 @@ int dst_kind, int src_kind, bool may_require_tmp, int *dst_stat, int *src_stat)}\n @multitable @columnfractions .15 .70\n @item @var{dst_token} @tab intent(in)  An opaque pointer identifying the\n destination coarray.\n-@item @var{dst_image_index} @tab The ID of the destination remote image; must\n-be a positive number.\n-@item @var{dst_refs} @tab intent(in) the references on the remote array to store\n-the data given by src.  Guaranteed to have at least one entry.\n-@item @var{src_token} @tab An opaque pointer identifying the source coarray.\n-@item @var{src_image_index} @tab The ID of the source remote image; must be a\n-positive number.\n-@item @var{src_refs} @tab intent(in) the references to apply to the remote\n+@item @var{dst_image_index} @tab intent(in)  The ID of the destination remote\n+image; must be a positive number.\n+@item @var{dst_refs} @tab intent(in) The references on the remote array to store\n+the data given by the source.  Guaranteed to have at least one entry.\n+@item @var{src_token} @tab intent(in)  An opaque pointer identifying the source\n+coarray.\n+@item @var{src_image_index} @tab intent(in)  The ID of the source remote image;\n+must be a positive number.\n+@item @var{src_refs} @tab intent(in) The references to apply to the remote\n structure to get the data.\n-@item @var{dst_kind} @tab Kind of the destination argument\n-@item @var{src_kind} @tab Kind of the source argument\n-@item @var{may_require_tmp} @tab The variable is false it is known at compile\n-time that the @var{dest} and @var{src} either cannot overlap or overlap (fully\n-or partially) such that walking @var{src} and @var{dest} in element wise\n-element order (honoring the stride value) will not lead to wrong results.\n-Otherwise, the value is true.\n+@item @var{dst_kind} @tab intent(in)  Kind of the destination argument\n+@item @var{src_kind} @tab intent(in)  Kind of the source argument\n+@item @var{may_require_tmp} @tab intent(in)  The variable is @code{false} when\n+it is known at compile time that the @var{dest} and @var{src} either cannot\n+overlap or overlap (fully or partially) such that walking @var{src} and\n+@var{dest} in element wise element order (honoring the stride value) will not\n+lead to wrong results.  Otherwise, the value is @code{true}.\n @item @var{dst_stat} @tab intent(out) when non-@code{NULL} give the result of\n the send-operation, i.e., zero on success and non-zero on error.  When\n @code{NULL} and an error occurs, then an error message is printed and the\n program is terminated.\n-@item @var{src_stat} @tab intent(out) when non-@code{NULL} give the result of\n+@item @var{src_stat} @tab intent(out) When non-@code{NULL} give the result of\n the get-operation, i.e., zero on success and non-zero on error.  When\n @code{NULL} and an error occurs, then an error message is printed and the\n program is terminated.\n @end multitable\n \n @item @emph{NOTES}\n-It is permitted to have image_ids equal; the memory of the send-to and the\n-send-from might (partially) overlap in that case.  The implementation has to\n-take care that it handles this case, e.g. using @code{memmove} which handles\n-(partially) overlapping memory.  If @var{may_require_tmp} is true, the library\n+It is permitted to have the same image index for both @var{src_image_index} and\n+@var{dst_image_index}; the memory of the send-to and the send-from might\n+(partially) overlap in that case.  The implementation has to take care that it\n+handles this case, e.g. using @code{memmove} which handles (partially)\n+overlapping memory.  If @var{may_require_tmp} is true, the library\n might additionally create a temporary variable, unless additional checks show\n that this is not required (e.g. because walking backward is possible or because\n both arrays are contiguous and @code{memmove} takes care of overlap issues).\n@@ -4665,29 +4689,29 @@ error message why the operation is not permitted.\n @table @asis\n @item @emph{Description}:\n Acquire a lock on the given image on a scalar locking variable or for the\n-given array element for an array-valued variable. If the @var{aquired_lock}\n-is @code{NULL}, the function return after having obtained the lock. If it is\n-nonnull, the result is is assigned the value true (one) when the lock could be\n-obtained and false (zero) otherwise.  Locking a lock variable which has already\n-been locked by the same image is an error.\n+given array element for an array-valued variable.  If the @var{aquired_lock}\n+is @code{NULL}, the function returns after having obtained the lock.  If it is\n+non-@code{NULL}, then @var{acquired_lock} is assigned the value true (one) when\n+the lock could be obtained and false (zero) otherwise.  Locking a lock variable\n+which has already been locked by the same image is an error.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_lock (caf_token_t token, size_t index, int image_index,\n int *aquired_lock, int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n-always 0.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{index} @tab intent(in)  Array index; first array index is 0.  For\n+scalars, it is always 0.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n @item @var{aquired_lock} @tab intent(out) If not NULL, it returns whether lock\n-could be obtained\n-@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n+could be obtained.\n+@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n@@ -4712,16 +4736,16 @@ int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n-always 0.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number.\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{index} @tab intent(in)  Array index; first array index is 0.  For\n+scalars, it is always 0.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number.\n @item @var{stat} @tab intent(out) For allocatable coarrays, stores the STAT=;\n-may be NULL\n+may be NULL.\n @item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n@@ -4744,22 +4768,22 @@ int image_index, int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n-always 0.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when accessed noncoindexed.\n-@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{index} @tab intent(in)  Array index; first array index is 0.  For\n+scalars, it is always 0.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image, when accessed noncoindexed.\n+@item @var{stat} @tab intent(out)  Stores the STAT=; may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n This acts like an atomic add of one to the remote image's event variable.\n The statement is an image-control statement but does not imply sync memory.\n Still, all preceeding push communications of this image to the specified\n-remote image has to be completed before @code{event_wait} on the remote\n+remote image have to be completed before @code{event_wait} on the remote\n image returns.\n @end table\n \n@@ -4781,15 +4805,15 @@ int until_count, int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n-always 0.\n-@item @var{until_count} @tab The number of events which have to be available\n-before the function returns.\n-@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{index} @tab intent(in)  Array index; first array index is 0.  For\n+scalars, it is always 0.\n+@item @var{until_count} @tab intent(in)  The number of events which have to be\n+available before the function returns.\n+@item @var{stat} @tab intent(out)  Stores the STAT=; may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n@@ -4799,12 +4823,13 @@ or equal the requested number of counts. Before the function returns, the\n event variable has to be decremented by the requested @var{until_count} value.\n A possible implementation would be a busy loop for a certain number of spins\n (possibly depending on the number of threads relative to the number of available\n-cores) followed by other waiting strategy such as a sleeping wait (possibly with\n-an increasing number of sleep time) or, if possible, a futex wait.\n+cores) followed by another waiting strategy such as a sleeping wait (possibly\n+with an increasing number of sleep time) or, if possible, a futex wait.\n \n The statement is an image-control statement but does not imply sync memory.\n-Still, all preceeding push communications to this image of images having\n-issued a @code{event_push} have to be completed before this function returns.\n+Still, all preceeding push communications of this image to the specified\n+remote image have to be completed before @code{event_wait} on the remote\n+image returns.\n @end table\n \n \n@@ -4815,31 +4840,33 @@ issued a @code{event_push} have to be completed before this function returns.\n \n @table @asis\n @item @emph{Description}:\n-Return the event count of the specified event count.\n+Return the event count of the specified event variable.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_event_query (caf_token_t token, size_t index,\n int image_index, int *count, int *stat)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{index} @tab Array index; first array index is 0. For scalars, it is\n-always 0.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when accessed noncoindexed.\n-@item @var{count} @tab intent(out) The number of events currently posted to\n-the event variable\n-@item @var{stat} @tab intent(out) Stores the STAT=; may be NULL\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{index} @tab intent(in)  Array index; first array index is 0.  For\n+scalars, it is always 0.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image when accessed noncoindexed.\n+@item @var{count} @tab intent(out)  The number of events currently posted to\n+the event variable.\n+@item @var{stat} @tab intent(out)  Stores the STAT=; may be NULL.\n @end multitable\n \n @item @emph{NOTES}\n-The typical use is to check the local even variable to only call\n+The typical use is to check the local event variable to only call\n @code{event_wait} when the data is available. However, a coindexed variable\n is permitted; there is no ordering or synchronization implied.  It acts like\n an atomic fetch of the value of the event variable.\n @end table\n \n+\n+\n @node _gfortran_caf_sync_all\n @subsection @code{_gfortran_caf_sync_all} --- All-image barrier\n @cindex Coarray, _gfortran_caf_sync_all\n@@ -4856,10 +4883,10 @@ previous segment have completed.\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n @end table\n \n@@ -4875,24 +4902,24 @@ Synchronization between the specified images; the program only continues on a\n given image after this function has been called on all images specified for\n that image. Note that one image can wait for all other images in the current\n team (e.g. via @code{sync images(*)}) while those only wait for that specific\n-image.  Additionally, @code{sync images} it ensures that all pending data\n-transfers of previous segment have completed.\n+image.  Additionally, @code{sync images} ensures that all pending data\n+transfers of previous segments have completed.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_sync_images (int count, int images[], int *stat,\n char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{count} @tab the number of images which are provided in the next\n-argument.  For a zero-sized array, the value is zero.  For @code{sync\n-images (*)}, the value is @math{-1}.\n-@item @var{images} @tab intent(in) an array with the images provided by the\n-user. If @var{count} is zero, a NULL pointer is passed.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{count} @tab intent(in)  The number of images which are provided in\n+the next argument.  For a zero-sized array, the value is zero.  For\n+@code{sync images (*)}, the value is @math{-1}.\n+@item @var{images} @tab intent(in)  An array with the images provided by the\n+user.  If @var{count} is zero, a NULL pointer is passed.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n @end table\n \n@@ -4912,10 +4939,10 @@ all pending memory operations of this image have been completed.\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTE} A simple implementation could be\n@@ -4939,7 +4966,7 @@ function should terminate the program with the specified exit code.\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{error} @tab the exit status to be used.\n+@item @var{error} @tab intent(in)  The exit status to be used.\n @end multitable\n @end table\n \n@@ -4959,8 +4986,8 @@ function should terminate the program with a nonzero-exit code.\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{string} @tab the error message (not zero terminated)\n-@item @var{len} @tab the length of the string\n+@item @var{string} @tab intent(in)  the error message (not zero terminated)\n+@item @var{len} @tab intent(in)  the length of the string\n @end multitable\n @end table\n \n@@ -4980,16 +5007,16 @@ int image_index, void *value, int *stat, int type, int kind)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when used noncoindexed.\n-@item @var{value} @tab intent(in) the value to be assigned, passed by reference.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image when used noncoindexed.\n+@item @var{value} @tab intent(in)  the value to be assigned, passed by reference\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{type} @tab intent(in)  The data type, i.e. @code{BT_INTEGER} (1) or\n @code{BT_LOGICAL} (2).\n-@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@item @var{kind} @tab intent(in)  The kind value (only 4; always @code{int})\n @end multitable\n @end table\n \n@@ -5007,15 +5034,14 @@ Reference atomically a value of a kind-4 integer or logical variable.\n @code{void _gfortran_caf_atomic_ref (caf_token_t token, size_t offset,\n int image_index, void *value, int *stat, int type, int kind)}\n \n-@item @emph{Arguments}:\n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when used noncoindexed.\n-@item @var{value} @tab intent(out) The variable assigned the atomically\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image when used noncoindexed.\n+@item @var{value} @tab intent(out)  The variable assigned the atomically\n referenced variable.\n @item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n @item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n@@ -5043,21 +5069,21 @@ int type, int kind)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when used noncoindexed.\n-@item @var{old} @tab intent(out) the value which the atomic variable had\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image when used noncoindexed.\n+@item @var{old} @tab intent(out)  The value which the atomic variable had\n just before the cas operation.\n-@item @var{compare} @tab intent(in) The value used for comparision.\n-@item @var{new_val} @tab intent(in) The new value for the atomic variable,\n+@item @var{compare} @tab intent(in)  The value used for comparision.\n+@item @var{new_val} @tab intent(in)  The new value for the atomic variable,\n assigned to the atomic variable, if @code{compare} equals the value of the\n atomic variable.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{type} @tab intent(in)  the data type, i.e. @code{BT_INTEGER} (1) or\n @code{BT_LOGICAL} (2).\n-@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@item @var{kind} @tab intent(in)  The kind value (only 4; always @code{int})\n @end multitable\n @end table\n \n@@ -5072,7 +5098,7 @@ atomic variable.\n Apply an operation atomically to an atomic integer or logical variable.\n After the operation, @var{old} contains the value just before the operation,\n which, respectively, adds (GFC_CAF_ATOMIC_ADD) atomically the @code{value} to\n-the atomic integer variable or does a bitwise AND, OR or exclusive OR of the\n+the atomic integer variable or does a bitwise AND, OR or exclusive OR\n between the atomic variable and @var{value}; the result is then stored in the\n atomic variable.\n \n@@ -5082,23 +5108,23 @@ int image_index, void *value, void *old, int *stat, int type, int kind)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{op} @tab the operation to be performed; possible values\n+@item @var{op} @tab intent(in)  the operation to be performed; possible values\n @code{GFC_CAF_ATOMIC_ADD} (1), @code{GFC_CAF_ATOMIC_AND} (2),\n @code{GFC_CAF_ATOMIC_OR} (3), @code{GFC_CAF_ATOMIC_XOR} (4).\n-@item @var{token} @tab intent(in) An opaque pointer identifying the coarray.\n-@item @var{offset} @tab By which amount of bytes the actual data is shifted\n-compared to the base address of the coarray.\n-@item @var{image_index} @tab The ID of the remote image; must be a positive\n-number; zero indicates the current image when used noncoindexed.\n-@item @var{old} @tab intent(out) the value which the atomic variable had\n+@item @var{token} @tab intent(in)  An opaque pointer identifying the coarray.\n+@item @var{offset} @tab intent(in)  By which amount of bytes the actual data is\n+shifted compared to the base address of the coarray.\n+@item @var{image_index} @tab intent(in)  The ID of the remote image; must be a\n+positive number; zero indicates the current image when used noncoindexed.\n+@item @var{old} @tab intent(out)  The value which the atomic variable had\n just before the atomic operation.\n-@item @var{val} @tab intent(in) The new value for the atomic variable,\n+@item @var{val} @tab intent(in)  The new value for the atomic variable,\n assigned to the atomic variable, if @code{compare} equals the value of the\n atomic variable.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{type} @tab the data type, i.e. @code{BT_INTEGER} (1) or\n-@code{BT_LOGICAL} (2).\n-@item @var{kind} @tab The kind value (only 4; always @code{int})\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{type} @tab intent(in)  the data type, i.e. @code{BT_INTEGER} (1) or\n+@code{BT_LOGICAL} (2)\n+@item @var{kind} @tab intent(in)  the kind value (only 4; always @code{int})\n @end multitable\n @end table\n \n@@ -5120,14 +5146,14 @@ int source_image, int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{a} @tab intent(inout) And array descriptor with the data to be\n-breoadcasted (on @var{source_image}) or to be received (other images).\n-@item @var{source_image} @tab The ID of the image from which the data should\n-be taken.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{a} @tab intent(inout)  An array descriptor with the data to be\n+broadcasted (on @var{source_image}) or to be received (other images).\n+@item @var{source_image} @tab intent(in)  The ID of the image from which the\n+data should be broadcasted.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg.\n @end multitable\n @end table\n \n@@ -5139,7 +5165,7 @@ an error message; may be NULL\n \n @table @asis\n @item @emph{Description}:\n-Calculates the for the each array element of the variable @var{a} the maximum\n+Calculates for each array element of the variable @var{a} the maximum\n value for that element in the current team; if @var{result_image} has the\n value 0, the result shall be stored on all images, otherwise, only on the\n specified image. This function operates on numeric values and character\n@@ -5151,20 +5177,21 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{a} @tab intent(inout) And array descriptor with the data to be\n-breoadcasted (on @var{source_image}) or to be received (other images).\n-@item @var{result_image} @tab The ID of the image to which the reduced\n-value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{a_len} @tab The string length of argument @var{a}.\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{a} @tab intent(inout)  An array descriptor for the data to be\n+processed.  On the destination image(s) the result overwrites the old content.\n+@item @var{result_image} @tab intent(in)  The ID of the image to which the\n+reduced value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{a_len} @tab intent(in)  the string length of argument @var{a}\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n-If @var{result_image} is nonzero, the value on all images except of the\n-specified one become undefined; hence, the library may make use of this.\n+If @var{result_image} is nonzero, the data in the array descriptor @var{a} on\n+all images except of the specified one become undefined; hence, the library may\n+make use of this.\n @end table\n \n \n@@ -5175,7 +5202,7 @@ specified one become undefined; hence, the library may make use of this.\n \n @table @asis\n @item @emph{Description}:\n-Calculates the for the each array element of the variable @var{a} the minimum\n+Calculates for each array element of the variable @var{a} the minimum\n value for that element in the current team; if @var{result_image} has the\n value 0, the result shall be stored on all images, otherwise, only on the\n specified image. This function operates on numeric values and character\n@@ -5187,20 +5214,21 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{a} @tab intent(inout) And array descriptor with the data to be\n-breoadcasted (on @var{source_image}) or to be received (other images).\n-@item @var{result_image} @tab The ID of the image to which the reduced\n-value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{a_len} @tab The string length of argument @var{a}.\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{a} @tab intent(inout)  An array descriptor for the data to be\n+processed.  On the destination image(s) the result overwrites the old content.\n+@item @var{result_image} @tab intent(in)  The ID of the image to which the\n+reduced value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{a_len} @tab intent(in)  the string length of argument @var{a}\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n-If @var{result_image} is nonzero, the value on all images except of the\n-specified one become undefined; hence, the library may make use of this.\n+If @var{result_image} is nonzero, the data in the array descriptor @var{a} on\n+all images except of the specified one become undefined; hence, the library may\n+make use of this.\n @end table\n \n \n@@ -5211,30 +5239,31 @@ specified one become undefined; hence, the library may make use of this.\n \n @table @asis\n @item @emph{Description}:\n-Calculates the for the each array element of the variable @var{a} the sum\n-value for that element in the current team; if @var{result_image} has the\n+Calculates for each array element of the variable @var{a} the sum of all\n+values for that element in the current team; if @var{result_image} has the\n value 0, the result shall be stored on all images, otherwise, only on the\n-specified image. This function operates on numeric values.\n+specified image.  This function operates on numeric values only.\n \n @item @emph{Syntax}:\n @code{void _gfortran_caf_co_sum (gfc_descriptor_t *a, int result_image,\n int *stat, char *errmsg, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{a} @tab intent(inout) And array descriptor with the data to be\n-breoadcasted (on @var{source_image}) or to be received (other images).\n-@item @var{result_image} @tab The ID of the image to which the reduced\n-value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{a} @tab intent(inout)  An array descriptor with the data to be\n+processed.  On the destination image(s) the result overwrites the old content.\n+@item @var{result_image} @tab intent(in)  The ID of the image to which the\n+reduced value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n-If @var{result_image} is nonzero, the value on all images except of the\n-specified one become undefined; hence, the library may make use of this.\n+If @var{result_image} is nonzero, the data in the array descriptor @var{a} on\n+all images except of the specified one become undefined; hence, the library may\n+make use of this.\n @end table\n \n \n@@ -5245,16 +5274,16 @@ specified one become undefined; hence, the library may make use of this.\n \n @table @asis\n @item @emph{Description}:\n-Calculates the for the each array element of the variable @var{a} the reduction\n+Calculates for each array element of the variable @var{a} the reduction\n value for that element in the current team; if @var{result_image} has the\n value 0, the result shall be stored on all images, otherwise, only on the\n-specified image. The @var{opr} is a pure function doing a mathematically\n+specified image.  The @var{opr} is a pure function doing a mathematically\n commutative and associative operation.\n \n The @var{opr_flags} denote the following; the values are bitwise ored.\n @code{GFC_CAF_BYREF} (1) if the result should be returned\n-by value; @code{GFC_CAF_HIDDENLEN} (2) whether the result and argument\n-string lengths shall be specified as hidden argument;\n+by reference; @code{GFC_CAF_HIDDENLEN} (2) whether the result and argument\n+string lengths shall be specified as hidden arguments;\n @code{GFC_CAF_ARG_VALUE} (4) whether the arguments shall be passed by value,\n @code{GFC_CAF_ARG_DESC} (8) whether the arguments shall be passed by descriptor.\n \n@@ -5266,27 +5295,29 @@ int *stat, char *errmsg, int a_len, int errmsg_len)}\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{opr} @tab Function pointer to the reduction function.\n-@item @var{opr_flags} @tab Flags regarding the reduction function\n-@item @var{a} @tab intent(inout) And array descriptor with the data to be\n-breoadcasted (on @var{source_image}) or to be received (other images).\n-@item @var{result_image} @tab The ID of the image to which the reduced\n-value should be copied to; if zero, it has to be copied to all images.\n-@item @var{stat} @tab intent(out) Stores the status STAT= and may be NULL.\n-@item @var{errmsg} @tab intent(out) When an error occurs, this will be set to\n-an error message; may be NULL\n-@item @var{a_len} @tab The string length of argument @var{a}.\n-@item @var{errmsg_len} @tab the buffer size of errmsg.\n+@item @var{a} @tab intent(inout)  An array descriptor with the data to be\n+processed.  On the destination image(s) the result overwrites the old content.\n+@item @var{opr} @tab intent(in)  Function pointer to the reduction function\n+@item @var{opr_flags} @tab intent(in)  Flags regarding the reduction function\n+@item @var{result_image} @tab intent(in)  The ID of the image to which the\n+reduced value should be copied to; if zero, it has to be copied to all images.\n+@item @var{stat} @tab intent(out)  Stores the status STAT= and may be NULL.\n+@item @var{errmsg} @tab intent(out)  When an error occurs, this will be set to\n+an error message; may be NULL.\n+@item @var{a_len} @tab intent(in)  the string length of argument @var{a}\n+@item @var{errmsg_len} @tab intent(in)  the buffer size of errmsg\n @end multitable\n \n @item @emph{NOTES}\n-If @var{result_image} is nonzero, the value on all images except of the\n-specified one become undefined; hence, the library may make use of this.\n+If @var{result_image} is nonzero, the data in the array descriptor @var{a} on\n+all images except of the specified one become undefined; hence, the library may\n+make use of this.\n+\n For character arguments, the result is passed as first argument, followed\n by the result string length, next come the two string arguments, followed\n-by the two hidden arguments. With C binding, there are no hidden arguments\n-and by-reference passing and either only a single character is passed or\n-an array descriptor.\n+by the two hidden string length arguments.  With C binding, there are no hidden\n+arguments and by-reference passing and either only a single character is passed\n+or an array descriptor.\n @end table\n \n "}]}