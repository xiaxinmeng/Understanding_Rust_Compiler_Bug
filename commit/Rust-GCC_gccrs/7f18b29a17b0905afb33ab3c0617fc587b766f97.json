{"sha": "7f18b29a17b0905afb33ab3c0617fc587b766f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2YxOGIyOWExN2IwOTA1YWZiMzNhYjNjMDYxN2ZjNTg3Yjc2NmY5Nw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T12:58:01Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2013-04-12T12:58:01Z"}, "message": "[multiple changes]\n\n2013-04-12  Robert Dewar  <dewar@adacore.com>\n\n\t* opt.ads (Style_Check_Main): New switch.\n\t* sem.adb (Semantics): Set Style_Check flag properly for new\n\tunit to be analyzed.\n\t* sem_ch10.adb (Analyze_With_Clause): Don't reset Style_Check,\n\tthe proper setting of this flag is now part of the Semantics\n\tprocedure.\n\t* switch-c.adb (Scan_Front_End_Switches): Set Style_Check_Main\n\tfor -gnatg and -gnaty\n\n2013-04-12  Doug Rupp  <rupp@adacore.com>\n\n\t* s-crtl.ads (fopen, freopen): Add vms_form parameter\n\t* i-cstrea.ads (fopen, freopen): Likewise.\n\t* adaint.h (__gnat_fopen, __gnat_freopen): Likewise.\n\t* adaint.c (__gnat_fopen, __gnat_freopen): Likewise.\n\t[VMS]: Split out RMS keys and call CRTL function appropriately.\n\t* s-fileio.adb (Form_VMS_RMS_Keys, Form_RMS_Context_Key): New\n\tsubprograms.\n\t(Open, Reset): Call Form_VMS_RMS_Keys. Call fopen,freopen with\n\tvms_form\n\t* gnat_rm.texi: Document implemented RMS keys.\n\nFrom-SVN: r197902", "tree": {"sha": "6db6862ab6efa3907d870a62cf3e6efc4c96409e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6db6862ab6efa3907d870a62cf3e6efc4c96409e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7f18b29a17b0905afb33ab3c0617fc587b766f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f18b29a17b0905afb33ab3c0617fc587b766f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7f18b29a17b0905afb33ab3c0617fc587b766f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7f18b29a17b0905afb33ab3c0617fc587b766f97/comments", "author": null, "committer": null, "parents": [{"sha": "0c68c6135fcd6bf0b97fc801b1d0ddc606275651", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c68c6135fcd6bf0b97fc801b1d0ddc606275651", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c68c6135fcd6bf0b97fc801b1d0ddc606275651"}], "stats": {"total": 446, "additions": 408, "deletions": 38}, "files": [{"sha": "b4d29f73f55e92fe865f36994301bd91a61d5996", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -1,3 +1,27 @@\n+2013-04-12  Robert Dewar  <dewar@adacore.com>\n+\n+\t* opt.ads (Style_Check_Main): New switch.\n+\t* sem.adb (Semantics): Set Style_Check flag properly for new\n+\tunit to be analyzed.\n+\t* sem_ch10.adb (Analyze_With_Clause): Don't reset Style_Check,\n+\tthe proper setting of this flag is now part of the Semantics\n+\tprocedure.\n+\t* switch-c.adb (Scan_Front_End_Switches): Set Style_Check_Main\n+\tfor -gnatg and -gnaty\n+\n+2013-04-12  Doug Rupp  <rupp@adacore.com>\n+\n+\t* s-crtl.ads (fopen, freopen): Add vms_form parameter\n+\t* i-cstrea.ads (fopen, freopen): Likewise.\n+\t* adaint.h (__gnat_fopen, __gnat_freopen): Likewise.\n+\t* adaint.c (__gnat_fopen, __gnat_freopen): Likewise.\n+\t[VMS]: Split out RMS keys and call CRTL function appropriately.\n+\t* s-fileio.adb (Form_VMS_RMS_Keys, Form_RMS_Context_Key): New\n+\tsubprograms.\n+\t(Open, Reset): Call Form_VMS_RMS_Keys. Call fopen,freopen with\n+\tvms_form\n+\t* gnat_rm.texi: Document implemented RMS keys.\n+\n 2013-04-12  Hristian Kirtchev  <kirtchev@adacore.com>\n \n \t* sem_ch13.adb (Analyze_Aspect_Specifications):"}, {"sha": "c4bb7540c52d3ae041b633ee578c8640e5947e93", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 70, "deletions": 5, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -213,6 +213,8 @@ struct vstring\n \n #define SYI$_ACTIVECPU_CNT 0x111e\n extern int LIB$GETSYI (int *, unsigned int *);\n+extern unsigned int LIB$CALLG_64\n+ ( unsigned long long argument_list [], int (*user_procedure)(void));\n \n #else\n #include <utime.h>\n@@ -820,7 +822,8 @@ __gnat_rmdir (char *path)\n }\n \n FILE *\n-__gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED)\n+__gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED,\n+              char *vms_form ATTRIBUTE_UNUSED)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (IS_CROSS)\n   TCHAR wpath[GNAT_MAX_PATH_LEN];\n@@ -837,7 +840,37 @@ __gnat_fopen (char *path, char *mode, int encoding ATTRIBUTE_UNUSED)\n \n   return _tfopen (wpath, wmode);\n #elif defined (VMS)\n-  return decc$fopen (path, mode);\n+  if (vms_form == 0)\n+    return decc$fopen (path, mode);\n+  else\n+    {\n+       char *local_form = (char *) alloca (strlen (vms_form) + 1);\n+       /* Allocate an argument list of guaranteed ample length.  */\n+       unsigned long long *arg_list =\n+        (unsigned long long *) alloca (strlen (vms_form) + 3);\n+       char *ptrb, *ptre;\n+       int i;\n+\n+       arg_list [1] = (unsigned long long) path;\n+       arg_list [2] = (unsigned long long) mode;\n+       strcpy (local_form, vms_form);\n+\n+       /* Given a string such as \"\\\"rfm=udf\\\",\\\"rat=cr\\\"\"\n+          Split it into an argument list as \"rfm=udf\",\"rat=cr\".  */\n+       ptrb = local_form;\n+       for (i = 0; *ptrb; i++)\n+         {\n+            ptrb = strchr (ptrb, '\"');\n+            ptre = strchr (ptrb + 1, '\"');\n+            *ptre = 0;\n+            arg_list [i + 3] = (unsigned long long) (ptrb + 1);\n+            ptrb = ptre + 1;\n+         }\n+       arg_list [0] = i + 2;\n+       /* CALLG_64 returns int , fortunately (FILE *) on VMS is a\n+          always a 32bit pointer.   */\n+       return LIB$CALLG_64 (arg_list, &decc$fopen);\n+    }\n #else\n   return GNAT_FOPEN (path, mode);\n #endif\n@@ -847,7 +880,8 @@ FILE *\n __gnat_freopen (char *path,\n \t\tchar *mode,\n \t\tFILE *stream,\n-\t\tint encoding ATTRIBUTE_UNUSED)\n+\t\tint encoding ATTRIBUTE_UNUSED,\n+                char *vms_form ATTRIBUTE_UNUSED)\n {\n #if defined (_WIN32) && ! defined (__vxworks) && ! defined (IS_CROSS)\n   TCHAR wpath[GNAT_MAX_PATH_LEN];\n@@ -864,7 +898,38 @@ __gnat_freopen (char *path,\n \n   return _tfreopen (wpath, wmode, stream);\n #elif defined (VMS)\n-  return decc$freopen (path, mode, stream);\n+  if (vms_form == 0)\n+    return decc$freopen (path, mode, stream);\n+  else\n+    {\n+       char *local_form = (char *) alloca (strlen (vms_form) + 1);\n+       /* Allocate an argument list of guaranteed ample length.  */\n+       unsigned long long *arg_list =\n+        (unsigned long long *) alloca (strlen (vms_form) + 4);\n+       char *ptrb, *ptre;\n+       int i;\n+\n+       arg_list [1] = (unsigned long long) path;\n+       arg_list [2] = (unsigned long long) mode;\n+       arg_list [3] = (unsigned long long) stream;\n+       strcpy (local_form, vms_form);\n+\n+       /* Given a string such as \"\\\"rfm=udf\\\",\\\"rat=cr\\\"\"\n+          Split it into an argument list as \"rfm=udf\",\"rat=cr\".  */\n+       ptrb = local_form;\n+       for (i = 0; *ptrb; i++)\n+         {\n+            ptrb = strchr (ptrb, '\"');\n+            ptre = strchr (ptrb + 1, '\"');\n+            *ptre = 0;\n+            arg_list [i + 4] = (unsigned long long) (ptrb + 1);\n+            ptrb = ptre + 1;\n+         }\n+       arg_list [0] = i + 3;\n+       /* CALLG_64 returns int , fortunately (FILE *) on VMS is a\n+          always a 32bit pointer.   */\n+       return LIB$CALLG_64 (arg_list, &decc$freopen);\n+    }\n #else\n   return freopen (path, mode, stream);\n #endif"}, {"sha": "78af57c9dae9b9a82b3aa7477723d2d10bbe9a46", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2012, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2013, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -128,9 +128,10 @@ extern int    __gnat_rename                        (char *, char *);\n extern int    __gnat_chdir                         (char *);\n extern int    __gnat_rmdir                         (char *);\n \n-extern FILE  *__gnat_fopen\t\t\t   (char *, char *, int);\n+extern FILE  *__gnat_fopen\t\t\t   (char *, char *, int,\n+\t\t\t\t\t\t    char *);\n extern FILE  *__gnat_freopen\t\t\t   (char *, char *, FILE *,\n-\t\t\t\t                    int);\n+\t\t\t\t                    int, char *);\n extern int    __gnat_open_read                     (char *, int);\n extern int    __gnat_open_rw                       (char *, int);\n extern int    __gnat_open_create                   (char *, int);"}, {"sha": "8e94e4e07a79ddd7b4a643941f4f00e377ade96a", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -14261,6 +14261,25 @@ The use of these parameters is described later in this section. If an\n unrecognized keyword appears in a form string, it is silently ignored\n and not considered invalid.\n \n+@noindent\n+For OpenVMS additional FORM string keywords are available for use with\n+RMS services.  The syntax is:\n+\n+@smallexample\n+VMS_RMS_Keys=(keyword=value,@dots{},keyword=value)\n+@end smallexample\n+\n+@noindent\n+The following RMS keywords and values are currently defined:\n+\n+@smallexample\n+Context=Force_Stream_Mode|Force_Record_Mode\n+@end smallexample\n+\n+@noindent\n+VMS RMS keys are silently ignored on non-VMS systems.  On OpenVMS\n+unimplented RMS keywords, values, or invalid syntax will raise Use_Error.\n+\n @node Direct_IO\n @section Direct_IO\n "}, {"sha": "95dae64361e6ff3b56cae4c92acc419cf6dde1d5", "filename": "gcc/ada/i-cstrea.ads", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fi-cstrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fi-cstrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fi-cstrea.ads?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1995-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1995-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -107,8 +107,8 @@ package Interfaces.C_Streams is\n    function fopen\n      (filename : chars;\n       mode     : chars;\n-      encoding : System.CRTL.Filename_Encoding := System.CRTL.UTF8)\n-      return FILEs\n+      encoding : System.CRTL.Filename_Encoding := System.CRTL.UTF8;\n+      vms_form : chars := System.Null_Address) return FILEs\n      renames System.CRTL.fopen;\n    --  Note: to maintain target independence, use text_translation_required,\n    --  a boolean variable defined in sysdep.c to deal with the target\n@@ -144,8 +144,8 @@ package Interfaces.C_Streams is\n      (filename : chars;\n       mode     : chars;\n       stream   : FILEs;\n-      encoding : System.CRTL.Filename_Encoding := System.CRTL.UTF8)\n-      return FILEs\n+      encoding : System.CRTL.Filename_Encoding := System.CRTL.UTF8;\n+      vms_form : chars := System.Null_Address) return FILEs\n      renames System.CRTL.freopen;\n \n    function fseek"}, {"sha": "b446eea827172a02333e4dcfba7781f37ea99a7a", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -1267,7 +1267,15 @@ package Opt is\n    --  GNAT\n    --  Set True to perform style checks. Activates checks carried out in\n    --  package Style (see body of this package for details of checks). This\n-   --  flag is set True by either the -gnatg or -gnaty switches.\n+   --  flag is set True by use of either the -gnatg or -gnaty switches, or\n+   --  by the Style_Check pragma.\n+\n+   Style_Check_Main : Boolean := False;\n+   --  GNAT\n+   --  Set True if Style_Check was set for the main unit. This is used to\n+   --  renable style checks for units in the mail extended source that get\n+   --  with'ed indirectly. It is set on by use of either the -gnatg or -gnaty\n+   --  switches, but not by use of the Style_Checks pragma.\n \n    Suppress_All_Inlining : Boolean := False;\n    --  GNAT"}, {"sha": "390f47e02dfb519cd12eb21a00b4a9a09976702c", "filename": "gcc/ada/s-crtl.ads", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fs-crtl.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fs-crtl.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-crtl.ads?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 2003-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2003-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -97,7 +97,8 @@ package System.CRTL is\n    function fopen\n      (filename : chars;\n       mode     : chars;\n-      encoding : Filename_Encoding := Unspecified) return FILEs;\n+      encoding : Filename_Encoding := Unspecified;\n+      vms_form : chars := System.Null_Address) return FILEs;\n    pragma Import (C, fopen, \"__gnat_fopen\");\n \n    function fputc (C : int; stream : FILEs) return int;\n@@ -113,7 +114,8 @@ package System.CRTL is\n      (filename : chars;\n       mode     : chars;\n       stream   : FILEs;\n-      encoding : Filename_Encoding := Unspecified) return FILEs;\n+      encoding : Filename_Encoding := Unspecified;\n+      vms_form : chars := System.Null_Address) return FILEs;\n    pragma Import (C, freopen, \"__gnat_freopen\");\n \n    function fseek"}, {"sha": "0eea5367ef441ab1d292b9b42244f4ee0d70357e", "filename": "gcc/ada/s-fileio.adb", "status": "modified", "additions": 247, "deletions": 9, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fs-fileio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fs-fileio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-fileio.adb?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2013, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -52,6 +52,11 @@ package body System.File_IO is\n    use type Interfaces.C.int;\n    use type CRTL.size_t;\n \n+   subtype String_Access is System.OS_Lib.String_Access;\n+   procedure Free (X : in out String_Access) renames System.OS_Lib.Free;\n+   function \"=\" (X, Y : String_Access) return Boolean\n+     renames System.OS_Lib.\"=\";\n+\n    ----------------------\n    -- Global Variables --\n    ----------------------\n@@ -98,6 +103,9 @@ package body System.File_IO is\n      (C, text_translation_required, \"__gnat_text_translation_required\");\n    --  If true, add appropriate suffix to control string for Open\n \n+   VMS_Formstr : String_Access := null;\n+   --  For special VMS RMS keywords and values.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n@@ -132,11 +140,20 @@ package body System.File_IO is\n    --  with Name includes that file name in the message.\n \n    procedure Raise_Device_Error\n-     (File : AFCB_Ptr; Errno : Integer := OS_Lib.Errno);\n+     (File  : AFCB_Ptr;\n+      Errno : Integer := OS_Lib.Errno);\n    pragma No_Return (Raise_Device_Error);\n    --  Clear error indication on File and raise Device_Error with an exception\n    --  message providing errno information.\n \n+   procedure Form_VMS_RMS_Keys (Form : String; VMS_Form : out String_Access);\n+   --   Parse the RMS Keys\n+\n+   function Form_RMS_Context_Key\n+     (Form     : String;\n+      VMS_Form : String_Access) return Natural;\n+   --   Parse the RMS Context Key\n+\n    ----------------\n    -- Append_Set --\n    ----------------\n@@ -640,6 +657,191 @@ package body System.File_IO is\n       Stop  := 0;\n    end Form_Parameter;\n \n+   --------------------------\n+   -- Form_RMS_Context_Key --\n+   --------------------------\n+\n+   function Form_RMS_Context_Key\n+     (Form     : String;\n+      VMS_Form : String_Access) return Natural\n+   is\n+      type Context_Parms is\n+        (Binary_Data, Convert_Fortran_Carriage_Control, Force_Record_Mode,\n+         Force_Stream_Mode, Explicit_Write);\n+   --  Ada-fied list of all possible Context keyword values.\n+\n+      Pos   : Natural := 0;\n+      Klen  : Natural := 0;\n+      Index : Natural;\n+\n+   begin\n+      --  Find the end of the occupation\n+\n+      for J in VMS_Form'First .. VMS_Form'Last loop\n+         if VMS_Form (J) = ASCII.NUL then\n+            Pos := J;\n+            exit;\n+         end if;\n+      end loop;\n+\n+      Index := Form'First;\n+      while Index < Form'Last loop\n+         if Form (Index) = '=' then\n+            Index := Index + 1;\n+\n+            --  Loop through the context values and look for a match\n+\n+            for Parm in Context_Parms loop\n+               declare\n+                  KImage : String := Context_Parms'Image (Parm);\n+\n+               begin\n+                  Klen := KImage'Length;\n+                  To_Lower (KImage);\n+\n+                  if Form (Index .. Index + Klen - 1) = KImage then\n+                     case Parm is\n+                        when Force_Record_Mode =>\n+                           VMS_Form (Pos) := '\"';\n+                           Pos := Pos + 1;\n+                           VMS_Form (Pos .. Pos + 7) := \"ctx=rec\";\n+                           Pos := Pos + 7;\n+                           VMS_Form (Pos) := '\"';\n+                           Pos := Pos + 1;\n+                           VMS_Form (Pos) := ',';\n+                           return Index + Klen;\n+\n+                        when Force_Stream_Mode =>\n+                           VMS_Form (Pos) := '\"';\n+                           Pos := Pos + 1;\n+                           VMS_Form (Pos .. Pos + 7) := \"ctx=stm\";\n+                           Pos := Pos + 7;\n+                           VMS_Form (Pos) := '\"';\n+                           Pos := Pos + 1;\n+                           VMS_Form (Pos) := ',';\n+                           return Index + Klen;\n+\n+                        when others =>\n+                           raise Use_Error\n+                             with \"unimplemented RMS Context Value\";\n+                     end case;\n+                  end if;\n+               end;\n+            end loop;\n+\n+            raise Use_Error with \"unrecognized RMS Context Value\";\n+         end if;\n+      end loop;\n+\n+      raise Use_Error with \"malformed RMS Context Value\";\n+   end Form_RMS_Context_Key;\n+\n+   -----------------------\n+   -- Form_VMS_RMS_Keys --\n+   -----------------------\n+\n+   procedure Form_VMS_RMS_Keys (Form : String; VMS_Form : out String_Access)\n+   is\n+      VMS_RMS_Keys_Token : constant String := \"vms_rms_keys\";\n+      Klen : Natural := VMS_RMS_Keys_Token'Length;\n+      Index : Natural;\n+\n+      --  Ada-fied list of all RMS keywords, translated from the\n+      --  HP C Run-Time Library Reference Manual, Table REF-3:\n+      --  RMS Valid Keywords and Values\n+\n+      type RMS_Keys is\n+       (Access_Callback, Allocation_Quantity, Block_Size, Context,\n+        Default_Extension_Quantity, Default_File_Name_String, Error_Callback,\n+        File_Processing_Options, Fixed_Header_Size, Global_Buffer_Count,\n+        Multiblock_Count, Multibuffer_Count, Maximum_Record_Size,\n+        Terminal_Input_Prompt, Record_Attributes, Record_Format,\n+        Record_Processing_Options, Retrieval_Pointer_Count, Sharing_Options,\n+        Timeout_IO_Value);\n+\n+   begin\n+      Index := Form'First + Klen - 1;\n+      while Index < Form'Last loop\n+         Index := Index + 1;\n+\n+         --  Scan for the token signalling VMS RMS Keys ahead.  Should\n+         --  whitespace be eaten???\n+\n+         if Form (Index - Klen .. Index - 1) = VMS_RMS_Keys_Token then\n+\n+            --  Allocate the VMS form string that will contain the cryptic\n+            --  CRTL RMS strings and initialize it to all nulls.  Since the\n+            --  CRTL strings are always shorter than the Ada-fied strings,\n+            --  it follows that an allocation of the original size will be\n+            --  more than adequate.\n+            VMS_Form := new String'(Form (Form'First .. Form'Last));\n+            VMS_Form.all := (others => ASCII.NUL);\n+\n+            if Form (Index) = '=' then\n+               Index := Index + 1;\n+               if Form (Index) = '(' then\n+                  while Index < Form'Last loop\n+                     Index := Index + 1;\n+\n+                     --  Loop through the RMS Keys and dispatch.\n+\n+                     for Key in RMS_Keys loop\n+                        declare\n+                           KImage : String := RMS_Keys'Image (Key);\n+                        begin\n+                           Klen := KImage'Length;\n+                           To_Lower (KImage);\n+                           if Form (Index .. Index + Klen - 1) = KImage then\n+                              case Key is\n+\n+                                 when Context =>\n+                                    Index := Form_RMS_Context_Key\n+                                     (Form (Index + Klen .. Form'Last),\n+                                      VMS_Form);\n+                                    exit;\n+\n+                                 when others =>\n+                                    raise Use_Error\n+                                     with \"unimplemented VMS RMS Form Key\";\n+                              end case;\n+                           end if;\n+                        end;\n+                     end loop;\n+\n+                     if Form (Index) = ')' then\n+\n+                        --  Done, erase the unneeded trailing comma and\n+                        --  return.\n+\n+                        for J in reverse VMS_Form'First .. VMS_Form'Last loop\n+                           if VMS_Form (J) = ',' then\n+                              VMS_Form (J) := ASCII.NUL;\n+                              return;\n+                           end if;\n+                        end loop;\n+\n+                        --  Shouldn't be possible to get here\n+                        raise Use_Error;\n+\n+                     elsif Form (Index) = ',' then\n+\n+                        --  Another key ahead, exit inner loop\n+                        null;\n+                     else\n+\n+                        --  Keyword value not terminated correctly\n+                        raise Use_Error with \"malformed VMS RMS Form\";\n+                     end if;\n+                  end loop;\n+               end if;\n+            end if;\n+\n+            --  Found the keyword, but not followed by correct syntax\n+            raise Use_Error with \"malformed VMS RMS Form\";\n+         end if;\n+      end loop;\n+   end Form_VMS_RMS_Keys;\n+\n    -------------\n    -- Is_Open --\n    -------------\n@@ -868,6 +1070,17 @@ package body System.File_IO is\n            Form_Boolean (Formstr, \"text_translation\", Default => True);\n       end if;\n \n+      --  Acquire settings of target specific form parameters on VMS. Only\n+      --  Context is currently implemented, for forcing a byte stream mode\n+      --  read. On non-VMS systems, the settings are ultimately ignored in\n+      --  the implementation of __gnat_fopen.\n+\n+      --  Should a warning be issued on non-VMS systems?  That's not possible\n+      --  without testing System.OpenVMS boolean which isn't present in most\n+      --  non-VMS versions of package System.\n+\n+      Form_VMS_RMS_Keys (Formstr, VMS_Formstr);\n+\n       --  If we were given a stream (call from xxx.C_Streams.Open), then set\n       --  the full name to the given one, and skip to end of processing.\n \n@@ -1030,7 +1243,19 @@ package body System.File_IO is\n             --  since by the time of the delete, the current working directory\n             --  may have changed and we do not want to delete a different file!\n \n-            Stream := fopen (Namestr'Address, Fopstr'Address, Encoding);\n+            if VMS_Formstr = null then\n+               Stream := fopen (Namestr'Address, Fopstr'Address, Encoding,\n+                                Null_Address);\n+            else\n+               Stream := fopen (Namestr'Address, Fopstr'Address, Encoding,\n+                                VMS_Formstr.all'Address);\n+            end if;\n+\n+            --   No need to keep this around\n+\n+            if VMS_Formstr /= null then\n+               Free (VMS_Formstr);\n+            end if;\n \n             if Stream = NULL_Stream then\n \n@@ -1042,15 +1267,15 @@ package body System.File_IO is\n                declare\n                   function Is_File_Not_Found_Error\n                     (Errno_Value : Integer) return Integer;\n-                  --  Non-zero when the given errno value indicates a non-\n-                  --  existing file.\n-\n                   pragma Import\n                     (C, Is_File_Not_Found_Error,\n                      \"__gnat_is_file_not_found_error\");\n+                  --  Non-zero when the given errno value indicates a non-\n+                  --  existing file.\n \n-                  Errno : constant Integer := OS_Lib.Errno;\n+                  Errno   : constant Integer := OS_Lib.Errno;\n                   Message : constant String := Errno_Message (Name, Errno);\n+\n                begin\n                   if Is_File_Not_Found_Error (Errno) /= 0 then\n                      raise Name_Error with Message;\n@@ -1196,8 +1421,21 @@ package body System.File_IO is\n          Fopen_Mode\n            (Mode, File.Is_Text_File, False, File.Access_Method, Fopstr);\n \n-         File.Stream := freopen\n-           (File.Name.all'Address, Fopstr'Address, File.Stream, File.Encoding);\n+         Form_VMS_RMS_Keys (File.Form.all, VMS_Formstr);\n+\n+         if VMS_Formstr = null then\n+            File.Stream := freopen\n+              (File.Name.all'Address, Fopstr'Address, File.Stream,\n+               File.Encoding, Null_Address);\n+         else\n+            File.Stream := freopen\n+              (File.Name.all'Address, Fopstr'Address, File.Stream,\n+               File.Encoding, VMS_Formstr.all'Address);\n+         end if;\n+\n+         if VMS_Formstr /= null then\n+            Free (VMS_Formstr);\n+         end if;\n \n          if File.Stream = NULL_Stream then\n             Close (File_Ptr);"}, {"sha": "d3ec497188db0975720ac4696cc126569d0e5f57", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -1311,13 +1311,18 @@ package body Sem is\n       S_In_Spec_Expr      : constant Boolean          := In_Spec_Expression;\n       S_Inside_A_Generic  : constant Boolean          := Inside_A_Generic;\n       S_Outer_Gen_Scope   : constant Entity_Id        := Outer_Generic_Scope;\n+      S_Style_Check       : constant Boolean          := Style_Check;\n \n       Generic_Main : constant Boolean :=\n                        Nkind (Unit (Cunit (Main_Unit)))\n                          in N_Generic_Declaration;\n       --  If the main unit is generic, every compiled unit, including its\n       --  context, is compiled with expansion disabled.\n \n+      Ext_Main_Source_Unit : constant Boolean :=\n+                               In_Extended_Main_Source_Unit (Comp_Unit);\n+      --  Determine if unit is in extended main source unit\n+\n       Save_Config_Switches : Config_Switches_Type;\n       --  Variable used to save values of config switches while we analyze the\n       --  new unit, to be restored on exit for proper recursive behavior.\n@@ -1386,9 +1391,6 @@ package body Sem is\n       --  Sequential_IO) as this would prevent pragma Extend_System from being\n       --  taken into account, for example when Text_IO is renaming DEC.Text_IO.\n \n-      --  Cleaner might be to do the kludge at the point of excluding the\n-      --  pragma (do not exclude for renamings ???)\n-\n       if Is_Predefined_File_Name\n            (Unit_File_Name (Current_Sem_Unit), Renamings_Included => False)\n       then\n@@ -1423,12 +1425,28 @@ package body Sem is\n       --  For unit in main extended unit, we reset the configuration values\n       --  for the non-partition-wide restrictions. For other units reset them.\n \n-      if In_Extended_Main_Source_Unit (Comp_Unit) then\n+      if Ext_Main_Source_Unit then\n          Restore_Config_Cunit_Boolean_Restrictions;\n       else\n          Reset_Cunit_Boolean_Restrictions;\n       end if;\n \n+      --  Turn off style checks for unit that is not in the extended main\n+      --  source unit. This improves processing efficiency for such units\n+      --  (for which we don't want style checks anyway, and where they will\n+      --  get suppressed), and is definitely needed to stop some style checks\n+      --  from invading the run-time units (e.g. overriding checks).\n+\n+      if not Ext_Main_Source_Unit then\n+         Style_Check := False;\n+\n+      --  If this is part of the extended main source unit, set style check\n+      --  mode to match the style check mode of the main source unit itself.\n+\n+      else\n+         Style_Check := Style_Check_Main;\n+      end if;\n+\n       --  Only do analysis of unit that has not already been analyzed\n \n       if not Analyzed (Comp_Unit) then\n@@ -1482,6 +1500,7 @@ package body Sem is\n       In_Spec_Expression   := S_In_Spec_Expr;\n       Inside_A_Generic     := S_Inside_A_Generic;\n       Outer_Generic_Scope  := S_Outer_Gen_Scope;\n+      Style_Check          := S_Style_Check;\n \n       Restore_Opt_Config_Switches (Save_Config_Switches);\n "}, {"sha": "f9da78add6dbd5cd872a376bc11562b5815e9961", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -2457,14 +2457,6 @@ package body Sem_Ch10 is\n          return;\n       end if;\n \n-      --  We reset ordinary style checking during the analysis of a with'ed\n-      --  unit, but we do NOT reset GNAT special analysis mode (the latter\n-      --  definitely *does* apply to with'ed units).\n-\n-      if not GNAT_Mode then\n-         Style_Check := False;\n-      end if;\n-\n       --  If the library unit is a predefined unit, and we are in high\n       --  integrity mode, then temporarily reset Configurable_Run_Time_Mode\n       --  for the analysis of the with'ed unit. This mode does not prevent"}, {"sha": "baffbec965a1ddaa873fcf6f0260984c855e69a7", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7f18b29a17b0905afb33ab3c0617fc587b766f97/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=7f18b29a17b0905afb33ab3c0617fc587b766f97", "patch": "@@ -751,6 +751,7 @@ package body Switch.C is\n                Identifier_Character_Set := 'n';\n                System_Extend_Unit := Empty;\n                Warning_Mode := Treat_As_Error;\n+               Style_Check_Main := True;\n \n                --  Set Ada 2012 mode explicitly. We don't want to rely on the\n                --  implicit setting here, since for example, we want\n@@ -1173,6 +1174,7 @@ package body Switch.C is\n \n             when 'y' =>\n                Ptr := Ptr + 1;\n+               Style_Check_Main := True;\n \n                if Ptr > Max then\n                   Set_Default_Style_Check_Options;"}]}