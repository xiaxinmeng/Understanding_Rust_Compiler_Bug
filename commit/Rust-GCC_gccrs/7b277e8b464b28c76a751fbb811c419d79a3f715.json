{"sha": "7b277e8b464b28c76a751fbb811c419d79a3f715", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IyNzdlOGI0NjRiMjhjNzZhNzUxZmJiODExYzQxOWQ3OWEzZjcxNQ==", "commit": {"author": {"name": "Tim Shen", "email": "timshen@google.com", "date": "2016-11-15T17:26:59Z"}, "committer": {"name": "Tim Shen", "email": "timshen@gcc.gnu.org", "date": "2016-11-15T17:26:59Z"}, "message": "variant: Remove variant<T&>...\n\n\t* include/std/variant: Remove variant<T&>, variant<void>, variant<> support\n\tto rebase on the post-Issaquah design.\n\t* testsuite/20_util/variant/compile.cc: Likewise.\n\nFrom-SVN: r242437", "tree": {"sha": "e0edc3c033006b310a44813b3690ad8ffbab83af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0edc3c033006b310a44813b3690ad8ffbab83af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b277e8b464b28c76a751fbb811c419d79a3f715", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b277e8b464b28c76a751fbb811c419d79a3f715", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b277e8b464b28c76a751fbb811c419d79a3f715", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b277e8b464b28c76a751fbb811c419d79a3f715/comments", "author": {"login": "timshen91", "id": 1157432, "node_id": "MDQ6VXNlcjExNTc0MzI=", "avatar_url": "https://avatars.githubusercontent.com/u/1157432?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timshen91", "html_url": "https://github.com/timshen91", "followers_url": "https://api.github.com/users/timshen91/followers", "following_url": "https://api.github.com/users/timshen91/following{/other_user}", "gists_url": "https://api.github.com/users/timshen91/gists{/gist_id}", "starred_url": "https://api.github.com/users/timshen91/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timshen91/subscriptions", "organizations_url": "https://api.github.com/users/timshen91/orgs", "repos_url": "https://api.github.com/users/timshen91/repos", "events_url": "https://api.github.com/users/timshen91/events{/privacy}", "received_events_url": "https://api.github.com/users/timshen91/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "18d2ada84b8b162ba6961d18d9db3b743e17db32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18d2ada84b8b162ba6961d18d9db3b743e17db32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18d2ada84b8b162ba6961d18d9db3b743e17db32"}], "stats": {"total": 236, "additions": 28, "deletions": 208}, "files": [{"sha": "cc72f15c4b83da1815f0e98400b349a0c28ceef4", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=7b277e8b464b28c76a751fbb811c419d79a3f715", "patch": "@@ -1,3 +1,9 @@\n+2016-11-15  Tim Shen  <timshen@google.com>\n+\n+\t* include/std/variant: Remove variant<T&>, variant<void>, variant<> support\n+\tto rebase on the post-Issaquah design.\n+\t* testsuite/20_util/variant/compile.cc: Likewise.\n+\n 2016-11-15  Matthias Klose  <doko@ubuntu.com>\n \n \t* configure: Regenerate.\n@@ -341,9 +347,9 @@\n \n 2016-11-09  Tim Shen  <timshen@google.com>\n \n-\t* libstdc++-v3/include/bits/regex.h (regex_iterator::regex_iterator()):\n+\t* include/bits/regex.h (regex_iterator::regex_iterator()):\n \tDefine end() as _M_pregex == nullptr.\n-\t* libstdc++-v3/include/bits/regex.tcc (regex_iterator::operator==(),\n+\t* include/bits/regex.tcc (regex_iterator::operator==(),\n \tregex_iterator::operator++()): Fix operator==() and operator++() to\n \tlook at null-ness of _M_pregex on both sides.\n \t* testsuite/28_regex/regression.cc: New testcase."}, {"sha": "7d9357537289ecd9436021364014f64eadb3634e", "filename": "libstdc++-v3/include/std/variant", "status": "modified", "additions": 13, "deletions": 64, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fvariant?ref=7b277e8b464b28c76a751fbb811c419d79a3f715", "patch": "@@ -137,41 +137,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __reserved_type_map_impl<const volatile _From, _To>\n     { using type = add_cv_t<__reserved_type_map<_From, _To>>; };\n \n-  // Stores a reference alternative as a... well, reference.\n-  template<typename _Reference>\n-    struct _Reference_storage\n-    {\n-      static_assert(is_reference_v<_Reference>,\n-\t\t    \"BUG: _Reference should be a reference\");\n-\n-      _Reference_storage(_Reference __ref) noexcept : _M_storage(__ref) { }\n-\n-      operator _Reference() noexcept\n-      { return static_cast<_Reference>(_M_storage); }\n-\n-      _Reference _M_storage;\n-    };\n-\n-  // Stores a void alternative, because it is not a regular type.\n-  template<typename _Void>\n-    struct _Void_storage { };\n-\n-  // Map from the alternative type to a non-qualified storage type.\n-  template<typename _Alternative, typename = void>\n-    struct __storage_type\n-    { using type = _Alternative; };\n-\n-  template<typename _Alternative>\n-    struct __storage_type<_Alternative,\n-\t\t\t  enable_if_t<is_reference_v<_Alternative>>>\n-    { using type = _Reference_storage<_Alternative>; };\n-\n+  // This abstraction might be useful for future features,\n+  // e.g. boost::recursive_wrapper.\n   template<typename _Alternative>\n-    struct __storage_type<_Alternative, enable_if_t<is_void_v<_Alternative>>>\n-    { using type = _Void_storage<_Alternative>; };\n-\n-  template<typename _Type>\n-    using __storage = typename __storage_type<_Type>::type;\n+    using __storage = _Alternative;\n \n   template<typename _Type, bool __is_literal = std::is_literal_type_v<_Type>>\n     struct _Uninitialized;\n@@ -202,37 +171,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  _M_storage;\n     };\n \n-  // Reverse mapping of __storage_type.\n-  template<typename _Storage_type>\n-    struct __alternative_type\n-    {\n-      static_assert(!is_reference_v<_Storage_type>,\n-\t\t    \"BUG: _Storage_type should not be reference\");\n-      using type = _Storage_type;\n-    };\n-\n-  template<typename _Reference>\n-    struct __alternative_type<_Reference_storage<_Reference>>\n-    { using type = _Reference; };\n-\n-  template<typename _Void>\n-    struct __alternative_type<_Void_storage<_Void>>\n-    { using type = _Void; };\n-\n   // Given a qualified storage type, return the desired reference.\n-  // The qualified storage type is supposed to carry the variant object's\n-  // qualifications and reference information, and the designated alternative's\n-  // storage type.\n-  // Returns the qualification-collapsed alternative references.\n-  //\n-  // For example, __get_alternative<_Reference_storage<int&&>&> returns int&.\n+  // For example, variant<int>&& stores the int as __storage<int>, and\n+  // _Qualified_storage will be __storage<int>&&.\n   template<typename _Qualified_storage>\n     decltype(auto)\n     __get_alternative(void* __ptr)\n     {\n       using _Storage = decay_t<_Qualified_storage>;\n-      using _Alternative = typename __alternative_type<_Storage>::type;\n-      return __reserved_type_map<_Qualified_storage, _Alternative>(\n+      return __reserved_type_map<_Qualified_storage, _Storage>(\n \t*static_cast<_Storage*>(__ptr));\n     }\n \n@@ -970,6 +917,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tvariant<_Types...>>\n     {\n     private:\n+      static_assert(sizeof...(_Types) > 0,\n+\t\t    \"variant must have at least one alternative\");\n+      static_assert(!(std::is_reference_v<_Types> || ...),\n+\t\t    \"variant must have no reference alternative\");\n+      static_assert(!(std::is_void_v<_Types> || ...),\n+\t\t    \"variant must have no void alternative\");\n+\n       using _Base = __detail::__variant::_Variant_base<_Types...>;\n       using _Default_ctor_enabler =\n \t_Enable_default_constructor<\n@@ -1265,11 +1219,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         __get_storage(_Vp&& __v);\n     };\n \n-  // To honor algebraic data type, variant<> should be a bottom type, which\n-  // is 0 (as opposed to a void type, which is 1). Use incomplete type to model\n-  // bottom type.\n-  template<> class variant<>;\n-\n   template<size_t _Np, typename... _Types>\n     variant_alternative_t<_Np, variant<_Types...>>&\n     get(variant<_Types...>& __v)"}, {"sha": "2470bcc7f9eac46eab7d7811075aeb0f8b1af08c", "filename": "libstdc++-v3/testsuite/20_util/variant/compile.cc", "status": "modified", "additions": 7, "deletions": 142, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b277e8b464b28c76a751fbb811c419d79a3f715/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fvariant%2Fcompile.cc?ref=7b277e8b464b28c76a751fbb811c419d79a3f715", "patch": "@@ -55,7 +55,6 @@ void default_ctor()\n {\n   static_assert(is_default_constructible_v<variant<int, string>>, \"\");\n   static_assert(is_default_constructible_v<variant<string, string>>, \"\");\n-  static_assert(!is_default_constructible_v<variant<>>, \"\");\n   static_assert(!is_default_constructible_v<variant<AllDeleted, string>>, \"\");\n   static_assert(is_default_constructible_v<variant<string, AllDeleted>>, \"\");\n \n@@ -123,14 +122,6 @@ void uses_alloc_ctors()\n   std::allocator<char> alloc;\n   variant<int> a(allocator_arg, alloc);\n   static_assert(!is_constructible_v<variant<AllDeleted>, allocator_arg_t, std::allocator<char>>, \"\");\n-  {\n-    variant<int> b(allocator_arg, alloc, a);\n-    static_assert(!is_constructible_v<variant<void>, allocator_arg_t, std::allocator<char>, const variant<void>&>, \"\");\n-  }\n-  {\n-    variant<int> b(allocator_arg, alloc, std::move(a));\n-    static_assert(!is_constructible_v<variant<void>, allocator_arg_t, std::allocator<char>, variant<void>&&>, \"\");\n-  }\n   {\n     variant<string, int> b(allocator_arg, alloc, \"a\");\n     static_assert(!is_constructible_v<variant<string, string>, allocator_arg_t, std::allocator<char>, const char*>, \"\");\n@@ -169,12 +160,6 @@ void copy_assign()\n     variant<DefaultNoexcept> a;\n     static_assert(!noexcept(a = a), \"\");\n   }\n-\n-  {\n-    float f1 = 1.0f, f2 = 2.0f;\n-    std::variant<float&> v1(f1);\n-    v1 = f2;\n-  }\n }\n \n void move_assign()\n@@ -203,103 +188,13 @@ void arbitrary_assign()\n \n void test_get()\n {\n-  {\n-    static_assert(is_same<decltype(get<0>(variant<int, string>())), int&&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, string>())), string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, string&>())), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, string&&>())), string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, const string>())), const string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, const string&>())), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(variant<int, const string&&>())), const string&&>::value, \"\");\n-\n-    static_assert(is_same<decltype(get<int>(variant<int, string>())), int&&>::value, \"\");\n-    static_assert(is_same<decltype(get<string>(variant<int, string>())), string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&>(variant<int, string&>())), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&&>(variant<int, string&&>())), string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string>(variant<int, const string>())), const string&&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&>(variant<int, const string&>())), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&&>(variant<int, const string&&>())), const string&&>::value, \"\");\n-  }\n-  {\n-    variant<int, string> a;\n-    variant<int, string&> b;\n-    variant<int, string&&> c;\n-    variant<int, const string> d;\n-    variant<int, const string&> e;\n-    variant<int, const string&&> f;\n-\n-    static_assert(is_same<decltype(get<0>(a)), int&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(a)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(b)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(c)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(f)), const string&>::value, \"\");\n-\n-    static_assert(is_same<decltype(get<int>(a)), int&>::value, \"\");\n-    static_assert(is_same<decltype(get<string>(a)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&>(b)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&&>(c)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&&>(f)), const string&>::value, \"\");\n-\n-    static_assert(is_same<decltype(get_if<0>(&a)), int*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&a)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&b)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&c)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&f)), const string*>::value, \"\");\n-\n-    static_assert(is_same<decltype(get_if<int>(&a)), int*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string>(&a)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string&>(&b)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string&&>(&c)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string&>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string&&>(&f)), const string*>::value, \"\");\n-  }\n-  {\n-    const variant<int, string> a;\n-    const variant<int, string&> b;\n-    const variant<int, string&&> c;\n-    const variant<int, const string> d;\n-    const variant<int, const string&> e;\n-    const variant<int, const string&&> f;\n-\n-    static_assert(is_same<decltype(get<0>(a)), const int&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(a)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(b)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(c)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(d)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<1>(f)), const string&>::value, \"\");\n-\n-    static_assert(is_same<decltype(get<int>(a)), const int&>::value, \"\");\n-    static_assert(is_same<decltype(get<string>(a)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&>(b)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<string&&>(c)), string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string>(d)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&>(e)), const string&>::value, \"\");\n-    static_assert(is_same<decltype(get<const string&&>(f)), const string&>::value, \"\");\n-\n-    static_assert(is_same<decltype(get_if<0>(&a)), const int*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&a)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&b)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&c)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&d)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<1>(&f)), const string*>::value, \"\");\n-\n-    static_assert(is_same<decltype(get_if<int>(&a)), const int*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string>(&a)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string&>(&b)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<string&&>(&c)), string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string>(&d)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string&>(&e)), const string*>::value, \"\");\n-    static_assert(is_same<decltype(get_if<const string&&>(&f)), const string*>::value, \"\");\n-  }\n+  static_assert(is_same<decltype(get<0>(variant<int, string>())), int&&>::value, \"\");\n+  static_assert(is_same<decltype(get<1>(variant<int, string>())), string&&>::value, \"\");\n+  static_assert(is_same<decltype(get<1>(variant<int, const string>())), const string&&>::value, \"\");\n+\n+  static_assert(is_same<decltype(get<int>(variant<int, string>())), int&&>::value, \"\");\n+  static_assert(is_same<decltype(get<string>(variant<int, string>())), string&&>::value, \"\");\n+  static_assert(is_same<decltype(get<const string>(variant<int, const string>())), const string&&>::value, \"\");\n }\n \n void test_relational()\n@@ -344,16 +239,6 @@ void test_visit()\n       void operator()(monostate) const {}\n       void operator()(const int&) const {}\n     };\n-    variant<monostate, int&, const int&, int&&, const int&&> a;\n-    const variant<monostate, int&, const int&, int&&, const int&&> b;\n-    Visitor v;\n-    const CVisitor u;\n-    static_assert(is_same<void, decltype(visit(Visitor(), a))>::value, \"\");\n-    static_assert(is_same<void, decltype(visit(Visitor(), b))>::value, \"\");\n-    static_assert(is_same<void, decltype(visit(v, a))>::value, \"\");\n-    static_assert(is_same<void, decltype(visit(v, b))>::value, \"\");\n-    static_assert(is_same<void, decltype(visit(u, a))>::value, \"\");\n-    static_assert(is_same<void, decltype(visit(u, b))>::value, \"\");\n   }\n   {\n     struct Visitor\n@@ -397,19 +282,6 @@ void test_constexpr()\n   }\n }\n \n-void test_void()\n-{\n-  static_assert(is_same<int&&, decltype(get<int>(variant<int, void>()))>::value, \"\");\n-  static_assert(!is_default_constructible_v<variant<void, int>>, \"\");\n-  static_assert(!is_copy_constructible_v<variant<int, void>>, \"\");\n-  static_assert(!is_move_constructible_v<variant<int, void>>, \"\");\n-  static_assert(!is_copy_assignable_v<variant<int, void>>, \"\");\n-  static_assert(!is_move_assignable_v<variant<int, void>>, \"\");\n-  variant<int, void, string> v;\n-  v = 3;\n-  v = \"asdf\";\n-}\n-\n void test_pr77641()\n {\n   struct X {\n@@ -457,11 +329,4 @@ void test_adl()\n    variant<X> v7{allocator_arg, a, in_place_index<0>, il, x};\n    variant<X> v8{allocator_arg, a, in_place_type<X>, il, x};\n    variant<X> v9{allocator_arg, a, in_place_type<X>, 1};\n-\n-   std::variant<X&> vr0(x);\n-   vr0 = x;\n-   variant<X&> vr1{in_place_index<0>, x};\n-   variant<X&> vr2{in_place_type<X&>, x};\n-   variant<X&> vr3{allocator_arg, a, in_place_index<0>, x};\n-   variant<X&> vr4{allocator_arg, a, in_place_type<X&>, x};\n }"}]}