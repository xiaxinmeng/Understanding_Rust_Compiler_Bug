{"sha": "ea85edfe73100acc3769d924074b42a9cf35a6d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWE4NWVkZmU3MzEwMGFjYzM3NjlkOTI0MDc0YjQyYTljZjM1YTZkMQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-12-13T13:59:35Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2011-12-13T13:59:35Z"}, "message": "re PR tree-optimization/51117 (rev.181172 causes glibc build failure)\n\n\tPR tree-optimization/51117\n\t* tree-eh.c (sink_clobbers): New function.\n\t(execute_lower_eh_dispatch): Call it for BBs ending with\n\tinternally throwing RESX.\n\t* cfgexpand.c (add_scope_conflicts_1): Add all conflicts only\n\tat the first real instruction.\n\nCo-Authored-By: Michael Matz <matz@suse.de>\n\nFrom-SVN: r182283", "tree": {"sha": "294ef0e96dd02fad62f02e425810cacff0f728be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/294ef0e96dd02fad62f02e425810cacff0f728be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ea85edfe73100acc3769d924074b42a9cf35a6d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea85edfe73100acc3769d924074b42a9cf35a6d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ea85edfe73100acc3769d924074b42a9cf35a6d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ea85edfe73100acc3769d924074b42a9cf35a6d1/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc45e4ba5adbdf11bebdae6aff125344cb9a4f75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc45e4ba5adbdf11bebdae6aff125344cb9a4f75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc45e4ba5adbdf11bebdae6aff125344cb9a4f75"}], "stats": {"total": 146, "additions": 116, "deletions": 30}, "files": [{"sha": "876245b6976f4914d9cb46e451f49b884f9e1dd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ea85edfe73100acc3769d924074b42a9cf35a6d1", "patch": "@@ -1,3 +1,13 @@\n+2011-12-13  Jakub Jelinek  <jakub@redhat.com>\n+\t    Michael Matz  <matz@suse.de>\n+\n+\tPR tree-optimization/51117\n+\t* tree-eh.c (sink_clobbers): New function.\n+\t(execute_lower_eh_dispatch): Call it for BBs ending with\n+\tinternally throwing RESX.\n+\t* cfgexpand.c (add_scope_conflicts_1): Add all conflicts only\n+\tat the first real instruction.\n+\n 2011-12-13  Tristan Gingold  <gingold@adacore.com>\n \n \t* final.c (final_scan_insn): Guard the call to begin_epilogue"}, {"sha": "d41497d31c0d3585f7cef27fc85ed370613354e4", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 26, "deletions": 24, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=ea85edfe73100acc3769d924074b42a9cf35a6d1", "patch": "@@ -456,34 +456,14 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n   FOR_EACH_EDGE (e, ei, bb->preds)\n     bitmap_ior_into (work, (bitmap)e->src->aux);\n \n-  if (for_conflict)\n-    {\n-      /* We need to add conflicts for everything life at the start of\n-         this block.  Unlike classical lifeness for named objects we can't\n-\t rely on seeing a def/use of the names we're interested in.\n-\t There might merely be indirect loads/stores.  We'd not add any\n-\t conflicts for such partitions.  */\n-      bitmap_iterator bi;\n-      unsigned i;\n-      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n-\t{\n-\t  unsigned j;\n-\t  bitmap_iterator bj;\n-\t  EXECUTE_IF_SET_IN_BITMAP (work, i, j, bj)\n-\t    add_stack_var_conflict (i, j);\n-\t}\n-      visit = visit_conflict;\n-    }\n-  else\n-    visit = visit_op;\n+  visit = visit_op;\n \n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n-      if (!is_gimple_debug (stmt))\n-\twalk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n+      walk_stmt_load_store_addr_ops (stmt, work, NULL, NULL, visit);\n     }\n-  for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+  for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple stmt = gsi_stmt (gsi);\n \n@@ -501,7 +481,29 @@ add_scope_conflicts_1 (basic_block bb, bitmap work, bool for_conflict)\n \t    bitmap_clear_bit (work, *v);\n \t}\n       else if (!is_gimple_debug (stmt))\n-\twalk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n+\t{\n+\t  if (for_conflict\n+\t      && visit == visit_op)\n+\t    {\n+\t      /* If this is the first real instruction in this BB we need\n+\t         to add conflicts for everything life at this point now.\n+\t\t Unlike classical lifeness for named objects we can't\n+\t\t rely on seeing a def/use of the names we're interested in.\n+\t\t There might merely be indirect loads/stores.  We'd not add any\n+\t\t conflicts for such partitions.  */\n+\t      bitmap_iterator bi;\n+\t      unsigned i;\n+\t      EXECUTE_IF_SET_IN_BITMAP (work, 0, i, bi)\n+\t\t{\n+\t\t  unsigned j;\n+\t\t  bitmap_iterator bj;\n+\t\t  EXECUTE_IF_SET_IN_BITMAP (work, i + 1, j, bj)\n+\t\t    add_stack_var_conflict (i, j);\n+\t\t}\n+\t      visit = visit_conflict;\n+\t    }\n+\t  walk_stmt_load_store_addr_ops (stmt, work, visit, visit, visit);\n+\t}\n     }\n }\n "}, {"sha": "0631ee1cf8dd066d1cce8983fdde762ef8e0b45e", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 80, "deletions": 6, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ea85edfe73100acc3769d924074b42a9cf35a6d1/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=ea85edfe73100acc3769d924074b42a9cf35a6d1", "patch": "@@ -3194,6 +3194,76 @@ optimize_clobbers (basic_block bb)\n     }\n }\n \n+/* Try to sink var = {v} {CLOBBER} stmts followed just by\n+   internal throw to successor BB.  */\n+\n+static int\n+sink_clobbers (basic_block bb)\n+{\n+  edge e;\n+  edge_iterator ei;\n+  gimple_stmt_iterator gsi, dgsi;\n+  basic_block succbb;\n+  bool any_clobbers = false;\n+\n+  /* Only optimize if BB has a single EH successor and\n+     all predecessor edges are EH too.  */\n+  if (!single_succ_p (bb)\n+      || (single_succ_edge (bb)->flags & EDGE_EH) == 0)\n+    return 0;\n+\n+  FOR_EACH_EDGE (e, ei, bb->preds)\n+    {\n+      if ((e->flags & EDGE_EH) == 0)\n+\treturn 0;\n+    }\n+\n+  /* And BB contains only CLOBBER stmts before the final\n+     RESX.  */\n+  gsi = gsi_last_bb (bb);\n+  for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tbreak;\n+      if (!gimple_clobber_p (stmt)\n+\t  || TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME)\n+\treturn 0;\n+      any_clobbers = true;\n+    }\n+  if (!any_clobbers)\n+    return 0;\n+\n+  succbb = single_succ (bb);\n+  dgsi = gsi_after_labels (succbb);\n+  gsi = gsi_last_bb (bb);\n+  for (gsi_prev (&gsi); !gsi_end_p (gsi); gsi_prev (&gsi))\n+    {\n+      gimple stmt = gsi_stmt (gsi);\n+      tree vdef;\n+      if (is_gimple_debug (stmt))\n+\tcontinue;\n+      if (gimple_code (stmt) == GIMPLE_LABEL)\n+\tbreak;\n+      unlink_stmt_vdef (stmt);\n+      gsi_remove (&gsi, false);\n+      vdef = gimple_vdef (stmt);\n+      if (vdef && TREE_CODE (vdef) == SSA_NAME)\n+\t{\n+\t  vdef = SSA_NAME_VAR (vdef);\n+\t  mark_sym_for_renaming (vdef);\n+\t  gimple_set_vdef (stmt, vdef);\n+\t  gimple_set_vuse (stmt, vdef);\n+\t}\n+      release_defs (stmt);\n+      gsi_insert_before (&dgsi, stmt, GSI_SAME_STMT);\n+    }\n+\n+  return TODO_update_ssa_only_virtuals;\n+}\n+\n /* At the end of inlining, we can lower EH_DISPATCH.  Return true when \n    we have found some duplicate labels and removed some edges.  */\n \n@@ -3349,7 +3419,7 @@ static unsigned\n execute_lower_eh_dispatch (void)\n {\n   basic_block bb;\n-  bool any_rewritten = false;\n+  int flags = 0;\n   bool redirected = false;\n \n   assign_filter_values ();\n@@ -3362,16 +3432,20 @@ execute_lower_eh_dispatch (void)\n       if (gimple_code (last) == GIMPLE_EH_DISPATCH)\n \t{\n \t  redirected |= lower_eh_dispatch (bb, last);\n-\t  any_rewritten = true;\n+\t  flags |= TODO_update_ssa_only_virtuals;\n+\t}\n+      else if (gimple_code (last) == GIMPLE_RESX)\n+\t{\n+\t  if (stmt_can_throw_external (last))\n+\t    optimize_clobbers (bb);\n+\t  else\n+\t    flags |= sink_clobbers (bb);\n \t}\n-      else if (gimple_code (last) == GIMPLE_RESX\n-\t       && stmt_can_throw_external (last))\n-\toptimize_clobbers (bb);\n     }\n \n   if (redirected)\n     delete_unreachable_blocks ();\n-  return any_rewritten ? TODO_update_ssa_only_virtuals : 0;\n+  return flags;\n }\n \n static bool"}]}