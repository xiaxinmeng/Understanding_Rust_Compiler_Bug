{"sha": "ce92603fbe3b4870e0a38efee1ee766d62942065", "node_id": "C_kwDOANBUbNoAKGNlOTI2MDNmYmUzYjQ4NzBlMGEzOGVmZWUxZWU3NjZkNjI5NDIwNjU", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-18T10:06:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-07-18T11:19:22Z"}, "message": "Improve common reduction vs builtin code generation in loop distribution\n\nloop distribution currently cannot handle the situation when the\nlast partition is a builtin but there's a common reduction in all\npartitions (like the final IV value).  The following lifts this\nrestriction by making the last non-builtin partition provide the\ndefinitions for the loop-closed PHI nodes.  Since we have heuristics\nin place to avoid code generating builtins last writing a testcase\nis difficult (but I ran into a case with other pending patches that\nmade the heuristic ineffective).  What's remaining is the inability\nto preserve common reductions when all partitions could be builtins\n(in some cases final value replacement could come to the rescue here).\n\n\t* tree-loop-distribution.cc (copy_loop_before): Add\n\tthe ability to replace the original LC PHI defs.\n\t(generate_loops_for_partition): Pass through a flag\n\twhether to redirect original LC PHI defs.\n\t(generate_code_for_partition): Likewise.\n\t(loop_distribution::distribute_loop): Compute the partition\n\tthat should provide the LC PHI defs for common reductions\n\tand pass that down.", "tree": {"sha": "7c2e3509cfb309d40b67c8bdada115918c25e76f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7c2e3509cfb309d40b67c8bdada115918c25e76f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ce92603fbe3b4870e0a38efee1ee766d62942065", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce92603fbe3b4870e0a38efee1ee766d62942065", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce92603fbe3b4870e0a38efee1ee766d62942065", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce92603fbe3b4870e0a38efee1ee766d62942065/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "06039e71f02e478280ed63a63cbf5e76f3897513", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06039e71f02e478280ed63a63cbf5e76f3897513", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06039e71f02e478280ed63a63cbf5e76f3897513"}], "stats": {"total": 64, "additions": 45, "deletions": 19}, "files": [{"sha": "0714bc41a43e7e6ad68f14216e18094567d4a378", "filename": "gcc/tree-loop-distribution.cc", "status": "modified", "additions": 45, "deletions": 19, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ce92603fbe3b4870e0a38efee1ee766d62942065/gcc%2Ftree-loop-distribution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ce92603fbe3b4870e0a38efee1ee766d62942065/gcc%2Ftree-loop-distribution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.cc?ref=ce92603fbe3b4870e0a38efee1ee766d62942065", "patch": "@@ -942,14 +942,32 @@ stmt_has_scalar_dependences_outside_loop (loop_p loop, gimple *stmt)\n /* Return a copy of LOOP placed before LOOP.  */\n \n static class loop *\n-copy_loop_before (class loop *loop)\n+copy_loop_before (class loop *loop, bool redirect_lc_phi_defs)\n {\n   class loop *res;\n   edge preheader = loop_preheader_edge (loop);\n \n   initialize_original_copy_tables ();\n   res = slpeel_tree_duplicate_loop_to_edge_cfg (loop, NULL, preheader);\n   gcc_assert (res != NULL);\n+\n+  /* When a not last partition is supposed to keep the LC PHIs computed\n+     adjust their definitions.  */\n+  if (redirect_lc_phi_defs)\n+    {\n+      edge exit = single_exit (loop);\n+      for (gphi_iterator si = gsi_start_phis (exit->dest); !gsi_end_p (si);\n+\t   gsi_next (&si))\n+\t{\n+\t  gphi *phi = si.phi ();\n+\t  if (virtual_operand_p (gimple_phi_result (phi)))\n+\t    continue;\n+\t  use_operand_p use_p = PHI_ARG_DEF_PTR_FROM_EDGE (phi, exit);\n+\t  tree new_def = get_current_def (USE_FROM_PTR (use_p));\n+\t  SET_USE (use_p, new_def);\n+\t}\n+    }\n+\n   free_original_copy_tables ();\n   delete_update_ssa ();\n \n@@ -977,15 +995,15 @@ create_bb_after_loop (class loop *loop)\n \n static void\n generate_loops_for_partition (class loop *loop, partition *partition,\n-\t\t\t      bool copy_p)\n+\t\t\t      bool copy_p, bool keep_lc_phis_p)\n {\n   unsigned i;\n   basic_block *bbs;\n \n   if (copy_p)\n     {\n       int orig_loop_num = loop->orig_loop_num;\n-      loop = copy_loop_before (loop);\n+      loop = copy_loop_before (loop, keep_lc_phis_p);\n       gcc_assert (loop != NULL);\n       loop->orig_loop_num = orig_loop_num;\n       create_preheader (loop, CP_SIMPLE_PREHEADERS);\n@@ -1336,7 +1354,8 @@ destroy_loop (class loop *loop)\n \n static bool \n generate_code_for_partition (class loop *loop,\n-\t\t\t     partition *partition, bool copy_p)\n+\t\t\t     partition *partition, bool copy_p,\n+\t\t\t     bool keep_lc_phis_p)\n {\n   switch (partition->kind)\n     {\n@@ -1345,7 +1364,8 @@ generate_code_for_partition (class loop *loop,\n       /* Reductions all have to be in the last partition.  */\n       gcc_assert (!partition_reduction_p (partition)\n \t\t  || !copy_p);\n-      generate_loops_for_partition (loop, partition, copy_p);\n+      generate_loops_for_partition (loop, partition, copy_p,\n+\t\t\t\t    keep_lc_phis_p);\n       return false;\n \n     case PKIND_MEMSET:\n@@ -3013,6 +3033,7 @@ loop_distribution::distribute_loop (class loop *loop,\n \n   bool any_builtin = false;\n   bool reduction_in_all = false;\n+  int reduction_partition_num = -1;\n   FOR_EACH_VEC_ELT (partitions, i, partition)\n     {\n       reduction_in_all\n@@ -3092,10 +3113,13 @@ loop_distribution::distribute_loop (class loop *loop,\n     }\n \n   /* Put a non-builtin partition last if we need to preserve a reduction.\n-     ???  This is a workaround that makes sort_partitions_by_post_order do\n-     the correct thing while in reality it should sort each component\n-     separately and then put the component with a reduction or a non-builtin\n-     last.  */\n+     In most cases this helps to keep a normal partition last avoiding to\n+     spill a reduction result across builtin calls.\n+     ???  The proper way would be to use dependences to see whether we\n+     can move builtin partitions earlier during merge_dep_scc_partitions\n+     and its sort_partitions_by_post_order.  Especially when the\n+     dependence graph is composed of multiple independent subgraphs the\n+     heuristic does not work reliably.  */\n   if (reduction_in_all\n       && partition_builtin_p (partitions.last()))\n     FOR_EACH_VEC_ELT (partitions, i, partition)\n@@ -3126,19 +3150,20 @@ loop_distribution::distribute_loop (class loop *loop,\n \n   finalize_partitions (loop, &partitions, &alias_ddrs);\n \n-  /* If there is a reduction in all partitions make sure the last one\n-     is not classified for builtin code generation.  */\n+  /* If there is a reduction in all partitions make sure the last\n+     non-builtin partition provides the LC PHI defs.  */\n   if (reduction_in_all)\n     {\n-      partition = partitions.last ();\n-      if (only_patterns_p\n-\t  && partition_builtin_p (partition)\n-\t  && !partition_builtin_p (partitions[0]))\n+      FOR_EACH_VEC_ELT (partitions, i, partition)\n+\tif (!partition_builtin_p (partition))\n+\t  reduction_partition_num = i;\n+      if (reduction_partition_num == -1)\n \t{\n-\t  nbp = 0;\n-\t  goto ldist_done;\n+\t  /* If all partitions are builtin, force the last one to\n+\t     be code generated as normal partition.  */\n+\t  partition = partitions.last ();\n+\t  partition->kind = PKIND_NORMAL;\n \t}\n-      partition->kind = PKIND_NORMAL;\n     }\n \n   nbp = partitions.length ();\n@@ -3164,7 +3189,8 @@ loop_distribution::distribute_loop (class loop *loop,\n     {\n       if (partition_builtin_p (partition))\n \t(*nb_calls)++;\n-      *destroy_p |= generate_code_for_partition (loop, partition, i < nbp - 1);\n+      *destroy_p |= generate_code_for_partition (loop, partition, i < nbp - 1,\n+\t\t\t\t\t\t i == reduction_partition_num);\n     }\n \n  ldist_done:"}]}