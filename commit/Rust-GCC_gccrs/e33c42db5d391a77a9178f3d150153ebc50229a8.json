{"sha": "e33c42db5d391a77a9178f3d150153ebc50229a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTMzYzQyZGI1ZDM5MWE3N2E5MTc4ZjNkMTUwMTUzZWJjNTAyMjlhOA==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2010-03-17T09:25:35Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2010-03-17T09:25:35Z"}, "message": "re PR rtl-optimization/42216 (changes in scheduling regress 464.h264ref 20%)\n\n\tPR rtl-optimization/42216\n\t* regrename.c (create_new_chain): New function, broken out from...\n\t(scan_rtx_reg): ... here.  Call it.  Handle the case where we are\n\tappending a use to an empty chain.\n\t(build_def_use): Remove previous changes that convert OP_INOUT to\n\tOP_OUT operands; instead detect the case where an OP_INOUT operand\n\tuses a previously untracked register and create an empty chain for\n\tit.\n\nFrom-SVN: r157511", "tree": {"sha": "79f93c327c44f2bd3488b8246a50ccea1207d51f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79f93c327c44f2bd3488b8246a50ccea1207d51f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e33c42db5d391a77a9178f3d150153ebc50229a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c42db5d391a77a9178f3d150153ebc50229a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e33c42db5d391a77a9178f3d150153ebc50229a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e33c42db5d391a77a9178f3d150153ebc50229a8/comments", "author": null, "committer": null, "parents": [{"sha": "4c4177dc90e8db16a78d6a6805eff25637cecbd1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c4177dc90e8db16a78d6a6805eff25637cecbd1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c4177dc90e8db16a78d6a6805eff25637cecbd1"}], "stats": {"total": 157, "additions": 92, "deletions": 65}, "files": [{"sha": "35f813d17aea20bbab2a08b050546845b08a9d3d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c42db5d391a77a9178f3d150153ebc50229a8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c42db5d391a77a9178f3d150153ebc50229a8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e33c42db5d391a77a9178f3d150153ebc50229a8", "patch": "@@ -1,3 +1,14 @@\n+2010-03-17  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\tPR rtl-optimization/42216\n+\t* regrename.c (create_new_chain): New function, broken out from...\n+\t(scan_rtx_reg): ... here.  Call it.  Handle the case where we are\n+\tappending a use to an empty chain.\n+\t(build_def_use): Remove previous changes that convert OP_INOUT to\n+\tOP_OUT operands; instead detect the case where an OP_INOUT operand\n+\tuses a previously untracked register and create an empty chain for\n+\tit.\n+\n 2010-03-17  Ralf Wildenhues  <Ralf.Wildenhues@gmx.de>\n \n \t* doc/extend.texi (Function Attributes): Rewrite unfinished"}, {"sha": "d6063a83a52139adb814535bca4a71abe79e1e1c", "filename": "gcc/regrename.c", "status": "modified", "additions": 81, "deletions": 65, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e33c42db5d391a77a9178f3d150153ebc50229a8/gcc%2Fregrename.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e33c42db5d391a77a9178f3d150153ebc50229a8/gcc%2Fregrename.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregrename.c?ref=e33c42db5d391a77a9178f3d150153ebc50229a8", "patch": "@@ -509,6 +509,72 @@ note_sets_clobbers (rtx x, const_rtx set, void *data)\n     add_to_hard_reg_set (&chain->hard_conflicts, GET_MODE (x), REGNO (x));\n }\n \n+/* Create a new chain for THIS_NREGS registers starting at THIS_REGNO,\n+   and record its occurrence in *LOC, which is being written to in INSN.\n+   This access requires a register of class CL.  */\n+\n+static void\n+create_new_chain (unsigned this_regno, unsigned this_nregs, rtx *loc,\n+\t\t  rtx insn, enum reg_class cl)\n+{\n+  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n+  struct du_chain *this_du;\n+  int nregs;\n+\n+  head->next_chain = open_chains;\n+  open_chains = head;\n+  head->regno = this_regno;\n+  head->nregs = this_nregs;\n+  head->need_caller_save_reg = 0;\n+  head->cannot_rename = 0;\n+  head->terminated = 0;\n+\n+  VEC_safe_push (du_head_p, heap, id_to_chain, head);\n+  head->id = current_id++;\n+\n+  bitmap_initialize (&head->conflicts, &bitmap_default_obstack);\n+  bitmap_copy (&head->conflicts, &open_chains_set);\n+  mark_conflict (open_chains, head->id);\n+\n+  /* Since we're tracking this as a chain now, remove it from the\n+     list of conflicting live hard registers and track it in\n+     live_in_chains instead.  */\n+  nregs = head->nregs;\n+  while (nregs-- > 0)\n+    {\n+      SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n+      CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n+    }\n+\n+  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n+  bitmap_set_bit (&open_chains_set, head->id);\n+\n+  open_chains = head;\n+\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"Creating chain %s (%d)\",\n+\t       reg_names[head->regno], head->id);\n+      if (insn != NULL_RTX)\n+\tfprintf (dump_file, \" at insn %d\", INSN_UID (insn));\n+      fprintf (dump_file, \"\\n\");\n+    }\n+\n+  if (insn == NULL_RTX)\n+    {\n+      head->first = head->last = NULL;\n+      return;\n+    }\n+\n+  this_du = XOBNEW (&rename_obstack, struct du_chain);\n+  head->first = head->last = this_du;\n+\n+  this_du->next_use = 0;\n+  this_du->loc = loc;\n+  this_du->insn = insn;\n+  this_du->cl = cl;\n+}\n+\n static void\n scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      enum op_type type)\n@@ -522,53 +588,7 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n   if (action == mark_write)\n     {\n       if (type == OP_OUT)\n-\t{\n-\t  struct du_head *head = XOBNEW (&rename_obstack, struct du_head);\n-\t  struct du_chain *this_du = XOBNEW (&rename_obstack, struct du_chain);\n-\t  int nregs;\n-\n-\t  head->next_chain = open_chains;\n-\t  open_chains = head;\n-\t  head->first = head->last = this_du;\n-\t  head->regno = this_regno;\n-\t  head->nregs = this_nregs;\n-\t  head->need_caller_save_reg = 0;\n-\t  head->cannot_rename = 0;\n-\t  head->terminated = 0;\n-\n-\t  VEC_safe_push (du_head_p, heap, id_to_chain, head);\n-\t  head->id = current_id++;\n-\n-\t  bitmap_initialize (&head->conflicts, &bitmap_default_obstack);\n-\t  bitmap_copy (&head->conflicts, &open_chains_set);\n-\t  mark_conflict (open_chains, head->id);\n-\n-\t  /* Since we're tracking this as a chain now, remove it from the\n-\t     list of conflicting live hard registers and track it in\n-\t     live_in_chains instead.  */\n-\t  nregs = head->nregs;\n-\t  while (nregs-- > 0)\n-\t    {\n-\t      SET_HARD_REG_BIT (live_in_chains, head->regno + nregs);\n-\t      CLEAR_HARD_REG_BIT (live_hard_regs, head->regno + nregs);\n-\t    }\n-\n-\t  COPY_HARD_REG_SET (head->hard_conflicts, live_hard_regs);\n-\t  bitmap_set_bit (&open_chains_set, head->id);\n-\n-\t  open_chains = head;\n-\n-\t  this_du->next_use = 0;\n-\t  this_du->loc = loc;\n-\t  this_du->insn = insn;\n-\t  this_du->cl = cl;\n-\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Creating chain %s (%d) at insn %d (%s)\\n\",\n-\t\t     reg_names[head->regno], head->id, INSN_UID (insn),\n-\t\t     scan_actions_name[(int) action]);\n-\t}\n+\tcreate_new_chain (this_regno, this_nregs, loc, insn, cl);\n       return;\n     }\n \n@@ -636,7 +656,10 @@ scan_rtx_reg (rtx insn, rtx *loc, enum reg_class cl, enum scan_actions action,\n \t      this_du->loc = loc;\n \t      this_du->insn = insn;\n \t      this_du->cl = cl;\n-\t      head->last->next_use = this_du;\n+\t      if (head->first == NULL)\n+\t\thead->first = this_du;\n+\t      else\n+\t\thead->last->next_use = this_du;\n \t      head->last = this_du;\n \n \t    }\n@@ -1069,7 +1092,6 @@ build_def_use (basic_block bb)\n \t  int n_ops;\n \t  rtx note;\n \t  rtx old_operands[MAX_RECOG_OPERANDS];\n-\t  bool has_dup[MAX_RECOG_OPERANDS];\n \t  rtx old_dups[MAX_DUP_OPERANDS];\n \t  int i;\n \t  int alt;\n@@ -1108,10 +1130,6 @@ build_def_use (basic_block bb)\n \t  n_ops = recog_data.n_operands;\n \t  untracked_operands = 0;\n \n-\t  memset (has_dup, 0, sizeof has_dup);\n-\t  for (i = 0; i < recog_data.n_dups; i++)\n-\t    has_dup[(int)recog_data.dup_num[i]] = true;\n-\n \t  /* Simplify the code below by rewriting things to reflect\n \t     matching constraints.  Also promote OP_OUT to OP_INOUT in\n \t     predicated instructions, but only for register operands\n@@ -1121,14 +1139,13 @@ build_def_use (basic_block bb)\n \t  predicated = GET_CODE (PATTERN (insn)) == COND_EXEC;\n \t  for (i = 0; i < n_ops; ++i)\n \t    {\n+\t      rtx op = recog_data.operand[i];\n \t      int matches = recog_op_alt[i][alt].matches;\n \t      if (matches >= 0)\n \t\trecog_op_alt[i][alt].cl = recog_op_alt[matches][alt].cl;\n \t      if (matches >= 0 || recog_op_alt[i][alt].matched >= 0\n-\t          || (predicated && recog_data.operand_type[i] == OP_OUT\n-\t\t      && verify_reg_tracked (recog_data.operand[i])))\n+\t          || (predicated && recog_data.operand_type[i] == OP_OUT))\n \t\t{\n-\t\t  rtx op = recog_data.operand[i];\n \t\t  recog_data.operand_type[i] = OP_INOUT;\n \t\t  /* A special case to deal with instruction patterns that\n \t\t     have matching operands with different modes.  If we're\n@@ -1145,18 +1162,17 @@ build_def_use (basic_block bb)\n \t\t    }\n \t\t}\n \t      /* If there's an in-out operand with a register that is not\n-\t\t being tracked at all yet, convert it to an earlyclobber\n-\t\t output operand.\n-\t\t This only works if the operand isn't duplicated, i.e. for\n-\t\t a ZERO_EXTRACT in a SET_DEST.  */\n+\t\t being tracked at all yet, open a chain.  */\n \t      if (recog_data.operand_type[i] == OP_INOUT\n \t\t  && !(untracked_operands & (1 << i))\n-\t\t  && !verify_reg_tracked (recog_data.operand[i]))\n+\t\t  && REG_P (op)\n+\t\t  && !verify_reg_tracked (op))\n \t\t{\n-\t\t  if (has_dup[i])\n-\t\t    fail_current_block = true;\n-\t\t  recog_data.operand_type[i] = OP_OUT;\n-\t\t  recog_op_alt[i][alt].earlyclobber = 1;\n+\t\t  enum machine_mode mode = GET_MODE (op);\n+\t\t  unsigned this_regno = REGNO (op);\n+\t\t  unsigned this_nregs = hard_regno_nregs[this_regno][mode];\n+\t\t  create_new_chain (this_regno, this_nregs, NULL, NULL_RTX,\n+\t\t\t\t    NO_REGS);\n \t\t}\n \t    }\n "}]}