{"sha": "bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM1YjJiNjg4MTUwZjk2YmQyYjc1YWExYjdmYzRkOWQ1MzcxMjk1NQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-11-08T07:37:07Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@gcc.gnu.org", "date": "2019-11-08T07:37:07Z"}, "message": "[rs6000]Fix PR92132 by adding vec_cmp and vcond_mask supports\n\n  To support full condition reduction vectorization, we have to define\n  vec_cmp* and vcond_mask_*.  This patch is to add related expands.\n  Also add the missing vector fp comparison RTL pattern supports\n  like: ungt, unge, unlt, unle, ne, lt and le.\n\ngcc/ChangeLog\n\n2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR target/92132\n    * config/rs6000/predicates.md\n    (signed_or_equality_comparison_operator): New predicate.\n    (unsigned_or_equality_comparison_operator): Likewise.\n    * config/rs6000/rs6000.md (one_cmpl<mode>2): Remove expand.\n    (one_cmpl<mode>3_internal): Rename to one_cmpl<mode>2.\n    * config/rs6000/vector.md\n    (vcond_mask_<mode><mode> for VEC_I and VEC_I): New expand.\n    (vec_cmp<mode><mode> for VEC_I and VEC_I): Likewise.\n    (vec_cmpu<mode><mode> for VEC_I and VEC_I): Likewise.\n    (vcond_mask_<mode><VEC_int> for VEC_F): New expand for float\n    vector modes and same-size integer vector modes.\n    (vec_cmp<mode><VEC_int> for VEC_F): Likewise.\n    (vector_lt<mode> for VEC_F): New expand.\n    (vector_le<mode> for VEC_F): Likewise.\n    (vector_ne<mode> for VEC_F): Likewise.\n    (vector_unge<mode> for VEC_F): Likewise.\n    (vector_ungt<mode> for VEC_F): Likewise.\n    (vector_unle<mode> for VEC_F): Likewise.\n    (vector_unlt<mode> for VEC_F): Likewise.\n    (vector_uneq<mode>): Expose name.\n    (vector_ltgt<mode>): Likewise.\n    (vector_unordered<mode>): Likewise.\n    (vector_ordered<mode>): Likewise.\n\ngcc/testsuite/ChangeLog\n\n2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>\n\n    PR target/92132\n    * gcc.target/powerpc/pr92132-fp-1.c: New test.\n    * gcc.target/powerpc/pr92132-fp-2.c: New test.\n    * gcc.target/powerpc/pr92132-int-1.c: New test.\n    * gcc.target/powerpc/pr92132-int-2.c: New test.\n\nFrom-SVN: r277947", "tree": {"sha": "72c6939503d3634fa7879b4050366ec2b89ce287", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/72c6939503d3634fa7879b4050366ec2b89ce287"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aeecaf58fa1fb33a08fba9b62f007740e9cb843", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1aeecaf58fa1fb33a08fba9b62f007740e9cb843", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1aeecaf58fa1fb33a08fba9b62f007740e9cb843"}], "stats": {"total": 1161, "additions": 1150, "deletions": 11}, "files": [{"sha": "0780b31a42e4dd29b849b21438530034f4a19cf8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -1,3 +1,30 @@\n+2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR target/92132\n+\t* config/rs6000/predicates.md\n+\t(signed_or_equality_comparison_operator): New predicate.\n+\t(unsigned_or_equality_comparison_operator): Likewise.\n+\t* config/rs6000/rs6000.md (one_cmpl<mode>2): Remove expand.\n+\t(one_cmpl<mode>3_internal): Rename to one_cmpl<mode>2.\n+\t* config/rs6000/vector.md\n+\t(vcond_mask_<mode><mode> for VEC_I and VEC_I): New expand.\n+\t(vec_cmp<mode><mode> for VEC_I and VEC_I): Likewise.\n+\t(vec_cmpu<mode><mode> for VEC_I and VEC_I): Likewise.\n+\t(vcond_mask_<mode><VEC_int> for VEC_F): New expand for float\n+\tvector modes and same-size integer vector modes.\n+\t(vec_cmp<mode><VEC_int> for VEC_F): Likewise.\n+\t(vector_lt<mode> for VEC_F): New expand.\n+\t(vector_le<mode> for VEC_F): Likewise.\n+\t(vector_ne<mode> for VEC_F): Likewise.\n+\t(vector_unge<mode> for VEC_F): Likewise.\n+\t(vector_ungt<mode> for VEC_F): Likewise.\n+\t(vector_unle<mode> for VEC_F): Likewise.\n+\t(vector_unlt<mode> for VEC_F): Likewise.\n+\t(vector_uneq<mode>): Expose name.\n+\t(vector_ltgt<mode>): Likewise.\n+\t(vector_unordered<mode>): Likewise.\n+\t(vector_ordered<mode>): Likewise.\n+\n 2019-11-08  Hongtao Liu  <Hongtao.liu@intel.com>\n \n \tPR target/92295"}, {"sha": "51cdd3a129d76236cad06135ea55b1b94754dcb2", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -1147,6 +1147,16 @@\n (define_predicate \"signed_comparison_operator\"\n   (match_code \"lt,gt,le,ge\"))\n \n+;; Return 1 if OP is a signed comparison or an equality operator.\n+(define_predicate \"signed_or_equality_comparison_operator\"\n+  (ior (match_operand 0 \"equality_operator\")\n+       (match_operand 0 \"signed_comparison_operator\")))\n+\n+;; Return 1 if OP is an unsigned comparison or an equality operator.\n+(define_predicate \"unsigned_or_equality_comparison_operator\"\n+  (ior (match_operand 0 \"equality_operator\")\n+       (match_operand 0 \"unsigned_comparison_operator\")))\n+\n ;; Return 1 if OP is a comparison operation that is valid for an SCC insn --\n ;; it must be a positive comparison.\n (define_predicate \"scc_comparison_operator\""}, {"sha": "fb18681da5d20738eaa10cc5441f016f5403d3f4", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -6504,12 +6504,6 @@\n   \"\"\n   \"\")\n \n-(define_expand \"one_cmpl<mode>2\"\n-  [(set (match_operand:BOOL_128 0 \"vlogical_operand\")\n-        (not:BOOL_128 (match_operand:BOOL_128 1 \"vlogical_operand\")))]\n-  \"\"\n-  \"\")\n-\n (define_expand \"nor<mode>3\"\n   [(set (match_operand:BOOL_128 0 \"vlogical_operand\")\n \t(and:BOOL_128\n@@ -6804,7 +6798,7 @@\n \t (const_string \"16\")))])\n \n ;; 128-bit one's complement\n-(define_insn_and_split \"*one_cmpl<mode>3_internal\"\n+(define_insn_and_split \"one_cmpl<mode>2\"\n   [(set (match_operand:BOOL_128 0 \"vlogical_operand\" \"=<BOOL_REGS_OUTPUT>\")\n \t(not:BOOL_128\n \t  (match_operand:BOOL_128 1 \"vlogical_operand\" \"<BOOL_REGS_UNARY>\")))]"}, {"sha": "b132037290ec40c97838f0ac0122a9373d69e56d", "filename": "gcc/config/rs6000/vector.md", "status": "modified", "additions": 258, "deletions": 4, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Fvector.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Fconfig%2Frs6000%2Fvector.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvector.md?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -493,6 +493,260 @@\n     FAIL;\n })\n \n+;; To support vector condition vectorization, define vcond_mask and vec_cmp.\n+\n+;; Same mode for condition true/false values and predicate operand.\n+(define_expand \"vcond_mask_<mode><mode>\"\n+  [(match_operand:VEC_I 0 \"vint_operand\")\n+   (match_operand:VEC_I 1 \"vint_operand\")\n+   (match_operand:VEC_I 2 \"vint_operand\")\n+   (match_operand:VEC_I 3 \"vint_operand\")]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_select_<mode> (operands[0], operands[2], operands[1],\n+\t\t\t\t  operands[3]));\n+  DONE;\n+})\n+\n+;; Condition true/false values are float but predicate operand is of\n+;; type integer vector with same element size.\n+(define_expand \"vcond_mask_<mode><VEC_int>\"\n+  [(match_operand:VEC_F 0 \"vfloat_operand\")\n+   (match_operand:VEC_F 1 \"vfloat_operand\")\n+   (match_operand:VEC_F 2 \"vfloat_operand\")\n+   (match_operand:<VEC_INT> 3 \"vint_operand\")]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_select_<mode> (operands[0], operands[2], operands[1],\n+\t\t\t\t  gen_lowpart (<MODE>mode, operands[3])));\n+  DONE;\n+})\n+\n+;; For signed integer vectors comparison.\n+(define_expand \"vec_cmp<mode><mode>\"\n+  [(set (match_operand:VEC_I 0 \"vint_operand\")\n+\t(match_operator 1 \"signed_or_equality_comparison_operator\"\n+\t  [(match_operand:VEC_I 2 \"vint_operand\")\n+\t   (match_operand:VEC_I 3 \"vint_operand\")]))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  switch (code)\n+    {\n+    case NE:\n+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));\n+      emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+      break;\n+    case EQ:\n+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));\n+      break;\n+    case GE:\n+      emit_insn (gen_vector_nlt<mode> (operands[0],operands[2], operands[3],\n+\t\t\t\t       tmp));\n+      break;\n+    case GT:\n+      emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[3]));\n+      break;\n+    case LE:\n+      emit_insn (gen_vector_ngt<mode> (operands[0], operands[2], operands[3],\n+\t\t\t\t       tmp));\n+      break;\n+    case LT:\n+      emit_insn (gen_vector_gt<mode> (operands[0], operands[3], operands[2]));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+  DONE;\n+})\n+\n+;; For unsigned integer vectors comparison.\n+(define_expand \"vec_cmpu<mode><mode>\"\n+  [(set (match_operand:VEC_I 0 \"vint_operand\")\n+\t(match_operator 1 \"unsigned_or_equality_comparison_operator\"\n+\t  [(match_operand:VEC_I 2 \"vint_operand\")\n+\t   (match_operand:VEC_I 3 \"vint_operand\")]))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx tmp = gen_reg_rtx (<MODE>mode);\n+  switch (code)\n+    {\n+    case NE:\n+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));\n+      emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+      break;\n+    case EQ:\n+      emit_insn (gen_vector_eq<mode> (operands[0], operands[2], operands[3]));\n+      break;\n+    case GEU:\n+      emit_insn (gen_vector_nltu<mode> (operands[0], operands[2], operands[3],\n+\t\t\t\t\ttmp));\n+      break;\n+    case GTU:\n+      emit_insn (gen_vector_gtu<mode> (operands[0], operands[2], operands[3]));\n+      break;\n+    case LEU:\n+      emit_insn (gen_vector_ngtu<mode> (operands[0], operands[2], operands[3],\n+\t\t\t\t\ttmp));\n+      break;\n+    case LTU:\n+      emit_insn (gen_vector_gtu<mode> (operands[0], operands[3], operands[2]));\n+      break;\n+    default:\n+      gcc_unreachable ();\n+      break;\n+    }\n+  DONE;\n+})\n+\n+;; For float point vectors comparison.\n+(define_expand \"vec_cmp<mode><VEC_int>\"\n+  [(set (match_operand:<VEC_INT> 0 \"vint_operand\")\n+\t (match_operator 1 \"comparison_operator\"\n+\t    [(match_operand:VEC_F 2 \"vfloat_operand\")\n+\t    (match_operand:VEC_F 3 \"vfloat_operand\")]))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx res = gen_reg_rtx (<MODE>mode);\n+  switch (code)\n+    {\n+    case NE:\n+      emit_insn (gen_vector_ne<mode> (res, operands[2], operands[3]));\n+      break;\n+    case EQ:\n+      emit_insn (gen_vector_eq<mode> (res, operands[2], operands[3]));\n+      break;\n+    case GE:\n+      emit_insn (gen_vector_ge<mode> (res, operands[2], operands[3]));\n+      break;\n+    case GT:\n+      emit_insn (gen_vector_gt<mode> (res, operands[2], operands[3]));\n+      break;\n+    case LE:\n+      emit_insn (gen_vector_le<mode> (res, operands[2], operands[3]));\n+      break;\n+    case LT:\n+      emit_insn (gen_vector_lt<mode> (res, operands[2], operands[3]));\n+      break;\n+    case LTGT:\n+      emit_insn (gen_vector_ltgt<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNORDERED:\n+      emit_insn (gen_vector_unordered<mode> (res, operands[2], operands[3]));\n+      break;\n+    case ORDERED:\n+      emit_insn (gen_vector_ordered<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNEQ:\n+      emit_insn (gen_vector_uneq<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNGE:\n+      emit_insn (gen_vector_unge<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNGT:\n+      emit_insn (gen_vector_ungt<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNLE:\n+      emit_insn (gen_vector_unle<mode> (res, operands[2], operands[3]));\n+      break;\n+    case UNLT:\n+      emit_insn (gen_vector_unlt<mode> (res, operands[2], operands[3]));\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  emit_insn (gen_move_insn (operands[0], gen_lowpart (<VEC_INT>mode, res)));\n+  DONE;\n+})\n+\n+; lt(a,b) = gt(b,a)\n+(define_expand \"vector_lt<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(lt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[1]));\n+  DONE;\n+})\n+\n+; le(a,b) = ge(b,a)\n+(define_expand \"vector_le<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(le:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_ge<mode> (operands[0], operands[2], operands[1]));\n+  DONE;\n+})\n+\n+; ne(a,b) = ~eq(a,b)\n+(define_expand \"vector_ne<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(ne:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t  (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_eq<mode> (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n+; unge(a,b) = ~gt(b,a)\n+(define_expand \"vector_unge<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(unge:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_gt<mode> (operands[0], operands[2], operands[1]));\n+  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n+; ungt(a,b) = ~ge(b,a)\n+(define_expand \"vector_ungt<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(ungt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_ge<mode> (operands[0], operands[2], operands[1]));\n+  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n+; unle(a,b) = ~gt(a,b)\n+(define_expand \"vector_unle<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(unle:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_gt<mode> (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n+; unlt(a,b) = ~ge(a,b)\n+(define_expand \"vector_unlt<mode>\"\n+  [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n+\t(unlt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n+\t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n+  \"VECTOR_UNIT_ALTIVEC_OR_VSX_P (<MODE>mode)\"\n+{\n+  emit_insn (gen_vector_ge<mode> (operands[0], operands[1], operands[2]));\n+  emit_insn (gen_one_cmpl<mode>2 (operands[0], operands[0]));\n+  DONE;\n+})\n+\n (define_expand \"vector_eq<mode>\"\n   [(set (match_operand:VEC_C 0 \"vlogical_operand\")\n \t(eq:VEC_C (match_operand:VEC_C 1 \"vlogical_operand\")\n@@ -575,7 +829,7 @@\n   operands[3] = gen_reg_rtx_and_attrs (operands[0]);\n })\n \n-(define_insn_and_split \"*vector_uneq<mode>\"\n+(define_insn_and_split \"vector_uneq<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n \t(uneq:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n \t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n@@ -596,7 +850,7 @@\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n \n-(define_insn_and_split \"*vector_ltgt<mode>\"\n+(define_insn_and_split \"vector_ltgt<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n \t(ltgt:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n \t\t    (match_operand:VEC_F 2 \"vfloat_operand\")))]\n@@ -617,7 +871,7 @@\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n \n-(define_insn_and_split \"*vector_ordered<mode>\"\n+(define_insn_and_split \"vector_ordered<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n \t(ordered:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n \t\t       (match_operand:VEC_F 2 \"vfloat_operand\")))]\n@@ -638,7 +892,7 @@\n   operands[4] = gen_reg_rtx (<MODE>mode);\n })\n \n-(define_insn_and_split \"*vector_unordered<mode>\"\n+(define_insn_and_split \"vector_unordered<mode>\"\n   [(set (match_operand:VEC_F 0 \"vfloat_operand\")\n \t(unordered:VEC_F (match_operand:VEC_F 1 \"vfloat_operand\")\n \t\t\t (match_operand:VEC_F 2 \"vfloat_operand\")))]"}, {"sha": "9fbff8b363ae16649e3f65b75146db3e5a450985", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -1,3 +1,11 @@\n+2019-11-08  Kewen Lin  <linkw@gcc.gnu.org>\n+\n+\tPR target/92132\n+\t* gcc.target/powerpc/pr92132-fp-1.c: New test.\n+\t* gcc.target/powerpc/pr92132-fp-2.c: New test.\n+\t* gcc.target/powerpc/pr92132-int-1.c: New test.\n+\t* gcc.target/powerpc/pr92132-int-2.c: New test.\n+\n 2019-11-08  Hongtao Liu  <hongtao.liu@intel.com>\n \n \t* gcc.target/i386/pr92295.c: New test."}, {"sha": "1023e8cd9d8fda7ea3535b18cc77689f58a42e5a", "filename": "gcc/testsuite/gcc.target/powerpc/pr92132-fp-1.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-1.c?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -0,0 +1,297 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vsx_hw } */\n+/* { dg-options \"-O2 -ftree-vectorize -mvsx -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* To test condition reduction vectorization, where comparison operands are of\n+   double type and condition true/false values are integer type.  Cover all\n+   float point comparison codes.  */\n+\n+#include <math.h>\n+\n+extern void\n+abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+#define FP_TYPE double\n+\n+#define LTGT(a, b) (__builtin_islessgreater ((a), (b)))\n+#define UNORD(a, b) (__builtin_isunordered ((a), (b)))\n+#define ORD(a, b) (!__builtin_isunordered ((a), (b)))\n+#define UNEQ(a, b) (!__builtin_islessgreater ((a), (b)))\n+#define UNGT(a, b) (!__builtin_islessequal ((a), (b)))\n+#define UNGE(a, b) (!__builtin_isless ((a), (b)))\n+#define UNLT(a, b) (!__builtin_isgreaterequal ((a), (b)))\n+#define UNLE(a, b) (!__builtin_isgreater ((a), (b)))\n+\n+__attribute__ ((noinline)) int\n+test_eq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] == min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ne (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] != min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_gt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] > min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] >= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_lt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_le (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] <= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ltgt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (LTGT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ord (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (ORD (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unord (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNORD (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_uneq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNEQ (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ungt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNGT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNGE (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unlt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNLT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unle (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNLE (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+\n+  FP_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};\n+\n+  FP_TYPE a2[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20,  1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, NAN, 25, 26, 27};\n+\n+  FP_TYPE a3[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};\n+\n+  FP_TYPE a4[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11,  12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  NAN, 6,  7};\n+\n+  FP_TYPE a5[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11,  12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  NAN, 10, 10};\n+\n+  ret = test_eq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ne (a1, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_gt (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ge (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_lt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_le (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ltgt (a3, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_ltgt (a5, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  ret = test_unord (a5, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_ord (a5, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_uneq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_uneq (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_ungt (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ungt (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_unge (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ungt (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_unlt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_unlt (a2, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  ret = test_unle (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_unle (a2, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 14 \"vect\" } } */"}, {"sha": "db7b9ad7a17ebf4f232e41850613dea6fa7c4837", "filename": "gcc/testsuite/gcc.target/powerpc/pr92132-fp-2.c", "status": "added", "additions": 297, "deletions": 0, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-fp-2.c?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -0,0 +1,297 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target vmx_hw } */\n+/* { dg-options \"-O2 -ftree-vectorize -maltivec -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* To test condition reduction vectorization, where comparison operands are of\n+   float type and condition true/false values are integer type.  Cover all\n+   float point comparison codes.  */\n+\n+#include <math.h>\n+\n+extern void\n+abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+#define FP_TYPE float\n+\n+#define LTGT(a, b) (__builtin_islessgreater ((a), (b)))\n+#define UNORD(a, b) (__builtin_isunordered ((a), (b)))\n+#define ORD(a, b) (!__builtin_isunordered ((a), (b)))\n+#define UNEQ(a, b) (!__builtin_islessgreater ((a), (b)))\n+#define UNGT(a, b) (!__builtin_islessequal ((a), (b)))\n+#define UNGE(a, b) (!__builtin_isless ((a), (b)))\n+#define UNLT(a, b) (!__builtin_isgreaterequal ((a), (b)))\n+#define UNLE(a, b) (!__builtin_isgreater ((a), (b)))\n+\n+__attribute__ ((noinline)) int\n+test_eq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] == min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ne (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] != min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_gt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] > min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] >= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_lt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_le (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] <= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ltgt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (LTGT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ord (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (ORD (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unord (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNORD (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_uneq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNEQ (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ungt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNGT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNGE (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unlt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNLT (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_unle (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (UNLE (a[i], min_v))\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+\n+  FP_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};\n+\n+  FP_TYPE a2[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20,  1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, NAN, 25, 26, 27};\n+\n+  FP_TYPE a3[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};\n+\n+  FP_TYPE a4[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11,  12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  NAN, 6,  7};\n+\n+  FP_TYPE a5[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11,  12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  NAN, 10, 10};\n+\n+  ret = test_eq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ne (a1, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_gt (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ge (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_lt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_le (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ltgt (a3, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_ltgt (a5, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  ret = test_unord (a5, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_ord (a5, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_uneq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_uneq (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_ungt (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ungt (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_unge (a3, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ungt (a4, 10);\n+  if (ret != 24)\n+    abort ();\n+\n+  ret = test_unlt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_unlt (a2, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  ret = test_unle (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_unle (a2, 10);\n+  if (ret != 23)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 14 \"vect\" } } */"}, {"sha": "a786811a57f30d8447ea1982ad6a250e523e9aff", "filename": "gcc/testsuite/gcc.target/powerpc/pr92132-int-1.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-1.c?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-O2 -ftree-vectorize -mdejagnu-cpu=power8 -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* To test condition reduction vectorization, where comparison operands are of\n+   signed long long type and condition true/false values are integer type.  */\n+\n+#include <math.h>\n+\n+extern void\n+abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+#define FP_TYPE signed long long\n+\n+__attribute__ ((noinline)) int\n+test_eq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] == min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ne (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] != min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_gt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] > min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] >= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_lt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_le (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] <= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+\n+  FP_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};\n+\n+  FP_TYPE a2[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};\n+\n+  ret = test_eq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ne (a1, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_gt (a2, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ge (a2, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_lt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_le (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 6 \"vect\" } } */"}, {"sha": "dd3c0307535151f7cd0b24f4c509626fcaed2013", "filename": "gcc/testsuite/gcc.target/powerpc/pr92132-int-2.c", "status": "added", "additions": 126, "deletions": 0, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc5b2b688150f96bd2b75aa1b7fc4d9d53712955/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fpr92132-int-2.c?ref=bc5b2b688150f96bd2b75aa1b7fc4d9d53712955", "patch": "@@ -0,0 +1,126 @@\n+/* { dg-do run } */\n+/* { dg-require-effective-target p8vector_hw } */\n+/* { dg-options \"-O2 -ftree-vectorize -mdejagnu-cpu=power8 -fno-vect-cost-model -fdump-tree-vect-details\" } */\n+\n+/* To test condition reduction vectorization, where comparison operands are of\n+   unsigned long long type and condition true/false values are integer type.  */\n+\n+#include <math.h>\n+\n+extern void\n+abort (void) __attribute__ ((noreturn));\n+\n+#define N 27\n+#define FP_TYPE unsigned long long\n+\n+__attribute__ ((noinline)) int\n+test_eq (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] == min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ne (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] != min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_gt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] > min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_ge (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] >= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_lt (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] < min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+__attribute__ ((noinline)) int\n+test_le (FP_TYPE *a, FP_TYPE min_v)\n+{\n+  int last = 0;\n+\n+  for (int i = 0; i < N; i++)\n+    if (a[i] <= min_v)\n+      last = i;\n+\n+  return last;\n+}\n+\n+int\n+main (void)\n+{\n+  int ret = 0;\n+\n+  FP_TYPE a1[N] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 1,  2,  3, 4,\n+\t\t   5,  6,  7,  8,  9,  10, 21, 22, 23, 24, 25, 26, 27};\n+\n+  FP_TYPE a2[N] = {21, 22, 23, 24, 25, 26, 27, 28, 29, 10, 11, 12, 13, 14,\n+\t\t   15, 16, 17, 18, 19, 20, 1,  2,  3,  4,  5,  6,  7};\n+\n+  ret = test_eq (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ne (a1, 10);\n+  if (ret != 26)\n+    abort ();\n+\n+  ret = test_gt (a2, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_ge (a2, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  ret = test_lt (a1, 10);\n+  if (ret != 18)\n+    abort ();\n+\n+  ret = test_le (a1, 10);\n+  if (ret != 19)\n+    abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"LOOP VECTORIZED\" 6 \"vect\" } } */"}]}