{"sha": "054cf924ac00a47301a1c49f6433f70775fe1c0d", "node_id": "C_kwDOANBUbNoAKDA1NGNmOTI0YWMwMGE0NzMwMWExYzQ5ZjY0MzNmNzA3NzVmZTFjMGQ", "commit": {"author": {"name": "Yannick Moy", "email": "moy@adacore.com", "date": "2022-04-11T15:56:01Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-05-19T14:05:29Z"}, "message": "[Ada] Further adapt proof of double arithmetic runtime unit\n\nAfter changes in Why3 and generation of VCs, ghost code needs to be\nadapted for proofs to remain automatic.\n\ngcc/ada/\n\n\t* libgnat/s-aridou.adb (Lemma_Abs_Range,\n\tLemma_Double_Shift_Left, Lemma_Shift_Left): New lemmas.\n\t(Double_Divide): Add ghost code.\n\t(Lemma_Concat_Definition, Lemma_Double_Shift_Left,\n\tLemma_Shift_Left, Lemma_Shift_Right): Define or complete lemmas.\n\t(Scaled_Divide): Add ghost code.", "tree": {"sha": "c4b9ea9836b00503a8617c66309c39cdedddfecc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c4b9ea9836b00503a8617c66309c39cdedddfecc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/054cf924ac00a47301a1c49f6433f70775fe1c0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054cf924ac00a47301a1c49f6433f70775fe1c0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/054cf924ac00a47301a1c49f6433f70775fe1c0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/054cf924ac00a47301a1c49f6433f70775fe1c0d/comments", "author": {"login": "yannickmoy", "id": 859440, "node_id": "MDQ6VXNlcjg1OTQ0MA==", "avatar_url": "https://avatars.githubusercontent.com/u/859440?v=4", "gravatar_id": "", "url": "https://api.github.com/users/yannickmoy", "html_url": "https://github.com/yannickmoy", "followers_url": "https://api.github.com/users/yannickmoy/followers", "following_url": "https://api.github.com/users/yannickmoy/following{/other_user}", "gists_url": "https://api.github.com/users/yannickmoy/gists{/gist_id}", "starred_url": "https://api.github.com/users/yannickmoy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/yannickmoy/subscriptions", "organizations_url": "https://api.github.com/users/yannickmoy/orgs", "repos_url": "https://api.github.com/users/yannickmoy/repos", "events_url": "https://api.github.com/users/yannickmoy/events{/privacy}", "received_events_url": "https://api.github.com/users/yannickmoy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "88f7b07de7579251f5134b65dad406fdfda3d057", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/88f7b07de7579251f5134b65dad406fdfda3d057", "html_url": "https://github.com/Rust-GCC/gccrs/commit/88f7b07de7579251f5134b65dad406fdfda3d057"}], "stats": {"total": 175, "additions": 171, "deletions": 4}, "files": [{"sha": "d2149681dbec67425c16187774405933f387c6b3", "filename": "gcc/ada/libgnat/s-aridou.adb", "status": "modified", "additions": 171, "deletions": 4, "changes": 175, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/054cf924ac00a47301a1c49f6433f70775fe1c0d/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/054cf924ac00a47301a1c49f6433f70775fe1c0d/gcc%2Fada%2Flibgnat%2Fs-aridou.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-aridou.adb?ref=054cf924ac00a47301a1c49f6433f70775fe1c0d", "patch": "@@ -208,6 +208,13 @@ is\n      Ghost,\n      Post => abs (X * Y) = abs X * abs Y;\n \n+   procedure Lemma_Abs_Range (X : Big_Integer)\n+   with\n+     Ghost,\n+     Pre  => In_Double_Int_Range (X),\n+     Post => abs (X) <= Big_2xxDouble_Minus_1\n+       and then In_Double_Int_Range (-abs (X));\n+\n    procedure Lemma_Abs_Rem_Commutation (X, Y : Big_Integer)\n    with\n      Ghost,\n@@ -306,6 +313,20 @@ is\n      Pre  => S <= Double_Size - S1,\n      Post => Shift_Left (Shift_Left (X, S), S1) = Shift_Left (X, S + S1);\n \n+   procedure Lemma_Double_Shift_Left (X : Double_Uns; S, S1 : Double_Uns)\n+   with\n+     Ghost,\n+     Pre  => S <= Double_Uns (Double_Size)\n+       and then S1 <= Double_Uns (Double_Size),\n+     Post => Shift_Left (Shift_Left (X, Natural (S)), Natural (S1)) =\n+             Shift_Left (X, Natural (S + S1));\n+\n+   procedure Lemma_Double_Shift_Left (X : Double_Uns; S, S1 : Natural)\n+   with\n+     Ghost,\n+     Pre  => S <= Double_Size - S1,\n+     Post => Shift_Left (Shift_Left (X, S), S1) = Shift_Left (X, S + S1);\n+\n    procedure Lemma_Double_Shift_Right (X : Double_Uns; S, S1 : Double_Uns)\n    with\n      Ghost,\n@@ -505,6 +526,13 @@ is\n      Pre  => A = B * Q + R and then R < B,\n      Post => Q = A / B and then R = A rem B;\n \n+   procedure Lemma_Shift_Left (X : Double_Uns; Shift : Natural)\n+   with\n+     Ghost,\n+     Pre  => Shift < Double_Size\n+       and then Big (X) * Big_2xx (Shift) < Big_2xxDouble,\n+     Post => Big (Shift_Left (X, Shift)) = Big (X) * Big_2xx (Shift);\n+\n    procedure Lemma_Shift_Right (X : Double_Uns; Shift : Natural)\n    with\n      Ghost,\n@@ -560,10 +588,10 @@ is\n    procedure Inline_Le3 (X1, X2, X3, Y1, Y2, Y3 : Single_Uns) is null;\n    procedure Lemma_Abs_Commutation (X : Double_Int) is null;\n    procedure Lemma_Abs_Mult_Commutation (X, Y : Big_Integer) is null;\n+   procedure Lemma_Abs_Range (X : Big_Integer) is null;\n    procedure Lemma_Add_Commutation (X : Double_Uns; Y : Single_Uns) is null;\n    procedure Lemma_Add_One (X : Double_Uns) is null;\n    procedure Lemma_Bounded_Powers_Of_2_Increasing (M, N : Natural) is null;\n-   procedure Lemma_Concat_Definition (X, Y : Single_Uns) is null;\n    procedure Lemma_Deep_Mult_Commutation\n      (Factor : Big_Integer;\n       X, Y   : Single_Uns)\n@@ -581,6 +609,8 @@ is\n    procedure Lemma_Double_Big_2xxSingle is null;\n    procedure Lemma_Double_Shift (X : Double_Uns; S, S1 : Double_Uns) is null;\n    procedure Lemma_Double_Shift (X : Single_Uns; S, S1 : Natural) is null;\n+   procedure Lemma_Double_Shift_Left (X : Double_Uns; S, S1 : Double_Uns)\n+   is null;\n    procedure Lemma_Double_Shift_Right (X : Double_Uns; S, S1 : Double_Uns)\n    is null;\n    procedure Lemma_Ge_Commutation (A, B : Double_Uns) is null;\n@@ -949,6 +979,7 @@ is\n                   pragma Assert (if X = Double_Int'First and then Round then\n                                     Mult > Big_2xxDouble);\n                elsif Ylo > 0 then\n+                  pragma Assert (Double_Uns'(Ylo * Zhi) > 0);\n                   pragma Assert (Big (Double_Uns'(Ylo * Zhi)) > 0);\n                   pragma Assert (if X = Double_Int'First and then Round then\n                                     Mult > Big_2xxDouble);\n@@ -1024,15 +1055,24 @@ is\n             pragma Assert (Big (Double_Uns (Hi (T2))) >= 1);\n             pragma Assert (Big (Double_Uns (Lo (T2))) >= 0);\n             pragma Assert (Big (Double_Uns (Lo (T1))) >= 0);\n+            pragma Assert (Mult >= Big_2xxDouble * Big (Double_Uns (Hi (T2))));\n             pragma Assert (Mult >= Big_2xxDouble);\n             if Hi (T2) > 1 then\n                pragma Assert (Big (Double_Uns (Hi (T2))) > 1);\n+               pragma Assert (if X = Double_Int'First and then Round then\n+                                 Mult > Big_2xxDouble);\n             elsif Lo (T2) > 0 then\n                pragma Assert (Big (Double_Uns (Lo (T2))) > 0);\n+               pragma Assert (if X = Double_Int'First and then Round then\n+                                 Mult > Big_2xxDouble);\n             elsif Lo (T1) > 0 then\n                pragma Assert (Double_Uns (Lo (T1)) > 0);\n                Lemma_Gt_Commutation (Double_Uns (Lo (T1)), 0);\n                pragma Assert (Big (Double_Uns (Lo (T1))) > 0);\n+               pragma Assert (if X = Double_Int'First and then Round then\n+                                 Mult > Big_2xxDouble);\n+            else\n+               pragma Assert (not (X = Double_Int'First and then Round));\n             end if;\n             Prove_Quotient_Zero;\n          end if;\n@@ -1172,6 +1212,18 @@ is\n       end if;\n    end Lemma_Abs_Rem_Commutation;\n \n+   -----------------------------\n+   -- Lemma_Concat_Definition --\n+   -----------------------------\n+\n+   procedure Lemma_Concat_Definition (X, Y : Single_Uns) is\n+      Hi : constant Double_Uns := Shift_Left (Double_Uns (X), Single_Size);\n+      Lo : constant Double_Uns := Double_Uns (Y);\n+   begin\n+      pragma Assert (Hi = Double_Uns'(2 ** Single_Size) * Double_Uns (X));\n+      pragma Assert ((Hi or Lo) = Hi + Lo);\n+   end Lemma_Concat_Definition;\n+\n    ------------------------\n    -- Lemma_Double_Shift --\n    ------------------------\n@@ -1185,6 +1237,19 @@ is\n         = Shift_Left (X, Natural (Double_Uns (S + S1))));\n    end Lemma_Double_Shift;\n \n+   -----------------------------\n+   -- Lemma_Double_Shift_Left --\n+   -----------------------------\n+\n+   procedure Lemma_Double_Shift_Left (X : Double_Uns; S, S1 : Natural) is\n+   begin\n+      Lemma_Double_Shift_Left (X, Double_Uns (S), Double_Uns (S1));\n+      pragma Assert (Shift_Left (Shift_Left (X, S), S1)\n+        = Shift_Left (Shift_Left (X, S), Natural (Double_Uns (S1))));\n+      pragma Assert (Shift_Left (X, S + S1)\n+        = Shift_Left (X, Natural (Double_Uns (S + S1))));\n+   end Lemma_Double_Shift_Left;\n+\n    ------------------------------\n    -- Lemma_Double_Shift_Right --\n    ------------------------------\n@@ -1328,15 +1393,78 @@ is\n       Lemma_Neg_Rem (X, Y);\n    end Lemma_Rem_Abs;\n \n+   ----------------------\n+   -- Lemma_Shift_Left --\n+   ----------------------\n+\n+   procedure Lemma_Shift_Left (X : Double_Uns; Shift : Natural) is\n+\n+      procedure Lemma_Mult_Pow2 (X : Double_Uns; I : Natural)\n+      with\n+        Ghost,\n+        Pre  => I < Double_Size - 1,\n+        Post => X * Double_Uns'(2) ** I * Double_Uns'(2)\n+          = X * Double_Uns'(2) ** (I + 1);\n+\n+      procedure Lemma_Mult_Pow2 (X : Double_Uns; I : Natural) is\n+         Mul1 : constant Double_Uns := Double_Uns'(2) ** I;\n+         Mul2 : constant Double_Uns := Double_Uns'(2);\n+         Left : constant Double_Uns := X * Mul1 * Mul2;\n+      begin\n+         pragma Assert (Left = X * (Mul1 * Mul2));\n+         pragma Assert (Mul1 * Mul2 = Double_Uns'(2) ** (I + 1));\n+      end Lemma_Mult_Pow2;\n+\n+      XX : Double_Uns := X;\n+\n+   begin\n+      for J in 1 .. Shift loop\n+         declare\n+            Cur_XX : constant Double_Uns := XX;\n+         begin\n+            XX := Shift_Left (XX, 1);\n+            pragma Assert (XX = Cur_XX * Double_Uns'(2));\n+            Lemma_Mult_Pow2 (X, J - 1);\n+         end;\n+         Lemma_Double_Shift_Left (X, J - 1, 1);\n+         pragma Loop_Invariant (XX = Shift_Left (X, J));\n+         pragma Loop_Invariant (XX = X * Double_Uns'(2) ** J);\n+      end loop;\n+   end Lemma_Shift_Left;\n+\n    -----------------------\n    -- Lemma_Shift_Right --\n    -----------------------\n \n    procedure Lemma_Shift_Right (X : Double_Uns; Shift : Natural) is\n+\n+      procedure Lemma_Div_Pow2 (X : Double_Uns; I : Natural)\n+      with\n+        Ghost,\n+        Pre  => I < Double_Size - 1,\n+        Post => X / Double_Uns'(2) ** I / Double_Uns'(2)\n+          = X / Double_Uns'(2) ** (I + 1);\n+\n+      procedure Lemma_Div_Pow2 (X : Double_Uns; I : Natural) is\n+         Div1 : constant Double_Uns := Double_Uns'(2) ** I;\n+         Div2 : constant Double_Uns := Double_Uns'(2);\n+         Left : constant Double_Uns := X / Div1 / Div2;\n+      begin\n+         pragma Assert (Left = X / (Div1 * Div2));\n+         pragma Assert (Div1 * Div2 = Double_Uns'(2) ** (I + 1));\n+      end Lemma_Div_Pow2;\n+\n       XX : Double_Uns := X;\n+\n    begin\n       for J in 1 .. Shift loop\n-         XX := Shift_Right (XX, 1);\n+         declare\n+            Cur_XX : constant Double_Uns := XX;\n+         begin\n+            XX := Shift_Right (XX, 1);\n+            pragma Assert (XX = Cur_XX / Double_Uns'(2));\n+            Lemma_Div_Pow2 (X, J - 1);\n+         end;\n          Lemma_Double_Shift_Right (X, J - 1, 1);\n          pragma Loop_Invariant (XX = Shift_Right (X, J));\n          pragma Loop_Invariant (XX = X / Double_Uns'(2) ** J);\n@@ -1607,6 +1735,7 @@ is\n                              \"Intentional Unsigned->Signed conversion\");\n          else\n             Prove_Neg_Int;\n+            Lemma_Abs_Range (Big (X) * Big (Y));\n             return To_Neg_Int (T2);\n          end if;\n       else -- X < 0\n@@ -1617,6 +1746,7 @@ is\n                              \"Intentional Unsigned->Signed conversion\");\n          else\n             Prove_Neg_Int;\n+            Lemma_Abs_Range (Big (X) * Big (Y));\n             return To_Neg_Int (T2);\n          end if;\n       end if;\n@@ -1901,6 +2031,9 @@ is\n \n       procedure Prove_Dividend_Scaling is\n       begin\n+         Lemma_Shift_Left (D (1) & D (2), Scale);\n+         Lemma_Shift_Left (Double_Uns (D (3)), Scale);\n+         Lemma_Shift_Left (Double_Uns (D (4)), Scale);\n          Lemma_Hi_Lo (D (1) & D (2), D (1), D (2));\n          pragma Assert (Mult * Big_2xx (Scale) =\n            Big_2xxSingle\n@@ -2116,6 +2249,7 @@ is\n          pragma Assert (Double_Uns (Lo (T1 rem Zlo)) = T1 rem Zlo);\n          Lemma_Hi_Lo (T2, Lo (T1 rem Zlo), D (4));\n          pragma Assert (T1 rem Zlo + Double_Uns'(1) <= Double_Uns (Zlo));\n+         Lemma_Ge_Commutation (Double_Uns (Zlo), T1 rem Zlo + Double_Uns'(1));\n          Lemma_Add_Commutation (T1 rem Zlo, 1);\n          pragma Assert (Big (T1 rem Zlo) + 1 <= Big (Double_Uns (Zlo)));\n          Lemma_Div_Definition (T2, Zlo, T2 / Zlo, Ru);\n@@ -2567,6 +2701,21 @@ is\n                elsif D (J) = Zhi then\n                   Qd (J) := Single_Uns'Last;\n \n+                  Lemma_Concat_Definition (D (J), D (J + 1));\n+                  pragma Assert (Big_2xxSingle > Big (Double_Uns (D (J + 2))));\n+                  pragma Assert (Big3 (D (J), D (J + 1), 0) + Big_2xxSingle\n+                                 > Big3 (D (J), D (J + 1), D (J + 2)));\n+                  pragma Assert (Big (Double_Uns'(0)) = 0);\n+                  pragma Assert (Big (D (J) & D (J + 1)) * Big_2xxSingle =\n+                    Big_2xxSingle * (Big_2xxSingle * Big (Double_Uns (D (J)))\n+                                              + Big (Double_Uns (D (J + 1)))));\n+                  pragma Assert (Big (D (J) & D (J + 1)) * Big_2xxSingle =\n+                    Big_2xxSingle * Big_2xxSingle * Big (Double_Uns (D (J)))\n+                               + Big_2xxSingle * Big (Double_Uns (D (J + 1))));\n+                  pragma Assert (Big (D (J) & D (J + 1)) * Big_2xxSingle\n+                                 = Big3 (D (J), D (J + 1), 0));\n+                  pragma Assert ((Big (D (J) & D (J + 1)) + 1) * Big_2xxSingle\n+                                 = Big3 (D (J), D (J + 1), 0) + Big_2xxSingle);\n                   Lemma_Gt_Mult (Big (Zu), Big (D (J) & D (J + 1)) + 1,\n                                  Big_2xxSingle,\n                                  Big3 (D (J), D (J + 1), D (J + 2)));\n@@ -2617,6 +2766,8 @@ is\n                   pragma Loop_Invariant (Qd (J)'Initialized);\n                   pragma Loop_Invariant\n                     (Big3 (S1, S2, S3) = Big (Double_Uns (Qd (J))) * Big (Zu));\n+                  pragma Loop_Invariant\n+                    (Big3 (S1, S2, S3) > Big3 (D (J), D (J + 1), D (J + 2)));\n                   pragma Assert (Big3 (S1, S2, S3) > 0);\n                   if Qd (J) = 0 then\n                      pragma Assert (Big3 (S1, S2, S3) = 0);\n@@ -2632,6 +2783,9 @@ is\n                     (Big3 (S1, S2, S3) >\n                        Big3 (D (J), D (J + 1), D (J + 2)) - Big (Zu));\n                   Lemma_Subtract_Commutation (Double_Uns (Qd (J)), 1);\n+                  pragma Assert (Double_Uns (Qd (J)) - Double_Uns'(1)\n+                                 = Double_Uns (Qd (J) - 1));\n+                  pragma Assert (Big (Double_Uns'(1)) = 1);\n                   Lemma_Substitution (Big3 (S1, S2, S3), Big (Zu),\n                                       Big (Double_Uns (Qd (J))) - 1,\n                                       Big (Double_Uns (Qd (J) - 1)), 0);\n@@ -2660,8 +2814,7 @@ is\n \n                pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) < Big (Zu));\n                if D (J) > 0 then\n-                  pragma Assert\n-                    (Big_2xxSingle * Big_2xxSingle = Big_2xxDouble);\n+                  Lemma_Double_Big_2xxSingle;\n                   pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) =\n                     Big_2xxSingle\n                       * Big_2xxSingle * Big (Double_Uns (D (J)))\n@@ -2671,9 +2824,22 @@ is\n                     Big_2xxDouble * Big (Double_Uns (D (J)))\n                   + Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n                                   + Big (Double_Uns (D (J + 2))));\n+                  pragma Assert (Big_2xxSingle >= 0);\n+                  pragma Assert (Big (Double_Uns (D (J + 1))) >= 0);\n+                  pragma Assert\n+                    (Big_2xxSingle * Big (Double_Uns (D (J + 1))) >= 0);\n+                  pragma Assert\n+                    (Big_2xxSingle * Big (Double_Uns (D (J + 1)))\n+                                   + Big (Double_Uns (D (J + 2))) >= 0);\n                   pragma Assert (Big3 (D (J), D (J + 1), D (J + 2)) >=\n                                    Big_2xxDouble * Big (Double_Uns (D (J))));\n                   Lemma_Ge_Commutation (Double_Uns (D (J)), Double_Uns'(1));\n+                  Lemma_Ge_Mult (Big (Double_Uns (D (J))),\n+                                 Big (Double_Uns'(1)),\n+                                 Big_2xxDouble,\n+                                 Big (Double_Uns'(1)) * Big_2xxDouble);\n+                  pragma Assert\n+                    (Big_2xxDouble * Big (Double_Uns'(1)) = Big_2xxDouble);\n                   pragma Assert\n                     (Big3 (D (J), D (J + 1), D (J + 2)) >= Big_2xxDouble);\n                   pragma Assert (False);\n@@ -3039,6 +3205,7 @@ is\n             begin\n                pragma Assert (Ru = Double_Uns (X) - Double_Uns (Y));\n                if Ru < 2 ** (Double_Size - 1) then  --  R >= 0\n+                  pragma Assert (To_Uns (Y) <= To_Uns (X));\n                   Lemma_Subtract_Double_Uns (X => Y, Y => X);\n                   pragma Assert (Ru = Double_Uns (X - Y));\n "}]}