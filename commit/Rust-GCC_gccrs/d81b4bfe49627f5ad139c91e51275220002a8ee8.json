{"sha": "d81b4bfe49627f5ad139c91e51275220002a8ee8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDgxYjRiZmU0OTYyN2Y1YWQxMzljOTFlNTEyNzUyMjAwMDJhOGVlOA==", "commit": {"author": {"name": "Thomas Quinot", "email": "quinot@adacore.com", "date": "2009-04-29T09:41:23Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-04-29T09:41:23Z"}, "message": "exp_ch7.adb, [...]: Minor reformatting\n\n2009-04-29  Thomas Quinot  <quinot@adacore.com>\n\n\t* exp_ch7.adb, rtsfind.adb: Minor reformatting\n\n\t* sem_res.adb: Minor reformatting\n\nFrom-SVN: r146937", "tree": {"sha": "b6fddcd6b87735eb40eea85a6c5cc2aec42bc0dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6fddcd6b87735eb40eea85a6c5cc2aec42bc0dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d81b4bfe49627f5ad139c91e51275220002a8ee8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81b4bfe49627f5ad139c91e51275220002a8ee8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d81b4bfe49627f5ad139c91e51275220002a8ee8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d81b4bfe49627f5ad139c91e51275220002a8ee8/comments", "author": null, "committer": null, "parents": [{"sha": "4342eda9e82d428a97d8b3226739ee8fdfb23742", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4342eda9e82d428a97d8b3226739ee8fdfb23742", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4342eda9e82d428a97d8b3226739ee8fdfb23742"}], "stats": {"total": 319, "additions": 167, "deletions": 152}, "files": [{"sha": "29f8ea928212a5b8018034e99aafa9ba730dff90", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d81b4bfe49627f5ad139c91e51275220002a8ee8", "patch": "@@ -1,3 +1,9 @@\n+2009-04-29  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* exp_ch7.adb, rtsfind.adb: Minor reformatting\n+\n+\t* sem_res.adb: Minor reformatting\n+\n 2009-04-29  Thomas Quinot  <quinot@adacore.com>\n \n \t* sem_res.adb (Static_Concatenation): An N_Op_Concat with static"}, {"sha": "145b55dec722faa8c38b49f9da0d124831a8330e", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=d81b4bfe49627f5ad139c91e51275220002a8ee8", "patch": "@@ -453,7 +453,7 @@ package body Exp_Ch7 is\n          --  worst-case assumption for runtime files, for efficiency reasons\n          --  (see exp_ch3.adb). The reference to RE_List_Controller may have\n          --  added a with_clause to the current body. Formally the spec needs\n-         --  the with_clause as well, so we add it now, for use by codepeer.\n+         --  the with_clause as well, so we add it now, for use by Codepeer.\n \n          declare\n             Loc         : constant Source_Ptr := Sloc (Typ);"}, {"sha": "629aae217feaed61fe124a32ec3eb9afaf033369", "filename": "gcc/ada/rtsfind.adb", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Frtsfind.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Frtsfind.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.adb?ref=d81b4bfe49627f5ad139c91e51275220002a8ee8", "patch": "@@ -1445,9 +1445,7 @@ package body Rtsfind is\n                   goto Continue;\n                end if;\n \n-               Load_RTU\n-                 (To_Load,\n-                  Use_Setting => In_Use (Cunit_Entity (U)));\n+               Load_RTU (To_Load, Use_Setting => In_Use (Cunit_Entity (U)));\n                Set_Is_Visible_Child_Unit (RT_Unit_Table (To_Load).Entity);\n \n                --  Prevent creation of an implicit 'with' from (for example)"}, {"sha": "690ade4827b66bec2876db631f04ec0d701b3a53", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 159, "deletions": 148, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d81b4bfe49627f5ad139c91e51275220002a8ee8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=d81b4bfe49627f5ad139c91e51275220002a8ee8", "patch": "@@ -3030,7 +3030,8 @@ package body Sem_Res is\n             when N_String_Literal =>\n                return True;\n \n-            when N_Op_Concat      =>\n+            when N_Op_Concat =>\n+\n                --  Concatenation is static when both operands are static\n                --  and the concatenation operator is a predefined one.\n \n@@ -3047,8 +3048,8 @@ package body Sem_Res is\n                   begin\n                      return Ekind (Ent) = E_Constant\n                               and then Present (Constant_Value (Ent))\n-                              and then Is_Static_Expression\n-                                         (Constant_Value (Ent));\n+                              and then\n+                                Is_Static_Expression (Constant_Value (Ent));\n                   end;\n \n                else\n@@ -3072,9 +3073,9 @@ package body Sem_Res is\n          if No (A) and then Needs_No_Actuals (Nam) then\n             null;\n \n-         --  If we have an error in any actual or formal, indicated by\n-         --  a type of Any_Type, then abandon resolution attempt, and\n-         --  set result type to Any_Type.\n+         --  If we have an error in any actual or formal, indicated by a type\n+         --  of Any_Type, then abandon resolution attempt, and set result type\n+         --  to Any_Type.\n \n          elsif (Present (A) and then Etype (A) = Any_Type)\n            or else Etype (F) = Any_Type\n@@ -3150,9 +3151,9 @@ package body Sem_Res is\n                      --  aliased, or neither (4.6 (8)).\n \n                      --  The additional rule 4.6 (24.9.2) seems unduly\n-                     --  restrictive: the privacy requirement should not\n-                     --  apply to generic types, and should be checked in\n-                     --  an instance. ARG query is in order.\n+                     --  restrictive: the privacy requirement should not apply\n+                     --  to generic types, and should be checked in an\n+                     --  instance. ARG query is in order ???\n \n                      Error_Msg_N\n                        (\"both component types in a view conversion must be\"\n@@ -3567,7 +3568,7 @@ package body Sem_Res is\n             end if;\n \n             --  Check that subprograms don't have improper controlling\n-            --  arguments (RM 3.9.2 (9))\n+            --  arguments (RM 3.9.2 (9)).\n \n             --  A primitive operation may have an access parameter of an\n             --  incomplete tagged type, but a dispatching call is illegal\n@@ -4746,7 +4747,11 @@ package body Sem_Res is\n \n       else\n          pragma Assert (Is_Overloaded (Subp));\n-         Nam := Empty;  --  We know that it will be assigned in loop below\n+\n+         --  Initialize Nam to prevent warning (we know it will be assigned\n+         --  in the loop below, but the compiler does not know that).\n+\n+         Nam := Empty;\n \n          Get_First_Interp (Subp,  I, It);\n          while Present (It.Typ) loop\n@@ -5191,9 +5196,9 @@ package body Sem_Res is\n       if Present (First_Formal (Nam)) then\n          Resolve_Actuals (N, Nam);\n \n-         --  Overloaded literals are rewritten as function calls, for\n-         --  purpose of resolution. After resolution, we can replace\n-         --  the call with the literal itself.\n+      --  Overloaded literals are rewritten as function calls, for purpose of\n+      --  resolution. After resolution, we can replace the call with the\n+      --  literal itself.\n \n       elsif Ekind (Nam) = E_Enumeration_Literal then\n          Copy_Node (Subp, N);\n@@ -5256,7 +5261,8 @@ package body Sem_Res is\n             A := First_Actual (N);\n             while Present (F) and then Present (A) loop\n                if (Ekind (F) = E_Out_Parameter\n-                     or else Ekind (F) = E_In_Out_Parameter)\n+                     or else\n+                   Ekind (F) = E_In_Out_Parameter)\n                  and then Warn_On_Modified_As_Out_Parameter (F)\n                  and then Is_Entity_Name (A)\n                  and then Present (Entity (A))\n@@ -5379,14 +5385,14 @@ package body Sem_Res is\n       elsif Root_Type (B_Typ) = Standard_Wide_Wide_Character then\n          return;\n \n-      --  If the entity is already set, this has already been resolved in\n-      --  a generic context, or comes from expansion. Nothing else to do.\n+      --  If the entity is already set, this has already been resolved in a\n+      --  generic context, or comes from expansion. Nothing else to do.\n \n       elsif Present (Entity (N)) then\n          return;\n \n-      --  Otherwise we have a user defined character type, and we can use\n-      --  the standard visibility mechanisms to locate the referenced entity\n+      --  Otherwise we have a user defined character type, and we can use the\n+      --  standard visibility mechanisms to locate the referenced entity.\n \n       else\n          C := Current_Entity (N);\n@@ -5424,10 +5430,10 @@ package body Sem_Res is\n       T : Entity_Id;\n \n    begin\n-      --  If this is an intrinsic operation which is not predefined, use\n-      --  the types of its declared arguments to resolve the possibly\n-      --  overloaded operands. Otherwise the operands are unambiguous and\n-      --  specify the expected type.\n+      --  If this is an intrinsic operation which is not predefined, use the\n+      --  types of its declared arguments to resolve the possibly overloaded\n+      --  operands. Otherwise the operands are unambiguous and specify the\n+      --  expected type.\n \n       if Scope (Entity (N)) /= Standard_Standard then\n          T := Etype (First_Entity (Entity (N)));\n@@ -5444,9 +5450,9 @@ package body Sem_Res is\n       Generate_Reference (T, N, ' ');\n \n       if T /= Any_Type then\n-         if T = Any_String\n-           or else T = Any_Composite\n-           or else T = Any_Character\n+         if T = Any_String    or else\n+            T = Any_Composite or else\n+            T = Any_Character\n          then\n             if T = Any_Character then\n                Ambiguous_Character (L);\n@@ -5477,12 +5483,10 @@ package body Sem_Res is\n       Condition : constant Node_Id := First (Expressions (N));\n       Then_Expr : constant Node_Id := Next (Condition);\n       Else_Expr : constant Node_Id := Next (Then_Expr);\n-\n    begin\n       Resolve (Condition, Standard_Boolean);\n       Resolve (Then_Expr, Typ);\n       Resolve (Else_Expr, Typ);\n-\n       Set_Etype (N, Typ);\n       Eval_Conditional_Expression (N);\n    end Resolve_Conditional_Expression;\n@@ -5608,9 +5612,9 @@ package body Sem_Res is\n          Eval_Named_Real (N);\n \n       --  Allow use of subtype only if it is a concurrent type where we are\n-      --  currently inside the body. This will eventually be expanded\n-      --  into a call to Self (for tasks) or _object (for protected\n-      --  objects). Any other use of a subtype is invalid.\n+      --  currently inside the body. This will eventually be expanded into a\n+      --  call to Self (for tasks) or _object (for protected objects). Any\n+      --  other use of a subtype is invalid.\n \n       elsif Is_Type (E) then\n          if Is_Concurrent_Type (E)\n@@ -5650,9 +5654,9 @@ package body Sem_Res is\n       --  In all other cases, just do the possible static evaluation\n \n       else\n-         --  A deferred constant that appears in an expression must have\n-         --  a completion, unless it has been removed by in-place expansion\n-         --  of an aggregate.\n+         --  A deferred constant that appears in an expression must have a\n+         --  completion, unless it has been removed by in-place expansion of\n+         --  an aggregate.\n \n          if Ekind (E) = E_Constant\n            and then Comes_From_Source (E)\n@@ -5709,11 +5713,11 @@ package body Sem_Res is\n \n          function Actual_Discriminant_Ref (Bound : Node_Id) return Node_Id;\n          --  If the bound is given by a discriminant, replace with a reference\n-         --  to the discriminant of the same name in the target task.\n-         --  If the entry name is the target of a requeue statement and the\n-         --  entry is in the current protected object, the bound to be used\n-         --  is the discriminal of the object (see apply_range_checks for\n-         --  details of the transformation).\n+         --  to the discriminant of the same name in the target task. If the\n+         --  entry name is the target of a requeue statement and the entry is\n+         --  in the current protected object, the bound to be used is the\n+         --  discriminal of the object (see apply_range_checks for details of\n+         --  the transformation).\n \n          -----------------------------\n          -- Actual_Discriminant_Ref --\n@@ -5753,7 +5757,8 @@ package body Sem_Res is\n       begin\n          if not Has_Discriminants (Tsk)\n            or else (not Is_Entity_Name (Lo)\n-                     and then not Is_Entity_Name (Hi))\n+                     and then\n+                    not Is_Entity_Name (Hi))\n          then\n             return Entry_Index_Type (E);\n \n@@ -5789,23 +5794,23 @@ package body Sem_Res is\n       end if;\n \n       if Is_Entity_Name (E_Name) then\n-         --  Entry call to an entry (or entry family) in the current task.\n-         --  This is legal even though the task will deadlock. Rewrite as\n-         --  call to current task.\n \n-         --  This can also be a call to an entry in  an enclosing task.\n-         --  If this is a single task, we have to retrieve its name,\n-         --  because the scope of the entry is the task type, not the\n-         --  object. If the enclosing task is a task type, the identity\n-         --  of the task is given by its own self variable.\n+         --  Entry call to an entry (or entry family) in the current task. This\n+         --  is legal even though the task will deadlock. Rewrite as call to\n+         --  current task.\n \n-         --  Finally this can be a requeue on an entry of the same task\n-         --  or protected object.\n+         --  This can also be a call to an entry in an enclosing task. If this\n+         --  is a single task, we have to retrieve its name, because the scope\n+         --  of the entry is the task type, not the object. If the enclosing\n+         --  task is a task type, the identity of the task is given by its own\n+         --  self variable.\n+\n+         --  Finally this can be a requeue on an entry of the same task or\n+         --  protected object.\n \n          S := Scope (Entity (E_Name));\n \n          for J in reverse 0 .. Scope_Stack.Last loop\n-\n             if Is_Task_Type (Scope_Stack.Table (J).Entity)\n               and then not Comes_From_Source (S)\n             then\n@@ -5842,9 +5847,9 @@ package body Sem_Res is\n       elsif Nkind (Entry_Name) = N_Selected_Component\n         and then Is_Overloaded (Prefix (Entry_Name))\n       then\n-         --  Use the entry name (which must be unique at this point) to\n-         --  find the prefix that returns the corresponding task type or\n-         --  protected type.\n+         --  Use the entry name (which must be unique at this point) to find\n+         --  the prefix that returns the corresponding task type or protected\n+         --  type.\n \n          declare\n             Pref : constant Node_Id := Prefix (Entry_Name);\n@@ -5874,8 +5879,8 @@ package body Sem_Res is\n          Index :=  First (Expressions (Entry_Name));\n          Resolve (Index, Entry_Index_Type (Nam));\n \n-         --  Up to this point the expression could have been the actual\n-         --  in a simple entry call, and be given by a named association.\n+         --  Up to this point the expression could have been the actual in a\n+         --  simple entry call, and be given by a named association.\n \n          if Nkind (Index) = N_Parameter_Association then\n             Error_Msg_N (\"expect expression for entry index\", Index);\n@@ -5900,8 +5905,8 @@ package body Sem_Res is\n       Was_Over    : Boolean;\n \n    begin\n-      --  We kill all checks here, because it does not seem worth the\n-      --  effort to do anything better, an entry call is a big operation.\n+      --  We kill all checks here, because it does not seem worth the effort to\n+      --  do anything better, an entry call is a big operation.\n \n       Kill_All_Checks;\n \n@@ -6041,17 +6046,17 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  After resolution, entry calls and protected procedure calls\n-      --  are changed into entry calls, for expansion. The structure\n-      --  of the node does not change, so it can safely be done in place.\n-      --  Protected function calls must keep their structure because they\n-      --  are subexpressions.\n+      --  After resolution, entry calls and protected procedure calls are\n+      --  changed into entry calls, for expansion. The structure of the node\n+      --  does not change, so it can safely be done in place. Protected\n+      --  function calls must keep their structure because they are\n+      --  subexpressions.\n \n       if Ekind (Nam) /= E_Function then\n \n          --  A protected operation that is not a function may modify the\n-         --  corresponding object, and cannot apply to a constant.\n-         --  If this is an internal call, the prefix is the type itself.\n+         --  corresponding object, and cannot apply to a constant. If this\n+         --  is an internal call, the prefix is the type itself.\n \n          if Is_Protected_Type (Scope (Nam))\n            and then not Is_Variable (Obj)\n@@ -6088,13 +6093,12 @@ package body Sem_Res is\n    -- Resolve_Equality_Op --\n    -------------------------\n \n-   --  Both arguments must have the same type, and the boolean context\n-   --  does not participate in the resolution. The first pass verifies\n-   --  that the interpretation is not ambiguous, and the type of the left\n-   --  argument is correctly set, or is Any_Type in case of ambiguity.\n-   --  If both arguments are strings or aggregates, allocators, or Null,\n-   --  they are ambiguous even though they carry a single (universal) type.\n-   --  Diagnose this case here.\n+   --  Both arguments must have the same type, and the boolean context does\n+   --  not participate in the resolution. The first pass verifies that the\n+   --  interpretation is not ambiguous, and the type of the left argument is\n+   --  correctly set, or is Any_Type in case of ambiguity. If both arguments\n+   --  are strings or aggregates, allocators, or Null, they are ambiguous even\n+   --  though they carry a single (universal) type. Diagnose this case here.\n \n    procedure Resolve_Equality_Op (N : Node_Id; Typ : Entity_Id) is\n       L : constant Node_Id   := Left_Opnd (N);\n@@ -6227,13 +6231,13 @@ package body Sem_Res is\n             Error_Msg_NE (\"cannot call abstract subprogram &!\", N, Entity (N));\n          end if;\n \n-         --  Ada 2005:  If one operand is an anonymous access type, convert\n-         --  the other operand to it, to ensure that the underlying types\n-         --  match in the back-end. Same for access_to_subprogram, and the\n-         --  conversion verifies that the types are subtype conformant.\n+         --  Ada 2005: If one operand is an anonymous access type, convert the\n+         --  other operand to it, to ensure that the underlying types match in\n+         --  the back-end. Same for access_to_subprogram, and the conversion\n+         --  verifies that the types are subtype conformant.\n \n-         --  We apply the same conversion in the case one of the operands is\n-         --  a private subtype of the type of the other.\n+         --  We apply the same conversion in the case one of the operands is a\n+         --  private subtype of the type of the other.\n \n          --  Why the Expander_Active test here ???\n \n@@ -6533,8 +6537,8 @@ package body Sem_Res is\n       elsif Typ /= Etype (Left_Opnd (N))\n         or else Typ /= Etype (Right_Opnd (N))\n       then\n-         --  Add explicit conversion where needed, and save interpretations\n-         --  in case operands are overloaded.\n+         --  Add explicit conversion where needed, and save interpretations in\n+         --  case operands are overloaded.\n \n          Arg1 := Convert_To (Typ, Left_Opnd  (N));\n          Arg2 := Convert_To (Typ, Right_Opnd (N));\n@@ -6688,7 +6692,7 @@ package body Sem_Res is\n       then\n          T := Etype (R);\n \n-      --  Ada 2005 (AI-251): Give support to the following case:\n+      --  Ada 2005 (AI-251): Support the following case:\n \n       --      type I is interface;\n       --      type T is tagged ...\n@@ -6698,7 +6702,7 @@ package body Sem_Res is\n       --         return O in T'Class.\n       --      end Test;\n \n-      --  In this case we have nothing else to do; the membership test will be\n+      --  In this case we have nothing else to do. The membership test will be\n       --  done at run-time.\n \n       elsif Ada_Version >= Ada_05\n@@ -6750,8 +6754,8 @@ package body Sem_Res is\n         and then Ekind (Typ) = E_Anonymous_Access_Type\n         and then Comes_From_Source (N)\n       then\n-         --  In the common case of a call which uses an explicitly null\n-         --  value for an access parameter, give specialized error message.\n+         --  In the common case of a call which uses an explicitly null value\n+         --  for an access parameter, give specialized error message.\n \n          if Nkind_In (Parent (N), N_Procedure_Call_Statement,\n                                   N_Function_Call)\n@@ -6787,9 +6791,9 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  In a distributed context, null for a remote access to subprogram\n-      --  may need to be replaced with a special record aggregate. In this\n-      --  case, return after having done the transformation.\n+      --  In a distributed context, null for a remote access to subprogram may\n+      --  need to be replaced with a special record aggregate. In this case,\n+      --  return after having done the transformation.\n \n       if (Ekind (Typ) = E_Record_Type\n            or else Is_Remote_Access_To_Subprogram_Type (Typ))\n@@ -6816,7 +6820,7 @@ package body Sem_Res is\n       --  up the tree following Parent pointers, calling Resolve_Op_Concat_Rest\n       --  to do the rest of the work at each level. The Parent pointers allow\n       --  us to avoid recursion, and thus avoid running out of memory. See also\n-      --  Sem_Ch4.Analyze_Concatenation, where a similar hack is used.\n+      --  Sem_Ch4.Analyze_Concatenation, where a similar approach is used.\n \n       NN  : Node_Id := N;\n       Op1 : Node_Id;\n@@ -7012,9 +7016,9 @@ package body Sem_Res is\n          Eval_Concatenation (N);\n       end if;\n \n-      --  If this is not a static concatenation, but the result is a\n-      --  string type (and not an array of strings) ensure that static\n-      --  string operands have their subtypes properly constructed.\n+      --  If this is not a static concatenation, but the result is a string\n+      --  type (and not an array of strings) ensure that static string operands\n+      --  have their subtypes properly constructed.\n \n       if Nkind (N) /= N_String_Literal\n         and then Is_Character_Type (Component_Type (Typ))\n@@ -7722,8 +7726,8 @@ package body Sem_Res is\n    begin\n       if Is_Overloaded (Name) then\n \n-         --  Use the context type to select the prefix that yields the\n-         --  correct array type.\n+         --  Use the context type to select the prefix that yields the correct\n+         --  array type.\n \n          declare\n             I      : Interp_Index;\n@@ -7896,8 +7900,8 @@ package body Sem_Res is\n                       or else Typ = Standard_Wide_Wide_String)\n                     and then Nkind (Original_Node (N)) /= N_String_Literal);\n \n-      --  If the resolving type is itself a string literal subtype, we\n-      --  can just reuse it, since there is no point in creating another.\n+      --  If the resolving type is itself a string literal subtype, we can just\n+      --  reuse it, since there is no point in creating another.\n \n       if Ekind (Typ) = E_String_Literal_Subtype then\n          Subtype_Id := Typ;\n@@ -7935,8 +7939,8 @@ package body Sem_Res is\n          return;\n       end if;\n \n-      --  The validity of a null string has been checked in the\n-      --  call to  Eval_String_Literal.\n+      --  The validity of a null string has been checked in the call to\n+      --  Eval_String_Literal.\n \n       if Strlen = 0 then\n          return;\n@@ -7982,7 +7986,9 @@ package body Sem_Res is\n \n                   --  If we are out of range, post error. This is one of the\n                   --  very few places that we place the flag in the middle of\n-                  --  a token, right under the offending wide character.\n+                  --  a token, right under the offending wide character. Not\n+                  --  quite clear if this is right wrt wide character encoding\n+                  --  sequences, but it's only an error message!\n \n                   Error_Msg\n                     (\"literal out of range of type Standard.Character\",\n@@ -8214,26 +8220,26 @@ package body Sem_Res is\n       Resolve (Operand);\n \n       --  Note: we do the Eval_Type_Conversion call before applying the\n-      --  required checks for a subtype conversion. This is important,\n-      --  since both are prepared under certain circumstances to change\n-      --  the type conversion to a constraint error node, but in the case\n-      --  of Eval_Type_Conversion this may reflect an illegality in the\n-      --  static case, and we would miss the illegality (getting only a\n-      --  warning message), if we applied the type conversion checks first.\n+      --  required checks for a subtype conversion. This is important, since\n+      --  both are prepared under certain circumstances to change the type\n+      --  conversion to a constraint error node, but in the case of\n+      --  Eval_Type_Conversion this may reflect an illegality in the static\n+      --  case, and we would miss the illegality (getting only a warning\n+      --  message), if we applied the type conversion checks first.\n \n       Eval_Type_Conversion (N);\n \n-      --  Even when evaluation is not possible, we may be able to simplify\n-      --  the conversion or its expression. This needs to be done before\n-      --  applying checks, since otherwise the checks may use the original\n-      --  expression and defeat the simplifications. This is specifically\n-      --  the case for elimination of the floating-point Truncation\n-      --  attribute in float-to-int conversions.\n+      --  Even when evaluation is not possible, we may be able to simplify the\n+      --  conversion or its expression. This needs to be done before applying\n+      --  checks, since otherwise the checks may use the original expression\n+      --  and defeat the simplifications. This is specifically the case for\n+      --  elimination of the floating-point Truncation attribute in\n+      --  float-to-int conversions.\n \n       Simplify_Type_Conversion (N);\n \n-      --  If after evaluation we still have a type conversion, then we\n-      --  may need to apply checks required for a subtype conversion.\n+      --  If after evaluation we still have a type conversion, then we may need\n+      --  to apply checks required for a subtype conversion.\n \n       --  Skip these type conversion checks if universal fixed operands\n       --  operands involved, since range checks are handled separately for\n@@ -8247,9 +8253,9 @@ package body Sem_Res is\n          Apply_Type_Conversion_Checks (N);\n       end if;\n \n-      --  Issue warning for conversion of simple object to its own type\n-      --  We have to test the original nodes, since they may have been\n-      --  rewritten by various optimizations.\n+      --  Issue warning for conversion of simple object to its own type. We\n+      --  have to test the original nodes, since they may have been rewritten\n+      --  by various optimizations.\n \n       Orig_N := Original_Node (N);\n \n@@ -8443,9 +8449,9 @@ package body Sem_Res is\n          end if;\n       end if;\n \n-      --  Generate warning for expressions like -5 mod 3 for integers. No\n-      --  need to worry in the floating-point case, since parens do not affect\n-      --  the result so there is no point in giving in a warning.\n+      --  Generate warning for expressions like -5 mod 3 for integers. No need\n+      --  to worry in the floating-point case, since parens do not affect the\n+      --  result so there is no point in giving in a warning.\n \n       declare\n          Norig : constant Node_Id := Original_Node (N);\n@@ -8473,7 +8479,7 @@ package body Sem_Res is\n             then\n                --  For mod, we always give the warning, since the value is\n                --  affected by the parenthesization (e.g. (-5) mod 315 /=\n-               --  (5 mod 315)). But for the other cases, the only concern is\n+               --  -(5 mod 315)). But for the other cases, the only concern is\n                --  overflow, e.g. for the case of 8 big signed (-(2 * 64)\n                --  overflows, but (-2) * 64 does not). So we try to give the\n                --  message only when overflow is possible.\n@@ -8495,8 +8501,8 @@ package body Sem_Res is\n                      LB := Expr_Value (Type_Low_Bound (Base_Type (Typ)));\n                   end if;\n \n-                  --  Note that the test below is deliberately excluding\n-                  --  the largest negative number, since that is a potentially\n+                  --  Note that the test below is deliberately excluding the\n+                  --  largest negative number, since that is a potentially\n                   --  troublesome case (e.g. -2 * x, where the result is the\n                   --  largest negative integer has an overflow with 2 * x).\n \n@@ -8642,9 +8648,9 @@ package body Sem_Res is\n       Op_Node   : Node_Id;\n \n    begin\n-      --  Rewrite the operator node using the real operator, not its\n-      --  renaming. Exclude user-defined intrinsic operations of the same\n-      --  name, which are treated separately and rewritten as calls.\n+      --  Rewrite the operator node using the real operator, not its renaming.\n+      --  Exclude user-defined intrinsic operations of the same name, which are\n+      --  treated separately and rewritten as calls.\n \n       if Ekind (Op) /= E_Function\n         or else Chars (N) /= Nam\n@@ -8679,7 +8685,7 @@ package body Sem_Res is\n                     N_Op_Expon | N_Op_Mod      | N_Op_Rem      =>\n                   Resolve_Intrinsic_Operator (N, Typ);\n \n-               when N_Op_Plus | N_Op_Minus    | N_Op_Abs      =>\n+               when N_Op_Plus  | N_Op_Minus    | N_Op_Abs      =>\n                   Resolve_Intrinsic_Unary_Operator (N, Typ);\n \n                when others =>\n@@ -8783,7 +8789,7 @@ package body Sem_Res is\n    procedure Set_String_Literal_Subtype (N : Node_Id; Typ : Entity_Id) is\n       Loc        : constant Source_Ptr := Sloc (N);\n       Low_Bound  : constant Node_Id :=\n-                        Type_Low_Bound (Etype (First_Index (Typ)));\n+                     Type_Low_Bound (Etype (First_Index (Typ)));\n       Subtype_Id : Entity_Id;\n \n    begin\n@@ -8918,7 +8924,8 @@ package body Sem_Res is\n       Scop : Entity_Id;\n \n       procedure Fixed_Point_Error;\n-      --  If true ambiguity, give details\n+      --  Give error messages for true ambiguity. Messages are posted on node\n+      --  N, and entities T1, T2 are the possible interpretations.\n \n       -----------------------\n       -- Fixed_Point_Error --\n@@ -9247,8 +9254,8 @@ package body Sem_Res is\n             N1  : Entity_Id;\n \n          begin\n-            --  Remove procedure calls, which syntactically cannot appear\n-            --  in this context, but which cannot be removed by type checking,\n+            --  Remove procedure calls, which syntactically cannot appear in\n+            --  this context, but which cannot be removed by type checking,\n             --  because the context does not impose a type.\n \n             --  When compiling for VMS, spurious ambiguities can be produced\n@@ -9376,8 +9383,8 @@ package body Sem_Res is\n         and then Is_Interface (Directly_Designated_Type (Target_Type))\n       then\n          --  Check the static accessibility rule of 4.6(17). Note that the\n-         --  check is not enforced when within an instance body, since the RM\n-         --  requires such cases to be caught at run time.\n+         --  check is not enforced when within an instance body, since the\n+         --  RM requires such cases to be caught at run time.\n \n          if Ekind (Target_Type) /= E_Anonymous_Access_Type then\n             if Type_Access_Level (Opnd_Type) >\n@@ -9408,16 +9415,16 @@ package body Sem_Res is\n             then\n                --  When the operand is a selected access discriminant the check\n                --  needs to be made against the level of the object denoted by\n-               --  the prefix of the selected name. (Object_Access_Level\n-               --  handles checking the prefix of the operand for this case.)\n+               --  the prefix of the selected name (Object_Access_Level handles\n+               --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand) >\n                           Type_Access_Level (Target_Type)\n                then\n-                  --  In an instance, this is a run-time check, but one we\n-                  --  know will fail, so generate an appropriate warning.\n-                  --  The raise will be generated by Expand_N_Type_Conversion.\n+                  --  In an instance, this is a run-time check, but one we know\n+                  --  will fail, so generate an appropriate warning. The raise\n+                  --  will be generated by Expand_N_Type_Conversion.\n \n                   if In_Instance_Body then\n                      Error_Msg_N\n@@ -9486,9 +9493,9 @@ package body Sem_Res is\n             if Type_Access_Level (Opnd_Type)\n               > Type_Access_Level (Target_Type)\n             then\n-               --  In an instance, this is a run-time check, but one we\n-               --  know will fail, so generate an appropriate warning.\n-               --  The raise will be generated by Expand_N_Type_Conversion.\n+               --  In an instance, this is a run-time check, but one we know\n+               --  will fail, so generate an appropriate warning. The raise\n+               --  will be generated by Expand_N_Type_Conversion.\n \n                if In_Instance_Body then\n                   Error_Msg_N\n@@ -9518,16 +9525,16 @@ package body Sem_Res is\n \n                --  When the operand is a selected access discriminant the check\n                --  needs to be made against the level of the object denoted by\n-               --  the prefix of the selected name. (Object_Access_Level\n-               --  handles checking the prefix of the operand for this case.)\n+               --  the prefix of the selected name (Object_Access_Level handles\n+               --  checking the prefix of the operand for this case).\n \n                if Nkind (Operand) = N_Selected_Component\n                  and then Object_Access_Level (Operand) >\n                           Type_Access_Level (Target_Type)\n                then\n-                  --  In an instance, this is a run-time check, but one we\n-                  --  know will fail, so generate an appropriate warning.\n-                  --  The raise will be generated by Expand_N_Type_Conversion.\n+                  --  In an instance, this is a run-time check, but one we know\n+                  --  will fail, so generate an appropriate warning. The raise\n+                  --  will be generated by Expand_N_Type_Conversion.\n \n                   if In_Instance_Body then\n                      Error_Msg_N\n@@ -9564,6 +9571,8 @@ package body Sem_Res is\n             end if;\n          end if;\n \n+         --  Need some comments here, and a name for this block ???\n+\n          declare\n             function Full_Designated_Type (T : Entity_Id) return Entity_Id;\n             --  Helper function to handle limited views\n@@ -9585,12 +9594,16 @@ package body Sem_Res is\n                end if;\n             end Full_Designated_Type;\n \n+            --  Local Declarations\n+\n             Target : constant Entity_Id := Full_Designated_Type (Target_Type);\n             Opnd   : constant Entity_Id := Full_Designated_Type (Opnd_Type);\n \n             Same_Base : constant Boolean :=\n                           Base_Type (Target) = Base_Type (Opnd);\n \n+         --  Start of processing for ???\n+\n          begin\n             if Is_Tagged_Type (Target) then\n                return Valid_Tagged_Conversion (Target, Opnd);\n@@ -9752,8 +9765,8 @@ package body Sem_Res is\n \n       elsif (In_Instance or In_Inlined_Body)\n         and then\n-           Root_Type (Underlying_Type (Target_Type)) =\n-           Root_Type (Underlying_Type (Opnd_Type))\n+          Root_Type (Underlying_Type (Target_Type)) =\n+          Root_Type (Underlying_Type (Opnd_Type))\n       then\n          return True;\n \n@@ -9764,13 +9777,11 @@ package body Sem_Res is\n       then\n          Error_Msg_N (\"target type must be general access type!\", N);\n          Error_Msg_NE (\"add ALL to }!\", N, Target_Type);\n-\n          return False;\n \n       else\n          Error_Msg_NE (\"invalid conversion, not compatible with }\",\n            N, Opnd_Type);\n-\n          return False;\n       end if;\n    end Valid_Conversion;"}]}