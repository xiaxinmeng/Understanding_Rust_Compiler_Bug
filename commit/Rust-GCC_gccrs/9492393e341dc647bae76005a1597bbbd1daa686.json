{"sha": "9492393e341dc647bae76005a1597bbbd1daa686", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ5MjM5M2UzNDFkYzY0N2JhZTc2MDA1YTE1OTdiYmJkMWRhYTY4Ng==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-07-31T12:44:28Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-07-31T12:44:28Z"}, "message": "* h8300.c (split_adds_subs): Rearrange code for conciseness.\n\nFrom-SVN: r35371", "tree": {"sha": "3e240f2a06cbf242eccac419a05e7a740dba42ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3e240f2a06cbf242eccac419a05e7a740dba42ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9492393e341dc647bae76005a1597bbbd1daa686", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9492393e341dc647bae76005a1597bbbd1daa686", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9492393e341dc647bae76005a1597bbbd1daa686", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9492393e341dc647bae76005a1597bbbd1daa686/comments", "author": null, "committer": null, "parents": [{"sha": "91f9a498c426fe5851788b94adcb6d3911949107", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91f9a498c426fe5851788b94adcb6d3911949107", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91f9a498c426fe5851788b94adcb6d3911949107"}], "stats": {"total": 68, "additions": 21, "deletions": 47}, "files": [{"sha": "d1d5440c61f183e849420ee15ad1d32b13927411", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9492393e341dc647bae76005a1597bbbd1daa686/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9492393e341dc647bae76005a1597bbbd1daa686/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9492393e341dc647bae76005a1597bbbd1daa686", "patch": "@@ -1,3 +1,7 @@\n+2000-07-31  Kazu Hirata  <kazu@hxi.com>\n+\n+\t* h8300.c (split_adds_subs): Rearrange code for conciseness.\n+\n Mon Jul 31 12:27:55 MET DST 2000  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.md (addsi to lea splitter, ashlqi3_1_lea): Fix bugs"}, {"sha": "7cb293eb08b2a274cc1446f3d6a50ada0e3d8e37", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 17, "deletions": 47, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9492393e341dc647bae76005a1597bbbd1daa686/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9492393e341dc647bae76005a1597bbbd1daa686/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=9492393e341dc647bae76005a1597bbbd1daa686", "patch": "@@ -682,61 +682,31 @@ split_adds_subs (mode, operands)\n {\n   HOST_WIDE_INT val = INTVAL (operands[1]);\n   rtx reg = operands[0];\n-  rtx tmp;\n+  HOST_WIDE_INT sign = 1;\n+  HOST_WIDE_INT amount;\n \n-  /* Take care of +/- 4 for H8300H and H8300S.  */\n-  if (TARGET_H8300H || TARGET_H8300S)\n+  /* Force VAL to be positive so that we do not have to consider the\n+     sign.  */\n+  if (val < 0)\n     {\n-      /* Get the value in range of +/- 4.  */\n-      if (val > 4)\n-\t{\n-\t  tmp = gen_rtx_PLUS (mode, reg, GEN_INT (4));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-\t  val -= 4;\n-\t}\n-      else if (val < -4)\n-\t{\n-\t  tmp = gen_rtx_PLUS (mode, reg, GEN_INT (-4));\n-\t  emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-\t  val += 4;\n-\t}\n+      val = -val;\n+      sign = -1;\n+    }\n \n-      if (val == 4 || val == -4)\n+  /* Try different amounts in descending order.  */\n+  for (amount = (TARGET_H8300H || TARGET_H8300S) ? 4 : 2;\n+       amount > 0;\n+       amount /= 2)\n+    {\n+      while (val >= amount)\n \t{\n-\t  tmp = gen_rtx_PLUS (mode, reg, GEN_INT (val));\n+\t  rtx tmp = gen_rtx_PLUS (mode, reg, GEN_INT (sign * amount));\n \t  emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-\t  return;\n+\t  val -= amount;\n \t}\n     }\n \n-  /* Get the value in range of +/- 2.  */\n-  if (val > 2)\n-    {\n-      tmp = gen_rtx_PLUS (mode, reg, GEN_INT (2));\n-      emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-      val -= 2;\n-    }\n-  else if (val < -2)\n-    {\n-      tmp = gen_rtx_PLUS (mode, reg, GEN_INT (-2));\n-      emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-      val += 2;\n-    }\n-\n-  /* If not optimizing, we might be asked to add 0.  */\n-  if (val == 0)\n-    return;\n-\n-  /* We should have one or two now.  */\n-  if (val >= -2 && val <= 2)\n-    {\n-      tmp = gen_rtx_PLUS (mode, reg, GEN_INT (val));\n-      emit_insn (gen_rtx_SET (VOIDmode, reg, tmp));\n-      return;\n-    }\n-\n-  /* In theory, this can't happen.  */\n-  abort ();\n+  return;\n }\n \n /* Return true if OP is a valid call operand, and OP represents"}]}