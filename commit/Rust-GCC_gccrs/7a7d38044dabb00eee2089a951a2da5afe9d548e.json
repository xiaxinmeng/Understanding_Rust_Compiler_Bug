{"sha": "7a7d38044dabb00eee2089a951a2da5afe9d548e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E3ZDM4MDQ0ZGFiYjAwZWVlMjA4OWE5NTFhMmRhNWFmZTlkNTQ4ZQ==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2006-09-17T09:17:51Z"}, "committer": {"name": "Ira Rosen", "email": "irar@gcc.gnu.org", "date": "2006-09-17T09:17:51Z"}, "message": "re PR tree-optimization/21591 (not vectorizing a loop with access to structs)\n\n        PR tree-opt/21591\n        * tree-data-ref.c (ptr_decl_may_alias_p): Look for the name memory\n        tag first.\n        (ptr_ptr_may_alias_p): Likewise.\n        (record_record_differ_p): New function.\n        (base_object_differ_p): Call record_record_differ_p.\n\nFrom-SVN: r117003", "tree": {"sha": "d1df57812a3967694aea7b307e722bb6b7afa93b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1df57812a3967694aea7b307e722bb6b7afa93b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a7d38044dabb00eee2089a951a2da5afe9d548e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7d38044dabb00eee2089a951a2da5afe9d548e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7d38044dabb00eee2089a951a2da5afe9d548e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7d38044dabb00eee2089a951a2da5afe9d548e/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "76c1a415eb3e4435e449fdeeb4e79d2deba9be35", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76c1a415eb3e4435e449fdeeb4e79d2deba9be35", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76c1a415eb3e4435e449fdeeb4e79d2deba9be35"}], "stats": {"total": 133, "additions": 118, "deletions": 15}, "files": [{"sha": "261926af016e53c0b75169f0db3574d91120b03f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a7d38044dabb00eee2089a951a2da5afe9d548e", "patch": "@@ -1,3 +1,12 @@\n+2006-09-17  Ira Rosen  <irar@il.ibm.com>\n+\n+        PR tree-opt/21591\n+\t* tree-data-ref.c (ptr_decl_may_alias_p): Look for the name memory\n+        tag first.\n+        (ptr_ptr_may_alias_p): Likewise.\n+        (record_record_differ_p): New function.\n+        (base_object_differ_p): Call record_record_differ_p.\n+\n 2006-09-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/29059"}, {"sha": "89cc01b37f174f713b0851d93fb226aa440f2514", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7a7d38044dabb00eee2089a951a2da5afe9d548e", "patch": "@@ -1,3 +1,8 @@\n+2006-09-17  Ira Rosen  <irar@il.ibm.com>\n+\n+        PR tree-opt/21591\n+        * gcc.dg/vect/pr21591.c: New test.\n+\n 2006-09-16  Andrew Pinski  <pinskia@physics.uc.edu>\n \n \tPR tree-opt/29059"}, {"sha": "8a8e30f52062a06ba0296a9ebfb6a25563aebfd9", "filename": "gcc/testsuite/gcc.dg/vect/pr21591.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fpr21591.c?ref=7a7d38044dabb00eee2089a951a2da5afe9d548e", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+\n+struct a\n+{\n+  int length;\n+  int a1[256];\n+};\n+\n+struct a *malloc1(__SIZE_TYPE__) __attribute__((malloc));\n+void free(void*);\n+\n+void f(void)\n+{\n+   struct a *a = malloc1(sizeof(struct a));\n+   struct a *b = malloc1(sizeof(struct a));\n+   struct a *c = malloc1(sizeof(struct a));\n+   int i;\n+\n+   for (i = 0; i < 256; i++) \n+   {\n+      b->a1[i] = i;\n+      c->a1[i] = i;\n+   }\n+   for (i = 0; i < 256; i++) \n+   {\n+      a->a1[i] = b->a1[i] + c->a1[i];\n+   }\n+   free(a);\n+   free(b);\n+   free(c);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { cleanup-tree-dump \"vect\" } } */\n+"}, {"sha": "30d745a4238e5f7668a6e9594777ebee6c710677", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 69, "deletions": 15, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a7d38044dabb00eee2089a951a2da5afe9d548e/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=7a7d38044dabb00eee2089a951a2da5afe9d548e", "patch": "@@ -140,16 +140,20 @@ ptr_decl_may_alias_p (tree ptr, tree decl,\n \t\t      struct data_reference *ptr_dr, \n \t\t      bool *aliased)\n {\n-  tree tag;\n-   \n+  tree tag = NULL_TREE;\n+  struct ptr_info_def *pi = DR_PTR_INFO (ptr_dr);  \n+\n   gcc_assert (TREE_CODE (ptr) == SSA_NAME && DECL_P (decl));\n \n-  tag = get_var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n+  if (pi)\n+    tag = pi->name_mem_tag;\n+  if (!tag)\n+    tag = get_var_ann (SSA_NAME_VAR (ptr))->symbol_mem_tag;\n   if (!tag)\n     tag = DR_MEMTAG (ptr_dr);\n   if (!tag)\n     return false;\n-  \n+   \n   *aliased = is_aliased_with (tag, decl);      \n   return true;\n }\n@@ -164,18 +168,29 @@ ptr_ptr_may_alias_p (tree ptr_a, tree ptr_b,\n \t\t     struct data_reference *drb, \n \t\t     bool *aliased)\n {  \n-  tree tag_a, tag_b;\n+  tree tag_a = NULL_TREE, tag_b = NULL_TREE;\n+  struct ptr_info_def *pi_a = DR_PTR_INFO (dra);  \n+  struct ptr_info_def *pi_b = DR_PTR_INFO (drb);  \n \n-  tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->symbol_mem_tag;\n-  if (!tag_a)\n-    tag_a = DR_MEMTAG (dra);\n-  if (!tag_a)\n-    return false;\n-  tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->symbol_mem_tag;\n-  if (!tag_b)\n-    tag_b = DR_MEMTAG (drb);\n-  if (!tag_b)\n-    return false;\n+  if (pi_a && pi_a->name_mem_tag && pi_b && pi_b->name_mem_tag)\n+    {\n+      tag_a = pi_a->name_mem_tag;\n+      tag_b = pi_b->name_mem_tag;\n+    }\n+  else\n+    {\n+      tag_a = get_var_ann (SSA_NAME_VAR (ptr_a))->symbol_mem_tag;\n+      if (!tag_a)\n+\ttag_a = DR_MEMTAG (dra);\n+      if (!tag_a)\n+\treturn false;\n+      \n+      tag_b = get_var_ann (SSA_NAME_VAR (ptr_b))->symbol_mem_tag;\n+      if (!tag_b)\n+\ttag_b = DR_MEMTAG (drb);\n+      if (!tag_b)\n+\treturn false;\n+    }\n   *aliased = (tag_a == tag_b);\n   return true;\n }\n@@ -244,6 +259,38 @@ record_ptr_differ_p (struct data_reference *dra,\n     return false;\n }\n \n+/* Determine if two record/union accesses are aliased. Return TRUE if they \n+   differ.  */\n+static bool\n+record_record_differ_p (struct data_reference *dra,\n+\t\t\tstruct data_reference *drb)\n+{\n+  bool aliased;\n+  tree base_a = DR_BASE_OBJECT (dra);\n+  tree base_b = DR_BASE_OBJECT (drb);\n+\n+  if (TREE_CODE (base_b) != COMPONENT_REF \n+      || TREE_CODE (base_a) != COMPONENT_REF)\n+    return false;\n+\n+  /* Peel COMPONENT_REFs to get to the base. Do not peel INDIRECT_REFs.\n+     For a.b.c.d[i] we will get a, and for a.b->c.d[i] we will get a.b.  \n+     Probably will be unnecessary with struct alias analysis.  */\n+  while (TREE_CODE (base_b) == COMPONENT_REF)\n+    base_b = TREE_OPERAND (base_b, 0);\n+  while (TREE_CODE (base_a) == COMPONENT_REF)\n+    base_a = TREE_OPERAND (base_a, 0);\n+\n+  if (TREE_CODE (base_a) == INDIRECT_REF\n+      && TREE_CODE (base_b) == INDIRECT_REF\n+      && ptr_ptr_may_alias_p (TREE_OPERAND (base_a, 0), \n+\t\t\t      TREE_OPERAND (base_b, 0), \n+\t\t\t      dra, drb, &aliased)\n+      && !aliased)\n+    return true;\n+  else\n+    return false;\n+}\n     \n /* Determine if an array access (BASE_A) and a record/union access (BASE_B)\n    are not aliased. Return TRUE if they differ.  */\n@@ -408,6 +455,13 @@ base_object_differ_p (struct data_reference *a,\n       return true;\n     }\n \n+  /* Compare two record/union accesses (b.c[i] or p->c[i]).  */\n+  if (record_record_differ_p (a, b))\n+    {\n+      *differ_p = true;\n+      return true;\n+    }\n+\n   return false;\n }\n "}]}