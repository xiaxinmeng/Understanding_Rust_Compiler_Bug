{"sha": "25583c4f453910e4bf35cc55b692dea60007f673", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU1ODNjNGY0NTM5MTBlNGJmMzVjYzU1YjY5MmRlYTYwMDA3ZjY3Mw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-20T08:21:25Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-20T08:21:25Z"}, "message": "Makefile.in (INTERNAL_FN_DEF, [...]): Define.\n\ngcc/\n\t* Makefile.in (INTERNAL_FN_DEF, INTERNAL_FN_H): Define.\n\t(GIMPLE_H): Include $(INTERNAL_FN_H).\n\t(OBJS-common): Add internal-fn.o.\n\t(internal-fn.o): New rule.\n\t* internal-fn.def: New file.\n\t* internal-fn.h: Likewise.\n\t* internal-fn.c: Likewise.\n\t* gimple.h: Include internal-fn.h.\n\t(GF_CALL_INTERNAL): New gf_mask.\n\t(gimple_statement_call): Put fntype into a union with a new\n\tinternal_fn field.\n\t(gimple_build_call_internal): Declare.\n\t(gimple_build_call_internal_vec): Likewise.\n\t(gimple_call_same_target_p): Likewise.\n\t(gimple_call_internal_p): New function.\n\t(gimple_call_internal_fn): Likewise.\n\t(gimple_call_fntype): Return null for internal calls.\n\t(gimple_call_set_fntype): Assert that the function is not internal.\n\t(gimple_call_set_fn): Likewise.\n\t(gimple_call_set_fndecl): Likewise.\n\t(gimple_call_set_internal_fn): New function.\n\t(gimple_call_addr_fndecl): Handle null functions.\n\t(gimple_call_return_type): Likewise null types.\n\t* gimple.c (gimple_build_call_internal_1): New function.\n\t(gimple_build_call_internal): Likewise.\n\t(gimple_build_call_internal_vec): Likewise.\n\t(gimple_call_same_target_p): Likewise.\n\t(gimple_call_flags): Handle calls to internal functions.\n\t(gimple_call_fnspec): New function.\n\t(gimple_call_arg_flags, gimple_call_return_flags): Use it.\n\t(gimple_has_side_effects): Handle null functions.\n\t(gimple_rhs_has_side_effects): Likewise.\n\t(gimple_call_copy_skip_args): Handle calls to internal functions.\n\t* cfgexpand.c (expand_call_stmt): Likewise.\n\t* expr.c (expand_expr_real_1): Assert that the call isn't internal.\n\t* gimple-fold.c (gimple_fold_call): Handle null functions.\n\t(gimple_fold_stmt_to_constant_1): Don't fold\n\tcalls to internal functions.\n\t* gimple-low.c (gimple_check_call_args): Handle calls to internal\n\tfunctions.\n\t* gimple-pretty-print.c (dump_gimple_call): Likewise.\n\t* ipa-prop.c (ipa_analyze_call_uses): Handle null functions.\n\t* tree-cfg.c (verify_gimple_call): Handle calls to internal functions.\n\t(do_warn_unused_result): Likewise.\n\t* tree-eh.c (same_handler_p): Use gimple_call_same_target_p.\n\t* tree-ssa-ccp.c (ccp_fold_stmt): Handle calls to internal functions.\n\t* tree-ssa-dom.c (hashable_expr): Use the gimple statement to record\n\tthe target of a call.\n\t(initialize_hash_element): Update accordingly.\n\t(hashable_expr_equal_p): Use gimple_call_same_target_p.\n\t(iterative_hash_hashable_expr): Handle calls to internal functions.\n\t(print_expr_hash_elt): Likewise.\n\t* tree-ssa-pre.c (can_value_number_call): Likewise.\n\t(eliminate): Handle null functions.\n\t* tree-ssa-sccvn.c (visit_use): Handle calls to internal functions.\n\t* tree-ssa-structalias.c (get_fi_for_callee): Likewise.\n\t(find_func_aliases): Likewise.\n\t* value-prof.c (gimple_ic_transform): Likewise.\n\t(gimple_indirect_call_to_profile): Likewise.\n\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n\t* lto-streamer-out.c (output_gimple_stmt): Likewise.\n\nFrom-SVN: r172758", "tree": {"sha": "302de9b13283837581d6bef410f79f930039eedc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/302de9b13283837581d6bef410f79f930039eedc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/25583c4f453910e4bf35cc55b692dea60007f673", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25583c4f453910e4bf35cc55b692dea60007f673", "html_url": "https://github.com/Rust-GCC/gccrs/commit/25583c4f453910e4bf35cc55b692dea60007f673", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/25583c4f453910e4bf35cc55b692dea60007f673/comments", "author": null, "committer": null, "parents": [{"sha": "7da29ed0cbd6437bdac10babe4d954506de6b809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7da29ed0cbd6437bdac10babe4d954506de6b809", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7da29ed0cbd6437bdac10babe4d954506de6b809"}], "stats": {"total": 550, "additions": 498, "deletions": 52}, "files": [{"sha": "e9b126bbd634d8018ea4c252e866ec3969158578", "filename": "gcc/ChangeLog", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1,3 +1,67 @@\n+2011-04-20  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* Makefile.in (INTERNAL_FN_DEF, INTERNAL_FN_H): Define.\n+\t(GIMPLE_H): Include $(INTERNAL_FN_H).\n+\t(OBJS-common): Add internal-fn.o.\n+\t(internal-fn.o): New rule.\n+\t* internal-fn.def: New file.\n+\t* internal-fn.h: Likewise.\n+\t* internal-fn.c: Likewise.\n+\t* gimple.h: Include internal-fn.h.\n+\t(GF_CALL_INTERNAL): New gf_mask.\n+\t(gimple_statement_call): Put fntype into a union with a new\n+\tinternal_fn field.\n+\t(gimple_build_call_internal): Declare.\n+\t(gimple_build_call_internal_vec): Likewise.\n+\t(gimple_call_same_target_p): Likewise.\n+\t(gimple_call_internal_p): New function.\n+\t(gimple_call_internal_fn): Likewise.\n+\t(gimple_call_fntype): Return null for internal calls.\n+\t(gimple_call_set_fntype): Assert that the function is not internal.\n+\t(gimple_call_set_fn): Likewise.\n+\t(gimple_call_set_fndecl): Likewise.\n+\t(gimple_call_set_internal_fn): New function.\n+\t(gimple_call_addr_fndecl): Handle null functions.\n+\t(gimple_call_return_type): Likewise null types.\n+\t* gimple.c (gimple_build_call_internal_1): New function.\n+\t(gimple_build_call_internal): Likewise.\n+\t(gimple_build_call_internal_vec): Likewise.\n+\t(gimple_call_same_target_p): Likewise.\n+\t(gimple_call_flags): Handle calls to internal functions.\n+\t(gimple_call_fnspec): New function.\n+\t(gimple_call_arg_flags, gimple_call_return_flags): Use it.\n+\t(gimple_has_side_effects): Handle null functions.\n+\t(gimple_rhs_has_side_effects): Likewise.\n+\t(gimple_call_copy_skip_args): Handle calls to internal functions.\n+\t* cfgexpand.c (expand_call_stmt): Likewise.\n+\t* expr.c (expand_expr_real_1): Assert that the call isn't internal.\n+\t* gimple-fold.c (gimple_fold_call): Handle null functions.\n+\t(gimple_fold_stmt_to_constant_1): Don't fold\n+\tcalls to internal functions.\n+\t* gimple-low.c (gimple_check_call_args): Handle calls to internal\n+\tfunctions.\n+\t* gimple-pretty-print.c (dump_gimple_call): Likewise.\n+\t* ipa-prop.c (ipa_analyze_call_uses): Handle null functions.\n+\t* tree-cfg.c (verify_gimple_call): Handle calls to internal functions.\n+\t(do_warn_unused_result): Likewise.\n+\t* tree-eh.c (same_handler_p): Use gimple_call_same_target_p.\n+\t* tree-ssa-ccp.c (ccp_fold_stmt): Handle calls to internal functions.\n+\t* tree-ssa-dom.c (hashable_expr): Use the gimple statement to record\n+\tthe target of a call.\n+\t(initialize_hash_element): Update accordingly.\n+\t(hashable_expr_equal_p): Use gimple_call_same_target_p.\n+\t(iterative_hash_hashable_expr): Handle calls to internal functions.\n+\t(print_expr_hash_elt): Likewise.\n+\t* tree-ssa-pre.c (can_value_number_call): Likewise.\n+\t(eliminate): Handle null functions.\n+\t* tree-ssa-sccvn.c (visit_use): Handle calls to internal functions.\n+\t* tree-ssa-structalias.c (get_fi_for_callee): Likewise.\n+\t(find_func_aliases): Likewise.\n+\t* value-prof.c (gimple_ic_transform): Likewise.\n+\t(gimple_indirect_call_to_profile): Likewise.\n+\t* lto-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* lto-streamer-out.c (output_gimple_stmt): Likewise.\n+\n 2011-04-19  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa-inline-transform.c (save_inline_function_body): Add comments."}, {"sha": "68cf1ace61ed419a6c58d23a7838311d9cea122e", "filename": "gcc/Makefile.in", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -893,6 +893,8 @@ RTL_ERROR_H = $(RTL_H) $(DIAGNOSTIC_CORE_H)\n READ_MD_H = $(OBSTACK_H) $(HASHTAB_H) read-md.h\n PARAMS_H = params.h params.def\n BUILTINS_DEF = builtins.def sync-builtins.def omp-builtins.def\n+INTERNAL_FN_DEF = internal-fn.def\n+INTERNAL_FN_H = internal-fn.h $(INTERNAL_FN_DEF)\n TREE_H = tree.h all-tree.def tree.def c-family/c-common.def \\\n \t$(lang_tree_files) $(MACHMODE_H) tree-check.h $(BUILTINS_DEF) \\\n \t$(INPUT_H) statistics.h $(VEC_H) treestruct.def $(HASHTAB_H) \\\n@@ -901,8 +903,8 @@ TREE_H = tree.h all-tree.def tree.def c-family/c-common.def \\\n REGSET_H = regset.h $(BITMAP_H) hard-reg-set.h\n BASIC_BLOCK_H = basic-block.h $(PREDICT_H) $(VEC_H) $(FUNCTION_H) cfghooks.h\n GIMPLE_H = gimple.h gimple.def gsstruct.def pointer-set.h $(VEC_H) \\\n-\t$(GGC_H) $(BASIC_BLOCK_H) $(TARGET_H) tree-ssa-operands.h \\\n-\ttree-ssa-alias.h vecir.h\n+\tvecir.h $(GGC_H) $(BASIC_BLOCK_H) $(TARGET_H) tree-ssa-operands.h \\\n+\ttree-ssa-alias.h $(INTERNAL_FN_H)\n GCOV_IO_H = gcov-io.h gcov-iov.h auto-host.h\n COVERAGE_H = coverage.h $(GCOV_IO_H)\n DEMANGLE_H = $(srcdir)/../include/demangle.h\n@@ -1274,6 +1276,7 @@ OBJS-common = \\\n \tinit-regs.o \\\n \tinput.o \\\n \tintegrate.o \\\n+\tinternal-fn.o \\\n \tintl.o \\\n \tira.o \\\n \tira-build.o \\\n@@ -2760,6 +2763,8 @@ tree-object-size.o: tree-object-size.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(TREE_H) $(DIAGNOSTIC_CORE_H) $(DIAGNOSTIC_H) $(TREE_FLOW_H) \\\n    $(TREE_PASS_H) tree-ssa-propagate.h tree-pretty-print.h \\\n    gimple-pretty-print.h\n+internal-fn.o : internal-fn.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(INTERNAL_FN_H) $(TREE_H) $(EXPR_H) $(OPTABS_H) $(GIMPLE_H)\n gimple.o : gimple.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TREE_H) \\\n    $(GGC_H) $(GIMPLE_H) $(DIAGNOSTIC_CORE_H) $(DIAGNOSTIC_H) gt-gimple.h \\\n    $(TREE_FLOW_H) value-prof.h $(FLAGS_H) $(DEMANGLE_H) \\"}, {"sha": "a3abc8497df299eead35ea37e41e44da1532fd3f", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1837,10 +1837,16 @@ expand_gimple_cond (basic_block bb, gimple stmt)\n static void\n expand_call_stmt (gimple stmt)\n {\n-  tree exp, decl, lhs = gimple_call_lhs (stmt);\n+  tree exp, decl, lhs;\n   bool builtin_p;\n   size_t i;\n \n+  if (gimple_call_internal_p (stmt))\n+    {\n+      expand_internal_call (stmt);\n+      return;\n+    }\n+\n   exp = build_vl_exp (CALL_EXPR, gimple_call_num_args (stmt) + 3);\n \n   CALL_EXPR_FN (exp) = gimple_call_fn (stmt);\n@@ -1890,6 +1896,7 @@ expand_call_stmt (gimple stmt)\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n   TREE_BLOCK (exp) = gimple_block (stmt);\n \n+  lhs = gimple_call_lhs (stmt);\n   if (lhs)\n     expand_assignment (lhs, exp, false);\n   else"}, {"sha": "8040d5116b8b5734ce00a51d324ca1b182602a37", "filename": "gcc/expr.c", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -8528,9 +8528,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t  if (code == SSA_NAME\n \t      && (g = SSA_NAME_DEF_STMT (ssa_name))\n \t      && gimple_code (g) == GIMPLE_CALL)\n-\t    pmode = promote_function_mode (type, mode, &unsignedp,\n-\t\t\t\t\t   gimple_call_fntype (g),\n-\t\t\t\t\t   2);\n+\t    {\n+\t      gcc_assert (!gimple_call_internal_p (g));\n+\t      pmode = promote_function_mode (type, mode, &unsignedp,\n+\t\t\t\t\t     gimple_call_fntype (g),\n+\t\t\t\t\t     2);\n+\t    }\n \t  else\n \t    pmode = promote_decl_mode (exp, &unsignedp);\n \t  gcc_assert (GET_MODE (decl_rtl) == pmode);"}, {"sha": "f4251191c6077f9111c169d460a5c3c78539dd06", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1541,7 +1541,7 @@ gimple_fold_call (gimple_stmt_iterator *gsi, bool inplace)\n \n   /* Check for virtual calls that became direct calls.  */\n   callee = gimple_call_fn (stmt);\n-  if (TREE_CODE (callee) == OBJ_TYPE_REF)\n+  if (callee && TREE_CODE (callee) == OBJ_TYPE_REF)\n     {\n       tree binfo, fndecl, delta, obj;\n       HOST_WIDE_INT token;\n@@ -2958,7 +2958,13 @@ gimple_fold_stmt_to_constant_1 (gimple stmt, tree (*valueize) (tree))\n \n     case GIMPLE_CALL:\n       {\n-\ttree fn = (*valueize) (gimple_call_fn (stmt));\n+\ttree fn;\n+\n+\tif (gimple_call_internal_p (stmt))\n+\t  /* No folding yet for these functions.  */\n+\t  return NULL_TREE;\n+\n+\tfn = (*valueize) (gimple_call_fn (stmt));\n \tif (TREE_CODE (fn) == ADDR_EXPR\n \t    && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n \t    && DECL_BUILT_IN (TREE_OPERAND (fn, 0)))"}, {"sha": "3afa0b2582d271ba56ed1330320373f2fce026b2", "filename": "gcc/gimple-low.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -219,6 +219,10 @@ gimple_check_call_args (gimple stmt, tree fndecl)\n   tree parms, p;\n   unsigned int i, nargs;\n \n+  /* Calls to internal functions always match their signature.  */\n+  if (gimple_call_internal_p (stmt))\n+    return true;\n+\n   nargs = gimple_call_num_args (stmt);\n \n   /* Get argument types for verification.  */"}, {"sha": "b27b1a5b0613f965bcbe6242aac10c3b471f92f0", "filename": "gcc/gimple-pretty-print.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-pretty-print.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -616,8 +616,12 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n   if (flags & TDF_RAW)\n     {\n-      dump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\",\n-                     gs, gimple_call_fn (gs), lhs);\n+      if (gimple_call_internal_p (gs))\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G <%s, %T\", gs,\n+\t\t\t internal_fn_name (gimple_call_internal_fn (gs)), lhs);\n+      else\n+\tdump_gimple_fmt (buffer, spc, flags, \"%G <%T, %T\",\n+\t\t\t gs, gimple_call_fn (gs), lhs);\n       if (gimple_call_num_args (gs) > 0)\n         {\n           pp_string (buffer, \", \");\n@@ -637,7 +641,10 @@ dump_gimple_call (pretty_printer *buffer, gimple gs, int spc, int flags)\n \n \t  pp_space (buffer);\n         }\n-      print_call_name (buffer, gimple_call_fn (gs), flags);\n+      if (gimple_call_internal_p (gs))\n+\tpp_string (buffer, internal_fn_name (gimple_call_internal_fn (gs)));\n+      else\n+\tprint_call_name (buffer, gimple_call_fn (gs), flags);\n       pp_string (buffer, \" (\");\n       dump_gimple_call_args (buffer, gs, flags);\n       pp_character (buffer, ')');"}, {"sha": "909091bcfd032dfdd36dcad9a804552017d67cb7", "filename": "gcc/gimple.c", "status": "modified", "additions": 103, "deletions": 20, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -277,6 +277,59 @@ gimple_build_call (tree fn, unsigned nargs, ...)\n }\n \n \n+/* Helper for gimple_build_call_internal and gimple_build_call_internal_vec.\n+   Build the basic components of a GIMPLE_CALL statement to internal\n+   function FN with NARGS arguments.  */\n+\n+static inline gimple\n+gimple_build_call_internal_1 (enum internal_fn fn, unsigned nargs)\n+{\n+  gimple s = gimple_build_with_ops (GIMPLE_CALL, ERROR_MARK, nargs + 3);\n+  s->gsbase.subcode |= GF_CALL_INTERNAL;\n+  gimple_call_set_internal_fn (s, fn);\n+  gimple_call_reset_alias_info (s);\n+  return s;\n+}\n+\n+\n+/* Build a GIMPLE_CALL statement to internal function FN.  NARGS is\n+   the number of arguments.  The ... are the arguments.  */\n+\n+gimple\n+gimple_build_call_internal (enum internal_fn fn, unsigned nargs, ...)\n+{\n+  va_list ap;\n+  gimple call;\n+  unsigned i;\n+\n+  call = gimple_build_call_internal_1 (fn, nargs);\n+  va_start (ap, nargs);\n+  for (i = 0; i < nargs; i++)\n+    gimple_call_set_arg (call, i, va_arg (ap, tree));\n+  va_end (ap);\n+\n+  return call;\n+}\n+\n+\n+/* Build a GIMPLE_CALL statement to internal function FN with the arguments\n+   specified in vector ARGS.  */\n+\n+gimple\n+gimple_build_call_internal_vec (enum internal_fn fn, VEC(tree, heap) *args)\n+{\n+  unsigned i, nargs;\n+  gimple call;\n+\n+  nargs = VEC_length (tree, args);\n+  call = gimple_build_call_internal_1 (fn, nargs);\n+  for (i = 0; i < nargs; i++)\n+    gimple_call_set_arg (call, i, VEC_index (tree, args, i));\n+\n+  return call;\n+}\n+\n+\n /* Build a GIMPLE_CALL statement from CALL_EXPR T.  Note that T is\n    assumed to be in GIMPLE form already.  Minimal checking is done of\n    this fact.  */\n@@ -1778,6 +1831,20 @@ gimple_has_body_p (tree fndecl)\n   return (gimple_body (fndecl) || (fn && fn->cfg));\n }\n \n+/* Return true if calls C1 and C2 are known to go to the same function.  */\n+\n+bool\n+gimple_call_same_target_p (const_gimple c1, const_gimple c2)\n+{\n+  if (gimple_call_internal_p (c1))\n+    return (gimple_call_internal_p (c2)\n+\t    && gimple_call_internal_fn (c1) == gimple_call_internal_fn (c2));\n+  else\n+    return (gimple_call_fn (c1) == gimple_call_fn (c2)\n+\t    || (gimple_call_fndecl (c1)\n+\t\t&& gimple_call_fndecl (c1) == gimple_call_fndecl (c2)));\n+}\n+\n /* Detect flags from a GIMPLE_CALL.  This is just like\n    call_expr_flags, but for gimple tuples.  */\n \n@@ -1789,6 +1856,8 @@ gimple_call_flags (const_gimple stmt)\n \n   if (decl)\n     flags = flags_from_decl_or_type (decl);\n+  else if (gimple_call_internal_p (stmt))\n+    flags = internal_fn_flags (gimple_call_internal_fn (stmt));\n   else\n     flags = flags_from_decl_or_type (gimple_call_fntype (stmt));\n \n@@ -1798,18 +1867,32 @@ gimple_call_flags (const_gimple stmt)\n   return flags;\n }\n \n+/* Return the \"fn spec\" string for call STMT.  */\n+\n+static tree\n+gimple_call_fnspec (const_gimple stmt)\n+{\n+  tree type, attr;\n+\n+  type = gimple_call_fntype (stmt);\n+  if (!type)\n+    return NULL_TREE;\n+\n+  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n+  if (!attr)\n+    return NULL_TREE;\n+\n+  return TREE_VALUE (TREE_VALUE (attr));\n+}\n+\n /* Detects argument flags for argument number ARG on call STMT.  */\n \n int\n gimple_call_arg_flags (const_gimple stmt, unsigned arg)\n {\n-  tree type = gimple_call_fntype (stmt);\n-  tree attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n-  if (!attr)\n-    return 0;\n+  tree attr = gimple_call_fnspec (stmt);\n \n-  attr = TREE_VALUE (TREE_VALUE (attr));\n-  if (1 + arg >= (unsigned) TREE_STRING_LENGTH (attr))\n+  if (!attr || 1 + arg >= (unsigned) TREE_STRING_LENGTH (attr))\n     return 0;\n \n   switch (TREE_STRING_POINTER (attr)[1 + arg])\n@@ -1841,19 +1924,13 @@ gimple_call_arg_flags (const_gimple stmt, unsigned arg)\n int\n gimple_call_return_flags (const_gimple stmt)\n {\n-  tree type;\n-  tree attr = NULL_TREE;\n+  tree attr;\n \n   if (gimple_call_flags (stmt) & ECF_MALLOC)\n     return ERF_NOALIAS;\n \n-  type = gimple_call_fntype (stmt);\n-  attr = lookup_attribute (\"fn spec\", TYPE_ATTRIBUTES (type));\n-  if (!attr)\n-    return 0;\n-\n-  attr = TREE_VALUE (TREE_VALUE (attr));\n-  if (TREE_STRING_LENGTH (attr) < 1)\n+  attr = gimple_call_fnspec (stmt);\n+  if (!attr || TREE_STRING_LENGTH (attr) < 1)\n     return 0;\n \n   switch (TREE_STRING_POINTER (attr)[0])\n@@ -2278,6 +2355,7 @@ gimple_has_side_effects (const_gimple s)\n   if (is_gimple_call (s))\n     {\n       unsigned nargs = gimple_call_num_args (s);\n+      tree fn;\n \n       if (!(gimple_call_flags (s) & (ECF_CONST | ECF_PURE)))\n         return true;\n@@ -2292,7 +2370,8 @@ gimple_has_side_effects (const_gimple s)\n \t  return true;\n \t}\n \n-      if (TREE_SIDE_EFFECTS (gimple_call_fn (s)))\n+      fn = gimple_call_fn (s);\n+      if (fn && TREE_SIDE_EFFECTS (fn))\n         return true;\n \n       for (i = 0; i < nargs; i++)\n@@ -2331,14 +2410,15 @@ gimple_rhs_has_side_effects (const_gimple s)\n   if (is_gimple_call (s))\n     {\n       unsigned nargs = gimple_call_num_args (s);\n+      tree fn;\n \n       if (!(gimple_call_flags (s) & (ECF_CONST | ECF_PURE)))\n         return true;\n \n       /* We cannot use gimple_has_volatile_ops here,\n          because we must ignore a volatile LHS.  */\n-      if (TREE_SIDE_EFFECTS (gimple_call_fn (s))\n-          || TREE_THIS_VOLATILE (gimple_call_fn (s)))\n+      fn = gimple_call_fn (s);\n+      if (fn && (TREE_SIDE_EFFECTS (fn) || TREE_THIS_VOLATILE (fn)))\n \t{\n \t  gcc_assert (gimple_has_volatile_ops (s));\n \t  return true;\n@@ -3094,7 +3174,6 @@ gimple\n gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n {\n   int i;\n-  tree fn = gimple_call_fn (stmt);\n   int nargs = gimple_call_num_args (stmt);\n   VEC(tree, heap) *vargs = VEC_alloc (tree, heap, nargs);\n   gimple new_stmt;\n@@ -3103,7 +3182,11 @@ gimple_call_copy_skip_args (gimple stmt, bitmap args_to_skip)\n     if (!bitmap_bit_p (args_to_skip, i))\n       VEC_quick_push (tree, vargs, gimple_call_arg (stmt, i));\n \n-  new_stmt = gimple_build_call_vec (fn, vargs);\n+  if (gimple_call_internal_p (stmt))\n+    new_stmt = gimple_build_call_internal_vec (gimple_call_internal_fn (stmt),\n+\t\t\t\t\t       vargs);\n+  else\n+    new_stmt = gimple_build_call_vec (gimple_call_fn (stmt), vargs);\n   VEC_free (tree, heap, vargs);\n   if (gimple_call_lhs (stmt))\n     gimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));"}, {"sha": "a5374a9620ce82588f0e3922a240ba1b6fe0e9c7", "filename": "gcc/gimple.h", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"basic-block.h\"\n #include \"tree-ssa-operands.h\"\n #include \"tree-ssa-alias.h\"\n+#include \"internal-fn.h\"\n \n struct gimple_seq_node_d;\n typedef struct gimple_seq_node_d *gimple_seq_node;\n@@ -103,6 +104,7 @@ enum gf_mask {\n     GF_CALL_VA_ARG_PACK\t\t= 1 << 4,\n     GF_CALL_NOTHROW\t\t= 1 << 5,\n     GF_CALL_ALLOCA_FOR_VAR\t= 1 << 6,\n+    GF_CALL_INTERNAL\t\t= 1 << 7,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n \n     /* True on an GIMPLE_OMP_RETURN statement if the return does not require\n@@ -407,7 +409,10 @@ struct GTY(()) gimple_statement_call\n   struct pt_solution call_clobbered;\n \n   /* [ WORD 13 ]  */\n-  tree fntype;\n+  union GTY ((desc (\"%1.membase.opbase.gsbase.subcode & GF_CALL_INTERNAL\"))) {\n+    tree GTY ((tag (\"0\"))) fntype;\n+    enum internal_fn GTY ((tag (\"GF_CALL_INTERNAL\"))) internal_fn;\n+  } u;\n \n   /* [ WORD 14 ]\n      Operand vector.  NOTE!  This must always be the last field\n@@ -821,6 +826,8 @@ gimple gimple_build_debug_bind_stat (tree, tree, gimple MEM_STAT_DECL);\n \n gimple gimple_build_call_vec (tree, VEC(tree, heap) *);\n gimple gimple_build_call (tree, unsigned, ...);\n+gimple gimple_build_call_internal (enum internal_fn, unsigned, ...);\n+gimple gimple_build_call_internal_vec (enum internal_fn, VEC(tree, heap) *);\n gimple gimple_build_call_from_tree (tree);\n gimple gimplify_assign (tree, tree, gimple_seq *);\n gimple gimple_build_cond (enum tree_code, tree, tree, tree, tree);\n@@ -865,6 +872,7 @@ gimple_seq gimple_seq_alloc (void);\n void gimple_seq_free (gimple_seq);\n void gimple_seq_add_seq (gimple_seq *, gimple_seq);\n gimple_seq gimple_seq_copy (gimple_seq);\n+bool gimple_call_same_target_p (const_gimple, const_gimple);\n int gimple_call_flags (const_gimple);\n int gimple_call_return_flags (const_gimple);\n int gimple_call_arg_flags (const_gimple, unsigned);\n@@ -2007,13 +2015,36 @@ gimple_call_set_lhs (gimple gs, tree lhs)\n }\n \n \n+/* Return true if call GS calls an internal-only function, as enumerated\n+   by internal_fn.  */\n+\n+static inline bool\n+gimple_call_internal_p (const_gimple gs)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  return (gs->gsbase.subcode & GF_CALL_INTERNAL) != 0;\n+}\n+\n+\n+/* Return the target of internal call GS.  */\n+\n+static inline enum internal_fn\n+gimple_call_internal_fn (const_gimple gs)\n+{\n+  gcc_gimple_checking_assert (gimple_call_internal_p (gs));\n+  return gs->gimple_call.u.internal_fn;\n+}\n+\n+\n /* Return the function type of the function called by GS.  */\n \n static inline tree\n gimple_call_fntype (const_gimple gs)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  return gs->gimple_call.fntype;\n+  if (gimple_call_internal_p (gs))\n+    return NULL_TREE;\n+  return gs->gimple_call.u.fntype;\n }\n \n /* Set the type of the function called by GS to FNTYPE.  */\n@@ -2022,7 +2053,8 @@ static inline void\n gimple_call_set_fntype (gimple gs, tree fntype)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n-  gs->gimple_call.fntype = fntype;\n+  gcc_gimple_checking_assert (!gimple_call_internal_p (gs));\n+  gs->gimple_call.u.fntype = fntype;\n }\n \n \n@@ -2053,6 +2085,7 @@ static inline void\n gimple_call_set_fn (gimple gs, tree fn)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  gcc_gimple_checking_assert (!gimple_call_internal_p (gs));\n   gimple_set_op (gs, 1, fn);\n }\n \n@@ -2063,16 +2096,29 @@ static inline void\n gimple_call_set_fndecl (gimple gs, tree decl)\n {\n   GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  gcc_gimple_checking_assert (!gimple_call_internal_p (gs));\n   gimple_set_op (gs, 1, build_fold_addr_expr_loc (gimple_location (gs), decl));\n }\n \n+\n+/* Set internal function FN to be the function called by call statement GS.  */\n+\n+static inline void\n+gimple_call_set_internal_fn (gimple gs, enum internal_fn fn)\n+{\n+  GIMPLE_CHECK (gs, GIMPLE_CALL);\n+  gcc_gimple_checking_assert (gimple_call_internal_p (gs));\n+  gs->gimple_call.u.internal_fn = fn;\n+}\n+\n+\n /* Given a valid GIMPLE_CALL function address return the FUNCTION_DECL\n    associated with the callee if known.  Otherwise return NULL_TREE.  */\n \n static inline tree\n gimple_call_addr_fndecl (const_tree fn)\n {\n-  if (TREE_CODE (fn) == ADDR_EXPR)\n+  if (fn && TREE_CODE (fn) == ADDR_EXPR)\n     {\n       tree fndecl = TREE_OPERAND (fn, 0);\n       if (TREE_CODE (fndecl) == MEM_REF\n@@ -2103,6 +2149,9 @@ gimple_call_return_type (const_gimple gs)\n {\n   tree type = gimple_call_fntype (gs);\n \n+  if (type == NULL_TREE)\n+    return TREE_TYPE (gimple_call_lhs (gs));\n+\n   /* The type returned by a function is the type of its\n      function type.  */\n   return TREE_TYPE (type);"}, {"sha": "9f087b83105e2764ffeaddfd6394ad2ec9bcbf36", "filename": "gcc/internal-fn.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -0,0 +1,64 @@\n+/* Internal functions.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"internal-fn.h\"\n+#include \"tree.h\"\n+#include \"expr.h\"\n+#include \"optabs.h\"\n+#include \"gimple.h\"\n+\n+/* The names of each internal function, indexed by function number.  */\n+const char *const internal_fn_name_array[] = {\n+#define DEF_INTERNAL_FN(CODE, FLAGS) #CODE,\n+#include \"internal-fn.def\"\n+#undef DEF_INTERNAL_FN\n+  \"<invalid-fn>\"\n+};\n+\n+/* The ECF_* flags of each internal function, indexed by function number.  */\n+const int internal_fn_flags_array[] = {\n+#define DEF_INTERNAL_FN(CODE, FLAGS) FLAGS,\n+#include \"internal-fn.def\"\n+#undef DEF_INTERNAL_FN\n+  0\n+};\n+\n+/* Routines to expand each internal function, indexed by function number.\n+   Each routine has the prototype:\n+\n+       expand_<NAME> (gimple stmt)\n+\n+   where STMT is the statement that performs the call. */\n+static void (*const internal_fn_expanders[]) (gimple) = {\n+#define DEF_INTERNAL_FN(CODE, FLAGS) expand_##CODE,\n+#include \"internal-fn.def\"\n+#undef DEF_INTERNAL_FN\n+  0\n+};\n+\n+/* Expand STMT, which is a call to internal function FN.  */\n+\n+void\n+expand_internal_call (gimple stmt)\n+{\n+  internal_fn_expanders[(int) gimple_call_internal_fn (stmt)] (stmt);\n+}"}, {"sha": "b9b622db71c6e7cce4f2044ce4e997a9c302ae9e", "filename": "gcc/internal-fn.def", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -0,0 +1,39 @@\n+/* Internal functions.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+/* This file specifies a list of internal \"functions\".  These functions\n+   differ from built-in functions in that they have no linkage and cannot\n+   be called directly by the user.  They represent operations that are only\n+   synthesised by GCC itself.\n+\n+   Internal functions are used instead of tree codes if the operation\n+   and its operands are more naturally represented as a GIMPLE_CALL\n+   than a GIMPLE_ASSIGN.\n+\n+   Each entry in this file has the form:\n+\n+     DEF_INTERNAL_FN (NAME, FLAGS)\n+\n+   where NAME is the name of the function and FLAGS is a set of\n+   ECF_* flags.  Each entry must have a corresponding expander\n+   of the form:\n+\n+     void expand_NAME (gimple stmt)\n+\n+   where STMT is the statement that performs the call.  */"}, {"sha": "c9e660b2d6a123a7777361967c701769147d13c6", "filename": "gcc/internal-fn.h", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -0,0 +1,51 @@\n+/* Internal functions.\n+   Copyright (C) 2011 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_INTERNAL_FN_H\n+#define GCC_INTERNAL_FN_H\n+\n+enum internal_fn {\n+#define DEF_INTERNAL_FN(CODE, FLAGS) IFN_##CODE,\n+#include \"internal-fn.def\"\n+#undef DEF_INTERNAL_FN\n+  IFN_LAST\n+};\n+\n+/* Return the name of internal function FN.  The name is only meaningful\n+   for dumps; it has no linkage.  */\n+\n+static inline const char *\n+internal_fn_name (enum internal_fn fn)\n+{\n+  extern const char *const internal_fn_name_array[];\n+  return internal_fn_name_array[(int) fn];\n+}\n+\n+/* Return the ECF_* flags for function FN.  */\n+\n+static inline int\n+internal_fn_flags (enum internal_fn fn)\n+{\n+  extern const int internal_fn_flags_array[];\n+  return internal_fn_flags_array[(int) fn];\n+}\n+\n+extern void expand_internal_call (gimple);\n+\n+#endif"}, {"sha": "3fdebc1f2c54fa1b475d16989fc8723db8a91cd9", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1456,6 +1456,8 @@ ipa_analyze_call_uses (struct cgraph_node *node,\n {\n   tree target = gimple_call_fn (call);\n \n+  if (!target)\n+    return;\n   if (TREE_CODE (target) == SSA_NAME)\n     ipa_analyze_indirect_call_uses (node, info, parms_info, call, target);\n   else if (TREE_CODE (target) == OBJ_TYPE_REF)"}, {"sha": "ce5e33d0929cae0e8d70fc4ed0cad47e8926c05d", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1063,7 +1063,13 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n \t    }\n \t}\n       if (is_gimple_call (stmt))\n-\tgimple_call_set_fntype (stmt, lto_input_tree (ib, data_in));\n+\t{\n+\t  if (gimple_call_internal_p (stmt))\n+\t    gimple_call_set_internal_fn\n+\t      (stmt, (enum internal_fn) lto_input_sleb128 (ib));\n+\t  else\n+\t    gimple_call_set_fntype (stmt, lto_input_tree (ib, data_in));\n+\t}\n       break;\n \n     case GIMPLE_NOP:"}, {"sha": "959498312a565b725b030fde9abb7a42879212a6", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1760,7 +1760,12 @@ output_gimple_stmt (struct output_block *ob, gimple stmt)\n \t  lto_output_tree_ref (ob, op);\n \t}\n       if (is_gimple_call (stmt))\n-\tlto_output_tree_ref (ob, gimple_call_fntype (stmt));\n+\t{\n+\t  if (gimple_call_internal_p (stmt))\n+\t    output_sleb128 (ob, (int) gimple_call_internal_fn (stmt));\n+\t  else\n+\t    lto_output_tree_ref (ob, gimple_call_fntype (stmt));\n+\t}\n       break;\n \n     case GIMPLE_NOP:"}, {"sha": "40f768886ee8e4ee673a99419005a857dfc31793", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -3046,16 +3046,35 @@ verify_gimple_call (gimple stmt)\n   tree fntype, fndecl;\n   unsigned i;\n \n-  if (!is_gimple_call_addr (fn))\n+  if (gimple_call_internal_p (stmt))\n+    {\n+      if (fn)\n+\t{\n+\t  error (\"gimple call has two targets\");\n+\t  debug_generic_stmt (fn);\n+\t  return true;\n+\t}\n+    }\n+  else\n+    {\n+      if (!fn)\n+\t{\n+\t  error (\"gimple call has no target\");\n+\t  return true;\n+\t}\n+    }\n+\n+  if (fn && !is_gimple_call_addr (fn))\n     {\n       error (\"invalid function in gimple call\");\n       debug_generic_stmt (fn);\n       return true;\n     }\n \n-  if (!POINTER_TYPE_P (TREE_TYPE  (fn))\n-      || (TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != FUNCTION_TYPE\n-\t  && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != METHOD_TYPE))\n+  if (fn\n+      && (!POINTER_TYPE_P (TREE_TYPE (fn))\n+\t  || (TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != FUNCTION_TYPE\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) != METHOD_TYPE)))\n     {\n       error (\"non-function in gimple call\");\n       return true;\n@@ -3087,7 +3106,8 @@ verify_gimple_call (gimple stmt)\n     }\n \n   fntype = gimple_call_fntype (stmt);\n-  if (gimple_call_lhs (stmt)\n+  if (fntype\n+      && gimple_call_lhs (stmt)\n       && !useless_type_conversion_p (TREE_TYPE (gimple_call_lhs (stmt)),\n \t\t\t\t     TREE_TYPE (fntype))\n       /* ???  At least C++ misses conversions at assignments from\n@@ -7436,6 +7456,8 @@ do_warn_unused_result (gimple_seq seq)\n \tcase GIMPLE_CALL:\n \t  if (gimple_call_lhs (g))\n \t    break;\n+\t  if (gimple_call_internal_p (g))\n+\t    break;\n \n \t  /* This is a naked call, as opposed to a GIMPLE_CALL with an\n \t     LHS.  All calls whose value is ignored should be"}, {"sha": "5ef319dc2ca8022de6dbe57a420354d5f7dfe50d", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -2743,7 +2743,7 @@ same_handler_p (gimple_seq oneh, gimple_seq twoh)\n       || gimple_call_lhs (twos)\n       || gimple_call_chain (ones)\n       || gimple_call_chain (twos)\n-      || !operand_equal_p (gimple_call_fn (ones), gimple_call_fn (twos), 0)\n+      || !gimple_call_same_target_p (ones, twos)\n       || gimple_call_num_args (ones) != gimple_call_num_args (twos))\n     return false;\n "}, {"sha": "2caec4c56791abadadb9938e4e0e137b534115d1", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1722,6 +1722,11 @@ ccp_fold_stmt (gimple_stmt_iterator *gsi)\n \t    return true;\n \t  }\n \n+\t/* Internal calls provide no argument types, so the extra laxity\n+\t   for normal calls does not apply.  */\n+\tif (gimple_call_internal_p (stmt))\n+\t  return false;\n+\n \t/* Propagate into the call arguments.  Compared to replace_uses_in\n \t   this can use the argument slot types for type verification\n \t   instead of the current argument type.  We also can safely"}, {"sha": "2e9498efdccbcdd03d0e3891e8651cb5f81baaf5", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -64,7 +64,7 @@ struct hashable_expr\n     struct { enum tree_code op;  tree opnd; } unary;\n     struct { enum tree_code op;  tree opnd0, opnd1; } binary;\n     struct { enum tree_code op;  tree opnd0, opnd1, opnd2; } ternary;\n-    struct { tree fn; bool pure; size_t nargs; tree *args; } call;\n+    struct { gimple fn_from; bool pure; size_t nargs; tree *args; } call;\n   } ops;\n };\n \n@@ -258,7 +258,7 @@ initialize_hash_element (gimple stmt, tree lhs,\n \n       expr->type = TREE_TYPE (gimple_call_lhs (stmt));\n       expr->kind = EXPR_CALL;\n-      expr->ops.call.fn = gimple_call_fn (stmt);\n+      expr->ops.call.fn_from = stmt;\n \n       if (gimple_call_flags (stmt) & (ECF_CONST | ECF_PURE))\n         expr->ops.call.pure = true;\n@@ -422,8 +422,8 @@ hashable_expr_equal_p (const struct hashable_expr *expr0,\n \n         /* If the calls are to different functions, then they\n            clearly cannot be equal.  */\n-        if (! operand_equal_p (expr0->ops.call.fn,\n-                               expr1->ops.call.fn, 0))\n+        if (!gimple_call_same_target_p (expr0->ops.call.fn_from,\n+                                        expr1->ops.call.fn_from))\n           return false;\n \n         if (! expr0->ops.call.pure)\n@@ -503,9 +503,15 @@ iterative_hash_hashable_expr (const struct hashable_expr *expr, hashval_t val)\n       {\n         size_t i;\n         enum tree_code code = CALL_EXPR;\n+        gimple fn_from;\n \n         val = iterative_hash_object (code, val);\n-        val = iterative_hash_expr (expr->ops.call.fn, val);\n+        fn_from = expr->ops.call.fn_from;\n+        if (gimple_call_internal_p (fn_from))\n+          val = iterative_hash_hashval_t\n+            ((hashval_t) gimple_call_internal_fn (fn_from), val);\n+        else\n+          val = iterative_hash_expr (gimple_call_fn (fn_from), val);\n         for (i = 0; i < expr->ops.call.nargs; i++)\n           val = iterative_hash_expr (expr->ops.call.args[i], val);\n       }\n@@ -565,8 +571,14 @@ print_expr_hash_elt (FILE * stream, const struct expr_hash_elt *element)\n         {\n           size_t i;\n           size_t nargs = element->expr.ops.call.nargs;\n-\n-          print_generic_expr (stream, element->expr.ops.call.fn, 0);\n+          gimple fn_from;\n+\n+          fn_from = element->expr.ops.call.fn_from;\n+          if (gimple_call_internal_p (fn_from))\n+            fputs (internal_fn_name (gimple_call_internal_fn (fn_from)),\n+                   stream);\n+          else\n+            print_generic_expr (stream, gimple_call_fn (fn_from), 0);\n           fprintf (stream, \" (\");\n           for (i = 0; i < nargs; i++)\n             {"}, {"sha": "ee9ee6fe080844f8a9388abd2b9030601e5a6e8f", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -2657,11 +2657,13 @@ compute_antic (void)\n }\n \n /* Return true if we can value number the call in STMT.  This is true\n-   if we have a pure or constant call.  */\n+   if we have a pure or constant call to a real function.  */\n \n static bool\n can_value_number_call (gimple stmt)\n {\n+  if (gimple_call_internal_p (stmt))\n+    return false;\n   if (gimple_call_flags (stmt) & (ECF_PURE | ECF_CONST))\n     return true;\n   return false;\n@@ -4384,6 +4386,8 @@ eliminate (void)\n \t    {\n \t      tree orig_fn = gimple_call_fn (stmt);\n \t      tree fn;\n+\t      if (!orig_fn)\n+\t\tcontinue;\n \t      if (TREE_CODE (orig_fn) == SSA_NAME)\n \t\tfn = VN_INFO (orig_fn)->valnum;\n \t      else if (TREE_CODE (orig_fn) == OBJ_TYPE_REF"}, {"sha": "ab56e3d534a0c9954b315b0ab527cbd3b1fce4cf", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -3125,7 +3125,8 @@ visit_use (tree use)\n \t  /* ???  We should handle stores from calls.  */\n \t  else if (TREE_CODE (lhs) == SSA_NAME)\n \t    {\n-\t      if (gimple_call_flags (stmt) & (ECF_PURE | ECF_CONST))\n+\t      if (!gimple_call_internal_p (stmt)\n+\t\t  && gimple_call_flags (stmt) & (ECF_PURE | ECF_CONST))\n \t\tchanged = visit_reference_op_call (lhs, stmt);\n \t      else\n \t\tchanged = defs_to_varying (stmt);"}, {"sha": "70405a16137f629874348ec9541f3c619e052c44", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -4026,6 +4026,8 @@ get_fi_for_callee (gimple call)\n {\n   tree decl;\n \n+  gcc_assert (!gimple_call_internal_p (call));\n+\n   /* If we can directly resolve the function being called, do so.\n      Otherwise, it must be some sort of indirect expression that\n      we should still be able to handle.  */\n@@ -4319,6 +4321,7 @@ find_func_aliases (gimple origt)\n \t    /* Fallthru to general call handling.  */;\n \t  }\n       if (!in_ipa_mode\n+\t  || gimple_call_internal_p (t)\n \t  || (fndecl\n \t      && (!(fi = lookup_vi_for_tree (fndecl))\n \t\t  || !fi->is_fn_info)))"}, {"sha": "056bcbe5693ed1605c6016eeab6046d36e3ed2b3", "filename": "gcc/value-prof.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/25583c4f453910e4bf35cc55b692dea60007f673/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=25583c4f453910e4bf35cc55b692dea60007f673", "patch": "@@ -1258,6 +1258,9 @@ gimple_ic_transform (gimple stmt)\n   if (gimple_call_fndecl (stmt) != NULL_TREE)\n     return false;\n \n+  if (gimple_call_internal_p (stmt))\n+    return false;\n+\n   histogram = gimple_histogram_value_of_type (cfun, stmt, HIST_TYPE_INDIR_CALL);\n   if (!histogram)\n     return false;\n@@ -1649,6 +1652,7 @@ gimple_indirect_call_to_profile (gimple stmt, histogram_values *values)\n   tree callee;\n \n   if (gimple_code (stmt) != GIMPLE_CALL\n+      || gimple_call_internal_p (stmt)\n       || gimple_call_fndecl (stmt) != NULL_TREE)\n     return;\n "}]}