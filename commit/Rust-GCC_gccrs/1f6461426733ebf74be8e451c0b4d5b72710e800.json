{"sha": "1f6461426733ebf74be8e451c0b4d5b72710e800", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWY2NDYxNDI2NzMzZWJmNzRiZThlNDUxYzBiNGQ1YjcyNzEwZTgwMA==", "commit": {"author": {"name": "Guilhem Lavaux", "email": "guilhem@kaffe.org", "date": "2004-05-04T22:05:25Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2004-05-04T22:05:25Z"}, "message": "MessageFormat.java: (class Field): New class.\n\n2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n\n\t* java/text/MessageFormat.java:\n\t(class Field): New class.\n\t(formatToCharacterIterator): New method.\n\t(format): Use formatInternal now.\n\t(formatInternal): New method. String formatter should\n\tbe done here (with attributes). Attributes merging supported.\n\t(parse): More documentation.\n\t(getFormatsByArgumentIndex): New method.\n\t(setFormatByArgumentIndex): New method.\n\t(setFormatsByArgumentIndex): New method.\n\nFrom-SVN: r81492", "tree": {"sha": "e0ce48549a010894fe7a89c76653ebe0d5d2d9ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0ce48549a010894fe7a89c76653ebe0d5d2d9ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1f6461426733ebf74be8e451c0b4d5b72710e800", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6461426733ebf74be8e451c0b4d5b72710e800", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f6461426733ebf74be8e451c0b4d5b72710e800", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f6461426733ebf74be8e451c0b4d5b72710e800/comments", "author": null, "committer": null, "parents": [{"sha": "8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cf1edb30c2c3803a6439afde8bcb5c8f01b5959"}], "stats": {"total": 208, "additions": 199, "deletions": 9}, "files": [{"sha": "ad5a349306a974f8a37b2f1685f3128323f10323", "filename": "libjava/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6461426733ebf74be8e451c0b4d5b72710e800/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6461426733ebf74be8e451c0b4d5b72710e800/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=1f6461426733ebf74be8e451c0b4d5b72710e800", "patch": "@@ -1,3 +1,16 @@\n+2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n+\n+\t* java/text/MessageFormat.java:\n+\t(class Field): New class.\n+\t(formatToCharacterIterator): New method.\n+\t(format): Use formatInternal now.\n+\t(formatInternal): New method. String formatter should\n+\tbe done here (with attributes). Attributes merging supported.\n+\t(parse): More documentation.\n+\t(getFormatsByArgumentIndex): New method.\n+\t(setFormatByArgumentIndex): New method.\n+\t(setFormatsByArgumentIndex): New method.\n+\n 2004-05-05  Guilhem Lavaux <guilhem@kaffe.org>\n \n \t* java/text/DecimalFormat.java"}, {"sha": "2e1786da986bb9a4fcf6ad5b2d126acb096a1c1b", "filename": "libjava/java/text/MessageFormat.java", "status": "modified", "additions": 186, "deletions": 9, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1f6461426733ebf74be8e451c0b4d5b72710e800/libjava%2Fjava%2Ftext%2FMessageFormat.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1f6461426733ebf74be8e451c0b4d5b72710e800/libjava%2Fjava%2Ftext%2FMessageFormat.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Ftext%2FMessageFormat.java?ref=1f6461426733ebf74be8e451c0b4d5b72710e800", "patch": "@@ -38,7 +38,11 @@\n \n package java.text;\n \n+import gnu.java.text.FormatCharacterIterator;\n+\n+import java.io.InvalidObjectException;\n import java.util.Date;\n+import java.util.HashMap;\n import java.util.Locale;\n import java.util.Vector;\n \n@@ -145,6 +149,43 @@ public class MessageFormat extends Format\n {\n   private static final long serialVersionUID = 6479157306784022952L;\n \n+  public static class Field extends Format.Field\n+  {\n+    static final long serialVersionUID = 7899943957617360810L;\n+\n+    /**\n+     * This is the attribute set for all characters produced\n+     * by MessageFormat during a formatting.\n+     */\n+    public static final MessageFormat.Field ARGUMENT = new Field(\"argument\");\n+\n+    // For deserialization\n+    private Field()\n+    {\n+      super(\"\");\n+    }\n+    \n+    private Field(String s)\n+    {\n+      super(s);\n+    }\n+\n+    /**\n+     * invoked to resolve the true static constant by\n+     * comparing the deserialized object to know name.\n+     *\n+     * @return object constant\n+     */\n+    protected Object readResolve() throws InvalidObjectException\n+    {\n+      if (getName().equals(ARGUMENT.getName()))\n+\treturn ARGUMENT;\n+\n+      throw new InvalidObjectException(\"no such MessageFormat field called \" + getName());\n+    }\n+\n+  }\n+\n   // Helper that returns the text up to the next format opener.  The\n   // text is put into BUFFER.  Returns index of character after end of\n   // string.  Throws IllegalArgumentException on error.\n@@ -320,6 +361,22 @@ public boolean equals (Object obj)\n \t    && locale.equals(mf.locale));\n   }\n \n+  /**\n+   * A convinience method to format patterns.\n+   *\n+   * @param aPattern The pattern used when formatting.\n+   * @param arguments The array containing the objects to be formatted.\n+   */\n+  public AttributedCharacterIterator formatToCharacterIterator (Object arguments)\n+  {\n+    Object[] arguments_array = (Object[])arguments;\n+    FormatCharacterIterator iterator = new FormatCharacterIterator();\n+    \n+    formatInternal(arguments_array, new StringBuffer(), null, iterator);\n+  \n+    return iterator;\n+  }\n+\n   /**\n    * A convinience method to format patterns.\n    *\n@@ -331,7 +388,7 @@ public static String format (String pattern, Object arguments[])\n     MessageFormat mf = new MessageFormat (pattern);\n     StringBuffer sb = new StringBuffer ();\n     FieldPosition fp = new FieldPosition (NumberFormat.INTEGER_FIELD);\n-    return mf.format(arguments, sb, fp).toString();\n+    return mf.formatInternal(arguments, sb, fp, null).toString();\n   }\n \n   /**\n@@ -342,18 +399,32 @@ public static String format (String pattern, Object arguments[])\n    * @param fp A FieldPosition object (it is ignored).\n    */\n   public final StringBuffer format (Object arguments[], StringBuffer appendBuf,\n-\t\t\t\t    FieldPosition ignore)\n+\t\t\t\t    FieldPosition fp)\n+  {\n+    return formatInternal(arguments, appendBuf, fp, null);\n+  }\n+\n+  protected final StringBuffer formatInternal (Object arguments[], StringBuffer appendBuf,\n+\t\t\t\t\t       FieldPosition fp,\n+\t\t\t\t\t       FormatCharacterIterator output_iterator)\n   {\n     appendBuf.append(leader);\n+    if (output_iterator != null)\n+      output_iterator.append(leader);\n \n     for (int i = 0; i < elements.length; ++i)\n       {\n \tif (elements[i].argNumber >= arguments.length)\n \t  throw new IllegalArgumentException(\"Not enough arguments given\");\n \n \tObject thisArg = arguments[elements[i].argNumber];\n+\tAttributedCharacterIterator iterator = null;\n \n \tFormat formatter = null;\n+\n+\tif (fp != null && i == fp.getField() && fp.getFieldAttribute() == Field.ARGUMENT)\n+\t  fp.setBeginIndex(appendBuf.length());\n+\n \tif (elements[i].setFormat != null)\n \t  formatter = elements[i].setFormat;\n \telse if (elements[i].format != null)\n@@ -371,25 +442,56 @@ else if (thisArg instanceof Date)\n \telse\n \t  appendBuf.append(thisArg);\n \n+\tif (fp != null && fp.getField() == i && fp.getFieldAttribute() == Field.ARGUMENT)\n+\t  fp.setEndIndex(appendBuf.length());\n+\n \tif (formatter != null)\n \t  {\n \t    // Special-case ChoiceFormat.\n \t    if (formatter instanceof ChoiceFormat)\n \t      {\n \t\tStringBuffer buf = new StringBuffer ();\n-\t\tformatter.format(thisArg, buf, ignore);\n+\t\tformatter.format(thisArg, buf, fp);\n \t\tMessageFormat mf = new MessageFormat ();\n \t\tmf.setLocale(locale);\n \t\tmf.applyPattern(buf.toString());\n-\t\tmf.format(arguments, appendBuf, ignore);\n+\t\tmf.format(arguments, appendBuf, fp);\n \t      }\n \t    else\n-\t      formatter.format(thisArg, appendBuf, ignore);\n+\t      {\n+\t\tif (output_iterator != null)\n+\t\t  iterator = formatter.formatToCharacterIterator(thisArg);\n+\t\telse\n+\t\t  formatter.format(thisArg, appendBuf, fp);\n+\t      }\n+\n+\t    elements[i].format = formatter;\n \t  }\n \n+\tif (output_iterator != null)\n+\t  {\n+\t    HashMap hash_argument = new HashMap();\n+\t    int position = output_iterator.getEndIndex();\n+\t    \n+\t    hash_argument.put (MessageFormat.Field.ARGUMENT,\n+\t\t\t       new Integer(elements[i].argNumber));\n+\n+\t    \n+\t    if (iterator != null)\n+\t      {\n+\t\toutput_iterator.append(iterator);\n+\t\toutput_iterator.addAttributes(hash_argument, position, \n+\t\t\t\t\t      output_iterator.getEndIndex());\n+\t      }\t\n+\t    else\n+\t      output_iterator.append(thisArg.toString(), hash_argument);\n+\t    \n+\t    output_iterator.append(elements[i].trailer);\n+\t  }\n+\t\n \tappendBuf.append(elements[i].trailer);\n       }\n-\n+    \n     return appendBuf;\n   }\n \n@@ -398,10 +500,10 @@ else if (thisArg instanceof Date)\n    *\n    * @param source The object to be formatted.\n    * @param result The StringBuffer where the text is appened.\n-   * @param fp A FieldPosition object (it is ignored).\n+   * @param fpos A FieldPosition object (it is ignored).\n    */\n   public final StringBuffer format (Object singleArg, StringBuffer appendBuf,\n-\t\t\t\t    FieldPosition ignore)\n+\t\t\t\t    FieldPosition fpos)\n   {\n     Object[] args;\n \n@@ -416,7 +518,7 @@ public final StringBuffer format (Object singleArg, StringBuffer appendBuf,\n \targs = new Object[1];\n \targs[0] = singleArg;\n       }\n-    return format (args, appendBuf, ignore);\n+    return format (args, appendBuf, fpos);\n   }\n \n   /**\n@@ -478,6 +580,15 @@ public MessageFormat(String pattern, Locale locale)\n     applyPattern (pattern);\n   }\n \n+  /**\n+   * Parse a string <code>sourceStr</code> against the pattern specified\n+   * to the MessageFormat constructor.\n+   *\n+   * @param sourceStr the string to be parsed.\n+   * @param pos the current parse position (and eventually the error position).\n+   * @return the array of parsed objects sorted according to their argument number\n+   * in the pattern.\n+   */ \n   public Object[] parse (String sourceStr, ParsePosition pos)\n   {\n     // Check initial text.\n@@ -628,6 +739,72 @@ public String toPattern ()\n     return pattern;\n   }\n \n+  /**\n+   * Return the formatters used sorted by argument index. It uses the\n+   * internal table to fill in this array: if a format has been\n+   * set using <code>setFormat</code> or <code>setFormatByArgumentIndex</code>\n+   * then it returns it at the right index. If not it uses the detected\n+   * formatters during a <code>format</code> call. If nothing is known\n+   * about that argument index it just puts null at that position.\n+   * To get useful informations you may have to call <code>format</code>\n+   * at least once.\n+   *\n+   * @return an array of formatters sorted by argument index.\n+   */\n+  public Format[] getFormatsByArgumentIndex()\n+  {\n+    int argNumMax = 0;\n+    // First, find the greatest argument number.\n+    for (int i=0;i<elements.length;i++)\n+      if (elements[i].argNumber > argNumMax)\n+\targNumMax = elements[i].argNumber;\n+\n+    Format[] formats = new Format[argNumMax];\n+    for (int i=0;i<elements.length;i++)\n+      {\n+\tif (elements[i].setFormat != null)\n+\t  formats[elements[i].argNumber] = elements[i].setFormat;\n+\telse if (elements[i].format != null)\n+\t  formats[elements[i].argNumber] = elements[i].format;\n+      }\n+    return formats;\n+  }\n+\n+  /**\n+   * Set the format to used using the argument index number.\n+   *\n+   * @param argumentIndex the argument index.\n+   * @param newFormat the format to use for this argument.\n+   */\n+  public void setFormatByArgumentIndex(int argumentIndex,\n+\t\t\t\t       Format newFormat)\n+  {\n+    for (int i=0;i<elements.length;i++)\n+      {\n+\tif (elements[i].argNumber == argumentIndex)\n+\t  elements[i].setFormat = newFormat;\n+      }\n+  }\n+\n+  /**\n+   * Set the format for argument using a specified array of formatters\n+   * which is sorted according to the argument index. If the number of\n+   * elements in the array is fewer than the number of arguments only\n+   * the arguments specified by the array are touched.\n+   *\n+   * @param newFormats array containing the new formats to set.\n+   *\n+   * @throws NullPointerException if newFormats is null\n+   */\n+  public void setFormatsByArgumentIndex(Format[] newFormats)\n+  {\n+    for (int i=0;i<newFormats.length;i++)\n+      {\n+\t// Nothing better than that can exist here.\n+\tsetFormatByArgumentIndex(i, newFormats[i]);\n+      }\n+  }\n+\n   // The pattern string.\n   private String pattern;\n   // The locale."}]}