{"sha": "45d9a5c65defa61b3aa35a020979ed11a42d823d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDVkOWE1YzY1ZGVmYTYxYjNhYTM1YTAyMDk3OWVkMTFhNDJkODIzZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-15T21:39:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1995-09-15T21:39:39Z"}, "message": "(fill_simple_delay_slots): When filling an insn's delay slot with a JUMP_INSN...\n\n(fill_simple_delay_slots): When filling an insn's delay slot with a\nJUMP_INSN, don't assume the JUMP_INSN immediately follows the insn on\nthe unfilled slots obstack.\n\nFrom-SVN: r10362", "tree": {"sha": "d66f938288685189b7e94879004a1eafcf73fe6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d66f938288685189b7e94879004a1eafcf73fe6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/45d9a5c65defa61b3aa35a020979ed11a42d823d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d9a5c65defa61b3aa35a020979ed11a42d823d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/45d9a5c65defa61b3aa35a020979ed11a42d823d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/45d9a5c65defa61b3aa35a020979ed11a42d823d/comments", "author": null, "committer": null, "parents": [{"sha": "7a7e1cfb3270aacb8234a311f8666c177e6e74a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a7e1cfb3270aacb8234a311f8666c177e6e74a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a7e1cfb3270aacb8234a311f8666c177e6e74a4"}], "stats": {"total": 18, "additions": 15, "deletions": 3}, "files": [{"sha": "edd76d5d21be90313eb1e1092e7627acb5a507a6", "filename": "gcc/reorg.c", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/45d9a5c65defa61b3aa35a020979ed11a42d823d/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/45d9a5c65defa61b3aa35a020979ed11a42d823d/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=45d9a5c65defa61b3aa35a020979ed11a42d823d", "patch": "@@ -2857,12 +2857,24 @@ fill_simple_delay_slots (first, non_jumps_p)\n \t  && eligible_for_delay (insn, slots_filled, trial, flags)\n \t  && no_labels_between_p (insn, trial))\n \t{\n+\t  rtx *tmp;\n \t  slots_filled++;\n \t  delay_list = add_to_delay_list (trial, delay_list);\n+\n+\t  /* TRIAL may have had its delay slot filled, then unfilled.  When\n+\t     the delay slot is unfilled, TRIAL is placed back on the unfilled\n+\t     slots obstack.  Unfortunately, it is placed on the end of the\n+\t     obstack, not in its original location.  Therefore, we must search\n+\t     from entry i + 1 to the end of the unfilled slots obstack to\n+\t     try and find TRIAL.  */\n+\t  tmp = &unfilled_slots_base[i + 1];\n+\t  while (*tmp != trial && tmp != unfilled_slots_next)\n+\t    tmp++;\n+\n \t  /* Remove the unconditional jump from consideration for delay slot\n-\t     filling and unthread it.  */\n-\t  if (unfilled_slots_base[i + 1] == trial)\n-\t    unfilled_slots_base[i + 1] = 0;\n+\t     filling and unthread it.   */\n+\t  if (*tmp == trial)\n+\t    *tmp = 0;\n \t  {\n \t    rtx next = NEXT_INSN (trial);\n \t    rtx prev = PREV_INSN (trial);"}]}