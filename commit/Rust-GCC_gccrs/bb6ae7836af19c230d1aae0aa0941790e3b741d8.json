{"sha": "bb6ae7836af19c230d1aae0aa0941790e3b741d8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmI2YWU3ODM2YWYxOWMyMzBkMWFhZTBhYTA5NDE3OTBlM2I3NDFkOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2000-11-27T16:01:29Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2000-11-27T16:01:29Z"}, "message": "arm.md (arm_adddi3, [...]): Merge with splitters to create define_insn_and_split patterns.\n\n* arm.md (arm_adddi3, adddi_sesidi_di, adddi_zesidi_di, arm_addsi3,\narm_subsi3_insn, anddi_zesidi_di, arm_andsi3_insn, anddi_notdi_di,\nanddi_notzesidi_di, anddi_notsesidi_di, arm_iorsi3,\none_cmpldi2): Merge with splitters to create define_insn_and_split\npatterns.  Remove redundant splits.\n(peephole2 for add:SI of invalid immediate): New.\n(peephole2 for minus:SI of invalid immediate): New.\n(peephole2 for ior:SI of invalid immediate): New.\n(peephole for merge of move and compare): Convert ot peephole2.\n(addsf3, adddf3): Mark as commutative.\n\n* arm.md (thumb peephole for merging stack adjustments): Convert to\npeephole2.\n\nFrom-SVN: r37796", "tree": {"sha": "4778f5da0ed5d23f76932d836a28b9ac9a22fdb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4778f5da0ed5d23f76932d836a28b9ac9a22fdb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bb6ae7836af19c230d1aae0aa0941790e3b741d8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6ae7836af19c230d1aae0aa0941790e3b741d8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb6ae7836af19c230d1aae0aa0941790e3b741d8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb6ae7836af19c230d1aae0aa0941790e3b741d8/comments", "author": null, "committer": null, "parents": [{"sha": "375de5b62f08e1a0cab0ea09d0113db75b4a8f9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/375de5b62f08e1a0cab0ea09d0113db75b4a8f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/375de5b62f08e1a0cab0ea09d0113db75b4a8f9e"}], "stats": {"total": 546, "additions": 225, "deletions": 321}, "files": [{"sha": "a1970f75ea6d2b1efc7ab2340400597509286f57", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6ae7836af19c230d1aae0aa0941790e3b741d8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6ae7836af19c230d1aae0aa0941790e3b741d8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bb6ae7836af19c230d1aae0aa0941790e3b741d8", "patch": "@@ -1,3 +1,19 @@\n+2000-11-27  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.md (arm_adddi3, adddi_sesidi_di, adddi_zesidi_di, arm_addsi3,\n+\tarm_subsi3_insn, anddi_zesidi_di, arm_andsi3_insn, anddi_notdi_di,\n+\tanddi_notzesidi_di, anddi_notsesidi_di, arm_iorsi3, \n+\tone_cmpldi2): Merge with splitters to create define_insn_and_split\n+ \tpatterns.  Remove redundant splits.\n+\t(peephole2 for add:SI of invalid immediate): New.\n+\t(peephole2 for minus:SI of invalid immediate): New.\n+\t(peephole2 for ior:SI of invalid immediate): New.\n+\t(peephole for merge of move and compare): Convert ot peephole2.\n+\t(addsf3, adddf3): Mark as commutative.\n+\n+\t* arm.md (thumb peephole for merging stack adjustments): Convert to\n+\tpeephole2.\n+\n 2000-11-27  Bernd Schmidt  <bernds@redhat.co.uk>\n \n \t* haifa-sched.c (print_pattern): Prettier output for COND_EXEC."}, {"sha": "ddb2640869012ca13714c11db313385400cbecb3", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 209, "deletions": 321, "changes": 530, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bb6ae7836af19c230d1aae0aa0941790e3b741d8/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bb6ae7836af19c230d1aae0aa0941790e3b741d8/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=bb6ae7836af19c230d1aae0aa0941790e3b741d8", "patch": "@@ -335,97 +335,13 @@\n    (LAST_ARM_REGNUM 15)\n    (CC_REGNUM       24)]\n )\n-\f\n-;;---------------------------------------------------------------------------\n+\n+;; Addition insns.\n \n ;; Note: For DImode insns, there is normally no reason why operands should\n ;; not be in the same register, what we don't want is for something being\n ;; written to partially overlap something that is an input.\n \n-;; Split up 64bit addition so that the component insns can schedule\n-;; independently.\n-(define_split\n-  [(set (match_operand:DI          0 \"s_register_operand\" \"\")\n-\t(plus:DI (match_operand:DI 1 \"s_register_operand\" \"\")\n-\t\t (match_operand:DI 2 \"s_register_operand\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\n-  \"\n-  [(parallel [(set (reg:CC_C CC_REGNUM)\n-\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n-\t\t\t\t (match_dup 1)))\n-\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n-   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n-\t\t\t       (plus:SI (match_dup 4) (match_dup 5))))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[5] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n-;; The first insn created by this splitter must set the low part of\n-;; operand0 as well as the carry bit in the CC register.  The second\n-;; insn must compute the sum of the carry bit, the sign extension of\n-;; operand 2 from 32 to 64 bits and the high part of operand 1.\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(plus:DI (sign_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t\t (match_operand:DI 1 \"s_register_operand\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\n-  \"\n-  [(parallel [(set (reg:CC_C CC_REGNUM)\n-\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n-\t\t\t\t (match_dup 1)))\n-\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n-   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n-\t\t\t       (plus:SI (ashiftrt:SI (match_dup 2)\n-\t\t\t\t\t\t     (const_int 31))\n-\t\t\t\t\t(match_dup 4))))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n-; The first insn created by this splitter must set the low part of\n-; operand0 as well as the carry bit in the CC register.  The second\n-; insn must compute the sum of the carry bit and the high bits from\n-; operand 1\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(plus:DI (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t\t (match_operand:DI 1 \"s_register_operand\" \"\")))\n-   (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM && reload_completed\n-  \"\n-  [(parallel [(set (reg:CC_C CC_REGNUM)\n-\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n-\t\t\t\t (match_dup 1)))\n-\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n-   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n-\t\t\t       (plus:SI (match_dup 4) (const_int 0))))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n-;; Addition insns.\n-\n (define_expand \"adddi3\"\n  [(parallel\n    [(set (match_operand:DI           0 \"s_register_operand\" \"\")\n@@ -455,41 +371,85 @@\n   [(set_attr \"length\" \"4\")]\n )\n \n-(define_insn \"*arm_adddi3\"\n+(define_insn_and_split \"*arm_adddi3\"\n   [(set (match_operand:DI          0 \"s_register_operand\" \"=&r,&r\")\n \t(plus:DI (match_operand:DI 1 \"s_register_operand\" \"%0, 0\")\n \t\t (match_operand:DI 2 \"s_register_operand\" \"r,  0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM\n-  \"\n+  \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(parallel [(set (reg:CC_C CC_REGNUM)\n+\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t (match_dup 1)))\n+\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n+   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n+\t\t\t       (plus:SI (match_dup 4) (match_dup 5))))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[5] = gen_highpart (SImode, operands[2]);\n+    operands[2] = gen_lowpart (SImode, operands[2]);\n+  }\"\n   [(set_attr \"conds\" \"clob\")\n    (set_attr \"length\" \"8\")]\n )\n \n-(define_insn \"*adddi_sesidi_di\"\n+(define_insn_and_split \"*adddi_sesidi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(plus:DI (sign_extend:DI\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n    (clobber (reg:CC CC_REGNUM))]\n-  \"TARGET_ARM\n-  \"\n+  \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(parallel [(set (reg:CC_C CC_REGNUM)\n+\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t (match_dup 1)))\n+\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n+   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n+\t\t\t       (plus:SI (ashiftrt:SI (match_dup 2)\n+\t\t\t\t\t\t     (const_int 31))\n+\t\t\t\t\t(match_dup 4))))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_lowpart (SImode, operands[2]);\n+  }\"\n   [(set_attr \"conds\" \"clob\")\n    (set_attr \"length\" \"8\")]\n )\n \n-(define_insn \"*adddi_zesidi_di\"\n+(define_insn_and_split \"*adddi_zesidi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(plus:DI (zero_extend:DI\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t (match_operand:DI 1 \"s_register_operand\" \"r,0\")))\n-   (clobber (reg:CC CC_REGNUM))\n-  ]\n-  \"TARGET_ARM\n-  \"\n+   (clobber (reg:CC CC_REGNUM))]\n+  \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(parallel [(set (reg:CC_C CC_REGNUM)\n+\t\t   (compare:CC_C (plus:SI (match_dup 1) (match_dup 2))\n+\t\t\t\t (match_dup 1)))\n+\t      (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))])\n+   (set (match_dup 3) (plus:SI (ltu:SI (reg:CC_C CC_REGNUM) (const_int 0))\n+\t\t\t       (plus:SI (match_dup 4) (const_int 0))))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[2] = gen_lowpart (SImode, operands[2]);\n+  }\"\n   [(set_attr \"conds\" \"clob\")\n    (set_attr \"length\" \"8\")]\n )\n@@ -510,29 +470,41 @@\n   \"\n )\n \n-(define_split\n-  [(set (match_operand:SI          0 \"s_register_operand\" \"\")\n+; If there is a scratch available, this will be faster than synthesising the\n+; addition.\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (set (match_operand:SI          0 \"s_register_operand\" \"\")\n \t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n \t\t (match_operand:SI 2 \"const_int_operand\"  \"\")))]\n   \"TARGET_ARM &&\n-  (!(const_ok_for_arm (INTVAL (operands[2]))\n-   || const_ok_for_arm (-INTVAL (operands[2]))))\"\n-  [(clobber (const_int 0))]\n-  \"\n-  arm_split_constant (PLUS, SImode, INTVAL (operands[2]), operands[0],\n-\t\t      operands[1], 0);\n-  DONE;\n-\")\n+   !(const_ok_for_arm (INTVAL (operands[2]))\n+     || const_ok_for_arm (-INTVAL (operands[2])))\n+    && const_ok_for_arm (~INTVAL (operands[2]))\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (plus:SI (match_dup 1) (match_dup 3)))]\n+  \"\"\n+)\n \n-(define_insn \"*arm_addsi3\"\n+(define_insn_and_split \"*arm_addsi3\"\n   [(set (match_operand:SI          0 \"s_register_operand\" \"=r,r,r\")\n-\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"r, r,r\")\n+\t(plus:SI (match_operand:SI 1 \"s_register_operand\" \"%r,r,r\")\n \t\t (match_operand:SI 2 \"reg_or_int_operand\" \"rI,L,?n\")))]\n   \"TARGET_ARM\"\n   \"@\n    add%?\\\\t%0, %1, %2\n    sub%?\\\\t%0, %1, #%n2\n    #\"\n+  \"TARGET_ARM &&\n+   GET_CODE (operands[2]) == CONST_INT\n+   && !(const_ok_for_arm (INTVAL (operands[2]))\n+        || const_ok_for_arm (-INTVAL (operands[2])))\"\n+  [(clobber (const_int 0))]\n+  \"\n+  arm_split_constant (PLUS, SImode, INTVAL (operands[2]), operands[0],\n+\t\t      operands[1], 0);\n+  DONE;\n+  \"\n   [(set_attr \"length\" \"4,4,16\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -568,7 +540,7 @@\n \n ;; Reloading and elimination of the frame pointer can\n ;; sometimes cause this optimization to be missed.\n-(define_peephole\n+(define_peephole2\n   [(set (match_operand:SI 0 \"register_operand\" \"=l\")\n \t(match_operand:SI 1 \"const_int_operand\" \"M\"))\n    (set (match_dup 0)\n@@ -577,8 +549,8 @@\n    && REGNO (operands[2]) == STACK_POINTER_REGNUM \n    && (unsigned HOST_WIDE_INT) (INTVAL (operands[1])) < 1024\n    && (INTVAL (operands[1]) & 3) == 0\"\n-  \"add\\\\t%0, %2, %1\"\n-  [(set_attr \"length\" \"2\")]\n+  [(set (match_dup 0) (plus:SI (match_dup 2) (match_dup 1)))]\n+  \"\"\n )\n \n (define_insn \"*addsi3_compare0\"\n@@ -764,73 +736,9 @@\n    (set_attr \"length\" \"4,8\")]\n )\n \n-; If a constant is too big to fit in a single instruction then the constant\n-; will be pre-loaded into a register taking at least two insns, we might be\n-; able to merge it with an add, but it depends on the exact value.\n-\n-(define_split\n-  [(set (match_operand:SI          0 \"s_register_operand\" \"=r\")\n-\t(plus:SI (match_operand:SI 1 \"s_register_operand\"  \"r\")\n-\t\t (match_operand:SI 2 \"const_int_operand\"   \"n\")))]\n-  \"TARGET_ARM\n-    && (!(const_ok_for_arm (INTVAL (operands[2]))\n-\t   || const_ok_for_arm (-INTVAL (operands[2]))))\"\n-  [(set (match_dup 0) (plus:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0) (plus:SI (match_dup 0) (match_dup 3)))]\n-  \"\n-  {\n-    unsigned int val = (unsigned) INTVAL (operands[2]);\n-    int i;\n-    unsigned int temp;\n-\n-    /* This code is similar to the approach followed in movsi,\n-       but it must generate exactly two insns.  */\n-\n-    for (i = 30; i >= 0; i -= 2)\n-      {\n-\tif (val & (3 << i))\n-\t  {\n-\t    i -= 6;\n-\t    if (i < 0)\n-\t      i = 0;\n-\n-\t    if (const_ok_for_arm (temp = (val & ~(255 << i))))\n-\t      {\n-\t\tval &= 255 << i;\n-\t\tbreak;\n-\t      }\n-\n-\t    /* We might be able to do this as (larger number - small\n-               number).  */\n-\t    temp = ((val >> i) & 255) + 1;\n-\t    if (temp > 255 && i < 24)\n-\t      {\n-\t\ti += 2;\n-\t\ttemp = ((val >> i) & 255) + 1;\n-\t      }\n-\n-\t    if (const_ok_for_arm ((temp << i) - val))\n-\t      {\n-\t\ti = temp << i;\n-\t\ttemp = (unsigned) - (int) (i - val);\n-\t\tval = i;\n-\t\tbreak;\n-\t      }\n-\n-\t    FAIL;\n-\t  }\n-      }\n-\n-    /* If we got here, we have found a way of doing it in two\n-       instructions.  the two constants are in val and temp.  */\n-    operands[2] = GEN_INT ((int) val);\n-    operands[3] = GEN_INT ((int) temp);\n-  }\"\n-)\n-\n (define_insn \"addsf3\"\n   [(set (match_operand:SF          0 \"s_register_operand\" \"=f,f\")\n-\t(plus:SF (match_operand:SF 1 \"s_register_operand\"  \"f,f\")\n+\t(plus:SF (match_operand:SF 1 \"s_register_operand\" \"%f,f\")\n \t\t (match_operand:SF 2 \"fpu_add_operand\"    \"fG,H\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"@\n@@ -842,7 +750,7 @@\n \n (define_insn \"adddf3\"\n   [(set (match_operand:DF          0 \"s_register_operand\" \"=f,f\")\n-\t(plus:DF (match_operand:DF 1 \"s_register_operand\"  \"f,f\")\n+\t(plus:DF (match_operand:DF 1 \"s_register_operand\" \"%f,f\")\n \t\t (match_operand:DF 2 \"fpu_add_operand\"    \"fG,H\")))]\n   \"TARGET_ARM && TARGET_HARD_FLOAT\"\n   \"@\n@@ -1031,29 +939,38 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-(define_insn \"*arm_subsi3_insn\"\n+(define_insn_and_split \"*arm_subsi3_insn\"\n   [(set (match_operand:SI           0 \"s_register_operand\" \"=r,r\")\n \t(minus:SI (match_operand:SI 1 \"reg_or_int_operand\" \"rI,?n\")\n \t\t  (match_operand:SI 2 \"s_register_operand\" \"r,r\")))]\n   \"TARGET_ARM\"\n   \"@\n    rsb%?\\\\t%0, %2, %1\n    #\"\n-  [(set_attr \"length\" \"4,16\")\n-   (set_attr \"predicable\" \"yes\")]\n-)\n-\n-(define_split\n-  [(set (match_operand:SI           0 \"s_register_operand\" \"\")\n-\t(minus:SI (match_operand:SI 1 \"const_int_operand\" \"\")\n-\t\t  (match_operand:SI 2 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && (!const_ok_for_arm (INTVAL (operands[1])))\"\n+  \"TARGET_ARM\n+   && GET_CODE (operands[1]) == CONST_INT\n+   && !const_ok_for_arm (INTVAL (operands[1]))\"\n   [(clobber (const_int 0))]\n   \"\n   arm_split_constant (MINUS, SImode, INTVAL (operands[1]), operands[0],\n \t\t      operands[2], 0);\n   DONE;\n   \"\n+  [(set_attr \"length\" \"4,16\")\n+   (set_attr \"predicable\" \"yes\")]\n+)\n+\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (set (match_operand:SI           0 \"s_register_operand\" \"\")\n+\t(minus:SI (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t  (match_operand:SI 2 \"s_register_operand\" \"\")))]\n+  \"TARGET_ARM\n+   && !const_ok_for_arm (INTVAL (operands[1]))\n+   && const_ok_for_arm (~INTVAL (operands[1]))\"\n+  [(set (match_dup 3) (match_dup 1))\n+   (set (match_dup 0) (minus:SI (match_dup 3) (match_dup 2)))]\n+  \"\"\n )\n \n (define_insn \"*subsi3_compare0\"\n@@ -1577,40 +1494,6 @@\n   }\"\n )\n \n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(not:DI (match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && reload_completed\"\n-  [(set (match_dup 0) (not:SI (match_dup 1)))\n-   (set (match_dup 2) (not:SI (match_dup 3)))]\n-  \"\n-  {\n-    operands[2] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[3] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-)\n-\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(and:DI\n-\t  (not:DI (match_operand:DI 1 \"s_register_operand\" \"\"))\n-\t  (match_operand:DI 2 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && reload_completed\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[5] = gen_highpart (SImode, operands[2]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n (define_split\n   [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n \t(match_operator:DI 6 \"logical_binary_operator\"\n@@ -1632,44 +1515,6 @@\n   }\"\n )\n \n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(and:DI (not:DI (sign_extend:DI\n-\t\t\t(match_operand:SI 2 \"s_register_operand\" \"\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && reload_completed\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3) (and:SI (not:SI\n-\t\t\t\t(ashiftrt:SI (match_dup 2) (const_int 31)))\n-\t\t\t       (match_dup 4)))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n-;; The zero extend of operand 2 clears the high word of the output\n-;; operand.\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(and:DI\n-\t  (zero_extend:DI (match_operand:SI 2 \"s_register_operand\" \"\"))\n-\t  (match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && reload_completed\"\n-  [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3) (const_int 0))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-  }\"\n-)\n-\n ;; The zero extend of operand 2 means we can just copy the high part of\n ;; operand1 into operand0.\n (define_split\n@@ -1708,26 +1553,6 @@\n   }\"\n )\n \n-;; (not (zero_extend ...)) allows us to just copy the high word from\n-;; operand1 to operand0.\n-(define_split\n-  [(set (match_operand:DI 0 \"s_register_operand\" \"\")\n-\t(and:DI (not:DI (zero_extend:DI\n-\t\t\t(match_operand:SI 2 \"s_register_operand\" \"\")))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"\")))]\n-  \"TARGET_ARM && operands[0] != operands[1] && reload_completed\"\n-  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n-   (set (match_dup 3) (match_dup 4))]\n-  \"\n-  {\n-    operands[3] = gen_highpart (SImode, operands[0]);\n-    operands[0] = gen_lowpart (SImode, operands[0]);\n-    operands[4] = gen_highpart (SImode, operands[1]);\n-    operands[1] = gen_lowpart (SImode, operands[1]);\n-    operands[2] = gen_lowpart (SImode, operands[2]);\n-  }\"\n-)\n-\n (define_insn \"anddi3\"\n   [(set (match_operand:DI         0 \"s_register_operand\" \"=&r,&r\")\n \t(and:DI (match_operand:DI 1 \"s_register_operand\"  \"%0,r\")\n@@ -1737,13 +1562,24 @@\n   [(set_attr \"length\" \"8\")]\n )\n \n-(define_insn \"*anddi_zesidi_di\"\n+(define_insn_and_split \"*anddi_zesidi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(and:DI (zero_extend:DI\n \t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\"))\n \t\t(match_operand:DI 1 \"s_register_operand\" \"?r,0\")))]\n   \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  ; The zero extend of operand 2 clears the high word of the output\n+  ; operand.\n+  [(set (match_dup 0) (and:SI (match_dup 1) (match_dup 2)))\n+   (set (match_dup 3) (const_int 0))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\"\n   [(set_attr \"length\" \"8\")]\n )\n \n@@ -1819,7 +1655,7 @@\n   \"\n )\n \n-(define_insn \"*arm_andsi3_insn\"\n+(define_insn_and_split \"*arm_andsi3_insn\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r,r,r\")\n \t(and:SI (match_operand:SI 1 \"s_register_operand\" \"r,r,r\")\n \t\t(match_operand:SI 2 \"reg_or_int_operand\" \"rI,K,?n\")))]\n@@ -1828,6 +1664,16 @@\n    and%?\\\\t%0, %1, %2\n    bic%?\\\\t%0, %1, #%B2\n    #\"\n+  \"TARGET_ARM\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && !(const_ok_for_arm (INTVAL (operands[2]))\n+\t|| const_ok_for_arm (~INTVAL (operands[2])))\"\n+  [(clobber (const_int 0))]\n+  \"\n+  arm_split_constant  (AND, SImode, INTVAL (operands[2]), operands[0],\n+\t\t       operands[1], 0);\n+  DONE;\n+  \"\n   [(set_attr \"length\" \"4,4,16\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -1841,21 +1687,6 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n-\t(and:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_ARM\n-   && (!(const_ok_for_arm (INTVAL (operands[2]))\n-\t || const_ok_for_arm (~INTVAL (operands[2]))))\"\n-  [(clobber (const_int 0))]\n-  \"\n-  arm_split_constant  (AND, SImode, INTVAL (operands[2]), operands[0],\n-\t\t       operands[1], 0);\n-  DONE;\n-  \"\n-)\n-\n (define_insn \"*andsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV\n@@ -2073,17 +1904,29 @@\n )\n \n ; constants for op 2 will never be given to these patterns.\n-(define_insn \"*anddi_notdi_di\"\n+(define_insn_and_split \"*anddi_notdi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n-\t(and:DI (not:DI (match_operand:DI 2 \"s_register_operand\" \"r,0\"))\n-\t\t(match_operand:DI 1 \"s_register_operand\" \"0,r\")))]\n+\t(and:DI (not:DI (match_operand:DI 1 \"s_register_operand\" \"r,0\"))\n+\t\t(match_operand:DI 2 \"s_register_operand\" \"0,r\")))]\n   \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n+   (set (match_dup 3) (and:SI (not:SI (match_dup 4)) (match_dup 5)))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+    operands[5] = gen_highpart (SImode, operands[2]);\n+    operands[2] = gen_lowpart (SImode, operands[2]);\n+  }\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")]\n )\n   \n-(define_insn \"*anddi_notzesidi_di\"\n+(define_insn_and_split \"*anddi_notzesidi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(and:DI (not:DI (zero_extend:DI\n \t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n@@ -2092,17 +1935,43 @@\n   \"@\n    bic%?\\\\t%Q0, %Q1, %2\n    #\"\n+  ; (not (zero_extend ...)) allows us to just copy the high word from\n+  ; operand1 to operand0.\n+  \"TARGET_ARM\n+   && reload_completed\n+   && operands[0] != operands[1]\"\n+  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n+   (set (match_dup 3) (match_dup 4))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\"\n   [(set_attr \"length\" \"4,8\")\n    (set_attr \"predicable\" \"yes\")]\n )\n   \n-(define_insn \"*anddi_notsesidi_di\"\n+(define_insn_and_split \"*anddi_notsesidi_di\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(and:DI (not:DI (sign_extend:DI\n \t\t\t (match_operand:SI 2 \"s_register_operand\" \"r,r\")))\n \t\t(match_operand:DI 1 \"s_register_operand\" \"?r,0\")))]\n   \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 0) (and:SI (not:SI (match_dup 1)) (match_dup 2)))\n+   (set (match_dup 3) (and:SI (not:SI\n+\t\t\t\t(ashiftrt:SI (match_dup 2) (const_int 31)))\n+\t\t\t       (match_dup 4)))]\n+  \"\n+  {\n+    operands[3] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[4] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -2218,14 +2087,23 @@\n   \"\n )\n \n-(define_insn \"*arm_iorsi3\"\n+(define_insn_and_split \"*arm_iorsi3\"\n   [(set (match_operand:SI         0 \"s_register_operand\" \"=r,r\")\n \t(ior:SI (match_operand:SI 1 \"s_register_operand\" \"r,r\")\n \t\t(match_operand:SI 2 \"reg_or_int_operand\" \"rI,?n\")))]\n   \"TARGET_ARM\"\n   \"@\n    orr%?\\\\t%0, %1, %2\n    #\"\n+  \"TARGET_ARM\n+   && GET_CODE (operands[2]) == CONST_INT\n+   && !const_ok_for_arm (INTVAL (operands[2]))\"\n+  [(clobber (const_int 0))]\n+  \"\n+  arm_split_constant (IOR, SImode, INTVAL (operands[2]), operands[0],\n+\t\t      operands[1], 0);\n+  DONE;\n+  \"\n   [(set_attr \"length\" \"4,16\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -2239,19 +2117,19 @@\n   [(set_attr \"length\" \"2\")]\n )\n \n-(define_split\n-  [(set (match_operand:SI         0 \"s_register_operand\" \"\")\n+(define_peephole2\n+  [(match_scratch:SI 3 \"r\")\n+   (set (match_operand:SI         0 \"s_register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"s_register_operand\" \"\")\n \t\t(match_operand:SI 2 \"const_int_operand\" \"\")))]\n-  \"TARGET_ARM && (!const_ok_for_arm (INTVAL (operands[2])))\"\n-  [(clobber (const_int 0))]\n-  \"\n-  arm_split_constant (IOR, SImode, INTVAL (operands[2]), operands[0],\n-\t\t      operands[1], 0);\n-  DONE;\n-  \"\n+  \"TARGET_ARM\n+   && !const_ok_for_arm (INTVAL (operands[2]))\n+   && const_ok_for_arm (~INTVAL (operands[2]))\"\n+  [(set (match_dup 3) (match_dup 2))\n+   (set (match_dup 0) (ior:SI (match_dup 1) (match_dup 3)))]\n+  \"\"\n )\n-  \n+\n (define_insn \"*iorsi3_compare0\"\n   [(set (reg:CC_NOOV CC_REGNUM)\n \t(compare:CC_NOOV (ior:SI (match_operand:SI 1 \"s_register_operand\" \"%r\")\n@@ -2986,11 +2864,21 @@\n ;  \"cos%?e\\\\t%0, %1\"\n ;[(set_attr \"type\" \"float_em\")])\n \n-(define_insn \"one_cmpldi2\"\n+(define_insn_and_split \"one_cmpldi2\"\n   [(set (match_operand:DI 0 \"s_register_operand\" \"=&r,&r\")\n \t(not:DI (match_operand:DI 1 \"s_register_operand\" \"?r,0\")))]\n   \"TARGET_ARM\"\n   \"#\"\n+  \"TARGET_ARM && reload_completed\"\n+  [(set (match_dup 0) (not:SI (match_dup 1)))\n+   (set (match_dup 2) (not:SI (match_dup 3)))]\n+  \"\n+  {\n+    operands[2] = gen_highpart (SImode, operands[0]);\n+    operands[0] = gen_lowpart (SImode, operands[0]);\n+    operands[3] = gen_highpart (SImode, operands[1]);\n+    operands[1] = gen_lowpart (SImode, operands[1]);\n+  }\"\n   [(set_attr \"length\" \"8\")\n    (set_attr \"predicable\" \"yes\")]\n )\n@@ -8417,15 +8305,15 @@\n \n ; This pattern is never tried by combine, so do it as a peephole\n \n-(define_peephole\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"s_register_operand\" \"r\"))\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"s_register_operand\" \"\")\n+\t(match_operand:SI 1 \"s_register_operand\" \"\"))\n    (set (reg:CC CC_REGNUM)\n \t(compare:CC (match_dup 1) (const_int 0)))]\n-  \"TARGET_ARM\n-  \"\n-  \"sub%?s\\\\t%0, %1, #0\"\n-  [(set_attr \"conds\" \"set\")]\n+  \"TARGET_ARM\"\n+  [(parallel [(set (reg:CC CC_REGNUM) (compare:CC (match_dup 1) (const_int 0)))\n+\t      (set (match_dup 0) (match_dup 1))])]\n+  \"\"\n )\n \n ; Peepholes to spot possible load- and store-multiples, if the ordering is"}]}