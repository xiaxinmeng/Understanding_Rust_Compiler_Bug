{"sha": "c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "node_id": "C_kwDOANBUbNoAKGM0YTkyYTkxMTdhMDM0ZTdjZjI5MWFlNTFkOGI5Yjg0NGZiNWE4OGI", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-11-22T17:22:03Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2022-11-22T17:28:44Z"}, "message": "ipa-cp: Do not be too optimistic about self-recursive edges (PR 107661)\n\nPR 107661 shows that function push_agg_values_for_index_from_edge\nshould not attempt to optimize self-recursive call graph edges when\ncalled from cgraph_edge_brings_all_agg_vals_for_node.  Unlike when\nbeing called from find_aggregate_values_for_callers_subset, we cannot\nexpect that any cloning for constants would lead to the edge leading\nfrom a new clone to the same new clone, in this case it would only be\nredirected to a new callee.\n\nFixed by adding a parameter to push_agg_values_from_edge whether being\noptimistic about self-recursive edges is possible.\n\ngcc/ChangeLog:\n\n2022-11-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107661\n\t* ipa-cp.cc (push_agg_values_from_edge): New parameter\n\toptimize_self_recursion, use it to decide whether to pass interim to\n\tthe helper function.\n\t(find_aggregate_values_for_callers_subset): Pass true in the new\n\tparameter of push_agg_values_from_edge.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Pass false in the new\n\tparameter of push_agg_values_from_edge.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107661\n\t* g++.dg/ipa/pr107661.C: New test.", "tree": {"sha": "79d3a5576878f91a4f881e3c6085adc773e7fa23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79d3a5576878f91a4f881e3c6085adc773e7fa23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmN9BswACgkQv2PBvD+k\nNUCqlhAAj7G4cJ/Oa7D4jsktNuAeVDvd5e2MEcWy8RdB2YEM6E1Z8YnAbLQSJTV/\nSeq5SVpPQ6AJNbzdq4+0eLFnQswG7kzUod7hBj9cy9rLbHQkmfGZBtqflcDg2FT1\nV05kl1BWs3uTLu2Gmqmyw91+SdDbNATCvDLXMYrLwFgAhEjEV0RS9wN+3M71rYLE\nC6RbL3VCL0Wr8PfECigsmV4EEngS2GNP9r70hGUu6GOZEqO8krJalZ5dKcx4zSG/\nxydcHbeVGvSXkk//d9rAxaATn/IpVf0W+g0Cs7JCBbvMQ3IeZUrqGPbBPwITvwDs\n7CHFptiOXz68zKgVCjuIX3i8JTVHelvUEfr3w9aHm2droLXvHltL/kiGltM0rT6E\nuvxAyX3OVyLpOghJ/psoAWJgCjQvR1qi3gG1TWxjv2xsR9tO6fH18uAD3lM+9z1a\nLEM4rjowBJepe0kPbyuDDsgl7yoBbR/A9L4/tyh7X63n46c7mk5zjIEaQjl+kJ1G\nkq44jES1N8jTj6m1CbdYMQjOhDVhJo8Rir44pWZKtpPvy7ks6pF6vq6bCGM13cSM\nQzSRzDh36h+CuuPA/6wN7yUgPQPr9fz3DgxlJIbxOu5bn21pIYlm+CaRTRu/eLYu\nhzEEFUqxRJAWNpGo84PNNzDO4Cn9X+s96CAxmSLCPzr72dYtI0U=\n=FSs1\n-----END PGP SIGNATURE-----", "payload": "tree 79d3a5576878f91a4f881e3c6085adc773e7fa23\nparent d6bbca7b78745915d98bb1324d79de6a1e6dc801\nauthor Martin Jambor <mjambor@suse.cz> 1669137723 +0100\ncommitter Martin Jambor <mjambor@suse.cz> 1669138124 +0100\n\nipa-cp: Do not be too optimistic about self-recursive edges (PR 107661)\n\nPR 107661 shows that function push_agg_values_for_index_from_edge\nshould not attempt to optimize self-recursive call graph edges when\ncalled from cgraph_edge_brings_all_agg_vals_for_node.  Unlike when\nbeing called from find_aggregate_values_for_callers_subset, we cannot\nexpect that any cloning for constants would lead to the edge leading\nfrom a new clone to the same new clone, in this case it would only be\nredirected to a new callee.\n\nFixed by adding a parameter to push_agg_values_from_edge whether being\noptimistic about self-recursive edges is possible.\n\ngcc/ChangeLog:\n\n2022-11-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107661\n\t* ipa-cp.cc (push_agg_values_from_edge): New parameter\n\toptimize_self_recursion, use it to decide whether to pass interim to\n\tthe helper function.\n\t(find_aggregate_values_for_callers_subset): Pass true in the new\n\tparameter of push_agg_values_from_edge.\n\t(cgraph_edge_brings_all_agg_vals_for_node): Pass false in the new\n\tparameter of push_agg_values_from_edge.\n\ngcc/testsuite/ChangeLog:\n\n2022-11-22  Martin Jambor  <mjambor@suse.cz>\n\n\tPR ipa/107661\n\t* g++.dg/ipa/pr107661.C: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d6bbca7b78745915d98bb1324d79de6a1e6dc801", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6bbca7b78745915d98bb1324d79de6a1e6dc801", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6bbca7b78745915d98bb1324d79de6a1e6dc801"}], "stats": {"total": 63, "additions": 56, "deletions": 7}, "files": [{"sha": "f0feb4beb8f6931c686c55734796c7cb542b54eb", "filename": "gcc/ipa-cp.cc", "status": "modified", "additions": 11, "deletions": 7, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b/gcc%2Fipa-cp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b/gcc%2Fipa-cp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.cc?ref=c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "patch": "@@ -5752,14 +5752,16 @@ push_agg_values_for_index_from_edge (struct cgraph_edge *cs, int index,\n    description of ultimate callee of CS or the one it was cloned from (the\n    summary where lattices are).  If INTERIM is non-NULL, it contains the\n    current interim state of collected aggregate values which can be used to\n-   compute values passed over self-recursive edges and to skip values which\n-   clearly will not be part of intersection with INTERIM.  */\n+   compute values passed over self-recursive edges (if OPTIMIZE_SELF_RECURSION\n+   is true) and to skip values which clearly will not be part of intersection\n+   with INTERIM.  */\n \n static void\n push_agg_values_from_edge (struct cgraph_edge *cs,\n \t\t\t   ipa_node_params *dest_info,\n \t\t\t   vec<ipa_argagg_value> *res,\n-\t\t\t   const ipa_argagg_value_list *interim)\n+\t\t\t   const ipa_argagg_value_list *interim,\n+\t\t\t   bool optimize_self_recursion)\n {\n   ipa_edge_args *args = ipa_edge_args_sum->get (cs);\n   if (!args)\n@@ -5785,7 +5787,9 @@ push_agg_values_from_edge (struct cgraph_edge *cs,\n       ipcp_param_lattices *plats = ipa_get_parm_lattices (dest_info, index);\n       if (plats->aggs_bottom)\n \tcontinue;\n-      push_agg_values_for_index_from_edge (cs, index, res, interim);\n+      push_agg_values_for_index_from_edge (cs, index, res,\n+\t\t\t\t\t   optimize_self_recursion ? interim\n+\t\t\t\t\t   : NULL);\n     }\n }\n \n@@ -5804,7 +5808,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n   /* gather_edges_for_value puts a non-recursive call into the first element of\n      callers if it can.  */\n   auto_vec<ipa_argagg_value, 32> interim;\n-  push_agg_values_from_edge (callers[0], dest_info, &interim, NULL);\n+  push_agg_values_from_edge (callers[0], dest_info, &interim, NULL, true);\n \n   unsigned valid_entries = interim.length ();\n   if (!valid_entries)\n@@ -5815,7 +5819,7 @@ find_aggregate_values_for_callers_subset (struct cgraph_node *node,\n     {\n       auto_vec<ipa_argagg_value, 32> last;\n       ipa_argagg_value_list avs (&interim);\n-      push_agg_values_from_edge (callers[i], dest_info, &last, &avs);\n+      push_agg_values_from_edge (callers[i], dest_info, &last, &avs, true);\n \n       valid_entries = intersect_argaggs_with (interim, last);\n       if (!valid_entries)\n@@ -5882,7 +5886,7 @@ cgraph_edge_brings_all_agg_vals_for_node (struct cgraph_edge *cs,\n   ipa_node_params *dest_info = ipa_node_params_sum->get (node);\n   gcc_checking_assert (dest_info->ipcp_orig_node);\n   dest_info = ipa_node_params_sum->get (dest_info->ipcp_orig_node);\n-  push_agg_values_from_edge (cs, dest_info, &edge_values, &existing);\n+  push_agg_values_from_edge (cs, dest_info, &edge_values, &existing, false);\n   const ipa_argagg_value_list avl (&edge_values);\n   return avl.superset_of_p (existing);\n }"}, {"sha": "cc6f8538dbfb1a9bef4b392973ef87cef8e2c950", "filename": "gcc/testsuite/g++.dg/ipa/pr107661.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr107661.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4a92a9117a034e7cf291ae51d8b9b844fb5a88b/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr107661.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fipa%2Fpr107661.C?ref=c4a92a9117a034e7cf291ae51d8b9b844fb5a88b", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run  { target c++11 } } */\n+/* { dg-options \"-O1 -fipa-cp -fipa-cp-clone\" } */\n+\n+struct R {} RGood;\n+struct L {} LBad;\n+\n+volatile int vi;\n+static void __attribute__((noipa)) L_run(void) { vi = 0; __builtin_abort (); }\n+static void callback_fn_L(void) { vi = 1; L_run(); }\n+static void callback_fn_R(void) { vi = 2; }\n+\n+struct function_ref {\n+  void (*callback)(void) = nullptr;\n+\n+  function_ref(L * pl) { callback = callback_fn_L; }\n+  function_ref(R * pr) { callback = callback_fn_R; }\n+};\n+\n+// allow one level of recursion to call callback twice\n+static int is_recur(void) {\n+    static int n = 0;\n+    switch (n++) {\n+      case 0: return 1;\n+      default: return 0;\n+    }\n+}\n+\n+static void do3(volatile int * punused, function_ref Expired) {\n+  Expired.callback();\n+\n+  if (is_recur())\n+      do3(punused, Expired);\n+}\n+\n+static void do1(function_ref Expired) {\n+  volatile int unused = 42;\n+\n+  do3(&unused, Expired);\n+}\n+\n+int main(int, const char **) { do1(&RGood); return 0; }\n+\n+void seemingly_unused_foo(void) { do1(&LBad); }\n+\n+void (*fnptr)(void) = seemingly_unused_foo;"}]}