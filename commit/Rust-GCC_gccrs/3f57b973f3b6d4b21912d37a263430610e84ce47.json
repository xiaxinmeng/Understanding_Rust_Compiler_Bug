{"sha": "3f57b973f3b6d4b21912d37a263430610e84ce47", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2Y1N2I5NzNmM2I2ZDRiMjE5MTJkMzdhMjYzNDMwNjEwZTg0Y2U0Nw==", "commit": {"author": {"name": "Mark Wielaard", "email": "mark@klomp.org", "date": "2001-02-17T15:09:46Z"}, "committer": {"name": "Mark Wielaard", "email": "mark@gcc.gnu.org", "date": "2001-02-17T15:09:46Z"}, "message": "Remerge with Classpath (changes by Bryce McKinlay <bryce@albatross.co.nz>)\n\n    Remerge with Classpath\n    (changes by Bryce McKinlay  <bryce@albatross.co.nz>)\n    * java/io/DataInputStream.java (readBoolean): Use convertToBoolean().\n    (readByte): Use convertToByte().\n    (readChar): Use convertToChar().\n    (readInt): Use convertToInt().\n    (readLong): Use convertToLong().\n    (readShort): Use convertToShort().\n    (readUnsignedByte): Use convertToUnsignedByte().\n    (readUnsignedShort): Use convertToUnsignedShort().\n    (readUTF): Use convertToUTF().\n\n    (convertToBoolean): Resurrected.\n    (convertToByte): Ditto.\n    (convertToChar): Ditto.\n    (convertToInt): Ditto.\n    (convertToLong): Ditto.\n    (convertToShort): Ditto.\n    (convertToUnsignedByte): Ditto.\n    (convertToUnsignedShort): Ditto.\n    (convertToUTF): Ditto.\n\nFrom-SVN: r39800", "tree": {"sha": "77f74bc7036fe475d2b489e8cf040d0870be772c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77f74bc7036fe475d2b489e8cf040d0870be772c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3f57b973f3b6d4b21912d37a263430610e84ce47", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f57b973f3b6d4b21912d37a263430610e84ce47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f57b973f3b6d4b21912d37a263430610e84ce47", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f57b973f3b6d4b21912d37a263430610e84ce47/comments", "author": null, "committer": null, "parents": [{"sha": "a7e96ed41a2e1a7878d41e74579ab1b76fa4fbe3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7e96ed41a2e1a7878d41e74579ab1b76fa4fbe3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7e96ed41a2e1a7878d41e74579ab1b76fa4fbe3"}], "stats": {"total": 215, "additions": 135, "deletions": 80}, "files": [{"sha": "7c10bba9b6ef6431d368c8fa7725b4b2f92988ad", "filename": "libjava/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f57b973f3b6d4b21912d37a263430610e84ce47/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f57b973f3b6d4b21912d37a263430610e84ce47/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=3f57b973f3b6d4b21912d37a263430610e84ce47", "patch": "@@ -1,3 +1,27 @@\n+2001-02-17  Mark Wielaard <mark@klomp.org>\n+\n+\tRemerge with Classpath\n+\t(changes by Bryce McKinlay  <bryce@albatross.co.nz>)\n+\t* java/io/DataInputStream.java (readBoolean): Use convertToBoolean().\n+\t(readByte): Use convertToByte().\n+\t(readChar): Use convertToChar().\n+\t(readInt): Use convertToInt().\n+\t(readLong): Use convertToLong().\n+\t(readShort): Use convertToShort().\n+\t(readUnsignedByte): Use convertToUnsignedByte().\n+\t(readUnsignedShort): Use convertToUnsignedShort().\n+\t(readUTF): Use convertToUTF().\n+\n+\t(convertToBoolean): Resurrected.\n+\t(convertToByte): Ditto.\n+\t(convertToChar): Ditto.\n+\t(convertToInt): Ditto.\n+\t(convertToLong): Ditto.\n+\t(convertToShort): Ditto.\n+\t(convertToUnsignedByte): Ditto.\n+\t(convertToUnsignedShort): Ditto.\n+\t(convertToUTF): Ditto.\n+\n 2001-02-17  Mark Wielaard <mark@klomp.org>\n \n \t* HACKING: new file"}, {"sha": "1607967cc66468b77c8864e520268f17a8fa8808", "filename": "libjava/java/io/DataInputStream.java", "status": "modified", "additions": 111, "deletions": 80, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3f57b973f3b6d4b21912d37a263430610e84ce47/libjava%2Fjava%2Fio%2FDataInputStream.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3f57b973f3b6d4b21912d37a263430610e84ce47/libjava%2Fjava%2Fio%2FDataInputStream.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Fio%2FDataInputStream.java?ref=3f57b973f3b6d4b21912d37a263430610e84ce47", "patch": "@@ -51,6 +51,9 @@ public class DataInputStream extends FilterInputStream implements DataInput\n   // handled correctly. If set, readLine() will ignore the first char it sees\n   // if that char is a '\\n'\n   boolean ignoreInitialNewline = false;\n+\n+  // Byte buffer, used to make primitive read calls more efficient.\n+  byte[] buf = new byte[8];\n   \n   /**\n    * This constructor initializes a new <code>DataInputStream</code>\n@@ -120,10 +123,7 @@ public final int read(byte[] b, int off, int len) throws IOException\n    */\n   public final boolean readBoolean() throws IOException\n   {\n-    int b = in.read();\n-    if (b < 0)\n-      throw new EOFException();    \n-    return (b != 0);\n+    return convertToBoolean(in.read());\n   }\n \n   /**\n@@ -143,11 +143,7 @@ public final boolean readBoolean() throws IOException\n    */\n   public final byte readByte() throws IOException\n   {\n-    int i = in.read();\n-    if (i < 0)\n-      throw new EOFException();\n-\n-    return (byte) i;\n+    return convertToByte(in.read());\n   }\n \n   /**\n@@ -177,11 +173,10 @@ public final byte readByte() throws IOException\n    */\n   public final char readChar() throws IOException\n   {\n-    int a = in.read();\n-    int b = in.read();\n-    if (b < 0)\n+    int count = in.read (buf, 0, 2);\n+    if (count < 2)\n       throw new EOFException();\n-    return (char) ((a << 8) | (b & 0xff));\n+    return convertToChar(buf);\n   }\n \n   /**\n@@ -308,15 +303,10 @@ public final void readFully(byte[] b, int off, int len) throws IOException\n    */\n   public final int readInt() throws IOException\n   {\n-    int a = in.read();\n-    int b = in.read();\n-    int c = in.read();\n-    int d = in.read();\n-    if (d < 0)\n+    int count = in.read (buf, 0, 4);\n+    if (count < 4)\n       throw new EOFException();\n-    \n-    return (((a & 0xff) << 24) | ((b & 0xff) << 16) |\n-\t    ((c & 0xff) << 8) | (d & 0xff));\n+    return convertToInt(buf);\n   }\n \n   /**\n@@ -463,25 +453,10 @@ else if (markSupported())\n    */\n   public final long readLong() throws IOException\n   {\n-    int a = in.read();\n-    int b = in.read();\n-    int c = in.read();\n-    int d = in.read();\n-    int e = in.read();\n-    int f = in.read();\n-    int g = in.read();\n-    int h = in.read();\n-    if (h < 0)\n+    int count = in.read(buf, 0, 8);\n+    if (count < 8)\n       throw new EOFException();\n-    \n-    return (((long)(a & 0xff) << 56) |\n-\t    ((long)(b & 0xff) << 48) |\n-\t    ((long)(c & 0xff) << 40) |\n-\t    ((long)(d & 0xff) << 32) |\n-\t    ((long)(e & 0xff) << 24) |\n-\t    ((long)(f & 0xff) << 16) |\n-\t    ((long)(g & 0xff) <<  8) |\n-\t    ((long)(h & 0xff)));\n+    return convertToLong(buf);\n   }\n \n   /**\n@@ -513,11 +488,10 @@ public final long readLong() throws IOException\n    */\n   public final short readShort() throws IOException\n   {\n-    int a = in.read();\n-    int b = in.read();\n-    if (b < 0)\n+    int count = in.read(buf, 0, 2);\n+    if (count < 2)\n       throw new EOFException();\n-    return (short) ((a << 8) | (b & 0xff));\n+    return convertToShort(buf);\n   }\n \n   /**\n@@ -538,11 +512,7 @@ public final short readShort() throws IOException\n    */\n   public final int readUnsignedByte() throws IOException\n   {\n-    int i = in.read();\n-    if (i < 0)\n-      throw new EOFException();\n-\n-    return (i & 0xFF);\n+    return convertToUnsignedByte(in.read());\n   }\n \n   /**\n@@ -572,11 +542,10 @@ public final int readUnsignedByte() throws IOException\n    */\n   public final int readUnsignedShort() throws IOException\n   {\n-    int a = in.read();\n-    int b = in.read();\n-    if (b < 0)\n+    int count = in.read(buf, 0, 2);\n+    if (count < 2)\n       throw new EOFException();\n-    return (((a & 0xff) << 8) | (b & 0xff));\n+    return convertToUnsignedShort(buf);\n   }\n \n   /**\n@@ -668,41 +637,14 @@ public final static String readUTF(DataInput in) throws IOException\n   {\n     final int UTFlen = in.readUnsignedShort();\n     byte[] buf = new byte[UTFlen];\n-    StringBuffer strbuf = new StringBuffer();\n \n     // This blocks until the entire string is available rather than\n     // doing partial processing on the bytes that are available and then\n     // blocking.  An advantage of the latter is that Exceptions\n     // could be thrown earlier.  The former is a bit cleaner.\n     in.readFully(buf, 0, UTFlen);\n-    for (int i = 0; i < UTFlen; )\n-      {\n-\tif ((buf[i] & 0x80) == 0)\t\t// bit pattern 0xxxxxxx\n-\t  strbuf.append((char) (buf[i++] & 0xFF));\n-\telse if ((buf[i] & 0xE0) == 0xC0)\t// bit pattern 110xxxxx\n-\t  {\n-\t    if (i + 1 >= UTFlen || (buf[i+1] & 0xC0) != 0x80)\n-\t      throw new UTFDataFormatException();\n \n-\t    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |\n-\t\t\t\t  (buf[i++] & 0x3F)));\n-\t  }\n-\telse if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n-\t  {\n-\t    if (i + 2 >= UTFlen ||\n-\t\t(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)\n-\t      throw new UTFDataFormatException();\n-\n-\t    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |\n-\t\t\t\t  ((buf[i++] & 0x3F) << 6) |\n-\t\t\t\t  (buf[i++] & 0x3F)));\n-\t  }\n-\telse // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)\n-\t  throw new UTFDataFormatException();\t// bit patterns 1111xxxx or\n-\t\t\t\t\t\t// \t\t10xxxxxx\n-      }\n-\n-    return strbuf.toString();\n+    return convertFromUTF(buf);\n   }\n \n   /**\n@@ -733,4 +675,93 @@ public final int skipBytes(int n) throws IOException\n       }         \n     return n;\n   }\n+  \n+  static boolean convertToBoolean(int b) throws EOFException\n+  {\n+    if (b < 0)\n+      throw new EOFException();    \n+    return (b != 0);\n+  }\n+\n+  static byte convertToByte(int i) throws EOFException\n+  {\n+    if (i < 0)\n+      throw new EOFException();\n+    return (byte) i;\n+  }\n+\n+  static int convertToUnsignedByte(int i) throws EOFException\n+  {\n+    if (i < 0)\n+      throw new EOFException();\n+    return (i & 0xFF);\n+  }\n+\n+  static char convertToChar(byte[] buf)\n+  {\n+    return (char) ((buf[0] << 8) | (buf[1] & 0xff));  \n+  }  \n+\n+  static short convertToShort(byte[] buf)\n+  {\n+    return (short) ((buf[0] << 8) | (buf[1] & 0xff));  \n+  }  \n+\n+  static int convertToUnsignedShort(byte[] buf)\n+  {\n+    return (((buf[0] & 0xff) << 8) | (buf[1] & 0xff));  \n+  }\n+\n+  static int convertToInt(byte[] buf)\n+  {\n+    return (((buf[0] & 0xff) << 24) | ((buf[1] & 0xff) << 16) |\n+\t    ((buf[2] & 0xff) << 8) | (buf[3] & 0xff));  \n+  }\n+\n+  static long convertToLong(byte[] buf)\n+  {\n+    return (((long)(buf[0] & 0xff) << 56) |\n+\t    ((long)(buf[1] & 0xff) << 48) |\n+\t    ((long)(buf[2] & 0xff) << 40) |\n+\t    ((long)(buf[3] & 0xff) << 32) |\n+\t    ((long)(buf[4] & 0xff) << 24) |\n+\t    ((long)(buf[5] & 0xff) << 16) |\n+\t    ((long)(buf[6] & 0xff) <<  8) |\n+\t    ((long)(buf[7] & 0xff)));  \n+  }\n+\n+  static String convertFromUTF(byte[] buf) \n+    throws EOFException, UTFDataFormatException\n+  {\n+    StringBuffer strbuf = new StringBuffer();\n+\n+    for (int i = 0; i < buf.length; )\n+      {\n+\tif ((buf[i] & 0x80) == 0)\t\t// bit pattern 0xxxxxxx\n+\t  strbuf.append((char) (buf[i++] & 0xFF));\n+\telse if ((buf[i] & 0xE0) == 0xC0)\t// bit pattern 110xxxxx\n+\t  {\n+\t    if (i + 1 >= buf.length || (buf[i+1] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException();\n+\n+\t    strbuf.append((char) (((buf[i++] & 0x1F) << 6) |\n+\t\t\t\t  (buf[i++] & 0x3F)));\n+\t  }\n+\telse if ((buf[i] & 0xF0) == 0xE0)\t// bit pattern 1110xxxx\n+\t  {\n+\t    if (i + 2 >= buf.length ||\n+\t\t(buf[i+1] & 0xC0) != 0x80 || (buf[i+2] & 0xC0) != 0x80)\n+\t      throw new UTFDataFormatException();\n+\n+\t    strbuf.append((char) (((buf[i++] & 0x0F) << 12) |\n+\t\t\t\t  ((buf[i++] & 0x3F) << 6) |\n+\t\t\t\t  (buf[i++] & 0x3F)));\n+\t  }\n+\telse // must be ((buf[i] & 0xF0) == 0xF0 || (buf[i] & 0xC0) == 0x80)\n+\t  throw new UTFDataFormatException();\t// bit patterns 1111xxxx or\n+\t\t\t\t\t\t// \t\t10xxxxxx\n+      }\n+\n+    return strbuf.toString();\n+  }\n }"}]}