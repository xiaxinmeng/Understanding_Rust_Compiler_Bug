{"sha": "a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTI4NTFiNzVjYzE3ODg5ZWFiYTA3YjAwNjNkZDdjZDFjMWU3ZmNmYQ==", "commit": {"author": {"name": "Tristan Gingold", "email": "gingold@adacore.com", "date": "2012-06-25T08:25:43Z"}, "committer": {"name": "Tristan Gingold", "email": "gingold@gcc.gnu.org", "date": "2012-06-25T08:25:43Z"}, "message": "winnt.c (i386_pe_seh_end_prologue): Move code to ...\n\n2012-06-25  Tristan Gingold  <gingold@adacore.com>\n\n\t* config/i386/winnt.c (i386_pe_seh_end_prologue): Move code to ...\n\t(seh_cfa_adjust_cfa): ... that function.\n\t(seh_emit_stackalloc): Do not emit out of range values.\n\t* config/i386/i386.md: Delete unused UNSPEC_REG_SAVE,\n\tUNSPEC_DEF_CFA constants.\n\t* config/i386/i386.h (SEH_MAX_FRAME_SIZE): Define.\n\t* config/i386/i386.c (ix86_frame_pointer_required): Required\n\tfor very large frames on SEH target.\n\t(ix86_compute_frame_layout): Save area is before frame pointer\n\ton SEH target.  Handle very large frames.\n\t(ix86_expand_prologue): Likewise.\n\nFrom-SVN: r188928", "tree": {"sha": "3b9eb13086b15baf1c0123d9959f48428c51189d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b9eb13086b15baf1c0123d9959f48428c51189d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/comments", "author": {"login": "gingold-adacore", "id": 16334725, "node_id": "MDQ6VXNlcjE2MzM0NzI1", "avatar_url": "https://avatars.githubusercontent.com/u/16334725?v=4", "gravatar_id": "", "url": "https://api.github.com/users/gingold-adacore", "html_url": "https://github.com/gingold-adacore", "followers_url": "https://api.github.com/users/gingold-adacore/followers", "following_url": "https://api.github.com/users/gingold-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/gingold-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/gingold-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/gingold-adacore/subscriptions", "organizations_url": "https://api.github.com/users/gingold-adacore/orgs", "repos_url": "https://api.github.com/users/gingold-adacore/repos", "events_url": "https://api.github.com/users/gingold-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/gingold-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4679c9b307c7e0fddfc9d463d448c48742decdf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4679c9b307c7e0fddfc9d463d448c48742decdf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4679c9b307c7e0fddfc9d463d448c48742decdf8"}], "stats": {"total": 126, "additions": 100, "deletions": 26}, "files": [{"sha": "fb64279ac68260c79ae665d41e00abf66b95e965", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "patch": "@@ -1,3 +1,17 @@\n+2012-06-25  Tristan Gingold  <gingold@adacore.com>\n+\n+\t* config/i386/winnt.c (i386_pe_seh_end_prologue): Move code to ...\n+\t(seh_cfa_adjust_cfa): ... that function.\n+\t(seh_emit_stackalloc): Do not emit out of range values.\n+\t* config/i386/i386.md: Delete unused UNSPEC_REG_SAVE,\n+\tUNSPEC_DEF_CFA constants.\n+\t* config/i386/i386.h (SEH_MAX_FRAME_SIZE): Define.\n+\t* config/i386/i386.c (ix86_frame_pointer_required): Required\n+\tfor very large frames on SEH target.\n+\t(ix86_compute_frame_layout): Save area is before frame pointer\n+\ton SEH target.  Handle very large frames.\n+\t(ix86_expand_prologue): Likewise.\n+\n 2012-06-24  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* output.h: (current_function_is_leaf,"}, {"sha": "7e2352d0fc6d71b612caab1b06deeb65d7bd7a1e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 59, "deletions": 7, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "patch": "@@ -8558,6 +8558,11 @@ ix86_frame_pointer_required (void)\n   if (TARGET_32BIT_MS_ABI && cfun->calls_setjmp)\n     return true;\n \n+  /* Win64 SEH, very large frames need a frame-pointer as maximum stack\n+     allocation is 4GB.  */\n+  if (TARGET_64BIT_MS_ABI && get_frame_size () > SEH_MAX_FRAME_SIZE)\n+    return true;\n+\n   /* In ix86_option_override_internal, TARGET_OMIT_LEAF_FRAME_POINTER\n      turns off the frame pointer by default.  Turn it back on now if\n      we've not got a leaf function.  */\n@@ -9051,6 +9056,11 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n   offset += frame->nregs * UNITS_PER_WORD;\n   frame->reg_save_offset = offset;\n \n+  /* On SEH target, registers are pushed just before the frame pointer\n+     location.  */\n+  if (TARGET_SEH)\n+    frame->hard_frame_pointer_offset = offset;\n+\n   /* Align and set SSE register save area.  */\n   if (frame->nsseregs)\n     {\n@@ -9142,9 +9152,12 @@ ix86_compute_frame_layout (struct ix86_frame *frame)\n     {\n       HOST_WIDE_INT diff;\n \n-      /* If we can leave the frame pointer where it is, do so.  */\n+      /* If we can leave the frame pointer where it is, do so.  Also, returns\n+\t the establisher frame for __builtin_frame_address (0).  */\n       diff = frame->stack_pointer_offset - frame->hard_frame_pointer_offset;\n-      if (diff > 240 || (diff & 15) != 0)\n+      if (diff <= SEH_MAX_FRAME_SIZE\n+\t  && (diff > 240 || (diff & 15) != 0)\n+\t  && !crtl->accesses_prior_frames)\n \t{\n \t  /* Ideally we'd determine what portion of the local stack frame\n \t     (within the constraint of the lowest 240) is most heavily used.\n@@ -10146,6 +10159,7 @@ ix86_expand_prologue (void)\n   struct ix86_frame frame;\n   HOST_WIDE_INT allocate;\n   bool int_registers_saved;\n+  bool sse_registers_saved;\n \n   ix86_finalize_stack_realign_flags ();\n \n@@ -10298,13 +10312,27 @@ ix86_expand_prologue (void)\n       m->fs.realigned = true;\n     }\n \n+  int_registers_saved = (frame.nregs == 0);\n+  sse_registers_saved = (frame.nsseregs == 0);\n+\n   if (frame_pointer_needed && !m->fs.fp_valid)\n     {\n       /* Note: AT&T enter does NOT have reversed args.  Enter is probably\n          slower on all targets.  Also sdb doesn't like it.  */\n       insn = emit_insn (gen_push (hard_frame_pointer_rtx));\n       RTX_FRAME_RELATED_P (insn) = 1;\n \n+      /* Push registers now, before setting the frame pointer\n+\t on SEH target.  */\n+      if (!int_registers_saved\n+\t  && TARGET_SEH\n+\t  && !frame.save_regs_using_mov)\n+\t{\n+\t  ix86_emit_save_regs ();\n+\t  int_registers_saved = true;\n+\t  gcc_assert (m->fs.sp_offset == frame.reg_save_offset);\n+\t}\n+\n       if (m->fs.sp_offset == frame.hard_frame_pointer_offset)\n \t{\n \t  insn = emit_move_insn (hard_frame_pointer_rtx, stack_pointer_rtx);\n@@ -10317,8 +10345,6 @@ ix86_expand_prologue (void)\n \t}\n     }\n \n-  int_registers_saved = (frame.nregs == 0);\n-\n   if (!int_registers_saved)\n     {\n       /* If saving registers via PUSH, do so now.  */\n@@ -10395,6 +10421,27 @@ ix86_expand_prologue (void)\n       current_function_static_stack_size = stack_size;\n     }\n \n+  /* On SEH target with very large frame size, allocate an area to save\n+     SSE registers (as the very large allocation won't be described).  */\n+  if (TARGET_SEH\n+      && frame.stack_pointer_offset > SEH_MAX_FRAME_SIZE\n+      && !sse_registers_saved)\n+    {\n+      HOST_WIDE_INT sse_size =\n+\tframe.sse_reg_save_offset - frame.reg_save_offset;\n+\n+      gcc_assert (int_registers_saved);\n+\n+      /* No need to do stack checking as the area will be immediately\n+\t written.  */\n+      pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n+\t\t\t         GEN_INT (-sse_size), -1,\n+\t\t\t\t m->fs.cfa_reg == stack_pointer_rtx);\n+      allocate -= sse_size;\n+      ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n+      sse_registers_saved = true;\n+    }\n+\n   /* The stack has already been decremented by the instruction calling us\n      so probe if the size is non-negative to preserve the protection area.  */\n   if (allocate >= 0 && flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n@@ -10519,7 +10566,7 @@ ix86_expand_prologue (void)\n \n   if (!int_registers_saved)\n     ix86_emit_save_regs_using_mov (frame.reg_save_offset);\n-  if (frame.nsseregs)\n+  if (!sse_registers_saved)\n     ix86_emit_save_sse_regs_using_mov (frame.sse_reg_save_offset);\n \n   pic_reg_used = false;\n@@ -10975,8 +11022,13 @@ ix86_expand_epilogue (int style)\n \t}\n \n       /* First step is to deallocate the stack frame so that we can\n-\t pop the registers.  */\n-      if (!m->fs.sp_valid)\n+\t pop the registers.  Also do it on SEH target for very large\n+\t frame as the emitted instructions aren't allowed by the ABI in\n+\t epilogues.  */\n+      if (!m->fs.sp_valid\n+ \t  || (TARGET_SEH\n+\t      && (m->fs.sp_offset - frame.reg_save_offset\n+\t\t  >= SEH_MAX_FRAME_SIZE)))\n \t{\n \t  pro_epilogue_adjust_stack (stack_pointer_rtx, hard_frame_pointer_rtx,\n \t\t\t\t     GEN_INT (m->fs.fp_offset"}, {"sha": "18633faa90aacf7cc842f69e998e7b3d0f62e900", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "patch": "@@ -729,6 +729,18 @@ enum target_cpu_default\n /* Boundary (in *bits*) on which the incoming stack is aligned.  */\n #define INCOMING_STACK_BOUNDARY ix86_incoming_stack_boundary\n \n+/* According to Windows x64 software convention, the maximum stack allocatable\n+   in the prologue is 4G - 8 bytes.  Furthermore, there is a limited set of\n+   instructions allowed to adjust the stack pointer in the epilog, forcing the\n+   use of frame pointer for frames larger than 2 GB.  This theorical limit\n+   is reduced by 256, an over-estimated upper bound for the stack use by the\n+   prologue.\n+   We define only one threshold for both the prolog and the epilog.  When the\n+   frame size is larger than this threshold, we allocate the are to save SSE\n+   regs, then save them, and then allocate the remaining.  There is no SEH\n+   unwind info for this later allocation.  */\n+#define SEH_MAX_FRAME_SIZE ((2U << 30) - 256)\n+\n /* Target OS keeps a vector-aligned (128-bit, 16-byte) stack.  This is\n    mandatory for the 64-bit ABI, and may or may not be true for other\n    operating systems.  */"}, {"sha": "727ec2b1723a513b3f698331b9864d123c057fc1", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "patch": "@@ -84,8 +84,6 @@\n   ;; Prologue support\n   UNSPEC_STACK_ALLOC\n   UNSPEC_SET_GOT\n-  UNSPEC_REG_SAVE\n-  UNSPEC_DEF_CFA\n   UNSPEC_SET_RIP\n   UNSPEC_SET_GOT_OFFSET\n   UNSPEC_MEMORY_BLOCKAGE"}, {"sha": "10cdee8002235344cd3e94573ad598192f60b211", "filename": "gcc/config/i386/winnt.c", "status": "modified", "additions": 15, "deletions": 17, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fwinnt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa/gcc%2Fconfig%2Fi386%2Fwinnt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fwinnt.c?ref=a2851b75cc17889eaba07b0063dd7cd1c1e7fcfa", "patch": "@@ -829,22 +829,6 @@ i386_pe_seh_end_prologue (FILE *f)\n     return;\n   seh = cfun->machine->seh;\n \n-  /* Emit an assembler directive to set up the frame pointer.  Always do\n-     this last.  The documentation talks about doing this \"before\" any\n-     other code that uses offsets, but (experimentally) that's after we\n-     emit the codes in reverse order (handled by the assembler).  */\n-  if (seh->cfa_reg != stack_pointer_rtx)\n-    {\n-      HOST_WIDE_INT offset = seh->sp_offset - seh->cfa_offset;\n-\n-      gcc_assert ((offset & 15) == 0);\n-      gcc_assert (IN_RANGE (offset, 0, 240));\n-\n-      fputs (\"\\t.seh_setframe\\t\", f);\n-      print_reg (seh->cfa_reg, 0, f);\n-      fprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n-    }\n-\n   XDELETE (seh);\n   cfun->machine->seh = NULL;\n \n@@ -915,7 +899,10 @@ seh_emit_stackalloc (FILE *f, struct seh_frame_state *seh,\n     seh->cfa_offset += offset;\n   seh->sp_offset += offset;\n \n-  fprintf (f, \"\\t.seh_stackalloc\\t\" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n+  /* Do not output the stackalloc in that case (it won't work as there is no\n+     encoding for very large frame size).  */\n+  if (offset < SEH_MAX_FRAME_SIZE)\n+    fprintf (f, \"\\t.seh_stackalloc\\t\" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n }\n \n /* Process REG_CFA_ADJUST_CFA for SEH.  */\n@@ -948,8 +935,19 @@ seh_cfa_adjust_cfa (FILE *f, struct seh_frame_state *seh, rtx pat)\n     seh_emit_stackalloc (f, seh, reg_offset);\n   else if (dest_regno == HARD_FRAME_POINTER_REGNUM)\n     {\n+      HOST_WIDE_INT offset;\n+\n       seh->cfa_reg = dest;\n       seh->cfa_offset -= reg_offset;\n+\n+      offset = seh->sp_offset - seh->cfa_offset;\n+\n+      gcc_assert ((offset & 15) == 0);\n+      gcc_assert (IN_RANGE (offset, 0, 240));\n+\n+      fputs (\"\\t.seh_setframe\\t\", f);\n+      print_reg (seh->cfa_reg, 0, f);\n+      fprintf (f, \", \" HOST_WIDE_INT_PRINT_DEC \"\\n\", offset);\n     }\n   else\n     gcc_unreachable ();"}]}