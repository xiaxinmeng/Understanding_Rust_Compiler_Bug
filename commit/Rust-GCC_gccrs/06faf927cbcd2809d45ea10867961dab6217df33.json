{"sha": "06faf927cbcd2809d45ea10867961dab6217df33", "node_id": "C_kwDOANBUbNoAKDA2ZmFmOTI3Y2JjZDI4MDlkNDVlYTEwODY3OTYxZGFiNjIxN2RmMzM", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2021-11-29T12:25:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-01-05T11:32:34Z"}, "message": "[Ada] Deconstruct dead wrappers added for external axiomatization\n\ngcc/ada/\n\n\t* sem_ch12.ads (Build_Function_Wrapper, Build_Operator_Wrapper):\n\tRemove unreferenced spec.\n\t* sem_ch12.adb (Build_Function_Wrapper, Build_Operator_Wrapper):\n\tRemove dead bodies.", "tree": {"sha": "907e405db901eb396d16820cad49fe6434934f5c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/907e405db901eb396d16820cad49fe6434934f5c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/06faf927cbcd2809d45ea10867961dab6217df33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06faf927cbcd2809d45ea10867961dab6217df33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/06faf927cbcd2809d45ea10867961dab6217df33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/06faf927cbcd2809d45ea10867961dab6217df33/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a056c2788630270b37066a1ac76d1e64ac6e194", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a056c2788630270b37066a1ac76d1e64ac6e194", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a056c2788630270b37066a1ac76d1e64ac6e194"}], "stats": {"total": 222, "additions": 0, "deletions": 222}, "files": [{"sha": "ec6b5928470e2452c762cc91ac5792f73206e748", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06faf927cbcd2809d45ea10867961dab6217df33/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06faf927cbcd2809d45ea10867961dab6217df33/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=06faf927cbcd2809d45ea10867961dab6217df33", "patch": "@@ -6080,211 +6080,6 @@ package body Sem_Ch12 is\n       end if;\n    end Get_Associated_Node;\n \n-   ----------------------------\n-   -- Build_Function_Wrapper --\n-   ----------------------------\n-\n-   function Build_Function_Wrapper\n-     (Formal_Subp : Entity_Id;\n-      Actual_Subp : Entity_Id) return Node_Id\n-   is\n-      Loc       : constant Source_Ptr := Sloc (Current_Scope);\n-      Ret_Type  : constant Entity_Id  := Get_Instance_Of (Etype (Formal_Subp));\n-      Actuals   : List_Id;\n-      Decl      : Node_Id;\n-      Func_Name : Node_Id;\n-      Func      : Entity_Id;\n-      Parm_Type : Node_Id;\n-      Profile   : List_Id := New_List;\n-      Spec      : Node_Id;\n-      Act_F     : Entity_Id;\n-      Form_F    : Entity_Id;\n-      New_F     : Entity_Id;\n-\n-   begin\n-      Func_Name := New_Occurrence_Of (Actual_Subp, Loc);\n-\n-      Func := Make_Defining_Identifier (Loc, Chars (Formal_Subp));\n-      Mutate_Ekind (Func, E_Function);\n-      Set_Is_Generic_Actual_Subprogram (Func);\n-\n-      Actuals := New_List;\n-      Profile := New_List;\n-\n-      Act_F  := First_Formal (Actual_Subp);\n-      Form_F := First_Formal (Formal_Subp);\n-      while Present (Form_F) loop\n-\n-         --  Create new formal for profile of wrapper, and add a reference\n-         --  to it in the list of actuals for the enclosing call. The name\n-         --  must be that of the formal in the formal subprogram, because\n-         --  calls to it in the generic body may use named associations.\n-\n-         New_F := Make_Defining_Identifier (Loc, Chars (Form_F));\n-\n-         Parm_Type :=\n-           New_Occurrence_Of (Get_Instance_Of (Etype (Form_F)), Loc);\n-\n-         Append_To (Profile,\n-           Make_Parameter_Specification (Loc,\n-             Defining_Identifier => New_F,\n-             Parameter_Type      => Parm_Type));\n-\n-         Append_To (Actuals, New_Occurrence_Of (New_F, Loc));\n-         Next_Formal (Form_F);\n-\n-         if Present (Act_F) then\n-            Next_Formal (Act_F);\n-         end if;\n-      end loop;\n-\n-      Spec :=\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => Func,\n-          Parameter_Specifications => Profile,\n-          Result_Definition        => New_Occurrence_Of (Ret_Type, Loc));\n-\n-      Decl :=\n-        Make_Expression_Function (Loc,\n-          Specification => Spec,\n-          Expression    =>\n-            Make_Function_Call (Loc,\n-              Name                   => Func_Name,\n-              Parameter_Associations => Actuals));\n-\n-      return Decl;\n-   end Build_Function_Wrapper;\n-\n-   ----------------------------\n-   -- Build_Operator_Wrapper --\n-   ----------------------------\n-\n-   function Build_Operator_Wrapper\n-     (Formal_Subp : Entity_Id;\n-      Actual_Subp : Entity_Id) return Node_Id\n-   is\n-      Loc       : constant Source_Ptr := Sloc (Current_Scope);\n-      Ret_Type  : constant Entity_Id  :=\n-                    Get_Instance_Of (Etype (Formal_Subp));\n-      Op_Type   : constant Entity_Id  :=\n-                    Get_Instance_Of (Etype (First_Formal (Formal_Subp)));\n-      Is_Binary : constant Boolean    :=\n-                    Present (Next_Formal (First_Formal (Formal_Subp)));\n-\n-      Decl    : Node_Id;\n-      Expr    : Node_Id := Empty;\n-      F1, F2  : Entity_Id;\n-      Func    : Entity_Id;\n-      Op_Name : Name_Id;\n-      Spec    : Node_Id;\n-      L, R    : Node_Id;\n-\n-   begin\n-      Op_Name := Chars (Actual_Subp);\n-\n-      --  Create entities for wrapper function and its formals\n-\n-      F1 := Make_Temporary (Loc, 'A');\n-      F2 := Make_Temporary (Loc, 'B');\n-      L  := New_Occurrence_Of (F1, Loc);\n-      R  := New_Occurrence_Of (F2, Loc);\n-\n-      Func := Make_Defining_Identifier (Loc, Chars (Formal_Subp));\n-      Mutate_Ekind (Func, E_Function);\n-      Set_Is_Generic_Actual_Subprogram (Func);\n-\n-      Spec :=\n-        Make_Function_Specification (Loc,\n-          Defining_Unit_Name       => Func,\n-          Parameter_Specifications => New_List (\n-            Make_Parameter_Specification (Loc,\n-               Defining_Identifier => F1,\n-               Parameter_Type      => New_Occurrence_Of (Op_Type, Loc))),\n-          Result_Definition        => New_Occurrence_Of (Ret_Type, Loc));\n-\n-      if Is_Binary then\n-         Append_To (Parameter_Specifications (Spec),\n-            Make_Parameter_Specification (Loc,\n-              Defining_Identifier => F2,\n-              Parameter_Type      => New_Occurrence_Of (Op_Type, Loc)));\n-      end if;\n-\n-      --  Build expression as a function call, or as an operator node\n-      --  that corresponds to the name of the actual, starting with\n-      --  binary operators.\n-\n-      if Op_Name not in Any_Operator_Name then\n-         Expr :=\n-           Make_Function_Call (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (Actual_Subp, Loc),\n-             Parameter_Associations => New_List (L));\n-\n-         if Is_Binary then\n-            Append_To (Parameter_Associations (Expr), R);\n-         end if;\n-\n-      --  Binary operators\n-\n-      elsif Is_Binary then\n-         if Op_Name = Name_Op_And then\n-            Expr := Make_Op_And      (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Or then\n-            Expr := Make_Op_Or       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Xor then\n-            Expr := Make_Op_Xor      (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Eq then\n-            Expr := Make_Op_Eq       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Ne then\n-            Expr := Make_Op_Ne       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Le then\n-            Expr := Make_Op_Le       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Gt then\n-            Expr := Make_Op_Gt       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Ge then\n-            Expr := Make_Op_Ge       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Lt then\n-            Expr := Make_Op_Lt       (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Add then\n-            Expr := Make_Op_Add      (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Subtract then\n-            Expr := Make_Op_Subtract (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Concat then\n-            Expr := Make_Op_Concat   (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Multiply then\n-            Expr := Make_Op_Multiply (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Divide then\n-            Expr := Make_Op_Divide   (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Mod then\n-            Expr := Make_Op_Mod      (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Rem then\n-            Expr := Make_Op_Rem      (Loc, Left_Opnd => L, Right_Opnd => R);\n-         elsif Op_Name = Name_Op_Expon then\n-            Expr := Make_Op_Expon    (Loc, Left_Opnd => L, Right_Opnd => R);\n-         end if;\n-\n-      --  Unary operators\n-\n-      else\n-         if Op_Name = Name_Op_Add then\n-            Expr := Make_Op_Plus  (Loc, Right_Opnd => L);\n-         elsif Op_Name = Name_Op_Subtract then\n-            Expr := Make_Op_Minus (Loc, Right_Opnd => L);\n-         elsif Op_Name = Name_Op_Abs then\n-            Expr := Make_Op_Abs   (Loc, Right_Opnd => L);\n-         elsif Op_Name = Name_Op_Not then\n-            Expr := Make_Op_Not   (Loc, Right_Opnd => L);\n-         end if;\n-      end if;\n-\n-      Decl :=\n-        Make_Expression_Function (Loc,\n-          Specification => Spec,\n-          Expression    => Expr);\n-\n-      return Decl;\n-   end Build_Operator_Wrapper;\n-\n    -----------------------------------\n    -- Build_Subprogram_Decl_Wrapper --\n    -----------------------------------"}, {"sha": "d12ea612f63b55f9378fc98d795ac61a1bf99b9e", "filename": "gcc/ada/sem_ch12.ads", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/06faf927cbcd2809d45ea10867961dab6217df33/gcc%2Fada%2Fsem_ch12.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/06faf927cbcd2809d45ea10867961dab6217df33/gcc%2Fada%2Fsem_ch12.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.ads?ref=06faf927cbcd2809d45ea10867961dab6217df33", "patch": "@@ -37,23 +37,6 @@ package Sem_Ch12 is\n    procedure Analyze_Formal_Subprogram_Declaration      (N : Node_Id);\n    procedure Analyze_Formal_Package_Declaration         (N : Node_Id);\n \n-   function Build_Function_Wrapper\n-     (Formal_Subp : Entity_Id;\n-      Actual_Subp : Entity_Id) return Node_Id;\n-   --  In GNATprove mode, create a wrapper function for actuals that are\n-   --  functions with any number of formal parameters, in order to propagate\n-   --  their contract to the renaming declarations generated for them. This\n-   --  is called after the renaming declaration created for the formal in the\n-   --  instance has been analyzed, and the actual is known.\n-\n-   function Build_Operator_Wrapper\n-     (Formal_Subp : Entity_Id;\n-      Actual_Subp : Entity_Id) return Node_Id;\n-   --  In GNATprove mode, create a wrapper function for actuals that are\n-   --  operators, in order to propagate their contract to the renaming\n-   --  declarations generated for them. The types are (the instances of)\n-   --  the types of the formal subprogram.\n-\n    procedure Start_Generic;\n    --  Must be invoked before starting to process a generic spec or body\n "}]}