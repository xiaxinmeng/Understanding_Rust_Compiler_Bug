{"sha": "2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQ0NGM3ZGVhN2M4ZDI5MTdlZWMyOGE1ZTA4ZThmNDA1YWFkOGMzZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2015-05-27T12:47:22Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2015-05-27T12:47:22Z"}, "message": "New memory allocation statistics infrastructure.\n\n\t* Makefile.in: Add additional dependencies related to memory report\n\tenhancement.\n\t* alloc-pool.c (allocate_pool_descriptor): Use new ctor.\n\t* bitmap.c (struct bitmap_descriptor_d): Remove.\n\t(struct loc): Likewise.\n\t(struct bitmap_desc_hasher): Likewise.\n\t(bitmap_desc_hasher::hash): Likewise.\n\t(bitmap_desc_hasher::equal): Likewise.\n\t(get_bitmap_descriptor): Likewise.\n\t(bitmap_register): User new memory descriptor API.\n\t(register_overhead): Likewise.\n\t(bitmap_find_bit): Register nsearches and search_iter statistics.\n\t(struct bitmap_output_info): Remove.\n\t(print_statistics): Likewise.\n\t(dump_bitmap_statistics): Use new memory descriptor.\n\t* bitmap.h (struct bitmap_usage): New class.\n\t* genmatch.c: Extend header file inclusion.\n\t* genpreds.c: Likewise.\n\t* ggc-common.c (struct ggc_usage): New class.\n\t(struct ggc_loc_desc_hasher): Remove.\n\t(ggc_loc_desc_hasher::hash): Likewise.\n\t(ggc_loc_desc_hasher::equal): Likewise.\n\t(struct ggc_ptr_hash_entry): Likewise.\n\t(struct ptr_hash_hasher): Likewise.\n\t(ptr_hash_hasher::hash): Likewise.\n\t(ptr_hash_hasher::equal): Likewise.\n\t(make_loc_descriptor): Likewise.\n\t(ggc_prune_ptr): Likewise.\n\t(dump_ggc_loc_statistics): Use new memory descriptor.\n\t(ggc_record_overhead): Likewise.\n\t(ggc_free_overhead): Likewise.\n\t(final_cmp_statistic): Remove.\n\t(cmp_statistic): Likewise.\n\t(ggc_add_statistics): Liekwise.\n\t(ggc_prune_overhead_list): Likewise.\n\t* hash-map-traits.h: New file.\n\t* hash-map.h (struct default_hashmap_traits): Move the traits to a\n\tseparate header file.\n\t* hash-set.h: Pass memory statistics info to ctor.\n\t* hash-table.c (void dump_hash_table_loc_statistics): New function.\n\t* hash-table.h (hash_table::hash_table): Add new ctor arguments.\n\t(hash_table::~hash_table): Register memory release operation.\n\t(hash_table::alloc_entries): Handle memory allocation operation.\n\t(hash_table::expand): Likewise.\n\t* inchash.c (iterative_hash_hashval_t): Move implementation to header\n\tfile.\n\t(iterative_hash_host_wide_int): Likewise.\n\t* inchash.h (class hash): Likewise.\n\t* mem-stats-traits.h: New file.\n\t* mem-stats.h: New file.\n\t(mem_location): Add new class.\n\t(mem_usage): Likewise.\n\t(mem_alloc_description): Likewise.\n\t* sese.c: Add new header file inclusision.\n\t* toplev.c (dump_memory_report): Add report for hash_table, hash_map\n\tand hash_set.\n\t* tree-sra.c: Add new header file inclusision.\n\t* vec.c (struct vec_descriptor): Remove.\n\t(hash_descriptor): Likewise.\n\t(struct vec_usage): Likewise.\n\t(struct ptr_hash_entry): Likewise.\n\t(hash_ptr): Likewise.\n\t(eq_ptr): Likewise.\n\t(vec_prefix::register_overhead): Use new memory descriptor API.\n\t(vec_prefix::release_overhead): Likewise.\n\t(add_statistics): Remove.\n\t(dump_vec_loc_statistics): Use new memory descriptor API.\n\t* vec.h (struct vec_prefix): Likewise.\n\t(va_heap::reserve): Likewise.\n\t(va_heap::release): Likewise.\n\t* emit-rtl.c (gen_raw_REG): Fix passing MEM_STAT.\n\nFrom-SVN: r223748", "tree": {"sha": "4505b8171553fd7e780bb28532a4986cd72b6f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4505b8171553fd7e780bb28532a4986cd72b6f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "151fbaac5c78c4e9b749fc9e916f78b0ba63b153", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/151fbaac5c78c4e9b749fc9e916f78b0ba63b153", "html_url": "https://github.com/Rust-GCC/gccrs/commit/151fbaac5c78c4e9b749fc9e916f78b0ba63b153"}], "stats": {"total": 1951, "additions": 1215, "deletions": 736}, "files": [{"sha": "fa6ce5cd08b4941f1371dde94701704094f3db3e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -1,3 +1,77 @@\n+2015-05-27  Martin Liska  <mliska@suse.cz>\n+\n+\t* Makefile.in: Add additional dependencies related to memory report\n+\tenhancement.\n+\t* alloc-pool.c (allocate_pool_descriptor): Use new ctor.\n+\t* bitmap.c (struct bitmap_descriptor_d): Remove.\n+\t(struct loc): Likewise.\n+\t(struct bitmap_desc_hasher): Likewise.\n+\t(bitmap_desc_hasher::hash): Likewise.\n+\t(bitmap_desc_hasher::equal): Likewise.\n+\t(get_bitmap_descriptor): Likewise.\n+\t(bitmap_register): User new memory descriptor API.\n+\t(register_overhead): Likewise.\n+\t(bitmap_find_bit): Register nsearches and search_iter statistics.\n+\t(struct bitmap_output_info): Remove.\n+\t(print_statistics): Likewise.\n+\t(dump_bitmap_statistics): Use new memory descriptor.\n+\t* bitmap.h (struct bitmap_usage): New class.\n+\t* genmatch.c: Extend header file inclusion.\n+\t* genpreds.c: Likewise.\n+\t* ggc-common.c (struct ggc_usage): New class.\n+\t(struct ggc_loc_desc_hasher): Remove.\n+\t(ggc_loc_desc_hasher::hash): Likewise.\n+\t(ggc_loc_desc_hasher::equal): Likewise.\n+\t(struct ggc_ptr_hash_entry): Likewise.\n+\t(struct ptr_hash_hasher): Likewise.\n+\t(ptr_hash_hasher::hash): Likewise.\n+\t(ptr_hash_hasher::equal): Likewise.\n+\t(make_loc_descriptor): Likewise.\n+\t(ggc_prune_ptr): Likewise.\n+\t(dump_ggc_loc_statistics): Use new memory descriptor.\n+\t(ggc_record_overhead): Likewise.\n+\t(ggc_free_overhead): Likewise.\n+\t(final_cmp_statistic): Remove.\n+\t(cmp_statistic): Likewise.\n+\t(ggc_add_statistics): Liekwise.\n+\t(ggc_prune_overhead_list): Likewise.\n+\t* hash-map-traits.h: New file.\n+\t* hash-map.h (struct default_hashmap_traits): Move the traits to a\n+\tseparate header file.\n+\t* hash-set.h: Pass memory statistics info to ctor.\n+\t* hash-table.c (void dump_hash_table_loc_statistics): New function.\n+\t* hash-table.h (hash_table::hash_table): Add new ctor arguments.\n+\t(hash_table::~hash_table): Register memory release operation.\n+\t(hash_table::alloc_entries): Handle memory allocation operation.\n+\t(hash_table::expand): Likewise.\n+\t* inchash.c (iterative_hash_hashval_t): Move implementation to header\n+\tfile.\n+\t(iterative_hash_host_wide_int): Likewise.\n+\t* inchash.h (class hash): Likewise.\n+\t* mem-stats-traits.h: New file.\n+\t* mem-stats.h: New file.\n+\t(mem_location): Add new class.\n+\t(mem_usage): Likewise.\n+\t(mem_alloc_description): Likewise.\n+\t* sese.c: Add new header file inclusision.\n+\t* toplev.c (dump_memory_report): Add report for hash_table, hash_map\n+\tand hash_set.\n+\t* tree-sra.c: Add new header file inclusision.\n+\t* vec.c (struct vec_descriptor): Remove.\n+\t(hash_descriptor): Likewise.\n+\t(struct vec_usage): Likewise.\n+\t(struct ptr_hash_entry): Likewise.\n+\t(hash_ptr): Likewise.\n+\t(eq_ptr): Likewise.\n+\t(vec_prefix::register_overhead): Use new memory descriptor API.\n+\t(vec_prefix::release_overhead): Likewise.\n+\t(add_statistics): Remove.\n+\t(dump_vec_loc_statistics): Use new memory descriptor API.\n+\t* vec.h (struct vec_prefix): Likewise.\n+\t(va_heap::reserve): Likewise.\n+\t(va_heap::release): Likewise.\n+\t* emit-rtl.c (gen_raw_REG): Fix passing MEM_STAT.\n+\n 2015-05-27  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-stmts.c (vectorizable_load): Initialize slp_perm"}, {"sha": "03c2ac6a62ee15102b8c6ea24d3bf940d1fdc85d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -1028,7 +1028,7 @@ BUILD_LIBS = $(BUILD_LIBIBERTY)\n \n BUILD_RTL = build/rtl.o build/read-rtl.o build/ggc-none.o \\\n \t    build/vec.o build/min-insn-modes.o build/gensupport.o \\\n-\t    build/print-rtl.o\n+\t    build/print-rtl.o build/hash-table.o\n BUILD_MD = build/read-md.o\n BUILD_ERRORS = build/errors.o\n \n@@ -1501,7 +1501,7 @@ OBJS = \\\n # Objects in libcommon.a, potentially used by all host binaries and with\n # no target dependencies.\n OBJS-libcommon = diagnostic.o diagnostic-color.o pretty-print.o intl.o \\\n-\tvec.o  input.o version.o\n+\tvec.o input.o version.o hash-table.o ggc-none.o\n \n # Objects in libcommon-target.a, used by drivers and by the core\n # compiler and containing target-dependent code.\n@@ -1937,7 +1937,7 @@ gcc-nm.c: gcc-ar.c\n \tcp $^ $@\n \n COLLECT2_OBJS = collect2.o collect2-aix.o tlink.o vec.o ggc-none.o \\\n-  collect-utils.o file-find.o\n+  collect-utils.o file-find.o hash-table.o\n COLLECT2_LIBS = @COLLECT2_LIBS@\n collect2$(exeext): $(COLLECT2_OBJS) $(LIBDEPS)\n # Don't try modifying collect2 (aka ld) in place--it might be linking this.\n@@ -2651,10 +2651,12 @@ s-iov: build/gcov-iov$(build_exeext) $(BASEVER) $(DEVPHASE)\n \n GCOV_OBJS = gcov.o\n gcov$(exeext): $(GCOV_OBJS) $(LIBDEPS)\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) $(LIBS) -o $@\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_OBJS) \\\n+\t\tbuild/hash-table.o ggc-none.o $(LIBS) -o $@\n GCOV_DUMP_OBJS = gcov-dump.o\n gcov-dump$(exeext): $(GCOV_DUMP_OBJS) $(LIBDEPS)\n \t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) $(GCOV_DUMP_OBJS) \\\n+\t\tbuild/hash-table.o build/ggc-none.o\\\n \t\t$(LIBS) -o $@\n \n GCOV_TOOL_DEP_FILES = $(srcdir)/../libgcc/libgcov-util.c gcov-io.c $(GCOV_IO_H) \\"}, {"sha": "e34acdb3500edfd623677dbffcae4fb8f0d5be13", "filename": "gcc/alloc-pool.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Falloc-pool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Falloc-pool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Falloc-pool.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -91,7 +91,9 @@ static struct alloc_pool_descriptor *\n allocate_pool_descriptor (const char *name)\n {\n   if (!alloc_pool_hash)\n-    alloc_pool_hash = new hash_map<const char *, alloc_pool_descriptor> (10);\n+    alloc_pool_hash = new hash_map<const char *, alloc_pool_descriptor> (10,\n+\t\t\t\t\t\t\t\t\t false,\n+\t\t\t\t\t\t\t\t\t false);\n \n   return &alloc_pool_hash->get_or_insert (name);\n }"}, {"sha": "5fc46548beb93ec2580ff35e8604114f864f89a7", "filename": "gcc/bitmap.c", "status": "modified", "additions": 21, "deletions": 157, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -25,112 +25,26 @@ along with GCC; see the file COPYING3.  If not see\n #include \"bitmap.h\"\n #include \"hash-table.h\"\n #include \"vec.h\"\n+#include \"inchash.h\"\n+#include \"mem-stats.h\"\n+#include \"hash-map.h\"\n \n-/* Store information about each particular bitmap, per allocation site.  */\n-struct bitmap_descriptor_d\n-{\n-  int id;\n-  const char *function;\n-  const char *file;\n-  int line;\n-  int created;\n-  uint64_t allocated;\n-  uint64_t peak;\n-  uint64_t current;\n-  uint64_t nsearches;\n-  uint64_t search_iter;\n-};\n-\n-typedef struct bitmap_descriptor_d *bitmap_descriptor;\n-typedef const struct bitmap_descriptor_d *const_bitmap_descriptor;\n-\n-/* Next available unique id number for bitmap desciptors.  */\n-static int next_bitmap_desc_id = 0;\n-\n-/* Vector mapping descriptor ids to descriptors.  */\n-static vec<bitmap_descriptor> bitmap_descriptors;\n-\n-/* Hashtable helpers.  */\n-\n-struct loc\n-{\n-  const char *file;\n-  const char *function;\n-  int line;\n-};\n-\n-struct bitmap_desc_hasher : typed_noop_remove <bitmap_descriptor_d>\n-{\n-  typedef bitmap_descriptor_d *value_type;\n-  typedef loc *compare_type;\n-  static inline hashval_t hash (const bitmap_descriptor_d *);\n-  static inline bool equal (const bitmap_descriptor_d *, const loc *);\n-};\n-\n-inline hashval_t\n-bitmap_desc_hasher::hash (const bitmap_descriptor_d *d)\n-{\n-  return htab_hash_pointer (d->file) + d->line;\n-}\n-\n-inline bool\n-bitmap_desc_hasher::equal (const bitmap_descriptor_d *d, const loc *l)\n-{\n-  return d->file == l->file && d->function == l->function && d->line == l->line;\n-}\n-\n-/* Hashtable mapping bitmap names to descriptors.  */\n-static hash_table<bitmap_desc_hasher> *bitmap_desc_hash;\n-\n-/* For given file and line, return descriptor, create new if needed.  */\n-static bitmap_descriptor\n-get_bitmap_descriptor (const char *file, int line, const char *function)\n-{\n-  bitmap_descriptor_d **slot;\n-  struct loc loc;\n-\n-  loc.file = file;\n-  loc.function = function;\n-  loc.line = line;\n-\n-  if (!bitmap_desc_hash)\n-    bitmap_desc_hash = new hash_table<bitmap_desc_hasher> (10);\n-\n-  slot\n-    = bitmap_desc_hash->find_slot_with_hash (&loc,\n-\t\t\t\t\t     htab_hash_pointer (file) + line,\n-\t\t\t\t\t     INSERT);\n-  if (*slot)\n-    return *slot;\n-\n-  *slot = XCNEW (struct bitmap_descriptor_d);\n-  bitmap_descriptors.safe_push (*slot);\n-  (*slot)->id = next_bitmap_desc_id++;\n-  (*slot)->file = file;\n-  (*slot)->function = function;\n-  (*slot)->line = line;\n-  return *slot;\n-}\n+/* Memory allocation statistics purpose instance.  */\n+mem_alloc_description<bitmap_usage> bitmap_mem_desc;\n \n /* Register new bitmap.  */\n void\n bitmap_register (bitmap b MEM_STAT_DECL)\n {\n-  bitmap_descriptor desc = get_bitmap_descriptor (ALONE_FINAL_PASS_MEM_STAT);\n-  desc->created++;\n-  b->descriptor_id = desc->id;\n+  bitmap_mem_desc.register_descriptor (b, BITMAP, false FINAL_PASS_MEM_STAT);\n }\n \n /* Account the overhead.  */\n static void\n register_overhead (bitmap b, int amount)\n {\n-  bitmap_descriptor desc = bitmap_descriptors[b->descriptor_id];\n-  desc->current += amount;\n-  if (amount > 0)\n-    desc->allocated += amount;\n-  if (desc->peak < desc->current)\n-    desc->peak = desc->current;\n+  if (bitmap_mem_desc.contains_descriptor_for_instance (b))\n+    bitmap_mem_desc.register_instance_overhead (amount, b);\n }\n \n /* Global data */\n@@ -579,10 +493,14 @@ bitmap_find_bit (bitmap head, unsigned int bit)\n       && head->first->next == NULL)\n     return NULL;\n \n+   /* Usage can be NULL due to allocated bitmaps for which we do not\n+      call initialize function.  */\n+   bitmap_usage *usage = bitmap_mem_desc.get_descriptor_for_instance (head);\n+\n   /* This bitmap has more than one element, and we're going to look\n      through the elements list.  Count that as a search.  */\n-  if (GATHER_STATISTICS)\n-    bitmap_descriptors[head->descriptor_id]->nsearches++;\n+  if (GATHER_STATISTICS && usage)\n+    usage->m_nsearches++;\n \n   if (head->indx < indx)\n     /* INDX is beyond head->indx.  Search from head->current\n@@ -591,8 +509,8 @@ bitmap_find_bit (bitmap head, unsigned int bit)\n \t element->next != 0 && element->indx < indx;\n \t element = element->next)\n       {\n-\tif (GATHER_STATISTICS)\n-\t  bitmap_descriptors[head->descriptor_id]->search_iter++;\n+\tif (GATHER_STATISTICS && usage)\n+\t  usage->m_search_iter++;\n       }\n \n   else if (head->indx / 2 < indx)\n@@ -602,8 +520,8 @@ bitmap_find_bit (bitmap head, unsigned int bit)\n \t element->prev != 0 && element->indx > indx;\n \t element = element->prev)\n       {\n-\tif (GATHER_STATISTICS)\n-\t  bitmap_descriptors[head->descriptor_id]->search_iter++;\n+\tif (GATHER_STATISTICS && usage)\n+\t  usage->m_search_iter++;\n       }\n \n   else\n@@ -612,9 +530,9 @@ bitmap_find_bit (bitmap head, unsigned int bit)\n     for (element = head->first;\n \t element->next != 0 && element->indx < indx;\n \t element = element->next)\n-      if (GATHER_STATISTICS)\n+      if (GATHER_STATISTICS && usage)\n \t{\n-\t  bitmap_descriptors[head->descriptor_id]->search_iter++;\n+\t  usage->m_search_iter++;\n \t}\n \n   /* `element' is the nearest to the one we want.  If it's not the one we\n@@ -2157,68 +2075,14 @@ bitmap_print (FILE *file, const_bitmap head, const char *prefix,\n   fputs (suffix, file);\n }\n \n-\n-/* Used to accumulate statistics about bitmap sizes.  */\n-struct bitmap_output_info\n-{\n-  uint64_t size;\n-  uint64_t count;\n-};\n-\n-/* Called via hash_table::traverse.  Output bitmap descriptor pointed out by\n-   SLOT and update statistics.  */\n-int\n-print_statistics (bitmap_descriptor_d **slot, bitmap_output_info *i)\n-{\n-  bitmap_descriptor d = *slot;\n-  char s[4096];\n-\n-  if (d->allocated)\n-    {\n-      const char *s1 = d->file;\n-      const char *s2;\n-      while ((s2 = strstr (s1, \"gcc/\")))\n-\ts1 = s2 + 4;\n-      sprintf (s, \"%s:%i (%s)\", s1, d->line, d->function);\n-      s[41] = 0;\n-      fprintf (stderr,\n-\t       \"%-41s %9u %15\" PRId64\" %15\" PRId64\" %15\" PRId64\n-\t       \" %10\" PRId64\" %10\" PRId64\"\\n\",\n-\t       s, d->created,\n-\t       d->allocated, d->peak, d->current,\n-\t       d->nsearches, d->search_iter);\n-      i->size += d->allocated;\n-      i->count += d->created;\n-    }\n-  return 1;\n-}\n-\n /* Output per-bitmap memory usage statistics.  */\n void\n dump_bitmap_statistics (void)\n {\n-  struct bitmap_output_info info;\n-\n   if (! GATHER_STATISTICS)\n     return;\n \n-  if (!bitmap_desc_hash)\n-    return;\n-\n-  fprintf (stderr,\n-\t   \"\\n%-41s %9s %15s %15s %15s %10s %10s\\n\",\n-\t   \"Bitmap\", \"Overall\",\n-\t   \"Allocated\", \"Peak\", \"Leak\",\n-\t   \"searched\", \"search_itr\");\n-  fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n-  info.count = 0;\n-  info.size = 0;\n-  bitmap_desc_hash->traverse <bitmap_output_info *, print_statistics> (&info);\n-  fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n-  fprintf (stderr,\n-\t   \"%-41s %9\" PRId64\" %15\" PRId64\"\\n\",\n-\t   \"Total\", info.count, info.size);\n-  fprintf (stderr, \"---------------------------------------------------------------------------------\\n\");\n+  bitmap_mem_desc.dump (BITMAP);\n }\n \n DEBUG_FUNCTION void"}, {"sha": "40562f64c3493a4aa8dfa488955a063f72f026b2", "filename": "gcc/bitmap.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -130,6 +130,62 @@ along with GCC; see the file COPYING3.  If not see\n #include \"hashtab.h\"\n #include \"statistics.h\"\n #include \"obstack.h\"\n+#include \"mem-stats.h\"\n+\n+/* Bitmap memory usage.  */\n+struct bitmap_usage: public mem_usage\n+{\n+  /* Default contructor.  */\n+  bitmap_usage (): m_nsearches (0), m_search_iter (0) {}\n+  /* Constructor.  */\n+  bitmap_usage (size_t allocated, size_t times, size_t peak,\n+\t     uint64_t nsearches, uint64_t search_iter)\n+    : mem_usage (allocated, times, peak),\n+    m_nsearches (nsearches), m_search_iter (search_iter) {}\n+\n+  /* Sum the usage with SECOND usage.  */\n+  bitmap_usage operator+ (const bitmap_usage &second)\n+  {\n+    return bitmap_usage (m_allocated + second.m_allocated,\n+\t\t\t     m_times + second.m_times,\n+\t\t\t     m_peak + second.m_peak,\n+\t\t\t     m_nsearches + second.m_nsearches,\n+\t\t\t     m_search_iter + second.m_search_iter);\n+  }\n+\n+  /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n+  inline void dump (mem_location *loc, mem_usage &total) const\n+  {\n+    char s[4096];\n+    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n+\t     loc->m_line, loc->m_function);\n+\n+    s[48] = '\\0';\n+\n+    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%12li%12li%10s\\n\", s,\n+\t     (long)m_allocated, get_percent (m_allocated, total.m_allocated),\n+\t     (long)m_peak, (long)m_times,\n+\t     get_percent (m_times, total.m_times),\n+\t     (long)m_nsearches, (long)m_search_iter,\n+\t     loc->m_ggc ? \"ggc\" : \"heap\");\n+  }\n+\n+  /* Dump header with NAME.  */\n+  static inline void dump_header (const char *name)\n+  {\n+    fprintf (stderr, \"%-48s %11s%16s%17s%12s%12s%10s\\n\", name, \"Leak\", \"Peak\",\n+\t     \"Times\", \"N searches\", \"Search iter\", \"Type\");\n+    print_dash_line ();\n+  }\n+\n+  /* Number search operations.  */\n+  uint64_t m_nsearches;\n+  /* Number of search iterations.  */\n+  uint64_t m_search_iter;\n+};\n+\n+/* Bitmap memory description.  */\n+extern mem_alloc_description<bitmap_usage> bitmap_mem_desc;\n \n /* Fundamental storage type for bitmap.  */\n "}, {"sha": "49a15090fc163ec81d22eea5de7d40ad0b378b0a", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -454,7 +454,7 @@ set_mode_and_regno (rtx x, machine_mode mode, unsigned int regno)\n rtx\n gen_raw_REG (machine_mode mode, unsigned int regno)\n {\n-  rtx x = rtx_alloc_stat (REG PASS_MEM_STAT);\n+  rtx x = rtx_alloc_stat (REG MEM_STAT_INFO);\n   set_mode_and_regno (x, mode, regno);\n   REG_ATTRS (x) = NULL;\n   ORIGINAL_REGNO (x) = regno;"}, {"sha": "9dc3b8cf9521cfddfaae302c22c58df88abc6eb7", "filename": "gcc/genmatch.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fgenmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fgenmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenmatch.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -30,6 +30,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"errors.h\"\n #include \"hashtab.h\"\n #include \"hash-table.h\"\n+#include \"inchash.h\"\n #include \"hash-map.h\"\n #include \"hash-set.h\"\n #include \"vec.h\""}, {"sha": "576be8647021d26062bcecdc6b67395687622dda", "filename": "gcc/genpreds.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fgenpreds.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fgenpreds.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenpreds.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -1492,6 +1492,7 @@ write_insn_preds_c (void)\n #include \\\"rtl.h\\\"\\n\\\n #include \\\"hash-set.h\\\"\\n\\\n #include \\\"machmode.h\\\"\\n\\\n+#include \\\"hash-map.h\\\"\\n\\\n #include \\\"vec.h\\\"\\n\\\n #include \\\"double-int.h\\\"\\n\\\n #include \\\"input.h\\\"\\n\\"}, {"sha": "2e94ca4a6ef0d6742d9d09ecfea0df34314de36e", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 144, "deletions": 235, "changes": 379, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"plugin.h\"\n #include \"vec.h\"\n #include \"timevar.h\"\n+#include \"mem-stats.h\"\n \n /* When set, ggc_collect will do collection.  */\n bool ggc_force_collect;\n@@ -830,273 +831,181 @@ init_ggc_heuristics (void)\n #endif\n }\n \n-/* Datastructure used to store per-call-site statistics.  */\n-struct ggc_loc_descriptor\n+/* GGC memory usage.  */\n+struct ggc_usage: public mem_usage\n {\n-  const char *file;\n-  int line;\n-  const char *function;\n-  int times;\n-  size_t allocated;\n-  size_t overhead;\n-  size_t freed;\n-  size_t collected;\n-};\n+  /* Default constructor.  */\n+  ggc_usage (): m_freed (0), m_collected (0), m_overhead (0) {}\n+  /* Constructor.  */\n+  ggc_usage (size_t allocated, size_t times, size_t peak,\n+\t     size_t freed, size_t collected, size_t overhead)\n+    : mem_usage (allocated, times, peak),\n+    m_freed (freed), m_collected (collected), m_overhead (overhead) {}\n \n-/* Hash table helper.  */\n+  /* Comparison operator.  */\n+  inline bool operator< (const ggc_usage &second) const\n+  {\n+    return (get_balance () == second.get_balance () ?\n+\t    (m_peak == second.m_peak ? m_times < second.m_times\n+\t     : m_peak < second.m_peak)\n+\t      : get_balance () < second.get_balance ());\n+  }\n \n-struct ggc_loc_desc_hasher : typed_noop_remove <ggc_loc_descriptor>\n-{\n-  typedef ggc_loc_descriptor *value_type;\n-  typedef ggc_loc_descriptor *compare_type;\n-  static inline hashval_t hash (const ggc_loc_descriptor *);\n-  static inline bool equal (const ggc_loc_descriptor *,\n-\t\t\t    const ggc_loc_descriptor *);\n-};\n+  /* Register overhead of ALLOCATED and OVERHEAD bytes.  */\n+  inline void register_overhead (size_t allocated, size_t overhead)\n+  {\n+    m_allocated += allocated;\n+    m_overhead += overhead;\n+    m_times++;\n+  }\n \n-inline hashval_t\n-ggc_loc_desc_hasher::hash (const ggc_loc_descriptor *d)\n-{\n-  return htab_hash_pointer (d->function) | d->line;\n-}\n+  /* Release overhead of SIZE bytes.  */\n+  inline void release_overhead (size_t size)\n+  {\n+    m_freed += size;\n+  }\n \n-inline bool\n-ggc_loc_desc_hasher::equal (const ggc_loc_descriptor *d,\n-\t\t\t    const ggc_loc_descriptor *d2)\n-{\n-  return (d->file == d2->file && d->line == d2->line\n-\t  && d->function == d2->function);\n-}\n+  /* Sum the usage with SECOND usage.  */\n+  ggc_usage operator+ (const ggc_usage &second)\n+  {\n+    return ggc_usage (m_allocated + second.m_allocated,\n+\t\t      m_times + second.m_times,\n+\t\t      m_peak + second.m_peak,\n+\t\t      m_freed + second.m_freed,\n+\t\t      m_collected + second.m_collected,\n+\t\t      m_overhead + second.m_overhead);\n+  }\n \n-/* Hashtable used for statistics.  */\n-static hash_table<ggc_loc_desc_hasher> *loc_hash;\n+  /* Dump usage with PREFIX, where TOTAL is sum of all rows.  */\n+  inline void dump (const char *prefix, ggc_usage &total) const\n+  {\n+    long balance = get_balance ();\n+    fprintf (stderr,\n+\t     \"%-48s %10li:%5.1f%%%10li:%5.1f%%\"\n+\t     \"%10li:%5.1f%%%10li:%5.1f%%%10li\\n\",\n+\t     prefix, (long)m_collected,\n+\t     get_percent (m_collected, total.m_collected),\n+\t     (long)m_freed, get_percent (m_freed, total.m_freed),\n+\t     (long)balance, get_percent (balance, total.get_balance ()),\n+\t     (long)m_overhead, get_percent (m_overhead, total.m_overhead),\n+\t     (long)m_times);\n+  }\n \n-struct ggc_ptr_hash_entry\n-{\n-  void *ptr;\n-  struct ggc_loc_descriptor *loc;\n-  size_t size;\n-};\n+  /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n+  inline void dump (mem_location *loc, ggc_usage &total) const\n+  {\n+    char s[4096];\n+    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n+\t     loc->m_line, loc->m_function);\n+    s[48] = '\\0';\n \n-/* Helper for ptr_hash table.  */\n+    dump (s, total);\n+  }\n \n-struct ptr_hash_hasher : typed_noop_remove <ggc_ptr_hash_entry>\n-{\n-  typedef ggc_ptr_hash_entry *value_type;\n-  typedef void *compare_type;\n-  static inline hashval_t hash (const ggc_ptr_hash_entry *);\n-  static inline bool equal (const ggc_ptr_hash_entry *, const void *);\n-};\n+  /* Dump footer.  */\n+  inline void dump_footer ()\n+  {\n+    print_dash_line ();\n+    dump (\"Total\", *this);\n+    print_dash_line ();\n+  }\n \n-inline hashval_t\n-ptr_hash_hasher::hash (const ggc_ptr_hash_entry *d)\n-{\n-  return htab_hash_pointer (d->ptr);\n-}\n+  /* Get balance which is GGC allocation leak.  */\n+  inline long get_balance () const\n+  {\n+    return m_allocated + m_overhead - m_collected - m_freed;\n+  }\n \n-inline bool\n-ptr_hash_hasher::equal (const ggc_ptr_hash_entry *p, const void *p2)\n-{\n-  return (p->ptr == p2);\n-}\n+  typedef std::pair<mem_location *, ggc_usage *> mem_pair_t;\n \n-/* Hashtable converting address of allocated field to loc descriptor.  */\n-static hash_table<ptr_hash_hasher> *ptr_hash;\n+  /* Compare wrapper used by qsort method.  */\n+  static int compare (const void *first, const void *second)\n+  {\n+    const mem_pair_t f = *(const mem_pair_t *)first;\n+    const mem_pair_t s = *(const mem_pair_t *)second;\n \n-/* Return descriptor for given call site, create new one if needed.  */\n-static struct ggc_loc_descriptor *\n-make_loc_descriptor (const char *name, int line, const char *function)\n-{\n-  struct ggc_loc_descriptor loc;\n-  struct ggc_loc_descriptor **slot;\n-\n-  loc.file = name;\n-  loc.line = line;\n-  loc.function = function;\n-  if (!loc_hash)\n-    loc_hash = new hash_table<ggc_loc_desc_hasher> (10);\n-\n-  slot = loc_hash->find_slot (&loc, INSERT);\n-  if (*slot)\n-    return *slot;\n-  *slot = XCNEW (struct ggc_loc_descriptor);\n-  (*slot)->file = name;\n-  (*slot)->line = line;\n-  (*slot)->function = function;\n-  return *slot;\n-}\n+    return (*f.second) < (*s.second);\n+  }\n+\n+  /* Compare rows in final GGC summary dump.  */\n+  static int compare_final (const void *first, const void *second)\n+  {  typedef std::pair<mem_location *, ggc_usage *> mem_pair_t;\n+\n+    const ggc_usage *f = ((const mem_pair_t *)first)->second;\n+    const ggc_usage *s = ((const mem_pair_t *)second)->second;\n+\n+    size_t a = f->m_allocated + f->m_overhead - f->m_freed;\n+    size_t b = s->m_allocated + s->m_overhead - s->m_freed;\n+\n+    return a == b ? 0 : (a < b ? 1 : -1);\n+  }\n+\n+  /* Dump header with NAME.  */\n+  static inline void dump_header (const char *name)\n+  {\n+    fprintf (stderr, \"%-48s %11s%17s%17s%16s%17s\\n\", name, \"Garbage\", \"Freed\",\n+\t     \"Leak\", \"Overhead\", \"Times\");\n+    print_dash_line ();\n+  }\n+\n+  /* Freed memory in bytes.  */\n+  size_t m_freed;\n+  /* Collected memory in bytes.  */\n+  size_t m_collected;\n+  /* Overhead memory in bytes.  */\n+  size_t m_overhead;\n+};\n+\n+/* GCC memory description.  */\n+static mem_alloc_description<ggc_usage> ggc_mem_desc;\n+\n+/* Dump per-site memory statistics.  */\n \n-/* Record ALLOCATED and OVERHEAD bytes to descriptor NAME:LINE (FUNCTION).  */\n void\n-ggc_record_overhead (size_t allocated, size_t overhead, void *ptr,\n-\t\t     const char *name, int line, const char *function)\n+dump_ggc_loc_statistics (bool final)\n {\n-  struct ggc_loc_descriptor *loc = make_loc_descriptor (name, line, function);\n-  struct ggc_ptr_hash_entry *p = XNEW (struct ggc_ptr_hash_entry);\n-  ggc_ptr_hash_entry **slot;\n-\n-  p->ptr = ptr;\n-  p->loc = loc;\n-  p->size = allocated + overhead;\n-  if (!ptr_hash)\n-    ptr_hash = new hash_table<ptr_hash_hasher> (10);\n-  slot = ptr_hash->find_slot_with_hash (ptr, htab_hash_pointer (ptr), INSERT);\n-  gcc_assert (!*slot);\n-  *slot = p;\n-\n-  loc->times++;\n-  loc->allocated+=allocated;\n-  loc->overhead+=overhead;\n-}\n+  if (! GATHER_STATISTICS)\n+    return;\n \n-/* Helper function for prune_overhead_list.  See if SLOT is still marked and\n-   remove it from hashtable if it is not.  */\n-int\n-ggc_prune_ptr (ggc_ptr_hash_entry **slot, void *b ATTRIBUTE_UNUSED)\n-{\n-  struct ggc_ptr_hash_entry *p = *slot;\n-  if (!ggc_marked_p (p->ptr))\n-    {\n-      p->loc->collected += p->size;\n-      ptr_hash->clear_slot (slot);\n-      free (p);\n-    }\n-  return 1;\n+  ggc_force_collect = true;\n+  ggc_collect ();\n+\n+  ggc_mem_desc.dump (GGC, final ? ggc_usage::compare_final : NULL);\n+\n+  ggc_force_collect = false;\n }\n \n-/* After live values has been marked, walk all recorded pointers and see if\n-   they are still live.  */\n+/* Record ALLOCATED and OVERHEAD bytes to descriptor NAME:LINE (FUNCTION).  */\n void\n-ggc_prune_overhead_list (void)\n+ggc_record_overhead (size_t allocated, size_t overhead, void *ptr MEM_STAT_DECL)\n {\n-  ptr_hash->traverse <void *, ggc_prune_ptr> (NULL);\n+  ggc_usage *usage = ggc_mem_desc.register_descriptor (ptr, GGC, false\n+\t\t\t\t\t\t       FINAL_PASS_MEM_STAT);\n+\n+  ggc_mem_desc.register_object_overhead (usage, allocated + overhead, ptr);\n+  usage->register_overhead (allocated, overhead);\n }\n \n /* Notice that the pointer has been freed.  */\n void\n ggc_free_overhead (void *ptr)\n {\n-  ggc_ptr_hash_entry **slot\n-    = ptr_hash->find_slot_with_hash (ptr, htab_hash_pointer (ptr), NO_INSERT);\n-  struct ggc_ptr_hash_entry *p;\n-  /* The pointer might be not found if a PCH read happened between allocation\n-     and ggc_free () call.  FIXME: account memory properly in the presence of\n-     PCH. */\n-  if (!slot)\n-      return;\n-  p = (struct ggc_ptr_hash_entry *) *slot;\n-  p->loc->freed += p->size;\n-  ptr_hash->clear_slot (slot);\n-  free (p);\n-}\n-\n-/* Helper for qsort; sort descriptors by amount of memory consumed.  */\n-static int\n-final_cmp_statistic (const void *loc1, const void *loc2)\n-{\n-  const struct ggc_loc_descriptor *const l1 =\n-    *(const struct ggc_loc_descriptor *const *) loc1;\n-  const struct ggc_loc_descriptor *const l2 =\n-    *(const struct ggc_loc_descriptor *const *) loc2;\n-  long diff;\n-  diff = ((long)(l1->allocated + l1->overhead - l1->freed) -\n-\t  (l2->allocated + l2->overhead - l2->freed));\n-  return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n+  ggc_mem_desc.release_object_overhead (ptr);\n }\n \n-/* Helper for qsort; sort descriptors by amount of memory consumed.  */\n-static int\n-cmp_statistic (const void *loc1, const void *loc2)\n-{\n-  const struct ggc_loc_descriptor *const l1 =\n-    *(const struct ggc_loc_descriptor *const *) loc1;\n-  const struct ggc_loc_descriptor *const l2 =\n-    *(const struct ggc_loc_descriptor *const *) loc2;\n-  long diff;\n-\n-  diff = ((long)(l1->allocated + l1->overhead - l1->freed - l1->collected) -\n-\t  (l2->allocated + l2->overhead - l2->freed - l2->collected));\n-  if (diff)\n-    return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n-  diff =  ((long)(l1->allocated + l1->overhead - l1->freed) -\n-\t   (l2->allocated + l2->overhead - l2->freed));\n-  return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n-}\n-\n-/* Collect array of the descriptors from hashtable.  */\n-static struct ggc_loc_descriptor **loc_array;\n-int\n-ggc_add_statistics (ggc_loc_descriptor **slot, int *n)\n-{\n-  loc_array[*n] = *slot;\n-  (*n)++;\n-  return 1;\n-}\n-\n-/* Dump per-site memory statistics.  */\n-\n+/* After live values has been marked, walk all recorded pointers and see if\n+   they are still live.  */\n void\n-dump_ggc_loc_statistics (bool final)\n+ggc_prune_overhead_list (void)\n {\n-  int nentries = 0;\n-  char s[4096];\n-  size_t collected = 0, freed = 0, allocated = 0, overhead = 0, times = 0;\n-  int i;\n+  typedef hash_map<const void *, std::pair<ggc_usage *, size_t > > map_t;\n \n-  if (! GATHER_STATISTICS)\n-    return;\n+  map_t::iterator it = ggc_mem_desc.m_reverse_object_map->begin ();\n \n-  ggc_force_collect = true;\n-  ggc_collect ();\n+  for (; it != ggc_mem_desc.m_reverse_object_map->end (); ++it)\n+    if (!ggc_marked_p ((*it).first))\n+      (*it).second.first->m_collected += (*it).second.second;\n \n-  loc_array = XCNEWVEC (struct ggc_loc_descriptor *,\n-\t\t\tloc_hash->elements_with_deleted ());\n-  fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n-\t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n-  fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  loc_hash->traverse <int *, ggc_add_statistics> (&nentries);\n-  qsort (loc_array, nentries, sizeof (*loc_array),\n-\t final ? final_cmp_statistic : cmp_statistic);\n-  for (i = 0; i < nentries; i++)\n-    {\n-      struct ggc_loc_descriptor *d = loc_array[i];\n-      allocated += d->allocated;\n-      times += d->times;\n-      freed += d->freed;\n-      collected += d->collected;\n-      overhead += d->overhead;\n-    }\n-  for (i = 0; i < nentries; i++)\n-    {\n-      struct ggc_loc_descriptor *d = loc_array[i];\n-      if (d->allocated)\n-\t{\n-\t  const char *s1 = d->file;\n-\t  const char *s2;\n-\t  while ((s2 = strstr (s1, \"gcc/\")))\n-\t    s1 = s2 + 4;\n-\t  sprintf (s, \"%s:%i (%s)\", s1, d->line, d->function);\n-\t  s[48] = 0;\n-\t  fprintf (stderr, \"%-48s %10li:%4.1f%% %10li:%4.1f%% %10li:%4.1f%% %10li:%4.1f%% %10li\\n\", s,\n-\t\t   (long)d->collected,\n-\t\t   (d->collected) * 100.0 / collected,\n-\t\t   (long)d->freed,\n-\t\t   (d->freed) * 100.0 / freed,\n-\t\t   (long)(d->allocated + d->overhead - d->freed - d->collected),\n-\t\t   (d->allocated + d->overhead - d->freed - d->collected) * 100.0\n-\t\t   / (allocated + overhead - freed - collected),\n-\t\t   (long)d->overhead,\n-\t\t   d->overhead * 100.0 / overhead,\n-\t\t   (long)d->times);\n-\t}\n-    }\n-  fprintf (stderr, \"%-48s %10ld       %10ld       %10ld       %10ld       %10ld\\n\",\n-\t   \"Total\", (long)collected, (long)freed,\n-\t   (long)(allocated + overhead - freed - collected), (long)overhead,\n-\t   (long)times);\n-  fprintf (stderr, \"%-48s %10s       %10s       %10s       %10s       %10s\\n\",\n-\t   \"source location\", \"Garbage\", \"Freed\", \"Leak\", \"Overhead\", \"Times\");\n-  fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  ggc_force_collect = false;\n+  delete ggc_mem_desc.m_reverse_object_map;\n+  ggc_mem_desc.m_reverse_object_map = new map_t (13, false, false);\n }"}, {"sha": "ce9c4a74b4031ec79d1957c12b44ff5a68aec0a3", "filename": "gcc/hash-map-traits.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-map-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-map-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map-traits.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -0,0 +1,104 @@\n+/* A hash map traits.\n+   Copyright (C) 2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef HASH_MAP_TRAITS_H\n+#define HASH_MAP_TRAITS_H\n+\n+/* Bacause mem-stats.h uses default hashmap traits, we have to\n+   put the class to this separate header file.  */\n+\n+/* implement default behavior for traits when types allow it.  */\n+\n+struct default_hashmap_traits\n+{\n+  /* Hashes the passed in key.  */\n+\n+  template<typename T>\n+  static hashval_t\n+  hash (T *p)\n+    {\n+      return uintptr_t (p) >> 3;\n+    }\n+\n+  /* If the value converts to hashval_t just use it.  */\n+\n+  template<typename T> static hashval_t hash (T v) { return v; }\n+\n+  /* Return true if the two keys passed as arguments are equal.  */\n+\n+  template<typename T>\n+  static bool\n+  equal_keys (const T &a, const T &b)\n+    {\n+      return a == b;\n+    }\n+\n+  /* Called to dispose of the key and value before marking the entry as\n+     deleted.  */\n+\n+  template<typename T> static void remove (T &v) { v.~T (); }\n+\n+  /* Mark the passed in entry as being deleted.  */\n+\n+  template<typename T>\n+  static void\n+  mark_deleted (T &e)\n+    {\n+      mark_key_deleted (e.m_key);\n+    }\n+\n+  /* Mark the passed in entry as being empty.  */\n+\n+  template<typename T>\n+  static void\n+  mark_empty (T &e)\n+    {\n+      mark_key_empty (e.m_key);\n+    }\n+\n+  /* Return true if the passed in entry is marked as deleted.  */\n+\n+  template<typename T>\n+  static bool\n+  is_deleted (T &e)\n+    {\n+      return e.m_key == (void *)1;\n+    }\n+\n+  /* Return true if the passed in entry is marked as empty.  */\n+\n+  template<typename T> static bool is_empty (T &e) { return e.m_key == NULL; }\n+\n+private:\n+  template<typename T>\n+  static void\n+  mark_key_deleted (T *&k)\n+    {\n+      k = reinterpret_cast<T *> (1);\n+    }\n+\n+  template<typename T>\n+  static void\n+  mark_key_empty (T *&k)\n+    {\n+      k = static_cast<T *> (0);\n+    }\n+};\n+\n+#endif // HASH_MAP_TRAITS_H"}, {"sha": "fb1a522a25d6950b08be6ed45538feb1df83efc1", "filename": "gcc/hash-map.h", "status": "modified", "additions": 10, "deletions": 82, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-map.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -24,87 +24,12 @@ along with GCC; see the file COPYING3.  If not see\n #include <new>\n #include <utility>\n #include \"hash-table.h\"\n-\n-/* implement default behavior for traits when types allow it.  */\n-\n-struct default_hashmap_traits\n-{\n-  /* Hashes the passed in key.  */\n-\n-  template<typename T>\n-  static hashval_t\n-  hash (T *p)\n-    {\n-      return uintptr_t(p) >> 3;\n-    }\n-\n-  /* If the value converts to hashval_t just use it.  */\n-\n-  template<typename T> static hashval_t hash (T v) { return v; }\n-\n-  /* Return true if the two keys passed as arguments are equal.  */\n-\n-  template<typename T>\n-  static bool\n-  equal_keys (const T &a, const T &b)\n-    {\n-      return a == b;\n-    }\n-\n-  /* Called to dispose of the key and value before marking the entry as\n-     deleted.  */\n-\n-  template<typename T> static void remove (T &v) { v.~T (); }\n-\n-  /* Mark the passed in entry as being deleted.  */\n-\n-  template<typename T>\n-  static void\n-  mark_deleted (T &e)\n-    {\n-      mark_key_deleted (e.m_key);\n-    }\n-\n-  /* Mark the passed in entry as being empty.  */\n-\n-  template<typename T>\n-  static void\n-  mark_empty (T &e)\n-    {\n-      mark_key_empty (e.m_key);\n-    }\n-\n-  /* Return true if the passed in entry is marked as deleted.  */\n-\n-  template<typename T>\n-  static bool\n-  is_deleted (T &e)\n-    {\n-      return e.m_key == (void *)1;\n-    }\n-\n-  /* Return true if the passed in entry is marked as empty.  */\n-\n-  template<typename T> static bool is_empty (T &e) { return e.m_key == NULL; }\n-\n-private:\n-  template<typename T>\n-  static void\n-  mark_key_deleted (T *&k)\n-    {\n-      k = reinterpret_cast<T *> (1);\n-    }\n-\n-  template<typename T>\n-  static void\n-  mark_key_empty (T *&k)\n-    {\n-      k = static_cast<T *> (0);\n-    }\n-};\n+#include \"hash-map-traits.h\"\n+#include \"mem-stats.h\"\n+#include \"vec.h\"\n \n template<typename Key, typename Value,\n-\t typename Traits = default_hashmap_traits>\n+\t typename Traits>\n class GTY((user)) hash_map\n {\n   struct hash_entry\n@@ -187,13 +112,16 @@ class GTY((user)) hash_map\n   };\n \n public:\n-  explicit hash_map (size_t n = 13, bool ggc = false) : m_table (n, ggc) {}\n+  explicit hash_map (size_t n = 13, bool ggc = false,\n+\t\t     bool gather_mem_stats = true CXX_MEM_STAT_INFO)\n+    : m_table (n, ggc, gather_mem_stats, HASH_MAP PASS_MEM_STAT) {}\n \n   /* Create a hash_map in ggc memory.  */\n-  static hash_map *create_ggc (size_t size)\n+  static hash_map *create_ggc (size_t size, bool gather_mem_stats = true\n+\t\t\t       CXX_MEM_STAT_INFO)\n     {\n       hash_map *map = ggc_alloc<hash_map> ();\n-      new (map) hash_map (size, true);\n+      new (map) hash_map (size, true, gather_mem_stats PASS_MEM_STAT);\n       return map;\n     }\n "}, {"sha": "b4db21acedb4e994115b9f7f640580633e350d8c", "filename": "gcc/hash-set.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-set.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -33,7 +33,7 @@ struct default_hashset_traits\n   static hashval_t\n   hash (T *p)\n     {\n-      return uintptr_t(p) >> 3;\n+      return uintptr_t (p) >> 3;\n     }\n \n   template<typename T> static hashval_t hash(const T &v) { return v; }\n@@ -180,7 +180,8 @@ class hash_set\n   };\n \n public:\n-  explicit hash_set (size_t n = 13, bool ggc = false) : m_table (n, ggc) {}\n+  explicit hash_set (size_t n = 13, bool ggc = false CXX_MEM_STAT_INFO)\n+    : m_table (n, ggc, true, HASH_SET PASS_MEM_STAT) {}\n \n   /* Create a hash_set in gc memory with space for at least n elements.  */\n "}, {"sha": "012b241906de7598ac61105acd8994c913702619", "filename": "gcc/hash-table.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-table.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-table.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -31,7 +31,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n \n-\n /* Table of primes and multiplicative inverses.\n \n    Note that these are not minimally reduced inverses.  Unlike when generating\n@@ -99,3 +98,15 @@ hash_table_higher_prime_index (unsigned long n)\n   return low;\n }\n \n+mem_alloc_description<mem_usage> hash_table_usage;\n+\n+/* Support function for statistics.  */\n+void dump_hash_table_loc_statistics (void)\n+{\n+  for (unsigned i = HASH_TABLE; i <= HASH_SET; i++)\n+    {\n+      mem_alloc_origin origin = (mem_alloc_origin) i;\n+      hash_table_usage.dump (origin);\n+    }\n+}\n+"}, {"sha": "74c3722bbf3d5f71355a1f09f62953d86c4fd6ce", "filename": "gcc/hash-table.h", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-table.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fhash-table.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhash-table.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -199,6 +199,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include <new>\n+#include \"mem-stats-traits.h\"\n \n template<typename, typename, typename> class hash_map;\n template<typename, typename> class hash_set;\n@@ -551,6 +552,8 @@ struct mark_empty_helper<Type *, Traits, false>\n   }\n };\n \n+class mem_usage;\n+\n /* User-facing hash table type.\n \n    The table stores elements of type Descriptor::value_type.\n@@ -583,16 +586,18 @@ class hash_table\n   typedef typename Descriptor::compare_type compare_type;\n \n public:\n-  explicit hash_table (size_t, bool ggc = false CXX_MEM_STAT_INFO);\n+  explicit hash_table (size_t, bool ggc = false, bool gather_mem_stats = true,\n+\t\t       mem_alloc_origin origin = HASH_TABLE\n+\t\t       CXX_MEM_STAT_INFO);\n   ~hash_table ();\n \n   /* Create a hash_table in gc memory.  */\n \n   static hash_table *\n-  create_ggc (size_t n)\n+  create_ggc (size_t n CXX_MEM_STAT_INFO)\n   {\n     hash_table *table = ggc_alloc<hash_table> ();\n-    new (table) hash_table (n, true);\n+    new (table) hash_table (n, true, true, HASH_TABLE PASS_MEM_STAT);\n     return table;\n   }\n \n@@ -759,19 +764,40 @@ class hash_table\n \n   /* if m_entries is stored in ggc memory.  */\n   bool m_ggc;\n+\n+  /* If we should gather memory statistics for the table.  */\n+  bool m_gather_mem_stats;\n };\n \n+/* As mem-stats.h heavily utilizes hash maps (hash tables), we have to include\n+   mem-stats.h after hash_table declaration.  */\n+\n+#include \"mem-stats.h\"\n+#include \"hash-map.h\"\n+#include \"vec.h\"\n+\n+extern mem_alloc_description<mem_usage> hash_table_usage;\n+\n+/* Support function for statistics.  */\n+extern void dump_hash_table_loc_statistics (void);\n+\n template<typename Descriptor, template<typename Type> class Allocator>\n-hash_table<Descriptor, Allocator>::hash_table (size_t size, bool ggc\n-\t\t\t\t\t\t     MEM_STAT_DECL) :\n+hash_table<Descriptor, Allocator>::hash_table (size_t size, bool ggc, bool\n+\t\t\t\t\t       gather_mem_stats,\n+\t\t\t\t\t       mem_alloc_origin origin\n+\t\t\t\t\t       MEM_STAT_DECL) :\n   m_n_elements (0), m_n_deleted (0), m_searches (0), m_collisions (0),\n-  m_ggc (ggc)\n+  m_ggc (ggc), m_gather_mem_stats (gather_mem_stats)\n {\n   unsigned int size_prime_index;\n \n   size_prime_index = hash_table_higher_prime_index (size);\n   size = prime_tab[size_prime_index].prime;\n \n+  if (m_gather_mem_stats)\n+    hash_table_usage.register_descriptor (this, origin, ggc\n+\t\t\t\t\t  FINAL_PASS_MEM_STAT);\n+\n   m_entries = alloc_entries (size PASS_MEM_STAT);\n   m_size = size;\n   m_size_prime_index = size_prime_index;\n@@ -788,6 +814,11 @@ hash_table<Descriptor, Allocator>::~hash_table ()\n     Allocator <value_type> ::data_free (m_entries);\n   else\n     ggc_free (m_entries);\n+\n+  if (m_gather_mem_stats)\n+    hash_table_usage.release_instance_overhead (this,\n+\t\t\t\t\t\tsizeof (value_type) * m_size,\n+\t\t\t\t\t\ttrue);\n }\n \n /* This function returns an array of empty hash table elements.  */\n@@ -798,6 +829,9 @@ hash_table<Descriptor, Allocator>::alloc_entries (size_t n MEM_STAT_DECL) const\n {\n   value_type *nentries;\n \n+  if (m_gather_mem_stats)\n+    hash_table_usage.register_instance_overhead (sizeof (value_type) * n, this);\n+\n   if (!m_ggc)\n     nentries = Allocator <value_type> ::data_alloc (n);\n   else\n@@ -881,6 +915,11 @@ hash_table<Descriptor, Allocator>::expand ()\n     }\n \n   value_type *nentries = alloc_entries (nsize);\n+\n+  if (m_gather_mem_stats)\n+    hash_table_usage.release_instance_overhead (this, sizeof (value_type)\n+\t\t\t\t\t\t    * osize);\n+\n   m_entries = nentries;\n   m_size = nsize;\n   m_size_prime_index = nindex;"}, {"sha": "90c62e828671e1e67e70bf30a7af2dde024f025c", "filename": "gcc/inchash.c", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Finchash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Finchash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finchash.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -26,54 +26,3 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"hashtab.h\"\n #include \"inchash.h\"\n-\n-/* Borrowed from hashtab.c iterative_hash implementation.  */\n-#define mix(a,b,c) \\\n-{ \\\n-  a -= b; a -= c; a ^= (c>>13); \\\n-  b -= c; b -= a; b ^= (a<< 8); \\\n-  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n-  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n-  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n-  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n-  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n-  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n-  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n-}\n-\n-\n-/* Produce good hash value combining VAL and VAL2.  */\n-hashval_t\n-iterative_hash_hashval_t (hashval_t val, hashval_t val2)\n-{\n-  /* the golden ratio; an arbitrary value.  */\n-  hashval_t a = 0x9e3779b9;\n-\n-  mix (a, val, val2);\n-  return val2;\n-}\n-\n-/* Produce good hash value combining VAL and VAL2.  */\n-\n-hashval_t\n-iterative_hash_host_wide_int (HOST_WIDE_INT val, hashval_t val2)\n-{\n-  if (sizeof (HOST_WIDE_INT) == sizeof (hashval_t))\n-    return iterative_hash_hashval_t (val, val2);\n-  else\n-    {\n-      hashval_t a = (hashval_t) val;\n-      /* Avoid warnings about shifting of more than the width of the type on\n-         hosts that won't execute this path.  */\n-      int zero = 0;\n-      hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 8 + zero));\n-      mix (a, b, val2);\n-      if (sizeof (HOST_WIDE_INT) > 2 * sizeof (hashval_t))\n-\t{\n-\t  hashval_t a = (hashval_t) (val >> (sizeof (hashval_t) * 16 + zero));\n-\t  hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 24 + zero));\n-\t  mix (a, b, val2);\n-\t}\n-      return val2;\n-    }\n-}"}, {"sha": "4bb1272c1a9eea78c7fdbc925b23e2e98b62d1c6", "filename": "gcc/inchash.h", "status": "modified", "additions": 59, "deletions": 6, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Finchash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Finchash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finchash.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -36,8 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n    Currently it just implements the plain old jhash based\n    incremental hash from gcc's tree.c.  */\n \n-extern hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n-extern hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n+hashval_t iterative_hash_host_wide_int (HOST_WIDE_INT, hashval_t);\n+hashval_t iterative_hash_hashval_t (hashval_t, hashval_t);\n \n namespace inchash\n {\n@@ -72,7 +72,7 @@ class hash\n   }\n \n   /* Hash in pointer PTR.  */\n-  void add_ptr (void *ptr)\n+  void add_ptr (const void *ptr)\n   {\n     add (&ptr, sizeof (ptr));\n   }\n@@ -121,13 +121,13 @@ class hash\n   {\n     if (a.end() > b.end())\n       {\n-        merge (b);\n+\tmerge (b);\n \tmerge (a);\n       }\n     else\n       {\n-        merge (a);\n-        merge (b);\n+\tmerge (a);\n+\tmerge (b);\n       }\n   }\n \n@@ -138,4 +138,57 @@ class hash\n \n }\n \n+/* Borrowed from hashtab.c iterative_hash implementation.  */\n+#define mix(a,b,c) \\\n+{ \\\n+  a -= b; a -= c; a ^= (c>>13); \\\n+  b -= c; b -= a; b ^= (a<< 8); \\\n+  c -= a; c -= b; c ^= ((b&0xffffffff)>>13); \\\n+  a -= b; a -= c; a ^= ((c&0xffffffff)>>12); \\\n+  b -= c; b -= a; b = (b ^ (a<<16)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>> 5)) & 0xffffffff; \\\n+  a -= b; a -= c; a = (a ^ (c>> 3)) & 0xffffffff; \\\n+  b -= c; b -= a; b = (b ^ (a<<10)) & 0xffffffff; \\\n+  c -= a; c -= b; c = (c ^ (b>>15)) & 0xffffffff; \\\n+}\n+\n+\n+/* Produce good hash value combining VAL and VAL2.  */\n+inline\n+hashval_t\n+iterative_hash_hashval_t (hashval_t val, hashval_t val2)\n+{\n+  /* the golden ratio; an arbitrary value.  */\n+  hashval_t a = 0x9e3779b9;\n+\n+  mix (a, val, val2);\n+  return val2;\n+}\n+\n+/* Produce good hash value combining VAL and VAL2.  */\n+\n+inline\n+hashval_t\n+iterative_hash_host_wide_int (HOST_WIDE_INT val, hashval_t val2)\n+{\n+  if (sizeof (HOST_WIDE_INT) == sizeof (hashval_t))\n+    return iterative_hash_hashval_t (val, val2);\n+  else\n+    {\n+      hashval_t a = (hashval_t) val;\n+      /* Avoid warnings about shifting of more than the width of the type on\n+         hosts that won't execute this path.  */\n+      int zero = 0;\n+      hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 8 + zero));\n+      mix (a, b, val2);\n+      if (sizeof (HOST_WIDE_INT) > 2 * sizeof (hashval_t))\n+\t{\n+\t  hashval_t a = (hashval_t) (val >> (sizeof (hashval_t) * 16 + zero));\n+\t  hashval_t b = (hashval_t) (val >> (sizeof (hashval_t) * 24 + zero));\n+\t  mix (a, b, val2);\n+\t}\n+      return val2;\n+    }\n+}\n+\n #endif"}, {"sha": "de1614e49d63bff7fa62b592f38da04ad3b6200d", "filename": "gcc/mem-stats-traits.h", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fmem-stats-traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fmem-stats-traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats-traits.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -0,0 +1,20 @@\n+#ifndef GCC_MEM_STATS_TRAITS_H\n+#define GCC_MEM_STATS_TRAITS_H\n+\n+/* Memory allocation origin.  */\n+enum mem_alloc_origin\n+{\n+  HASH_TABLE,\n+  HASH_MAP,\n+  HASH_SET,\n+  VEC,\n+  BITMAP,\n+  GGC,\n+  MEM_ALLOC_ORIGIN_LENGTH\n+};\n+\n+/* Verbose names of the memory allocation origin.  */\n+static const char * mem_alloc_origin_names[] = { \"Hash tables\", \"Hash maps\",\n+  \"Hash sets\", \"Heap vectors\", \"Bitmaps\", \"GGC memory\" };\n+\n+#endif // GCC_MEM_STATS_TRAITS_H"}, {"sha": "ac472315fd39c48f409b38eb7356a18cc1e536c3", "filename": "gcc/mem-stats.h", "status": "added", "additions": 550, "deletions": 0, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fmem-stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fmem-stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmem-stats.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -0,0 +1,550 @@\n+#ifndef GCC_MEM_STATS_H\n+#define GCC_MEM_STATS_H\n+\n+#include \"hash-map-traits.h\"\n+#include \"inchash.h\"\n+#include \"mem-stats-traits.h\"\n+#include \"vec.h\"\n+\n+/* Forward declaration.  */\n+template<typename Key, typename Value,\n+\t typename Traits = default_hashmap_traits>\n+class hash_map;\n+\n+/* Memory allocation location.  */\n+struct mem_location\n+{\n+  /* Default constructor.  */\n+  inline mem_location () {}\n+\n+  /* Constructor.  */\n+  inline mem_location (const char *filename, const char *function, int line,\n+\t\tmem_alloc_origin origin, bool ggc):\n+    m_filename (filename), m_function (function), m_line (line), m_origin\n+    (origin), m_ggc (ggc) {}\n+\n+  /* Compute hash value based on file name, function name and line in\n+     source code. As there is just a single pointer registered for every\n+     constant that points to e.g. the same file name, we can use hash\n+     of the pointer.  */\n+  hashval_t hash ()\n+  {\n+    inchash::hash hash;\n+\n+    hash.add_ptr (m_filename);\n+    hash.add_ptr (m_function);\n+    hash.add_int (m_line);\n+\n+    return hash.end ();\n+  }\n+\n+  /* Return true if the memory location is equal to OTHER.  */\n+  int equal (mem_location &other)\n+  {\n+    return m_filename == other.m_filename && m_function == other.m_function\n+      && m_line == other.m_line;\n+  }\n+\n+  /* Return trimmed filename for the location.  */\n+  inline const char *get_trimmed_filename ()\n+  {\n+    const char *s1 = m_filename;\n+    const char *s2;\n+\n+    while ((s2 = strstr (s1, \"gcc/\")))\n+      s1 = s2 + 4;\n+\n+    return s1;\n+  }\n+\n+  /* Return display name associated to ORIGIN type.  */\n+  static const char *get_origin_name (mem_alloc_origin origin)\n+  {\n+    return mem_alloc_origin_names[(unsigned) origin];\n+  }\n+\n+  /* File name of source code.  */\n+  const char *m_filename;\n+  /* Funcation name.  */\n+  const char *m_function;\n+  /* Line number in source code.  */\n+  int m_line;\n+  /* Origin type.  */\n+  mem_alloc_origin m_origin;\n+  /* Flag if used by GGC allocation.  */\n+  bool m_ggc;\n+};\n+\n+/* Memory usage register to a memory location.  */\n+struct mem_usage\n+{\n+  /* Default constructor.  */\n+  mem_usage (): m_allocated (0), m_times (0), m_peak (0) {}\n+\n+  /* Constructor.  */\n+  mem_usage (size_t allocated, size_t times, size_t peak):\n+    m_allocated (allocated), m_times (times), m_peak (peak) {}\n+\n+  /* Register overhead of SIZE bytes.  */\n+  inline void register_overhead (size_t size)\n+  {\n+    m_allocated += size;\n+    m_times++;\n+\n+    if (m_peak < m_allocated)\n+      m_peak = m_allocated;\n+  }\n+\n+  /* Release overhead of SIZE bytes.  */\n+  inline void release_overhead (size_t size)\n+  {\n+    gcc_assert (size <= m_allocated);\n+\n+    m_allocated -= size;\n+  }\n+\n+  /* Sum the usage with SECOND usage.  */\n+  mem_usage operator+ (const mem_usage &second)\n+  {\n+    return mem_usage (m_allocated + second.m_allocated,\n+\t\t      m_times + second.m_times,\n+\t\t      m_peak + second.m_peak);\n+  }\n+\n+  /* Comparison operator.  */\n+  inline bool operator< (const mem_usage &second) const\n+  {\n+    return (m_allocated == second.m_allocated ?\n+\t    (m_peak == second.m_peak ? m_times < second.m_times\n+\t     : m_peak < second.m_peak) : m_allocated < second.m_allocated);\n+  }\n+\n+  /* Compare wrapper used by qsort method.  */\n+  static int compare (const void *first, const void *second)\n+  {\n+    typedef std::pair<mem_location *, mem_usage *> mem_pair_t;\n+\n+    const mem_pair_t f = *(const mem_pair_t *)first;\n+    const mem_pair_t s = *(const mem_pair_t *)second;\n+\n+    return (*f.second) < (*s.second);\n+  }\n+\n+  /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n+  inline void dump (mem_location *loc, mem_usage &total) const\n+  {\n+    char s[4096];\n+    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n+\t     loc->m_line, loc->m_function);\n+\n+    s[48] = '\\0';\n+\n+    fprintf (stderr, \"%-48s %10li:%5.1f%%%10li%10li:%5.1f%%%10s\\n\", s,\n+\t     (long)m_allocated, get_percent (m_allocated, total.m_allocated),\n+\t     (long)m_peak, (long)m_times,\n+\t     get_percent (m_times, total.m_times), loc->m_ggc ? \"ggc\" : \"heap\");\n+  }\n+\n+  /* Dump footer.  */\n+  inline void dump_footer ()\n+  {\n+    print_dash_line ();\n+    fprintf (stderr, \"%s%54li%27li\\n\", \"Total\", (long)m_allocated,\n+\t     (long)m_times);\n+    print_dash_line ();\n+  }\n+\n+  /* Return fraction of NOMINATOR and DENOMINATOR in percent.  */\n+  static inline float get_percent (size_t nominator, size_t denominator)\n+  {\n+    return denominator == 0 ? 0.0f : nominator * 100.0 / denominator;\n+  }\n+\n+  /* Print line made of dashes.  */\n+  static inline void print_dash_line ()\n+  {\n+    fprintf (stderr, \"%s\\n\", std::string (128, '-').c_str ());\n+  }\n+\n+  /* Dump header with NAME.  */\n+  static inline void dump_header (const char *name)\n+  {\n+    fprintf (stderr, \"%-48s %11s%16s%10s%17s\\n\", name, \"Leak\", \"Peak\",\n+\t     \"Times\", \"Type\");\n+    print_dash_line ();\n+  }\n+\n+  /* Current number of allocated bytes.  */\n+  size_t m_allocated;\n+  /* Number of allocations.  */\n+  size_t m_times;\n+  /* Peak allocation in bytes.  */\n+  size_t m_peak;\n+};\n+\n+/* Memory usage pair that connectes memory usage and number\n+   of allocated bytes.  */\n+template <class T>\n+struct mem_usage_pair\n+{\n+  mem_usage_pair (T *usage_, size_t allocated_): usage (usage_),\n+  allocated (allocated_) {}\n+\n+  T *usage;\n+  size_t allocated;\n+};\n+\n+/* Memory allocation description.  */\n+template <class T>\n+class mem_alloc_description\n+{\n+public:\n+  struct mem_alloc_hashmap_traits: default_hashmap_traits\n+  {\n+    static hashval_t\n+    hash (const mem_location *l)\n+    {\n+\tinchash::hash hstate;\n+\n+\thstate.add_ptr ((const void *)l->m_filename);\n+\thstate.add_ptr (l->m_function);\n+\thstate.add_int (l->m_line);\n+\n+\treturn hstate.end ();\n+    }\n+\n+    static bool\n+    equal_keys (const mem_location *l1, const mem_location *l2)\n+    {\n+      return l1->m_filename == l2->m_filename\n+\t&& l1->m_function == l2->m_function\n+\t&& l1->m_line == l2->m_line;\n+    }\n+  };\n+\n+  /* Internal class type definitions.  */\n+  typedef hash_map <mem_location *, T *, mem_alloc_hashmap_traits> mem_map_t;\n+  typedef hash_map <const void *, mem_usage_pair<T>, default_hashmap_traits>\n+    reverse_mem_map_t;\n+  typedef hash_map <const void *, std::pair<T *, size_t> > reverse_object_map_t;\n+  typedef std::pair <mem_location *, T *> mem_list_t;\n+\n+  /* Default contructor.  */\n+  mem_alloc_description ();\n+\n+  /* Default destructor.  */\n+  ~mem_alloc_description ();\n+\n+  /* Returns true if instance PTR is registered by the memory description.  */\n+  bool contains_descriptor_for_instance (const void *ptr);\n+\n+  /* Return descriptor for instance PTR.  */\n+  T *get_descriptor_for_instance (const void *ptr);\n+\n+  /* Register memory allocation descriptor for container PTR. ORIGIN identifies\n+     type of container and GGC identifes if the allocation is handled in GGC\n+     memory. Each location is identified by file NAME, LINE in source code and\n+     FUNCTION name.  */\n+  T *register_descriptor (const void *ptr, mem_alloc_origin origin,\n+\t\t\t  bool ggc, const char *name, int line,\n+\t\t\t  const char *function);\n+\n+  /* Register instance overhead identified by PTR pointer. Allocation takes\n+     SIZE bytes.  */\n+  T *register_instance_overhead (size_t size, const void *ptr);\n+\n+  /* For containers (and GGC) where we want to track every instance object,\n+     we register allocation of SIZE bytes, identified by PTR pointer, belonging\n+     to USAGE descriptor.  */\n+  void register_object_overhead (T *usage, size_t size, const void *ptr);\n+\n+  /* Release PTR pointer of SIZE bytes. If REMOVE_FROM_MAP is set to true,\n+     remove the instance from reverse map.  */\n+  void release_instance_overhead (void *ptr, size_t size,\n+\t\t\t\t  bool remove_from_map = false);\n+\n+  /* Release intance object identified by PTR pointer.  */\n+  void release_object_overhead (void *ptr);\n+\n+  /* Get sum value for ORIGIN type of allocation for the descriptor.  */\n+  T get_sum (mem_alloc_origin origin);\n+\n+  /* Get all tracked instances registered by the description. Items\n+     are filtered by ORIGIN type, LENGTH is return value where we register\n+     the number of elements in the list. If we want to process custom order,\n+     CMP comparator can be provided.  */\n+  mem_list_t *get_list (mem_alloc_origin origin, unsigned *length,\n+\t\t\tint (*cmp) (const void *first, const void *second)\n+\t\t\t  = NULL);\n+\n+  /* Dump all tracked instances of type ORIGIN. If we want to process custom\n+     order, CMP comparator can be provided.  */\n+  void dump (mem_alloc_origin origin,\n+\t     int (*cmp) (const void *first, const void *second) = NULL);\n+\n+  /* Reverse object map used for every object allocation mapping.  */\n+  reverse_object_map_t *m_reverse_object_map;\n+\n+private:\n+  /* Register overhead of SIZE bytes of ORIGIN type. PTR pointer is allocated\n+     in NAME source file, at LINE in source code, in FUNCTION.  */\n+  T *register_overhead (size_t size, mem_alloc_origin origin, const char *name,\n+\t\t\tint line, const char *function, const void *ptr);\n+\n+  /* Allocation location coupled to the description.  */\n+  mem_location m_location;\n+\n+  /* Location to usage mapping.  */\n+  mem_map_t *m_map;\n+\n+  /* Reverse pointer to usage mapping.  */\n+  reverse_mem_map_t *m_reverse_map;\n+};\n+\n+#include \"hash-map.h\"\n+\n+/* Returns true if instance PTR is registered by the memory description.  */\n+\n+template <class T>\n+inline bool\n+mem_alloc_description<T>::contains_descriptor_for_instance (const void *ptr)\n+{\n+  return m_reverse_map->get (ptr);\n+}\n+\n+/* Return descriptor for instance PTR.  */\n+\n+template <class T>\n+inline T*\n+mem_alloc_description<T>::get_descriptor_for_instance (const void *ptr)\n+{\n+  return m_reverse_map->get (ptr) ? (*m_reverse_map->get (ptr)).usage : NULL;\n+}\n+\n+/* Register memory allocation descriptor for container PTR. ORIGIN identifies\n+   type of container and GGC identifes if the allocation is handled in GGC\n+   memory. Each location is identified by file NAME, LINE in source code and\n+   FUNCTION name.  */\n+\n+template <class T>\n+inline T*\n+mem_alloc_description<T>::register_descriptor (const void *ptr,\n+\t\t\t\t\t       mem_alloc_origin origin,\n+\t\t\t\t\t       bool ggc,\n+\t\t\t\t\t       const char *filename,\n+\t\t\t\t\t       int line,\n+\t\t\t\t\t       const char *function)\n+{\n+  mem_location *l = new mem_location (filename, function, line, origin, ggc);\n+  T *usage = NULL;\n+\n+  T **slot = m_map->get (l);\n+  if (slot)\n+    {\n+      delete l;\n+      usage = *slot;\n+    }\n+  else\n+    {\n+      usage = new T ();\n+      m_map->put (l, usage);\n+    }\n+\n+  if (!m_reverse_map->get (ptr))\n+    m_reverse_map->put (ptr, mem_usage_pair<T> (usage, 0));\n+\n+  return usage;\n+}\n+\n+/* Register instance overhead identified by PTR pointer. Allocation takes\n+   SIZE bytes.  */\n+\n+template <class T>\n+inline T*\n+mem_alloc_description<T>::register_instance_overhead (size_t size,\n+\t\t\t\t\t\t      const void *ptr)\n+{\n+  mem_usage_pair <T> *slot = m_reverse_map->get (ptr);\n+  if (!slot)\n+    {\n+      /* Due to PCH, it can really happen.  */\n+      return NULL;\n+    }\n+\n+  T *usage = (*slot).usage;\n+  usage->register_overhead (size);\n+\n+  return usage;\n+}\n+\n+/* For containers (and GGC) where we want to track every instance object,\n+   we register allocation of SIZE bytes, identified by PTR pointer, belonging\n+   to USAGE descriptor.  */\n+\n+template <class T>\n+void\n+mem_alloc_description<T>::register_object_overhead (T *usage, size_t size,\n+\t\t\t\t\t\t    const void *ptr)\n+{\n+  /* In case of GGC, it is possible to have already occupied the memory\n+     location.  */\n+  m_reverse_object_map->put (ptr, std::pair<T *, size_t> (usage, size));\n+}\n+\n+/* Register overhead of SIZE bytes of ORIGIN type. PTR pointer is allocated\n+   in NAME source file, at LINE in source code, in FUNCTION.  */\n+\n+template <class T>\n+inline T*\n+mem_alloc_description<T>::register_overhead (size_t size,\n+\t\t\t\t\t     mem_alloc_origin origin,\n+\t\t\t\t\t     const char *filename,\n+\t\t\t\t\t     int line,\n+\t\t\t\t\t     const char *function,\n+\t\t\t\t\t     const void *ptr)\n+{\n+  T *usage = register_descriptor (ptr, origin, filename, line, function);\n+  usage->register_overhead (size);\n+\n+  return usage;\n+}\n+\n+/* Release PTR pointer of SIZE bytes.  */\n+\n+template <class T>\n+inline void\n+mem_alloc_description<T>::release_instance_overhead (void *ptr, size_t size,\n+\t\t\t\t\t\t     bool remove_from_map)\n+{\n+  mem_usage_pair<T> *slot = m_reverse_map->get (ptr);\n+\n+  if (!slot)\n+    {\n+      /* Due to PCH, it can really happen.  */\n+      return;\n+    }\n+\n+  mem_usage_pair<T> usage_pair = *slot;\n+  usage_pair.usage->release_overhead (size);\n+\n+  if (remove_from_map)\n+    m_reverse_map->remove (ptr);\n+}\n+\n+/* Release intance object identified by PTR pointer.  */\n+\n+template <class T>\n+inline void\n+mem_alloc_description<T>::release_object_overhead (void *ptr)\n+{\n+  std::pair <T *, size_t> *entry = m_reverse_object_map->get (ptr);\n+  if (entry)\n+    {\n+      entry->first->release_overhead (entry->second);\n+      m_reverse_object_map->remove (ptr);\n+    }\n+}\n+\n+/* Default contructor.  */\n+\n+template <class T>\n+inline\n+mem_alloc_description<T>::mem_alloc_description ()\n+{\n+  m_map = new mem_map_t (13, false, false);\n+  m_reverse_map = new reverse_mem_map_t (13, false, false);\n+  m_reverse_object_map = new reverse_object_map_t (13, false, false);\n+}\n+\n+/* Default destructor.  */\n+\n+template <class T>\n+inline\n+mem_alloc_description<T>::~mem_alloc_description ()\n+{\n+  for (typename mem_map_t::iterator it = m_map->begin (); it != m_map->end ();\n+       ++it)\n+    {\n+      delete (*it).first;\n+      delete (*it).second;\n+    }\n+\n+  delete m_map;\n+  delete m_reverse_map;\n+  delete m_reverse_object_map;\n+}\n+\n+/* Get all tracked instances registered by the description. Items are filtered\n+   by ORIGIN type, LENGTH is return value where we register the number of\n+   elements in the list. If we want to process custom order, CMP comparator\n+   can be provided.  */\n+\n+template <class T>\n+inline\n+typename mem_alloc_description<T>::mem_list_t *\n+mem_alloc_description<T>::get_list (mem_alloc_origin origin, unsigned *length,\n+\t\t\tint (*cmp) (const void *first, const void *second))\n+{\n+  /* vec data structure is not used because all vectors generate memory\n+     allocation info a it would create a cycle.  */\n+  size_t element_size = sizeof (mem_list_t);\n+  mem_list_t *list = XCNEWVEC (mem_list_t, m_map->elements ());\n+  unsigned i = 0;\n+\n+  for (typename mem_map_t::iterator it = m_map->begin (); it != m_map->end ();\n+       ++it)\n+    if ((*it).first->m_origin == origin)\n+      list[i++] = std::pair<mem_location*, T*> (*it);\n+\n+  qsort (list, i, element_size, cmp == NULL ? T::compare : cmp);\n+  *length = i;\n+\n+  return list;\n+}\n+\n+/* Get sum value for ORIGIN type of allocation for the descriptor.  */\n+\n+template <class T>\n+inline T\n+mem_alloc_description<T>::get_sum (mem_alloc_origin origin)\n+{\n+  unsigned length;\n+  mem_list_t *list = get_list (origin, &length);\n+  T sum;\n+\n+  for (unsigned i = 0; i < length; i++)\n+    sum = sum + *list[i].second;\n+\n+  XDELETEVEC (list);\n+\n+  return sum;\n+}\n+\n+/* Dump all tracked instances of type ORIGIN. If we want to process custom\n+   order, CMP comparator can be provided.  */\n+\n+template <class T>\n+inline void\n+mem_alloc_description<T>::dump (mem_alloc_origin origin,\n+\t\t\t\tint (*cmp) (const void *first,\n+\t\t\t\t\t    const void *second))\n+{\n+  unsigned length;\n+\n+  fprintf (stderr, \"\\n\");\n+\n+  mem_list_t *list = get_list (origin, &length, cmp);\n+  T total = get_sum (origin);\n+\n+  T::dump_header (mem_location::get_origin_name (origin));\n+  for (int i = length - 1; i >= 0; i--)\n+    list[i].second->dump (list[i].first, total);\n+\n+  total.dump_footer ();\n+\n+  XDELETEVEC (list);\n+\n+  fprintf (stderr, \"\\n\");\n+}\n+\n+#endif // GCC_MEM_STATS_H"}, {"sha": "c274547c85a5d87b68558034a743c40162f2cb22", "filename": "gcc/sese.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fsese.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fsese.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsese.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -22,6 +22,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"mem-stats.h\"\n #include \"hash-map.h\"\n #include \"hash-set.h\"\n #include \"machmode.h\""}, {"sha": "3b57b482c3d93024ea8d8e4289a1f51dbdab7ac2", "filename": "gcc/toplev.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -1963,6 +1963,7 @@ dump_memory_report (bool final)\n   dump_rtx_statistics ();\n   dump_alloc_pool_statistics ();\n   dump_bitmap_statistics ();\n+  dump_hash_table_loc_statistics ();\n   dump_vec_loc_statistics ();\n   dump_ggc_loc_statistics (final);\n   dump_alias_stats (stderr);"}, {"sha": "d799751da30796e24a1f2079eb0b74c84ac8aea5", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -74,6 +74,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n+#include \"mem-stats.h\"\n #include \"hash-map.h\"\n #include \"hash-table.h\"\n #include \"alloc-pool.h\""}, {"sha": "d4a7a0229beaca1fd5d3958c2759f86450a4e0de", "filename": "gcc/vec.c", "status": "modified", "additions": 94, "deletions": 184, "changes": 278, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -33,6 +33,9 @@ along with GCC; see the file COPYING3.  If not see\n #include \"vec.h\"\n #include \"diagnostic-core.h\"\n #include \"hashtab.h\"\n+#include \"mem-stats.h\"\n+#include \"hash-map.h\"\n+#include \"mem-stats.h\"\n \n /* vNULL is an empty type with a template cast operation that returns\n    a zero-initialized vec<T, A, L> instance.  Use this when you want\n@@ -44,129 +47,110 @@ along with GCC; see the file COPYING3.  If not see\n    they cannot have ctors/dtors.  */\n vnull vNULL;\n \n-\n-/* Store information about each particular vector.  */\n-struct vec_descriptor\n-{\n-  const char *function;\n-  const char *file;\n-  int line;\n-  size_t allocated;\n-  size_t times;\n-  size_t peak;\n-};\n-\n-\n-/* Hashtable mapping vec addresses to descriptors.  */\n-static htab_t vec_desc_hash;\n-\n-/* Hashtable helpers.  */\n-static hashval_t\n-hash_descriptor (const void *p)\n-{\n-  const struct vec_descriptor *const d =\n-    (const struct vec_descriptor *) p;\n-  return htab_hash_pointer (d->file) + d->line;\n-}\n-static int\n-eq_descriptor (const void *p1, const void *p2)\n+/* Vector memory usage.  */\n+struct vec_usage: public mem_usage\n {\n-  const struct vec_descriptor *const d = (const struct vec_descriptor *) p1;\n-  const struct vec_descriptor *const l = (const struct vec_descriptor *) p2;\n-  return d->file == l->file && d->function == l->function && d->line == l->line;\n-}\n-\n-/* Hashtable converting address of allocated field to loc descriptor.  */\n-static htab_t ptr_hash;\n-struct ptr_hash_entry\n-{\n-  void *ptr;\n-  struct vec_descriptor *loc;\n-  size_t allocated;\n+  /* Default constructor.  */\n+  vec_usage (): m_items (0), m_items_peak (0) {}\n+\n+  /* Constructor.  */\n+  vec_usage (size_t allocated, size_t times, size_t peak,\n+\t     size_t items, size_t items_peak)\n+    : mem_usage (allocated, times, peak),\n+    m_items (items), m_items_peak (items_peak) {}\n+\n+  /* Comparison operator.  */\n+  inline bool operator< (const vec_usage &second) const\n+  {\n+    return (m_allocated == second.m_allocated ?\n+\t    (m_peak == second.m_peak ? m_times < second.m_times\n+\t     : m_peak < second.m_peak) : m_allocated < second.m_allocated);\n+  }\n+\n+  /* Sum the usage with SECOND usage.  */\n+  vec_usage operator+ (const vec_usage &second)\n+  {\n+    return vec_usage (m_allocated + second.m_allocated,\n+\t\t      m_times + second.m_times,\n+\t\t      m_peak + second.m_peak,\n+\t\t      m_items + second.m_items,\n+\t\t      m_items_peak + second.m_items_peak);\n+  }\n+\n+  /* Dump usage coupled to LOC location, where TOTAL is sum of all rows.  */\n+  inline void dump (mem_location *loc, mem_usage &total) const\n+  {\n+    char s[4096];\n+    sprintf (s, \"%s:%i (%s)\", loc->get_trimmed_filename (),\n+\t     loc->m_line, loc->m_function);\n+\n+    s[48] = '\\0';\n+\n+    fprintf (stderr, \"%-48s %10li:%4.1f%%%10li%10li:%4.1f%%%11li%11li\\n\", s,\n+\t     (long)m_allocated, m_allocated * 100.0 / total.m_allocated,\n+\t     (long)m_peak, (long)m_times, m_times * 100.0 / total.m_times,\n+\t     (long)m_items, (long)m_items_peak);\n+  }\n+\n+  /* Dump footer.  */\n+  inline void dump_footer ()\n+  {\n+    print_dash_line ();\n+    fprintf (stderr, \"%s%55li%25li%17li\\n\", \"Total\", (long)m_allocated,\n+\t     (long)m_times, (long)m_items);\n+    print_dash_line ();\n+  }\n+\n+  /* Dump header with NAME.  */\n+  static inline void dump_header (const char *name)\n+  {\n+    fprintf (stderr, \"%-48s %11s%15s%10s%17s%11s\\n\", name, \"Leak\", \"Peak\",\n+\t     \"Times\", \"Leak items\", \"Peak items\");\n+    print_dash_line ();\n+  }\n+\n+  /* Compare wrapper used by qsort method.  */\n+  static int compare (const void *first, const void *second)\n+  {\n+    typedef std::pair<mem_location *, vec_usage *> mem_pair_t;\n+\n+    const mem_pair_t f = *(const mem_pair_t *)first;\n+    const mem_pair_t s = *(const mem_pair_t *)second;\n+\n+    return (*f.second) < (*s.second);\n+  }\n+\n+  /* Current number of items allocated.  */\n+  size_t m_items;\n+  /* Peak value of number of allocated items.  */\n+  size_t m_items_peak;\n };\n \n-/* Hash table helpers functions.  */\n-static hashval_t\n-hash_ptr (const void *p)\n-{\n-  const struct ptr_hash_entry *const d = (const struct ptr_hash_entry *) p;\n-\n-  return htab_hash_pointer (d->ptr);\n-}\n-\n-static int\n-eq_ptr (const void *p1, const void *p2)\n-{\n-  const struct ptr_hash_entry *const p = (const struct ptr_hash_entry *) p1;\n-\n-  return (p->ptr == p2);\n-}\n-\n-/* Return descriptor for given call site, create new one if needed.  */\n-static struct vec_descriptor *\n-vec_descriptor (const char *name, int line, const char *function)\n-{\n-  struct vec_descriptor loc;\n-  struct vec_descriptor **slot;\n-\n-  loc.file = name;\n-  loc.line = line;\n-  loc.function = function;\n-  if (!vec_desc_hash)\n-    vec_desc_hash = htab_create (10, hash_descriptor, eq_descriptor, NULL);\n-\n-  slot = (struct vec_descriptor **) htab_find_slot (vec_desc_hash, &loc,\n-\t\t\t\t\t\t    INSERT);\n-  if (*slot)\n-    return *slot;\n-  *slot = XCNEW (struct vec_descriptor);\n-  (*slot)->file = name;\n-  (*slot)->line = line;\n-  (*slot)->function = function;\n-  (*slot)->allocated = 0;\n-  (*slot)->peak = 0;\n-  return *slot;\n-}\n+/* Vector memory description.  */\n+static mem_alloc_description <vec_usage> vec_mem_desc;\n \n /* Account the overhead.  */\n \n void\n-vec_prefix::register_overhead (size_t size, const char *name, int line,\n-\t\t\t       const char *function)\n+vec_prefix::register_overhead (void *ptr, size_t size, size_t elements\n+\t\t\t       MEM_STAT_DECL)\n {\n-  struct vec_descriptor *loc = vec_descriptor (name, line, function);\n-  struct ptr_hash_entry *p = XNEW (struct ptr_hash_entry);\n-  PTR *slot;\n-\n-  p->ptr = this;\n-  p->loc = loc;\n-  p->allocated = size;\n-  if (!ptr_hash)\n-    ptr_hash = htab_create (10, hash_ptr, eq_ptr, NULL);\n-  slot = htab_find_slot_with_hash (ptr_hash, this, htab_hash_pointer (this),\n-\t\t\t\t   INSERT);\n-  gcc_assert (!*slot);\n-  *slot = p;\n-\n-  loc->allocated += size;\n-  if (loc->peak < loc->allocated)\n-    loc->peak += loc->allocated;\n-  loc->times++;\n+  vec_mem_desc.register_descriptor (ptr, VEC, false FINAL_PASS_MEM_STAT);\n+  vec_usage *usage = vec_mem_desc.register_instance_overhead (size, ptr);\n+  usage->m_items += elements;\n+  if (usage->m_items_peak < usage->m_items)\n+    usage->m_items_peak = usage->m_items;\n }\n \n-\n /* Notice that the memory allocated for the vector has been freed.  */\n \n void\n-vec_prefix::release_overhead (void)\n+vec_prefix::release_overhead (void *ptr, size_t size, bool in_dtor\n+\t\t\t      MEM_STAT_DECL)\n {\n-  PTR *slot = htab_find_slot_with_hash (ptr_hash, this,\n-\t\t\t\t\thtab_hash_pointer (this),\n-\t\t\t\t\tNO_INSERT);\n-  struct ptr_hash_entry *p = (struct ptr_hash_entry *) *slot;\n-  p->loc->allocated -= p->allocated;\n-  htab_clear_slot (ptr_hash, slot);\n-  ::free (p);\n+  if (!vec_mem_desc.contains_descriptor_for_instance (ptr))\n+    vec_mem_desc.register_descriptor (ptr, VEC, false FINAL_PASS_MEM_STAT);\n+  vec_mem_desc.release_instance_overhead (ptr, size, in_dtor);\n }\n \n \n@@ -195,84 +179,10 @@ vec_prefix::calculate_allocation_1 (unsigned alloc, unsigned desired)\n   return alloc;\n }\n \n-\n-/* Helper for qsort; sort descriptors by amount of memory consumed.  */\n-\n-static int\n-cmp_statistic (const void *loc1, const void *loc2)\n-{\n-  const struct vec_descriptor *const l1 =\n-    *(const struct vec_descriptor *const *) loc1;\n-  const struct vec_descriptor *const l2 =\n-    *(const struct vec_descriptor *const *) loc2;\n-  long diff;\n-  diff = l1->allocated - l2->allocated;\n-  if (!diff)\n-    diff = l1->peak - l2->peak;\n-  if (!diff)\n-    diff = l1->times - l2->times;\n-  return diff > 0 ? 1 : diff < 0 ? -1 : 0;\n-}\n-\n-\n-/* Collect array of the descriptors from hashtable.  */\n-\n-static struct vec_descriptor **loc_array;\n-static int\n-add_statistics (void **slot, void *b)\n-{\n-  int *n = (int *)b;\n-  loc_array[*n] = (struct vec_descriptor *) *slot;\n-  (*n)++;\n-  return 1;\n-}\n-\n /* Dump per-site memory statistics.  */\n \n void\n dump_vec_loc_statistics (void)\n {\n-  int nentries = 0;\n-  char s[4096];\n-  size_t allocated = 0;\n-  size_t times = 0;\n-  int i;\n-\n-  if (! GATHER_STATISTICS)\n-    return;\n-\n-  loc_array = XCNEWVEC (struct vec_descriptor *, vec_desc_hash->n_elements);\n-  fprintf (stderr, \"Heap vectors:\\n\");\n-  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n-\t   \"source location\", \"Leak\", \"Peak\", \"Times\");\n-  fprintf (stderr, \"-------------------------------------------------------\\n\");\n-  htab_traverse (vec_desc_hash, add_statistics, &nentries);\n-  qsort (loc_array, nentries, sizeof (*loc_array), cmp_statistic);\n-  for (i = 0; i < nentries; i++)\n-    {\n-      struct vec_descriptor *d = loc_array[i];\n-      allocated += d->allocated;\n-      times += d->times;\n-    }\n-  for (i = 0; i < nentries; i++)\n-    {\n-      struct vec_descriptor *d = loc_array[i];\n-      const char *s1 = d->file;\n-      const char *s2;\n-      while ((s2 = strstr (s1, \"gcc/\")))\n-\ts1 = s2 + 4;\n-      sprintf (s, \"%s:%i (%s)\", s1, d->line, d->function);\n-      s[48] = 0;\n-      fprintf (stderr, \"%-48s %10li:%4.1f%% %10li      %10li:%4.1f%% \\n\", s,\n-\t       (long)d->allocated,\n-\t       (d->allocated) * 100.0 / allocated,\n-\t       (long)d->peak,\n-\t       (long)d->times,\n-\t       (d->times) * 100.0 / times);\n-    }\n-  fprintf (stderr, \"%-48s %10ld                        %10ld\\n\",\n-\t   \"Total\", (long)allocated, (long)times);\n-  fprintf (stderr, \"\\n%-48s %10s       %10s       %10s\\n\",\n-\t   \"source location\", \"Leak\", \"Peak\", \"Times\");\n-  fprintf (stderr, \"-------------------------------------------------------\\n\");\n+  vec_mem_desc.dump (VEC);\n }"}, {"sha": "7b9697922ad6ebec924804c4c125e3b46677299e", "filename": "gcc/vec.h", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=2d44c7dea7c8d2917eec28a5e08e8f405aad8c3e", "patch": "@@ -51,7 +51,7 @@ along with GCC; see the file COPYING3.  If not see\n \n   extern void ggc_free (void *);\n   extern size_t ggc_round_alloc_size (size_t requested_size);\n-  extern void *ggc_realloc (void *, size_t CXX_MEM_STAT_INFO);\n+  extern void *ggc_realloc (void *, size_t MEM_STAT_DECL);\n #  endif  // GCC_GGC_H\n #endif\t// VEC_GC_ENABLED\n \n@@ -206,6 +206,8 @@ along with GCC; see the file COPYING3.  If not see\n /* Support function for statistics.  */\n extern void dump_vec_loc_statistics (void);\n \n+/* Hashtable mapping vec addresses to descriptors.  */\n+extern htab_t vec_mem_usage_hash;\n \n /* Control data for vectors.  This contains the number of allocated\n    and used slots inside a vector.  */\n@@ -216,8 +218,8 @@ struct vec_prefix\n \t     compilers that have stricter notions of PODness for types.  */\n \n   /* Memory allocation support routines in vec.c.  */\n-  void register_overhead (size_t, const char *, int, const char *);\n-  void release_overhead (void);\n+  void register_overhead (void *, size_t, size_t CXX_MEM_STAT_INFO);\n+  void release_overhead (void *, size_t, bool CXX_MEM_STAT_INFO);\n   static unsigned calculate_allocation (vec_prefix *, unsigned, bool);\n   static unsigned calculate_allocation_1 (unsigned, unsigned);\n \n@@ -303,15 +305,15 @@ va_heap::reserve (vec<T, va_heap, vl_embed> *&v, unsigned reserve, bool exact\n   gcc_checking_assert (alloc);\n \n   if (GATHER_STATISTICS && v)\n-    v->m_vecpfx.release_overhead ();\n+    v->m_vecpfx.release_overhead (v, v->allocated (), false);\n \n   size_t size = vec<T, va_heap, vl_embed>::embedded_size (alloc);\n   unsigned nelem = v ? v->length () : 0;\n   v = static_cast <vec<T, va_heap, vl_embed> *> (xrealloc (v, size));\n   v->embedded_init (alloc, nelem);\n \n   if (GATHER_STATISTICS)\n-    v->m_vecpfx.register_overhead (size FINAL_PASS_MEM_STAT);\n+    v->m_vecpfx.register_overhead (v, alloc, nelem PASS_MEM_STAT);\n }\n \n \n@@ -325,7 +327,7 @@ va_heap::release (vec<T, va_heap, vl_embed> *&v)\n     return;\n \n   if (GATHER_STATISTICS)\n-    v->m_vecpfx.release_overhead ();\n+    v->m_vecpfx.release_overhead (v, v->allocated (), true);\n   ::free (v);\n   v = NULL;\n }"}]}