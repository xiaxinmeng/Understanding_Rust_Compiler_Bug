{"sha": "ccf4d5128446c504efe2133f907f8b13181b0f3c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2NmNGQ1MTI4NDQ2YzUwNGVmZTIxMzNmOTA3ZjhiMTMxODFiMGYzYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2003-01-29T16:50:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2003-01-29T16:50:34Z"}, "message": "arm.c (arm_legtimize_address): New function.\n\n* arm.c (arm_legtimize_address): New function.\n* arm-protos.h (arm_legtimize_address): Add prototype.\n* arm.h (ARM_LEGITIMIZE_ADDRESS): Use arm_legitimize_address.\n(LEGITIMIZE_ADDRESS, THUMB_LEGITIMIZE_ADDRESS): Wrap with\ndo ... while (0)\n\nFrom-SVN: r62091", "tree": {"sha": "71fd9080e958d30ae437a22c2911f8676957654e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71fd9080e958d30ae437a22c2911f8676957654e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ccf4d5128446c504efe2133f907f8b13181b0f3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf4d5128446c504efe2133f907f8b13181b0f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ccf4d5128446c504efe2133f907f8b13181b0f3c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ccf4d5128446c504efe2133f907f8b13181b0f3c/comments", "author": null, "committer": null, "parents": [{"sha": "0680c8fb906deed9c3c90b25324c65056d826912", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0680c8fb906deed9c3c90b25324c65056d826912", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0680c8fb906deed9c3c90b25324c65056d826912"}], "stats": {"total": 200, "additions": 115, "deletions": 85}, "files": [{"sha": "744f12683d5f54051024bb2f3b6085e5d042f400", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ccf4d5128446c504efe2133f907f8b13181b0f3c", "patch": "@@ -1,3 +1,11 @@\n+2003-01-29  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\t* arm.c (arm_legtimize_address): New function.\n+\t* arm-protos.h (arm_legtimize_address): Add prototype.\n+\t* arm.h (ARM_LEGITIMIZE_ADDRESS): Use arm_legitimize_address.\n+\t(LEGITIMIZE_ADDRESS, THUMB_LEGITIMIZE_ADDRESS): Wrap with\n+\tdo ... while (0)\n+\n 2003-01-29\tJoel Sherrill <joel@OARcorp.com>\n \n \t* gthr-rtems.h: Define __GTHREAD_MUTEX_INIT.  Apparently no code"}, {"sha": "6fce0ce391a212a5698b02c90fee3ec5d38a158e", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=ccf4d5128446c504efe2133f907f8b13181b0f3c", "patch": "@@ -57,6 +57,7 @@ extern int    thumb_legitimate_address_p PARAMS ((enum machine_mode, rtx,\n \t\t\t\t\t\t  int));\n extern int    thumb_legitimate_offset_p\tPARAMS ((enum machine_mode,\n \t\t\t\t\t\t HOST_WIDE_INT));\n+extern rtx    arm_legitimize_address\tPARAMS ((rtx, rtx, enum machine_mode));\n extern int    const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n extern int    neg_const_double_rtx_ok_for_fpu\tPARAMS ((rtx));\n "}, {"sha": "576d038a7281506cc449604b9c8af996e886ff14", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=ccf4d5128446c504efe2133f907f8b13181b0f3c", "patch": "@@ -2905,6 +2905,91 @@ thumb_legitimate_offset_p (mode, val)\n     }\n }\n \n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.  */\n+\n+rtx\n+arm_legitimize_address (x, orig_x, mode)\n+     rtx x;\n+     rtx orig_x;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (x) == PLUS)\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+\n+      if (CONSTANT_P (xop0) && !symbol_mentioned_p (xop0))\n+\txop0 = force_reg (SImode, xop0);\n+\n+      if (CONSTANT_P (xop1) && !symbol_mentioned_p (xop1))\n+\txop1 = force_reg (SImode, xop1);\n+\n+      if (ARM_BASE_REGISTER_RTX_P (xop0)\n+\t  && GET_CODE (xop1) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT n, low_n;\n+\t  rtx base_reg, val;\n+\t  n = INTVAL (xop1);\n+\n+\t  if (mode == DImode || (TARGET_SOFT_FLOAT && mode == DFmode))\n+\t    {\n+\t      low_n = n & 0x0f;\n+\t      n &= ~0x0f;\n+\t      if (low_n > 4)\n+\t\t{\n+\t\t  n += 16;\n+\t\t  low_n -= 16;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      low_n = ((mode) == TImode ? 0\n+\t\t       : n >= 0 ? (n & 0xfff) : -((-n) & 0xfff));\n+\t      n -= low_n;\n+\t    }\n+\n+\t  base_reg = gen_reg_rtx (SImode);\n+\t  val = force_operand (gen_rtx_PLUS (SImode, xop0,\n+\t\t\t\t\t     GEN_INT (n)), NULL_RTX);\n+\t  emit_move_insn (base_reg, val);\n+\t  x = (low_n == 0 ? base_reg\n+\t       : gen_rtx_PLUS (SImode, base_reg, GEN_INT (low_n)));\n+\t}\n+      else if (xop0 != XEXP (x, 0) || xop1 != XEXP (x, 1))\n+\tx = gen_rtx_PLUS (SImode, xop0, xop1);\n+    }\n+\n+  /* XXX We don't allow MINUS any more -- see comment in\n+     arm_legitimate_address_p ().  */\n+  else if (GET_CODE (x) == MINUS)\n+    {\n+      rtx xop0 = XEXP (x, 0);\n+      rtx xop1 = XEXP (x, 1);\n+\n+      if (CONSTANT_P (xop0))\n+\txop0 = force_reg (SImode, xop0);\n+\n+      if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\n+\txop1 = force_reg (SImode, xop1);\n+\n+      if (xop0 != XEXP (x, 0) || xop1 != XEXP (x, 1))\n+\tx = gen_rtx_MINUS (SImode, xop0, xop1);\n+    }\n+\n+  if (flag_pic)\n+    {\n+      /* We need to find and carefully transform any SYMBOL and LABEL\n+\t references; so go back to the original address expression.  */\n+      rtx new_x = legitimize_pic_address (orig_x, mode, NULL_RTX);\n+\n+      if (new_x != orig_x)\n+\tx = new_x;\n+    }\n+\n+  return x;\n+}\n+\n \f\n \n #define REG_OR_SUBREG_REG(X)\t\t\t\t\t\t\\"}, {"sha": "9f3420beb26cf324935fb76e57fe5a158ecca5b0", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 21, "deletions": 85, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ccf4d5128446c504efe2133f907f8b13181b0f3c/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=ccf4d5128446c504efe2133f907f8b13181b0f3c", "patch": "@@ -1964,92 +1964,28 @@ typedef struct\n \n \f\n /* Try machine-dependent ways of modifying an illegitimate address\n-   to be legitimate.  If we find one, return the new, valid address.\n-   This macro is used in only one place: `memory_address' in explow.c.\n-\n-   OLDX is the address as it was before break_out_memory_refs was called.\n-   In some cases it is useful to look at this to decide what needs to be done.\n-\n-   MODE and WIN are passed so that this macro can use\n-   GO_IF_LEGITIMATE_ADDRESS.\n-\n-   It is always safe for this macro to do nothing.  It exists to recognize\n-   opportunities to optimize the output.\n-\n-   On the ARM, try to convert [REG, #BIGCONST]\n-   into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n-   where VALIDCONST == 0 in case of TImode.  */\n-#define ARM_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t \\\n-{\t\t\t\t\t\t\t\t\t \\\n-  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (CONSTANT_P (xop0) && ! symbol_mentioned_p (xop0))\t\t \\\n-\txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n-      if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\t\t \\\n-\txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n-      if (ARM_BASE_REGISTER_RTX_P (xop0)\t\t\t\t \\\n-\t  && GET_CODE (xop1) == CONST_INT)\t\t\t\t \\\n-\t{\t\t\t\t\t\t\t\t \\\n-\t  HOST_WIDE_INT n, low_n;\t\t\t\t\t \\\n-\t  rtx base_reg, val;\t\t\t\t\t\t \\\n-\t  n = INTVAL (xop1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-\t  if (MODE == DImode || (TARGET_SOFT_FLOAT && MODE == DFmode))\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      low_n = n & 0x0f;\t\t\t\t\t\t \\\n-\t      n &= ~0x0f;\t\t\t\t\t\t \\\n-\t      if (low_n > 4)\t\t\t\t\t\t \\\n-\t\t{\t\t\t\t\t\t\t \\\n-\t\t  n += 16;\t\t\t\t\t\t \\\n-\t\t  low_n -= 16;\t\t\t\t\t\t \\\n-\t\t}\t\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  else\t\t\t\t\t\t\t\t \\\n-\t    {\t\t\t\t\t\t\t\t \\\n-\t      low_n = ((MODE) == TImode ? 0\t\t\t\t \\\n-\t\t       : n >= 0 ? (n & 0xfff) : -((-n) & 0xfff));\t \\\n-\t      n -= low_n;\t\t\t\t\t\t \\\n-\t    }\t\t\t\t\t\t\t\t \\\n-\t  base_reg = gen_reg_rtx (SImode);\t\t\t\t \\\n-\t  val = force_operand (gen_rtx_PLUS (SImode, xop0,\t\t \\\n-\t\t\t\t\t     GEN_INT (n)), NULL_RTX);\t \\\n-\t  emit_move_insn (base_reg, val);\t\t\t\t \\\n-\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t \\\n-\t\t : gen_rtx_PLUS (SImode, base_reg, GEN_INT (low_n)));\t \\\n-\t}\t\t\t\t\t\t\t\t \\\n-      else if (xop0 != XEXP (X, 0) || xop1 != XEXP (x, 1))\t\t \\\n-\t(X) = gen_rtx_PLUS (SImode, xop0, xop1);\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  else if (GET_CODE (X) == MINUS)\t\t\t\t\t \\\n-    {\t\t\t\t\t\t\t\t\t \\\n-      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n-      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n-\t\t\t\t\t\t\t\t\t \\\n-      if (CONSTANT_P (xop0))\t\t\t\t\t\t \\\n-\txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n-      if (CONSTANT_P (xop1) && ! symbol_mentioned_p (xop1))\t\t \\\n-\txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n-      if (xop0 != XEXP (X, 0) || xop1 != XEXP (X, 1))\t\t\t \\\n-\t(X) = gen_rtx_MINUS (SImode, xop0, xop1);\t\t\t \\\n-    }\t\t\t\t\t\t\t\t\t \\\n-  if (flag_pic)\t\t\t\t\t\t\t\t \\\n-    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\t \\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t \\\n-    goto WIN;\t\t\t\t\t\t\t\t \\\n-}\n+   to be legitimate.  If we find one, return the new, valid address.  */\n+#define ARM_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n+do {\t\t\t\t\t\t\t\\\n+  X = arm_legitimize_address (X, OLDX, MODE);\t\t\\\n+\t\t\t\t\t\t\t\\\n+  if (memory_address_p (MODE, X))\t\t\t\\\n+    goto WIN;\t\t\t\t\t\t\\\n+} while (0)\n \n-#define THUMB_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-  if (flag_pic)\t\t\t\t\t\t\\\n-    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\t\n-     \n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\\\n-  if (TARGET_ARM)\t\t\t\t\\\n-    ARM_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)\t\\\n-  else\t\t\t\t\t\t\\\n-    THUMB_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN)\n+#define THUMB_LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\\\n+do {\t\t\t\t\t\t\t\t\\\n+  if (flag_pic)\t\t\t\t\t\t\t\\\n+    (X) = legitimize_pic_address (OLDX, MODE, NULL_RTX);\t\\\n+} while (0)\n+\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\\\n+do {\t\t\t\t\t\t\t\\\n+  if (TARGET_ARM)\t\t\t\t\t\\\n+    ARM_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN);\t\\\n+  else\t\t\t\t\t\t\t\\\n+    THUMB_LEGITIMIZE_ADDRESS (X, OLDX, MODE, WIN);\t\\\n+} while (0)\n      \n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */"}]}