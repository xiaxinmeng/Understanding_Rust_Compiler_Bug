{"sha": "52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTJhN2ZiM2NkMzk2YTMwYmYzNzBkMjY3ZDljYTY4NWJiZDQzOTRjZA==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2013-10-29T01:01:52Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2013-10-29T01:01:52Z"}, "message": "Handle simple inheritance in gengtype\n\n\t* gengtype-parse.c (opts_have): Drop \"static\" so that\n\twe can use this from gengtype.c.\n\t* gengtype.c (set_gc_used_type): Mark any base class as used;\n\tupdate field traversal to visit inherited fields.\n\t(output_mangled_typename):  Convert references to classes within\n\tan inheritance hierarchy to reference the ultimate base class,\n\tsince only it will have gt_ functions.\n\t(get_string_option): New.\n\t(walk_subclasses): New.\n\t(walk_type): Treat GTY structs that have a \"desc\" as being the\n\troot of an inheritance hierarchy.  Generate a switch on it\n\twithin the marking function which walks all subclasses, adding\n\tcases for them via walk_subclasses.  For subclasses, visit all\n\tfields of the type (including inherited ones).\n\t(write_func_for_structure): Don't write fns for subclasses, only\n\tfor the ultimate base class within an inheritance hierarchy.\n\tSubclasses-marking will be handled by the base class marking\n\tfunctions.\n\t(write_types): Likewise.\n\t(write_local_func_for_structure): Likewise.\n\t(USED_BY_TYPED_GC_P): Emit allocators for subclasses that have\n\ta \"tag\" option (and are thus concrete subclasses).\n\t(write_root): Use the marker function for the ultimate base class.\n\t* gengtype.h (FOR_ALL_INHERITED_FIELDS): New.\n\t(opts_have): Add declaration.\n\nFrom-SVN: r204146", "tree": {"sha": "500792a83215ba241bd2dddaaebc624b38f6e335", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/500792a83215ba241bd2dddaaebc624b38f6e335"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a6137eb928a21241857e488a70d0dc0de2c4cd4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6137eb928a21241857e488a70d0dc0de2c4cd4f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6137eb928a21241857e488a70d0dc0de2c4cd4f"}], "stats": {"total": 140, "additions": 133, "deletions": 7}, "files": [{"sha": "3a391b091572b7d8cdece93494c36a31e9ed0c6c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "patch": "@@ -1,3 +1,31 @@\n+2013-10-29  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* gengtype-parse.c (opts_have): Drop \"static\" so that\n+\twe can use this from gengtype.c.\n+\t* gengtype.c (set_gc_used_type): Mark any base class as used;\n+\tupdate field traversal to visit inherited fields.\n+\t(output_mangled_typename):  Convert references to classes within\n+\tan inheritance hierarchy to reference the ultimate base class,\n+\tsince only it will have gt_ functions.\n+\t(get_string_option): New.\n+\t(walk_subclasses): New.\n+\t(walk_type): Treat GTY structs that have a \"desc\" as being the\n+\troot of an inheritance hierarchy.  Generate a switch on it\n+\twithin the marking function which walks all subclasses, adding\n+\tcases for them via walk_subclasses.  For subclasses, visit all\n+\tfields of the type (including inherited ones).\n+\t(write_func_for_structure): Don't write fns for subclasses, only\n+\tfor the ultimate base class within an inheritance hierarchy.\n+\tSubclasses-marking will be handled by the base class marking\n+\tfunctions.\n+\t(write_types): Likewise.\n+\t(write_local_func_for_structure): Likewise.\n+\t(USED_BY_TYPED_GC_P): Emit allocators for subclasses that have\n+\ta \"tag\" option (and are thus concrete subclasses).\n+\t(write_root): Use the marker function for the ultimate base class.\n+\t* gengtype.h (FOR_ALL_INHERITED_FIELDS): New.\n+\t(opts_have): Add declaration.\n+\n 2013-10-28  Vladimir Makarov  <vmakarov@redhat.com>\n \n \t* lra-spills.c (lra_final_code_change): Remove useless move insns"}, {"sha": "f480503f8f1b3644218261a63ed7635e28fdccb5", "filename": "gcc/gengtype-parse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-parse.c?ref=52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "patch": "@@ -793,7 +793,7 @@ struct_field_seq (void)\n \n /* Return true if OPTS contain the option named STR.  */\n \n-static bool\n+bool\n opts_have (options_p opts, const char *str)\n {\n   for (options_p opt = opts; opt; opt = opt->next)"}, {"sha": "31e0f998a03e8c80d8d2c440fe078b4865a74ed7", "filename": "gcc/gengtype.c", "status": "modified", "additions": 96, "deletions": 6, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "patch": "@@ -1532,7 +1532,11 @@ set_gc_used_type (type_p t, enum gc_used_enum level, type_p param[NUM_PARAM],\n \tprocess_gc_options (t->u.s.opt, level, &dummy, &dummy, &dummy, &dummy,\n \t\t\t    &dummy2);\n \n-\tfor (f = t->u.s.fields; f; f = f->next)\n+\tif (t->u.s.base_class)\n+\t  set_gc_used_type (t->u.s.base_class, level, param,\n+\t\t\t    allow_undefined_types);\n+\n+\tFOR_ALL_INHERITED_FIELDS(t, f)\n \t  {\n \t    int maybe_undef = 0;\n \t    int pass_param = 0;\n@@ -2547,6 +2551,11 @@ output_mangled_typename (outf_p of, const_type_p t)\n       case TYPE_LANG_STRUCT:\n       case TYPE_USER_STRUCT:\n \t{\n+\t  /* For references to classes within an inheritance hierarchy,\n+\t     only ever reference the ultimate base class, since only\n+\t     it will have gt_ functions.  */\n+\t  while (t->u.s.base_class)\n+\t    t = t->u.s.base_class;\n \t  const char *id_for_tag = filter_type_name (t->u.s.tag);\n \t  oprintf (of, \"%lu%s\", (unsigned long) strlen (id_for_tag),\n \t\t   id_for_tag);\n@@ -2609,6 +2618,44 @@ output_escaped_param (struct walk_type_data *d, const char *param,\n \t}\n }\n \n+const char *\n+get_string_option (options_p opt, const char *key)\n+{\n+  for (; opt; opt = opt->next)\n+    if (strcmp (opt->name, key) == 0)\n+      return opt->info.string;\n+  return NULL;\n+}\n+\n+static void\n+walk_subclasses (type_p base, struct walk_type_data *d)\n+{\n+  for (type_p sub = structures; sub != NULL; sub = sub->next)\n+    {\n+      if (sub->u.s.base_class == base)\n+\t{\n+\t  const char *type_tag = get_string_option (sub->u.s.opt, \"tag\");\n+\t  if (type_tag)\n+\t    {\n+\t      oprintf (d->of, \"%*scase %s:\\n\", d->indent, \"\", type_tag);\n+\t      d->indent += 2;\n+\t      oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n+\t      d->indent += 2;\n+\t      oprintf (d->of, \"%*s%s *sub = static_cast <%s *> (x);\\n\",\n+\t\t       d->indent, \"\", sub->u.s.tag, sub->u.s.tag);\n+\t      const char *old_val = d->val;\n+\t      d->val = \"(*sub)\";\n+\t      walk_type (sub, d);\n+\t      d->val = old_val;\n+\t      d->indent -= 2;\n+\t      oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t      oprintf (d->of, \"%*sbreak;\\n\", d->indent, \"\");\n+\t      d->indent -= 2;\n+\t    }\n+\t  walk_subclasses (sub, d);\n+\t}\n+    }\n+}\n \n /* Call D->PROCESS_FIELD for every field (or subfield) of D->VAL,\n    which is of type T.  Write code to D->OF to constrain execution (at\n@@ -2626,6 +2673,7 @@ walk_type (type_p t, struct walk_type_data *d)\n {\n   const char *length = NULL;\n   const char *desc = NULL;\n+  const char *type_tag = NULL;\n   int maybe_undef_p = 0;\n   int use_param_num = -1;\n   int use_params_p = 0;\n@@ -2654,7 +2702,7 @@ walk_type (type_p t, struct walk_type_data *d)\n     else if (strcmp (oo->name, \"dot\") == 0)\n       ;\n     else if (strcmp (oo->name, \"tag\") == 0)\n-      ;\n+      type_tag = oo->info.string;\n     else if (strcmp (oo->name, \"special\") == 0)\n       ;\n     else if (strcmp (oo->name, \"skip\") == 0)\n@@ -2973,8 +3021,18 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    d->indent += 2;\n \t    oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n \t  }\n+\telse if (desc)\n+\t  {\n+\t    oprintf (d->of, \"%*sswitch (\", d->indent, \"\");\n+\t    output_escaped_param (d, desc, \"desc\");\n+\t    oprintf (d->of, \")\\n\");\n+\t    d->indent += 2;\n+\t    oprintf (d->of, \"%*s{\\n\", d->indent, \"\");\n+\t    oprintf (d->of, \"%*scase %s:\\n\", d->indent, \"\", type_tag);\n+\t    d->indent += 2;\n+\t  }\n \n-\tfor (f = t->u.s.fields; f; f = f->next)\n+\tFOR_ALL_INHERITED_FIELDS (t, f)\n \t  {\n \t    options_p oo;\n \t    int skip_p = 0;\n@@ -3012,7 +3070,7 @@ walk_type (type_p t, struct walk_type_data *d)\n \t  }\n \tendcounter = d->counter;\n \n-\tfor (f = t->u.s.fields; f; f = f->next)\n+\tFOR_ALL_INHERITED_FIELDS (t, f)\n \t  {\n \t    options_p oo;\n \t    const char *dot = \".\";\n@@ -3114,11 +3172,26 @@ walk_type (type_p t, struct walk_type_data *d)\n \t    oprintf (d->of, \"%*sdefault:\\n\", d->indent, \"\");\n \t    oprintf (d->of, \"%*s  break;\\n\", d->indent, \"\");\n \t  }\n+\n+\tif (desc && !union_p)\n+\t  {\n+\t\toprintf (d->of, \"%*sbreak;\\n\", d->indent, \"\");\n+\t\td->indent -= 2;\n+          }\n \tif (union_p)\n \t  {\n \t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n \t    d->indent -= 2;\n \t  }\n+\telse if (desc)\n+\t  {\n+\t    /* Add cases to handle subclasses.  */\n+\t    walk_subclasses (t, d);\n+\n+\t    /* End of the switch statement */\n+\t    oprintf (d->of, \"%*s}\\n\", d->indent, \"\");\n+\t    d->indent -= 2;\n+\t  }\n \tif (any_length_seen)\n \t  {\n \t    d->indent -= 2;\n@@ -3464,6 +3537,11 @@ write_func_for_structure (type_p orig_s, type_p s, type_p *param,\n   options_p opt;\n   struct walk_type_data d;\n \n+  /* Don't write fns for subclasses, only for the ultimate base class\n+     within an inheritance hierarchy.  */\n+  if (s->u.s.base_class)\n+    return;\n+\n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_for_structure (s, param);\n   for (opt = s->u.s.opt; opt; opt = opt->next)\n@@ -3640,7 +3718,10 @@ write_types (outf_p output_header, type_p structures, type_p param_structs,\n      emitted afterwards.  This is needed in plugin mode.  */\n   oprintf (output_header, \"/* Macros and declarations.  */\\n\");\n   for (s = structures; s; s = s->next)\n-    if (s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n+    /* Do not emit handlers for derived classes; we only ever deal with\n+       the ultimate base class within an inheritance hierarchy.  */\n+    if ((s->gc_used == GC_POINTED_TO || s->gc_used == GC_MAYBE_POINTED_TO)\n+        && !s->u.s.base_class)\n       {\n \toptions_p opt;\n \n@@ -3945,6 +4026,11 @@ write_local_func_for_structure (const_type_p orig_s, type_p s, type_p *param)\n {\n   struct walk_type_data d;\n \n+  /* Don't write fns for subclasses, only for the ultimate base class\n+     within an inheritance hierarchy.  */\n+  if (s->u.s.base_class)\n+    return;\n+\n   memset (&d, 0, sizeof (d));\n   d.of = get_output_file_for_structure (s, param);\n   d.process_field = write_types_local_process_field;\n@@ -4089,7 +4175,9 @@ write_local (outf_p output_header, type_p structures, type_p param_structs)\n \t   || ((s)->gc_used == GC_MAYBE_POINTED_TO\t\t\t\\\n \t       && s->u.s.line.file != NULL)\t\t\t\t\\\n \t   || ((s)->gc_used == GC_USED\t\t\t\t\t\\\n-\t       && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))))))\n+\t       && strncmp (s->u.s.tag, \"anonymous\", strlen (\"anonymous\"))) \\\n+\t   || (s->u.s.base_class && opts_have (s->u.s.opt, \"tag\")))))\n+\n \n \n /* Might T contain any non-pointer elements?  */\n@@ -4373,6 +4461,8 @@ write_root (outf_p f, pair_p v, type_p type, const char *name, int has_length,\n \n \tif (!has_length && union_or_struct_p (tp))\n \t  {\n+\t    while (tp->u.s.base_class)\n+\t      tp = tp->u.s.base_class;\n \t    const char *id_for_tag = filter_type_name (tp->u.s.tag);\n \t    oprintf (f, \"    &gt_ggc_mx_%s,\\n\", id_for_tag);\n \t    if (emit_pch)"}, {"sha": "2d20bf98efb7b3c4dc2279026b70844abbade1af", "filename": "gcc/gengtype.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/52a7fb3cd396a30bf370d267d9ca685bbd4394cd/gcc%2Fgengtype.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.h?ref=52a7fb3cd396a30bf370d267d9ca685bbd4394cd", "patch": "@@ -506,4 +506,12 @@ void dbgprint_count_type_at (const char *, int, const char *, type_p);\n #define DBGPRINT_COUNT_TYPE(Msg,Ty) do{/*nodbgprint_count_type*/}while (0)\n #endif /*ENABLE_CHECKING */\n \n+#define FOR_ALL_INHERITED_FIELDS(TYPE, FIELD_VAR) \\\n+  for (type_p sub = (TYPE); sub; sub = sub->u.s.base_class) \\\n+    for (FIELD_VAR = sub->u.s.fields; FIELD_VAR; FIELD_VAR = FIELD_VAR->next)\n+\n+extern bool\n+opts_have (options_p opts, const char *str);\n+\n+\n #endif"}]}