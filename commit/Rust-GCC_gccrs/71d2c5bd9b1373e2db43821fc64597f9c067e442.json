{"sha": "71d2c5bd9b1373e2db43821fc64597f9c067e442", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFkMmM1YmQ5YjEzNzNlMmRiNDM4MjFmYzY0NTk3ZjljMDY3ZTQ0Mg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2002-05-27T12:30:16Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2002-05-27T12:30:16Z"}, "message": "basic-block.h (can_hoist_p, [...]): new.\n\n\n\t* basic-block.h (can_hoist_p, hoist_insn_after, hoist_insn_to_edge):\n\tnew.\n\t* rtlanal.c (hoist_test_store, can_hoist_insn_p, hoist_update_store,\n\thoist_insn_after, hoist_insn_to_edge): New.\n\nFrom-SVN: r53923", "tree": {"sha": "bc531a8c624948c7be25d7b10204c39c7f5b3b6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc531a8c624948c7be25d7b10204c39c7f5b3b6b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71d2c5bd9b1373e2db43821fc64597f9c067e442", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d2c5bd9b1373e2db43821fc64597f9c067e442", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71d2c5bd9b1373e2db43821fc64597f9c067e442", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71d2c5bd9b1373e2db43821fc64597f9c067e442/comments", "author": null, "committer": null, "parents": [{"sha": "bed1bd8c51498ff087a18eb0bbc4cd35122f719f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bed1bd8c51498ff087a18eb0bbc4cd35122f719f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bed1bd8c51498ff087a18eb0bbc4cd35122f719f"}], "stats": {"total": 276, "additions": 276, "deletions": 0}, "files": [{"sha": "59047b87a28e586c6dd6b14094aaa7f510e8d501", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71d2c5bd9b1373e2db43821fc64597f9c067e442", "patch": "@@ -1,3 +1,10 @@\n+Mon May 27 14:28:12 CEST 2002  Jan Hubicka  <jh@suse.cz>\n+\n+\t* basic-block.h (can_hoist_p, hoist_insn_after, hoist_insn_to_edge):\n+\tnew.\n+\t* rtlanal.c (hoist_test_store, can_hoist_insn_p, hoist_update_store,\n+\thoist_insn_after, hoist_insn_to_edge): New.\n+\n Mon May 27 12:14:02 CEST 2002  Jan Hubicka  <jh@suse.cz>\n \n \t* basic-block.h (PEOP_SCAN_DEAD_STORES): New."}, {"sha": "3eafb1c43802a7292f143da9c51ec0d470664128", "filename": "gcc/basic-block.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=71d2c5bd9b1373e2db43821fc64597f9c067e442", "patch": "@@ -729,6 +729,9 @@ extern bool mark_dfs_back_edges\t\tPARAMS ((void));\n extern void set_edge_can_fallthru_flag\tPARAMS ((void));\n extern void update_br_prob_note\t\tPARAMS ((basic_block));\n extern void fixup_abnormal_edges\tPARAMS ((void));\n+extern bool can_hoist_insn_p\t\tPARAMS ((rtx, rtx, regset));\n+extern rtx hoist_insn_after\t\tPARAMS ((rtx, rtx, rtx, rtx));\n+extern rtx hoist_insn_to_edge\t\tPARAMS ((rtx, edge, rtx, rtx));\n \n /* In dominance.c */\n "}, {"sha": "617776ae2aae35e24a23e1fd0ebba382937a8140", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 266, "deletions": 0, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71d2c5bd9b1373e2db43821fc64597f9c067e442/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=71d2c5bd9b1373e2db43821fc64597f9c067e442", "patch": "@@ -29,13 +29,16 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"tm_p.h\"\n #include \"flags.h\"\n+#include \"basic-block.h\"\n \n /* Forward declarations */\n static int global_reg_mentioned_p_1 PARAMS ((rtx *, void *));\n static void set_of_1\t\tPARAMS ((rtx, rtx, void *));\n static void insn_dependent_p_1\tPARAMS ((rtx, rtx, void *));\n static int computed_jump_p_1\tPARAMS ((rtx));\n static void parms_set \t\tPARAMS ((rtx, rtx, void *));\n+static bool hoist_test_store\t\tPARAMS ((rtx, rtx, regset));\n+static void hoist_update_store\t\tPARAMS ((rtx, rtx *, rtx, rtx));\n \n /* Bit flags that specify the machine subtype we are compiling for.\n    Bits are tested using macros TARGET_... defined in the tm.h file\n@@ -3256,3 +3259,266 @@ keep_with_call_p (insn)\n     }\n   return false;\n }\n+\n+/* Return true when store to register X can be hoisted to the place\n+   with LIVE registers (can be NULL).  Value VAL contains destination\n+   whose value will be used.  */\n+\n+static bool\n+hoist_test_store (x, val, live)\n+     rtx x, val;\n+     regset live;\n+{\n+  if (GET_CODE (x) == SCRATCH)\n+    return true;\n+\n+  if (rtx_equal_p (x, val))\n+    return true;\n+\n+  /* Allow subreg of X in case it is not writting just part of multireg pseudo.\n+     Then we would need to update all users to care hoisting the store too.\n+     Caller may represent that by specifying whole subreg as val.  */\n+\n+  if (GET_CODE (x) == SUBREG && rtx_equal_p (SUBREG_REG (x), val))\n+    {\n+      if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) > UNITS_PER_WORD\n+\t  && GET_MODE_BITSIZE (GET_MODE (x)) <\n+\t  GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))))\n+\treturn false;\n+      return true;\n+    }\n+  if (GET_CODE (x) == SUBREG)\n+    x = SUBREG_REG (x);\n+\n+  /* Anything except register store is not hoistable.  This includes the\n+     partial stores to registers.  */\n+\n+  if (!REG_P (x))\n+    return false;\n+\n+  /* Pseudo registers can be allways replaced by another pseudo to avoid\n+     the side effect, for hard register we must ensure that they are dead.\n+     Eventually we may want to add code to try turn pseudos to hards, but it\n+     is unlikely usefull.  */\n+\n+  if (REGNO (x) < FIRST_PSEUDO_REGISTER)\n+    {\n+      int regno = REGNO (x);\n+      int n = HARD_REGNO_NREGS (regno, GET_MODE (x));\n+\n+      if (!live)\n+\treturn false;\n+      if (REGNO_REG_SET_P (live, regno))\n+\treturn false;\n+      while (--n > 0)\n+\tif (REGNO_REG_SET_P (live, regno + n))\n+\t  return false;\n+    }\n+  return true;\n+}\n+\n+\n+/* Return true if INSN can be hoisted to place with LIVE hard registers\n+   (LIVE can be NULL when unknown).  VAL is expected to be stored by the insn\n+   and used by the hoisting pass.  */\n+\n+bool\n+can_hoist_insn_p (insn, val, live)\n+     rtx insn, val;\n+     regset live;\n+{\n+  rtx pat = PATTERN (insn);\n+  int i;\n+\n+  /* It probably does not worth the complexity to handle multiple\n+     set stores.  */\n+  if (!single_set (insn))\n+    return false;\n+  /* We can move CALL_INSN, but we need to check that all caller clobbered\n+     regs are dead.  */\n+  if (GET_CODE (insn) == CALL_INSN)\n+    return false;\n+  /* In future we will handle hoisting of libcall sequences, but\n+     give up for now.  */\n+  if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+    return false;\n+  switch (GET_CODE (pat))\n+    {\n+    case SET:\n+      if (!hoist_test_store (SET_DEST (pat), val, live))\n+\treturn false;\n+      break;\n+    case USE:\n+      /* USES do have sick semantics, so do not move them.  */\n+      return false;\n+      break;\n+    case CLOBBER:\n+      if (!hoist_test_store (XEXP (pat, 0), val, live))\n+\treturn false;\n+      break;\n+    case PARALLEL:\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx x = XVECEXP (pat, 0, i);\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case SET:\n+\t      if (!hoist_test_store (SET_DEST (x), val, live))\n+\t\treturn false;\n+\t      break;\n+\t    case USE:\n+\t      /* We need to fix callers to really ensure availability\n+\t         of all values inisn uses, but for now it is safe to prohibit\n+\t\t hoisting of any insn having such a hiden uses.  */\n+\t      return false;\n+\t      break;\n+\t    case CLOBBER:\n+\t      if (!hoist_test_store (SET_DEST (x), val, live))\n+\t\treturn false;\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      break;\n+    default:\n+      abort ();\n+    }\n+  return true;\n+}\n+\n+/* Update store after hoisting - replace all stores to pseudo registers\n+   by new ones to avoid clobbering of values except for store to VAL that will\n+   be updated to NEW.  */\n+\n+static void\n+hoist_update_store (insn, xp, val, new)\n+     rtx insn, *xp, val, new;\n+{\n+  rtx x = *xp;\n+\n+  if (GET_CODE (x) == SCRATCH)\n+    return;\n+\n+  if (GET_CODE (x) == SUBREG && SUBREG_REG (x) == val)\n+    validate_change (insn, xp,\n+\t\t     simplify_gen_subreg (GET_MODE (x), new, GET_MODE (new),\n+\t\t\t\t\t  SUBREG_BYTE (x)), 1);\n+  if (rtx_equal_p (x, val))\n+    {\n+      validate_change (insn, xp, new, 1);\n+      return;\n+    }\n+  if (GET_CODE (x) == SUBREG)\n+    {\n+      xp = &SUBREG_REG (x);\n+      x = *xp;\n+    }\n+\n+  if (!REG_P (x))\n+    abort ();\n+\n+  /* We've verified that hard registers are dead, so we may keep the side\n+     effect.  Otherwise replace it by new pseudo.  */\n+  if (REGNO (x) >= FIRST_PSEUDO_REGISTER)\n+    validate_change (insn, xp, gen_reg_rtx (GET_MODE (x)), 1);\n+  REG_NOTES (insn)\n+    = alloc_EXPR_LIST (REG_UNUSED, *xp, REG_NOTES (insn));\n+}\n+\n+/* Create a copy of INSN after AFTER replacing store of VAL to NEW\n+   and each other side effect to pseudo register by new pseudo register.  */\n+\n+rtx\n+hoist_insn_after (insn, after, val, new)\n+     rtx insn, after, val, new;\n+{\n+  rtx pat;\n+  int i;\n+  rtx note;\n+\n+  insn = emit_copy_of_insn_after (insn, after);\n+  pat = PATTERN (insn);\n+\n+  /* Remove REG_UNUSED notes as we will re-emit them.  */\n+  while ((note = find_reg_note (insn, REG_UNUSED, NULL_RTX)))\n+    remove_note (insn, note);\n+\n+  /* To get this working callers must ensure to move everything referenced\n+     by REG_EQUAL/REG_EQUIV notes too.  Lets remove them, it is probably\n+     easier.  */\n+  while ((note = find_reg_note (insn, REG_EQUAL, NULL_RTX)))\n+    remove_note (insn, note);\n+  while ((note = find_reg_note (insn, REG_EQUIV, NULL_RTX)))\n+    remove_note (insn, note);\n+\n+  /* Remove REG_DEAD notes as they might not be valid anymore in case\n+     we create redundancy.  */\n+  while ((note = find_reg_note (insn, REG_DEAD, NULL_RTX)))\n+    remove_note (insn, note);\n+  switch (GET_CODE (pat))\n+    {\n+    case SET:\n+      hoist_update_store (insn, &SET_DEST (pat), val, new);\n+      break;\n+    case USE:\n+      break;\n+    case CLOBBER:\n+      hoist_update_store (insn, &XEXP (pat, 0), val, new);\n+      break;\n+    case PARALLEL:\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx x = XVECEXP (pat, 0, i);\n+\t  switch (GET_CODE (x))\n+\t    {\n+\t    case SET:\n+\t      hoist_update_store (insn, &SET_DEST (x), val, new);\n+\t      break;\n+\t    case USE:\n+\t      break;\n+\t    case CLOBBER:\n+\t      hoist_update_store (insn, &SET_DEST (x), val, new);\n+\t      break;\n+\t    default:\n+\t      break;\n+\t    }\n+\t}\n+      break;\n+    default:\n+      abort ();\n+    }\n+  if (!apply_change_group ())\n+    abort ();\n+\n+  return insn;\n+}\n+\n+rtx\n+hoist_insn_to_edge (insn, e, val, new)\n+     rtx insn, val, new;\n+     edge e;\n+{\n+  rtx new_insn;\n+\n+  /* We cannot insert instructions on an abnormal critical edge.\n+     It will be easier to find the culprit if we die now.  */\n+  if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n+    abort ();\n+\n+  /* Do not use emit_insn_on_edge as we want to preserve notes and similar\n+     stuff.  We also emit CALL_INSNS and firends.  */\n+  if (e->insns == NULL_RTX)\n+    {\n+      start_sequence ();\n+      emit_note (NULL, NOTE_INSN_DELETED);\n+    }\n+  else\n+    push_to_sequence (e->insns);\n+\n+  new_insn = hoist_insn_after (insn, get_last_insn (), val, new);\n+\n+  e->insns = get_insns ();\n+  end_sequence ();\n+  return new_insn;\n+}"}]}