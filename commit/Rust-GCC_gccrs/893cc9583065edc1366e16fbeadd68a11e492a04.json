{"sha": "893cc9583065edc1366e16fbeadd68a11e492a04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODkzY2M5NTgzMDY1ZWRjMTM2NmUxNmZiZWFkZDY4YTExZTQ5MmEwNA==", "commit": {"author": {"name": "Dennis Glatting", "email": "dglattin@gnu.org", "date": "1992-08-31T21:09:15Z"}, "committer": {"name": "Dennis Glatting", "email": "dglattin@gnu.org", "date": "1992-08-31T21:09:15Z"}, "message": "minor documentation changes.\n\nFrom-SVN: r2007", "tree": {"sha": "1fa02ec82c2dd5a4b1d331ffeffe753874ded1d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fa02ec82c2dd5a4b1d331ffeffe753874ded1d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/893cc9583065edc1366e16fbeadd68a11e492a04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893cc9583065edc1366e16fbeadd68a11e492a04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/893cc9583065edc1366e16fbeadd68a11e492a04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/893cc9583065edc1366e16fbeadd68a11e492a04/comments", "author": null, "committer": null, "parents": [{"sha": "4037e7bffbec3296143033939137e26b54c0e902", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4037e7bffbec3296143033939137e26b54c0e902", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4037e7bffbec3296143033939137e26b54c0e902"}], "stats": {"total": 159, "additions": 61, "deletions": 98}, "files": [{"sha": "650bcced0c42113b50d49006de33e48eee686463", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 61, "deletions": 98, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/893cc9583065edc1366e16fbeadd68a11e492a04/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/893cc9583065edc1366e16fbeadd68a11e492a04/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=893cc9583065edc1366e16fbeadd68a11e492a04", "patch": "@@ -25,10 +25,13 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n    the executable file might be covered by the GNU General Public License.  */\n \n /* \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/dispatch.common/RCS/hash.c,v 0.12 1992/04/13 11:43:08 dennisg Exp dennisg $\n-  $Author: dennisg $\n-  $Date: 1992/04/13 11:43:08 $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/dispatch/RCS/hash.c,v 0.13 1992/08/18 04:46:58 dglattin Exp $\n+  $Author: dglattin $\n+  $Date: 1992/08/18 04:46:58 $\n   $Log: hash.c,v $\n+ * Revision 0.13  1992/08/18  04:46:58  dglattin\n+ * Saving a working version before release.\n+ *\n  * Revision 0.12  1992/04/13  11:43:08  dennisg\n  * Check in after array version of run-time works.\n  * Expect more changes as hash version and other changes are made.\n@@ -110,41 +113,31 @@ hash_new (u_int sizeOfHash, HashFunc aHashFunc, CompareFunc aCompareFunc) {\n   Cache_t retCache;\n   \n \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Pass me a value greater\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthan 0 and a power of 2. */\n+  /* Pass me a value greater than 0 and a power of 2. */\n   assert(sizeOfHash);\n-\tassert( !(sizeOfHash & (sizeOfHash - 1)));\n+  assert( !(sizeOfHash & (sizeOfHash - 1)));\n   \n-                                                /* Allocate the cache \n-                                                  structure.  calloc () insures\n-                                                  its initialization for\n-                                                  default values. */\n+  /* Allocate the cache structure.  calloc () insures\n+     its initialization for default values. */\n   retCache = calloc (1, sizeof (Cache));\n   assert(retCache);\n   \n-                                                /* Allocate the array of \n-                                                  buckets for the cache.  \n-                                                  calloc() initializes all of \n-                                                  the pointers to NULL. */\n+  /* Allocate the array of buckets for the cache.  \n+     calloc() initializes all of the pointers to NULL. */\n   retCache->theNodeTable = calloc (sizeOfHash, sizeof (CacheNode_t));\n   assert(retCache->theNodeTable);\n   \n   retCache->sizeOfHash  = sizeOfHash;\n \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* This should work for all\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprocessor architectures? */\n-\tretCache->mask = ( sizeOfHash - 1 );\n+  /* This should work for all processor architectures? */\n+  retCache->mask = ( sizeOfHash - 1 );\n \t\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Store the hashing function\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tso that codes can be \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcomputed. */\n-\tretCache->hashFunc = aHashFunc;\n+  /* Store the hashing function so that codes can be computed. */\n+  retCache->hashFunc = aHashFunc;\n \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Store the function that\n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcompares hash keys to \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tdetermine if they are \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tequal. */\n-\tretCache->compareFunc = aCompareFunc;\n+  /* Store the function that compares hash keys to \n+     determine if they are equal. */\n+  retCache->compareFunc = aCompareFunc;\n \n   return retCache;\n }\n@@ -156,13 +149,11 @@ hash_delete (Cache_t theCache) {\n   CacheNode_t aNode;\n   \n \n-                                               /* Purge all key/value pairs \n-                                                  from the table. */\n+  /* Purge all key/value pairs from the table. */\n   while (aNode = hash_next (theCache, NULL))\n     hash_remove (theCache, aNode->theKey);\n \n-                                                /* Release the array of nodes \n-                                                  and the cache itself. */\n+  /* Release the array of nodes and the cache itself. */\n   free (theCache->theNodeTable);\n   free (theCache);\n }\n@@ -177,15 +168,13 @@ hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n \n   assert(aCacheNode);\n   \n-                                                /* Initialize the new node. */\n+  /* Initialize the new node. */\n   aCacheNode->theKey    = aKey;\n   aCacheNode->theValue  = aValue;\n   aCacheNode->nextNode  = (* (*theCache)->theNodeTable)[ indx ];\n   \n-                                                /* Debugging.\n-                                                \n-                                                  Check the list for another \n-                                                  key. */\n+  /* Debugging.\n+     Check the list for another key. */\n #ifdef DEBUG\n     { CacheNode_t checkHashNode = (* (*theCache)->theNodeTable)[ indx ];\n     \n@@ -197,47 +186,38 @@ hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n     }\n #endif\n \n-                                                /* Install the node as the\n-                                                  first element on the list. */\n+  /* Install the node as the first element on the list. */\n   (* (*theCache)->theNodeTable)[ indx ] = aCacheNode;\n \n-                                                /* Bump the number of entries\n-                                                  in the cache. */\n+  /* Bump the number of entries in the cache. */\n   ++ (*theCache)->entriesInHash;\n   \n-                                                /* Check the hash table's\n-                                                  fullness.   We're going\n-                                                  to expand if it is above\n-                                                  the fullness level. */\n+  /* Check the hash table's fullness.   We're going\n+     to expand if it is above the fullness level. */\n   if (FULLNESS (*theCache)) {\n-                                                /* The hash table has reached\n-                                                  its fullness level.  Time to\n-                                                  expand it. \n+    \n+    /* The hash table has reached its fullness level.  Time to\n+       expand it. \n                                                   \n-                                                  I'm using a slow method \n-                                                  here but is built on other\n-                                                  primitive functions thereby\n-                                                  increasing its \n-                                                  correctness. */\n+       I'm using a slow method here but is built on other\n+       primitive functions thereby increasing its \n+       correctness. */\n     CacheNode_t aNode = NULL;\n     Cache_t     newCache = hash_new (EXPANSION (*theCache), \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*theCache)->hashFunc, \n-\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t (*theCache)->compareFunc);\n+\t\t\t\t     (*theCache)->hashFunc, \n+\t\t\t\t     (*theCache)->compareFunc);\n \n     DEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n-      *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n+\t\t  *theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n       \n-                                                /* Copy the nodes from the\n-                                                  first hash table to the\n-                                                  new one. */\n+    /* Copy the nodes from the first hash table to the new one. */\n     while (aNode = hash_next (*theCache, aNode))\n       hash_add (&newCache, aNode->theKey, aNode->theValue);\n \n-                                                /* Trash the old cache. */\n+    /* Trash the old cache. */\n     hash_delete (*theCache);\n     \n-                                                /* Return a pointer to the new\n-                                                  hash table. */\n+    /* Return a pointer to the new hash table. */\n     *theCache = newCache;\n   }\n }\n@@ -250,20 +230,16 @@ hash_remove (Cache_t theCache, void* aKey) {\n   CacheNode_t aCacheNode = (*theCache->theNodeTable)[ indx ];\n   \n   \n-                                                /* We assume there is an entry \n-                                                  in the table.  Error if it \n-                                                  is not. */\n+  /* We assume there is an entry in the table.  Error if it is not. */\n   assert(aCacheNode);\n   \n-                                                /* Special case.  First element \n-                                                  is the key/value pair to be \n-                                                  removed. */\n+  /* Special case.  First element is the key/value pair to be removed. */\n   if ((*theCache->compareFunc)(aCacheNode->theKey, aKey)) {\n     (*theCache->theNodeTable)[ indx ] = aCacheNode->nextNode;\n     free (aCacheNode);\n   } else {\n-                                                /* Otherwise, find the hash \n-                                                  entry. */\n+\n+    /* Otherwise, find the hash entry. */\n     CacheNode_t prevHashNode = aCacheNode;\n     BOOL        removed = NO;\n     \n@@ -278,8 +254,7 @@ hash_remove (Cache_t theCache, void* aKey) {\n     assert(removed);\n   }\n   \n-                                                /* Decrement the number of\n-                                                  entries in the hash table. */\n+  /* Decrement the number of entries in the hash table. */\n   --theCache->entriesInHash;\n }\n \n@@ -290,60 +265,48 @@ hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n   CacheNode_t theCacheNode = aCacheNode;\n   \n   \n-                                                /* If the scan is being started\n-                                                  then reset the last node \n-                                                  visitied pointer and bucket \n-                                                  index. */\n+  /* If the scan is being started then reset the last node \n+     visitied pointer and bucket index. */\n   if (!theCacheNode)\n     theCache->lastBucket  = 0;\n   \n-                                                /* If there is a node visited\n-                                                  last then check for another \n-                                                  entry in the same bucket; \n-                                                  Otherwise step to the next \n-                                                  bucket. */\n+  /* If there is a node visited last then check for another \n+     entry in the same bucket;  Otherwise step to the next bucket. */\n   if (theCacheNode)\n     if (theCacheNode->nextNode)\n-                                                /* There is a node which \n-                                                  follows the last node \n-                                                  returned.  Step to that node \n-                                                  and retun it. */\n+      /* There is a node which follows the last node \n+\t returned.  Step to that node and retun it. */\n       return theCacheNode->nextNode;\n     else\n       ++theCache->lastBucket;\n \n-                                                /* If the list isn't exhausted \n-                                                  then search the buckets for \n-                                                  other nodes. */\n+  /* If the list isn't exhausted then search the buckets for \n+     other nodes. */\n   if (theCache->lastBucket < theCache->sizeOfHash) {\n-                                                /*  Scan the remainder of the \n-                                                  buckets looking for an entry\n-                                                  at the head of the list.  \n-                                                  Return the first item \n-                                                  found. */\n+    /*  Scan the remainder of the buckets looking for an entry\n+\tat the head of the list.  Return the first item found. */\n     while (theCache->lastBucket < theCache->sizeOfHash)\n       if ((*theCache->theNodeTable)[ theCache->lastBucket ])\n         return (*theCache->theNodeTable)[ theCache->lastBucket ];\n       else\n         ++theCache->lastBucket;\n   \n-                                                /* No further nodes were found\n-                                                  in the hash table. */\n+    /* No further nodes were found in the hash table. */\n     return NULL;\n   } else\n     return NULL;\n }\n \n \n-                                                /* Given key, return its \n-                                                  value.  Return NULL if the\n-                                                  key/value pair isn't in\n-                                                  the hash. */\n+/* \n+ * Given key, return its value.  Return NULL if the\n+ * key/value pair isn't in the hash. \n+ */\n void* \n hash_value_for_key (Cache_t theCache, void* aKey) {\n \n   CacheNode_t aCacheNode = \n-              (*theCache->theNodeTable)[(*theCache->hashFunc)(theCache, aKey)];\n+    (*theCache->theNodeTable)[(*theCache->hashFunc)(theCache, aKey)];\n   void*       retVal = NULL;\n   \n "}]}