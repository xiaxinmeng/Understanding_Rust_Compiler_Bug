{"sha": "6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ5OTAxZTc1ZjE5ZGZkMzQ0ODBjNGNmMjU4NTliN2Q0YTNiZmYwMQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-01T20:58:55Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-01T20:58:55Z"}, "message": "Makefile.in (rtl-profile.o, [...]): Add GCC_H dependency.\n\n\t* Makefile.in (rtl-profile.o, value-prof.o): Add GCC_H dependency.\n\t* common.opt (fspeculative-prefetching): New.\n\t* flags.h (flag_speculative_prefetching_set): Declare.\n\t* gcov-io.c (gcov_write_counter, gcov_read_counter): Allow negative\n\tvalues.\n\t* opts.c (flag_sepculative_prefetching_set): New variable.\n\t(common_handle_option): Handle -fspeculative-prefetching.\n\t* passes.c (rest_of_compilation): Ditto.\n\t* profile.c (instrument_values, compute_value_histograms, branch_prob):\n\tUse vectors instead of arrays.\n\t* toplev.c (process_options): Handle -fspeculative-prefetching.\n\t* rtl-profile.c: Include ggc.h.\n\t(rtl_gen_interval_profiler, rtl_gen_pow2_profiler,\n\trtl_gen_one_value_profiler_no_edge_manipulation,\n\trtl_gen_one_value_profiler, rtl_gen_const_delta_profiler): Type of\n\targument changed.\n\t* tree-profile.c (tree_gen_interval_profiler, tree_gen_pow2_profiler,\n\ttree_gen_one_value_profiler, tree_gen_const_delta_profiler): Type of\n\targument changed.\n\t* value-prof.c: Include ggc.h.\n\t(NOPREFETCH_RANGE_MIN, NOPREFETCH_RANGE_MAX): New\n\tmacros.\n\t(insn_prefetch_values_to_profile, find_mem_reference_1,\n\tfind_mem_reference_2, find_mem_reference, gen_speculative_prefetch,\n\tspeculative_prefetching_transform): New.\n\t(value_profile_transformations): Call speculative_prefetching_transform.\n\t(insn_values_to_profile): Call insn_prefetch_values_to_profile.\n\t(insn_divmod_values_to_profile, rtl_find_values_to_profile,\n\ttree_find_values_to_profile, find_values to profile): Use vectors\n\tinstead of arrays.\n\t(free_profiled_values): Removed.\n\t* value-prof.h (struct histogram_value): Renamed to\n\tstruct histogram_value_t.\n\t(histogram_value, histogram_values): New types.\n\t(find_values_to_profile): Declaration changed.\n\t(free_profiled_values): Removed.\n\t(struct profile_hooks): Type of argument of the hooks changed to\n\thistogram_value.\n\t* doc/invoke.texi (-fspeculative-prefetching): Document.\n\nFrom-SVN: r86930", "tree": {"sha": "4f8dfeb1abc654e971b9c4f5130e5a5bacce5cbb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f8dfeb1abc654e971b9c4f5130e5a5bacce5cbb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/comments", "author": null, "committer": null, "parents": [{"sha": "d7fe1183215b7a04b62839775c775e6c4a5c90e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7fe1183215b7a04b62839775c775e6c4a5c90e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7fe1183215b7a04b62839775c775e6c4a5c90e1"}], "stats": {"total": 656, "additions": 499, "deletions": 157}, "files": [{"sha": "04d4fc45a1102739eb95c0c6e5059e4883be2fb6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -1,3 +1,45 @@\n+2004-09-01  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* Makefile.in (rtl-profile.o, value-prof.o): Add GCC_H dependency.\n+\t* common.opt (fspeculative-prefetching): New.\n+\t* flags.h (flag_speculative_prefetching_set): Declare.\n+\t* gcov-io.c (gcov_write_counter, gcov_read_counter): Allow negative\n+\tvalues.\n+\t* opts.c (flag_sepculative_prefetching_set): New variable.\n+\t(common_handle_option): Handle -fspeculative-prefetching.\n+\t* passes.c (rest_of_compilation): Ditto.\n+\t* profile.c (instrument_values, compute_value_histograms, branch_prob):\n+\tUse vectors instead of arrays.\n+\t* toplev.c (process_options): Handle -fspeculative-prefetching.\n+\t* rtl-profile.c: Include ggc.h.\n+\t(rtl_gen_interval_profiler, rtl_gen_pow2_profiler,\n+\trtl_gen_one_value_profiler_no_edge_manipulation,\n+\trtl_gen_one_value_profiler, rtl_gen_const_delta_profiler): Type of\n+\targument changed.\n+\t* tree-profile.c (tree_gen_interval_profiler, tree_gen_pow2_profiler,\n+\ttree_gen_one_value_profiler, tree_gen_const_delta_profiler): Type of\n+\targument changed.\n+\t* value-prof.c: Include ggc.h.\n+\t(NOPREFETCH_RANGE_MIN, NOPREFETCH_RANGE_MAX): New\n+\tmacros.\n+\t(insn_prefetch_values_to_profile, find_mem_reference_1,\n+\tfind_mem_reference_2, find_mem_reference, gen_speculative_prefetch,\n+\tspeculative_prefetching_transform): New.\n+\t(value_profile_transformations): Call speculative_prefetching_transform.\n+\t(insn_values_to_profile): Call insn_prefetch_values_to_profile.\n+\t(insn_divmod_values_to_profile, rtl_find_values_to_profile,\n+\ttree_find_values_to_profile, find_values to profile): Use vectors\n+\tinstead of arrays.\n+\t(free_profiled_values): Removed.\n+\t* value-prof.h (struct histogram_value): Renamed to\n+\tstruct histogram_value_t.\n+\t(histogram_value, histogram_values): New types.\n+\t(find_values_to_profile): Declaration changed.\n+\t(free_profiled_values): Removed.\n+\t(struct profile_hooks): Type of argument of the hooks changed to\n+\thistogram_value.\n+\t* doc/invoke.texi (-fspeculative-prefetching): Document.\n+\n 2004-09-01  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n \n \tPR rtl-optimization/16408"}, {"sha": "dd2333cd5d9b70f43e232b9ebab44fdb928c68ec", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -1959,10 +1959,10 @@ tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H)\n rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(RTL_H) $(TREE_H) $(FLAGS_H) output.h $(REGS_H) $(EXPR_H) function.h \\\n-   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h $(GGC_H)\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h $(FLAGS_H) \\\n-   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H)\n+   $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H) $(GGC_H)\n loop.o : loop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(FLAGS_H) $(LOOP_H) \\\n    insn-config.h $(REGS_H) hard-reg-set.h $(RECOG_H) $(EXPR_H) \\\n    real.h $(PREDICT_H) $(BASIC_BLOCK_H) function.h $(CFGLOOP_H) \\"}, {"sha": "e74596470fced6739f40fd28c562cf1698571178", "filename": "gcc/common.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -752,6 +752,10 @@ fsingle-precision-constant\n Common Report Var(flag_single_precision_constant)\n Convert floating point constants to single precision constants\n \n+fspeculative-prefetching\n+Common Report Var(flag_speculative_prefetching)\n+Use value profiling for speculative prefetching\n+\n ; Emit code to probe the stack, to help detect stack overflow; also\n ; may cause large objects to be allocated dynamically.\n fstack-check"}, {"sha": "b4efeb4c2b158e58de2148ab7f838830b3df4d8a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -311,7 +311,7 @@ Objective-C and Objective-C++ Dialects}.\n -fsched-stalled-insns=@var{n} -sched-stalled-insns-dep=@var{n} @gol\n -fsched2-use-superblocks @gol\n -fsched2-use-traces -freschedule-modulo-scheduled-loops @gol\n--fsignaling-nans -fsingle-precision-constant  @gol\n+-fsignaling-nans -fsingle-precision-constant  -fspeculative-prefetching @gol\n -fstrength-reduce  -fstrict-aliasing  -ftracer  -fthread-jumps @gol\n -funroll-all-loops  -funroll-loops  -fpeel-loops @gol\n -funswitch-loops  -fold-unroll-loops  -fold-unroll-all-loops @gol\n@@ -5011,6 +5011,21 @@ and actually performs the optimizations based on them.\n Currently the optimizations include specialization of division operation\n using the knowledge about the value of the denominator.\n \n+@item -fspeculative-prefetching\n+@opindex fspeculative-prefetching\n+If combined with @option{-fprofile-arcs}, it instructs the compiler to add\n+a code to gather information about addresses of memory references in the\n+program.\n+\n+With @option{-fbranch-probabilities}, it reads back the data gathered\n+and issues prefetch instructions according to them.  In addition to the opportunities\n+noticed by @option{-fprefetch-loop-arrays}, it also notices more complicated\n+memory access patterns -- for example accesses to the data stored in linked\n+list whose elements are usually allocated sequentially.\n+\n+In order to prevent issuing double prefetches, usage of\n+@option{-fspeculative-prefetching} implies @option{-fno-prefetch-loop-arrays}.\n+\n Enabled with @option{-fprofile-generate} and @option{-fprofile-use}.\n \n @item -frename-registers"}, {"sha": "fb240356f7a6a17cdb9c7cf7d71bcd0debbb5327", "filename": "gcc/flags.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -257,6 +257,10 @@ extern int flag_remove_unreachable_functions;\n /* Nonzero if we should track variables.  */\n extern int flag_var_tracking;\n \n+/* True if flag_speculative_prefetching was set by user.  Used to suppress\n+   warning message in case flag was set by -fprofile-{generate,use}.  */\n+extern bool flag_speculative_prefetching_set;\n+\n /* A string that's used when a random name is required.  NULL means\n    to make it really random.  */\n "}, {"sha": "7370f510d37959af8df3780b17ec0d3004662cde", "filename": "gcc/gcov-io.c", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fgcov-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fgcov-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov-io.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -268,9 +268,6 @@ gcov_write_counter (gcov_type value)\n     buffer[1] = (gcov_unsigned_t) (value >> 32);\n   else\n     buffer[1] = 0;\n-  \n-  if (value < 0)\n-    gcov_var.error = -1;\n }\n #endif /* IN_LIBGCOV */\n \n@@ -453,9 +450,7 @@ gcov_read_counter (void)\n     value |= ((gcov_type) from_file (buffer[1])) << 32;\n   else if (buffer[1])\n     gcov_var.error = -1;\n-  \n-  if (value < 0)\n-    gcov_var.error = -1;\n+\n   return value;\n }\n "}, {"sha": "3c4982735126c31cfb4e8f5bdb3a633ae48fee2d", "filename": "gcc/opts.c", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -93,6 +93,7 @@ static const char undocumented_msg[] = N_(\"This switch lacks documentation\");\n static bool profile_arc_flag_set, flag_profile_values_set;\n static bool flag_unroll_loops_set, flag_tracer_set;\n static bool flag_value_profile_transformations_set;\n+bool flag_speculative_prefetching_set;\n static bool flag_peel_loops_set, flag_branch_probabilities_set;\n \n /* Input file names.  */\n@@ -830,6 +831,10 @@ common_handle_option (size_t scode, const char *arg, int value)\n         flag_tracer = value;\n       if (!flag_value_profile_transformations_set)\n         flag_value_profile_transformations = value;\n+#ifdef HAVE_prefetch\n+      if (!flag_speculative_prefetching_set)\n+\tflag_speculative_prefetching = value;\n+#endif\n       break;\n \n     case OPT_fprofile_generate:\n@@ -839,6 +844,10 @@ common_handle_option (size_t scode, const char *arg, int value)\n         flag_profile_values = value;\n       if (!flag_value_profile_transformations_set)\n         flag_value_profile_transformations = value;\n+#ifdef HAVE_prefetch\n+      if (!flag_speculative_prefetching_set)\n+\tflag_speculative_prefetching = value;\n+#endif\n       break;\n \n     case OPT_fprofile_values:\n@@ -861,7 +870,11 @@ common_handle_option (size_t scode, const char *arg, int value)\n       break;\n \n     case OPT_fvpt:\n-      flag_value_profile_transformations_set = value;\n+      flag_value_profile_transformations_set = true;\n+      break;\n+\n+    case OPT_fspeculative_prefetching:\n+      flag_speculative_prefetching_set = true;\n       break;\n \n     case OPT_frandom_seed:"}, {"sha": "783e33d8bbc27f1a7b618fa57cdbd1c0a1150cc9", "filename": "gcc/passes.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -1820,7 +1820,8 @@ rest_of_compilation (void)\n \n       if (flag_branch_probabilities\n \t  && flag_profile_values\n-\t  && flag_value_profile_transformations)\n+\t  && (flag_value_profile_transformations\n+\t      || flag_speculative_prefetching))\n \trest_of_handle_value_profile_transformations ();\n \n       /* Remove the death notes created for vpt.  */"}, {"sha": "2200e76399ddf242e1cc2f8169c4adf86ac01449", "filename": "gcc/profile.c", "status": "modified", "additions": 37, "deletions": 30, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -119,9 +119,9 @@ static int total_num_branches;\n /* Forward declarations.  */\n static void find_spanning_tree (struct edge_list *);\n static unsigned instrument_edges (struct edge_list *);\n-static void instrument_values (unsigned, struct histogram_value *);\n+static void instrument_values (histogram_values);\n static void compute_branch_probabilities (void);\n-static void compute_value_histograms (unsigned, struct histogram_value *);\n+static void compute_value_histograms (histogram_values);\n static gcov_type * get_exec_counts (void);\n static basic_block find_group (basic_block);\n static void union_groups (basic_block, basic_block);\n@@ -166,17 +166,18 @@ instrument_edges (struct edge_list *el)\n   return num_instr_edges;\n }\n \n-/* Add code to measure histograms list of VALUES of length N_VALUES.  */\n+/* Add code to measure histograms for values in list VALUES.  */\n static void\n-instrument_values (unsigned n_values, struct histogram_value *values)\n+instrument_values (histogram_values values)\n {\n   unsigned i, t;\n \n   /* Emit code to generate the histograms before the insns.  */\n \n-  for (i = 0; i < n_values; i++)\n+  for (i = 0; i < VEC_length (histogram_value, values); i++)\n     {\n-      switch (values[i].type)\n+      histogram_value hist = VEC_index (histogram_value, values, i);\n+      switch (hist->type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n \t  t = GCOV_COUNTER_V_INTERVAL;\n@@ -197,25 +198,25 @@ instrument_values (unsigned n_values, struct histogram_value *values)\n \tdefault:\n \t  abort ();\n \t}\n-      if (!coverage_counter_alloc (t, values[i].n_counters))\n+      if (!coverage_counter_alloc (t, hist->n_counters))\n \tcontinue;\n \n-      switch (values[i].type)\n+      switch (hist->type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n-\t  (profile_hooks->gen_interval_profiler) (values + i, t, 0);\n+\t  (profile_hooks->gen_interval_profiler) (hist, t, 0);\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n-\t  (profile_hooks->gen_pow2_profiler) (values + i, t, 0);\n+\t  (profile_hooks->gen_pow2_profiler) (hist, t, 0);\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n-\t  (profile_hooks->gen_one_value_profiler) (values + i, t, 0);\n+\t  (profile_hooks->gen_one_value_profiler) (hist, t, 0);\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n-\t  (profile_hooks->gen_const_delta_profiler) (values + i, t, 0);\n+\t  (profile_hooks->gen_const_delta_profiler) (hist, t, 0);\n \t  break;\n \n \tdefault:\n@@ -613,22 +614,27 @@ compute_branch_probabilities (void)\n   free_aux_for_blocks ();\n }\n \n-/* Load value histograms for N_VALUES values whose description is stored\n-   in VALUES array from .da file.  */\n+/* Load value histograms values whose description is stored in VALUES array\n+   from .da file.  */\n+\n static void\n-compute_value_histograms (unsigned n_values, struct histogram_value *values)\n+compute_value_histograms (histogram_values values)\n {\n   unsigned i, j, t, any;\n   unsigned n_histogram_counters[GCOV_N_VALUE_COUNTERS];\n   gcov_type *histogram_counts[GCOV_N_VALUE_COUNTERS];\n   gcov_type *act_count[GCOV_N_VALUE_COUNTERS];\n   gcov_type *aact_count;\n+  histogram_value hist;\n  \n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n     n_histogram_counters[t] = 0;\n \n-  for (i = 0; i < n_values; i++)\n-    n_histogram_counters[(int) (values[i].type)] += values[i].n_counters;\n+  for (i = 0; i < VEC_length (histogram_value, values); i++)\n+    {\n+      hist = VEC_index (histogram_value, values, i);\n+      n_histogram_counters[(int) hist->type] += hist->n_counters;\n+    }\n \n   any = 0;\n   for (t = 0; t < GCOV_N_VALUE_COUNTERS; t++)\n@@ -649,25 +655,27 @@ compute_value_histograms (unsigned n_values, struct histogram_value *values)\n   if (!any)\n     return;\n \n-  for (i = 0; i < n_values; i++)\n+  for (i = 0; i < VEC_length (histogram_value, values); i++)\n     {\n       rtx hist_list = NULL_RTX;\n-      t = (int) (values[i].type);\n+\n+      hist = VEC_index (histogram_value, values, i);\n+      t = (int) hist->type;\n \n       /* FIXME: make this work for trees.  */\n       if (!ir_type ())\n \t{\n \t  aact_count = act_count[t];\n-\t  act_count[t] += values[i].n_counters;\n-\t  for (j = values[i].n_counters; j > 0; j--)\n+\t  act_count[t] += hist->n_counters;\n+\t  for (j = hist->n_counters; j > 0; j--)\n \t    hist_list = alloc_EXPR_LIST (0, GEN_INT (aact_count[j - 1]), \n \t\t\t\t\thist_list);\n \t      hist_list = alloc_EXPR_LIST (0, \n-\t\t\t    copy_rtx ((rtx)values[i].value), hist_list);\n-\t  hist_list = alloc_EXPR_LIST (0, GEN_INT (values[i].type), hist_list);\n-\t      REG_NOTES ((rtx)values[i].insn) =\n+\t\t\t    copy_rtx ((rtx) hist->value), hist_list);\n+\t  hist_list = alloc_EXPR_LIST (0, GEN_INT (hist->type), hist_list);\n+\t      REG_NOTES ((rtx) hist->insn) =\n \t\t  alloc_EXPR_LIST (REG_VALUE_PROFILE, hist_list,\n-\t\t\t\t       REG_NOTES ((rtx)values[i].insn));\n+\t\t\t\t   REG_NOTES ((rtx) hist->insn));\n \t}\n     }\n \n@@ -700,8 +708,7 @@ branch_prob (void)\n   unsigned num_edges, ignored_edges;\n   unsigned num_instrumented;\n   struct edge_list *el;\n-  unsigned n_values = 0;\n-  struct histogram_value *values = NULL;\n+  histogram_values values = NULL;\n \n   total_num_times_called++;\n \n@@ -960,13 +967,13 @@ branch_prob (void)\n #undef BB_TO_GCOV_INDEX\n \n   if (flag_profile_values)\n-    find_values_to_profile (&n_values, &values);\n+    find_values_to_profile (&values);\n \n   if (flag_branch_probabilities)\n     {\n       compute_branch_probabilities ();\n       if (flag_profile_values)\n-\tcompute_value_histograms (n_values, values);\n+\tcompute_value_histograms (values);\n     }\n \n   remove_fake_edges ();\n@@ -981,7 +988,7 @@ branch_prob (void)\n \tabort ();\n \n       if (flag_profile_values)\n-\tinstrument_values (n_values, values);\n+\tinstrument_values (values);\n \n       /* Commit changes done by instrumentation.  */\n       if (ir_type ())"}, {"sha": "2d0c69ccb9162bfdf9fcd8930f334489836ad6a8", "filename": "gcc/rtl-profile.c", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -62,6 +62,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"coverage.h\"\n #include \"value-prof.h\"\n #include \"tree.h\"\n+#include \"ggc.h\"\n \n /* Output instructions as RTL to increment the edge execution count.  */\n \n@@ -93,8 +94,7 @@ rtl_gen_edge_profiler (int edgeno, edge e)\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-rtl_gen_interval_profiler (struct histogram_value *value, unsigned tag,\n-\t\t       unsigned base)\n+rtl_gen_interval_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -196,8 +196,7 @@ rtl_gen_interval_profiler (struct histogram_value *value, unsigned tag,\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-rtl_gen_pow2_profiler (struct histogram_value *value, unsigned tag, \n-\t\t\tunsigned base)\n+rtl_gen_pow2_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -272,8 +271,8 @@ rtl_gen_pow2_profiler (struct histogram_value *value, unsigned tag,\n    section for counters, BASE is offset of the counter position.  */\n \n static rtx\n-rtl_gen_one_value_profiler_no_edge_manipulation (struct histogram_value *value,\n-\t\t\t\t\t\tunsigned tag, unsigned base)\n+rtl_gen_one_value_profiler_no_edge_manipulation (histogram_value value,\n+\t\t\t\t\t\t unsigned tag, unsigned base)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -351,8 +350,7 @@ rtl_gen_one_value_profiler_no_edge_manipulation (struct histogram_value *value,\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-rtl_gen_one_value_profiler (struct histogram_value *value, unsigned tag,\n-\t\t\tunsigned base)\n+rtl_gen_one_value_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n   edge e = split_block (BLOCK_FOR_INSN ((rtx)value->insn),\n \t\t   PREV_INSN ((rtx)value->insn));\n@@ -368,10 +366,9 @@ rtl_gen_one_value_profiler (struct histogram_value *value, unsigned tag,\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-rtl_gen_const_delta_profiler (struct histogram_value *value, unsigned tag,\n-\t\t\t  unsigned base)\n+rtl_gen_const_delta_profiler (histogram_value value, unsigned tag, unsigned base)\n {\n-  struct histogram_value one_value_delta;\n+  histogram_value one_value_delta;\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n   rtx stored_value_ref, stored_value, tmp, uval;\n@@ -393,13 +390,14 @@ rtl_gen_const_delta_profiler (struct histogram_value *value, unsigned tag,\n \t\t\t     copy_rtx (uval), copy_rtx (stored_value),\n \t\t\t     NULL_RTX, 0, OPTAB_WIDEN);\n \n-  one_value_delta.value = tmp;\n-  one_value_delta.mode = mode;\n-  one_value_delta.seq = NULL_RTX;\n-  one_value_delta.insn = value->insn;\n-  one_value_delta.type = HIST_TYPE_SINGLE_VALUE;\n-  emit_insn (rtl_gen_one_value_profiler_no_edge_manipulation (&one_value_delta,\n-\t\t\t\t\t     tag, base + 1));\n+  one_value_delta = ggc_alloc (sizeof (*one_value_delta));\n+  one_value_delta->value = tmp;\n+  one_value_delta->mode = mode;\n+  one_value_delta->seq = NULL_RTX;\n+  one_value_delta->insn = value->insn;\n+  one_value_delta->type = HIST_TYPE_SINGLE_VALUE;\n+  emit_insn (rtl_gen_one_value_profiler_no_edge_manipulation (one_value_delta,\n+\t\t\t\t\t\t\t      tag, base + 1));\n   emit_move_insn (copy_rtx (stored_value), uval);\n   sequence = get_insns ();\n   end_sequence ();"}, {"sha": "853f17048c09b883fda928a67fc95e8712d89410", "filename": "gcc/toplev.c", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -1730,6 +1730,17 @@ process_options (void)\n   if (flag_value_profile_transformations)\n     flag_profile_values = 1;\n \n+  /* Speculative prefetching implies the value profiling.  We also switch off\n+     the prefetching in the loop optimizer, so that we do not emit double\n+     prefetches.  TODO -- we should teach these two to cooperate; the loop\n+     based prefetching may sometimes do a better job, especially in connection\n+     with reuse analysis.  */\n+  if (flag_speculative_prefetching)\n+    {\n+      flag_profile_values = 1;\n+      flag_prefetch_loop_arrays = 0;\n+    }\n+\n   /* Warn about options that are not supported on this machine.  */\n #ifndef INSN_SCHEDULING\n   if (flag_schedule_insns || flag_schedule_insns_after_reload)\n@@ -1898,12 +1909,24 @@ process_options (void)\n       warning (\"-fprefetch-loop-arrays not supported for this target\");\n       flag_prefetch_loop_arrays = 0;\n     }\n+  if (flag_speculative_prefetching)\n+    {\n+      if (flag_speculative_prefetching_set)\n+\tWARNIng (\"-fspeculative-prefetching not supported for this target\");\n+      flag_speculative_prefetching = 0;\n+    }\n #else\n   if (flag_prefetch_loop_arrays && !HAVE_prefetch)\n     {\n       warning (\"-fprefetch-loop-arrays not supported for this target (try -march switches)\");\n       flag_prefetch_loop_arrays = 0;\n     }\n+  if (flag_speculative_prefetching && !HAVE_prefetch)\n+    {\n+      if (flag_speculative_prefetching_set)\n+\twarning (\"-fspeculative-prefetching not supported for this target (try -march switches)\");\n+      flag_speculative_prefetching = 0;\n+    }\n #endif\n \n   /* This combination of options isn't handled for i386 targets and doesn't"}, {"sha": "7f184152cb79ca274842840c67327b840c6436d2", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -94,7 +94,7 @@ tree_gen_edge_profiler (int edgeno, edge e)\n    tag of the section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_interval_profiler (struct histogram_value *value ATTRIBUTE_UNUSED, \n+tree_gen_interval_profiler (histogram_value value ATTRIBUTE_UNUSED, \n \t\t\t    unsigned tag ATTRIBUTE_UNUSED, \n \t\t\t    unsigned base ATTRIBUTE_UNUSED)\n {\n@@ -107,7 +107,7 @@ tree_gen_interval_profiler (struct histogram_value *value ATTRIBUTE_UNUSED,\n    of the section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_pow2_profiler (struct histogram_value *value ATTRIBUTE_UNUSED, \n+tree_gen_pow2_profiler (histogram_value value ATTRIBUTE_UNUSED, \n \t\t\tunsigned tag ATTRIBUTE_UNUSED,\n \t\t\tunsigned base ATTRIBUTE_UNUSED)\n {\n@@ -120,7 +120,7 @@ tree_gen_pow2_profiler (struct histogram_value *value ATTRIBUTE_UNUSED,\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_one_value_profiler (struct histogram_value *value ATTRIBUTE_UNUSED, \n+tree_gen_one_value_profiler (histogram_value value ATTRIBUTE_UNUSED, \n \t\t\t    unsigned tag ATTRIBUTE_UNUSED,\n \t\t\t    unsigned base ATTRIBUTE_UNUSED)\n {\n@@ -134,7 +134,7 @@ tree_gen_one_value_profiler (struct histogram_value *value ATTRIBUTE_UNUSED,\n    section for counters, BASE is offset of the counter position.  */\n \n static void\n-tree_gen_const_delta_profiler (struct histogram_value *value ATTRIBUTE_UNUSED, \n+tree_gen_const_delta_profiler (histogram_value value ATTRIBUTE_UNUSED, \n \t\t\t\tunsigned tag ATTRIBUTE_UNUSED,\n \t\t\t\tunsigned base ATTRIBUTE_UNUSED)\n {"}, {"sha": "a01c1c9b2da65813517963fa96e7041e91cdaa19", "filename": "gcc/value-prof.c", "status": "modified", "additions": 315, "deletions": 80, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -33,11 +33,20 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"optabs.h\"\n #include \"regs.h\"\n+#include \"ggc.h\"\n \n static struct value_prof_hooks *value_prof_hooks;\n \n-/* In this file value profile based optimizations will be placed (none are\n-   here just now, but they are hopefully coming soon).\n+/* In this file value profile based optimizations are placed.  Currently the\n+   following optimizations are implemented (for more detailed descriptions\n+   see comments at value_profile_transformations):\n+\n+   1) Division/modulo specialisation.  Provided that we can determine that the\n+      operands of the division have some special properties, we may use it to\n+      produce more effective code.\n+   2) Speculative prefetching.  If we are able to determine that the difference\n+      between addresses accessed by a memory reference is usually constant, we\n+      may add the prefetch instructions.\n \n    Every such optimization should add its requirements for profiled values to\n    insn_values_to_profile function.  This function is called from branch_prob\n@@ -52,35 +61,51 @@ static struct value_prof_hooks *value_prof_hooks;\n    -- the expression that is profiled\n    -- list of counters starting from the first one.  */\n \n-static void insn_divmod_values_to_profile (rtx, unsigned *,\n-\t\t\t\t\t   struct histogram_value **);\n-static void insn_values_to_profile (rtx, unsigned *, struct histogram_value **);\n+/* For speculative prefetching, the range in that we do not prefetch (because\n+   we assume that it will be in cache anyway).  The assymetry between min and\n+   max range is trying to reflect the fact that the sequential prefetching\n+   of the data is commonly done directly by hardware.  Nevertheless, these\n+   values are just a guess and should of course be target-specific.  */\n+\n+#ifndef NOPREFETCH_RANGE_MIN\n+#define NOPREFETCH_RANGE_MIN (-16)\n+#endif\n+#ifndef NOPREFETCH_RANGE_MAX\n+#define NOPREFETCH_RANGE_MAX 32\n+#endif\n+\n+static void insn_divmod_values_to_profile (rtx, histogram_values *);\n+#ifdef HAVE_prefetch\n+static bool insn_prefetch_values_to_profile (rtx, histogram_values *);\n+static int find_mem_reference_1 (rtx *, void *);\n+static void find_mem_reference_2 (rtx, rtx, void *);\n+static bool find_mem_reference (rtx, rtx *, int *);\n+#endif\n+\n+static void insn_values_to_profile (rtx, histogram_values *);\n static rtx gen_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n \t\t\t\t   rtx, gcov_type, int);\n static rtx gen_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx, int);\n static rtx gen_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n \t\t\t     int, int, int);\n+#ifdef HAVE_prefetch\n+static rtx gen_speculative_prefetch (rtx, gcov_type, int);\n+#endif\n static bool divmod_fixed_value_transform (rtx insn);\n static bool mod_pow2_value_transform (rtx);\n static bool mod_subtract_transform (rtx);\n+#ifdef HAVE_prefetch\n+static bool speculative_prefetching_transform (rtx);\n+#endif\n \f\n-/* Release the list of VALUES of length N_VALUES for that we want to measure\n-   histograms.  */\n-void\n-free_profiled_values (unsigned n_values ATTRIBUTE_UNUSED,\n-\t\t      struct histogram_value *values)\n-{\n-  free (values);\n-}\n-\n /* Find values inside INSN for that we want to measure histograms for\n-   division/modulo optimization.  */\n+   division/modulo optimization and stores them to VALUES.  */\n static void\n-insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n-\t\t\t       struct histogram_value **values)\n+insn_divmod_values_to_profile (rtx insn, histogram_values *values)\n {\n   rtx set, set_src, op1, op2;\n   enum machine_mode mode;\n+  histogram_value hist;\n \n   if (!INSN_P (insn))\n     return;\n@@ -108,30 +133,26 @@ insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n       /* Check for a special case where the divisor is power of 2.  */\n       if ((GET_CODE (set_src) == UMOD) && !CONSTANT_P (op2))\n \t{\n-\t  *values = xrealloc (*values,\n-\t\t\t      (*n_values + 1)\n-\t\t\t\t* sizeof (struct histogram_value));\n-\t  (*values)[*n_values].value = op2;\n-\t  (*values)[*n_values].seq = NULL_RTX;\n-\t  (*values)[*n_values].mode = mode;\n-\t  (*values)[*n_values].insn = insn;\n-\t  (*values)[*n_values].type = HIST_TYPE_POW2;\n-\t  (*values)[*n_values].hdata.pow2.may_be_other = 1;\n-\t  (*n_values)++;\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->value = op2;\n+\t  hist->seq = NULL_RTX;\n+\t  hist->mode = mode;\n+\t  hist->insn = insn;\n+\t  hist->type = HIST_TYPE_POW2;\n+\t  hist->hdata.pow2.may_be_other = 1;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n \t}\n \n       /* Check whether the divisor is not in fact a constant.  */\n       if (!CONSTANT_P (op2))\n \t{\n-\t  *values = xrealloc (*values,\n-\t\t\t      (*n_values + 1)\n-\t\t\t\t* sizeof (struct histogram_value));\n-\t  (*values)[*n_values].value = op2;\n-\t  (*values)[*n_values].mode = mode;\n-\t  (*values)[*n_values].seq = NULL_RTX;\n-\t  (*values)[*n_values].insn = insn;\n-\t  (*values)[*n_values].type = HIST_TYPE_SINGLE_VALUE;\n-\t  (*n_values)++;\n+\t  hist = ggc_alloc (sizeof (*hist));\n+\t  hist->value = op2;\n+\t  hist->mode = mode;\n+\t  hist->seq = NULL_RTX;\n+\t  hist->insn = insn;\n+\t  hist->type = HIST_TYPE_SINGLE_VALUE;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n \t}\n \n       /* For mod, check whether it is not often a noop (or replaceable by\n@@ -140,22 +161,20 @@ insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n \t{\n \t  rtx tmp;\n \n-\t  *values = xrealloc (*values,\n-\t\t\t      (*n_values + 1)\n-\t\t\t\t* sizeof (struct histogram_value));\n+\t  hist = ggc_alloc (sizeof (*hist));\n \t  start_sequence ();\n \t  tmp = simplify_gen_binary (DIV, mode, copy_rtx (op1), copy_rtx (op2));\n-\t  (*values)[*n_values].value = force_operand (tmp, NULL_RTX);\n-\t  (*values)[*n_values].seq = get_insns ();\n+\t  hist->value = force_operand (tmp, NULL_RTX);\n+\t  hist->seq = get_insns ();\n \t  end_sequence ();\n-\t  (*values)[*n_values].mode = mode;\n-\t  (*values)[*n_values].insn = insn;\n-\t  (*values)[*n_values].type = HIST_TYPE_INTERVAL;\n-\t  (*values)[*n_values].hdata.intvl.int_start = 0;\n-\t  (*values)[*n_values].hdata.intvl.steps = 2;\n-\t  (*values)[*n_values].hdata.intvl.may_be_less = 1;\n-\t  (*values)[*n_values].hdata.intvl.may_be_more = 1;\n-\t  (*n_values)++;\n+\t  hist->mode = mode;\n+\t  hist->insn = insn;\n+\t  hist->type = HIST_TYPE_INTERVAL;\n+\t  hist->hdata.intvl.int_start = 0;\n+\t  hist->hdata.intvl.steps = 2;\n+\t  hist->hdata.intvl.may_be_less = 1;\n+\t  hist->hdata.intvl.may_be_more = 1;\n+\t  VEC_safe_push (histogram_value, *values, hist);\n \t}\n       return;\n \n@@ -164,72 +183,162 @@ insn_divmod_values_to_profile (rtx insn, unsigned *n_values,\n     }\n }\n \n+#ifdef HAVE_prefetch\n+\n+/* Called from find_mem_reference through for_each_rtx, finds a memory\n+   reference.  I.e. if *EXPR is a MEM, the reference to this MEM is stored\n+   to *RET and the traversing of the expression is interrupted by returning 1.\n+   Otherwise 0 is returned.  */\n+\n+static int\n+find_mem_reference_1 (rtx *expr, void *ret)\n+{\n+  rtx *mem = ret;\n+\n+  if (GET_CODE (*expr) == MEM)\n+    {\n+      *mem = *expr;\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+/* Called form find_mem_reference through note_stores to find out whether\n+   the memory reference MEM is a store.  I.e. if EXPR == MEM, the variable\n+   FMR2_WRITE is set to true.  */\n+\n+static int fmr2_write;\n+static void\n+find_mem_reference_2 (rtx expr, rtx pat ATTRIBUTE_UNUSED, void *mem)\n+{\n+  if (expr == mem)\n+    fmr2_write = true;\n+}\n+\n+/* Find a memory reference inside INSN, return it in MEM. Set WRITE to true\n+   if it is a write of the mem.  Return false if no memory reference is found,\n+   true otherwise.  */\n+\n+static bool\n+find_mem_reference (rtx insn, rtx *mem, int *write)\n+{\n+  *mem = NULL_RTX;\n+  for_each_rtx (&PATTERN (insn), find_mem_reference_1, mem);\n+\n+  if (!*mem)\n+    return false;\n+  \n+  fmr2_write = false;\n+  note_stores (PATTERN (insn), find_mem_reference_2, *mem);\n+  *write = fmr2_write;\n+  return true;\n+}\n+\n+/* Find values inside INSN for that we want to measure histograms for\n+   a speculative prefetching.  Add them to the list VALUES.\n+   Returns true if such we found any such value, false otherwise.  */\n+\n+static bool\n+insn_prefetch_values_to_profile (rtx insn, histogram_values *values)\n+{\n+  rtx mem, address;\n+  int write;\n+  histogram_value hist;\n+\n+  if (!INSN_P (insn))\n+    return false;\n+\n+  if (!find_mem_reference (insn, &mem, &write))\n+    return false;\n+\n+  address = XEXP (mem, 0);\n+  if (side_effects_p (address))\n+    return false;\n+      \n+  if (CONSTANT_P (address))\n+    return false;\n+\n+  hist = ggc_alloc (sizeof (*hist));\n+  hist->value = address;\n+  hist->mode = GET_MODE (address);\n+  hist->seq = NULL_RTX;\n+  hist->insn = insn;\n+  hist->type = HIST_TYPE_CONST_DELTA;\n+  VEC_safe_push (histogram_value, *values, hist);\n+\n+  return true;\n+}\n+#endif\n /* Find values inside INSN for that we want to measure histograms and adds\n    them to list VALUES (increasing the record of its length in N_VALUES).  */\n static void\n-insn_values_to_profile (rtx insn,\n-\t\t\tunsigned *n_values,\n-\t\t\tstruct histogram_value **values)\n+insn_values_to_profile (rtx insn, histogram_values *values)\n {\n   if (flag_value_profile_transformations)\n-    insn_divmod_values_to_profile (insn, n_values, values);\n+    insn_divmod_values_to_profile (insn, values);\n+\n+#ifdef HAVE_prefetch\n+  if (flag_speculative_prefetching)\n+    insn_prefetch_values_to_profile (insn, values);\n+#endif\n }\n \n /* Find list of values for that we want to measure histograms.  */\n static void\n-rtl_find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n+rtl_find_values_to_profile (histogram_values *values)\n {\n   rtx insn;\n   unsigned i;\n \n   life_analysis (NULL, PROP_DEATH_NOTES);\n \n-  *n_values = 0;\n-  *values = NULL;\n+  *values = VEC_alloc (histogram_value, 0);\n   for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    insn_values_to_profile (insn, n_values, values);\n+    insn_values_to_profile (insn, values);\n \n-  for (i = 0; i < *n_values; i++)\n+  for (i = 0; i < VEC_length (histogram_value, *values); i++)\n     {\n-      switch ((*values)[i].type)\n+      histogram_value hist = VEC_index (histogram_value, *values, i);\n+\n+      switch (hist->type)\n \t{\n \tcase HIST_TYPE_INTERVAL:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Interval counter for insn %d, range %d -- %d.\\n\",\n-\t\t     INSN_UID ((rtx)(*values)[i].insn),\n-\t\t     (*values)[i].hdata.intvl.int_start,\n-\t\t     ((*values)[i].hdata.intvl.int_start\n-\t\t      + (*values)[i].hdata.intvl.steps - 1));\n-\t  (*values)[i].n_counters = (*values)[i].hdata.intvl.steps +\n-\t\t  ((*values)[i].hdata.intvl.may_be_less ? 1 : 0) +\n-\t\t  ((*values)[i].hdata.intvl.may_be_more ? 1 : 0);\n+\t\t     INSN_UID ((rtx)hist->insn),\n+\t\t     hist->hdata.intvl.int_start,\n+\t\t     (hist->hdata.intvl.int_start\n+\t\t      + hist->hdata.intvl.steps - 1));\n+\t  hist->n_counters = hist->hdata.intvl.steps +\n+\t\t  (hist->hdata.intvl.may_be_less ? 1 : 0) +\n+\t\t  (hist->hdata.intvl.may_be_more ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_POW2:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Pow2 counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)(*values)[i].insn));\n-\t  (*values)[i].n_counters \n-\t\t= GET_MODE_BITSIZE ((*values)[i].mode)\n-\t\t  +  ((*values)[i].hdata.pow2.may_be_other ? 1 : 0);\n+\t\t     INSN_UID ((rtx)hist->insn));\n+\t  hist->n_counters \n+\t\t= GET_MODE_BITSIZE (hist->mode)\n+\t\t  +  (hist->hdata.pow2.may_be_other ? 1 : 0);\n \t  break;\n \n \tcase HIST_TYPE_SINGLE_VALUE:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Single value counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)(*values)[i].insn));\n-\t  (*values)[i].n_counters = 3;\n+\t\t     INSN_UID ((rtx)hist->insn));\n+\t  hist->n_counters = 3;\n \t  break;\n \n \tcase HIST_TYPE_CONST_DELTA:\n \t  if (dump_file)\n \t    fprintf (dump_file,\n \t\t     \"Constant delta counter for insn %d.\\n\",\n-\t\t     INSN_UID ((rtx)(*values)[i].insn));\n-\t  (*values)[i].n_counters = 4;\n+\t\t     INSN_UID ((rtx)hist->insn));\n+\t  hist->n_counters = 4;\n \t  break;\n \n \tdefault:\n@@ -300,6 +409,23 @@ rtl_find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n    It would be possible to continue analogically for K * b for other small\n    K's, but it is probably not useful.\n \n+   5)\n+\n+   Read or write of mem[address], where the value of address changes usually\n+   by a constant C != 0 between the following accesses to the computation; with\n+   -fspeculative-prefetching we then add a prefetch of address + C before\n+   the insn.  This handles prefetching of several interesting cases in addition\n+   to a simple prefetching for addresses that are induction variables, e. g.\n+   linked lists allocated sequentially (even in case they are processed\n+   recursively).\n+\n+   TODO -- we should also check whether there is not (usually) a small\n+\t   difference with the adjacent memory references, so that we do\n+\t   not issue overlapping prefetches.  Also we should employ some\n+\t   heuristics to eliminate cases where prefetching evidently spoils\n+\t   the code.\n+\t-- it should somehow cooperate with the loop optimizer prefetching\n+\n    TODO:\n \n    There are other useful cases that could be handled by a similar mechanism,\n@@ -353,6 +479,11 @@ rtl_value_profile_transformations (void)\n \t      || divmod_fixed_value_transform (insn)\n \t      || mod_pow2_value_transform (insn)))\n \tchanged = true;\n+#ifdef HAVE_prefetch\n+      if (flag_speculative_prefetching\n+\t  && speculative_prefetching_transform (insn))\n+\tchanged = true;\n+#endif\n     }\n \n   if (changed)\n@@ -754,12 +885,118 @@ mod_subtract_transform (rtx insn)\n \n   return true;\n }\n+\n+#ifdef HAVE_prefetch\n+/* Generate code for transformation 5 for mem with ADDRESS and a constant\n+   step DELTA.  WRITE is true if the reference is a store to mem.  */\n+\n+static rtx\n+gen_speculative_prefetch (rtx address, gcov_type delta, int write)\n+{\n+  rtx tmp;\n+  rtx sequence;\n+\n+  /* TODO: we do the prefetching for just one iteration ahead, which\n+     often is not enough.  */\n+  start_sequence ();\n+  if (offsettable_address_p (0, VOIDmode, address))\n+    tmp = plus_constant (copy_rtx (address), delta);\n+  else\n+    {\n+      tmp = simplify_gen_binary (PLUS, Pmode,\n+\t\t\t\t copy_rtx (address), GEN_INT (delta));\n+      tmp = force_operand (tmp, NULL);\n+    }\n+  if (! (*insn_data[(int)CODE_FOR_prefetch].operand[0].predicate)\n+      (tmp, insn_data[(int)CODE_FOR_prefetch].operand[0].mode))\n+    tmp = force_reg (Pmode, tmp);\n+  emit_insn (gen_prefetch (tmp, GEN_INT (write), GEN_INT (3)));\n+  sequence = get_insns ();\n+  end_sequence ();\n+\n+  return sequence;\n+}\n+\n+/* Do transform 5) on INSN if applicable.  */\n+\n+static bool\n+speculative_prefetching_transform (rtx insn)\n+{\n+  rtx histogram, value;\n+  gcov_type val, count, all;\n+  edge e;\n+  rtx mem, address;\n+  int write;\n+\n+  if (!maybe_hot_bb_p (BLOCK_FOR_INSN (insn)))\n+    return false;\n+\n+  if (!find_mem_reference (insn, &mem, &write))\n+    return false;\n+\n+  address = XEXP (mem, 0);\n+  if (side_effects_p (address))\n+    return false;\n+      \n+  if (CONSTANT_P (address))\n+    return false;\n+\n+  for (histogram = REG_NOTES (insn);\n+       histogram;\n+       histogram = XEXP (histogram, 1))\n+    if (REG_NOTE_KIND (histogram) == REG_VALUE_PROFILE\n+\t&& XEXP (XEXP (histogram, 0), 0) == GEN_INT (HIST_TYPE_CONST_DELTA))\n+      break;\n+\n+  if (!histogram)\n+    return false;\n+\n+  histogram = XEXP (XEXP (histogram, 0), 1);\n+  value = XEXP (histogram, 0);\n+  histogram = XEXP (histogram, 1);\n+  /* Skip last value referenced.  */\n+  histogram = XEXP (histogram, 1);\n+  val = INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+  count = INTVAL (XEXP (histogram, 0));\n+  histogram = XEXP (histogram, 1);\n+  all = INTVAL (XEXP (histogram, 0));\n+\n+  /* With that few executions we do not really have a reason to optimize the\n+     statement, and more importantly, the data about differences of addresses\n+     are spoiled by the first item that had no previous value to compare\n+     with.  */\n+  if (all < 4)\n+    return false;\n+\n+  /* We require that count is at least half of all; this means\n+     that for the transformation to fire the value must be constant\n+     at least 50% of time (and 75% gives the garantee of usage).  */\n+  if (!rtx_equal_p (address, value) || 2 * count < all)\n+    return false;\n+\n+  /* If the difference is too small, it does not make too much sense to\n+     prefetch, as the memory is probably already in cache.  */\n+  if (val >= NOPREFETCH_RANGE_MIN && val <= NOPREFETCH_RANGE_MAX)\n+    return false;\n+\n+  if (dump_file)\n+    fprintf (dump_file, \"Speculative prefetching for insn %d\\n\",\n+\t     INSN_UID (insn));\n+\n+  e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n+  \n+  insert_insn_on_edge (gen_speculative_prefetch (address, val, write), e);\n+\n+  return true;\n+}\n+#endif  /* HAVE_prefetch */\n \f\n /* Connection to the outside world.  */\n /* Struct for IR-dependent hooks.  */\n struct value_prof_hooks {\n   /* Find list of values for which we want to measure histograms.  */\n-  void (*find_values_to_profile) (unsigned *, struct histogram_value **);\n+  void (*find_values_to_profile) (histogram_values *);\n \n   /* Identify and exploit properties of values that are hard to analyze\n      statically.  See value-prof.c for more detail.  */\n@@ -783,10 +1020,8 @@ rtl_register_value_prof_hooks (void)\n \f\n /* Tree-based versions are stubs for now.  */\n static void\n-tree_find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n+tree_find_values_to_profile (histogram_values *values ATTRIBUTE_UNUSED)\n {\n-  (void)n_values;\n-  (void)values;\n   abort ();\n }\n \n@@ -811,9 +1046,9 @@ tree_register_value_prof_hooks (void)\n \f\n /* IR-independent entry points.  */\n void\n-find_values_to_profile (unsigned *n_values, struct histogram_value **values)\n+find_values_to_profile (histogram_values *values)\n {\n-  (value_prof_hooks->find_values_to_profile) (n_values, values);\n+  (value_prof_hooks->find_values_to_profile) (values);\n }\n \n bool"}, {"sha": "60215fde30dc4dd9198f98214ea1fe6e9eee0163", "filename": "gcc/value-prof.h", "status": "modified", "additions": 19, "deletions": 14, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d9901e75f19dfd34480c4cf25859b7d4a3bff01/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=6d9901e75f19dfd34480c4cf25859b7d4a3bff01", "patch": "@@ -39,14 +39,15 @@ enum hist_type\n \n /* The value to measure.  */\n /* The void *'s are either rtx or tree, depending on which IR is in use.  */\n-struct histogram_value\n+struct histogram_value_t GTY(())\n {\n-  void * value;\t\t/* The value to profile.  */\n-  enum machine_mode mode; /* And its mode.  */\n-  void * seq;\t\t/* Insns required to count the profiled value.  */\n-  void * insn;\t\t/* Insn before that to measure.  */\n-  enum hist_type type;\t/* Type of information to measure.  */\n-  unsigned n_counters;\t/* Number of required counters.  */\n+  PTR GTY ((skip (\"\"))) value;\t\t/* The value to profile.  */\n+  enum machine_mode mode;\t\t/* And its mode.  */\n+  PTR GTY ((skip (\"\"))) seq;\t\t/* Insns required to count the\n+\t\t\t\t\t   profiled value.  */\n+  PTR GTY ((skip (\"\"))) insn;\t\t/* Insn before that to measure.  */\n+  enum hist_type type;\t\t\t/* Type of information to measure.  */\n+  unsigned n_counters;\t\t\t/* Number of required counters.  */\n   union\n     {\n       struct\n@@ -63,13 +64,18 @@ struct histogram_value\n     } hdata;\t\t/* Profiled information specific data.  */\n };\n \n+typedef struct histogram_value_t *histogram_value;\n+\n+DEF_VEC_P(histogram_value);\n+\n+typedef VEC(histogram_value) *histogram_values;\n+\n /* Hooks registration.  */\n extern void rtl_register_value_prof_hooks (void);\n extern void tree_register_value_prof_hooks (void);\n \n /* IR-independent entry points.  */\n-extern void find_values_to_profile (unsigned *, struct histogram_value **);\n-extern void free_profiled_values (unsigned, struct histogram_value *);\n+extern void find_values_to_profile (histogram_values *);\n extern bool value_profile_transformations (void);\n \f\n /* External declarations for edge-based profiling.  */\n@@ -78,18 +84,17 @@ struct profile_hooks {\n   void (*gen_edge_profiler) (int, edge);\n \n   /* Insert code to increment the interval histogram counter.  */\n-  void (*gen_interval_profiler) (struct histogram_value *, unsigned, unsigned);\n+  void (*gen_interval_profiler) (histogram_value, unsigned, unsigned);\n \n   /* Insert code to increment the power of two histogram counter.  */\n-  void (*gen_pow2_profiler) (struct histogram_value *, unsigned, unsigned);\n+  void (*gen_pow2_profiler) (histogram_value, unsigned, unsigned);\n \n   /* Insert code to find the most common value.  */\n-  void (*gen_one_value_profiler) (struct histogram_value *, unsigned, unsigned);\n+  void (*gen_one_value_profiler) (histogram_value, unsigned, unsigned);\n \n   /* Insert code to find the most common value of a difference between two\n      evaluations of an expression.  */\n-  void (*gen_const_delta_profiler) (struct histogram_value *, unsigned, \n-\t\t\t\t    unsigned);\n+  void (*gen_const_delta_profiler) (histogram_value, unsigned, unsigned);\n   FILE * (*profile_dump_file) (void);\n };\n "}]}