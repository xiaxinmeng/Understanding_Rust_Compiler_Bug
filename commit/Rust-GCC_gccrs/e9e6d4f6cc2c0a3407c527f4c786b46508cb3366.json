{"sha": "e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTllNmQ0ZjZjYzJjMGEzNDA3YzUyN2Y0Yzc4NmI0NjUwOGNiMzM2Ng==", "commit": {"author": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2016-08-10T19:04:13Z"}, "committer": {"name": "Kelvin Nilsen", "email": "kelvin@gcc.gnu.org", "date": "2016-08-10T19:04:13Z"}, "message": "altivec.h (vec_extract_exp): New macro.\n\ngcc/ChangeLog:\n\n2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* config/rs6000/altivec.h (vec_extract_exp): New macro.\n\t(vec_extract_sig): New macro.\n\t(vec_insert_exp): New macro.\n\t(vec_test_data_class): New macro.\n\t(scalar_extract_exp): New macro.\n\t(scalar_extract_sig): New macro.\n\t(scalar_insert_exp): New macro.\n\t(scalar_test_data_class): New macro.\n\t(scalar_test_neg): New macro.\n\t(scalar_cmp_exp_gt): New macro.\n\t(scalar_cmp_exp_lt): New macro.\n\t(scalar_cmp_exp_eq): New macro.\n\t(scalar_cmp_exp_unordered): New macro.\n\t* config/rs6000/predicates.md (u7bit_cint_operand): New predicate\n\tto enforce constraint that operand is a 7-bit unsigned literal.\n\t* config/rs6000/rs6000-builtin.def (BU_P9V_64BIT_VSX_1): New macro\n\tfor power9 built-ins.\n\t(BU_P9V_VSX_2): Likewise.\n\t(BU_P9V_64BIT_VSX_2): Likewise.\n\t(VSEEDP): Add scalar extract exponent support.\n\t(VSEESP): Add scalar extract signature support.\n\t(VSTDCNDP): Add scalar test negative support.\n\t(VSTDCNSP): Likewise.\n\t(VSIEDP): Add scalar insert exponent support.\n\t(VSCEDPGT): Add scalar compare exponent greater than support.\n\t(VSCEDPLT): Add scalar compare exponent less than support.\n\t(VSCEDPEQ): Add scalar compare exponent test-for-equality support.\n\t(VSCEDPUO): Add scalar compare exponent test-for-unordered support.\n\t(VSTDCDP): Add scalar test data class support.\n\t(VSTDCSP): Likewise.\n\t(VSEEDP): Add overload support for scalar extract exponent\n\toperation.\n\t(VSESDP): Add overload support for scalar extract signature\n\toperation.\n\t(VSTDCN): Add overload support for scalar test negative\n\toperation.\n\t(VSTDCNDP): Add overload support for scalar test negative\n\toperation.\n\t(VSTDCNSP): Add overload support for scalar test negative\n\toperation.\n\t(VSIEDP): Add overload support for scalar insert exponent\n\toperation.\n\t(VSTDC): Add overload support for scalar test data class\n\toperation.\n\t(VSTDCDP): Add overload support for scalar test data class\n\toperation.\n\t(VSTDCSP): Add overload support for scalar test data class\n\topreation.\n\t(VSCEDPGT): Add overload support for scalar compare exponent\n\tgreater than operation.\n\t(VSCEDPLT): Add overload support for scalar compare exponent\n\tless than operation.\n\t(VSCEDPEQ): Add overload support for scalar compare exponent\n\ttest-for-equality operation.\n\t(VSCEDPUO): Add overload support for scalar compare exponent\n\ttest-for-unordered operation.\n\t(VEEDP): Add vector extract exponent support.\n\t(VEESP): Likewise.\n\t(VESDP): Add vector extract significand support.\n\t(VESSP): Likewise.\n\t(VIEDP): Add vector insert exponent support.\n\t(VIESP): Likewise.\n\t(VTDCDP): Add vector test data class support.\n\t(VTDCSP): Likewise.\n\t(VES): Add overload support for vector extract significand operation.\n\t(VESDP): Likewise.\n\t(VESSP): Likewise\n\t(VEE): Add overload support for vector extract exponent operation.\n\t(VEEDP): Likewise.\n\t(VEESP): Likewise.\n\t(VTDC): Add overload support for vector test data class operation.\n\t(VTDCDP): Likewise.\n\t(VTDCSP): Likewise.\n\t(VIE): Add overload support for vector insert exponent operation.\n\t(VIEDP): Likewise.\n\t(VIESP): Likewise.\n\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n\toverloaded binary floating point functions.\n\t(altivec_resolve_overloaded_builtin): Improve error messages to\n\tdistinguish between functions not supported in the current\n\tcompiler configuration and functions that were invoked with an\n\tinvalid parameter combination, and include the built-in function\n\tname in both error messages.\n\t* config/rs6000/rs6000-protos.h (rs6000_overloaded_builtin_name):\n\tNew prototype.\n\t* config/rs6000/rs6000.c (rs6000_overloaded_builtin_name): New\n\tfunction.\n\t(rs6000_expand_binop_builtin): Add check to enforce that argument\n\t2 of the test data class operations is a 7-bit unsigned literal.\n\t(rs6000_invalid_builtin): Add code to issue an error message if a\n\tbuilt-in function that requires the power9_vector and -m32\n\tcommand-line options is compiled without these options.\n\t* config/rs6000/vsx.md (UNSPEC_VSX_SXEXPDP): New value.\n\t(UNSPEC_VSX_SXSIGDP): New value.\n\t(UNSPEC_VSX_SXSIGPDP): New value.\n\t(UNSPEC_VSX_SIEXPDP): New value.\n\t(UNSPEC_VSX_SCMPEXPDP): New value.\n\t(UNSPEC_VSX_STSTDC): New value.\n\t(UNSPEC_VSX_VXEXP): New value.\n\t(UNSPEC_VSX_VXSIG): New value.\n\t(UNSPEC_VSX_VIEXP): New value.\n\t(UNSPEC_VSX_VTSTDC): New value.\n\t(xsxexpdp): New insn for scalar extract exponent.\n\t(xsxsigdp): New insn for scalar extract significand.\n\t(xsiexpdp): New insn for scalar insert exponent.\n\t(xscmpexpdp_<code>): New expansion for scalar compare exponents.\n\t(*xscmpexpdp): New insn for scalar compare exponents.\n\t(xststdc<Fvsx): New expansion for both single- and\n\tdouble-precision scalar test data class operations.\n\t(xststdcneg<Fvsx>): New expansion for both single- and\n\tdouble-precision scalar test for negative value operations.\n\t(*xststdc<Fvsx>): New insn for scalar test data class\n\toperation.\n\t(xvxexp<VSs>): New insn for single- and double-precision\n\tvector extract exponent operation.\n\t(xvxsig<VSs>): New insn for single- and double-precision\n\tvector extract significand operation.\n\t(xviexp<VSs>): New insn for single- and double-precision\n\tvector insert exponent operation.\n\t(xvtstdc<VSs>): New insn for single- and double-precision\n\tvector test data class operation.\n\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document\n\tbuilt-in functions to represent the Power9 binary floating-point\n\tsupport instructions.\n\ngcc/testsuite/ChangeLog:\n\n2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n\n\t* gcc.target/powerpc/bfp/bfp.exp: New file.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-exp-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-extract-sig-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-insert-exp-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-3.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-4.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-5.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-6.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-data-class-7.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-0.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-1.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-2.c: New test.\n\t* gcc.target/powerpc/bfp/scalar-test-neg-3.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-0.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-1.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-2.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-exp-3.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-0.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-1.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-2.c: New test.\n\t* gcc.target/powerpc/bfp/vec-extract-sig-3.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-0.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-1.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-2.c: New test.\n\t* gcc.target/powerpc/bfp/vec-insert-exp-3.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-0.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-1.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-2.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-3.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-4.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-5.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-6.c: New test.\n\t* gcc.target/powerpc/bfp/vec-test-data-class-7.c: New test.\n\nFrom-SVN: r239334", "tree": {"sha": "735765220e78bb6de5aaa0915ba9cc7bddbbf100", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/735765220e78bb6de5aaa0915ba9cc7bddbbf100"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/comments", "author": null, "committer": null, "parents": [{"sha": "4cc1fc4f9eefdfdae09ecb7f4cff9a284b1b4e8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cc1fc4f9eefdfdae09ecb7f4cff9a284b1b4e8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cc1fc4f9eefdfdae09ecb7f4cff9a284b1b4e8b"}], "stats": {"total": 1655, "additions": 1637, "deletions": 18}, "files": [{"sha": "ebb2cb7e40d7873ad11db103e9a87f611f01e0ef", "filename": "gcc/ChangeLog", "status": "modified", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -1,3 +1,130 @@\n+2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* config/rs6000/altivec.h (vec_extract_exp): New macro.\n+\t(vec_extract_sig): New macro.\n+\t(vec_insert_exp): New macro.\n+\t(vec_test_data_class): New macro.\n+\t(scalar_extract_exp): New macro.\n+\t(scalar_extract_sig): New macro.\n+\t(scalar_insert_exp): New macro.\n+\t(scalar_test_data_class): New macro.\n+\t(scalar_test_neg): New macro.\n+\t(scalar_cmp_exp_gt): New macro.\n+\t(scalar_cmp_exp_lt): New macro.\n+\t(scalar_cmp_exp_eq): New macro.\n+\t(scalar_cmp_exp_unordered): New macro.\n+\t* config/rs6000/predicates.md (u7bit_cint_operand): New predicate\n+\tto enforce constraint that operand is a 7-bit unsigned literal.\n+\t* config/rs6000/rs6000-builtin.def (BU_P9V_64BIT_VSX_1): New macro\n+\tfor power9 built-ins.\n+\t(BU_P9V_VSX_2): Likewise.\n+\t(BU_P9V_64BIT_VSX_2): Likewise.\n+\t(VSEEDP): Add scalar extract exponent support.\n+\t(VSEESP): Add scalar extract signature support.\n+\t(VSTDCNDP): Add scalar test negative support.\n+\t(VSTDCNSP): Likewise.\n+\t(VSIEDP): Add scalar insert exponent support.\n+\t(VSCEDPGT): Add scalar compare exponent greater than support.\n+\t(VSCEDPLT): Add scalar compare exponent less than support.\n+\t(VSCEDPEQ): Add scalar compare exponent test-for-equality support.\n+\t(VSCEDPUO): Add scalar compare exponent test-for-unordered support.\n+\t(VSTDCDP): Add scalar test data class support.\n+\t(VSTDCSP): Likewise.\n+\t(VSEEDP): Add overload support for scalar extract exponent\n+\toperation.\n+\t(VSESDP): Add overload support for scalar extract signature\n+\toperation.\n+\t(VSTDCN): Add overload support for scalar test negative\n+\toperation.\n+\t(VSTDCNDP): Add overload support for scalar test negative\n+\toperation.\n+\t(VSTDCNSP): Add overload support for scalar test negative\n+\toperation.\n+\t(VSIEDP): Add overload support for scalar insert exponent\n+\toperation.\n+\t(VSTDC): Add overload support for scalar test data class\n+\toperation.\n+\t(VSTDCDP): Add overload support for scalar test data class\n+\toperation.\n+\t(VSTDCSP): Add overload support for scalar test data class\n+\topreation.\n+\t(VSCEDPGT): Add overload support for scalar compare exponent\n+\tgreater than operation.\n+\t(VSCEDPLT): Add overload support for scalar compare exponent\n+\tless than operation.\n+\t(VSCEDPEQ): Add overload support for scalar compare exponent\n+\ttest-for-equality operation.\n+\t(VSCEDPUO): Add overload support for scalar compare exponent\n+\ttest-for-unordered operation.\n+\t(VEEDP): Add vector extract exponent support.\n+\t(VEESP): Likewise.\n+\t(VESDP): Add vector extract significand support.\n+\t(VESSP): Likewise.\n+\t(VIEDP): Add vector insert exponent support.\n+\t(VIESP): Likewise.\n+\t(VTDCDP): Add vector test data class support.\n+\t(VTDCSP): Likewise.\n+\t(VES): Add overload support for vector extract significand operation.\n+\t(VESDP): Likewise.\n+\t(VESSP): Likewise\n+\t(VEE): Add overload support for vector extract exponent operation.\n+\t(VEEDP): Likewise.\n+\t(VEESP): Likewise.\n+\t(VTDC): Add overload support for vector test data class operation.\n+\t(VTDCDP): Likewise.\n+\t(VTDCSP): Likewise.\n+\t(VIE): Add overload support for vector insert exponent operation.\n+\t(VIEDP): Likewise.\n+\t(VIESP): Likewise.\n+\t* config/rs6000/rs6000-c.c (altivec_overloaded_builtins): Add\n+\toverloaded binary floating point functions.\n+\t(altivec_resolve_overloaded_builtin): Improve error messages to\n+\tdistinguish between functions not supported in the current\n+\tcompiler configuration and functions that were invoked with an\n+\tinvalid parameter combination, and include the built-in function\n+\tname in both error messages.\n+\t* config/rs6000/rs6000-protos.h (rs6000_overloaded_builtin_name):\n+\tNew prototype.\n+\t* config/rs6000/rs6000.c (rs6000_overloaded_builtin_name): New\n+\tfunction.\n+\t(rs6000_expand_binop_builtin): Add check to enforce that argument\n+\t2 of the test data class operations is a 7-bit unsigned literal.\n+\t(rs6000_invalid_builtin): Add code to issue an error message if a\n+\tbuilt-in function that requires the power9_vector and -m32\n+\tcommand-line options is compiled without these options.\n+\t* config/rs6000/vsx.md (UNSPEC_VSX_SXEXPDP): New value.\n+\t(UNSPEC_VSX_SXSIGDP): New value.\n+\t(UNSPEC_VSX_SXSIGPDP): New value.\n+\t(UNSPEC_VSX_SIEXPDP): New value.\n+\t(UNSPEC_VSX_SCMPEXPDP): New value.\n+\t(UNSPEC_VSX_STSTDC): New value.\n+\t(UNSPEC_VSX_VXEXP): New value.\n+\t(UNSPEC_VSX_VXSIG): New value.\n+\t(UNSPEC_VSX_VIEXP): New value.\n+\t(UNSPEC_VSX_VTSTDC): New value.\n+\t(xsxexpdp): New insn for scalar extract exponent.\n+\t(xsxsigdp): New insn for scalar extract significand.\n+\t(xsiexpdp): New insn for scalar insert exponent.\n+\t(xscmpexpdp_<code>): New expansion for scalar compare exponents.\n+\t(*xscmpexpdp): New insn for scalar compare exponents.\n+\t(xststdc<Fvsx): New expansion for both single- and\n+\tdouble-precision scalar test data class operations.\n+\t(xststdcneg<Fvsx>): New expansion for both single- and\n+\tdouble-precision scalar test for negative value operations.\n+\t(*xststdc<Fvsx>): New insn for scalar test data class\n+\toperation.\n+\t(xvxexp<VSs>): New insn for single- and double-precision\n+\tvector extract exponent operation.\n+\t(xvxsig<VSs>): New insn for single- and double-precision\n+\tvector extract significand operation.\n+\t(xviexp<VSs>): New insn for single- and double-precision\n+\tvector insert exponent operation.\n+\t(xvtstdc<VSs>): New insn for single- and double-precision\n+\tvector test data class operation.\n+\t* doc/extend.texi (PowerPC AltiVec Built-in Functions): Document\n+\tbuilt-in functions to represent the Power9 binary floating-point\n+\tsupport instructions.\n+\n 2016-08-10  bin cheng  <bin.cheng@arm.com>\n \n \t* doc/sourcebuild.texi (@item vect_cond_mixed): New item."}, {"sha": "28add2a4147d45b2b7a9b21721b46e74511fa397", "filename": "gcc/config/rs6000/altivec.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Faltivec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Faltivec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faltivec.h?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -409,6 +409,23 @@\n \n #define vec_slv __builtin_vec_vslv\n #define vec_srv __builtin_vec_vsrv\n+\n+#define vec_extract_exp __builtin_vec_extract_exp\n+#define vec_extract_sig __builtin_vec_extract_sig\n+#define vec_insert_exp __builtin_vec_insert_exp\n+#define vec_test_data_class __builtin_vec_test_data_class\n+\n+#define scalar_extract_exp __builtin_vec_scalar_extract_exp\n+#define scalar_extract_sig __builtin_vec_scalar_extract_sig\n+#define scalar_insert_exp __builtin_vec_scalar_insert_exp\n+#define scalar_test_data_class __builtin_vec_scalar_test_data_class\n+#define scalar_test_neg __builtin_vec_scalar_test_neg\n+\n+#define scalar_cmp_exp_gt __builtin_vec_scalar_cmp_exp_gt\n+#define scalar_cmp_exp_lt __builtin_vec_scalar_cmp_exp_lt\n+#define scalar_cmp_exp_eq __builtin_vec_scalar_cmp_exp_eq\n+#define scalar_cmp_exp_unordered __builtin_vec_scalar_cmp_exp_unordered\n+\n #endif\n \n /* Predicates."}, {"sha": "a7d66ad2e5a1d0ecb4949c04f989a7a10402e5c3", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -147,6 +147,11 @@\n   (and (match_code \"const_int\")\n        (match_test \"INTVAL (op) >= 0 && INTVAL (op) <= 63\")))\n \n+;; Return 1 if op is an unsigned 7-bit constant integer.\n+(define_predicate \"u7bit_cint_operand\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 127)\")))\n+\n ;; Return 1 if op is a signed 8-bit constant integer.\n ;; Integer multiplication complete more quickly\n (define_predicate \"s8bit_cint_operand\""}, {"sha": "e1d53f117087182dbba84d505bb981ae04fc9cb9", "filename": "gcc/config/rs6000/rs6000-builtin.def", "status": "modified", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-builtin.def?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -799,6 +799,32 @@\n \t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n \t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n \n+#define BU_P9V_64BIT_VSX_1(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_1 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    (RS6000_BTM_64BIT\t\t\t\t\t\\\n+\t\t     | RS6000_BTM_P9_VECTOR),\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_UNARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P9V_VSX_2(ENUM, NAME, ATTR, ICODE)\t\t\t\t\\\n+  RS6000_BUILTIN_2 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    RS6000_BTM_P9_VECTOR,\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n+#define BU_P9V_64BIT_VSX_2(ENUM, NAME, ATTR, ICODE)\t\t\t\\\n+  RS6000_BUILTIN_2 (P9V_BUILTIN_ ## ENUM,\t\t/* ENUM */\t\\\n+\t\t    \"__builtin_vsx_\" NAME,\t\t/* NAME */\t\\\n+\t\t    (RS6000_BTM_64BIT\t\t\t\t\t\\\n+\t\t     | RS6000_BTM_P9_VECTOR),\t\t/* MASK */\t\\\n+\t\t    (RS6000_BTC_ ## ATTR\t\t/* ATTR */\t\\\n+\t\t     | RS6000_BTC_BINARY),\t\t\t\t\\\n+\t\t    CODE_FOR_ ## ICODE)\t\t\t/* ICODE */\n+\n #define BU_P9V_OVERLOAD_1(ENUM, NAME)\t\t\t\t\t\\\n   RS6000_BUILTIN_1 (P9V_BUILTIN_VEC_ ## ENUM,\t\t/* ENUM */\t\\\n \t\t    \"__builtin_vec_\" NAME,\t\t/* NAME */\t\\\n@@ -1799,6 +1825,74 @@ BU_P9V_OVERLOAD_2 (VADUB,\t\"vadub\")\n BU_P9V_OVERLOAD_2 (VADUH,\t\"vaduh\")\n BU_P9V_OVERLOAD_2 (VADUW,\t\"vaduw\")\n \n+/* 1 argument vsx scalar functions added in ISA 3.0 (power9).  */\n+BU_P9V_64BIT_VSX_1 (VSEEDP,\t\"scalar_extract_exp\",\tCONST,\txsxexpdp)\n+BU_P9V_64BIT_VSX_1 (VSESDP,\t\"scalar_extract_sig\",\tCONST,\txsxsigdp)\n+\n+BU_P9V_VSX_1 (VSTDCNDP,\t\"scalar_test_neg_dp\",\tCONST,\txststdcnegdp)\n+BU_P9V_VSX_1 (VSTDCNSP,\t\"scalar_test_neg_sp\",\tCONST,\txststdcnegsp)\n+\n+/* 2 argument vsx scalar functions added in ISA 3.0 (power9).  */\n+BU_P9V_64BIT_VSX_2 (VSIEDP,\t\"scalar_insert_exp\",\tCONST,\txsiexpdp)\n+\n+BU_P9V_VSX_2 (VSCEDPGT,\t\"scalar_cmp_exp_dp_gt\",\tCONST,\txscmpexpdp_gt)\n+BU_P9V_VSX_2 (VSCEDPLT,\t\"scalar_cmp_exp_dp_lt\",\tCONST,\txscmpexpdp_lt)\n+BU_P9V_VSX_2 (VSCEDPEQ,\t\"scalar_cmp_exp_dp_eq\",\tCONST,\txscmpexpdp_eq)\n+BU_P9V_VSX_2 (VSCEDPUO,\t\"scalar_cmp_exp_dp_unordered\",\tCONST,\txscmpexpdp_unordered)\n+\n+BU_P9V_VSX_2 (VSTDCDP,\t\"scalar_test_data_class_dp\",\tCONST,\txststdcdp)\n+BU_P9V_VSX_2 (VSTDCSP,\t\"scalar_test_data_class_sp\",\tCONST,\txststdcsp)\n+\n+/* ISA 3.0 vector scalar overloaded 1 argument functions.  */\n+BU_P9V_OVERLOAD_1 (VSEEDP,\t\"scalar_extract_exp\")\n+BU_P9V_OVERLOAD_1 (VSESDP,\t\"scalar_extract_sig\")\n+\n+BU_P9V_OVERLOAD_1 (VSTDCN,\t\"scalar_test_neg\")\n+BU_P9V_OVERLOAD_1 (VSTDCNDP,\t\"scalar_test_neg_dp\")\n+BU_P9V_OVERLOAD_1 (VSTDCNSP,\t\"scalar_test_neg_sp\")\n+\n+/* ISA 3.0 vector scalar overloaded 2 argument functions.  */\n+BU_P9V_OVERLOAD_2 (VSIEDP,\t\"scalar_insert_exp\")\n+\n+BU_P9V_OVERLOAD_2 (VSTDC,\t\"scalar_test_data_class\")\n+BU_P9V_OVERLOAD_2 (VSTDCDP,\t\"scalar_test_data_class_dp\")\n+BU_P9V_OVERLOAD_2 (VSTDCSP,\t\"scalar_test_data_class_sp\")\n+\n+BU_P9V_OVERLOAD_2 (VSCEDPGT,\t\"scalar_cmp_exp_gt\")\n+BU_P9V_OVERLOAD_2 (VSCEDPLT,\t\"scalar_cmp_exp_lt\")\n+BU_P9V_OVERLOAD_2 (VSCEDPEQ,\t\"scalar_cmp_exp_eq\")\n+BU_P9V_OVERLOAD_2 (VSCEDPUO,\t\"scalar_cmp_exp_unordered\")\n+\n+/* 1 argument vsx vector functions added in ISA 3.0 (power9).  */\n+BU_P9V_VSX_1 (VEEDP, \"extract_exp_dp\", CONST, xvxexpdp)\n+BU_P9V_VSX_1 (VEESP, \"extract_exp_sp\", CONST, xvxexpsp)\n+BU_P9V_VSX_1 (VESDP, \"extract_sig_dp\", CONST, xvxsigdp)\n+BU_P9V_VSX_1 (VESSP, \"extract_sig_sp\", CONST, xvxsigsp)\n+\n+/* 2 argument vsx vector functions added in ISA 3.0 (power9).  */\n+BU_P9V_VSX_2 (VIEDP, \"insert_exp_dp\", CONST, xviexpdp)\n+BU_P9V_VSX_2 (VIESP, \"insert_exp_sp\", CONST, xviexpsp)\n+BU_P9V_VSX_2 (VTDCDP, \"test_data_class_dp\", CONST, xvtstdcdp)\n+BU_P9V_VSX_2 (VTDCSP, \"test_data_class_sp\", CONST, xvtstdcsp)\n+\n+/* ISA 3.0 vector overloaded 1 argument functions.  */\n+BU_P9V_OVERLOAD_1 (VES,\t\t\"extract_sig\")\n+BU_P9V_OVERLOAD_1 (VESDP,\t\"extract_sig_dp\")\n+BU_P9V_OVERLOAD_1 (VESSP,\t\"extract_sig_sp\")\n+\n+BU_P9V_OVERLOAD_1 (VEE,\t\t\"extract_exp\")\n+BU_P9V_OVERLOAD_1 (VEEDP,\t\"extract_exp_dp\")\n+BU_P9V_OVERLOAD_1 (VEESP,\t\"extract_exp_sp\")\n+\n+/* ISA 3.0 vector overloaded 2 argument functions.  */\n+BU_P9V_OVERLOAD_2 (VTDC,\t\"test_data_class\")\n+BU_P9V_OVERLOAD_2 (VTDCDP,\t\"test_data_class_dp\")\n+BU_P9V_OVERLOAD_2 (VTDCSP,\t\"test_data_class_sp\")\n+\n+BU_P9V_OVERLOAD_2 (VIE,\t\t\"insert_exp\")\n+BU_P9V_OVERLOAD_2 (VIEDP,\t\"insert_exp_dp\")\n+BU_P9V_OVERLOAD_2 (VIESP,\t\"insert_exp_sp\")\n+\n \f\n /* 2 argument extended divide functions added in ISA 2.06.  */\n BU_P7_MISC_2 (DIVWE,\t\t\"divwe\",\tCONST,\tdive_si)"}, {"sha": "8dfb53fc1873ceb4d8d42a5505289b8750fa8945", "filename": "gcc/config/rs6000/rs6000-c.c", "status": "modified", "additions": 115, "deletions": 18, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-c.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -4302,6 +4302,84 @@ const struct altivec_builtin_types altivec_overloaded_builtins[] = {\n     RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI,\n     RS6000_BTI_unsigned_V4SI, 0 },\n \n+  { P9V_BUILTIN_VEC_VES, P9V_BUILTIN_VESSP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, 0, 0 },\n+  { P9V_BUILTIN_VEC_VES, P9V_BUILTIN_VESDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VESSP, P9V_BUILTIN_VESSP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, 0, 0 },\n+  { P9V_BUILTIN_VEC_VESDP, P9V_BUILTIN_VESDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VEE, P9V_BUILTIN_VEESP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, 0, 0 },\n+  { P9V_BUILTIN_VEC_VEE, P9V_BUILTIN_VEEDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VEESP, P9V_BUILTIN_VEESP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, 0, 0 },\n+  { P9V_BUILTIN_VEC_VEEDP, P9V_BUILTIN_VEEDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VTDC, P9V_BUILTIN_VTDCSP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, RS6000_BTI_UINTSI, 0 },\n+  { P9V_BUILTIN_VEC_VTDC, P9V_BUILTIN_VTDCDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, RS6000_BTI_UINTSI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VTDCSP, P9V_BUILTIN_VTDCSP,\n+    RS6000_BTI_V4SI, RS6000_BTI_V4SF, RS6000_BTI_UINTSI, 0 },\n+  { P9V_BUILTIN_VEC_VTDCDP, P9V_BUILTIN_VTDCDP,\n+    RS6000_BTI_V2DI, RS6000_BTI_V2DF, RS6000_BTI_UINTSI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VIE, P9V_BUILTIN_VIESP,\n+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },\n+  { P9V_BUILTIN_VEC_VIE, P9V_BUILTIN_VIEDP,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VIESP, P9V_BUILTIN_VIESP,\n+    RS6000_BTI_V4SF, RS6000_BTI_unsigned_V4SI, RS6000_BTI_unsigned_V4SI, 0 },\n+  { P9V_BUILTIN_VEC_VIEDP, P9V_BUILTIN_VIEDP,\n+    RS6000_BTI_V2DF, RS6000_BTI_unsigned_V2DI, RS6000_BTI_unsigned_V2DI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSTDC, P9V_BUILTIN_VSTDCSP,\n+    RS6000_BTI_UINTSI, RS6000_BTI_float, RS6000_BTI_UINTSI, 0 },\n+  { P9V_BUILTIN_VEC_VSTDC, P9V_BUILTIN_VSTDCDP,\n+    RS6000_BTI_UINTSI, RS6000_BTI_double, RS6000_BTI_UINTSI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSTDCSP, P9V_BUILTIN_VSTDCSP,\n+    RS6000_BTI_UINTSI, RS6000_BTI_float, RS6000_BTI_UINTSI, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCDP, P9V_BUILTIN_VSTDCDP,\n+    RS6000_BTI_UINTSI, RS6000_BTI_double, RS6000_BTI_UINTSI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSTDCN, P9V_BUILTIN_VSTDCNSP,\n+    RS6000_BTI_INTSI, RS6000_BTI_float, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCN, P9V_BUILTIN_VSTDCNDP,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSTDCNSP, P9V_BUILTIN_VSTDCNSP,\n+    RS6000_BTI_INTSI, RS6000_BTI_float, 0, 0 },\n+  { P9V_BUILTIN_VEC_VSTDCNDP, P9V_BUILTIN_VSTDCNDP,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSEEDP, P9V_BUILTIN_VSEEDP,\n+    RS6000_BTI_UINTSI, RS6000_BTI_double, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSESDP, P9V_BUILTIN_VSESDP,\n+    RS6000_BTI_UINTDI, RS6000_BTI_double, 0, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSIEDP, P9V_BUILTIN_VSIEDP,\n+    RS6000_BTI_double, RS6000_BTI_UINTDI, RS6000_BTI_UINTDI, 0 },\n+\n+  { P9V_BUILTIN_VEC_VSCEDPGT, P9V_BUILTIN_VSCEDPGT,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, RS6000_BTI_double, 0 },\n+  { P9V_BUILTIN_VEC_VSCEDPLT, P9V_BUILTIN_VSCEDPLT,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, RS6000_BTI_double, 0 },\n+  { P9V_BUILTIN_VEC_VSCEDPEQ, P9V_BUILTIN_VSCEDPEQ,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, RS6000_BTI_double, 0 },\n+  { P9V_BUILTIN_VEC_VSCEDPUO, P9V_BUILTIN_VSCEDPUO,\n+    RS6000_BTI_INTSI, RS6000_BTI_double, RS6000_BTI_double, 0 },\n+\n   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n     RS6000_BTI_V16QI, RS6000_BTI_V16QI, 0, 0 },\n   { P8V_BUILTIN_VEC_VGBBD, P8V_BUILTIN_VGBBD,\n@@ -5551,23 +5629,42 @@ altivec_resolve_overloaded_builtin (location_t loc, tree fndecl,\n       return build_int_cst (NULL_TREE, TYPE_VECTOR_SUBPARTS (types[0]));\n     }\n \n-  for (desc = altivec_overloaded_builtins;\n-       desc->code && desc->code != fcode; desc++)\n-    continue;\n-\n-  /* For arguments after the last, we have RS6000_BTI_NOT_OPAQUE in\n-     the opX fields.  */\n-  for (; desc->code == fcode; desc++)\n-    if ((desc->op1 == RS6000_BTI_NOT_OPAQUE\n-\t || rs6000_builtin_type_compatible (types[0], desc->op1))\n-\t&& (desc->op2 == RS6000_BTI_NOT_OPAQUE\n-\t    || rs6000_builtin_type_compatible (types[1], desc->op2))\n-\t&& (desc->op3 == RS6000_BTI_NOT_OPAQUE\n-\t    || rs6000_builtin_type_compatible (types[2], desc->op3))\n-\t&& rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n-      return altivec_build_resolved_builtin (args, n, desc);\n-\n+  {\n+    bool unsupported_builtin = false;\n+    for (desc = altivec_overloaded_builtins;\n+\t desc->code && desc->code != fcode; desc++)\n+      continue;\n+    \n+    /* For arguments after the last, we have RS6000_BTI_NOT_OPAQUE in\n+       the opX fields.  */\n+    for (; desc->code == fcode; desc++)\n+      {\n+\tif ((desc->op1 == RS6000_BTI_NOT_OPAQUE\n+\t     || rs6000_builtin_type_compatible (types[0], desc->op1))\n+\t    && (desc->op2 == RS6000_BTI_NOT_OPAQUE\n+\t\t|| rs6000_builtin_type_compatible (types[1], desc->op2))\n+\t    && (desc->op3 == RS6000_BTI_NOT_OPAQUE\n+\t\t|| rs6000_builtin_type_compatible (types[2], desc->op3)))\n+\t  {\n+\t    if (rs6000_builtin_decls[desc->overloaded_code] != NULL_TREE)\n+\t      return altivec_build_resolved_builtin (args, n, desc);\n+\t    else\n+\t      unsupported_builtin = true;\n+\t  }\n+      }\n+    \n+    if (unsupported_builtin)\n+      {\n+\tconst char *name = rs6000_overloaded_builtin_name (fcode);\n+\terror (\"Builtin function %s not supported in this compiler configuration\",\n+\t       name);\n+\treturn error_mark_node;\n+      }\n+  }\n  bad:\n-  error (\"invalid parameter combination for AltiVec intrinsic\");\n-  return error_mark_node;\n+    {\n+      const char *name = rs6000_overloaded_builtin_name (fcode);\n+      error (\"invalid parameter combination for AltiVec intrinsic %s\", name);\n+      return error_mark_node;\n+    }\n }"}, {"sha": "c15703b12e06df9e8a06bc35770162a418fbbae2", "filename": "gcc/config/rs6000/rs6000-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-protos.h?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -218,6 +218,7 @@ extern void rs6000_sibcall_aix (rtx, rtx, rtx, rtx);\n extern void rs6000_aix_asm_output_dwarf_table_ref (char *);\n extern void get_ppc476_thunk_name (char name[32]);\n extern bool rs6000_overloaded_builtin_p (enum rs6000_builtins);\n+extern const char *rs6000_overloaded_builtin_name (enum rs6000_builtins);\n extern HOST_WIDE_INT rs6000_builtin_mask_calculate (void);\n extern void rs6000_asm_output_dwarf_pcrel (FILE *file, int size,\n \t\t\t\t\t   const char *label);"}, {"sha": "cfc4e0142fd379e3819cda2fe56b27d75fabd5c1", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -13572,6 +13572,12 @@ rs6000_overloaded_builtin_p (enum rs6000_builtins fncode)\n   return (rs6000_builtin_info[(int)fncode].attr & RS6000_BTC_OVERLOADED) != 0;\n }\n \n+const char *\n+rs6000_overloaded_builtin_name (enum rs6000_builtins fncode)\n+{\n+  return rs6000_builtin_info[(int)fncode].name;\n+}\n+\n /* Expand an expression EXP that calls a builtin without arguments.  */\n static rtx\n rs6000_expand_zeroop_builtin (enum insn_code icode, rtx target)\n@@ -13791,6 +13797,20 @@ rs6000_expand_binop_builtin (enum insn_code icode, tree exp, rtx target)\n \t  return CONST0_RTX (tmode);\n \t}\n     }\n+  else if (icode == CODE_FOR_xststdcdp\n+\t   || icode == CODE_FOR_xststdcsp\n+\t   || icode == CODE_FOR_xvtstdcdp\n+\t   || icode == CODE_FOR_xvtstdcsp)\n+    {\n+      /* Only allow 7-bit unsigned literals. */\n+      STRIP_NOPS (arg1);\n+      if (TREE_CODE (arg1) != INTEGER_CST\n+\t  || !IN_RANGE (TREE_INT_CST_LOW (arg1), 0, 127))\n+\t{\n+\t  error (\"argument 2 must be a 7-bit unsigned literal\");\n+\t  return CONST0_RTX (tmode);\n+\t}\n+    }\n \n   if (target == 0\n       || GET_MODE (target) != tmode\n@@ -15901,6 +15921,10 @@ rs6000_invalid_builtin (enum rs6000_builtins fncode)\n     error (\"Builtin function %s requires the -mhard-dfp option\", name);\n   else if ((fnmask & RS6000_BTM_P8_VECTOR) != 0)\n     error (\"Builtin function %s requires the -mpower8-vector option\", name);\n+  else if ((fnmask & (RS6000_BTM_P9_VECTOR | RS6000_BTM_64BIT))\n+\t   == (RS6000_BTM_P9_VECTOR | RS6000_BTM_64BIT))\n+    error (\"Builtin function %s requires the -mcpu=power9 and\"\n+\t   \" -m64 options\", name);\n   else if ((fnmask & RS6000_BTM_P9_VECTOR) != 0)\n     error (\"Builtin function %s requires the -mcpu=power9 option\", name);\n   else if ((fnmask & (RS6000_BTM_P9_MISC | RS6000_BTM_64BIT))"}, {"sha": "1896de9e9b60ff628c623cafbd224637c4bedf73", "filename": "gcc/config/rs6000/vsx.md", "status": "modified", "additions": 165, "deletions": 0, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Fvsx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fconfig%2Frs6000%2Fvsx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fvsx.md?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -18,6 +18,9 @@\n ;; along with GCC; see the file COPYING3.  If not see\n ;; <http://www.gnu.org/licenses/>.\n \n+;; Iterator for comparison types\n+(define_code_iterator CMP_TEST [eq lt gt unordered])\n+\n ;; Iterator for both scalar and vector floating point types supported by VSX\n (define_mode_iterator VSX_B [DF V4SF V2DF])\n \n@@ -311,6 +314,15 @@\n    UNSPEC_P9_MEMORY\n    UNSPEC_VSX_VSLO\n    UNSPEC_VSX_EXTRACT\n+   UNSPEC_VSX_SXEXPDP\n+   UNSPEC_VSX_SXSIGDP\n+   UNSPEC_VSX_SIEXPDP\n+   UNSPEC_VSX_SCMPEXPDP\n+   UNSPEC_VSX_STSTDC\n+   UNSPEC_VSX_VXEXP\n+   UNSPEC_VSX_VXSIG\n+   UNSPEC_VSX_VIEXP\n+   UNSPEC_VSX_VTSTDC\n   ])\n \n ;; VSX moves\n@@ -2995,3 +3007,156 @@\n    mfvsrd %0,%x1\n    stxsi<wd>x %x1,%y0\"\n   [(set_attr \"type\" \"mffgpr,fpstore\")])\n+\n+;; ISA 3.0 Binary Floating-Point Support\n+\n+;; VSX Scalar Extract Exponent Double-Precision\n+(define_insn \"xsxexpdp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DF 1 \"vsx_register_operand\" \"wa\")]\n+\t UNSPEC_VSX_SXEXPDP))]\n+  \"TARGET_P9_VECTOR && TARGET_64BIT\"\n+  \"xsxexpdp %0,%x1\"\n+  [(set_attr \"type\" \"integer\")])\n+\n+;; VSX Scalar Extract Significand Double-Precision\n+(define_insn \"xsxsigdp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(unspec:DI [(match_operand:DF 1 \"vsx_register_operand\" \"wa\")]\n+\t UNSPEC_VSX_SXSIGDP))]\n+  \"TARGET_P9_VECTOR && TARGET_64BIT\"\n+  \"xsxsigdp %0,%x1\"\n+  [(set_attr \"type\" \"integer\")])\n+\n+;; VSX Scalar Insert Exponent Double-Precision\n+(define_insn \"xsiexpdp\"\n+  [(set (match_operand:DF 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:DF [(match_operand:DI 1 \"register_operand\" \"r\")\n+\t\t    (match_operand:DI 2 \"register_operand\" \"r\")]\n+\t UNSPEC_VSX_SIEXPDP))]\n+  \"TARGET_P9_VECTOR && TARGET_64BIT\"\n+  \"xsiexpdp %x0,%1,%2\"\n+  [(set_attr \"type\" \"fpsimple\")])\n+\n+;; VSX Scalar Compare Exponents Double-Precision\n+(define_expand \"xscmpexpdp_<code>\"\n+  [(set (match_dup 3)\n+\t(compare:CCFP\n+\t (unspec:DF\n+\t  [(match_operand:DF 1 \"vsx_register_operand\" \"wa\")\n+\t   (match_operand:DF 2 \"vsx_register_operand\" \"wa\")]\n+\t  UNSPEC_VSX_SCMPEXPDP)\n+\t (const_int 0)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(CMP_TEST:SI (match_dup 3)\n+\t\t     (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  operands[3] = gen_reg_rtx (CCFPmode);\n+})\n+\n+(define_insn \"*xscmpexpdp\"\n+  [(set (match_operand:CCFP 0 \"cc_reg_operand\" \"=y\")\n+\t(compare:CCFP\n+\t (unspec:DF [(match_operand:DF 1 \"vsx_register_operand\" \"wa\")\n+\t\t     (match_operand:DF 2 \"vsx_register_operand\" \"wa\")]\n+\t  UNSPEC_VSX_SCMPEXPDP)\n+\t (match_operand:SI 3 \"zero_constant\" \"j\")))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xscmpexpdp %0,%x1,%x2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+;; VSX Scalar Test Data Class Double- and Single-Precision\n+;;  (The lt bit is set if operand 1 is negative.  The eq bit is set\n+;;   if any of the conditions tested by operand 2 are satisfied.\n+;;   The gt and unordered bits are cleared to zero.)\n+(define_expand \"xststdc<Fvsx>\"\n+  [(set (match_dup 3)\n+\t(compare:CCFP\n+\t (unspec:SFDF\n+\t  [(match_operand:SFDF 1 \"vsx_register_operand\" \"wa\")\n+\t   (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (match_dup 4)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(eq:SI (match_dup 3)\n+\t       (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  operands[3] = gen_reg_rtx (CCFPmode);\n+  operands[4] = CONST0_RTX (SImode);\n+})\n+\n+;; The VSX Scalar Test Data Class Double- and Single-Precision\n+;; instruction may also be used to test for negative value.\n+(define_expand \"xststdcneg<Fvsx>\"\n+  [(set (match_dup 2)\n+\t(compare:CCFP\n+\t (unspec:SFDF\n+\t  [(match_operand:SFDF 1 \"vsx_register_operand\" \"wa\")\n+\t   (const_int 0)]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (match_dup 3)))\n+   (set (match_operand:SI 0 \"register_operand\" \"=r\")\n+\t(lt:SI (match_dup 2)\n+\t       (const_int 0)))]\n+  \"TARGET_P9_VECTOR\"\n+{\n+  operands[2] = gen_reg_rtx (CCFPmode);\n+  operands[3] = CONST0_RTX (SImode);\n+})\n+\n+(define_insn \"*xststdc<Fvsx>\"\n+  [(set (match_operand:CCFP 0 \"\" \"=y\")\n+\t(compare:CCFP\n+\t (unspec:SFDF [(match_operand:SFDF 1 \"vsx_register_operand\" \"wa\")\n+\t\t       (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t  UNSPEC_VSX_STSTDC)\n+\t (match_operand:SI 3 \"zero_constant\" \"j\")))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xststdc<Fvsx> %0,%x1,%2\"\n+  [(set_attr \"type\" \"fpcompare\")])\n+\n+;; VSX Vector Extract Exponent Double and Single Precision\n+(define_insn \"xvxexp<VSs>\"\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:VSX_F\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"wa\")]\n+\t UNSPEC_VSX_VXEXP))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xvxexp<VSs> %x0,%x1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; VSX Vector Extract Significand Double and Single Precision\n+(define_insn \"xvxsig<VSs>\"\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:VSX_F\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"wa\")]\n+\t UNSPEC_VSX_VXSIG))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xvxsig<VSs> %x0,%x1\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; VSX Vector Insert Exponent Double and Single Precision\n+(define_insn \"xviexp<VSs>\"\n+  [(set (match_operand:VSX_F 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:VSX_F\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"wa\")\n+\t  (match_operand:VSX_F 2 \"vsx_register_operand\" \"wa\")]\n+\t UNSPEC_VSX_VIEXP))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xviexp<VSs> %x0,%x1,%x2\"\n+  [(set_attr \"type\" \"vecsimple\")])\n+\n+;; VSX Vector Test Data Class Double and Single Precision\n+;; The corresponding elements of the result vector are all ones\n+;; if any of the conditions tested by operand 3 are satisfied.\n+(define_insn \"xvtstdc<VSs>\"\n+  [(set (match_operand:<VSI> 0 \"vsx_register_operand\" \"=wa\")\n+\t(unspec:<VSI>\n+\t [(match_operand:VSX_F 1 \"vsx_register_operand\" \"wa\")\n+\t  (match_operand:SI 2 \"u7bit_cint_operand\" \"n\")]\n+\t UNSPEC_VSX_VTSTDC))]\n+  \"TARGET_P9_VECTOR\"\n+  \"xvtstdc<VSs> %x0,%x1,%2\"\n+  [(set_attr \"type\" \"vecsimple\")])"}, {"sha": "5285e002d7e28ae2da38c29731f01f709e9d94fa", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -14916,6 +14916,23 @@ int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov (unsigned int comparison, _Decimal128 value);\n int __builtin_dfp_dtstsfi_ov_dd (unsigned int comparison, _Decimal64 value);\n int __builtin_dfp_dtstsfi_ov_td (unsigned int comparison, _Decimal128 value);\n+\n+unsigned int scalar_extract_exp (double source);\n+unsigned long long int scalar_extract_sig (double source);\n+\n+double\n+scalar_insert_exp (unsigned long long int significand, unsigned long long int exponent);\n+\n+int scalar_cmp_exp_gt (double arg1, double arg2);\n+int scalar_cmp_exp_lt (double arg1, double arg2);\n+int scalar_cmp_exp_eq (double arg1, double arg2);\n+int scalar_cmp_exp_unordered (double arg1, double arg2);\n+\n+int scalar_test_data_class (float source, unsigned int condition);\n+int scalar_test_data_class (double source, unsigned int condition);\n+\n+int scalar_test_neg (float source);\n+int scalar_test_neg (double source);\n @end smallexample\n \n The @code{__builtin_darn} and @code{__builtin_darn_raw}\n@@ -14926,6 +14943,50 @@ random number.  The @code{__builtin_darn_raw} function provides a\n 64-bit raw random number.  The @code{__builtin_darn_32} function\n provides a 32-bit random number.\n \n+The @code{scalar_extract_sig} and @code{scalar_insert_exp}\n+functions require a 64-bit environment supporting ISA 3.0 or later.\n+The @code{scalar_extract_exp} and @code{vec_extract_sig} built-in\n+functions return the significand and exponent respectively of their\n+@code{source} arguments.  The\n+@code{scalar_insert_exp} built-in function returns a double-precision\n+floating point value that is constructed by assembling the values of its\n+@code{significand} and @code{exponent} arguments.  The sign of the\n+result is copied from the most significant bit of the\n+@code{significand} argument.  The significand and exponent components\n+of the result are composed of the least significant 11 bits of the\n+@code{significand} argument and the least significant 52 bits of the\n+@code{exponent} argument.\n+\n+The @code{scalar_cmp_exp_gt}, @code{scalar_cmp_exp_lt},\n+@code{scalar_cmp_exp_eq}, and @code{scalar_cmp_exp_unordered} built-in\n+functions return a non-zero value if @code{arg1} is greater than, less\n+than, equal to, or not comparable to @code{arg2} respectively.  The\n+arguments are not comparable if one or the other equals NaN (not a\n+number). \n+\n+The @code{scalar_test_data_class} built-in functions return a non-zero\n+value if any of the condition tests enabled by the value of the\n+@code{condition} variable are true.  The\n+@code{condition} argument must be an unsigned integer with value not\n+exceeding 127.  The\n+@code{condition} argument is encoded as a bitmask with each bit\n+enabling the testing of a different condition, as characterized by the\n+following:\n+@smallexample\n+0x40    Test for NaN\n+0x20    Test for +Infinity\n+0x10    Test for -Infinity\n+0x08    Test for +Zero\n+0x04    Test for -Zero\n+0x02    Test for +Denormal\n+0x01    Test for -Denormal\n+@end smallexample\n+\n+If all of the enabled test conditions are false, the return value is 0.\n+\n+The @code{scalar_test_neg} built-in functions return a non-zero value\n+if their @code{source} argument holds a negative value.\n+\n The @code{__builtin_dfp_dtstsfi_lt} function returns a non-zero value\n if and only if the number of signficant digits of its @code{value} argument\n is less than its @code{comparison} argument.  The\n@@ -17653,6 +17714,66 @@ differences of the pairs of vector elements supplied in its two vector\n arguments, placing the absolute differences into the corresponding\n elements of the vector result.\n \n+The following built-in functions are available for the PowerPC family\n+of processors, starting with ISA 3.0 or later (@option{-mcpu=power9}):\n+@smallexample\n+__vector int\n+vec_extract_exp (__vector float source);\n+__vector long long int\n+vec_extract_exp (__vector double source);\n+\n+__vector int\n+vec_extract_sig (__vector float source);\n+__vector long long int\n+vec_extract_sig (__vector double source);\n+\n+__vector float\n+vec_insert_exp (__vector unsigned int significands,  __vector unsigned int exponents);\n+__vector double\n+vec_insert_exp (__vector unsigned long long int significands,\n+                __vector unsigned long long int exponents);\n+\n+__vector int vec_test_data_class (__vector float source, unsigned int condition);\n+__vector long long int vec_test_data_class (__vector double source, unsigned int condition);\n+@end smallexample\n+\n+The @code{vec_extract_sig} and @code{vec_extract_exp} built-in\n+functions return vectors representing the significands and exponents\n+of their @code{source} arguments respectively.  The\n+@code{vec_insert_exp} built-in functions return a vector of single- or\n+double-precision floating\n+point values constructed by assembling the values of their\n+@code{significands} and @code{exponents} arguments into the\n+corresponding elements of the returned vector.  The sign of each\n+element of the result is copied from the most significant bit of the\n+corresponding entry within the @code{significands} argument.  The\n+significand and exponent components of each element of the result are\n+composed of the least significant bits of the corresponding\n+@code{significands} element and the least significant bits of the\n+corresponding @code{exponents} element.\n+\n+The @code{vec_test_data_class} built-in function returns a vector\n+representing the results of testing the @code{source} vector for the\n+condition selected by the @code{condition} argument.  The\n+@code{condition} argument must be an unsigned integer with value not\n+exceeding 127.  The\n+@code{condition} argument is encoded as a bitmask with each bit\n+enabling the testing of a different condition, as characterized by the\n+following:\n+@smallexample\n+0x40    Test for NaN\n+0x20    Test for +Infinity\n+0x10    Test for -Infinity\n+0x08    Test for +Zero\n+0x04    Test for -Zero\n+0x02    Test for +Denormal\n+0x01    Test for -Denormal\n+@end smallexample\n+\n+If any of the enabled test conditions is true, the corresponding entry\n+in the result vector is -1.  Otherwise (all of the enabled test\n+conditions are false), the corresponding entry of the result vector is 0.\n+\n If the cryptographic instructions are enabled (@option{-mcrypto} or\n @option{-mcpu=power8}), the following builtins are enabled.\n "}, {"sha": "d9c6907ce1116bde23a97d887f1e96c598b613da", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -1,3 +1,60 @@\n+2016-08-10  Kelvin Nilsen  <kelvin@gcc.gnu.org>\n+\n+\t* gcc.target/powerpc/bfp/bfp.exp: New file.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-eq-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-gt-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-lt-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-exp-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-extract-sig-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-insert-exp-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-3.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-4.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-5.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-6.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-data-class-7.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-0.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-1.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-2.c: New test.\n+\t* gcc.target/powerpc/bfp/scalar-test-neg-3.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-0.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-1.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-2.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-exp-3.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-0.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-1.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-2.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-extract-sig-3.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-0.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-1.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-2.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-insert-exp-3.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-0.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-1.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-2.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-3.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-4.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-5.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-6.c: New test.\n+\t* gcc.target/powerpc/bfp/vec-test-data-class-7.c: New test.\n+\n 2016-08-10  Bin Cheng  <bin.cheng@arm.com>\n \n \t* lib/target-supports.exp (check_effective_target_vect_cond_mixed):"}, {"sha": "fcce6961a11f1b4967a6b6ade9503fc8e62f3dac", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/bfp.exp", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fbfp.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fbfp.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fbfp.exp?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,40 @@\n+# Copyright (C) 2014-2016 Free Software Foundation, Inc.\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 3, or (at your option)\n+# any later version.\n+#\n+# GCC is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.\n+\n+# Exit immediately if this isn't a PowerPC target or if the target is aix.\n+if { (![istarget powerpc*-*-*] && ![istarget rs6000-*-*])\n+     || [istarget \"powerpc*-*-aix*\"] } then {\n+  return\n+}\n+\n+global DEFAULT_CFLAGS\n+if ![info exists DEFAULT_CFLAGS] then {\n+  set DEFAULT_CFLAGS \" -ansi -pedantic-errors\"\n+}\n+\n+# Load support procs.\n+load_lib gcc-dg.exp\n+load_lib torture-options.exp\n+\n+# Initialize.\n+dg-init\n+\n+dg-runtest [lsort [glob -nocomplain $srcdir/$subdir/*.c*]] \"\" $DEFAULT_CFLAGS\n+\n+# All done.\n+dg-finish"}, {"sha": "303fede966fd0aa215d01faf34bcc26247779962", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-eq-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_eq (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_eq (exponent1, exponent2);\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "98adc134ff6c4895da7abc0ff2ca0c00f67cd2f1", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-eq-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+char\n+compare_exponents_eq (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_eq (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "45f0df8989463a0439358c5ac2836096adcc5ff3", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-eq-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-eq-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_eq (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return __builtin_vec_scalar_cmp_exp_eq (exponent1, exponent2);\t/* { dg-error \"Builtin function __builtin_vsx_scalar_cmp_exp_dp_eq requires\" } */\n+}"}, {"sha": "d87c617608450fd8ba8b70144886808c425a7ceb", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-gt-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_gt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_gt (exponent1, exponent2);\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "3adccebbd9d6d4865c286430737061406e89ec18", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-gt-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+char\n+compare_exponents_gt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_gt (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "0ccf1ceea2a7e7f5495ffffd52980f3f7a9b94b1", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-gt-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-gt-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_gt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return __builtin_vec_scalar_cmp_exp_gt (exponent1, exponent2); /* { dg-error \"Builtin function __builtin_vsx_scalar_cmp_exp_dp_gt requires\" } */\n+}"}, {"sha": "d6a671042631810e0d2139e3de29b98a0329c701", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-lt-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_lt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_lt (exponent1, exponent2);\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "14bae66570d44706c81f693c25668b98d4f4a29a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-lt-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+char\n+compare_exponents_lt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_lt (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "e453f236c6630c126e5c49972d15c71c0edaaba7", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-lt-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-lt-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_lt (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return __builtin_vec_scalar_cmp_exp_lt (exponent1, exponent2);\t/* { dg-error \"Builtin function __builtin_vsx_scalar_cmp_exp_dp_lt requires\" } */\n+}"}, {"sha": "0cd240a23a3a318d127b633c70712999f9e1bccc", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_unordered (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return scalar_cmp_exp_unordered (exponent1, exponent2);\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "2372b61049df68a6416e73c58100bd0325dafabc", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+char\n+compare_exponents_unordered (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  if (scalar_cmp_exp_unordered (exponent1, exponent2))\n+    return 't';\n+  else\n+    return 'f';\n+}\n+\n+/* { dg-final { scan-assembler \"xscmpexpdp\" } } */"}, {"sha": "dcedf0de887be1bd84a56486cd70319cfadbdbad", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-cmp-exp-unordered-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-cmp-exp-unordered-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed on 32-bit and 64-bit configurations.  */\n+#include <altivec.h>\n+\n+int\n+compare_exponents_unordered (double *exponent1_p, double *exponent2_p)\n+{\n+  double exponent1 = *exponent1_p;\n+  double exponent2 = *exponent2_p;\n+\n+  return __builtin_vec_scalar_cmp_exp_unordered (exponent1, exponent2);\t/* { dg-error \"Builtin function __builtin_vsx_scalar_cmp_exp_dp_unordered requires\" } */\n+}"}, {"sha": "a8d51df76ac7f8a6f1bae2165f29362eb980806e", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned int\n+get_exponent (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_extract_exp (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xsxexpdp\" } } */"}, {"sha": "e2f045cdce859e051cdc1319fd369148ddc0c811", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned int\n+get_exponent (double *p)\n+{\n+  double source = *p;\n+\n+  return __builtin_vec_scalar_extract_exp (source); /* { dg-error \"Builtin function __builtin_vsx_scalar_extract_exp requires\" } */\n+}\n+\n+"}, {"sha": "a60b54a6089345b082f73e7dd472fc5b0cf7d4fe", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-exp-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-exp-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, where a compiler error\n+   should be issued because this builtin is not available on \n+   32-bit configurations.  */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+get_exponent (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_extract_exp (source);\t/* { dg-error \"Builtin function __builtin_vec_scalar_extract_exp not supported in this compiler configuration\" } */\n+}\n+\n+"}, {"sha": "300587ecd5289c1e057f5499337a4f0226541c4d", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_significand (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_extract_sig (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xsxsigdp\" } } */"}, {"sha": "b2e5647673d21556f0e8707610497d0f60b6f727", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_significand (double *p)\n+{\n+  double source = *p;\n+\n+  return __builtin_vec_scalar_extract_sig (source);\t/* { dg-error \"Builtin function __builtin_vsx_scalar_extract_sig requires\" } */\n+}"}, {"sha": "237bd027cab6a4c5b72686d77b373823c467454c", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-extract-sig-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-extract-sig-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, producing a compiler\n+   error because the builtin requires 64 bits.  */\n+#include <altivec.h>\n+\n+unsigned long long int\n+get_significand (double *p)\n+{\n+  double source = *p;\n+\n+  return __builtin_vec_scalar_extract_sig (source); /* { dg-error \"Builtin function __builtin_vec_scalar_extract_sig not supported in this compiler configuration\" } */\n+}"}, {"sha": "cda0394ae8fecbaff10e4b1cdfd0a74118917050", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-0.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+double\n+insert_exponent (unsigned long long int *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned long long int significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent);\n+}\n+\n+/* { dg-final { scan-assembler \"xsiexpdp\" } } */"}, {"sha": "f2b720f444bc56c1b5681ba236c620aed8cafa55", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+/* This test should succeed only on 64-bit configurations.  */\n+#include <altivec.h>\n+\n+double\n+insert_exponent (unsigned long long int *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned long long int significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return __builtin_vec_scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vsx_scalar_insert_exp requires\" } */\n+}"}, {"sha": "5044c81f0694b06564ac228d884f1d8d03246538", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-insert-exp-2.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-insert-exp-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target ilp32 } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+/* This test only runs on 32-bit configurations, where a compiler error\n+   should be issued because this builtin is not available on \n+   32-bit configurations.  */\n+\n+#include <altivec.h>\n+\n+double\n+insert_exponent (unsigned long long int *significand_p,\n+\t\t unsigned long long int *exponent_p)\n+{\n+  unsigned long long int significand = *significand_p;\n+  unsigned long long int exponent = *exponent_p;\n+\n+  return scalar_insert_exp (significand, exponent); /* { dg-error \"Builtin function __builtin_vec_scalar_insert_exp not supported in this compiler configuration\" } */\n+}"}, {"sha": "c7fe4b3807690a86762ae8bc05433d890f4a6951", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_test_data_class (source, 3);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcdp\" } } */"}, {"sha": "0b074c2694b4d412b055bcab40e37a0bf95e2c39", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (float *p)\n+{\n+  float source = *p;\n+\n+  return scalar_test_data_class (source, 3);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcsp\" } } */"}, {"sha": "6e2955e18e49ffae259c50b207761a4999bdd50c", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_test_data_class (source, 256);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "ef8ec708abcfe63483b1965aae48ca0d74c06478", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-3.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (float *p)\n+{\n+  float source = *p;\n+\n+  return scalar_test_data_class (source, 256);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "e5c7770ea34a161d7ea22d96b778a1622747b003", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-4.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (double *p, unsigned int condition_flag)\n+{\n+  double source = *p;\n+\n+  return scalar_test_data_class (source, condition_flag); /* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "1051ad13de55961d1585ecdea2aab2f5ec72533f", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-5.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (float *p, unsigned int condition_flag)\n+{\n+  float source = *p;\n+\n+  return scalar_test_data_class (source, condition_flag);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}\n+"}, {"sha": "56489aac34c4af46dce30312255bfd5e82abccc0", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-6.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (double *p)\n+{\n+  double source = *p;\n+\n+  return __builtin_vec_scalar_test_data_class (source, 3); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_data_class_dp requires\" } */\n+}"}, {"sha": "eae63459d45f8a22cbe4a342d10bfb51248e498c", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-data-class-7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-data-class-7.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_data_class (float *p)\n+{\n+  float source = *p;\n+\n+  return __builtin_vec_scalar_test_data_class (source, 3); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_data_class_sp requires\" } */\n+}"}, {"sha": "94f4c285a14f857a55c4910cd8572075ea65a808", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_neg (double *p)\n+{\n+  double source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcdp\" } } */"}, {"sha": "b79d1f997fe2e3c4fd753821fcaaaecd15357da7", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_neg (float *p)\n+{\n+  float source = *p;\n+\n+  return scalar_test_neg (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xststdcsp\" } } */"}, {"sha": "bfc0552b905f00c3e2dfc893a2d2f13b51dd3040", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_neg (float *p)\n+{\n+  float source = *p;\n+\n+  return __builtin_vec_scalar_test_neg_sp (source); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_neg_sp requires\" } */\n+}"}, {"sha": "712788285cca6ac3039ba73c19131c51ced092d3", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/scalar-test-neg-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fscalar-test-neg-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+unsigned int\n+test_neg (double *p)\n+{\n+  double source = *p;\n+\n+  return __builtin_vec_scalar_test_neg_dp (source); /* { dg-error \"Builtin function __builtin_vsx_scalar_test_neg_dp requires\" } */\n+}"}, {"sha": "75eea0ebe291cde599c6e7e2a1bedd8c93dbf32f", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_exponents (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_extract_exp (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xvxexpsp\" } } */"}, {"sha": "ed464cc2eadc9ecce36e22a8920b5712ec2d19e2", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_exponents (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_extract_exp (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xvxexpdp\" } } */"}, {"sha": "0b456e4d3e97314c646ee28b38c344455d220a88", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_exponents (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return __builtin_vec_extract_exp (source); /* { dg-error \"Builtin function __builtin_vsx_extract_exp_dp requires\" } */\n+}"}, {"sha": "09e0724f7293d8536cdd3e853eeec1e38eea70ee", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-exp-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-exp-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_exponents (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return __builtin_vec_extract_exp (source);\t/* { dg-error \"Builtin function __builtin_vsx_extract_exp_sp requires\" } */\n+}"}, {"sha": "c675809192256e786c43df6d2e2645c143ee9be7", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_significands (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_extract_sig (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xvxsigsp\" } } */"}, {"sha": "f244942c6c4eba62eb0e6f18b5d853f8b963bdcf", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_significands (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_extract_sig (source);\n+}\n+\n+/* { dg-final { scan-assembler \"xvxsigdp\" } } */"}, {"sha": "5d1d1223baee93ff343ba2bc5a55b6b3d8da1234", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_significands (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return __builtin_vec_extract_sig (source);\t/* { dg-error \"Builtin function __builtin_vsx_extract_sig_dp requires\" } */\n+}"}, {"sha": "40d0c47873b8929c765931c036ac90dcde6e1114", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-extract-sig-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-extract-sig-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_significands (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return __builtin_vec_extract_sig (source);\t/* { dg-error \"Builtin function __builtin_vsx_extract_sig_sp requires\" } */\n+}"}, {"sha": "917ff71455799588070dde69bebcabf018357e78", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-0.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector float\n+make_floats (__vector unsigned int *significands_p, \n+\t     __vector unsigned int *exponents_p)\n+{\n+  __vector unsigned int significands = *significands_p;\n+  __vector unsigned int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+/* { dg-final { scan-assembler \"xviexpsp\" } } */"}, {"sha": "de4def1b6d19d94661e843620fb8a8a75001839e", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector double\n+make_doubles (__vector unsigned long long int *significands_p,\n+\t      __vector unsigned long long int *exponents_p)\n+{\n+  __vector unsigned long long int significands = *significands_p;\n+  __vector unsigned long long int exponents = *exponents_p;\n+\n+  return vec_insert_exp (significands, exponents);\n+}\n+\n+/* { dg-final { scan-assembler \"xviexpdp\" } } */"}, {"sha": "1a02bf2d81d2e2f42123f57ee74adaa0fb937335", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-2.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector float\n+make_floats (__vector unsigned int *significands_p, \n+\t     __vector unsigned int *exponents_p)\n+{\n+  __vector unsigned int significands = *significands_p;\n+  __vector unsigned int exponents = *exponents_p;\n+\n+  return __builtin_vec_insert_exp (significands, exponents); /* { dg-error \"Builtin function __builtin_vsx_insert_exp_sp requires\" } */\n+}"}, {"sha": "97d44719943b9f22fab8494844169c5d42daf77a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-insert-exp-3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-insert-exp-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector double\n+make_doubles (__vector unsigned long long int *significands_p,\n+\t      __vector unsigned long long int *exponents_p)\n+{\n+  __vector unsigned long long int significands = *significands_p;\n+  __vector unsigned long long int exponents = *exponents_p;\n+\n+  return __builtin_vec_insert_exp (significands, exponents); /* { dg-error \"Builtin function __builtin_vsx_insert_exp_dp requires\" } */\n+}"}, {"sha": "65b2786f445040dc92e5f4937a2e40066be2adae", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-0.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-0.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_data_class_flags (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 0x37);\n+}\n+\n+/* { dg-final { scan-assembler \"xvtstdcsp\" } } */"}, {"sha": "7db579719adaa4151bd9971b4586f2e750428774", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-1.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-1.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_data_class_flags (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 0x37);\n+}\n+\n+/* { dg-final { scan-assembler \"xvtstdcdp\" } } */"}, {"sha": "cdcc19e511f938ccd8cf3b4855f4680d7138133b", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-2.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_data_class_flags (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return __builtin_vec_test_data_class (source, 0x37); /* { dg-error \"Builtin function __builtin_vsx_test_data_class_dp requires\" } */\n+}"}, {"sha": "23f5acefcc2be4d7795de861de4d80681e138955", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-3.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power8\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power8\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_data_class_flags (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return __builtin_vec_test_data_class (source, 0x37); /* { dg-error \"Builtin function __builtin_vsx_test_data_class_sp requires\" } */\n+}"}, {"sha": "91c2293ea1666be950d48844ef70b3d864b40d6a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-4.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_data_class_flags (__vector float *p)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, 256);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}"}, {"sha": "cf46d8590a87ef26978ab0aa9ec2d0d312f73968", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-5.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-5.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_data_class_flags (__vector double *p)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, 256);\t/* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}"}, {"sha": "b780adcf53201a7f063d2e8cbbfc958dc7d8a94a", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-6.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector int\n+get_data_class_flags (__vector float *p, unsigned int condition_flag)\n+{\n+  __vector float source = *p;\n+\n+  return vec_test_data_class (source, condition_flag); /* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}"}, {"sha": "3fde79314edaae205e61b8e9d366b7f7fefa8db9", "filename": "gcc/testsuite/gcc.target/powerpc/bfp/vec-test-data-class-7.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e9e6d4f6cc2c0a3407c527f4c786b46508cb3366/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fpowerpc%2Fbfp%2Fvec-test-data-class-7.c?ref=e9e6d4f6cc2c0a3407c527f4c786b46508cb3366", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile { target { powerpc*-*-* } } } */\n+/* { dg-skip-if \"do not override -mcpu\" { powerpc*-*-* } { \"-mcpu=*\" } { \"-mcpu=power9\" } } */\n+/* { dg-require-effective-target powerpc_p9vector_ok } */\n+/* { dg-options \"-mcpu=power9\" } */\n+\n+#include <altivec.h>\n+\n+__vector long long int\n+get_data_class_flags (__vector double *p, unsigned int condition_flag)\n+{\n+  __vector double source = *p;\n+\n+  return vec_test_data_class (source, condition_flag); /* { dg-error \"argument 2 must be a 7-bit unsigned literal\" } */\n+}"}]}