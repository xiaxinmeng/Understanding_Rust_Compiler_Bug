{"sha": "f624ffa71f84afc0f8fb14e76a664a4556574efd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYyNGZmYTcxZjg0YWZjMGY4ZmIxNGU3NmE2NjRhNDU1NjU3NGVmZA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-05-28T01:03:16Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-05-28T01:03:16Z"}, "message": "cpplex.c (_cpp_lex_line): Merge vertical space.\n\n\t* cpplex.c (_cpp_lex_line): Merge vertical space.  Flag\n\tfirst token of a line BOL.  Update EOF code for this.\n\tRemove illegal directive check - it appears in the (not\n\tyet committed) caller.\n\t* cpplib.h (BOL): New flag.\n\nFrom-SVN: r34216", "tree": {"sha": "a1d9e801ecfc422ad3a6c2468f8a9c254c4e255c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1d9e801ecfc422ad3a6c2468f8a9c254c4e255c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f624ffa71f84afc0f8fb14e76a664a4556574efd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f624ffa71f84afc0f8fb14e76a664a4556574efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f624ffa71f84afc0f8fb14e76a664a4556574efd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f624ffa71f84afc0f8fb14e76a664a4556574efd/comments", "author": null, "committer": null, "parents": [{"sha": "ad265aa4d61d9c7dac95718a1f00c18476c7ee13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ad265aa4d61d9c7dac95718a1f00c18476c7ee13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ad265aa4d61d9c7dac95718a1f00c18476c7ee13"}], "stats": {"total": 77, "additions": 37, "deletions": 40}, "files": [{"sha": "a2d525367eacc854035988dfc608f4511719ba16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f624ffa71f84afc0f8fb14e76a664a4556574efd", "patch": "@@ -1,3 +1,11 @@\n+2000-05-28  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cpplex.c (_cpp_lex_line): Merge vertical space.  Flag\n+\tfirst token of a line BOL.  Update EOF code for this.\n+\tRemove illegal directive check - it appears in the (not\n+\tyet committed) caller.\n+\t* cpplib.h (BOL): New flag.\n+\n 2000-05-28  Neil Booth  <NeilB@earthling.net>\n \n         * cpplex.c (_cpp_init_toklist): No comment space to initialise."}, {"sha": "905be7b55c824e582d425a9dcdb0d6f35705cfcf", "filename": "gcc/cpplex.c", "status": "modified", "additions": 25, "deletions": 37, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=f624ffa71f84afc0f8fb14e76a664a4556574efd", "patch": "@@ -62,7 +62,6 @@ static void pedantic_whitespace\tPARAMS ((cpp_reader *, U_CHAR *,\n \n #ifdef NEW_LEXER\n \n-static void expand_comment_space PARAMS ((cpp_toklist *));\n void init_trigraph_map PARAMS ((void));\n static unsigned char* trigraph_replace PARAMS ((cpp_reader *, unsigned char *,\n \t\t\t\t\t\tunsigned char *));\n@@ -76,7 +75,8 @@ static void parse_number PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *));\n static void parse_string2 PARAMS ((cpp_reader *, cpp_toklist *, cpp_name *,\n \t\t\t\t  unsigned int, int));\n static int trigraph_ok PARAMS ((cpp_reader *, const unsigned char *));\n-static void save_comment PARAMS ((cpp_toklist *, cpp_token *, unsigned char *,\n+static void save_comment PARAMS ((cpp_toklist *, cpp_token *,\n+\t\t\t\t  const unsigned char *,\n \t\t\t\t  unsigned int, unsigned int));\n void _cpp_lex_line PARAMS ((cpp_reader *, cpp_toklist *));\n \n@@ -120,8 +120,8 @@ typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \n /* An upper bound on the number of bytes needed to spell a token,\n    including preceding whitespace.  */\n-#define TOKEN_LEN(token) (5 + (token_spellings[token->type].type > \\\n-\t\t               SPELL_NONE ? token->val.name.len: 0))\n+#define TOKEN_LEN(token) (5 + (token_spellings[(token)->type].type > \\\n+\t\t               SPELL_NONE ? (token)->val.name.len: 0))\n \n #endif\n \n@@ -2866,9 +2866,10 @@ save_comment (list, token, from, len, type)\n \n /*\n  *  The tokenizer's main loop.  Returns a token list, representing a\n- *  logical line in the input file, terminated with a CPP_VSPACE\n- *  token.  On EOF, a token list containing the single CPP_EOF token\n- *  is returned.\n+ *  logical line in the input file.  On EOF after some tokens have\n+ *  been processed, we return immediately.  Then in next call, or if\n+ *  EOF occurred at the beginning of a logical line, a single CPP_EOF\n+ *  token is placed in the list.\n  *\n  *  Implementation relies almost entirely on lookback, rather than\n  *  looking forwards.  This means that tokenization requires just\n@@ -2891,6 +2892,7 @@ _cpp_lex_line (pfile, list)\n   unsigned char flags = 0;\n   unsigned int first_token = list->tokens_used;\n \n+  list->line = CPP_BUF_LINE (buffer);\n   pfile->col_adjust = 0;\n  expanded:\n   token_limit = list->tokens + list->tokens_cap;\n@@ -3122,8 +3124,12 @@ _cpp_lex_line (pfile, list)\n \t      buffer->cur = cur;\n \t      cpp_warning (pfile, \"backslash and newline separated by space\");\n \t    }\n-\t  PUSH_TOKEN (CPP_VSPACE);\n-\t  goto out;\n+\t  /* Skip vertical space until we have at least one token to\n+             return.  */\n+\t  if (cur_token != &list->tokens[first_token])\n+\t    goto out;\n+\t  list->line = CPP_BUF_LINE (buffer);\n+\t  break;\n \n \tcase '-':\n \t  if (IMMED_TOKEN () && PREV_TOKEN_TYPE == CPP_MINUS)\n@@ -3327,35 +3333,19 @@ _cpp_lex_line (pfile, list)\n       goto expanded;\n     }\n \n-  cur_token->type = CPP_EOF;\n   cur_token->flags = flags;\n-\n-  if (cur_token != &list->tokens[first_token])\n+  if (cur_token == &list->tokens[first_token])\n     {\n-      /* Next call back will get just a CPP_EOF.  */\n-      buffer->cur = cur;\n-      cpp_warning (pfile, \"no newline at end of file\");\n-      PUSH_TOKEN (CPP_VSPACE);\n+      /* FIXME: move this warning to callers who care.  */\n+      if (cur > buffer->buf && !IS_NEWLINE (cur[-1]))\n+\tcpp_warning (pfile, \"no newline at end of file\");\n+      cur_token++->type = CPP_EOF;\n     }\n \n  out:\n+  list->tokens[first_token].flags |= BOL;\n   buffer->cur = cur;\n-\n   list->tokens_used = cur_token - list->tokens;\n-\n-  /* FIXME:  take this check out and put it in the caller.\n-     list->directive == 0 indicates an unknown directive (but null\n-     directive is OK).  This is the first time we can be sure the\n-     directive is invalid, and thus warn about it, because it might\n-     have been split by escaped newlines.  Also, don't complain about\n-     invalid directives in assembly source, we don't know where the\n-     comments are, and # may introduce assembler pseudo-ops.  */\n-\n-  if (IS_DIRECTIVE (list) && list->dirno == -1\n-      && list->tokens[1].type != CPP_VSPACE\n-      && !CPP_OPTION (pfile, lang_asm))\n-    cpp_error_with_line (pfile, list->line, list->tokens[1].col,\n-\t\t\t \"invalid preprocessing directive\");\n }\n \n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n@@ -3460,15 +3450,13 @@ _cpp_output_list (pfile, list)\n      cpp_reader *pfile;\n      cpp_toklist *list;\n {\n-  cpp_token *token;\n+  unsigned int i;\n \n-  token = &list->tokens[0];\n-  do\n+  for (i = 0; i < list->tokens_used; i++)\n     {\n-      CPP_RESERVE (pfile, TOKEN_LEN (token));\n-      pfile->limit = spell_token (pfile, token, pfile->limit, 1);\n+      CPP_RESERVE (pfile, TOKEN_LEN (&list->tokens[i]));\n+      pfile->limit = spell_token (pfile, &list->tokens[i], pfile->limit, 1);\n     }\n-  while (token++->type != CPP_VSPACE);\n }\n \n #endif"}, {"sha": "68059cc1403b94469c757912105f75bdf18279d3", "filename": "gcc/cpplib.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f624ffa71f84afc0f8fb14e76a664a4556574efd/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=f624ffa71f84afc0f8fb14e76a664a4556574efd", "patch": "@@ -121,11 +121,11 @@ typedef struct cpp_name cpp_name;\n   I(CPP_COMMENT,\t0)\t/* Only if output comments.  */ \\\n   N(CPP_MACRO_ARG,      0)\t/* Macro argument.  */          \\\n   N(CPP_SUBLIST,        0)\t/* Sublist.  */                 \\\n-  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\t\t\\\n   N(CPP_EOF,\t\t0)\t/* End of file.  */\t\t\\\n   N(CPP_HEADER_NAME,\t0)\t/* <stdio.h> in #include */\t\\\n \\\n   /* Obsolete - will be removed when no code uses them still.  */\t\\\n+  T(CPP_VSPACE,\t\t\"\\n\")\t/* End of line.  */\t\t\\\n   N(CPP_HSPACE,\t\t0)\t/* Horizontal white space.  */\t\\\n   N(CPP_DIRECTIVE,\t0)\t/* #define and the like */\t\\\n   N(CPP_MACRO,\t\t0)\t/* Like a NAME, but expanded.  */\n@@ -168,8 +168,9 @@ struct cpp_name\n \n /* Flags for the cpp_token structure.  */\n #define PREV_WHITESPACE     1\t/* If whitespace before this token.  */\n-#define DIGRAPH             2\t/* If it was a digraph.  */\n-#define UNSIGNED_INT        4   /* If int preprocessing token unsigned.  */\n+#define BOL\t\t    2   /* Beginning of line.  */\n+#define DIGRAPH             4\t/* If it was a digraph.  */\n+#define UNSIGNED_INT        8   /* If int preprocessing token unsigned.  */\n \n /* A preprocessing token.  This has been carefully packed and should\n    occupy 16 bytes on both 32- and 64-bit hosts.  */"}]}