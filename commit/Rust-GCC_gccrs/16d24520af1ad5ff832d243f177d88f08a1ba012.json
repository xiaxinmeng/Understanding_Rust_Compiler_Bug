{"sha": "16d24520af1ad5ff832d243f177d88f08a1ba012", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZkMjQ1MjBhZjFhZDVmZjgzMmQyNDNmMTc3ZDg4ZjA4YTFiYTAxMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-11-22T19:33:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-11-22T19:33:31Z"}, "message": "Replace REDUC_*_EXPRs with internal functions.\n\nThis patch replaces the REDUC_*_EXPR tree codes with internal functions.\nThis is needed so that the upcoming in-order reductions can also use\ninternal functions without too much complication.\n\n2017-11-22  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree.def (REDUC_MAX_EXPR, REDUC_MIN_EXPR, REDUC_PLUS_EXPR): Delete.\n\t* cfgexpand.c (expand_debug_expr): Remove handling for them.\n\t* expr.c (expand_expr_real_2): Likewise.\n\t* fold-const.c (const_unop): Likewise.\n\t* optabs-tree.c (optab_for_tree_code): Likewise.\n\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n\t* tree-inline.c (estimate_operator_cost): Likewise.\n\t* tree-pretty-print.c (dump_generic_node): Likewise.\n\t(op_code_prio): Likewise.\n\t(op_symbol_code): Likewise.\n\t* internal-fn.def (DEF_INTERNAL_SIGNED_OPTAB_FN): Define.\n\t(IFN_REDUC_PLUS, IFN_REDUC_MAX, IFN_REDUC_MIN): New internal functions.\n\t* internal-fn.c (direct_internal_fn_optab): New function.\n\t(direct_internal_fn_array, direct_internal_fn_supported_p\n\t(internal_fn_expanders): Handle DEF_INTERNAL_SIGNED_OPTAB_FN.\n\t* fold-const-call.c (fold_const_reduction): New function.\n\t(fold_const_call): Handle CFN_REDUC_PLUS, CFN_REDUC_MAX and\n\tCFN_REDUC_MIN.\n\t* tree-vect-loop.c: Include internal-fn.h.\n\t(reduction_code_for_scalar_code): Rename to...\n\t(reduction_fn_for_scalar_code): ...this and return an internal\n\tfunction.\n\t(vect_model_reduction_cost): Take an internal_fn rather than\n\ta tree_code.\n\t(vect_create_epilog_for_reduction): Likewise.  Build calls rather\n\tthan assignments.\n\t(vectorizable_reduction): Use internal functions rather than tree\n\tcodes for the reduction operation.  Update calls to the functions\n\tabove.\n\t* config/aarch64/aarch64-builtins.c (aarch64_gimple_fold_builtin):\n\tUse calls to internal functions rather than REDUC tree codes.\n\t* config/aarch64/aarch64-simd.md: Update comment accordingly.\n\nFrom-SVN: r255073", "tree": {"sha": "a50dc9dd04288c819f739efe8344b2235847007b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50dc9dd04288c819f739efe8344b2235847007b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16d24520af1ad5ff832d243f177d88f08a1ba012", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d24520af1ad5ff832d243f177d88f08a1ba012", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d24520af1ad5ff832d243f177d88f08a1ba012", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d24520af1ad5ff832d243f177d88f08a1ba012/comments", "author": null, "committer": null, "parents": [{"sha": "5675291ddbc7c7bee1b4722f1358a276365c0ee5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5675291ddbc7c7bee1b4722f1358a276365c0ee5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5675291ddbc7c7bee1b4722f1358a276365c0ee5"}], "stats": {"total": 382, "additions": 196, "deletions": 186}, "files": [{"sha": "50f5a7334a9ad3e4f1f8a77d715ac53396776002", "filename": "gcc/ChangeLog", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -1,3 +1,38 @@\n+2017-11-22  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree.def (REDUC_MAX_EXPR, REDUC_MIN_EXPR, REDUC_PLUS_EXPR): Delete.\n+\t* cfgexpand.c (expand_debug_expr): Remove handling for them.\n+\t* expr.c (expand_expr_real_2): Likewise.\n+\t* fold-const.c (const_unop): Likewise.\n+\t* optabs-tree.c (optab_for_tree_code): Likewise.\n+\t* tree-cfg.c (verify_gimple_assign_unary): Likewise.\n+\t* tree-inline.c (estimate_operator_cost): Likewise.\n+\t* tree-pretty-print.c (dump_generic_node): Likewise.\n+\t(op_code_prio): Likewise.\n+\t(op_symbol_code): Likewise.\n+\t* internal-fn.def (DEF_INTERNAL_SIGNED_OPTAB_FN): Define.\n+\t(IFN_REDUC_PLUS, IFN_REDUC_MAX, IFN_REDUC_MIN): New internal functions.\n+\t* internal-fn.c (direct_internal_fn_optab): New function.\n+\t(direct_internal_fn_array, direct_internal_fn_supported_p\n+\t(internal_fn_expanders): Handle DEF_INTERNAL_SIGNED_OPTAB_FN.\n+\t* fold-const-call.c (fold_const_reduction): New function.\n+\t(fold_const_call): Handle CFN_REDUC_PLUS, CFN_REDUC_MAX and\n+\tCFN_REDUC_MIN.\n+\t* tree-vect-loop.c: Include internal-fn.h.\n+\t(reduction_code_for_scalar_code): Rename to...\n+\t(reduction_fn_for_scalar_code): ...this and return an internal\n+\tfunction.\n+\t(vect_model_reduction_cost): Take an internal_fn rather than\n+\ta tree_code.\n+\t(vect_create_epilog_for_reduction): Likewise.  Build calls rather\n+\tthan assignments.\n+\t(vectorizable_reduction): Use internal functions rather than tree\n+\tcodes for the reduction operation.  Update calls to the functions\n+\tabove.\n+\t* config/aarch64/aarch64-builtins.c (aarch64_gimple_fold_builtin):\n+\tUse calls to internal functions rather than REDUC tree codes.\n+\t* config/aarch64/aarch64-simd.md: Update comment accordingly.\n+\n 2017-11-22  Olivier Hainque  <hainque@adacore.com>\n \n        * config/vxworks.c (vxworks_override_options): Pick default"}, {"sha": "d1140602da4b4f377533692abe717e96097281d5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -5051,9 +5051,6 @@ expand_debug_expr (tree exp)\n \n     /* Vector stuff.  For most of the codes we don't have rtl codes.  */\n     case REALIGN_LOAD_EXPR:\n-    case REDUC_MAX_EXPR:\n-    case REDUC_MIN_EXPR:\n-    case REDUC_PLUS_EXPR:\n     case VEC_COND_EXPR:\n     case VEC_PACK_FIX_TRUNC_EXPR:\n     case VEC_PACK_SAT_EXPR:"}, {"sha": "8cbdb0112032a8c1485c4b466bb6010e89fd013d", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -1597,24 +1597,27 @@ aarch64_gimple_fold_builtin (gimple_stmt_iterator *gsi)\n \t\t\t? gimple_call_arg_ptr (stmt, 0)\n \t\t\t: &error_mark_node);\n \n-\t  /* We use gimple's REDUC_(PLUS|MIN|MAX)_EXPRs for float, signed int\n+\t  /* We use gimple's IFN_REDUC_(PLUS|MIN|MAX)s for float, signed int\n \t     and unsigned int; it will distinguish according to the types of\n \t     the arguments to the __builtin.  */\n \t  switch (fcode)\n \t    {\n \t      BUILTIN_VALL (UNOP, reduc_plus_scal_, 10)\n-\t        new_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n-\t\t\t\t\t\tREDUC_PLUS_EXPR, args[0]);\n+\t        new_stmt = gimple_build_call_internal (IFN_REDUC_PLUS,\n+\t\t\t\t\t\t       1, args[0]);\n+\t\tgimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n \t\tbreak;\n \t      BUILTIN_VDQIF (UNOP, reduc_smax_scal_, 10)\n \t      BUILTIN_VDQ_BHSI (UNOPU, reduc_umax_scal_, 10)\n-\t\tnew_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n-\t\t\t\t\t\tREDUC_MAX_EXPR, args[0]);\n+\t        new_stmt = gimple_build_call_internal (IFN_REDUC_MAX,\n+\t\t\t\t\t\t       1, args[0]);\n+\t\tgimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n \t\tbreak;\n \t      BUILTIN_VDQIF (UNOP, reduc_smin_scal_, 10)\n \t      BUILTIN_VDQ_BHSI (UNOPU, reduc_umin_scal_, 10)\n-\t\tnew_stmt = gimple_build_assign (gimple_call_lhs (stmt),\n-\t\t\t\t\t\tREDUC_MIN_EXPR, args[0]);\n+\t        new_stmt = gimple_build_call_internal (IFN_REDUC_MIN,\n+\t\t\t\t\t\t       1, args[0]);\n+\t\tgimple_call_set_lhs (new_stmt, gimple_call_lhs (stmt));\n \t\tbreak;\n \t      BUILTIN_GPF (BINOP, fmulx, 0)\n \t\t{"}, {"sha": "39299733ba95a9251bdb64dedd142b53fe4bb566", "filename": "gcc/config/aarch64/aarch64-simd.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-simd.md?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -2338,7 +2338,7 @@\n ;; 'across lanes' max and min ops.\n \n ;; Template for outputting a scalar, so we can create __builtins which can be\n-;; gimple_fold'd to the REDUC_(MAX|MIN)_EXPR tree code.  (This is FP smax/smin).\n+;; gimple_fold'd to the IFN_REDUC_(MAX|MIN) function.  (This is FP smax/smin).\n (define_expand \"reduc_<maxmin_uns>_scal_<mode>\"\n   [(match_operand:<VEL> 0 \"register_operand\")\n    (unspec:VHSDF [(match_operand:VHSDF 1 \"register_operand\")]"}, {"sha": "290f0c49d65460661961d3b4bc50c774caf9b500", "filename": "gcc/expr.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -9368,26 +9368,6 @@ expand_expr_real_2 (sepops ops, rtx target, machine_mode tmode,\n         return target;\n       }\n \n-    case REDUC_MAX_EXPR:\n-    case REDUC_MIN_EXPR:\n-    case REDUC_PLUS_EXPR:\n-      {\n-        op0 = expand_normal (treeop0);\n-        this_optab = optab_for_tree_code (code, type, optab_default);\n-        machine_mode vec_mode = TYPE_MODE (TREE_TYPE (treeop0));\n-\n-\tstruct expand_operand ops[2];\n-\tenum insn_code icode = optab_handler (this_optab, vec_mode);\n-\n-\tcreate_output_operand (&ops[0], target, mode);\n-\tcreate_input_operand (&ops[1], op0, vec_mode);\n-\texpand_insn (icode, 2, ops);\n-\ttarget = ops[0].value;\n-\tif (GET_MODE (target) != mode)\n-\t  return gen_lowpart (tmode, target);\n-\treturn target;\n-      }\n-\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n       {"}, {"sha": "4d7059802368b6362013a56828cca0aec6e1ffed", "filename": "gcc/fold-const-call.c", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ffold-const-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ffold-const-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const-call.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -583,6 +583,25 @@ fold_const_builtin_nan (tree type, tree arg, bool quiet)\n   return NULL_TREE;\n }\n \n+/* Fold a call to IFN_REDUC_<CODE> (ARG), returning a value of type TYPE.  */\n+\n+static tree\n+fold_const_reduction (tree type, tree arg, tree_code code)\n+{\n+  if (TREE_CODE (arg) != VECTOR_CST)\n+    return NULL_TREE;\n+\n+  tree res = VECTOR_CST_ELT (arg, 0);\n+  unsigned int nelts = VECTOR_CST_NELTS (arg);\n+  for (unsigned int i = 1; i < nelts; i++)\n+    {\n+      res = const_binop (code, type, res, VECTOR_CST_ELT (arg, i));\n+      if (res == NULL_TREE || !CONSTANT_CLASS_P (res))\n+\treturn NULL_TREE;\n+    }\n+  return res;\n+}\n+\n /* Try to evaluate:\n \n       *RESULT = FN (*ARG)\n@@ -1148,6 +1167,15 @@ fold_const_call (combined_fn fn, tree type, tree arg)\n     CASE_FLT_FN_FLOATN_NX (CFN_BUILT_IN_NANS):\n       return fold_const_builtin_nan (type, arg, false);\n \n+    case CFN_REDUC_PLUS:\n+      return fold_const_reduction (type, arg, PLUS_EXPR);\n+\n+    case CFN_REDUC_MAX:\n+      return fold_const_reduction (type, arg, MAX_EXPR);\n+\n+    case CFN_REDUC_MIN:\n+      return fold_const_reduction (type, arg, MIN_EXPR);\n+\n     default:\n       return fold_const_call_1 (fn, type, arg);\n     }"}, {"sha": "8c8e52a2a277ca051e4bfdd755ead64e9cf666dc", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -1717,36 +1717,6 @@ const_unop (enum tree_code code, tree type, tree arg0)\n \treturn build_vector (type, elts);\n       }\n \n-    case REDUC_MIN_EXPR:\n-    case REDUC_MAX_EXPR:\n-    case REDUC_PLUS_EXPR:\n-      {\n-\tunsigned int nelts, i;\n-\tenum tree_code subcode;\n-\n-\tif (TREE_CODE (arg0) != VECTOR_CST)\n-\t  return NULL_TREE;\n-\tnelts = VECTOR_CST_NELTS (arg0);\n-\n-\tswitch (code)\n-\t  {\n-\t  case REDUC_MIN_EXPR: subcode = MIN_EXPR; break;\n-\t  case REDUC_MAX_EXPR: subcode = MAX_EXPR; break;\n-\t  case REDUC_PLUS_EXPR: subcode = PLUS_EXPR; break;\n-\t  default: gcc_unreachable ();\n-\t  }\n-\n-\ttree res = VECTOR_CST_ELT (arg0, 0);\n-\tfor (i = 1; i < nelts; i++)\n-\t  {\n-\t    res = const_binop (subcode, res, VECTOR_CST_ELT (arg0, i));\n-\t    if (res == NULL_TREE || !CONSTANT_CLASS_P (res))\n-\t      return NULL_TREE;\n-\t  }\n-\n-\treturn res;\n-      }\n-\n     default:\n       break;\n     }"}, {"sha": "119fa1ab03030c08b33bb6bff39dd07676ac82e2", "filename": "gcc/internal-fn.c", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Finternal-fn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Finternal-fn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -90,6 +90,8 @@ init_internal_fns ()\n const direct_internal_fn_info direct_internal_fn_array[IFN_LAST + 1] = {\n #define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) not_direct,\n #define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) TYPE##_direct,\n+#define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n+\t\t\t\t     UNSIGNED_OPTAB, TYPE) TYPE##_direct,\n #include \"internal-fn.def\"\n   not_direct\n };\n@@ -2818,6 +2820,30 @@ multi_vector_optab_supported_p (convert_optab optab, tree_pair types,\n #define direct_mask_store_optab_supported_p direct_optab_supported_p\n #define direct_store_lanes_optab_supported_p multi_vector_optab_supported_p\n \n+/* Return the optab used by internal function FN.  */\n+\n+static optab\n+direct_internal_fn_optab (internal_fn fn, tree_pair types)\n+{\n+  switch (fn)\n+    {\n+#define DEF_INTERNAL_FN(CODE, FLAGS, FNSPEC) \\\n+    case IFN_##CODE: break;\n+#define DEF_INTERNAL_OPTAB_FN(CODE, FLAGS, OPTAB, TYPE) \\\n+    case IFN_##CODE: return OPTAB##_optab;\n+#define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n+\t\t\t\t     UNSIGNED_OPTAB, TYPE)\t\t\\\n+    case IFN_##CODE: return (TYPE_UNSIGNED (types.SELECTOR)\t\t\\\n+\t\t\t     ? UNSIGNED_OPTAB ## _optab\t\t\t\\\n+\t\t\t     : SIGNED_OPTAB ## _optab);\n+#include \"internal-fn.def\"\n+\n+    case IFN_LAST:\n+      break;\n+    }\n+  gcc_unreachable ();\n+}\n+\n /* Return true if FN is supported for the types in TYPES when the\n    optimization type is OPT_TYPE.  The types are those associated with\n    the \"type0\" and \"type1\" fields of FN's direct_internal_fn_info\n@@ -2835,6 +2861,16 @@ direct_internal_fn_supported_p (internal_fn fn, tree_pair types,\n     case IFN_##CODE: \\\n       return direct_##TYPE##_optab_supported_p (OPTAB##_optab, types, \\\n \t\t\t\t\t\topt_type);\n+#define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n+\t\t\t\t     UNSIGNED_OPTAB, TYPE)\t\t\\\n+    case IFN_##CODE:\t\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\toptab which_optab = (TYPE_UNSIGNED (types.SELECTOR)\t\t\\\n+\t\t\t     ? UNSIGNED_OPTAB ## _optab\t\t\t\\\n+\t\t\t     : SIGNED_OPTAB ## _optab);\t\t\t\\\n+\treturn direct_##TYPE##_optab_supported_p (which_optab, types,\t\\\n+\t\t\t\t\t\t  opt_type);\t\t\\\n+      }\n #include \"internal-fn.def\"\n \n     case IFN_LAST:\n@@ -2874,6 +2910,15 @@ set_edom_supported_p (void)\n   {\t\t\t\t\t\t\t\\\n     expand_##TYPE##_optab_fn (fn, stmt, OPTAB##_optab);\t\\\n   }\n+#define DEF_INTERNAL_SIGNED_OPTAB_FN(CODE, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n+\t\t\t\t     UNSIGNED_OPTAB, TYPE)\t\t\\\n+  static void\t\t\t\t\t\t\t\t\\\n+  expand_##CODE (internal_fn fn, gcall *stmt)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    tree_pair types = direct_internal_fn_types (fn, stmt);\t\t\\\n+    optab which_optab = direct_internal_fn_optab (fn, types);\t\t\\\n+    expand_##TYPE##_optab_fn (fn, stmt, which_optab);\t\t\t\\\n+  }\n #include \"internal-fn.def\"\n \n /* Routines to expand each internal function, indexed by function number."}, {"sha": "d6ab03112b00dd9f928a98342536dd0273950fc1", "filename": "gcc/internal-fn.def", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Finternal-fn.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Finternal-fn.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.def?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -30,6 +30,8 @@ along with GCC; see the file COPYING3.  If not see\n \n      DEF_INTERNAL_FN (NAME, FLAGS, FNSPEC)\n      DEF_INTERNAL_OPTAB_FN (NAME, FLAGS, OPTAB, TYPE)\n+     DEF_INTERNAL_SIGNED_OPTAB_FN (NAME, FLAGS, SELECTOR, SIGNED_OPTAB,\n+\t\t\t\t   UNSIGNED_OPTAB, TYPE)\n      DEF_INTERNAL_FLT_FN (NAME, FLAGS, OPTAB, TYPE)\n      DEF_INTERNAL_INT_FN (NAME, FLAGS, OPTAB, TYPE)\n \n@@ -49,6 +51,12 @@ along with GCC; see the file COPYING3.  If not see\n    - mask_store: currently just maskstore\n    - store_lanes: currently just vec_store_lanes\n \n+   DEF_INTERNAL_SIGNED_OPTAB_FN defines an internal function that\n+   maps to one of two optabs, depending on the signedness of an input.\n+   SIGNED_OPTAB and UNSIGNED_OPTAB are the optabs for signed and\n+   unsigned inputs respectively, both without the trailing \"_optab\".\n+   SELECTOR says which type in the tree_pair determines the signedness.\n+\n    DEF_INTERNAL_FLT_FN is like DEF_INTERNAL_OPTAB_FN, but in addition,\n    the function implements the computational part of a built-in math\n    function BUILT_IN_<NAME>{F,,L}.  Unlike some built-in functions,\n@@ -75,6 +83,12 @@ along with GCC; see the file COPYING3.  If not see\n   DEF_INTERNAL_FN (NAME, FLAGS | ECF_LEAF, NULL)\n #endif\n \n+#ifndef DEF_INTERNAL_SIGNED_OPTAB_FN\n+#define DEF_INTERNAL_SIGNED_OPTAB_FN(NAME, FLAGS, SELECTOR, SIGNED_OPTAB, \\\n+\t\t\t\t     UNSIGNED_OPTAB, TYPE) \\\n+  DEF_INTERNAL_FN (NAME, FLAGS | ECF_LEAF, NULL)\n+#endif\n+\n #ifndef DEF_INTERNAL_FLT_FN\n #define DEF_INTERNAL_FLT_FN(NAME, FLAGS, OPTAB, TYPE) \\\n   DEF_INTERNAL_OPTAB_FN (NAME, FLAGS, OPTAB, TYPE)\n@@ -98,6 +112,13 @@ DEF_INTERNAL_OPTAB_FN (STORE_LANES, ECF_CONST, vec_store_lanes, store_lanes)\n \n DEF_INTERNAL_OPTAB_FN (RSQRT, ECF_CONST, rsqrt, unary)\n \n+DEF_INTERNAL_OPTAB_FN (REDUC_PLUS, ECF_CONST | ECF_NOTHROW,\n+\t\t       reduc_plus_scal, unary)\n+DEF_INTERNAL_SIGNED_OPTAB_FN (REDUC_MAX, ECF_CONST | ECF_NOTHROW, first,\n+\t\t\t      reduc_smax_scal, reduc_umax_scal, unary)\n+DEF_INTERNAL_SIGNED_OPTAB_FN (REDUC_MIN, ECF_CONST | ECF_NOTHROW, first,\n+\t\t\t      reduc_smin_scal, reduc_umin_scal, unary)\n+\n /* Unary math functions.  */\n DEF_INTERNAL_FLT_FN (ACOS, ECF_CONST, acos, unary)\n DEF_INTERNAL_FLT_FN (ASIN, ECF_CONST, asin, unary)\n@@ -236,5 +257,6 @@ DEF_INTERNAL_FN (DIVMOD, ECF_CONST | ECF_LEAF, NULL)\n #undef DEF_INTERNAL_INT_FN\n #undef DEF_INTERNAL_FLT_FN\n #undef DEF_INTERNAL_FLT_FLOATN_FN\n+#undef DEF_INTERNAL_SIGNED_OPTAB_FN\n #undef DEF_INTERNAL_OPTAB_FN\n #undef DEF_INTERNAL_FN"}, {"sha": "a510c165b0579d0c7aa1f891322a4f19fc61f9ed", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -146,17 +146,6 @@ optab_for_tree_code (enum tree_code code, const_tree type,\n     case FMA_EXPR:\n       return fma_optab;\n \n-    case REDUC_MAX_EXPR:\n-      return TYPE_UNSIGNED (type)\n-\t     ? reduc_umax_scal_optab : reduc_smax_scal_optab;\n-\n-    case REDUC_MIN_EXPR:\n-      return TYPE_UNSIGNED (type)\n-\t     ? reduc_umin_scal_optab : reduc_smin_scal_optab;\n-\n-    case REDUC_PLUS_EXPR:\n-      return reduc_plus_scal_optab;\n-\n     case VEC_WIDEN_MULT_HI_EXPR:\n       return TYPE_UNSIGNED (type) ?\n \tvec_widen_umult_hi_optab : vec_widen_smult_hi_optab;"}, {"sha": "bb30a92189937737775350065228833b0c02546b", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -3792,18 +3792,6 @@ verify_gimple_assign_unary (gassign *stmt)\n \n         return false;\n       }\n-    case REDUC_MAX_EXPR:\n-    case REDUC_MIN_EXPR:\n-    case REDUC_PLUS_EXPR:\n-      if (!VECTOR_TYPE_P (rhs1_type)\n-\t  || !useless_type_conversion_p (lhs_type, TREE_TYPE (rhs1_type)))\n-        {\n-\t  error (\"reduction should convert from vector to element type\");\n-\t  debug_generic_expr (lhs_type);\n-\t  debug_generic_expr (rhs1_type);\n-\t  return true;\n-\t}\n-      return false;\n \n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:"}, {"sha": "5747785caeaef79272ddc4d4191f758bb57747a7", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -3877,9 +3877,6 @@ estimate_operator_cost (enum tree_code code, eni_weights *weights,\n \n     case REALIGN_LOAD_EXPR:\n \n-    case REDUC_MAX_EXPR:\n-    case REDUC_MIN_EXPR:\n-    case REDUC_PLUS_EXPR:\n     case WIDEN_SUM_EXPR:\n     case WIDEN_MULT_EXPR:\n     case DOT_PROD_EXPR:"}, {"sha": "c79b79f64e7d84d39f9e8b400034f278ddd985ec", "filename": "gcc/tree-pretty-print.c", "status": "modified", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pretty-print.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -3209,24 +3209,6 @@ dump_generic_node (pretty_printer *pp, tree node, int spc, dump_flags_t flags,\n       is_expr = false;\n       break;\n \n-    case REDUC_MAX_EXPR:\n-      pp_string (pp, \" REDUC_MAX_EXPR < \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (pp, \" > \");\n-      break;\n-\n-    case REDUC_MIN_EXPR:\n-      pp_string (pp, \" REDUC_MIN_EXPR < \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (pp, \" > \");\n-      break;\n-\n-    case REDUC_PLUS_EXPR:\n-      pp_string (pp, \" REDUC_PLUS_EXPR < \");\n-      dump_generic_node (pp, TREE_OPERAND (node, 0), spc, flags, false);\n-      pp_string (pp, \" > \");\n-      break;\n-\n     case VEC_WIDEN_MULT_HI_EXPR:\n     case VEC_WIDEN_MULT_LO_EXPR:\n     case VEC_WIDEN_MULT_EVEN_EXPR:\n@@ -3606,9 +3588,6 @@ op_code_prio (enum tree_code code)\n     case ABS_EXPR:\n     case REALPART_EXPR:\n     case IMAGPART_EXPR:\n-    case REDUC_MAX_EXPR:\n-    case REDUC_MIN_EXPR:\n-    case REDUC_PLUS_EXPR:\n     case VEC_UNPACK_HI_EXPR:\n     case VEC_UNPACK_LO_EXPR:\n     case VEC_UNPACK_FLOAT_HI_EXPR:\n@@ -3727,9 +3706,6 @@ op_symbol_code (enum tree_code code)\n     case PLUS_EXPR:\n       return \"+\";\n \n-    case REDUC_PLUS_EXPR:\n-      return \"r+\";\n-\n     case WIDEN_SUM_EXPR:\n       return \"w+\";\n "}, {"sha": "d7669e4ebb71e25706fa1bdbe3f9a63ae4553a7c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 55, "deletions": 63, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cgraph.h\"\n #include \"tree-cfg.h\"\n #include \"tree-if-conv.h\"\n+#include \"internal-fn.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -2376,43 +2377,42 @@ vect_analyze_loop (struct loop *loop, loop_vec_info orig_loop_vinfo)\n }\n \n \n-/* Function reduction_code_for_scalar_code\n+/* Function reduction_fn_for_scalar_code\n \n    Input:\n    CODE - tree_code of a reduction operations.\n \n    Output:\n-   REDUC_CODE - the corresponding tree-code to be used to reduce the\n-      vector of partial results into a single scalar result, or ERROR_MARK\n+   REDUC_FN - the corresponding internal function to be used to reduce the\n+      vector of partial results into a single scalar result, or IFN_LAST\n       if the operation is a supported reduction operation, but does not have\n-      such a tree-code.\n+      such an internal function.\n \n    Return FALSE if CODE currently cannot be vectorized as reduction.  */\n \n static bool\n-reduction_code_for_scalar_code (enum tree_code code,\n-                                enum tree_code *reduc_code)\n+reduction_fn_for_scalar_code (enum tree_code code, internal_fn *reduc_fn)\n {\n   switch (code)\n     {\n       case MAX_EXPR:\n-        *reduc_code = REDUC_MAX_EXPR;\n+        *reduc_fn = IFN_REDUC_MAX;\n         return true;\n \n       case MIN_EXPR:\n-        *reduc_code = REDUC_MIN_EXPR;\n+        *reduc_fn = IFN_REDUC_MIN;\n         return true;\n \n       case PLUS_EXPR:\n-        *reduc_code = REDUC_PLUS_EXPR;\n+        *reduc_fn = IFN_REDUC_PLUS;\n         return true;\n \n       case MULT_EXPR:\n       case MINUS_EXPR:\n       case BIT_IOR_EXPR:\n       case BIT_XOR_EXPR:\n       case BIT_AND_EXPR:\n-        *reduc_code = ERROR_MARK;\n+        *reduc_fn = IFN_LAST;\n         return true;\n \n       default:\n@@ -3745,7 +3745,7 @@ have_whole_vector_shift (machine_mode mode)\n    the loop, and the epilogue code that must be generated.  */\n \n static void\n-vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n+vect_model_reduction_cost (stmt_vec_info stmt_info, internal_fn reduc_fn,\n \t\t\t   int ncopies)\n {\n   int prologue_cost = 0, epilogue_cost = 0;\n@@ -3799,7 +3799,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \n   if (!loop || !nested_in_vect_loop_p (loop, orig_stmt))\n     {\n-      if (reduc_code != ERROR_MARK)\n+      if (reduc_fn != IFN_LAST)\n \t{\n \t  if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION)\n \t    {\n@@ -4266,7 +4266,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n      we have to generate more than one vector stmt - i.e - we need to \"unroll\"\n      the vector stmt by a factor VF/nunits.  For more details see documentation\n      in vectorizable_operation.\n-   REDUC_CODE is the tree-code for the epilog reduction.\n+   REDUC_FN is the internal function for the epilog reduction.\n    REDUCTION_PHIS is a list of the phi-nodes that carry the reduction \n      computation.\n    REDUC_INDEX is the index of the operand in the right hand side of the \n@@ -4282,7 +4282,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n       The loop-latch argument is taken from VECT_DEFS - the vector of partial \n       sums.\n    2. \"Reduces\" each vector of partial results VECT_DEFS into a single result,\n-      by applying the operation specified by REDUC_CODE if available, or by \n+      by calling the function specified by REDUC_FN if available, or by\n       other means (whole-vector shifts or a scalar loop).\n       The function also creates a new phi node at the loop exit to preserve\n       loop-closed form, as illustrated below.\n@@ -4317,7 +4317,7 @@ get_initial_defs_for_reduction (slp_tree slp_node,\n static void\n vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \t\t\t\t  gimple *reduc_def_stmt,\n-\t\t\t\t  int ncopies, enum tree_code reduc_code,\n+\t\t\t\t  int ncopies, internal_fn reduc_fn,\n \t\t\t\t  vec<gimple *> reduction_phis,\n                                   bool double_reduc, \n \t\t\t\t  slp_tree slp_node,\n@@ -4569,7 +4569,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n         step 3: adjust the scalar result (s_out3) if needed.\n \n         Step 1 can be accomplished using one the following three schemes:\n-          (scheme 1) using reduc_code, if available.\n+          (scheme 1) using reduc_fn, if available.\n           (scheme 2) using whole-vector shifts, if available.\n           (scheme 3) using a scalar loop. In this case steps 1+2 above are\n                      combined.\n@@ -4649,7 +4649,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   exit_gsi = gsi_after_labels (exit_bb);\n \n   /* 2.2 Get the relevant tree-code to use in the epilog for schemes 2,3\n-         (i.e. when reduc_code is not available) and in the final adjustment\n+         (i.e. when reduc_fn is not available) and in the final adjustment\n \t code (if needed).  Also get the original scalar reduction variable as\n          defined in the loop.  In case STMT is a \"pattern-stmt\" (i.e. - it\n          represents a reduction pattern), the tree-code and scalar-def are\n@@ -4755,7 +4755,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n     new_phi_result = PHI_RESULT (new_phis[0]);\n \n   if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION\n-      && reduc_code != ERROR_MARK)\n+      && reduc_fn != IFN_LAST)\n     {\n       /* For condition reductions, we have a vector (NEW_PHI_RESULT) containing\n \t various data values where the condition matched and another vector\n@@ -4793,8 +4793,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n       /* Find maximum value from the vector of found indexes.  */\n       tree max_index = make_ssa_name (index_scalar_type);\n-      gimple *max_index_stmt = gimple_build_assign (max_index, REDUC_MAX_EXPR,\n-\t\t\t\t\t\t    induction_index);\n+      gcall *max_index_stmt = gimple_build_call_internal (IFN_REDUC_MAX,\n+\t\t\t\t\t\t\t  1, induction_index);\n+      gimple_call_set_lhs (max_index_stmt, max_index);\n       gsi_insert_before (&exit_gsi, max_index_stmt, GSI_SAME_STMT);\n \n       /* Vector of {max_index, max_index, max_index,...}.  */\n@@ -4849,13 +4850,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n \n       /* Reduce down to a scalar value.  */\n       tree data_reduc = make_ssa_name (scalar_type_unsigned);\n-      optab ot = optab_for_tree_code (REDUC_MAX_EXPR, vectype_unsigned,\n-\t\t\t\t      optab_default);\n-      gcc_assert (optab_handler (ot, TYPE_MODE (vectype_unsigned))\n-\t\t  != CODE_FOR_nothing);\n-      gimple *data_reduc_stmt = gimple_build_assign (data_reduc,\n-\t\t\t\t\t\t     REDUC_MAX_EXPR,\n-\t\t\t\t\t\t     vec_cond_cast);\n+      gcall *data_reduc_stmt = gimple_build_call_internal (IFN_REDUC_MAX,\n+\t\t\t\t\t\t\t   1, vec_cond_cast);\n+      gimple_call_set_lhs (data_reduc_stmt, data_reduc);\n       gsi_insert_before (&exit_gsi, data_reduc_stmt, GSI_SAME_STMT);\n \n       /* Convert the reduced value back to the result type and set as the\n@@ -4867,9 +4864,9 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       scalar_results.safe_push (new_temp);\n     }\n   else if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) == COND_REDUCTION\n-\t   && reduc_code == ERROR_MARK)\n+\t   && reduc_fn == IFN_LAST)\n     {\n-      /* Condition redution without supported REDUC_MAX_EXPR.  Generate\n+      /* Condition reduction without supported IFN_REDUC_MAX.  Generate\n \t idx = 0;\n          idx_val = induction_index[0];\n \t val = data_reduc[0];\n@@ -4939,7 +4936,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n   /* 2.3 Create the reduction code, using one of the three schemes described\n          above. In SLP we simply need to extract all the elements from the \n          vector (without reducing them), so we use scalar shifts.  */\n-  else if (reduc_code != ERROR_MARK && !slp_reduc)\n+  else if (reduc_fn != IFN_LAST && !slp_reduc)\n     {\n       tree tmp;\n       tree vec_elem_type;\n@@ -4954,22 +4951,27 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple *stmt,\n       vec_elem_type = TREE_TYPE (TREE_TYPE (new_phi_result));\n       if (!useless_type_conversion_p (scalar_type, vec_elem_type))\n \t{\n-          tree tmp_dest =\n-\t      vect_create_destination_var (scalar_dest, vec_elem_type);\n-\t  tmp = build1 (reduc_code, vec_elem_type, new_phi_result);\n-\t  epilog_stmt = gimple_build_assign (tmp_dest, tmp);\n+\t  tree tmp_dest\n+\t    = vect_create_destination_var (scalar_dest, vec_elem_type);\n+\t  epilog_stmt = gimple_build_call_internal (reduc_fn, 1,\n+\t\t\t\t\t\t    new_phi_result);\n+\t  gimple_set_lhs (epilog_stmt, tmp_dest);\n \t  new_temp = make_ssa_name (tmp_dest, epilog_stmt);\n-\t  gimple_assign_set_lhs (epilog_stmt, new_temp);\n+\t  gimple_set_lhs (epilog_stmt, new_temp);\n \t  gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n-\t  tmp = build1 (NOP_EXPR, scalar_type, new_temp);\n+\t  epilog_stmt = gimple_build_assign (new_scalar_dest, NOP_EXPR,\n+\t\t\t\t\t     new_temp);\n \t}\n       else\n-\ttmp = build1 (reduc_code, scalar_type, new_phi_result);\n+\t{\n+\t  epilog_stmt = gimple_build_call_internal (reduc_fn, 1,\n+\t\t\t\t\t\t    new_phi_result);\n+\t  gimple_set_lhs (epilog_stmt, new_scalar_dest);\n+\t}\n \n-      epilog_stmt = gimple_build_assign (new_scalar_dest, tmp);\n       new_temp = make_ssa_name (new_scalar_dest, epilog_stmt);\n-      gimple_assign_set_lhs (epilog_stmt, new_temp);\n+      gimple_set_lhs (epilog_stmt, new_temp);\n       gsi_insert_before (&exit_gsi, epilog_stmt, GSI_SAME_STMT);\n \n       if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info)\n@@ -5589,10 +5591,11 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree vectype_in = NULL_TREE;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  enum tree_code code, orig_code, epilog_reduc_code;\n+  enum tree_code code, orig_code;\n+  internal_fn reduc_fn;\n   machine_mode vec_mode;\n   int op_type;\n-  optab optab, reduc_optab;\n+  optab optab;\n   tree new_temp = NULL_TREE;\n   gimple *def_stmt;\n   enum vect_def_type dt, cond_reduc_dt = vect_unknown_def_type;\n@@ -6135,29 +6138,21 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n         double_reduc = true;\n     }\n \n-  epilog_reduc_code = ERROR_MARK;\n+  reduc_fn = IFN_LAST;\n \n   if (STMT_VINFO_VEC_REDUCTION_TYPE (stmt_info) != COND_REDUCTION)\n     {\n-      if (reduction_code_for_scalar_code (orig_code, &epilog_reduc_code))\n+      if (reduction_fn_for_scalar_code (orig_code, &reduc_fn))\n \t{\n-\t  reduc_optab = optab_for_tree_code (epilog_reduc_code, vectype_out,\n-                                         optab_default);\n-\t  if (!reduc_optab)\n-\t    {\n-\t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"no optab for reduction.\\n\");\n-\n-\t      epilog_reduc_code = ERROR_MARK;\n-\t    }\n-\t  else if (optab_handler (reduc_optab, vec_mode) == CODE_FOR_nothing)\n+\t  if (reduc_fn != IFN_LAST\n+\t      && !direct_internal_fn_supported_p (reduc_fn, vectype_out,\n+\t\t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"reduc op not supported by target.\\n\");\n \n-\t      epilog_reduc_code = ERROR_MARK;\n+\t      reduc_fn = IFN_LAST;\n \t    }\n \t}\n       else\n@@ -6180,11 +6175,9 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n       cr_index_vector_type = build_vector_type\n \t(cr_index_scalar_type, TYPE_VECTOR_SUBPARTS (vectype_out));\n \n-      optab = optab_for_tree_code (REDUC_MAX_EXPR, cr_index_vector_type,\n-\t\t\t\t   optab_default);\n-      if (optab_handler (optab, TYPE_MODE (cr_index_vector_type))\n-\t  != CODE_FOR_nothing)\n-\tepilog_reduc_code = REDUC_MAX_EXPR;\n+      if (direct_internal_fn_supported_p (IFN_REDUC_MAX, cr_index_vector_type,\n+\t\t\t\t\t  OPTIMIZE_FOR_SPEED))\n+\treduc_fn = IFN_REDUC_MAX;\n     }\n \n   if ((double_reduc\n@@ -6307,7 +6300,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (!vec_stmt) /* transformation not required.  */\n     {\n       if (first_p)\n-\tvect_model_reduction_cost (stmt_info, epilog_reduc_code, ncopies);\n+\tvect_model_reduction_cost (stmt_info, reduc_fn, ncopies);\n       STMT_VINFO_TYPE (stmt_info) = reduc_vec_info_type;\n       return true;\n     }\n@@ -6461,8 +6454,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     vect_defs[0] = gimple_assign_lhs (*vec_stmt);\n \n   vect_create_epilog_for_reduction (vect_defs, stmt, reduc_def_stmt,\n-\t\t\t\t    epilog_copies,\n-                                    epilog_reduc_code, phis,\n+\t\t\t\t    epilog_copies, reduc_fn, phis,\n \t\t\t\t    double_reduc, slp_node, slp_node_instance);\n \n   return true;"}, {"sha": "063e90826a38f56ee1b97914f709ed39b6e1dbbb", "filename": "gcc/tree.def", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d24520af1ad5ff832d243f177d88f08a1ba012/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=16d24520af1ad5ff832d243f177d88f08a1ba012", "patch": "@@ -1268,18 +1268,6 @@ DEFTREECODE (OMP_CLAUSE, \"omp_clause\", tcc_exceptional, 0)\n    Operand 0: BODY: contains body of the transaction.  */\n DEFTREECODE (TRANSACTION_EXPR, \"transaction_expr\", tcc_expression, 1)\n \n-/* Reduction operations.\n-   Operations that take a vector of elements and \"reduce\" it to a scalar\n-   result (e.g. summing the elements of the vector, finding the minimum over\n-   the vector elements, etc).\n-   Operand 0 is a vector.\n-   The expression returns a scalar, with type the same as the elements of the\n-   vector, holding the result of the reduction of all elements of the operand.\n-   */\n-DEFTREECODE (REDUC_MAX_EXPR, \"reduc_max_expr\", tcc_unary, 1)\n-DEFTREECODE (REDUC_MIN_EXPR, \"reduc_min_expr\", tcc_unary, 1)\n-DEFTREECODE (REDUC_PLUS_EXPR, \"reduc_plus_expr\", tcc_unary, 1)\n-\n /* Widening dot-product.\n    The first two arguments are of type t1.\n    The third argument and the result are of type t2, such that t2 is at least"}]}