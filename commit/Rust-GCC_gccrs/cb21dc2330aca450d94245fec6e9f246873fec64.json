{"sha": "cb21dc2330aca450d94245fec6e9f246873fec64", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2IyMWRjMjMzMGFjYTQ1MGQ5NDI0NWZlYzZlOWYyNDY4NzNmZWM2NA==", "commit": {"author": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-12-03T02:01:23Z"}, "committer": {"name": "Dennis Glatting", "email": "dennisg@gnu.org", "date": "1991-12-03T02:01:23Z"}, "message": "fixed assert macro.\n\nadded memory allocation adjustment macro for hash size allocation.\n\nFrom-SVN: r96", "tree": {"sha": "71b209dc272627dbbe24a309c25e7b2056d8a9c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/71b209dc272627dbbe24a309c25e7b2056d8a9c9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cb21dc2330aca450d94245fec6e9f246873fec64", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb21dc2330aca450d94245fec6e9f246873fec64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb21dc2330aca450d94245fec6e9f246873fec64", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb21dc2330aca450d94245fec6e9f246873fec64/comments", "author": null, "committer": null, "parents": [{"sha": "c4329e99baf201aa69935ccb99a2da8c8376fe47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4329e99baf201aa69935ccb99a2da8c8376fe47", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4329e99baf201aa69935ccb99a2da8c8376fe47"}], "stats": {"total": 164, "additions": 90, "deletions": 74}, "files": [{"sha": "b49678f10e497b7ba2f4c1b0f2b09c5f1c37da7a", "filename": "gcc/objc/hash.c", "status": "modified", "additions": 70, "deletions": 57, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb21dc2330aca450d94245fec6e9f246873fec64/gcc%2Fobjc%2Fhash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb21dc2330aca450d94245fec6e9f246873fec64/gcc%2Fobjc%2Fhash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.c?ref=cb21dc2330aca450d94245fec6e9f246873fec64", "patch": "@@ -16,17 +16,21 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.7 1991/11/23 22:18:29 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.c,v 0.8 1991/11/24 01:20:02 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/11/23 22:18:29 $\n+  $Date: 1991/11/24 01:20:02 $\n   $Log: hash.c,v $\n+ * Revision 0.8  1991/11/24  01:20:02  dennisg\n+ * changed shorts back to ints.\n+ * the efficiency gained didn't out weight the grossness of the code.\n+ *\n  * Revision 0.7  1991/11/23  22:18:29  dennisg\n  * deleted hashIndex() and moved it to hash-inline.h\n- * converted hash_value_for_key() to a inline and moved it to hash-inline.h.\n+ * converted hash_value_for_key () to a inline and moved it to hash-inline.h.\n  *\n  * Revision 0.6  1991/11/21  22:27:06  dennisg\n  * changed hash value calculation.\n- * func name changed from hashValue() to hashIndex().  the\n+ * func name changed from hashValue () to hashIndex().  the\n  * func really calculated a index anyway.\n  * changed hash func impl.  essentially it was calculating a hash value\n  * from a hash value.  this is a implementation thing.\n@@ -35,8 +39,8 @@\n  * converted hashIndex() to a inline.\n  *\n  * Revision 0.4  1991/11/19  12:34:41  dennisg\n- * bug in hash_delete().  It was using void* to obtain nodes to\n- * pass to hash_remove().  The value passed to hash_removed() is a\n+ * bug in hash_delete ().  It was using void* to obtain nodes to\n+ * pass to hash_remove ().  The value passed to hash_removed () is a\n  * entry from the node structure rather than the node itself.  Using\n  * void* removed compiler checking.\n  * Modified to implement cache expansion.\n@@ -70,96 +74,104 @@\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tThese equations are \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tpercentages. */\n #define\tFULLNESS(cache)\t\\\n-\t((((cache)->sizeOfHash * 75\t) / 100 ) <= (cache)->entriesInHash)\n+\t ((((cache)->sizeOfHash * 75\t) / 100) <= (cache)->entriesInHash)\n #define\tEXPANSION(cache) \\\n \t(((cache)->sizeOfHash * 175 ) / 100 )\n \n+#define\tMEMORY_ALLOCATION_ADJUST(i) \\\n+\t((i&0x01)?i:(i-1))\n \n-Cache_t hash_new( u_int sizeOfHash ) {\n+Cache_t hash_new (u_int sizeOfHash) {\n \n   Cache_t retCache;\n+\t\n \n-\n-  assert( sizeOfHash );\n+  assert(sizeOfHash);\n+\t\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Memory is allocated on this\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmachine in even address\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tchunks.  Therefore the\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tmodulus must be odd. */\n+\tsizeOfHash = MEMORY_ALLOCATION_ADJUST(sizeOfHash);\n \n                                                 /* Allocate the cache \n-                                                  structure.  calloc() insures\n+                                                  structure.  calloc () insures\n                                                   its initialization for\n                                                   default values. */\n-  retCache = calloc( 1, sizeof( Cache ));\n-  assert( retCache );\n+  retCache = calloc (1, sizeof (Cache));\n+  assert(retCache);\n   \n                                                 /* Allocate the array of \n                                                   buckets for the cache.  \n-                                                  calloc() initializes all of \n+                                                  calloc () initializes all of \n                                                   the pointers to NULL. */\n-  retCache->theNodeTable = calloc( sizeOfHash, sizeof( CacheNode_t ));\n-  assert( retCache->theNodeTable );\n+  retCache->theNodeTable = calloc (sizeOfHash, sizeof (CacheNode_t));\n+  assert(retCache->theNodeTable);\n   \n-  retCache->sizeOfHash = sizeOfHash;\n+  retCache->sizeOfHash\t= sizeOfHash;\n \n   return retCache;\n }\n \n \n-void hash_delete( Cache_t theCache ) {\n+void hash_delete (Cache_t theCache) {\n \n   CacheNode_t aNode;\n   \n \n                                                 /* Purge all key/value pairs \n                                                   from the table. */\n-  while( aNode = hash_next( theCache, NULL ))\n-    hash_remove( theCache, aNode->theKey );\n+  while (aNode = hash_next (theCache, NULL))\n+    hash_remove (theCache, aNode->theKey);\n \n                                                 /* Release the array of nodes \n                                                   and the cache itself. */\n-  free( theCache->theNodeTable );\n-  free( theCache );\n+  free (theCache->theNodeTable);\n+  free (theCache);\n }\n \n \n-void hash_add( Cache_t* theCache, void* aKey, void* aValue ) {\n+void hash_add (Cache_t* theCache, void* aKey, void* aValue) {\n \n-  u_int       indx = hashIndex( *theCache, aKey );\n-  CacheNode_t aCacheNode = calloc( 1, sizeof( CacheNode ));\n+  u_int       indx = hashIndex(*theCache, aKey);\n+  CacheNode_t aCacheNode = calloc (1, sizeof (CacheNode));\n \n \n-  assert( aCacheNode );\n+  assert(aCacheNode);\n   \n                                                 /* Initialize the new node. */\n   aCacheNode->theKey    = aKey;\n   aCacheNode->theValue  = aValue;\n-  aCacheNode->nextNode  = ( *( *theCache )->theNodeTable )[ indx ];\n+  aCacheNode->nextNode  = (* (*theCache)->theNodeTable)[ indx ];\n   \n                                                 /* Debugging.\n                                                 \n                                                   Check the list for another \n                                                   key. */\n #ifdef DEBUG\n-    { CacheNode_t checkHashNode = ( *( *theCache )->theNodeTable )[ indx ];\n+    { CacheNode_t checkHashNode = (* (*theCache)->theNodeTable)[ indx ];\n     \n-      while( checkHashNode ) {\n+      while (checkHashNode) {\n     \n-        assert( checkHashNode->theKey != aKey );\n+        assert(checkHashNode->theKey != aKey);\n         checkHashNode = checkHashNode->nextNode;\n       }\n     }\n #endif\n \n                                                 /* Install the node as the\n                                                   first element on the list. */\n-  ( *( *theCache )->theNodeTable )[ indx ] = aCacheNode;\n+  (* (*theCache)->theNodeTable)[ indx ] = aCacheNode;\n \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Bump the number of entries\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin the cache. */\n-\t++( *theCache )->entriesInHash;\n+\t++ (*theCache)->entriesInHash;\n \t\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Check the hash table's\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfullness.   We're going\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tto expand if it is above\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthe fullness level. */\n-\tif(FULLNESS( *theCache )) {\n+\tif (FULLNESS (*theCache)) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* The hash table has reached\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tits fullness level.  Time to\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\texpand it. \n@@ -169,20 +181,21 @@ void hash_add( Cache_t* theCache, void* aKey, void* aValue ) {\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tprimitive functions thereby\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tincreasing its \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcorrectness. */\n-\t\tCache_t\t\t\tnewCache = hash_new(EXPANSION( *theCache ));\n \t\tCacheNode_t\taNode = NULL;\n+\t\tCache_t\t\t\tnewCache = \n+\t\t\t\t\t\t\t\t\thash_new (MEMORY_ALLOCATION_ADJUST( EXPANSION (*theCache)));\n \n \t\tDEBUG_PRINTF (stderr, \"Expanding cache %#x from %d to %d\\n\",\n-\t\t\t*theCache, ( *theCache )->sizeOfHash, newCache->sizeOfHash);\n+\t\t\t*theCache, (*theCache)->sizeOfHash, newCache->sizeOfHash);\n \t\t\t\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Copy the nodes from the\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tfirst hash table to the\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tnew one. */\n-\t\twhile( aNode = hash_next( *theCache, aNode ))\n-\t\t\thash_add( &newCache, aNode->theKey, aNode->theValue );\n+\t\twhile (aNode = hash_next (*theCache, aNode))\n+\t\t\thash_add (&newCache, aNode->theKey, aNode->theValue);\n \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Trash the old cache. */\n-\t\thash_delete( *theCache );\n+\t\thash_delete (*theCache);\n \t\t\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Return a pointer to the new\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table. */\n@@ -191,23 +204,23 @@ void hash_add( Cache_t* theCache, void* aKey, void* aValue ) {\n }\n \n \n-void hash_remove( Cache_t theCache, void* aKey ) {\n+void hash_remove (Cache_t theCache, void* aKey) {\n \n-  u_int       indx = hashIndex( theCache, aKey );\n-  CacheNode_t aCacheNode = ( *theCache->theNodeTable )[ indx ];\n+  u_int       indx = hashIndex(theCache, aKey);\n+  CacheNode_t aCacheNode = (*theCache->theNodeTable)[ indx ];\n   \n   \n                                                 /* We assume there is an entry \n                                                   in the table.  Error if it \n                                                   is not. */\n-  assert( aCacheNode );\n+  assert(aCacheNode);\n   \n                                                 /* Special case.  First element \n                                                   is the key/value pair to be \n                                                   removed. */\n-  if( aCacheNode->theKey == aKey ) {\n-    ( *theCache->theNodeTable )[ indx ] = aCacheNode->nextNode;\n-    free( aCacheNode );\n+  if (aCacheNode->theKey == aKey) {\n+    (*theCache->theNodeTable)[ indx ] = aCacheNode->nextNode;\n+    free (aCacheNode);\n   } else {\n                                                 /* Otherwise, find the hash \n                                                   entry. */\n@@ -216,13 +229,13 @@ void hash_remove( Cache_t theCache, void* aKey ) {\n     \n     do {\n     \n-      if( aCacheNode->theKey == aKey ) {\n+      if (aCacheNode->theKey == aKey) {\n         prevHashNode->nextNode = aCacheNode->nextNode, removed = YES;\n-        free( aCacheNode );\n+        free (aCacheNode);\n       } else\n         prevHashNode = aCacheNode, aCacheNode = aCacheNode->nextNode;\n-    } while( !removed && aCacheNode );\n-    assert( removed );\n+    } while (!removed && aCacheNode);\n+    assert(removed);\n   }\n \t\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t/* Decrement the number of\n@@ -231,7 +244,7 @@ void hash_remove( Cache_t theCache, void* aKey ) {\n }\n \n \n-CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode ) {\n+CacheNode_t hash_next (Cache_t theCache, CacheNode_t aCacheNode) {\n \n   CacheNode_t theCacheNode = aCacheNode;\n   \n@@ -240,16 +253,16 @@ CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode ) {\n                                                   then reset the last node \n                                                   visitied pointer and bucket \n                                                   index. */\n-  if( !theCacheNode )\n+  if (!theCacheNode)\n     theCache->lastBucket  = 0;\n   \n                                                 /* If there is a node visited\n                                                   last then check for another \n                                                   entry in the same bucket; \n                                                   Otherwise step to the next \n                                                   bucket. */\n-  if( theCacheNode )\n-    if( theCacheNode->nextNode )\n+  if (theCacheNode)\n+    if (theCacheNode->nextNode)\n                                                 /* There is a node which \n                                                   follows the last node \n                                                   returned.  Step to that node \n@@ -261,15 +274,15 @@ CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode ) {\n                                                 /* If the list isn't exhausted \n                                                   then search the buckets for \n                                                   other nodes. */\n-  if( theCache->lastBucket < theCache->sizeOfHash ) {\n+  if (theCache->lastBucket < theCache->sizeOfHash) {\n                                                 /*  Scan the remainder of the \n                                                   buckets looking for an entry\n                                                   at the head of the list.  \n                                                   Return the first item \n                                                   found. */\n-    while( theCache->lastBucket < theCache->sizeOfHash )\n-      if(( *theCache->theNodeTable )[ theCache->lastBucket ])\n-        return ( *theCache->theNodeTable )[ theCache->lastBucket ];\n+    while (theCache->lastBucket < theCache->sizeOfHash)\n+      if ((*theCache->theNodeTable)[ theCache->lastBucket ])\n+        return (*theCache->theNodeTable)[ theCache->lastBucket ];\n       else\n         ++theCache->lastBucket;\n   "}, {"sha": "e68138b182e0729209905dca49d8087ec9b6aa38", "filename": "gcc/objc/hash.h", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cb21dc2330aca450d94245fec6e9f246873fec64/gcc%2Fobjc%2Fhash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cb21dc2330aca450d94245fec6e9f246873fec64/gcc%2Fobjc%2Fhash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fhash.h?ref=cb21dc2330aca450d94245fec6e9f246873fec64", "patch": "@@ -6,7 +6,7 @@\n  *  void*.  The hashing function converts the key to\n  *  an integer and computes it hash value.\n  *\n- * Copyright (C) 1991 Threaded Technologies Inc.\n+ * Copyright  (C) 1991 Threaded Technologies Inc.\n  * \n  * This program is free software; you can redistribute it and/or modify\n  * it under the terms of the GNU General Public License as published\n@@ -21,14 +21,18 @@\n  * along with this program; if not, write to the Free Software\n  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.\n  * \n-  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.5 1991/11/23 22:19:21 dennisg Exp dennisg $\n+  $Header: /usr/user/dennis_glatting/ObjC/c-runtime/lib/RCS/hash.h,v 0.6 1991/11/24 01:20:02 dennisg Exp dennisg $\n   $Author: dennisg $\n-  $Date: 1991/11/23 22:19:21 $\n+  $Date: 1991/11/24 01:20:02 $\n   $Log: hash.h,v $\n+ * Revision 0.6  1991/11/24  01:20:02  dennisg\n+ * changed shorts back to ints.\n+ * the efficiency gained didn't out weight the grossness of the code.\n+ *\n  * Revision 0.5  1991/11/23  22:19:21  dennisg\n  * converted some entries in the hash structure from ints to shorts.\n  * this was done to use a less expensive division instruction\n- * in the hashIndex() routine.\n+ * in the hashIndex () routine.\n  *\n  * Revision 0.4  1991/11/21  22:25:19  dennisg\n  * deleted hash mask information from hash struct.\n@@ -85,24 +89,25 @@ typedef struct cache_node {\n  * This data structure is the cache.\n  *\n  * It must be passed to all of the hashing routines\n- *  (except for new).\n+ *   (except for new).\n  */\n typedef struct cache {\n   /*\n    * Variables used to implement the\n    *  hash itself.\n    */\n-  CacheNode_t (* theNodeTable )[];                /* Pointer to an array of\n+  CacheNode_t  (* theNodeTable)[];                /* Pointer to an array of\n                                                     hash nodes. */\n \t/*\n \t * Variables used to track the size of the hash\n \t *\ttable so to determine when to resize it.\n \t */\n-  u_int       sizeOfHash,                         /* Number of buckets \n+  u_int       sizeOfHash,                        /* Number of buckets \n                                                     allocated for the hash\n-                                                    table (number of array\n+                                                    table  (number of array\n                                                     entries allocated for\n-                                                    \"theNodeTable\"). */\n+                                                    \"theNodeTable\").  Must be\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ta power of two. */\n \t\t\t\t\t\t\tentriesInHash;\t\t\t\t\t\t\t\t\t\t\t/* Current number of entries\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tin ther hash table. */\n   /*\n@@ -119,14 +124,12 @@ typedef struct cache {\n                                                   functions. */\n                                                 /* Allocate and initialize \n                                                   a hash table.  Hash table \n-                                                  size taken as a parameter. \n-                                                    A value of 0 is not \n-                                                  allowed. */ \n-Cache_t hash_new( u_int sizeOfHash );\n+                                                  size taken as a parameter. */ \n+Cache_t hash_new (u_int sizeOfHash);\n                                                 /* Deallocate all of the\n                                                   hash nodes and the cache\n                                                   itself. */\n-void hash_delete( Cache_t theCache );\n+void hash_delete (Cache_t theCache);\n                                                 /* Add the key/value pair\n                                                   to the hash table.  If the\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\thash table reaches a \n@@ -135,12 +138,12 @@ void hash_delete( Cache_t theCache );\n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tassert() if the key is \n \t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\talready in the hash. */\n-void hash_add( Cache_t* theCache, void* aKey, void* aValue );\n+void hash_add (Cache_t* theCache, void* aKey, void* aValue);\n                                                 /* Remove the key/value pair\n                                                   from the hash table.  \n                                                   assert() if the key isn't \n                                                   in the table. */\n-void hash_remove( Cache_t theCache, void* aKey );\n+void hash_remove (Cache_t theCache, void* aKey);\n                                                 /* Used to index through the\n                                                   hash table.  Start with NULL\n                                                   to get the first entry.\n@@ -153,7 +156,7 @@ void hash_remove( Cache_t theCache, void* aKey );\n                                                   Cache nodes are returned\n                                                   such that key or value can\n                                                   ber extracted. */\n-CacheNode_t hash_next( Cache_t theCache, CacheNode_t aCacheNode );\n+CacheNode_t hash_next (Cache_t theCache, CacheNode_t aCacheNode);\n \n \n #ifdef __cplusplus"}]}