{"sha": "c5ee5ad288f320f565e51d9b6ce836750bd31eec", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVlZTVhZDI4OGYzMjBmNTY1ZTUxZDliNmNlODM2NzUwYmQzMWVlYw==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2006-10-31T17:53:35Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2006-10-31T17:53:35Z"}, "message": "exp_aggr.adb (Build_Record_Aggr_Code): For extension aggregates...\n\n2006-10-31  Bob Duff  <duff@adacore.com>\n\t    Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_aggr.adb (Build_Record_Aggr_Code): For extension aggregates, if\n\tthe parent part is a build-in-place function call, generate assignments.\n\t(Expand_Record_Aggregate): Call Convert_To_Assignments if any components\n\tare build-in-place function calls.\n\t(Replace_Self_Reference): New subsidiary of\n\tMake_OK_Assignment_Statement, to replace an access attribute that is a\n\tself-reference into an access to the appropriate component of the\n\ttarget object. Generalizes previous mechanism to handle self-references\n\tnested at any level.\n\t(Is_Self_Referential_Init): Remove, not needed.\n\t(Is_Self_Referential_Init): New predicate to simplify handling of self\n\treferential components in record aggregates.\n\t(Has_Default_Init_Comps, Make_OK_Assignment_Statement): Add guard to\n\tcheck for presence of entity before checking for self-reference.\n\t(Has_Default_Init_Comps): Return True if a component association is a\n\tself-reference to the enclosing type, which can only come from a\n\tdefault initialization.\n\t(Make_OK_Assignment_Statement): If the expression is of the form\n\tTyp'Acc, where Acc is an access attribute, the expression comes from a\n\tdefault initialized self-referential component.\n\t(Build_Record_Aggr_Code): If the type of the aggregate is a tagged type\n\tthat has been derived from several abstract interfaces we must also\n\tinitialize the tags of the secondary dispatch tables.\n\nFrom-SVN: r118253", "tree": {"sha": "3006b5171d1d3bcd7fb234215083843ddddc61da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3006b5171d1d3bcd7fb234215083843ddddc61da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5ee5ad288f320f565e51d9b6ce836750bd31eec", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ee5ad288f320f565e51d9b6ce836750bd31eec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5ee5ad288f320f565e51d9b6ce836750bd31eec", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5ee5ad288f320f565e51d9b6ce836750bd31eec/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e84a19613db328acceca4550d53093a84501245f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e84a19613db328acceca4550d53093a84501245f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e84a19613db328acceca4550d53093a84501245f"}], "stats": {"total": 117, "additions": 100, "deletions": 17}, "files": [{"sha": "3e9c3156d423fdcfcfbfa7718e6a6a364bbc8dcc", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 100, "deletions": 17, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5ee5ad288f320f565e51d9b6ce836750bd31eec/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5ee5ad288f320f565e51d9b6ce836750bd31eec/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=c5ee5ad288f320f565e51d9b6ce836750bd31eec", "patch": "@@ -41,6 +41,7 @@ with Itypes;   use Itypes;\n with Lib;      use Lib;\n with Nmake;    use Nmake;\n with Nlists;   use Nlists;\n+with Opt;      use Opt;\n with Restrict; use Restrict;\n with Rident;   use Rident;\n with Rtsfind;  use Rtsfind;\n@@ -113,7 +114,7 @@ package body Exp_Aggr is\n    --      aggregate\n \n    procedure Convert_To_Assignments (N : Node_Id; Typ : Entity_Id);\n-   --  N is an N_Aggregate of a N_Extension_Aggregate. Typ is the type of\n+   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of\n    --  the aggregate. Transform the given aggregate into a sequence of\n    --  assignments component per component.\n \n@@ -124,7 +125,7 @@ package body Exp_Aggr is\n       Flist                         : Node_Id   := Empty;\n       Obj                           : Entity_Id := Empty;\n       Is_Limited_Ancestor_Expansion : Boolean   := False) return List_Id;\n-   --  N is an N_Aggregate or a N_Extension_Aggregate. Typ is the type of the\n+   --  N is an N_Aggregate or an N_Extension_Aggregate. Typ is the type of the\n    --  aggregate. Target is an expression containing the location on which the\n    --  component by component assignments will take place. Returns the list of\n    --  assignments plus all other adjustments needed for tagged and controlled\n@@ -256,11 +257,17 @@ package body Exp_Aggr is\n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n       Name       : Node_Id;\n-      Expression : Node_Id) return Node_Id;\n+      Expression : Node_Id;\n+      Self_Ref   : Boolean := False) return Node_Id;\n    --  This is like Make_Assignment_Statement, except that Assignment_OK\n    --  is set in the left operand. All assignments built by this unit\n    --  use this routine. This is needed to deal with assignments to\n    --  initialized constants that are done in place.\n+   --  If Self_Ref is true, the aggregate contains an access reference to the\n+   --  enclosing type, obtained from a default initialization. The reference\n+   --  as to be expanded into a reference to  the enclosing object, which is\n+   --  obtained from the Name in the assignment. The value of Self_Ref is\n+   --  inherited from the aggregate itself.\n \n    function Packed_Array_Aggregate_Handled (N : Node_Id) return Boolean;\n    --  Given an array aggregate, this function handles the case of a packed\n@@ -2239,23 +2246,32 @@ package body Exp_Aggr is\n                   Check_Ancestor_Discriminants (Entity (A));\n                end if;\n \n-            --  Ada 2005 (AI-287): If the ancestor part is a limited type,\n-            --  a recursive call expands the ancestor.\n+            --  Ada 2005 (AI-287): If the ancestor part is an aggregate of\n+            --  limited type, a recursive call expands the ancestor. Note that\n+            --  in the limited case, the ancestor part must be either a\n+            --  function call (possibly qualified) or aggregate (definitely\n+            --  qualified).\n \n-            elsif Is_Limited_Type (Etype (A)) then\n+            elsif Is_Limited_Type (Etype (A))\n+              and then Nkind (Unqualify (A)) /= N_Function_Call --  aggregate?\n+            then\n                Ancestor_Is_Expression := True;\n \n                Append_List_To (L,\n                   Build_Record_Aggr_Code (\n-                    N                             => Expression (A),\n-                    Typ                           => Etype (Expression (A)),\n+                    N                             => Unqualify (A),\n+                    Typ                           => Etype (Unqualify (A)),\n                     Target                        => Target,\n                     Flist                         => Flist,\n                     Obj                           => Obj,\n                     Is_Limited_Ancestor_Expansion => True));\n \n             --  If the ancestor part is an expression \"E\", we generate\n             --     T(tmp) := E;\n+            --  In Ada 2005, this includes the case of a (possibly qualified)\n+            --  limited function call. The assignment will turn into a\n+            --  build-in-place function call (see\n+            --  Make_Build_In_Place_Call_In_Assignment).\n \n             else\n                Ancestor_Is_Expression := True;\n@@ -2264,10 +2280,8 @@ package body Exp_Aggr is\n                --  If the ancestor part is an aggregate, force its full\n                --  expansion, which was delayed.\n \n-               if Nkind (A) = N_Qualified_Expression\n-                 and then (Nkind (Expression (A)) = N_Aggregate\n-                             or else\n-                           Nkind (Expression (A)) = N_Extension_Aggregate)\n+               if Nkind (Unqualify (A)) = N_Aggregate\n+                 or else Nkind (Unqualify (A)) = N_Extension_Aggregate\n                then\n                   Set_Analyzed (A, False);\n                   Set_Analyzed (Expression (A), False);\n@@ -2283,7 +2297,8 @@ package body Exp_Aggr is\n                Assign := New_List (\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Ref,\n-                   Expression => A));\n+                   Expression => A,\n+                   Self_Ref   => Has_Self_Reference (N)));\n                Set_No_Ctrl_Actions (First (Assign));\n \n                --  Assign the tag now to make sure that the dispatching call in\n@@ -2657,7 +2672,8 @@ package body Exp_Aggr is\n                Instr :=\n                  Make_OK_Assignment_Statement (Loc,\n                    Name       => Comp_Expr,\n-                   Expression => Expression (Comp));\n+                   Expression => Expression (Comp),\n+                   Self_Ref   => Has_Self_Reference (N));\n \n                Set_No_Ctrl_Actions (Instr);\n                Append_To (L, Instr);\n@@ -2757,7 +2773,7 @@ package body Exp_Aggr is\n            Make_OK_Assignment_Statement (Loc,\n              Name =>\n                Make_Selected_Component (Loc,\n-                  Prefix => New_Copy_Tree (Target),\n+                 Prefix => New_Copy_Tree (Target),\n                  Selector_Name =>\n                    New_Reference_To\n                      (First_Tag_Component (Base_Type (Typ)), Loc)),\n@@ -2769,6 +2785,20 @@ package body Exp_Aggr is\n                     Loc)));\n \n          Append_To (L, Instr);\n+\n+         --  Ada 2005 (AI-251): If the tagged type has been derived from\n+         --  abstract interfaces we must also initialize the tags of the\n+         --  secondary dispatch tables.\n+\n+         if Present (Abstract_Interfaces (Base_Type (Typ)))\n+           and then not\n+             Is_Empty_Elmt_List (Abstract_Interfaces (Base_Type (Typ)))\n+         then\n+            Init_Secondary_Tags\n+              (Typ        => Base_Type (Typ),\n+               Target     => Target,\n+               Stmts_List => L);\n+         end if;\n       end if;\n \n       --  If the controllers have not been initialized yet (by lack of non-\n@@ -4765,10 +4795,19 @@ package body Exp_Aggr is\n          return;\n       end if;\n \n+      --  Ada 2005 (AI-318-2): We need to convert to assignments if components\n+      --  are build-in-place function calls. This test could be more specific,\n+      --  but doing it for all inherently limited aggregates seems harmless.\n+      --  The assignments will turn into build-in-place function calls (see\n+      --  Make_Build_In_Place_Call_In_Assignment).\n+\n+      if Ada_Version >= Ada_05 and then Is_Inherently_Limited_Type (Typ) then\n+         Convert_To_Assignments (N, Typ);\n+\n       --  Gigi doesn't handle properly temporaries of variable size\n       --  so we generate it in the front-end\n \n-      if not Size_Known_At_Compile_Time (Typ) then\n+      elsif not Size_Known_At_Compile_Time (Typ) then\n          Convert_To_Assignments (N, Typ);\n \n       --  Temporaries for controlled aggregates need to be attached to a\n@@ -5131,6 +5170,10 @@ package body Exp_Aggr is\n          return False;\n       end if;\n \n+      if Has_Self_Reference (N) then\n+         return True;\n+      end if;\n+\n       --  Check if any direct component has default initialized components\n \n       C := First (Comps);\n@@ -5218,10 +5261,50 @@ package body Exp_Aggr is\n    function Make_OK_Assignment_Statement\n      (Sloc       : Source_Ptr;\n       Name       : Node_Id;\n-      Expression : Node_Id) return Node_Id\n+      Expression : Node_Id;\n+      Self_Ref   : Boolean := False) return Node_Id\n    is\n+      function Replace_Type (Expr : Node_Id) return Traverse_Result;\n+      --  If the aggregate contains a self-reference, traverse each\n+      --  expression to replace a possible self-reference with a reference\n+      --  to the proper component of the target of the assignment.\n+\n+      ------------------\n+      -- Replace_Type --\n+      ------------------\n+\n+      function Replace_Type (Expr : Node_Id) return Traverse_Result is\n+      begin\n+         if Nkind (Expr) = N_Attribute_Reference\n+           and  then Is_Entity_Name (Prefix (Expr))\n+           and then Is_Type (Entity (Prefix (Expr)))\n+         then\n+            if Is_Entity_Name (Prefix (Name)) then\n+               Rewrite (Prefix (Expr),\n+                 New_Occurrence_Of (Entity (Prefix (Name)), Sloc));\n+            else\n+               Rewrite (Expr,\n+                 Make_Attribute_Reference (Sloc,\n+                   Attribute_Name => Name_Unrestricted_Access,\n+                   Prefix         => New_Copy_Tree (Prefix (Name))));\n+               Set_Analyzed (Parent (Expr), False);\n+            end if;\n+         end if;\n+         return OK;\n+      end Replace_Type;\n+\n+      procedure Replace_Self_Reference is\n+        new Traverse_Proc (Replace_Type);\n+\n+   --  Start of processing for Make_OK_Assignment_Statement\n+\n    begin\n       Set_Assignment_OK (Name);\n+\n+      if Self_Ref then\n+         Replace_Self_Reference (Expression);\n+      end if;\n+\n       return Make_Assignment_Statement (Sloc, Name, Expression);\n    end Make_OK_Assignment_Statement;\n "}]}