{"sha": "867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODY3YTAxMjZiY2I4ZTJlYTJiOWVmOTAwYWM4YjZiNzVjNGZjNjM4Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-06-08T12:18:27Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-06-08T12:18:27Z"}, "message": "Remove word_mode hack for split bitfields\n\nThis patch is effectively reverting a change from 1994.  The reason\nI think it's a hack is that store_bit_field_1 is creating a subreg\nreference to one word of a field even though it has already proven that\nthe field spills into the following word.  We then rely on the special\nSUBREG handling in store_split_bit_field to ignore the extent of op0 and\nlook inside the SUBREG_REG regardless.  I don't see any reason why we can't\npass the original op0 to store_split_bit_field instead.\n\nTested on aarch64-linux-gnu and x86_64-linux-gnu.\n\ngcc/\n\t* expmed.c (store_bit_field_1): Do not restrict a multiword op0\n\tto one word if the field is known to overlap other words.\n\t(extract_bit_field_1): Likewise.\n\t(store_split_bit_field): Remove compensating code.\n\t(extract_split_bit_field): Likewise.\n\nFrom-SVN: r237211", "tree": {"sha": "40883c86eea64895001fccfa98cda344648a1326", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/40883c86eea64895001fccfa98cda344648a1326"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "html_url": "https://github.com/Rust-GCC/gccrs/commit/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d821b79474ab6c3513fe0060decff0ecd5934fc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d821b79474ab6c3513fe0060decff0ecd5934fc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d821b79474ab6c3513fe0060decff0ecd5934fc0"}], "stats": {"total": 63, "additions": 21, "deletions": 42}, "files": [{"sha": "6767537e9c960809265a966854238394ad8eae37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "patch": "@@ -1,3 +1,11 @@\n+2016-06-08  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* expmed.c (store_bit_field_1): Do not restrict a multiword op0\n+\tto one word if the field is known to overlap other words.\n+\t(extract_bit_field_1): Likewise.\n+\t(store_split_bit_field): Remove compensating code.\n+\t(extract_split_bit_field): Likewise.\n+\n 2016-06-08  Bernd Schmidt  <bschmidt@redhat.com>\n \n \tPR debug/71432"}, {"sha": "6645a535b3eef9624e6f3ce61d2fcf864d1cf574", "filename": "gcc/expmed.c", "status": "modified", "additions": 13, "deletions": 42, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=867a0126bcb8e2ea2b9ef900ac8b6b75c4fc6382", "patch": "@@ -967,11 +967,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      If the region spans two words, defer to store_split_bit_field.  */\n   if (!MEM_P (op0) && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n     {\n-      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n-\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n-      gcc_assert (op0);\n-      bitnum %= BITS_PER_WORD;\n-      if (bitnum + bitsize > BITS_PER_WORD)\n+      if (bitnum % BITS_PER_WORD + bitsize > BITS_PER_WORD)\n \t{\n \t  if (!fallback_p)\n \t    return false;\n@@ -980,6 +976,10 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t bitregion_end, value, reverse);\n \t  return true;\n \t}\n+      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n+      gcc_assert (op0);\n+      bitnum %= BITS_PER_WORD;\n     }\n \n   /* From here on we can assume that the field to be stored in fits\n@@ -1383,25 +1383,8 @@ store_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n \t\t\t\t\t    bitsdone, NULL_RTX, 1, false);\n \t}\n \n-      /* If OP0 is a register, then handle OFFSET here.\n-\n-\t When handling multiword bitfields, extract_bit_field may pass\n-\t down a word_mode SUBREG of a larger REG for a bitfield that actually\n-\t crosses a word boundary.  Thus, for a SUBREG, we must find\n-\t the current word starting from the base register.  */\n-      if (GET_CODE (op0) == SUBREG)\n-\t{\n-\t  int word_offset = (SUBREG_BYTE (op0) / UNITS_PER_WORD)\n-\t\t\t    + (offset * unit / BITS_PER_WORD);\n-\t  machine_mode sub_mode = GET_MODE (SUBREG_REG (op0));\n-\t  if (sub_mode != BLKmode && GET_MODE_SIZE (sub_mode) < UNITS_PER_WORD)\n-\t    word = word_offset ? const0_rtx : op0;\n-\t  else\n-\t    word = operand_subword_force (SUBREG_REG (op0), word_offset,\n-\t\t\t\t\t  GET_MODE (SUBREG_REG (op0)));\n-\t  offset &= BITS_PER_WORD / unit - 1;\n-\t}\n-      else if (REG_P (op0))\n+      /* If OP0 is a register, then handle OFFSET here.  */\n+      if (SUBREG_P (op0) || REG_P (op0))\n \t{\n \t  machine_mode op0_mode = GET_MODE (op0);\n \t  if (op0_mode != BLKmode && GET_MODE_SIZE (op0_mode) < UNITS_PER_WORD)\n@@ -1787,17 +1770,17 @@ extract_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n      If the region spans two words, defer to extract_split_bit_field.  */\n   if (!MEM_P (op0) && GET_MODE_SIZE (GET_MODE (op0)) > UNITS_PER_WORD)\n     {\n-      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n-\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n-      bitnum %= BITS_PER_WORD;\n-      if (bitnum + bitsize > BITS_PER_WORD)\n+      if (bitnum % BITS_PER_WORD + bitsize > BITS_PER_WORD)\n \t{\n \t  if (!fallback_p)\n \t    return NULL_RTX;\n \t  target = extract_split_bit_field (op0, bitsize, bitnum, unsignedp,\n \t\t\t\t\t    reverse);\n \t  return convert_extracted_bit_field (target, mode, tmode, unsignedp);\n \t}\n+      op0 = simplify_gen_subreg (word_mode, op0, GET_MODE (op0),\n+\t\t\t\t bitnum / BITS_PER_WORD * UNITS_PER_WORD);\n+      bitnum %= BITS_PER_WORD;\n     }\n \n   /* From here on we know the desired field is smaller than a word.\n@@ -2109,20 +2092,8 @@ extract_split_bit_field (rtx op0, unsigned HOST_WIDE_INT bitsize,\n       thissize = MIN (bitsize - bitsdone, BITS_PER_WORD);\n       thissize = MIN (thissize, unit - thispos);\n \n-      /* If OP0 is a register, then handle OFFSET here.\n-\n-\t When handling multiword bitfields, extract_bit_field may pass\n-\t down a word_mode SUBREG of a larger REG for a bitfield that actually\n-\t crosses a word boundary.  Thus, for a SUBREG, we must find\n-\t the current word starting from the base register.  */\n-      if (GET_CODE (op0) == SUBREG)\n-\t{\n-\t  int word_offset = (SUBREG_BYTE (op0) / UNITS_PER_WORD) + offset;\n-\t  word = operand_subword_force (SUBREG_REG (op0), word_offset,\n-\t\t\t\t\tGET_MODE (SUBREG_REG (op0)));\n-\t  offset = 0;\n-\t}\n-      else if (REG_P (op0))\n+      /* If OP0 is a register, then handle OFFSET here.  */\n+      if (SUBREG_P (op0) || REG_P (op0))\n \t{\n \t  word = operand_subword_force (op0, offset, GET_MODE (op0));\n \t  offset = 0;"}]}