{"sha": "d986ff50b4aad62c45d7ac62915e072643ddfca1", "node_id": "C_kwDOANBUbNoAKGQ5ODZmZjUwYjRhYWQ2MmM0NWQ3YWM2MjkxNWUwNzI2NDNkZGZjYTE", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-19T17:59:12Z"}, "committer": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2021-11-24T14:03:07Z"}, "message": "Split return functionality of get_non_stale_global_range.\n\nGet_non_stale_global_range returns true only when there is a cache entry that\nis not out of date.  Change it so that it returns true if there was a cache\nvalue, but return the temporal comparison result in an auxiallary flag.\n\n\t* gimple-range-cache.cc (ranger_cache::get_global_range): Always\n\treturn a range, return if it came from the cache or not.\n\t(get_non_stale_global_range): Rename to get_global_range, and return\n\tthe temporal state in a flag.\n\t* gimple-range-cache.h (get_non_stale_global_range): Rename and adjust.\n\t* gimple-range.cc (gimple_ranger::range_of_expr): No need to query\n\tget_global_range.\n\t(gimple_ranger::range_of_stmt): Adjust for global cache temporal state\n\treturned in a flag.", "tree": {"sha": "079d6a4f311580b7dc15272e9c7737ae792b1468", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/079d6a4f311580b7dc15272e9c7737ae792b1468"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d986ff50b4aad62c45d7ac62915e072643ddfca1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d986ff50b4aad62c45d7ac62915e072643ddfca1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d986ff50b4aad62c45d7ac62915e072643ddfca1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d986ff50b4aad62c45d7ac62915e072643ddfca1/comments", "author": null, "committer": null, "parents": [{"sha": "a031bb7a585f789df2aed856a57646b8c45d0878", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a031bb7a585f789df2aed856a57646b8c45d0878", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a031bb7a585f789df2aed856a57646b8c45d0878"}], "stats": {"total": 78, "additions": 41, "deletions": 37}, "files": [{"sha": "fe31e9462aa6a25647e82a8411c77146a26ee141", "filename": "gcc/gimple-range-cache.cc", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range-cache.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range-cache.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.cc?ref=d986ff50b4aad62c45d7ac62915e072643ddfca1", "patch": "@@ -923,44 +923,45 @@ ranger_cache::dump_bb (FILE *f, basic_block bb)\n }\n \n // Get the global range for NAME, and return in R.  Return false if the\n-// global range is not set.\n+// global range is not set, and return the legacy global value in R.\n \n bool\n ranger_cache::get_global_range (irange &r, tree name) const\n {\n-  return m_globals.get_global_range (r, name);\n+  if (m_globals.get_global_range (r, name))\n+    return true;\n+  r = gimple_range_global (name);\n+  return false;\n }\n \n-// Get the global range for NAME, and return in R if the value is not stale.\n-// If the range is set, but is stale, mark it current and return false.\n-// If it is not set pick up the legacy global value, mark it current, and\n-// return false.\n-// Note there is always a value returned in R. The return value indicates\n-// whether that value is an up-to-date calculated value or not..\n+// Get the global range for NAME, and return in R.  Return false if the\n+// global range is not set, and R will contain the legacy global value.\n+// CURRENT_P is set to true if the value was in cache and not stale.\n+// Otherwise, set CURRENT_P to false and mark as it always current.\n+// If the global cache did not have a value, initialize it as well.\n+// After this call, the global cache will have a value.\n \n bool\n-ranger_cache::get_non_stale_global_range (irange &r, tree name)\n+ranger_cache::get_global_range (irange &r, tree name, bool &current_p)\n {\n-  if (m_globals.get_global_range (r, name))\n-    {\n-      // Use this value if the range is constant or current.\n-      if (r.singleton_p ()\n-\t  || m_temporal->current_p (name, m_gori.depend1 (name),\n-\t\t\t\t    m_gori.depend2 (name)))\n-\treturn true;\n-    }\n+  bool had_global = get_global_range (r, name);\n+\n+  // If there was a global value, set current flag, otherwise set a value.\n+  current_p = false;\n+  if (had_global)\n+    current_p = r.singleton_p ()\n+\t\t|| m_temporal->current_p (name, m_gori.depend1 (name),\n+\t\t\t\t\t  m_gori.depend2 (name));\n   else\n-    {\n-      // Global has never been accessed, so pickup the legacy global value.\n-      r = gimple_range_global (name);\n-      m_globals.set_global_range (name, r);\n-    }\n-  // After a stale check failure, mark the value as always current until a\n-  // new one is set.\n-  m_temporal->set_always_current (name);\n-  return false;\n+    m_globals.set_global_range (name, r);\n+\n+  // If the existing value was not current, mark it as always current.\n+  if (!current_p)\n+    m_temporal->set_always_current (name);\n+  return current_p;\n }\n-//  Set the global range of NAME to R.\n+\n+//  Set the global range of NAME to R and give it a timestamp.\n \n void\n ranger_cache::set_global_range (tree name, const irange &r)"}, {"sha": "eb7a875c46bddf2eaf16aa1b7b8353df2908febd", "filename": "gcc/gimple-range-cache.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range-cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range-cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-cache.h?ref=d986ff50b4aad62c45d7ac62915e072643ddfca1", "patch": "@@ -100,7 +100,7 @@ class ranger_cache : public range_query\n   bool block_range (irange &r, basic_block bb, tree name, bool calc = true);\n \n   bool get_global_range (irange &r, tree name) const;\n-  bool get_non_stale_global_range (irange &r, tree name);\n+  bool get_global_range (irange &r, tree name, bool &current_p);\n   void set_global_range (tree name, const irange &r);\n \n   void propagate_updated_value (tree name, basic_block bb);"}, {"sha": "e3ab3a8bb48fe164ba75a2f173a207a12b87100e", "filename": "gcc/gimple-range.cc", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d986ff50b4aad62c45d7ac62915e072643ddfca1/gcc%2Fgimple-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range.cc?ref=d986ff50b4aad62c45d7ac62915e072643ddfca1", "patch": "@@ -85,8 +85,7 @@ gimple_ranger::range_of_expr (irange &r, tree expr, gimple *stmt)\n   if (!stmt)\n     {\n       int_range_max tmp;\n-      if (!m_cache.get_global_range (r, expr))\n-        r = gimple_range_global (expr);\n+      m_cache.get_global_range (r, expr);\n       // Pick up implied context information from the on-entry cache\n       // if current_bb is set.  Do not attempt any new calculations.\n       if (current_bb && m_cache.block_range (tmp, current_bb, expr, false))\n@@ -282,15 +281,19 @@ gimple_ranger::range_of_stmt (irange &r, gimple *s, tree name)\n     }\n   else if (!gimple_range_ssa_p (name))\n     res = get_tree_range (r, name, NULL);\n-  // Check if the stmt has already been processed, and is not stale.\n-  else if (m_cache.get_non_stale_global_range (r, name))\n-    {\n-      if (idx)\n-\ttracer.trailer (idx, \" cached\", true, name, r);\n-      return true;\n-    }\n   else\n     {\n+      bool current;\n+      // Check if the stmt has already been processed, and is not stale.\n+      if (m_cache.get_global_range (r, name, current))\n+\t{\n+\t  if (current)\n+\t    {\n+\t      if (idx)\n+\t\ttracer.trailer (idx, \" cached\", true, name, r);\n+\t      return true;\n+\t    }\n+\t}\n       // Otherwise calculate a new value.\n       int_range_max tmp;\n       fold_range_internal (tmp, s, name);"}]}