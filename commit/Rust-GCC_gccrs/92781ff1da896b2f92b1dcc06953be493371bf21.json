{"sha": "92781ff1da896b2f92b1dcc06953be493371bf21", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTI3ODFmZjFkYTg5NmIyZjkyYjFkY2MwNjk1M2JlNDkzMzcxYmYyMQ==", "commit": {"author": {"name": "Michael Matz", "email": "matz@suse.de", "date": "2019-10-22T12:25:03Z"}, "committer": {"name": "Michael Matz", "email": "matz@gcc.gnu.org", "date": "2019-10-22T12:25:03Z"}, "message": "re PR middle-end/90796 (GCC: O2 vs O3 output differs on simple test)\n\nFix PR middle-end/90796\n\n        PR middle-end/90796\n        * gimple-loop-jam.c (any_access_function_variant_p): New function.\n        (adjust_unroll_factor): Use it to constrain safety, new parameter.\n        (tree_loop_unroll_and_jam): Adjust call and profitable unroll factor.\n\ntestsuite/\n        * gcc.dg/unroll-and-jam.c: Add three invalid and one valid case.\n\nFrom-SVN: r277287", "tree": {"sha": "dc1d1782a0e0eb5a953e17ec69cebac7ecb7c6d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dc1d1782a0e0eb5a953e17ec69cebac7ecb7c6d7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92781ff1da896b2f92b1dcc06953be493371bf21", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92781ff1da896b2f92b1dcc06953be493371bf21", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92781ff1da896b2f92b1dcc06953be493371bf21", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92781ff1da896b2f92b1dcc06953be493371bf21/comments", "author": {"login": "susematz", "id": 4117296, "node_id": "MDQ6VXNlcjQxMTcyOTY=", "avatar_url": "https://avatars.githubusercontent.com/u/4117296?v=4", "gravatar_id": "", "url": "https://api.github.com/users/susematz", "html_url": "https://github.com/susematz", "followers_url": "https://api.github.com/users/susematz/followers", "following_url": "https://api.github.com/users/susematz/following{/other_user}", "gists_url": "https://api.github.com/users/susematz/gists{/gist_id}", "starred_url": "https://api.github.com/users/susematz/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/susematz/subscriptions", "organizations_url": "https://api.github.com/users/susematz/orgs", "repos_url": "https://api.github.com/users/susematz/repos", "events_url": "https://api.github.com/users/susematz/events{/privacy}", "received_events_url": "https://api.github.com/users/susematz/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9107d6526b938eba8168025c0d90d06ad3634e69", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9107d6526b938eba8168025c0d90d06ad3634e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9107d6526b938eba8168025c0d90d06ad3634e69"}], "stats": {"total": 115, "additions": 104, "deletions": 11}, "files": [{"sha": "34ce686e1a0382bd986f29893d41042a88f68dd7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92781ff1da896b2f92b1dcc06953be493371bf21", "patch": "@@ -1,3 +1,10 @@\n+2019-10-22  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/90796\n+\t* gimple-loop-jam.c (any_access_function_variant_p): New function.\n+\t(adjust_unroll_factor): Use it to constrain safety, new parameter.\n+\t(tree_loop_unroll_and_jam): Adjust call and profitable unroll factor.\n+\n 2019-10-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92173"}, {"sha": "899653b0863475bd9f809bd5b7ec485c6b936ea0", "filename": "gcc/gimple-loop-jam.c", "status": "modified", "additions": 74, "deletions": 7, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Fgimple-loop-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Fgimple-loop-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.c?ref=92781ff1da896b2f92b1dcc06953be493371bf21", "patch": "@@ -360,16 +360,33 @@ fuse_loops (class loop *loop)\n   rewrite_into_loop_closed_ssa_1 (NULL, 0, SSA_OP_USE, loop);\n }\n \n+/* Return true if any of the access functions for dataref A\n+   isn't invariant with respect to loop LOOP_NEST.  */\n+static bool\n+any_access_function_variant_p (const struct data_reference *a,\n+\t\t\t       const class loop *loop_nest)\n+{\n+  unsigned int i;\n+  vec<tree> fns = DR_ACCESS_FNS (a);\n+  tree t;\n+\n+  FOR_EACH_VEC_ELT (fns, i, t)\n+    if (!evolution_function_is_invariant_p (t, loop_nest->num))\n+      return true;\n+\n+  return false;\n+}\n+\n /* Returns true if the distance in DDR can be determined and adjusts\n    the unroll factor in *UNROLL to make unrolling valid for that distance.\n-   Otherwise return false.\n+   Otherwise return false.  DDR is with respect to the outer loop of INNER.\n \n    If this data dep can lead to a removed memory reference, increment\n    *REMOVED and adjust *PROFIT_UNROLL to be the necessary unroll factor\n    for this to happen.  */\n \n static bool\n-adjust_unroll_factor (struct data_dependence_relation *ddr,\n+adjust_unroll_factor (class loop *inner, struct data_dependence_relation *ddr,\n \t\t      unsigned *unroll, unsigned *profit_unroll,\n \t\t      unsigned *removed)\n {\n@@ -392,9 +409,59 @@ adjust_unroll_factor (struct data_dependence_relation *ddr,\n \t    gcc_unreachable ();\n \t  else if ((unsigned)dist >= *unroll)\n \t    ;\n-\t  else if (lambda_vector_lexico_pos (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)\n-\t\t   || (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1)\n-\t\t       && dist > 0))\n+\t  else if (lambda_vector_zerop (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))\n+\t    {\n+\t      /* We have (a,0) with a < N, so this will be transformed into\n+\t         (0,0) after unrolling by N.  This might potentially be a\n+\t\t problem, if it's not a read-read dependency.  */\n+\t      if (DR_IS_READ (DDR_A (ddr)) && DR_IS_READ (DDR_B (ddr)))\n+\t\t;\n+\t      else\n+\t\t{\n+\t\t  /* So, at least one is a write, and we might reduce the\n+\t\t     distance vector to (0,0).  This is still no problem\n+\t\t     if both data-refs are affine with respect to the inner\n+\t\t     loops.  But if one of them is invariant with respect\n+\t\t     to an inner loop our reordering implicit in loop fusion\n+\t\t     corrupts the program, as our data dependences don't\n+\t\t     capture this.  E.g. for:\n+\t\t       for (0 <= i < n)\n+\t\t         for (0 <= j < m)\n+\t\t           a[i][0] = a[i+1][0] + 2;    // (1)\n+\t\t           b[i][j] = b[i+1][j] + 2;    // (2)\n+\t\t     the distance vector for both statements is (-1,0),\n+\t\t     but exchanging the order for (2) is okay, while\n+\t\t     for (1) it is not.  To see this, write out the original\n+\t\t     accesses (assume m is 2):\n+\t\t       a i j original\n+\t\t       0 0 0 r a[1][0] b[1][0]\n+\t\t       1 0 0 w a[0][0] b[0][0]\n+\t\t       2 0 1 r a[1][0] b[1][1]\n+\t\t       3 0 1 w a[0][0] b[0][1]\n+\t\t       4 1 0 r a[2][0] b[2][0]\n+\t\t       5 1 0 w a[1][0] b[1][0]\n+\t\t     after unroll-by-2 and fusion the accesses are done in\n+\t\t     this order (from column a): 0,1, 4,5, 2,3, i.e. this:\n+\t\t       a i j transformed\n+\t\t       0 0 0 r a[1][0] b[1][0]\n+\t\t       1 0 0 w a[0][0] b[0][0]\n+\t\t       4 1 0 r a[2][0] b[2][0]\n+\t\t       5 1 0 w a[1][0] b[1][0]\n+\t\t       2 0 1 r a[1][0] b[1][1]  \n+\t\t       3 0 1 w a[0][0] b[0][1]\n+\t\t     Note how access 2 accesses the same element as access 5\n+\t\t     for array 'a' but not for array 'b'.  */\n+\t\t  if (any_access_function_variant_p (DDR_A (ddr), inner)\n+\t\t      && any_access_function_variant_p (DDR_B (ddr), inner))\n+\t\t    ;\n+\t\t  else\n+\t\t    /* And if any dataref of this pair is invariant with\n+\t\t       respect to the inner loop, we have no chance than\n+\t\t       to reduce the unroll factor.  */\n+\t\t    *unroll = dist;\n+\t\t}\n+\t    }\n+\t  else if (lambda_vector_lexico_pos (dist_v + 1, DDR_NB_LOOPS (ddr) - 1))\n \t    ;\n \t  else\n \t    *unroll = dist;\n@@ -486,7 +553,7 @@ tree_loop_unroll_and_jam (void)\n \t  /* Now check the distance vector, for determining a sensible\n \t     outer unroll factor, and for validity of merging the inner\n \t     loop copies.  */\n-\t  if (!adjust_unroll_factor (ddr, &unroll_factor, &profit_unroll,\n+\t  if (!adjust_unroll_factor (loop, ddr, &unroll_factor, &profit_unroll,\n \t\t\t\t     &removed))\n \t    {\n \t      /* Couldn't get the distance vector.  For two reads that's\n@@ -506,7 +573,7 @@ tree_loop_unroll_and_jam (void)\n \t to ignore all profitability concerns and apply the transformation\n \t always.  */\n       if (!PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n-\tprofit_unroll = 2;\n+\tprofit_unroll = MAX(2, profit_unroll);\n       else if (removed * 100 / datarefs.length ()\n \t  < (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n \tprofit_unroll = 1;"}, {"sha": "9caf60787d4dab9152d039c9fe85ac0177c6b361", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92781ff1da896b2f92b1dcc06953be493371bf21", "patch": "@@ -1,3 +1,8 @@\n+2019-10-22  Michael Matz  <matz@suse.de>\n+\n+\tPR middle-end/90796\n+\t* gcc.dg/unroll-and-jam.c: Add three invalid and one valid case.\n+\n 2019-10-22  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/92173"}, {"sha": "bcfe1bda9b0b9cc242dde43210199f87218b3a08", "filename": "gcc/testsuite/gcc.dg/unroll-and-jam.c", "status": "modified", "additions": 18, "deletions": 4, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92781ff1da896b2f92b1dcc06953be493371bf21/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Funroll-and-jam.c?ref=92781ff1da896b2f92b1dcc06953be493371bf21", "patch": "@@ -31,10 +31,10 @@ void checkb(void)\n   //printf(\"  %d\\n\", sum);\n }\n \n+unsigned i, j;\n #define TEST(name, body, test) \\\n static void __attribute__((noinline,noclone)) name (unsigned long n, unsigned long m) \\\n { \\\n-  unsigned long i, j; \\\n   for (i = 1; i < m; i++) { \\\n       for (j = 1; j < n; j++) { \\\n \t  body; \\\n@@ -58,16 +58,22 @@ TEST(foo3, aa[i+1][j-1]=aa[i][j] * aa[i][j] / 2, checkaa()) //notok, -1,1\n TEST(foo4, aa[i][j] = aa[i-1][j+1] * aa[i-1][j+1] / 2, checkaa()) //notok, -1,1\n TEST(foo5, aa[i][j] = aa[i+1][j+1] * aa[i+1][j+1] / 2, checkaa()) //ok, 1,1\n TEST(foo6, aa[i][j] = aa[i+1][j] * aa[i+1][j] / 2, checkaa()) //ok, -1,0\n+TEST(foo61, aa[i][0] = aa[i+1][0] * aa[i+1][0] / 2, checkaa()) //notok, -1,0\n+TEST(foo62, aa[i][j/2] = aa[i+1][j/2] * aa[i+1][j/2] / 2, checkaa()) //notok, not affine\n+TEST(foo63, aa[i][j%2] = aa[i+1][j%2] * aa[i+1][j%2] / 2, checkaa()) //notok, not affine\n TEST(foo7, aa[i+1][j] = aa[i][j] * aa[i][j] / 2, checkaa()) //ok, 1,0\n TEST(foo9, b[j] = 3*b[j+1] + 1, checkb()) //notok, 0,-1\n TEST(foo10, b[j] = 3*b[j] + 1, checkb()) //ok, 0,0\n+extern int f;\n+TEST(foo11, f = b[i-1] = 1 + 3* b[i+1], checkb()) //ok, 2,0 but must reduce unroll factor to 2, (it would be incorrect with unroll-by-3, which the profitability would suggest)\n \n /* foo8 should work as well, but currently doesn't because the distance\n    vectors we compute are too pessimistic.  We compute\n      (0,1), (1,1) and (1,-1) \n    and the last one causes us to lose.  */\n TEST(foo8, b[j+1] = 3*b[j] + 1, checkb()) //ok, 0,1\n \n+int f;\n unsigned int a[1024];\n unsigned int b[1024];\n unsigned int aa[16][1024];\n@@ -88,10 +94,12 @@ void init(void)\n     printf(\" %s\\n\", #name); \\\n     init();for(i=0;i<4;i++)name##noopt(32,8); checka = checksum; \\\n     init();for(i=0;i<4;i++)name(32,8); \\\n+    if (checka != checksum) fail = 1; \\\n     printf(\"%sok %s\\n\", checka != checksum ? \"NOT \" : \"\", #name);\n \n int main()\n {\n+  int fail = 0;\n   int i;\n   unsigned checka;\n   RUN(foo1);\n@@ -100,12 +108,18 @@ int main()\n   RUN(foo4);\n   RUN(foo5);\n   RUN(foo6);\n+  RUN(foo61);\n+  RUN(foo62);\n+  RUN(foo63);\n   RUN(foo7);\n   RUN(foo8);\n   RUN(foo9);\n   RUN(foo10);\n-  return 0;\n+  RUN(foo11);\n+  if (fail)\n+    __builtin_abort();\n+  return fail;\n }\n \n-/* Five loops should be unroll-jammed (actually six, but see above).  */\n-/* { dg-final { scan-tree-dump-times \"applying unroll and jam\" 5 \"unrolljam\" } } */\n+/* Six loops should be unroll-jammed (actually seven, but see above).  */\n+/* { dg-final { scan-tree-dump-times \"applying unroll and jam\" 6 \"unrolljam\" } } */"}]}