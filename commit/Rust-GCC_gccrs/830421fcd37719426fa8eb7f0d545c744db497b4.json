{"sha": "830421fcd37719426fa8eb7f0d545c744db497b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODMwNDIxZmNkMzc3MTk0MjZmYThlYjdmMGQ1NDVjNzQ0ZGI0OTdiNA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2018-01-03T20:37:41Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2018-01-03T20:37:41Z"}, "message": "re PR c++/83555 (Unnecessary null check when static_cast is used with references.)\n\n\tPR c++/83555\n\t* typeck.c (build_static_cast_1): For static casts to reference types,\n\tcall build_base_path with flag_delete_null_pointer_checks as nonnull\n\tinstead of always false.  When -fsanitize=null, call\n\tubsan_maybe_instrument_reference on the NULL reference INTEGER_CST.\n\t* cp-gimplify.c (cp_genericize_r): Don't walk subtrees of UBSAN_NULL\n\tcall if the first argument is INTEGER_CST with REFERENCE_TYPE.\n\n\t* g++.dg/opt/pr83555.C: New test.\n\t* g++.dg/ubsan/pr83555.C: New test.\n\nFrom-SVN: r256186", "tree": {"sha": "4caa4cc0a2b0794c69cc3be5c592273f1dbcc26b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4caa4cc0a2b0794c69cc3be5c592273f1dbcc26b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/830421fcd37719426fa8eb7f0d545c744db497b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830421fcd37719426fa8eb7f0d545c744db497b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/830421fcd37719426fa8eb7f0d545c744db497b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/830421fcd37719426fa8eb7f0d545c744db497b4/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bdbeed1d0b00bc21a105712b1b672ebec37358e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bdbeed1d0b00bc21a105712b1b672ebec37358e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bdbeed1d0b00bc21a105712b1b672ebec37358e"}], "stats": {"total": 97, "additions": 94, "deletions": 3}, "files": [{"sha": "959f412ebf39fd1eb68865b57950d4d516843aac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -1,3 +1,13 @@\n+2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83555\n+\t* typeck.c (build_static_cast_1): For static casts to reference types,\n+\tcall build_base_path with flag_delete_null_pointer_checks as nonnull\n+\tinstead of always false.  When -fsanitize=null, call\n+\tubsan_maybe_instrument_reference on the NULL reference INTEGER_CST.\n+\t* cp-gimplify.c (cp_genericize_r): Don't walk subtrees of UBSAN_NULL\n+\tcall if the first argument is INTEGER_CST with REFERENCE_TYPE.\n+\n 2018-01-03  Nathan Sidwell  <nathan@acm.org>\n \n \tPR c++/83667"}, {"sha": "eda493a7bec11c922ef38dda2a7ba20647bc122e", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -1506,6 +1506,12 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t      if (sanitize_flags_p (SANITIZE_VPTR) && !is_ctor)\n \t\tcp_ubsan_maybe_instrument_member_call (stmt);\n \t    }\n+\t  else if (fn == NULL_TREE\n+\t\t   && CALL_EXPR_IFN (stmt) == IFN_UBSAN_NULL\n+\t\t   && TREE_CODE (CALL_EXPR_ARG (stmt, 0)) == INTEGER_CST\n+\t\t   && (TREE_CODE (TREE_TYPE (CALL_EXPR_ARG (stmt, 0)))\n+\t\t       == REFERENCE_TYPE))\n+\t    *walk_subtrees = 0;\n \t}\n       break;\n "}, {"sha": "76fd9302edfc4c510e97878d675105530fdd4887", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 17, "deletions": 3, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -6943,8 +6943,11 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \t}\n \n       /* Convert from \"B*\" to \"D*\".  This function will check that \"B\"\n-\t is not a virtual base of \"D\".  */\n-      expr = build_base_path (MINUS_EXPR, expr, base, /*nonnull=*/false,\n+\t is not a virtual base of \"D\".  Even if we don't have a guarantee\n+\t that expr is NULL, if the static_cast is to a reference type,\n+\t it is UB if it would be NULL, so omit the non-NULL check.  */\n+      expr = build_base_path (MINUS_EXPR, expr, base,\n+\t\t\t      /*nonnull=*/flag_delete_null_pointer_checks,\n \t\t\t      complain);\n \n       /* Convert the pointer to a reference -- but then remember that\n@@ -6955,7 +6958,18 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n          is a variable with the same type, the conversion would get folded\n          away, leaving just the variable and causing lvalue_kind to give\n          the wrong answer.  */\n-      return convert_from_reference (rvalue (cp_fold_convert (type, expr)));\n+      expr = cp_fold_convert (type, expr);\n+\n+      /* When -fsanitize=null, make sure to diagnose reference binding to\n+\t NULL even when the reference is converted to pointer later on.  */\n+      if (sanitize_flags_p (SANITIZE_NULL)\n+\t  && TREE_CODE (expr) == COND_EXPR\n+\t  && TREE_OPERAND (expr, 2)\n+\t  && TREE_CODE (TREE_OPERAND (expr, 2)) == INTEGER_CST\n+\t  && TREE_TYPE (TREE_OPERAND (expr, 2)) == type)\n+\tubsan_maybe_instrument_reference (&TREE_OPERAND (expr, 2));\n+\n+      return convert_from_reference (rvalue (expr));\n     }\n \n   /* \"A glvalue of type cv1 T1 can be cast to type rvalue reference to"}, {"sha": "7c4e6e9a3495631751b248074e5dc5984d0119df", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -1,3 +1,9 @@\n+2018-01-03  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/83555\n+\t* g++.dg/opt/pr83555.C: New test.\n+\t* g++.dg/ubsan/pr83555.C: New test.\n+\n 2018-01-03  David Malcolm  <dmalcolm@redhat.com>\n \n \tPR c/82050"}, {"sha": "c6f810d1f00c73433207c46a162ea74e73821351", "filename": "gcc/testsuite/g++.dg/opt/pr83555.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83555.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83555.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fpr83555.C?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -0,0 +1,15 @@\n+// PR c++/83555\n+// { dg-do compile }\n+// { dg-options \"-O2 -fdump-tree-optimized -fdelete-null-pointer-checks\" }\n+\n+struct A { int a; };\n+struct B { int b; };\n+struct C : A, B { int c; };\n+\n+C *\n+foo (B *b)\n+{\n+  return &static_cast<C &>(*b);\n+}\n+\n+// { dg-final { scan-tree-dump-not \"if \\\\(b_\\[0-9]*\\\\(D\\\\) .= 0\" \"optimized\" } }"}, {"sha": "6574923740c6dae76c908c8f750ca4d7d99e8180", "filename": "gcc/testsuite/g++.dg/ubsan/pr83555.C", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr83555.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/830421fcd37719426fa8eb7f0d545c744db497b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr83555.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fpr83555.C?ref=830421fcd37719426fa8eb7f0d545c744db497b4", "patch": "@@ -0,0 +1,40 @@\n+// PR c++/83555\n+// { dg-do run }\n+// { dg-options \"-fsanitize=null\" }\n+// { dg-output \":25:\\[^\\n\\r]*reference binding to null pointer of type 'struct C'\" }\n+\n+struct A { int a; };\n+struct B { int b; };\n+struct C : A, B { int c; };\n+\n+__attribute__((noipa)) C *\n+foo (B *b)\n+{\n+  return static_cast<C *>(b);\n+}\n+\n+__attribute__((noipa)) C *\n+bar (B *b)\n+{\n+  return &static_cast<C &>(*b);\n+}\n+\n+__attribute__((noipa)) C *\n+baz (B *b)\n+{\n+  return &static_cast<C &>(*b);\n+}\n+\n+int\n+main ()\n+{\n+  C c;\n+  if (foo (static_cast<B *> (&c)) != &c)\n+    __builtin_abort ();\n+  if (foo (0))\n+    __builtin_abort ();\n+  if (bar (static_cast<B *> (&c)) != &c)\n+    __builtin_abort ();\n+  baz (0);\n+  return 0;\n+}"}]}