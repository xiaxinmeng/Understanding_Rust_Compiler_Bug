{"sha": "b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjI4ZWFkNDVmZTYzMGI5ZTAxOGE4MWNiNDZiN2UxZjk3MWU0ZGMxNw==", "commit": {"author": {"name": "Alan Hayward", "email": "alan.hayward@arm.com", "date": "2016-06-03T13:00:06Z"}, "committer": {"name": "Alan Hayward", "email": "alahay01@gcc.gnu.org", "date": "2016-06-03T13:00:06Z"}, "message": "[2/3] Vectorize inductions that are live after the loop\n\n2016-06-03  Alan Hayward  <alan.hayward@arm.com>\n\n[2/3] Vectorize inductions that are live after the loop\n\ngcc/\n\t* tree-vect-loop.c (vect_analyze_loop_operations): Allow live stmts.\n\t(vectorizable_reduction): Check for new relevant state.\n\t(vectorizable_live_operation): vectorize live stmts using\n\tBIT_FIELD_REF.  Remove special case for gimple assigns stmts.\n\t* tree-vect-stmts.c (is_simple_and_all_uses_invariant): New function.\n\t(vect_stmt_relevant_p): Check for stmts which are only used live.\n\t(process_use): Use of a stmt does not inherit it's live value.\n\t(vect_mark_stmts_to_be_vectorized): Simplify relevance inheritance.\n\t(vect_analyze_stmt): Check for new relevant state.\n\t* tree-vectorizer.h (vect_relevant): New entry for a stmt which is used\n\toutside the loop, but not inside it.\n\ntestsuite/\n\t* gcc.dg/tree-ssa/pr64183.c: Ensure test does not vectorize.\n\t* testsuite/gcc.dg/vect/no-scevccp-vect-iv-2.c: Remove xfail.\n\t* gcc.dg/vect/vect-live-1.c: New test.\n\t* gcc.dg/vect/vect-live-2.c: New test.\n\t* gcc.dg/vect/vect-live-3.c: New test.\n\t* gcc.dg/vect/vect-live-4.c: New test.\n\t* gcc.dg/vect/vect-live-5.c: New test.\n\t* gcc.dg/vect/vect-live-slp-1.c: New test.\n\t* gcc.dg/vect/vect-live-slp-2.c: New test.\n\t* gcc.dg/vect/vect-live-slp-3.c: New test.\n\nFrom-SVN: r237064", "tree": {"sha": "8158807035672c6080932262ccede47287be36b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8158807035672c6080932262ccede47287be36b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/comments", "author": {"login": "a74nh", "id": 4146708, "node_id": "MDQ6VXNlcjQxNDY3MDg=", "avatar_url": "https://avatars.githubusercontent.com/u/4146708?v=4", "gravatar_id": "", "url": "https://api.github.com/users/a74nh", "html_url": "https://github.com/a74nh", "followers_url": "https://api.github.com/users/a74nh/followers", "following_url": "https://api.github.com/users/a74nh/following{/other_user}", "gists_url": "https://api.github.com/users/a74nh/gists{/gist_id}", "starred_url": "https://api.github.com/users/a74nh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/a74nh/subscriptions", "organizations_url": "https://api.github.com/users/a74nh/orgs", "repos_url": "https://api.github.com/users/a74nh/repos", "events_url": "https://api.github.com/users/a74nh/events{/privacy}", "received_events_url": "https://api.github.com/users/a74nh/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "c83a894c1e437a1653fc38b537d3bb98a91e5631", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c83a894c1e437a1653fc38b537d3bb98a91e5631", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c83a894c1e437a1653fc38b537d3bb98a91e5631"}], "stats": {"total": 805, "additions": 678, "deletions": 127}, "files": [{"sha": "a7476c64d5a697fa72419fc5bd39c42ca3182174", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -1,3 +1,17 @@\n+2016-06-03  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* tree-vect-loop.c (vect_analyze_loop_operations): Allow live stmts.\n+\t(vectorizable_reduction): Check for new relevant state.\n+\t(vectorizable_live_operation): vectorize live stmts using\n+\tBIT_FIELD_REF.  Remove special case for gimple assigns stmts.\n+\t* tree-vect-stmts.c (is_simple_and_all_uses_invariant): New function.\n+\t(vect_stmt_relevant_p): Check for stmts which are only used live.\n+\t(process_use): Use of a stmt does not inherit it's live value.\n+\t(vect_mark_stmts_to_be_vectorized): Simplify relevance inheritance.\n+\t(vect_analyze_stmt): Check for new relevant state.\n+\t* tree-vectorizer.h (vect_relevant): New entry for a stmt which is used\n+\toutside the loop, but not inside it.\n+\n 2016-06-03  Alan Hayward  <alan.hayward@arm.com>\n \n \t* tree-vectorizer.h (vect_get_vec_def_for_operand_1): New"}, {"sha": "0c976b67901fce56b341b6dc85eedbe336c2910f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -1,3 +1,16 @@\n+2016-06-03  Alan Hayward  <alan.hayward@arm.com>\n+\n+\t* gcc.dg/tree-ssa/pr64183.c: Ensure test does not vectorize.\n+\t* testsuite/gcc.dg/vect/no-scevccp-vect-iv-2.c: Remove xfail.\n+\t* gcc.dg/vect/vect-live-1.c: New test.\n+\t* gcc.dg/vect/vect-live-2.c: New test.\n+\t* gcc.dg/vect/vect-live-3.c: New test.\n+\t* gcc.dg/vect/vect-live-4.c: New test.\n+\t* gcc.dg/vect/vect-live-5.c: New test.\n+\t* gcc.dg/vect/vect-live-slp-1.c: New test.\n+\t* gcc.dg/vect/vect-live-slp-2.c: New test.\n+\t* gcc.dg/vect/vect-live-slp-3.c: New test.\n+\n 2016-06-03  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR middle-end/71387"}, {"sha": "8a3fadc7602a815567515a096adf8ede0c8d7a41", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr64183.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64183.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64183.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr64183.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O3 -fdump-tree-cunroll-details\" } */\n+/* { dg-options \"-O3 -fno-tree-vectorize -fdump-tree-cunroll-details\" } */\n \n int bits;\n unsigned int size;"}, {"sha": "131d2d9e03f44ed680cb49c71673908511c9236f", "filename": "gcc/testsuite/gcc.dg/vect/no-scevccp-vect-iv-2.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-vect-iv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-vect-iv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fno-scevccp-vect-iv-2.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -12,9 +12,7 @@ int main1 ()\n   int k = 0;\n   int m = 3, i = 0;\n   \n-  /* Vectorization of induction that is used after the loop.  \n-     Currently vectorizable because scev_ccp disconnects the\n-     use-after-the-loop from the iv def inside the loop.  */\n+  /* Vectorization of induction that is used after the loop.  */\n \n    do { \n         k = k + 2;\n@@ -46,4 +44,4 @@ int main (void)\n   return 0;\n } \n \n-/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { xfail *-*-* } } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */"}, {"sha": "3f3a44f8bfb6c43436bede039d406da7af7e6857", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-1.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-1.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+__attribute__ ((noinline)) int\n+liveloop (int start, int n, int *x)\n+{\n+  int i = start;\n+  int j;\n+\n+  for (j = 0; j < n; ++j)\n+    {\n+      i += 1;\n+      x[j] = i;\n+    }\n+  return i;\n+}\n+\n+#define MAX 62\n+#define START 27\n+\n+int\n+main (void)\n+{\n+  int a[MAX];\n+  int i;\n+\n+  int ret = liveloop (START, MAX, a);\n+\n+  if (ret != MAX + START)\n+    abort ();\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      if (a[i] != i+START+1)\n+\tabort ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 1 \"vect\" } } */"}, {"sha": "523241cdee4243265c3a2d928764b7f259034831", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-2.c", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-2.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,55 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+__attribute__ ((noinline)) int\n+liveloop (int start, int n, int *x, int *y)\n+{\n+  int i = start;\n+  int j;\n+  int ret;\n+\n+  for (j = 0; j < n; ++j)\n+    {\n+      i += 1;\n+      x[j] = i;\n+      ret = y[j];\n+    }\n+  return ret;\n+}\n+\n+#define MAX 97\n+#define START 13\n+\n+int\n+main (void)\n+{\n+  int a[MAX];\n+  int b[MAX];\n+  int i;\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      b[i] = i;\n+    }\n+\n+  int ret = liveloop (START, MAX, a, b);\n+\n+  if (ret != MAX - 1)\n+    abort ();\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      if (a[i] != i+START+1)\n+\tabort ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 1 \"vect\" } } */"}, {"sha": "404eac502be6d578d88231644b55b65e0b4f20da", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-3.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-3.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Two Statements used outside the loop.  SCEV cannot hoist the stmt.  */\n+__attribute__ ((noinline)) int\n+liveloop (int start, int n, int *x, int *y)\n+{\n+  int i = start;\n+  int j;\n+  int ret;\n+\n+  for (j = 0; j < n; ++j)\n+    {\n+      ret = x[j] + y[j];\n+      i += 1;\n+      x[j] = i;\n+    }\n+  return ret;\n+}\n+\n+#define MAX 173\n+#define START 7\n+\n+int\n+main (void)\n+{\n+  int a[MAX];\n+  int b[MAX];\n+  int i;\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      a[i] = i;\n+      b[i] = i * 2;\n+    }\n+\n+  int ret = liveloop (START, MAX, a, b);\n+\n+  if (ret != (MAX - 1) * 3)\n+    abort ();\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      if (a[i] != i+START+1)\n+\tabort ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 2 \"vect\" } } */"}, {"sha": "1b9690089aff841b344ad3bb62233a39e3d89763", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-4.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-4.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement used outside the loop, not used inside the loop.  SCEV cannot\n+  hoist the stmt.  */\n+__attribute__ ((noinline)) int\n+liveloop (int n, int *x, int *y)\n+{\n+  int i;\n+  int ret;\n+\n+  for (i = 0; i < n; ++i)\n+    {\n+      ret = x[i] + 5;\n+      y[i] = ret;\n+    }\n+  return ret;\n+}\n+\n+#define MAX 273\n+\n+int\n+main (void)\n+{\n+  int a[MAX];\n+  int b[MAX];\n+  int i;\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      a[i] = i;\n+    }\n+\n+  int ret = liveloop (MAX, a, b);\n+\n+  if (ret != MAX + 4)\n+    abort ();\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      if (b[i] != i+5)\n+\tabort ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 1 \"vect\" } } */"}, {"sha": "f475ca822b18874c5beca7465ae2094281644d96", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-5.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-5.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement that is simple and invariant used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+__attribute__ ((noinline)) int\n+liveloop (int start, int n, int *x, int *y)\n+{\n+  int i = start;\n+  int j;\n+  int ret;\n+\n+  for (j = 0; j < n; ++j)\n+    {\n+      i += 1;\n+      ret = y[0];\n+      x[j] = i + ret;\n+    }\n+  return ret;\n+}\n+\n+#define MAX 77\n+#define START 37\n+\n+int\n+main (void)\n+{\n+  int a[MAX];\n+  int b = 99;\n+  int i;\n+\n+  int ret = liveloop (START, MAX, a, &b);\n+\n+  if (ret != 99)\n+    abort ();\n+\n+  for (i=0; i<MAX; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      if (a[i] != i+START+100)\n+\tabort ();\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 1 \"vect\" } } */\n+/* { dg-final { scan-tree-dump \"statement is simple and uses invariant.  Leaving in place\" \"vect\" } } */"}, {"sha": "464930b09430364009efde53a3dd992c987b8b5d", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-slp-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-1.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,70 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement in SLP vectorization used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+#define LIVELOOP(RET) \\\n+__attribute__ ((noinline)) int \\\n+liveloop##RET (int n, int *x, int *y) \\\n+{ \\\n+  int n0, n1, n2, n3, j; \\\n+  for (j = 0; j < n; ++j) \\\n+    { \\\n+      n0 = x[(j*4)]; \\\n+      n1 = x[(j*4)+1]; \\\n+      n2 = x[(j*4)+2]; \\\n+      n3 = x[(j*4)+3]; \\\n+      y[(j*4)] = n0 + 1; \\\n+      y[(j*4)+1] = n1 + 2; \\\n+      y[(j*4)+2] = n2 + 3; \\\n+      y[(j*4)+3] = n3 + 4; \\\n+    } \\\n+  return n##RET; \\\n+}\n+\n+LIVELOOP (0)\n+LIVELOOP (1)\n+LIVELOOP (2)\n+LIVELOOP (3)\n+typedef int (*FP)(int n, int *x, int *y);\n+const FP llf[]= {&liveloop0, &liveloop1, &liveloop2, &liveloop3};\n+\n+#define MAX 113\n+\n+int\n+main (void)\n+{\n+  int a[MAX*4];\n+  int b[MAX*4];\n+  int i;\n+\n+  for (i=0; i<MAX*4; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      a[i] = i;\n+    }\n+\n+  for (i=0; i<4; i++)\n+    {\n+      __asm__ volatile (\"\");\n+\n+      int ret = llf[i] (MAX, a, b);\n+\n+      if (ret != (MAX * 4) - 4 + i)\n+\tabort ();\n+\n+      for (i=0; i<MAX*4; i++)\n+\t{\n+\t  __asm__ volatile (\"\");\n+\t  if (b[i] != i + (i%4) + 1)\n+\t    abort ();\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 4 \"vect\" } } */"}, {"sha": "86f43c174689fbe79e80502a8db81e3ebb90c057", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-slp-2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-2.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement in SLP vectorization used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+#define LIVELOOP(RET) \\\n+__attribute__ ((noinline)) int \\\n+liveloop##RET (int n, int *x, int *y) \\\n+{ \\\n+  int n0, n1, j; \\\n+  for (j = 0; j < n; ++j) \\\n+    { \\\n+      n0 = x[(j*2)]; \\\n+      n1 = x[(j*2)+1]; \\\n+      y[(j*2)] = n0 + 1; \\\n+      y[(j*2)+1] = n1 + 2; \\\n+    } \\\n+  return n##RET; \\\n+}\n+\n+LIVELOOP (0)\n+LIVELOOP (1)\n+typedef int (*FP)(int n, int *x, int *y);\n+const FP llf[]= {&liveloop0, &liveloop1};\n+\n+#define MAX 137\n+\n+int\n+main (void)\n+{\n+  int a[MAX*4];\n+  int b[MAX*4];\n+  int i;\n+\n+  for (i=0; i<MAX*2; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      a[i] = i;\n+    }\n+\n+  for (i=0; i<2; i++)\n+    {\n+      __asm__ volatile (\"\");\n+\n+      int ret = llf[i] (MAX, a, b);\n+\n+      if (ret != (MAX * 2) - 2 + i)\n+\tabort ();\n+\n+      for (i=0; i<MAX*2; i++)\n+\t{\n+\t  __asm__ volatile (\"\");\n+\t  if (b[i] != i + (i%2) + 1)\n+\t    abort ();\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 2 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 2 \"vect\" } } */"}, {"sha": "57ff2e855ae356838d639936e850684856504ab2", "filename": "gcc/testsuite/gcc.dg/vect/vect-live-slp-3.c", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-live-slp-3.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -0,0 +1,71 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-tree-scev-cprop -fdump-tree-vect-details\" } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Statement in SLP vectorization used outside the loop.\n+   NOTE: SCEV disabled to ensure the live operation is not removed before\n+   vectorization.  */\n+#define LIVELOOP(RET) \\\n+__attribute__ ((noinline)) long \\\n+liveloop##RET (int n, long *x, long *y) \\\n+{ \\\n+  long n0, n1, n2, n3; \\\n+  int j; \\\n+  for (j = 0; j < n; ++j) \\\n+    { \\\n+      n0 = x[(j*4)]; \\\n+      n1 = x[(j*4)+1]; \\\n+      n2 = x[(j*4)+2]; \\\n+      n3 = x[(j*4)+3]; \\\n+      y[(j*4)] = n0 + 1; \\\n+      y[(j*4)+1] = n1 + 2; \\\n+      y[(j*4)+2] = n2 + 3; \\\n+      y[(j*4)+3] = n3 + 4; \\\n+    } \\\n+  return n##RET; \\\n+}\n+\n+LIVELOOP (0)\n+LIVELOOP (1)\n+LIVELOOP (2)\n+LIVELOOP (3)\n+typedef long (*FP)(int n, long *x, long *y);\n+const FP llf[]= {&liveloop0, &liveloop1, &liveloop2, &liveloop3};\n+\n+#define MAX 153\n+\n+int\n+main (void)\n+{\n+  long a[MAX*4];\n+  long b[MAX*4];\n+  int i;\n+\n+  for (i=0; i<MAX*4; i++)\n+    {\n+      __asm__ volatile (\"\");\n+      a[i] = i;\n+    }\n+\n+  for (i=0; i<4; i++)\n+    {\n+      __asm__ volatile (\"\");\n+\n+      int ret = llf[i] (MAX, a, b);\n+\n+      if (ret != (MAX * 4) - 4 + i)\n+\tabort ();\n+\n+      for (i=0; i<MAX*4; i++)\n+\t{\n+\t  __asm__ volatile (\"\");\n+\t  if (b[i] != i + (i%4) + 1)\n+\t    abort ();\n+\t}\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 4 \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vec_stmt_relevant_p: stmt live but not relevant\" 4 \"vect\" } } */"}, {"sha": "3cf1c795e69c94401f86c631f2172985e5ea80a8", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 91, "deletions": 66, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -47,6 +47,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-vectorizer.h\"\n #include \"gimple-fold.h\"\n #include \"cgraph.h\"\n+#include \"tree-cfg.h\"\n \n /* Loop Vectorization Pass.\n \n@@ -1679,15 +1680,6 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo)\n \n           gcc_assert (stmt_info);\n \n-          if (STMT_VINFO_LIVE_P (stmt_info))\n-            {\n-              /* FORNOW: not yet supported.  */\n-              if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: value used after loop.\\n\");\n-              return false;\n-            }\n-\n           if (STMT_VINFO_RELEVANT (stmt_info) == vect_used_in_scope\n               && STMT_VINFO_DEF_TYPE (stmt_info) != vect_induction_def)\n             {\n@@ -5933,7 +5925,7 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n    from the vectorized reduction operation generated in the previous iteration.\n   */\n \n-  if (STMT_VINFO_RELEVANT (stmt_info) == vect_unused_in_scope)\n+  if (STMT_VINFO_RELEVANT (stmt_info) <= vect_used_only_live)\n     {\n       single_defuse_cycle = true;\n       epilog_copies = 1;\n@@ -6329,84 +6321,117 @@ vectorizable_induction (gimple *phi,\n bool\n vectorizable_live_operation (gimple *stmt,\n \t\t\t     gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n+\t\t\t     slp_tree slp_node, int slp_index,\n \t\t\t     gimple **vec_stmt)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n-  tree op;\n-  gimple *def_stmt;\n-  ssa_op_iter iter;\n+  imm_use_iterator imm_iter;\n+  tree lhs, lhs_type, bitsize, vec_bitsize;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  int nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+  int ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+  gimple *use_stmt;\n+  auto_vec<tree> vec_oprnds;\n \n   gcc_assert (STMT_VINFO_LIVE_P (stmt_info));\n \n   if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_reduction_def)\n     return false;\n \n-  if (!is_gimple_assign (stmt))\n+  /* FORNOW.  CHECKME.  */\n+  if (nested_in_vect_loop_p (loop, stmt))\n+    return false;\n+\n+  /* If STMT is a simple assignment and its inputs are invariant, then it can\n+     remain in place, unvectorized.  The original last scalar value that it\n+     computes will be used.  */\n+  if (is_simple_and_all_uses_invariant (stmt, loop_vinfo))\n     {\n-      if (gimple_call_internal_p (stmt)\n-\t  && gimple_call_internal_fn (stmt) == IFN_GOMP_SIMD_LANE\n-\t  && gimple_call_lhs (stmt)\n-\t  && loop->simduid\n-\t  && TREE_CODE (gimple_call_arg (stmt, 0)) == SSA_NAME\n-\t  && loop->simduid\n-\t     == SSA_NAME_VAR (gimple_call_arg (stmt, 0)))\n-\t{\n-\t  edge e = single_exit (loop);\n-\t  basic_block merge_bb = e->dest;\n-\t  imm_use_iterator imm_iter;\n-\t  use_operand_p use_p;\n-\t  tree lhs = gimple_call_lhs (stmt);\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"statement is simple and uses invariant.  Leaving in \"\n+\t\t\t \"place.\\n\");\n+      return true;\n+    }\n \n-\t  FOR_EACH_IMM_USE_FAST (use_p, imm_iter, lhs)\n-\t    {\n-\t      gimple *use_stmt = USE_STMT (use_p);\n-\t      if (gimple_code (use_stmt) == GIMPLE_PHI\n-\t\t  && gimple_bb (use_stmt) == merge_bb)\n-\t\t{\n-\t\t  if (vec_stmt)\n-\t\t    {\n-\t\t      tree vfm1\n-\t\t\t= build_int_cst (unsigned_type_node,\n-\t\t\t\t\t loop_vinfo->vectorization_factor - 1);\n-\t\t      SET_PHI_ARG_DEF (use_stmt, e->dest_idx, vfm1);\n-\t\t    }\n-\t\t  return true;\n-\t\t}\n-\t    }\n-\t}\n+  if (!vec_stmt)\n+    /* No transformation required.  */\n+    return true;\n \n-      return false;\n-    }\n+  /* If stmt has a related stmt, then use that for getting the lhs.  */\n+  if (is_pattern_stmt_p (stmt_info))\n+    stmt = STMT_VINFO_RELATED_STMT (stmt_info);\n \n-  if (TREE_CODE (gimple_assign_lhs (stmt)) != SSA_NAME)\n-    return false;\n+  lhs = (is_a <gphi *> (stmt)) ? gimple_phi_result (stmt)\n+\t: gimple_get_lhs (stmt);\n+  lhs_type = TREE_TYPE (lhs);\n \n-  /* FORNOW. CHECKME. */\n-  if (nested_in_vect_loop_p (loop, stmt))\n-    return false;\n+  /* Find all uses of STMT outside the loop - there should be exactly one.  */\n+  auto_vec<gimple *, 4> worklist;\n+  FOR_EACH_IMM_USE_STMT (use_stmt, imm_iter, lhs)\n+    if (!flow_bb_inside_loop_p (loop, gimple_bb (use_stmt)))\n+\tworklist.safe_push (use_stmt);\n+  gcc_assert (worklist.length () == 1);\n+\n+  bitsize = TYPE_SIZE (lhs_type);\n+  vec_bitsize = TYPE_SIZE (vectype);\n \n-  /* FORNOW: support only if all uses are invariant.  This means\n-     that the scalar operations can remain in place, unvectorized.\n-     The original last scalar value that they compute will be used.  */\n-  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+  /* Get the vectorized lhs of STMT and the lane to use (counted in bits).  */\n+  tree vec_lhs, bitstart;\n+  if (slp_node)\n     {\n-      enum vect_def_type dt = vect_uninitialized_def;\n+      gcc_assert (slp_index >= 0);\n \n-      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt))\n-        {\n-          if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"use not simple.\\n\");\n-          return false;\n-        }\n+      int num_scalar = SLP_TREE_SCALAR_STMTS (slp_node).length ();\n+      int num_vec = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n+      int scalar_per_vec = num_scalar / num_vec;\n \n-      if (dt != vect_external_def && dt != vect_constant_def)\n-        return false;\n+      /* There are three possibilites here:\n+\t 1: All scalar stmts fit in a single vector.\n+\t 2: All scalar stmts fit multiple times into a single vector.\n+\t    We must choose the last occurence of stmt in the vector.\n+\t 3: Scalar stmts are split across multiple vectors.\n+\t    We must choose the correct vector and mod the lane accordingly.  */\n+\n+      /* Get the correct slp vectorized stmt.  */\n+      int vec_entry = slp_index / scalar_per_vec;\n+      vec_lhs = gimple_get_lhs (SLP_TREE_VEC_STMTS (slp_node)[vec_entry]);\n+\n+      /* Get entry to use.  */\n+      bitstart = build_int_cst (unsigned_type_node,\n+\t\t\t\tscalar_per_vec - (slp_index % scalar_per_vec));\n+      bitstart = int_const_binop (MULT_EXPR, bitsize, bitstart);\n+      bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitstart);\n+    }\n+  else\n+    {\n+      enum vect_def_type dt = STMT_VINFO_DEF_TYPE (stmt_info);\n+      vec_lhs = vect_get_vec_def_for_operand_1 (stmt, dt);\n+\n+      /* For multiple copies, get the last copy.  */\n+      for (int i = 1; i < ncopies; ++i)\n+\tvec_lhs = vect_get_vec_def_for_stmt_copy (vect_unknown_def_type,\n+\t\t\t\t\t\t  vec_lhs);\n+\n+      /* Get the last lane in the vector.  */\n+      bitstart = int_const_binop (MINUS_EXPR, vec_bitsize, bitsize);\n     }\n \n-  /* No transformation is required for the cases we currently support.  */\n+  /* Create a new vectorized stmt for the uses of STMT and insert outside the\n+     loop.  */\n+  tree new_name = make_ssa_name (lhs_type);\n+  tree new_tree = build3 (BIT_FIELD_REF, lhs_type, vec_lhs, bitsize, bitstart);\n+  gimple *new_stmt = gimple_build_assign (new_name, new_tree);\n+  gsi_insert_on_edge_immediate (single_exit (loop), new_stmt);\n+\n+  /* Replace all uses of the USE_STMT in the worklist with the newly inserted\n+     statement.  */\n+  use_stmt = worklist.pop ();\n+  replace_uses_by (gimple_phi_result (use_stmt), new_name);\n+  update_stmt (use_stmt);\n+\n   return true;\n }\n "}, {"sha": "5554fe8a46d9ab4539e42e3709216db155538c80", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 93, "deletions": 55, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -236,6 +236,38 @@ vect_mark_relevant (vec<gimple *> *worklist, gimple *stmt,\n }\n \n \n+/* Function is_simple_and_all_uses_invariant\n+\n+   Return true if STMT is simple and all uses of it are invariant.  */\n+\n+bool\n+is_simple_and_all_uses_invariant (gimple *stmt, loop_vec_info loop_vinfo)\n+{\n+  tree op;\n+  gimple *def_stmt;\n+  ssa_op_iter iter;\n+\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  FOR_EACH_SSA_TREE_OPERAND (op, stmt, iter, SSA_OP_USE)\n+    {\n+      enum vect_def_type dt = vect_uninitialized_def;\n+\n+      if (!vect_is_simple_use (op, loop_vinfo, &def_stmt, &dt))\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"use not simple.\\n\");\n+\t  return false;\n+\t}\n+\n+      if (dt != vect_external_def && dt != vect_constant_def)\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* Function vect_stmt_relevant_p.\n \n    Return true if STMT in loop that is represented by LOOP_VINFO is\n@@ -303,6 +335,14 @@ vect_stmt_relevant_p (gimple *stmt, loop_vec_info loop_vinfo,\n \t}\n     }\n \n+  if (*live_p && *relevant == vect_unused_in_scope)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t \"vec_stmt_relevant_p: stmt live but not relevant.\\n\");\n+      *relevant = vect_used_only_live;\n+    }\n+\n   return (*live_p || *relevant);\n }\n \n@@ -377,7 +417,7 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n \n    Inputs:\n    - a USE in STMT in a loop represented by LOOP_VINFO\n-   - LIVE_P, RELEVANT - enum values to be set in the STMT_VINFO of the stmt\n+   - RELEVANT - enum value to be set in the STMT_VINFO of the stmt\n      that defined USE.  This is done by calling mark_relevant and passing it\n      the WORKLIST (to add DEF_STMT to the WORKLIST in case it is relevant).\n    - FORCE is true if exist_non_indexing_operands_for_use_p check shouldn't\n@@ -400,7 +440,7 @@ exist_non_indexing_operands_for_use_p (tree use, gimple *stmt)\n    Return true if everything is as expected. Return false otherwise.  */\n \n static bool\n-process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n+process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo,\n \t     enum vect_relevant relevant, vec<gimple *> *worklist,\n \t     bool force)\n {\n@@ -519,6 +559,7 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n           break;\n \n         case vect_used_by_reduction:\n+\tcase vect_used_only_live:\n           relevant = vect_used_in_outer_by_reduction;\n           break;\n \n@@ -531,7 +572,7 @@ process_use (gimple *stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n         }\n     }\n \n-  vect_mark_relevant (worklist, def_stmt, relevant, live_p);\n+  vect_mark_relevant (worklist, def_stmt, relevant, false);\n   return true;\n }\n \n@@ -565,8 +606,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n   basic_block bb;\n   gimple *phi;\n   bool live_p;\n-  enum vect_relevant relevant, tmp_relevant;\n-  enum vect_def_type def_type;\n+  enum vect_relevant relevant;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -618,80 +658,62 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t}\n \n       /* Examine the USEs of STMT. For each USE, mark the stmt that defines it\n-\t (DEF_STMT) as relevant/irrelevant and live/dead according to the\n-\t liveness and relevance properties of STMT.  */\n+\t (DEF_STMT) as relevant/irrelevant according to the relevance property\n+\t of STMT.  */\n       stmt_vinfo = vinfo_for_stmt (stmt);\n       relevant = STMT_VINFO_RELEVANT (stmt_vinfo);\n-      live_p = STMT_VINFO_LIVE_P (stmt_vinfo);\n \n-      /* Generally, the liveness and relevance properties of STMT are\n-\t propagated as is to the DEF_STMTs of its USEs:\n-\t  live_p <-- STMT_VINFO_LIVE_P (STMT_VINFO)\n-\t  relevant <-- STMT_VINFO_RELEVANT (STMT_VINFO)\n+      /* Generally, the relevance property of STMT (in STMT_VINFO_RELEVANT) is\n+\t propagated as is to the DEF_STMTs of its USEs.\n \n \t One exception is when STMT has been identified as defining a reduction\n-\t variable; in this case we set the liveness/relevance as follows:\n-\t   live_p = false\n-\t   relevant = vect_used_by_reduction\n+\t variable; in this case we set the relevance to vect_used_by_reduction.\n \t This is because we distinguish between two kinds of relevant stmts -\n \t those that are used by a reduction computation, and those that are\n \t (also) used by a regular computation.  This allows us later on to\n \t identify stmts that are used solely by a reduction, and therefore the\n \t order of the results that they produce does not have to be kept.  */\n \n-      def_type = STMT_VINFO_DEF_TYPE (stmt_vinfo);\n-      tmp_relevant = relevant;\n-      switch (def_type)\n+      switch (STMT_VINFO_DEF_TYPE (stmt_vinfo))\n         {\n           case vect_reduction_def:\n-\t    switch (tmp_relevant)\n+\t    gcc_assert (relevant != vect_unused_in_scope);\n+\t    if (relevant != vect_unused_in_scope\n+\t\t&& relevant != vect_used_in_scope\n+\t\t&& relevant != vect_used_by_reduction\n+\t\t&& relevant != vect_used_only_live)\n \t      {\n-\t        case vect_unused_in_scope:\n-\t          relevant = vect_used_by_reduction;\n-\t          break;\n-\n-\t        case vect_used_by_reduction:\n-\t          if (gimple_code (stmt) == GIMPLE_PHI)\n-                    break;\n-  \t          /* fall through */\n-\n-\t        default:\n-\t          if (dump_enabled_p ())\n-\t            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                     \"unsupported use of reduction.\\n\");\n-\t          return false;\n+\t\tif (dump_enabled_p ())\n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t   \"unsupported use of reduction.\\n\");\n+\t\treturn false;\n \t      }\n-\n-\t    live_p = false;\n \t    break;\n \n           case vect_nested_cycle:\n-            if (tmp_relevant != vect_unused_in_scope\n-                && tmp_relevant != vect_used_in_outer_by_reduction\n-                && tmp_relevant != vect_used_in_outer)\n+\t    if (relevant != vect_unused_in_scope\n+\t\t&& relevant != vect_used_in_outer_by_reduction\n+\t\t&& relevant != vect_used_in_outer)\n               {\n                 if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"unsupported use of nested cycle.\\n\");\n \n                 return false;\n               }\n-\n-            live_p = false;\n             break;\n \n           case vect_double_reduction_def:\n-            if (tmp_relevant != vect_unused_in_scope\n-                && tmp_relevant != vect_used_by_reduction)\n+\t    if (relevant != vect_unused_in_scope\n+\t\t&& relevant != vect_used_by_reduction\n+\t\t&& relevant != vect_used_only_live)\n               {\n                 if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"unsupported use of double reduction.\\n\");\n \n                 return false;\n               }\n-\n-            live_p = false;\n             break;\n \n           default:\n@@ -712,17 +734,17 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t      if (rhs_code == COND_EXPR && COMPARISON_CLASS_P (op))\n \t\t{\n \t\t  if (!process_use (stmt, TREE_OPERAND (op, 0), loop_vinfo,\n-\t\t\t\t    live_p, relevant, &worklist, false)\n+\t\t\t\t    relevant, &worklist, false)\n \t\t      || !process_use (stmt, TREE_OPERAND (op, 1), loop_vinfo,\n-\t\t\t\t       live_p, relevant, &worklist, false))\n+\t\t\t\t       relevant, &worklist, false))\n \t\t    return false;\n \t\t  i = 2;\n \t\t}\n \t      for (; i < gimple_num_ops (stmt); i++)\n                 {\n \t\t  op = gimple_op (stmt, i);\n                   if (TREE_CODE (op) == SSA_NAME\n-\t\t      && !process_use (stmt, op, loop_vinfo, live_p, relevant,\n+\t\t      && !process_use (stmt, op, loop_vinfo, relevant,\n \t\t\t\t       &worklist, false))\n                     return false;\n                  }\n@@ -732,7 +754,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               for (i = 0; i < gimple_call_num_args (stmt); i++)\n                 {\n                   tree arg = gimple_call_arg (stmt, i);\n-                  if (!process_use (stmt, arg, loop_vinfo, live_p, relevant,\n+\t\t  if (!process_use (stmt, arg, loop_vinfo, relevant,\n \t\t\t\t    &worklist, false))\n                     return false;\n                 }\n@@ -742,7 +764,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n         FOR_EACH_PHI_OR_STMT_USE (use_p, stmt, iter, SSA_OP_USE)\n           {\n             tree op = USE_FROM_PTR (use_p);\n-            if (!process_use (stmt, op, loop_vinfo, live_p, relevant,\n+\t    if (!process_use (stmt, op, loop_vinfo, relevant,\n \t\t\t      &worklist, false))\n               return false;\n           }\n@@ -752,8 +774,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t  tree off;\n \t  tree decl = vect_check_gather_scatter (stmt, loop_vinfo, NULL, &off, NULL);\n \t  gcc_assert (decl);\n-\t  if (!process_use (stmt, off, loop_vinfo, live_p, relevant,\n-\t\t\t    &worklist, true))\n+\t  if (!process_use (stmt, off, loop_vinfo, relevant, &worklist, true))\n \t    return false;\n \t}\n     } /* while worklist */\n@@ -8001,7 +8022,8 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t\t     && (relevance == vect_used_in_outer\n \t\t\t || relevance == vect_used_in_outer_by_reduction\n \t\t\t || relevance == vect_used_by_reduction\n-\t\t\t || relevance == vect_unused_in_scope));\n+\t\t\t || relevance == vect_unused_in_scope\n+\t\t\t || relevance == vect_used_only_live));\n          break;\n \n       case vect_induction_def:\n@@ -8115,7 +8137,7 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n       need extra handling, except for vectorizable reductions.  */\n   if (STMT_VINFO_LIVE_P (stmt_info)\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n-    ok = vectorizable_live_operation (stmt, NULL, NULL);\n+    ok = vectorizable_live_operation (stmt, NULL, NULL, -1, NULL);\n \n   if (!ok)\n     {\n@@ -8291,10 +8313,26 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   /* Handle stmts whose DEF is used outside the loop-nest that is\n      being vectorized.  */\n-  if (STMT_VINFO_LIVE_P (stmt_info)\n+  if (slp_node)\n+    {\n+      gimple *slp_stmt;\n+      int i;\n+      FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (slp_node), i, slp_stmt)\n+\t{\n+\t  stmt_vec_info slp_stmt_info = vinfo_for_stmt (slp_stmt);\n+\t  if (STMT_VINFO_LIVE_P (slp_stmt_info)\n+\t      && STMT_VINFO_TYPE (slp_stmt_info) != reduc_vec_info_type)\n+\t    {\n+\t      done = vectorizable_live_operation (slp_stmt, gsi, slp_node, i,\n+\t\t\t\t\t\t  &vec_stmt);\n+\t      gcc_assert (done);\n+\t    }\n+\t}\n+    }\n+  else if (STMT_VINFO_LIVE_P (stmt_info)\n       && STMT_VINFO_TYPE (stmt_info) != reduc_vec_info_type)\n     {\n-      done = vectorizable_live_operation (stmt, gsi, &vec_stmt);\n+      done = vectorizable_live_operation (stmt, gsi, slp_node, -1, &vec_stmt);\n       gcc_assert (done);\n     }\n "}, {"sha": "6d52b5531a01b1b4ed0766e96022fc4a3608b1c0", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b28ead45fe630b9e018a81cb46b7e1f971e4dc17/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=b28ead45fe630b9e018a81cb46b7e1f971e4dc17", "patch": "@@ -442,6 +442,9 @@ enum stmt_vec_info_type {\n    block.  */\n enum vect_relevant {\n   vect_unused_in_scope = 0,\n+\n+  /* The def is only used outside the loop.  */\n+  vect_used_only_live,\n   /* The def is in the inner loop, and the use is in the outer loop, and the\n      use is a reduction stmt.  */\n   vect_used_in_outer_by_reduction,\n@@ -1072,7 +1075,7 @@ extern loop_vec_info vect_analyze_loop (struct loop *);\n extern void vect_transform_loop (loop_vec_info);\n extern loop_vec_info vect_analyze_loop_form (struct loop *);\n extern bool vectorizable_live_operation (gimple *, gimple_stmt_iterator *,\n-\t\t\t\t\t gimple **);\n+\t\t\t\t\t slp_tree, int, gimple **);\n extern bool vectorizable_reduction (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, slp_tree);\n extern bool vectorizable_induction (gimple *, gimple_stmt_iterator *, gimple **);\n@@ -1098,6 +1101,7 @@ extern void vect_get_slp_defs (vec<tree> , slp_tree,\n \t\t\t       vec<vec<tree> > *, int);\n extern bool vect_slp_bb (basic_block);\n extern gimple *vect_find_last_scalar_stmt_in_slp (slp_tree);\n+extern bool is_simple_and_all_uses_invariant (gimple *, loop_vec_info);\n \n /* In tree-vect-patterns.c.  */\n /* Pattern recognition functions."}]}