{"sha": "a5497b12385d3a21e336f068d5477574a78da94a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU0OTdiMTIzODVkM2EyMWUzMzZmMDY4ZDU0Nzc1NzRhNzhkYTk0YQ==", "commit": {"author": {"name": "Venkataramanan Kumar", "email": "venkataramanan.kumar@amd.com", "date": "2012-10-09T15:48:45Z"}, "committer": {"name": "Venkataramanan Kumar", "email": "vekumar@gcc.gnu.org", "date": "2012-10-09T15:48:45Z"}, "message": "Fix for PR53397 by making prefecthing less agressive\n\nFrom-SVN: r192261", "tree": {"sha": "57e1fe2200c0ab02d5afebc842ab80d29b4aa98e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/57e1fe2200c0ab02d5afebc842ab80d29b4aa98e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a5497b12385d3a21e336f068d5477574a78da94a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5497b12385d3a21e336f068d5477574a78da94a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5497b12385d3a21e336f068d5477574a78da94a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5497b12385d3a21e336f068d5477574a78da94a/comments", "author": null, "committer": null, "parents": [{"sha": "eeeef8f4f93036d2ea25325a3b681c338e7e143f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eeeef8f4f93036d2ea25325a3b681c338e7e143f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eeeef8f4f93036d2ea25325a3b681c338e7e143f"}], "stats": {"total": 165, "additions": 148, "deletions": 17}, "files": [{"sha": "6d245742d977ca0946edff055a66bff1f7488474", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a5497b12385d3a21e336f068d5477574a78da94a", "patch": "@@ -1,3 +1,21 @@\n+2012-10-09  Venkataramanan Kumar  <venkataramanan.kumar@amd.com>\n+\n+\tPR middle-end/53397\n+\t* tree-ssa-loop-prefetch.c (gather_memory_references_ref):\n+\tPerform non constant step prefetching in inner loop, only\n+\twhen it is invariant in the entire loop nest.\n+\t* tree-ssa-loop-prefetch.c (dump_mem_details): New function to dump\n+\tbase, step and delta values of memeory reference analysed for\n+\t prefetching.\n+\t* tree-ssa-loop-prefetch.c (dump_mem_ref): Call dump_mem_details\n+\tto print base, step and delta values of memory reference.\t\n+\t* cfgloop.h (loop_outermost): New function that returns outermost\n+\tloop for a given loop in a loop nest.\n+\t* testsuite/gcc.dg/pr53397-1.c: New test case\n+\tChecks we are prefecthing for loop invariant steps\n+\t* testsuite/gcc.dg/pr53397-2.c: New test case\n+\tChecks we are not prefecthing for loop variant steps\n+\n 2012-10-09  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/54837"}, {"sha": "80af7d8dbc439a99123682e76d292b5a0bab8c4e", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=a5497b12385d3a21e336f068d5477574a78da94a", "patch": "@@ -712,4 +712,18 @@ extern void move_loop_invariants (void);\n extern bool finite_loop_p (struct loop *);\n extern void scale_loop_profile (struct loop *loop, int scale, int iteration_bound);\n \n+/* Returns the outermost loop of the loop nest that contains LOOP.*/\n+static inline struct loop *\n+loop_outermost (struct loop *loop)\n+{\n+  \n+  unsigned n = VEC_length (loop_p, loop->superloops);\n+\n+  if (n <= 1)\n+    return loop;\n+\n+  return VEC_index (loop_p, loop->superloops, 1);\n+}\n+\n+\n #endif /* GCC_CFGLOOP_H */"}, {"sha": "abb83c6c58405d3f91f4b6f21b29502eb4195546", "filename": "gcc/testsuite/gcc.dg/pr53397-1.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-1.c?ref=a5497b12385d3a21e336f068d5477574a78da94a", "patch": "@@ -0,0 +1,28 @@\n+/* Prefetching when the step is loop invariant.  */\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-options \"-O3 -fprefetch-loop-arrays -fdump-tree-aprefetch-details --param min-insn-to-prefetch-ratio=3 --param simultaneous-prefetches=10 -fdump-tree-aprefetch-details\" } */\n+\n+\n+double data[16384];\n+void prefetch_when_non_constant_step_is_invariant(int step, int n)\n+{\n+     int a;\n+     int b;\n+     for (a = 1; a < step; a++) {\n+        for (b = 0; b < n; b += 2 * step) {\n+\n+          int i = 2*(b + a);\n+          int j = 2*(b + a + step);\n+\n+\n+          data[j]   = data[i];\n+          data[j+1] = data[i+1];\n+        }\n+     }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Issued prefetch\" \"aprefetch\" } } */\n+/* { dg-final { scan-assembler \"prefetcht0\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */"}, {"sha": "4793ae0a6e692010ece845b9fb6adb85f68623ef", "filename": "gcc/testsuite/gcc.dg/pr53397-2.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr53397-2.c?ref=a5497b12385d3a21e336f068d5477574a78da94a", "patch": "@@ -0,0 +1,28 @@\n+/* Not prefetching when the step is loop variant.  */\n+/* { dg-do compile { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-require-effective-target sse2 } */\n+/* { dg-options \"-O3 -fprefetch-loop-arrays -fdump-tree-aprefetch-details --param min-insn-to-prefetch-ratio=3 --param simultaneous-prefetches=10 -fdump-tree-aprefetch-details\" } */\n+\n+double data[16384];\n+void donot_prefetch_when_non_constant_step_is_variant(int step, int n)\n+{ \n+     int a;\n+     int b;\n+     for (a = 1; a < step; a++,step*=2) {\n+        for (b = 0; b < n; b += 2 * step) {\n+\n+          int i = 2*(b + a);\n+          int j = 2*(b + a + step);\n+\n+\n+          data[j]   = data[i];\n+          data[j+1] = data[i+1];\n+        }\n+     } \n+}\n+\n+/* { dg-final { scan-tree-dump \"Not prefetching\" \"aprefetch\" } } */\n+/* { dg-final { scan-tree-dump \"loop variant step\" \"aprefetch\" } } */\n+\n+/* { dg-final { cleanup-tree-dump \"aprefetch\" } } */\n+"}, {"sha": "dcc65e19abbc2374a140198d60dd6b13d6e96e21", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 60, "deletions": 17, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a5497b12385d3a21e336f068d5477574a78da94a/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=a5497b12385d3a21e336f068d5477574a78da94a", "patch": "@@ -278,29 +278,37 @@ struct mem_ref\n \t\t\t\t   nontemporal one.  */\n };\n \n-/* Dumps information about reference REF to FILE.  */\n-\n+/* Dumps information about memory reference */\n static void\n-dump_mem_ref (FILE *file, struct mem_ref *ref)\n+dump_mem_details (FILE *file, tree base, tree step,\n+\t    HOST_WIDE_INT delta, bool write_p) \n {\n-  fprintf (file, \"Reference %p:\\n\", (void *) ref);\n-\n-  fprintf (file, \"  group %p (base \", (void *) ref->group);\n-  print_generic_expr (file, ref->group->base, TDF_SLIM);\n+  fprintf (file, \"(base \");\n+  print_generic_expr (file, base, TDF_SLIM);\n   fprintf (file, \", step \");\n-  if (cst_and_fits_in_hwi (ref->group->step))\n-    fprintf (file, HOST_WIDE_INT_PRINT_DEC, int_cst_value (ref->group->step));\n+  if (cst_and_fits_in_hwi (step))\n+    fprintf (file, HOST_WIDE_INT_PRINT_DEC, int_cst_value (step));\n   else\n-    print_generic_expr (file, ref->group->step, TDF_TREE);\n+    print_generic_expr (file, step, TDF_TREE);\n   fprintf (file, \")\\n\");\n-\n   fprintf (file, \"  delta \");\n-  fprintf (file, HOST_WIDE_INT_PRINT_DEC, ref->delta);\n+  fprintf (file, HOST_WIDE_INT_PRINT_DEC, delta);\n   fprintf (file, \"\\n\");\n+  fprintf (file, \"  %s\\n\", write_p ? \"write\" : \"read\");\n+  fprintf (file, \"\\n\");\n+}\n \n-  fprintf (file, \"  %s\\n\", ref->write_p ? \"write\" : \"read\");\n+/* Dumps information about reference REF to FILE.  */\n \n-  fprintf (file, \"\\n\");\n+static void\n+dump_mem_ref (FILE *file, struct mem_ref *ref)\n+{\n+  fprintf (file, \"Reference %p:\\n\", (void *) ref);\n+\n+  fprintf (file, \"  group %p \", (void *) ref->group);\n+\n+  dump_mem_details (file, ref->group->base, ref->group->step, ref->delta,\n+                   ref->write_p);\n }\n \n /* Finds a group with BASE and STEP in GROUPS, or creates one if it does not\n@@ -537,9 +545,44 @@ gather_memory_references_ref (struct loop *loop, struct mem_ref_group **refs,\n   if (may_be_nonaddressable_p (base))\n     return false;\n \n-  /* Limit non-constant step prefetching only to the innermost loops.  */\n-  if (!cst_and_fits_in_hwi (step) && loop->inner != NULL)\n-    return false;\n+  /* Limit non-constant step prefetching only to the innermost loops and \n+     only when the step is loop invariant in the entire loop nest. */\n+  if (!cst_and_fits_in_hwi (step))\n+    {\n+      if (loop->inner != NULL)\n+        {\n+          if (dump_file && (dump_flags & TDF_DETAILS))\n+            {\n+              fprintf (dump_file, \"Memory expression %p\\n\",(void *) ref ); \n+              print_generic_expr (dump_file, ref, TDF_TREE); \n+              fprintf (dump_file,\":\");\n+              dump_mem_details( dump_file, base, step, delta, write_p);              \n+              fprintf (dump_file, \n+                       \"Ignoring %p, non-constant step prefetching is \"\n+                       \"limited to inner most loops \\n\", \n+                       (void *) ref);\n+            }\n+            return false;    \n+         }\n+      else\n+        {\n+          if (!expr_invariant_in_loop_p (loop_outermost (loop), step))\n+          {\n+            if (dump_file && (dump_flags & TDF_DETAILS))\n+              {\n+                fprintf (dump_file, \"Memory expression %p\\n\",(void *) ref );\n+                print_generic_expr (dump_file, ref, TDF_TREE);\n+                fprintf (dump_file,\":\");\n+                dump_mem_details(dump_file, base, step, delta, write_p);\n+                fprintf (dump_file, \n+                         \"Not prefetching, ignoring %p due to \"\n+                         \"loop variant step\\n\",\n+                         (void *) ref);\n+              }\n+              return false;                 \n+            }\n+        }\n+    }\n \n   /* Now we know that REF = &BASE + STEP * iter + DELTA, where DELTA and STEP\n      are integer constants.  */"}]}