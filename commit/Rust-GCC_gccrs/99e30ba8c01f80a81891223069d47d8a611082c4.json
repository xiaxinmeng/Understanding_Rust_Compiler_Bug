{"sha": "99e30ba8c01f80a81891223069d47d8a611082c4", "node_id": "C_kwDOANBUbNoAKDk5ZTMwYmE4YzAxZjgwYTgxODkxMjIzMDY5ZDQ3ZDhhNjExMDgyYzQ", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2021-07-29T15:15:46Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-23T13:06:14Z"}, "message": "[Ada] Cleanup and efficiency improvements\n\ngcc/ada/\n\n\t* gen_il-gen.adb: Generate getters and setters with much of the\n\tcode inlined. Generate code for storing a few fields in the node\n\theader, to avoid the extra level of indirection for those\n\tfields. We generate the header type, so we don't have to\n\tduplicate hand-written Ada and C code to depend on the number of\n\theader fields.  Declare constants for slot size. Use short names\n\tbecause these are used all over.  Remove\n\tPut_Low_Level_Accessor_Instantiations, Put_Low_Level_C_Getter,\n\twhich are no longer needed.  Rename\n\tPut_High_Level_C_Getter-->Put_C_Getter.\n\t* atree.ads, atree.adb: Take into account the header slots.\n\tTake into account the single Node_Or_Entity_Field type.  Remove\n\t\"pragma Assertion_Policy (Ignore);\", because the routines in\n\tthis package are no longer efficiency critical.\n\t* atree.h: Remove low-level getters, which are no longer used by\n\tsinfo.h and einfo.h.\n\t* einfo-utils.adb: Avoid crash in Known_Alignment.\n\t* live.adb, sem_eval.adb: Remove code that prevents Node_Id from\n\thaving a predicate.  We don't actually add a predicate to\n\tNode_Id, but we want to be able to for temporary debugging.\n\t* sinfo-utils.adb: Remove code that prevents Node_Id from having\n\ta predicate.  Take into account the single Node_Or_Entity_Field\n\ttype.\n\t* sinfo-utils.ads: Minor.\n\t* table.ads (Table_Type): Make the components aliased, because\n\tlow-level setters in Atree need to take 'Access.\n\t* treepr.adb: Take into account the single Node_Or_Entity_Field\n\ttype.  Make some code more robust, so we can print out\n\thalf-baked nodes.\n\t* types.ads: Move types here for visibility purposes.\n\t* gcc-interface/gigi.h, gcc-interface/trans.c: Take into account\n\tthe Node_Header change in the GNAT front end.\n\t* gcc-interface/cuintp.c, gcc-interface/targtyps.c: Add because\n\tgigi.h now refers to type Node_Header, which is in sinfo.h.", "tree": {"sha": "2bfbbf0e257e54ccf041809b15680cfb8b58c83a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2bfbbf0e257e54ccf041809b15680cfb8b58c83a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/99e30ba8c01f80a81891223069d47d8a611082c4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e30ba8c01f80a81891223069d47d8a611082c4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/99e30ba8c01f80a81891223069d47d8a611082c4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/99e30ba8c01f80a81891223069d47d8a611082c4/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7165704bfaae012cb28e5411619218da6fb8320d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7165704bfaae012cb28e5411619218da6fb8320d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7165704bfaae012cb28e5411619218da6fb8320d"}], "stats": {"total": 1254, "additions": 691, "deletions": 563}, "files": [{"sha": "00565d66d85c0a76f02334c3ea5613698d0616ca", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 284, "deletions": 205, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -23,20 +23,12 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Assertions in this package are too slow, and are mostly needed when working\n---  on this package itself, or on gen_il, so we disable them.\n---  To debug low-level bugs in this area, comment out the following pragma,\n---  and run with -gnatd_v.\n-\n-pragma Assertion_Policy (Ignore);\n-\n with Aspects;        use Aspects;\n with Debug;          use Debug;\n with Namet;          use Namet;\n with Nlists;         use Nlists;\n with Opt;            use Opt;\n with Output;         use Output;\n-with Seinfo;         use Seinfo;\n with Sinfo.Utils;    use Sinfo.Utils;\n with System.Storage_Elements;\n \n@@ -153,43 +145,59 @@ package body Atree is\n \n    function Size_In_Slots (N : Node_Or_Entity_Id) return Slot_Count;\n    --  Number of slots belonging to N. This can be less than\n-   --  Size_In_Slots_To_Alloc for entities.\n+   --  Size_In_Slots_To_Alloc for entities. Includes both header\n+   --  and dynamic slots.\n+\n+   function Size_In_Slots_Dynamic (N : Node_Or_Entity_Id) return Slot_Count;\n+   --  Just counts the number of dynamic slots\n \n    function Size_In_Slots_To_Alloc (N : Node_Or_Entity_Id) return Slot_Count;\n    function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Slot_Count;\n    --  Number of slots to allocate for a node or entity. For entities, we have\n    --  to allocate the max, because we don't know the Ekind when this is\n    --  called.\n \n-   function Off_0 (N : Node_Id) return Node_Offset;\n-   --  Offset of the first slot of N (offset 0) in Slots.Table\n+   function Off_F (N : Node_Id) return Node_Offset with Inline;\n+   --  Offset of the first dynamic slot of N in Slots.Table.\n+   --  The actual offset of this slot from the start of the node\n+   --  is not 0; this is logically the first slot after the header\n+   --  slots.\n+\n+   function Off_0 (N : Node_Id) return Node_Offset'Base with Inline;\n+   --  This is for zero-origin addressing of the dynamic slots.\n+   --  It points to slot 0 of N in Slots.Table, which does not exist,\n+   --  because the first few slots are stored in the header.\n \n-   function Off_L (N : Node_Id) return Node_Offset;\n+   function Off_L (N : Node_Id) return Node_Offset with Inline;\n    --  Offset of the last slot of N in Slots.Table\n \n-   procedure Zero_Slots (First, Last : Node_Offset) with Inline;\n-   --  Set slots in the range F..L to zero\n+   procedure Zero_Dynamic_Slots (First, Last : Node_Offset'Base) with Inline;\n+   --  Set dynamic slots in the range First..Last to zero\n+\n+   procedure Zero_Header_Slots (N : Node_Or_Entity_Id) with Inline;\n+   --  Zero the header slots belonging to N\n \n    procedure Zero_Slots (N : Node_Or_Entity_Id) with Inline;\n-   --  Zero the slots belonging to N\n+   --  Zero the slots belonging to N (both header and dynamic)\n \n-   procedure Copy_Slots (From, To : Node_Offset; Num_Slots : Slot_Count)\n+   procedure Copy_Dynamic_Slots\n+     (From, To : Node_Offset; Num_Slots : Slot_Count)\n      with Inline;\n    --  Copy Num_Slots slots from From to To. Caller is responsible for ensuring\n    --  that the Num_Slots at To are a reasonable place to copy to.\n \n    procedure Copy_Slots (Source, Destination : Node_Id) with Inline;\n-   --  Copies the slots of Source to Destination; uses the node kind to\n-   --  determine the Num_Slots.\n+   --  Copies the slots (both header and dynamic) of Source to Destination;\n+   --  uses the node kind to determine the Num_Slots.\n \n    function Get_Field_Value\n-     (N : Node_Id; Field : Node_Field) return Field_Size_32_Bit;\n+     (N : Node_Id; Field : Node_Or_Entity_Field) return Field_Size_32_Bit;\n    --  Get any field value as a Field_Size_32_Bit. If the field is smaller than\n    --  32 bits, convert it to Field_Size_32_Bit. The Field must be present in\n    --  the Nkind of N.\n \n    procedure Set_Field_Value\n-     (N : Node_Id; Field : Node_Field; Val : Field_Size_32_Bit);\n+     (N : Node_Id; Field : Node_Or_Entity_Field; Val : Field_Size_32_Bit);\n    --  Set any field value as a Field_Size_32_Bit. If the field is smaller than\n    --  32 bits, convert it from Field_Size_32_Bit, and Val had better be small\n    --  enough. The Field must be present in the Nkind of N.\n@@ -199,10 +207,6 @@ package body Atree is\n    --  Called whenever Nkind is modified. Raises an exception if not all\n    --  vanishing fields are in their initial zero state.\n \n-   function Get_Field_Value\n-     (N : Entity_Id; Field : Entity_Field) return Field_Size_32_Bit;\n-   procedure Set_Field_Value\n-     (N : Entity_Id; Field : Entity_Field; Val : Field_Size_32_Bit);\n    procedure Check_Vanishing_Fields\n      (Old_N : Entity_Id; New_Kind : Entity_Kind);\n    --  Above are the same as the ones for nodes, but for entities\n@@ -405,7 +409,8 @@ package body Atree is\n \n             pragma Assert (N'Valid);\n             pragma Assert (N <= Node_Offsets.Last);\n-            pragma Assert (Off_0 (N) <= Off_L (N));\n+            pragma Assert (Off_L (N) >= Off_0 (N));\n+            pragma Assert (Off_L (N) >= Off_F (N) - 1);\n             pragma Assert (Off_L (N) <= Slots.Last);\n             pragma Assert (Nkind (N)'Valid);\n             pragma Assert (Nkind (N) /= N_Unused_At_End);\n@@ -469,8 +474,9 @@ package body Atree is\n \n          function Cast is new\n            Unchecked_Conversion (Field_Size_1_Bit, Field_Type);\n+         Val : constant Field_Size_1_Bit := Get_1_Bit_Val (N, Offset);\n       begin\n-         return Cast (Get_1_Bit_Val (N, Offset));\n+         return Cast (Val);\n       end Get_1_Bit_Field;\n \n       function Get_2_Bit_Field\n@@ -480,8 +486,9 @@ package body Atree is\n \n          function Cast is new\n            Unchecked_Conversion (Field_Size_2_Bit, Field_Type);\n+         Val : constant Field_Size_2_Bit := Get_2_Bit_Val (N, Offset);\n       begin\n-         return Cast (Get_2_Bit_Val (N, Offset));\n+         return Cast (Val);\n       end Get_2_Bit_Field;\n \n       function Get_4_Bit_Field\n@@ -491,8 +498,9 @@ package body Atree is\n \n          function Cast is new\n            Unchecked_Conversion (Field_Size_4_Bit, Field_Type);\n+         Val : constant Field_Size_4_Bit := Get_4_Bit_Val (N, Offset);\n       begin\n-         return Cast (Get_4_Bit_Val (N, Offset));\n+         return Cast (Val);\n       end Get_4_Bit_Field;\n \n       function Get_8_Bit_Field\n@@ -502,8 +510,9 @@ package body Atree is\n \n          function Cast is new\n            Unchecked_Conversion (Field_Size_8_Bit, Field_Type);\n+         Val : constant Field_Size_8_Bit := Get_8_Bit_Val (N, Offset);\n       begin\n-         return Cast (Get_8_Bit_Val (N, Offset));\n+         return Cast (Val);\n       end Get_8_Bit_Field;\n \n       function Get_32_Bit_Field\n@@ -514,7 +523,8 @@ package body Atree is\n          function Cast is new\n            Unchecked_Conversion (Field_Size_32_Bit, Field_Type);\n \n-         Result : constant Field_Type := Cast (Get_32_Bit_Val (N, Offset));\n+         Val : constant Field_Size_32_Bit := Get_32_Bit_Val (N, Offset);\n+         Result : constant Field_Type := Cast (Val);\n          --  Note: declaring Result here instead of directly returning\n          --  Cast (...) helps CodePeer understand that there are no issues\n          --  around uninitialized variables.\n@@ -612,133 +622,214 @@ package body Atree is\n          Set_32_Bit_Val (N, Offset, Cast (Val));\n       end Set_32_Bit_Field;\n \n+      pragma Style_Checks (\"M90\");\n+\n+      -----------------------------------\n+      -- Low-level getters and setters --\n+      -----------------------------------\n+\n+      --  In the getters and setters below, we use shifting and masking to\n+      --  simulate packed arrays. F_Size is the field size in bits. Mask is\n+      --  that number of 1 bits in the low-order bits. F_Per_Slot is the number\n+      --  of fields per slot. Slot_Off is the offset of the slot of interest.\n+      --  S is the slot at that offset. V is the amount to shift by.\n+\n+      function In_NH (Slot_Off : Field_Offset) return Boolean is\n+        (Slot_Off < Seinfo.N_Head);\n+      --  In_NH stands for \"in Node_Header\", not \"in New Hampshire\"\n+\n+      function Get_Slot\n+        (N : Node_Or_Entity_Id; Slot_Off : Field_Offset)\n+         return Slot is\n+         (if In_NH (Slot_Off) then\n+            Node_Offsets.Table (N).Slots (Slot_Off)\n+          else Slots.Table (Node_Offsets.Table (N).Offset + Slot_Off));\n+      --  Get the slot, either directly from the node header, or indirectly\n+      --  from the Slots table.\n+\n       function Get_1_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_1_Bit\n       is\n-         --  We wish we were using packed arrays, but instead we're simulating\n-         --  them with modular integers. L here (and elsewhere) is the 'Length\n-         --  of that simulated array.\n-         L : constant Field_Offset := Slot_Size / 1;\n-\n-         pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 1;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset (N, Slot_Off));\n+         Raw : constant Field_Size_1_Bit :=\n+           Field_Size_1_Bit (Shift_Right (S, V) and Mask);\n       begin\n-         return Field_Size_1_Bit (Shift_Right (S, V) and 1);\n+         return Raw;\n       end Get_1_Bit_Val;\n \n       function Get_2_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_2_Bit\n       is\n-         L : constant Field_Offset := Slot_Size / 2;\n-\n-         pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 2;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset (N, Slot_Off));\n+         Raw : constant Field_Size_2_Bit :=\n+           Field_Size_2_Bit (Shift_Right (S, V) and Mask);\n       begin\n-         return Field_Size_2_Bit (Shift_Right (S, V) and 3);\n+         return Raw;\n       end Get_2_Bit_Val;\n \n       function Get_4_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_4_Bit\n       is\n-         L : constant Field_Offset := Slot_Size / 4;\n-\n-         pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 4;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset (N, Slot_Off));\n+         Raw : constant Field_Size_4_Bit :=\n+           Field_Size_4_Bit (Shift_Right (S, V) and Mask);\n       begin\n-         return Field_Size_4_Bit (Shift_Right (S, V) and 15);\n+         return Raw;\n       end Get_4_Bit_Val;\n \n       function Get_8_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_8_Bit\n       is\n-         L : constant Field_Offset := Slot_Size / 8;\n-\n-         pragma Debug (Validate_Node_And_Offset (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 8;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset (N, Slot_Off));\n+         Raw : constant Field_Size_8_Bit :=\n+           Field_Size_8_Bit (Shift_Right (S, V) and Mask);\n       begin\n-         return Field_Size_8_Bit (Shift_Right (S, V) and 255);\n+         return Raw;\n       end Get_8_Bit_Val;\n \n       function Get_32_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset) return Field_Size_32_Bit\n       is\n-         pragma Debug (Validate_Node_And_Offset (N, Offset));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset);\n+         F_Size : constant := 32;\n+         --  No Mask needed\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         S : constant Slot := Get_Slot (N, Slot_Off);\n+         pragma Debug (Validate_Node_And_Offset (N, Slot_Off));\n+         Raw : constant Field_Size_32_Bit :=\n+           Field_Size_32_Bit (S);\n       begin\n-         return Field_Size_32_Bit (S);\n+         return Raw;\n       end Get_32_Bit_Val;\n \n+      type Slot_Ptr is access all Slot;\n+      function Get_Slot_Ptr\n+        (N : Node_Or_Entity_Id; Slot_Off : Field_Offset)\n+         return Slot_Ptr is\n+         (if In_NH (Slot_Off) then\n+            Node_Offsets.Table (N).Slots (Slot_Off)'Access\n+          else Slots.Table (Node_Offsets.Table (N).Offset + Slot_Off)'Access);\n+\n       procedure Set_1_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_1_Bit)\n       is\n-         L : constant Field_Offset := Slot_Size / 1;\n-\n-         pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 1;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n+         S : Slot renames Ptr.all;\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (1, V)) or Shift_Left (Slot (Val), V);\n+         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n       end Set_1_Bit_Val;\n \n       procedure Set_2_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_2_Bit)\n       is\n-         L : constant Field_Offset := Slot_Size / 2;\n-\n-         pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 2;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n+         S : Slot renames Ptr.all;\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (3, V)) or Shift_Left (Slot (Val), V);\n+         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n       end Set_2_Bit_Val;\n \n       procedure Set_4_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_4_Bit)\n       is\n-         L : constant Field_Offset := Slot_Size / 4;\n-\n-         pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 4;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n+         S : Slot renames Ptr.all;\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (15, V)) or Shift_Left (Slot (Val), V);\n+         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n       end Set_4_Bit_Val;\n \n       procedure Set_8_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_8_Bit)\n       is\n-         L : constant Field_Offset := Slot_Size / 8;\n-\n-         pragma Debug (Validate_Node_And_Offset_Write (N, Offset / L));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset / L);\n-         V : constant Natural := Natural ((Offset mod L) * (Slot_Size / L));\n+         F_Size : constant := 8;\n+         Mask : constant := 2**F_Size - 1;\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n+         S : Slot renames Ptr.all;\n+         V : constant Natural := Natural ((Offset mod F_Per_Slot) * F_Size);\n+         pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n-         S := (S and not Shift_Left (255, V)) or Shift_Left (Slot (Val), V);\n+         S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Val), V);\n       end Set_8_Bit_Val;\n \n       procedure Set_32_Bit_Val\n         (N : Node_Or_Entity_Id; Offset : Field_Offset; Val : Field_Size_32_Bit)\n       is\n-         pragma Debug (Validate_Node_And_Offset_Write (N, Offset));\n-\n-         S : Slot renames Slots.Table (Node_Offsets.Table (N) + Offset);\n+         F_Size : constant := 32;\n+         --  No Mask needed\n+         F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\n+         Slot_Off : constant Field_Offset := Offset / F_Per_Slot;\n+         Ptr : constant Slot_Ptr := Get_Slot_Ptr (N, Slot_Off);\n+         S : Slot renames Ptr.all;\n+         pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\n       begin\n          S := Slot (Val);\n       end Set_32_Bit_Val;\n \n+      ----------------------\n+      -- Print_Atree_Info --\n+      ----------------------\n+\n+      procedure Print_Atree_Info (N : Node_Or_Entity_Id) is\n+         function Cast is new Unchecked_Conversion (Slot, Int);\n+      begin\n+         Write_Int (Int (Size_In_Slots (N)));\n+         Write_Str (\" slots (\");\n+         Write_Int (Int (Off_0 (N)));\n+         Write_Str (\" .. \");\n+         Write_Int (Int (Off_L (N)));\n+         Write_Str (\"):\");\n+\n+         for Off in Off_0 (N) .. Off_L (N) loop\n+            Write_Str (\" \");\n+            Write_Int (Cast (Get_Slot (N, Off)));\n+         end loop;\n+\n+         Write_Eol;\n+      end Print_Atree_Info;\n+\n    end Atree_Private_Part;\n \n    ---------------\n@@ -751,13 +842,12 @@ package body Atree is\n    --  etc.\n \n    function Get_Field_Value\n-     (N : Node_Id; Field : Node_Field) return Field_Size_32_Bit\n+     (N : Node_Id; Field : Node_Or_Entity_Field) return Field_Size_32_Bit\n    is\n-      pragma Assert (Field_Checking.Field_Present (Nkind (N), Field));\n-      Desc : Field_Descriptor renames Node_Field_Descriptors (Field);\n+      Desc : Seinfo.Field_Descriptor renames Field_Descriptors (Field);\n \n    begin\n-      case Field_Size (Desc.Kind) is\n+      case Seinfo.Field_Size (Desc.Kind) is\n          when 1 => return Field_Size_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n          when 2 => return Field_Size_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n          when 4 => return Field_Size_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n@@ -767,13 +857,12 @@ package body Atree is\n    end Get_Field_Value;\n \n    procedure Set_Field_Value\n-     (N : Node_Id; Field : Node_Field; Val : Field_Size_32_Bit)\n+     (N : Node_Id; Field : Node_Or_Entity_Field; Val : Field_Size_32_Bit)\n    is\n-      pragma Assert (Field_Checking.Field_Present (Nkind (N), Field));\n-      Desc : Field_Descriptor renames Node_Field_Descriptors (Field);\n+      Desc : Seinfo.Field_Descriptor renames Field_Descriptors (Field);\n \n    begin\n-      case Field_Size (Desc.Kind) is\n+      case Seinfo.Field_Size (Desc.Kind) is\n          when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_Size_1_Bit (Val));\n          when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_Size_2_Bit (Val));\n          when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_Size_4_Bit (Val));\n@@ -782,13 +871,15 @@ package body Atree is\n       end case;\n    end Set_Field_Value;\n \n-   procedure Reinit_Field_To_Zero (N : Node_Id; Field : Node_Field) is\n+   procedure Reinit_Field_To_Zero\n+     (N : Node_Id; Field : Node_Or_Entity_Field)\n+   is\n    begin\n       Set_Field_Value (N, Field, 0);\n    end Reinit_Field_To_Zero;\n \n    function Field_Is_Initial_Zero\n-     (N : Node_Id; Field : Node_Field) return Boolean is\n+     (N : Node_Id; Field : Node_Or_Entity_Field) return Boolean is\n    begin\n       return Get_Field_Value (N, Field) = 0;\n    end Field_Is_Initial_Zero;\n@@ -839,47 +930,6 @@ package body Atree is\n       end loop;\n    end Check_Vanishing_Fields;\n \n-   function Get_Field_Value\n-     (N : Entity_Id; Field : Entity_Field) return Field_Size_32_Bit\n-   is\n-      pragma Assert (Field_Checking.Field_Present (Ekind (N), Field));\n-      Desc : Field_Descriptor renames Entity_Field_Descriptors (Field);\n-   begin\n-      case Field_Size (Desc.Kind) is\n-         when 1 => return Field_Size_32_Bit (Get_1_Bit_Val (N, Desc.Offset));\n-         when 2 => return Field_Size_32_Bit (Get_2_Bit_Val (N, Desc.Offset));\n-         when 4 => return Field_Size_32_Bit (Get_4_Bit_Val (N, Desc.Offset));\n-         when 8 => return Field_Size_32_Bit (Get_8_Bit_Val (N, Desc.Offset));\n-         when others => return Get_32_Bit_Val (N, Desc.Offset);  -- 32\n-      end case;\n-   end Get_Field_Value;\n-\n-   procedure Set_Field_Value\n-     (N : Entity_Id; Field : Entity_Field; Val : Field_Size_32_Bit)\n-   is\n-      pragma Assert (Field_Checking.Field_Present (Ekind (N), Field));\n-      Desc : Field_Descriptor renames Entity_Field_Descriptors (Field);\n-   begin\n-      case Field_Size (Desc.Kind) is\n-         when 1 => Set_1_Bit_Val (N, Desc.Offset, Field_Size_1_Bit (Val));\n-         when 2 => Set_2_Bit_Val (N, Desc.Offset, Field_Size_2_Bit (Val));\n-         when 4 => Set_4_Bit_Val (N, Desc.Offset, Field_Size_4_Bit (Val));\n-         when 8 => Set_8_Bit_Val (N, Desc.Offset, Field_Size_8_Bit (Val));\n-         when others => Set_32_Bit_Val (N, Desc.Offset, Val);  -- 32\n-      end case;\n-   end Set_Field_Value;\n-\n-   procedure Reinit_Field_To_Zero (N : Node_Id; Field : Entity_Field) is\n-   begin\n-      Set_Field_Value (N, Field, 0);\n-   end Reinit_Field_To_Zero;\n-\n-   function Field_Is_Initial_Zero\n-     (N : Entity_Id; Field : Entity_Field) return Boolean is\n-   begin\n-      return Get_Field_Value (N, Field) = 0;\n-   end Field_Is_Initial_Zero;\n-\n    procedure Check_Vanishing_Fields\n      (Old_N : Entity_Id; New_Kind : Entity_Kind)\n    is\n@@ -918,7 +968,7 @@ package body Atree is\n    end Check_Vanishing_Fields;\n \n    Nkind_Offset : constant Field_Offset :=\n-     Node_Field_Descriptors (F_Nkind).Offset;\n+     Field_Descriptors (F_Nkind).Offset;\n \n    procedure Set_Node_Kind_Type is new Set_8_Bit_Field (Node_Kind) with Inline;\n \n@@ -943,35 +993,43 @@ package body Atree is\n       if Old_Size < New_Size then\n          declare\n             Old_Last_Slot : constant Node_Offset := Slots.Last;\n-            Old_Off_0 : constant Node_Offset := Off_0 (N);\n+            Old_Off_F : constant Node_Offset := Off_F (N);\n          begin\n-            if Old_Last_Slot = Old_Off_0 + Old_Size - 1 then\n+            if Old_Last_Slot = Old_Off_F + Old_Size - 1 then\n                --  In this case, the slots are at the end of Slots.Table, so we\n                --  don't need to move them.\n                Slots.Set_Last (Old_Last_Slot + New_Size - Old_Size);\n \n             else\n                --  Move the slots\n-               All_Node_Offsets (N) := Alloc_Slots (New_Size);\n-               Copy_Slots (Old_Off_0, Off_0 (N), Old_Size);\n-               pragma Debug (Zero_Slots (Old_Off_0, Old_Off_0 + Old_Size - 1));\n+\n+               declare\n+                  New_Off_F : constant Node_Offset := Alloc_Slots (New_Size);\n+               begin\n+                  All_Node_Offsets (N).Offset := New_Off_F - Seinfo.N_Head;\n+                  Copy_Dynamic_Slots (Old_Off_F, New_Off_F, Old_Size);\n+                  pragma Debug\n+                    (Zero_Dynamic_Slots (Old_Off_F, Old_Off_F + Old_Size - 1));\n+               end;\n             end if;\n          end;\n \n-         Zero_Slots (Off_0 (N) + Old_Size, Slots.Last);\n+         Zero_Dynamic_Slots (Off_F (N) + Old_Size, Slots.Last);\n       end if;\n \n       Set_Node_Kind_Type (N, Nkind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n+\n+      New_Node_Debugging_Output (N);\n    end Mutate_Nkind;\n \n    procedure Mutate_Nkind (N : Node_Id; Val : Node_Kind) is\n    begin\n-      Mutate_Nkind (N, Val, Old_Size => Size_In_Slots (N));\n+      Mutate_Nkind (N, Val, Old_Size => Size_In_Slots_Dynamic (N));\n    end Mutate_Nkind;\n \n    Ekind_Offset : constant Field_Offset :=\n-     Entity_Field_Descriptors (F_Ekind).Offset;\n+     Field_Descriptors (F_Ekind).Offset;\n \n    procedure Set_Entity_Kind_Type is new Set_8_Bit_Field (Entity_Kind)\n      with Inline;\n@@ -993,6 +1051,8 @@ package body Atree is\n \n       Set_Entity_Kind_Type (N, Ekind_Offset, Val);\n       pragma Debug (Validate_Node_Write (N));\n+\n+      New_Node_Debugging_Output (N);\n    end Mutate_Ekind;\n \n    -----------------------\n@@ -1006,8 +1066,9 @@ package body Atree is\n             Sz : constant Slot_Count := Size_In_Slots_To_Alloc (Kind);\n             Sl : constant Node_Offset := Alloc_Slots (Sz);\n          begin\n-            Node_Offsets.Table (Result) := Sl;\n-            Zero_Slots (Sl, Sl + Sz - 1);\n+            Node_Offsets.Table (Result).Offset := Sl - Seinfo.N_Head;\n+            Zero_Dynamic_Slots (Sl, Sl + Sz - 1);\n+            Zero_Header_Slots (Result);\n          end;\n \n          Init_Nkind (Result, Kind);\n@@ -1045,7 +1106,7 @@ package body Atree is\n       pragma Assert (Nkind (N) not in N_Entity);\n       pragma Assert (New_Kind not in N_Entity);\n \n-      Old_Size : constant Slot_Count := Size_In_Slots (N);\n+      Old_Size : constant Slot_Count := Size_In_Slots_Dynamic (N);\n       New_Size : constant Slot_Count := Size_In_Slots_To_Alloc (New_Kind);\n \n       Save_Sloc    : constant Source_Ptr := Sloc (N);\n@@ -1068,15 +1129,16 @@ package body Atree is\n             New_Offset : constant Field_Offset := Alloc_Slots (New_Size);\n          begin\n             pragma Debug (Zero_Slots (N));\n-            Node_Offsets.Table (N) := New_Offset;\n-            Zero_Slots (New_Offset, New_Offset + New_Size - 1);\n+            Node_Offsets.Table (N).Offset := New_Offset - Seinfo.N_Head;\n+            Zero_Dynamic_Slots (New_Offset, New_Offset + New_Size - 1);\n+            Zero_Header_Slots (N);\n          end;\n \n       else\n          Zero_Slots (N);\n       end if;\n \n-      Mutate_Nkind (N, New_Kind, Old_Size);\n+      Init_Nkind (N, New_Kind); -- Not Mutate, because of Zero_Slots above\n \n       Set_Sloc (N, Save_Sloc);\n       Set_In_List (N, Save_In_List);\n@@ -1095,8 +1157,10 @@ package body Atree is\n    -- Copy_Slots --\n    ----------------\n \n-   procedure Copy_Slots (From, To : Node_Offset; Num_Slots : Slot_Count) is\n-      pragma Assert (From /= To);\n+   procedure Copy_Dynamic_Slots\n+     (From, To : Node_Offset; Num_Slots : Slot_Count)\n+   is\n+      pragma Assert (if Num_Slots /= 0 then From /= To);\n \n       All_Slots : Slots.Table_Type renames\n         Slots.Table (Slots.First .. Slots.Last);\n@@ -1109,21 +1173,21 @@ package body Atree is\n \n    begin\n       Destination_Slots := Source_Slots;\n-   end Copy_Slots;\n+   end Copy_Dynamic_Slots;\n \n    procedure Copy_Slots (Source, Destination : Node_Id) is\n       pragma Debug (Validate_Node (Source));\n-      pragma Debug (Validate_Node_Write (Destination));\n       pragma Assert (Source /= Destination);\n \n-      S_Size : constant Slot_Count := Size_In_Slots (Source);\n+      S_Size : constant Slot_Count := Size_In_Slots_Dynamic (Source);\n \n       All_Node_Offsets : Node_Offsets.Table_Type renames\n         Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n \n    begin\n-      Copy_Slots\n-        (All_Node_Offsets (Source), All_Node_Offsets (Destination), S_Size);\n+      Copy_Dynamic_Slots\n+        (Off_F (Source), Off_F (Destination), S_Size);\n+      All_Node_Offsets (Destination).Slots := All_Node_Offsets (Source).Slots;\n    end Copy_Slots;\n \n    ---------------\n@@ -1152,14 +1216,14 @@ package body Atree is\n \n       if D_Size < S_Size then\n          pragma Debug (Zero_Slots (Destination)); -- destroy old slots\n-         Node_Offsets.Table (Destination) := Alloc_Slots (S_Size);\n+         Node_Offsets.Table (Destination).Offset :=\n+           Alloc_Slots (S_Size) - Seinfo.N_Head;\n       end if;\n \n       Copy_Slots (Source, Destination);\n \n       Set_In_List (Destination, Save_In_List);\n       Set_Link (Destination, Save_Link);\n-\n       Set_Paren_Count_Of_Copy (Target => Destination, Source => Source);\n    end Copy_Node;\n \n@@ -1371,7 +1435,7 @@ package body Atree is\n         (Is_Entity (E1) and then Is_Entity (E2)\n            and then not In_List (E1) and then not In_List (E2));\n \n-      Old_E1 : constant Node_Offset := Node_Offsets.Table (E1);\n+      Old_E1 : constant Seinfo.Node_Header := Node_Offsets.Table (E1);\n \n    begin\n       Node_Offsets.Table (E1) := Node_Offsets.Table (E2);\n@@ -1404,6 +1468,7 @@ package body Atree is\n       pragma Assert (not Is_Entity (Source));\n \n       Old_Kind : constant Node_Kind := Nkind (Source);\n+      pragma Assert (Old_Kind in N_Direct_Name);\n       New_Kind : constant Node_Kind :=\n         (case Old_Kind is\n            when N_Character_Literal => N_Defining_Character_Literal,\n@@ -1469,8 +1534,9 @@ package body Atree is\n    begin\n       for J in Fields'Range loop\n          declare\n+            use Seinfo;\n             Desc : Field_Descriptor renames\n-              Node_Field_Descriptors (Fields (J));\n+              Field_Descriptors (Fields (J));\n          begin\n             if Desc.Kind in Node_Id_Field | List_Id_Field then\n                Fix_Parent (Get_Node_Field_Union (Fix_Node, Desc.Offset));\n@@ -1620,7 +1686,8 @@ package body Atree is\n       end if;\n \n       return New_Id : constant Node_Id := Alloc_Node_Id do\n-         Node_Offsets.Table (New_Id) := Alloc_Slots (S_Size);\n+         Node_Offsets.Table (New_Id).Offset :=\n+           Alloc_Slots (S_Size) - Seinfo.N_Head;\n          Orig_Nodes.Append (New_Id);\n          Copy_Slots (Source, New_Id);\n \n@@ -1676,7 +1743,7 @@ package body Atree is\n       --  source nodes, then reset Current_Error_Node. This is useful\n       --  if we bomb during parsing to get a error location for the bomb.\n \n-      if  New_Sloc > No_Location and then Comes_From_Source_Default then\n+      if New_Sloc > No_Location and then Comes_From_Source_Default then\n          Current_Error_Node := New_Id;\n       end if;\n \n@@ -1765,15 +1832,24 @@ package body Atree is\n    -- Off_0 --\n    -----------\n \n-   function Off_0 (N : Node_Id) return Node_Offset is\n+   function Off_0 (N : Node_Id) return Node_Offset'Base is\n       pragma Debug (Validate_Node (N));\n \n       All_Node_Offsets : Node_Offsets.Table_Type renames\n         Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n    begin\n-      return All_Node_Offsets (N);\n+      return All_Node_Offsets (N).Offset;\n    end Off_0;\n \n+   -----------\n+   -- Off_F --\n+   -----------\n+\n+   function Off_F (N : Node_Id) return Node_Offset is\n+   begin\n+      return Off_0 (N) + Seinfo.N_Head;\n+   end Off_F;\n+\n    -----------\n    -- Off_L --\n    -----------\n@@ -1784,7 +1860,7 @@ package body Atree is\n       All_Node_Offsets : Node_Offsets.Table_Type renames\n         Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n    begin\n-      return All_Node_Offsets (N) + Size_In_Slots (N) - 1;\n+      return All_Node_Offsets (N).Offset + Size_In_Slots (N) - 1;\n    end Off_L;\n \n    -------------------\n@@ -1855,28 +1931,6 @@ package body Atree is\n       Set_Comes_From_Source (NewN, Comes_From_Source (OldN));\n    end Preserve_Comes_From_Source;\n \n-   ----------------------\n-   -- Print_Atree_Info --\n-   ----------------------\n-\n-   procedure Print_Atree_Info (N : Node_Or_Entity_Id) is\n-      function Cast is new Unchecked_Conversion (Slot, Int);\n-   begin\n-      Write_Int (Int (Size_In_Slots (N)));\n-      Write_Str (\" slots (\");\n-      Write_Int (Int (Off_0 (N)));\n-      Write_Str (\" .. \");\n-      Write_Int (Int (Off_L (N)));\n-      Write_Str (\"):\");\n-\n-      for Off in Off_0 (N) .. Off_L (N) loop\n-         Write_Str (\" \");\n-         Write_Int (Cast (Slots.Table (Off)));\n-      end loop;\n-\n-      Write_Eol;\n-   end Print_Atree_Info;\n-\n    -------------------\n    -- Relocate_Node --\n    -------------------\n@@ -1926,7 +1980,7 @@ package body Atree is\n       procedure Destroy_New_Node is\n       begin\n          Zero_Slots (New_Node);\n-         Node_Offsets.Table (New_Node) := Field_Offset'Base'Last;\n+         Node_Offsets.Table (New_Node).Offset := Field_Offset'Base'Last;\n       end Destroy_New_Node;\n \n    begin\n@@ -2182,11 +2236,15 @@ package body Atree is\n       Rewriting_Proc := Proc;\n    end Set_Rewriting_Proc;\n \n+   ----------------------------\n+   -- Size_In_Slots_To_Alloc --\n+   ----------------------------\n+\n    function Size_In_Slots_To_Alloc (Kind : Node_Kind) return Slot_Count is\n    begin\n       return\n         (if Kind in N_Entity then Einfo.Entities.Max_Entity_Size\n-         else Sinfo.Nodes.Size (Kind));\n+         else Sinfo.Nodes.Size (Kind)) - Seinfo.N_Head;\n       --  Unfortunately, we don't know the Entity_Kind, so we have to use the\n       --  max.\n    end Size_In_Slots_To_Alloc;\n@@ -2197,6 +2255,10 @@ package body Atree is\n       return Size_In_Slots_To_Alloc (Nkind (N));\n    end Size_In_Slots_To_Alloc;\n \n+   -------------------\n+   -- Size_In_Slots --\n+   -------------------\n+\n    function Size_In_Slots (N : Node_Or_Entity_Id) return Slot_Count is\n    begin\n       pragma Assert (Nkind (N) /= N_Unused_At_Start);\n@@ -2205,6 +2267,15 @@ package body Atree is\n          else Sinfo.Nodes.Size (Nkind (N)));\n    end Size_In_Slots;\n \n+   ---------------------------\n+   -- Size_In_Slots_Dynamic --\n+   ---------------------------\n+\n+   function Size_In_Slots_Dynamic (N : Node_Or_Entity_Id) return Slot_Count is\n+   begin\n+      return Size_In_Slots (N) - Seinfo.N_Head;\n+   end Size_In_Slots_Dynamic;\n+\n    -------------------\n    -- Traverse_Func --\n    -------------------\n@@ -2372,14 +2443,22 @@ package body Atree is\n    -- Zero_Slots --\n    ----------------\n \n-   procedure Zero_Slots (First, Last : Node_Offset) is\n+   procedure Zero_Dynamic_Slots (First, Last : Node_Offset'Base) is\n    begin\n       Slots.Table (First .. Last) := (others => 0);\n-   end Zero_Slots;\n+   end Zero_Dynamic_Slots;\n+\n+   procedure Zero_Header_Slots (N : Node_Or_Entity_Id) is\n+      All_Node_Offsets : Node_Offsets.Table_Type renames\n+        Node_Offsets.Table (Node_Offsets.First .. Node_Offsets.Last);\n+   begin\n+      All_Node_Offsets (N).Slots := (others => 0);\n+   end Zero_Header_Slots;\n \n    procedure Zero_Slots (N : Node_Or_Entity_Id) is\n    begin\n-      Zero_Slots (Off_0 (N), Off_L (N));\n+      Zero_Dynamic_Slots (Off_F (N), Off_L (N));\n+      Zero_Header_Slots (N);\n    end Zero_Slots;\n \n end Atree;"}, {"sha": "8836bb84e1accb98fbd2a742ef79a8c9bd6cefad", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -48,6 +48,7 @@ with Alloc;\n with Sinfo.Nodes;    use Sinfo.Nodes;\n with Einfo.Entities; use Einfo.Entities;\n with Types;          use Types;\n+with Seinfo;\n with System;         use System;\n with Table;\n with Unchecked_Conversion;\n@@ -566,10 +567,9 @@ package Atree is\n \n    type Entity_Field_Set is array (Entity_Field) of Boolean with Pack;\n \n-   procedure Reinit_Field_To_Zero (N : Node_Id; Field : Node_Field);\n-   procedure Reinit_Field_To_Zero (N : Node_Id; Field : Entity_Field);\n+   procedure Reinit_Field_To_Zero (N : Node_Id; Field : Node_Or_Entity_Field);\n    --  When a node is created, all fields are initialized to zero, even if zero\n-   --  is not a valid value of the field type. These procedures put the field\n+   --  is not a valid value of the field type. This procedure puts the field\n    --  back to its initial zero value. Note that you can't just do something\n    --  like Set_Some_Field (N, 0), if Some_Field is of (say) type Uintp,\n    --  because Uintp is a subrange that does not include 0.\n@@ -583,9 +583,7 @@ package Atree is\n    --  this.\n \n    function Field_Is_Initial_Zero\n-     (N : Node_Id; Field : Node_Field) return Boolean;\n-   function Field_Is_Initial_Zero\n-     (N : Entity_Id; Field : Entity_Field) return Boolean;\n+     (N : Node_Id; Field : Node_Or_Entity_Field) return Boolean;\n    --  True if the field value is the initial zero value\n \n    procedure Mutate_Nkind (N : Node_Id; Val : Node_Kind) with Inline;\n@@ -611,10 +609,6 @@ package Atree is\n    --  always the same; for example we change from E_Void, to E_Variable, to\n    --  E_Void, to E_Constant.\n \n-   procedure Print_Atree_Info (N : Node_Or_Entity_Id);\n-   --  Called from Treepr to print out information about N that is private to\n-   --  Atree.\n-\n    -----------------------------\n    -- Private Part Subpackage --\n    -----------------------------\n@@ -639,7 +633,7 @@ package Atree is\n       --  The nodes of the tree are stored in two tables (i.e. growable\n       --  arrays).\n \n-      --  A Node_Id points to an element of Nodes, which contains a\n+      --  A Node_Id points to an element of Node_Offsets, which contains a\n       --  Field_Offset that points to an element of Slots. Each slot can\n       --  contain a single 32-bit field, or multiple smaller fields.\n       --  An n-bit field is aligned on an n-bit boundary. The size of a node is\n@@ -649,12 +643,21 @@ package Atree is\n       --  The reason for the extra level of indirection is that Copy_Node,\n       --  Exchange_Entities, and Rewrite all assume that nodes can be modified\n       --  in place.\n-\n-      subtype Node_Offset is Field_Offset'Base\n-        range 1 .. Field_Offset'Base'Last;\n+      --\n+      --  As an optimization, we store a few slots directly in the Node_Offsets\n+      --  table (see type Node_Header) rather than requiring the extra level of\n+      --  indirection for accessing those slots. N_Head is the number of slots\n+      --  stored in the Node_Header. N_Head can be adjusted by modifying\n+      --  Gen_IL.Gen. If N_Head is (say) 3, then a node containing 7 slots will\n+      --  have slots 0..2 in the header, and 3..6 stored indirect in the Slots\n+      --  table. We use zero-origin addressing, so the Offset into the Slots\n+      --  table will point 3 slots before slot 3.\n+\n+      pragma Assert (Seinfo.N_Head <= Min_Node_Size);\n+      pragma Assert (Seinfo.N_Head <= Min_Entity_Size);\n \n       package Node_Offsets is new Table.Table\n-        (Table_Component_Type => Node_Offset,\n+        (Table_Component_Type => Seinfo.Node_Header,\n          Table_Index_Type     => Node_Id'Base,\n          Table_Low_Bound      => First_Node_Id,\n          Table_Initial        => Alloc.Node_Offsets_Initial,\n@@ -668,14 +671,11 @@ package Atree is\n       --  Short names for use in gdb, not used in real code. Note that gdb\n       --  can't find Node_Offsets.Table without a full expanded name.\n \n-      --  We define the type Slot as a 32-bit modular integer. It is logically\n-      --  split into the appropriate numbers of components of appropriate size,\n-      --  but this splitting is not explicit because packed arrays cannot be\n-      --  properly interfaced in C/C++ and packed records are way too slow.\n-\n-      Slot_Size : constant := 32;\n-      type Slot is mod 2**Slot_Size;\n-      for Slot'Size use Slot_Size;\n+      --  The type Slot is defined in Types as a 32-bit modular integer. It\n+      --  is logically split into the appropriate numbers of components of\n+      --  appropriate size, but this splitting is not explicit because packed\n+      --  arrays cannot be properly interfaced in C/C++ and packed records are\n+      --  way too slow.\n \n       function Shift_Left (S : Slot; V : Natural) return Slot;\n       pragma Import (Intrinsic, Shift_Left);\n@@ -856,6 +856,10 @@ package Atree is\n       function Is_Valid_Node (U : Union_Id) return Boolean;\n       --  True if U is within the range of Node_Offsets\n \n+      procedure Print_Atree_Info (N : Node_Or_Entity_Id);\n+      --  Called from Treepr to print out information about N that is private\n+      --  to Atree.\n+\n    end Atree_Private_Part;\n \n end Atree;"}, {"sha": "7fb3bcbc28782b7a71335218a01ecdb6b8a13360", "filename": "gcc/ada/atree.h", "status": "modified", "additions": 0, "deletions": 71, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fatree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.h?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -65,77 +65,6 @@ Present (Tree_Id N)\n #define Current_Error_Node atree__current_error_node\n extern Node_Id Current_Error_Node;\n \n-/* The following code corresponds to the Get_n_Bit_Field functions (for\n-   various n) in package Atree.  The low-level getters in sinfo.h call\n-   these even-lower-level getters.  */\n-\n-extern Field_Offset *Node_Offsets_Ptr;\n-extern any_slot *Slots_Ptr;\n-\n-INLINE unsigned int Get_1_Bit_Field (Node_Id, Field_Offset);\n-INLINE unsigned int Get_2_Bit_Field (Node_Id, Field_Offset);\n-INLINE unsigned int Get_4_Bit_Field (Node_Id, Field_Offset);\n-INLINE unsigned int Get_8_Bit_Field (Node_Id, Field_Offset);\n-INLINE unsigned int Get_32_Bit_Field (Node_Id, Field_Offset);\n-INLINE unsigned int Get_32_Bit_Field_With_Default (Node_Id, Field_Offset,\n-\t\t\t\t\t\t   unsigned int);\n-INLINE unsigned int Get_Valid_32_Bit_Field (Node_Id, Field_Offset);\n-\n-INLINE unsigned int\n-Get_1_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  const Field_Offset L = Slot_Size / 1;\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n-  return (slot >> (Offset % L) * (Slot_Size / L)) & 1;\n-}\n-\n-INLINE unsigned int\n-Get_2_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  const Field_Offset L = Slot_Size / 2;\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n-  return (slot >> (Offset % L) * (Slot_Size / L)) & 3;\n-}\n-\n-INLINE unsigned int\n-Get_4_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  const Field_Offset L = Slot_Size / 4;\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n-  return (slot >> (Offset % L) * (Slot_Size / L)) & 15;\n-}\n-\n-INLINE unsigned int\n-Get_8_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  const Field_Offset L = Slot_Size / 8;\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset / L);\n-  return (slot >> (Offset % L) * (Slot_Size / L)) & 255;\n-}\n-\n-INLINE unsigned int\n-Get_32_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset);\n-  return slot;\n-}\n-\n-INLINE unsigned int\n-Get_32_Bit_Field_With_Default (Node_Id N, Field_Offset Offset,\n-\t\t\t       unsigned int Default_Value)\n-{\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset);\n-  return slot == Empty ? Default_Value : slot;\n-}\n-\n-INLINE unsigned int\n-Get_Valid_32_Bit_Field (Node_Id N, Field_Offset Offset)\n-{\n-  any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[N] + Offset);\n-  gcc_assert (slot != Empty);\n-  return slot;\n-}\n-\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "23e93c989d02d4b157cc3ed38332f9ef6f13300f", "filename": "gcc/ada/einfo-utils.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Feinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Feinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo-utils.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -364,7 +364,9 @@ package body Einfo.Utils is\n \n    function Known_Alignment (E : Entity_Id) return B is\n    begin\n-      return not Field_Is_Initial_Zero (E, F_Alignment);\n+      --  For some reason, Empty is passed to this sometimes\n+\n+      return No (E) or else not Field_Is_Initial_Zero (E, F_Alignment);\n    end Known_Alignment;\n \n    procedure Reinit_Alignment (Id : E) is"}, {"sha": "3488ae4bb82a12a172e51965d3780a6088808aba", "filename": "gcc/ada/gcc-interface/cuintp.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Fcuintp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fcuintp.c?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -40,6 +40,7 @@\n #include \"types.h\"\n #include \"uintp.h\"\n #include \"ada-tree.h\"\n+#include \"sinfo.h\"\n #include \"gigi.h\"\n \n /* Universal integers are represented by the Uint type which is an index into"}, {"sha": "692ef44dabf4a07e0e678a99f6f45521460857d1", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -234,7 +234,7 @@ extern \"C\" {\n extern void gigi (Node_Id gnat_root,\n \t          int max_gnat_node,\n \t\t  int number_name,\n-\t\t  Field_Offset *node_offsets_ptr,\n+\t\t  Node_Header *node_offsets_ptr,\n \t\t  any_slot *slots_ptr,\n \t\t  Node_Id *next_node_ptr,\n \t\t  Node_Id *prev_node_ptr,"}, {"sha": "6a3c0f2275db75c406b3b172e80fc5a011b925bf", "filename": "gcc/ada/gcc-interface/targtyps.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftargtyps.c?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -35,6 +35,7 @@\n #include \"ada.h\"\n #include \"types.h\"\n #include \"ada-tree.h\"\n+#include \"sinfo.h\"\n #include \"gigi.h\"\n \n /* If we don't have a specific size for Ada's equivalent of `long', use that"}, {"sha": "158bfe35f7b8efb35c9e6541d130e15dff28016b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -75,7 +75,7 @@\n #define ALLOCA_THRESHOLD 1000\n \n /* Pointers to front-end tables accessed through macros.  */\n-Field_Offset *Node_Offsets_Ptr;\n+Node_Header *Node_Offsets_Ptr;\n any_slot *Slots_Ptr;\n Node_Id *Next_Node_Ptr;\n Node_Id *Prev_Node_Ptr;\n@@ -279,7 +279,7 @@ void\n gigi (Node_Id gnat_root,\n       int max_gnat_node,\n       int number_name ATTRIBUTE_UNUSED,\n-      Field_Offset *node_offsets_ptr,\n+      Node_Header *node_offsets_ptr,\n       any_slot *slots_ptr,\n       Node_Id *next_node_ptr,\n       Node_Id *prev_node_ptr,"}, {"sha": "95fb526f5f2e26cf23af894ec70d99f5c7d21563", "filename": "gcc/ada/gen_il-gen.adb", "status": "modified", "additions": 326, "deletions": 222, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgen_il-gen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fgen_il-gen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgen_il-gen.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -28,6 +28,20 @@ with Ada.Text_IO;\n \n package body Gen_IL.Gen is\n \n+   Num_Header_Slots : constant := 3;\n+   --  Number of header slots; the first Num_Header_Slots slots are stored in\n+   --  the header; the rest are dynamically allocated in the Slots table. We\n+   --  need to subtract this off when accessing dynamic slots. The constant\n+   --  Seinfo.N_Head will contain this value.\n+   --\n+   --  This number can be adjusted for efficiency. We choose 3 because the\n+   --  minimum node size is 3 slots, and because that causes the size of type\n+   --  Node_Header to be a power of 2. We can't make it zero, however, because\n+   --  C doesn't allow zero-length arrays.\n+\n+   N_Head : constant String := Image (Field_Offset'(Num_Header_Slots));\n+   --  String form of the above\n+\n    Enable_Assertions : constant Boolean := True;\n    --  True to enable predicates on the _Id types, and preconditions on getters\n    --  and setters.\n@@ -37,6 +51,9 @@ package body Gen_IL.Gen is\n    --  which results in enormous nodes. For experimenting and debugging.\n    --  Should be True in normal operation, for efficiency.\n \n+   SS : constant := 32; -- slot size in bits\n+   SSS : constant String := Image (Bit_Offset'(SS));\n+\n    Inline : constant String := \"Inline\";\n    --  For experimenting with Inline_Always\n \n@@ -563,6 +580,8 @@ package body Gen_IL.Gen is\n       procedure Put_Setter_Spec (S : in out Sink; F : Field_Enum);\n       procedure Put_Getter_Decl (S : in out Sink; F : Field_Enum);\n       procedure Put_Setter_Decl (S : in out Sink; F : Field_Enum);\n+      procedure Put_Getter_Setter_Locals\n+        (S : in out Sink; F : Field_Enum; Get : Boolean);\n       procedure Put_Getter_Body (S : in out Sink; F : Field_Enum);\n       procedure Put_Setter_Body (S : in out Sink; F : Field_Enum);\n       --  Print out the specification, declaration, or body of a getter or\n@@ -573,9 +592,9 @@ package body Gen_IL.Gen is\n       --  Print out the precondition, if any, for a getter or setter for the\n       --  given field.\n \n-      procedure Put_Low_Level_Accessor_Instantiations\n+      procedure Put_Casts\n         (S : in out Sink; T : Type_Enum);\n-      --  Print out the low-level getter and setter for a given type\n+      --  Print out the Cast functions for a given type\n \n       procedure Put_Traversed_Fields (S : in out Sink);\n       --  Called by Put_Nodes to print out the Traversed_Fields table in\n@@ -616,19 +635,14 @@ package body Gen_IL.Gen is\n       --  corresponding to the Ada Node_Kind, Entity_Kind, and subtypes\n       --  thereof.\n \n-      procedure Put_Low_Level_C_Getter\n-        (S : in out Sink; T : Type_Enum);\n-      --  Used by Put_Sinfo_Dot_H and Put_Einfo_Dot_H to print out low-level\n-      --  getters.\n-\n-      procedure Put_High_Level_C_Getters\n+      procedure Put_C_Getters\n         (S : in out Sink; Root : Root_Type);\n       --  Used by Put_Sinfo_Dot_H and Put_Einfo_Dot_H to print out high-level\n       --  getters.\n \n-      procedure Put_High_Level_C_Getter\n+      procedure Put_C_Getter\n         (S : in out Sink; F : Field_Enum);\n-      --  Used by Put_High_Level_C_Getters to print out one high-level getter.\n+      --  Used by Put_C_Getters to print out one high-level getter.\n \n       procedure Put_Union_Membership\n         (S : in out Sink; Root : Root_Type);\n@@ -884,13 +898,13 @@ package body Gen_IL.Gen is\n \n       function To_Size_In_Slots (Size_In_Bits : Bit_Offset)\n         return Field_Offset is\n-          ((Field_Offset (Size_In_Bits) + 31) / 32);\n+          ((Field_Offset (Size_In_Bits) + (SS - 1)) / SS);\n \n       function Type_Size_In_Slots (T : Concrete_Type) return Field_Offset is\n         (To_Size_In_Slots (Type_Bit_Size (T))); -- rounded up to slot boundary\n \n       function Type_Bit_Size_Aligned (T : Concrete_Type) return Bit_Offset is\n-        (Bit_Offset (Type_Size_In_Slots (T)) * 32); -- multiple of slot size\n+        (Bit_Offset (Type_Size_In_Slots (T)) * SS); -- multiple of slot size\n \n       ---------------------------\n       -- Compute_Field_Offsets --\n@@ -1289,7 +1303,10 @@ package body Gen_IL.Gen is\n                   end if;\n                end loop;\n \n-               Type_Bit_Size (T) := Max_Offset + 1;\n+               --  No type can be smaller than the header slots\n+\n+               Type_Bit_Size (T) :=\n+                 Bit_Offset'Max (Max_Offset + 1, SS * Num_Header_Slots);\n             end;\n          end loop;\n \n@@ -1596,57 +1613,25 @@ package body Gen_IL.Gen is\n            (if Setter_Needs_Parent (F) then \"_With_Parent\" else \"\"));\n \n       -------------------------------------------\n-      -- Put_Low_Level_Accessor_Instantiations --\n+      -- Put_Casts --\n       -------------------------------------------\n \n-      procedure Put_Low_Level_Accessor_Instantiations\n+      procedure Put_Casts\n         (S : in out Sink; T : Type_Enum)\n       is\n+         Pre : constant String :=\n+           \"function Cast is new Unchecked_Conversion (\";\n+         Lo_Type : constant String := \"Field_Size_\" & Image (Field_Size (T)) & \"_Bit\";\n+         Hi_Type : constant String := Get_Set_Id_Image (T);\n       begin\n-         --  Special case for subtypes of Uint that have predicates. Use\n-         --  Get_Valid_32_Bit_Field in that case.\n-\n-         if T in Uint_Subtype then\n-            pragma Assert (Field_Size (T) = 32);\n-            Put (S, LF & \"function \" & Low_Level_Getter_Name (T) &\n-                 \" is new Get_Valid_32_Bit_Field (\" &\n-                 Get_Set_Id_Image (T) &\n-                 \") with \" & Inline & \";\" & LF);\n-\n-         --  Special case for types that have special defaults; instantiate\n-         --  Get_32_Bit_Field_With_Default and pass in the Default_Val.\n-\n-         elsif Field_Has_Special_Default (T) then\n-            pragma Assert (Field_Size (T) = 32);\n-            Put (S, LF & \"function \" & Low_Level_Getter_Name (T) &\n-                 \" is new Get_32_Bit_Field_With_Default (\" &\n-                 Get_Set_Id_Image (T) & \", \" & Special_Default (T) &\n-                 \") with \" & Inline & \";\" & LF);\n-\n-         --  Otherwise, instantiate the normal getter for the right size in\n-         --  bits.\n-\n-         else\n-            Put (S, LF & \"function \" & Low_Level_Getter_Name (T) &\n-                 \" is new Get_\" & Image (Field_Size (T)) & \"_Bit_Field (\" &\n-                 Get_Set_Id_Image (T) & \") with \" & Inline & \";\" & LF);\n-         end if;\n-\n-         if T in Node_Kind_Type | Entity_Kind_Type then\n-            Put (S, \"pragma Warnings (Off);\" & LF);\n-            --  Set_Node_Kind_Type and Set_Entity_Kind_Type might not be called\n-         end if;\n-\n-         --  No special cases for the setter\n-\n-         Put (S, \"procedure \" & Low_Level_Setter_Name (T) & \" is new Set_\" &\n-                 Image (Field_Size (T)) & \"_Bit_Field (\" & Get_Set_Id_Image (T) &\n-                 \") with \" & Inline & \";\" & LF);\n+         if T not in Uint_Subtype then\n+            if T not in Node_Kind_Type | Entity_Kind_Type then\n+               Put (S, Pre & Hi_Type & \", \" & Lo_Type & \");\" & LF);\n+            end if;\n \n-         if T in Node_Kind_Type | Entity_Kind_Type then\n-            Put (S, \"pragma Warnings (On);\" & LF);\n+            Put (S, Pre & Lo_Type & \", \" & Hi_Type & \");\" & LF);\n          end if;\n-      end Put_Low_Level_Accessor_Instantiations;\n+      end Put_Casts;\n \n       ----------------------\n       -- Put_Precondition --\n@@ -1753,12 +1738,64 @@ package body Gen_IL.Gen is\n          Put (S, \";\" & LF);\n       end Put_Getter_Decl;\n \n+      ------------------------------\n+      -- Put_Getter_Setter_Locals --\n+      ------------------------------\n+\n+      procedure Put_Getter_Setter_Locals\n+        (S : in out Sink; F : Field_Enum; Get : Boolean)\n+      is\n+         Rec : Field_Info renames Field_Table (F).all;\n+\n+         Off : constant Field_Offset := Rec.Offset;\n+         F_Size : constant Bit_Offset := Field_Size (Rec.Field_Type);\n+         F_Per_Slot : constant Field_Offset :=\n+           SS / Field_Offset (Field_Size (Rec.Field_Type));\n+         Slot_Off : constant Field_Offset := Off / F_Per_Slot;\n+         In_NH : constant Boolean := Slot_Off < Num_Header_Slots;\n+\n+         N : constant String :=\n+           (if Get then Node_To_Fetch_From (F) else \"N\");\n+\n+      begin\n+         Put (S, \" is\" & LF);\n+         Increase_Indent (S, 3);\n+         Put (S, \"--  \" & Image (F_Per_Slot) & \"  \" & Image (F_Size) &\n+                \"-bit fields per \" & SSS & \"-bit slot.\" & LF);\n+         Put (S, \"--  Offset \" & Image (Off) & \" = \" &\n+                Image (Slot_Off) & \" slots + \" & Image (Off mod F_Per_Slot) &\n+                \" fields in slot.\" & LF & LF);\n+\n+         Put (S, \"Off : constant := \" & Image (Off) & \";\" & LF);\n+         Put (S, \"F_Size : constant := \" & Image (F_Size) & \";\" & LF);\n+\n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"Mask : constant := 2**F_Size - 1;\" & LF);\n+         end if;\n+\n+         Put (S, \"F_Per_Slot : constant Field_Offset := Slot_Size / F_Size;\" & LF);\n+         Put (S, \"Slot_Off : constant Field_Offset := Off / F_Per_Slot;\" & LF);\n+\n+         if In_NH then\n+            Put (S, \"S : Slot renames Node_Offsets.Table (\" & N & \").Slots (Slot_Off);\" & LF);\n+         else\n+            Put (S, \"S : Slot renames Slots.Table (Node_Offsets.Table (\" & N & \").Offset + Slot_Off);\" & LF);\n+         end if;\n+\n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"V : constant Natural := Natural ((Off mod F_Per_Slot) * F_Size);\" & LF);\n+            Put (S, LF);\n+         end if;\n+      end Put_Getter_Setter_Locals;\n+\n       ---------------------\n       -- Put_Getter_Body --\n       ---------------------\n \n       procedure Put_Getter_Body (S : in out Sink; F : Field_Enum) is\n          Rec : Field_Info renames Field_Table (F).all;\n+         F_Size : constant Bit_Offset := Field_Size (Rec.Field_Type);\n+         T : constant String := Get_Set_Id_Image (Rec.Field_Type);\n       begin\n          --  Note that we store the result in a local constant below, so that\n          --  the \"Pre => ...\" can refer to it. The constant is called Val so\n@@ -1767,16 +1804,43 @@ package body Gen_IL.Gen is\n          --  and setter.\n \n          Put_Getter_Spec (S, F);\n-         Put (S, \" is\" & LF);\n-         Increase_Indent (S, 3);\n-         Put (S, \"Val : constant \" & Get_Set_Id_Image (Rec.Field_Type) &\n-              \" := \" & Low_Level_Getter_Name (Rec.Field_Type) &\n-              \" (\" & Node_To_Fetch_From (F) & \", \" &\n-              Image (Rec.Offset) & \");\" & LF);\n+         Put_Getter_Setter_Locals (S, F, Get => True);\n+\n+         Put (S, \"Raw : constant Field_Size_\" & Image (F_Size) & \"_Bit :=\" & LF);\n+         Increase_Indent (S, 2);\n+         Put (S, \"Field_Size_\" & Image (F_Size) & \"_Bit (\");\n+\n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"Shift_Right (S, V) and Mask);\" & LF);\n+         else\n+            Put (S, \"S);\" & LF);\n+         end if;\n+\n+         Decrease_Indent (S, 2);\n+\n+         Put (S, \"Val : constant \" & T & \" :=\");\n+\n+         if Field_Has_Special_Default (Rec.Field_Type) then\n+            pragma Assert (Field_Size (Rec.Field_Type) = 32);\n+            Put (S, LF);\n+            Increase_Indent (S, 2);\n+            Put (S, \"(if Raw = 0 then \" & Special_Default (Rec.Field_Type) & \" else \" & \"Cast (Raw));\");\n+            Decrease_Indent (S, 2);\n+\n+         else\n+            Put (S, \" Cast (Raw);\");\n+         end if;\n+\n+         Put (S, LF);\n+\n          Decrease_Indent (S, 3);\n          Put (S, \"begin\" & LF);\n          Increase_Indent (S, 3);\n \n+         Put (S, \"--  pragma Debug (Validate_Node_And_Offset (NN, Slot_Off));\" & LF);\n+         --  Comment out the validation, because it's too slow, and because the\n+         --  relevant routines in Atree are not visible.\n+\n          if Rec.Pre.all /= \"\" then\n             Put (S, \"pragma Assert (\" & Rec.Pre.all & \");\" & LF);\n          end if;\n@@ -1824,6 +1888,7 @@ package body Gen_IL.Gen is\n \n       procedure Put_Setter_Body (S : in out Sink; F : Field_Enum) is\n          Rec : Field_Info renames Field_Table (F).all;\n+         F_Size : constant Bit_Offset := Field_Size (Rec.Field_Type);\n \n          --  If Type_Only was specified in the call to Create_Semantic_Field,\n          --  then we assert that the node is a base type. We cannot assert that\n@@ -1836,10 +1901,18 @@ package body Gen_IL.Gen is\n                 \"Is_Base_Type (N)\");\n       begin\n          Put_Setter_Spec (S, F);\n-         Put (S, \" is\" & LF);\n+         Put_Getter_Setter_Locals (S, F, Get => False);\n+\n+         Put (S, \"Raw : constant Field_Size_\" & Image (F_Size) & \"_Bit := Cast (Val);\" & LF);\n+\n+         Decrease_Indent (S, 3);\n          Put (S, \"begin\" & LF);\n          Increase_Indent (S, 3);\n \n+         Put (S, \"--  pragma Debug (Validate_Node_And_Offset_Write (N, Slot_Off));\" & LF);\n+         --  Comment out the validation, because it's too slow, and because the\n+         --  relevant routines in Atree are not visible.\n+\n          if Rec.Pre.all /= \"\" then\n             Put (S, \"pragma Assert (\" & Rec.Pre.all & \");\" & LF);\n          end if;\n@@ -1852,8 +1925,28 @@ package body Gen_IL.Gen is\n             Put (S, \"pragma Assert (\" & Type_Only_Assertion & \");\" & LF);\n          end if;\n \n-         Put (S, Low_Level_Setter_Name (F) & \" (N, \" & Image (Rec.Offset)\n-              & \", Val);\" & LF);\n+         if Setter_Needs_Parent (F) then\n+            declare\n+               Err : constant String :=\n+                 (if Rec.Field_Type = List_Id then \"Error_List\" else \"Error\");\n+            begin\n+               Put (S, \"if Present (Val) and then Val /= \" & Err & \" then\" & LF);\n+               Increase_Indent (S, 3);\n+               Put (S, \"pragma Warnings (Off, \"\"actuals for this call may be in wrong order\"\");\" & LF);\n+               Put (S, \"Set_Parent (Val, N);\" & LF);\n+               Put (S, \"pragma Warnings (On, \"\"actuals for this call may be in wrong order\"\");\" & LF);\n+               Decrease_Indent (S, 3);\n+               Put (S, \"end if;\" & LF & LF);\n+            end;\n+         end if;\n+\n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"S := (S and not Shift_Left (Mask, V)) or Shift_Left (Slot (Raw), V);\" & LF);\n+\n+         else\n+            Put (S, \"S := Slot (Raw);\" & LF);\n+         end if;\n+\n          Decrease_Indent (S, 3);\n          Put (S, \"end Set_\" & Image (F) & \";\" & LF & LF);\n       end Put_Setter_Body;\n@@ -2076,7 +2169,7 @@ package body Gen_IL.Gen is\n               when others => \"Entity_Field\");  -- Entity_Kind\n \n       begin\n-         Put (S, \"--  Table of sizes in 32-bit slots for given \" &\n+         Put (S, \"--  Table of sizes in \" & SSS & \"-bit slots for given \" &\n               Image (Root) & \", for use by Atree:\" & LF);\n \n          case Root is\n@@ -2107,34 +2200,48 @@ package body Gen_IL.Gen is\n          Put (S, \"); -- Size\" & LF);\n          Decrease_Indent (S, 2);\n \n-         declare\n-            type Dummy is array\n-              (First_Field (Root) .. Last_Field (Root)) of Boolean;\n-            Num_Fields : constant Root_Int := Dummy'Length;\n-            First_Time : Boolean := True;\n-         begin\n-            Put (S, LF & \"--  Enumeration of all \" & Image (Num_Fields)\n-                 & \" fields:\" & LF & LF);\n+         if Root = Node_Kind then\n+            declare\n+               type Node_Dummy is array (Node_Field) of Boolean;\n+               type Entity_Dummy is array (Entity_Field) of Boolean;\n+               Num_Fields : constant Root_Int :=\n+                 Node_Dummy'Length + Entity_Dummy'Length;\n+               First_Time : Boolean := True;\n+            begin\n+               Put (S, LF & \"--  Enumeration of all \" & Image (Num_Fields)\n+                    & \" fields:\" & LF & LF);\n \n-            Put (S, \"type \" & Field_Enum_Type_Name & \" is\" & LF);\n-            Increase_Indent (S, 2);\n-            Put (S, \"(\");\n-            Increase_Indent (S, 1);\n+               Put (S, \"type Node_Or_Entity_Field is\" & LF);\n+               Increase_Indent (S, 2);\n+               Put (S, \"(\");\n+               Increase_Indent (S, 1);\n \n-            for F in First_Field (Root) .. Last_Field (Root) loop\n-               if First_Time then\n-                  First_Time := False;\n-               else\n+               for F in Node_Field loop\n+                  if First_Time then\n+                     First_Time := False;\n+                  else\n+                     Put (S, \",\" & LF);\n+                  end if;\n+\n+                  Put (S, F_Image (F));\n+               end loop;\n+\n+               for F in Entity_Field loop\n                   Put (S, \",\" & LF);\n-               end if;\n+                  Put (S, F_Image (F));\n+               end loop;\n \n-               Put (S, F_Image (F));\n-            end loop;\n+               Decrease_Indent (S, 1);\n+               Put (S, \"); -- Node_Or_Entity_Field\" & LF);\n+               Decrease_Indent (S, 2);\n+            end;\n+         end if;\n \n-            Decrease_Indent (S, 1);\n-            Put (S, \"); -- \" & Field_Enum_Type_Name & LF);\n-            Decrease_Indent (S, 2);\n-         end;\n+         Put (S, LF & \"subtype \" & Field_Enum_Type_Name & \" is\" & LF);\n+         Increase_Indent (S, 2);\n+         Put (S, \"Node_Or_Entity_Field range \" & F_Image (First_Field (Root)) &\n+                \" .. \" & F_Image (Last_Field (Root)) & \";\" & LF);\n+         Decrease_Indent (S, 2);\n \n          Put (S, LF & \"type \" & Field_Enum_Type_Name & \"_Index is new Pos;\" & LF);\n          Put (S, \"type \" & Field_Enum_Type_Name & \"_Array is array (\" &\n@@ -2193,34 +2300,43 @@ package body Gen_IL.Gen is\n             Decrease_Indent (S, 2);\n          end;\n \n-         declare\n-            First_Time : Boolean := True;\n-         begin\n-            Put (S, LF & \"--  Table mapping fields to kind and offset:\" & LF & LF);\n+         if Root = Node_Kind then\n+            declare\n+               First_Time : Boolean := True;\n+            begin\n+               Put (S, LF & \"--  Table mapping fields to kind and offset:\" & LF & LF);\n \n-            Put (S, Field_Enum_Type_Name & \"_Descriptors : constant array (\" &\n-                 Field_Enum_Type_Name & \") of Field_Descriptor :=\" & LF);\n+               Put (S, \"Field_Descriptors : constant array (\" &\n+                    \"Node_Or_Entity_Field) of Field_Descriptor :=\" & LF);\n \n-            Increase_Indent (S, 2);\n-            Put (S, \"(\");\n-            Increase_Indent (S, 1);\n+               Increase_Indent (S, 2);\n+               Put (S, \"(\");\n+               Increase_Indent (S, 1);\n \n-            for F in First_Field (Root) .. Last_Field (Root) loop\n-               if First_Time then\n-                  First_Time := False;\n-               else\n-                  Put (S, \",\" & LF);\n-               end if;\n+               for F in Node_Field loop\n+                  if First_Time then\n+                     First_Time := False;\n+                  else\n+                     Put (S, \",\" & LF);\n+                  end if;\n \n-               Put (S, F_Image (F) & \" => (\" &\n-                    Image (Field_Table (F).Field_Type) & \"_Field, \" &\n-                    Image (Field_Table (F).Offset) & \")\");\n-            end loop;\n+                  Put (S, F_Image (F) & \" => (\" &\n+                       Image (Field_Table (F).Field_Type) & \"_Field, \" &\n+                       Image (Field_Table (F).Offset) & \")\");\n+               end loop;\n \n-            Decrease_Indent (S, 1);\n-            Put (S, \"); -- Field_Descriptors\" & LF);\n-            Decrease_Indent (S, 2);\n-         end;\n+               for F in Entity_Field loop\n+                  Put (S, \",\" & LF);\n+                  Put (S, F_Image (F) & \" => (\" &\n+                       Image (Field_Table (F).Field_Type) & \"_Field, \" &\n+                       Image (Field_Table (F).Offset) & \")\");\n+               end loop;\n+\n+               Decrease_Indent (S, 1);\n+               Put (S, \"); -- Field_Descriptors\" & LF);\n+               Decrease_Indent (S, 2);\n+            end;\n+         end if;\n \n       end Put_Tables;\n \n@@ -2293,6 +2409,21 @@ package body Gen_IL.Gen is\n          Decrease_Indent (S, 3);\n          Put (S, \"end record;\" & LF);\n \n+         --  Print out the node header types. Note that the Offset field is of\n+         --  the base type, because we are using zero-origin addressing in\n+         --  Atree.\n+\n+         Put (S, \"N_Head : constant Field_Offset := \" & N_Head & \";\" & LF);\n+         Put (S, \"\" & LF);\n+         Put (S, \"type Node_Header_Slots is\" & LF);\n+         Put (S, \"  array (Field_Offset range 0 .. N_Head - 1) of aliased Slot;\" & LF);\n+         Put (S, \"type Node_Header is record\" & LF);\n+         Put (S, \"   Slots : Node_Header_Slots;\" & LF);\n+         Put (S, \"   Offset : Node_Offset'Base;\" & LF);\n+         Put (S, \"end record;\" & LF);\n+         Put (S, \"pragma Assert (Node_Header'Size = (\" & N_Head &\n+                \" + 1) * \" & SSS & \");\" & LF);\n+\n          Decrease_Indent (S, 3);\n          Put (S, LF & \"end Seinfo;\" & LF);\n       end Put_Seinfo;\n@@ -2305,39 +2436,6 @@ package body Gen_IL.Gen is\n          S : Sink;\n          B : Sink;\n \n-         procedure Put_Setter_With_Parent (Kind : String);\n-         --  Put the low-level ..._With_Parent setter. Kind is either \"Node\" or\n-         --  \"List\".\n-\n-         procedure Put_Setter_With_Parent (Kind : String) is\n-            Error : constant String := (if Kind = \"Node\" then \"\" else \"_\" & Kind);\n-         begin\n-            Put (B, LF & \"procedure Set_\" & Kind & \"_Id_With_Parent\" & LF);\n-            Increase_Indent (B, 2);\n-            Put (B, \"(N : Node_Id; Offset : Field_Offset; Val : \" & Kind & \"_Id);\" & LF & LF);\n-            Decrease_Indent (B, 2);\n-\n-            Put (B, \"procedure Set_\" & Kind & \"_Id_With_Parent\" & LF);\n-            Increase_Indent (B, 2);\n-            Put (B, \"(N : Node_Id; Offset : Field_Offset; Val : \" & Kind & \"_Id) is\" & LF);\n-            Decrease_Indent (B, 2);\n-            Put (B, \"begin\" & LF);\n-            Increase_Indent (B, 3);\n-            Put (B, \"if Present (Val) and then Val /= Error\" & Error & \" then\" & LF);\n-            Increase_Indent (B, 3);\n-            Put (B, \"pragma Warnings (Off, \"\"actuals for this call may be in wrong order\"\");\" & LF);\n-            Put (B, \"Set_Parent (Val, N);\" & LF);\n-            Put (B, \"pragma Warnings (On, \"\"actuals for this call may be in wrong order\"\");\" & LF);\n-            Decrease_Indent (B, 3);\n-            Put (B, \"end if;\" & LF & LF);\n-\n-            Put (B, \"Set_\" & Kind & \"_Id (N, Offset, Val);\" & LF);\n-            Decrease_Indent (B, 3);\n-            Put (B, \"end Set_\" & Kind & \"_Id_With_Parent;\" & LF);\n-         end Put_Setter_With_Parent;\n-\n-      --  Start of processing for Put_Nodes\n-\n       begin\n          Create_File (S, \"sinfo-nodes.ads\");\n          Create_File (B, \"sinfo-nodes.adb\");\n@@ -2369,6 +2467,7 @@ package body Gen_IL.Gen is\n          Decrease_Indent (S, 3);\n          Put (S, LF & \"end Sinfo.Nodes;\" & LF);\n \n+         Put (B, \"with Unchecked_Conversion;\" & LF);\n          Put (B, \"with Atree; use Atree; use Atree.Atree_Private_Part;\" & LF);\n          Put (B, \"with Nlists; use Nlists;\" & LF);\n          Put (B, \"pragma Warnings (Off);\" & LF);\n@@ -2381,19 +2480,14 @@ package body Gen_IL.Gen is\n \n          Put (B, \"--  This package is automatically generated.\" & LF & LF);\n \n-         Put (B, \"--  Instantiations of low-level getters and setters that take offsets\" & LF);\n-         Put (B, \"--  in units of the size of the field.\" & LF);\n-\n          Put (B, \"pragma Style_Checks (\"\"M200\"\");\" & LF);\n+\n          for T in Special_Type loop\n             if Node_Field_Types_Used (T) then\n-               Put_Low_Level_Accessor_Instantiations (B, T);\n+               Put_Casts (B, T);\n             end if;\n          end loop;\n \n-         Put_Setter_With_Parent (\"Node\");\n-         Put_Setter_With_Parent (\"List\");\n-\n          Put_Subp_Bodies (B, Node_Kind);\n \n          Decrease_Indent (B, 3);\n@@ -2411,7 +2505,6 @@ package body Gen_IL.Gen is\n       begin\n          Create_File (S, \"einfo-entities.ads\");\n          Create_File (B, \"einfo-entities.adb\");\n-         Put (S, \"with Seinfo; use Seinfo;\" & LF);\n          Put (S, \"with Sinfo.Nodes; use Sinfo.Nodes;\" & LF);\n \n          Put (S, LF & \"package Einfo.Entities is\" & LF & LF);\n@@ -2430,6 +2523,7 @@ package body Gen_IL.Gen is\n          Decrease_Indent (S, 3);\n          Put (S, LF & \"end Einfo.Entities;\" & LF);\n \n+         Put (B, \"with Unchecked_Conversion;\" & LF);\n          Put (B, \"with Atree; use Atree; use Atree.Atree_Private_Part;\" & LF);\n          Put (B, \"with Einfo.Utils; use Einfo.Utils;\" & LF);\n          --  This forms a cycle between packages (via bodies, which is OK)\n@@ -2439,13 +2533,11 @@ package body Gen_IL.Gen is\n \n          Put (B, \"--  This package is automatically generated.\" & LF & LF);\n \n-         Put (B, \"--  Instantiations of low-level getters and setters that take offsets\" & LF);\n-         Put (B, \"--  in units of the size of the field.\" & LF);\n-\n          Put (B, \"pragma Style_Checks (\"\"M200\"\");\" & LF);\n+\n          for T in Special_Type loop\n             if Entity_Field_Types_Used (T) then\n-               Put_Low_Level_Accessor_Instantiations (B, T);\n+               Put_Casts (B, T);\n             end if;\n          end loop;\n \n@@ -2714,11 +2806,11 @@ package body Gen_IL.Gen is\n             return Result : Bit_Offset do\n                if F = No_Field then\n                   --  We don't have a field size for No_Field, so just look at\n-                  --  the bits up to the next word boundary.\n+                  --  the bits up to the next slot boundary.\n \n                   Result := First_Bit;\n \n-                  while (Result + 1) mod 32 /= 0\n+                  while (Result + 1) mod SS /= 0\n                     and then Type_Layout (T) (Result + 1) = No_Field\n                   loop\n                      Result := Result + 1;\n@@ -2731,19 +2823,19 @@ package body Gen_IL.Gen is\n          end Get_Last_Bit;\n \n          function First_Bit_Image (First_Bit : Bit_Offset) return String is\n-            W : constant Bit_Offset := First_Bit / 32;\n-            B : constant Bit_Offset := First_Bit mod 32;\n-            pragma Assert (W * 32 + B = First_Bit);\n+            W : constant Bit_Offset := First_Bit / SS;\n+            B : constant Bit_Offset := First_Bit mod SS;\n+            pragma Assert (W * SS + B = First_Bit);\n          begin\n             return\n-              Image (W) & \"*32\" & (if B = 0 then \"\" else \" + \" & Image (B));\n+              Image (W) & \"*\" & SSS & (if B = 0 then \"\" else \" + \" & Image (B));\n          end First_Bit_Image;\n \n          function Last_Bit_Image (Last_Bit : Bit_Offset) return String is\n-            W : constant Bit_Offset := (Last_Bit + 1) / 32;\n+            W : constant Bit_Offset := (Last_Bit + 1) / SS;\n          begin\n-            if W * 32 - 1 = Last_Bit then\n-               return Image (W) & \"*32 - 1\";\n+            if W * SS - 1 = Last_Bit then\n+               return Image (W) & \"*\" & SSS & \" - 1\";\n             else\n                return First_Bit_Image (Last_Bit);\n             end if;\n@@ -3027,76 +3119,84 @@ package body Gen_IL.Gen is\n          Put_Union_Membership (S, Root);\n       end Put_C_Type_And_Subtypes;\n \n-      ----------------------------\n-      -- Put_Low_Level_C_Getter --\n-      ----------------------------\n+      ------------------\n+      -- Put_C_Getter --\n+      ------------------\n \n-      procedure Put_Low_Level_C_Getter\n-        (S : in out Sink; T : Type_Enum)\n+      procedure Put_C_Getter\n+        (S : in out Sink; F : Field_Enum)\n       is\n-         T_Image : constant String := Get_Set_Id_Image (T);\n+         Rec : Field_Info renames Field_Table (F).all;\n+\n+         Off : constant Field_Offset := Rec.Offset;\n+         F_Size : constant Bit_Offset := Field_Size (Rec.Field_Type);\n+         F_Per_Slot : constant Field_Offset :=\n+           SS / Field_Offset (Field_Size (Rec.Field_Type));\n+         Slot_Off : constant Field_Offset := Off / F_Per_Slot;\n+         In_NH : constant Boolean := Slot_Off < Num_Header_Slots;\n \n+         N : constant String := Node_To_Fetch_From (F);\n       begin\n-         Put (S, \"INLINE \" & T_Image & \"\" & LF);\n-         Put (S, \"Get_\" & Image (T) & \" (Node_Id N, Field_Offset Offset)\" & LF);\n+         Put (S, \"INLINE \" & Get_Set_Id_Image (Rec.Field_Type) &\n+              \" \" & Image (F) & \" (Node_Id N)\" & LF);\n \n+         Put (S, \"{\" & LF);\n          Increase_Indent (S, 3);\n+         Put (S, \"const Field_Offset Off = \" & Image (Rec.Offset) & \";\" & LF);\n+         Put (S, \"const Field_Offset F_Size = \" & Image (F_Size) & \";\" & LF);\n \n-         --  Same special cases for getters as in\n-         --  Put_Low_Level_Accessor_Instantiations.\n-\n-         if T in Uint_Subtype then\n-            pragma Assert (Field_Size (T) = 32);\n-            Put (S, \"{ return (\" & T_Image &\n-                 \") Get_Valid_32_Bit_Field(N, Offset); }\" & LF & LF);\n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"const any_slot Mask = (1 << F_Size) - 1;\" & LF);\n+         end if;\n \n-         elsif Field_Has_Special_Default (T) then\n-            pragma Assert (Field_Size (T) = 32);\n-            Put (S, \"{ return (\" & T_Image &\n-                 \") Get_32_Bit_Field_With_Default(N, Offset, \" &\n-                 Special_Default (T) & \"); }\" & LF & LF);\n+         Put (S, \"const Field_Offset F_Per_Slot = Slot_Size / F_Size;\" & LF);\n+         Put (S, \"const Field_Offset Slot_Off = Off / F_Per_Slot;\" & LF);\n+         Put (S, LF);\n+         if In_NH then\n+            Put (S, \"any_slot slot = Node_Offsets_Ptr[\" & N & \"].Slots[Slot_Off];\" & LF);\n+         else\n+            Put (S, \"any_slot slot = *(Slots_Ptr + Node_Offsets_Ptr[\" & N &\n+                   \"].Offset + Slot_Off);\" & LF);\n+         end if;\n \n+         if Field_Size (Rec.Field_Type) /= SS then\n+            Put (S, \"unsigned int Raw = (slot >> (Off % F_Per_Slot) * F_Size) & Mask;\" & LF);\n          else\n-            Put (S, \"{ return (\" & T_Image & \") Get_\" &\n-                 Image (Field_Size (T)) & \"_Bit_Field(N, Offset); }\" & LF & LF);\n+            Put (S, \"unsigned int Raw = slot;\" & LF);\n          end if;\n \n-         Decrease_Indent (S, 3);\n-      end Put_Low_Level_C_Getter;\n+         Put (S, Get_Set_Id_Image (Rec.Field_Type) & \" val = \");\n \n-      -----------------------------\n-      -- Put_High_Level_C_Getter --\n-      -----------------------------\n+         if Field_Has_Special_Default (Rec.Field_Type) then\n+            Increase_Indent (S, 2);\n+            Put (S, \"(Raw? Raw : \" & Special_Default (Rec.Field_Type) & \")\");\n+            Decrease_Indent (S, 2);\n \n-      procedure Put_High_Level_C_Getter\n-        (S : in out Sink; F : Field_Enum)\n-      is\n-      begin\n-         Put (S, \"INLINE \" & Get_Set_Id_Image (Field_Table (F).Field_Type) &\n-              \" \" & Image (F) & \" (Node_Id N)\" & LF);\n+         else\n+            Put (S, \"Raw\");\n+         end if;\n \n-         Increase_Indent (S, 3);\n-         Put (S, \"{ return \" &\n-              Low_Level_Getter_Name (Field_Table (F).Field_Type) &\n-              \"(\" & Node_To_Fetch_From (F) & \", \" &\n-              Image (Field_Table (F).Offset) & \"); }\" & LF & LF);\n+         Put (S, \";\" & LF);\n+\n+         Put (S, \"return val;\" & LF);\n          Decrease_Indent (S, 3);\n-      end Put_High_Level_C_Getter;\n+         Put (S, \"}\" & LF & LF);\n+      end Put_C_Getter;\n \n-      ------------------------------\n-      -- Put_High_Level_C_Getters --\n-      ------------------------------\n+      -------------------\n+      -- Put_C_Getters --\n+      -------------------\n \n-      procedure Put_High_Level_C_Getters\n+      procedure Put_C_Getters\n         (S : in out Sink; Root : Root_Type)\n       is\n       begin\n          Put (S, \"// Getters for fields\" & LF & LF);\n \n          for F in First_Field (Root) .. Last_Field (Root) loop\n-            Put_High_Level_C_Getter (S, F);\n+            Put_C_Getter (S, F);\n          end loop;\n-      end Put_High_Level_C_Getters;\n+      end Put_C_Getters;\n \n       --------------------------\n       -- Put_Union_Membership --\n@@ -3174,16 +3274,24 @@ package body Gen_IL.Gen is\n \n          Put (S, \"typedef Boolean Flag;\" & LF & LF);\n \n+         Put (S, \"#define N_Head \" & N_Head & LF);\n+         Put (S, \"\" & LF);\n+         Put (S, \"typedef struct Node_Header {\" & LF);\n+         Increase_Indent (S, 2);\n+         Put (S, \"any_slot Slots[N_Head];\" & LF);\n+         Put (S, \"Field_Offset Offset;\" & LF);\n+         Decrease_Indent (S, 2);\n+         Put (S, \"} Node_Header;\" & LF & LF);\n+\n+         Put (S, \"extern Node_Header *Node_Offsets_Ptr;\" & LF);\n+         Put (S, \"extern any_slot *Slots_Ptr;\" & LF & LF);\n+\n          Put_C_Type_And_Subtypes (S, Node_Kind);\n \n          Put (S, \"// Getters corresponding to instantiations of Atree.Get_n_Bit_Field\"\n                  & LF & LF);\n \n-         for T in Special_Type loop\n-            Put_Low_Level_C_Getter (S, T);\n-         end loop;\n-\n-         Put_High_Level_C_Getters (S, Node_Kind);\n+         Put_C_Getters (S, Node_Kind);\n \n          Put (S, \"#ifdef __cplusplus\" & LF);\n          Put (S, \"}\" & LF);\n@@ -3238,11 +3346,7 @@ package body Gen_IL.Gen is\n \n          Put_C_Type_And_Subtypes (S, Entity_Kind);\n \n-         --  Note that we do not call Put_Low_Level_C_Getter here. Those are in\n-         --  sinfo.h, so every file that #includes einfo.h must #include\n-         --  sinfo.h first.\n-\n-         Put_High_Level_C_Getters (S, Entity_Kind);\n+         Put_C_Getters (S, Entity_Kind);\n \n          Put (S, \"// Abstract type queries\" & LF & LF);\n "}, {"sha": "db0a5f2cefc0d8344abf0bf9c7d321a2c275e000", "filename": "gcc/ada/live.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Flive.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Flive.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flive.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -45,7 +45,8 @@ package body Live is\n    --  any valuable per-node space and possibly results in better locality and\n    --  cache usage.\n \n-   type Name_Set is array (Node_Id range <>) of Boolean;\n+   type Name_Set is array (Node_Id'Base range <>) of Boolean;\n+   --  We use 'Base here, in case we want to add a predicate to Node_Id\n    pragma Pack (Name_Set);\n \n    function Marked (Marks : Name_Set; Name : Node_Id) return Boolean;"}, {"sha": "20bc03ac68632317bf268ed7aa181168e0d9ec53", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -118,7 +118,8 @@ package body Sem_Eval is\n    subtype CV_Range is Nat range 0 .. CV_Cache_Size;\n \n    type CV_Entry is record\n-      N : Node_Id;\n+      N : Node_Id'Base;\n+      --  We use 'Base here, in case we want to add a predicate to Node_Id\n       V : Uint;\n    end record;\n "}, {"sha": "55d0e40d718cde66aaf967f1bae3d3c5fa437808", "filename": "gcc/ada/sinfo-utils.adb", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsinfo-utils.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsinfo-utils.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -55,7 +55,7 @@ package body Sinfo.Utils is\n    --  The second method is much faster if the amount of Ada code being\n    --  compiled is large.\n \n-   ww : Node_Id'Base := Node_Id'First - 1;\n+   ww : Node_Id'Base := Node_Low_Bound - 1;\n    pragma Export (Ada, ww);\n    Watch_Node : Node_Id'Base renames ww;\n    --  Node to \"watch\"; that is, whenever a node is created, we check if it\n@@ -72,8 +72,8 @@ package body Sinfo.Utils is\n \n    procedure nnd (N : Node_Id);\n    pragma Export (Ada, nnd);\n-   --  For debugging. If debugging is turned on, New_Node and New_Entity call\n-   --  this. If debug flag N is turned on, this prints out the new node.\n+   --  For debugging. If debugging is turned on, New_Node and New_Entity (etc.)\n+   --  call this. If debug flag N is turned on, this prints out the new node.\n    --\n    --  If Node = Watch_Node, this prints out the new node and calls\n    --  New_Node_Breakpoint. Otherwise, does nothing.\n@@ -265,7 +265,7 @@ package body Sinfo.Utils is\n          if Fields (J) /= F_Link then -- Don't walk Parent!\n             declare\n                Desc : Field_Descriptor renames\n-                 Node_Field_Descriptors (Fields (J));\n+                 Field_Descriptors (Fields (J));\n             begin\n                if Is_In_Union_Id (Desc.Kind) then\n                   Action (Get_Node_Field_Union (N, Desc.Offset));\n@@ -290,7 +290,7 @@ package body Sinfo.Utils is\n          if Fields (J) /= F_Link then -- Don't walk Parent!\n             declare\n                Desc : Field_Descriptor renames\n-                 Node_Field_Descriptors (Fields (J));\n+                 Field_Descriptors (Fields (J));\n             begin\n                if Is_In_Union_Id (Desc.Kind) then\n                   Set_Node_Field_Union"}, {"sha": "e3bb8d430a372ec044bc6f09605ebddfd2201785", "filename": "gcc/ada/sinfo-utils.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsinfo-utils.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Fsinfo-utils.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo-utils.ads?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -23,7 +23,7 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with Sinfo.Nodes;    use Sinfo.Nodes;\n+with Sinfo.Nodes; use Sinfo.Nodes;\n \n package Sinfo.Utils is\n "}, {"sha": "07f2ae8a51021a9623f303d28eb329ba33e1d7c9", "filename": "gcc/ada/table.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftable.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftable.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftable.ads?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -102,7 +102,7 @@ package Table is\n       --  mode parameters with scalar values.\n \n       type Table_Type is\n-        array (Table_Index_Type range <>) of Table_Component_Type;\n+        array (Table_Index_Type range <>) of aliased Table_Component_Type;\n \n       subtype Big_Table_Type is\n         Table_Type (Table_Low_Bound .. Table_Index_Type'Last);"}, {"sha": "4c7833beade3553f8847d1ef0b1f3e2c00e21a88", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 29, "deletions": 29, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -130,9 +130,7 @@ package body Treepr is\n    procedure Capitalize (S : in out String);\n    --  Turns an identifier into Mixed_Case\n \n-   function Image (F : Node_Field) return String;\n-\n-   function Image (F : Entity_Field) return String;\n+   function Image (F : Node_Or_Entity_Field) return String;\n \n    procedure Print_Init;\n    --  Initialize for printing of tree with descendants\n@@ -281,7 +279,7 @@ package body Treepr is\n    -- Image --\n    -----------\n \n-   function Image (F : Node_Field) return String is\n+   function Image (F : Node_Or_Entity_Field) return String is\n    begin\n       case F is\n          when F_Alloc_For_BIP_Return =>\n@@ -321,18 +319,6 @@ package body Treepr is\n          when F_TSS_Elist =>\n             return \"TSS_Elist\";\n \n-         when others =>\n-            declare\n-               Result : constant String := Capitalize (F'Img);\n-            begin\n-               return Result (3 .. Result'Last); -- Remove \"F_\"\n-            end;\n-      end case;\n-   end Image;\n-\n-   function Image (F : Entity_Field) return String is\n-   begin\n-      case F is\n          when F_BIP_Initialization_Call =>\n             return \"BIP_Initialization_Call\";\n          when F_Body_Needed_For_SAL =>\n@@ -666,7 +652,7 @@ package body Treepr is\n             for Field_Index in Fields'Range loop\n                declare\n                   FD : Field_Descriptor renames\n-                    Entity_Field_Descriptors (Fields (Field_Index));\n+                    Field_Descriptors (Fields (Field_Index));\n                begin\n                   if Should_Print (Fields (Field_Index))\n                     and then (FD.Kind = Flag_Field) = Print_Flags\n@@ -1266,14 +1252,21 @@ package body Treepr is\n \n       --  Print Chars field if present\n \n-      if Nkind (N) in N_Has_Chars and then Chars (N) /= No_Name then\n-         Print_Str (Prefix);\n-         Print_Str (\"Chars = \");\n-         Print_Name (Chars (N));\n-         Write_Str (\" (Name_Id=\");\n-         Write_Int (Int (Chars (N)));\n-         Write_Char (')');\n-         Print_Eol;\n+      if Nkind (N) in N_Has_Chars then\n+         if Field_Is_Initial_Zero (N, F_Chars) then\n+            Print_Str (Prefix);\n+            Print_Str (\"Chars = initial zero\");\n+            Print_Eol;\n+\n+         elsif Chars (N) /= No_Name then\n+            Print_Str (Prefix);\n+            Print_Str (\"Chars = \");\n+            Print_Name (Chars (N));\n+            Write_Str (\" (Name_Id=\");\n+            Write_Int (Int (Chars (N)));\n+            Write_Char (')');\n+            Print_Eol;\n+         end if;\n       end if;\n \n       --  Special field print operations for non-entity nodes\n@@ -1454,7 +1447,7 @@ package body Treepr is\n             for Field_Index in Fields'Range loop\n                declare\n                   FD : Field_Descriptor renames\n-                    Node_Field_Descriptors (Fields (Field_Index));\n+                    Field_Descriptors (Fields (Field_Index));\n                begin\n                   if Should_Print (Fields (Field_Index))\n                     and then (FD.Kind = Flag_Field) = Print_Flags\n@@ -1624,7 +1617,14 @@ package body Treepr is\n \n          if Nkind (N) in N_Has_Chars then\n             Write_Char (' ');\n-            Print_Name (Chars (N));\n+\n+            if Field_Is_Initial_Zero (N, F_Chars) then\n+               Print_Str (\"Chars = initial zero\");\n+               Print_Eol;\n+\n+            else\n+               Print_Name (Chars (N));\n+            end if;\n          end if;\n \n          if Nkind (N) in N_Entity then\n@@ -2265,7 +2265,7 @@ package body Treepr is\n          for Field_Index in A'Range loop\n             declare\n                F : constant Node_Field := A (Field_Index);\n-               FD : Field_Descriptor renames Node_Field_Descriptors (F);\n+               FD : Field_Descriptor renames Field_Descriptors (F);\n             begin\n                if FD.Kind in Node_Id_Field | List_Id_Field | Elist_Id_Field\n                   --  For all other kinds of descendants (strings, names, uints\n@@ -2293,7 +2293,7 @@ package body Treepr is\n             for Field_Index in A'Range loop\n                declare\n                   F : constant Entity_Field := A (Field_Index);\n-                  FD : Field_Descriptor renames Entity_Field_Descriptors (F);\n+                  FD : Field_Descriptor renames Field_Descriptors (F);\n                begin\n                   if FD.Kind in Node_Id_Field | List_Id_Field | Elist_Id_Field\n                   then"}, {"sha": "07b0960c1777b5953c154ed102fa9aca9368d9e7", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/99e30ba8c01f80a81891223069d47d8a611082c4/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=99e30ba8c01f80a81891223069d47d8a611082c4", "patch": "@@ -991,6 +991,8 @@ package Types is\n    --  Offset of a node field, in units of the size of the field, which is\n    --  always a power of 2.\n \n+   subtype Node_Offset is Field_Offset'Base range 1 .. Field_Offset'Base'Last;\n+\n    subtype Slot_Count is Field_Offset;\n    --  Count of number of slots. Same type as Field_Offset to avoid\n    --  proliferation of type conversions.\n@@ -1005,4 +1007,8 @@ package Types is\n    type Offset_Array is\n      array (Offset_Array_Index range <>) of Opt_Field_Offset;\n \n+   Slot_Size : constant := 32;\n+   type Slot is mod 2**Slot_Size;\n+   for Slot'Size use Slot_Size;\n+\n end Types;"}]}