{"sha": "ef178af3a4faba2594c5a106ca721a5c3db4f693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYxNzhhZjNhNGZhYmEyNTk0YzVhMTA2Y2E3MjFhNWMzZGI0ZjY5Mw==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@bitmover.com", "date": "1999-08-31T19:39:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-08-31T19:39:10Z"}, "message": "rtl.h (RTL_CHECK1, RTL_CHECK2): New macros which type- and bounds- check RTL accesses if --enable-checking.\n\n1999-08-31 12:20 -0700 Zack Weinberg <zack@bitmover.com>\n\n\t* rtl.h (RTL_CHECK1, RTL_CHECK2): New macros which type- and\n\tbounds- check RTL accesses if --enable-checking.\n\t(RTVEC_ELT): Bounds check if --enable-checking.\n\t(XWINT, XINT, XSTR, XEXP, XVEC, XMODE, XBITMAP, XTREE,\n\tXBBDEF): Use RTL_CHECK1/RTL_CHECK2 as appropriate.\n\t(XVECEXP, XVECLEN): Define in terms of XVEC, RTVEC_ELT, and\n\tGET_NUM_ELEM.\n\t(X0WINT, X0INT, X0STR, X0EXP, X0VEC, X0MODE, X0BITMAP, X0TREE,\n\tX0BBDEF, X0ADVFLAGS):  New macros for accessing '0' slots of RTXes.\n\n\t(ADDR_DIFF_VEC_FLAGS): Use X0ADVFLAGS.\n\t(NOTE_SOURCE_FILE): Use X0STR.\n\t(NOTE_BLOCK_NUMBER, NOTE_EH_HANDLER, LABEL_NUSES,\n\tMEM_ALIAS_SET): Use X0INT.\n\t(NOTE_RANGE_INFO, NOTE_LIVE_INFO, NOTE_BASIC_BLOCK,\n\tJUMP_LABEL, LABEL_REFS, LABEL_NEXTREF, CONTAINING_INSN):\n\tUse X0EXP.\n\t* real.h (CONST_DOUBLE_CHAIN): Use X0EXP.\n\t* rtl.c (copy_rtx, copy_most_rtx): Copy '0' slots with X0WINT.\n\t(rtl_check_failed_bounds, rtl_check_failed_type1,\n\trtl_check_failed_type2, rtvec_check_failed_bounds): New\n\tfunctions.\n\t(fancy_abort): Fix comment.\n\n\t* cse.c (canon_hash): Read CONST_DOUBLE data slots with XWINT.\n\t(cse_insn): Decrement LABEL_NUSES for jump target before\n\tdeleting jump insn.\n\t* emit-rtl.c (gen_rtx_CONST_DOUBLE): Use X0EXP for slot 1.\n\t* final.c (alter_subreg): Compute regno before changing x to\n\tREG; set REGNO(x) after changing it.\n\t* flow.c (count_basic_blocks): Use XWINT to inspect EH_REGION\n\tnotes containing CONST_INTs.\n\t(delete_eh_regions): Use NOTE_EH_HANDLER.\n\t* function.c (put_reg_into_stack): Make reg a MEM before\n\tinitializing it.\n\t(fixup_var_refs_insns):  Save REG_NOTES (insn) in case we\n\tdelete insn.\n\t(gen_mem_addressof): Make reg a MEM before initializing it.\n\t* integrate.c (copy_rtx_and_substitute): Copy '0' slots with\n\tX0WINT.\n\t* local-alloc.c (update_equiv_regs): Zap REG_NOTES before\n\tdeleting an insn, not after.\n\t(block_alloc): Only look at PATTERN(insn) if we have to, and\n\tonly if it's format class 'i'.\n\t* loop.c (check_dbra_loop): Check bl->biv->add_val is a\n\tCONST_INT before using its INTVAL.\n\t* print-rtl.c (print_rtx): Use X0STR.\n\t* regmove.c (fixup_match_1): Don't look at PATTERN of\n\tnon-class-'i' insn chain elements.\n\t* reload.c (loc_mentioned_in_p): Take address of\n\tin->fld[1].rtx directly.\n\t* reload1.c (reload): Change reg to a MEM before initializing\n\tit.\n\t* varasm.c (mark_constant_pool): Skip CONST_DOUBLES, which\n\thave no names.\n\t* config/i386/i386.md (decrement_and_branch_if_zero): Fix typo.\n\nFrom-SVN: r29008", "tree": {"sha": "0b67c4cdc852a2b9c74808c3b360549b5fc234f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b67c4cdc852a2b9c74808c3b360549b5fc234f0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef178af3a4faba2594c5a106ca721a5c3db4f693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef178af3a4faba2594c5a106ca721a5c3db4f693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef178af3a4faba2594c5a106ca721a5c3db4f693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef178af3a4faba2594c5a106ca721a5c3db4f693/comments", "author": null, "committer": null, "parents": [{"sha": "8230525836955815b66b3e2a7a46fd6a0dbb7fd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8230525836955815b66b3e2a7a46fd6a0dbb7fd6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8230525836955815b66b3e2a7a46fd6a0dbb7fd6"}], "stats": {"total": 336, "additions": 273, "deletions": 63}, "files": [{"sha": "d84191d92285bc066fb94a83f3653fea3959b38c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -1,3 +1,62 @@\n+1999-08-31 12:20 -0700 Zack Weinberg <zack@bitmover.com>\n+\n+\t* rtl.h (RTL_CHECK1, RTL_CHECK2): New macros which type- and\n+\tbounds- check RTL accesses if --enable-checking.\n+\t(RTVEC_ELT): Bounds check if --enable-checking.\n+\t(XWINT, XINT, XSTR, XEXP, XVEC, XMODE, XBITMAP, XTREE,\n+\tXBBDEF): Use RTL_CHECK1/RTL_CHECK2 as appropriate.\n+\t(XVECEXP, XVECLEN): Define in terms of XVEC, RTVEC_ELT, and\n+\tGET_NUM_ELEM.\n+\t(X0WINT, X0INT, X0STR, X0EXP, X0VEC, X0MODE, X0BITMAP, X0TREE,\n+\tX0BBDEF, X0ADVFLAGS):  New macros for accessing '0' slots of RTXes.\n+\n+\t(ADDR_DIFF_VEC_FLAGS): Use X0ADVFLAGS.\n+\t(NOTE_SOURCE_FILE): Use X0STR.\n+\t(NOTE_BLOCK_NUMBER, NOTE_EH_HANDLER, LABEL_NUSES,\n+\tMEM_ALIAS_SET): Use X0INT.\n+\t(NOTE_RANGE_INFO, NOTE_LIVE_INFO, NOTE_BASIC_BLOCK,\n+\tJUMP_LABEL, LABEL_REFS, LABEL_NEXTREF, CONTAINING_INSN):\n+\tUse X0EXP.\n+\t* real.h (CONST_DOUBLE_CHAIN): Use X0EXP.\n+\t* rtl.c (copy_rtx, copy_most_rtx): Copy '0' slots with X0WINT.\n+\t(rtl_check_failed_bounds, rtl_check_failed_type1,\n+\trtl_check_failed_type2, rtvec_check_failed_bounds): New\n+\tfunctions.\n+\t(fancy_abort): Fix comment.\n+\n+\t* cse.c (canon_hash): Read CONST_DOUBLE data slots with XWINT.\n+\t(cse_insn): Decrement LABEL_NUSES for jump target before\n+\tdeleting jump insn.\n+\t* emit-rtl.c (gen_rtx_CONST_DOUBLE): Use X0EXP for slot 1.\n+\t* final.c (alter_subreg): Compute regno before changing x to\n+\tREG; set REGNO(x) after changing it.\n+\t* flow.c (count_basic_blocks): Use XWINT to inspect EH_REGION\n+\tnotes containing CONST_INTs.\n+\t(delete_eh_regions): Use NOTE_EH_HANDLER.\n+\t* function.c (put_reg_into_stack): Make reg a MEM before\n+\tinitializing it.\n+\t(fixup_var_refs_insns):  Save REG_NOTES (insn) in case we\n+\tdelete insn.\n+\t(gen_mem_addressof): Make reg a MEM before initializing it.\n+\t* integrate.c (copy_rtx_and_substitute): Copy '0' slots with\n+\tX0WINT.\n+\t* local-alloc.c (update_equiv_regs): Zap REG_NOTES before\n+\tdeleting an insn, not after.\n+\t(block_alloc): Only look at PATTERN(insn) if we have to, and\n+\tonly if it's format class 'i'.\n+\t* loop.c (check_dbra_loop): Check bl->biv->add_val is a\n+\tCONST_INT before using its INTVAL.\n+\t* print-rtl.c (print_rtx): Use X0STR.\n+\t* regmove.c (fixup_match_1): Don't look at PATTERN of \n+\tnon-class-'i' insn chain elements.\n+\t* reload.c (loc_mentioned_in_p): Take address of\n+\tin->fld[1].rtx directly.\n+\t* reload1.c (reload): Change reg to a MEM before initializing\n+\tit.\n+\t* varasm.c (mark_constant_pool): Skip CONST_DOUBLES, which\n+\thave no names.\n+\t* config/i386/i386.md (decrement_and_branch_if_zero): Fix typo.\n+\n Fri Aug 20 13:43:41 1999  Andrew Haley  <aph@cygnus.com>\n \n \t* config/mips/mips.c (machine_dependent_reorg): Force a"}, {"sha": "547facd171cfc42aa5b0cd0002801334ea049075", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -6413,7 +6413,7 @@ byte_xor_operation:\n {\n   CC_STATUS_INIT;\n \n-  if (GET_CODE (operands[1]) == REG && REGNO (operands[2]) == 2 &&\n+  if (GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 2 &&\n       operands[2] == constm1_rtx && ix86_cpu == PROCESSOR_K6)\n     return \\\"loop %l3\\\";\n "}, {"sha": "6c7aef31ecd3b89ce884b0d22f4a5f93694579fa", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -2166,7 +2166,7 @@ canon_hash (x, mode)\n       if (GET_MODE (x) != VOIDmode)\n \tfor (i = 2; i < GET_RTX_LENGTH (CONST_DOUBLE); i++)\n \t  {\n-\t    unsigned tem = XINT (x, i);\n+\t    unsigned HOST_WIDE_INT tem = XWINT (x, i);\n \t    hash += tem;\n \t  }\n       else\n@@ -7384,13 +7384,13 @@ cse_insn (insn, libcall_insn)\n \t the insn.  */\n       else if (n_sets == 1 && dest == pc_rtx && src == pc_rtx)\n \t{\n+\t  /* One less use of the label this insn used to jump to.  */\n+\t  if (JUMP_LABEL (insn) != 0)\n+\t    --LABEL_NUSES (JUMP_LABEL (insn));\n \t  PUT_CODE (insn, NOTE);\n \t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n \t  NOTE_SOURCE_FILE (insn) = 0;\n \t  cse_jumps_altered = 1;\n-\t  /* One less use of the label this insn used to jump to.  */\n-\t  if (JUMP_LABEL (insn) != 0)\n-\t    --LABEL_NUSES (JUMP_LABEL (insn));\n \t  /* No more processing for this set.  */\n \t  sets[i].rtl = 0;\n \t}"}, {"sha": "3535a23239dcf86805bbfc190b2b870cfece2e43", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -217,7 +217,7 @@ gen_rtx_CONST_DOUBLE (mode, arg0, arg1, arg2)\n \n   PUT_MODE (r, mode);\n   XEXP (r, 0) = arg0;\n-  XEXP (r, 1) = NULL_RTX;\n+  X0EXP (r, 1) = NULL_RTX;\n   XWINT (r, 2) = arg1;\n   XWINT (r, 3) = arg2;\n "}, {"sha": "c4d470820461eb67591a62e2b2d42c08b7effc00", "filename": "gcc/final.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -3089,20 +3089,22 @@ alter_subreg (x)\n \n   if (GET_CODE (y) == REG)\n     {\n+      int regno;\n       /* If the word size is larger than the size of this register,\n \t adjust the register number to compensate.  */\n       /* ??? Note that this just catches stragglers created by/for\n \t integrate.  It would be better if we either caught these\n \t earlier, or kept _all_ subregs until now and eliminate\n \t gen_lowpart and friends.  */\n \n-      PUT_CODE (x, REG);\n #ifdef ALTER_HARD_SUBREG\n-      REGNO (x) = ALTER_HARD_SUBREG(GET_MODE (x), SUBREG_WORD (x),\n-\t\t\t\t    GET_MODE (y), REGNO (y));\n+      regno = ALTER_HARD_SUBREG(GET_MODE (x), SUBREG_WORD (x),\n+\t\t\t\tGET_MODE (y), REGNO (y));\n #else\n-      REGNO (x) = REGNO (y) + SUBREG_WORD (x);\n+      regno = REGNO (y) + SUBREG_WORD (x);\n #endif\n+      PUT_CODE (x, REG);\n+      REGNO (x) = regno;\n       /* This field has a different meaning for REGs and SUBREGs.  Make sure\n \t to clear it!  */\n       x->used = 0;"}, {"sha": "a813d943e690f4c14bb3d71b26350752ce20028d", "filename": "gcc/flow.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -473,7 +473,7 @@ count_basic_blocks (f)\n       if (code == CALL_INSN)\n \t{\n \t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t  int region = (note ? XINT (XEXP (note, 0), 0) : 1);\n+\t  int region = (note ? XWINT (XEXP (note, 0), 0) : 1);\n \t  prev_call = insn;\n \t  call_had_abnormal_edge = 0;\n \n@@ -553,7 +553,7 @@ find_basic_blocks_1 (f, bb_eh_end)\n \t{\n \t  /* Record whether this call created an edge.  */\n \t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t  int region = (note ? XINT (XEXP (note, 0), 0) : 1);\n+\t  int region = (note ? XWINT (XEXP (note, 0), 0) : 1);\n \t  call_has_abnormal_edge = 0;\n \n \t  /* If there is an EH region, we have an edge.  */\n@@ -1613,7 +1613,7 @@ delete_eh_regions ()\n \tif ((NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG) ||\n \t    (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)) \n \t  {\n-\t    int num = CODE_LABEL_NUMBER (insn);\n+\t    int num = NOTE_EH_HANDLER (insn);\n \t    /* A NULL handler indicates a region is no longer needed,\n \t       as long as it isn't the target of a rethrow.  */\n \t    if (get_first_handler (num) == NULL && ! rethrow_used (num))"}, {"sha": "6fb5368a3a3cd086e097342a40943742d1708696", "filename": "gcc/function.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -1341,11 +1341,11 @@ put_reg_into_stack (function, reg, type, promoted_mode, decl_mode, volatile_p,\n \tnew = assign_stack_local (decl_mode, GET_MODE_SIZE (decl_mode), 0);\n     }\n \n+  PUT_CODE (reg, MEM);\n   PUT_MODE (reg, decl_mode);\n   XEXP (reg, 0) = XEXP (new, 0);\n   /* `volatil' bit means one thing for MEMs, another entirely for REGs.  */\n   MEM_VOLATILE_P (reg) = volatile_p;\n-  PUT_CODE (reg, MEM);\n \n   /* If this is a memory ref that contains aggregate components,\n      mark it as such for cse and loop optimize.  If we are reusing a\n@@ -1495,6 +1495,9 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \n       if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n \t{\n+\t  /* Remember the notes in case we delete the insn.  */\n+\t  note = REG_NOTES (insn);\n+\n \t  /* If this is a CLOBBER of VAR, delete it.\n \n \t     If it has a REG_LIBCALL note, delete the REG_LIBCALL\n@@ -1653,10 +1656,13 @@ fixup_var_refs_insns (var, promoted_mode, unsignedp, insn, toplevel, ht)\n \t  /* Also fix up any invalid exprs in the REG_NOTES of this insn.\n \t     But don't touch other insns referred to by reg-notes;\n \t     we will get them elsewhere.  */\n-\t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t    if (GET_CODE (note) != INSN_LIST)\n-\t      XEXP (note, 0)\n-\t\t= walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n+\t  while (note)\n+\t    {\n+\t      if (GET_CODE (note) != INSN_LIST)\n+\t\tXEXP (note, 0)\n+\t\t  = walk_fixup_memory_subreg (XEXP (note, 0), insn, 1);\n+\t       note = XEXP (note, 1);\n+\t    }\n \t}\n \n       if (!ht)\n@@ -2631,9 +2637,9 @@ gen_mem_addressof (reg, decl)\n      address is being taken.  */\n   REG_USERVAR_P (XEXP (r, 0)) = REG_USERVAR_P (reg);\n \n-  XEXP (reg, 0) = r;\n   PUT_CODE (reg, MEM);\n   PUT_MODE (reg, DECL_MODE (decl));\n+  XEXP (reg, 0) = r;\n   MEM_VOLATILE_P (reg) = TREE_SIDE_EFFECTS (decl);\n   MEM_SET_IN_STRUCT_P (reg, AGGREGATE_TYPE_P (type));\n   MEM_ALIAS_SET (reg) = get_alias_set (decl);"}, {"sha": "9fb0bf0d6d2c313ca66be1d140fa0fe19700915b", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -5955,6 +5955,8 @@ main (argc, argv)\n   rtx tem;\n   int i;\n \n+  progname = \"genattrtab\";\n+\n #if defined (RLIMIT_STACK) && defined (HAVE_GETRLIMIT) && defined (HAVE_SETRLIMIT)\n   /* Get rid of any avoidable limit on stack size.  */\n   {"}, {"sha": "56d09c2010e7813ff0258858da94dc4d817a5baf", "filename": "gcc/integrate.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -2699,7 +2699,8 @@ copy_rtx_and_substitute (orig, map)\n       switch (*format_ptr++)\n \t{\n \tcase '0':\n-\t  XEXP (copy, i) = XEXP (orig, i);\n+\t  /* Copy this through the wide int field; that's safest.  */\n+\t  X0WINT (copy, i) = X0WINT (orig, i);\n \t  break;\n \n \tcase 'e':"}, {"sha": "dcee4992c5acac731e498519e3f88f13bf1770fc", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -971,11 +971,11 @@ update_equiv_regs ()\n \n \t\t  emit_insn_before (copy_rtx (PATTERN (equiv_insn)), insn);\n \t\t  REG_NOTES (PREV_INSN (insn)) = REG_NOTES (equiv_insn);\n+\t\t  REG_NOTES (equiv_insn) = 0;\n \n \t\t  PUT_CODE (equiv_insn, NOTE);\n \t\t  NOTE_LINE_NUMBER (equiv_insn) = NOTE_INSN_DELETED;\n \t\t  NOTE_SOURCE_FILE (equiv_insn) = 0;\n-\t\t  REG_NOTES (equiv_insn) = 0;\n \n \t\t  if (block < 0)\n \t\t    REG_BASIC_BLOCK (regno) = 0;\n@@ -1071,8 +1071,6 @@ block_alloc (b)\n   insn = BLOCK_HEAD (b);\n   while (1)\n     {\n-      register rtx body = PATTERN (insn);\n-\n       if (GET_CODE (insn) != NOTE)\n \tinsn_number++;\n \n@@ -1083,6 +1081,9 @@ block_alloc (b)\n \t  register rtx r0, r1;\n \t  int combined_regno = -1;\n \t  int i;\n+#ifndef REGISTER_CONSTRAINTS\n+\t  register rtx body = PATTERN (insn);\n+#endif\n \n \t  this_insn_number = insn_number;\n \t  this_insn = insn;\n@@ -1184,11 +1185,11 @@ block_alloc (b)\n \t\t\t can only be in the same register as the output, give\n \t\t\t priority to an equivalence found from that insn.  */\n \t\t      int may_save_copy\n-\t\t\t= ((SET_DEST (body) == r0 && SET_SRC (body) == r1)\n #ifdef REGISTER_CONSTRAINTS\n-\t\t\t   || (r1 == recog_operand[i] && must_match_0 >= 0)\n+\t\t\t= (r1 == recog_operand[i] && must_match_0 >= 0);\n+#else\n+\t\t\t= (SET_DEST (body) == r0 && SET_SRC (body) == r1);\n #endif\n-\t\t\t   );\n \t\t      \n \t\t      if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n \t\t\twin = combine_regs (r1, r0, may_save_copy,"}, {"sha": "59628fd4f74d928137bf495cdaa6026a8f217539", "filename": "gcc/loop.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -7797,7 +7797,8 @@ check_dbra_loop (loop_end, insn_count, loop_start, loop_info)\n \t    }\n \t}\n     }\n-  else if (INTVAL (bl->biv->add_val) > 0)\n+  else if (GET_CODE (bl->biv->add_val) == CONST_INT\n+\t   && INTVAL (bl->biv->add_val) > 0)\n     {\n       /* Try to change inc to dec, so can apply above optimization.  */\n       /* Can do this if:"}, {"sha": "52c92f3022f4e6503ecf6c7bc723705478a76d3b", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -185,8 +185,7 @@ print_rtx (in_rtx)\n \t      }\n \t    else\n \t      {\n-\t\t/* Can't use XSTR because of type checking.  */\n-\t\tchar *str = in_rtx->fld[i].rtstr;\n+\t\tchar *str = X0STR (in_rtx, i);\n \t\tif (str == 0)\n \t\t  fputs (dump_for_graph ? \" \\\\\\\"\\\\\\\"\" : \" \\\"\\\"\", outfile);\n \t\telse"}, {"sha": "a1e85b16c84d4798522940c17f3eccded8c1afb1", "filename": "gcc/real.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -452,7 +452,7 @@ union real_extract\n #define CONST_DOUBLE_HIGH(r) XWINT (r, 3)\n \n /* Link for chain of all CONST_DOUBLEs in use in current function.  */\n-#define CONST_DOUBLE_CHAIN(r) XEXP (r, 1)\n+#define CONST_DOUBLE_CHAIN(r) X0EXP (r, 1)\n /* The MEM which represents this CONST_DOUBLE's value in memory,\n    or const0_rtx if no MEM has been made for it yet,\n    or cc0_rtx if it is not on the chain.  */"}, {"sha": "c0e5f7e75676ebdc307139bfcdba6c23d6dd02d9", "filename": "gcc/regmove.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fregmove.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fregmove.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregmove.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -1905,7 +1905,9 @@ fixup_match_1 (insn, set, src, src_subreg, dst, backward, operand_number,\n \t  NOTE_SOURCE_FILE (insn) = 0;\n \t  /* emit_insn_after_with_line_notes has no\n \t     return value, so search for the new insn.  */\n-\t  for (insn = p; PATTERN (insn) != pat; )\n+\t  insn = p;\n+\t  while (GET_RTX_CLASS (GET_CODE (insn)) != 'i'\n+\t\t || PATTERN (insn) != pat)\n \t    insn = PREV_INSN (insn);\n \n \t  REG_NOTES (insn) = notes;"}, {"sha": "46479ac53e1abdf77c7765dfb81a034ac01b4418", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -1631,7 +1631,7 @@ loc_mentioned_in_p (loc, in)\n \n   for (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n     {\n-      if (loc == &XEXP (in, i))\n+      if (loc == &in->fld[i].rtx)\n \treturn 1;\n       if (fmt[i] == 'e')\n         {"}, {"sha": "83ebad3c6bc0f533e59a788a60b55ff06d347545", "filename": "gcc/reload1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freload1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Freload1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload1.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -1110,6 +1110,7 @@ reload (first, global, dumpfile)\n \t  if (reg_renumber[i] < 0)\n \t    {\n \t      rtx reg = regno_reg_rtx[i];\n+\t      PUT_CODE (reg, MEM);\n \t      XEXP (reg, 0) = addr;\n \t      REG_USERVAR_P (reg) = 0;\n \t      RTX_UNCHANGING_P (reg) = is_readonly;\n@@ -1118,7 +1119,6 @@ reload (first, global, dumpfile)\n \t      /* We have no alias information about this newly created\n \t\t MEM.  */\n \t      MEM_ALIAS_SET (reg) = 0;\n-\t      PUT_CODE (reg, MEM);\n \t    }\n \t  else if (reg_equiv_mem[i])\n \t    XEXP (reg_equiv_mem[i], 0) = addr;"}, {"sha": "e183b0503542693c8947f6c650cc6e9bae07d75d", "filename": "gcc/rtl.c", "status": "modified", "additions": 71, "deletions": 5, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Frtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Frtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -387,7 +387,6 @@ copy_rtx (orig)\n \t    XEXP (copy, i) = copy_rtx (XEXP (orig, i));\n \t  break;\n \n-\tcase '0':\n \tcase 'u':\n \t  XEXP (copy, i) = XEXP (orig, i);\n \t  break;\n@@ -428,6 +427,11 @@ copy_rtx (orig)\n \t  XSTR (copy, i) = XSTR (orig, i);\n \t  break;\n \n+\tcase '0':\n+\t  /* Copy this through the wide int field; that's safest. */\n+\t  X0WINT (copy, i) = X0WINT (orig, i);\n+\t  break;\n+\t  \n \tdefault:\n \t  abort ();\n \t}\n@@ -487,7 +491,6 @@ copy_most_rtx (orig, may_share)\n \t    XEXP (copy, i) = copy_most_rtx (XEXP (orig, i), may_share);\n \t  break;\n \n-\tcase '0':\n \tcase 'u':\n \t  XEXP (copy, i) = XEXP (orig, i);\n \t  break;\n@@ -522,6 +525,11 @@ copy_most_rtx (orig, may_share)\n \t  XSTR (copy, i) = XSTR (orig, i);\n \t  break;\n \n+\tcase '0':\n+\t  /* Copy this through the wide int field; that's safest. */\n+\t  X0WINT (copy, i) = X0WINT (orig, i);\n+\t  break;\n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -934,6 +942,65 @@ read_rtx (infile)\n   return return_rtx;\n }\n \n+#if defined ENABLE_CHECKING && (__GNUC__ > 2 || __GNUC_MINOR__ > 6)\n+void\n+rtl_check_failed_bounds (r, n, file, line, func)\n+    rtx r;\n+    int n;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: access of elt %d of `%s' with last elt %d\",\n+\t n, GET_RTX_NAME (GET_CODE (r)), GET_RTX_LENGTH (GET_CODE (r))-1);\n+  fancy_abort (file, line, func);\n+}\n+\n+void\n+rtl_check_failed_type1 (r, n, c1, file, line, func)\n+    rtx r;\n+    int n;\n+    int c1;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: expected elt %d type '%c', have '%c' (rtx %s)\",\n+\t n, c1, GET_RTX_FORMAT (GET_CODE (r))[n], GET_RTX_NAME (GET_CODE (r)));\n+  fancy_abort (file, line, func);\n+}\n+\n+void\n+rtl_check_failed_type2 (r, n, c1, c2, file, line, func)\n+    rtx r;\n+    int n;\n+    int c1;\n+    int c2;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: expected elt %d type '%c' or '%c', have '%c' (rtx %s)\",\n+\t n, c1, c2,\n+\t GET_RTX_FORMAT (GET_CODE (r))[n], GET_RTX_NAME (GET_CODE(r)));\n+  fancy_abort (file, line, func);\n+}\n+\n+/* XXX Maybe print the vector?  */\n+void\n+rtvec_check_failed_bounds (r, n, file, line, func)\n+    rtvec r;\n+    int n;\n+    const char *file;\n+    int line;\n+    const char *func;\n+{\n+  error (\"RTL check: access of elt %d of vector with last elt %d\",\n+\t n, GET_NUM_ELEM (r)-1);\n+  fancy_abort (file, line, func);\n+}\n+#endif /* ENABLE_CHECKING */\n+\n /* These are utility functions used by fatal-error functions all over the\n    code.  rtl.c happens to be linked by all the programs that need them,\n    so these are here.  In the future we want to break out all error handling\n@@ -962,11 +1029,10 @@ trim_filename (name)\n }\n \n /* Report an internal compiler error in a friendly manner and without\n-   dumping core.  There are two versions because __FUNCTION__ isn't\n-   available except in gcc 2.7 and later.  */\n+   dumping core.  */\n \n extern void fatal PVPROTO ((const char *, ...))\n-    ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n+  ATTRIBUTE_PRINTF_1 ATTRIBUTE_NORETURN;\n \n void\n fancy_abort (file, line, function)"}, {"sha": "ec0b73829debc3e8f5e08014b124c7be93405f25", "filename": "gcc/rtl.h", "status": "modified", "additions": 93, "deletions": 25, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -222,19 +222,86 @@ typedef struct rtvec_def{\n \n /* General accessor macros for accessing the fields of an rtx.  */\n \n-#define XWINT(RTX, N)\t((RTX)->fld[N].rtwint)\t\t\t/* w */\n-#define XINT(RTX, N)\t((RTX)->fld[N].rtint)\t\t\t/* i,n */\n-#define XSTR(RTX, N)\t((RTX)->fld[N].rtstr)\t\t\t/* s,S */\n-#define XEXP(RTX, N)\t((RTX)->fld[N].rtx)\t\t\t/* e,u */\n-#define XVEC(RTX, N)\t((RTX)->fld[N].rtvec)\t\t\t/* E,V */\n-#define XVECLEN(RTX, N)\t((RTX)->fld[N].rtvec->num_elem)\t\t/* E,V */\n-#define XMODE(RTX, N)\t((RTX)->fld[N].rttype)\t\t\t/* M */\n-#define XBITMAP(RTX, N) ((RTX)->fld[N].rtbit)\t\t\t/* b */\n-#define XTREE(RTX, N)   ((RTX)->fld[N].rttree)\t\t\t/* t */\n-#define XBBDEF(RTX, N)\t((RTX)->fld[N].bb)\t\t\t/* B */\n-\n-#define RTVEC_ELT(RTVEC, I)\t((RTVEC)->elem[I])\n-#define XVECEXP(RTX,N,M)\tRTVEC_ELT (XVEC (RTX, N), M)\n+#if defined ENABLE_CHECKING  && (__GNUC__ > 2 || __GNUC_MINOR__ > 6)\n+/* The bit with a star outside the statement expr and an & inside is\n+   so that N can be evaluated only once.  */\n+#define RTL_CHECK1(RTX, N, C1)\t\t\t\t\t\t\\\n+(*({ rtx _rtx = RTX; int _n = N;\t\t\t\t\t\\\n+     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n+     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n+       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n+\t\t\t\t__PRETTY_FUNCTION__);\t\t\t\\\n+     if (GET_RTX_FORMAT(_code)[_n] != C1)\t\t\t\t\\\n+       rtl_check_failed_type1 (_rtx, _n, C1, __FILE__, __LINE__,\t\\\n+\t\t\t       __PRETTY_FUNCTION__);\t\t\t\\\n+     &_rtx->fld[_n]; }))\n+\n+#define RTL_CHECK2(RTX, N, C1, C2)\t\t\t\t\t\\\n+(*({ rtx _rtx = RTX; int _n = N;\t\t\t\t\t\\\n+     enum rtx_code _code = GET_CODE (_rtx);\t\t\t\t\\\n+     if (_n < 0 || _n >= GET_RTX_LENGTH (_code))\t\t\t\\\n+       rtl_check_failed_bounds (_rtx, _n, __FILE__, __LINE__,\t\t\\\n+\t\t\t\t__PRETTY_FUNCTION__);\t\t\t\\\n+     if (GET_RTX_FORMAT(_code)[_n] != C1\t\t\t\t\\\n+\t && GET_RTX_FORMAT(_code)[_n] != C2)\t\t\t\t\\\n+       rtl_check_failed_type2 (_rtx, _n, C1, C2, __FILE__, __LINE__,\t\\\n+\t\t\t       __PRETTY_FUNCTION__);\t\t\t\\\n+     &_rtx->fld[_n]; }))\n+\n+#define RTVEC_ELT(RTVEC, I)\t\t\t\t\t\t\\\n+(*({ rtvec _rtvec = RTVEC; int _i = I;\t\t\t\t\t\\\n+     if (_i < 0 || _i >= GET_NUM_ELEM (_rtvec))\t\t\t\t\\\n+       rtvec_check_failed_bounds (_rtvec, _i, __FILE__, __LINE__,\t\\\n+\t\t\t\t  __PRETTY_FUNCTION__);\t\t\t\\\n+     &_rtvec->elem[_i]; }))\n+\n+extern void rtl_check_failed_bounds PROTO((rtx, int,\n+\t\t\t\t\t   const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+extern void rtl_check_failed_type1 PROTO((rtx, int, int,\n+\t\t\t\t\t  const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+extern void rtl_check_failed_type2 PROTO((rtx, int, int, int,\n+\t\t\t\t\t  const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+extern void rtvec_check_failed_bounds PROTO((rtvec, int,\n+\t\t\t\t\t     const char *, int, const char *))\n+    ATTRIBUTE_NORETURN;\n+\n+#else   /* not ENABLE_CHECKING */\n+\n+#define RTL_CHECK1(RTX, N, C1)     ((RTX)->fld[N])\n+#define RTL_CHECK2(RTX, N, C1, C2) ((RTX)->fld[N])\n+#define RTVEC_ELT(RTVEC, I)\t   ((RTVEC)->elem[I])\n+\n+#endif\n+\n+#define XWINT(RTX, N)\t(RTL_CHECK1(RTX, N, 'w').rtwint)\n+#define XINT(RTX, N)\t(RTL_CHECK2(RTX, N, 'i', 'n').rtint)\n+#define XSTR(RTX, N)\t(RTL_CHECK2(RTX, N, 's', 'S').rtstr)\n+#define XEXP(RTX, N)\t(RTL_CHECK2(RTX, N, 'e', 'u').rtx)\n+#define XVEC(RTX, N)\t(RTL_CHECK2(RTX, N, 'E', 'V').rtvec)\n+#define XMODE(RTX, N)\t(RTL_CHECK1(RTX, N, 'M').rttype)\n+#define XBITMAP(RTX, N) (RTL_CHECK1(RTX, N, 'b').rtbit)\n+#define XTREE(RTX, N)   (RTL_CHECK1(RTX, N, 't').rttree)\n+#define XBBDEF(RTX, N)\t(RTL_CHECK1(RTX, N, 'B').bb)\n+\n+#define XVECEXP(RTX, N, M)\tRTVEC_ELT (XVEC (RTX, N), M)\n+#define XVECLEN(RTX, N)\t\tGET_NUM_ELEM (XVEC (RTX, N))\n+\n+/* These are like XWINT, etc. except that they expect a '0' field instead\n+   of the normal type code.  */\n+\n+#define X0WINT(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtwint)\n+#define X0INT(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtint)\n+#define X0STR(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtstr)\n+#define X0EXP(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtx)\n+#define X0VEC(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rtvec)\n+#define X0MODE(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rttype)\n+#define X0BITMAP(RTX, N)   (RTL_CHECK1(RTX, N, '0').rtbit)\n+#define X0TREE(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').rttree)\n+#define X0BBDEF(RTX, N)\t   (RTL_CHECK1(RTX, N, '0').bb)\n+#define X0ADVFLAGS(RTX, N) (RTL_CHECK1(RTX, N, '0').rt_addr_diff_vec_flags)\n \n \f\n /* ACCESS MACROS for particular fields of insns.  */\n@@ -357,7 +424,7 @@ typedef struct rtvec_def{\n \n #define REG_NOTES(INSN)\tXEXP(INSN, 6)\n \n-#define ADDR_DIFF_VEC_FLAGS(RTX) ((RTX)->fld[4].rt_addr_diff_vec_flags)\n+#define ADDR_DIFF_VEC_FLAGS(RTX) X0ADVFLAGS(RTX, 4)\n \n /* Don't forget to change reg_note_name in rtl.c.  */\n enum reg_note { REG_DEAD = 1, REG_INC = 2, REG_EQUIV = 3, REG_WAS_0 = 4,\n@@ -404,11 +471,12 @@ extern const char * const reg_note_name[];\n    The NOTE_INSN_RANGE_{START,END} and NOTE_INSN_LIVE notes record their\n    information as a rtx in the field.  */\n \n-#define NOTE_SOURCE_FILE(INSN)  ((INSN)->fld[3].rtstr)\n-#define NOTE_BLOCK_NUMBER(INSN) ((INSN)->fld[3].rtint)\n-#define NOTE_RANGE_INFO(INSN)   ((INSN)->fld[3].rtx)\n-#define NOTE_LIVE_INFO(INSN)    ((INSN)->fld[3].rtx)\n-#define NOTE_BASIC_BLOCK(INSN)\t((INSN)->fld[3].bb)\n+#define NOTE_SOURCE_FILE(INSN) \tX0STR(INSN, 3)\n+#define NOTE_BLOCK_NUMBER(INSN)\tX0INT(INSN, 3)\n+#define NOTE_EH_HANDLER(INSN)\tX0INT(INSN, 3)\n+#define NOTE_RANGE_INFO(INSN)  \tX0EXP(INSN, 3)\n+#define NOTE_LIVE_INFO(INSN)   \tX0EXP(INSN, 3)\n+#define NOTE_BASIC_BLOCK(INSN)\tX0EXP(INSN, 3)\n \n /* If the NOTE_BLOCK_NUMBER field gets a -1, it means create a new\n    block node for a live range block.  */\n@@ -488,7 +556,7 @@ extern const char * const note_insn_name[];\n \n /* In jump.c, each label contains a count of the number\n    of LABEL_REFs that point at it, so unused labels can be deleted.  */\n-#define LABEL_NUSES(LABEL) ((LABEL)->fld[5].rtint)\n+#define LABEL_NUSES(LABEL) X0INT(LABEL, 5)\n \n /* The original regno this ADDRESSOF was built for.  */\n #define ADDRESSOF_REGNO(RTX) XINT(RTX, 1)\n@@ -499,24 +567,24 @@ extern const char * const note_insn_name[];\n /* In jump.c, each JUMP_INSN can point to a label that it can jump to,\n    so that if the JUMP_INSN is deleted, the label's LABEL_NUSES can\n    be decremented and possibly the label can be deleted.  */\n-#define JUMP_LABEL(INSN)   ((INSN)->fld[7].rtx)\n+#define JUMP_LABEL(INSN)   X0EXP(INSN, 7)\n \n /* Once basic blocks are found in flow.c,\n    each CODE_LABEL starts a chain that goes through\n    all the LABEL_REFs that jump to that label.\n    The chain eventually winds up at the CODE_LABEL; it is circular.  */\n-#define LABEL_REFS(LABEL) ((LABEL)->fld[6].rtx)\n+#define LABEL_REFS(LABEL) X0EXP(LABEL, 6)\n \f\n /* This is the field in the LABEL_REF through which the circular chain\n    of references to a particular label is linked.\n    This chain is set up in flow.c.  */\n \n-#define LABEL_NEXTREF(REF) ((REF)->fld[1].rtx)\n+#define LABEL_NEXTREF(REF) X0EXP(REF, 1)\n \n /* Once basic blocks are found in flow.c,\n    Each LABEL_REF points to its containing instruction with this field.  */\n \n-#define CONTAINING_INSN(RTX) ((RTX)->fld[2].rtx)\n+#define CONTAINING_INSN(RTX) X0EXP(RTX, 2)\n \n /* For a REG rtx, REGNO extracts the register number.  */\n \n@@ -601,7 +669,7 @@ extern const char * const note_insn_name[];\n    some front-ends, these numbers may correspond in some way to types,\n    or other language-level entities, but they need not, and the\n    back-end makes no such assumptions.  */\n-#define MEM_ALIAS_SET(RTX) (XINT (RTX, 1))\n+#define MEM_ALIAS_SET(RTX) X0INT(RTX, 1)\n \n /* For a LABEL_REF, 1 means that this reference is to a label outside the\n    loop containing the reference.  */"}, {"sha": "944d1bb47f3faff8a355d4f05e0260c8338613be", "filename": "gcc/varasm.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef178af3a4faba2594c5a106ca721a5c3db4f693/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=ef178af3a4faba2594c5a106ca721a5c3db4f693", "patch": "@@ -3745,6 +3745,9 @@ mark_constant_pool ()\n       if (!pool->mark)\n \t  continue;\n \n+      /* skip CONST_DOUBLEs too - correct?  */\n+      if (GET_CODE (pool->constant) == CONST_DOUBLE)\n+\tcontinue;\n       label = XSTR (pool->constant, 0);\n \n       /* Be sure the symbol's value is marked. */"}]}