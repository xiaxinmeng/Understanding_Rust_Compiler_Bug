{"sha": "683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "node_id": "C_kwDOANBUbNoAKDY4M2YxMTg0Mzk3NGYwYmRmNDJmNzljZGNiYjBjMmI0M2M3YjgxYjA", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-07-04T11:51:02Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2022-07-04T11:52:02Z"}, "message": "OpenMP: Move omp requires checks to libgomp\n\nHandle reverse_offload, unified_address, and unified_shared_memory\nrequirements in libgomp by saving them alongside the offload table.\nWhen the device lto1 runs, it extracts the data for mkoffload. The\nlatter than passes the value on to GOMP_offload_register_ver.\n\nlto1 (either the host one, with -flto [+ ENABLE_OFFLOADING], or in the\noffload-device lto1) also does the the consistency check is done,\nerroring out when the 'omp requires' clause use is inconsistent.\n\nFor all in-principle supported devices, if a requirement cannot be fulfilled,\nthe device is excluded from the (supported) devices list. Currently, none of\nthose requirements are marked as supported for any of the non-host devices.\n\ngcc/c/ChangeLog:\n\n\t* c-parser.cc (c_parser_omp_target_data, c_parser_omp_target_update,\n\tc_parser_omp_target_enter_data, c_parser_omp_target_exit_data): Set\n\tOMP_REQUIRES_TARGET_USED.\n\t(c_parser_omp_requires): Remove sorry.\n\ngcc/ChangeLog:\n\n\t* config/gcn/mkoffload.cc (process_asm): Write '#include <stdint.h>'.\n\t(process_obj): Pass omp_requires_mask to GOMP_offload_register_ver.\n\t(main): Ask lto1 to obtain omp_requires_mask and pass it on.\n\t* config/nvptx/mkoffload.cc (process, main): Likewise.\n\t* lto-cgraph.cc (omp_requires_to_name): New.\n\t(input_offload_tables): Save omp_requires_mask.\n\t(output_offload_tables): Read it, check for consistency,\n\tsave value for mkoffload.\n\t* omp-low.cc (lower_omp_target): Force output_offloadtables\n\tcall for OMP_REQUIRES_TARGET_USED.\n\ngcc/cp/ChangeLog:\n\n\t* parser.cc (cp_parser_omp_target_data,\n\tcp_parser_omp_target_enter_data, cp_parser_omp_target_exit_data,\n\tcp_parser_omp_target_update): Set OMP_REQUIRES_TARGET_USED.\n\t(cp_parser_omp_requires): Remove sorry.\n\ngcc/fortran/ChangeLog:\n\n\t* openmp.cc (gfc_match_omp_requires): Remove sorry.\n\t* parse.cc (decode_omp_directive): Don't regard 'declare target'\n\tas target usage for 'omp requires'; add more flags to\n\tomp_requires_mask.\n\ninclude/ChangeLog:\n\n\t* gomp-constants.h (GOMP_VERSION): Bump to 2.\n\t(GOMP_REQUIRES_UNIFIED_ADDRESS, GOMP_REQUIRES_UNIFIED_SHARED_MEMORY,\n\tGOMP_REQUIRES_REVERSE_OFFLOAD, GOMP_REQUIRES_TARGET_USED):\n\tNew defines.\n\nlibgomp/ChangeLog:\n\n\t* libgomp-plugin.h (GOMP_OFFLOAD_get_num_devices): Add\n\tomp_requires_mask arg.\n\t* plugin/plugin-gcn.c (GOMP_OFFLOAD_get_num_devices): Likewise;\n\treturn -1 when device available but omp_requires_mask != 0.\n\t* plugin/plugin-nvptx.c (GOMP_OFFLOAD_get_num_devices): Likewise.\n\t* oacc-host.c (host_get_num_devices, host_openacc_get_property):\n\tUpdate call.\n\t* oacc-init.c (resolve_device, acc_init_1, acc_shutdown_1,\n\tgoacc_attach_host_thread_to_device, acc_get_num_devices,\n\tacc_set_device_num, get_property_any): Likewise.\n\t* target.c (omp_requires_mask): New global var.\n\t(gomp_requires_to_name): New.\n\t(GOMP_offload_register_ver): Handle passed omp_requires_mask.\n\t(gomp_target_init): Handle omp_requires_mask.\n\t* libgomp.texi (OpenMP 5.0): Update requires impl. status.\n\t(OpenMP 5.1): Add a missed item.\n\t(OpenMP 5.2): Mark linear-clause change as supported in C/C++.\n\t* testsuite/libgomp.c-c++-common/requires-1-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-1.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-2-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-2.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-3-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-3.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-4-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-4.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-5-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-5.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-6.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-7-aux.c: New test.\n\t* testsuite/libgomp.c-c++-common/requires-7.c: New test.\n\t* testsuite/libgomp.fortran/requires-1-aux.f90: New test.\n\t* testsuite/libgomp.fortran/requires-1.f90: New test.\n\nliboffloadmic/ChangeLog:\n\n\t* plugin/libgomp-plugin-intelmic.cpp (GOMP_OFFLOAD_get_num_devices):\n\tReturn -1 when device available but omp_requires_mask != 0.\n\ngcc/testsuite/ChangeLog:\n\n\t* c-c++-common/gomp/requires-4.c: Update dg-*.\n\t* c-c++-common/gomp/reverse-offload-1.c: Likewise.\n\t* c-c++-common/gomp/target-device-ancestor-2.c: Likewise.\n\t* c-c++-common/gomp/target-device-ancestor-3.c: Likewise.\n\t* c-c++-common/gomp/target-device-ancestor-4.c: Likewise.\n\t* c-c++-common/gomp/target-device-ancestor-5.c: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-3.f90: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-4.f90: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-5.f90: Likewise.\n\t* gfortran.dg/gomp/target-device-ancestor-2.f90: Likewise. Move\n\tpost-FE checks to ...\n\t* gfortran.dg/gomp/target-device-ancestor-2a.f90: ... this new file.\n\t* gfortran.dg/gomp/requires-8.f90: Update as we don't regard\n\t'declare target' for the 'requires' usage requirement.\n\nCo-authored-by: Chung-Lin Tang <cltang@codesourcery.com>\nCo-authored-by: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "6464c7a452dd52c98ef5d08071d552ecd4e42276", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6464c7a452dd52c98ef5d08071d552ecd4e42276"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10b502fb78351a4073b6682c026a92c82d3da6c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10b502fb78351a4073b6682c026a92c82d3da6c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10b502fb78351a4073b6682c026a92c82d3da6c5"}], "stats": {"total": 848, "additions": 716, "deletions": 132}, "files": [{"sha": "9c02141e2c66fdfc2e27db2c3b4f34f074990c79", "filename": "gcc/c/c-parser.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fc%2Fc-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fc%2Fc-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fc-parser.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -20915,6 +20915,10 @@ c_parser_omp_teams (location_t loc, c_parser *parser,\n static tree\n c_parser_omp_target_data (location_t loc, c_parser *parser, bool *if_p)\n {\n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target data\");\n@@ -21010,6 +21014,10 @@ c_parser_omp_target_update (location_t loc, c_parser *parser,\n       return false;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree stmt = make_node (OMP_TARGET_UPDATE);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_UPDATE_CLAUSES (stmt) = clauses;\n@@ -21057,6 +21065,10 @@ c_parser_omp_target_enter_data (location_t loc, c_parser *parser,\n       return true;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target enter data\");\n@@ -21151,6 +21163,10 @@ c_parser_omp_target_exit_data (location_t loc, c_parser *parser,\n       return true;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = c_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n \t\t\t\t\"#pragma omp target exit data\");\n@@ -22779,9 +22795,6 @@ c_parser_omp_requires (c_parser *parser)\n \t      c_parser_skip_to_pragma_eol (parser, false);\n \t      return;\n \t    }\n-\t  if (p && this_req != OMP_REQUIRES_DYNAMIC_ALLOCATORS)\n-\t    sorry_at (cloc, \"%qs clause on %<requires%> directive not \"\n-\t\t\t    \"supported yet\", p);\n \t  if (p)\n \t    c_parser_consume_token (parser);\n \t  if (this_req)"}, {"sha": "b8b3fecfcb4176c78c7f9bf94203eb3f4905fd9f", "filename": "gcc/config/gcn/mkoffload.cc", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fmkoffload.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -611,6 +611,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n   struct regcount *regcounts = XOBFINISH (&regcounts_os, struct regcount *);\n \n   fprintf (cfile, \"#include <stdlib.h>\\n\");\n+  fprintf (cfile, \"#include <stdint.h>\\n\");\n   fprintf (cfile, \"#include <stdbool.h>\\n\\n\");\n \n   fprintf (cfile, \"static const int gcn_num_vars = %d;\\n\\n\", var_count);\n@@ -664,7 +665,7 @@ process_asm (FILE *in, FILE *out, FILE *cfile)\n /* Embed an object file into a C source file.  */\n \n static void\n-process_obj (FILE *in, FILE *cfile)\n+process_obj (FILE *in, FILE *cfile, uint32_t omp_requires)\n {\n   size_t len = 0;\n   const char *input = read_file (in, &len);\n@@ -692,16 +693,18 @@ process_obj (FILE *in, FILE *cfile)\n \n   fprintf (cfile,\n \t   \"static const struct gcn_image_desc {\\n\"\n+\t   \"  uintptr_t omp_requires_mask;\\n\"\n \t   \"  const struct gcn_image *gcn_image;\\n\"\n \t   \"  unsigned kernel_count;\\n\"\n \t   \"  const struct hsa_kernel_description *kernel_infos;\\n\"\n \t   \"  unsigned global_variable_count;\\n\"\n \t   \"} target_data = {\\n\"\n+\t   \"  %d,\\n\"\n \t   \"  &gcn_image,\\n\"\n \t   \"  sizeof (gcn_kernels) / sizeof (gcn_kernels[0]),\\n\"\n \t   \"  gcn_kernels,\\n\"\n \t   \"  gcn_num_vars\\n\"\n-\t   \"};\\n\\n\");\n+\t   \"};\\n\\n\", omp_requires);\n \n   fprintf (cfile,\n \t   \"#ifdef __cplusplus\\n\"\n@@ -1077,9 +1080,27 @@ main (int argc, char **argv)\n       unsetenv (\"COMPILER_PATH\");\n       unsetenv (\"LIBRARY_PATH\");\n \n+      char *omp_requires_file;\n+      if (save_temps)\n+\tomp_requires_file = concat (dumppfx, \".mkoffload.omp_requires\", NULL);\n+      else\n+\tomp_requires_file = make_temp_file (\".mkoffload.omp_requires\");\n+\n       /* Run the compiler pass.  */\n+      xputenv (concat (\"GCC_OFFLOAD_OMP_REQUIRES_FILE=\", omp_requires_file, NULL));\n       fork_execute (cc_argv[0], CONST_CAST (char **, cc_argv), true, \".gcc_args\");\n       obstack_free (&cc_argv_obstack, NULL);\n+      unsetenv(\"GCC_OFFLOAD_OMP_REQUIRES_FILE\");\n+\n+      in = fopen (omp_requires_file, \"rb\");\n+      if (!in)\n+\tfatal_error (input_location, \"cannot open omp_requires file %qs\",\n+\t\t     omp_requires_file);\n+      uint32_t omp_requires;\n+      if (fread (&omp_requires, sizeof (omp_requires), 1, in) != 1)\n+\tfatal_error (input_location, \"cannot read omp_requires file %qs\",\n+\t\t     omp_requires_file);\n+      fclose (in);\n \n       in = fopen (gcn_s1_name, \"r\");\n       if (!in)\n@@ -1102,7 +1123,7 @@ main (int argc, char **argv)\n       if (!in)\n \tfatal_error (input_location, \"cannot open intermediate gcn obj file\");\n \n-      process_obj (in, cfile);\n+      process_obj (in, cfile, omp_requires);\n \n       fclose (in);\n "}, {"sha": "d8c81eb05473994cccc1670092640db0a83e9131", "filename": "gcc/config/nvptx/mkoffload.cc", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fmkoffload.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -231,7 +231,7 @@ access_check (const char *name, int mode)\n }\n \n static void\n-process (FILE *in, FILE *out)\n+process (FILE *in, FILE *out, uint32_t omp_requires)\n {\n   size_t len = 0;\n   const char *input = read_file (in, &len);\n@@ -240,6 +240,8 @@ process (FILE *in, FILE *out)\n   unsigned obj_count = 0;\n   unsigned ix;\n \n+  fprintf (out, \"#include <stdint.h>\\n\\n\");\n+\n   /* Dump out char arrays for each PTX object file.  These are\n      terminated by a NUL.  */\n   for (size_t i = 0; i != len;)\n@@ -309,19 +311,20 @@ process (FILE *in, FILE *out)\n \n   fprintf (out,\n \t   \"static const struct nvptx_tdata {\\n\"\n+\t   \"  uintptr_t omp_requires_mask;\\n\"\n \t   \"  const struct ptx_obj *ptx_objs;\\n\"\n \t   \"  unsigned ptx_num;\\n\"\n \t   \"  const char *const *var_names;\\n\"\n \t   \"  unsigned var_num;\\n\"\n \t   \"  const struct nvptx_fn *fn_names;\\n\"\n \t   \"  unsigned fn_num;\\n\"\n \t   \"} target_data = {\\n\"\n-\t   \"  ptx_objs, sizeof (ptx_objs) / sizeof (ptx_objs[0]),\\n\"\n+\t   \"  %d, ptx_objs, sizeof (ptx_objs) / sizeof (ptx_objs[0]),\\n\"\n \t   \"  var_mappings,\"\n \t   \"  sizeof (var_mappings) / sizeof (var_mappings[0]),\\n\"\n \t   \"  func_mappings,\"\n \t   \"  sizeof (func_mappings) / sizeof (func_mappings[0])\\n\"\n-\t   \"};\\n\\n\");\n+\t   \"};\\n\\n\", omp_requires);\n \n   fprintf (out, \"#ifdef __cplusplus\\n\"\n \t   \"extern \\\"C\\\" {\\n\"\n@@ -583,19 +586,37 @@ main (int argc, char **argv)\n       unsetenv (\"COMPILER_PATH\");\n       unsetenv (\"LIBRARY_PATH\");\n \n+      char *omp_requires_file;\n+      if (save_temps)\n+\tomp_requires_file = concat (dumppfx, \".mkoffload.omp_requires\", NULL);\n+      else\n+\tomp_requires_file = make_temp_file (\".mkoffload.omp_requires\");\n+\n+      xputenv (concat (\"GCC_OFFLOAD_OMP_REQUIRES_FILE=\", omp_requires_file, NULL));\n       fork_execute (new_argv[0], CONST_CAST (char **, new_argv), true,\n \t\t    \".gcc_args\");\n       obstack_free (&argv_obstack, NULL);\n+      unsetenv(\"GCC_OFFLOAD_OMP_REQUIRES_FILE\");\n \n       xputenv (concat (\"GCC_EXEC_PREFIX=\", execpath, NULL));\n       xputenv (concat (\"COMPILER_PATH=\", cpath, NULL));\n       xputenv (concat (\"LIBRARY_PATH=\", lpath, NULL));\n \n+      in = fopen (omp_requires_file, \"rb\");\n+      if (!in)\n+\tfatal_error (input_location, \"cannot open omp_requires file %qs\",\n+\t\t     omp_requires_file);\n+      uint32_t omp_requires;\n+      if (fread (&omp_requires, sizeof (omp_requires), 1, in) != 1)\n+\tfatal_error (input_location, \"cannot read omp_requires file %qs\",\n+\t\t     omp_requires_file);\n+      fclose (in);\n+\n       in = fopen (ptx_name, \"r\");\n       if (!in)\n \tfatal_error (input_location, \"cannot open intermediate ptx file\");\n \n-      process (in, out);\n+      process (in, out, omp_requires);\n       fclose (in);\n     }\n "}, {"sha": "df657a3fb2b1e7e8d0410c3070306e793a0d4bb2", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -44329,6 +44329,10 @@ cp_parser_omp_teams (cp_parser *parser, cp_token *pragma_tok,\n static tree\n cp_parser_omp_target_data (cp_parser *parser, cp_token *pragma_tok, bool *if_p)\n {\n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target data\", pragma_tok);\n@@ -44432,6 +44436,10 @@ cp_parser_omp_target_enter_data (cp_parser *parser, cp_token *pragma_tok,\n       return true;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_ENTER_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target enter data\", pragma_tok);\n@@ -44531,6 +44539,10 @@ cp_parser_omp_target_exit_data (cp_parser *parser, cp_token *pragma_tok,\n       return true;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree clauses\n     = cp_parser_omp_all_clauses (parser, OMP_TARGET_EXIT_DATA_CLAUSE_MASK,\n \t\t\t\t \"#pragma omp target exit data\", pragma_tok);\n@@ -44625,6 +44637,10 @@ cp_parser_omp_target_update (cp_parser *parser, cp_token *pragma_tok,\n       return true;\n     }\n \n+  if (flag_openmp)\n+    omp_requires_mask\n+      = (enum omp_requires) (omp_requires_mask | OMP_REQUIRES_TARGET_USED);\n+\n   tree stmt = make_node (OMP_TARGET_UPDATE);\n   TREE_TYPE (stmt) = void_type_node;\n   OMP_TARGET_UPDATE_CLAUSES (stmt) = clauses;\n@@ -46919,9 +46935,6 @@ cp_parser_omp_requires (cp_parser *parser, cp_token *pragma_tok)\n \t      cp_parser_skip_to_pragma_eol (parser, pragma_tok);\n \t      return false;\n \t    }\n-\t  if (p && this_req != OMP_REQUIRES_DYNAMIC_ALLOCATORS)\n-\t    sorry_at (cloc, \"%qs clause on %<requires%> directive not \"\n-\t\t\t    \"supported yet\", p);\n \t  if (p)\n \t    cp_lexer_consume_token (parser->lexer);\n \t  if (this_req)"}, {"sha": "51b429a597c07d0199e605a3f46915b8e456d61f", "filename": "gcc/fortran/openmp.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ffortran%2Fopenmp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ffortran%2Fopenmp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -5488,10 +5488,6 @@ gfc_match_omp_requires (void)\n       else\n \tgoto error;\n \n-      if (requires_clause & ~(OMP_REQ_ATOMIC_MEM_ORDER_MASK\n-\t\t\t      | OMP_REQ_DYNAMIC_ALLOCATORS))\n-\tgfc_error_now (\"Sorry, %qs clause at %L on REQUIRES directive is not \"\n-\t\t       \"yet supported\", clause, &old_loc);\n       if (!gfc_omp_requires_add_clause (requires_clause, clause, &old_loc, NULL))\n \tgoto error;\n       requires_clauses |= requires_clause;"}, {"sha": "0b4c596996c6e1406134192beaf7270495e8f42e", "filename": "gcc/fortran/parse.cc", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ffortran%2Fparse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ffortran%2Fparse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -1168,7 +1168,8 @@ decode_omp_directive (void)\n     }\n   switch (ret)\n     {\n-    case ST_OMP_DECLARE_TARGET:\n+    /* Set omp_target_seen; exclude ST_OMP_DECLARE_TARGET.\n+       FIXME: Get clarification, cf. OpenMP Spec Issue #3240.  */\n     case ST_OMP_TARGET:\n     case ST_OMP_TARGET_DATA:\n     case ST_OMP_TARGET_ENTER_DATA:\n@@ -6879,11 +6880,14 @@ gfc_parse_file (void)\n \n   /* Fixup for external procedures and resolve 'omp requires'.  */\n   int omp_requires;\n+  bool omp_target_seen;\n   omp_requires = 0;\n+  omp_target_seen = false;\n   for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;\n        gfc_current_ns = gfc_current_ns->sibling)\n     {\n       omp_requires |= gfc_current_ns->omp_requires;\n+      omp_target_seen |= gfc_current_ns->omp_target_seen;\n       gfc_check_externals (gfc_current_ns);\n     }\n   for (gfc_current_ns = gfc_global_ns_list; gfc_current_ns;\n@@ -6908,6 +6912,22 @@ gfc_parse_file (void)\n       break;\n     }\n \n+  if (omp_target_seen)\n+    omp_requires_mask = (enum omp_requires) (omp_requires_mask\n+\t\t\t\t\t     | OMP_REQUIRES_TARGET_USED);\n+  if (omp_requires & OMP_REQ_REVERSE_OFFLOAD)\n+    omp_requires_mask = (enum omp_requires) (omp_requires_mask\n+\t\t\t\t\t     | OMP_REQUIRES_REVERSE_OFFLOAD);\n+  if (omp_requires & OMP_REQ_UNIFIED_ADDRESS)\n+    omp_requires_mask = (enum omp_requires) (omp_requires_mask\n+\t\t\t\t\t     | OMP_REQUIRES_UNIFIED_ADDRESS);\n+  if (omp_requires & OMP_REQ_UNIFIED_SHARED_MEMORY)\n+    omp_requires_mask\n+\t  = (enum omp_requires) (omp_requires_mask\n+\t\t\t\t | OMP_REQUIRES_UNIFIED_SHARED_MEMORY);\n+  if (omp_requires & OMP_REQ_DYNAMIC_ALLOCATORS)\n+    omp_requires_mask = (enum omp_requires) (omp_requires_mask\n+\t\t\t\t\t     | OMP_REQUIRES_DYNAMIC_ALLOCATORS);\n   /* Do the parse tree dump.  */\n   gfc_current_ns = flag_dump_fortran_original ? gfc_global_ns_list : NULL;\n "}, {"sha": "48629651e3174df743a0d54967591bd6e2e09d84", "filename": "gcc/lto-cgraph.cc", "status": "modified", "additions": 116, "deletions": 1, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Flto-cgraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Flto-cgraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -37,6 +37,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"pass_manager.h\"\n #include \"ipa-utils.h\"\n #include \"omp-offload.h\"\n+#include \"omp-general.h\"\n #include \"stringpool.h\"\n #include \"attribs.h\"\n #include \"alloc-pool.h\"\n@@ -1068,7 +1069,10 @@ read_string (class lto_input_block *ib)\n void\n output_offload_tables (void)\n {\n-  if (vec_safe_is_empty (offload_funcs) && vec_safe_is_empty (offload_vars))\n+  bool output_requires = (flag_openmp\n+\t\t\t  && (omp_requires_mask & OMP_REQUIRES_TARGET_USED) != 0);\n+  if (vec_safe_is_empty (offload_funcs) && vec_safe_is_empty (offload_vars)\n+      && !output_requires)\n     return;\n \n   struct lto_simple_output_block *ob\n@@ -1098,6 +1102,19 @@ output_offload_tables (void)\n \t\t\t       (*offload_vars)[i]);\n     }\n \n+  if (output_requires)\n+    {\n+      HOST_WIDE_INT val = ((HOST_WIDE_INT) omp_requires_mask\n+\t\t\t   & (OMP_REQUIRES_UNIFIED_ADDRESS\n+\t\t\t      | OMP_REQUIRES_UNIFIED_SHARED_MEMORY\n+\t\t\t      | OMP_REQUIRES_REVERSE_OFFLOAD\n+\t\t\t      | OMP_REQUIRES_TARGET_USED));\n+      /* (Mis)use LTO_symtab_edge for this variable.  */\n+      streamer_write_enum (ob->main_stream, LTO_symtab_tags,\n+\t\t\t   LTO_symtab_last_tag, LTO_symtab_edge);\n+      streamer_write_hwi_stream (ob->main_stream, val);\n+    }\n+\n   streamer_write_uhwi_stream (ob->main_stream, 0);\n   lto_destroy_simple_output_block (ob);\n \n@@ -1764,6 +1781,20 @@ input_symtab (void)\n     }\n }\n \n+static void\n+omp_requires_to_name (char *buf, size_t size, HOST_WIDE_INT requires_mask)\n+{\n+  char *end = buf + size, *p = buf;\n+  if (requires_mask & GOMP_REQUIRES_UNIFIED_ADDRESS)\n+    p += snprintf (p, end - p, \"unified_address\");\n+  if (requires_mask & GOMP_REQUIRES_UNIFIED_SHARED_MEMORY)\n+    p += snprintf (p, end - p, \"%sunified_shared_memory\",\n+\t\t   (p == buf ? \"\" : \", \"));\n+  if (requires_mask & GOMP_REQUIRES_REVERSE_OFFLOAD)\n+    p += snprintf (p, end - p, \"%sreverse_offload\",\n+\t\t   (p == buf ? \"\" : \", \"));\n+}\n+\n /* Input function/variable tables that will allow libgomp to look up offload\n    target code, and store them into OFFLOAD_FUNCS and OFFLOAD_VARS.  */\n \n@@ -1773,6 +1804,10 @@ input_offload_tables (bool do_force_output)\n   struct lto_file_decl_data **file_data_vec = lto_get_file_decl_data ();\n   struct lto_file_decl_data *file_data;\n   unsigned int j = 0;\n+  const char *requires_fn = NULL;\n+  tree requires_decl = NULL_TREE;\n+\n+  omp_requires_mask = (omp_requires) 0;\n \n   while ((file_data = file_data_vec[j++]))\n     {\n@@ -1784,6 +1819,7 @@ input_offload_tables (bool do_force_output)\n       if (!ib)\n \tcontinue;\n \n+      tree tmp_decl = NULL_TREE;\n       enum LTO_symtab_tags tag\n \t= streamer_read_enum (ib, LTO_symtab_tags, LTO_symtab_last_tag);\n       while (tag)\n@@ -1799,6 +1835,7 @@ input_offload_tables (bool do_force_output)\n \t\t LTO mode.  */\n \t      if (do_force_output)\n \t\tcgraph_node::get (fn_decl)->mark_force_output ();\n+\t      tmp_decl = fn_decl;\n \t    }\n \t  else if (tag == LTO_symtab_variable)\n \t    {\n@@ -1810,6 +1847,72 @@ input_offload_tables (bool do_force_output)\n \t\t may be no refs to var_decl in offload LTO mode.  */\n \t      if (do_force_output)\n \t\tvarpool_node::get (var_decl)->force_output = 1;\n+\t      tmp_decl = var_decl;\n+\t    }\n+\t  else if (tag == LTO_symtab_edge)\n+\t    {\n+\t      static bool error_emitted = false;\n+\t      HOST_WIDE_INT val = streamer_read_hwi (ib);\n+\n+\t      if (omp_requires_mask == 0)\n+\t\t{\n+\t\t  omp_requires_mask = (omp_requires) val;\n+\t\t  requires_decl = tmp_decl;\n+\t\t  requires_fn = file_data->file_name;\n+\t\t}\n+\t      else if (omp_requires_mask != val && !error_emitted)\n+\t\t{\n+\t\t  const char *fn1 = requires_fn;\n+\t\t  if (requires_decl != NULL_TREE)\n+\t\t    {\n+\t\t      while (DECL_CONTEXT (requires_decl) != NULL_TREE\n+\t\t\t     && TREE_CODE (requires_decl) != TRANSLATION_UNIT_DECL)\n+\t\t\trequires_decl = DECL_CONTEXT (requires_decl);\n+\t\t      if (requires_decl != NULL_TREE)\n+\t\t\tfn1 = IDENTIFIER_POINTER (DECL_NAME (requires_decl));\n+\t\t    }\n+\n+\t\t  const char *fn2 = file_data->file_name;\n+\t\t  if (tmp_decl != NULL_TREE)\n+\t\t    {\n+\t\t      while (DECL_CONTEXT (tmp_decl) != NULL_TREE\n+\t\t\t     && TREE_CODE (tmp_decl) != TRANSLATION_UNIT_DECL)\n+\t\t\ttmp_decl = DECL_CONTEXT (tmp_decl);\n+\t\t      if (tmp_decl != NULL_TREE)\n+\t\t\tfn2 = IDENTIFIER_POINTER (DECL_NAME (requires_decl));\n+\t\t    }\n+\n+\t\t  char buf1[sizeof (\"unified_address, unified_shared_memory, \"\n+\t\t\t\t    \"reverse_offload\")];\n+\t\t  char buf2[sizeof (\"unified_address, unified_shared_memory, \"\n+\t\t\t\t    \"reverse_offload\")];\n+\t\t  omp_requires_to_name (buf2, sizeof (buf2),\n+\t\t\t\t\tval != OMP_REQUIRES_TARGET_USED\n+\t\t\t\t\t? val\n+\t\t\t\t\t: (HOST_WIDE_INT) omp_requires_mask);\n+\t\t  if (val != OMP_REQUIRES_TARGET_USED\n+\t\t      && omp_requires_mask != OMP_REQUIRES_TARGET_USED)\n+\t\t    {\n+\t\t      omp_requires_to_name (buf1, sizeof (buf1),\n+\t\t\t\t\t    omp_requires_mask);\n+\t\t      error (\"OpenMP %<requires%> directive with non-identical \"\n+\t\t\t     \"clauses in multiple compilation units: %qs vs. \"\n+\t\t\t     \"%qs\", buf1, buf2);\n+\t\t      inform (UNKNOWN_LOCATION, \"%qs has %qs\", fn1, buf1);\n+\t\t      inform (UNKNOWN_LOCATION, \"%qs has %qs\", fn2, buf2);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      error (\"OpenMP %<requires%> directive with %qs specified \"\n+\t\t\t     \"only in some compilation units\", buf2);\n+\t\t      inform (UNKNOWN_LOCATION, \"%qs has %qs\",\n+\t\t\t      val != OMP_REQUIRES_TARGET_USED ? fn2 : fn1,\n+\t\t\t      buf2);\n+\t\t      inform (UNKNOWN_LOCATION, \"but %qs has not\",\n+\t\t\t      val != OMP_REQUIRES_TARGET_USED ? fn1 : fn2);\n+\t\t    }\n+\t\t  error_emitted = true;\n+\t\t}\n \t    }\n \t  else\n \t    fatal_error (input_location,\n@@ -1821,6 +1924,18 @@ input_offload_tables (bool do_force_output)\n       lto_destroy_simple_input_block (file_data, LTO_section_offload_table,\n \t\t\t\t      ib, data, len);\n     }\n+#ifdef ACCEL_COMPILER\n+  char *omp_requires_file = getenv (\"GCC_OFFLOAD_OMP_REQUIRES_FILE\");\n+  if (omp_requires_file == NULL || omp_requires_file[0] == '\\0')\n+    fatal_error (input_location, \"GCC_OFFLOAD_OMP_REQUIRES_FILE unset\");\n+  FILE *f = fopen (omp_requires_file, \"wb\");\n+  if (!f)\n+    fatal_error (input_location, \"Cannot open omp_requires file %qs\",\n+\t\t omp_requires_file);\n+  uint32_t req_mask = omp_requires_mask;\n+  fwrite (&req_mask, sizeof (req_mask), 1, f);\n+  fclose (f);\n+#endif\n }\n \n /* True when we need optimization summary for NODE.  */"}, {"sha": "d73c165f0298a6098829ddd2d8a8ce055b0681dd", "filename": "gcc/omp-low.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fomp-low.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Fomp-low.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.cc?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -12701,6 +12701,11 @@ lower_omp_target (gimple_stmt_iterator *gsi_p, omp_context *ctx)\n       gcc_unreachable ();\n     }\n \n+  /* Ensure that requires map is written via output_offload_tables, even if only\n+     'target (enter/exit) data' is used in the translation unit.  */\n+  if (ENABLE_OFFLOADING && (omp_requires_mask & OMP_REQUIRES_TARGET_USED))\n+    g->have_offload = true;\n+\n   clauses = gimple_omp_target_clauses (stmt);\n \n   gimple_seq dep_ilist = NULL;"}, {"sha": "8f45d83ea6e30c2d564ec14d6fd5f463575e1a51", "filename": "gcc/testsuite/c-c++-common/gomp/requires-4.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Frequires-4.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -9,5 +9,3 @@ foo (void)\n #pragma omp requires unified_shared_memory\t/* { dg-error \"'unified_shared_memory' clause used lexically after first target construct or offloading API\" } */\n #pragma omp requires unified_address\t/* { dg-error \"'unified_address' clause used lexically after first target construct or offloading API\" } */\n #pragma omp requires reverse_offload\t/* { dg-error \"'reverse_offload' clause used lexically after first target construct or offloading API\" } */\n-\n-/* { dg-prune-output \"not supported yet\" } */"}, {"sha": "3452156f9484ea0e99d12aa2fc7e24af3a1d095f", "filename": "gcc/testsuite/c-c++-common/gomp/reverse-offload-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Freverse-offload-1.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -43,7 +43,7 @@ tg_fn (int *x, int *y)\n   x2 = x2 + 2 + called_in_target1 ();\n   y2 = y2 + 7;\n \n-  #pragma omp target device(ancestor : 1) map(tofrom: x2)\n+  #pragma omp target device(ancestor : 1) map(tofrom: x2)  /* { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" } */\n     check_offload(&x2, &y2);\n \n   if (x2 != 2+2+3+42 || y2 != 3 + 7)"}, {"sha": "b16e701bd5a175b5d647143e15fe35b9a32ad89b", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-2.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-2.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -1,13 +1,11 @@\n /* { dg-do compile } */\n \n-#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+#pragma omp requires reverse_offload\n \n void\n foo (int n)\n {\n-  /* The following test is marked with 'xfail' because a previous 'sorry' from\n-     'reverse_offload' suppresses the 'sorry' for 'ancestor'.  */\n-  #pragma omp target device (ancestor: 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  #pragma omp target device (ancestor: 1)\n   ;\n \n \n@@ -19,9 +17,9 @@ foo (int n)\n   #pragma omp target device (ancestor : 42) /* { dg-error \"the 'device' clause expression must evaluate to '1'\" } */\n   ;\n \n-  #pragma omp target device (ancestor : n) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  #pragma omp target device (ancestor : n)\n   ;\n-  #pragma omp target device (ancestor : n + 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  #pragma omp target device (ancestor : n + 1)\n   ;\n \n "}, {"sha": "d16590107d2fe461f2b220bcf522340e690ddafc", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-3.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-3.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -11,7 +11,7 @@ int bar (void);\n \n /* { dg-do compile } */\n \n-#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+#pragma omp requires reverse_offload\n \n void\n foo (void)"}, {"sha": "241234f8daf6d25d36c396ad3c1ad4a28acc4e2a", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-4.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -4,12 +4,12 @@\n   /* Test to ensure that device-modifier 'ancestor' is parsed correctly in\n      device clauses. */\n \n-#pragma omp requires reverse_offload /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+#pragma omp requires reverse_offload\n \n void\n foo (void)\n {\n-  #pragma omp target device (ancestor: 1) /* { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } } */\n+  #pragma omp target device (ancestor: 1) /* { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" } */\n   ;\n \n }"}, {"sha": "b1520ff0636e415dadd9957b4dae1d818bd82e38", "filename": "gcc/testsuite/c-c++-common/gomp/target-device-ancestor-5.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fgomp%2Ftarget-device-ancestor-5.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -1,4 +1,4 @@\n-#pragma omp requires reverse_offload  /* { dg-message \"sorry, unimplemented: 'reverse_offload' clause on 'requires' directive not supported yet\" } */\n+#pragma omp requires reverse_offload\n \n void\n foo ()"}, {"sha": "583c5a56b32e07f7c1f50aea589ce4012a73cd2b", "filename": "gcc/testsuite/gfortran.dg/gomp/requires-8.f90", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Frequires-8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Frequires-8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Frequires-8.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -1,3 +1,7 @@\n+module m0\n+  integer :: x\n+end module m0\n+\n module m  !  { dg-error \"has OpenMP device constructs/routines but does not set !.OMP REQUIRES UNIFIED_SHARED_MEMORY but other program units do\" }\n   !$omp requires reverse_offload\n contains\n@@ -13,10 +17,14 @@ subroutine bar2\n  end subroutine foo\n end module m\n \n-subroutine bar  ! { dg-error \"has OpenMP device constructs/routines but does not set !.OMP REQUIRES REVERSE_OFFLOAD but other program units do\" }\n+subroutine bar\n   !use m\n-  !$omp requires unified_shared_memory\n+  !$omp requires unified_shared_memory  ! Possibly OK - needs OpenMP Lang Spec clarification (-> #3240)\n   !$omp declare target\n end subroutine bar\n \n-! { dg-prune-output \"not yet supported\" }\n+subroutine foobar  ! { dg-error \"has OpenMP device constructs/routines but does not set !.OMP REQUIRES REVERSE_OFFLOAD but other program units do\" }\n+  use m0\n+  !$omp requires unified_shared_memory\n+  !$omp target enter data map(to:x)\n+end subroutine foobar"}, {"sha": "230c690d84c5f94d05e58e1ef9879a6a63094644", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-2.f90", "status": "modified", "additions": 5, "deletions": 65, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -4,19 +4,16 @@\n \n integer :: a, b, c\n \n-!$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+!$omp requires reverse_offload\n \n \n-! The following test case is marked with 'xfail' because a previous 'sorry' from\n-! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n-\n-!$omp target device (ancestor: 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp target device (ancestor: 1)\n !$omp end target\n \n-!$omp target device (ancestor : a)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp target device (ancestor : a)\n !$omp end target\n \n-!$omp target device (ancestor : a + 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp target device (ancestor : a + 1)\n !$omp end target\n \n \n@@ -32,61 +29,4 @@\n !$omp target device (42)\n !$omp end target\n \n-\n-! Ensure that no OpenMP constructs appear inside target regions with 'ancestor'.\n-! The following test case is marked with 'xfail' because a previous 'sorry' from\n-! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n-\n-!$omp target device (ancestor: 1)\n-  !$omp teams  ! { dg-error \"\" \"OpenMP constructs are not allowed in target region with 'ancestor'\" { xfail *-*-* } }\n-  !$omp end teams\n-!$omp end target\n-\n-!$omp target device (device_num: 1)\n-  !$omp teams\n-  !$omp end teams\n-!$omp end target\n-\n-!$omp target device (1)\n-  !$omp teams\n-  !$omp end teams\n-!$omp end target\n-\n-\n-! Ensure that with 'ancestor' only the 'device', 'firstprivate', 'private',\n-! 'defaultmap', and 'map' clauses appear on the construct.\n-! The following test case is marked with 'xfail' because a previous 'sorry' from\n-! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n-\n-!$omp target nowait device (ancestor: 1)  ! { dg-error \"\" \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" { xfail *-*-* } }\n-!$omp end target\n-\n-!$omp target device (ancestor: 1) nowait  ! { dg-error \"\" \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" { xfail *-*-* } }\n-!$omp end target\n-\n-!$omp target nowait device (device_num: 1)\n-!$omp end target\n-\n-!$omp target nowait device (1)\n-!$omp end target\n-\n-!$omp target device (ancestor: 1) firstprivate (a) private (b) defaultmap (none) map (c)\n-!$omp end target\n-\n-\n-! Ensure that 'ancestor' is only used with 'target' constructs (not with\n-! 'target data', 'target update' etc.).\n-! The following test case is marked with 'xfail' because a previous 'sorry' from\n-! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n-\n-!$omp target data map (a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n-!$omp end target data\n-\n-!$omp target enter data map (to: a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n-!$omp target exit data map (from: a) device (ancestor: 1)  ! { dg-error \"\" \"'device' clause with 'ancestor' is only allowed on 'target' construct\" { xfail *-*-* } }\n-\n-!$omp target update to (a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" \"\" { xfail *-*-* } }\n-! { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" \"\" { xfail *-*-* } .-1 }\n-\n-\n-end\n\\ No newline at end of file\n+end"}, {"sha": "feb76fe214419e94f2a0b9f21128f1f6e32a0a16", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-2a.f90", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2a.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2a.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-2a.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do compile }\n+\n+implicit none\n+\n+integer :: a, b, c\n+\n+!$omp requires reverse_offload\n+\n+!$omp target device (ancestor: 1)\n+!$omp end target\n+\n+!$omp target device (ancestor : a)\n+!$omp end target\n+\n+!$omp target device (ancestor : a + 1)\n+!$omp end target\n+\n+\n+!$omp target device (device_num:42)\n+!$omp end target\n+\n+!$omp target device (42)\n+!$omp end target\n+\n+\n+! Ensure that no OpenMP constructs appear inside target regions with 'ancestor'.\n+\n+!$omp target device (ancestor: 1)\n+  !$omp teams  ! { dg-error \"OpenMP constructs are not allowed in target region with 'ancestor'\" }\n+  !$omp end teams\n+!$omp end target\n+\n+!$omp target device (device_num: 1)\n+  !$omp teams\n+  !$omp end teams\n+!$omp end target\n+\n+!$omp target device (1)\n+  !$omp teams\n+  !$omp end teams\n+!$omp end target\n+\n+\n+! Ensure that with 'ancestor' only the 'device', 'firstprivate', 'private',\n+! 'defaultmap', and 'map' clauses appear on the construct.\n+\n+!$omp target nowait device (ancestor: 1)  ! { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" }\n+!$omp end target\n+\n+!$omp target device (ancestor: 1) nowait  ! { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" }\n+!$omp end target\n+\n+!$omp target nowait device (device_num: 1)\n+!$omp end target\n+\n+!$omp target nowait device (1)\n+!$omp end target\n+\n+!$omp target device (ancestor: 1) firstprivate (a) private (b) defaultmap (none) map (c)\n+!$omp end target\n+\n+\n+! Ensure that 'ancestor' is only used with 'target' constructs (not with\n+! 'target data', 'target update' etc.).\n+! The following test case is marked with 'xfail' because a previous 'sorry' from\n+! 'reverse_offload' suppresses the 'sorry' for 'ancestor'.\n+\n+!$omp target data map (a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" }\n+!$omp end target data\n+\n+!$omp target enter data map (to: a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" }\n+!$omp target exit data map (from: a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" }\n+\n+!$omp target update to (a) device (ancestor: 1)  ! { dg-error \"'device' clause with 'ancestor' is only allowed on 'target' construct\" }\n+\n+!$omp target device (ancestor: 1) if(.false.)\n+! { dg-error \"with 'ancestor', only the 'device', 'firstprivate', 'private', 'defaultmap', and 'map' clauses may appear on the construct\" \"\" { target *-*-* } .-1 }\n+!$omp end target\n+\n+end"}, {"sha": "e8975e6a08b5047d169e68ac673c7a9e4d7ecc8f", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-3.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-3.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -16,10 +16,10 @@ subroutine f1 ()\n   implicit none\n   integer :: n\n \n-  !$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+  !$omp requires reverse_offload\n \n   !$omp target device (ancestor : 1)\n-    n = omp_get_thread_num ()  ! { dg-error \"\" \"OpenMP runtime API call 'omp_get_thread_num' in a region with 'device\\\\(ancestor\\\\)' clause\" { xfail *-*-* } }\n+    n = omp_get_thread_num ()  ! { dg-error \"OpenMP runtime API call 'omp_get_thread_num' in a region with 'device\\\\(ancestor\\\\)' clause\" }\n   !$omp end target\n \n   !$omp target device (device_num : 1)\n@@ -30,4 +30,4 @@ subroutine f1 ()\n     n = omp_get_thread_num ()\n   !$omp end target\n \n-end\n\\ No newline at end of file\n+end"}, {"sha": "ab56e2d1d52a654108f2aeae184567593ed9caef", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-4.f90", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-4.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -4,11 +4,11 @@\n ! Test to ensure that device-modifier 'ancestor' is parsed correctly in\n ! device clauses.\n \n-!$omp requires reverse_offload  ! { dg-error \"Sorry, 'reverse_offload' clause at \\\\(1\\\\) on REQUIRES directive is not yet supported\" }\n+!$omp requires reverse_offload\n \n-!$omp target device (ancestor : 1)  ! { dg-message \"\" \"sorry, unimplemented: 'ancestor' not yet supported\" { xfail *-*-* } }\n+!$omp target device (ancestor : 1)  ! { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" }\n !$omp end target\n \n end\n \n-! TODO: dg-final { scan-tree-dump-times \"pragma omp target \\[^\\n\\r)]*device\\\\(ancestor:1\\\\)\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"pragma omp target \\[^\\n\\r)]*device\\\\(ancestor:1\\\\)\" 1 \"original\" } }"}, {"sha": "ca8d4b282a0d9842a3be3560d10be815c5c11a42", "filename": "gcc/testsuite/gfortran.dg/gomp/target-device-ancestor-5.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Ftarget-device-ancestor-5.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -6,7 +6,7 @@\n !\n \n module m\n-  !$omp requires reverse_offload  ! { dg-error \"REQUIRES directive is not yet supported\" }\n+  !$omp requires reverse_offload\n contains\n   subroutine foo()\n     !$omp target device(ancestor:1)\n@@ -17,7 +17,7 @@ subroutine bar()\n     block\n       block\n         block\n-          !$omp target device(ancestor:1)\n+          !$omp target device(ancestor:1)  ! { dg-message \"sorry, unimplemented: 'ancestor' not yet supported\" }\n           !$omp end target\n         end block\n       end block\n@@ -26,7 +26,7 @@ end subroutine bar\n end module m\n \n subroutine foo()\n-  !$omp requires reverse_offload  ! { dg-error \"REQUIRES directive is not yet supported\" }\n+  !$omp requires reverse_offload\n   block\n     block\n       block\n@@ -49,7 +49,7 @@ end subroutine bar\n end subroutine foo\n \n program main\n-  !$omp requires reverse_offload  ! { dg-error \"REQUIRES directive is not yet supported\" }\n+  !$omp requires reverse_offload\n contains\n   subroutine foo()\n     !$omp target device(ancestor:1)"}, {"sha": "3e3078f082ed3f1cd9b42bc51f0c61f950c627f7", "filename": "include/gomp-constants.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/include%2Fgomp-constants.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/include%2Fgomp-constants.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgomp-constants.h?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -282,7 +282,7 @@ enum gomp_map_kind\n /* Versions of libgomp and device-specific plugins.  GOMP_VERSION\n    should be incremented whenever an ABI-incompatible change is introduced\n    to the plugin interface defined in libgomp/libgomp.h.  */\n-#define GOMP_VERSION\t1\n+#define GOMP_VERSION\t2\n #define GOMP_VERSION_NVIDIA_PTX 1\n #define GOMP_VERSION_INTEL_MIC 0\n #define GOMP_VERSION_GCN 2\n@@ -341,6 +341,13 @@ enum gomp_map_kind\n #define GOMP_DEPEND_MUTEXINOUTSET\t4\n #define GOMP_DEPEND_INOUTSET\t\t5\n \n+/* Flag values for requires-directive features, must match corresponding\n+   OMP_REQUIRES_* values in gcc/omp-general.h.  */\n+#define GOMP_REQUIRES_UNIFIED_ADDRESS       0x10\n+#define GOMP_REQUIRES_UNIFIED_SHARED_MEMORY 0x20\n+#define GOMP_REQUIRES_REVERSE_OFFLOAD       0x80\n+#define GOMP_REQUIRES_TARGET_USED           0x200\n+\n /* HSA specific data structures.  */\n \n /* Identifiers of device-specific target arguments.  */"}, {"sha": "ab3ed638475be3ab544fbd9a84d5c22349d24ac5", "filename": "libgomp/libgomp-plugin.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Flibgomp-plugin.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Flibgomp-plugin.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp-plugin.h?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -125,7 +125,7 @@ extern void GOMP_PLUGIN_fatal (const char *, ...)\n extern const char *GOMP_OFFLOAD_get_name (void);\n extern unsigned int GOMP_OFFLOAD_get_caps (void);\n extern int GOMP_OFFLOAD_get_type (void);\n-extern int GOMP_OFFLOAD_get_num_devices (void);\n+extern int GOMP_OFFLOAD_get_num_devices (unsigned int);\n extern bool GOMP_OFFLOAD_init_device (int);\n extern bool GOMP_OFFLOAD_fini_device (int);\n extern unsigned GOMP_OFFLOAD_version (void);"}, {"sha": "39426ff7fbfbc345e16e7e70f916f8390ca5048d", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -189,8 +189,8 @@ The OpenMP 4.5 specification is fully supported.\n       env variable @tab Y @tab\n @item Nested-parallel changes to @emph{max-active-levels-var} ICV @tab Y @tab\n @item @code{requires} directive @tab P\n-      @tab Only fulfillable requirement are @code{atomic_default_mem_order}\n-      and @code{dynamic_allocators}\n+      @tab complete but no non-host devices provides @code{unified_address},\n+      @code{unified_shared_memory} or @code{reverse_offload}\n @item @code{teams} construct outside an enclosing target region @tab Y @tab\n @item Non-rectangular loop nests @tab Y @tab\n @item @code{!=} as relational-op in canonical loop form for C/C++ @tab Y @tab\n@@ -344,6 +344,8 @@ The OpenMP 4.5 specification is fully supported.\n @item @code{unconstrained} and @code{reproducible} modifiers on @code{order}\n       clause @tab Y @tab\n @item Support @code{begin/end declare target} syntax in C/C++ @tab N @tab\n+@item Pointer predetermined firstprivate getting initialized\n+to address of matching mapped list item per 5.1, Sect. 2.21.7.2 @tab N @tab\n @end multitable\n \n \n@@ -361,7 +363,7 @@ The OpenMP 4.5 specification is fully supported.\n @item Clauses on @code{end} directive can be on directive @tab N @tab\n @item Deprecation of no-argument @code{destroy} clause on @code{depobj}\n       @tab N @tab\n-@item @code{linear} clause syntax changes and @code{step} modifier @tab N @tab\n+@item @code{linear} clause syntax changes and @code{step} modifier @tab P @tab only C/C++\n @item Deprecation of minus operator for reductions @tab N @tab\n @item Deprecation of separating @code{map} modifiers without comma @tab N @tab\n @item @code{declare mapper} with iterator and @code{present} modifiers"}, {"sha": "eb11b9cf16a90780c2796a82614d58c05640245a", "filename": "libgomp/oacc-host.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Foacc-host.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Foacc-host.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-host.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -54,7 +54,7 @@ host_get_type (void)\n }\n \n static int\n-host_get_num_devices (void)\n+host_get_num_devices (unsigned int omp_requires_mask __attribute__((unused)))\n {\n   return 1;\n }\n@@ -229,7 +229,7 @@ host_openacc_get_property (int n, enum goacc_property prop)\n {\n   union goacc_property_value nullval = { .val = 0 };\n \n-  if (n >= host_get_num_devices ())\n+  if (n >= host_get_num_devices (0))\n     return nullval;\n \n   switch (prop)"}, {"sha": "42c3e74e6ba3f7fb4e44696584f04b921ecd1443", "filename": "libgomp/oacc-init.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Foacc-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Foacc-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-init.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -148,7 +148,7 @@ resolve_device (acc_device_t d, bool fail_is_error)\n \t      if (dispatchers[d]\n \t\t  && !strcasecmp (goacc_device_type,\n \t\t\t\t  get_openacc_name (dispatchers[d]->name))\n-\t\t  && dispatchers[d]->get_num_devices_func () > 0)\n+\t\t  && dispatchers[d]->get_num_devices_func (0) > 0)\n \t\tgoto found;\n \n \t    if (fail_is_error)\n@@ -169,7 +169,7 @@ resolve_device (acc_device_t d, bool fail_is_error)\n     case acc_device_not_host:\n       /* Find the first available device after acc_device_not_host.  */\n       while (known_device_type_p (++d))\n-\tif (dispatchers[d] && dispatchers[d]->get_num_devices_func () > 0)\n+\tif (dispatchers[d] && dispatchers[d]->get_num_devices_func (0) > 0)\n \t  goto found;\n       if (d_arg == acc_device_default)\n \t{\n@@ -302,7 +302,7 @@ acc_init_1 (acc_device_t d, acc_construct_t parent_construct, int implicit)\n \n   base_dev = resolve_device (d, true);\n \n-  ndevs = base_dev->get_num_devices_func ();\n+  ndevs = base_dev->get_num_devices_func (0);\n \n   if (ndevs <= 0 || goacc_device_num >= ndevs)\n     acc_dev_num_out_of_range (d, goacc_device_num, ndevs);\n@@ -351,7 +351,7 @@ acc_shutdown_1 (acc_device_t d)\n   /* Get the base device for this device type.  */\n   base_dev = resolve_device (d, true);\n \n-  ndevs = base_dev->get_num_devices_func ();\n+  ndevs = base_dev->get_num_devices_func (0);\n \n   /* Unload all the devices of this type that have been opened.  */\n   for (i = 0; i < ndevs; i++)\n@@ -520,7 +520,7 @@ goacc_attach_host_thread_to_device (int ord)\n       base_dev = cached_base_dev;\n     }\n   \n-  num_devices = base_dev->get_num_devices_func ();\n+  num_devices = base_dev->get_num_devices_func (0);\n   if (num_devices <= 0 || ord >= num_devices)\n     acc_dev_num_out_of_range (acc_device_type (base_dev->type), ord,\n \t\t\t      num_devices);\n@@ -599,7 +599,7 @@ acc_get_num_devices (acc_device_t d)\n   if (!acc_dev)\n     return 0;\n \n-  n = acc_dev->get_num_devices_func ();\n+  n = acc_dev->get_num_devices_func (0);\n   if (n < 0)\n     n = 0;\n \n@@ -779,7 +779,7 @@ acc_set_device_num (int ord, acc_device_t d)\n \n       cached_base_dev = base_dev = resolve_device (d, true);\n \n-      num_devices = base_dev->get_num_devices_func ();\n+      num_devices = base_dev->get_num_devices_func (0);\n \n       if (num_devices <= 0 || ord >= num_devices)\n         acc_dev_num_out_of_range (d, ord, num_devices);\n@@ -814,7 +814,7 @@ get_property_any (int ord, acc_device_t d, acc_device_property_t prop)\n \n   struct gomp_device_descr *dev = resolve_device (d, true);\n \n-  int num_devices = dev->get_num_devices_func ();\n+  int num_devices = dev->get_num_devices_func (0);\n \n   if (num_devices <= 0 || ord >= num_devices)\n     acc_dev_num_out_of_range (d, ord, num_devices);"}, {"sha": "ea327bf2ca09c16105b54e390ab9a57ea59774f9", "filename": "libgomp/plugin/plugin-gcn.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Fplugin%2Fplugin-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Fplugin%2Fplugin-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-gcn.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -3221,10 +3221,14 @@ GOMP_OFFLOAD_version (void)\n /* Return the number of GCN devices on the system.  */\n \n int\n-GOMP_OFFLOAD_get_num_devices (void)\n+GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n {\n   if (!init_hsa_context ())\n     return 0;\n+  /* Return -1 if no omp_requires_mask cannot be fulfilled but\n+     devices were present.  */\n+  if (hsa_context.agent_count > 0 && omp_requires_mask != 0)\n+    return -1;\n   return hsa_context.agent_count;\n }\n "}, {"sha": "bc63e274cdfa7639c8663de9e1d4737fce2a3a4e", "filename": "libgomp/plugin/plugin-nvptx.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Fplugin%2Fplugin-nvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Fplugin%2Fplugin-nvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fplugin%2Fplugin-nvptx.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -1175,9 +1175,14 @@ GOMP_OFFLOAD_get_type (void)\n }\n \n int\n-GOMP_OFFLOAD_get_num_devices (void)\n+GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n {\n-  return nvptx_get_num_devices ();\n+  int num_devices = nvptx_get_num_devices ();\n+  /* Return -1 if no omp_requires_mask cannot be fulfilled but\n+     devices were present.  */\n+  if (num_devices > 0 && omp_requires_mask != 0)\n+    return -1;\n+  return num_devices;\n }\n \n bool"}, {"sha": "4dac81862d7f73fece6b05850e60776760e41cd3", "filename": "libgomp/target.c", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -36,6 +36,7 @@\n # include <inttypes.h>  /* For PRIu64.  */\n #endif\n #include <string.h>\n+#include <stdio.h>  /* For snprintf. */\n #include <assert.h>\n #include <errno.h>\n \n@@ -98,6 +99,9 @@ static int num_devices;\n /* Number of GOMP_OFFLOAD_CAP_OPENMP_400 devices.  */\n static int num_devices_openmp;\n \n+/* OpenMP requires mask.  */\n+static int omp_requires_mask;\n+\n /* Similar to gomp_realloc, but release register_lock before gomp_fatal.  */\n \n static void *\n@@ -2314,6 +2318,20 @@ gomp_unload_image_from_device (struct gomp_device_descr *devicep,\n     }\n }\n \n+static void\n+gomp_requires_to_name (char *buf, size_t size, int requires_mask)\n+{\n+  char *end = buf + size, *p = buf;\n+  if (requires_mask & GOMP_REQUIRES_UNIFIED_ADDRESS)\n+    p += snprintf (p, end - p, \"unified_address\");\n+  if (requires_mask & GOMP_REQUIRES_UNIFIED_SHARED_MEMORY)\n+    p += snprintf (p, end - p, \"%sunified_shared_memory\",\n+\t\t   (p == buf ? \"\" : \", \"));\n+  if (requires_mask & GOMP_REQUIRES_REVERSE_OFFLOAD)\n+    p += snprintf (p, end - p, \"%sreverse_offload\",\n+\t\t   (p == buf ? \"\" : \", \"));\n+}\n+\n /* This function should be called from every offload image while loading.\n    It gets the descriptor of the host func and var tables HOST_TABLE, TYPE of\n    the target, and TARGET_DATA needed by target plugin.  */\n@@ -2323,13 +2341,43 @@ GOMP_offload_register_ver (unsigned version, const void *host_table,\n \t\t\t   int target_type, const void *target_data)\n {\n   int i;\n+  int omp_req = 0;\n \n   if (GOMP_VERSION_LIB (version) > GOMP_VERSION)\n     gomp_fatal (\"Library too old for offload (version %u < %u)\",\n \t\tGOMP_VERSION, GOMP_VERSION_LIB (version));\n-  \n+\n+  if (GOMP_VERSION_LIB (version) > 1)\n+    {\n+      omp_req = (int) (size_t) ((void **) target_data)[0];\n+      target_data = &((void **) target_data)[1];\n+    }\n+\n   gomp_mutex_lock (&register_lock);\n \n+  if (omp_req && omp_requires_mask && omp_requires_mask != omp_req)\n+    {\n+      char buf1[sizeof (\"unified_address, unified_shared_memory, \"\n+\t\t\t\"reverse_offload\")];\n+      char buf2[sizeof (\"unified_address, unified_shared_memory, \"\n+\t\t\t\"reverse_offload\")];\n+      gomp_requires_to_name (buf2, sizeof (buf2),\n+\t\t\t     omp_req != GOMP_REQUIRES_TARGET_USED\n+\t\t\t     ? omp_req : omp_requires_mask);\n+      if (omp_req != GOMP_REQUIRES_TARGET_USED\n+\t  && omp_requires_mask != GOMP_REQUIRES_TARGET_USED)\n+\t{\n+\t  gomp_requires_to_name (buf1, sizeof (buf1), omp_requires_mask);\n+\t  gomp_fatal (\"OpenMP 'requires' directive with non-identical clauses \"\n+\t\t      \"in multiple compilation units: '%s' vs. '%s'\",\n+\t\t      buf1, buf2);\n+\t}\n+      else\n+\tgomp_fatal (\"OpenMP 'requires' directive with '%s' specified only in \"\n+\t\t    \"some compilation units\", buf2);\n+    }\n+  omp_requires_mask = omp_req;\n+\n   /* Load image to all initialized devices.  */\n   for (i = 0; i < num_devices; i++)\n     {\n@@ -4125,8 +4173,30 @@ gomp_target_init (void)\n \n \tif (gomp_load_plugin_for_device (&current_device, plugin_name))\n \t  {\n-\t    new_num_devs = current_device.get_num_devices_func ();\n-\t    if (new_num_devs >= 1)\n+\t    int omp_req = omp_requires_mask & ~GOMP_REQUIRES_TARGET_USED;\n+\t    new_num_devs = current_device.get_num_devices_func (omp_req);\n+\t    if (gomp_debug_var > 0 && new_num_devs < 0)\n+\t      {\n+\t\tbool found = false;\n+\t\tint type = current_device.get_type_func ();\n+\t\tfor (int img = 0; img < num_offload_images; img++)\n+\t\t  if (type == offload_images[img].type)\n+\t\t    found = true;\n+\t\tif (found)\n+\t\t  {\n+\t\t    char buf[sizeof (\"unified_address, unified_shared_memory, \"\n+\t\t\t\t     \"reverse_offload\")];\n+\t\t    gomp_requires_to_name (buf, sizeof (buf), omp_req);\n+\t\t    char *name = (char *) malloc (cur_len + 1);\n+\t\t    memcpy (name, cur, cur_len);\n+\t\t    name[cur_len] = '\\0';\n+\t\t    gomp_debug (1,\n+\t\t\t\t\"%s devices present but 'omp requires %s' \"\n+\t\t\t        \"cannot be fulfilled\", name, buf);\n+\t\t    free (name);\n+\t\t  }\n+\t      }\n+\t    else if (new_num_devs >= 1)\n \t      {\n \t\t/* Augment DEVICES and NUM_DEVICES.  */\n "}, {"sha": "bdca662e42f9043224d02d1639e18b3428116b8e", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-1-aux.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+#pragma omp requires unified_address\n+\n+int x;\n+\n+void foo (void)\n+{\n+  #pragma omp target\n+  x = 1;\n+}"}, {"sha": "fedf977976954d39ef6df93c9dbe0e4e9ea31de9", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-1.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-1.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do link { target { offload_target_nvptx || offload_target_amdgcn } } } */\n+/* { dg-additional-sources requires-1-aux.c } */\n+\n+/* Check diagnostic by device-compiler's lto1.\n+   Other file uses: 'requires unified_address'.  */\n+\n+#pragma omp requires unified_shared_memory\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-error \"OpenMP 'requires' directive with non-identical clauses in multiple compilation units: 'unified_shared_memory' vs. 'unified_address'\" \"\" { target *-*-* } 0 }  */\n+/* { dg-excess-errors \"Ignore messages like: errors during merging of translation units|mkoffload returned 1 exit status\" } */"}, {"sha": "617577448ed12024568336d07a3feddede9da5fb", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-2-aux.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+int x;\n+\n+void foo (void)\n+{\n+  #pragma omp target\n+  x = 1;\n+}"}, {"sha": "be1830d0c46eef9c75a3385ba17705785c751faf", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-2.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-2.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do link { target offloading_enabled } } */\n+/* { dg-additional-options \"-foffload=disable -flto\" } */\n+/* { dg-additional-sources requires-2-aux.c } */\n+\n+/* Check diagnostic by host's lto1.\n+   Other file does not have any 'omp requires'. */\n+\n+#pragma omp requires unified_shared_memory\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-error \"OpenMP 'requires' directive with 'unified_shared_memory' specified only in some compilation units\" \"\" { target *-*-* } 0 }  */\n+/* { dg-excess-errors \"Ignore messages like: errors during merging of translation units|mkoffload returned 1 exit status\" } */"}, {"sha": "bdca662e42f9043224d02d1639e18b3428116b8e", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-3-aux.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+#pragma omp requires unified_address\n+\n+int x;\n+\n+void foo (void)\n+{\n+  #pragma omp target\n+  x = 1;\n+}"}, {"sha": "4b07ffdd09b42fc3f0c24a5750b3a0593cd59132", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-3.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-3.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do link { target offloading_enabled } } */\n+/* { dg-additional-sources requires-3-aux.c } */\n+\n+/* Check diagnostic by device-compiler's lto1.\n+   Other file uses: 'requires unified_address'.  */\n+\n+#pragma omp requires unified_address,unified_shared_memory\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-error \"OpenMP 'requires' directive with non-identical clauses in multiple compilation units: 'unified_address, unified_shared_memory' vs. 'unified_address'\" \"\" { target *-*-* } 0 }  */\n+/* { dg-excess-errors \"Ignore messages like: errors during merging of translation units|mkoffload returned 1 exit status\" } */"}, {"sha": "b8b51ae8ca71ef9c69687064a5a3b5d7f9592998", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-4-aux.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+#pragma omp requires reverse_offload\n+\n+/* Note: The file does not have neither of:\n+   declare target directives, device constructs or device routines.  */\n+\n+int x;\n+\n+void foo (void)\n+{\n+  x = 1;\n+}"}, {"sha": "128fdbb8463d640faf76f1a31cc04fc57ceb54ec", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-4.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do link { target offloading_enabled } } */\n+/* { dg-additional-options \"-flto\" } */\n+/* { dg-additional-sources requires-4-aux.c } */\n+\n+/* Check diagnostic by device-compiler's or host compiler's lto1.\n+   Other file uses: 'requires reverse_offload', but that's inactive as\n+   there are no declare target directives, device constructs nor device routines  */\n+\n+#pragma omp requires unified_address,unified_shared_memory\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}"}, {"sha": "d223749f0a12f4eeca374d46feed07ea05f61751", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-5-aux.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+#pragma omp requires unified_shared_memory, unified_address, reverse_offload\n+\n+int x;\n+\n+void foo (void)\n+{\n+  #pragma omp target\n+  x = 1;\n+}"}, {"sha": "c1e5540cfc51c2b6b46dafb5b41a022a0fc41df5", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-5.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-5.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run { target { offload_target_nvptx || offload_target_amdgcn } } } */\n+/* { dg-additional-sources requires-5-aux.c } */\n+\n+#pragma omp requires unified_shared_memory, unified_address, reverse_offload\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}\n+\n+/* (Only) if GOMP_DEBUG=1, should print at runtime the following:\n+   \"devices present but 'omp requires unified_address, unified_shared_memory, reverse_offload' cannot be fulfilled\" */"}, {"sha": "b00c7459bbc3094ccfa704cf0fc4a19695f4f4b5", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-6.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-6.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,17 @@\n+#pragma omp requires unified_shared_memory, unified_address, reverse_offload\n+\n+/* The requires line is not active as there is none of:\n+     declare target directives, device constructs or device routines.\n+   Thus, this code is expected to work everywhere.  */\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  return 0;\n+}"}, {"sha": "0916db8a0ce07a3dd779748fa3fd865307d25e49", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-7-aux.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7-aux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7-aux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7-aux.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-skip-if \"\" { *-*-* } } */\n+\n+#pragma omp requires unified_address\n+\n+int x;\n+\n+void foo (void)\n+{\n+  x = 1;\n+  #pragma omp target enter data map(always,to: x)\n+}"}, {"sha": "c94a4c1084636029a2d39f387dfb92976e1d60e7", "filename": "libgomp/testsuite/libgomp.c-c++-common/requires-7.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c-c%2B%2B-common%2Frequires-7.c?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do link { target { offload_target_nvptx || offload_target_amdgcn } } } */\n+/* { dg-additional-sources requires-7-aux.c } */\n+\n+/* Check diagnostic by device-compiler's lto1.\n+   Other file uses: 'requires unified_address'.  */\n+\n+#pragma omp requires unified_shared_memory\n+\n+int a[10];\n+extern void foo (void);\n+\n+int\n+main (void)\n+{\n+  #pragma omp target\n+  for (int i = 0; i < 10; i++)\n+    a[i] = 0;\n+\n+  foo ();\n+  return 0;\n+}\n+\n+/* { dg-error \"OpenMP 'requires' directive with non-identical clauses in multiple compilation units: 'unified_shared_memory' vs. 'unified_address'\" \"\" { target *-*-* } 0 }  */\n+/* { dg-excess-errors \"Ignore messages like: errors during merging of translation units|mkoffload returned 1 exit status\" } */"}, {"sha": "a18caeb4c694545a31783b3707cc4a59e6173719", "filename": "libgomp/testsuite/libgomp.fortran/requires-1-aux.f90", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1-aux.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1-aux.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1-aux.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,14 @@\n+! { dg-skip-if \"\" { *-*-* } }\n+\n+module m\n+  integer x\n+end module m\n+\n+subroutine foo\n+  use m\n+  implicit none\n+  !$omp requires unified_address\n+\n+  x = 1\n+  !$omp target enter data map(always,to: x)\n+end"}, {"sha": "33741af15f1a0ab8ded42900f9fe1fd026c6f52a", "filename": "libgomp/testsuite/libgomp.fortran/requires-1.f90", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Frequires-1.f90?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -0,0 +1,26 @@\n+! { dg-do link { target { offload_target_nvptx || offload_target_amdgcn } } }\n+! { dg-additional-sources requires-1-aux.f90 }\n+\n+! Check diagnostic by device-compiler's lto1.\n+!   Other file uses: 'requires unified_address'.\n+\n+module m\n+  integer :: a(10)\n+  interface\n+    subroutine foo\n+    end\n+  end interface\n+end\n+\n+program main\n+  !$omp requires unified_shared_memory\n+\n+  !$omp target\n+    a = 0\n+  !$omp end target\n+\n+  call foo ()\n+end\n+\n+! { dg-error \"OpenMP 'requires' directive with non-identical clauses in multiple compilation units: 'unified_shared_memory' vs. 'unified_address'\" \"\" { target *-*-* } 0 }\n+! { dg-excess-errors \"Ignore messages like: errors during merging of translation units|mkoffload returned 1 exit status\" }"}, {"sha": "33bae0650b41c6fffe0036f8b1bf4c0ddc531c64", "filename": "liboffloadmic/plugin/libgomp-plugin-intelmic.cpp", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/683f11843974f0bdf42f79cdcbb0c2b43c7b81b0/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/liboffloadmic%2Fplugin%2Flibgomp-plugin-intelmic.cpp?ref=683f11843974f0bdf42f79cdcbb0c2b43c7b81b0", "patch": "@@ -168,8 +168,12 @@ GOMP_OFFLOAD_get_type (void)\n }\n \n extern \"C\" int\n-GOMP_OFFLOAD_get_num_devices (void)\n+GOMP_OFFLOAD_get_num_devices (unsigned int omp_requires_mask)\n {\n+  /* Return -1 if no omp_requires_mask cannot be fulfilled but\n+     devices were present.  */\n+  if (num_devices > 0 && omp_requires_mask != 0)\n+    return -1;\n   TRACE (\"(): return %d\", num_devices);\n   return num_devices;\n }"}]}