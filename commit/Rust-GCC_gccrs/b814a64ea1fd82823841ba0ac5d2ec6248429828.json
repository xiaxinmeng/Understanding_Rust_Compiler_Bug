{"sha": "b814a64ea1fd82823841ba0ac5d2ec6248429828", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgxNGE2NGVhMWZkODI4MjM4NDFiYTBhYzVkMmVjNjI0ODQyOTgyOA==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2006-10-28T23:31:22Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2006-10-28T23:31:22Z"}, "message": "gfortran.h: Remove GFC_MPFR_TOO_OLD.\n\n2006-10-27  Steven G. Kargl  <kargl@gcc.gnu.org>\n\t* gfortran.h: Remove GFC_MPFR_TOO_OLD.\n\t* arith.c (arctangent2): Remove function\n\t(gfc_check_real_range): Remove subnormal kludge.\n\t* arith.h: Remove arctangent2 prototype.\n\t* simplify.c: (gfc_simplify_atan2): Remove use of arctangent2.\n\t(gfc_simplify_exponent, gfc_simplify_log, gfc_simplify_nearest,\n\tgfc_simplify_rrspacing, gfc_simplify_spacing): Remove mpfr kludges.\n\nFrom-SVN: r118120", "tree": {"sha": "92aa54b723fbf8259a3029a5c5e269278d1d32ca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/92aa54b723fbf8259a3029a5c5e269278d1d32ca"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b814a64ea1fd82823841ba0ac5d2ec6248429828", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b814a64ea1fd82823841ba0ac5d2ec6248429828", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b814a64ea1fd82823841ba0ac5d2ec6248429828", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b814a64ea1fd82823841ba0ac5d2ec6248429828/comments", "author": null, "committer": null, "parents": [{"sha": "857d325a640ab62412800b36a89f82f0e424db68", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/857d325a640ab62412800b36a89f82f0e424db68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/857d325a640ab62412800b36a89f82f0e424db68"}], "stats": {"total": 286, "additions": 13, "deletions": 273}, "files": [{"sha": "a4b4014346d8ce98505f48804a95dff55b7d3612", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b814a64ea1fd82823841ba0ac5d2ec6248429828", "patch": "@@ -1,3 +1,12 @@\n+2006-10-27  Steven G. Kargl  <kargl@gcc.gnu.org>\n+\t* gfortran.h: Remove GFC_MPFR_TOO_OLD.\n+\t* arith.c (arctangent2): Remove function\n+\t(gfc_check_real_range): Remove subnormal kludge.\n+\t* arith.h: Remove arctangent2 prototype.\n+\t* simplify.c: (gfc_simplify_atan2): Remove use of arctangent2.\n+\t(gfc_simplify_exponent, gfc_simplify_log, gfc_simplify_nearest,\n+\tgfc_simplify_rrspacing, gfc_simplify_spacing): Remove mpfr kludges.\n+\n 2006-10-28  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/28224"}, {"sha": "f130344930eb0fa6bfe72da8a9cfd7a333f71de8", "filename": "gcc/fortran/arith.c", "status": "modified", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=b814a64ea1fd82823841ba0ac5d2ec6248429828", "patch": "@@ -75,57 +75,6 @@ gfc_set_model (mpfr_t x)\n   mpfr_set_default_prec (mpfr_get_prec (x));\n }\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-/* Calculate atan2 (y, x)\n-\n-atan2(y, x) = atan(y/x)\t\t\t\tif x > 0,\n-\t      sign(y)*(pi - atan(|y/x|))\tif x < 0,\n-\t      0\t\t\t\t\tif x = 0 && y == 0,\n-\t      sign(y)*pi/2\t\t\tif x = 0 && y != 0.\n-*/\n-\n-void\n-arctangent2 (mpfr_t y, mpfr_t x, mpfr_t result)\n-{\n-  int i;\n-  mpfr_t t;\n-\n-  gfc_set_model (y);\n-  mpfr_init (t);\n-\n-  i = mpfr_sgn (x);\n-\n-  if (i > 0)\n-    {\n-      mpfr_div (t, y, x, GFC_RND_MODE);\n-      mpfr_atan (result, t, GFC_RND_MODE);\n-    }\n-  else if (i < 0)\n-    {\n-      mpfr_const_pi (result, GFC_RND_MODE);\n-      mpfr_div (t, y, x, GFC_RND_MODE);\n-      mpfr_abs (t, t, GFC_RND_MODE);\n-      mpfr_atan (t, t, GFC_RND_MODE);\n-      mpfr_sub (result, result, t, GFC_RND_MODE);\n-      if (mpfr_sgn (y) < 0)\n-\tmpfr_neg (result, result, GFC_RND_MODE);\n-    }\n-  else\n-    {\n-      if (mpfr_sgn (y) == 0)\n-\tmpfr_set_ui (result, 0, GFC_RND_MODE);\n-      else\n-\t{\n-          mpfr_const_pi (result, GFC_RND_MODE);\n-          mpfr_div_ui (result, result, 2, GFC_RND_MODE);\n-\t  if (mpfr_sgn (y) < 0)\n-\t    mpfr_neg (result, result, GFC_RND_MODE);\n-\t}\n-    }\n-\n-  mpfr_clear (t);\n-}\n-#endif\n \n /* Given an arithmetic error code, return a pointer to a string that\n    explains the error.  */\n@@ -412,31 +361,6 @@ gfc_check_real_range (mpfr_t p, int kind)\n     }\n   else if (mpfr_cmp (q, gfc_real_kinds[i].tiny) < 0)\n     {\n-#if defined(GFC_MPFR_TOO_OLD)\n-      /* MPFR operates on a number with a given precision and enormous\n-\texponential range.  To represent subnormal numbers, the exponent is\n-\tallowed to become smaller than emin, but always retains the full\n-\tprecision.  This code resets unused bits to 0 to alleviate\n-\trounding problems.  Note, a future version of MPFR will have a\n- \tmpfr_subnormalize() function, which handles this truncation in a\n-\tmore efficient and robust way.  */\n-\n-      int j, k;\n-      char *bin, *s;\n-      mp_exp_t e;\n-\n-      bin = mpfr_get_str (NULL, &e, gfc_real_kinds[i].radix, 0, q, GMP_RNDN);\n-      k = gfc_real_kinds[i].digits - (gfc_real_kinds[i].min_exponent - e);\n-      for (j = k; j < gfc_real_kinds[i].digits; j++)\n-\tbin[j] = '0';\n-      /* Need space for '0.', bin, 'E', and e */\n-      s = (char *) gfc_getmem (strlen(bin) + 10);\n-      sprintf (s, \"0.%sE%d\", bin, (int) e);\n-      mpfr_set_str (q, s, gfc_real_kinds[i].radix, GMP_RNDN);\n-\n-      gfc_free (s);\n-      gfc_free (bin);\n-#else\n       mp_exp_t emin, emax;\n       int en;\n \n@@ -453,7 +377,6 @@ gfc_check_real_range (mpfr_t p, int kind)\n       /* Reset emin and emax.  */\n       mpfr_set_emin (emin);\n       mpfr_set_emax (emax);\n-#endif\n \n       /* Copy sign if needed.  */\n       if (mpfr_sgn (p) < 0)"}, {"sha": "60fd2e0e3db6776c120e3cd047dbef1c6c211810", "filename": "gcc/fortran/arith.h", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=b814a64ea1fd82823841ba0ac5d2ec6248429828", "patch": "@@ -25,11 +25,9 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n \n #include \"gfortran.h\"\n \n-/* MPFR does not have mpfr_atan2(), which needs to return the principle\n-   value of atan2().  MPFR also does not have the conversion of a mpfr_t\n-   to a mpz_t, so declare a function for this as well.  */\n+/* MPFR also does not have the conversion of a mpfr_t to a mpz_t, so declare\n+   a function for this as well.  */\n \n-void arctangent2 (mpfr_t, mpfr_t, mpfr_t);\n void gfc_mpfr_to_mpz (mpz_t, mpfr_t);\n void gfc_set_model_kind (int);\n void gfc_set_model (mpfr_t);"}, {"sha": "89d8e2ff1c0c22ef879ff4a45be4dcf6c708b2d0", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=b814a64ea1fd82823841ba0ac5d2ec6248429828", "patch": "@@ -1224,10 +1224,6 @@ gfc_intrinsic_sym;\n #include <gmp.h>\n #include <mpfr.h>\n #define GFC_RND_MODE GMP_RNDN\n-#undef GFC_MPFR_TOO_OLD\n-#if MPFR_VERSION_MAJOR < 2 || (MPFR_VERSION_MAJOR == 2 && MPFR_VERSION_MINOR < 2)\n-#define GFC_MPFR_TOO_OLD 1\n-#endif\n \n typedef struct gfc_expr\n {"}, {"sha": "75e4c3c6bd3e2059205f045c233635c1f5abd15f", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 2, "deletions": 188, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b814a64ea1fd82823841ba0ac5d2ec6248429828/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=b814a64ea1fd82823841ba0ac5d2ec6248429828", "patch": "@@ -607,11 +607,7 @@ gfc_simplify_atan2 (gfc_expr * y, gfc_expr * x)\n       return &gfc_bad_expr;\n     }\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-  arctangent2 (y->value.real, x->value.real, result->value.real);\n-#else\n   mpfr_atan2 (result->value.real, y->value.real, x->value.real, GFC_RND_MODE);\n-#endif\n \n   return range_check (result, \"ATAN2\");\n }\n@@ -1060,10 +1056,6 @@ gfc_simplify_exponent (gfc_expr * x)\n   int i;\n   gfc_expr *result;\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-  mpfr_t tmp;\n-#endif\n-\n   if (x->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n@@ -1078,27 +1070,8 @@ gfc_simplify_exponent (gfc_expr * x)\n       return result;\n     }\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-  /* PR fortran/28276 suffers from a buggy MPFR, and this block of code\n-     does not function correctly.  */\n-  mpfr_init (tmp);\n-\n-  mpfr_abs (tmp, x->value.real, GFC_RND_MODE);\n-  mpfr_log2 (tmp, tmp, GFC_RND_MODE);\n-\n-  gfc_mpfr_to_mpz (result->value.integer, tmp);\n-\n-  /* The model number for tiny(x) is b**(emin - 1) where b is the base and emin\n-     is the smallest exponent value.  So, we need to add 1 if x is tiny(x).  */\n-  i = gfc_validate_kind (x->ts.type, x->ts.kind, false);\n-  if (mpfr_cmp (x->value.real, gfc_real_kinds[i].tiny) == 0)\n-    mpz_add_ui (result->value.integer,result->value.integer, 1);\n-\n-  mpfr_clear (tmp);\n-#else\n   i = (int) mpfr_get_exp (x->value.real);\n   mpz_set_si (result->value.integer, i);\n-#endif\n \n   return range_check (result, \"EXPONENT\");\n }\n@@ -2160,13 +2133,8 @@ gfc_simplify_log (gfc_expr * x)\n       mpfr_init (xr);\n       mpfr_init (xi);\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-      arctangent2 (x->value.complex.i, x->value.complex.r, result->value.complex.i);\n-#else\n       mpfr_atan2 (result->value.complex.i, x->value.complex.i, x->value.complex.r,\n \t\t  GFC_RND_MODE);\n-#endif\n-\n \n       mpfr_mul (xr, x->value.complex.r, x->value.complex.r, GFC_RND_MODE);\n       mpfr_mul (xi, x->value.complex.i, x->value.complex.i, GFC_RND_MODE);\n@@ -2494,9 +2462,6 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n   gfc_expr *result;\n   mpfr_t tmp;\n   int sgn;\n-#if defined(GFC_MPFR_TOO_OLD)\n-  int direction;\n-#endif\n \n   if (x->expr_type != EXPR_CONSTANT || s->expr_type != EXPR_CONSTANT)\n     return NULL;\n@@ -2510,60 +2475,11 @@ gfc_simplify_nearest (gfc_expr * x, gfc_expr * s)\n   gfc_set_model_kind (x->ts.kind);\n   result = gfc_copy_expr (x);\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-\n-  direction = mpfr_sgn (s->value.real);\n-  sgn = mpfr_sgn (x->value.real);\n-\n-  if (sgn == 0)\n-    {\n-      int k = gfc_validate_kind (BT_REAL, x->ts.kind, 0);\n-\n-      if (direction > 0)\n-\tmpfr_add (result->value.real,\n-\t\t  x->value.real, gfc_real_kinds[k].subnormal, GFC_RND_MODE);\n-      else\n-\tmpfr_sub (result->value.real,\n-\t\t  x->value.real, gfc_real_kinds[k].subnormal, GFC_RND_MODE);\n-    }\n-  else\n-    {\n-      if (sgn < 0)\n-\t{\n-\t  direction = -direction;\n-\t  mpfr_neg (result->value.real, result->value.real, GFC_RND_MODE);\n-\t}\n-\n-      if (direction > 0)\n-\tmpfr_add_one_ulp (result->value.real, GFC_RND_MODE);\n-      else\n-\t{\n-\t  /* In this case the exponent can shrink, which makes us skip\n-\t     over one number because we subtract one ulp with the\n-\t     larger exponent.  Thus we need to compensate for this.  */\n-\t  mpfr_init_set (tmp, result->value.real, GFC_RND_MODE);\n-\n-\t  mpfr_sub_one_ulp (result->value.real, GFC_RND_MODE);\n-\t  mpfr_add_one_ulp (result->value.real, GFC_RND_MODE);\n-\n-\t  /* If we're back to where we started, the spacing is one\n-\t     ulp, and we get the correct result by subtracting.  */\n-\t  if (mpfr_cmp (tmp, result->value.real) == 0)\n-\t    mpfr_sub_one_ulp (result->value.real, GFC_RND_MODE);\n-\n-\t  mpfr_clear (tmp);\n-\t}\n-\n-      if (sgn < 0)\n-\tmpfr_neg (result->value.real, result->value.real, GFC_RND_MODE);\n-    }\n-#else\n   sgn = mpfr_sgn (s->value.real); \n   mpfr_init (tmp);\n   mpfr_set_inf (tmp, sgn);\n   mpfr_nexttoward (result->value.real, tmp);\n   mpfr_clear(tmp);\n-#endif\n \n   return range_check (result, \"NEAREST\");\n }\n@@ -3112,57 +3028,6 @@ gfc_simplify_reshape (gfc_expr * source, gfc_expr * shape_exp,\n }\n \n \n-#if defined(GFC_MPFR_TOO_OLD)\n-gfc_expr *\n-gfc_simplify_rrspacing (gfc_expr * x)\n-{\n-  gfc_expr *result;\n-  mpfr_t absv, log2, exp, frac, pow2;\n-  int i, p;\n-\n-  if (x->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n-  i = gfc_validate_kind (x->ts.type, x->ts.kind, false);\n-\n-  result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n-\n-  p = gfc_real_kinds[i].digits;\n-\n-  gfc_set_model_kind (x->ts.kind);\n-\n-  if (mpfr_sgn (x->value.real) == 0)\n-    {\n-      mpfr_set_ui (result->value.real, 0, GFC_RND_MODE);\n-      return result;\n-    }\n-\n-  mpfr_init (log2);\n-  mpfr_init (absv);\n-  mpfr_init (frac);\n-  mpfr_init (pow2);\n-  mpfr_init (exp);\n-\n-  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n-  mpfr_log2 (log2, absv, GFC_RND_MODE);\n-\n-  mpfr_trunc (log2, log2);\n-  mpfr_add_ui (exp, log2, 1, GFC_RND_MODE);\n-\n-  mpfr_ui_pow (pow2, 2, exp, GFC_RND_MODE);\n-  mpfr_div (frac, absv, pow2, GFC_RND_MODE);\n-\n-  mpfr_mul_2exp (result->value.real, frac, (unsigned long)p, GFC_RND_MODE);\n-\n-  mpfr_clear (log2);\n-  mpfr_clear (absv);\n-  mpfr_clear (frac);\n-  mpfr_clear (pow2);\n-  mpfr_clear (exp);\n-\n-  return range_check (result, \"RRSPACING\");\n-}\n-#else\n gfc_expr *\n gfc_simplify_rrspacing (gfc_expr * x)\n {\n@@ -3195,7 +3060,7 @@ gfc_simplify_rrspacing (gfc_expr * x)\n \n   return range_check (result, \"RRSPACING\");\n }\n-#endif\n+\n \n gfc_expr *\n gfc_simplify_scale (gfc_expr * x, gfc_expr * i)\n@@ -3639,58 +3504,7 @@ gfc_simplify_sngl (gfc_expr * a)\n   return range_check (result, \"SNGL\");\n }\n \n-#if defined(GFC_MPFR_TOO_OLD)\n-gfc_expr *\n-gfc_simplify_spacing (gfc_expr * x)\n-{\n-  gfc_expr *result;\n-  mpfr_t absv, log2;\n-  long diff;\n-  int i, p;\n-\n-  if (x->expr_type != EXPR_CONSTANT)\n-    return NULL;\n-\n-  i = gfc_validate_kind (x->ts.type, x->ts.kind, false);\n \n-  p = gfc_real_kinds[i].digits;\n-\n-  result = gfc_constant_result (BT_REAL, x->ts.kind, &x->where);\n-\n-  gfc_set_model_kind (x->ts.kind);\n-\n-  /* Special case x = 0 and -0.  */\n-  mpfr_init (absv);\n-  mpfr_abs (absv, x->value.real, GFC_RND_MODE);\n-  if (mpfr_sgn (absv) == 0)\n-    {\n-      mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n-      return result;\n-    }\n-\n-  mpfr_init (log2);\n-  mpfr_log2 (log2, absv, GFC_RND_MODE);\n-  mpfr_trunc (log2, log2);\n-\n-  mpfr_add_ui (log2, log2, 1, GFC_RND_MODE);\n-\n-  /* FIXME: We should be using mpfr_get_si here, but this function is\n-     not available with the version of mpfr distributed with gmp (as of\n-     2004-09-17). Replace once mpfr has been imported into the gcc cvs\n-     tree.  */\n-  diff = (long)mpfr_get_d (log2, GFC_RND_MODE) - (long)p;\n-  mpfr_set_ui (result->value.real, 1, GFC_RND_MODE);\n-  mpfr_mul_2si (result->value.real, result->value.real, diff, GFC_RND_MODE);\n-\n-  mpfr_clear (log2);\n-  mpfr_clear (absv);\n-\n-  if (mpfr_cmp (result->value.real, gfc_real_kinds[i].tiny) < 0)\n-    mpfr_set (result->value.real, gfc_real_kinds[i].tiny, GFC_RND_MODE);\n-\n-  return range_check (result, \"SPACING\");\n-}\n-#else\n gfc_expr *\n gfc_simplify_spacing (gfc_expr * x)\n {\n@@ -3727,7 +3541,7 @@ gfc_simplify_spacing (gfc_expr * x)\n \n   return range_check (result, \"SPACING\");\n }\n-#endif\n+\n \n gfc_expr *\n gfc_simplify_sqrt (gfc_expr * e)"}]}