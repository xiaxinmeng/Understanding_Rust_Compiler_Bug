{"sha": "8039ca76a5705ae5052b20cee64110c32545c4fc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAzOWNhNzZhNTcwNWFlNTA1MmIyMGNlZTY0MTEwYzMyNTQ1YzRmYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-24T23:46:17Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2011-03-24T23:46:17Z"}, "message": "Update to current version of Go library.\n\nFrom-SVN: r171427", "tree": {"sha": "9319bca77115a32f6a0b5e8bcd651465b14c76da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9319bca77115a32f6a0b5e8bcd651465b14c76da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8039ca76a5705ae5052b20cee64110c32545c4fc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8039ca76a5705ae5052b20cee64110c32545c4fc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8039ca76a5705ae5052b20cee64110c32545c4fc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8039ca76a5705ae5052b20cee64110c32545c4fc/comments", "author": null, "committer": null, "parents": [{"sha": "7114321ee4f521ea9fbdd08a4c23b361181f3658", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7114321ee4f521ea9fbdd08a4c23b361181f3658", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7114321ee4f521ea9fbdd08a4c23b361181f3658"}], "stats": {"total": 11720, "additions": 8977, "deletions": 2743}, "files": [{"sha": "729be06029097a2dbe0418ae1a25b060064ce3e1", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -1,4 +1,4 @@\n-94d654be2064\n+31d7feb9281b\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "77bf27a7c53af9a48559614b4a7fad3d7020d650", "filename": "libgo/Makefile.am", "status": "modified", "additions": 119, "deletions": 33, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -182,6 +182,7 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n \tcrypto/dsa.gox \\\n+\tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n@@ -254,11 +255,14 @@ toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n \thash/adler32.gox \\\n \thash/crc32.gox \\\n-\thash/crc64.gox\n+\thash/crc64.gox \\\n+\thash/fnv.gox\n \n toolexeclibgohttpdir = $(toolexeclibgodir)/http\n \n toolexeclibgohttp_DATA = \\\n+\thttp/cgi.gox \\\n+\thttp/httptest.gox \\\n \thttp/pprof.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n@@ -301,6 +305,11 @@ toolexeclibgoos_DATA = \\\n \t$(os_inotify_gox) \\\n \tos/signal.gox\n \n+toolexeclibgopathdir = $(toolexeclibgodir)/path\n+\n+toolexeclibgopath_DATA = \\\n+\tpath/filepath.gox\n+\n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n \n toolexeclibgorpc_DATA = \\\n@@ -543,6 +552,7 @@ go_html_files = \\\n go_http_files = \\\n \tgo/http/chunked.go \\\n \tgo/http/client.go \\\n+\tgo/http/cookie.go \\\n \tgo/http/dump.go \\\n \tgo/http/fs.go \\\n \tgo/http/header.go \\\n@@ -726,8 +736,7 @@ go_patch_files = \\\n \n go_path_files = \\\n \tgo/path/match.go \\\n-\tgo/path/path.go \\\n-\tgo/path/path_unix.go\n+\tgo/path/path.go\n \n go_rand_files = \\\n \tgo/rand/exp.go \\\n@@ -753,6 +762,7 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n+\tgo/runtime/mem.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -826,6 +836,7 @@ go_testing_files = \\\n go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n+\tgo/time/sys.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo_unix.go\n@@ -936,6 +947,8 @@ go_crypto_cipher_files = \\\n \tgo/crypto/cipher/ofb.go\n go_crypto_dsa_files = \\\n \tgo/crypto/dsa/dsa.go\n+go_crypto_ecdsa_files = \\\n+\tgo/crypto/ecdsa/ecdsa.go\n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go\n go_crypto_hmac_files = \\\n@@ -1101,6 +1114,7 @@ go_go_token_files = \\\n \tgo/go/token/token.go\n go_go_typechecker_files = \\\n \tgo/go/typechecker/scope.go \\\n+\tgo/go/typechecker/type.go \\\n \tgo/go/typechecker/typechecker.go \\\n \tgo/go/typechecker/universe.go\n \n@@ -1110,7 +1124,15 @@ go_hash_crc32_files = \\\n \tgo/hash/crc32/crc32.go\n go_hash_crc64_files = \\\n \tgo/hash/crc64/crc64.go\n-\n+go_hash_fnv_files = \\\n+\tgo/hash/fnv/fnv.go\n+\n+go_http_cgi_files = \\\n+\tgo/http/cgi/child.go \\\n+\tgo/http/cgi/host.go\n+go_http_httptest_files = \\\n+\tgo/http/httptest/recorder.go \\\n+\tgo/http/httptest/server.go\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n \n@@ -1151,6 +1173,11 @@ go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n \n+go_path_filepath_files = \\\n+\tgo/path/filepath/match.go \\\n+\tgo/path/filepath/path.go \\\n+\tgo/path/filepath/path_unix.go\n+\n go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n@@ -1377,6 +1404,7 @@ libgo_go_objs = \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n \tcrypto/dsa.lo \\\n+\tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n \tcrypto/md4.lo \\\n@@ -1426,6 +1454,9 @@ libgo_go_objs = \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n+\thash/fnv.lo \\\n+\thttp/cgi.lo \\\n+\thttp/httptest.lo \\\n \thttp/pprof.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n@@ -1436,6 +1467,7 @@ libgo_go_objs = \\\n \tnet/textproto.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/signal.lo \\\n+\tpath/filepath.lo \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n@@ -1532,7 +1564,7 @@ asn1/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: asn1/check\n \n-big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox\n+big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox os.gox\n \t$(BUILDPACKAGE)\n big/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1597,9 +1629,9 @@ fmt/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: fmt/check\n \n-gob/gob.lo: $(go_gob_files) bytes.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox \\\n-\t\tutf8.gox\n+gob/gob.lo: $(go_gob_files) bufio.gox bytes.gox fmt.gox io.gox math.gox \\\n+\t\tos.gox reflect.gox runtime.gox strings.gox sync.gox \\\n+\t\tunicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n gob/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1621,8 +1653,8 @@ html/check: $(CHECK_DEPS)\n http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n \t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n \t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n-\t\tnet.gox net/textproto.gox os.gox path.gox sort.gox \\\n-\t\tstrconv.gox strings.gox sync.gox time.gox utf8.gox\n+\t\tnet.gox net/textproto.gox os.gox path.gox path/filepath.gox \\\n+\t\tsort.gox strconv.gox strings.gox sync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1634,7 +1666,7 @@ image/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: image/check\n \n-io/io.lo: $(go_io_files) os.gox runtime.gox sync.gox\n+io/io.lo: $(go_io_files) os.gox sync.gox\n \t$(BUILDPACKAGE)\n io/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1697,8 +1729,7 @@ patch/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: patch/check\n \n-path/path.lo: $(go_path_files) io/ioutil.gox os.gox sort.gox strings.gox \\\n-\t\tutf8.gox\n+path/path.lo: $(go_path_files) os.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n path/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1799,7 +1830,7 @@ template/check: $(CHECK_DEPS)\n .PHONY: template/check\n \n testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox time.gox\n+\t\truntime.gox runtime/pprof.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -1862,7 +1893,7 @@ archive/tar/check: $(CHECK_DEPS)\n \n archive/zip.lo: $(go_archive_zip_files) bufio.gox bytes.gox \\\n \t\tcompress/flate.gox hash.gox hash/crc32.gox \\\n-\t\tencoding/binary.gox io.gox os.gox\n+\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox\n \t$(BUILDPACKAGE)\n archive/zip/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/zip\n@@ -1977,6 +2008,14 @@ crypto/dsa/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/dsa/check\n \n+crypto/ecdsa.lo: $(go_crypto_ecdsa_files) big.gox crypto/elliptic.gox io.gox \\\n+\t\tos.gox\n+\t$(BUILDPACKAGE)\n+crypto/ecdsa/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/ecdsa\n+\t$(CHECK)\n+.PHONY: crypto/ecdsa/check\n+\n crypto/elliptic.lo: $(go_crypto_elliptic_files) big.gox io.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n crypto/elliptic/check: $(CHECK_DEPS)\n@@ -2014,8 +2053,8 @@ crypto/ocsp/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n-\t\t crypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox crypto/dsa.gox \\\n+\t\tcrypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n \t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n \t\thash.gox io.gox os.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n@@ -2137,10 +2176,10 @@ crypto/openpgp/error/check: $(CHECK_DEPS)\n crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n \t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n-\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n-\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/binary.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox os.gox strconv.gox strings.gox\n+\t\tcrypto/dsa.gox crypto/openpgp/error.gox \\\n+\t\tcrypto/openpgp/s2k.gox crypto/rand.gox crypto/rsa.gox \\\n+\t\tcrypto/sha1.gox crypto/subtle.gox encoding/binary.gox fmt.gox \\\n+\t\thash.gox io.gox io/ioutil.gox os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/packet/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/packet\n@@ -2288,8 +2327,8 @@ exp/eval/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: exp/eval/check\n \n-go/ast.lo: $(go_go_ast_files) fmt.gox go/token.gox io.gox os.gox reflect.gox \\\n-\t\tunicode.gox utf8.gox\n+go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/token.gox io.gox os.gox \\\n+\t\treflect.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast\n@@ -2306,25 +2345,25 @@ go/doc/check: $(CHECK_DEPS)\n \n go/parser.lo: $(go_go_parser_files) bytes.gox fmt.gox go/ast.gox \\\n \t\tgo/scanner.gox go/token.gox io.gox io/ioutil.gox os.gox \\\n-\t\tpath.gox strings.gox\n+\t\tpath/filepath.gox strings.gox\n \t$(BUILDPACKAGE)\n go/parser/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/parser\n \t$(CHECK)\n .PHONY: go/parser/check\n \n go/printer.lo: $(go_go_printer_files) bytes.gox fmt.gox go/ast.gox \\\n-\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n-\t\tstrings.gox tabwriter.gox\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox reflect.gox \\\n+\t\truntime.gox strings.gox tabwriter.gox\n \t$(BUILDPACKAGE)\n go/printer/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/printer\n \t$(CHECK)\n .PHONY: go/printer/check\n \n go/scanner.lo: $(go_go_scanner_files) bytes.gox container/vector.gox fmt.gox \\\n-\t\tgo/token.gox io.gox os.gox path.gox sort.gox strconv.gox \\\n-\t\tunicode.gox utf8.gox\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox sort.gox \\\n+\t\tstrconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/scanner/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/scanner\n@@ -2367,6 +2406,30 @@ hash/crc64/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: hash/crc64/check\n \n+hash/fnv.lo: $(go_hash_fnv_files) encoding/binary.gox hash.gox os.gox\n+\t$(BUILDPACKAGE)\n+hash/fnv/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) hash/fnv\n+\t$(CHECK)\n+.PHONY: hash/fnv/check\n+\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox encoding/line.gox \\\n+\t\texec.gox fmt.gox http.gox io.gox io/ioutil.gox log.gox \\\n+\t\tos.gox path/filepath.gox regexp.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+http/cgi/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/cgi\n+\t$(CHECK)\n+.PHONY: http/cgi/check\n+\n+http/httptest.lo: $(go_http_httptest_files) bytes.gox fmt.gox http.gox \\\n+\t\tnet.gox os.gox\n+\t$(BUILDPACKAGE)\n+http/httptest/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/httptest\n+\t$(CHECK)\n+.PHONY: http/httptest/check\n+\n http/pprof.lo: $(go_http_pprof_files) bufio.gox fmt.gox http.gox os.gox \\\n \t\truntime.gox runtime/pprof.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n@@ -2398,16 +2461,16 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: index/suffixarray/check\n \n-io/ioutil.lo: $(go_io_ioutil_files) bytes.gox io.gox os.gox sort.gox \\\n-\t\tstrconv.gox\n+io/ioutil.lo: $(go_io_ioutil_files) bytes.gox io.gox os.gox path/filepath.gox \\\n+\t\tsort.gox strconv.gox\n \t$(BUILDPACKAGE)\n io/ioutil/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) io/ioutil\n \t$(CHECK)\n .PHONY: io/ioutil/check\n \n mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox io.gox \\\n-\t\tmime.gox os.gox regexp.gox strings.gox\n+\t\tmime.gox net/textproto.gox os.gox regexp.gox strings.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n@@ -2445,6 +2508,14 @@ unix.go: $(srcdir)/go/os/signal/mkunix.sh sysinfo.go\n \t$(SHELL) $(srcdir)/go/os/signal/mkunix.sh sysinfo.go > $@.tmp\n \tmv -f $@.tmp $@\n \n+path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox sort.gox \\\n+\t\tstrings.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+path/filepath/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) path/filepath\n+\t$(CHECK)\n+.PHONY: path/filepath/check\n+\n rpc/jsonrpc.lo: $(go_rpc_jsonrpc_files) fmt.gox io.gox json.gox net.gox \\\n \t\tos.gox rpc.gox sync.gox\n \t$(BUILDPACKAGE)\n@@ -2462,7 +2533,7 @@ runtime/debug/check: $(CHECK_DEPS)\n .PHONY: runtime/debug/check\n \n runtime/pprof.lo: $(go_runtime_pprof_files) bufio.gox fmt.gox io.gox os.gox \\\n-\t\truntime.gox\n+\t\truntime.gox sync.gox\n \t$(BUILDPACKAGE)\n runtime/pprof/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) runtime/pprof\n@@ -2653,6 +2724,8 @@ crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n crypto/dsa.gox: crypto/dsa.lo\n \t$(BUILDGOX)\n+crypto/ecdsa.gox: crypto/ecdsa.lo\t\n+\t$(BUILDGOX)\n crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n@@ -2757,7 +2830,13 @@ hash/crc32.gox: hash/crc32.lo\n \t$(BUILDGOX)\n hash/crc64.gox: hash/crc64.lo\n \t$(BUILDGOX)\n+hash/fnv.gox: hash/fnv.lo\n+\t$(BUILDGOX)\n \n+http/cgi.gox: http/cgi.lo\n+\t$(BUILDGOX)\n+http/httptest.gox: http/httptest.lo\n+\t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n \n@@ -2785,6 +2864,9 @@ os/inotify.gox: os/inotify.lo\n os/signal.gox: os/signal.lo\n \t$(BUILDGOX)\n \n+path/filepath.gox: path/filepath.lo\n+\t$(BUILDGOX)\n+\n rpc/jsonrpc.gox: rpc/jsonrpc.lo\n \t$(BUILDGOX)\n \n@@ -2823,7 +2905,7 @@ TEST_PACKAGES = \\\n \tfmt/check \\\n \tgob/check \\\n \thtml/check \\\n-\t$(if $(GCCGO_RUN_ALL_TESTS),http/check) \\\n+\thttp/check \\\n \tio/check \\\n \tjson/check \\\n \tlog/check \\\n@@ -2872,6 +2954,7 @@ TEST_PACKAGES = \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n \tcrypto/dsa/check \\\n+\tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n@@ -2916,13 +2999,16 @@ TEST_PACKAGES = \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n+\thash/fnv/check \\\n+\thttp/cgi/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n \t$(os_inotify_check) \\\n \tos/signal/check \\\n+\tpath/filepath/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n \ttesting/quick/check \\"}, {"sha": "dd942254dcb7e53fff1d4d0de2755ed9c516ab4d", "filename": "libgo/Makefile.in", "status": "modified", "additions": 174, "deletions": 59, "changes": 233, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -110,6 +110,7 @@ am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgomimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgonetdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoosdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibgopathdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgorpcdir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgoruntimedir)\" \\\n \t\"$(DESTDIR)$(toolexeclibgosyncdir)\" \\\n@@ -141,9 +142,10 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \tcontainer/heap.lo container/list.lo container/ring.lo \\\n \tcontainer/vector.lo crypto/aes.lo crypto/block.lo \\\n \tcrypto/blowfish.lo crypto/cast5.lo crypto/cipher.lo \\\n-\tcrypto/dsa.lo crypto/elliptic.lo crypto/hmac.lo crypto/md4.lo \\\n-\tcrypto/md5.lo crypto/ocsp.lo crypto/openpgp.lo crypto/rand.lo \\\n-\tcrypto/rc4.lo crypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n+\tcrypto/dsa.lo crypto/ecdsa.lo crypto/elliptic.lo \\\n+\tcrypto/hmac.lo crypto/md4.lo crypto/md5.lo crypto/ocsp.lo \\\n+\tcrypto/openpgp.lo crypto/rand.lo crypto/rc4.lo \\\n+\tcrypto/ripemd160.lo crypto/rsa.lo crypto/sha1.lo \\\n \tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n \tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo crypto/openpgp/error.lo \\\n@@ -155,13 +157,14 @@ am__DEPENDENCIES_2 = asn1/asn1.lo big/big.lo bufio/bufio.lo \\\n \texp/datafmt.lo exp/draw.lo exp/eval.lo go/ast.lo go/doc.lo \\\n \tgo/parser.lo go/printer.lo go/scanner.lo go/token.lo \\\n \tgo/typechecker.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n-\thttp/pprof.lo image/jpeg.lo image/png.lo index/suffixarray.lo \\\n-\tio/ioutil.lo mime/multipart.lo net/dict.lo net/textproto.lo \\\n-\t$(am__DEPENDENCIES_1) os/signal.lo rpc/jsonrpc.lo \\\n-\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n-\tsync/atomic_c.lo syscalls/syscall.lo syscalls/errno.lo \\\n-\ttesting/testing.lo testing/iotest.lo testing/quick.lo \\\n-\ttesting/script.lo\n+\thash/fnv.lo http/cgi.lo http/httptest.lo http/pprof.lo \\\n+\timage/jpeg.lo image/png.lo index/suffixarray.lo io/ioutil.lo \\\n+\tmime/multipart.lo net/dict.lo net/textproto.lo \\\n+\t$(am__DEPENDENCIES_1) os/signal.lo path/filepath.lo \\\n+\trpc/jsonrpc.lo runtime/debug.lo runtime/pprof.lo \\\n+\tsync/atomic.lo sync/atomic_c.lo syscalls/syscall.lo \\\n+\tsyscalls/errno.lo testing/testing.lo testing/iotest.lo \\\n+\ttesting/quick.lo testing/script.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -280,8 +283,9 @@ DATA = $(toolexeclibgo_DATA) $(toolexeclibgoarchive_DATA) \\\n \t$(toolexeclibgoimage_DATA) $(toolexeclibgoindex_DATA) \\\n \t$(toolexeclibgoio_DATA) $(toolexeclibgomime_DATA) \\\n \t$(toolexeclibgonet_DATA) $(toolexeclibgoos_DATA) \\\n-\t$(toolexeclibgorpc_DATA) $(toolexeclibgoruntime_DATA) \\\n-\t$(toolexeclibgosync_DATA) $(toolexeclibgotesting_DATA)\n+\t$(toolexeclibgopath_DATA) $(toolexeclibgorpc_DATA) \\\n+\t$(toolexeclibgoruntime_DATA) $(toolexeclibgosync_DATA) \\\n+\t$(toolexeclibgotesting_DATA)\n RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n   distclean-recursive maintainer-clean-recursive\n AM_RECURSIVE_TARGETS = $(RECURSIVE_TARGETS:-recursive=) \\\n@@ -620,6 +624,7 @@ toolexeclibgocrypto_DATA = \\\n \tcrypto/cast5.gox \\\n \tcrypto/cipher.gox \\\n \tcrypto/dsa.gox \\\n+\tcrypto/ecdsa.gox \\\n \tcrypto/elliptic.gox \\\n \tcrypto/hmac.gox \\\n \tcrypto/md4.gox \\\n@@ -686,10 +691,13 @@ toolexeclibgohashdir = $(toolexeclibgodir)/hash\n toolexeclibgohash_DATA = \\\n \thash/adler32.gox \\\n \thash/crc32.gox \\\n-\thash/crc64.gox\n+\thash/crc64.gox \\\n+\thash/fnv.gox\n \n toolexeclibgohttpdir = $(toolexeclibgodir)/http\n toolexeclibgohttp_DATA = \\\n+\thttp/cgi.gox \\\n+\thttp/httptest.gox \\\n \thttp/pprof.gox\n \n toolexeclibgoimagedir = $(toolexeclibgodir)/image\n@@ -723,6 +731,10 @@ toolexeclibgoos_DATA = \\\n \t$(os_inotify_gox) \\\n \tos/signal.gox\n \n+toolexeclibgopathdir = $(toolexeclibgodir)/path\n+toolexeclibgopath_DATA = \\\n+\tpath/filepath.gox\n+\n toolexeclibgorpcdir = $(toolexeclibgodir)/rpc\n toolexeclibgorpc_DATA = \\\n \trpc/jsonrpc.gox\n@@ -928,6 +940,7 @@ go_html_files = \\\n go_http_files = \\\n \tgo/http/chunked.go \\\n \tgo/http/client.go \\\n+\tgo/http/cookie.go \\\n \tgo/http/dump.go \\\n \tgo/http/fs.go \\\n \tgo/http/header.go \\\n@@ -1084,8 +1097,7 @@ go_patch_files = \\\n \n go_path_files = \\\n \tgo/path/match.go \\\n-\tgo/path/path.go \\\n-\tgo/path/path_unix.go\n+\tgo/path/path.go\n \n go_rand_files = \\\n \tgo/rand/exp.go \\\n@@ -1111,6 +1123,7 @@ go_runtime_files = \\\n \tgo/runtime/debug.go \\\n \tgo/runtime/error.go \\\n \tgo/runtime/extern.go \\\n+\tgo/runtime/mem.go \\\n \tgo/runtime/sig.go \\\n \tgo/runtime/softfloat64.go \\\n \tgo/runtime/type.go \\\n@@ -1170,6 +1183,7 @@ go_testing_files = \\\n go_time_files = \\\n \tgo/time/format.go \\\n \tgo/time/sleep.go \\\n+\tgo/time/sys.go \\\n \tgo/time/tick.go \\\n \tgo/time/time.go \\\n \tgo/time/zoneinfo_unix.go\n@@ -1286,6 +1300,9 @@ go_crypto_cipher_files = \\\n go_crypto_dsa_files = \\\n \tgo/crypto/dsa/dsa.go\n \n+go_crypto_ecdsa_files = \\\n+\tgo/crypto/ecdsa/ecdsa.go\n+\n go_crypto_elliptic_files = \\\n \tgo/crypto/elliptic/elliptic.go\n \n@@ -1490,6 +1507,7 @@ go_go_token_files = \\\n \n go_go_typechecker_files = \\\n \tgo/go/typechecker/scope.go \\\n+\tgo/go/typechecker/type.go \\\n \tgo/go/typechecker/typechecker.go \\\n \tgo/go/typechecker/universe.go\n \n@@ -1502,6 +1520,17 @@ go_hash_crc32_files = \\\n go_hash_crc64_files = \\\n \tgo/hash/crc64/crc64.go\n \n+go_hash_fnv_files = \\\n+\tgo/hash/fnv/fnv.go\n+\n+go_http_cgi_files = \\\n+\tgo/http/cgi/child.go \\\n+\tgo/http/cgi/host.go\n+\n+go_http_httptest_files = \\\n+\tgo/http/httptest/recorder.go \\\n+\tgo/http/httptest/server.go\n+\n go_http_pprof_files = \\\n \tgo/http/pprof/pprof.go\n \n@@ -1542,6 +1571,11 @@ go_os_signal_files = \\\n \tgo/os/signal/signal.go \\\n \tunix.go\n \n+go_path_filepath_files = \\\n+\tgo/path/filepath/match.go \\\n+\tgo/path/filepath/path.go \\\n+\tgo/path/filepath/path_unix.go\n+\n go_rpc_jsonrpc_files = \\\n \tgo/rpc/jsonrpc/client.go \\\n \tgo/rpc/jsonrpc/server.go\n@@ -1718,6 +1752,7 @@ libgo_go_objs = \\\n \tcrypto/cast5.lo \\\n \tcrypto/cipher.lo \\\n \tcrypto/dsa.lo \\\n+\tcrypto/ecdsa.lo \\\n \tcrypto/elliptic.lo \\\n \tcrypto/hmac.lo \\\n \tcrypto/md4.lo \\\n@@ -1767,6 +1802,9 @@ libgo_go_objs = \\\n \thash/adler32.lo \\\n \thash/crc32.lo \\\n \thash/crc64.lo \\\n+\thash/fnv.lo \\\n+\thttp/cgi.lo \\\n+\thttp/httptest.lo \\\n \thttp/pprof.lo \\\n \timage/jpeg.lo \\\n \timage/png.lo \\\n@@ -1777,6 +1815,7 @@ libgo_go_objs = \\\n \tnet/textproto.lo \\\n \t$(os_lib_inotify_lo) \\\n \tos/signal.lo \\\n+\tpath/filepath.lo \\\n \trpc/jsonrpc.lo \\\n \truntime/debug.lo \\\n \truntime/pprof.lo \\\n@@ -1883,7 +1922,7 @@ TEST_PACKAGES = \\\n \tfmt/check \\\n \tgob/check \\\n \thtml/check \\\n-\t$(if $(GCCGO_RUN_ALL_TESTS),http/check) \\\n+\thttp/check \\\n \tio/check \\\n \tjson/check \\\n \tlog/check \\\n@@ -1932,6 +1971,7 @@ TEST_PACKAGES = \\\n \tcrypto/cast5/check \\\n \tcrypto/cipher/check \\\n \tcrypto/dsa/check \\\n+\tcrypto/ecdsa/check \\\n \tcrypto/elliptic/check \\\n \tcrypto/hmac/check \\\n \tcrypto/md4/check \\\n@@ -1976,13 +2016,16 @@ TEST_PACKAGES = \\\n \thash/adler32/check \\\n \thash/crc32/check \\\n \thash/crc64/check \\\n+\thash/fnv/check \\\n+\thttp/cgi/check \\\n \timage/png/check \\\n \tindex/suffixarray/check \\\n \tio/ioutil/check \\\n \tmime/multipart/check \\\n \tnet/textproto/check \\\n \t$(os_inotify_check) \\\n \tos/signal/check \\\n+\tpath/filepath/check \\\n \trpc/jsonrpc/check \\\n \tsync/atomic/check \\\n \ttesting/quick/check \\\n@@ -3271,6 +3314,26 @@ uninstall-toolexeclibgoosDATA:\n \ttest -n \"$$files\" || exit 0; \\\n \techo \" ( cd '$(DESTDIR)$(toolexeclibgoosdir)' && rm -f\" $$files \")\"; \\\n \tcd \"$(DESTDIR)$(toolexeclibgoosdir)\" && rm -f $$files\n+install-toolexeclibgopathDATA: $(toolexeclibgopath_DATA)\n+\t@$(NORMAL_INSTALL)\n+\ttest -z \"$(toolexeclibgopathdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgopathdir)\"\n+\t@list='$(toolexeclibgopath_DATA)'; test -n \"$(toolexeclibgopathdir)\" || list=; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_DATA) $$files '$(DESTDIR)$(toolexeclibgopathdir)'\"; \\\n+\t  $(INSTALL_DATA) $$files \"$(DESTDIR)$(toolexeclibgopathdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-toolexeclibgopathDATA:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(toolexeclibgopath_DATA)'; test -n \"$(toolexeclibgopathdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\ttest -n \"$$files\" || exit 0; \\\n+\techo \" ( cd '$(DESTDIR)$(toolexeclibgopathdir)' && rm -f\" $$files \")\"; \\\n+\tcd \"$(DESTDIR)$(toolexeclibgopathdir)\" && rm -f $$files\n install-toolexeclibgorpcDATA: $(toolexeclibgorpc_DATA)\n \t@$(NORMAL_INSTALL)\n \ttest -z \"$(toolexeclibgorpcdir)\" || $(MKDIR_P) \"$(DESTDIR)$(toolexeclibgorpcdir)\"\n@@ -3668,7 +3731,7 @@ all-am: Makefile $(LIBRARIES) $(LTLIBRARIES) all-multi $(DATA) \\\n \t\tconfig.h\n installdirs: installdirs-recursive\n installdirs-am:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibgodir)\" \"$(DESTDIR)$(toolexeclibgoarchivedir)\" \"$(DESTDIR)$(toolexeclibgocompressdir)\" \"$(DESTDIR)$(toolexeclibgocontainerdir)\" \"$(DESTDIR)$(toolexeclibgocryptodir)\" \"$(DESTDIR)$(toolexeclibgocryptoopenpgpdir)\" \"$(DESTDIR)$(toolexeclibgodebugdir)\" \"$(DESTDIR)$(toolexeclibgoencodingdir)\" \"$(DESTDIR)$(toolexeclibgoexpdir)\" \"$(DESTDIR)$(toolexeclibgogodir)\" \"$(DESTDIR)$(toolexeclibgohashdir)\" \"$(DESTDIR)$(toolexeclibgohttpdir)\" \"$(DESTDIR)$(toolexeclibgoimagedir)\" \"$(DESTDIR)$(toolexeclibgoindexdir)\" \"$(DESTDIR)$(toolexeclibgoiodir)\" \"$(DESTDIR)$(toolexeclibgomimedir)\" \"$(DESTDIR)$(toolexeclibgonetdir)\" \"$(DESTDIR)$(toolexeclibgoosdir)\" \"$(DESTDIR)$(toolexeclibgopathdir)\" \"$(DESTDIR)$(toolexeclibgorpcdir)\" \"$(DESTDIR)$(toolexeclibgoruntimedir)\" \"$(DESTDIR)$(toolexeclibgosyncdir)\" \"$(DESTDIR)$(toolexeclibgotestingdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-recursive\n@@ -3741,9 +3804,9 @@ install-exec-am: install-multi install-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n-\tinstall-toolexeclibgotestingDATA\n+\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n+\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgosyncDATA install-toolexeclibgotestingDATA\n \n install-html: install-html-recursive\n \n@@ -3800,7 +3863,8 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n-\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotestingDATA\n@@ -3836,15 +3900,15 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tinstall-toolexeclibgohttpDATA install-toolexeclibgoimageDATA \\\n \tinstall-toolexeclibgoindexDATA install-toolexeclibgoioDATA \\\n \tinstall-toolexeclibgomimeDATA install-toolexeclibgonetDATA \\\n-\tinstall-toolexeclibgoosDATA install-toolexeclibgorpcDATA \\\n-\tinstall-toolexeclibgoruntimeDATA install-toolexeclibgosyncDATA \\\n-\tinstall-toolexeclibgotestingDATA installcheck installcheck-am \\\n-\tinstalldirs installdirs-am maintainer-clean \\\n-\tmaintainer-clean-generic maintainer-clean-multi mostlyclean \\\n-\tmostlyclean-compile mostlyclean-generic mostlyclean-libtool \\\n-\tmostlyclean-local mostlyclean-multi pdf pdf-am ps ps-am tags \\\n-\ttags-recursive uninstall uninstall-am \\\n-\tuninstall-toolexeclibLIBRARIES \\\n+\tinstall-toolexeclibgoosDATA install-toolexeclibgopathDATA \\\n+\tinstall-toolexeclibgorpcDATA install-toolexeclibgoruntimeDATA \\\n+\tinstall-toolexeclibgosyncDATA install-toolexeclibgotestingDATA \\\n+\tinstallcheck installcheck-am installdirs installdirs-am \\\n+\tmaintainer-clean maintainer-clean-generic \\\n+\tmaintainer-clean-multi mostlyclean mostlyclean-compile \\\n+\tmostlyclean-generic mostlyclean-libtool mostlyclean-local \\\n+\tmostlyclean-multi pdf pdf-am ps ps-am tags tags-recursive \\\n+\tuninstall uninstall-am uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibLTLIBRARIES uninstall-toolexeclibgoDATA \\\n \tuninstall-toolexeclibgoarchiveDATA \\\n \tuninstall-toolexeclibgocompressDATA \\\n@@ -3859,7 +3923,8 @@ uninstall-am: uninstall-toolexeclibLIBRARIES \\\n \tuninstall-toolexeclibgoimageDATA \\\n \tuninstall-toolexeclibgoindexDATA uninstall-toolexeclibgoioDATA \\\n \tuninstall-toolexeclibgomimeDATA uninstall-toolexeclibgonetDATA \\\n-\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgorpcDATA \\\n+\tuninstall-toolexeclibgoosDATA uninstall-toolexeclibgopathDATA \\\n+\tuninstall-toolexeclibgorpcDATA \\\n \tuninstall-toolexeclibgoruntimeDATA \\\n \tuninstall-toolexeclibgosyncDATA \\\n \tuninstall-toolexeclibgotestingDATA\n@@ -3918,7 +3983,7 @@ asn1/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: asn1/check\n \n-big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox\n+big/big.lo: $(go_big_files) fmt.gox rand.gox strings.gox os.gox\n \t$(BUILDPACKAGE)\n big/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -3983,9 +4048,9 @@ fmt/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: fmt/check\n \n-gob/gob.lo: $(go_gob_files) bytes.gox fmt.gox io.gox math.gox os.gox \\\n-\t\treflect.gox runtime.gox strings.gox sync.gox unicode.gox \\\n-\t\tutf8.gox\n+gob/gob.lo: $(go_gob_files) bufio.gox bytes.gox fmt.gox io.gox math.gox \\\n+\t\tos.gox reflect.gox runtime.gox strings.gox sync.gox \\\n+\t\tunicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n gob/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4007,8 +4072,8 @@ html/check: $(CHECK_DEPS)\n http/http.lo: $(go_http_files) bufio.gox bytes.gox container/vector.gox \\\n \t\tcrypto/rand.gox crypto/tls.gox encoding/base64.gox fmt.gox \\\n \t\tio.gox io/ioutil.gox log.gox mime.gox mime/multipart.gox \\\n-\t\tnet.gox net/textproto.gox os.gox path.gox sort.gox \\\n-\t\tstrconv.gox strings.gox sync.gox time.gox utf8.gox\n+\t\tnet.gox net/textproto.gox os.gox path.gox path/filepath.gox \\\n+\t\tsort.gox strconv.gox strings.gox sync.gox time.gox utf8.gox\n \t$(BUILDPACKAGE)\n http/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4020,7 +4085,7 @@ image/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: image/check\n \n-io/io.lo: $(go_io_files) os.gox runtime.gox sync.gox\n+io/io.lo: $(go_io_files) os.gox sync.gox\n \t$(BUILDPACKAGE)\n io/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4083,8 +4148,7 @@ patch/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: patch/check\n \n-path/path.lo: $(go_path_files) io/ioutil.gox os.gox sort.gox strings.gox \\\n-\t\tutf8.gox\n+path/path.lo: $(go_path_files) os.gox strings.gox utf8.gox\n \t$(BUILDPACKAGE)\n path/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4185,7 +4249,7 @@ template/check: $(CHECK_DEPS)\n .PHONY: template/check\n \n testing/testing.lo: $(go_testing_files) flag.gox fmt.gox os.gox regexp.gox \\\n-\t\truntime.gox time.gox\n+\t\truntime.gox runtime/pprof.gox time.gox\n \t$(BUILDPACKAGE)\n testing/check: $(CHECK_DEPS)\n \t$(CHECK)\n@@ -4248,7 +4312,7 @@ archive/tar/check: $(CHECK_DEPS)\n \n archive/zip.lo: $(go_archive_zip_files) bufio.gox bytes.gox \\\n \t\tcompress/flate.gox hash.gox hash/crc32.gox \\\n-\t\tencoding/binary.gox io.gox os.gox\n+\t\tencoding/binary.gox io.gox io/ioutil.gox os.gox\n \t$(BUILDPACKAGE)\n archive/zip/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) archive/zip\n@@ -4363,6 +4427,14 @@ crypto/dsa/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/dsa/check\n \n+crypto/ecdsa.lo: $(go_crypto_ecdsa_files) big.gox crypto/elliptic.gox io.gox \\\n+\t\tos.gox\n+\t$(BUILDPACKAGE)\n+crypto/ecdsa/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/ecdsa\n+\t$(CHECK)\n+.PHONY: crypto/ecdsa/check\n+\n crypto/elliptic.lo: $(go_crypto_elliptic_files) big.gox io.gox os.gox sync.gox\n \t$(BUILDPACKAGE)\n crypto/elliptic/check: $(CHECK_DEPS)\n@@ -4400,8 +4472,8 @@ crypto/ocsp/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: crypto/ocsp/check\n \n-crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox \\\n-\t\t crypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n+crypto/openpgp.lo: $(go_crypto_openpgp_files) crypto.gox crypto/dsa.gox \\\n+\t\tcrypto/openpgp/armor.gox crypto/openpgp/error.gox \\\n \t\tcrypto/openpgp/packet.gox crypto/rsa.gox crypto/sha256.gox \\\n \t\thash.gox io.gox os.gox strconv.gox time.gox\n \t$(BUILDPACKAGE)\n@@ -4523,10 +4595,10 @@ crypto/openpgp/error/check: $(CHECK_DEPS)\n crypto/openpgp/packet.lo: $(go_crypto_openpgp_packet_files) big.gox bytes.gox \\\n \t\tcompress/flate.gox compress/zlib.gox crypto.gox \\\n \t\tcrypto/aes.gox crypto/cast5.gox crypto/cipher.gox \\\n-\t\tcrypto/openpgp/error.gox crypto/openpgp/s2k.gox \\\n-\t\tcrypto/rand.gox crypto/rsa.gox crypto/sha1.gox \\\n-\t\tcrypto/subtle.gox encoding/binary.gox hash.gox io.gox \\\n-\t\tio/ioutil.gox os.gox strconv.gox strings.gox\n+\t\tcrypto/dsa.gox crypto/openpgp/error.gox \\\n+\t\tcrypto/openpgp/s2k.gox crypto/rand.gox crypto/rsa.gox \\\n+\t\tcrypto/sha1.gox crypto/subtle.gox encoding/binary.gox fmt.gox \\\n+\t\thash.gox io.gox io/ioutil.gox os.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n crypto/openpgp/packet/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) crypto/openpgp/packet\n@@ -4674,8 +4746,8 @@ exp/eval/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: exp/eval/check\n \n-go/ast.lo: $(go_go_ast_files) fmt.gox go/token.gox io.gox os.gox reflect.gox \\\n-\t\tunicode.gox utf8.gox\n+go/ast.lo: $(go_go_ast_files) bytes.gox fmt.gox go/token.gox io.gox os.gox \\\n+\t\treflect.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/ast/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/ast\n@@ -4692,25 +4764,25 @@ go/doc/check: $(CHECK_DEPS)\n \n go/parser.lo: $(go_go_parser_files) bytes.gox fmt.gox go/ast.gox \\\n \t\tgo/scanner.gox go/token.gox io.gox io/ioutil.gox os.gox \\\n-\t\tpath.gox strings.gox\n+\t\tpath/filepath.gox strings.gox\n \t$(BUILDPACKAGE)\n go/parser/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/parser\n \t$(CHECK)\n .PHONY: go/parser/check\n \n go/printer.lo: $(go_go_printer_files) bytes.gox fmt.gox go/ast.gox \\\n-\t\tgo/token.gox io.gox os.gox reflect.gox runtime.gox \\\n-\t\tstrings.gox tabwriter.gox\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox reflect.gox \\\n+\t\truntime.gox strings.gox tabwriter.gox\n \t$(BUILDPACKAGE)\n go/printer/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/printer\n \t$(CHECK)\n .PHONY: go/printer/check\n \n go/scanner.lo: $(go_go_scanner_files) bytes.gox container/vector.gox fmt.gox \\\n-\t\tgo/token.gox io.gox os.gox path.gox sort.gox strconv.gox \\\n-\t\tunicode.gox utf8.gox\n+\t\tgo/token.gox io.gox os.gox path/filepath.gox sort.gox \\\n+\t\tstrconv.gox unicode.gox utf8.gox\n \t$(BUILDPACKAGE)\n go/scanner/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) go/scanner\n@@ -4753,6 +4825,30 @@ hash/crc64/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: hash/crc64/check\n \n+hash/fnv.lo: $(go_hash_fnv_files) encoding/binary.gox hash.gox os.gox\n+\t$(BUILDPACKAGE)\n+hash/fnv/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) hash/fnv\n+\t$(CHECK)\n+.PHONY: hash/fnv/check\n+\n+http/cgi.lo: $(go_http_cgi_files) bufio.gox bytes.gox encoding/line.gox \\\n+\t\texec.gox fmt.gox http.gox io.gox io/ioutil.gox log.gox \\\n+\t\tos.gox path/filepath.gox regexp.gox strconv.gox strings.gox\n+\t$(BUILDPACKAGE)\n+http/cgi/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/cgi\n+\t$(CHECK)\n+.PHONY: http/cgi/check\n+\n+http/httptest.lo: $(go_http_httptest_files) bytes.gox fmt.gox http.gox \\\n+\t\tnet.gox os.gox\n+\t$(BUILDPACKAGE)\n+http/httptest/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) http/httptest\n+\t$(CHECK)\n+.PHONY: http/httptest/check\n+\n http/pprof.lo: $(go_http_pprof_files) bufio.gox fmt.gox http.gox os.gox \\\n \t\truntime.gox runtime/pprof.gox strconv.gox strings.gox\n \t$(BUILDPACKAGE)\n@@ -4784,16 +4880,16 @@ index/suffixarray/check: $(CHECK_DEPS)\n \t$(CHECK)\n .PHONY: index/suffixarray/check\n \n-io/ioutil.lo: $(go_io_ioutil_files) bytes.gox io.gox os.gox sort.gox \\\n-\t\tstrconv.gox\n+io/ioutil.lo: $(go_io_ioutil_files) bytes.gox io.gox os.gox path/filepath.gox \\\n+\t\tsort.gox strconv.gox\n \t$(BUILDPACKAGE)\n io/ioutil/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) io/ioutil\n \t$(CHECK)\n .PHONY: io/ioutil/check\n \n mime/multipart.lo: $(go_mime_multipart_files) bufio.gox bytes.gox io.gox \\\n-\t\tmime.gox os.gox regexp.gox strings.gox\n+\t\tmime.gox net/textproto.gox os.gox regexp.gox strings.gox\n \t$(BUILDPACKAGE)\n mime/multipart/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) mime/multipart\n@@ -4831,6 +4927,14 @@ unix.go: $(srcdir)/go/os/signal/mkunix.sh sysinfo.go\n \t$(SHELL) $(srcdir)/go/os/signal/mkunix.sh sysinfo.go > $@.tmp\n \tmv -f $@.tmp $@\n \n+path/filepath.lo: $(go_path_filepath_files) bytes.gox os.gox sort.gox \\\n+\t\tstrings.gox utf8.gox\n+\t$(BUILDPACKAGE)\n+path/filepath/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) path/filepath\n+\t$(CHECK)\n+.PHONY: path/filepath/check\n+\n rpc/jsonrpc.lo: $(go_rpc_jsonrpc_files) fmt.gox io.gox json.gox net.gox \\\n \t\tos.gox rpc.gox sync.gox\n \t$(BUILDPACKAGE)\n@@ -4848,7 +4952,7 @@ runtime/debug/check: $(CHECK_DEPS)\n .PHONY: runtime/debug/check\n \n runtime/pprof.lo: $(go_runtime_pprof_files) bufio.gox fmt.gox io.gox os.gox \\\n-\t\truntime.gox\n+\t\truntime.gox sync.gox\n \t$(BUILDPACKAGE)\n runtime/pprof/check: $(CHECK_DEPS)\n \t@$(MKDIR_P) runtime/pprof\n@@ -5034,6 +5138,8 @@ crypto/cipher.gox: crypto/cipher.lo\n \t$(BUILDGOX)\n crypto/dsa.gox: crypto/dsa.lo\n \t$(BUILDGOX)\n+crypto/ecdsa.gox: crypto/ecdsa.lo\t\n+\t$(BUILDGOX)\n crypto/elliptic.gox: crypto/elliptic.lo\n \t$(BUILDGOX)\n crypto/hmac.gox: crypto/hmac.lo\n@@ -5138,7 +5244,13 @@ hash/crc32.gox: hash/crc32.lo\n \t$(BUILDGOX)\n hash/crc64.gox: hash/crc64.lo\n \t$(BUILDGOX)\n+hash/fnv.gox: hash/fnv.lo\n+\t$(BUILDGOX)\n \n+http/cgi.gox: http/cgi.lo\n+\t$(BUILDGOX)\n+http/httptest.gox: http/httptest.lo\n+\t$(BUILDGOX)\n http/pprof.gox: http/pprof.lo\n \t$(BUILDGOX)\n \n@@ -5166,6 +5278,9 @@ os/inotify.gox: os/inotify.lo\n os/signal.gox: os/signal.lo\n \t$(BUILDGOX)\n \n+path/filepath.gox: path/filepath.lo\n+\t$(BUILDGOX)\n+\n rpc/jsonrpc.gox: rpc/jsonrpc.lo\n \t$(BUILDGOX)\n "}, {"sha": "3b265c9b72e6fe99cf50fb88ee13fabd44400a77", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -19,6 +19,7 @@ import (\n \t\"hash/crc32\"\n \t\"encoding/binary\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n )\n \n@@ -109,7 +110,7 @@ func (f *File) Open() (rc io.ReadCloser, err os.Error) {\n \tr := io.NewSectionReader(f.zipr, off+f.bodyOffset, size)\n \tswitch f.Method {\n \tcase 0: // store (no compression)\n-\t\trc = nopCloser{r}\n+\t\trc = ioutil.NopCloser(r)\n \tcase 8: // DEFLATE\n \t\trc = flate.NewReader(r)\n \tdefault:\n@@ -147,12 +148,6 @@ func (r *checksumReader) Read(b []byte) (n int, err os.Error) {\n \n func (r *checksumReader) Close() os.Error { return r.rc.Close() }\n \n-type nopCloser struct {\n-\tio.Reader\n-}\n-\n-func (f nopCloser) Close() os.Error { return nil }\n-\n func readFileHeader(f *File, r io.Reader) (err os.Error) {\n \tdefer func() {\n \t\tif rerr, ok := recover().(os.Error); ok {"}, {"sha": "ecd70e03ef10b954c6a011d5c6408839d24e9f7b", "filename": "libgo/go/big/int.go", "status": "modified", "additions": 39, "deletions": 50, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,6 +8,7 @@ package big\n \n import (\n \t\"fmt\"\n+\t\"os\"\n \t\"rand\"\n )\n \n@@ -393,62 +394,19 @@ func (z *Int) SetString(s string, base int) (*Int, bool) {\n }\n \n \n-// SetBytes interprets b as the bytes of a big-endian, unsigned integer and\n-// sets z to that value.\n-func (z *Int) SetBytes(b []byte) *Int {\n-\tconst s = _S\n-\tz.abs = z.abs.make((len(b) + s - 1) / s)\n-\n-\tj := 0\n-\tfor len(b) >= s {\n-\t\tvar w Word\n-\n-\t\tfor i := s; i > 0; i-- {\n-\t\t\tw <<= 8\n-\t\t\tw |= Word(b[len(b)-i])\n-\t\t}\n-\n-\t\tz.abs[j] = w\n-\t\tj++\n-\t\tb = b[0 : len(b)-s]\n-\t}\n-\n-\tif len(b) > 0 {\n-\t\tvar w Word\n-\n-\t\tfor i := len(b); i > 0; i-- {\n-\t\t\tw <<= 8\n-\t\t\tw |= Word(b[len(b)-i])\n-\t\t}\n-\n-\t\tz.abs[j] = w\n-\t}\n-\n-\tz.abs = z.abs.norm()\n+// SetBytes interprets buf as the bytes of a big-endian unsigned\n+// integer, sets z to that value, and returns z.\n+func (z *Int) SetBytes(buf []byte) *Int {\n+\tz.abs = z.abs.setBytes(buf)\n \tz.neg = false\n \treturn z\n }\n \n \n-// Bytes returns the absolute value of x as a big-endian byte array.\n+// Bytes returns the absolute value of z as a big-endian byte slice.\n func (z *Int) Bytes() []byte {\n-\tconst s = _S\n-\tb := make([]byte, len(z.abs)*s)\n-\n-\tfor i, w := range z.abs {\n-\t\twordBytes := b[(len(z.abs)-i-1)*s : (len(z.abs)-i)*s]\n-\t\tfor j := s - 1; j >= 0; j-- {\n-\t\t\twordBytes[j] = byte(w)\n-\t\t\tw >>= 8\n-\t\t}\n-\t}\n-\n-\ti := 0\n-\tfor i < len(b) && b[i] == 0 {\n-\t\ti++\n-\t}\n-\n-\treturn b[i:]\n+\tbuf := make([]byte, len(z.abs)*_S)\n+\treturn buf[z.abs.bytes(buf):]\n }\n \n \n@@ -739,3 +697,34 @@ func (z *Int) Not(x *Int) *Int {\n \tz.neg = true // z cannot be zero if x is positive\n \treturn z\n }\n+\n+\n+// Gob codec version. Permits backward-compatible changes to the encoding.\n+const version byte = 1\n+\n+// GobEncode implements the gob.GobEncoder interface.\n+func (z *Int) GobEncode() ([]byte, os.Error) {\n+\tbuf := make([]byte, len(z.abs)*_S+1) // extra byte for version and sign bit\n+\ti := z.abs.bytes(buf) - 1            // i >= 0\n+\tb := version << 1                    // make space for sign bit\n+\tif z.neg {\n+\t\tb |= 1\n+\t}\n+\tbuf[i] = b\n+\treturn buf[i:], nil\n+}\n+\n+\n+// GobDecode implements the gob.GobDecoder interface.\n+func (z *Int) GobDecode(buf []byte) os.Error {\n+\tif len(buf) == 0 {\n+\t\treturn os.NewError(\"Int.GobDecode: no data\")\n+\t}\n+\tb := buf[0]\n+\tif b>>1 != version {\n+\t\treturn os.NewError(fmt.Sprintf(\"Int.GobDecode: encoding version %d not supported\", b>>1))\n+\t}\n+\tz.neg = b&1 != 0\n+\tz.abs = z.abs.setBytes(buf[1:])\n+\treturn nil\n+}"}, {"sha": "c0cc9accf1a86103b6596d40dd35eda95b41aaad", "filename": "libgo/go/big/int_test.go", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fint_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/hex\"\n \t\"fmt\"\n+\t\"gob\"\n \t\"testing\"\n \t\"testing/quick\"\n )\n@@ -1053,3 +1054,41 @@ func TestModInverse(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+\n+var gobEncodingTests = []string{\n+\t\"0\",\n+\t\"1\",\n+\t\"2\",\n+\t\"10\",\n+\t\"42\",\n+\t\"1234567890\",\n+\t\"298472983472983471903246121093472394872319615612417471234712061\",\n+}\n+\n+func TestGobEncoding(t *testing.T) {\n+\tvar medium bytes.Buffer\n+\tenc := gob.NewEncoder(&medium)\n+\tdec := gob.NewDecoder(&medium)\n+\tfor i, test := range gobEncodingTests {\n+\t\tfor j := 0; j < 2; j++ {\n+\t\t\tmedium.Reset() // empty buffer for each test case (in case of failures)\n+\t\t\tstest := test\n+\t\t\tif j == 0 {\n+\t\t\t\tstest = \"-\" + test\n+\t\t\t}\n+\t\t\tvar tx Int\n+\t\t\ttx.SetString(stest, 10)\n+\t\t\tif err := enc.Encode(&tx); err != nil {\n+\t\t\t\tt.Errorf(\"#%d%c: encoding failed: %s\", i, 'a'+j, err)\n+\t\t\t}\n+\t\t\tvar rx Int\n+\t\t\tif err := dec.Decode(&rx); err != nil {\n+\t\t\t\tt.Errorf(\"#%d%c: decoding failed: %s\", i, 'a'+j, err)\n+\t\t\t}\n+\t\t\tif rx.Cmp(&tx) != 0 {\n+\t\t\t\tt.Errorf(\"#%d%c: transmission failed: got %s want %s\", i, 'a'+j, &rx, &tx)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "a04d3b1d9c1e4cc21552d72228fac0246a98fe76", "filename": "libgo/go/big/nat.go", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbig%2Fnat.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -1065,3 +1065,50 @@ NextRandom:\n \n \treturn true\n }\n+\n+\n+// bytes writes the value of z into buf using big-endian encoding.\n+// len(buf) must be >= len(z)*_S. The value of z is encoded in the\n+// slice buf[i:]. The number i of unused bytes at the beginning of\n+// buf is returned as result.\n+func (z nat) bytes(buf []byte) (i int) {\n+\ti = len(buf)\n+\tfor _, d := range z {\n+\t\tfor j := 0; j < _S; j++ {\n+\t\t\ti--\n+\t\t\tbuf[i] = byte(d)\n+\t\t\td >>= 8\n+\t\t}\n+\t}\n+\n+\tfor i < len(buf) && buf[i] == 0 {\n+\t\ti++\n+\t}\n+\n+\treturn\n+}\n+\n+\n+// setBytes interprets buf as the bytes of a big-endian unsigned\n+// integer, sets z to that value, and returns z.\n+func (z nat) setBytes(buf []byte) nat {\n+\tz = z.make((len(buf) + _S - 1) / _S)\n+\n+\tk := 0\n+\ts := uint(0)\n+\tvar d Word\n+\tfor i := len(buf); i > 0; i-- {\n+\t\td |= Word(buf[i-1]) << s\n+\t\tif s += 8; s == _S*8 {\n+\t\t\tz[k] = d\n+\t\t\tk++\n+\t\t\ts = 0\n+\t\t\td = 0\n+\t\t}\n+\t}\n+\tif k < len(z) {\n+\t\tz[k] = d\n+\t}\n+\n+\treturn z.norm()\n+}"}, {"sha": "8028e04dcd972dc6b51828afab7e36dcc9138a5c", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,9 +2,10 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package bufio\n+package bufio_test\n \n import (\n+\t. \"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n@@ -502,9 +503,8 @@ func TestWriteString(t *testing.T) {\n \tb.WriteString(\"7890\")                      // easy after flush\n \tb.WriteString(\"abcdefghijklmnopqrstuvwxy\") // hard\n \tb.WriteString(\"z\")\n-\tb.Flush()\n-\tif b.err != nil {\n-\t\tt.Error(\"WriteString\", b.err)\n+\tif err := b.Flush(); err != nil {\n+\t\tt.Error(\"WriteString\", err)\n \t}\n \ts := \"01234567890abcdefghijklmnopqrstuvwxyz\"\n \tif string(buf.Bytes()) != s {"}, {"sha": "ed5884a4b78de8a1437bedd82a69b59c97da4b20", "filename": "libgo/go/compress/flate/deflate_test.go", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Fflate%2Fdeflate_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -191,9 +191,16 @@ func testSync(t *testing.T, level int, input []byte, name string) {\n \t\t\tt.Errorf(\"testSync/%d: read wrong bytes: %x vs %x\", i, input[lo:hi], out[:hi-lo])\n \t\t\treturn\n \t\t}\n-\t\tif i == 0 && buf.buf.Len() != 0 {\n-\t\t\tt.Errorf(\"testSync/%d (%d, %d, %s): extra data after %d\", i, level, len(input), name, hi-lo)\n-\t\t}\n+\t\t// This test originally checked that after reading\n+\t\t// the first half of the input, there was nothing left\n+\t\t// in the read buffer (buf.buf.Len() != 0) but that is\n+\t\t// not necessarily the case: the write Flush may emit\n+\t\t// some extra framing bits that are not necessary\n+\t\t// to process to obtain the first half of the uncompressed\n+\t\t// data.  The test ran correctly most of the time, because\n+\t\t// the background goroutine had usually read even\n+\t\t// those extra bits by now, but it's not a useful thing to\n+\t\t// check.\n \t\tbuf.WriteMode()\n \t}\n \tbuf.ReadMode()"}, {"sha": "4b5dfaadea2023c51568f4109615decb22a2c683", "filename": "libgo/go/compress/lzw/reader_test.go", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Freader_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -117,16 +118,34 @@ func (devNull) Write(p []byte) (int, os.Error) {\n \treturn len(p), nil\n }\n \n-func BenchmarkDecoder(b *testing.B) {\n+func benchmarkDecoder(b *testing.B, n int) {\n \tb.StopTimer()\n+\tb.SetBytes(int64(n))\n \tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tbuf0 = buf0[:10000]\n \tcompressed := bytes.NewBuffer(nil)\n \tw := NewWriter(compressed, LSB, 8)\n-\tio.Copy(w, bytes.NewBuffer(buf0))\n+\tfor i := 0; i < n; i += len(buf0) {\n+\t\tio.Copy(w, bytes.NewBuffer(buf0))\n+\t}\n \tw.Close()\n \tbuf1 := compressed.Bytes()\n+\tbuf0, compressed, w = nil, nil, nil\n+\truntime.GC()\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tio.Copy(devNull{}, NewReader(bytes.NewBuffer(buf1), LSB, 8))\n \t}\n }\n+\n+func BenchmarkDecoder1e4(b *testing.B) {\n+\tbenchmarkDecoder(b, 1e4)\n+}\n+\n+func BenchmarkDecoder1e5(b *testing.B) {\n+\tbenchmarkDecoder(b, 1e5)\n+}\n+\n+func BenchmarkDecoder1e6(b *testing.B) {\n+\tbenchmarkDecoder(b, 1e6)\n+}"}, {"sha": "2e0a8de0a87f84124d3c754b8b7831177b7de479", "filename": "libgo/go/compress/lzw/writer_test.go", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcompress%2Flzw%2Fwriter_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -99,13 +100,33 @@ func TestWriter(t *testing.T) {\n \t}\n }\n \n-func BenchmarkEncoder(b *testing.B) {\n+func benchmarkEncoder(b *testing.B, n int) {\n \tb.StopTimer()\n-\tbuf, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tb.SetBytes(int64(n))\n+\tbuf0, _ := ioutil.ReadFile(\"../testdata/e.txt\")\n+\tbuf0 = buf0[:10000]\n+\tbuf1 := make([]byte, n)\n+\tfor i := 0; i < n; i += len(buf0) {\n+\t\tcopy(buf1[i:], buf0)\n+\t}\n+\tbuf0 = nil\n+\truntime.GC()\n \tb.StartTimer()\n \tfor i := 0; i < b.N; i++ {\n \t\tw := NewWriter(devNull{}, LSB, 8)\n-\t\tw.Write(buf)\n+\t\tw.Write(buf1)\n \t\tw.Close()\n \t}\n }\n+\n+func BenchmarkEncoder1e4(b *testing.B) {\n+\tbenchmarkEncoder(b, 1e4)\n+}\n+\n+func BenchmarkEncoder1e5(b *testing.B) {\n+\tbenchmarkEncoder(b, 1e5)\n+}\n+\n+func BenchmarkEncoder1e6(b *testing.B) {\n+\tbenchmarkEncoder(b, 1e6)\n+}"}, {"sha": "1f37849c5d5ee1b467e8e297f6a0a3d03202ea3d", "filename": "libgo/go/crypto/ecdsa/ecdsa.go", "status": "added", "additions": 149, "deletions": 0, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,149 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package ecdsa implements the Elliptic Curve Digital Signature Algorithm, as\n+// defined in FIPS 186-3.\n+package ecdsa\n+\n+// References:\n+//   [NSA]: Suite B implementor's guide to FIPS 186-3,\n+//     http://www.nsa.gov/ia/_files/ecdsa.pdf\n+//   [SECG]: SECG, SEC1\n+//     http://www.secg.org/download/aid-780/sec1-v2.pdf\n+\n+import (\n+\t\"big\"\n+\t\"crypto/elliptic\"\n+\t\"io\"\n+\t\"os\"\n+)\n+\n+// PublicKey represents an ECDSA public key.\n+type PublicKey struct {\n+\t*elliptic.Curve\n+\tX, Y *big.Int\n+}\n+\n+// PrivateKey represents a ECDSA private key.\n+type PrivateKey struct {\n+\tPublicKey\n+\tD *big.Int\n+}\n+\n+var one = new(big.Int).SetInt64(1)\n+\n+// randFieldElement returns a random element of the field underlying the given\n+// curve using the procedure given in [NSA] A.2.1.\n+func randFieldElement(c *elliptic.Curve, rand io.Reader) (k *big.Int, err os.Error) {\n+\tb := make([]byte, c.BitSize/8+8)\n+\t_, err = rand.Read(b)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tk = new(big.Int).SetBytes(b)\n+\tn := new(big.Int).Sub(c.N, one)\n+\tk.Mod(k, n)\n+\tk.Add(k, one)\n+\treturn\n+}\n+\n+// GenerateKey generates a public&private key pair.\n+func GenerateKey(c *elliptic.Curve, rand io.Reader) (priv *PrivateKey, err os.Error) {\n+\tk, err := randFieldElement(c, rand)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tpriv = new(PrivateKey)\n+\tpriv.PublicKey.Curve = c\n+\tpriv.D = k\n+\tpriv.PublicKey.X, priv.PublicKey.Y = c.ScalarBaseMult(k.Bytes())\n+\treturn\n+}\n+\n+// hashToInt converts a hash value to an integer. There is some disagreement\n+// about how this is done. [NSA] suggests that this is done in the obvious\n+// manner, but [SECG] truncates the hash to the bit-length of the curve order\n+// first. We follow [SECG] because that's what OpenSSL does.\n+func hashToInt(hash []byte, c *elliptic.Curve) *big.Int {\n+\torderBits := c.N.BitLen()\n+\torderBytes := (orderBits + 7) / 8\n+\tif len(hash) > orderBytes {\n+\t\thash = hash[:orderBytes]\n+\t}\n+\n+\tret := new(big.Int).SetBytes(hash)\n+\texcess := orderBytes*8 - orderBits\n+\tif excess > 0 {\n+\t\tret.Rsh(ret, uint(excess))\n+\t}\n+\treturn ret\n+}\n+\n+// Sign signs an arbitrary length hash (which should be the result of hashing a\n+// larger message) using the private key, priv. It returns the signature as a\n+// pair of integers. The security of the private key depends on the entropy of\n+// rand.\n+func Sign(rand io.Reader, priv *PrivateKey, hash []byte) (r, s *big.Int, err os.Error) {\n+\t// See [NSA] 3.4.1\n+\tc := priv.PublicKey.Curve\n+\n+\tvar k, kInv *big.Int\n+\tfor {\n+\t\tfor {\n+\t\t\tk, err = randFieldElement(c, rand)\n+\t\t\tif err != nil {\n+\t\t\t\tr = nil\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tkInv = new(big.Int).ModInverse(k, c.N)\n+\t\t\tr, _ = priv.Curve.ScalarBaseMult(k.Bytes())\n+\t\t\tr.Mod(r, priv.Curve.N)\n+\t\t\tif r.Sign() != 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\n+\t\te := hashToInt(hash, c)\n+\t\ts = new(big.Int).Mul(priv.D, r)\n+\t\ts.Add(s, e)\n+\t\ts.Mul(s, kInv)\n+\t\ts.Mod(s, priv.PublicKey.Curve.N)\n+\t\tif s.Sign() != 0 {\n+\t\t\tbreak\n+\t\t}\n+\t}\n+\n+\treturn\n+}\n+\n+// Verify verifies the signature in r, s of hash using the public key, pub. It\n+// returns true iff the signature is valid.\n+func Verify(pub *PublicKey, hash []byte, r, s *big.Int) bool {\n+\t// See [NSA] 3.4.2\n+\tc := pub.Curve\n+\n+\tif r.Sign() == 0 || s.Sign() == 0 {\n+\t\treturn false\n+\t}\n+\tif r.Cmp(c.N) >= 0 || s.Cmp(c.N) >= 0 {\n+\t\treturn false\n+\t}\n+\te := hashToInt(hash, c)\n+\tw := new(big.Int).ModInverse(s, c.N)\n+\n+\tu1 := e.Mul(e, w)\n+\tu2 := w.Mul(r, w)\n+\n+\tx1, y1 := c.ScalarBaseMult(u1.Bytes())\n+\tx2, y2 := c.ScalarMult(pub.X, pub.Y, u2.Bytes())\n+\tif x1.Cmp(x2) == 0 {\n+\t\treturn false\n+\t}\n+\tx, _ := c.Add(x1, y1, x2, y2)\n+\tx.Mod(x, c.N)\n+\treturn x.Cmp(r) == 0\n+}"}, {"sha": "cc22b7a52f1ae8b34e3a8c8cbd008ee90f60d9ce", "filename": "libgo/go/crypto/ecdsa/ecdsa_test.go", "status": "added", "additions": 218, "deletions": 0, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fecdsa%2Fecdsa_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,218 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ecdsa\n+\n+import (\n+\t\"big\"\n+\t\"crypto/elliptic\"\n+\t\"crypto/sha1\"\n+\t\"crypto/rand\"\n+\t\"encoding/hex\"\n+\t\"testing\"\n+)\n+\n+func testKeyGeneration(t *testing.T, c *elliptic.Curve, tag string) {\n+\tpriv, err := GenerateKey(c, rand.Reader)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error: %s\", tag, err)\n+\t\treturn\n+\t}\n+\tif !c.IsOnCurve(priv.PublicKey.X, priv.PublicKey.Y) {\n+\t\tt.Errorf(\"%s: public key invalid\", tag, err)\n+\t}\n+}\n+\n+func TestKeyGeneration(t *testing.T) {\n+\ttestKeyGeneration(t, elliptic.P224(), \"p224\")\n+\ttestKeyGeneration(t, elliptic.P256(), \"p256\")\n+\ttestKeyGeneration(t, elliptic.P384(), \"p384\")\n+\ttestKeyGeneration(t, elliptic.P521(), \"p521\")\n+}\n+\n+func testSignAndVerify(t *testing.T, c *elliptic.Curve, tag string) {\n+\tpriv, _ := GenerateKey(c, rand.Reader)\n+\n+\thashed := []byte(\"testing\")\n+\tr, s, err := Sign(rand.Reader, priv, hashed)\n+\tif err != nil {\n+\t\tt.Errorf(\"%s: error signing: %s\", tag, err)\n+\t\treturn\n+\t}\n+\n+\tif !Verify(&priv.PublicKey, hashed, r, s) {\n+\t\tt.Errorf(\"%s: Verify failed\", tag)\n+\t}\n+\n+\thashed[0] ^= 0xff\n+\tif Verify(&priv.PublicKey, hashed, r, s) {\n+\t\tt.Errorf(\"%s: Verify always works!\", tag)\n+\t}\n+}\n+\n+func TestSignAndVerify(t *testing.T) {\n+\ttestSignAndVerify(t, elliptic.P224(), \"p224\")\n+\ttestSignAndVerify(t, elliptic.P256(), \"p256\")\n+\ttestSignAndVerify(t, elliptic.P384(), \"p384\")\n+\ttestSignAndVerify(t, elliptic.P521(), \"p521\")\n+}\n+\n+func fromHex(s string) *big.Int {\n+\tr, ok := new(big.Int).SetString(s, 16)\n+\tif !ok {\n+\t\tpanic(\"bad hex\")\n+\t}\n+\treturn r\n+}\n+\n+// These test vectors were taken from\n+//   http://csrc.nist.gov/groups/STM/cavp/documents/dss/ecdsatestvectors.zip\n+var testVectors = []struct {\n+\tmsg    string\n+\tQx, Qy string\n+\tr, s   string\n+\tok     bool\n+}{\n+\t{\n+\t\t\"09626b45493672e48f3d1226a3aff3201960e577d33a7f72c7eb055302db8fe8ed61685dd036b554942a5737cd1512cdf811ee0c00e6dd2f08c69f08643be396e85dafda664801e772cdb7396868ac47b172245b41986aa2648cb77fbbfa562581be06651355a0c4b090f9d17d8f0ab6cced4e0c9d386cf465a516630f0231bd\",\n+\t\t\"9504b5b82d97a264d8b3735e0568decabc4b6ca275bc53cbadfc1c40\",\n+\t\t\"03426f80e477603b10dee670939623e3da91a94267fc4e51726009ed\",\n+\t\t\"81d3ac609f9575d742028dd496450a58a60eea2dcf8b9842994916e1\",\n+\t\t\"96a8c5f382c992e8f30ccce9af120b067ec1d74678fa8445232f75a5\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"96b2b6536f6df29be8567a72528aceeaccbaa66c66c534f3868ca9778b02faadb182e4ed34662e73b9d52ecbe9dc8e875fc05033c493108b380689ebf47e5b062e6a0cdb3dd34ce5fe347d92768d72f7b9b377c20aea927043b509c078ed2467d7113405d2ddd458811e6faf41c403a2a239240180f1430a6f4330df5d77de37\",\n+\t\t\"851e3100368a22478a0029353045ae40d1d8202ef4d6533cfdddafd8\",\n+\t\t\"205302ac69457dd345e86465afa72ee8c74ca97e2b0b999aec1f10c2\",\n+\t\t\"4450c2d38b697e990721aa2dbb56578d32b4f5aeb3b9072baa955ee0\",\n+\t\t\"e26d4b589166f7b4ba4b1c8fce823fa47aad22f8c9c396b8c6526e12\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"86778dbb4a068a01047a8d245d632f636c11d2ad350740b36fad90428b454ad0f120cb558d12ea5c8a23db595d87543d06d1ef489263d01ee529871eb68737efdb8ff85bc7787b61514bed85b7e01d6be209e0a4eb0db5c8df58a5c5bf706d76cb2bdf7800208639e05b89517155d11688236e6a47ed37d8e5a2b1e0adea338e\",\n+\t\t\"ad5bda09d319a717c1721acd6688d17020b31b47eef1edea57ceeffc\",\n+\t\t\"c8ce98e181770a7c9418c73c63d01494b8b80a41098c5ea50692c984\",\n+\t\t\"de5558c257ab4134e52c19d8db3b224a1899cbd08cc508ce8721d5e9\",\n+\t\t\"745db7af5a477e5046705c0a5eff1f52cb94a79d481f0c5a5e108ecd\",\n+\t\ttrue,\n+\t},\n+\t{\n+\t\t\"4bc6ef1958556686dab1e39c3700054a304cbd8f5928603dcd97fafd1f29e69394679b638f71c9344ce6a535d104803d22119f57b5f9477e253817a52afa9bfbc9811d6cc8c8be6b6566c6ef48b439bbb532abe30627548c598867f3861ba0b154dc1c3deca06eb28df8efd28258554b5179883a36fbb1eecf4f93ee19d41e3d\",\n+\t\t\"cc5eea2edf964018bdc0504a3793e4d2145142caa09a72ac5fb8d3e8\",\n+\t\t\"a48d78ae5d08aa725342773975a00d4219cf7a8029bb8cf3c17c374a\",\n+\t\t\"67b861344b4e416d4094472faf4272f6d54a497177fbc5f9ef292836\",\n+\t\t\"1d54f3fcdad795bf3b23408ecbac3e1321d1d66f2e4e3d05f41f7020\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"bb658732acbf3147729959eb7318a2058308b2739ec58907dd5b11cfa3ecf69a1752b7b7d806fe00ec402d18f96039f0b78dbb90a59c4414fb33f1f4e02e4089de4122cd93df5263a95be4d7084e2126493892816e6a5b4ed123cb705bf930c8f67af0fb4514d5769232a9b008a803af225160ce63f675bd4872c4c97b146e5e\",\n+\t\t\"6234c936e27bf141fc7534bfc0a7eedc657f91308203f1dcbd642855\",\n+\t\t\"27983d87ca785ef4892c3591ef4a944b1deb125dd58bd351034a6f84\",\n+\t\t\"e94e05b42d01d0b965ffdd6c3a97a36a771e8ea71003de76c4ecb13f\",\n+\t\t\"1dc6464ffeefbd7872a081a5926e9fc3e66d123f1784340ba17737e9\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"7c00be9123bfa2c4290be1d8bc2942c7f897d9a5b7917e3aabd97ef1aab890f148400a89abd554d19bec9d8ed911ce57b22fbcf6d30ca2115f13ce0a3f569a23bad39ee645f624c49c60dcfc11e7d2be24de9c905596d8f23624d63dc46591d1f740e46f982bfae453f107e80db23545782be23ce43708245896fc54e1ee5c43\",\n+\t\t\"9f3f037282aaf14d4772edffff331bbdda845c3f65780498cde334f1\",\n+\t\t\"8308ee5a16e3bcb721b6bc30000a0419bc1aaedd761be7f658334066\",\n+\t\t\"6381d7804a8808e3c17901e4d283b89449096a8fba993388fa11dc54\",\n+\t\t\"8e858f6b5b253686a86b757bad23658cda53115ac565abca4e3d9f57\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"cffc122a44840dc705bb37130069921be313d8bde0b66201aebc48add028ca131914ef2e705d6bedd19dc6cf9459bbb0f27cdfe3c50483808ffcdaffbeaa5f062e097180f07a40ef4ab6ed03fe07ed6bcfb8afeb42c97eafa2e8a8df469de07317c5e1494c41547478eff4d8c7d9f0f484ad90fedf6e1c35ee68fa73f1691601\",\n+\t\t\"a03b88a10d930002c7b17ca6af2fd3e88fa000edf787dc594f8d4fd4\",\n+\t\t\"e0cf7acd6ddc758e64847fe4df9915ebda2f67cdd5ec979aa57421f5\",\n+\t\t\"387b84dcf37dc343c7d2c5beb82f0bf8bd894b395a7b894565d296c1\",\n+\t\t\"4adc12ce7d20a89ce3925e10491c731b15ddb3f339610857a21b53b4\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"26e0e0cafd85b43d16255908ccfd1f061c680df75aba3081246b337495783052ba06c60f4a486c1591a4048bae11b4d7fec4f161d80bdc9a7b79d23e44433ed625eab280521a37f23dd3e1bdc5c6a6cfaa026f3c45cf703e76dab57add93fe844dd4cda67dc3bddd01f9152579e49df60969b10f09ce9372fdd806b0c7301866\",\n+\t\t\"9a8983c42f2b5a87c37a00458b5970320d247f0c8a88536440173f7d\",\n+\t\t\"15e489ec6355351361900299088cfe8359f04fe0cab78dde952be80c\",\n+\t\t\"929a21baa173d438ec9f28d6a585a2f9abcfc0a4300898668e476dc0\",\n+\t\t\"59a853f046da8318de77ff43f26fe95a92ee296fa3f7e56ce086c872\",\n+\t\ttrue,\n+\t},\n+\t{\n+\t\t\"1078eac124f48ae4f807e946971d0de3db3748dd349b14cca5c942560fb25401b2252744f18ad5e455d2d97ed5ae745f55ff509c6c8e64606afe17809affa855c4c4cdcaf6b69ab4846aa5624ed0687541aee6f2224d929685736c6a23906d974d3c257abce1a3fb8db5951b89ecb0cda92b5207d93f6618fd0f893c32cf6a6e\",\n+\t\t\"d6e55820bb62c2be97650302d59d667a411956138306bd566e5c3c2b\",\n+\t\t\"631ab0d64eaf28a71b9cbd27a7a88682a2167cee6251c44e3810894f\",\n+\t\t\"65af72bc7721eb71c2298a0eb4eed3cec96a737cc49125706308b129\",\n+\t\t\"bd5a987c78e2d51598dbd9c34a9035b0069c580edefdacee17ad892a\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"919deb1fdd831c23481dfdb2475dcbe325b04c34f82561ced3d2df0b3d749b36e255c4928973769d46de8b95f162b53cd666cad9ae145e7fcfba97919f703d864efc11eac5f260a5d920d780c52899e5d76f8fe66936ff82130761231f536e6a3d59792f784902c469aa897aabf9a0678f93446610d56d5e0981e4c8a563556b\",\n+\t\t\"269b455b1024eb92d860a420f143ac1286b8cce43031562ae7664574\",\n+\t\t\"baeb6ca274a77c44a0247e5eb12ca72bdd9a698b3f3ae69c9f1aaa57\",\n+\t\t\"cb4ec2160f04613eb0dfe4608486091a25eb12aa4dec1afe91cfb008\",\n+\t\t\"40b01d8cd06589481574f958b98ca08ade9d2a8fe31024375c01bb40\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"6e012361250dacf6166d2dd1aa7be544c3206a9d43464b3fcd90f3f8cf48d08ec099b59ba6fe7d9bdcfaf244120aed1695d8be32d1b1cd6f143982ab945d635fb48a7c76831c0460851a3d62b7209c30cd9c2abdbe3d2a5282a9fcde1a6f418dd23c409bc351896b9b34d7d3a1a63bbaf3d677e612d4a80fa14829386a64b33f\",\n+\t\t\"6d2d695efc6b43b13c14111f2109608f1020e3e03b5e21cfdbc82fcd\",\n+\t\t\"26a4859296b7e360b69cf40be7bd97ceaffa3d07743c8489fc47ca1b\",\n+\t\t\"9a8cb5f2fdc288b7183c5b32d8e546fc2ed1ca4285eeae00c8b572ad\",\n+\t\t\"8c623f357b5d0057b10cdb1a1593dab57cda7bdec9cf868157a79b97\",\n+\t\ttrue,\n+\t},\n+\t{\n+\t\t\"bf6bd7356a52b234fe24d25557200971fc803836f6fec3cade9642b13a8e7af10ab48b749de76aada9d8927f9b12f75a2c383ca7358e2566c4bb4f156fce1fd4e87ef8c8d2b6b1bdd351460feb22cdca0437ac10ca5e0abbbce9834483af20e4835386f8b1c96daaa41554ceee56730aac04f23a5c765812efa746051f396566\",\n+\t\t\"14250131b2599939cf2d6bc491be80ddfe7ad9de644387ee67de2d40\",\n+\t\t\"b5dc473b5d014cd504022043c475d3f93c319a8bdcb7262d9e741803\",\n+\t\t\"4f21642f2201278a95339a80f75cc91f8321fcb3c9462562f6cbf145\",\n+\t\t\"452a5f816ea1f75dee4fd514fa91a0d6a43622981966c59a1b371ff8\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"0eb7f4032f90f0bd3cf9473d6d9525d264d14c031a10acd31a053443ed5fe919d5ac35e0be77813071b4062f0b5fdf58ad5f637b76b0b305aec18f82441b6e607b44cdf6e0e3c7c57f24e6fd565e39430af4a6b1d979821ed0175fa03e3125506847654d7e1ae904ce1190ae38dc5919e257bdac2db142a6e7cd4da6c2e83770\",\n+\t\t\"d1f342b7790a1667370a1840255ac5bbbdc66f0bc00ae977d99260ac\",\n+\t\t\"76416cabae2de9a1000b4646338b774baabfa3db4673790771220cdb\",\n+\t\t\"bc85e3fc143d19a7271b2f9e1c04b86146073f3fab4dda1c3b1f35ca\",\n+\t\t\"9a5c70ede3c48d5f43307a0c2a4871934424a3303b815df4bb0f128e\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"5cc25348a05d85e56d4b03cec450128727bc537c66ec3a9fb613c151033b5e86878632249cba83adcefc6c1e35dcd31702929c3b57871cda5c18d1cf8f9650a25b917efaed56032e43b6fc398509f0d2997306d8f26675f3a8683b79ce17128e006aa0903b39eeb2f1001be65de0520115e6f919de902b32c38d691a69c58c92\",\n+\t\t\"7e49a7abf16a792e4c7bbc4d251820a2abd22d9f2fc252a7bf59c9a6\",\n+\t\t\"44236a8fb4791c228c26637c28ae59503a2f450d4cfb0dc42aa843b9\",\n+\t\t\"084461b4050285a1a85b2113be76a17878d849e6bc489f4d84f15cd8\",\n+\t\t\"079b5bddcc4d45de8dbdfd39f69817c7e5afa454a894d03ee1eaaac3\",\n+\t\tfalse,\n+\t},\n+\t{\n+\t\t\"1951533ce33afb58935e39e363d8497a8dd0442018fd96dff167b3b23d7206a3ee182a3194765df4768a3284e23b8696c199b4686e670d60c9d782f08794a4bccc05cffffbd1a12acd9eb1cfa01f7ebe124da66ecff4599ea7720c3be4bb7285daa1a86ebf53b042bd23208d468c1b3aa87381f8e1ad63e2b4c2ba5efcf05845\",\n+\t\t\"31945d12ebaf4d81f02be2b1768ed80784bf35cf5e2ff53438c11493\",\n+\t\t\"a62bebffac987e3b9d3ec451eb64c462cdf7b4aa0b1bbb131ceaa0a4\",\n+\t\t\"bc3c32b19e42b710bca5c6aaa128564da3ddb2726b25f33603d2af3c\",\n+\t\t\"ed1a719cc0c507edc5239d76fe50e2306c145ad252bd481da04180c0\",\n+\t\tfalse,\n+\t},\n+}\n+\n+func TestVectors(t *testing.T) {\n+\tsha := sha1.New()\n+\n+\tfor i, test := range testVectors {\n+\t\tpub := PublicKey{\n+\t\t\tCurve: elliptic.P224(),\n+\t\t\tX:     fromHex(test.Qx),\n+\t\t\tY:     fromHex(test.Qy),\n+\t\t}\n+\t\tmsg, _ := hex.DecodeString(test.msg)\n+\t\tsha.Reset()\n+\t\tsha.Write(msg)\n+\t\thashed := sha.Sum()\n+\t\tr := fromHex(test.r)\n+\t\ts := fromHex(test.s)\n+\t\tif Verify(&pub, hashed, r, s) != test.ok {\n+\t\t\tt.Errorf(\"%d: bad result\", i)\n+\t\t}\n+\t}\n+}"}, {"sha": "2296e9607776affef2b91d98583d24f9a72c83f1", "filename": "libgo/go/crypto/elliptic/elliptic.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Felliptic%2Felliptic.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -24,6 +24,7 @@ import (\n // See http://www.hyperelliptic.org/EFD/g1p/auto-shortw.html\n type Curve struct {\n \tP       *big.Int // the order of the underlying field\n+\tN       *big.Int // the order of the base point\n \tB       *big.Int // the constant of the curve equation\n \tGx, Gy  *big.Int // (x,y) of the base point\n \tBitSize int      // the size of the underlying field\n@@ -315,6 +316,7 @@ func initP224() {\n \t// See FIPS 186-3, section D.2.2\n \tp224 = new(Curve)\n \tp224.P, _ = new(big.Int).SetString(\"26959946667150639794667015087019630673557916260026308143510066298881\", 10)\n+\tp224.N, _ = new(big.Int).SetString(\"26959946667150639794667015087019625940457807714424391721682722368061\", 10)\n \tp224.B, _ = new(big.Int).SetString(\"b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4\", 16)\n \tp224.Gx, _ = new(big.Int).SetString(\"b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21\", 16)\n \tp224.Gy, _ = new(big.Int).SetString(\"bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34\", 16)\n@@ -325,6 +327,7 @@ func initP256() {\n \t// See FIPS 186-3, section D.2.3\n \tp256 = new(Curve)\n \tp256.P, _ = new(big.Int).SetString(\"115792089210356248762697446949407573530086143415290314195533631308867097853951\", 10)\n+\tp256.N, _ = new(big.Int).SetString(\"115792089210356248762697446949407573529996955224135760342422259061068512044369\", 10)\n \tp256.B, _ = new(big.Int).SetString(\"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b\", 16)\n \tp256.Gx, _ = new(big.Int).SetString(\"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296\", 16)\n \tp256.Gy, _ = new(big.Int).SetString(\"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5\", 16)\n@@ -335,6 +338,7 @@ func initP384() {\n \t// See FIPS 186-3, section D.2.4\n \tp384 = new(Curve)\n \tp384.P, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319\", 10)\n+\tp384.N, _ = new(big.Int).SetString(\"39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643\", 10)\n \tp384.B, _ = new(big.Int).SetString(\"b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef\", 16)\n \tp384.Gx, _ = new(big.Int).SetString(\"aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7\", 16)\n \tp384.Gy, _ = new(big.Int).SetString(\"3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\", 16)\n@@ -345,6 +349,7 @@ func initP521() {\n \t// See FIPS 186-3, section D.2.5\n \tp521 = new(Curve)\n \tp521.P, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151\", 10)\n+\tp521.N, _ = new(big.Int).SetString(\"6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449\", 10)\n \tp521.B, _ = new(big.Int).SetString(\"051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00\", 16)\n \tp521.Gx, _ = new(big.Int).SetString(\"c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66\", 16)\n \tp521.Gy, _ = new(big.Int).SetString(\"11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\", 16)"}, {"sha": "57ff3afbfc702609c48950f55a51d1b20b7b9861", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,6 +7,7 @@\n package packet\n \n import (\n+\t\"big\"\n \t\"crypto/aes\"\n \t\"crypto/cast5\"\n \t\"crypto/cipher\"\n@@ -166,10 +167,10 @@ func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader,\n \treturn\n }\n \n-// serialiseHeader writes an OpenPGP packet header to w. See RFC 4880, section\n+// serializeHeader writes an OpenPGP packet header to w. See RFC 4880, section\n // 4.2.\n-func serialiseHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n-\tvar buf [5]byte\n+func serializeHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n+\tvar buf [6]byte\n \tvar n int\n \n \tbuf[0] = 0x80 | 0x40 | byte(ptype)\n@@ -178,16 +179,16 @@ func serialiseHeader(w io.Writer, ptype packetType, length int) (err os.Error) {\n \t\tn = 2\n \t} else if length < 8384 {\n \t\tlength -= 192\n-\t\tbuf[1] = byte(length >> 8)\n+\t\tbuf[1] = 192 + byte(length>>8)\n \t\tbuf[2] = byte(length)\n \t\tn = 3\n \t} else {\n-\t\tbuf[0] = 255\n-\t\tbuf[1] = byte(length >> 24)\n-\t\tbuf[2] = byte(length >> 16)\n-\t\tbuf[3] = byte(length >> 8)\n-\t\tbuf[4] = byte(length)\n-\t\tn = 5\n+\t\tbuf[1] = 255\n+\t\tbuf[2] = byte(length >> 24)\n+\t\tbuf[3] = byte(length >> 16)\n+\t\tbuf[4] = byte(length >> 8)\n+\t\tbuf[5] = byte(length)\n+\t\tn = 6\n \t}\n \n \t_, err = w.Write(buf[:n])\n@@ -371,7 +372,7 @@ func (cipher CipherFunction) new(key []byte) (block cipher.Block) {\n \n // readMPI reads a big integer from r. The bit length returned is the bit\n // length that was specified in r. This is preserved so that the integer can be\n-// reserialised exactly.\n+// reserialized exactly.\n func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err os.Error) {\n \tvar buf [2]byte\n \t_, err = readFull(r, buf[0:])\n@@ -385,11 +386,16 @@ func readMPI(r io.Reader) (mpi []byte, bitLength uint16, err os.Error) {\n \treturn\n }\n \n-// writeMPI serialises a big integer to r.\n+// writeMPI serializes a big integer to w.\n func writeMPI(w io.Writer, bitLength uint16, mpiBytes []byte) (err os.Error) {\n \t_, err = w.Write([]byte{byte(bitLength >> 8), byte(bitLength)})\n \tif err == nil {\n \t\t_, err = w.Write(mpiBytes)\n \t}\n \treturn\n }\n+\n+// writeBig serializes a *big.Int to w.\n+func writeBig(w io.Writer, i *big.Int) os.Error {\n+\treturn writeMPI(w, uint16(i.BitLen()), i.Bytes())\n+}"}, {"sha": "1a4692cd4f5d1b02607fe15d3c5f38480731f499", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -190,3 +190,23 @@ func TestReadHeader(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestSerializeHeader(t *testing.T) {\n+\ttag := packetTypePublicKey\n+\tlengths := []int{0, 1, 2, 64, 192, 193, 8000, 8384, 8385, 10000}\n+\n+\tfor _, length := range lengths {\n+\t\tbuf := bytes.NewBuffer(nil)\n+\t\tserializeHeader(buf, tag, length)\n+\t\ttag2, length2, _, err := readHeader(buf)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"length %d, err: %s\", length, err)\n+\t\t}\n+\t\tif tag2 != tag {\n+\t\t\tt.Errorf(\"length %d, tag incorrect (got %d, want %d)\", length, tag2, tag)\n+\t\t}\n+\t\tif int(length2) != length {\n+\t\t\tt.Errorf(\"length %d, length incorrect (got %d)\", length, length2)\n+\t\t}\n+\t}\n+}"}, {"sha": "694482390294e25e575dabc4f09a5ee5c6968edd", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"big\"\n \t\"bytes\"\n \t\"crypto/cipher\"\n+\t\"crypto/dsa\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rsa\"\n@@ -134,7 +135,16 @@ func (pk *PrivateKey) Decrypt(passphrase []byte) os.Error {\n }\n \n func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n-\t// TODO(agl): support DSA and ECDSA private keys.\n+\tswitch pk.PublicKey.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoRSAEncryptOnly:\n+\t\treturn pk.parseRSAPrivateKey(data)\n+\tcase PubKeyAlgoDSA:\n+\t\treturn pk.parseDSAPrivateKey(data)\n+\t}\n+\tpanic(\"impossible\")\n+}\n+\n+func (pk *PrivateKey) parseRSAPrivateKey(data []byte) (err os.Error) {\n \trsaPub := pk.PublicKey.PublicKey.(*rsa.PublicKey)\n \trsaPriv := new(rsa.PrivateKey)\n \trsaPriv.PublicKey = *rsaPub\n@@ -162,3 +172,22 @@ func (pk *PrivateKey) parsePrivateKey(data []byte) (err os.Error) {\n \n \treturn nil\n }\n+\n+func (pk *PrivateKey) parseDSAPrivateKey(data []byte) (err os.Error) {\n+\tdsaPub := pk.PublicKey.PublicKey.(*dsa.PublicKey)\n+\tdsaPriv := new(dsa.PrivateKey)\n+\tdsaPriv.PublicKey = *dsaPub\n+\n+\tbuf := bytes.NewBuffer(data)\n+\tx, _, err := readMPI(buf)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\n+\tdsaPriv.X = new(big.Int).SetBytes(x)\n+\tpk.PrivateKey = dsaPriv\n+\tpk.Encrypted = false\n+\tpk.encryptedData = nil\n+\n+\treturn nil\n+}"}, {"sha": "ebef481fb7f19c6c398b2ba8806b845e10e3e01a", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 35, "deletions": 11, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"encoding/binary\"\n+\t\"fmt\"\n \t\"hash\"\n \t\"io\"\n \t\"os\"\n@@ -178,24 +179,35 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err os.E\n \t\treturn error.InvalidArgumentError(\"public key cannot generate signatures\")\n \t}\n \n-\trsaPublicKey, ok := pk.PublicKey.(*rsa.PublicKey)\n-\tif !ok {\n-\t\t// TODO(agl): support DSA and ECDSA keys.\n-\t\treturn error.UnsupportedError(\"non-RSA public key\")\n-\t}\n-\n \tsigned.Write(sig.HashSuffix)\n \thashBytes := signed.Sum()\n \n \tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n \t\treturn error.SignatureError(\"hash tag doesn't match\")\n \t}\n \n-\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.Signature)\n-\tif err != nil {\n-\t\treturn error.SignatureError(\"RSA verification failure\")\n+\tif pk.PubKeyAlgo != sig.PubKeyAlgo {\n+\t\treturn error.InvalidArgumentError(\"public key and signature use different algorithms\")\n \t}\n-\treturn nil\n+\n+\tswitch pk.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\t\trsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)\n+\t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature)\n+\t\tif err != nil {\n+\t\t\treturn error.SignatureError(\"RSA verification failure\")\n+\t\t}\n+\t\treturn nil\n+\tcase PubKeyAlgoDSA:\n+\t\tdsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)\n+\t\tif !dsa.Verify(dsaPublicKey, hashBytes, sig.DSASigR, sig.DSASigS) {\n+\t\t\treturn error.SignatureError(\"DSA verification failure\")\n+\t\t}\n+\t\treturn nil\n+\tdefault:\n+\t\tpanic(\"shouldn't happen\")\n+\t}\n+\tpanic(\"unreachable\")\n }\n \n // VerifyKeySignature returns nil iff sig is a valid signature, make by this\n@@ -239,9 +251,21 @@ func (pk *PublicKey) VerifyUserIdSignature(id string, sig *Signature) (err os.Er\n \treturn pk.VerifySignature(h, sig)\n }\n \n+// KeyIdString returns the public key's fingerprint in capital hex\n+// (e.g. \"6C7EE1B8621CC013\").\n+func (pk *PublicKey) KeyIdString() string {\n+\treturn fmt.Sprintf(\"%X\", pk.Fingerprint[12:20])\n+}\n+\n+// KeyIdShortString returns the short form of public key's fingerprint\n+// in capital hex, as shown by gpg --list-keys (e.g. \"621CC013\").\n+func (pk *PublicKey) KeyIdShortString() string {\n+\treturn fmt.Sprintf(\"%X\", pk.Fingerprint[16:20])\n+}\n+\n // A parsedMPI is used to store the contents of a big integer, along with the\n // bit length that was specified in the original input. This allows the MPI to\n-// be reserialised exactly.\n+// be reserialized exactly.\n type parsedMPI struct {\n \tbytes     []byte\n \tbitLength uint16"}, {"sha": "069388c14dccc1fc705e2b476faa9d29c3b2939b", "filename": "libgo/go/crypto/openpgp/packet/public_key_test.go", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -16,9 +16,11 @@ var pubKeyTests = []struct {\n \tcreationTime   uint32\n \tpubKeyAlgo     PublicKeyAlgorithm\n \tkeyId          uint64\n+\tkeyIdString    string\n+\tkeyIdShort     string\n }{\n-\t{rsaPkDataHex, rsaFingerprintHex, 0x4d3c5c10, PubKeyAlgoRSA, 0xa34d7e18c20c31bb},\n-\t{dsaPkDataHex, dsaFingerprintHex, 0x4d432f89, PubKeyAlgoDSA, 0x8e8fbe54062f19ed},\n+\t{rsaPkDataHex, rsaFingerprintHex, 0x4d3c5c10, PubKeyAlgoRSA, 0xa34d7e18c20c31bb, \"A34D7E18C20C31BB\", \"C20C31BB\"},\n+\t{dsaPkDataHex, dsaFingerprintHex, 0x4d432f89, PubKeyAlgoDSA, 0x8e8fbe54062f19ed, \"8E8FBE54062F19ED\", \"062F19ED\"},\n }\n \n func TestPublicKeyRead(t *testing.T) {\n@@ -46,6 +48,12 @@ func TestPublicKeyRead(t *testing.T) {\n \t\tif pk.KeyId != test.keyId {\n \t\t\tt.Errorf(\"#%d: bad keyid got:%x want:%x\", i, pk.KeyId, test.keyId)\n \t\t}\n+\t\tif g, e := pk.KeyIdString(), test.keyIdString; g != e {\n+\t\t\tt.Errorf(\"#%d: bad KeyIdString got:%q want:%q\", i, g, e)\n+\t\t}\n+\t\tif g, e := pk.KeyIdShortString(), test.keyIdShort; g != e {\n+\t\t\tt.Errorf(\"#%d: bad KeyIdShortString got:%q want:%q\", i, g, e)\n+\t\t}\n \t}\n }\n "}, {"sha": "719657e76ee09e57b633796badf5144b28c060d2", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "modified", "additions": 85, "deletions": 23, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -5,7 +5,9 @@\n package packet\n \n import (\n+\t\"big\"\n \t\"crypto\"\n+\t\"crypto/dsa\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rand\"\n@@ -29,7 +31,9 @@ type Signature struct {\n \t// of bad signed data.\n \tHashTag      [2]byte\n \tCreationTime uint32 // Unix epoch time\n-\tSignature    []byte\n+\n+\tRSASignature     []byte\n+\tDSASigR, DSASigS *big.Int\n \n \t// The following are optional so are nil when not included in the\n \t// signature.\n@@ -66,7 +70,7 @@ func (sig *Signature) parse(r io.Reader) (err os.Error) {\n \tsig.SigType = SignatureType(buf[0])\n \tsig.PubKeyAlgo = PublicKeyAlgorithm(buf[1])\n \tswitch sig.PubKeyAlgo {\n-\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n \tdefault:\n \t\terr = error.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t\treturn\n@@ -122,8 +126,20 @@ func (sig *Signature) parse(r io.Reader) (err os.Error) {\n \t\treturn\n \t}\n \n-\t// We have already checked that the public key algorithm is RSA.\n-\tsig.Signature, _, err = readMPI(r)\n+\tswitch sig.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\t\tsig.RSASignature, _, err = readMPI(r)\n+\tcase PubKeyAlgoDSA:\n+\t\tvar rBytes, sBytes []byte\n+\t\trBytes, _, err = readMPI(r)\n+\t\tsig.DSASigR = new(big.Int).SetBytes(rBytes)\n+\t\tif err == nil {\n+\t\t\tsBytes, _, err = readMPI(r)\n+\t\t\tsig.DSASigS = new(big.Int).SetBytes(sBytes)\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"unreachable\")\n+\t}\n \treturn\n }\n \n@@ -316,8 +332,8 @@ func subpacketLengthLength(length int) int {\n \treturn 5\n }\n \n-// serialiseSubpacketLength marshals the given length into to.\n-func serialiseSubpacketLength(to []byte, length int) int {\n+// serializeSubpacketLength marshals the given length into to.\n+func serializeSubpacketLength(to []byte, length int) int {\n \tif length < 192 {\n \t\tto[0] = byte(length)\n \t\treturn 1\n@@ -336,7 +352,7 @@ func serialiseSubpacketLength(to []byte, length int) int {\n \treturn 5\n }\n \n-// subpacketsLength returns the serialised length, in bytes, of the given\n+// subpacketsLength returns the serialized length, in bytes, of the given\n // subpackets.\n func subpacketsLength(subpackets []outputSubpacket, hashed bool) (length int) {\n \tfor _, subpacket := range subpackets {\n@@ -349,11 +365,11 @@ func subpacketsLength(subpackets []outputSubpacket, hashed bool) (length int) {\n \treturn\n }\n \n-// serialiseSubpackets marshals the given subpackets into to.\n-func serialiseSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n+// serializeSubpackets marshals the given subpackets into to.\n+func serializeSubpackets(to []byte, subpackets []outputSubpacket, hashed bool) {\n \tfor _, subpacket := range subpackets {\n \t\tif subpacket.hashed == hashed {\n-\t\t\tn := serialiseSubpacketLength(to, len(subpacket.contents)+1)\n+\t\t\tn := serializeSubpacketLength(to, len(subpacket.contents)+1)\n \t\t\tto[n] = byte(subpacket.subpacketType)\n \t\t\tto = to[1+n:]\n \t\t\tn = copy(to, subpacket.contents)\n@@ -381,7 +397,7 @@ func (sig *Signature) buildHashSuffix() (err os.Error) {\n \t}\n \tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n \tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n-\tserialiseSubpackets(sig.HashSuffix[6:l], sig.outSubpackets, true)\n+\tserializeSubpackets(sig.HashSuffix[6:l], sig.outSubpackets, true)\n \ttrailer := sig.HashSuffix[l:]\n \ttrailer[0] = 4\n \ttrailer[1] = 0xff\n@@ -392,32 +408,66 @@ func (sig *Signature) buildHashSuffix() (err os.Error) {\n \treturn\n }\n \n-// SignRSA signs a message with an RSA private key. The hash, h, must contain\n-// the hash of message to be signed and will be mutated by this function.\n-func (sig *Signature) SignRSA(h hash.Hash, priv *rsa.PrivateKey) (err os.Error) {\n+func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err os.Error) {\n \terr = sig.buildHashSuffix()\n \tif err != nil {\n \t\treturn\n \t}\n \n \th.Write(sig.HashSuffix)\n-\tdigest := h.Sum()\n+\tdigest = h.Sum()\n \tcopy(sig.HashTag[:], digest)\n-\tsig.Signature, err = rsa.SignPKCS1v15(rand.Reader, priv, sig.Hash, digest)\n \treturn\n }\n \n-// Serialize marshals sig to w. SignRSA must have been called first.\n+// SignRSA signs a message with an RSA private key. The hash, h, must contain\n+// the hash of the message to be signed and will be mutated by this function.\n+// On success, the signature is stored in sig. Call Serialize to write it out.\n+func (sig *Signature) SignRSA(h hash.Hash, priv *rsa.PrivateKey) (err os.Error) {\n+\tdigest, err := sig.signPrepareHash(h)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tsig.RSASignature, err = rsa.SignPKCS1v15(rand.Reader, priv, sig.Hash, digest)\n+\treturn\n+}\n+\n+// SignDSA signs a message with a DSA private key. The hash, h, must contain\n+// the hash of the message to be signed and will be mutated by this function.\n+// On success, the signature is stored in sig. Call Serialize to write it out.\n+func (sig *Signature) SignDSA(h hash.Hash, priv *dsa.PrivateKey) (err os.Error) {\n+\tdigest, err := sig.signPrepareHash(h)\n+\tif err != nil {\n+\t\treturn\n+\t}\n+\tsig.DSASigR, sig.DSASigS, err = dsa.Sign(rand.Reader, priv, digest)\n+\treturn\n+}\n+\n+// Serialize marshals sig to w. SignRSA or SignDSA must have been called first.\n func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n-\tif sig.Signature == nil {\n-\t\treturn error.InvalidArgumentError(\"Signature: need to call SignRSA before Serialize\")\n+\tif sig.RSASignature == nil && sig.DSASigR == nil {\n+\t\treturn error.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n+\t}\n+\n+\tsigLength := 0\n+\tswitch sig.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\t\tsigLength = len(sig.RSASignature)\n+\tcase PubKeyAlgoDSA:\n+\t\tsigLength = 2 /* MPI length */\n+\t\tsigLength += (sig.DSASigR.BitLen() + 7) / 8\n+\t\tsigLength += 2 /* MPI length */\n+\t\tsigLength += (sig.DSASigS.BitLen() + 7) / 8\n+\tdefault:\n+\t\tpanic(\"impossible\")\n \t}\n \n \tunhashedSubpacketsLen := subpacketsLength(sig.outSubpackets, false)\n \tlength := len(sig.HashSuffix) - 6 /* trailer not included */ +\n \t\t2 /* length of unhashed subpackets */ + unhashedSubpacketsLen +\n-\t\t2 /* hash tag */ + 2 /* length of signature MPI */ + len(sig.Signature)\n-\terr = serialiseHeader(w, packetTypeSignature, length)\n+\t\t2 /* hash tag */ + 2 /* length of signature MPI */ + sigLength\n+\terr = serializeHeader(w, packetTypeSignature, length)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -430,7 +480,7 @@ func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n \tunhashedSubpackets := make([]byte, 2+unhashedSubpacketsLen)\n \tunhashedSubpackets[0] = byte(unhashedSubpacketsLen >> 8)\n \tunhashedSubpackets[1] = byte(unhashedSubpacketsLen)\n-\tserialiseSubpackets(unhashedSubpackets[2:], sig.outSubpackets, false)\n+\tserializeSubpackets(unhashedSubpackets[2:], sig.outSubpackets, false)\n \n \t_, err = w.Write(unhashedSubpackets)\n \tif err != nil {\n@@ -440,7 +490,19 @@ func (sig *Signature) Serialize(w io.Writer) (err os.Error) {\n \tif err != nil {\n \t\treturn\n \t}\n-\treturn writeMPI(w, 8*uint16(len(sig.Signature)), sig.Signature)\n+\n+\tswitch sig.PubKeyAlgo {\n+\tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n+\t\terr = writeMPI(w, 8*uint16(len(sig.RSASignature)), sig.RSASignature)\n+\tcase PubKeyAlgoDSA:\n+\t\terr = writeBig(w, sig.DSASigR)\n+\t\tif err == nil {\n+\t\t\terr = writeBig(w, sig.DSASigS)\n+\t\t}\n+\tdefault:\n+\t\tpanic(\"impossible\")\n+\t}\n+\treturn\n }\n \n // outputSubpacket represents a subpacket to be marshaled."}, {"sha": "6218d9990dd381cefadf82b2416bb348bc3be99a", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -44,6 +44,17 @@ func TestReadPrivateKeyRing(t *testing.T) {\n \t}\n }\n \n+func TestReadDSAKey(t *testing.T) {\n+\tkring, err := ReadKeyRing(readerFromHex(dsaTestKeyHex))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t\treturn\n+\t}\n+\tif len(kring) != 1 || uint32(kring[0].PrimaryKey.KeyId) != 0x0CCC0360 {\n+\t\tt.Errorf(\"bad parse: %#v\", kring)\n+\t}\n+}\n+\n func TestGetKeyById(t *testing.T) {\n \tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n \n@@ -192,7 +203,7 @@ func TestSymmetricallyEncrypted(t *testing.T) {\n \t}\n }\n \n-func testDetachedSignature(t *testing.T, kring KeyRing, signature io.Reader, sigInput, tag string) {\n+func testDetachedSignature(t *testing.T, kring KeyRing, signature io.Reader, sigInput, tag string, expectedSignerKeyId uint64) {\n \tsigned := bytes.NewBufferString(sigInput)\n \tsigner, err := CheckDetachedSignature(kring, signed, signature)\n \tif err != nil {\n@@ -203,18 +214,25 @@ func testDetachedSignature(t *testing.T, kring KeyRing, signature io.Reader, sig\n \t\tt.Errorf(\"%s: signer is nil\", tag)\n \t\treturn\n \t}\n-\texpectedSignerKeyId := uint64(0xa34d7e18c20c31bb)\n \tif signer.PrimaryKey.KeyId != expectedSignerKeyId {\n \t\tt.Errorf(\"%s: wrong signer got:%x want:%x\", tag, signer.PrimaryKey.KeyId, expectedSignerKeyId)\n \t}\n }\n \n func TestDetachedSignature(t *testing.T) {\n \tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n-\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureHex), signedInput, \"binary\")\n-\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureTextHex), signedInput, \"text\")\n+\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureHex), signedInput, \"binary\", testKey1KeyId)\n+\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureTextHex), signedInput, \"text\", testKey1KeyId)\n }\n \n+func TestDetachedSignatureDSA(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(dsaTestKeyHex))\n+\ttestDetachedSignature(t, kring, readerFromHex(detachedSignatureDSAHex), signedInput, \"binary\", testKey3KeyId)\n+}\n+\n+const testKey1KeyId = 0xA34D7E18C20C31BB\n+const testKey3KeyId = 0x338934250CCC0360\n+\n const signedInput = \"Signed message\\nline 2\\nline 3\\n\"\n const signedTextInput = \"Signed message\\r\\nline 2\\r\\nline 3\\r\\n\"\n \n@@ -224,6 +242,8 @@ const detachedSignatureHex = \"889c04000102000605024d449cd1000a0910a34d7e18c20c31\n \n const detachedSignatureTextHex = \"889c04010102000605024d449d21000a0910a34d7e18c20c31bbc8c60400a24fbef7342603a41cb1165767bd18985d015fb72fe05db42db36cfb2f1d455967f1e491194fbf6cf88146222b23bf6ffbd50d17598d976a0417d3192ff9cc0034fd00f287b02e90418bbefe609484b09231e4e7a5f3562e199bf39909ab5276c4d37382fe088f6b5c3426fc1052865da8b3ab158672d58b6264b10823dc4b39\"\n \n+const detachedSignatureDSAHex = \"884604001102000605024d6c4eac000a0910338934250ccc0360f18d00a087d743d6405ed7b87755476629600b8b694a39e900a0abff8126f46faf1547c1743c37b21b4ea15b8f83\"\n+\n const testKeys1And2Hex = \"988d044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd0011010001b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b0020003b88d044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f0011010001889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab0020003988d044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b0020003b88d044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020003\"\n \n const testKeys1And2PrivateHex = \"9501d8044d3c5c10010400b1d13382944bd5aba23a4312968b5095d14f947f600eb478e14a6fcb16b0e0cac764884909c020bc495cfcc39a935387c661507bdb236a0612fb582cac3af9b29cc2c8c70090616c41b662f4da4c1201e195472eb7f4ae1ccbcbf9940fe21d985e379a5563dde5b9a23d35f1cfaa5790da3b79db26f23695107bfaca8e7b5bcd00110100010003ff4d91393b9a8e3430b14d6209df42f98dc927425b881f1209f319220841273a802a97c7bdb8b3a7740b3ab5866c4d1d308ad0d3a79bd1e883aacf1ac92dfe720285d10d08752a7efe3c609b1d00f17f2805b217be53999a7da7e493bfc3e9618fd17018991b8128aea70a05dbce30e4fbe626aa45775fa255dd9177aabf4df7cf0200c1ded12566e4bc2bb590455e5becfb2e2c9796482270a943343a7835de41080582c2be3caf5981aa838140e97afa40ad652a0b544f83eb1833b0957dce26e47b0200eacd6046741e9ce2ec5beb6fb5e6335457844fb09477f83b050a96be7da043e17f3a9523567ed40e7a521f818813a8b8a72209f1442844843ccc7eb9805442570200bdafe0438d97ac36e773c7162028d65844c4d463e2420aa2228c6e50dc2743c3d6c72d0d782a5173fe7be2169c8a9f4ef8a7cf3e37165e8c61b89c346cdc6c1799d2b41054657374204b6579203120285253412988b804130102002205024d3c5c10021b03060b090807030206150802090a0b0416020301021e01021780000a0910a34d7e18c20c31bbb5b304009cc45fe610b641a2c146331be94dade0a396e73ca725e1b25c21708d9cab46ecca5ccebc23055879df8f99eea39b377962a400f2ebdc36a7c99c333d74aeba346315137c3ff9d0a09b0273299090343048afb8107cf94cbd1400e3026f0ccac7ecebbc4d78588eb3e478fe2754d3ca664bcf3eac96ca4a6b0c8d7df5102f60f6b00200009d01d8044d3c5c10010400b201df61d67487301f11879d514f4248ade90c8f68c7af1284c161098de4c28c2850f1ec7b8e30f959793e571542ffc6532189409cb51c3d30dad78c4ad5165eda18b20d9826d8707d0f742e2ab492103a85bbd9ddf4f5720f6de7064feb0d39ee002219765bb07bcfb8b877f47abe270ddeda4f676108cecb6b9bb2ad484a4f00110100010003fd17a7490c22a79c59281fb7b20f5e6553ec0c1637ae382e8adaea295f50241037f8997cf42c1ce26417e015091451b15424b2c59eb8d4161b0975630408e394d3b00f88d4b4e18e2cc85e8251d4753a27c639c83f5ad4a571c4f19d7cd460b9b73c25ade730c99df09637bd173d8e3e981ac64432078263bb6dc30d3e974150dd0200d0ee05be3d4604d2146fb0457f31ba17c057560785aa804e8ca5530a7cd81d3440d0f4ba6851efcfd3954b7e68908fc0ba47f7ac37bf559c6c168b70d3a7c8cd0200da1c677c4bce06a068070f2b3733b0a714e88d62aa3f9a26c6f5216d48d5c2b5624144f3807c0df30be66b3268eeeca4df1fbded58faf49fc95dc3c35f134f8b01fd1396b6c0fc1b6c4f0eb8f5e44b8eace1e6073e20d0b8bc5385f86f1cf3f050f66af789f3ef1fc107b7f4421e19e0349c730c68f0a226981f4e889054fdb4dc149e8e889f04180102000905024d3c5c10021b0c000a0910a34d7e18c20c31bb1a03040085c8d62e16d05dc4e9dad64953c8a2eed8b6c12f92b1575eeaa6dcf7be9473dd5b24b37b6dffbb4e7c99ed1bd3cb11634be19b3e6e207bed7505c7ca111ccf47cb323bf1f8851eb6360e8034cbff8dd149993c959de89f8f77f38e7e98b8e3076323aa719328e2b408db5ec0d03936efd57422ba04f925cdc7b4c1af7590e40ab00200009501fe044d3c5c33010400b488c3e5f83f4d561f317817538d9d0397981e9aef1321ca68ebfae1cf8b7d388e19f4b5a24a82e2fbbf1c6c26557a6c5845307a03d815756f564ac7325b02bc83e87d5480a8fae848f07cb891f2d51ce7df83dcafdc12324517c86d472cc0ee10d47a68fd1d9ae49a6c19bbd36d82af597a0d88cc9c49de9df4e696fc1f0b5d0011010001fe030302e9030f3c783e14856063f16938530e148bc57a7aa3f3e4f90df9dceccdc779bc0835e1ad3d006e4a8d7b36d08b8e0de5a0d947254ecfbd22037e6572b426bcfdc517796b224b0036ff90bc574b5509bede85512f2eefb520fb4b02aa523ba739bff424a6fe81c5041f253f8d757e69a503d3563a104d0d49e9e890b9d0c26f96b55b743883b472caa7050c4acfd4a21f875bdf1258d88bd61224d303dc9df77f743137d51e6d5246b88c406780528fd9a3e15bab5452e5b93970d9dcc79f48b38651b9f15bfbcf6da452837e9cc70683d1bdca94507870f743e4ad902005812488dd342f836e72869afd00ce1850eea4cfa53ce10e3608e13d3c149394ee3cbd0e23d018fcbcb6e2ec5a1a22972d1d462ca05355d0d290dd2751e550d5efb38c6c89686344df64852bf4ff86638708f644e8ec6bd4af9b50d8541cb91891a431326ab2e332faa7ae86cfb6e0540aa63160c1e5cdd5a4add518b303fff0a20117c6bc77f7cfbaf36b04c865c6c2b42754657374204b6579203220285253412c20656e637279707465642070726976617465206b65792988b804130102002205024d3c5c33021b03060b090807030206150802090a0b0416020301021e01021780000a0910d4984f961e35246b98940400908a73b6a6169f700434f076c6c79015a49bee37130eaf23aaa3cfa9ce60bfe4acaa7bc95f1146ada5867e0079babb38804891f4f0b8ebca57a86b249dee786161a755b7a342e68ccf3f78ed6440a93a6626beb9a37aa66afcd4f888790cb4bb46d94a4ae3eb3d7d3e6b00f6bfec940303e89ec5b32a1eaaacce66497d539328b00200009d01fe044d3c5c33010400a4e913f9442abcc7f1804ccab27d2f787ffa592077ca935a8bb23165bd8d57576acac647cc596b2c3f814518cc8c82953c7a4478f32e0cf645630a5ba38d9618ef2bc3add69d459ae3dece5cab778938d988239f8c5ae437807075e06c828019959c644ff05ef6a5a1dab72227c98e3a040b0cf219026640698d7a13d8538a570011010001fe030302e9030f3c783e148560f936097339ae381d63116efcf802ff8b1c9360767db5219cc987375702a4123fd8657d3e22700f23f95020d1b261eda5257e9a72f9a918e8ef22dd5b3323ae03bbc1923dd224db988cadc16acc04b120a9f8b7e84da9716c53e0334d7b66586ddb9014df604b41be1e960dcfcbc96f4ed150a1a0dd070b9eb14276b9b6be413a769a75b519a53d3ecc0c220e85cd91ca354d57e7344517e64b43b6e29823cbd87eae26e2b2e78e6dedfbb76e3e9f77bcb844f9a8932eb3db2c3f9e44316e6f5d60e9e2a56e46b72abe6b06dc9a31cc63f10023d1f5e12d2a3ee93b675c96f504af0001220991c88db759e231b3320dcedf814dcf723fd9857e3d72d66a0f2af26950b915abdf56c1596f46a325bf17ad4810d3535fb02a259b247ac3dbd4cc3ecf9c51b6c07cebb009c1506fba0a89321ec8683e3fd009a6e551d50243e2d5092fefb3321083a4bad91320dc624bd6b5dddf93553e3d53924c05bfebec1fb4bd47e89a1a889f04180102000905024d3c5c33021b0c000a0910d4984f961e35246b26c703ff7ee29ef53bc1ae1ead533c408fa136db508434e233d6e62be621e031e5940bbd4c08142aed0f82217e7c3e1ec8de574bc06ccf3c36633be41ad78a9eacd209f861cae7b064100758545cc9dd83db71806dc1cfd5fb9ae5c7474bba0c19c44034ae61bae5eca379383339dece94ff56ff7aa44a582f3e5c38f45763af577c0934b0020000\"\n@@ -235,3 +255,7 @@ const signedTextMessageHex = \"a3019bc0cbccc8c4b8d8b74ee2108fe16ec6d36a250cbece0c\n const signedEncryptedMessageHex = \"848c032a67d68660df41c70103ff5789d0de26b6a50c985a02a13131ca829c413a35d0e6fa8d6842599252162808ac7439c72151c8c6183e76923fe3299301414d0c25a2f06a2257db3839e7df0ec964773f6e4c4ac7ff3b48c444237166dd46ba8ff443a5410dc670cb486672fdbe7c9dfafb75b4fea83af3a204fe2a7dfa86bd20122b4f3d2646cbeecb8f7be8d2c03b018bd210b1d3791e1aba74b0f1034e122ab72e760492c192383cf5e20b5628bd043272d63df9b923f147eb6091cd897553204832aba48fec54aa447547bb16305a1024713b90e77fd0065f1918271947549205af3c74891af22ee0b56cd29bfec6d6e351901cd4ab3ece7c486f1e32a792d4e474aed98ee84b3f591c7dff37b64e0ecd68fd036d517e412dcadf85840ce184ad7921ad446c4ee28db80447aea1ca8d4f574db4d4e37688158ddd19e14ee2eab4873d46947d65d14a23e788d912cf9a19624ca7352469b72a83866b7c23cb5ace3deab3c7018061b0ba0f39ed2befe27163e5083cf9b8271e3e3d52cc7ad6e2a3bd81d4c3d7022f8d\"\n \n const symmetricallyEncryptedCompressedHex = \"8c0d04030302eb4a03808145d0d260c92f714339e13de5a79881216431925bf67ee2898ea61815f07894cd0703c50d0a76ef64d482196f47a8bc729af9b80bb6\"\n+\n+const dsaTestKeyHex = \"9901a2044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\"\n+\n+const dsaTestKeyPrivateHex = \"9501bb044d6c49de110400cb5ce438cf9250907ac2ba5bf6547931270b89f7c4b53d9d09f4d0213a5ef2ec1f26806d3d259960f872a4a102ef1581ea3f6d6882d15134f21ef6a84de933cc34c47cc9106efe3bd84c6aec12e78523661e29bc1a61f0aab17fa58a627fd5fd33f5149153fbe8cd70edf3d963bc287ef875270ff14b5bfdd1bca4483793923b00a0fe46d76cb6e4cbdc568435cd5480af3266d610d303fe33ae8273f30a96d4d34f42fa28ce1112d425b2e3bf7ea553d526e2db6b9255e9dc7419045ce817214d1a0056dbc8d5289956a4b1b69f20f1105124096e6a438f41f2e2495923b0f34b70642607d45559595c7fe94d7fa85fc41bf7d68c1fd509ebeaa5f315f6059a446b9369c277597e4f474a9591535354c7e7f4fd98a08aa60400b130c24ff20bdfbf683313f5daebf1c9b34b3bdadfc77f2ddd72ee1fb17e56c473664bc21d66467655dd74b9005e3a2bacce446f1920cd7017231ae447b67036c9b431b8179deacd5120262d894c26bc015bffe3d827ba7087ad9b700d2ca1f6d16cc1786581e5dd065f293c31209300f9b0afcc3f7c08dd26d0a22d87580b4d00009f592e0619d823953577d4503061706843317e4fee083db41054657374204b65792033202844534129886204131102002205024d6c49de021b03060b090807030206150802090a0b0416020301021e01021780000a0910338934250ccc03607e0400a0bdb9193e8a6b96fc2dfc108ae848914b504481f100a09c4dc148cb693293a67af24dd40d2b13a9e36794\""}, {"sha": "ef7b11230a987ac55f230504d6da617e7bcaa748", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,6 +6,7 @@ package openpgp\n \n import (\n \t\"crypto\"\n+\t\"crypto/dsa\"\n \t\"crypto/openpgp/armor\"\n \t\"crypto/openpgp/error\"\n \t\"crypto/openpgp/packet\"\n@@ -39,7 +40,7 @@ func DetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error {\n // ArmoredDetachSignText signs message (after canonicalising the line endings)\n // with the private key from signer (which must already have been decrypted)\n // and writes an armored signature to w.\n-func SignTextDetachedArmored(w io.Writer, signer *Entity, message io.Reader) os.Error {\n+func ArmoredDetachSignText(w io.Writer, signer *Entity, message io.Reader) os.Error {\n \treturn armoredDetachSign(w, signer, message, packet.SigTypeText)\n }\n \n@@ -80,6 +81,9 @@ func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.S\n \tcase packet.PubKeyAlgoRSA, packet.PubKeyAlgoRSASignOnly:\n \t\tpriv := signer.PrivateKey.PrivateKey.(*rsa.PrivateKey)\n \t\terr = sig.SignRSA(h, priv)\n+\tcase packet.PubKeyAlgoDSA:\n+\t\tpriv := signer.PrivateKey.PrivateKey.(*dsa.PrivateKey)\n+\t\terr = sig.SignDSA(h, priv)\n \tdefault:\n \t\terr = error.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t}"}, {"sha": "42cd0d27f850f512bc153ec7fbebc1d2d0aa314b", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -18,7 +18,7 @@ func TestSignDetached(t *testing.T) {\n \t\tt.Error(err)\n \t}\n \n-\ttestDetachedSignature(t, kring, out, signedInput, \"check\")\n+\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey1KeyId)\n }\n \n func TestSignTextDetached(t *testing.T) {\n@@ -30,5 +30,17 @@ func TestSignTextDetached(t *testing.T) {\n \t\tt.Error(err)\n \t}\n \n-\ttestDetachedSignature(t, kring, out, signedInput, \"check\")\n+\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey1KeyId)\n+}\n+\n+func TestSignDetachedDSA(t *testing.T) {\n+\tkring, _ := ReadKeyRing(readerFromHex(dsaTestKeyPrivateHex))\n+\tout := bytes.NewBuffer(nil)\n+\tmessage := bytes.NewBufferString(signedInput)\n+\terr := DetachSign(out, kring[0], message)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\ttestDetachedSignature(t, kring, out, signedInput, \"check\", testKey3KeyId)\n }"}, {"sha": "81b5a07446ea644b0e4cb5047fe8b23e343cdca4", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,6 +7,7 @@ package tls\n import (\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n+\t\"crypto/x509\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"sync\"\n@@ -95,6 +96,9 @@ type ConnectionState struct {\n \tHandshakeComplete  bool\n \tCipherSuite        uint16\n \tNegotiatedProtocol string\n+\n+\t// the certificate chain that was presented by the other side\n+\tPeerCertificates []*x509.Certificate\n }\n \n // A Config structure is used to configure a TLS client or server. After one"}, {"sha": "1e6fe60aec2a4ba630bce7f1967fa2ae81f975e9", "filename": "libgo/go/crypto/tls/conn.go", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fconn.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -762,6 +762,7 @@ func (c *Conn) ConnectionState() ConnectionState {\n \tif c.handshakeComplete {\n \t\tstate.NegotiatedProtocol = c.clientProtocol\n \t\tstate.CipherSuite = c.cipherSuite\n+\t\tstate.PeerCertificates = c.peerCertificates\n \t}\n \n \treturn state\n@@ -776,15 +777,6 @@ func (c *Conn) OCSPResponse() []byte {\n \treturn c.ocspResponse\n }\n \n-// PeerCertificates returns the certificate chain that was presented by the\n-// other side.\n-func (c *Conn) PeerCertificates() []*x509.Certificate {\n-\tc.handshakeMutex.Lock()\n-\tdefer c.handshakeMutex.Unlock()\n-\n-\treturn c.peerCertificates\n-}\n-\n // VerifyHostname checks that the peer certificate chain is valid for\n // connecting to host.  If so, it returns nil; if not, it returns an os.Error\n // describing the problem."}, {"sha": "ee77f949fc038b4d01d3d053a0e775c98b5b8ede", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -25,7 +25,7 @@ func main() {\n \n \tpriv, err := rsa.GenerateKey(rand.Reader, 1024)\n \tif err != nil {\n-\t\tlog.Exitf(\"failed to generate private key: %s\", err)\n+\t\tlog.Fatalf(\"failed to generate private key: %s\", err)\n \t\treturn\n \t}\n \n@@ -46,13 +46,13 @@ func main() {\n \n \tderBytes, err := x509.CreateCertificate(rand.Reader, &template, &template, &priv.PublicKey, priv)\n \tif err != nil {\n-\t\tlog.Exitf(\"Failed to create certificate: %s\", err)\n+\t\tlog.Fatalf(\"Failed to create certificate: %s\", err)\n \t\treturn\n \t}\n \n \tcertOut, err := os.Open(\"cert.pem\", os.O_WRONLY|os.O_CREAT, 0644)\n \tif err != nil {\n-\t\tlog.Exitf(\"failed to open cert.pem for writing: %s\", err)\n+\t\tlog.Fatalf(\"failed to open cert.pem for writing: %s\", err)\n \t\treturn\n \t}\n \tpem.Encode(certOut, &pem.Block{Type: \"CERTIFICATE\", Bytes: derBytes})"}, {"sha": "49f0a5361fbf5410ae0e0e25414740e8ae3529a9", "filename": "libgo/go/debug/proc/proc_darwin.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_darwin.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,6 +12,6 @@ func Attach(pid int) (Process, os.Error) {\n \treturn nil, os.NewError(\"debug/proc not implemented on OS X\")\n }\n \n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n+func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n \treturn Attach(0)\n }"}, {"sha": "4df07c365afe5ac9a4d712f2cc02c1a728113ad2", "filename": "libgo/go/debug/proc/proc_freebsd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_freebsd.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,6 +12,6 @@ func Attach(pid int) (Process, os.Error) {\n \treturn nil, os.NewError(\"debug/proc not implemented on FreeBSD\")\n }\n \n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n+func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n \treturn Attach(0)\n }"}, {"sha": "6890a2221ef4b3496c6d7b3f32963afac8b906f6", "filename": "libgo/go/debug/proc/proc_linux.go", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_linux.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -1279,25 +1279,31 @@ func Attach(pid int) (Process, os.Error) {\n \treturn p, nil\n }\n \n-// ForkExec forks the current process and execs argv0, stopping the\n-// new process after the exec syscall.  See os.ForkExec for additional\n+// StartProcess forks the current process and execs argv0, stopping the\n+// new process after the exec syscall.  See os.StartProcess for additional\n // details.\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n+func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n+\tsysattr := &syscall.ProcAttr{\n+\t\tDir:    attr.Dir,\n+\t\tEnv:    attr.Env,\n+\t\tPtrace: true,\n+\t}\n \tp := newProcess(-1)\n \n \t// Create array of integer (system) fds.\n-\tintfd := make([]int, len(fd))\n-\tfor i, f := range fd {\n+\tintfd := make([]int, len(attr.Files))\n+\tfor i, f := range attr.Files {\n \t\tif f == nil {\n \t\t\tintfd[i] = -1\n \t\t} else {\n \t\t\tintfd[i] = f.Fd()\n \t\t}\n \t}\n+\tsysattr.Files = intfd\n \n \t// Fork from the monitor thread so we get the right tracer pid.\n \terr := p.do(func() os.Error {\n-\t\tpid, errno := syscall.PtraceForkExec(argv0, argv, envv, dir, intfd)\n+\t\tpid, _, errno := syscall.StartProcess(argv0, argv, sysattr)\n \t\tif errno != 0 {\n \t\t\treturn &os.PathError{\"fork/exec\", argv0, os.Errno(errno)}\n \t\t}"}, {"sha": "661474b67aaaabe246ab0a2d0be3fa842580a4f9", "filename": "libgo/go/debug/proc/proc_windows.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fproc%2Fproc_windows.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,6 +12,6 @@ func Attach(pid int) (Process, os.Error) {\n \treturn nil, os.NewError(\"debug/proc not implemented on windows\")\n }\n \n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []*os.File) (Process, os.Error) {\n+func StartProcess(argv0 string, argv []string, attr *os.ProcAttr) (Process, os.Error) {\n \treturn Attach(0)\n }"}, {"sha": "44e3b65bec87f24c18e6d5733785a657c41d8809", "filename": "libgo/go/exec/exec.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexec%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexec%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -75,17 +75,19 @@ func modeToFiles(mode, fd int) (*os.File, *os.File, os.Error) {\n \n // Run starts the named binary running with\n // arguments argv and environment envv.\n+// If the dir argument is not empty, the child changes\n+// into the directory before executing the binary.\n // It returns a pointer to a new Cmd representing\n // the command or an error.\n //\n-// The parameters stdin, stdout, and stderr\n+// The arguments stdin, stdout, and stderr\n // specify how to handle standard input, output, and error.\n // The choices are DevNull (connect to /dev/null),\n // PassThrough (connect to the current process's standard stream),\n // Pipe (connect to an operating system pipe), and\n // MergeWithStdout (only for standard error; use the same\n // file descriptor as was used for standard output).\n-// If a parameter is Pipe, then the corresponding field (Stdin, Stdout, Stderr)\n+// If an argument is Pipe, then the corresponding field (Stdin, Stdout, Stderr)\n // of the returned Cmd is the other end of the pipe.\n // Otherwise the field in Cmd is nil.\n func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int) (c *Cmd, err os.Error) {\n@@ -105,7 +107,7 @@ func Run(name string, argv, envv []string, dir string, stdin, stdout, stderr int\n \t}\n \n \t// Run command.\n-\tc.Process, err = os.StartProcess(name, argv, envv, dir, fd[0:])\n+\tc.Process, err = os.StartProcess(name, argv, &os.ProcAttr{Dir: dir, Files: fd[:], Env: envv})\n \tif err != nil {\n \t\tgoto Error\n \t}"}, {"sha": "5e37b99eeca0f8cd4f2749aa7f3847fe41b1bee4", "filename": "libgo/go/exec/exec_test.go", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexec%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexec%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexec%2Fexec_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -118,3 +118,55 @@ func TestAddEnvVar(t *testing.T) {\n \t\tt.Fatal(\"close:\", err)\n \t}\n }\n+\n+var tryargs = []string{\n+\t`2`,\n+\t`2 `,\n+\t\"2 \\t\",\n+\t`2\" \"`,\n+\t`2 ab `,\n+\t`2 \"ab\" `,\n+\t`2 \\ `,\n+\t`2 \\\\ `,\n+\t`2 \\\" `,\n+\t`2 \\`,\n+\t`2\\`,\n+\t`2\"`,\n+\t`2\\\"`,\n+\t`2 \"`,\n+\t`2 \\\"`,\n+\t``,\n+\t`2 ^ `,\n+\t`2 \\^`,\n+}\n+\n+func TestArgs(t *testing.T) {\n+\tfor _, a := range tryargs {\n+\t\targv := []string{\n+\t\t\t\"awk\",\n+\t\t\t`BEGIN{printf(\"%s|%s|%s\",ARGV[1],ARGV[2],ARGV[3])}`,\n+\t\t\t\"/dev/null\",\n+\t\t\ta,\n+\t\t\t\"EOF\",\n+\t\t}\n+\t\texe, err := LookPath(argv[0])\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"run:\", err)\n+\t\t}\n+\t\tcmd, err := Run(exe, argv, nil, \"\", DevNull, Pipe, DevNull)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"run:\", err)\n+\t\t}\n+\t\tbuf, err := ioutil.ReadAll(cmd.Stdout)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"read:\", err)\n+\t\t}\n+\t\texpect := \"/dev/null|\" + a + \"|EOF\"\n+\t\tif string(buf) != expect {\n+\t\t\tt.Errorf(\"read: got %q expect %q\", buf, expect)\n+\t\t}\n+\t\tif err = cmd.Close(); err != nil {\n+\t\t\tt.Fatal(\"close:\", err)\n+\t\t}\n+\t}\n+}"}, {"sha": "f6b7c1cda941ac4ef4798a7cbefb9f9f42064d63", "filename": "libgo/go/exp/eval/stmt.go", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -287,9 +287,6 @@ func (a *stmtCompiler) compile(s ast.Stmt) {\n \tcase *ast.SwitchStmt:\n \t\ta.compileSwitchStmt(s)\n \n-\tcase *ast.TypeCaseClause:\n-\t\tnotimpl = true\n-\n \tcase *ast.TypeSwitchStmt:\n \t\tnotimpl = true\n \n@@ -1012,13 +1009,13 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \t\t\ta.diagAt(clause.Pos(), \"switch statement must contain case clauses\")\n \t\t\tcontinue\n \t\t}\n-\t\tif clause.Values == nil {\n+\t\tif clause.List == nil {\n \t\t\tif hasDefault {\n \t\t\t\ta.diagAt(clause.Pos(), \"switch statement contains more than one default case\")\n \t\t\t}\n \t\t\thasDefault = true\n \t\t} else {\n-\t\t\tncases += len(clause.Values)\n+\t\t\tncases += len(clause.List)\n \t\t}\n \t}\n \n@@ -1030,7 +1027,7 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \t\tif !ok {\n \t\t\tcontinue\n \t\t}\n-\t\tfor _, v := range clause.Values {\n+\t\tfor _, v := range clause.List {\n \t\t\te := condbc.compileExpr(condbc.block, false, v)\n \t\t\tswitch {\n \t\t\tcase e == nil:\n@@ -1077,8 +1074,8 @@ func (a *stmtCompiler) compileSwitchStmt(s *ast.SwitchStmt) {\n \n \t\t// Save jump PC's\n \t\tpc := a.nextPC()\n-\t\tif clause.Values != nil {\n-\t\t\tfor _ = range clause.Values {\n+\t\tif clause.List != nil {\n+\t\t\tfor _ = range clause.List {\n \t\t\t\tcasePCs[i] = &pc\n \t\t\t\ti++\n \t\t\t}"}, {"sha": "a8a3e16204121e4db0e58d5d2c85b5a05d801893", "filename": "libgo/go/exp/eval/stmt_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Feval%2Fstmt_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -27,7 +27,7 @@ var stmtTests = []test{\n \tCErr(\"i, u := 1, 2\", atLeastOneDecl),\n \tVal2(\"i, x := 2, f\", \"i\", 2, \"x\", 1.0),\n \t// Various errors\n-\tCErr(\"1 := 2\", \"left side of := must be a name\"),\n+\tCErr(\"1 := 2\", \"expected identifier\"),\n \tCErr(\"c, a := 1, 1\", \"cannot assign\"),\n \t// Unpacking\n \tVal2(\"x, y := oneTwo()\", \"x\", 1, \"y\", 2),"}, {"sha": "9920ff6b883a1c354a0abd41fb5ea52df475e864", "filename": "libgo/go/exp/ogle/cmd.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fogle%2Fcmd.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -160,7 +160,7 @@ func cmdLoad(args []byte) os.Error {\n \t\t} else {\n \t\t\tfname = parts[0]\n \t\t}\n-\t\ttproc, err = proc.ForkExec(fname, parts, os.Environ(), \"\", []*os.File{os.Stdin, os.Stdout, os.Stderr})\n+\t\ttproc, err = proc.StartProcess(fname, parts, &os.ProcAttr{Files: []*os.File{os.Stdin, os.Stdout, os.Stderr}})\n \t\tif err != nil {\n \t\t\treturn err\n \t\t}"}, {"sha": "ed6cff78db40fbf9eda4ae796f9de1c279977aa7", "filename": "libgo/go/expvar/expvar.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fexpvar%2Fexpvar.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexpvar%2Fexpvar.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -269,7 +269,7 @@ func Iter() <-chan KeyValue {\n }\n \n func expvarHandler(w http.ResponseWriter, r *http.Request) {\n-\tw.SetHeader(\"content-type\", \"application/json; charset=utf-8\")\n+\tw.Header().Set(\"Content-Type\", \"application/json; charset=utf-8\")\n \tfmt.Fprintf(w, \"{\\n\")\n \tfirst := true\n \tfor name, value := range vars {"}, {"sha": "14f4d522c6a4ea23c70d12808c03834cc175e830", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 33, "deletions": 16, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -56,7 +56,7 @@\n \n \t\tflag.Bool(...)  // global options\n \t\tflag.Parse()  // parse leading command\n-\t\tsubcmd := flag.Args(0)\n+\t\tsubcmd := flag.Arg[0]\n \t\tswitch subcmd {\n \t\t\t// add per-subcommand options\n \t\t}\n@@ -68,6 +68,7 @@ package flag\n import (\n \t\"fmt\"\n \t\"os\"\n+\t\"sort\"\n \t\"strconv\"\n )\n \n@@ -205,16 +206,34 @@ type allFlags struct {\n \n var flags *allFlags\n \n-// VisitAll visits the flags, calling fn for each. It visits all flags, even those not set.\n+// sortFlags returns the flags as a slice in lexicographical sorted order.\n+func sortFlags(flags map[string]*Flag) []*Flag {\n+\tlist := make(sort.StringArray, len(flags))\n+\ti := 0\n+\tfor _, f := range flags {\n+\t\tlist[i] = f.Name\n+\t\ti++\n+\t}\n+\tlist.Sort()\n+\tresult := make([]*Flag, len(list))\n+\tfor i, name := range list {\n+\t\tresult[i] = flags[name]\n+\t}\n+\treturn result\n+}\n+\n+// VisitAll visits the flags in lexicographical order, calling fn for each.\n+// It visits all flags, even those not set.\n func VisitAll(fn func(*Flag)) {\n-\tfor _, f := range flags.formal {\n+\tfor _, f := range sortFlags(flags.formal) {\n \t\tfn(f)\n \t}\n }\n \n-// Visit visits the flags, calling fn for each. It visits only those flags that have been set.\n+// Visit visits the flags in lexicographical order, calling fn for each.\n+// It visits only those flags that have been set.\n func Visit(fn func(*Flag)) {\n-\tfor _, f := range flags.actual {\n+\tfor _, f := range sortFlags(flags.actual) {\n \t\tfn(f)\n \t}\n }\n@@ -260,14 +279,17 @@ var Usage = func() {\n \n var panicOnError = false\n \n-func fail() {\n+// failf prints to standard error a formatted error and Usage, and then exits the program.\n+func failf(format string, a ...interface{}) {\n+\tfmt.Fprintf(os.Stderr, format, a...)\n \tUsage()\n \tif panicOnError {\n \t\tpanic(\"flag parse error\")\n \t}\n \tos.Exit(2)\n }\n \n+// NFlag returns the number of flags that have been set.\n func NFlag() int { return len(flags.actual) }\n \n // Arg returns the i'th command-line argument.  Arg(0) is the first remaining argument\n@@ -415,8 +437,7 @@ func (f *allFlags) parseOne() (ok bool) {\n \t}\n \tname := s[num_minuses:]\n \tif len(name) == 0 || name[0] == '-' || name[0] == '=' {\n-\t\tfmt.Fprintln(os.Stderr, \"bad flag syntax:\", s)\n-\t\tfail()\n+\t\tfailf(\"bad flag syntax: %s\\n\", s)\n \t}\n \n \t// it's a flag. does it have an argument?\n@@ -434,14 +455,12 @@ func (f *allFlags) parseOne() (ok bool) {\n \tm := flags.formal\n \tflag, alreadythere := m[name] // BUG\n \tif !alreadythere {\n-\t\tfmt.Fprintf(os.Stderr, \"flag provided but not defined: -%s\\n\", name)\n-\t\tfail()\n+\t\tfailf(\"flag provided but not defined: -%s\\n\", name)\n \t}\n \tif fv, ok := flag.Value.(*boolValue); ok { // special case: doesn't need an arg\n \t\tif has_value {\n \t\t\tif !fv.Set(value) {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"invalid boolean value %q for flag: -%s\\n\", value, name)\n-\t\t\t\tfail()\n+\t\t\t\tfailf(\"invalid boolean value %q for flag: -%s\\n\", value, name)\n \t\t\t}\n \t\t} else {\n \t\t\tfv.Set(\"true\")\n@@ -454,13 +473,11 @@ func (f *allFlags) parseOne() (ok bool) {\n \t\t\tvalue, f.args = f.args[0], f.args[1:]\n \t\t}\n \t\tif !has_value {\n-\t\t\tfmt.Fprintf(os.Stderr, \"flag needs an argument: -%s\\n\", name)\n-\t\t\tfail()\n+\t\t\tfailf(\"flag needs an argument: -%s\\n\", name)\n \t\t}\n \t\tok = flag.Value.Set(value)\n \t\tif !ok {\n-\t\t\tfmt.Fprintf(os.Stderr, \"invalid value %q for flag: -%s\\n\", value, name)\n-\t\t\tfail()\n+\t\t\tfailf(\"invalid value %q for flag: -%s\\n\", value, name)\n \t\t}\n \t}\n \tflags.actual[name] = flag"}, {"sha": "1e47d12e48a76ac07c151da89426e267ae3911d5", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,6 +8,7 @@ import (\n \t. \"flag\"\n \t\"fmt\"\n \t\"os\"\n+\t\"sort\"\n \t\"testing\"\n )\n \n@@ -77,6 +78,12 @@ func TestEverything(t *testing.T) {\n \t\t\tt.Log(k, *v)\n \t\t}\n \t}\n+\t// Now test they're visited in sort order.\n+\tvar flagNames []string\n+\tVisit(func(f *Flag) { flagNames = append(flagNames, f.Name) })\n+\tif !sort.StringsAreSorted(flagNames) {\n+\t\tt.Errorf(\"flag names not sorted: %v\", flagNames)\n+\t}\n }\n \n func TestUsage(t *testing.T) {"}, {"sha": "caaa7ac1a8af36ed2fb0ac13ef69911f33971954", "filename": "libgo/go/fmt/format.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fformat.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -107,7 +107,7 @@ func (f *fmt) writePadding(n int, padding []byte) {\n }\n \n // Append b to f.buf, padded on left (w > 0) or right (w < 0 or f.minus)\n-// clear flags aftewards.\n+// clear flags afterwards.\n func (f *fmt) pad(b []byte) {\n \tvar padding []byte\n \tvar left, right int\n@@ -124,7 +124,7 @@ func (f *fmt) pad(b []byte) {\n }\n \n // append s to buf, padded on left (w > 0) or right (w < 0 or f.minus).\n-// clear flags aftewards.\n+// clear flags afterwards.\n func (f *fmt) padString(s string) {\n \tvar padding []byte\n \tvar left, right int"}, {"sha": "36271a8d4665ca404d0c698c82cade78b0622065", "filename": "libgo/go/fmt/scan.go", "status": "modified", "additions": 39, "deletions": 22, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -35,10 +35,15 @@ type ScanState interface {\n \tReadRune() (rune int, size int, err os.Error)\n \t// UnreadRune causes the next call to ReadRune to return the same rune.\n \tUnreadRune() os.Error\n-\t// Token returns the next space-delimited token from the input. If\n-\t// a width has been specified, the returned token will be no longer\n-\t// than the width.\n-\tToken() (token string, err os.Error)\n+\t// Token skips space in the input if skipSpace is true, then returns the\n+\t// run of Unicode code points c satisfying f(c).  If f is nil,\n+\t// !unicode.IsSpace(c) is used; that is, the token will hold non-space\n+\t// characters.  Newlines are treated as space unless the scan operation\n+\t// is Scanln, Fscanln or Sscanln, in which case a newline is treated as\n+\t// EOF.  The returned slice points to shared data that may be overwritten\n+\t// by the next call to Token, a call to a Scan function using the ScanState\n+\t// as input, or when the calling Scan method returns.\n+\tToken(skipSpace bool, f func(int) bool) (token []byte, err os.Error)\n \t// Width returns the value of the width option and whether it has been set.\n \t// The unit is Unicode code points.\n \tWidth() (wid int, ok bool)\n@@ -134,7 +139,7 @@ type scanError struct {\n \terr os.Error\n }\n \n-const EOF = -1\n+const eof = -1\n \n // ss is the internal implementation of ScanState.\n type ss struct {\n@@ -202,7 +207,7 @@ func (s *ss) getRune() (rune int) {\n \trune, _, err := s.ReadRune()\n \tif err != nil {\n \t\tif err == os.EOF {\n-\t\t\treturn EOF\n+\t\t\treturn eof\n \t\t}\n \t\ts.error(err)\n \t}\n@@ -214,7 +219,7 @@ func (s *ss) getRune() (rune int) {\n // syntax error.\n func (s *ss) mustReadRune() (rune int) {\n \trune = s.getRune()\n-\tif rune == EOF {\n+\tif rune == eof {\n \t\ts.error(io.ErrUnexpectedEOF)\n \t}\n \treturn\n@@ -238,7 +243,7 @@ func (s *ss) errorString(err string) {\n \tpanic(scanError{os.ErrorString(err)})\n }\n \n-func (s *ss) Token() (tok string, err os.Error) {\n+func (s *ss) Token(skipSpace bool, f func(int) bool) (tok []byte, err os.Error) {\n \tdefer func() {\n \t\tif e := recover(); e != nil {\n \t\t\tif se, ok := e.(scanError); ok {\n@@ -248,10 +253,19 @@ func (s *ss) Token() (tok string, err os.Error) {\n \t\t\t}\n \t\t}\n \t}()\n-\ttok = s.token()\n+\tif f == nil {\n+\t\tf = notSpace\n+\t}\n+\ts.buf.Reset()\n+\ttok = s.token(skipSpace, f)\n \treturn\n }\n \n+// notSpace is the default scanning function used in Token.\n+func notSpace(r int) bool {\n+\treturn !unicode.IsSpace(r)\n+}\n+\n // readRune is a structure to enable reading UTF-8 encoded code points\n // from an io.Reader.  It is used if the Reader given to the scanner does\n // not already implement io.RuneReader.\n@@ -364,7 +378,7 @@ func (s *ss) free(old ssave) {\n func (s *ss) skipSpace(stopAtNewline bool) {\n \tfor {\n \t\trune := s.getRune()\n-\t\tif rune == EOF {\n+\t\tif rune == eof {\n \t\t\treturn\n \t\t}\n \t\tif rune == '\\n' {\n@@ -384,24 +398,27 @@ func (s *ss) skipSpace(stopAtNewline bool) {\n \t}\n }\n \n+\n // token returns the next space-delimited string from the input.  It\n // skips white space.  For Scanln, it stops at newlines.  For Scan,\n // newlines are treated as spaces.\n-func (s *ss) token() string {\n-\ts.skipSpace(false)\n+func (s *ss) token(skipSpace bool, f func(int) bool) []byte {\n+\tif skipSpace {\n+\t\ts.skipSpace(false)\n+\t}\n \t// read until white space or newline\n \tfor {\n \t\trune := s.getRune()\n-\t\tif rune == EOF {\n+\t\tif rune == eof {\n \t\t\tbreak\n \t\t}\n-\t\tif unicode.IsSpace(rune) {\n+\t\tif !f(rune) {\n \t\t\ts.UnreadRune()\n \t\t\tbreak\n \t\t}\n \t\ts.buf.WriteRune(rune)\n \t}\n-\treturn s.buf.String()\n+\treturn s.buf.Bytes()\n }\n \n // typeError indicates that the type of the operand did not match the format\n@@ -416,7 +433,7 @@ var boolError = os.ErrorString(\"syntax error scanning boolean\")\n // If accept is true, it puts the character into the input token.\n func (s *ss) consume(ok string, accept bool) bool {\n \trune := s.getRune()\n-\tif rune == EOF {\n+\tif rune == eof {\n \t\treturn false\n \t}\n \tif strings.IndexRune(ok, rune) >= 0 {\n@@ -425,7 +442,7 @@ func (s *ss) consume(ok string, accept bool) bool {\n \t\t}\n \t\treturn true\n \t}\n-\tif rune != EOF && accept {\n+\tif rune != eof && accept {\n \t\ts.UnreadRune()\n \t}\n \treturn false\n@@ -434,7 +451,7 @@ func (s *ss) consume(ok string, accept bool) bool {\n // peek reports whether the next character is in the ok string, without consuming it.\n func (s *ss) peek(ok string) bool {\n \trune := s.getRune()\n-\tif rune != EOF {\n+\tif rune != eof {\n \t\ts.UnreadRune()\n \t}\n \treturn strings.IndexRune(ok, rune) >= 0\n@@ -729,7 +746,7 @@ func (s *ss) convertString(verb int) (str string) {\n \tcase 'x':\n \t\tstr = s.hexString()\n \tdefault:\n-\t\tstr = s.token() // %s and %v just return the next word\n+\t\tstr = string(s.token(true, notSpace)) // %s and %v just return the next word\n \t}\n \t// Empty strings other than with %q are not OK.\n \tif len(str) == 0 && verb != 'q' && s.maxWid > 0 {\n@@ -797,7 +814,7 @@ func (s *ss) hexDigit(digit int) int {\n // There must be either two hexadecimal digits or a space character in the input.\n func (s *ss) hexByte() (b byte, ok bool) {\n \trune1 := s.getRune()\n-\tif rune1 == EOF {\n+\tif rune1 == eof {\n \t\treturn\n \t}\n \tif unicode.IsSpace(rune1) {\n@@ -953,7 +970,7 @@ func (s *ss) doScan(a []interface{}) (numProcessed int, err os.Error) {\n \tif !s.nlIsSpace {\n \t\tfor {\n \t\t\trune := s.getRune()\n-\t\t\tif rune == '\\n' || rune == EOF {\n+\t\t\tif rune == '\\n' || rune == eof {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tif !unicode.IsSpace(rune) {\n@@ -993,7 +1010,7 @@ func (s *ss) advance(format string) (i int) {\n \t\t\t// There was space in the format, so there should be space (EOF)\n \t\t\t// in the input.\n \t\t\tinputc := s.getRune()\n-\t\t\tif inputc == EOF {\n+\t\t\tif inputc == eof {\n \t\t\t\treturn\n \t\t\t}\n \t\t\tif !unicode.IsSpace(inputc) {"}, {"sha": "8d2e6f5c64e86448d8fe6e16d6112b794492771e", "filename": "libgo/go/fmt/scan_test.go", "status": "modified", "additions": 11, "deletions": 18, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fscan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ffmt%2Fscan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fscan_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -88,14 +88,15 @@ type FloatTest struct {\n type Xs string\n \n func (x *Xs) Scan(state ScanState, verb int) os.Error {\n-\ttok, err := state.Token()\n+\ttok, err := state.Token(true, func(r int) bool { return r == verb })\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif !regexp.MustCompile(\"^\" + string(verb) + \"+$\").MatchString(tok) {\n+\ts := string(tok)\n+\tif !regexp.MustCompile(\"^\" + string(verb) + \"+$\").MatchString(s) {\n \t\treturn os.ErrorString(\"syntax error for xs\")\n \t}\n-\t*x = Xs(tok)\n+\t*x = Xs(s)\n \treturn nil\n }\n \n@@ -113,9 +114,11 @@ func (s *IntString) Scan(state ScanState, verb int) os.Error {\n \t\treturn err\n \t}\n \n-\tif _, err := Fscan(state, &s.s); err != nil {\n+\ttok, err := state.Token(true, nil)\n+\tif err != nil {\n \t\treturn err\n \t}\n+\ts.s = string(tok)\n \treturn nil\n }\n \n@@ -331,7 +334,7 @@ var multiTests = []ScanfMultiTest{\n \t{\"%c%c%c\", \"2\\u50c2X\", args(&i, &j, &k), args('2', '\\u50c2', 'X'), \"\"},\n \n \t// Custom scanners.\n-\t{\"%2e%f\", \"eefffff\", args(&x, &y), args(Xs(\"ee\"), Xs(\"fffff\")), \"\"},\n+\t{\"%e%f\", \"eefffff\", args(&x, &y), args(Xs(\"ee\"), Xs(\"fffff\")), \"\"},\n \t{\"%4v%s\", \"12abcd\", args(&z, &s), args(IntString{12, \"ab\"}, \"cd\"), \"\"},\n \n \t// Errors\n@@ -476,22 +479,12 @@ func verifyInf(str string, t *testing.T) {\n \t}\n }\n \n-\n func TestInf(t *testing.T) {\n \tfor _, s := range []string{\"inf\", \"+inf\", \"-inf\", \"INF\", \"-INF\", \"+INF\", \"Inf\", \"-Inf\", \"+Inf\"} {\n \t\tverifyInf(s, t)\n \t}\n }\n \n-// TODO: there's no conversion from []T to ...T, but we can fake it.  These\n-// functions do the faking.  We index the table by the length of the param list.\n-var fscanf = []func(io.Reader, string, []interface{}) (int, os.Error){\n-\t0: func(r io.Reader, f string, i []interface{}) (int, os.Error) { return Fscanf(r, f) },\n-\t1: func(r io.Reader, f string, i []interface{}) (int, os.Error) { return Fscanf(r, f, i[0]) },\n-\t2: func(r io.Reader, f string, i []interface{}) (int, os.Error) { return Fscanf(r, f, i[0], i[1]) },\n-\t3: func(r io.Reader, f string, i []interface{}) (int, os.Error) { return Fscanf(r, f, i[0], i[1], i[2]) },\n-}\n-\n func testScanfMulti(name string, t *testing.T) {\n \tsliceType := reflect.Typeof(make([]interface{}, 1)).(*reflect.SliceType)\n \tfor _, test := range multiTests {\n@@ -501,7 +494,7 @@ func testScanfMulti(name string, t *testing.T) {\n \t\t} else {\n \t\t\tr = newReader(test.text)\n \t\t}\n-\t\tn, err := fscanf[len(test.in)](r, test.format, test.in)\n+\t\tn, err := Fscanf(r, test.format, test.in...)\n \t\tif err != nil {\n \t\t\tif test.err == \"\" {\n \t\t\t\tt.Errorf(\"got error scanning (%q, %q): %q\", test.format, test.text, err)\n@@ -830,12 +823,12 @@ func testScanInts(t *testing.T, scan func(*RecursiveInt, *bytes.Buffer) os.Error\n \ti := 1\n \tfor ; r != nil; r = r.next {\n \t\tif r.i != i {\n-\t\t\tt.Fatal(\"bad scan: expected %d got %d\", i, r.i)\n+\t\t\tt.Fatalf(\"bad scan: expected %d got %d\", i, r.i)\n \t\t}\n \t\ti++\n \t}\n \tif i-1 != intCount {\n-\t\tt.Fatal(\"bad scan count: expected %d got %d\", intCount, i-1)\n+\t\tt.Fatalf(\"bad scan count: expected %d got %d\", intCount, i-1)\n \t}\n }\n "}, {"sha": "4a4c12b7c0a2065660584f509e5f0228183a5c51", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 16, "deletions": 30, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -602,12 +602,12 @@ type (\n \t\tElse Stmt // else branch; or nil\n \t}\n \n-\t// A CaseClause represents a case of an expression switch statement.\n+\t// A CaseClause represents a case of an expression or type switch statement.\n \tCaseClause struct {\n-\t\tCase   token.Pos // position of \"case\" or \"default\" keyword\n-\t\tValues []Expr    // nil means default case\n-\t\tColon  token.Pos // position of \":\"\n-\t\tBody   []Stmt    // statement list; or nil\n+\t\tCase  token.Pos // position of \"case\" or \"default\" keyword\n+\t\tList  []Expr    // list of expressions or types; nil means default case\n+\t\tColon token.Pos // position of \":\"\n+\t\tBody  []Stmt    // statement list; or nil\n \t}\n \n \t// A SwitchStmt node represents an expression switch statement.\n@@ -618,20 +618,12 @@ type (\n \t\tBody   *BlockStmt // CaseClauses only\n \t}\n \n-\t// A TypeCaseClause represents a case of a type switch statement.\n-\tTypeCaseClause struct {\n-\t\tCase  token.Pos // position of \"case\" or \"default\" keyword\n-\t\tTypes []Expr    // nil means default case\n-\t\tColon token.Pos // position of \":\"\n-\t\tBody  []Stmt    // statement list; or nil\n-\t}\n-\n \t// An TypeSwitchStmt node represents a type switch statement.\n \tTypeSwitchStmt struct {\n \t\tSwitch token.Pos  // position of \"switch\" keyword\n \t\tInit   Stmt       // initalization statement; or nil\n-\t\tAssign Stmt       // x := y.(type)\n-\t\tBody   *BlockStmt // TypeCaseClauses only\n+\t\tAssign Stmt       // x := y.(type) or y.(type)\n+\t\tBody   *BlockStmt // CaseClauses only\n \t}\n \n \t// A CommClause node represents a case of a select statement.\n@@ -687,7 +679,6 @@ func (s *BlockStmt) Pos() token.Pos      { return s.Lbrace }\n func (s *IfStmt) Pos() token.Pos         { return s.If }\n func (s *CaseClause) Pos() token.Pos     { return s.Case }\n func (s *SwitchStmt) Pos() token.Pos     { return s.Switch }\n-func (s *TypeCaseClause) Pos() token.Pos { return s.Case }\n func (s *TypeSwitchStmt) Pos() token.Pos { return s.Switch }\n func (s *CommClause) Pos() token.Pos     { return s.Case }\n func (s *SelectStmt) Pos() token.Pos     { return s.Select }\n@@ -734,13 +725,7 @@ func (s *CaseClause) End() token.Pos {\n \t}\n \treturn s.Colon + 1\n }\n-func (s *SwitchStmt) End() token.Pos { return s.Body.End() }\n-func (s *TypeCaseClause) End() token.Pos {\n-\tif n := len(s.Body); n > 0 {\n-\t\treturn s.Body[n-1].End()\n-\t}\n-\treturn s.Colon + 1\n-}\n+func (s *SwitchStmt) End() token.Pos     { return s.Body.End() }\n func (s *TypeSwitchStmt) End() token.Pos { return s.Body.End() }\n func (s *CommClause) End() token.Pos {\n \tif n := len(s.Body); n > 0 {\n@@ -772,7 +757,6 @@ func (s *BlockStmt) stmtNode()      {}\n func (s *IfStmt) stmtNode()         {}\n func (s *CaseClause) stmtNode()     {}\n func (s *SwitchStmt) stmtNode()     {}\n-func (s *TypeCaseClause) stmtNode() {}\n func (s *TypeSwitchStmt) stmtNode() {}\n func (s *CommClause) stmtNode()     {}\n func (s *SelectStmt) stmtNode()     {}\n@@ -937,11 +921,13 @@ func (d *FuncDecl) declNode() {}\n // via Doc and Comment fields.\n //\n type File struct {\n-\tDoc      *CommentGroup   // associated documentation; or nil\n-\tPackage  token.Pos       // position of \"package\" keyword\n-\tName     *Ident          // package name\n-\tDecls    []Decl          // top-level declarations; or nil\n-\tComments []*CommentGroup // list of all comments in the source file\n+\tDoc        *CommentGroup   // associated documentation; or nil\n+\tPackage    token.Pos       // position of \"package\" keyword\n+\tName       *Ident          // package name\n+\tDecls      []Decl          // top-level declarations; or nil\n+\tScope      *Scope          // package scope\n+\tUnresolved []*Ident        // unresolved global identifiers\n+\tComments   []*CommentGroup // list of all comments in the source file\n }\n \n \n@@ -959,7 +945,7 @@ func (f *File) End() token.Pos {\n //\n type Package struct {\n \tName  string           // package name\n-\tScope *Scope           // package scope; or nil\n+\tScope *Scope           // package scope\n \tFiles map[string]*File // Go source files by filename\n }\n "}, {"sha": "4da487ce02ad02fd7c508b64809537f6543edbc3", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -425,5 +425,6 @@ func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \t\t}\n \t}\n \n-\treturn &File{doc, pos, NewIdent(pkg.Name), decls, comments}\n+\t// TODO(gri) need to compute pkgScope and unresolved identifiers!\n+\treturn &File{doc, pos, NewIdent(pkg.Name), decls, nil, nil, comments}\n }"}, {"sha": "82c334ece67504ac4d21523db72c9439a4c71173", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -30,15 +30,19 @@ func NotNilFilter(_ string, value reflect.Value) bool {\n \n \n // Fprint prints the (sub-)tree starting at AST node x to w.\n+// If fset != nil, position information is interpreted relative\n+// to that file set. Otherwise positions are printed as integer\n+// values (file set specific offsets).\n //\n // A non-nil FieldFilter f may be provided to control the output:\n // struct fields for which f(fieldname, fieldvalue) is true are\n // are printed; all others are filtered from the output.\n //\n-func Fprint(w io.Writer, x interface{}, f FieldFilter) (n int, err os.Error) {\n+func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n int, err os.Error) {\n \t// setup printer\n \tp := printer{\n \t\toutput: w,\n+\t\tfset:   fset,\n \t\tfilter: f,\n \t\tptrmap: make(map[interface{}]int),\n \t\tlast:   '\\n', // force printing of line number on first line\n@@ -65,14 +69,15 @@ func Fprint(w io.Writer, x interface{}, f FieldFilter) (n int, err os.Error) {\n \n \n // Print prints x to standard output, skipping nil fields.\n-// Print(x) is the same as Fprint(os.Stdout, x, NotNilFilter).\n-func Print(x interface{}) (int, os.Error) {\n-\treturn Fprint(os.Stdout, x, NotNilFilter)\n+// Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n+func Print(fset *token.FileSet, x interface{}) (int, os.Error) {\n+\treturn Fprint(os.Stdout, fset, x, NotNilFilter)\n }\n \n \n type printer struct {\n \toutput  io.Writer\n+\tfset    *token.FileSet\n \tfilter  FieldFilter\n \tptrmap  map[interface{}]int // *reflect.PtrValue -> line number\n \twritten int                 // number of bytes written to output\n@@ -137,16 +142,6 @@ func (p *printer) printf(format string, args ...interface{}) {\n // probably be in a different package.\n \n func (p *printer) print(x reflect.Value) {\n-\t// Note: This test is only needed because AST nodes\n-\t//       embed a token.Position, and thus all of them\n-\t//       understand the String() method (but it only\n-\t//       applies to the Position field).\n-\t// TODO: Should reconsider this AST design decision.\n-\tif pos, ok := x.Interface().(token.Position); ok {\n-\t\tp.printf(\"%s\", pos)\n-\t\treturn\n-\t}\n-\n \tif !NotNilFilter(\"\", x) {\n \t\tp.printf(\"nil\")\n \t\treturn\n@@ -163,6 +158,7 @@ func (p *printer) print(x reflect.Value) {\n \t\t\tp.print(key)\n \t\t\tp.printf(\": \")\n \t\t\tp.print(v.Elem(key))\n+\t\t\tp.printf(\"\\n\")\n \t\t}\n \t\tp.indent--\n \t\tp.printf(\"}\")\n@@ -212,6 +208,11 @@ func (p *printer) print(x reflect.Value) {\n \t\tp.printf(\"}\")\n \n \tdefault:\n-\t\tp.printf(\"%v\", x.Interface())\n+\t\tvalue := x.Interface()\n+\t\t// position values can be printed nicely if we have a file set\n+\t\tif pos, ok := value.(token.Pos); ok && p.fset != nil {\n+\t\t\tvalue = p.fset.Position(pos)\n+\t\t}\n+\t\tp.printf(\"%v\", value)\n \t}\n }"}, {"sha": "91866dcf57b4a4194e1c42e112a40b8e0ad1b9c4", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 86, "deletions": 175, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,105 +2,140 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements scopes, the objects they contain,\n-// and object types.\n+// This file implements scopes and the objects they contain.\n \n package ast\n \n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/token\"\n+)\n+\n+\n // A Scope maintains the set of named language entities declared\n // in the scope and a link to the immediately surrounding (outer)\n // scope.\n //\n type Scope struct {\n \tOuter   *Scope\n-\tObjects []*Object // in declaration order\n-\t// Implementation note: In some cases (struct fields,\n-\t// function parameters) we need the source order of\n-\t// variables. Thus for now, we store scope entries\n-\t// in a linear list. If scopes become very large\n-\t// (say, for packages), we may need to change this\n-\t// to avoid slow lookups.\n+\tObjects map[string]*Object\n }\n \n \n // NewScope creates a new scope nested in the outer scope.\n func NewScope(outer *Scope) *Scope {\n-\tconst n = 4 // initial scope capacity, must be > 0\n-\treturn &Scope{outer, make([]*Object, 0, n)}\n+\tconst n = 4 // initial scope capacity\n+\treturn &Scope{outer, make(map[string]*Object, n)}\n }\n \n \n // Lookup returns the object with the given name if it is\n // found in scope s, otherwise it returns nil. Outer scopes\n // are ignored.\n //\n-// Lookup always returns nil if name is \"_\", even if the scope\n-// contains objects with that name.\n-//\n func (s *Scope) Lookup(name string) *Object {\n-\tif name != \"_\" {\n-\t\tfor _, obj := range s.Objects {\n-\t\t\tif obj.Name == name {\n-\t\t\t\treturn obj\n-\t\t\t}\n-\t\t}\n-\t}\n-\treturn nil\n+\treturn s.Objects[name]\n }\n \n \n // Insert attempts to insert a named object into the scope s.\n-// If the scope does not contain an object with that name yet\n-// or if the object is named \"_\", Insert inserts the object\n-// and returns it. Otherwise, Insert leaves the scope unchanged\n-// and returns the object found in the scope instead.\n+// If the scope does not contain an object with that name yet,\n+// Insert inserts the object and returns it. Otherwise, Insert\n+// leaves the scope unchanged and returns the object found in\n+// the scope instead.\n //\n-func (s *Scope) Insert(obj *Object) *Object {\n-\talt := s.Lookup(obj.Name)\n-\tif alt == nil {\n-\t\ts.append(obj)\n+func (s *Scope) Insert(obj *Object) (alt *Object) {\n+\tif alt = s.Objects[obj.Name]; alt == nil {\n+\t\ts.Objects[obj.Name] = obj\n \t\talt = obj\n \t}\n-\treturn alt\n+\treturn\n }\n \n \n-func (s *Scope) append(obj *Object) {\n-\ts.Objects = append(s.Objects, obj)\n+// Debugging support\n+func (s *Scope) String() string {\n+\tvar buf bytes.Buffer\n+\tfmt.Fprintf(&buf, \"scope %p {\", s)\n+\tif s != nil && len(s.Objects) > 0 {\n+\t\tfmt.Fprintln(&buf)\n+\t\tfor _, obj := range s.Objects {\n+\t\t\tfmt.Fprintf(&buf, \"\\t%s %s\\n\", obj.Kind, obj.Name)\n+\t\t}\n+\t}\n+\tfmt.Fprintf(&buf, \"}\\n\")\n+\treturn buf.String()\n }\n \n+\n // ----------------------------------------------------------------------------\n // Objects\n \n-// An Object describes a language entity such as a package,\n-// constant, type, variable, or function (incl. methods).\n+// An Object describes a named language entity such as a package,\n+// constant, type, variable, function (incl. methods), or label.\n //\n type Object struct {\n-\tKind Kind\n-\tName string // declared name\n-\tType *Type\n-\tDecl interface{} // corresponding Field, XxxSpec or FuncDecl\n-\tN    int         // value of iota for this declaration\n+\tKind ObjKind\n+\tName string      // declared name\n+\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, or LabeledStmt; or nil\n+\tType interface{} // place holder for type information; may be nil\n }\n \n \n // NewObj creates a new object of a given kind and name.\n-func NewObj(kind Kind, name string) *Object {\n+func NewObj(kind ObjKind, name string) *Object {\n \treturn &Object{Kind: kind, Name: name}\n }\n \n \n-// Kind describes what an object represents.\n-type Kind int\n+// Pos computes the source position of the declaration of an object name.\n+// The result may be an invalid position if it cannot be computed\n+// (obj.Decl may be nil or not correct).\n+func (obj *Object) Pos() token.Pos {\n+\tname := obj.Name\n+\tswitch d := obj.Decl.(type) {\n+\tcase *Field:\n+\t\tfor _, n := range d.Names {\n+\t\t\tif n.Name == name {\n+\t\t\t\treturn n.Pos()\n+\t\t\t}\n+\t\t}\n+\tcase *ValueSpec:\n+\t\tfor _, n := range d.Names {\n+\t\t\tif n.Name == name {\n+\t\t\t\treturn n.Pos()\n+\t\t\t}\n+\t\t}\n+\tcase *TypeSpec:\n+\t\tif d.Name.Name == name {\n+\t\t\treturn d.Name.Pos()\n+\t\t}\n+\tcase *FuncDecl:\n+\t\tif d.Name.Name == name {\n+\t\t\treturn d.Name.Pos()\n+\t\t}\n+\tcase *LabeledStmt:\n+\t\tif d.Label.Name == name {\n+\t\t\treturn d.Label.Pos()\n+\t\t}\n+\t}\n+\treturn token.NoPos\n+}\n+\n+\n+// ObKind describes what an object represents.\n+type ObjKind int\n \n // The list of possible Object kinds.\n const (\n-\tBad Kind = iota // for error handling\n-\tPkg             // package\n-\tCon             // constant\n-\tTyp             // type\n-\tVar             // variable\n-\tFun             // function or method\n+\tBad ObjKind = iota // for error handling\n+\tPkg                // package\n+\tCon                // constant\n+\tTyp                // type\n+\tVar                // variable\n+\tFun                // function or method\n+\tLbl                // label\n )\n \n \n@@ -111,132 +146,8 @@ var objKindStrings = [...]string{\n \tTyp: \"type\",\n \tVar: \"var\",\n \tFun: \"func\",\n+\tLbl: \"label\",\n }\n \n \n-func (kind Kind) String() string { return objKindStrings[kind] }\n-\n-\n-// IsExported returns whether obj is exported.\n-func (obj *Object) IsExported() bool { return IsExported(obj.Name) }\n-\n-\n-// ----------------------------------------------------------------------------\n-// Types\n-\n-// A Type represents a Go type.\n-type Type struct {\n-\tForm     Form\n-\tObj      *Object // corresponding type name, or nil\n-\tScope    *Scope  // fields and methods, always present\n-\tN        uint    // basic type id, array length, number of function results, or channel direction\n-\tKey, Elt *Type   // map key and array, pointer, slice, map or channel element\n-\tParams   *Scope  // function (receiver, input and result) parameters, tuple expressions (results of function calls), or nil\n-\tExpr     Expr    // corresponding AST expression\n-}\n-\n-\n-// NewType creates a new type of a given form.\n-func NewType(form Form) *Type {\n-\treturn &Type{Form: form, Scope: NewScope(nil)}\n-}\n-\n-\n-// Form describes the form of a type.\n-type Form int\n-\n-// The list of possible type forms.\n-const (\n-\tBadType    Form = iota // for error handling\n-\tUnresolved             // type not fully setup\n-\tBasic\n-\tArray\n-\tStruct\n-\tPointer\n-\tFunction\n-\tMethod\n-\tInterface\n-\tSlice\n-\tMap\n-\tChannel\n-\tTuple\n-)\n-\n-\n-var formStrings = [...]string{\n-\tBadType:    \"badType\",\n-\tUnresolved: \"unresolved\",\n-\tBasic:      \"basic\",\n-\tArray:      \"array\",\n-\tStruct:     \"struct\",\n-\tPointer:    \"pointer\",\n-\tFunction:   \"function\",\n-\tMethod:     \"method\",\n-\tInterface:  \"interface\",\n-\tSlice:      \"slice\",\n-\tMap:        \"map\",\n-\tChannel:    \"channel\",\n-\tTuple:      \"tuple\",\n-}\n-\n-\n-func (form Form) String() string { return formStrings[form] }\n-\n-\n-// The list of basic type id's.\n-const (\n-\tBool = iota\n-\tByte\n-\tUint\n-\tInt\n-\tFloat\n-\tComplex\n-\tUintptr\n-\tString\n-\n-\tUint8\n-\tUint16\n-\tUint32\n-\tUint64\n-\n-\tInt8\n-\tInt16\n-\tInt32\n-\tInt64\n-\n-\tFloat32\n-\tFloat64\n-\n-\tComplex64\n-\tComplex128\n-\n-\t// TODO(gri) ideal types are missing\n-)\n-\n-\n-var BasicTypes = map[uint]string{\n-\tBool:    \"bool\",\n-\tByte:    \"byte\",\n-\tUint:    \"uint\",\n-\tInt:     \"int\",\n-\tFloat:   \"float\",\n-\tComplex: \"complex\",\n-\tUintptr: \"uintptr\",\n-\tString:  \"string\",\n-\n-\tUint8:  \"uint8\",\n-\tUint16: \"uint16\",\n-\tUint32: \"uint32\",\n-\tUint64: \"uint64\",\n-\n-\tInt8:  \"int8\",\n-\tInt16: \"int16\",\n-\tInt32: \"int32\",\n-\tInt64: \"int64\",\n-\n-\tFloat32: \"float32\",\n-\tFloat64: \"float64\",\n-\n-\tComplex64:  \"complex64\",\n-\tComplex128: \"complex128\",\n-}\n+func (kind ObjKind) String() string { return objKindStrings[kind] }"}, {"sha": "95c4b3a3564948379abd558473bd66dffc80491f", "filename": "libgo/go/go/ast/walk.go", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fwalk.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -234,7 +234,7 @@ func Walk(v Visitor, node Node) {\n \t\t}\n \n \tcase *CaseClause:\n-\t\twalkExprList(v, n.Values)\n+\t\twalkExprList(v, n.List)\n \t\twalkStmtList(v, n.Body)\n \n \tcase *SwitchStmt:\n@@ -246,12 +246,6 @@ func Walk(v Visitor, node Node) {\n \t\t}\n \t\tWalk(v, n.Body)\n \n-\tcase *TypeCaseClause:\n-\t\tfor _, x := range n.Types {\n-\t\t\tWalk(v, x)\n-\t\t}\n-\t\twalkStmtList(v, n.Body)\n-\n \tcase *TypeSwitchStmt:\n \t\tif n.Init != nil {\n \t\t\tWalk(v, n.Init)"}, {"sha": "6f35b495efa15234c2a1b06e505031e44ae5edca", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -14,7 +14,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n-\tpathutil \"path\"\n+\t\"path/filepath\"\n )\n \n \n@@ -198,7 +198,7 @@ func ParseDir(fset *token.FileSet, path string, filter func(*os.FileInfo) bool,\n \tfor i := 0; i < len(list); i++ {\n \t\td := &list[i]\n \t\tif filter == nil || filter(d) {\n-\t\t\tfilenames[n] = pathutil.Join(path, d.Name)\n+\t\t\tfilenames[n] = filepath.Join(path, d.Name)\n \t\t\tn++\n \t\t}\n \t}"}, {"sha": "b0e8c8ad7a8e86f6674e083962d40cd4b835b4f2", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 320, "deletions": 125, "changes": 445, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -17,10 +17,6 @@ import (\n )\n \n \n-// noPos is used when there is no corresponding source position for a token.\n-var noPos token.Position\n-\n-\n // The mode parameter to the Parse* functions is a set of flags (or 0).\n // They control the amount of source code parsed and other optional\n // parser functionality.\n@@ -30,6 +26,7 @@ const (\n \tImportsOnly                        // parsing stops after import declarations\n \tParseComments                      // parse comments and add them to AST\n \tTrace                              // print a trace of parsed productions\n+\tDeclarationErrors                  // report declaration errors\n )\n \n \n@@ -46,16 +43,26 @@ type parser struct {\n \n \t// Comments\n \tcomments    []*ast.CommentGroup\n-\tleadComment *ast.CommentGroup // the last lead comment\n-\tlineComment *ast.CommentGroup // the last line comment\n+\tleadComment *ast.CommentGroup // last lead comment\n+\tlineComment *ast.CommentGroup // last line comment\n \n \t// Next token\n-\tpos token.Pos   // token position\n-\ttok token.Token // one token look-ahead\n-\tlit []byte      // token literal\n+\tpos  token.Pos   // token position\n+\ttok  token.Token // one token look-ahead\n+\tlit_ []byte      // token literal (slice into original source, don't hold on to it)\n \n \t// Non-syntactic parser control\n \texprLev int // < 0: in control clause, >= 0: in expression\n+\n+\t// Ordinary identifer scopes\n+\tpkgScope   *ast.Scope   // pkgScope.Outer == nil\n+\ttopScope   *ast.Scope   // top-most scope; may be pkgScope\n+\tunresolved []*ast.Ident // unresolved global identifiers\n+\n+\t// Label scope\n+\t// (maintained by open/close LabelScope)\n+\tlabelScope  *ast.Scope     // label scope for current function\n+\ttargetStack [][]*ast.Ident // stack of unresolved labels\n }\n \n \n@@ -72,9 +79,126 @@ func scannerMode(mode uint) uint {\n func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode uint) {\n \tp.file = fset.AddFile(filename, fset.Base(), len(src))\n \tp.scanner.Init(p.file, src, p, scannerMode(mode))\n+\n \tp.mode = mode\n \tp.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)\n+\n \tp.next()\n+\n+\t// set up the pkgScope here (as opposed to in parseFile) because\n+\t// there are other parser entry points (ParseExpr, etc.)\n+\tp.openScope()\n+\tp.pkgScope = p.topScope\n+\n+\t// for the same reason, set up a label scope\n+\tp.openLabelScope()\n+}\n+\n+\n+func (p *parser) lit() []byte {\n+\t// make a copy of p.lit_ so that we don't hold on to\n+\t// a copy of the entire source indirectly in the AST\n+\tt := make([]byte, len(p.lit_))\n+\tcopy(t, p.lit_)\n+\treturn t\n+}\n+\n+\n+// ----------------------------------------------------------------------------\n+// Scoping support\n+\n+func (p *parser) openScope() {\n+\tp.topScope = ast.NewScope(p.topScope)\n+}\n+\n+\n+func (p *parser) closeScope() {\n+\tp.topScope = p.topScope.Outer\n+}\n+\n+\n+func (p *parser) openLabelScope() {\n+\tp.labelScope = ast.NewScope(p.labelScope)\n+\tp.targetStack = append(p.targetStack, nil)\n+}\n+\n+\n+func (p *parser) closeLabelScope() {\n+\t// resolve labels\n+\tn := len(p.targetStack) - 1\n+\tscope := p.labelScope\n+\tfor _, ident := range p.targetStack[n] {\n+\t\tident.Obj = scope.Lookup(ident.Name)\n+\t\tif ident.Obj == nil && p.mode&DeclarationErrors != 0 {\n+\t\t\tp.error(ident.Pos(), fmt.Sprintf(\"label %s undefined\", ident.Name))\n+\t\t}\n+\t}\n+\t// pop label scope\n+\tp.targetStack = p.targetStack[0:n]\n+\tp.labelScope = p.labelScope.Outer\n+}\n+\n+\n+func (p *parser) declare(decl interface{}, scope *ast.Scope, kind ast.ObjKind, idents ...*ast.Ident) {\n+\tfor _, ident := range idents {\n+\t\tif ident.Name != \"_\" {\n+\t\t\tobj := ast.NewObj(kind, ident.Name)\n+\t\t\t// remember the corresponding declaration for redeclaration\n+\t\t\t// errors and global variable resolution/typechecking phase\n+\t\t\tobj.Decl = decl\n+\t\t\talt := scope.Insert(obj)\n+\t\t\tif alt != obj && p.mode&DeclarationErrors != 0 {\n+\t\t\t\tprevDecl := \"\"\n+\t\t\t\tif pos := alt.Pos(); pos.IsValid() {\n+\t\t\t\t\tprevDecl = fmt.Sprintf(\"\\n\\tprevious declaration at %s\", p.file.Position(pos))\n+\t\t\t\t}\n+\t\t\t\tp.error(ident.Pos(), fmt.Sprintf(\"%s redeclared in this block%s\", ident.Name, prevDecl))\n+\t\t\t}\n+\t\t\tident.Obj = obj\n+\t\t}\n+\t}\n+}\n+\n+\n+func (p *parser) shortVarDecl(idents []*ast.Ident) {\n+\t// Go spec: A short variable declaration may redeclare variables\n+\t// provided they were originally declared in the same block with\n+\t// the same type, and at least one of the non-blank variables is new.\n+\tn := 0 // number of new variables\n+\tfor _, ident := range idents {\n+\t\tif ident.Name != \"_\" {\n+\t\t\tobj := ast.NewObj(ast.Var, ident.Name)\n+\t\t\t// short var declarations cannot have redeclaration errors\n+\t\t\t// and are not global => no need to remember the respective\n+\t\t\t// declaration\n+\t\t\talt := p.topScope.Insert(obj)\n+\t\t\tif alt == obj {\n+\t\t\t\tn++ // new declaration\n+\t\t\t}\n+\t\t\tident.Obj = alt\n+\t\t}\n+\t}\n+\tif n == 0 && p.mode&DeclarationErrors != 0 {\n+\t\tp.error(idents[0].Pos(), \"no new variables on left side of :=\")\n+\t}\n+}\n+\n+\n+func (p *parser) resolve(ident *ast.Ident) {\n+\tif ident.Name == \"_\" {\n+\t\treturn\n+\t}\n+\t// try to resolve the identifier\n+\tfor s := p.topScope; s != nil; s = s.Outer {\n+\t\tif obj := s.Lookup(ident.Name); obj != nil {\n+\t\t\tident.Obj = obj\n+\t\t\treturn\n+\t\t}\n+\t}\n+\t// collect unresolved global identifiers; ignore the others\n+\tif p.topScope == p.pkgScope {\n+\t\tp.unresolved = append(p.unresolved, ident)\n+\t}\n }\n \n \n@@ -120,31 +244,31 @@ func (p *parser) next0() {\n \t\ts := p.tok.String()\n \t\tswitch {\n \t\tcase p.tok.IsLiteral():\n-\t\t\tp.printTrace(s, string(p.lit))\n+\t\t\tp.printTrace(s, string(p.lit_))\n \t\tcase p.tok.IsOperator(), p.tok.IsKeyword():\n \t\t\tp.printTrace(\"\\\"\" + s + \"\\\"\")\n \t\tdefault:\n \t\t\tp.printTrace(s)\n \t\t}\n \t}\n \n-\tp.pos, p.tok, p.lit = p.scanner.Scan()\n+\tp.pos, p.tok, p.lit_ = p.scanner.Scan()\n }\n \n // Consume a comment and return it and the line on which it ends.\n func (p *parser) consumeComment() (comment *ast.Comment, endline int) {\n \t// /*-style comments may end on a different line than where they start.\n \t// Scan the comment for '\\n' chars and adjust endline accordingly.\n \tendline = p.file.Line(p.pos)\n-\tif p.lit[1] == '*' {\n-\t\tfor _, b := range p.lit {\n+\tif p.lit_[1] == '*' {\n+\t\tfor _, b := range p.lit_ {\n \t\t\tif b == '\\n' {\n \t\t\t\tendline++\n \t\t\t}\n \t\t}\n \t}\n \n-\tcomment = &ast.Comment{p.pos, p.lit}\n+\tcomment = &ast.Comment{p.pos, p.lit()}\n \tp.next0()\n \n \treturn\n@@ -234,12 +358,12 @@ func (p *parser) errorExpected(pos token.Pos, msg string) {\n \tif pos == p.pos {\n \t\t// the error happened at the current position;\n \t\t// make the error message more specific\n-\t\tif p.tok == token.SEMICOLON && p.lit[0] == '\\n' {\n+\t\tif p.tok == token.SEMICOLON && p.lit_[0] == '\\n' {\n \t\t\tmsg += \", found newline\"\n \t\t} else {\n \t\t\tmsg += \", found '\" + p.tok.String() + \"'\"\n \t\t\tif p.tok.IsLiteral() {\n-\t\t\t\tmsg += \" \" + string(p.lit)\n+\t\t\t\tmsg += \" \" + string(p.lit_)\n \t\t\t}\n \t\t}\n \t}\n@@ -271,7 +395,7 @@ func (p *parser) parseIdent() *ast.Ident {\n \tpos := p.pos\n \tname := \"_\"\n \tif p.tok == token.IDENT {\n-\t\tname = string(p.lit)\n+\t\tname = string(p.lit_)\n \t\tp.next()\n \t} else {\n \t\tp.expect(token.IDENT) // use expect() error handling\n@@ -339,13 +463,16 @@ func (p *parser) parseQualifiedIdent() ast.Expr {\n \t\tdefer un(trace(p, \"QualifiedIdent\"))\n \t}\n \n-\tvar x ast.Expr = p.parseIdent()\n+\tident := p.parseIdent()\n+\tp.resolve(ident)\n+\tvar x ast.Expr = ident\n \tif p.tok == token.PERIOD {\n \t\t// first identifier is a package identifier\n \t\tp.next()\n \t\tsel := p.parseIdent()\n \t\tx = &ast.SelectorExpr{x, sel}\n \t}\n+\n \treturn x\n }\n \n@@ -407,7 +534,7 @@ func (p *parser) parseFieldDecl() *ast.Field {\n \t// optional tag\n \tvar tag *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\ttag = &ast.BasicLit{p.pos, p.tok, p.lit()}\n \t\tp.next()\n \t}\n \n@@ -426,7 +553,7 @@ func (p *parser) parseFieldDecl() *ast.Field {\n \t\t}\n \t}\n \n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n \n \treturn &ast.Field{doc, idents, typ, tag, p.lineComment}\n }\n@@ -519,7 +646,7 @@ func (p *parser) parseVarList(isParam bool) (list []ast.Expr, typ ast.Expr) {\n }\n \n \n-func (p *parser) parseParameterList(ellipsisOk bool) (params []*ast.Field) {\n+func (p *parser) parseParameterList(scope *ast.Scope, ellipsisOk bool) (params []*ast.Field) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ParameterList\"))\n \t}\n@@ -528,15 +655,23 @@ func (p *parser) parseParameterList(ellipsisOk bool) (params []*ast.Field) {\n \tif typ != nil {\n \t\t// IdentifierList Type\n \t\tidents := p.makeIdentList(list)\n-\t\tparams = append(params, &ast.Field{nil, idents, typ, nil, nil})\n+\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\tparams = append(params, field)\n+\t\t// Go spec: The scope of an identifier denoting a function\n+\t\t// parameter or result variable is the function body.\n+\t\tp.declare(field, scope, ast.Var, idents...)\n \t\tif p.tok == token.COMMA {\n \t\t\tp.next()\n \t\t}\n \n \t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n \t\t\tidents := p.parseIdentList()\n \t\t\ttyp := p.parseVarType(ellipsisOk)\n-\t\t\tparams = append(params, &ast.Field{nil, idents, typ, nil, nil})\n+\t\t\tfield := &ast.Field{nil, idents, typ, nil, nil}\n+\t\t\tparams = append(params, field)\n+\t\t\t// Go spec: The scope of an identifier denoting a function\n+\t\t\t// parameter or result variable is the function body.\n+\t\t\tp.declare(field, scope, ast.Var, idents...)\n \t\t\tif p.tok != token.COMMA {\n \t\t\t\tbreak\n \t\t\t}\n@@ -555,29 +690,29 @@ func (p *parser) parseParameterList(ellipsisOk bool) (params []*ast.Field) {\n }\n \n \n-func (p *parser) parseParameters(ellipsisOk bool) *ast.FieldList {\n+func (p *parser) parseParameters(scope *ast.Scope, ellipsisOk bool) *ast.FieldList {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Parameters\"))\n \t}\n \n \tvar params []*ast.Field\n \tlparen := p.expect(token.LPAREN)\n \tif p.tok != token.RPAREN {\n-\t\tparams = p.parseParameterList(ellipsisOk)\n+\t\tparams = p.parseParameterList(scope, ellipsisOk)\n \t}\n \trparen := p.expect(token.RPAREN)\n \n \treturn &ast.FieldList{lparen, params, rparen}\n }\n \n \n-func (p *parser) parseResult() *ast.FieldList {\n+func (p *parser) parseResult(scope *ast.Scope) *ast.FieldList {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Result\"))\n \t}\n \n \tif p.tok == token.LPAREN {\n-\t\treturn p.parseParameters(false)\n+\t\treturn p.parseParameters(scope, false)\n \t}\n \n \ttyp := p.tryType()\n@@ -591,27 +726,28 @@ func (p *parser) parseResult() *ast.FieldList {\n }\n \n \n-func (p *parser) parseSignature() (params, results *ast.FieldList) {\n+func (p *parser) parseSignature(scope *ast.Scope) (params, results *ast.FieldList) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Signature\"))\n \t}\n \n-\tparams = p.parseParameters(true)\n-\tresults = p.parseResult()\n+\tparams = p.parseParameters(scope, true)\n+\tresults = p.parseResult(scope)\n \n \treturn\n }\n \n \n-func (p *parser) parseFuncType() *ast.FuncType {\n+func (p *parser) parseFuncType() (*ast.FuncType, *ast.Scope) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"FuncType\"))\n \t}\n \n \tpos := p.expect(token.FUNC)\n-\tparams, results := p.parseSignature()\n+\tscope := ast.NewScope(p.topScope) // function scope\n+\tparams, results := p.parseSignature(scope)\n \n-\treturn &ast.FuncType{pos, params, results}\n+\treturn &ast.FuncType{pos, params, results}, scope\n }\n \n \n@@ -627,13 +763,14 @@ func (p *parser) parseMethodSpec() *ast.Field {\n \tif ident, isIdent := x.(*ast.Ident); isIdent && p.tok == token.LPAREN {\n \t\t// method\n \t\tidents = []*ast.Ident{ident}\n-\t\tparams, results := p.parseSignature()\n+\t\tscope := ast.NewScope(nil) // method scope\n+\t\tparams, results := p.parseSignature(scope)\n \t\ttyp = &ast.FuncType{token.NoPos, params, results}\n \t} else {\n \t\t// embedded interface\n \t\ttyp = x\n \t}\n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n \n \treturn &ast.Field{doc, idents, typ, nil, p.lineComment}\n }\n@@ -706,7 +843,8 @@ func (p *parser) tryRawType(ellipsisOk bool) ast.Expr {\n \tcase token.MUL:\n \t\treturn p.parsePointerType()\n \tcase token.FUNC:\n-\t\treturn p.parseFuncType()\n+\t\ttyp, _ := p.parseFuncType()\n+\t\treturn typ\n \tcase token.INTERFACE:\n \t\treturn p.parseInterfaceType()\n \tcase token.MAP:\n@@ -745,13 +883,17 @@ func (p *parser) parseStmtList() (list []ast.Stmt) {\n }\n \n \n-func (p *parser) parseBody() *ast.BlockStmt {\n+func (p *parser) parseBody(scope *ast.Scope) *ast.BlockStmt {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Body\"))\n \t}\n \n \tlbrace := p.expect(token.LBRACE)\n+\tp.topScope = scope // open function scope\n+\tp.openLabelScope()\n \tlist := p.parseStmtList()\n+\tp.closeLabelScope()\n+\tp.closeScope()\n \trbrace := p.expect(token.RBRACE)\n \n \treturn &ast.BlockStmt{lbrace, list, rbrace}\n@@ -764,7 +906,9 @@ func (p *parser) parseBlockStmt() *ast.BlockStmt {\n \t}\n \n \tlbrace := p.expect(token.LBRACE)\n+\tp.openScope()\n \tlist := p.parseStmtList()\n+\tp.closeScope()\n \trbrace := p.expect(token.RBRACE)\n \n \treturn &ast.BlockStmt{lbrace, list, rbrace}\n@@ -779,14 +923,14 @@ func (p *parser) parseFuncTypeOrLit() ast.Expr {\n \t\tdefer un(trace(p, \"FuncTypeOrLit\"))\n \t}\n \n-\ttyp := p.parseFuncType()\n+\ttyp, scope := p.parseFuncType()\n \tif p.tok != token.LBRACE {\n \t\t// function type only\n \t\treturn typ\n \t}\n \n \tp.exprLev++\n-\tbody := p.parseBody()\n+\tbody := p.parseBody(scope)\n \tp.exprLev--\n \n \treturn &ast.FuncLit{typ, body}\n@@ -803,10 +947,12 @@ func (p *parser) parseOperand() ast.Expr {\n \n \tswitch p.tok {\n \tcase token.IDENT:\n-\t\treturn p.parseIdent()\n+\t\tident := p.parseIdent()\n+\t\tp.resolve(ident)\n+\t\treturn ident\n \n \tcase token.INT, token.FLOAT, token.IMAG, token.CHAR, token.STRING:\n-\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tx := &ast.BasicLit{p.pos, p.tok, p.lit()}\n \t\tp.next()\n \t\treturn x\n \n@@ -1202,6 +1348,9 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t\tpos, tok := p.pos, p.tok\n \t\tp.next()\n \t\ty := p.parseExprList()\n+\t\tif tok == token.DEFINE {\n+\t\t\tp.shortVarDecl(p.makeIdentList(x))\n+\t\t}\n \t\treturn &ast.AssignStmt{x, pos, tok, y}\n \t}\n \n@@ -1216,7 +1365,12 @@ func (p *parser) parseSimpleStmt(labelOk bool) ast.Stmt {\n \t\tcolon := p.pos\n \t\tp.next()\n \t\tif label, isIdent := x[0].(*ast.Ident); labelOk && isIdent {\n-\t\t\treturn &ast.LabeledStmt{label, colon, p.parseStmt()}\n+\t\t\t// Go spec: The scope of a label is the body of the function\n+\t\t\t// in which it is declared and excludes the body of any nested\n+\t\t\t// function.\n+\t\t\tstmt := &ast.LabeledStmt{label, colon, p.parseStmt()}\n+\t\t\tp.declare(stmt, p.labelScope, ast.Lbl, label)\n+\t\t\treturn stmt\n \t\t}\n \t\tp.error(x[0].Pos(), \"illegal label declaration\")\n \t\treturn &ast.BadStmt{x[0].Pos(), colon + 1}\n@@ -1304,14 +1458,17 @@ func (p *parser) parseBranchStmt(tok token.Token) *ast.BranchStmt {\n \t\tdefer un(trace(p, \"BranchStmt\"))\n \t}\n \n-\ts := &ast.BranchStmt{p.pos, tok, nil}\n-\tp.expect(tok)\n+\tpos := p.expect(tok)\n+\tvar label *ast.Ident\n \tif tok != token.FALLTHROUGH && p.tok == token.IDENT {\n-\t\ts.Label = p.parseIdent()\n+\t\tlabel = p.parseIdent()\n+\t\t// add to list of unresolved targets\n+\t\tn := len(p.targetStack) - 1\n+\t\tp.targetStack[n] = append(p.targetStack[n], label)\n \t}\n \tp.expectSemi()\n \n-\treturn s\n+\treturn &ast.BranchStmt{pos, tok, label}\n }\n \n \n@@ -1333,6 +1490,8 @@ func (p *parser) parseIfStmt() *ast.IfStmt {\n \t}\n \n \tpos := p.expect(token.IF)\n+\tp.openScope()\n+\tdefer p.closeScope()\n \n \tvar s ast.Stmt\n \tvar x ast.Expr\n@@ -1368,28 +1527,6 @@ func (p *parser) parseIfStmt() *ast.IfStmt {\n }\n \n \n-func (p *parser) parseCaseClause() *ast.CaseClause {\n-\tif p.trace {\n-\t\tdefer un(trace(p, \"CaseClause\"))\n-\t}\n-\n-\t// SwitchCase\n-\tpos := p.pos\n-\tvar x []ast.Expr\n-\tif p.tok == token.CASE {\n-\t\tp.next()\n-\t\tx = p.parseExprList()\n-\t} else {\n-\t\tp.expect(token.DEFAULT)\n-\t}\n-\n-\tcolon := p.expect(token.COLON)\n-\tbody := p.parseStmtList()\n-\n-\treturn &ast.CaseClause{pos, x, colon, body}\n-}\n-\n-\n func (p *parser) parseTypeList() (list []ast.Expr) {\n \tif p.trace {\n \t\tdefer un(trace(p, \"TypeList\"))\n@@ -1405,25 +1542,30 @@ func (p *parser) parseTypeList() (list []ast.Expr) {\n }\n \n \n-func (p *parser) parseTypeCaseClause() *ast.TypeCaseClause {\n+func (p *parser) parseCaseClause(exprSwitch bool) *ast.CaseClause {\n \tif p.trace {\n-\t\tdefer un(trace(p, \"TypeCaseClause\"))\n+\t\tdefer un(trace(p, \"CaseClause\"))\n \t}\n \n-\t// TypeSwitchCase\n \tpos := p.pos\n-\tvar types []ast.Expr\n+\tvar list []ast.Expr\n \tif p.tok == token.CASE {\n \t\tp.next()\n-\t\ttypes = p.parseTypeList()\n+\t\tif exprSwitch {\n+\t\t\tlist = p.parseExprList()\n+\t\t} else {\n+\t\t\tlist = p.parseTypeList()\n+\t\t}\n \t} else {\n \t\tp.expect(token.DEFAULT)\n \t}\n \n \tcolon := p.expect(token.COLON)\n+\tp.openScope()\n \tbody := p.parseStmtList()\n+\tp.closeScope()\n \n-\treturn &ast.TypeCaseClause{pos, types, colon, body}\n+\treturn &ast.CaseClause{pos, list, colon, body}\n }\n \n \n@@ -1447,6 +1589,8 @@ func (p *parser) parseSwitchStmt() ast.Stmt {\n \t}\n \n \tpos := p.expect(token.SWITCH)\n+\tp.openScope()\n+\tdefer p.closeScope()\n \n \tvar s1, s2 ast.Stmt\n \tif p.tok != token.LBRACE {\n@@ -1466,28 +1610,21 @@ func (p *parser) parseSwitchStmt() ast.Stmt {\n \t\tp.exprLev = prevLev\n \t}\n \n-\tif isExprSwitch(s2) {\n-\t\tlbrace := p.expect(token.LBRACE)\n-\t\tvar list []ast.Stmt\n-\t\tfor p.tok == token.CASE || p.tok == token.DEFAULT {\n-\t\t\tlist = append(list, p.parseCaseClause())\n-\t\t}\n-\t\trbrace := p.expect(token.RBRACE)\n-\t\tbody := &ast.BlockStmt{lbrace, list, rbrace}\n-\t\tp.expectSemi()\n-\t\treturn &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body}\n-\t}\n-\n-\t// type switch\n-\t// TODO(gri): do all the checks!\n+\texprSwitch := isExprSwitch(s2)\n \tlbrace := p.expect(token.LBRACE)\n \tvar list []ast.Stmt\n \tfor p.tok == token.CASE || p.tok == token.DEFAULT {\n-\t\tlist = append(list, p.parseTypeCaseClause())\n+\t\tlist = append(list, p.parseCaseClause(exprSwitch))\n \t}\n \trbrace := p.expect(token.RBRACE)\n \tp.expectSemi()\n \tbody := &ast.BlockStmt{lbrace, list, rbrace}\n+\n+\tif exprSwitch {\n+\t\treturn &ast.SwitchStmt{pos, s1, p.makeExpr(s2), body}\n+\t}\n+\t// type switch\n+\t// TODO(gri): do all the checks!\n \treturn &ast.TypeSwitchStmt{pos, s1, s2, body}\n }\n \n@@ -1497,7 +1634,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\tdefer un(trace(p, \"CommClause\"))\n \t}\n \n-\t// CommCase\n+\tp.openScope()\n \tpos := p.pos\n \tvar comm ast.Stmt\n \tif p.tok == token.CASE {\n@@ -1518,7 +1655,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\tpos := p.pos\n \t\t\ttok := p.tok\n \t\t\tvar rhs ast.Expr\n-\t\t\tif p.tok == token.ASSIGN || p.tok == token.DEFINE {\n+\t\t\tif tok == token.ASSIGN || tok == token.DEFINE {\n \t\t\t\t// RecvStmt with assignment\n \t\t\t\tif len(lhs) > 2 {\n \t\t\t\t\tp.errorExpected(lhs[0].Pos(), \"1 or 2 expressions\")\n@@ -1527,6 +1664,9 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \t\t\t\t}\n \t\t\t\tp.next()\n \t\t\t\trhs = p.parseExpr()\n+\t\t\t\tif tok == token.DEFINE {\n+\t\t\t\t\tp.shortVarDecl(p.makeIdentList(lhs))\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\t// rhs must be single receive operation\n \t\t\t\tif len(lhs) > 1 {\n@@ -1552,6 +1692,7 @@ func (p *parser) parseCommClause() *ast.CommClause {\n \n \tcolon := p.expect(token.COLON)\n \tbody := p.parseStmtList()\n+\tp.closeScope()\n \n \treturn &ast.CommClause{pos, comm, colon, body}\n }\n@@ -1582,6 +1723,8 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t}\n \n \tpos := p.expect(token.FOR)\n+\tp.openScope()\n+\tdefer p.closeScope()\n \n \tvar s1, s2, s3 ast.Stmt\n \tif p.tok != token.LBRACE {\n@@ -1631,18 +1774,16 @@ func (p *parser) parseForStmt() ast.Stmt {\n \t\t\treturn &ast.BadStmt{pos, body.End()}\n \t\t}\n \t\tif rhs, isUnary := as.Rhs[0].(*ast.UnaryExpr); isUnary && rhs.Op == token.RANGE {\n-\t\t\t// rhs is range expression; check lhs\n+\t\t\t// rhs is range expression\n+\t\t\t// (any short variable declaration was handled by parseSimpleStat above)\n \t\t\treturn &ast.RangeStmt{pos, key, value, as.TokPos, as.Tok, rhs.X, body}\n-\t\t} else {\n-\t\t\tp.errorExpected(s2.Pos(), \"range clause\")\n-\t\t\treturn &ast.BadStmt{pos, body.End()}\n \t\t}\n-\t} else {\n-\t\t// regular for statement\n-\t\treturn &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}\n+\t\tp.errorExpected(s2.Pos(), \"range clause\")\n+\t\treturn &ast.BadStmt{pos, body.End()}\n \t}\n \n-\tpanic(\"unreachable\")\n+\t// regular for statement\n+\treturn &ast.ForStmt{pos, s1, p.makeExpr(s2), s3, body}\n }\n \n \n@@ -1706,67 +1847,82 @@ func (p *parser) parseStmt() (s ast.Stmt) {\n // ----------------------------------------------------------------------------\n // Declarations\n \n-type parseSpecFunction func(p *parser, doc *ast.CommentGroup) ast.Spec\n+type parseSpecFunction func(p *parser, doc *ast.CommentGroup, iota int) ast.Spec\n \n \n-func parseImportSpec(p *parser, doc *ast.CommentGroup) ast.Spec {\n+func parseImportSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ImportSpec\"))\n \t}\n \n \tvar ident *ast.Ident\n-\tif p.tok == token.PERIOD {\n+\tswitch p.tok {\n+\tcase token.PERIOD:\n \t\tident = &ast.Ident{p.pos, \".\", nil}\n \t\tp.next()\n-\t} else if p.tok == token.IDENT {\n+\tcase token.IDENT:\n \t\tident = p.parseIdent()\n \t}\n \n \tvar path *ast.BasicLit\n \tif p.tok == token.STRING {\n-\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit}\n+\t\tpath = &ast.BasicLit{p.pos, p.tok, p.lit()}\n \t\tp.next()\n \t} else {\n \t\tp.expect(token.STRING) // use expect() error handling\n \t}\n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n \n \treturn &ast.ImportSpec{doc, ident, path, p.lineComment}\n }\n \n \n-func parseConstSpec(p *parser, doc *ast.CommentGroup) ast.Spec {\n+func parseConstSpec(p *parser, doc *ast.CommentGroup, iota int) ast.Spec {\n \tif p.trace {\n \t\tdefer un(trace(p, \"ConstSpec\"))\n \t}\n \n \tidents := p.parseIdentList()\n \ttyp := p.tryType()\n \tvar values []ast.Expr\n-\tif typ != nil || p.tok == token.ASSIGN {\n+\tif typ != nil || p.tok == token.ASSIGN || iota == 0 {\n \t\tp.expect(token.ASSIGN)\n \t\tvalues = p.parseExprList()\n \t}\n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// Go spec: The scope of a constant or variable identifier declared inside\n+\t// a function begins at the end of the ConstSpec or VarSpec and ends at\n+\t// the end of the innermost containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tp.declare(spec, p.topScope, ast.Con, idents...)\n \n-\treturn &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\treturn spec\n }\n \n \n-func parseTypeSpec(p *parser, doc *ast.CommentGroup) ast.Spec {\n+func parseTypeSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tif p.trace {\n \t\tdefer un(trace(p, \"TypeSpec\"))\n \t}\n \n \tident := p.parseIdent()\n \ttyp := p.parseType()\n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// Go spec: The scope of a type identifier declared inside a function begins\n+\t// at the identifier in the TypeSpec and ends at the end of the innermost\n+\t// containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.TypeSpec{doc, ident, typ, p.lineComment}\n+\tp.declare(spec, p.topScope, ast.Typ, ident)\n \n-\treturn &ast.TypeSpec{doc, ident, typ, p.lineComment}\n+\treturn spec\n }\n \n \n-func parseVarSpec(p *parser, doc *ast.CommentGroup) ast.Spec {\n+func parseVarSpec(p *parser, doc *ast.CommentGroup, _ int) ast.Spec {\n \tif p.trace {\n \t\tdefer un(trace(p, \"VarSpec\"))\n \t}\n@@ -1778,9 +1934,16 @@ func parseVarSpec(p *parser, doc *ast.CommentGroup) ast.Spec {\n \t\tp.expect(token.ASSIGN)\n \t\tvalues = p.parseExprList()\n \t}\n-\tp.expectSemi()\n+\tp.expectSemi() // call before accessing p.linecomment\n+\n+\t// Go spec: The scope of a constant or variable identifier declared inside\n+\t// a function begins at the end of the ConstSpec or VarSpec and ends at\n+\t// the end of the innermost containing block.\n+\t// (Global identifiers are resolved in a separate phase after parsing.)\n+\tspec := &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\tp.declare(spec, p.topScope, ast.Var, idents...)\n \n-\treturn &ast.ValueSpec{doc, idents, typ, values, p.lineComment}\n+\treturn spec\n }\n \n \n@@ -1796,26 +1959,26 @@ func (p *parser) parseGenDecl(keyword token.Token, f parseSpecFunction) *ast.Gen\n \tif p.tok == token.LPAREN {\n \t\tlparen = p.pos\n \t\tp.next()\n-\t\tfor p.tok != token.RPAREN && p.tok != token.EOF {\n-\t\t\tlist = append(list, f(p, p.leadComment))\n+\t\tfor iota := 0; p.tok != token.RPAREN && p.tok != token.EOF; iota++ {\n+\t\t\tlist = append(list, f(p, p.leadComment, iota))\n \t\t}\n \t\trparen = p.expect(token.RPAREN)\n \t\tp.expectSemi()\n \t} else {\n-\t\tlist = append(list, f(p, nil))\n+\t\tlist = append(list, f(p, nil, 0))\n \t}\n \n \treturn &ast.GenDecl{doc, pos, keyword, lparen, list, rparen}\n }\n \n \n-func (p *parser) parseReceiver() *ast.FieldList {\n+func (p *parser) parseReceiver(scope *ast.Scope) *ast.FieldList {\n \tif p.trace {\n \t\tdefer un(trace(p, \"Receiver\"))\n \t}\n \n \tpos := p.pos\n-\tpar := p.parseParameters(false)\n+\tpar := p.parseParameters(scope, false)\n \n \t// must have exactly one receiver\n \tif par.NumFields() != 1 {\n@@ -1844,22 +2007,37 @@ func (p *parser) parseFuncDecl() *ast.FuncDecl {\n \n \tdoc := p.leadComment\n \tpos := p.expect(token.FUNC)\n+\tscope := ast.NewScope(p.topScope) // function scope\n \n \tvar recv *ast.FieldList\n \tif p.tok == token.LPAREN {\n-\t\trecv = p.parseReceiver()\n+\t\trecv = p.parseReceiver(scope)\n \t}\n \n \tident := p.parseIdent()\n-\tparams, results := p.parseSignature()\n+\n+\tparams, results := p.parseSignature(scope)\n \n \tvar body *ast.BlockStmt\n \tif p.tok == token.LBRACE {\n-\t\tbody = p.parseBody()\n+\t\tbody = p.parseBody(scope)\n \t}\n \tp.expectSemi()\n \n-\treturn &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body}\n+\tdecl := &ast.FuncDecl{doc, recv, ident, &ast.FuncType{pos, params, results}, body}\n+\tif recv == nil {\n+\t\t// Go spec: The scope of an identifier denoting a constant, type,\n+\t\t// variable, or function (but not method) declared at top level\n+\t\t// (outside any function) is the package block.\n+\t\t//\n+\t\t// init() functions cannot be referred to and there may\n+\t\t// be more than one - don't put them in the pkgScope\n+\t\tif ident.Name != \"init\" {\n+\t\t\tp.declare(decl, p.pkgScope, ast.Fun, ident)\n+\t\t}\n+\t}\n+\n+\treturn decl\n }\n \n \n@@ -1918,6 +2096,8 @@ func (p *parser) parseFile() *ast.File {\n \t// package clause\n \tdoc := p.leadComment\n \tpos := p.expect(token.PACKAGE)\n+\t// Go spec: The package clause is not a declaration;\n+\t// the package name does not appear in any scope.\n \tident := p.parseIdent()\n \tp.expectSemi()\n \n@@ -1940,5 +2120,20 @@ func (p *parser) parseFile() *ast.File {\n \t\t}\n \t}\n \n-\treturn &ast.File{doc, pos, ident, decls, p.comments}\n+\tif p.topScope != p.pkgScope {\n+\t\tpanic(\"internal error: imbalanced scopes\")\n+\t}\n+\n+\t// resolve global identifiers within the same file\n+\ti := 0\n+\tfor _, ident := range p.unresolved {\n+\t\t// i <= index for current ident\n+\t\tident.Obj = p.pkgScope.Lookup(ident.Name)\n+\t\tif ident.Obj == nil {\n+\t\t\tp.unresolved[i] = ident\n+\t\t\ti++\n+\t\t}\n+\t}\n+\n+\treturn &ast.File{doc, pos, ident, decls, p.pkgScope, p.unresolved[0:i], p.comments}\n }"}, {"sha": "2f1ee6bfc094594355ad638d5261916b4833ceb3", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -21,6 +21,7 @@ var illegalInputs = []interface{}{\n \t`package p; func f() { if /* should have condition */ {} };`,\n \t`package p; func f() { if ; /* should have condition */ {} };`,\n \t`package p; func f() { if f(); /* should have condition */ {} };`,\n+\t`package p; const c; /* should have constant value */`,\n }\n \n \n@@ -73,7 +74,7 @@ var validFiles = []string{\n \n func TestParse3(t *testing.T) {\n \tfor _, filename := range validFiles {\n-\t\t_, err := ParseFile(fset, filename, nil, 0)\n+\t\t_, err := ParseFile(fset, filename, nil, DeclarationErrors)\n \t\tif err != nil {\n \t\t\tt.Errorf(\"ParseFile(%s): %v\", filename, err)\n \t\t}"}, {"sha": "2238b6bedc80ba518b209846d67e29230a95c3ca", "filename": "libgo/go/go/printer/nodes.go", "status": "modified", "additions": 38, "deletions": 54, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fnodes.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -108,17 +108,6 @@ func (p *printer) identList(list []*ast.Ident, indent bool, multiLine *bool) {\n }\n \n \n-// Compute the key size of a key:value expression.\n-// Returns 0 if the expression doesn't fit onto a single line.\n-func (p *printer) keySize(pair *ast.KeyValueExpr) int {\n-\tif p.nodeSize(pair, infinity) <= infinity {\n-\t\t// entire expression fits on one line - return key size\n-\t\treturn p.nodeSize(pair.Key, infinity)\n-\t}\n-\treturn 0\n-}\n-\n-\n // Print a list of expressions. If the list spans multiple\n // source lines, the original line breaks are respected between\n // expressions. Sets multiLine to true if the list spans multiple\n@@ -204,17 +193,21 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t//           the key and the node size into the decision process\n \t\tuseFF := true\n \n-\t\t// determine size\n+\t\t// determine element size: all bets are off if we don't have\n+\t\t// position information for the previous and next token (likely\n+\t\t// generated code - simply ignore the size in this case by setting\n+\t\t// it to 0)\n \t\tprevSize := size\n \t\tconst infinity = 1e6 // larger than any source line\n \t\tsize = p.nodeSize(x, infinity)\n \t\tpair, isPair := x.(*ast.KeyValueExpr)\n-\t\tif size <= infinity {\n+\t\tif size <= infinity && prev.IsValid() && next.IsValid() {\n \t\t\t// x fits on a single line\n \t\t\tif isPair {\n \t\t\t\tsize = p.nodeSize(pair.Key, infinity) // size <= infinity\n \t\t\t}\n \t\t} else {\n+\t\t\t// size too large or we don't have good layout information\n \t\t\tsize = 0\n \t\t}\n \n@@ -244,7 +237,6 @@ func (p *printer) exprList(prev0 token.Pos, list []ast.Expr, depth int, mode exp\n \t\t\t\t// lines are broken using newlines so comments remain aligned\n \t\t\t\t// unless forceFF is set or there are multiple expressions on\n \t\t\t\t// the same line in which case formfeed is used\n-\t\t\t\t// broken with a formfeed\n \t\t\t\tif p.linebreak(line, linebreakMin, ws, useFF || prevBreak+1 < i) {\n \t\t\t\t\tws = ignore\n \t\t\t\t\t*multiLine = true\n@@ -375,7 +367,7 @@ func (p *printer) setLineComment(text string) {\n }\n \n \n-func (p *printer) fieldList(fields *ast.FieldList, isIncomplete bool, ctxt exprContext) {\n+func (p *printer) fieldList(fields *ast.FieldList, isStruct, isIncomplete bool) {\n \tp.nesting++\n \tdefer func() {\n \t\tp.nesting--\n@@ -384,15 +376,15 @@ func (p *printer) fieldList(fields *ast.FieldList, isIncomplete bool, ctxt exprC\n \tlbrace := fields.Opening\n \tlist := fields.List\n \trbrace := fields.Closing\n+\tsrcIsOneLine := lbrace.IsValid() && rbrace.IsValid() && p.fset.Position(lbrace).Line == p.fset.Position(rbrace).Line\n \n-\tif !isIncomplete && !p.commentBefore(p.fset.Position(rbrace)) {\n+\tif !isIncomplete && !p.commentBefore(p.fset.Position(rbrace)) && srcIsOneLine {\n \t\t// possibly a one-line struct/interface\n \t\tif len(list) == 0 {\n \t\t\t// no blank between keyword and {} in this case\n \t\t\tp.print(lbrace, token.LBRACE, rbrace, token.RBRACE)\n \t\t\treturn\n-\t\t} else if ctxt&(compositeLit|structType) == compositeLit|structType &&\n-\t\t\tp.isOneLineFieldList(list) { // for now ignore interfaces\n+\t\t} else if isStruct && p.isOneLineFieldList(list) { // for now ignore interfaces\n \t\t\t// small enough - print on one line\n \t\t\t// (don't use identList and ignore source line breaks)\n \t\t\tp.print(lbrace, token.LBRACE, blank)\n@@ -414,7 +406,7 @@ func (p *printer) fieldList(fields *ast.FieldList, isIncomplete bool, ctxt exprC\n \n \t// at least one entry or incomplete\n \tp.print(blank, lbrace, token.LBRACE, indent, formfeed)\n-\tif ctxt&structType != 0 {\n+\tif isStruct {\n \n \t\tsep := vtab\n \t\tif len(list) == 1 {\n@@ -497,15 +489,6 @@ func (p *printer) fieldList(fields *ast.FieldList, isIncomplete bool, ctxt exprC\n // ----------------------------------------------------------------------------\n // Expressions\n \n-// exprContext describes the syntactic environment in which an expression node is printed.\n-type exprContext uint\n-\n-const (\n-\tcompositeLit exprContext = 1 << iota\n-\tstructType\n-)\n-\n-\n func walkBinary(e *ast.BinaryExpr) (has4, has5 bool, maxProblem int) {\n \tswitch e.Op.Precedence() {\n \tcase 4:\n@@ -650,7 +633,7 @@ func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiL\n \tprintBlank := prec < cutoff\n \n \tws := indent\n-\tp.expr1(x.X, prec, depth+diffPrec(x.X, prec), 0, multiLine)\n+\tp.expr1(x.X, prec, depth+diffPrec(x.X, prec), multiLine)\n \tif printBlank {\n \t\tp.print(blank)\n \t}\n@@ -669,7 +652,7 @@ func (p *printer) binaryExpr(x *ast.BinaryExpr, prec1, cutoff, depth int, multiL\n \tif printBlank {\n \t\tp.print(blank)\n \t}\n-\tp.expr1(x.Y, prec+1, depth+1, 0, multiLine)\n+\tp.expr1(x.Y, prec+1, depth+1, multiLine)\n \tif ws == ignore {\n \t\tp.print(unindent)\n \t}\n@@ -742,7 +725,7 @@ func selectorExprList(expr ast.Expr) (list []ast.Expr) {\n \n \n // Sets multiLine to true if the expression spans multiple lines.\n-func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multiLine *bool) {\n+func (p *printer) expr1(expr ast.Expr, prec1, depth int, multiLine *bool) {\n \tp.print(expr.Pos())\n \n \tswitch x := expr.(type) {\n@@ -792,7 +775,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \t\t\t\t// TODO(gri) Remove this code if it cannot be reached.\n \t\t\t\tp.print(blank)\n \t\t\t}\n-\t\t\tp.expr1(x.X, prec, depth, 0, multiLine)\n+\t\t\tp.expr1(x.X, prec, depth, multiLine)\n \t\t}\n \n \tcase *ast.BasicLit:\n@@ -818,7 +801,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \t\tp.exprList(token.NoPos, parts, depth, periodSep, multiLine, token.NoPos)\n \n \tcase *ast.TypeAssertExpr:\n-\t\tp.expr1(x.X, token.HighestPrec, depth, 0, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, depth, multiLine)\n \t\tp.print(token.PERIOD, token.LPAREN)\n \t\tif x.Type != nil {\n \t\t\tp.expr(x.Type, multiLine)\n@@ -829,14 +812,14 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \n \tcase *ast.IndexExpr:\n \t\t// TODO(gri): should treat[] like parentheses and undo one level of depth\n-\t\tp.expr1(x.X, token.HighestPrec, 1, 0, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, 1, multiLine)\n \t\tp.print(x.Lbrack, token.LBRACK)\n \t\tp.expr0(x.Index, depth+1, multiLine)\n \t\tp.print(x.Rbrack, token.RBRACK)\n \n \tcase *ast.SliceExpr:\n \t\t// TODO(gri): should treat[] like parentheses and undo one level of depth\n-\t\tp.expr1(x.X, token.HighestPrec, 1, 0, multiLine)\n+\t\tp.expr1(x.X, token.HighestPrec, 1, multiLine)\n \t\tp.print(x.Lbrack, token.LBRACK)\n \t\tif x.Low != nil {\n \t\t\tp.expr0(x.Low, depth+1, multiLine)\n@@ -856,7 +839,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \t\tif len(x.Args) > 1 {\n \t\t\tdepth++\n \t\t}\n-\t\tp.expr1(x.Fun, token.HighestPrec, depth, 0, multiLine)\n+\t\tp.expr1(x.Fun, token.HighestPrec, depth, multiLine)\n \t\tp.print(x.Lparen, token.LPAREN)\n \t\tp.exprList(x.Lparen, x.Args, depth, commaSep|commaTerm, multiLine, x.Rparen)\n \t\tif x.Ellipsis.IsValid() {\n@@ -867,7 +850,7 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \tcase *ast.CompositeLit:\n \t\t// composite literal elements that are composite literals themselves may have the type omitted\n \t\tif x.Type != nil {\n-\t\t\tp.expr1(x.Type, token.HighestPrec, depth, compositeLit, multiLine)\n+\t\t\tp.expr1(x.Type, token.HighestPrec, depth, multiLine)\n \t\t}\n \t\tp.print(x.Lbrace, token.LBRACE)\n \t\tp.exprList(x.Lbrace, x.Elts, 1, commaSep|commaTerm, multiLine, x.Rbrace)\n@@ -892,15 +875,15 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \n \tcase *ast.StructType:\n \t\tp.print(token.STRUCT)\n-\t\tp.fieldList(x.Fields, x.Incomplete, ctxt|structType)\n+\t\tp.fieldList(x.Fields, true, x.Incomplete)\n \n \tcase *ast.FuncType:\n \t\tp.print(token.FUNC)\n \t\tp.signature(x.Params, x.Results, multiLine)\n \n \tcase *ast.InterfaceType:\n \t\tp.print(token.INTERFACE)\n-\t\tp.fieldList(x.Methods, x.Incomplete, ctxt)\n+\t\tp.fieldList(x.Methods, false, x.Incomplete)\n \n \tcase *ast.MapType:\n \t\tp.print(token.MAP, token.LBRACK)\n@@ -929,14 +912,14 @@ func (p *printer) expr1(expr ast.Expr, prec1, depth int, ctxt exprContext, multi\n \n \n func (p *printer) expr0(x ast.Expr, depth int, multiLine *bool) {\n-\tp.expr1(x, token.LowestPrec, depth, 0, multiLine)\n+\tp.expr1(x, token.LowestPrec, depth, multiLine)\n }\n \n \n // Sets multiLine to true if the expression spans multiple lines.\n func (p *printer) expr(x ast.Expr, multiLine *bool) {\n \tconst depth = 1\n-\tp.expr1(x, token.LowestPrec, depth, 0, multiLine)\n+\tp.expr1(x, token.LowestPrec, depth, multiLine)\n }\n \n \n@@ -1145,9 +1128,9 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\t}\n \n \tcase *ast.CaseClause:\n-\t\tif s.Values != nil {\n+\t\tif s.List != nil {\n \t\t\tp.print(token.CASE)\n-\t\t\tp.exprList(s.Pos(), s.Values, 1, blankStart|commaSep, multiLine, s.Colon)\n+\t\t\tp.exprList(s.Pos(), s.List, 1, blankStart|commaSep, multiLine, s.Colon)\n \t\t} else {\n \t\t\tp.print(token.DEFAULT)\n \t\t}\n@@ -1160,16 +1143,6 @@ func (p *printer) stmt(stmt ast.Stmt, nextIsRBrace bool, multiLine *bool) {\n \t\tp.block(s.Body, 0)\n \t\t*multiLine = true\n \n-\tcase *ast.TypeCaseClause:\n-\t\tif s.Types != nil {\n-\t\t\tp.print(token.CASE)\n-\t\t\tp.exprList(s.Pos(), s.Types, 1, blankStart|commaSep, multiLine, s.Colon)\n-\t\t} else {\n-\t\t\tp.print(token.DEFAULT)\n-\t\t}\n-\t\tp.print(s.Colon, token.COLON)\n-\t\tp.stmtList(s.Body, 1, nextIsRBrace)\n-\n \tcase *ast.TypeSwitchStmt:\n \t\tp.print(token.SWITCH)\n \t\tif s.Init != nil {\n@@ -1331,13 +1304,23 @@ func (p *printer) genDecl(d *ast.GenDecl, multiLine *bool) {\n // any control chars. Otherwise, the result is > maxSize.\n //\n func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {\n+\t// nodeSize invokes the printer, which may invoke nodeSize\n+\t// recursively. For deep composite literal nests, this can\n+\t// lead to an exponential algorithm. Remember previous\n+\t// results to prune the recursion (was issue 1628).\n+\tif size, found := p.nodeSizes[n]; found {\n+\t\treturn size\n+\t}\n+\n \tsize = maxSize + 1 // assume n doesn't fit\n+\tp.nodeSizes[n] = size\n+\n \t// nodeSize computation must be indendent of particular\n \t// style so that we always get the same decision; print\n \t// in RawFormat\n \tcfg := Config{Mode: RawFormat}\n \tvar buf bytes.Buffer\n-\tif _, err := cfg.Fprint(&buf, p.fset, n); err != nil {\n+\tif _, err := cfg.fprint(&buf, p.fset, n, p.nodeSizes); err != nil {\n \t\treturn\n \t}\n \tif buf.Len() <= maxSize {\n@@ -1347,6 +1330,7 @@ func (p *printer) nodeSize(n ast.Node, maxSize int) (size int) {\n \t\t\t}\n \t\t}\n \t\tsize = buf.Len() // n fits\n+\t\tp.nodeSizes[n] = size\n \t}\n \treturn\n }"}, {"sha": "a43e4a12c774688a0fa362dc16d390cfdfe5ad19", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,7 +12,7 @@ import (\n \t\"go/token\"\n \t\"io\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"runtime\"\n \t\"tabwriter\"\n )\n@@ -94,22 +94,23 @@ type printer struct {\n \t// written using writeItem.\n \tlast token.Position\n \n-\t// HTML support\n-\tlastTaggedLine int // last line for which a line tag was written\n-\n \t// The list of all source comments, in order of appearance.\n \tcomments        []*ast.CommentGroup // may be nil\n \tcindex          int                 // current comment index\n \tuseNodeComments bool                // if not set, ignore lead and line comments of nodes\n+\n+\t// Cache of already computed node sizes.\n+\tnodeSizes map[ast.Node]int\n }\n \n \n-func (p *printer) init(output io.Writer, cfg *Config, fset *token.FileSet) {\n+func (p *printer) init(output io.Writer, cfg *Config, fset *token.FileSet, nodeSizes map[ast.Node]int) {\n \tp.output = output\n \tp.Config = *cfg\n \tp.fset = fset\n \tp.errors = make(chan os.Error)\n \tp.buffer = make([]whiteSpace, 0, 16) // whitespace sequences are short\n+\tp.nodeSizes = nodeSizes\n }\n \n \n@@ -244,7 +245,7 @@ func (p *printer) writeItem(pos token.Position, data []byte) {\n \t}\n \tif debug {\n \t\t// do not update p.pos - use write0\n-\t\t_, filename := path.Split(pos.Filename)\n+\t\t_, filename := filepath.Split(pos.Filename)\n \t\tp.write0([]byte(fmt.Sprintf(\"[%s:%d:%d]\", filename, pos.Line, pos.Column)))\n \t}\n \tp.write(data)\n@@ -994,13 +995,8 @@ type Config struct {\n }\n \n \n-// Fprint \"pretty-prints\" an AST node to output and returns the number\n-// of bytes written and an error (if any) for a given configuration cfg.\n-// Position information is interpreted relative to the file set fset.\n-// The node type must be *ast.File, or assignment-compatible to ast.Expr,\n-// ast.Decl, ast.Spec, or ast.Stmt.\n-//\n-func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) (int, os.Error) {\n+// fprint implements Fprint and takes a nodesSizes map for setting up the printer state.\n+func (cfg *Config) fprint(output io.Writer, fset *token.FileSet, node interface{}, nodeSizes map[ast.Node]int) (int, os.Error) {\n \t// redirect output through a trimmer to eliminate trailing whitespace\n \t// (Input to a tabwriter must be untrimmed since trailing tabs provide\n \t// formatting information. The tabwriter could provide trimming\n@@ -1029,7 +1025,7 @@ func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{\n \n \t// setup printer and print node\n \tvar p printer\n-\tp.init(output, cfg, fset)\n+\tp.init(output, cfg, fset, nodeSizes)\n \tgo func() {\n \t\tswitch n := node.(type) {\n \t\tcase ast.Expr:\n@@ -1076,6 +1072,17 @@ func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{\n }\n \n \n+// Fprint \"pretty-prints\" an AST node to output and returns the number\n+// of bytes written and an error (if any) for a given configuration cfg.\n+// Position information is interpreted relative to the file set fset.\n+// The node type must be *ast.File, or assignment-compatible to ast.Expr,\n+// ast.Decl, ast.Spec, or ast.Stmt.\n+//\n+func (cfg *Config) Fprint(output io.Writer, fset *token.FileSet, node interface{}) (int, os.Error) {\n+\treturn cfg.fprint(output, fset, node, make(map[ast.Node]int))\n+}\n+\n+\n // Fprint \"pretty-prints\" an AST node to output.\n // It calls Config.Fprint with default settings.\n //"}, {"sha": "3ff087e2993b58358fdddea3e08b6fd8e14400f8", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 32, "deletions": 4, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -11,8 +11,9 @@ import (\n \t\"go/ast\"\n \t\"go/parser\"\n \t\"go/token\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"testing\"\n+\t\"time\"\n )\n \n \n@@ -45,7 +46,7 @@ const (\n )\n \n \n-func check(t *testing.T, source, golden string, mode checkMode) {\n+func runcheck(t *testing.T, source, golden string, mode checkMode) {\n \t// parse source\n \tprog, err := parser.ParseFile(fset, source, nil, parser.ParseComments)\n \tif err != nil {\n@@ -109,6 +110,32 @@ func check(t *testing.T, source, golden string, mode checkMode) {\n }\n \n \n+func check(t *testing.T, source, golden string, mode checkMode) {\n+\t// start a timer to produce a time-out signal\n+\ttc := make(chan int)\n+\tgo func() {\n+\t\ttime.Sleep(20e9) // plenty of a safety margin, even for very slow machines\n+\t\ttc <- 0\n+\t}()\n+\n+\t// run the test\n+\tcc := make(chan int)\n+\tgo func() {\n+\t\truncheck(t, source, golden, mode)\n+\t\tcc <- 0\n+\t}()\n+\n+\t// wait for the first finisher\n+\tselect {\n+\tcase <-tc:\n+\t\t// test running past time out\n+\t\tt.Errorf(\"%s: running too slowly\", source)\n+\tcase <-cc:\n+\t\t// test finished within alloted time margin\n+\t}\n+}\n+\n+\n type entry struct {\n \tsource, golden string\n \tmode           checkMode\n@@ -124,13 +151,14 @@ var data = []entry{\n \t{\"expressions.input\", \"expressions.raw\", rawFormat},\n \t{\"declarations.input\", \"declarations.golden\", 0},\n \t{\"statements.input\", \"statements.golden\", 0},\n+\t{\"slow.input\", \"slow.golden\", 0},\n }\n \n \n func TestFiles(t *testing.T) {\n \tfor _, e := range data {\n-\t\tsource := path.Join(dataDir, e.source)\n-\t\tgolden := path.Join(dataDir, e.golden)\n+\t\tsource := filepath.Join(dataDir, e.source)\n+\t\tgolden := filepath.Join(dataDir, e.golden)\n \t\tcheck(t, source, golden, e.mode)\n \t\t// TODO(gri) check that golden is idempotent\n \t\t//check(t, golden, golden, e.mode);"}, {"sha": "314d3213c740a0ecc3972d5b528ff3f5c5a373ca", "filename": "libgo/go/go/printer/testdata/expressions.golden", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.golden?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -224,11 +224,7 @@ func _() {\n \t_ = struct{ x int }{0}\n \t_ = struct{ x, y, z int }{0, 1, 2}\n \t_ = struct{ int }{0}\n-\t_ = struct {\n-\t\ts struct {\n-\t\t\tint\n-\t\t}\n-\t}{struct{ int }{0}}\t// compositeLit context not propagated => multiLine result\n+\t_ = struct{ s struct{ int } }{struct{ int }{0}}\n }\n \n "}, {"sha": "cac22af431312fa08d5eb23318183593e2c5b596", "filename": "libgo/go/go/printer/testdata/expressions.input", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.input?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -224,7 +224,7 @@ func _() {\n \t_ = struct{ x int }{0}\n \t_ = struct{ x, y, z int }{0, 1, 2}\n \t_ = struct{ int }{0}\n-\t_ = struct{ s struct { int } }{struct{ int}{0}}  // compositeLit context not propagated => multiLine result\n+\t_ = struct{ s struct { int } }{struct{ int}{0} }\n }\n \n "}, {"sha": "f22ceeb476f9083af9b88a498a383b56828d15dc", "filename": "libgo/go/go/printer/testdata/expressions.raw", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fexpressions.raw?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -224,11 +224,7 @@ func _() {\n \t_ = struct{ x int }{0}\n \t_ = struct{ x, y, z int }{0, 1, 2}\n \t_ = struct{ int }{0}\n-\t_ = struct {\n-\t\ts struct {\n-\t\t\tint\n-\t\t}\n-\t}{struct{ int }{0}}\t// compositeLit context not propagated => multiLine result\n+\t_ = struct{ s struct{ int } }{struct{ int }{0}}\n }\n \n "}, {"sha": "43a15cb1d0815757dd8f3b61804e77143fb5ce3b", "filename": "libgo/go/go/printer/testdata/slow.golden", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.golden?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package deepequal_test\n+\n+import (\n+\t\"testing\"\n+\t\"google3/spam/archer/frontend/deepequal\"\n+)\n+\n+func TestTwoNilValues(t *testing.T) {\n+\tif err := deepequal.Check(nil, nil); err != nil {\n+\t\tt.Errorf(\"expected nil, saw %v\", err)\n+\t}\n+}\n+\n+type Foo struct {\n+\tbar\t*Bar\n+\tbang\t*Bar\n+}\n+\n+type Bar struct {\n+\tbaz\t*Baz\n+\tfoo\t[]*Foo\n+}\n+\n+type Baz struct {\n+\tentries\t\tmap[int]interface{}\n+\twhatever\tstring\n+}\n+\n+func newFoo() *Foo {\n+\treturn &Foo{bar: &Bar{baz: &Baz{\n+\t\tentries: map[int]interface{}{\n+\t\t\t42:\t&Foo{},\n+\t\t\t21:\t&Bar{},\n+\t\t\t11:\t&Baz{whatever: \"it's just a test\"}}}},\n+\t\tbang: &Bar{foo: []*Foo{\n+\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t43:\t&Foo{},\n+\t\t\t\t\t22:\t&Bar{},\n+\t\t\t\t\t13:\t&Baz{whatever: \"this is nuts\"}}}},\n+\t\t\t\tbang: &Bar{foo: []*Foo{\n+\t\t\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t\t\t61:\t&Foo{},\n+\t\t\t\t\t\t\t71:\t&Bar{},\n+\t\t\t\t\t\t\t11:\t&Baz{whatever: \"no, it's Go\"}}}},\n+\t\t\t\t\t\tbang: &Bar{foo: []*Foo{\n+\t\t\t\t\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\t\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t\t\t\t\t0:\t&Foo{},\n+\t\t\t\t\t\t\t\t\t-2:\t&Bar{},\n+\t\t\t\t\t\t\t\t\t-11:\t&Baz{whatever: \"we need to go deeper\"}}}},\n+\t\t\t\t\t\t\t\tbang: &Bar{foo: []*Foo{\n+\t\t\t\t\t\t\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\t\t\t\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t\t\t\t\t\t\t-2:\t&Foo{},\n+\t\t\t\t\t\t\t\t\t\t\t-5:\t&Bar{},\n+\t\t\t\t\t\t\t\t\t\t\t-7:\t&Baz{whatever: \"are you serious?\"}}}},\n+\t\t\t\t\t\t\t\t\t\tbang:\t&Bar{foo: []*Foo{}}},\n+\t\t\t\t\t\t\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\t\t\t\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t\t\t\t\t\t\t-100:\t&Foo{},\n+\t\t\t\t\t\t\t\t\t\t\t50:\t&Bar{},\n+\t\t\t\t\t\t\t\t\t\t\t20:\t&Baz{whatever: \"na, not really ...\"}}}},\n+\t\t\t\t\t\t\t\t\t\tbang:\t&Bar{foo: []*Foo{}}}}}}}}},\n+\t\t\t\t\t&Foo{bar: &Bar{baz: &Baz{\n+\t\t\t\t\t\tentries: map[int]interface{}{\n+\t\t\t\t\t\t\t2:\t&Foo{},\n+\t\t\t\t\t\t\t1:\t&Bar{},\n+\t\t\t\t\t\t\t-1:\t&Baz{whatever: \"... it's just a test.\"}}}},\n+\t\t\t\t\t\tbang:\t&Bar{foo: []*Foo{}}}}}}}}}\n+}\n+\n+func TestElaborate(t *testing.T) {\n+\ta := newFoo()\n+\tb := newFoo()\n+\n+\tif err := deepequal.Check(a, b); err != nil {\n+\t\tt.Errorf(\"expected nil, saw %v\", err)\n+\t}\n+}"}, {"sha": "0e5a23d88605b9ce0a96e3833f80d4f3e3ad2a2e", "filename": "libgo/go/go/printer/testdata/slow.input", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Ftestdata%2Fslow.input?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,85 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package deepequal_test\n+\n+import (\n+        \"testing\"\n+        \"google3/spam/archer/frontend/deepequal\"\n+)\n+\n+func TestTwoNilValues(t *testing.T) {\n+        if err := deepequal.Check(nil, nil); err != nil {\n+                t.Errorf(\"expected nil, saw %v\", err)\n+        }\n+}\n+\n+type Foo struct {\n+        bar *Bar\n+        bang *Bar\n+}\n+\n+type Bar struct {\n+        baz *Baz\n+        foo []*Foo\n+}\n+\n+type Baz struct {\n+        entries  map[int]interface{}\n+        whatever string\n+}\n+\n+func newFoo() (*Foo) {\n+return &Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+42: &Foo{},\n+21: &Bar{},\n+11: &Baz{ whatever: \"it's just a test\" }}}},\n+        bang: &Bar{foo: []*Foo{\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+43: &Foo{},\n+22: &Bar{},\n+13: &Baz{ whatever: \"this is nuts\" }}}},\n+        bang: &Bar{foo: []*Foo{\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+61: &Foo{},\n+71: &Bar{},\n+11: &Baz{ whatever: \"no, it's Go\" }}}},\n+        bang: &Bar{foo: []*Foo{\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+0: &Foo{},\n+-2: &Bar{},\n+-11: &Baz{ whatever: \"we need to go deeper\" }}}},\n+        bang: &Bar{foo: []*Foo{\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+-2: &Foo{},\n+-5: &Bar{},\n+-7: &Baz{ whatever: \"are you serious?\" }}}},\n+        bang: &Bar{foo: []*Foo{}}},\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+-100: &Foo{},\n+50: &Bar{},\n+20: &Baz{ whatever: \"na, not really ...\" }}}},\n+        bang: &Bar{foo: []*Foo{}}}}}}}}},\n+&Foo{bar: &Bar{ baz: &Baz{\n+entries: map[int]interface{}{\n+2: &Foo{},\n+1: &Bar{},\n+-1: &Baz{ whatever: \"... it's just a test.\" }}}},\n+        bang: &Bar{foo: []*Foo{}}}}}}}}}\n+}\n+\n+func TestElaborate(t *testing.T) {\n+        a := newFoo()\n+        b := newFoo()\n+\n+        if err := deepequal.Check(a, b); err != nil {\n+                t.Errorf(\"expected nil, saw %v\", err)\n+        }\n+}"}, {"sha": "59fed9dffc6bfe919238bd3b9eb1671dd855fb87", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -23,7 +23,7 @@ package scanner\n import (\n \t\"bytes\"\n \t\"go/token\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"strconv\"\n \t\"unicode\"\n \t\"utf8\"\n@@ -118,7 +118,7 @@ func (S *Scanner) Init(file *token.File, src []byte, err ErrorHandler, mode uint\n \t\tpanic(\"file size does not match src len\")\n \t}\n \tS.file = file\n-\tS.dir, _ = path.Split(file.Name())\n+\tS.dir, _ = filepath.Split(file.Name())\n \tS.src = src\n \tS.err = err\n \tS.mode = mode\n@@ -177,13 +177,13 @@ var prefix = []byte(\"//line \")\n func (S *Scanner) interpretLineComment(text []byte) {\n \tif bytes.HasPrefix(text, prefix) {\n \t\t// get filename and line number, if any\n-\t\tif i := bytes.Index(text, []byte{':'}); i > 0 {\n+\t\tif i := bytes.LastIndex(text, []byte{':'}); i > 0 {\n \t\t\tif line, err := strconv.Atoi(string(text[i+1:])); err == nil && line > 0 {\n \t\t\t\t// valid //line filename:line comment;\n-\t\t\t\tfilename := path.Clean(string(text[len(prefix):i]))\n-\t\t\t\tif filename[0] != '/' {\n+\t\t\t\tfilename := filepath.Clean(string(text[len(prefix):i]))\n+\t\t\t\tif !filepath.IsAbs(filename) {\n \t\t\t\t\t// make filename relative to current directory\n-\t\t\t\t\tfilename = path.Join(S.dir, filename)\n+\t\t\t\t\tfilename = filepath.Join(S.dir, filename)\n \t\t\t\t}\n \t\t\t\t// update scanner position\n \t\t\t\tS.file.AddLineInfo(S.lineOffset, filename, line-1) // -1 since comment applies to next line"}, {"sha": "93f34581b7fc6e22be5b851018b2e1810b3d589e", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 28, "deletions": 17, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,6 +7,8 @@ package scanner\n import (\n \t\"go/token\"\n \t\"os\"\n+\t\"path/filepath\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -443,32 +445,41 @@ func TestSemis(t *testing.T) {\n \t}\n }\n \n-\n-var segments = []struct {\n+type segment struct {\n \tsrcline  string // a line of source text\n \tfilename string // filename for current token\n \tline     int    // line number for current token\n-}{\n+}\n+\n+var segments = []segment{\n \t// exactly one token per line since the test consumes one token per segment\n-\t{\"  line1\", \"dir/TestLineComments\", 1},\n-\t{\"\\nline2\", \"dir/TestLineComments\", 2},\n-\t{\"\\nline3  //line File1.go:100\", \"dir/TestLineComments\", 3}, // bad line comment, ignored\n-\t{\"\\nline4\", \"dir/TestLineComments\", 4},\n-\t{\"\\n//line File1.go:100\\n  line100\", \"dir/File1.go\", 100},\n-\t{\"\\n//line File2.go:200\\n  line200\", \"dir/File2.go\", 200},\n+\t{\"  line1\", filepath.Join(\"dir\", \"TestLineComments\"), 1},\n+\t{\"\\nline2\", filepath.Join(\"dir\", \"TestLineComments\"), 2},\n+\t{\"\\nline3  //line File1.go:100\", filepath.Join(\"dir\", \"TestLineComments\"), 3}, // bad line comment, ignored\n+\t{\"\\nline4\", filepath.Join(\"dir\", \"TestLineComments\"), 4},\n+\t{\"\\n//line File1.go:100\\n  line100\", filepath.Join(\"dir\", \"File1.go\"), 100},\n+\t{\"\\n//line File2.go:200\\n  line200\", filepath.Join(\"dir\", \"File2.go\"), 200},\n \t{\"\\n//line :1\\n  line1\", \"dir\", 1},\n-\t{\"\\n//line foo:42\\n  line42\", \"dir/foo\", 42},\n-\t{\"\\n //line foo:42\\n  line44\", \"dir/foo\", 44},           // bad line comment, ignored\n-\t{\"\\n//line foo 42\\n  line46\", \"dir/foo\", 46},            // bad line comment, ignored\n-\t{\"\\n//line foo:42 extra text\\n  line48\", \"dir/foo\", 48}, // bad line comment, ignored\n-\t{\"\\n//line /bar:42\\n  line42\", \"/bar\", 42},\n-\t{\"\\n//line ./foo:42\\n  line42\", \"dir/foo\", 42},\n-\t{\"\\n//line a/b/c/File1.go:100\\n  line100\", \"dir/a/b/c/File1.go\", 100},\n+\t{\"\\n//line foo:42\\n  line42\", filepath.Join(\"dir\", \"foo\"), 42},\n+\t{\"\\n //line foo:42\\n  line44\", filepath.Join(\"dir\", \"foo\"), 44},           // bad line comment, ignored\n+\t{\"\\n//line foo 42\\n  line46\", filepath.Join(\"dir\", \"foo\"), 46},            // bad line comment, ignored\n+\t{\"\\n//line foo:42 extra text\\n  line48\", filepath.Join(\"dir\", \"foo\"), 48}, // bad line comment, ignored\n+\t{\"\\n//line /bar:42\\n  line42\", string(filepath.Separator) + \"bar\", 42},\n+\t{\"\\n//line ./foo:42\\n  line42\", filepath.Join(\"dir\", \"foo\"), 42},\n+\t{\"\\n//line a/b/c/File1.go:100\\n  line100\", filepath.Join(\"dir\", \"a\", \"b\", \"c\", \"File1.go\"), 100},\n+}\n+\n+var winsegments = []segment{\n+\t{\"\\n//line c:\\\\dir\\\\File1.go:100\\n  line100\", \"c:\\\\dir\\\\File1.go\", 100},\n }\n \n \n // Verify that comments of the form \"//line filename:line\" are interpreted correctly.\n func TestLineComments(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tsegments = append(segments, winsegments...)\n+\t}\n+\n \t// make source\n \tvar src string\n \tfor _, e := range segments {\n@@ -477,7 +488,7 @@ func TestLineComments(t *testing.T) {\n \n \t// verify scan\n \tvar S Scanner\n-\tfile := fset.AddFile(\"dir/TestLineComments\", fset.Base(), len(src))\n+\tfile := fset.AddFile(filepath.Join(\"dir\", \"TestLineComments\"), fset.Base(), len(src))\n \tS.Init(file, []byte(src), nil, 0)\n \tfor _, s := range segments {\n \t\tp, _, lit := S.Scan()"}, {"sha": "bd24f4ca42dc3d911a8a4a12897d4e8d77211f38", "filename": "libgo/go/go/typechecker/scope.go", "status": "modified", "additions": 14, "deletions": 58, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Fscope.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,15 +2,15 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// This file implements scope support functions.\n+// DEPRECATED FILE - WILL GO AWAY EVENTUALLY.\n+//\n+// Scope handling is now done in go/parser.\n+// The functionality here is only present to\n+// keep the typechecker running for now.\n \n package typechecker\n \n-import (\n-\t\"fmt\"\n-\t\"go/ast\"\n-\t\"go/token\"\n-)\n+import \"go/ast\"\n \n \n func (tc *typechecker) openScope() *ast.Scope {\n@@ -24,52 +24,25 @@ func (tc *typechecker) closeScope() {\n }\n \n \n-// objPos computes the source position of the declaration of an object name.\n-// Only required for error reporting, so doesn't have to be fast.\n-func objPos(obj *ast.Object) (pos token.Pos) {\n-\tswitch d := obj.Decl.(type) {\n-\tcase *ast.Field:\n-\t\tfor _, n := range d.Names {\n-\t\t\tif n.Name == obj.Name {\n-\t\t\t\treturn n.Pos()\n-\t\t\t}\n-\t\t}\n-\tcase *ast.ValueSpec:\n-\t\tfor _, n := range d.Names {\n-\t\t\tif n.Name == obj.Name {\n-\t\t\t\treturn n.Pos()\n-\t\t\t}\n-\t\t}\n-\tcase *ast.TypeSpec:\n-\t\treturn d.Name.Pos()\n-\tcase *ast.FuncDecl:\n-\t\treturn d.Name.Pos()\n-\t}\n-\tif debug {\n-\t\tfmt.Printf(\"decl = %T\\n\", obj.Decl)\n-\t}\n-\tpanic(\"unreachable\")\n-}\n-\n-\n // declInScope declares an object of a given kind and name in scope and sets the object's Decl and N fields.\n // It returns the newly allocated object. If an object with the same name already exists in scope, an error\n // is reported and the object is not inserted.\n-// (Objects with _ name are always inserted into a scope without errors, but they cannot be found.)\n-func (tc *typechecker) declInScope(scope *ast.Scope, kind ast.Kind, name *ast.Ident, decl interface{}, n int) *ast.Object {\n+func (tc *typechecker) declInScope(scope *ast.Scope, kind ast.ObjKind, name *ast.Ident, decl interface{}, n int) *ast.Object {\n \tobj := ast.NewObj(kind, name.Name)\n \tobj.Decl = decl\n-\tobj.N = n\n+\t//obj.N = n\n \tname.Obj = obj\n-\tif alt := scope.Insert(obj); alt != obj {\n-\t\ttc.Errorf(name.Pos(), \"%s already declared at %s\", name.Name, objPos(alt))\n+\tif name.Name != \"_\" {\n+\t\tif alt := scope.Insert(obj); alt != obj {\n+\t\t\ttc.Errorf(name.Pos(), \"%s already declared at %s\", name.Name, tc.fset.Position(alt.Pos()).String())\n+\t\t}\n \t}\n \treturn obj\n }\n \n \n // decl is the same as declInScope(tc.topScope, ...)\n-func (tc *typechecker) decl(kind ast.Kind, name *ast.Ident, decl interface{}, n int) *ast.Object {\n+func (tc *typechecker) decl(kind ast.ObjKind, name *ast.Ident, decl interface{}, n int) *ast.Object {\n \treturn tc.declInScope(tc.topScope, kind, name, decl, n)\n }\n \n@@ -91,7 +64,7 @@ func (tc *typechecker) find(name *ast.Ident) (obj *ast.Object) {\n \n // findField returns the object with the given name if visible in the type's scope.\n // If no such object is found, an error is reported and a bad object is returned instead.\n-func (tc *typechecker) findField(typ *ast.Type, name *ast.Ident) (obj *ast.Object) {\n+func (tc *typechecker) findField(typ *Type, name *ast.Ident) (obj *ast.Object) {\n \t// TODO(gri) This is simplistic at the moment and ignores anonymous fields.\n \tobj = typ.Scope.Lookup(name.Name)\n \tif obj == nil {\n@@ -100,20 +73,3 @@ func (tc *typechecker) findField(typ *ast.Type, name *ast.Ident) (obj *ast.Objec\n \t}\n \treturn\n }\n-\n-\n-// printScope prints the objects in a scope.\n-func printScope(scope *ast.Scope) {\n-\tfmt.Printf(\"scope %p {\", scope)\n-\tif scope != nil && len(scope.Objects) > 0 {\n-\t\tfmt.Println()\n-\t\tfor _, obj := range scope.Objects {\n-\t\t\tform := \"void\"\n-\t\t\tif obj.Type != nil {\n-\t\t\t\tform = obj.Type.Form.String()\n-\t\t\t}\n-\t\t\tfmt.Printf(\"\\t%s\\t%s\\n\", obj.Name, form)\n-\t\t}\n-\t}\n-\tfmt.Printf(\"}\\n\")\n-}"}, {"sha": "4e317f214645e164302640660f2d4c57583ae753", "filename": "libgo/go/go/typechecker/testdata/test0.src", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest0.src?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "previous_filename": "libgo/go/go/typechecker/testdata/test0.go"}, {"sha": "b5531fb9f5b62fa0d1074851df232a620dc2e117", "filename": "libgo/go/go/typechecker/testdata/test1.src", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest1.src?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,7 +7,7 @@\n package P1\n \n const (\n-\tc1         /* ERROR \"missing initializer\" */\n+\tc1 = 0\n \tc2     int = 0\n \tc3, c4 = 0\n )", "previous_filename": "libgo/go/go/typechecker/testdata/test1.go"}, {"sha": "2e1a9fa8f5b26dd9891de0a509b7845da93870bc", "filename": "libgo/go/go/typechecker/testdata/test3.src", "status": "renamed", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest3.src?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -27,8 +27,11 @@ func (T) m1 /* ERROR \"already declared\" */ ()    {}\n \n func (x *T) m2(u, x /* ERROR \"already declared\" */ int)               {}\n func (x *T) m3(a, b, c int) (u, x /* ERROR \"already declared\" */ int) {}\n-func (T) _(x, x /* ERROR \"already declared\" */ int)                   {}\n-func (T) _() (x, x /* ERROR \"already declared\" */ int)                {}\n+// The following are disabled for now because the typechecker\n+// in in the process of being rewritten and cannot handle them\n+// at the moment\n+//func (T) _(x, x /* \"already declared\" */ int)                   {}\n+//func (T) _() (x, x /* \"already declared\" */ int)                {}\n \n //func (PT) _() {}\n ", "previous_filename": "libgo/go/go/typechecker/testdata/test3.go"}, {"sha": "94d3558f9cdb21b10ed81ea3ea6b7aa78b4d76e3", "filename": "libgo/go/go/typechecker/testdata/test4.src", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftestdata%2Ftest4.src?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,5 +7,5 @@\n package P4\n \n const (\n-\tc0 /* ERROR \"missing initializer\" */\n+\tc0 = 0\n )", "previous_filename": "libgo/go/go/typechecker/testdata/test4.go"}, {"sha": "62b4e9d3e4ad57eb57ec98319ee1da70a2c39563", "filename": "libgo/go/go/typechecker/type.go", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftype.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package typechecker\n+\n+import \"go/ast\"\n+\n+\n+// A Type represents a Go type.\n+type Type struct {\n+\tForm     Form\n+\tObj      *ast.Object // corresponding type name, or nil\n+\tScope    *ast.Scope  // fields and methods, always present\n+\tN        uint        // basic type id, array length, number of function results, or channel direction\n+\tKey, Elt *Type       // map key and array, pointer, slice, map or channel element\n+\tParams   *ast.Scope  // function (receiver, input and result) parameters, tuple expressions (results of function calls), or nil\n+\tExpr     ast.Expr    // corresponding AST expression\n+}\n+\n+\n+// NewType creates a new type of a given form.\n+func NewType(form Form) *Type {\n+\treturn &Type{Form: form, Scope: ast.NewScope(nil)}\n+}\n+\n+\n+// Form describes the form of a type.\n+type Form int\n+\n+// The list of possible type forms.\n+const (\n+\tBadType    Form = iota // for error handling\n+\tUnresolved             // type not fully setup\n+\tBasic\n+\tArray\n+\tStruct\n+\tPointer\n+\tFunction\n+\tMethod\n+\tInterface\n+\tSlice\n+\tMap\n+\tChannel\n+\tTuple\n+)\n+\n+\n+var formStrings = [...]string{\n+\tBadType:    \"badType\",\n+\tUnresolved: \"unresolved\",\n+\tBasic:      \"basic\",\n+\tArray:      \"array\",\n+\tStruct:     \"struct\",\n+\tPointer:    \"pointer\",\n+\tFunction:   \"function\",\n+\tMethod:     \"method\",\n+\tInterface:  \"interface\",\n+\tSlice:      \"slice\",\n+\tMap:        \"map\",\n+\tChannel:    \"channel\",\n+\tTuple:      \"tuple\",\n+}\n+\n+\n+func (form Form) String() string { return formStrings[form] }\n+\n+\n+// The list of basic type id's.\n+const (\n+\tBool = iota\n+\tByte\n+\tUint\n+\tInt\n+\tFloat\n+\tComplex\n+\tUintptr\n+\tString\n+\n+\tUint8\n+\tUint16\n+\tUint32\n+\tUint64\n+\n+\tInt8\n+\tInt16\n+\tInt32\n+\tInt64\n+\n+\tFloat32\n+\tFloat64\n+\n+\tComplex64\n+\tComplex128\n+\n+\t// TODO(gri) ideal types are missing\n+)\n+\n+\n+var BasicTypes = map[uint]string{\n+\tBool:    \"bool\",\n+\tByte:    \"byte\",\n+\tUint:    \"uint\",\n+\tInt:     \"int\",\n+\tFloat:   \"float\",\n+\tComplex: \"complex\",\n+\tUintptr: \"uintptr\",\n+\tString:  \"string\",\n+\n+\tUint8:  \"uint8\",\n+\tUint16: \"uint16\",\n+\tUint32: \"uint32\",\n+\tUint64: \"uint64\",\n+\n+\tInt8:  \"int8\",\n+\tInt16: \"int16\",\n+\tInt32: \"int32\",\n+\tInt64: \"int64\",\n+\n+\tFloat32: \"float32\",\n+\tFloat64: \"float64\",\n+\n+\tComplex64:  \"complex64\",\n+\tComplex128: \"complex128\",\n+}"}, {"sha": "4fc5647f0d5d055ab3b8b3115a336e0e7914a219", "filename": "libgo/go/go/typechecker/typechecker.go", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -65,6 +65,7 @@ type typechecker struct {\n \tfset *token.FileSet\n \tscanner.ErrorVector\n \timporter Importer\n+\tglobals  []*ast.Object        // list of global objects\n \ttopScope *ast.Scope           // current top-most scope\n \tcyclemap map[*ast.Object]bool // for cycle detection\n \tiota     int                  // current value of iota\n@@ -94,7 +95,7 @@ phase 1: declare all global objects; also collect all function and method declar\n \t- report global double declarations\n \n phase 2: bind methods to their receiver base types\n-\t- received base types must be declared in the package, thus for\n+\t- receiver base types must be declared in the package, thus for\n \t  each method a corresponding (unresolved) type must exist\n \t- report method double declarations and errors with base types\n \n@@ -142,16 +143,16 @@ func (tc *typechecker) checkPackage(pkg *ast.Package) {\n \t}\n \n \t// phase 3: resolve all global objects\n-\t// (note that objects with _ name are also in the scope)\n \ttc.cyclemap = make(map[*ast.Object]bool)\n-\tfor _, obj := range tc.topScope.Objects {\n+\tfor _, obj := range tc.globals {\n \t\ttc.resolve(obj)\n \t}\n \tassert(len(tc.cyclemap) == 0)\n \n \t// 4: sequentially typecheck function and method bodies\n \tfor _, f := range funcs {\n-\t\ttc.checkBlock(f.Body.List, f.Name.Obj.Type)\n+\t\tftype, _ := f.Name.Obj.Type.(*Type)\n+\t\ttc.checkBlock(f.Body.List, ftype)\n \t}\n \n \tpkg.Scope = tc.topScope\n@@ -183,11 +184,11 @@ func (tc *typechecker) declGlobal(global ast.Decl) {\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t\tfor _, name := range s.Names {\n-\t\t\t\t\t\ttc.decl(ast.Con, name, s, iota)\n+\t\t\t\t\t\ttc.globals = append(tc.globals, tc.decl(ast.Con, name, s, iota))\n \t\t\t\t\t}\n \t\t\t\tcase token.VAR:\n \t\t\t\t\tfor _, name := range s.Names {\n-\t\t\t\t\t\ttc.decl(ast.Var, name, s, 0)\n+\t\t\t\t\t\ttc.globals = append(tc.globals, tc.decl(ast.Var, name, s, 0))\n \t\t\t\t\t}\n \t\t\t\tdefault:\n \t\t\t\t\tpanic(\"unreachable\")\n@@ -196,9 +197,10 @@ func (tc *typechecker) declGlobal(global ast.Decl) {\n \t\t\t\tiota++\n \t\t\tcase *ast.TypeSpec:\n \t\t\t\tobj := tc.decl(ast.Typ, s.Name, s, 0)\n+\t\t\t\ttc.globals = append(tc.globals, obj)\n \t\t\t\t// give all type objects an unresolved type so\n \t\t\t\t// that we can collect methods in the type scope\n-\t\t\t\ttyp := ast.NewType(ast.Unresolved)\n+\t\t\t\ttyp := NewType(Unresolved)\n \t\t\t\tobj.Type = typ\n \t\t\t\ttyp.Obj = obj\n \t\t\tdefault:\n@@ -208,7 +210,7 @@ func (tc *typechecker) declGlobal(global ast.Decl) {\n \n \tcase *ast.FuncDecl:\n \t\tif d.Recv == nil {\n-\t\t\ttc.decl(ast.Fun, d.Name, d, 0)\n+\t\t\ttc.globals = append(tc.globals, tc.decl(ast.Fun, d.Name, d, 0))\n \t\t}\n \n \tdefault:\n@@ -239,8 +241,8 @@ func (tc *typechecker) bindMethod(method *ast.FuncDecl) {\n \t\t} else if obj.Kind != ast.Typ {\n \t\t\ttc.Errorf(name.Pos(), \"invalid receiver: %s is not a type\", name.Name)\n \t\t} else {\n-\t\t\ttyp := obj.Type\n-\t\t\tassert(typ.Form == ast.Unresolved)\n+\t\t\ttyp := obj.Type.(*Type)\n+\t\t\tassert(typ.Form == Unresolved)\n \t\t\tscope = typ.Scope\n \t\t}\n \t}\n@@ -261,7 +263,7 @@ func (tc *typechecker) bindMethod(method *ast.FuncDecl) {\n func (tc *typechecker) resolve(obj *ast.Object) {\n \t// check for declaration cycles\n \tif tc.cyclemap[obj] {\n-\t\ttc.Errorf(objPos(obj), \"illegal cycle in declaration of %s\", obj.Name)\n+\t\ttc.Errorf(obj.Pos(), \"illegal cycle in declaration of %s\", obj.Name)\n \t\tobj.Kind = ast.Bad\n \t\treturn\n \t}\n@@ -271,7 +273,7 @@ func (tc *typechecker) resolve(obj *ast.Object) {\n \t}()\n \n \t// resolve non-type objects\n-\ttyp := obj.Type\n+\ttyp, _ := obj.Type.(*Type)\n \tif typ == nil {\n \t\tswitch obj.Kind {\n \t\tcase ast.Bad:\n@@ -282,12 +284,12 @@ func (tc *typechecker) resolve(obj *ast.Object) {\n \n \t\tcase ast.Var:\n \t\t\ttc.declVar(obj)\n-\t\t\t//obj.Type = tc.typeFor(nil, obj.Decl.(*ast.ValueSpec).Type, false)\n+\t\t\tobj.Type = tc.typeFor(nil, obj.Decl.(*ast.ValueSpec).Type, false)\n \n \t\tcase ast.Fun:\n-\t\t\tobj.Type = ast.NewType(ast.Function)\n+\t\t\tobj.Type = NewType(Function)\n \t\t\tt := obj.Decl.(*ast.FuncDecl).Type\n-\t\t\ttc.declSignature(obj.Type, nil, t.Params, t.Results)\n+\t\t\ttc.declSignature(obj.Type.(*Type), nil, t.Params, t.Results)\n \n \t\tdefault:\n \t\t\t// type objects have non-nil types when resolve is called\n@@ -300,32 +302,34 @@ func (tc *typechecker) resolve(obj *ast.Object) {\n \t}\n \n \t// resolve type objects\n-\tif typ.Form == ast.Unresolved {\n+\tif typ.Form == Unresolved {\n \t\ttc.typeFor(typ, typ.Obj.Decl.(*ast.TypeSpec).Type, false)\n \n \t\t// provide types for all methods\n \t\tfor _, obj := range typ.Scope.Objects {\n \t\t\tif obj.Kind == ast.Fun {\n \t\t\t\tassert(obj.Type == nil)\n-\t\t\t\tobj.Type = ast.NewType(ast.Method)\n+\t\t\t\tobj.Type = NewType(Method)\n \t\t\t\tf := obj.Decl.(*ast.FuncDecl)\n \t\t\t\tt := f.Type\n-\t\t\t\ttc.declSignature(obj.Type, f.Recv, t.Params, t.Results)\n+\t\t\t\ttc.declSignature(obj.Type.(*Type), f.Recv, t.Params, t.Results)\n \t\t\t}\n \t\t}\n \t}\n }\n \n \n-func (tc *typechecker) checkBlock(body []ast.Stmt, ftype *ast.Type) {\n+func (tc *typechecker) checkBlock(body []ast.Stmt, ftype *Type) {\n \ttc.openScope()\n \tdefer tc.closeScope()\n \n \t// inject function/method parameters into block scope, if any\n \tif ftype != nil {\n \t\tfor _, par := range ftype.Params.Objects {\n-\t\t\tobj := tc.topScope.Insert(par)\n-\t\t\tassert(obj == par) // ftype has no double declarations\n+\t\t\tif par.Name != \"_\" {\n+\t\t\t\tobj := tc.topScope.Insert(par)\n+\t\t\t\tassert(obj == par) // ftype has no double declarations\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -362,16 +366,16 @@ func (tc *typechecker) declFields(scope *ast.Scope, fields *ast.FieldList, ref b\n }\n \n \n-func (tc *typechecker) declSignature(typ *ast.Type, recv, params, results *ast.FieldList) {\n-\tassert((typ.Form == ast.Method) == (recv != nil))\n+func (tc *typechecker) declSignature(typ *Type, recv, params, results *ast.FieldList) {\n+\tassert((typ.Form == Method) == (recv != nil))\n \ttyp.Params = ast.NewScope(nil)\n \ttc.declFields(typ.Params, recv, true)\n \ttc.declFields(typ.Params, params, true)\n \ttyp.N = tc.declFields(typ.Params, results, true)\n }\n \n \n-func (tc *typechecker) typeFor(def *ast.Type, x ast.Expr, ref bool) (typ *ast.Type) {\n+func (tc *typechecker) typeFor(def *Type, x ast.Expr, ref bool) (typ *Type) {\n \tx = unparen(x)\n \n \t// type name\n@@ -381,10 +385,10 @@ func (tc *typechecker) typeFor(def *ast.Type, x ast.Expr, ref bool) (typ *ast.Ty\n \t\tif obj.Kind != ast.Typ {\n \t\t\ttc.Errorf(t.Pos(), \"%s is not a type\", t.Name)\n \t\t\tif def == nil {\n-\t\t\t\ttyp = ast.NewType(ast.BadType)\n+\t\t\t\ttyp = NewType(BadType)\n \t\t\t} else {\n \t\t\t\ttyp = def\n-\t\t\t\ttyp.Form = ast.BadType\n+\t\t\t\ttyp.Form = BadType\n \t\t\t}\n \t\t\ttyp.Expr = x\n \t\t\treturn\n@@ -393,7 +397,7 @@ func (tc *typechecker) typeFor(def *ast.Type, x ast.Expr, ref bool) (typ *ast.Ty\n \t\tif !ref {\n \t\t\ttc.resolve(obj) // check for cycles even if type resolved\n \t\t}\n-\t\ttyp = obj.Type\n+\t\ttyp = obj.Type.(*Type)\n \n \t\tif def != nil {\n \t\t\t// new type declaration: copy type structure\n@@ -410,7 +414,7 @@ func (tc *typechecker) typeFor(def *ast.Type, x ast.Expr, ref bool) (typ *ast.Ty\n \t// type literal\n \ttyp = def\n \tif typ == nil {\n-\t\ttyp = ast.NewType(ast.BadType)\n+\t\ttyp = NewType(BadType)\n \t}\n \ttyp.Expr = x\n \n@@ -419,42 +423,42 @@ func (tc *typechecker) typeFor(def *ast.Type, x ast.Expr, ref bool) (typ *ast.Ty\n \t\tif debug {\n \t\t\tfmt.Println(\"qualified identifier unimplemented\")\n \t\t}\n-\t\ttyp.Form = ast.BadType\n+\t\ttyp.Form = BadType\n \n \tcase *ast.StarExpr:\n-\t\ttyp.Form = ast.Pointer\n+\t\ttyp.Form = Pointer\n \t\ttyp.Elt = tc.typeFor(nil, t.X, true)\n \n \tcase *ast.ArrayType:\n \t\tif t.Len != nil {\n-\t\t\ttyp.Form = ast.Array\n+\t\t\ttyp.Form = Array\n \t\t\t// TODO(gri) compute the real length\n \t\t\t// (this may call resolve recursively)\n \t\t\t(*typ).N = 42\n \t\t} else {\n-\t\t\ttyp.Form = ast.Slice\n+\t\t\ttyp.Form = Slice\n \t\t}\n \t\ttyp.Elt = tc.typeFor(nil, t.Elt, t.Len == nil)\n \n \tcase *ast.StructType:\n-\t\ttyp.Form = ast.Struct\n+\t\ttyp.Form = Struct\n \t\ttc.declFields(typ.Scope, t.Fields, false)\n \n \tcase *ast.FuncType:\n-\t\ttyp.Form = ast.Function\n+\t\ttyp.Form = Function\n \t\ttc.declSignature(typ, nil, t.Params, t.Results)\n \n \tcase *ast.InterfaceType:\n-\t\ttyp.Form = ast.Interface\n+\t\ttyp.Form = Interface\n \t\ttc.declFields(typ.Scope, t.Methods, true)\n \n \tcase *ast.MapType:\n-\t\ttyp.Form = ast.Map\n+\t\ttyp.Form = Map\n \t\ttyp.Key = tc.typeFor(nil, t.Key, true)\n \t\ttyp.Elt = tc.typeFor(nil, t.Value, true)\n \n \tcase *ast.ChanType:\n-\t\ttyp.Form = ast.Channel\n+\t\ttyp.Form = Channel\n \t\ttyp.N = uint(t.Dir)\n \t\ttyp.Elt = tc.typeFor(nil, t.Value, true)\n "}, {"sha": "3988ff1680b9bdac9929f1658d9651dda4a733d1", "filename": "libgo/go/go/typechecker/typechecker_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Ftypechecker_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -93,7 +93,7 @@ func expectedErrors(t *testing.T, pkg *ast.Package) (list scanner.ErrorList) {\n \n \n func testFilter(f *os.FileInfo) bool {\n-\treturn strings.HasSuffix(f.Name, \".go\") && f.Name[0] != '.'\n+\treturn strings.HasSuffix(f.Name, \".src\") && f.Name[0] != '.'\n }\n \n "}, {"sha": "cf4434993e126363aeff7029747489b2f37280f7", "filename": "libgo/go/go/typechecker/universe.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftypechecker%2Funiverse.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -24,8 +24,8 @@ func init() {\n \tUniverse = ast.NewScope(nil)\n \n \t// basic types\n-\tfor n, name := range ast.BasicTypes {\n-\t\ttyp := ast.NewType(ast.Basic)\n+\tfor n, name := range BasicTypes {\n+\t\ttyp := NewType(Basic)\n \t\ttyp.N = n\n \t\tobj := ast.NewObj(ast.Typ, name)\n \t\tobj.Type = typ"}, {"sha": "28042ccaa3a2db8a815eaa9ac079797fd6207eca", "filename": "libgo/go/gob/codec_test.go", "status": "modified", "additions": 34, "deletions": 27, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fcodec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fcodec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fcodec_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -50,15 +50,15 @@ func testError(t *testing.T) {\n func TestUintCodec(t *testing.T) {\n \tdefer testError(t)\n \tb := new(bytes.Buffer)\n-\tencState := newEncoderState(nil, b)\n+\tencState := newEncoderState(b)\n \tfor _, tt := range encodeT {\n \t\tb.Reset()\n \t\tencState.encodeUint(tt.x)\n \t\tif !bytes.Equal(tt.b, b.Bytes()) {\n \t\t\tt.Errorf(\"encodeUint: %#x encode: expected % x got % x\", tt.x, tt.b, b.Bytes())\n \t\t}\n \t}\n-\tdecState := newDecodeState(nil, b)\n+\tdecState := newDecodeState(b)\n \tfor u := uint64(0); ; u = (u + 1) * 7 {\n \t\tb.Reset()\n \t\tencState.encodeUint(u)\n@@ -75,9 +75,9 @@ func TestUintCodec(t *testing.T) {\n func verifyInt(i int64, t *testing.T) {\n \tdefer testError(t)\n \tvar b = new(bytes.Buffer)\n-\tencState := newEncoderState(nil, b)\n+\tencState := newEncoderState(b)\n \tencState.encodeInt(i)\n-\tdecState := newDecodeState(nil, b)\n+\tdecState := newDecodeState(b)\n \tdecState.buf = make([]byte, 8)\n \tj := decState.decodeInt()\n \tif i != j {\n@@ -111,9 +111,16 @@ var complexResult = []byte{0x07, 0xFE, 0x31, 0x40, 0xFE, 0x33, 0x40}\n // The result of encoding \"hello\" with field number 7\n var bytesResult = []byte{0x07, 0x05, 'h', 'e', 'l', 'l', 'o'}\n \n-func newencoderState(b *bytes.Buffer) *encoderState {\n+func newDecodeState(buf *bytes.Buffer) *decoderState {\n+\td := new(decoderState)\n+\td.b = buf\n+\td.buf = make([]byte, uint64Size)\n+\treturn d\n+}\n+\n+func newEncoderState(b *bytes.Buffer) *encoderState {\n \tb.Reset()\n-\tstate := newEncoderState(nil, b)\n+\tstate := &encoderState{enc: nil, b: b}\n \tstate.fieldnum = -1\n \treturn state\n }\n@@ -127,7 +134,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t{\n \t\tdata := struct{ a bool }{true}\n \t\tinstr := &encInstr{encBool, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(boolResult, b.Bytes()) {\n \t\t\tt.Errorf(\"bool enc instructions: expected % x got % x\", boolResult, b.Bytes())\n@@ -139,7 +146,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a int }{17}\n \t\tinstr := &encInstr{encInt, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int enc instructions: expected % x got % x\", signedResult, b.Bytes())\n@@ -151,7 +158,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a uint }{17}\n \t\tinstr := &encInstr{encUint, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n@@ -163,7 +170,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a int8 }{17}\n \t\tinstr := &encInstr{encInt8, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int8 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n@@ -175,7 +182,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a uint8 }{17}\n \t\tinstr := &encInstr{encUint8, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint8 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n@@ -187,7 +194,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a int16 }{17}\n \t\tinstr := &encInstr{encInt16, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int16 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n@@ -199,7 +206,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a uint16 }{17}\n \t\tinstr := &encInstr{encUint16, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint16 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n@@ -211,7 +218,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a int32 }{17}\n \t\tinstr := &encInstr{encInt32, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int32 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n@@ -223,7 +230,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a uint32 }{17}\n \t\tinstr := &encInstr{encUint32, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint32 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n@@ -235,7 +242,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a int64 }{17}\n \t\tinstr := &encInstr{encInt64, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(signedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"int64 enc instructions: expected % x got % x\", signedResult, b.Bytes())\n@@ -247,7 +254,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a uint64 }{17}\n \t\tinstr := &encInstr{encUint64, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(unsignedResult, b.Bytes()) {\n \t\t\tt.Errorf(\"uint64 enc instructions: expected % x got % x\", unsignedResult, b.Bytes())\n@@ -259,7 +266,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a float32 }{17}\n \t\tinstr := &encInstr{encFloat32, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(floatResult, b.Bytes()) {\n \t\t\tt.Errorf(\"float32 enc instructions: expected % x got % x\", floatResult, b.Bytes())\n@@ -271,7 +278,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a float64 }{17}\n \t\tinstr := &encInstr{encFloat64, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(floatResult, b.Bytes()) {\n \t\t\tt.Errorf(\"float64 enc instructions: expected % x got % x\", floatResult, b.Bytes())\n@@ -283,7 +290,7 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a []byte }{[]byte(\"hello\")}\n \t\tinstr := &encInstr{encUint8Array, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(bytesResult, b.Bytes()) {\n \t\t\tt.Errorf(\"bytes enc instructions: expected % x got % x\", bytesResult, b.Bytes())\n@@ -295,15 +302,15 @@ func TestScalarEncInstructions(t *testing.T) {\n \t\tb.Reset()\n \t\tdata := struct{ a string }{\"hello\"}\n \t\tinstr := &encInstr{encString, 6, 0, 0}\n-\t\tstate := newencoderState(b)\n+\t\tstate := newEncoderState(b)\n \t\tinstr.op(instr, state, unsafe.Pointer(&data))\n \t\tif !bytes.Equal(bytesResult, b.Bytes()) {\n \t\t\tt.Errorf(\"string enc instructions: expected % x got % x\", bytesResult, b.Bytes())\n \t\t}\n \t}\n }\n \n-func execDec(typ string, instr *decInstr, state *decodeState, t *testing.T, p unsafe.Pointer) {\n+func execDec(typ string, instr *decInstr, state *decoderState, t *testing.T, p unsafe.Pointer) {\n \tdefer testError(t)\n \tv := int(state.decodeUint())\n \tif v+state.fieldnum != 6 {\n@@ -313,9 +320,9 @@ func execDec(typ string, instr *decInstr, state *decodeState, t *testing.T, p un\n \tstate.fieldnum = 6\n }\n \n-func newDecodeStateFromData(data []byte) *decodeState {\n+func newDecodeStateFromData(data []byte) *decoderState {\n \tb := bytes.NewBuffer(data)\n-\tstate := newDecodeState(nil, b)\n+\tstate := newDecodeState(b)\n \tstate.fieldnum = -1\n \treturn state\n }\n@@ -997,9 +1004,9 @@ func TestInvalidField(t *testing.T) {\n \tvar bad0 Bad0\n \tbad0.CH = make(chan int)\n \tb := new(bytes.Buffer)\n-\tvar nilEncoder *Encoder\n-\terr := nilEncoder.encode(b, reflect.NewValue(&bad0), userType(reflect.Typeof(&bad0)))\n-\tif err == nil {\n+\tdummyEncoder := new(Encoder) // sufficient for this purpose.\n+\tdummyEncoder.encode(b, reflect.NewValue(&bad0), userType(reflect.Typeof(&bad0)))\n+\tif err := dummyEncoder.err; err == nil {\n \t\tt.Error(\"expected error; got none\")\n \t} else if strings.Index(err.String(), \"type\") < 0 {\n \t\tt.Error(\"expected type error; got\", err)"}, {"sha": "f8159d4ea32357fd20a69524ed9a89b2593eedc5", "filename": "libgo/go/gob/decode.go", "status": "modified", "additions": 279, "deletions": 116, "changes": 395, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecode.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -13,38 +13,47 @@ import (\n \t\"math\"\n \t\"os\"\n \t\"reflect\"\n-\t\"unicode\"\n \t\"unsafe\"\n-\t\"utf8\"\n )\n \n var (\n \terrBadUint = os.ErrorString(\"gob: encoded unsigned integer out of range\")\n \terrBadType = os.ErrorString(\"gob: unknown type id or corrupted data\")\n-\terrRange   = os.ErrorString(\"gob: internal error: field numbers out of bounds\")\n+\terrRange   = os.ErrorString(\"gob: bad data: field numbers out of bounds\")\n )\n \n-// The execution state of an instance of the decoder. A new state\n+// decoderState is the execution state of an instance of the decoder. A new state\n // is created for nested objects.\n-type decodeState struct {\n+type decoderState struct {\n \tdec *Decoder\n \t// The buffer is stored with an extra indirection because it may be replaced\n \t// if we load a type during decode (when reading an interface value).\n \tb        *bytes.Buffer\n \tfieldnum int // the last field number read.\n \tbuf      []byte\n+\tnext     *decoderState // for free list\n }\n \n // We pass the bytes.Buffer separately for easier testing of the infrastructure\n // without requiring a full Decoder.\n-func newDecodeState(dec *Decoder, buf *bytes.Buffer) *decodeState {\n-\td := new(decodeState)\n-\td.dec = dec\n+func (dec *Decoder) newDecoderState(buf *bytes.Buffer) *decoderState {\n+\td := dec.freeList\n+\tif d == nil {\n+\t\td = new(decoderState)\n+\t\td.dec = dec\n+\t\td.buf = make([]byte, uint64Size)\n+\t} else {\n+\t\tdec.freeList = d.next\n+\t}\n \td.b = buf\n-\td.buf = make([]byte, uint64Size)\n \treturn d\n }\n \n+func (dec *Decoder) freeDecoderState(d *decoderState) {\n+\td.next = dec.freeList\n+\tdec.freeList = d\n+}\n+\n func overflow(name string) os.ErrorString {\n \treturn os.ErrorString(`value for \"` + name + `\" out of range`)\n }\n@@ -85,7 +94,7 @@ func decodeUintReader(r io.Reader, buf []byte) (x uint64, width int, err os.Erro\n \n // decodeUint reads an encoded unsigned integer from state.r.\n // Does not check for overflow.\n-func (state *decodeState) decodeUint() (x uint64) {\n+func (state *decoderState) decodeUint() (x uint64) {\n \tb, err := state.b.ReadByte()\n \tif err != nil {\n \t\terror(err)\n@@ -112,15 +121,16 @@ func (state *decodeState) decodeUint() (x uint64) {\n \n // decodeInt reads an encoded signed integer from state.r.\n // Does not check for overflow.\n-func (state *decodeState) decodeInt() int64 {\n+func (state *decoderState) decodeInt() int64 {\n \tx := state.decodeUint()\n \tif x&1 != 0 {\n \t\treturn ^int64(x >> 1)\n \t}\n \treturn int64(x >> 1)\n }\n \n-type decOp func(i *decInstr, state *decodeState, p unsafe.Pointer)\n+// decOp is the signature of a decoding operator for a given type.\n+type decOp func(i *decInstr, state *decoderState, p unsafe.Pointer)\n \n // The 'instructions' of the decoding machine\n type decInstr struct {\n@@ -150,26 +160,31 @@ func decIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {\n \treturn p\n }\n \n-func ignoreUint(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// ignoreUint discards a uint value with no destination.\n+func ignoreUint(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tstate.decodeUint()\n }\n \n-func ignoreTwoUints(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// ignoreTwoUints discards a uint value with no destination. It's used to skip\n+// complex values.\n+func ignoreTwoUints(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tstate.decodeUint()\n \tstate.decodeUint()\n }\n \n-func decBool(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decBool decodes a uiint and stores it as a boolean through p.\n+func decBool(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(bool))\n \t\t}\n \t\tp = *(*unsafe.Pointer)(p)\n \t}\n-\t*(*bool)(p) = state.decodeInt() != 0\n+\t*(*bool)(p) = state.decodeUint() != 0\n }\n \n-func decInt8(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decInt8 decodes an integer and stores it as an int8 through p.\n+func decInt8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int8))\n@@ -184,7 +199,8 @@ func decInt8(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decUint8(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decUint8 decodes an unsigned integer and stores it as a uint8 through p.\n+func decUint8(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint8))\n@@ -199,7 +215,8 @@ func decUint8(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decInt16(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decInt16 decodes an integer and stores it as an int16 through p.\n+func decInt16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int16))\n@@ -214,7 +231,8 @@ func decInt16(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decUint16(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decUint16 decodes an unsigned integer and stores it as a uint16 through p.\n+func decUint16(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint16))\n@@ -229,7 +247,8 @@ func decUint16(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decInt32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decInt32 decodes an integer and stores it as an int32 through p.\n+func decInt32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int32))\n@@ -244,7 +263,8 @@ func decInt32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decUint32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decUint32 decodes an unsigned integer and stores it as a uint32 through p.\n+func decUint32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint32))\n@@ -259,7 +279,8 @@ func decUint32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decInt64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decInt64 decodes an integer and stores it as an int64 through p.\n+func decInt64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(int64))\n@@ -269,7 +290,8 @@ func decInt64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t*(*int64)(p) = int64(state.decodeInt())\n }\n \n-func decUint64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decUint64 decodes an unsigned integer and stores it as a uint64 through p.\n+func decUint64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(uint64))\n@@ -294,7 +316,9 @@ func floatFromBits(u uint64) float64 {\n \treturn math.Float64frombits(v)\n }\n \n-func storeFloat32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// storeFloat32 decodes an unsigned integer, treats it as a 32-bit floating-point\n+// number, and stores it through p. It's a helper function for float32 and complex64.\n+func storeFloat32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tv := floatFromBits(state.decodeUint())\n \tav := v\n \tif av < 0 {\n@@ -308,7 +332,9 @@ func storeFloat32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n }\n \n-func decFloat32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decFloat32 decodes an unsigned integer, treats it as a 32-bit floating-point\n+// number, and stores it through p.\n+func decFloat32(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float32))\n@@ -318,7 +344,9 @@ func decFloat32(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \tstoreFloat32(i, state, p)\n }\n \n-func decFloat64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decFloat64 decodes an unsigned integer, treats it as a 64-bit floating-point\n+// number, and stores it through p.\n+func decFloat64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(float64))\n@@ -328,8 +356,10 @@ func decFloat64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t*(*float64)(p) = floatFromBits(uint64(state.decodeUint()))\n }\n \n-// Complex numbers are just a pair of floating-point numbers, real part first.\n-func decComplex64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decComplex64 decodes a pair of unsigned integers, treats them as a\n+// pair of floating point numbers, and stores them as a complex64 through p.\n+// The real part comes first.\n+func decComplex64(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(complex64))\n@@ -340,7 +370,10 @@ func decComplex64(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \tstoreFloat32(i, state, unsafe.Pointer(uintptr(p)+uintptr(unsafe.Sizeof(float32(0)))))\n }\n \n-func decComplex128(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// decComplex128 decodes a pair of unsigned integers, treats them as a\n+// pair of floating point numbers, and stores them as a complex128 through p.\n+// The real part comes first.\n+func decComplex128(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new(complex128))\n@@ -352,8 +385,10 @@ func decComplex128(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t*(*complex128)(p) = complex(real, imag)\n }\n \n+// decUint8Array decodes byte array and stores through p a slice header\n+// describing the data.\n // uint8 arrays are encoded as an unsigned count followed by the raw bytes.\n-func decUint8Array(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+func decUint8Array(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]uint8))\n@@ -365,8 +400,10 @@ func decUint8Array(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t*(*[]uint8)(p) = b\n }\n \n+// decString decodes byte array and stores through p a string header\n+// describing the data.\n // Strings are encoded as an unsigned count followed by the raw bytes.\n-func decString(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+func decString(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tif i.indir > 0 {\n \t\tif *(*unsafe.Pointer)(p) == nil {\n \t\t\t*(*unsafe.Pointer)(p) = unsafe.Pointer(new([]byte))\n@@ -375,10 +412,18 @@ func decString(i *decInstr, state *decodeState, p unsafe.Pointer) {\n \t}\n \tb := make([]byte, state.decodeUint())\n \tstate.b.Read(b)\n-\t*(*string)(p) = string(b)\n+\t// It would be a shame to do the obvious thing here,\n+\t//\t*(*string)(p) = string(b)\n+\t// because we've already allocated the storage and this would\n+\t// allocate again and copy.  So we do this ugly hack, which is even\n+\t// even more unsafe than it looks as it depends the memory\n+\t// representation of a string matching the beginning of the memory\n+\t// representation of a byte slice (a byte slice is longer).\n+\t*(*string)(p) = *(*string)(unsafe.Pointer(&b))\n }\n \n-func ignoreUint8Array(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+// ignoreUint8Array skips over the data for a byte slice value with no destination.\n+func ignoreUint8Array(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \tb := make([]byte, state.decodeUint())\n \tstate.b.Read(b)\n }\n@@ -409,9 +454,16 @@ func allocate(rtyp reflect.Type, p uintptr, indir int) uintptr {\n \treturn *(*uintptr)(up)\n }\n \n+// decodeSingle decodes a top-level value that is not a struct and stores it through p.\n+// Such values are preceded by a zero, making them have the memory layout of a\n+// struct field (although with an illegal field number).\n func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, p uintptr) (err os.Error) {\n-\tp = allocate(ut.base, p, ut.indir)\n-\tstate := newDecodeState(dec, &dec.buf)\n+\tindir := ut.indir\n+\tif ut.isGobDecoder {\n+\t\tindir = int(ut.decIndir)\n+\t}\n+\tp = allocate(ut.base, p, indir)\n+\tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = singletonField\n \tbasep := p\n \tdelta := int(state.decodeUint())\n@@ -424,16 +476,18 @@ func (dec *Decoder) decodeSingle(engine *decEngine, ut *userTypeInfo, p uintptr)\n \t\tptr = decIndirect(ptr, instr.indir)\n \t}\n \tinstr.op(instr, state, ptr)\n+\tdec.freeDecoderState(state)\n \treturn nil\n }\n \n+// decodeSingle decodes a top-level struct and stores it through p.\n // Indir is for the value, not the type.  At the time of the call it may\n // differ from ut.indir, which was computed when the engine was built.\n // This state cannot arise for decodeSingle, which is called directly\n // from the user's value, not from the innards of an engine.\n-func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr, indir int) (err os.Error) {\n+func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr, indir int) {\n \tp = allocate(ut.base.(*reflect.StructType), p, indir)\n-\tstate := newDecodeState(dec, &dec.buf)\n+\tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = -1\n \tbasep := p\n \tfor state.b.Len() > 0 {\n@@ -457,11 +511,12 @@ func (dec *Decoder) decodeStruct(engine *decEngine, ut *userTypeInfo, p uintptr,\n \t\tinstr.op(instr, state, p)\n \t\tstate.fieldnum = fieldnum\n \t}\n-\treturn nil\n+\tdec.freeDecoderState(state)\n }\n \n-func (dec *Decoder) ignoreStruct(engine *decEngine) (err os.Error) {\n-\tstate := newDecodeState(dec, &dec.buf)\n+// ignoreStruct discards the data for a struct with no destination.\n+func (dec *Decoder) ignoreStruct(engine *decEngine) {\n+\tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = -1\n \tfor state.b.Len() > 0 {\n \t\tdelta := int(state.decodeUint())\n@@ -479,22 +534,25 @@ func (dec *Decoder) ignoreStruct(engine *decEngine) (err os.Error) {\n \t\tinstr.op(instr, state, unsafe.Pointer(nil))\n \t\tstate.fieldnum = fieldnum\n \t}\n-\treturn nil\n+\tdec.freeDecoderState(state)\n }\n \n-func (dec *Decoder) ignoreSingle(engine *decEngine) (err os.Error) {\n-\tstate := newDecodeState(dec, &dec.buf)\n+// ignoreSingle discards the data for a top-level non-struct value with no\n+// destination. It's used when calling Decode with a nil value.\n+func (dec *Decoder) ignoreSingle(engine *decEngine) {\n+\tstate := dec.newDecoderState(&dec.buf)\n \tstate.fieldnum = singletonField\n \tdelta := int(state.decodeUint())\n \tif delta != 0 {\n \t\terrorf(\"gob decode: corrupted data: non-zero delta for singleton\")\n \t}\n \tinstr := &engine.instr[singletonField]\n \tinstr.op(instr, state, unsafe.Pointer(nil))\n-\treturn nil\n+\tdec.freeDecoderState(state)\n }\n \n-func (dec *Decoder) decodeArrayHelper(state *decodeState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl os.ErrorString) {\n+// decodeArrayHelper does the work for decoding arrays and slices.\n+func (dec *Decoder) decodeArrayHelper(state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, elemIndir int, ovfl os.ErrorString) {\n \tinstr := &decInstr{elemOp, 0, elemIndir, 0, ovfl}\n \tfor i := 0; i < length; i++ {\n \t\tup := unsafe.Pointer(p)\n@@ -506,7 +564,10 @@ func (dec *Decoder) decodeArrayHelper(state *decodeState, p uintptr, elemOp decO\n \t}\n }\n \n-func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decodeState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl os.ErrorString) {\n+// decodeArray decodes an array and stores it through p, that is, p points to the zeroth element.\n+// The length is an unsigned integer preceding the elements.  Even though the length is redundant\n+// (it's part of the type), it's a useful check and is included in the encoding.\n+func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, length, indir, elemIndir int, ovfl os.ErrorString) {\n \tif indir > 0 {\n \t\tp = allocate(atyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -516,7 +577,9 @@ func (dec *Decoder) decodeArray(atyp *reflect.ArrayType, state *decodeState, p u\n \tdec.decodeArrayHelper(state, p, elemOp, elemWid, length, elemIndir, ovfl)\n }\n \n-func decodeIntoValue(state *decodeState, op decOp, indir int, v reflect.Value, ovfl os.ErrorString) reflect.Value {\n+// decodeIntoValue is a helper for map decoding.  Since maps are decoded using reflection,\n+// unlike the other items we can't use a pointer directly.\n+func decodeIntoValue(state *decoderState, op decOp, indir int, v reflect.Value, ovfl os.ErrorString) reflect.Value {\n \tinstr := &decInstr{op, 0, indir, 0, ovfl}\n \tup := unsafe.Pointer(v.UnsafeAddr())\n \tif indir > 1 {\n@@ -526,7 +589,11 @@ func decodeIntoValue(state *decodeState, op decOp, indir int, v reflect.Value, o\n \treturn v\n }\n \n-func (dec *Decoder) decodeMap(mtyp *reflect.MapType, state *decodeState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl os.ErrorString) {\n+// decodeMap decodes a map and stores its header through p.\n+// Maps are encoded as a length followed by key:value pairs.\n+// Because the internals of maps are not visible to us, we must\n+// use reflection rather than pointer magic.\n+func (dec *Decoder) decodeMap(mtyp *reflect.MapType, state *decoderState, p uintptr, keyOp, elemOp decOp, indir, keyIndir, elemIndir int, ovfl os.ErrorString) {\n \tif indir > 0 {\n \t\tp = allocate(mtyp, p, 1) // All but the last level has been allocated by dec.Indirect\n \t}\n@@ -538,7 +605,7 @@ func (dec *Decoder) decodeMap(mtyp *reflect.MapType, state *decodeState, p uintp\n \t// Maps cannot be accessed by moving addresses around the way\n \t// that slices etc. can.  We must recover a full reflection value for\n \t// the iteration.\n-\tv := reflect.NewValue(unsafe.Unreflect(mtyp, unsafe.Pointer((p)))).(*reflect.MapValue)\n+\tv := reflect.NewValue(unsafe.Unreflect(mtyp, unsafe.Pointer(p))).(*reflect.MapValue)\n \tn := int(state.decodeUint())\n \tfor i := 0; i < n; i++ {\n \t\tkey := decodeIntoValue(state, keyOp, keyIndir, reflect.MakeZero(mtyp.Key()), ovfl)\n@@ -547,21 +614,24 @@ func (dec *Decoder) decodeMap(mtyp *reflect.MapType, state *decodeState, p uintp\n \t}\n }\n \n-func (dec *Decoder) ignoreArrayHelper(state *decodeState, elemOp decOp, length int) {\n+// ignoreArrayHelper does the work for discarding arrays and slices.\n+func (dec *Decoder) ignoreArrayHelper(state *decoderState, elemOp decOp, length int) {\n \tinstr := &decInstr{elemOp, 0, 0, 0, os.ErrorString(\"no error\")}\n \tfor i := 0; i < length; i++ {\n \t\telemOp(instr, state, nil)\n \t}\n }\n \n-func (dec *Decoder) ignoreArray(state *decodeState, elemOp decOp, length int) {\n+// ignoreArray discards the data for an array value with no destination.\n+func (dec *Decoder) ignoreArray(state *decoderState, elemOp decOp, length int) {\n \tif n := state.decodeUint(); n != uint64(length) {\n \t\terrorf(\"gob: length mismatch in ignoreArray\")\n \t}\n \tdec.ignoreArrayHelper(state, elemOp, length)\n }\n \n-func (dec *Decoder) ignoreMap(state *decodeState, keyOp, elemOp decOp) {\n+// ignoreMap discards the data for a map value with no destination.\n+func (dec *Decoder) ignoreMap(state *decoderState, keyOp, elemOp decOp) {\n \tn := int(state.decodeUint())\n \tkeyInstr := &decInstr{keyOp, 0, 0, 0, os.ErrorString(\"no error\")}\n \telemInstr := &decInstr{elemOp, 0, 0, 0, os.ErrorString(\"no error\")}\n@@ -571,7 +641,9 @@ func (dec *Decoder) ignoreMap(state *decodeState, keyOp, elemOp decOp) {\n \t}\n }\n \n-func (dec *Decoder) decodeSlice(atyp *reflect.SliceType, state *decodeState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl os.ErrorString) {\n+// decodeSlice decodes a slice and stores the slice header through p.\n+// Slices are encoded as an unsigned length followed by the elements.\n+func (dec *Decoder) decodeSlice(atyp *reflect.SliceType, state *decoderState, p uintptr, elemOp decOp, elemWid uintptr, indir, elemIndir int, ovfl os.ErrorString) {\n \tn := int(uintptr(state.decodeUint()))\n \tif indir > 0 {\n \t\tup := unsafe.Pointer(p)\n@@ -590,7 +662,8 @@ func (dec *Decoder) decodeSlice(atyp *reflect.SliceType, state *decodeState, p u\n \tdec.decodeArrayHelper(state, hdrp.Data, elemOp, elemWid, n, elemIndir, ovfl)\n }\n \n-func (dec *Decoder) ignoreSlice(state *decodeState, elemOp decOp) {\n+// ignoreSlice skips over the data for a slice value with no destination.\n+func (dec *Decoder) ignoreSlice(state *decoderState, elemOp decOp) {\n \tdec.ignoreArrayHelper(state, elemOp, int(state.decodeUint()))\n }\n \n@@ -609,9 +682,10 @@ func setInterfaceValue(ivalue *reflect.InterfaceValue, value reflect.Value) {\n \tivalue.Set(value)\n }\n \n-// decodeInterface receives the name of a concrete type followed by its value.\n+// decodeInterface decodes an interface value and stores it through p.\n+// Interfaces are encoded as the name of a concrete type followed by a value.\n // If the name is empty, the value is nil and no value is sent.\n-func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decodeState, p uintptr, indir int) {\n+func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decoderState, p uintptr, indir int) {\n \t// Create an interface reflect.Value.  We need one even for the nil case.\n \tivalue := reflect.MakeZero(ityp).(*reflect.InterfaceValue)\n \t// Read the name of the concrete type.\n@@ -655,7 +729,8 @@ func (dec *Decoder) decodeInterface(ityp *reflect.InterfaceType, state *decodeSt\n \t*(*[2]uintptr)(unsafe.Pointer(p)) = ivalue.Get()\n }\n \n-func (dec *Decoder) ignoreInterface(state *decodeState) {\n+// ignoreInterface discards the data for an interface value with no destination.\n+func (dec *Decoder) ignoreInterface(state *decoderState) {\n \t// Read the name of the concrete type.\n \tb := make([]byte, state.decodeUint())\n \t_, err := state.b.Read(b)\n@@ -670,6 +745,32 @@ func (dec *Decoder) ignoreInterface(state *decodeState) {\n \tstate.b.Next(int(state.decodeUint()))\n }\n \n+// decodeGobDecoder decodes something implementing the GobDecoder interface.\n+// The data is encoded as a byte slice.\n+func (dec *Decoder) decodeGobDecoder(state *decoderState, v reflect.Value, index int) {\n+\t// Read the bytes for the value.\n+\tb := make([]byte, state.decodeUint())\n+\t_, err := state.b.Read(b)\n+\tif err != nil {\n+\t\terror(err)\n+\t}\n+\t// We know it's a GobDecoder, so just call the method directly.\n+\terr = v.Interface().(GobDecoder).GobDecode(b)\n+\tif err != nil {\n+\t\terror(err)\n+\t}\n+}\n+\n+// ignoreGobDecoder discards the data for a GobDecoder value with no destination.\n+func (dec *Decoder) ignoreGobDecoder(state *decoderState) {\n+\t// Read the bytes for the value.\n+\tb := make([]byte, state.decodeUint())\n+\t_, err := state.b.Read(b)\n+\tif err != nil {\n+\t\terror(err)\n+\t}\n+}\n+\n // Index by Go types.\n var decOpTable = [...]decOp{\n \treflect.Bool:       decBool,\n@@ -699,10 +800,14 @@ var decIgnoreOpMap = map[typeId]decOp{\n \ttComplex: ignoreTwoUints,\n }\n \n-// Return the decoding op for the base type under rt and\n+// decOpFor returns the decoding op for the base type under rt and\n // the indirection count to reach it.\n func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProgress map[reflect.Type]*decOp) (*decOp, int) {\n \tut := userType(rt)\n+\t// If the type implements GobEncoder, we handle it without further processing.\n+\tif ut.isGobDecoder {\n+\t\treturn dec.gobDecodeOpFor(ut)\n+\t}\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n \t// Return the pointer to the op we're already building.\n \tif opPtr := inProgress[rt]; opPtr != nil {\n@@ -724,7 +829,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\telemId := dec.wireType[wireId].ArrayT.Elem\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.decodeArray(t, state, uintptr(p), *elemOp, t.Elem().Size(), t.Len(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n@@ -735,7 +840,7 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\tkeyOp, keyIndir := dec.decOpFor(keyId, t.Key(), name, inProgress)\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tup := unsafe.Pointer(p)\n \t\t\t\tstate.dec.decodeMap(t, state, uintptr(up), *keyOp, *elemOp, i.indir, keyIndir, elemIndir, ovfl)\n \t\t\t}\n@@ -754,26 +859,23 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \t\t\t}\n \t\t\telemOp, elemIndir := dec.decOpFor(elemId, t.Elem(), name, inProgress)\n \t\t\tovfl := overflow(name)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.decodeSlice(t, state, uintptr(p), *elemOp, t.Elem().Size(), i.indir, elemIndir, ovfl)\n \t\t\t}\n \n \t\tcase *reflect.StructType:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n-\t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, typ)\n+\t\t\tenginePtr, err := dec.getDecEnginePtr(wireId, userType(typ))\n \t\t\tif err != nil {\n \t\t\t\terror(err)\n \t\t\t}\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs.\n-\t\t\t\terr = dec.decodeStruct(*enginePtr, userType(typ), uintptr(p), i.indir)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\terror(err)\n-\t\t\t\t}\n+\t\t\t\tdec.decodeStruct(*enginePtr, userType(typ), uintptr(p), i.indir)\n \t\t\t}\n \t\tcase *reflect.InterfaceType:\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n-\t\t\t\tdec.decodeInterface(t, state, uintptr(p), i.indir)\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\t\tstate.dec.decodeInterface(t, state, uintptr(p), i.indir)\n \t\t\t}\n \t\t}\n \t}\n@@ -783,27 +885,27 @@ func (dec *Decoder) decOpFor(wireId typeId, rt reflect.Type, name string, inProg\n \treturn &op, indir\n }\n \n-// Return the decoding op for a field that has no destination.\n+// decIgnoreOpFor returns the decoding op for a field that has no destination.\n func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \top, ok := decIgnoreOpMap[wireId]\n \tif !ok {\n \t\tif wireId == tInterface {\n \t\t\t// Special case because it's a method: the ignored item might\n \t\t\t// define types and we need to record their state in the decoder.\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n-\t\t\t\tdec.ignoreInterface(state)\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\t\tstate.dec.ignoreInterface(state)\n \t\t\t}\n \t\t\treturn op\n \t\t}\n \t\t// Special cases\n \t\twire := dec.wireType[wireId]\n \t\tswitch {\n \t\tcase wire == nil:\n-\t\t\tpanic(\"internal error: can't find ignore op for type \" + wireId.string())\n+\t\t\terrorf(\"gob: bad data: undefined type %s\", wireId.string())\n \t\tcase wire.ArrayT != nil:\n \t\t\telemId := wire.ArrayT.Elem\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.ignoreArray(state, elemOp, wire.ArrayT.Len)\n \t\t\t}\n \n@@ -812,14 +914,14 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\telemId := dec.wireType[wireId].MapT.Elem\n \t\t\tkeyOp := dec.decIgnoreOpFor(keyId)\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.ignoreMap(state, keyOp, elemOp)\n \t\t\t}\n \n \t\tcase wire.SliceT != nil:\n \t\t\telemId := wire.SliceT.Elem\n \t\t\telemOp := dec.decIgnoreOpFor(elemId)\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\tstate.dec.ignoreSlice(state, elemOp)\n \t\t\t}\n \n@@ -829,28 +931,75 @@ func (dec *Decoder) decIgnoreOpFor(wireId typeId) decOp {\n \t\t\tif err != nil {\n \t\t\t\terror(err)\n \t\t\t}\n-\t\t\top = func(i *decInstr, state *decodeState, p unsafe.Pointer) {\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n \t\t\t\t// indirect through enginePtr to delay evaluation for recursive structs\n \t\t\t\tstate.dec.ignoreStruct(*enginePtr)\n \t\t\t}\n+\n+\t\tcase wire.GobEncoderT != nil:\n+\t\t\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t\t\tstate.dec.ignoreGobDecoder(state)\n+\t\t\t}\n \t\t}\n \t}\n \tif op == nil {\n-\t\terrorf(\"ignore can't handle type %s\", wireId.string())\n+\t\terrorf(\"gob: bad data: ignore can't handle type %s\", wireId.string())\n \t}\n \treturn op\n }\n \n-// Are these two gob Types compatible?\n-// Answers the question for basic types, arrays, and slices.\n+// gobDecodeOpFor returns the op for a type that is known to implement\n+// GobDecoder.\n+func (dec *Decoder) gobDecodeOpFor(ut *userTypeInfo) (*decOp, int) {\n+\trt := ut.user\n+\tif ut.decIndir == -1 {\n+\t\trt = reflect.PtrTo(rt)\n+\t} else if ut.decIndir > 0 {\n+\t\tfor i := int8(0); i < ut.decIndir; i++ {\n+\t\t\trt = rt.(*reflect.PtrType).Elem()\n+\t\t}\n+\t}\n+\tvar op decOp\n+\top = func(i *decInstr, state *decoderState, p unsafe.Pointer) {\n+\t\t// Allocate the underlying data, but hold on to the address we have,\n+\t\t// since we need it to get to the receiver's address.\n+\t\tallocate(ut.base, uintptr(p), ut.indir)\n+\t\tvar v reflect.Value\n+\t\tif ut.decIndir == -1 {\n+\t\t\t// Need to climb up one level to turn value into pointer.\n+\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n+\t\t} else {\n+\t\t\tif ut.decIndir > 0 {\n+\t\t\t\tp = decIndirect(p, int(ut.decIndir))\n+\t\t\t}\n+\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, p))\n+\t\t}\n+\t\tstate.dec.decodeGobDecoder(state, v, methodIndex(rt, gobDecodeMethodName))\n+\t}\n+\treturn &op, int(ut.decIndir)\n+\n+}\n+\n+// compatibleType asks: Are these two gob Types compatible?\n+// Answers the question for basic types, arrays, maps and slices, plus\n+// GobEncoder/Decoder pairs.\n // Structs are considered ok; fields will be checked later.\n func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[reflect.Type]typeId) bool {\n \tif rhs, ok := inProgress[fr]; ok {\n \t\treturn rhs == fw\n \t}\n \tinProgress[fr] = fw\n-\tfr = userType(fr).base\n-\tswitch t := fr.(type) {\n+\tut := userType(fr)\n+\twire, ok := dec.wireType[fw]\n+\t// If fr is a GobDecoder, the wire type must be GobEncoder.\n+\t// And if fr is not a GobDecoder, the wire type must not be either.\n+\tif ut.isGobDecoder != (ok && wire.GobEncoderT != nil) { // the parentheses look odd but are correct.\n+\t\treturn false\n+\t}\n+\tif ut.isGobDecoder { // This test trumps all others.\n+\t\treturn true\n+\t}\n+\tswitch t := ut.base.(type) {\n \tdefault:\n \t\t// chan, etc: cannot handle.\n \t\treturn false\n@@ -869,14 +1018,12 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \tcase *reflect.InterfaceType:\n \t\treturn fw == tInterface\n \tcase *reflect.ArrayType:\n-\t\twire, ok := dec.wireType[fw]\n \t\tif !ok || wire.ArrayT == nil {\n \t\t\treturn false\n \t\t}\n \t\tarray := wire.ArrayT\n \t\treturn t.Len() == array.Len && dec.compatibleType(t.Elem(), array.Elem, inProgress)\n \tcase *reflect.MapType:\n-\t\twire, ok := dec.wireType[fw]\n \t\tif !ok || wire.MapT == nil {\n \t\t\treturn false\n \t\t}\n@@ -911,8 +1058,13 @@ func (dec *Decoder) typeString(remoteId typeId) string {\n \treturn dec.wireType[remoteId].string()\n }\n \n-\n-func (dec *Decoder) compileSingle(remoteId typeId, rt reflect.Type) (engine *decEngine, err os.Error) {\n+// compileSingle compiles the decoder engine for a non-struct top-level value, including\n+// GobDecoders.\n+func (dec *Decoder) compileSingle(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err os.Error) {\n+\trt := ut.base\n+\tif ut.isGobDecoder {\n+\t\trt = ut.user\n+\t}\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, 1) // one item\n \tname := rt.String()                // best we can do\n@@ -926,6 +1078,7 @@ func (dec *Decoder) compileSingle(remoteId typeId, rt reflect.Type) (engine *dec\n \treturn\n }\n \n+// compileIgnoreSingle compiles the decoder engine for a non-struct top-level value that will be discarded.\n func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err os.Error) {\n \tengine = new(decEngine)\n \tengine.instr = make([]decInstr, 1) // one item\n@@ -936,16 +1089,13 @@ func (dec *Decoder) compileIgnoreSingle(remoteId typeId) (engine *decEngine, err\n \treturn\n }\n \n-// Is this an exported - upper case - name?\n-func isExported(name string) bool {\n-\trune, _ := utf8.DecodeRuneInString(name)\n-\treturn unicode.IsUpper(rune)\n-}\n-\n-func (dec *Decoder) compileDec(remoteId typeId, rt reflect.Type) (engine *decEngine, err os.Error) {\n+// compileDec compiles the decoder engine for a value.  If the value is not a struct,\n+// it calls out to compileSingle.\n+func (dec *Decoder) compileDec(remoteId typeId, ut *userTypeInfo) (engine *decEngine, err os.Error) {\n+\trt := ut.base\n \tsrt, ok := rt.(*reflect.StructType)\n-\tif !ok {\n-\t\treturn dec.compileSingle(remoteId, rt)\n+\tif !ok || ut.isGobDecoder {\n+\t\treturn dec.compileSingle(remoteId, ut)\n \t}\n \tvar wireStruct *structType\n \t// Builtin types can come from global pool; the rest must be defined by the decoder.\n@@ -990,7 +1140,9 @@ func (dec *Decoder) compileDec(remoteId typeId, rt reflect.Type) (engine *decEng\n \treturn\n }\n \n-func (dec *Decoder) getDecEnginePtr(remoteId typeId, rt reflect.Type) (enginePtr **decEngine, err os.Error) {\n+// getDecEnginePtr returns the engine for the specified type.\n+func (dec *Decoder) getDecEnginePtr(remoteId typeId, ut *userTypeInfo) (enginePtr **decEngine, err os.Error) {\n+\trt := ut.base\n \tdecoderMap, ok := dec.decoderCache[rt]\n \tif !ok {\n \t\tdecoderMap = make(map[typeId]**decEngine)\n@@ -1000,19 +1152,20 @@ func (dec *Decoder) getDecEnginePtr(remoteId typeId, rt reflect.Type) (enginePtr\n \t\t// To handle recursive types, mark this engine as underway before compiling.\n \t\tenginePtr = new(*decEngine)\n \t\tdecoderMap[remoteId] = enginePtr\n-\t\t*enginePtr, err = dec.compileDec(remoteId, rt)\n+\t\t*enginePtr, err = dec.compileDec(remoteId, ut)\n \t\tif err != nil {\n \t\t\tdecoderMap[remoteId] = nil, false\n \t\t}\n \t}\n \treturn\n }\n \n-// When ignoring struct data, in effect we compile it into this type\n+// emptyStruct is the type we compile into when ignoring a struct value.\n type emptyStruct struct{}\n \n var emptyStructType = reflect.Typeof(emptyStruct{})\n \n+// getDecEnginePtr returns the engine for the specified type when the value is to be discarded.\n func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, err os.Error) {\n \tvar ok bool\n \tif enginePtr, ok = dec.ignorerCache[wireId]; !ok {\n@@ -1021,7 +1174,7 @@ func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, er\n \t\tdec.ignorerCache[wireId] = enginePtr\n \t\twire := dec.wireType[wireId]\n \t\tif wire != nil && wire.StructT != nil {\n-\t\t\t*enginePtr, err = dec.compileDec(wireId, emptyStructType)\n+\t\t\t*enginePtr, err = dec.compileDec(wireId, userType(emptyStructType))\n \t\t} else {\n \t\t\t*enginePtr, err = dec.compileIgnoreSingle(wireId)\n \t\t}\n@@ -1032,41 +1185,51 @@ func (dec *Decoder) getIgnoreEnginePtr(wireId typeId) (enginePtr **decEngine, er\n \treturn\n }\n \n-func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) (err os.Error) {\n-\tdefer catchError(&err)\n+// decodeValue decodes the data stream representing a value and stores it in val.\n+func (dec *Decoder) decodeValue(wireId typeId, val reflect.Value) {\n+\tdefer catchError(&dec.err)\n \t// If the value is nil, it means we should just ignore this item.\n \tif val == nil {\n-\t\treturn dec.decodeIgnoredValue(wireId)\n+\t\tdec.decodeIgnoredValue(wireId)\n+\t\treturn\n \t}\n \t// Dereference down to the underlying struct type.\n \tut := userType(val.Type())\n \tbase := ut.base\n \tindir := ut.indir\n-\tenginePtr, err := dec.getDecEnginePtr(wireId, base)\n-\tif err != nil {\n-\t\treturn err\n+\tif ut.isGobDecoder {\n+\t\tindir = int(ut.decIndir)\n+\t}\n+\tvar enginePtr **decEngine\n+\tenginePtr, dec.err = dec.getDecEnginePtr(wireId, ut)\n+\tif dec.err != nil {\n+\t\treturn\n \t}\n \tengine := *enginePtr\n-\tif st, ok := base.(*reflect.StructType); ok {\n+\tif st, ok := base.(*reflect.StructType); ok && !ut.isGobDecoder {\n \t\tif engine.numInstr == 0 && st.NumField() > 0 && len(dec.wireType[wireId].StructT.Field) > 0 {\n \t\t\tname := base.Name()\n-\t\t\treturn os.ErrorString(\"gob: type mismatch: no fields matched compiling decoder for \" + name)\n+\t\t\terrorf(\"gob: type mismatch: no fields matched compiling decoder for %s\", name)\n \t\t}\n-\t\treturn dec.decodeStruct(engine, ut, uintptr(val.UnsafeAddr()), indir)\n+\t\tdec.decodeStruct(engine, ut, uintptr(val.UnsafeAddr()), indir)\n+\t} else {\n+\t\tdec.decodeSingle(engine, ut, uintptr(val.UnsafeAddr()))\n \t}\n-\treturn dec.decodeSingle(engine, ut, uintptr(val.UnsafeAddr()))\n }\n \n-func (dec *Decoder) decodeIgnoredValue(wireId typeId) os.Error {\n-\tenginePtr, err := dec.getIgnoreEnginePtr(wireId)\n-\tif err != nil {\n-\t\treturn err\n+// decodeIgnoredValue decodes the data stream representing a value of the specified type and discards it.\n+func (dec *Decoder) decodeIgnoredValue(wireId typeId) {\n+\tvar enginePtr **decEngine\n+\tenginePtr, dec.err = dec.getIgnoreEnginePtr(wireId)\n+\tif dec.err != nil {\n+\t\treturn\n \t}\n \twire := dec.wireType[wireId]\n \tif wire != nil && wire.StructT != nil {\n-\t\treturn dec.ignoreStruct(*enginePtr)\n+\t\tdec.ignoreStruct(*enginePtr)\n+\t} else {\n+\t\tdec.ignoreSingle(*enginePtr)\n \t}\n-\treturn dec.ignoreSingle(*enginePtr)\n }\n \n func init() {"}, {"sha": "34364161aa3bf50ef5caa723aee93ae2df0d7066", "filename": "libgo/go/gob/decoder.go", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fdecoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fdecoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fdecoder.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -5,6 +5,7 @@\n package gob\n \n import (\n+\t\"bufio\"\n \t\"bytes\"\n \t\"io\"\n \t\"os\"\n@@ -21,7 +22,7 @@ type Decoder struct {\n \twireType     map[typeId]*wireType                    // map from remote ID to local description\n \tdecoderCache map[reflect.Type]map[typeId]**decEngine // cache of compiled engines\n \tignorerCache map[typeId]**decEngine                  // ditto for ignored objects\n-\tcountState   *decodeState                            // reads counts from wire\n+\tfreeList     *decoderState                           // list of free decoderStates; avoids reallocation\n \tcountBuf     []byte                                  // used for decoding integers while parsing messages\n \ttmp          []byte                                  // temporary storage for i/o; saves reallocating\n \terr          os.Error\n@@ -30,7 +31,7 @@ type Decoder struct {\n // NewDecoder returns a new decoder that reads from the io.Reader.\n func NewDecoder(r io.Reader) *Decoder {\n \tdec := new(Decoder)\n-\tdec.r = r\n+\tdec.r = bufio.NewReader(r)\n \tdec.wireType = make(map[typeId]*wireType)\n \tdec.decoderCache = make(map[reflect.Type]map[typeId]**decEngine)\n \tdec.ignorerCache = make(map[typeId]**decEngine)\n@@ -49,7 +50,7 @@ func (dec *Decoder) recvType(id typeId) {\n \n \t// Type:\n \twire := new(wireType)\n-\tdec.err = dec.decodeValue(tWireType, reflect.NewValue(wire))\n+\tdec.decodeValue(tWireType, reflect.NewValue(wire))\n \tif dec.err != nil {\n \t\treturn\n \t}\n@@ -184,7 +185,7 @@ func (dec *Decoder) DecodeValue(value reflect.Value) os.Error {\n \tdec.err = nil\n \tid := dec.decodeTypeSequence(false)\n \tif dec.err == nil {\n-\t\tdec.err = dec.decodeValue(id, value)\n+\t\tdec.decodeValue(id, value)\n \t}\n \treturn dec.err\n }"}, {"sha": "5cfdb583a1804e57848d5aa642458efffab3eba8", "filename": "libgo/go/gob/encode.go", "status": "modified", "additions": 166, "deletions": 48, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencode.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,16 +6,14 @@ package gob\n \n import (\n \t\"bytes\"\n-\t\"io\"\n \t\"math\"\n-\t\"os\"\n \t\"reflect\"\n \t\"unsafe\"\n )\n \n const uint64Size = unsafe.Sizeof(uint64(0))\n \n-// The global execution state of an instance of the encoder.\n+// encoderState is the global execution state of an instance of the encoder.\n // Field numbers are delta encoded and always increase. The field\n // number is initialized to -1 so 0 comes out as delta(1). A delta of\n // 0 terminates the structure.\n@@ -25,10 +23,26 @@ type encoderState struct {\n \tsendZero bool                 // encoding an array element or map key/value pair; send zero values\n \tfieldnum int                  // the last field number written.\n \tbuf      [1 + uint64Size]byte // buffer used by the encoder; here to avoid allocation.\n+\tnext     *encoderState        // for free list\n }\n \n-func newEncoderState(enc *Encoder, b *bytes.Buffer) *encoderState {\n-\treturn &encoderState{enc: enc, b: b}\n+func (enc *Encoder) newEncoderState(b *bytes.Buffer) *encoderState {\n+\te := enc.freeList\n+\tif e == nil {\n+\t\te = new(encoderState)\n+\t\te.enc = enc\n+\t} else {\n+\t\tenc.freeList = e.next\n+\t}\n+\te.sendZero = false\n+\te.fieldnum = 0\n+\te.b = b\n+\treturn e\n+}\n+\n+func (enc *Encoder) freeEncoderState(e *encoderState) {\n+\te.next = enc.freeList\n+\tenc.freeList = e\n }\n \n // Unsigned integers have a two-state encoding.  If the number is less\n@@ -72,6 +86,7 @@ func (state *encoderState) encodeInt(i int64) {\n \tstate.encodeUint(uint64(x))\n }\n \n+// encOp is the signature of an encoding operator for a given type.\n type encOp func(i *encInstr, state *encoderState, p unsafe.Pointer)\n \n // The 'instructions' of the encoding machine\n@@ -82,21 +97,25 @@ type encInstr struct {\n \toffset uintptr // offset in the structure of the field to encode\n }\n \n-// Emit a field number and update the state to record its value for delta encoding.\n-// If the instruction pointer is nil, do nothing\n+// update emits a field number and updates the state to record its value for delta encoding.\n+// If the instruction pointer is nil, it does nothing\n func (state *encoderState) update(instr *encInstr) {\n \tif instr != nil {\n \t\tstate.encodeUint(uint64(instr.field - state.fieldnum))\n \t\tstate.fieldnum = instr.field\n \t}\n }\n \n-// Each encoder is responsible for handling any indirections associated\n-// with the data structure.  If any pointer so reached is nil, no bytes are written.\n-// If the data item is zero, no bytes are written.\n-// Otherwise, the output (for a scalar) is the field number, as an encoded integer,\n-// followed by the field data in its appropriate format.\n+// Each encoder for a composite is responsible for handling any\n+// indirections associated with the elements of the data structure.\n+// If any pointer so reached is nil, no bytes are written.  If the\n+// data item is zero, no bytes are written.  Single values - ints,\n+// strings etc. - are indirected before calling their encoders.\n+// Otherwise, the output (for a scalar) is the field number, as an\n+// encoded integer, followed by the field data in its appropriate\n+// format.\n \n+// encIndirect dereferences p indir times and returns the result.\n func encIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {\n \tfor ; indir > 0; indir-- {\n \t\tp = *(*unsafe.Pointer)(p)\n@@ -107,6 +126,7 @@ func encIndirect(p unsafe.Pointer, indir int) unsafe.Pointer {\n \treturn p\n }\n \n+// encBool encodes the bool with address p as an unsigned 0 or 1.\n func encBool(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tb := *(*bool)(p)\n \tif b || state.sendZero {\n@@ -119,6 +139,7 @@ func encBool(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt encodes the int with address p.\n func encInt(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := int64(*(*int)(p))\n \tif v != 0 || state.sendZero {\n@@ -127,6 +148,7 @@ func encInt(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUint encodes the uint with address p.\n func encUint(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := uint64(*(*uint)(p))\n \tif v != 0 || state.sendZero {\n@@ -135,6 +157,7 @@ func encUint(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt8 encodes the int8 with address p.\n func encInt8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := int64(*(*int8)(p))\n \tif v != 0 || state.sendZero {\n@@ -143,6 +166,7 @@ func encInt8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUint8 encodes the uint8 with address p.\n func encUint8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := uint64(*(*uint8)(p))\n \tif v != 0 || state.sendZero {\n@@ -151,6 +175,7 @@ func encUint8(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt16 encodes the int16 with address p.\n func encInt16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := int64(*(*int16)(p))\n \tif v != 0 || state.sendZero {\n@@ -159,6 +184,7 @@ func encInt16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUint16 encodes the uint16 with address p.\n func encUint16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := uint64(*(*uint16)(p))\n \tif v != 0 || state.sendZero {\n@@ -167,6 +193,7 @@ func encUint16(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt32 encodes the int32 with address p.\n func encInt32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := int64(*(*int32)(p))\n \tif v != 0 || state.sendZero {\n@@ -175,6 +202,7 @@ func encInt32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUint encodes the uint32 with address p.\n func encUint32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := uint64(*(*uint32)(p))\n \tif v != 0 || state.sendZero {\n@@ -183,6 +211,7 @@ func encUint32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt64 encodes the int64 with address p.\n func encInt64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := *(*int64)(p)\n \tif v != 0 || state.sendZero {\n@@ -191,6 +220,7 @@ func encInt64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encInt64 encodes the uint64 with address p.\n func encUint64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := *(*uint64)(p)\n \tif v != 0 || state.sendZero {\n@@ -199,6 +229,7 @@ func encUint64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUintptr encodes the uintptr with address p.\n func encUintptr(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tv := uint64(*(*uintptr)(p))\n \tif v != 0 || state.sendZero {\n@@ -207,6 +238,7 @@ func encUintptr(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// floatBits returns a uint64 holding the bits of a floating-point number.\n // Floating-point numbers are transmitted as uint64s holding the bits\n // of the underlying representation.  They are sent byte-reversed, with\n // the exponent end coming out first, so integer floating point numbers\n@@ -223,6 +255,7 @@ func floatBits(f float64) uint64 {\n \treturn v\n }\n \n+// encFloat32 encodes the float32 with address p.\n func encFloat32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tf := *(*float32)(p)\n \tif f != 0 || state.sendZero {\n@@ -232,6 +265,7 @@ func encFloat32(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encFloat64 encodes the float64 with address p.\n func encFloat64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tf := *(*float64)(p)\n \tif f != 0 || state.sendZero {\n@@ -241,6 +275,7 @@ func encFloat64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encComplex64 encodes the complex64 with address p.\n // Complex numbers are just a pair of floating-point numbers, real part first.\n func encComplex64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tc := *(*complex64)(p)\n@@ -253,6 +288,7 @@ func encComplex64(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encComplex128 encodes the complex128 with address p.\n func encComplex128(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tc := *(*complex128)(p)\n \tif c != 0+0i || state.sendZero {\n@@ -264,6 +300,7 @@ func encComplex128(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encUint8Array encodes the byte slice whose header has address p.\n // Byte arrays are encoded as an unsigned count followed by the raw bytes.\n func encUint8Array(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tb := *(*[]byte)(p)\n@@ -274,33 +311,36 @@ func encUint8Array(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t}\n }\n \n+// encString encodes the string whose header has address p.\n // Strings are encoded as an unsigned count followed by the raw bytes.\n func encString(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \ts := *(*string)(p)\n \tif len(s) > 0 || state.sendZero {\n \t\tstate.update(i)\n \t\tstate.encodeUint(uint64(len(s)))\n-\t\tio.WriteString(state.b, s)\n+\t\tstate.b.WriteString(s)\n \t}\n }\n \n-// The end of a struct is marked by a delta field number of 0.\n+// encStructTerminator encodes the end of an encoded struct\n+// as delta field number of 0.\n func encStructTerminator(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \tstate.encodeUint(0)\n }\n \n // Execution engine\n \n-// The encoder engine is an array of instructions indexed by field number of the encoding\n+// encEngine an array of instructions indexed by field number of the encoding\n // data, typically a struct.  It is executed top to bottom, walking the struct.\n type encEngine struct {\n \tinstr []encInstr\n }\n \n const singletonField = 0\n \n+// encodeSingle encodes a single top-level non-struct value.\n func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep uintptr) {\n-\tstate := newEncoderState(enc, b)\n+\tstate := enc.newEncoderState(b)\n \tstate.fieldnum = singletonField\n \t// There is no surrounding struct to frame the transmission, so we must\n \t// generate data even if the item is zero.  To do this, set sendZero.\n@@ -313,10 +353,12 @@ func (enc *Encoder) encodeSingle(b *bytes.Buffer, engine *encEngine, basep uintp\n \t\t}\n \t}\n \tinstr.op(instr, state, p)\n+\tenc.freeEncoderState(state)\n }\n \n+// encodeStruct encodes a single struct value.\n func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep uintptr) {\n-\tstate := newEncoderState(enc, b)\n+\tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tfor i := 0; i < len(engine.instr); i++ {\n \t\tinstr := &engine.instr[i]\n@@ -328,10 +370,12 @@ func (enc *Encoder) encodeStruct(b *bytes.Buffer, engine *encEngine, basep uintp\n \t\t}\n \t\tinstr.op(instr, state, p)\n \t}\n+\tenc.freeEncoderState(state)\n }\n \n+// encodeArray encodes the array whose 0th element is at p.\n func (enc *Encoder) encodeArray(b *bytes.Buffer, p uintptr, op encOp, elemWid uintptr, elemIndir int, length int) {\n-\tstate := newEncoderState(enc, b)\n+\tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n \tstate.encodeUint(uint64(length))\n@@ -347,8 +391,10 @@ func (enc *Encoder) encodeArray(b *bytes.Buffer, p uintptr, op encOp, elemWid ui\n \t\top(nil, state, unsafe.Pointer(elemp))\n \t\tp += uintptr(elemWid)\n \t}\n+\tenc.freeEncoderState(state)\n }\n \n+// encodeReflectValue is a helper for maps. It encodes the value v.\n func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir int) {\n \tfor i := 0; i < indir && v != nil; i++ {\n \t\tv = reflect.Indirect(v)\n@@ -359,8 +405,11 @@ func encodeReflectValue(state *encoderState, v reflect.Value, op encOp, indir in\n \top(nil, state, unsafe.Pointer(v.UnsafeAddr()))\n }\n \n+// encodeMap encodes a map as unsigned count followed by key:value pairs.\n+// Because map internals are not exposed, we must use reflection rather than\n+// addresses.\n func (enc *Encoder) encodeMap(b *bytes.Buffer, mv *reflect.MapValue, keyOp, elemOp encOp, keyIndir, elemIndir int) {\n-\tstate := newEncoderState(enc, b)\n+\tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n \tkeys := mv.Keys()\n@@ -369,14 +418,16 @@ func (enc *Encoder) encodeMap(b *bytes.Buffer, mv *reflect.MapValue, keyOp, elem\n \t\tencodeReflectValue(state, key, keyOp, keyIndir)\n \t\tencodeReflectValue(state, mv.Elem(key), elemOp, elemIndir)\n \t}\n+\tenc.freeEncoderState(state)\n }\n \n+// encodeInterface encodes the interface value iv.\n // To send an interface, we send a string identifying the concrete type, followed\n // by the type identifier (which might require defining that type right now), followed\n // by the concrete value.  A nil value gets sent as the empty string for the name,\n // followed by no value.\n func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue) {\n-\tstate := newEncoderState(enc, b)\n+\tstate := enc.newEncoderState(b)\n \tstate.fieldnum = -1\n \tstate.sendZero = true\n \tif iv.IsNil() {\n@@ -391,7 +442,7 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue)\n \t}\n \t// Send the name.\n \tstate.encodeUint(uint64(len(name)))\n-\t_, err := io.WriteString(state.b, name)\n+\t_, err := state.b.WriteString(name)\n \tif err != nil {\n \t\terror(err)\n \t}\n@@ -403,15 +454,32 @@ func (enc *Encoder) encodeInterface(b *bytes.Buffer, iv *reflect.InterfaceValue)\n \t// should be written to b, before the encoded value.\n \tenc.pushWriter(b)\n \tdata := new(bytes.Buffer)\n-\terr = enc.encode(data, iv.Elem(), ut)\n-\tif err != nil {\n-\t\terror(err)\n+\tenc.encode(data, iv.Elem(), ut)\n+\tif enc.err != nil {\n+\t\terror(enc.err)\n \t}\n \tenc.popWriter()\n \tenc.writeMessage(b, data)\n \tif enc.err != nil {\n \t\terror(err)\n \t}\n+\tenc.freeEncoderState(state)\n+}\n+\n+// encGobEncoder encodes a value that implements the GobEncoder interface.\n+// The data is sent as a byte array.\n+func (enc *Encoder) encodeGobEncoder(b *bytes.Buffer, v reflect.Value, index int) {\n+\t// TODO: should we catch panics from the called method?\n+\t// We know it's a GobEncoder, so just call the method directly.\n+\tdata, err := v.Interface().(GobEncoder).GobEncode()\n+\tif err != nil {\n+\t\terror(err)\n+\t}\n+\tstate := enc.newEncoderState(b)\n+\tstate.fieldnum = -1\n+\tstate.encodeUint(uint64(len(data)))\n+\tstate.b.Write(data)\n+\tenc.freeEncoderState(state)\n }\n \n var encOpTable = [...]encOp{\n@@ -434,10 +502,14 @@ var encOpTable = [...]encOp{\n \treflect.String:     encString,\n }\n \n-// Return (a pointer to) the encoding op for the base type under rt and\n+// encOpFor returns (a pointer to) the encoding op for the base type under rt and\n // the indirection count to reach it.\n func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp) (*encOp, int) {\n \tut := userType(rt)\n+\t// If the type implements GobEncoder, we handle it without further processing.\n+\tif ut.isGobEncoder {\n+\t\treturn enc.gobEncodeOpFor(ut)\n+\t}\n \t// If this type is already in progress, it's a recursive type (e.g. map[string]*T).\n \t// Return the pointer to the op we're already building.\n \tif opPtr := inProgress[rt]; opPtr != nil {\n@@ -483,7 +555,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t\t// Maps cannot be accessed by moving addresses around the way\n \t\t\t\t// that slices etc. can.  We must recover a full reflection value for\n \t\t\t\t// the iteration.\n-\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer((p))))\n+\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer(p)))\n \t\t\t\tmv := reflect.Indirect(v).(*reflect.MapValue)\n \t\t\t\tif !state.sendZero && mv.Len() == 0 {\n \t\t\t\t\treturn\n@@ -493,7 +565,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\t}\n \t\tcase *reflect.StructType:\n \t\t\t// Generate a closure that calls out to the engine for the nested type.\n-\t\t\tenc.getEncEngine(typ)\n+\t\t\tenc.getEncEngine(userType(typ))\n \t\t\tinfo := mustGetTypeInfo(typ)\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\tstate.update(i)\n@@ -504,7 +576,7 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \t\t\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n \t\t\t\t// Interfaces transmit the name and contents of the concrete\n \t\t\t\t// value they contain.\n-\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer((p))))\n+\t\t\t\tv := reflect.NewValue(unsafe.Unreflect(t, unsafe.Pointer(p)))\n \t\t\t\tiv := reflect.Indirect(v).(*reflect.InterfaceValue)\n \t\t\t\tif !state.sendZero && (iv == nil || iv.IsNil()) {\n \t\t\t\t\treturn\n@@ -520,22 +592,64 @@ func (enc *Encoder) encOpFor(rt reflect.Type, inProgress map[reflect.Type]*encOp\n \treturn &op, indir\n }\n \n-// The local Type was compiled from the actual value, so we know it's compatible.\n-func (enc *Encoder) compileEnc(rt reflect.Type) *encEngine {\n-\tsrt, isStruct := rt.(*reflect.StructType)\n+// methodIndex returns which method of rt implements the method.\n+func methodIndex(rt reflect.Type, method string) int {\n+\tfor i := 0; i < rt.NumMethod(); i++ {\n+\t\tif rt.Method(i).Name == method {\n+\t\t\treturn i\n+\t\t}\n+\t}\n+\terrorf(\"gob: internal error: can't find method %s\", method)\n+\treturn 0\n+}\n+\n+// gobEncodeOpFor returns the op for a type that is known to implement\n+// GobEncoder.\n+func (enc *Encoder) gobEncodeOpFor(ut *userTypeInfo) (*encOp, int) {\n+\trt := ut.user\n+\tif ut.encIndir == -1 {\n+\t\trt = reflect.PtrTo(rt)\n+\t} else if ut.encIndir > 0 {\n+\t\tfor i := int8(0); i < ut.encIndir; i++ {\n+\t\t\trt = rt.(*reflect.PtrType).Elem()\n+\t\t}\n+\t}\n+\tvar op encOp\n+\top = func(i *encInstr, state *encoderState, p unsafe.Pointer) {\n+\t\tvar v reflect.Value\n+\t\tif ut.encIndir == -1 {\n+\t\t\t// Need to climb up one level to turn value into pointer.\n+\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, unsafe.Pointer(&p)))\n+\t\t} else {\n+\t\t\tv = reflect.NewValue(unsafe.Unreflect(rt, p))\n+\t\t}\n+\t\tstate.update(i)\n+\t\tstate.enc.encodeGobEncoder(state.b, v, methodIndex(rt, gobEncodeMethodName))\n+\t}\n+\treturn &op, int(ut.encIndir) // encIndir: op will get called with p == address of receiver.\n+}\n+\n+// compileEnc returns the engine to compile the type.\n+func (enc *Encoder) compileEnc(ut *userTypeInfo) *encEngine {\n+\tsrt, isStruct := ut.base.(*reflect.StructType)\n \tengine := new(encEngine)\n \tseen := make(map[reflect.Type]*encOp)\n-\tif isStruct {\n-\t\tfor fieldNum := 0; fieldNum < srt.NumField(); fieldNum++ {\n+\trt := ut.base\n+\tif ut.isGobEncoder {\n+\t\trt = ut.user\n+\t}\n+\tif !ut.isGobEncoder && isStruct {\n+\t\tfor fieldNum, wireFieldNum := 0, 0; fieldNum < srt.NumField(); fieldNum++ {\n \t\t\tf := srt.Field(fieldNum)\n \t\t\tif !isExported(f.Name) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\top, indir := enc.encOpFor(f.Type, seen)\n-\t\t\tengine.instr = append(engine.instr, encInstr{*op, fieldNum, indir, uintptr(f.Offset)})\n+\t\t\tengine.instr = append(engine.instr, encInstr{*op, wireFieldNum, indir, uintptr(f.Offset)})\n+\t\t\twireFieldNum++\n \t\t}\n \t\tif srt.NumField() > 0 && len(engine.instr) == 0 {\n-\t\t\terrorf(\"type %s has no exported fields\", rt)\n+\t\t\terrorf(\"gob: type %s has no exported fields\", rt)\n \t\t}\n \t\tengine.instr = append(engine.instr, encInstr{encStructTerminator, 0, 0, 0})\n \t} else {\n@@ -546,38 +660,42 @@ func (enc *Encoder) compileEnc(rt reflect.Type) *encEngine {\n \treturn engine\n }\n \n+// getEncEngine returns the engine to compile the type.\n // typeLock must be held (or we're in initialization and guaranteed single-threaded).\n-// The reflection type must have all its indirections processed out.\n-func (enc *Encoder) getEncEngine(rt reflect.Type) *encEngine {\n-\tinfo, err1 := getTypeInfo(rt)\n+func (enc *Encoder) getEncEngine(ut *userTypeInfo) *encEngine {\n+\tinfo, err1 := getTypeInfo(ut)\n \tif err1 != nil {\n \t\terror(err1)\n \t}\n \tif info.encoder == nil {\n \t\t// mark this engine as underway before compiling to handle recursive types.\n \t\tinfo.encoder = new(encEngine)\n-\t\tinfo.encoder = enc.compileEnc(rt)\n+\t\tinfo.encoder = enc.compileEnc(ut)\n \t}\n \treturn info.encoder\n }\n \n-// Put this in a function so we can hold the lock only while compiling, not when encoding.\n-func (enc *Encoder) lockAndGetEncEngine(rt reflect.Type) *encEngine {\n+// lockAndGetEncEngine is a function that locks and compiles.\n+// This lets us hold the lock only while compiling, not when encoding.\n+func (enc *Encoder) lockAndGetEncEngine(ut *userTypeInfo) *encEngine {\n \ttypeLock.Lock()\n \tdefer typeLock.Unlock()\n-\treturn enc.getEncEngine(rt)\n+\treturn enc.getEncEngine(ut)\n }\n \n-func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInfo) (err os.Error) {\n-\tdefer catchError(&err)\n-\tfor i := 0; i < ut.indir; i++ {\n+func (enc *Encoder) encode(b *bytes.Buffer, value reflect.Value, ut *userTypeInfo) {\n+\tdefer catchError(&enc.err)\n+\tengine := enc.lockAndGetEncEngine(ut)\n+\tindir := ut.indir\n+\tif ut.isGobEncoder {\n+\t\tindir = int(ut.encIndir)\n+\t}\n+\tfor i := 0; i < indir; i++ {\n \t\tvalue = reflect.Indirect(value)\n \t}\n-\tengine := enc.lockAndGetEncEngine(ut.base)\n-\tif value.Type().Kind() == reflect.Struct {\n+\tif !ut.isGobEncoder && value.Type().Kind() == reflect.Struct {\n \t\tenc.encodeStruct(b, engine, value.UnsafeAddr())\n \t} else {\n \t\tenc.encodeSingle(b, engine, value.UnsafeAddr())\n \t}\n-\treturn nil\n }"}, {"sha": "e52a4de29f7117c9f9b3d274a96835daaeb0de38", "filename": "libgo/go/gob/encoder.go", "status": "modified", "additions": 66, "deletions": 52, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fencoder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fencoder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fencoder.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -19,7 +19,9 @@ type Encoder struct {\n \tw          []io.Writer             // where to send the data\n \tsent       map[reflect.Type]typeId // which types we've already sent\n \tcountState *encoderState           // stage for writing counts\n+\tfreeList   *encoderState           // list of free encoderStates; avoids reallocation\n \tbuf        []byte                  // for collecting the output.\n+\tbyteBuf    bytes.Buffer            // buffer for top-level encoderState\n \terr        os.Error\n }\n \n@@ -28,7 +30,7 @@ func NewEncoder(w io.Writer) *Encoder {\n \tenc := new(Encoder)\n \tenc.w = []io.Writer{w}\n \tenc.sent = make(map[reflect.Type]typeId)\n-\tenc.countState = newEncoderState(enc, new(bytes.Buffer))\n+\tenc.countState = enc.newEncoderState(new(bytes.Buffer))\n \treturn enc\n }\n \n@@ -78,12 +80,57 @@ func (enc *Encoder) writeMessage(w io.Writer, b *bytes.Buffer) {\n \t}\n }\n \n+// sendActualType sends the requested type, without further investigation, unless\n+// it's been sent before.\n+func (enc *Encoder) sendActualType(w io.Writer, state *encoderState, ut *userTypeInfo, actual reflect.Type) (sent bool) {\n+\tif _, alreadySent := enc.sent[actual]; alreadySent {\n+\t\treturn false\n+\t}\n+\ttypeLock.Lock()\n+\tinfo, err := getTypeInfo(ut)\n+\ttypeLock.Unlock()\n+\tif err != nil {\n+\t\tenc.setError(err)\n+\t\treturn\n+\t}\n+\t// Send the pair (-id, type)\n+\t// Id:\n+\tstate.encodeInt(-int64(info.id))\n+\t// Type:\n+\tenc.encode(state.b, reflect.NewValue(info.wire), wireTypeUserInfo)\n+\tenc.writeMessage(w, state.b)\n+\tif enc.err != nil {\n+\t\treturn\n+\t}\n+\n+\t// Remember we've sent this type, both what the user gave us and the base type.\n+\tenc.sent[ut.base] = info.id\n+\tif ut.user != ut.base {\n+\t\tenc.sent[ut.user] = info.id\n+\t}\n+\t// Now send the inner types\n+\tswitch st := actual.(type) {\n+\tcase *reflect.StructType:\n+\t\tfor i := 0; i < st.NumField(); i++ {\n+\t\t\tenc.sendType(w, state, st.Field(i).Type)\n+\t\t}\n+\tcase reflect.ArrayOrSliceType:\n+\t\tenc.sendType(w, state, st.Elem())\n+\t}\n+\treturn true\n+}\n+\n+// sendType sends the type info to the other side, if necessary. \n func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Type) (sent bool) {\n-\t// Drill down to the base type.\n \tut := userType(origt)\n-\trt := ut.base\n+\tif ut.isGobEncoder {\n+\t\t// The rules are different: regardless of the underlying type's representation,\n+\t\t// we need to tell the other side that this exact type is a GobEncoder.\n+\t\treturn enc.sendActualType(w, state, ut, ut.user)\n+\t}\n \n-\tswitch rt := rt.(type) {\n+\t// It's a concrete value, so drill down to the base type.\n+\tswitch rt := ut.base.(type) {\n \tdefault:\n \t\t// Basic types and interfaces do not need to be described.\n \t\treturn\n@@ -109,43 +156,7 @@ func (enc *Encoder) sendType(w io.Writer, state *encoderState, origt reflect.Typ\n \t\treturn\n \t}\n \n-\t// Have we already sent this type?  This time we ask about the base type.\n-\tif _, alreadySent := enc.sent[rt]; alreadySent {\n-\t\treturn\n-\t}\n-\n-\t// Need to send it.\n-\ttypeLock.Lock()\n-\tinfo, err := getTypeInfo(rt)\n-\ttypeLock.Unlock()\n-\tif err != nil {\n-\t\tenc.setError(err)\n-\t\treturn\n-\t}\n-\t// Send the pair (-id, type)\n-\t// Id:\n-\tstate.encodeInt(-int64(info.id))\n-\t// Type:\n-\tenc.encode(state.b, reflect.NewValue(info.wire), wireTypeUserInfo)\n-\tenc.writeMessage(w, state.b)\n-\tif enc.err != nil {\n-\t\treturn\n-\t}\n-\n-\t// Remember we've sent this type.\n-\tenc.sent[rt] = info.id\n-\t// Remember we've sent the top-level, possibly indirect type too.\n-\tenc.sent[origt] = info.id\n-\t// Now send the inner types\n-\tswitch st := rt.(type) {\n-\tcase *reflect.StructType:\n-\t\tfor i := 0; i < st.NumField(); i++ {\n-\t\t\tenc.sendType(w, state, st.Field(i).Type)\n-\t\t}\n-\tcase reflect.ArrayOrSliceType:\n-\t\tenc.sendType(w, state, st.Elem())\n-\t}\n-\treturn true\n+\treturn enc.sendActualType(w, state, ut, ut.base)\n }\n \n // Encode transmits the data item represented by the empty interface value,\n@@ -159,11 +170,14 @@ func (enc *Encoder) Encode(e interface{}) os.Error {\n // sent.\n func (enc *Encoder) sendTypeDescriptor(w io.Writer, state *encoderState, ut *userTypeInfo) {\n \t// Make sure the type is known to the other side.\n-\t// First, have we already sent this (base) type?\n-\tbase := ut.base\n-\tif _, alreadySent := enc.sent[base]; !alreadySent {\n+\t// First, have we already sent this type?\n+\trt := ut.base\n+\tif ut.isGobEncoder {\n+\t\trt = ut.user\n+\t}\n+\tif _, alreadySent := enc.sent[rt]; !alreadySent {\n \t\t// No, so send it.\n-\t\tsent := enc.sendType(w, state, base)\n+\t\tsent := enc.sendType(w, state, rt)\n \t\tif enc.err != nil {\n \t\t\treturn\n \t\t}\n@@ -172,13 +186,13 @@ func (enc *Encoder) sendTypeDescriptor(w io.Writer, state *encoderState, ut *use\n \t\t// need to send the type info but we do need to update enc.sent.\n \t\tif !sent {\n \t\t\ttypeLock.Lock()\n-\t\t\tinfo, err := getTypeInfo(base)\n+\t\t\tinfo, err := getTypeInfo(ut)\n \t\t\ttypeLock.Unlock()\n \t\t\tif err != nil {\n \t\t\t\tenc.setError(err)\n \t\t\t\treturn\n \t\t\t}\n-\t\t\tenc.sent[base] = info.id\n+\t\t\tenc.sent[rt] = info.id\n \t\t}\n \t}\n }\n@@ -206,7 +220,8 @@ func (enc *Encoder) EncodeValue(value reflect.Value) os.Error {\n \t}\n \n \tenc.err = nil\n-\tstate := newEncoderState(enc, new(bytes.Buffer))\n+\tenc.byteBuf.Reset()\n+\tstate := enc.newEncoderState(&enc.byteBuf)\n \n \tenc.sendTypeDescriptor(enc.writer(), state, ut)\n \tenc.sendTypeId(state, ut)\n@@ -215,12 +230,11 @@ func (enc *Encoder) EncodeValue(value reflect.Value) os.Error {\n \t}\n \n \t// Encode the object.\n-\terr = enc.encode(state.b, value, ut)\n-\tif err != nil {\n-\t\tenc.setError(err)\n-\t} else {\n+\tenc.encode(state.b, value, ut)\n+\tif enc.err == nil {\n \t\tenc.writeMessage(enc.writer(), state.b)\n \t}\n \n+\tenc.freeEncoderState(state)\n \treturn enc.err\n }"}, {"sha": "012b09956622b82593e52157594b3d86c20b3e8e", "filename": "libgo/go/gob/gobencdec_test.go", "status": "added", "additions": 384, "deletions": 0, "changes": 384, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Fgobencdec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Fgobencdec_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,384 @@\n+// Copyright 20011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file contains tests of the GobEncoder/GobDecoder support.\n+\n+package gob\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+// Types that implement the GobEncoder/Decoder interfaces.\n+\n+type ByteStruct struct {\n+\ta byte // not an exported field\n+}\n+\n+type StringStruct struct {\n+\ts string // not an exported field\n+}\n+\n+type Gobber int\n+\n+type ValueGobber string // encodes with a value, decodes with a pointer.\n+\n+// The relevant methods\n+\n+func (g *ByteStruct) GobEncode() ([]byte, os.Error) {\n+\tb := make([]byte, 3)\n+\tb[0] = g.a\n+\tb[1] = g.a + 1\n+\tb[2] = g.a + 2\n+\treturn b, nil\n+}\n+\n+func (g *ByteStruct) GobDecode(data []byte) os.Error {\n+\tif g == nil {\n+\t\treturn os.ErrorString(\"NIL RECEIVER\")\n+\t}\n+\t// Expect N sequential-valued bytes.\n+\tif len(data) == 0 {\n+\t\treturn os.EOF\n+\t}\n+\tg.a = data[0]\n+\tfor i, c := range data {\n+\t\tif c != g.a+byte(i) {\n+\t\t\treturn os.ErrorString(\"invalid data sequence\")\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func (g *StringStruct) GobEncode() ([]byte, os.Error) {\n+\treturn []byte(g.s), nil\n+}\n+\n+func (g *StringStruct) GobDecode(data []byte) os.Error {\n+\t// Expect N sequential-valued bytes.\n+\tif len(data) == 0 {\n+\t\treturn os.EOF\n+\t}\n+\ta := data[0]\n+\tfor i, c := range data {\n+\t\tif c != a+byte(i) {\n+\t\t\treturn os.ErrorString(\"invalid data sequence\")\n+\t\t}\n+\t}\n+\tg.s = string(data)\n+\treturn nil\n+}\n+\n+func (g *Gobber) GobEncode() ([]byte, os.Error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%d\", *g)), nil\n+}\n+\n+func (g *Gobber) GobDecode(data []byte) os.Error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%d\", (*int)(g))\n+\treturn err\n+}\n+\n+func (v ValueGobber) GobEncode() ([]byte, os.Error) {\n+\treturn []byte(fmt.Sprintf(\"VALUE=%s\", v)), nil\n+}\n+\n+func (v *ValueGobber) GobDecode(data []byte) os.Error {\n+\t_, err := fmt.Sscanf(string(data), \"VALUE=%s\", (*string)(v))\n+\treturn err\n+}\n+\n+// Structs that include GobEncodable fields.\n+\n+type GobTest0 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tG *ByteStruct\n+}\n+\n+type GobTest1 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tG *StringStruct\n+}\n+\n+type GobTest2 struct {\n+\tX int    // guarantee we have  something in common with GobTest*\n+\tG string // not a GobEncoder - should give us errors\n+}\n+\n+type GobTest3 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tG *Gobber\n+}\n+\n+type GobTest4 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tV ValueGobber\n+}\n+\n+type GobTest5 struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+\tV *ValueGobber\n+}\n+\n+type GobTestIgnoreEncoder struct {\n+\tX int // guarantee we have  something in common with GobTest*\n+}\n+\n+type GobTestValueEncDec struct {\n+\tX int          // guarantee we have  something in common with GobTest*\n+\tG StringStruct // not a pointer.\n+}\n+\n+type GobTestIndirectEncDec struct {\n+\tX int             // guarantee we have  something in common with GobTest*\n+\tG ***StringStruct // indirections to the receiver.\n+}\n+\n+func TestGobEncoderField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\t// First a field that's a structure.\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTest0{17, &ByteStruct{'A'}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTest0)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.G.a != 'A' {\n+\t\tt.Errorf(\"expected 'A' got %c\", x.G.a)\n+\t}\n+\t// Now a field that's not a structure.\n+\tb.Reset()\n+\tgobber := Gobber(23)\n+\terr = enc.Encode(GobTest3{17, &gobber})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\ty := new(GobTest3)\n+\terr = dec.Decode(y)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif *y.G != 23 {\n+\t\tt.Errorf(\"expected '23 got %d\", *y.G)\n+\t}\n+}\n+\n+// Even though the field is a value, we can still take its address\n+// and should be able to call the methods.\n+func TestGobEncoderValueField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\t// First a field that's a structure.\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTestValueEncDec{17, StringStruct{\"HIJKL\"}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestValueEncDec)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.G.s != \"HIJKL\" {\n+\t\tt.Errorf(\"expected `HIJKL` got %s\", x.G.s)\n+\t}\n+}\n+\n+// GobEncode/Decode should work even if the value is\n+// more indirect than the receiver.\n+func TestGobEncoderIndirectField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\t// First a field that's a structure.\n+\tenc := NewEncoder(b)\n+\ts := &StringStruct{\"HIJKL\"}\n+\tsp := &s\n+\terr := enc.Encode(GobTestIndirectEncDec{17, &sp})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestIndirectEncDec)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif (***x.G).s != \"HIJKL\" {\n+\t\tt.Errorf(\"expected `HIJKL` got %s\", (***x.G).s)\n+\t}\n+}\n+\n+// As long as the fields have the same name and implement the\n+// interface, we can cross-connect them.  Not sure it's useful\n+// and may even be bad but it works and it's hard to prevent\n+// without exposing the contents of the object, which would\n+// defeat the purpose.\n+func TestGobEncoderFieldsOfDifferentType(t *testing.T) {\n+\t// first, string in field to byte in field\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTest1{17, &StringStruct{\"ABC\"}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTest0)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.G.a != 'A' {\n+\t\tt.Errorf(\"expected 'A' got %c\", x.G.a)\n+\t}\n+\t// now the other direction, byte in field to string in field\n+\tb.Reset()\n+\terr = enc.Encode(GobTest0{17, &ByteStruct{'X'}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\ty := new(GobTest1)\n+\terr = dec.Decode(y)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif y.G.s != \"XYZ\" {\n+\t\tt.Fatalf(\"expected `XYZ` got %c\", y.G.s)\n+\t}\n+}\n+\n+// Test that we can encode a value and decode into a pointer.\n+func TestGobEncoderValueEncoder(t *testing.T) {\n+\t// first, string in field to byte in field\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTest4{17, ValueGobber(\"hello\")})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTest5)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif *x.V != \"hello\" {\n+\t\tt.Errorf(\"expected `hello` got %s\", x.V)\n+\t}\n+}\n+\n+func TestGobEncoderFieldTypeError(t *testing.T) {\n+\t// GobEncoder to non-decoder: error\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTest1{17, &StringStruct{\"ABC\"}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := &GobTest2{}\n+\terr = dec.Decode(x)\n+\tif err == nil {\n+\t\tt.Fatal(\"expected decode error for mismatched fields (encoder to non-decoder)\")\n+\t}\n+\tif strings.Index(err.String(), \"type\") < 0 {\n+\t\tt.Fatal(\"expected type error; got\", err)\n+\t}\n+\t// Non-encoder to GobDecoder: error\n+\tb.Reset()\n+\terr = enc.Encode(GobTest2{17, \"ABC\"})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\ty := &GobTest1{}\n+\terr = dec.Decode(y)\n+\tif err == nil {\n+\t\tt.Fatal(\"expected decode error for mistmatched fields (non-encoder to decoder)\")\n+\t}\n+\tif strings.Index(err.String(), \"type\") < 0 {\n+\t\tt.Fatal(\"expected type error; got\", err)\n+\t}\n+}\n+\n+// Even though ByteStruct is a struct, it's treated as a singleton at the top level.\n+func TestGobEncoderStructSingleton(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(&ByteStruct{'A'})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(ByteStruct)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.a != 'A' {\n+\t\tt.Errorf(\"expected 'A' got %c\", x.a)\n+\t}\n+}\n+\n+func TestGobEncoderNonStructSingleton(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(Gobber(1234))\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tvar x Gobber\n+\terr = dec.Decode(&x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x != 1234 {\n+\t\tt.Errorf(\"expected 1234 got %c\", x)\n+\t}\n+}\n+\n+func TestGobEncoderIgnoreStructField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\t// First a field that's a structure.\n+\tenc := NewEncoder(b)\n+\terr := enc.Encode(GobTest0{17, &ByteStruct{'A'}})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestIgnoreEncoder)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.X != 17 {\n+\t\tt.Errorf(\"expected 17 got %c\", x.X)\n+\t}\n+}\n+\n+func TestGobEncoderIgnoreNonStructField(t *testing.T) {\n+\tb := new(bytes.Buffer)\n+\t// First a field that's a structure.\n+\tenc := NewEncoder(b)\n+\tgobber := Gobber(23)\n+\terr := enc.Encode(GobTest3{17, &gobber})\n+\tif err != nil {\n+\t\tt.Fatal(\"encode error:\", err)\n+\t}\n+\tdec := NewDecoder(b)\n+\tx := new(GobTestIgnoreEncoder)\n+\terr = dec.Decode(x)\n+\tif err != nil {\n+\t\tt.Fatal(\"decode error:\", err)\n+\t}\n+\tif x.X != 17 {\n+\t\tt.Errorf(\"expected 17 got %c\", x.X)\n+\t}\n+}"}, {"sha": "645f4fe51c9058ce68d0e511cf466632cbb2f0bb", "filename": "libgo/go/gob/timing_test.go", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftiming_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftiming_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftiming_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,90 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package gob\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+type Bench struct {\n+\tA int\n+\tB float64\n+\tC string\n+\tD []byte\n+}\n+\n+func benchmarkEndToEnd(r io.Reader, w io.Writer, b *testing.B) {\n+\tb.StopTimer()\n+\tenc := NewEncoder(w)\n+\tdec := NewDecoder(r)\n+\tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\tif enc.Encode(bench) != nil {\n+\t\t\tpanic(\"encode error\")\n+\t\t}\n+\t\tif dec.Decode(bench) != nil {\n+\t\t\tpanic(\"decode error\")\n+\t\t}\n+\t}\n+}\n+\n+func BenchmarkEndToEndPipe(b *testing.B) {\n+\tr, w, err := os.Pipe()\n+\tif err != nil {\n+\t\tpanic(\"can't get pipe:\" + err.String())\n+\t}\n+\tbenchmarkEndToEnd(r, w, b)\n+}\n+\n+func BenchmarkEndToEndByteBuffer(b *testing.B) {\n+\tvar buf bytes.Buffer\n+\tbenchmarkEndToEnd(&buf, &buf, b)\n+}\n+\n+func TestCountEncodeMallocs(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n+\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tconst count = 1000\n+\tfor i := 0; i < count; i++ {\n+\t\terr := enc.Encode(bench)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"encode:\", err)\n+\t\t}\n+\t}\n+\tmallocs += runtime.MemStats.Mallocs\n+\tfmt.Printf(\"mallocs per encode of type Bench: %d\\n\", mallocs/count)\n+}\n+\n+func TestCountDecodeMallocs(t *testing.T) {\n+\tvar buf bytes.Buffer\n+\tenc := NewEncoder(&buf)\n+\tbench := &Bench{7, 3.2, \"now is the time\", []byte(\"for all good men\")}\n+\tconst count = 1000\n+\tfor i := 0; i < count; i++ {\n+\t\terr := enc.Encode(bench)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"encode:\", err)\n+\t\t}\n+\t}\n+\tdec := NewDecoder(&buf)\n+\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tfor i := 0; i < count; i++ {\n+\t\t*bench = Bench{}\n+\t\terr := dec.Decode(&bench)\n+\t\tif err != nil {\n+\t\t\tt.Fatal(\"decode:\", err)\n+\t\t}\n+\t}\n+\tmallocs += runtime.MemStats.Mallocs\n+\tfmt.Printf(\"mallocs per decode of type Bench: %d\\n\", mallocs/count)\n+}"}, {"sha": "fc620f5c7c1011967e997576a97e73cf36517587", "filename": "libgo/go/gob/type.go", "status": "modified", "additions": 216, "deletions": 64, "changes": 280, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,15 +9,21 @@ import (\n \t\"os\"\n \t\"reflect\"\n \t\"sync\"\n+\t\"unicode\"\n+\t\"utf8\"\n )\n \n // userTypeInfo stores the information associated with a type the user has handed\n // to the package.  It's computed once and stored in a map keyed by reflection\n // type.\n type userTypeInfo struct {\n-\tuser  reflect.Type // the type the user handed us\n-\tbase  reflect.Type // the base type after all indirections\n-\tindir int          // number of indirections to reach the base type\n+\tuser         reflect.Type // the type the user handed us\n+\tbase         reflect.Type // the base type after all indirections\n+\tindir        int          // number of indirections to reach the base type\n+\tisGobEncoder bool         // does the type implement GobEncoder?\n+\tisGobDecoder bool         // does the type implement GobDecoder?\n+\tencIndir     int8         // number of indirections to reach the receiver type; may be negative\n+\tdecIndir     int8         // number of indirections to reach the receiver type; may be negative\n }\n \n var (\n@@ -68,10 +74,73 @@ func validUserType(rt reflect.Type) (ut *userTypeInfo, err os.Error) {\n \t\t}\n \t\tut.indir++\n \t}\n+\tut.isGobEncoder, ut.encIndir = implementsInterface(ut.user, gobEncoderCheck)\n+\tut.isGobDecoder, ut.decIndir = implementsInterface(ut.user, gobDecoderCheck)\n \tuserTypeCache[rt] = ut\n \treturn\n }\n \n+const (\n+\tgobEncodeMethodName = \"GobEncode\"\n+\tgobDecodeMethodName = \"GobDecode\"\n+)\n+\n+// implements returns whether the type implements the interface, as encoded\n+// in the check function.\n+func implements(typ reflect.Type, check func(typ reflect.Type) bool) bool {\n+\tif typ.NumMethod() == 0 { // avoid allocations etc. unless there's some chance\n+\t\treturn false\n+\t}\n+\treturn check(typ)\n+}\n+\n+// gobEncoderCheck makes the type assertion a boolean function.\n+func gobEncoderCheck(typ reflect.Type) bool {\n+\t_, ok := reflect.MakeZero(typ).Interface().(GobEncoder)\n+\treturn ok\n+}\n+\n+// gobDecoderCheck makes the type assertion a boolean function.\n+func gobDecoderCheck(typ reflect.Type) bool {\n+\t_, ok := reflect.MakeZero(typ).Interface().(GobDecoder)\n+\treturn ok\n+}\n+\n+// implementsInterface reports whether the type implements the\n+// interface. (The actual check is done through the provided function.)\n+// It also returns the number of indirections required to get to the\n+// implementation.\n+func implementsInterface(typ reflect.Type, check func(typ reflect.Type) bool) (success bool, indir int8) {\n+\tif typ == nil {\n+\t\treturn\n+\t}\n+\trt := typ\n+\t// The type might be a pointer and we need to keep\n+\t// dereferencing to the base type until we find an implementation.\n+\tfor {\n+\t\tif implements(rt, check) {\n+\t\t\treturn true, indir\n+\t\t}\n+\t\tif p, ok := rt.(*reflect.PtrType); ok {\n+\t\t\tindir++\n+\t\t\tif indir > 100 { // insane number of indirections\n+\t\t\t\treturn false, 0\n+\t\t\t}\n+\t\t\trt = p.Elem()\n+\t\t\tcontinue\n+\t\t}\n+\t\tbreak\n+\t}\n+\t// No luck yet, but if this is a base type (non-pointer), the pointer might satisfy.\n+\tif _, ok := typ.(*reflect.PtrType); !ok {\n+\t\t// Not a pointer, but does the pointer work?\n+\t\tif implements(reflect.PtrTo(typ), check) {\n+\t\t\treturn true, -1\n+\t\t}\n+\t}\n+\treturn false, 0\n+}\n+\n // userType returns, and saves, the information associated with user-provided type rt.\n // If the user type is not valid, it calls error.\n func userType(rt reflect.Type) *userTypeInfo {\n@@ -153,22 +222,24 @@ func (t *CommonType) name() string { return t.Name }\n \n var (\n \t// Primordial types, needed during initialization.\n-\ttBool      = bootstrapType(\"bool\", false, 1)\n-\ttInt       = bootstrapType(\"int\", int(0), 2)\n-\ttUint      = bootstrapType(\"uint\", uint(0), 3)\n-\ttFloat     = bootstrapType(\"float\", float64(0), 4)\n-\ttBytes     = bootstrapType(\"bytes\", make([]byte, 0), 5)\n-\ttString    = bootstrapType(\"string\", \"\", 6)\n-\ttComplex   = bootstrapType(\"complex\", 0+0i, 7)\n-\ttInterface = bootstrapType(\"interface\", interface{}(nil), 8)\n+\t// Always passed as pointers so the interface{} type\n+\t// goes through without losing its interfaceness.\n+\ttBool      = bootstrapType(\"bool\", (*bool)(nil), 1)\n+\ttInt       = bootstrapType(\"int\", (*int)(nil), 2)\n+\ttUint      = bootstrapType(\"uint\", (*uint)(nil), 3)\n+\ttFloat     = bootstrapType(\"float\", (*float64)(nil), 4)\n+\ttBytes     = bootstrapType(\"bytes\", (*[]byte)(nil), 5)\n+\ttString    = bootstrapType(\"string\", (*string)(nil), 6)\n+\ttComplex   = bootstrapType(\"complex\", (*complex128)(nil), 7)\n+\ttInterface = bootstrapType(\"interface\", (*interface{})(nil), 8)\n \t// Reserve some Ids for compatible expansion\n-\ttReserved7 = bootstrapType(\"_reserved1\", struct{ r7 int }{}, 9)\n-\ttReserved6 = bootstrapType(\"_reserved1\", struct{ r6 int }{}, 10)\n-\ttReserved5 = bootstrapType(\"_reserved1\", struct{ r5 int }{}, 11)\n-\ttReserved4 = bootstrapType(\"_reserved1\", struct{ r4 int }{}, 12)\n-\ttReserved3 = bootstrapType(\"_reserved1\", struct{ r3 int }{}, 13)\n-\ttReserved2 = bootstrapType(\"_reserved1\", struct{ r2 int }{}, 14)\n-\ttReserved1 = bootstrapType(\"_reserved1\", struct{ r1 int }{}, 15)\n+\ttReserved7 = bootstrapType(\"_reserved1\", (*struct{ r7 int })(nil), 9)\n+\ttReserved6 = bootstrapType(\"_reserved1\", (*struct{ r6 int })(nil), 10)\n+\ttReserved5 = bootstrapType(\"_reserved1\", (*struct{ r5 int })(nil), 11)\n+\ttReserved4 = bootstrapType(\"_reserved1\", (*struct{ r4 int })(nil), 12)\n+\ttReserved3 = bootstrapType(\"_reserved1\", (*struct{ r3 int })(nil), 13)\n+\ttReserved2 = bootstrapType(\"_reserved1\", (*struct{ r2 int })(nil), 14)\n+\ttReserved1 = bootstrapType(\"_reserved1\", (*struct{ r1 int })(nil), 15)\n )\n \n // Predefined because it's needed by the Decoder\n@@ -229,6 +300,23 @@ func (a *arrayType) safeString(seen map[typeId]bool) string {\n \n func (a *arrayType) string() string { return a.safeString(make(map[typeId]bool)) }\n \n+// GobEncoder type (something that implements the GobEncoder interface)\n+type gobEncoderType struct {\n+\tCommonType\n+}\n+\n+func newGobEncoderType(name string) *gobEncoderType {\n+\tg := &gobEncoderType{CommonType{Name: name}}\n+\tsetTypeId(g)\n+\treturn g\n+}\n+\n+func (g *gobEncoderType) safeString(seen map[typeId]bool) string {\n+\treturn g.Name\n+}\n+\n+func (g *gobEncoderType) string() string { return g.Name }\n+\n // Map type\n type mapType struct {\n \tCommonType\n@@ -324,11 +412,16 @@ func newStructType(name string) *structType {\n \treturn s\n }\n \n-func (s *structType) init(field []*fieldType) {\n-\ts.Field = field\n-}\n-\n-func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n+// newTypeObject allocates a gobType for the reflection type rt.\n+// Unless ut represents a GobEncoder, rt should be the base type\n+// of ut.\n+// This is only called from the encoding side. The decoding side\n+// works through typeIds and userTypeInfos alone.\n+func newTypeObject(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error) {\n+\t// Does this type implement GobEncoder?\n+\tif ut.isGobEncoder {\n+\t\treturn newGobEncoderType(name), nil\n+\t}\n \tvar err os.Error\n \tvar type0, type1 gobType\n \tdefer func() {\n@@ -364,7 +457,7 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \tcase *reflect.ArrayType:\n \t\tat := newArrayType(name)\n \t\ttypes[rt] = at\n-\t\ttype0, err = getType(\"\", t.Elem())\n+\t\ttype0, err = getBaseType(\"\", t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -382,11 +475,11 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \tcase *reflect.MapType:\n \t\tmt := newMapType(name)\n \t\ttypes[rt] = mt\n-\t\ttype0, err = getType(\"\", t.Key())\n+\t\ttype0, err = getBaseType(\"\", t.Key())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\ttype1, err = getType(\"\", t.Elem())\n+\t\ttype1, err = getBaseType(\"\", t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -400,7 +493,7 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \t\t}\n \t\tst := newSliceType(name)\n \t\ttypes[rt] = st\n-\t\ttype0, err = getType(t.Elem().Name(), t.Elem())\n+\t\ttype0, err = getBaseType(t.Elem().Name(), t.Elem())\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n@@ -411,22 +504,23 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \t\tst := newStructType(name)\n \t\ttypes[rt] = st\n \t\tidToType[st.id()] = st\n-\t\tfield := make([]*fieldType, t.NumField())\n \t\tfor i := 0; i < t.NumField(); i++ {\n \t\t\tf := t.Field(i)\n+\t\t\tif !isExported(f.Name) {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\ttyp := userType(f.Type).base\n \t\t\ttname := typ.Name()\n \t\t\tif tname == \"\" {\n \t\t\t\tt := userType(f.Type).base\n \t\t\t\ttname = t.String()\n \t\t\t}\n-\t\t\tgt, err := getType(tname, f.Type)\n+\t\t\tgt, err := getBaseType(tname, f.Type)\n \t\t\tif err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tfield[i] = &fieldType{f.Name, gt.id()}\n+\t\t\tst.Field = append(st.Field, &fieldType{f.Name, gt.id()})\n \t\t}\n-\t\tst.init(field)\n \t\treturn st, nil\n \n \tdefault:\n@@ -435,15 +529,30 @@ func newTypeObject(name string, rt reflect.Type) (gobType, os.Error) {\n \treturn nil, nil\n }\n \n+// isExported reports whether this is an exported - upper case - name.\n+func isExported(name string) bool {\n+\trune, _ := utf8.DecodeRuneInString(name)\n+\treturn unicode.IsUpper(rune)\n+}\n+\n+// getBaseType returns the Gob type describing the given reflect.Type's base type.\n+// typeLock must be held.\n+func getBaseType(name string, rt reflect.Type) (gobType, os.Error) {\n+\tut := userType(rt)\n+\treturn getType(name, ut, ut.base)\n+}\n+\n // getType returns the Gob type describing the given reflect.Type.\n+// Should be called only when handling GobEncoders/Decoders,\n+// which may be pointers.  All other types are handled through the\n+//  base type, never a pointer.\n // typeLock must be held.\n-func getType(name string, rt reflect.Type) (gobType, os.Error) {\n-\trt = userType(rt).base\n+func getType(name string, ut *userTypeInfo, rt reflect.Type) (gobType, os.Error) {\n \ttyp, present := types[rt]\n \tif present {\n \t\treturn typ, nil\n \t}\n-\ttyp, err := newTypeObject(name, rt)\n+\ttyp, err := newTypeObject(name, ut, rt)\n \tif err == nil {\n \t\ttypes[rt] = typ\n \t}\n@@ -457,9 +566,10 @@ func checkId(want, got typeId) {\n \t}\n }\n \n-// used for building the basic types; called only from init()\n+// used for building the basic types; called only from init().  the incoming\n+// interface always refers to a pointer.\n func bootstrapType(name string, e interface{}, expect typeId) typeId {\n-\trt := reflect.Typeof(e)\n+\trt := reflect.Typeof(e).(*reflect.PtrType).Elem()\n \t_, present := types[rt]\n \tif present {\n \t\tpanic(\"bootstrap type already present: \" + name + \", \" + rt.String())\n@@ -484,10 +594,11 @@ func bootstrapType(name string, e interface{}, expect typeId) typeId {\n // To maintain binary compatibility, if you extend this type, always put\n // the new fields last.\n type wireType struct {\n-\tArrayT  *arrayType\n-\tSliceT  *sliceType\n-\tStructT *structType\n-\tMapT    *mapType\n+\tArrayT      *arrayType\n+\tSliceT      *sliceType\n+\tStructT     *structType\n+\tMapT        *mapType\n+\tGobEncoderT *gobEncoderType\n }\n \n func (w *wireType) string() string {\n@@ -504,6 +615,8 @@ func (w *wireType) string() string {\n \t\treturn w.StructT.Name\n \tcase w.MapT != nil:\n \t\treturn w.MapT.Name\n+\tcase w.GobEncoderT != nil:\n+\t\treturn w.GobEncoderT.Name\n \t}\n \treturn unknown\n }\n@@ -516,49 +629,88 @@ type typeInfo struct {\n \n var typeInfoMap = make(map[reflect.Type]*typeInfo) // protected by typeLock\n \n-// The reflection type must have all its indirections processed out.\n // typeLock must be held.\n-func getTypeInfo(rt reflect.Type) (*typeInfo, os.Error) {\n-\tif rt.Kind() == reflect.Ptr {\n-\t\tpanic(\"pointer type in getTypeInfo: \" + rt.String())\n+func getTypeInfo(ut *userTypeInfo) (*typeInfo, os.Error) {\n+\trt := ut.base\n+\tif ut.isGobEncoder {\n+\t\t// We want the user type, not the base type.\n+\t\trt = ut.user\n \t}\n \tinfo, ok := typeInfoMap[rt]\n-\tif !ok {\n-\t\tinfo = new(typeInfo)\n-\t\tname := rt.Name()\n-\t\tgt, err := getType(name, rt)\n+\tif ok {\n+\t\treturn info, nil\n+\t}\n+\tinfo = new(typeInfo)\n+\tgt, err := getBaseType(rt.Name(), rt)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tinfo.id = gt.id()\n+\n+\tif ut.isGobEncoder {\n+\t\tuserType, err := getType(rt.Name(), ut, rt)\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tinfo.id = gt.id()\n-\t\tt := info.id.gobType()\n-\t\tswitch typ := rt.(type) {\n-\t\tcase *reflect.ArrayType:\n-\t\t\tinfo.wire = &wireType{ArrayT: t.(*arrayType)}\n-\t\tcase *reflect.MapType:\n-\t\t\tinfo.wire = &wireType{MapT: t.(*mapType)}\n-\t\tcase *reflect.SliceType:\n-\t\t\t// []byte == []uint8 is a special case handled separately\n-\t\t\tif typ.Elem().Kind() != reflect.Uint8 {\n-\t\t\t\tinfo.wire = &wireType{SliceT: t.(*sliceType)}\n-\t\t\t}\n-\t\tcase *reflect.StructType:\n-\t\t\tinfo.wire = &wireType{StructT: t.(*structType)}\n+\t\tinfo.wire = &wireType{GobEncoderT: userType.id().gobType().(*gobEncoderType)}\n+\t\ttypeInfoMap[ut.user] = info\n+\t\treturn info, nil\n+\t}\n+\n+\tt := info.id.gobType()\n+\tswitch typ := rt.(type) {\n+\tcase *reflect.ArrayType:\n+\t\tinfo.wire = &wireType{ArrayT: t.(*arrayType)}\n+\tcase *reflect.MapType:\n+\t\tinfo.wire = &wireType{MapT: t.(*mapType)}\n+\tcase *reflect.SliceType:\n+\t\t// []byte == []uint8 is a special case handled separately\n+\t\tif typ.Elem().Kind() != reflect.Uint8 {\n+\t\t\tinfo.wire = &wireType{SliceT: t.(*sliceType)}\n \t\t}\n-\t\ttypeInfoMap[rt] = info\n+\tcase *reflect.StructType:\n+\t\tinfo.wire = &wireType{StructT: t.(*structType)}\n \t}\n+\ttypeInfoMap[rt] = info\n \treturn info, nil\n }\n \n // Called only when a panic is acceptable and unexpected.\n func mustGetTypeInfo(rt reflect.Type) *typeInfo {\n-\tt, err := getTypeInfo(rt)\n+\tt, err := getTypeInfo(userType(rt))\n \tif err != nil {\n \t\tpanic(\"getTypeInfo: \" + err.String())\n \t}\n \treturn t\n }\n \n+// GobEncoder is the interface describing data that provides its own\n+// representation for encoding values for transmission to a GobDecoder.\n+// A type that implements GobEncoder and GobDecoder has complete\n+// control over the representation of its data and may therefore\n+// contain things such as private fields, channels, and functions,\n+// which are not usually transmissable in gob streams.\n+//\n+// Note: Since gobs can be stored permanently, It is good design\n+// to guarantee the encoding used by a GobEncoder is stable as the\n+// software evolves.  For instance, it might make sense for GobEncode\n+// to include a version number in the encoding.\n+type GobEncoder interface {\n+\t// GobEncode returns a byte slice representing the encoding of the\n+\t// receiver for transmission to a GobDecoder, usually of the same\n+\t// concrete type.\n+\tGobEncode() ([]byte, os.Error)\n+}\n+\n+// GobDecoder is the interface describing data that provides its own\n+// routine for decoding transmitted values sent by a GobEncoder.\n+type GobDecoder interface {\n+\t// GobDecode overwrites the receiver, which must be a pointer,\n+\t// with the value represented by the byte slice, which was written\n+\t// by GobEncode, usually for the same concrete type.\n+\tGobDecode([]byte) os.Error\n+}\n+\n var (\n \tnameToConcreteType = make(map[string]reflect.Type)\n \tconcreteTypeToName = make(map[reflect.Type]string)"}, {"sha": "ffd1345e5c0c135a911ef0298b7f261e323051be", "filename": "libgo/go/gob/type_test.go", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftype_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fgob%2Ftype_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgob%2Ftype_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -26,7 +26,7 @@ var basicTypes = []typeT{\n func getTypeUnlocked(name string, rt reflect.Type) gobType {\n \ttypeLock.Lock()\n \tdefer typeLock.Unlock()\n-\tt, err := getType(name, rt)\n+\tt, err := getBaseType(name, rt)\n \tif err != nil {\n \t\tpanic(\"getTypeUnlocked: \" + err.String())\n \t}\n@@ -126,27 +126,27 @@ func TestMapType(t *testing.T) {\n }\n \n type Bar struct {\n-\tx string\n+\tX string\n }\n \n // This structure has pointers and refers to itself, making it a good test case.\n type Foo struct {\n-\ta int\n-\tb int32 // will become int\n-\tc string\n-\td []byte\n-\te *float64    // will become float64\n-\tf ****float64 // will become float64\n-\tg *Bar\n-\th *Bar // should not interpolate the definition of Bar again\n-\ti *Foo // will not explode\n+\tA int\n+\tB int32 // will become int\n+\tC string\n+\tD []byte\n+\tE *float64    // will become float64\n+\tF ****float64 // will become float64\n+\tG *Bar\n+\tH *Bar // should not interpolate the definition of Bar again\n+\tI *Foo // will not explode\n }\n \n func TestStructType(t *testing.T) {\n \tsstruct := getTypeUnlocked(\"Foo\", reflect.Typeof(Foo{}))\n \tstr := sstruct.string()\n \t// If we can print it correctly, we built it correctly.\n-\texpected := \"Foo = struct { a int; b int; c string; d bytes; e float; f float; g Bar = struct { x string; }; h Bar; i Foo; }\"\n+\texpected := \"Foo = struct { A int; B int; C string; D bytes; E float; F float; G Bar = struct { X string; }; H Bar; I Foo; }\"\n \tif str != expected {\n \t\tt.Errorf(\"struct printed as %q; expected %q\", str, expected)\n \t}"}, {"sha": "66ab5a635bf0f792b64f042c6e3c2648e89ffe62", "filename": "libgo/go/hash/fnv/fnv.go", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,133 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The fnv package implements FNV-1 and FNV-1a,\n+// non-cryptographic hash functions created by\n+// Glenn Fowler, Landon Curt Noll, and Phong Vo.\n+// See http://isthe.com/chongo/tech/comp/fnv/.\n+package fnv\n+\n+import (\n+\t\"encoding/binary\"\n+\t\"hash\"\n+\t\"os\"\n+\t\"unsafe\"\n+)\n+\n+type (\n+\tsum32  uint32\n+\tsum32a uint32\n+\tsum64  uint64\n+\tsum64a uint64\n+)\n+\n+const (\n+\toffset32 = 2166136261\n+\toffset64 = 14695981039346656037\n+\tprime32  = 16777619\n+\tprime64  = 1099511628211\n+)\n+\n+// New32 returns a new 32-bit FNV-1 hash.Hash.\n+func New32() hash.Hash32 {\n+\tvar s sum32 = offset32\n+\treturn &s\n+}\n+\n+// New32a returns a new 32-bit FNV-1a hash.Hash.\n+func New32a() hash.Hash32 {\n+\tvar s sum32a = offset32\n+\treturn &s\n+}\n+\n+// New64 returns a new 64-bit FNV-1 hash.Hash.\n+func New64() hash.Hash64 {\n+\tvar s sum64 = offset64\n+\treturn &s\n+}\n+\n+// New64a returns a new 64-bit FNV-1a hash.Hash.\n+func New64a() hash.Hash64 {\n+\tvar s sum64a = offset64\n+\treturn &s\n+}\n+\n+func (s *sum32) Reset()  { *s = offset32 }\n+func (s *sum32a) Reset() { *s = offset32 }\n+func (s *sum64) Reset()  { *s = offset64 }\n+func (s *sum64a) Reset() { *s = offset64 }\n+\n+func (s *sum32) Sum32() uint32  { return uint32(*s) }\n+func (s *sum32a) Sum32() uint32 { return uint32(*s) }\n+func (s *sum64) Sum64() uint64  { return uint64(*s) }\n+func (s *sum64a) Sum64() uint64 { return uint64(*s) }\n+\n+func (s *sum32) Write(data []byte) (int, os.Error) {\n+\thash := *s\n+\tfor _, c := range data {\n+\t\thash *= prime32\n+\t\thash ^= sum32(c)\n+\t}\n+\t*s = hash\n+\treturn len(data), nil\n+}\n+\n+func (s *sum32a) Write(data []byte) (int, os.Error) {\n+\thash := *s\n+\tfor _, c := range data {\n+\t\thash ^= sum32a(c)\n+\t\thash *= prime32\n+\t}\n+\t*s = hash\n+\treturn len(data), nil\n+}\n+\n+func (s *sum64) Write(data []byte) (int, os.Error) {\n+\thash := *s\n+\tfor _, c := range data {\n+\t\thash *= prime64\n+\t\thash ^= sum64(c)\n+\t}\n+\t*s = hash\n+\treturn len(data), nil\n+}\n+\n+func (s *sum64a) Write(data []byte) (int, os.Error) {\n+\thash := *s\n+\tfor _, c := range data {\n+\t\thash ^= sum64a(c)\n+\t\thash *= prime64\n+\t}\n+\t*s = hash\n+\treturn len(data), nil\n+}\n+\n+func (s *sum32) Size() int  { return unsafe.Sizeof(*s) }\n+func (s *sum32a) Size() int { return unsafe.Sizeof(*s) }\n+func (s *sum64) Size() int  { return unsafe.Sizeof(*s) }\n+func (s *sum64a) Size() int { return unsafe.Sizeof(*s) }\n+\n+func (s *sum32) Sum() []byte {\n+\ta := make([]byte, unsafe.Sizeof(*s))\n+\tbinary.BigEndian.PutUint32(a, uint32(*s))\n+\treturn a\n+}\n+\n+func (s *sum32a) Sum() []byte {\n+\ta := make([]byte, unsafe.Sizeof(*s))\n+\tbinary.BigEndian.PutUint32(a, uint32(*s))\n+\treturn a\n+}\n+\n+func (s *sum64) Sum() []byte {\n+\ta := make([]byte, unsafe.Sizeof(*s))\n+\tbinary.BigEndian.PutUint64(a, uint64(*s))\n+\treturn a\n+}\n+\n+func (s *sum64a) Sum() []byte {\n+\ta := make([]byte, unsafe.Sizeof(*s))\n+\tbinary.BigEndian.PutUint64(a, uint64(*s))\n+\treturn a\n+}"}, {"sha": "3ea3fe6f1244ac7071a91f55cc86c094233cb3b8", "filename": "libgo/go/hash/fnv/fnv_test.go", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhash%2Ffnv%2Ffnv_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,167 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package fnv\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/binary\"\n+\t\"hash\"\n+\t\"testing\"\n+)\n+\n+const testDataSize = 40\n+\n+type golden struct {\n+\tsum  []byte\n+\ttext string\n+}\n+\n+var golden32 = []golden{\n+\t{[]byte{0x81, 0x1c, 0x9d, 0xc5}, \"\"},\n+\t{[]byte{0x05, 0x0c, 0x5d, 0x7e}, \"a\"},\n+\t{[]byte{0x70, 0x77, 0x2d, 0x38}, \"ab\"},\n+\t{[]byte{0x43, 0x9c, 0x2f, 0x4b}, \"abc\"},\n+}\n+\n+var golden32a = []golden{\n+\t{[]byte{0x81, 0x1c, 0x9d, 0xc5}, \"\"},\n+\t{[]byte{0xe4, 0x0c, 0x29, 0x2c}, \"a\"},\n+\t{[]byte{0x4d, 0x25, 0x05, 0xca}, \"ab\"},\n+\t{[]byte{0x1a, 0x47, 0xe9, 0x0b}, \"abc\"},\n+}\n+\n+var golden64 = []golden{\n+\t{[]byte{0xcb, 0xf2, 0x9c, 0xe4, 0x84, 0x22, 0x23, 0x25}, \"\"},\n+\t{[]byte{0xaf, 0x63, 0xbd, 0x4c, 0x86, 0x01, 0xb7, 0xbe}, \"a\"},\n+\t{[]byte{0x08, 0x32, 0x67, 0x07, 0xb4, 0xeb, 0x37, 0xb8}, \"ab\"},\n+\t{[]byte{0xd8, 0xdc, 0xca, 0x18, 0x6b, 0xaf, 0xad, 0xcb}, \"abc\"},\n+}\n+\n+var golden64a = []golden{\n+\t{[]byte{0xcb, 0xf2, 0x9c, 0xe4, 0x84, 0x22, 0x23, 0x25}, \"\"},\n+\t{[]byte{0xaf, 0x63, 0xdc, 0x4c, 0x86, 0x01, 0xec, 0x8c}, \"a\"},\n+\t{[]byte{0x08, 0x9c, 0x44, 0x07, 0xb5, 0x45, 0x98, 0x6a}, \"ab\"},\n+\t{[]byte{0xe7, 0x1f, 0xa2, 0x19, 0x05, 0x41, 0x57, 0x4b}, \"abc\"},\n+}\n+\n+func TestGolden32(t *testing.T) {\n+\ttestGolden(t, New32(), golden32)\n+}\n+\n+func TestGolden32a(t *testing.T) {\n+\ttestGolden(t, New32a(), golden32a)\n+}\n+\n+func TestGolden64(t *testing.T) {\n+\ttestGolden(t, New64(), golden64)\n+}\n+\n+func TestGolden64a(t *testing.T) {\n+\ttestGolden(t, New64a(), golden64a)\n+}\n+\n+func testGolden(t *testing.T, hash hash.Hash, gold []golden) {\n+\tfor _, g := range gold {\n+\t\thash.Reset()\n+\t\tdone, error := hash.Write([]byte(g.text))\n+\t\tif error != nil {\n+\t\t\tt.Fatalf(\"write error: %s\", error)\n+\t\t}\n+\t\tif done != len(g.text) {\n+\t\t\tt.Fatalf(\"wrote only %d out of %d bytes\", done, len(g.text))\n+\t\t}\n+\t\tif actual := hash.Sum(); !bytes.Equal(g.sum, actual) {\n+\t\t\tt.Errorf(\"hash(%q) = 0x%x want 0x%x\", g.text, actual, g.sum)\n+\t\t}\n+\t}\n+}\n+\n+func TestIntegrity32(t *testing.T) {\n+\ttestIntegrity(t, New32())\n+}\n+\n+func TestIntegrity32a(t *testing.T) {\n+\ttestIntegrity(t, New32a())\n+}\n+\n+func TestIntegrity64(t *testing.T) {\n+\ttestIntegrity(t, New64())\n+}\n+\n+func TestIntegrity64a(t *testing.T) {\n+\ttestIntegrity(t, New64a())\n+}\n+\n+func testIntegrity(t *testing.T, h hash.Hash) {\n+\tdata := []byte{'1', '2', 3, 4, 5}\n+\th.Write(data)\n+\tsum := h.Sum()\n+\n+\tif size := h.Size(); size != len(sum) {\n+\t\tt.Fatalf(\"Size()=%d but len(Sum())=%d\", size, len(sum))\n+\t}\n+\n+\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\t\tt.Fatalf(\"first Sum()=0x%x, second Sum()=0x%x\", sum, a)\n+\t}\n+\n+\th.Reset()\n+\th.Write(data)\n+\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\t\tt.Fatalf(\"Sum()=0x%x, but after Reset() Sum()=0x%x\", sum, a)\n+\t}\n+\n+\th.Reset()\n+\th.Write(data[:2])\n+\th.Write(data[2:])\n+\tif a := h.Sum(); !bytes.Equal(sum, a) {\n+\t\tt.Fatalf(\"Sum()=0x%x, but with partial writes, Sum()=0x%x\", sum, a)\n+\t}\n+\n+\tswitch h.Size() {\n+\tcase 4:\n+\t\tsum32 := h.(hash.Hash32).Sum32()\n+\t\tif sum32 != binary.BigEndian.Uint32(sum) {\n+\t\t\tt.Fatalf(\"Sum()=0x%x, but Sum32()=0x%x\", sum, sum32)\n+\t\t}\n+\tcase 8:\n+\t\tsum64 := h.(hash.Hash64).Sum64()\n+\t\tif sum64 != binary.BigEndian.Uint64(sum) {\n+\t\t\tt.Fatalf(\"Sum()=0x%x, but Sum64()=0x%x\", sum, sum64)\n+\t\t}\n+\t}\n+}\n+\n+func Benchmark32(b *testing.B) {\n+\tbenchmark(b, New32())\n+}\n+\n+func Benchmark32a(b *testing.B) {\n+\tbenchmark(b, New32a())\n+}\n+\n+func Benchmark64(b *testing.B) {\n+\tbenchmark(b, New64())\n+}\n+\n+func Benchmark64a(b *testing.B) {\n+\tbenchmark(b, New64a())\n+}\n+\n+func benchmark(b *testing.B, h hash.Hash) {\n+\tb.ResetTimer()\n+\tb.SetBytes(testDataSize)\n+\tdata := make([]byte, testDataSize)\n+\tfor i, _ := range data {\n+\t\tdata[i] = byte(i + 'a')\n+\t}\n+\n+\tb.StartTimer()\n+\tfor todo := b.N; todo != 0; todo-- {\n+\t\th.Reset()\n+\t\th.Write(data)\n+\t\th.Sum()\n+\t}\n+}"}, {"sha": "c7d48b9eb3fbd96bb9d3638e5d29de81f3f8de58", "filename": "libgo/go/http/cgi/child.go", "status": "added", "additions": 192, "deletions": 0, "changes": 192, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,192 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements CGI from the perspective of a child\n+// process.\n+\n+package cgi\n+\n+import (\n+\t\"bufio\"\n+\t\"fmt\"\n+\t\"http\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+// Request returns the HTTP request as represented in the current\n+// environment. This assumes the current program is being run\n+// by a web server in a CGI environment.\n+func Request() (*http.Request, os.Error) {\n+\treturn requestFromEnvironment(envMap(os.Environ()))\n+}\n+\n+func envMap(env []string) map[string]string {\n+\tm := make(map[string]string)\n+\tfor _, kv := range env {\n+\t\tif idx := strings.Index(kv, \"=\"); idx != -1 {\n+\t\t\tm[kv[:idx]] = kv[idx+1:]\n+\t\t}\n+\t}\n+\treturn m\n+}\n+\n+// These environment variables are manually copied into Request\n+var skipHeader = map[string]bool{\n+\t\"HTTP_HOST\":       true,\n+\t\"HTTP_REFERER\":    true,\n+\t\"HTTP_USER_AGENT\": true,\n+}\n+\n+func requestFromEnvironment(env map[string]string) (*http.Request, os.Error) {\n+\tr := new(http.Request)\n+\tr.Method = env[\"REQUEST_METHOD\"]\n+\tif r.Method == \"\" {\n+\t\treturn nil, os.NewError(\"cgi: no REQUEST_METHOD in environment\")\n+\t}\n+\tr.Close = true\n+\tr.Trailer = http.Header{}\n+\tr.Header = http.Header{}\n+\n+\tr.Host = env[\"HTTP_HOST\"]\n+\tr.Referer = env[\"HTTP_REFERER\"]\n+\tr.UserAgent = env[\"HTTP_USER_AGENT\"]\n+\n+\t// CGI doesn't allow chunked requests, so these should all be accurate:\n+\tr.Proto = \"HTTP/1.0\"\n+\tr.ProtoMajor = 1\n+\tr.ProtoMinor = 0\n+\tr.TransferEncoding = nil\n+\n+\tif lenstr := env[\"CONTENT_LENGTH\"]; lenstr != \"\" {\n+\t\tclen, err := strconv.Atoi64(lenstr)\n+\t\tif err != nil {\n+\t\t\treturn nil, os.NewError(\"cgi: bad CONTENT_LENGTH in environment: \" + lenstr)\n+\t\t}\n+\t\tr.ContentLength = clen\n+\t\tr.Body = ioutil.NopCloser(io.LimitReader(os.Stdin, clen))\n+\t}\n+\n+\t// Copy \"HTTP_FOO_BAR\" variables to \"Foo-Bar\" Headers\n+\tfor k, v := range env {\n+\t\tif !strings.HasPrefix(k, \"HTTP_\") || skipHeader[k] {\n+\t\t\tcontinue\n+\t\t}\n+\t\tr.Header.Add(strings.Replace(k[5:], \"_\", \"-\", -1), v)\n+\t}\n+\n+\t// TODO: cookies.  parsing them isn't exported, though.\n+\n+\tif r.Host != \"\" {\n+\t\t// Hostname is provided, so we can reasonably construct a URL,\n+\t\t// even if we have to assume 'http' for the scheme.\n+\t\tr.RawURL = \"http://\" + r.Host + env[\"REQUEST_URI\"]\n+\t\turl, err := http.ParseURL(r.RawURL)\n+\t\tif err != nil {\n+\t\t\treturn nil, os.NewError(\"cgi: failed to parse host and REQUEST_URI into a URL: \" + r.RawURL)\n+\t\t}\n+\t\tr.URL = url\n+\t}\n+\t// Fallback logic if we don't have a Host header or the URL\n+\t// failed to parse\n+\tif r.URL == nil {\n+\t\tr.RawURL = env[\"REQUEST_URI\"]\n+\t\turl, err := http.ParseURL(r.RawURL)\n+\t\tif err != nil {\n+\t\t\treturn nil, os.NewError(\"cgi: failed to parse REQUEST_URI into a URL: \" + r.RawURL)\n+\t\t}\n+\t\tr.URL = url\n+\t}\n+\treturn r, nil\n+}\n+\n+// Serve executes the provided Handler on the currently active CGI\n+// request, if any. If there's no current CGI environment\n+// an error is returned. The provided handler may be nil to use\n+// http.DefaultServeMux.\n+func Serve(handler http.Handler) os.Error {\n+\treq, err := Request()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tif handler == nil {\n+\t\thandler = http.DefaultServeMux\n+\t}\n+\trw := &response{\n+\t\treq:    req,\n+\t\theader: make(http.Header),\n+\t\tbufw:   bufio.NewWriter(os.Stdout),\n+\t}\n+\thandler.ServeHTTP(rw, req)\n+\tif err = rw.bufw.Flush(); err != nil {\n+\t\treturn err\n+\t}\n+\treturn nil\n+}\n+\n+type response struct {\n+\treq        *http.Request\n+\theader     http.Header\n+\tbufw       *bufio.Writer\n+\theaderSent bool\n+}\n+\n+func (r *response) Flush() {\n+\tr.bufw.Flush()\n+}\n+\n+func (r *response) RemoteAddr() string {\n+\treturn os.Getenv(\"REMOTE_ADDR\")\n+}\n+\n+func (r *response) Header() http.Header {\n+\treturn r.header\n+}\n+\n+func (r *response) Write(p []byte) (n int, err os.Error) {\n+\tif !r.headerSent {\n+\t\tr.WriteHeader(http.StatusOK)\n+\t}\n+\treturn r.bufw.Write(p)\n+}\n+\n+func (r *response) WriteHeader(code int) {\n+\tif r.headerSent {\n+\t\t// Note: explicitly using Stderr, as Stdout is our HTTP output.\n+\t\tfmt.Fprintf(os.Stderr, \"CGI attempted to write header twice on request for %s\", r.req.URL)\n+\t\treturn\n+\t}\n+\tr.headerSent = true\n+\tfmt.Fprintf(r.bufw, \"Status: %d %s\\r\\n\", code, http.StatusText(code))\n+\n+\t// Set a default Content-Type\n+\tif _, hasType := r.header[\"Content-Type\"]; !hasType {\n+\t\tr.header.Add(\"Content-Type\", \"text/html; charset=utf-8\")\n+\t}\n+\n+\t// TODO: add a method on http.Header to write itself to an io.Writer?\n+\t// This is duplicated code.\n+\tfor k, vv := range r.header {\n+\t\tfor _, v := range vv {\n+\t\t\tv = strings.Replace(v, \"\\n\", \"\", -1)\n+\t\t\tv = strings.Replace(v, \"\\r\", \"\", -1)\n+\t\t\tv = strings.TrimSpace(v)\n+\t\t\tfmt.Fprintf(r.bufw, \"%s: %s\\r\\n\", k, v)\n+\t\t}\n+\t}\n+\tr.bufw.Write([]byte(\"\\r\\n\"))\n+\tr.bufw.Flush()\n+}\n+\n+func (r *response) UsingTLS() bool {\n+\t// There's apparently a de-facto standard for this.\n+\t// http://docstore.mik.ua/orelly/linux/cgi/ch03_02.htm#ch03-35636\n+\tif s := os.Getenv(\"HTTPS\"); s == \"on\" || s == \"ON\" || s == \"1\" {\n+\t\treturn true\n+\t}\n+\treturn false\n+}"}, {"sha": "db0e09cf66a9aeeb866ff2579a95dbdaf60c0e36", "filename": "libgo/go/http/cgi/child_test.go", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fchild_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests for CGI (the child process perspective)\n+\n+package cgi\n+\n+import (\n+\t\"testing\"\n+)\n+\n+func TestRequest(t *testing.T) {\n+\tenv := map[string]string{\n+\t\t\"REQUEST_METHOD\":  \"GET\",\n+\t\t\"HTTP_HOST\":       \"example.com\",\n+\t\t\"HTTP_REFERER\":    \"elsewhere\",\n+\t\t\"HTTP_USER_AGENT\": \"goclient\",\n+\t\t\"HTTP_FOO_BAR\":    \"baz\",\n+\t\t\"REQUEST_URI\":     \"/path?a=b\",\n+\t\t\"CONTENT_LENGTH\":  \"123\",\n+\t}\n+\treq, err := requestFromEnvironment(env)\n+\tif err != nil {\n+\t\tt.Fatalf(\"requestFromEnvironment: %v\", err)\n+\t}\n+\tif g, e := req.UserAgent, \"goclient\"; e != g {\n+\t\tt.Errorf(\"expected UserAgent %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.Method, \"GET\"; e != g {\n+\t\tt.Errorf(\"expected Method %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.Header.Get(\"User-Agent\"), \"\"; e != g {\n+\t\t// Tests that we don't put recognized headers in the map\n+\t\tt.Errorf(\"expected User-Agent %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.ContentLength, int64(123); e != g {\n+\t\tt.Errorf(\"expected ContentLength %d; got %d\", e, g)\n+\t}\n+\tif g, e := req.Referer, \"elsewhere\"; e != g {\n+\t\tt.Errorf(\"expected Referer %q; got %q\", e, g)\n+\t}\n+\tif req.Header == nil {\n+\t\tt.Fatalf(\"unexpected nil Header\")\n+\t}\n+\tif g, e := req.Header.Get(\"Foo-Bar\"), \"baz\"; e != g {\n+\t\tt.Errorf(\"expected Foo-Bar %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.RawURL, \"http://example.com/path?a=b\"; e != g {\n+\t\tt.Errorf(\"expected RawURL %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.URL.String(), \"http://example.com/path?a=b\"; e != g {\n+\t\tt.Errorf(\"expected URL %q; got %q\", e, g)\n+\t}\n+\tif g, e := req.FormValue(\"a\"), \"b\"; e != g {\n+\t\tt.Errorf(\"expected FormValue(a) %q; got %q\", e, g)\n+\t}\n+\tif req.Trailer == nil {\n+\t\tt.Errorf(\"unexpected nil Trailer\")\n+\t}\n+}\n+\n+func TestRequestWithoutHost(t *testing.T) {\n+\tenv := map[string]string{\n+\t\t\"HTTP_HOST\":      \"\",\n+\t\t\"REQUEST_METHOD\": \"GET\",\n+\t\t\"REQUEST_URI\":    \"/path?a=b\",\n+\t\t\"CONTENT_LENGTH\": \"123\",\n+\t}\n+\treq, err := requestFromEnvironment(env)\n+\tif err != nil {\n+\t\tt.Fatalf(\"requestFromEnvironment: %v\", err)\n+\t}\n+\tif g, e := req.RawURL, \"/path?a=b\"; e != g {\n+\t\tt.Errorf(\"expected RawURL %q; got %q\", e, g)\n+\t}\n+\tif req.URL == nil {\n+\t\tt.Fatalf(\"unexpected nil URL\")\n+\t}\n+\tif g, e := req.URL.String(), \"/path?a=b\"; e != g {\n+\t\tt.Errorf(\"expected URL %q; got %q\", e, g)\n+\t}\n+}"}, {"sha": "227238737495544232bb115f63bb25f7287eeb1b", "filename": "libgo/go/http/cgi/host.go", "status": "added", "additions": 221, "deletions": 0, "changes": 221, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,221 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// This file implements the host side of CGI (being the webserver\n+// parent process).\n+\n+// Package cgi implements CGI (Common Gateway Interface) as specified\n+// in RFC 3875.\n+//\n+// Note that using CGI means starting a new process to handle each\n+// request, which is typically less efficient than using a\n+// long-running server.  This package is intended primarily for\n+// compatibility with existing systems.\n+package cgi\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/line\"\n+\t\"exec\"\n+\t\"fmt\"\n+\t\"http\"\n+\t\"io\"\n+\t\"log\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"regexp\"\n+\t\"strconv\"\n+\t\"strings\"\n+)\n+\n+var trailingPort = regexp.MustCompile(`:([0-9]+)$`)\n+\n+// Handler runs an executable in a subprocess with a CGI environment.\n+type Handler struct {\n+\tPath string // path to the CGI executable\n+\tRoot string // root URI prefix of handler or empty for \"/\"\n+\n+\tEnv    []string    // extra environment variables to set, if any\n+\tLogger *log.Logger // optional log for errors or nil to use log.Print\n+\tArgs   []string    // optional arguments to pass to child process\n+}\n+\n+func (h *Handler) ServeHTTP(rw http.ResponseWriter, req *http.Request) {\n+\troot := h.Root\n+\tif root == \"\" {\n+\t\troot = \"/\"\n+\t}\n+\n+\tif len(req.TransferEncoding) > 0 && req.TransferEncoding[0] == \"chunked\" {\n+\t\trw.WriteHeader(http.StatusBadRequest)\n+\t\trw.Write([]byte(\"Chunked request bodies are not supported by CGI.\"))\n+\t\treturn\n+\t}\n+\n+\tpathInfo := req.URL.Path\n+\tif root != \"/\" && strings.HasPrefix(pathInfo, root) {\n+\t\tpathInfo = pathInfo[len(root):]\n+\t}\n+\n+\tport := \"80\"\n+\tif matches := trailingPort.FindStringSubmatch(req.Host); len(matches) != 0 {\n+\t\tport = matches[1]\n+\t}\n+\n+\tenv := []string{\n+\t\t\"SERVER_SOFTWARE=go\",\n+\t\t\"SERVER_NAME=\" + req.Host,\n+\t\t\"HTTP_HOST=\" + req.Host,\n+\t\t\"GATEWAY_INTERFACE=CGI/1.1\",\n+\t\t\"REQUEST_METHOD=\" + req.Method,\n+\t\t\"QUERY_STRING=\" + req.URL.RawQuery,\n+\t\t\"REQUEST_URI=\" + req.URL.RawPath,\n+\t\t\"PATH_INFO=\" + pathInfo,\n+\t\t\"SCRIPT_NAME=\" + root,\n+\t\t\"SCRIPT_FILENAME=\" + h.Path,\n+\t\t\"REMOTE_ADDR=\" + req.RemoteAddr,\n+\t\t\"REMOTE_HOST=\" + req.RemoteAddr,\n+\t\t\"SERVER_PORT=\" + port,\n+\t}\n+\n+\tif req.TLS != nil {\n+\t\tenv = append(env, \"HTTPS=on\")\n+\t}\n+\n+\tif len(req.Cookie) > 0 {\n+\t\tb := new(bytes.Buffer)\n+\t\tfor idx, c := range req.Cookie {\n+\t\t\tif idx > 0 {\n+\t\t\t\tb.Write([]byte(\"; \"))\n+\t\t\t}\n+\t\t\tfmt.Fprintf(b, \"%s=%s\", c.Name, c.Value)\n+\t\t}\n+\t\tenv = append(env, \"HTTP_COOKIE=\"+b.String())\n+\t}\n+\n+\tfor k, v := range req.Header {\n+\t\tk = strings.Map(upperCaseAndUnderscore, k)\n+\t\tenv = append(env, \"HTTP_\"+k+\"=\"+strings.Join(v, \", \"))\n+\t}\n+\n+\tif req.ContentLength > 0 {\n+\t\tenv = append(env, fmt.Sprintf(\"CONTENT_LENGTH=%d\", req.ContentLength))\n+\t}\n+\tif ctype := req.Header.Get(\"Content-Type\"); ctype != \"\" {\n+\t\tenv = append(env, \"CONTENT_TYPE=\"+ctype)\n+\t}\n+\n+\tif h.Env != nil {\n+\t\tenv = append(env, h.Env...)\n+\t}\n+\n+\tcwd, pathBase := filepath.Split(h.Path)\n+\tif cwd == \"\" {\n+\t\tcwd = \".\"\n+\t}\n+\n+\targs := []string{h.Path}\n+\targs = append(args, h.Args...)\n+\n+\tcmd, err := exec.Run(\n+\t\tpathBase,\n+\t\targs,\n+\t\tenv,\n+\t\tcwd,\n+\t\texec.Pipe,        // stdin\n+\t\texec.Pipe,        // stdout\n+\t\texec.PassThrough, // stderr (for now)\n+\t)\n+\tif err != nil {\n+\t\trw.WriteHeader(http.StatusInternalServerError)\n+\t\th.printf(\"CGI error: %v\", err)\n+\t\treturn\n+\t}\n+\tdefer func() {\n+\t\tcmd.Stdin.Close()\n+\t\tcmd.Stdout.Close()\n+\t\tcmd.Wait(0) // no zombies\n+\t}()\n+\n+\tif req.ContentLength != 0 {\n+\t\tgo io.Copy(cmd.Stdin, req.Body)\n+\t}\n+\n+\tlinebody := line.NewReader(cmd.Stdout, 1024)\n+\theaders := rw.Header()\n+\tstatusCode := http.StatusOK\n+\tfor {\n+\t\tline, isPrefix, err := linebody.ReadLine()\n+\t\tif isPrefix {\n+\t\t\trw.WriteHeader(http.StatusInternalServerError)\n+\t\t\th.printf(\"CGI: long header line from subprocess.\")\n+\t\t\treturn\n+\t\t}\n+\t\tif err == os.EOF {\n+\t\t\tbreak\n+\t\t}\n+\t\tif err != nil {\n+\t\t\trw.WriteHeader(http.StatusInternalServerError)\n+\t\t\th.printf(\"CGI: error reading headers: %v\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif len(line) == 0 {\n+\t\t\tbreak\n+\t\t}\n+\t\tparts := strings.Split(string(line), \":\", 2)\n+\t\tif len(parts) < 2 {\n+\t\t\th.printf(\"CGI: bogus header line: %s\", string(line))\n+\t\t\tcontinue\n+\t\t}\n+\t\theader, val := parts[0], parts[1]\n+\t\theader = strings.TrimSpace(header)\n+\t\tval = strings.TrimSpace(val)\n+\t\tswitch {\n+\t\tcase header == \"Status\":\n+\t\t\tif len(val) < 3 {\n+\t\t\t\th.printf(\"CGI: bogus status (short): %q\", val)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tcode, err := strconv.Atoi(val[0:3])\n+\t\t\tif err != nil {\n+\t\t\t\th.printf(\"CGI: bogus status: %q\", val)\n+\t\t\t\th.printf(\"CGI: line was %q\", line)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tstatusCode = code\n+\t\tdefault:\n+\t\t\theaders.Add(header, val)\n+\t\t}\n+\t}\n+\trw.WriteHeader(statusCode)\n+\n+\t_, err = io.Copy(rw, linebody)\n+\tif err != nil {\n+\t\th.printf(\"CGI: copy error: %v\", err)\n+\t}\n+}\n+\n+func (h *Handler) printf(format string, v ...interface{}) {\n+\tif h.Logger != nil {\n+\t\th.Logger.Printf(format, v...)\n+\t} else {\n+\t\tlog.Printf(format, v...)\n+\t}\n+}\n+\n+func upperCaseAndUnderscore(rune int) int {\n+\tswitch {\n+\tcase rune >= 'a' && rune <= 'z':\n+\t\treturn rune - ('a' - 'A')\n+\tcase rune == '-':\n+\t\treturn '_'\n+\tcase rune == '=':\n+\t\t// Maybe not part of the CGI 'spec' but would mess up\n+\t\t// the environment in any case, as Go represents the\n+\t\t// environment as a slice of \"key=value\" strings.\n+\t\treturn '_'\n+\t}\n+\t// TODO: other transformations in spec or practice?\n+\treturn rune\n+}"}, {"sha": "e8084b1134e3e8f8235933b106238c525e376e22", "filename": "libgo/go/http/cgi/host_test.go", "status": "added", "additions": 273, "deletions": 0, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fhost_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,273 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests for package cgi\n+\n+package cgi\n+\n+import (\n+\t\"bufio\"\n+\t\"exec\"\n+\t\"fmt\"\n+\t\"http\"\n+\t\"http/httptest\"\n+\t\"os\"\n+\t\"strings\"\n+\t\"testing\"\n+)\n+\n+var cgiScriptWorks = canRun(\"./testdata/test.cgi\")\n+\n+func canRun(s string) bool {\n+\tc, err := exec.Run(s, []string{s}, nil, \".\", exec.DevNull, exec.DevNull, exec.DevNull)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\tw, err := c.Wait(0)\n+\tif err != nil {\n+\t\treturn false\n+\t}\n+\treturn w.Exited() && w.ExitStatus() == 0\n+}\n+\n+func newRequest(httpreq string) *http.Request {\n+\tbuf := bufio.NewReader(strings.NewReader(httpreq))\n+\treq, err := http.ReadRequest(buf)\n+\tif err != nil {\n+\t\tpanic(\"cgi: bogus http request in test: \" + httpreq)\n+\t}\n+\treq.RemoteAddr = \"1.2.3.4\"\n+\treturn req\n+}\n+\n+func runCgiTest(t *testing.T, h *Handler, httpreq string, expectedMap map[string]string) *httptest.ResponseRecorder {\n+\trw := httptest.NewRecorder()\n+\treq := newRequest(httpreq)\n+\th.ServeHTTP(rw, req)\n+\n+\t// Make a map to hold the test map that the CGI returns.\n+\tm := make(map[string]string)\n+\tlinesRead := 0\n+readlines:\n+\tfor {\n+\t\tline, err := rw.Body.ReadString('\\n')\n+\t\tswitch {\n+\t\tcase err == os.EOF:\n+\t\t\tbreak readlines\n+\t\tcase err != nil:\n+\t\t\tt.Fatalf(\"unexpected error reading from CGI: %v\", err)\n+\t\t}\n+\t\tlinesRead++\n+\t\ttrimmedLine := strings.TrimRight(line, \"\\r\\n\")\n+\t\tsplit := strings.Split(trimmedLine, \"=\", 2)\n+\t\tif len(split) != 2 {\n+\t\t\tt.Fatalf(\"Unexpected %d parts from invalid line number %v: %q; existing map=%v\",\n+\t\t\t\tlen(split), linesRead, line, m)\n+\t\t}\n+\t\tm[split[0]] = split[1]\n+\t}\n+\n+\tfor key, expected := range expectedMap {\n+\t\tif got := m[key]; got != expected {\n+\t\t\tt.Errorf(\"for key %q got %q; expected %q\", key, got, expected)\n+\t\t}\n+\t}\n+\treturn rw\n+}\n+\n+func skipTest(t *testing.T) bool {\n+\tif !cgiScriptWorks {\n+\t\t// No Perl on Windows, needed by test.cgi\n+\t\t// TODO: make the child process be Go, not Perl.\n+\t\tt.Logf(\"Skipping test: test.cgi failed.\")\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+\n+func TestCGIBasicGet(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"test\":                  \"Hello CGI\",\n+\t\t\"param-a\":               \"b\",\n+\t\t\"param-foo\":             \"bar\",\n+\t\t\"env-GATEWAY_INTERFACE\": \"CGI/1.1\",\n+\t\t\"env-HTTP_HOST\":         \"example.com\",\n+\t\t\"env-PATH_INFO\":         \"\",\n+\t\t\"env-QUERY_STRING\":      \"foo=bar&a=b\",\n+\t\t\"env-REMOTE_ADDR\":       \"1.2.3.4\",\n+\t\t\"env-REMOTE_HOST\":       \"1.2.3.4\",\n+\t\t\"env-REQUEST_METHOD\":    \"GET\",\n+\t\t\"env-REQUEST_URI\":       \"/test.cgi?foo=bar&a=b\",\n+\t\t\"env-SCRIPT_FILENAME\":   \"testdata/test.cgi\",\n+\t\t\"env-SCRIPT_NAME\":       \"/test.cgi\",\n+\t\t\"env-SERVER_NAME\":       \"example.com\",\n+\t\t\"env-SERVER_PORT\":       \"80\",\n+\t\t\"env-SERVER_SOFTWARE\":   \"go\",\n+\t}\n+\treplay := runCgiTest(t, h, \"GET /test.cgi?foo=bar&a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+\n+\tif expected, got := \"text/html\", replay.Header().Get(\"Content-Type\"); got != expected {\n+\t\tt.Errorf(\"got a Content-Type of %q; expected %q\", got, expected)\n+\t}\n+\tif expected, got := \"X-Test-Value\", replay.Header().Get(\"X-Test-Header\"); got != expected {\n+\t\tt.Errorf(\"got a X-Test-Header of %q; expected %q\", got, expected)\n+\t}\n+}\n+\n+func TestCGIBasicGetAbsPath(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\tpwd, err := os.Getwd()\n+\tif err != nil {\n+\t\tt.Fatalf(\"getwd error: %v\", err)\n+\t}\n+\th := &Handler{\n+\t\tPath: pwd + \"/testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"env-REQUEST_URI\":     \"/test.cgi?foo=bar&a=b\",\n+\t\t\"env-SCRIPT_FILENAME\": pwd + \"/testdata/test.cgi\",\n+\t\t\"env-SCRIPT_NAME\":     \"/test.cgi\",\n+\t}\n+\trunCgiTest(t, h, \"GET /test.cgi?foo=bar&a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+}\n+\n+func TestPathInfo(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"param-a\":             \"b\",\n+\t\t\"env-PATH_INFO\":       \"/extrapath\",\n+\t\t\"env-QUERY_STRING\":    \"a=b\",\n+\t\t\"env-REQUEST_URI\":     \"/test.cgi/extrapath?a=b\",\n+\t\t\"env-SCRIPT_FILENAME\": \"testdata/test.cgi\",\n+\t\t\"env-SCRIPT_NAME\":     \"/test.cgi\",\n+\t}\n+\trunCgiTest(t, h, \"GET /test.cgi/extrapath?a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+}\n+\n+func TestPathInfoDirRoot(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/myscript/\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"env-PATH_INFO\":       \"bar\",\n+\t\t\"env-QUERY_STRING\":    \"a=b\",\n+\t\t\"env-REQUEST_URI\":     \"/myscript/bar?a=b\",\n+\t\t\"env-SCRIPT_FILENAME\": \"testdata/test.cgi\",\n+\t\t\"env-SCRIPT_NAME\":     \"/myscript/\",\n+\t}\n+\trunCgiTest(t, h, \"GET /myscript/bar?a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+}\n+\n+func TestDupHeaders(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"env-REQUEST_URI\":     \"/myscript/bar?a=b\",\n+\t\t\"env-SCRIPT_FILENAME\": \"testdata/test.cgi\",\n+\t\t\"env-HTTP_COOKIE\":     \"nom=NOM; yum=YUM\",\n+\t\t\"env-HTTP_X_FOO\":      \"val1, val2\",\n+\t}\n+\trunCgiTest(t, h, \"GET /myscript/bar?a=b HTTP/1.0\\n\"+\n+\t\t\"Cookie: nom=NOM\\n\"+\n+\t\t\"Cookie: yum=YUM\\n\"+\n+\t\t\"X-Foo: val1\\n\"+\n+\t\t\"X-Foo: val2\\n\"+\n+\t\t\"Host: example.com\\n\\n\",\n+\t\texpectedMap)\n+}\n+\n+func TestPathInfoNoRoot(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"env-PATH_INFO\":       \"/bar\",\n+\t\t\"env-QUERY_STRING\":    \"a=b\",\n+\t\t\"env-REQUEST_URI\":     \"/bar?a=b\",\n+\t\t\"env-SCRIPT_FILENAME\": \"testdata/test.cgi\",\n+\t\t\"env-SCRIPT_NAME\":     \"/\",\n+\t}\n+\trunCgiTest(t, h, \"GET /bar?a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+}\n+\n+func TestCGIBasicPost(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\tpostReq := `POST /test.cgi?a=b HTTP/1.0\n+Host: example.com\n+Content-Type: application/x-www-form-urlencoded\n+Content-Length: 15\n+\n+postfoo=postbar`\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"test\":               \"Hello CGI\",\n+\t\t\"param-postfoo\":      \"postbar\",\n+\t\t\"env-REQUEST_METHOD\": \"POST\",\n+\t\t\"env-CONTENT_LENGTH\": \"15\",\n+\t\t\"env-REQUEST_URI\":    \"/test.cgi?a=b\",\n+\t}\n+\trunCgiTest(t, h, postReq, expectedMap)\n+}\n+\n+func chunk(s string) string {\n+\treturn fmt.Sprintf(\"%x\\r\\n%s\\r\\n\", len(s), s)\n+}\n+\n+// The CGI spec doesn't allow chunked requests.\n+func TestCGIPostChunked(t *testing.T) {\n+\tif skipTest(t) {\n+\t\treturn\n+\t}\n+\tpostReq := `POST /test.cgi?a=b HTTP/1.1\n+Host: example.com\n+Content-Type: application/x-www-form-urlencoded\n+Transfer-Encoding: chunked\n+\n+` + chunk(\"postfoo\") + chunk(\"=\") + chunk(\"postbar\") + chunk(\"\")\n+\n+\th := &Handler{\n+\t\tPath: \"testdata/test.cgi\",\n+\t\tRoot: \"/test.cgi\",\n+\t}\n+\texpectedMap := map[string]string{}\n+\tresp := runCgiTest(t, h, postReq, expectedMap)\n+\tif got, expected := resp.Code, http.StatusBadRequest; got != expected {\n+\t\tt.Fatalf(\"Expected %v response code from chunked request body; got %d\",\n+\t\t\texpected, got)\n+\t}\n+}"}, {"sha": "3e4a6addfa5dd182ff57bac33ed4cc0632954650", "filename": "libgo/go/http/cgi/matryoshka_test.go", "status": "added", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fmatryoshka_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcgi%2Fmatryoshka_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcgi%2Fmatryoshka_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests a Go CGI program running under a Go CGI host process.\n+// Further, the two programs are the same binary, just checking\n+// their environment to figure out what mode to run in.\n+\n+package cgi\n+\n+import (\n+\t\"fmt\"\n+\t\"http\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+// This test is a CGI host (testing host.go) that runs its own binary\n+// as a child process testing the other half of CGI (child.go).\n+func TestHostingOurselves(t *testing.T) {\n+\th := &Handler{\n+\t\tPath: os.Args[0],\n+\t\tRoot: \"/test.go\",\n+\t\tArgs: []string{\"-test.run=TestBeChildCGIProcess\"},\n+\t}\n+\texpectedMap := map[string]string{\n+\t\t\"test\":                  \"Hello CGI-in-CGI\",\n+\t\t\"param-a\":               \"b\",\n+\t\t\"param-foo\":             \"bar\",\n+\t\t\"env-GATEWAY_INTERFACE\": \"CGI/1.1\",\n+\t\t\"env-HTTP_HOST\":         \"example.com\",\n+\t\t\"env-PATH_INFO\":         \"\",\n+\t\t\"env-QUERY_STRING\":      \"foo=bar&a=b\",\n+\t\t\"env-REMOTE_ADDR\":       \"1.2.3.4\",\n+\t\t\"env-REMOTE_HOST\":       \"1.2.3.4\",\n+\t\t\"env-REQUEST_METHOD\":    \"GET\",\n+\t\t\"env-REQUEST_URI\":       \"/test.go?foo=bar&a=b\",\n+\t\t\"env-SCRIPT_FILENAME\":   os.Args[0],\n+\t\t\"env-SCRIPT_NAME\":       \"/test.go\",\n+\t\t\"env-SERVER_NAME\":       \"example.com\",\n+\t\t\"env-SERVER_PORT\":       \"80\",\n+\t\t\"env-SERVER_SOFTWARE\":   \"go\",\n+\t}\n+\treplay := runCgiTest(t, h, \"GET /test.go?foo=bar&a=b HTTP/1.0\\nHost: example.com\\n\\n\", expectedMap)\n+\n+\tif expected, got := \"text/html; charset=utf-8\", replay.Header().Get(\"Content-Type\"); got != expected {\n+\t\tt.Errorf(\"got a Content-Type of %q; expected %q\", got, expected)\n+\t}\n+\tif expected, got := \"X-Test-Value\", replay.Header().Get(\"X-Test-Header\"); got != expected {\n+\t\tt.Errorf(\"got a X-Test-Header of %q; expected %q\", got, expected)\n+\t}\n+}\n+\n+// Note: not actually a test.\n+func TestBeChildCGIProcess(t *testing.T) {\n+\tif os.Getenv(\"REQUEST_METHOD\") == \"\" {\n+\t\t// Not in a CGI environment; skipping test.\n+\t\treturn\n+\t}\n+\tServe(http.HandlerFunc(func(rw http.ResponseWriter, req *http.Request) {\n+\t\trw.Header().Set(\"X-Test-Header\", \"X-Test-Value\")\n+\t\tfmt.Fprintf(rw, \"test=Hello CGI-in-CGI\\n\")\n+\t\treq.ParseForm()\n+\t\tfor k, vv := range req.Form {\n+\t\t\tfor _, v := range vv {\n+\t\t\t\tfmt.Fprintf(rw, \"param-%s=%s\\n\", k, v)\n+\t\t\t}\n+\t\t}\n+\t\tfor _, kv := range os.Environ() {\n+\t\t\tfmt.Fprintf(rw, \"env-%s\\n\", kv)\n+\t\t}\n+\t}))\n+\tos.Exit(0)\n+}"}, {"sha": "daba3a89b0c21effce0c6f9e4f85c3d97afb6968", "filename": "libgo/go/http/client.go", "status": "modified", "additions": 21, "deletions": 62, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -11,6 +11,7 @@ import (\n \t\"encoding/base64\"\n \t\"fmt\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n \t\"strconv\"\n \t\"strings\"\n@@ -20,26 +21,28 @@ import (\n // that uses DefaultTransport.\n // Client is not yet very configurable.\n type Client struct {\n-\tTransport ClientTransport // if nil, DefaultTransport is used\n+\tTransport RoundTripper // if nil, DefaultTransport is used\n }\n \n // DefaultClient is the default Client and is used by Get, Head, and Post.\n var DefaultClient = &Client{}\n \n-// ClientTransport is an interface representing the ability to execute a\n+// RoundTripper is an interface representing the ability to execute a\n // single HTTP transaction, obtaining the Response for a given Request.\n-type ClientTransport interface {\n-\t// Do executes a single HTTP transaction, returning the Response for the\n-\t// request req.  Do should not attempt to interpret the response.\n-\t// In particular, Do must return err == nil if it obtained a response,\n-\t// regardless of the response's HTTP status code.  A non-nil err should\n-\t// be reserved for failure to obtain a response.  Similarly, Do should\n-\t// not attempt to handle higher-level protocol details such as redirects,\n+type RoundTripper interface {\n+\t// RoundTrip executes a single HTTP transaction, returning\n+\t// the Response for the request req.  RoundTrip should not\n+\t// attempt to interpret the response.  In particular,\n+\t// RoundTrip must return err == nil if it obtained a response,\n+\t// regardless of the response's HTTP status code.  A non-nil\n+\t// err should be reserved for failure to obtain a response.\n+\t// Similarly, RoundTrip should not attempt to handle\n+\t// higher-level protocol details such as redirects,\n \t// authentication, or cookies.\n \t//\n-\t// Transports may modify the request. The request Headers field is\n-\t// guaranteed to be initalized.\n-\tDo(req *Request) (resp *Response, err os.Error)\n+\t// RoundTrip may modify the request. The request Headers field is\n+\t// guaranteed to be initialized.\n+\tRoundTrip(req *Request) (resp *Response, err os.Error)\n }\n \n // Given a string of the form \"host\", \"host:port\", or \"[ipv6::address]:port\",\n@@ -54,40 +57,6 @@ type readClose struct {\n \tio.Closer\n }\n \n-// matchNoProxy returns true if requests to addr should not use a proxy,\n-// according to the NO_PROXY or no_proxy environment variable.\n-func matchNoProxy(addr string) bool {\n-\tif len(addr) == 0 {\n-\t\treturn false\n-\t}\n-\tno_proxy := os.Getenv(\"NO_PROXY\")\n-\tif len(no_proxy) == 0 {\n-\t\tno_proxy = os.Getenv(\"no_proxy\")\n-\t}\n-\tif no_proxy == \"*\" {\n-\t\treturn true\n-\t}\n-\n-\taddr = strings.ToLower(strings.TrimSpace(addr))\n-\tif hasPort(addr) {\n-\t\taddr = addr[:strings.LastIndex(addr, \":\")]\n-\t}\n-\n-\tfor _, p := range strings.Split(no_proxy, \",\", -1) {\n-\t\tp = strings.ToLower(strings.TrimSpace(p))\n-\t\tif len(p) == 0 {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif hasPort(p) {\n-\t\t\tp = p[:strings.LastIndex(p, \":\")]\n-\t\t}\n-\t\tif addr == p || (p[0] == '.' && (strings.HasSuffix(addr, p) || addr == p[1:])) {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n // Do sends an HTTP request and returns an HTTP response, following\n // policy (e.g. redirects, cookies, auth) as configured on the client.\n //\n@@ -100,11 +69,7 @@ func (c *Client) Do(req *Request) (resp *Response, err os.Error) {\n \n \n // send issues an HTTP request.  Caller should close resp.Body when done reading from it.\n-//\n-// TODO: support persistent connections (multiple requests on a single connection).\n-// send() method is nonpublic because, when we refactor the code for persistent\n-// connections, it may no longer make sense to have a method with this signature.\n-func send(req *Request, t ClientTransport) (resp *Response, err os.Error) {\n+func send(req *Request, t RoundTripper) (resp *Response, err os.Error) {\n \tif t == nil {\n \t\tt = DefaultTransport\n \t\tif t == nil {\n@@ -115,9 +80,9 @@ func send(req *Request, t ClientTransport) (resp *Response, err os.Error) {\n \n \t// Most the callers of send (Get, Post, et al) don't need\n \t// Headers, leaving it uninitialized.  We guarantee to the\n-\t// ClientTransport that this has been initialized, though.\n+\t// Transport that this has been initialized, though.\n \tif req.Header == nil {\n-\t\treq.Header = Header(make(map[string][]string))\n+\t\treq.Header = make(Header)\n \t}\n \n \tinfo := req.URL.RawUserinfo\n@@ -130,7 +95,7 @@ func send(req *Request, t ClientTransport) (resp *Response, err os.Error) {\n \t\t}\n \t\treq.Header.Set(\"Authorization\", \"Basic \"+string(encoded))\n \t}\n-\treturn t.Do(req)\n+\treturn t.RoundTrip(req)\n }\n \n // True if the specified HTTP status code is one for which the Get utility should\n@@ -237,7 +202,7 @@ func (c *Client) Post(url string, bodyType string, body io.Reader) (r *Response,\n \treq.ProtoMajor = 1\n \treq.ProtoMinor = 1\n \treq.Close = true\n-\treq.Body = nopCloser{body}\n+\treq.Body = ioutil.NopCloser(body)\n \treq.Header = Header{\n \t\t\"Content-Type\": {bodyType},\n \t}\n@@ -272,7 +237,7 @@ func (c *Client) PostForm(url string, data map[string]string) (r *Response, err\n \treq.ProtoMinor = 1\n \treq.Close = true\n \tbody := urlencode(data)\n-\treq.Body = nopCloser{body}\n+\treq.Body = ioutil.NopCloser(body)\n \treq.Header = Header{\n \t\t\"Content-Type\":   {\"application/x-www-form-urlencoded\"},\n \t\t\"Content-Length\": {strconv.Itoa(body.Len())},\n@@ -312,9 +277,3 @@ func (c *Client) Head(url string) (r *Response, err os.Error) {\n \t}\n \treturn send(&req, c.Transport)\n }\n-\n-type nopCloser struct {\n-\tio.Reader\n-}\n-\n-func (nopCloser) Close() os.Error { return nil }"}, {"sha": "3a6f834253b3fef59b693a8a176df63ddb939ede", "filename": "libgo/go/http/client_test.go", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fclient_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -4,20 +4,28 @@\n \n // Tests for client.go\n \n-package http\n+package http_test\n \n import (\n+\t\"fmt\"\n+\t. \"http\"\n+\t\"http/httptest\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"strings\"\n \t\"testing\"\n )\n \n+var robotsTxtHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n+\tw.Header().Set(\"Last-Modified\", \"sometime\")\n+\tfmt.Fprintf(w, \"User-agent: go\\nDisallow: /something/\")\n+})\n+\n func TestClient(t *testing.T) {\n-\t// TODO: add a proper test suite.  Current test merely verifies that\n-\t// we can retrieve the Google robots.txt file.\n+\tts := httptest.NewServer(robotsTxtHandler)\n+\tdefer ts.Close()\n \n-\tr, _, err := Get(\"http://www.google.com/robots.txt\")\n+\tr, _, err := Get(ts.URL)\n \tvar b []byte\n \tif err == nil {\n \t\tb, err = ioutil.ReadAll(r.Body)\n@@ -31,7 +39,10 @@ func TestClient(t *testing.T) {\n }\n \n func TestClientHead(t *testing.T) {\n-\tr, err := Head(\"http://www.google.com/robots.txt\")\n+\tts := httptest.NewServer(robotsTxtHandler)\n+\tdefer ts.Close()\n+\n+\tr, err := Head(ts.URL)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -44,7 +55,7 @@ type recordingTransport struct {\n \treq *Request\n }\n \n-func (t *recordingTransport) Do(req *Request) (resp *Response, err os.Error) {\n+func (t *recordingTransport) RoundTrip(req *Request) (resp *Response, err os.Error) {\n \tt.req = req\n \treturn nil, os.NewError(\"dummy impl\")\n }"}, {"sha": "2bb66e58e5c4c7c7072e2dce1a728ecc8cbf5506", "filename": "libgo/go/http/cookie.go", "status": "added", "additions": 272, "deletions": 0, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,272 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strconv\"\n+\t\"strings\"\n+\t\"time\"\n+)\n+\n+// This implementation is done according to IETF draft-ietf-httpstate-cookie-23, found at\n+//\n+//    http://tools.ietf.org/html/draft-ietf-httpstate-cookie-23\n+\n+// A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an\n+// HTTP response or the Cookie header of an HTTP request.\n+type Cookie struct {\n+\tName       string\n+\tValue      string\n+\tPath       string\n+\tDomain     string\n+\tExpires    time.Time\n+\tRawExpires string\n+\n+\t// MaxAge=0 means no 'Max-Age' attribute specified. \n+\t// MaxAge<0 means delete cookie now, equivalently 'Max-Age: 0'\n+\t// MaxAge>0 means Max-Age attribute present and given in seconds\n+\tMaxAge   int\n+\tSecure   bool\n+\tHttpOnly bool\n+\tRaw      string\n+\tUnparsed []string // Raw text of unparsed attribute-value pairs\n+}\n+\n+// readSetCookies parses all \"Set-Cookie\" values from\n+// the header h, removes the successfully parsed values from the \n+// \"Set-Cookie\" key in h and returns the parsed Cookies.\n+func readSetCookies(h Header) []*Cookie {\n+\tcookies := []*Cookie{}\n+\tvar unparsedLines []string\n+\tfor _, line := range h[\"Set-Cookie\"] {\n+\t\tparts := strings.Split(strings.TrimSpace(line), \";\", -1)\n+\t\tif len(parts) == 1 && parts[0] == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tparts[0] = strings.TrimSpace(parts[0])\n+\t\tj := strings.Index(parts[0], \"=\")\n+\t\tif j < 0 {\n+\t\t\tunparsedLines = append(unparsedLines, line)\n+\t\t\tcontinue\n+\t\t}\n+\t\tname, value := parts[0][:j], parts[0][j+1:]\n+\t\tif !isCookieNameValid(name) {\n+\t\t\tunparsedLines = append(unparsedLines, line)\n+\t\t\tcontinue\n+\t\t}\n+\t\tvalue, success := parseCookieValue(value)\n+\t\tif !success {\n+\t\t\tunparsedLines = append(unparsedLines, line)\n+\t\t\tcontinue\n+\t\t}\n+\t\tc := &Cookie{\n+\t\t\tName:  name,\n+\t\t\tValue: value,\n+\t\t\tRaw:   line,\n+\t\t}\n+\t\tfor i := 1; i < len(parts); i++ {\n+\t\t\tparts[i] = strings.TrimSpace(parts[i])\n+\t\t\tif len(parts[i]) == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tattr, val := parts[i], \"\"\n+\t\t\tif j := strings.Index(attr, \"=\"); j >= 0 {\n+\t\t\t\tattr, val = attr[:j], attr[j+1:]\n+\t\t\t}\n+\t\t\tval, success = parseCookieValue(val)\n+\t\t\tif !success {\n+\t\t\t\tc.Unparsed = append(c.Unparsed, parts[i])\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tswitch strings.ToLower(attr) {\n+\t\t\tcase \"secure\":\n+\t\t\t\tc.Secure = true\n+\t\t\t\tcontinue\n+\t\t\tcase \"httponly\":\n+\t\t\t\tc.HttpOnly = true\n+\t\t\t\tcontinue\n+\t\t\tcase \"domain\":\n+\t\t\t\tc.Domain = val\n+\t\t\t\t// TODO: Add domain parsing\n+\t\t\t\tcontinue\n+\t\t\tcase \"max-age\":\n+\t\t\t\tsecs, err := strconv.Atoi(val)\n+\t\t\t\tif err != nil || secs < 0 || secs != 0 && val[0] == '0' {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif secs <= 0 {\n+\t\t\t\t\tc.MaxAge = -1\n+\t\t\t\t} else {\n+\t\t\t\t\tc.MaxAge = secs\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\tcase \"expires\":\n+\t\t\t\tc.RawExpires = val\n+\t\t\t\texptime, err := time.Parse(time.RFC1123, val)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\tc.Expires = time.Time{}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tc.Expires = *exptime\n+\t\t\t\tcontinue\n+\t\t\tcase \"path\":\n+\t\t\t\tc.Path = val\n+\t\t\t\t// TODO: Add path parsing\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tc.Unparsed = append(c.Unparsed, parts[i])\n+\t\t}\n+\t\tcookies = append(cookies, c)\n+\t}\n+\th[\"Set-Cookie\"] = unparsedLines, unparsedLines != nil\n+\treturn cookies\n+}\n+\n+// writeSetCookies writes the wire representation of the set-cookies\n+// to w. Each cookie is written on a separate \"Set-Cookie: \" line.\n+// This choice is made because HTTP parsers tend to have a limit on\n+// line-length, so it seems safer to place cookies on separate lines.\n+func writeSetCookies(w io.Writer, kk []*Cookie) os.Error {\n+\tif kk == nil {\n+\t\treturn nil\n+\t}\n+\tlines := make([]string, 0, len(kk))\n+\tvar b bytes.Buffer\n+\tfor _, c := range kk {\n+\t\tb.Reset()\n+\t\tfmt.Fprintf(&b, \"%s=%s\", c.Name, c.Value)\n+\t\tif len(c.Path) > 0 {\n+\t\t\tfmt.Fprintf(&b, \"; Path=%s\", URLEscape(c.Path))\n+\t\t}\n+\t\tif len(c.Domain) > 0 {\n+\t\t\tfmt.Fprintf(&b, \"; Domain=%s\", URLEscape(c.Domain))\n+\t\t}\n+\t\tif len(c.Expires.Zone) > 0 {\n+\t\t\tfmt.Fprintf(&b, \"; Expires=%s\", c.Expires.Format(time.RFC1123))\n+\t\t}\n+\t\tif c.MaxAge > 0 {\n+\t\t\tfmt.Fprintf(&b, \"; Max-Age=%d\", c.MaxAge)\n+\t\t} else if c.MaxAge < 0 {\n+\t\t\tfmt.Fprintf(&b, \"; Max-Age=0\")\n+\t\t}\n+\t\tif c.HttpOnly {\n+\t\t\tfmt.Fprintf(&b, \"; HttpOnly\")\n+\t\t}\n+\t\tif c.Secure {\n+\t\t\tfmt.Fprintf(&b, \"; Secure\")\n+\t\t}\n+\t\tlines = append(lines, \"Set-Cookie: \"+b.String()+\"\\r\\n\")\n+\t}\n+\tsort.SortStrings(lines)\n+\tfor _, l := range lines {\n+\t\tif _, err := io.WriteString(w, l); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+// readCookies parses all \"Cookie\" values from\n+// the header h, removes the successfully parsed values from the \n+// \"Cookie\" key in h and returns the parsed Cookies.\n+func readCookies(h Header) []*Cookie {\n+\tcookies := []*Cookie{}\n+\tlines, ok := h[\"Cookie\"]\n+\tif !ok {\n+\t\treturn cookies\n+\t}\n+\tunparsedLines := []string{}\n+\tfor _, line := range lines {\n+\t\tparts := strings.Split(strings.TrimSpace(line), \";\", -1)\n+\t\tif len(parts) == 1 && parts[0] == \"\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\t// Per-line attributes\n+\t\tparsedPairs := 0\n+\t\tfor i := 0; i < len(parts); i++ {\n+\t\t\tparts[i] = strings.TrimSpace(parts[i])\n+\t\t\tif len(parts[i]) == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tattr, val := parts[i], \"\"\n+\t\t\tif j := strings.Index(attr, \"=\"); j >= 0 {\n+\t\t\t\tattr, val = attr[:j], attr[j+1:]\n+\t\t\t}\n+\t\t\tif !isCookieNameValid(attr) {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tval, success := parseCookieValue(val)\n+\t\t\tif !success {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tcookies = append(cookies, &Cookie{Name: attr, Value: val})\n+\t\t\tparsedPairs++\n+\t\t}\n+\t\tif parsedPairs == 0 {\n+\t\t\tunparsedLines = append(unparsedLines, line)\n+\t\t}\n+\t}\n+\th[\"Cookie\"] = unparsedLines, len(unparsedLines) > 0\n+\treturn cookies\n+}\n+\n+// writeCookies writes the wire representation of the cookies\n+// to w. Each cookie is written on a separate \"Cookie: \" line.\n+// This choice is made because HTTP parsers tend to have a limit on\n+// line-length, so it seems safer to place cookies on separate lines.\n+func writeCookies(w io.Writer, kk []*Cookie) os.Error {\n+\tlines := make([]string, 0, len(kk))\n+\tfor _, c := range kk {\n+\t\tlines = append(lines, fmt.Sprintf(\"Cookie: %s=%s\\r\\n\", c.Name, c.Value))\n+\t}\n+\tsort.SortStrings(lines)\n+\tfor _, l := range lines {\n+\t\tif _, err := io.WriteString(w, l); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\treturn nil\n+}\n+\n+func unquoteCookieValue(v string) string {\n+\tif len(v) > 1 && v[0] == '\"' && v[len(v)-1] == '\"' {\n+\t\treturn v[1 : len(v)-1]\n+\t}\n+\treturn v\n+}\n+\n+func isCookieByte(c byte) bool {\n+\tswitch true {\n+\tcase c == 0x21, 0x23 <= c && c <= 0x2b, 0x2d <= c && c <= 0x3a,\n+\t\t0x3c <= c && c <= 0x5b, 0x5d <= c && c <= 0x7e:\n+\t\treturn true\n+\t}\n+\treturn false\n+}\n+\n+func parseCookieValue(raw string) (string, bool) {\n+\traw = unquoteCookieValue(raw)\n+\tfor i := 0; i < len(raw); i++ {\n+\t\tif !isCookieByte(raw[i]) {\n+\t\t\treturn \"\", false\n+\t\t}\n+\t}\n+\treturn raw, true\n+}\n+\n+func isCookieNameValid(raw string) bool {\n+\tfor _, c := range raw {\n+\t\tif !isToken(byte(c)) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}"}, {"sha": "db09970406b0eac802f9337638756211cf38bc2e", "filename": "libgo/go/http/cookie_test.go", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fcookie_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fcookie_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,110 @@\n+// Copyright 2010 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"json\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+\n+var writeSetCookiesTests = []struct {\n+\tCookies []*Cookie\n+\tRaw     string\n+}{\n+\t{\n+\t\t[]*Cookie{\n+\t\t\t&Cookie{Name: \"cookie-1\", Value: \"v$1\"},\n+\t\t\t&Cookie{Name: \"cookie-2\", Value: \"two\", MaxAge: 3600},\n+\t\t},\n+\t\t\"Set-Cookie: cookie-1=v$1\\r\\n\" +\n+\t\t\t\"Set-Cookie: cookie-2=two; Max-Age=3600\\r\\n\",\n+\t},\n+}\n+\n+func TestWriteSetCookies(t *testing.T) {\n+\tfor i, tt := range writeSetCookiesTests {\n+\t\tvar w bytes.Buffer\n+\t\twriteSetCookies(&w, tt.Cookies)\n+\t\tseen := string(w.Bytes())\n+\t\tif seen != tt.Raw {\n+\t\t\tt.Errorf(\"Test %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.Raw, seen)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+var writeCookiesTests = []struct {\n+\tCookies []*Cookie\n+\tRaw     string\n+}{\n+\t{\n+\t\t[]*Cookie{&Cookie{Name: \"cookie-1\", Value: \"v$1\"}},\n+\t\t\"Cookie: cookie-1=v$1\\r\\n\",\n+\t},\n+}\n+\n+func TestWriteCookies(t *testing.T) {\n+\tfor i, tt := range writeCookiesTests {\n+\t\tvar w bytes.Buffer\n+\t\twriteCookies(&w, tt.Cookies)\n+\t\tseen := string(w.Bytes())\n+\t\tif seen != tt.Raw {\n+\t\t\tt.Errorf(\"Test %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.Raw, seen)\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+var readSetCookiesTests = []struct {\n+\tHeader  Header\n+\tCookies []*Cookie\n+}{\n+\t{\n+\t\tHeader{\"Set-Cookie\": {\"Cookie-1=v$1\"}},\n+\t\t[]*Cookie{&Cookie{Name: \"Cookie-1\", Value: \"v$1\", Raw: \"Cookie-1=v$1\"}},\n+\t},\n+}\n+\n+func toJSON(v interface{}) string {\n+\tb, err := json.Marshal(v)\n+\tif err != nil {\n+\t\treturn fmt.Sprintf(\"%#v\", v)\n+\t}\n+\treturn string(b)\n+}\n+\n+func TestReadSetCookies(t *testing.T) {\n+\tfor i, tt := range readSetCookiesTests {\n+\t\tc := readSetCookies(tt.Header)\n+\t\tif !reflect.DeepEqual(c, tt.Cookies) {\n+\t\t\tt.Errorf(\"#%d readSetCookies: have\\n%s\\nwant\\n%s\\n\", i, toJSON(c), toJSON(tt.Cookies))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}\n+\n+var readCookiesTests = []struct {\n+\tHeader  Header\n+\tCookies []*Cookie\n+}{\n+\t{\n+\t\tHeader{\"Cookie\": {\"Cookie-1=v$1\"}},\n+\t\t[]*Cookie{&Cookie{Name: \"Cookie-1\", Value: \"v$1\"}},\n+\t},\n+}\n+\n+func TestReadCookies(t *testing.T) {\n+\tfor i, tt := range readCookiesTests {\n+\t\tc := readCookies(tt.Header)\n+\t\tif !reflect.DeepEqual(c, tt.Cookies) {\n+\t\t\tt.Errorf(\"#%d readCookies: have\\n%s\\nwant\\n%s\\n\", i, toJSON(c), toJSON(tt.Cookies))\n+\t\t\tcontinue\n+\t\t}\n+\t}\n+}"}, {"sha": "306c45bc2c9398c9281aadc9eb8aec0d94fd56ad", "filename": "libgo/go/http/dump.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fdump.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fdump.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fdump.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,10 +7,10 @@ package http\n import (\n \t\"bytes\"\n \t\"io\"\n+\t\"io/ioutil\"\n \t\"os\"\n )\n \n-\n // One of the copies, say from b to r2, could be avoided by using a more\n // elaborate trick where the other copy is made during Request/Response.Write.\n // This would complicate things too much, given that these functions are for\n@@ -23,7 +23,7 @@ func drainBody(b io.ReadCloser) (r1, r2 io.ReadCloser, err os.Error) {\n \tif err = b.Close(); err != nil {\n \t\treturn nil, nil, err\n \t}\n-\treturn nopCloser{&buf}, nopCloser{bytes.NewBuffer(buf.Bytes())}, nil\n+\treturn ioutil.NopCloser(&buf), ioutil.NopCloser(bytes.NewBuffer(buf.Bytes())), nil\n }\n \n // DumpRequest returns the wire representation of req,"}, {"sha": "a76b70760dfa98b815b0f708f14063c1b55ae2c7", "filename": "libgo/go/http/export_test.go", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fexport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fexport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fexport_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,34 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Bridge package to expose http internals to tests in the http_test\n+// package.\n+\n+package http\n+\n+func (t *Transport) IdleConnKeysForTesting() (keys []string) {\n+\tkeys = make([]string, 0)\n+\tt.lk.Lock()\n+\tdefer t.lk.Unlock()\n+\tif t.idleConn == nil {\n+\t\treturn\n+\t}\n+\tfor key, _ := range t.idleConn {\n+\t\tkeys = append(keys, key)\n+\t}\n+\treturn\n+}\n+\n+func (t *Transport) IdleConnCountForTesting(cacheKey string) int {\n+\tt.lk.Lock()\n+\tdefer t.lk.Unlock()\n+\tif t.idleConn == nil {\n+\t\treturn 0\n+\t}\n+\tconns, ok := t.idleConn[cacheKey]\n+\tif !ok {\n+\t\treturn 0\n+\t}\n+\treturn len(conns)\n+}"}, {"sha": "4ad680ccc314bdbd9948ca396f25deace3d4c3bc", "filename": "libgo/go/http/fs.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ffs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ffs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"io\"\n \t\"mime\"\n \t\"os\"\n-\t\"path\"\n+\t\"path/filepath\"\n \t\"strconv\"\n \t\"strings\"\n \t\"time\"\n@@ -108,11 +108,11 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t\tw.WriteHeader(StatusNotModified)\n \t\treturn\n \t}\n-\tw.SetHeader(\"Last-Modified\", time.SecondsToUTC(d.Mtime_ns/1e9).Format(TimeFormat))\n+\tw.Header().Set(\"Last-Modified\", time.SecondsToUTC(d.Mtime_ns/1e9).Format(TimeFormat))\n \n \t// use contents of index.html for directory, if present\n \tif d.IsDirectory() {\n-\t\tindex := name + indexPage\n+\t\tindex := name + filepath.FromSlash(indexPage)\n \t\tff, err := os.Open(index, os.O_RDONLY, 0)\n \t\tif err == nil {\n \t\t\tdefer ff.Close()\n@@ -135,18 +135,18 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \tcode := StatusOK\n \n \t// use extension to find content type.\n-\text := path.Ext(name)\n+\text := filepath.Ext(name)\n \tif ctype := mime.TypeByExtension(ext); ctype != \"\" {\n-\t\tw.SetHeader(\"Content-Type\", ctype)\n+\t\tw.Header().Set(\"Content-Type\", ctype)\n \t} else {\n \t\t// read first chunk to decide between utf-8 text and binary\n \t\tvar buf [1024]byte\n \t\tn, _ := io.ReadFull(f, buf[:])\n \t\tb := buf[:n]\n \t\tif isText(b) {\n-\t\t\tw.SetHeader(\"Content-Type\", \"text-plain; charset=utf-8\")\n+\t\t\tw.Header().Set(\"Content-Type\", \"text-plain; charset=utf-8\")\n \t\t} else {\n-\t\t\tw.SetHeader(\"Content-Type\", \"application/octet-stream\") // generic binary\n+\t\t\tw.Header().Set(\"Content-Type\", \"application/octet-stream\") // generic binary\n \t\t}\n \t\tf.Seek(0, 0) // rewind to output whole file\n \t}\n@@ -166,11 +166,11 @@ func serveFile(w ResponseWriter, r *Request, name string, redirect bool) {\n \t\t}\n \t\tsize = ra.length\n \t\tcode = StatusPartialContent\n-\t\tw.SetHeader(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, d.Size))\n+\t\tw.Header().Set(\"Content-Range\", fmt.Sprintf(\"bytes %d-%d/%d\", ra.start, ra.start+ra.length-1, d.Size))\n \t}\n \n-\tw.SetHeader(\"Accept-Ranges\", \"bytes\")\n-\tw.SetHeader(\"Content-Length\", strconv.Itoa64(size))\n+\tw.Header().Set(\"Accept-Ranges\", \"bytes\")\n+\tw.Header().Set(\"Content-Length\", strconv.Itoa64(size))\n \n \tw.WriteHeader(code)\n \n@@ -202,7 +202,7 @@ func (f *fileHandler) ServeHTTP(w ResponseWriter, r *Request) {\n \t\treturn\n \t}\n \tpath = path[len(f.prefix):]\n-\tserveFile(w, r, f.root+\"/\"+path, true)\n+\tserveFile(w, r, filepath.Join(f.root, filepath.FromSlash(path)), true)\n }\n \n // httpRange specifies the byte range to be sent to the client."}, {"sha": "a89c76d0bfb5c90b267f7c4e25bdb459b4e47d0d", "filename": "libgo/go/http/fs_test.go", "status": "modified", "additions": 10, "deletions": 73, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ffs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ffs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ffs_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,89 +2,22 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package http\n+package http_test\n \n import (\n \t\"fmt\"\n+\t. \"http\"\n+\t\"http/httptest\"\n \t\"io/ioutil\"\n-\t\"net\"\n \t\"os\"\n-\t\"sync\"\n \t\"testing\"\n )\n \n-var ParseRangeTests = []struct {\n-\ts      string\n-\tlength int64\n-\tr      []httpRange\n-}{\n-\t{\"\", 0, nil},\n-\t{\"foo\", 0, nil},\n-\t{\"bytes=\", 0, nil},\n-\t{\"bytes=5-4\", 10, nil},\n-\t{\"bytes=0-2,5-4\", 10, nil},\n-\t{\"bytes=0-9\", 10, []httpRange{{0, 10}}},\n-\t{\"bytes=0-\", 10, []httpRange{{0, 10}}},\n-\t{\"bytes=5-\", 10, []httpRange{{5, 5}}},\n-\t{\"bytes=0-20\", 10, []httpRange{{0, 10}}},\n-\t{\"bytes=15-,0-5\", 10, nil},\n-\t{\"bytes=-5\", 10, []httpRange{{5, 5}}},\n-\t{\"bytes=-15\", 10, []httpRange{{0, 10}}},\n-\t{\"bytes=0-499\", 10000, []httpRange{{0, 500}}},\n-\t{\"bytes=500-999\", 10000, []httpRange{{500, 500}}},\n-\t{\"bytes=-500\", 10000, []httpRange{{9500, 500}}},\n-\t{\"bytes=9500-\", 10000, []httpRange{{9500, 500}}},\n-\t{\"bytes=0-0,-1\", 10000, []httpRange{{0, 1}, {9999, 1}}},\n-\t{\"bytes=500-600,601-999\", 10000, []httpRange{{500, 101}, {601, 399}}},\n-\t{\"bytes=500-700,601-999\", 10000, []httpRange{{500, 201}, {601, 399}}},\n-}\n-\n-func TestParseRange(t *testing.T) {\n-\tfor _, test := range ParseRangeTests {\n-\t\tr := test.r\n-\t\tranges, err := parseRange(test.s, test.length)\n-\t\tif err != nil && r != nil {\n-\t\t\tt.Errorf(\"parseRange(%q) returned error %q\", test.s, err)\n-\t\t}\n-\t\tif len(ranges) != len(r) {\n-\t\t\tt.Errorf(\"len(parseRange(%q)) = %d, want %d\", test.s, len(ranges), len(r))\n-\t\t\tcontinue\n-\t\t}\n-\t\tfor i := range r {\n-\t\t\tif ranges[i].start != r[i].start {\n-\t\t\t\tt.Errorf(\"parseRange(%q)[%d].start = %d, want %d\", test.s, i, ranges[i].start, r[i].start)\n-\t\t\t}\n-\t\t\tif ranges[i].length != r[i].length {\n-\t\t\t\tt.Errorf(\"parseRange(%q)[%d].length = %d, want %d\", test.s, i, ranges[i].length, r[i].length)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n const (\n \ttestFile       = \"testdata/file\"\n \ttestFileLength = 11\n )\n \n-var (\n-\tserverOnce sync.Once\n-\tserverAddr string\n-)\n-\n-func startServer(t *testing.T) {\n-\tserverOnce.Do(func() {\n-\t\tHandleFunc(\"/ServeFile\", func(w ResponseWriter, r *Request) {\n-\t\t\tServeFile(w, r, \"testdata/file\")\n-\t\t})\n-\t\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n-\t\tif err != nil {\n-\t\t\tt.Fatal(\"listen:\", err)\n-\t\t}\n-\t\tserverAddr = l.Addr().String()\n-\t\tgo Serve(l, nil)\n-\t})\n-}\n-\n var ServeFileRangeTests = []struct {\n \tstart, end int\n \tr          string\n@@ -99,7 +32,11 @@ var ServeFileRangeTests = []struct {\n }\n \n func TestServeFile(t *testing.T) {\n-\tstartServer(t)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tServeFile(w, r, \"testdata/file\")\n+\t}))\n+\tdefer ts.Close()\n+\n \tvar err os.Error\n \n \tfile, err := ioutil.ReadFile(testFile)\n@@ -110,7 +47,7 @@ func TestServeFile(t *testing.T) {\n \t// set up the Request (re-used for all tests)\n \tvar req Request\n \treq.Header = make(Header)\n-\tif req.URL, err = ParseURL(\"http://\" + serverAddr + \"/ServeFile\"); err != nil {\n+\tif req.URL, err = ParseURL(ts.URL); err != nil {\n \t\tt.Fatal(\"ParseURL:\", err)\n \t}\n \treq.Method = \"GET\"\n@@ -149,7 +86,7 @@ func TestServeFile(t *testing.T) {\n }\n \n func getBody(t *testing.T, req Request) (*Response, []byte) {\n-\tr, err := send(&req, DefaultTransport)\n+\tr, err := DefaultClient.Do(&req)\n \tif err != nil {\n \t\tt.Fatal(req.URL.String(), \"send:\", err)\n \t}"}, {"sha": "0dd19a617cc4c58334215daa97658c2ada0fbe62", "filename": "libgo/go/http/httptest/recorder.go", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Frecorder.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,59 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The httptest package provides utilities for HTTP testing.\n+package httptest\n+\n+import (\n+\t\"bytes\"\n+\t\"http\"\n+\t\"os\"\n+)\n+\n+// ResponseRecorder is an implementation of http.ResponseWriter that\n+// records its mutations for later inspection in tests.\n+type ResponseRecorder struct {\n+\tCode      int           // the HTTP response code from WriteHeader\n+\tHeaderMap http.Header   // the HTTP response headers\n+\tBody      *bytes.Buffer // if non-nil, the bytes.Buffer to append written data to\n+\tFlushed   bool\n+}\n+\n+// NewRecorder returns an initialized ResponseRecorder.\n+func NewRecorder() *ResponseRecorder {\n+\treturn &ResponseRecorder{\n+\t\tHeaderMap: make(http.Header),\n+\t\tBody:      new(bytes.Buffer),\n+\t}\n+}\n+\n+// DefaultRemoteAddr is the default remote address to return in RemoteAddr if\n+// an explicit DefaultRemoteAddr isn't set on ResponseRecorder.\n+const DefaultRemoteAddr = \"1.2.3.4\"\n+\n+// Header returns the response headers.\n+func (rw *ResponseRecorder) Header() http.Header {\n+\treturn rw.HeaderMap\n+}\n+\n+// Write always succeeds and writes to rw.Body, if not nil.\n+func (rw *ResponseRecorder) Write(buf []byte) (int, os.Error) {\n+\tif rw.Body != nil {\n+\t\trw.Body.Write(buf)\n+\t}\n+\tif rw.Code == 0 {\n+\t\trw.Code = http.StatusOK\n+\t}\n+\treturn len(buf), nil\n+}\n+\n+// WriteHeader sets rw.Code.\n+func (rw *ResponseRecorder) WriteHeader(code int) {\n+\trw.Code = code\n+}\n+\n+// Flush sets rw.Flushed to true.\n+func (rw *ResponseRecorder) Flush() {\n+\trw.Flushed = true\n+}"}, {"sha": "6e825a890d19382122f768161fa0f685839ec9ae", "filename": "libgo/go/http/httptest/server.go", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fhttptest%2Fserver.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,70 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Implementation of Server\n+\n+package httptest\n+\n+import (\n+\t\"fmt\"\n+\t\"http\"\n+\t\"os\"\n+\t\"net\"\n+)\n+\n+// A Server is an HTTP server listening on a system-chosen port on the\n+// local loopback interface, for use in end-to-end HTTP tests.\n+type Server struct {\n+\tURL      string // base URL of form http://ipaddr:port with no trailing slash\n+\tListener net.Listener\n+}\n+\n+// historyListener keeps track of all connections that it's ever\n+// accepted.\n+type historyListener struct {\n+\tnet.Listener\n+\thistory []net.Conn\n+}\n+\n+func (hs *historyListener) Accept() (c net.Conn, err os.Error) {\n+\tc, err = hs.Listener.Accept()\n+\tif err == nil {\n+\t\ths.history = append(hs.history, c)\n+\t}\n+\treturn\n+}\n+\n+// NewServer starts and returns a new Server.\n+// The caller should call Close when finished, to shut it down.\n+func NewServer(handler http.Handler) *Server {\n+\tts := new(Server)\n+\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n+\tif err != nil {\n+\t\tif l, err = net.Listen(\"tcp6\", \"[::1]:0\"); err != nil {\n+\t\t\tpanic(fmt.Sprintf(\"httptest: failed to listen on a port: %v\", err))\n+\t\t}\n+\t}\n+\tts.Listener = &historyListener{l, make([]net.Conn, 0)}\n+\tts.URL = \"http://\" + l.Addr().String()\n+\tserver := &http.Server{Handler: handler}\n+\tgo server.Serve(ts.Listener)\n+\treturn ts\n+}\n+\n+// Close shuts down the server.\n+func (s *Server) Close() {\n+\ts.Listener.Close()\n+}\n+\n+// CloseClientConnections closes any currently open HTTP connections\n+// to the test Server.\n+func (s *Server) CloseClientConnections() {\n+\thl, ok := s.Listener.(*historyListener)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\tfor _, conn := range hl.history {\n+\t\tconn.Close()\n+\t}\n+}"}, {"sha": "b93c5fe4855c8c5d207c2a0b9374ddb5005e68ba", "filename": "libgo/go/http/persist.go", "status": "modified", "additions": 71, "deletions": 41, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fpersist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fpersist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpersist.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -25,15 +25,15 @@ var (\n // i.e. requests can be read out of sync (but in the same order) while the\n // respective responses are sent.\n type ServerConn struct {\n+\tlk              sync.Mutex // read-write protects the following fields\n \tc               net.Conn\n \tr               *bufio.Reader\n-\tclsd            bool     // indicates a graceful close\n \tre, we          os.Error // read/write errors\n \tlastbody        io.ReadCloser\n \tnread, nwritten int\n-\tpipe            textproto.Pipeline\n \tpipereq         map[*Request]uint\n-\tlk              sync.Mutex // protected read/write to re,we\n+\n+\tpipe textproto.Pipeline\n }\n \n // NewServerConn returns a new ServerConn reading and writing c.  If r is not\n@@ -90,15 +90,21 @@ func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \t\tdefer sc.lk.Unlock()\n \t\treturn nil, sc.re\n \t}\n+\tif sc.r == nil { // connection closed by user in the meantime\n+\t\tdefer sc.lk.Unlock()\n+\t\treturn nil, os.EBADF\n+\t}\n+\tr := sc.r\n+\tlastbody := sc.lastbody\n+\tsc.lastbody = nil\n \tsc.lk.Unlock()\n \n \t// Make sure body is fully consumed, even if user does not call body.Close\n-\tif sc.lastbody != nil {\n+\tif lastbody != nil {\n \t\t// body.Close is assumed to be idempotent and multiple calls to\n \t\t// it should return the error that its first invokation\n \t\t// returned.\n-\t\terr = sc.lastbody.Close()\n-\t\tsc.lastbody = nil\n+\t\terr = lastbody.Close()\n \t\tif err != nil {\n \t\t\tsc.lk.Lock()\n \t\t\tdefer sc.lk.Unlock()\n@@ -107,10 +113,10 @@ func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \t\t}\n \t}\n \n-\treq, err = ReadRequest(sc.r)\n+\treq, err = ReadRequest(r)\n+\tsc.lk.Lock()\n+\tdefer sc.lk.Unlock()\n \tif err != nil {\n-\t\tsc.lk.Lock()\n-\t\tdefer sc.lk.Unlock()\n \t\tif err == io.ErrUnexpectedEOF {\n \t\t\t// A close from the opposing client is treated as a\n \t\t\t// graceful close, even if there was some unparse-able\n@@ -119,18 +125,16 @@ func (sc *ServerConn) Read() (req *Request, err os.Error) {\n \t\t\treturn nil, sc.re\n \t\t} else {\n \t\t\tsc.re = err\n-\t\t\treturn\n+\t\t\treturn req, err\n \t\t}\n \t}\n \tsc.lastbody = req.Body\n \tsc.nread++\n \tif req.Close {\n-\t\tsc.lk.Lock()\n-\t\tdefer sc.lk.Unlock()\n \t\tsc.re = ErrPersistEOF\n \t\treturn req, sc.re\n \t}\n-\treturn\n+\treturn req, err\n }\n \n // Pending returns the number of unanswered requests\n@@ -165,24 +169,27 @@ func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n \t\tdefer sc.lk.Unlock()\n \t\treturn sc.we\n \t}\n-\tsc.lk.Unlock()\n+\tif sc.c == nil { // connection closed by user in the meantime\n+\t\tdefer sc.lk.Unlock()\n+\t\treturn os.EBADF\n+\t}\n+\tc := sc.c\n \tif sc.nread <= sc.nwritten {\n+\t\tdefer sc.lk.Unlock()\n \t\treturn os.NewError(\"persist server pipe count\")\n \t}\n-\n \tif resp.Close {\n \t\t// After signaling a keep-alive close, any pipelined unread\n \t\t// requests will be lost. It is up to the user to drain them\n \t\t// before signaling.\n-\t\tsc.lk.Lock()\n \t\tsc.re = ErrPersistEOF\n-\t\tsc.lk.Unlock()\n \t}\n+\tsc.lk.Unlock()\n \n-\terr := resp.Write(sc.c)\n+\terr := resp.Write(c)\n+\tsc.lk.Lock()\n+\tdefer sc.lk.Unlock()\n \tif err != nil {\n-\t\tsc.lk.Lock()\n-\t\tdefer sc.lk.Unlock()\n \t\tsc.we = err\n \t\treturn err\n \t}\n@@ -196,14 +203,17 @@ func (sc *ServerConn) Write(req *Request, resp *Response) os.Error {\n // responsible for closing the underlying connection. One must call Close to\n // regain control of that connection and deal with it as desired.\n type ClientConn struct {\n+\tlk              sync.Mutex // read-write protects the following fields\n \tc               net.Conn\n \tr               *bufio.Reader\n \tre, we          os.Error // read/write errors\n \tlastbody        io.ReadCloser\n \tnread, nwritten int\n-\tpipe            textproto.Pipeline\n \tpipereq         map[*Request]uint\n-\tlk              sync.Mutex // protects read/write to re,we,pipereq,etc.\n+\n+\tpipe     textproto.Pipeline\n+\twriteReq func(*Request, io.Writer) os.Error\n+\treadRes  func(buf *bufio.Reader, method string) (*Response, os.Error)\n }\n \n // NewClientConn returns a new ClientConn reading and writing c.  If r is not\n@@ -212,7 +222,21 @@ func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn {\n \tif r == nil {\n \t\tr = bufio.NewReader(c)\n \t}\n-\treturn &ClientConn{c: c, r: r, pipereq: make(map[*Request]uint)}\n+\treturn &ClientConn{\n+\t\tc:        c,\n+\t\tr:        r,\n+\t\tpipereq:  make(map[*Request]uint),\n+\t\twriteReq: (*Request).Write,\n+\t\treadRes:  ReadResponse,\n+\t}\n+}\n+\n+// NewProxyClientConn works like NewClientConn but writes Requests\n+// using Request's WriteProxy method.\n+func NewProxyClientConn(c net.Conn, r *bufio.Reader) *ClientConn {\n+\tcc := NewClientConn(c, r)\n+\tcc.writeReq = (*Request).WriteProxy\n+\treturn cc\n }\n \n // Close detaches the ClientConn and returns the underlying connection as well\n@@ -221,11 +245,11 @@ func NewClientConn(c net.Conn, r *bufio.Reader) *ClientConn {\n // logic. The user should not call Close while Read or Write is in progress.\n func (cc *ClientConn) Close() (c net.Conn, r *bufio.Reader) {\n \tcc.lk.Lock()\n+\tdefer cc.lk.Unlock()\n \tc = cc.c\n \tr = cc.r\n \tcc.c = nil\n \tcc.r = nil\n-\tcc.lk.Unlock()\n \treturn\n }\n \n@@ -261,20 +285,22 @@ func (cc *ClientConn) Write(req *Request) (err os.Error) {\n \t\tdefer cc.lk.Unlock()\n \t\treturn cc.we\n \t}\n-\tcc.lk.Unlock()\n-\n+\tif cc.c == nil { // connection closed by user in the meantime\n+\t\tdefer cc.lk.Unlock()\n+\t\treturn os.EBADF\n+\t}\n+\tc := cc.c\n \tif req.Close {\n \t\t// We write the EOF to the write-side error, because there\n \t\t// still might be some pipelined reads\n-\t\tcc.lk.Lock()\n \t\tcc.we = ErrPersistEOF\n-\t\tcc.lk.Unlock()\n \t}\n+\tcc.lk.Unlock()\n \n-\terr = req.Write(cc.c)\n+\terr = cc.writeReq(req, c)\n+\tcc.lk.Lock()\n+\tdefer cc.lk.Unlock()\n \tif err != nil {\n-\t\tcc.lk.Lock()\n-\t\tdefer cc.lk.Unlock()\n \t\tcc.we = err\n \t\treturn err\n \t}\n@@ -316,15 +342,21 @@ func (cc *ClientConn) Read(req *Request) (resp *Response, err os.Error) {\n \t\tdefer cc.lk.Unlock()\n \t\treturn nil, cc.re\n \t}\n+\tif cc.r == nil { // connection closed by user in the meantime\n+\t\tdefer cc.lk.Unlock()\n+\t\treturn nil, os.EBADF\n+\t}\n+\tr := cc.r\n+\tlastbody := cc.lastbody\n+\tcc.lastbody = nil\n \tcc.lk.Unlock()\n \n \t// Make sure body is fully consumed, even if user does not call body.Close\n-\tif cc.lastbody != nil {\n+\tif lastbody != nil {\n \t\t// body.Close is assumed to be idempotent and multiple calls to\n \t\t// it should return the error that its first invokation\n \t\t// returned.\n-\t\terr = cc.lastbody.Close()\n-\t\tcc.lastbody = nil\n+\t\terr = lastbody.Close()\n \t\tif err != nil {\n \t\t\tcc.lk.Lock()\n \t\t\tdefer cc.lk.Unlock()\n@@ -333,24 +365,22 @@ func (cc *ClientConn) Read(req *Request) (resp *Response, err os.Error) {\n \t\t}\n \t}\n \n-\tresp, err = ReadResponse(cc.r, req.Method)\n+\tresp, err = cc.readRes(r, req.Method)\n+\tcc.lk.Lock()\n+\tdefer cc.lk.Unlock()\n \tif err != nil {\n-\t\tcc.lk.Lock()\n-\t\tdefer cc.lk.Unlock()\n \t\tcc.re = err\n-\t\treturn\n+\t\treturn resp, err\n \t}\n \tcc.lastbody = resp.Body\n \n \tcc.nread++\n \n \tif resp.Close {\n-\t\tcc.lk.Lock()\n-\t\tdefer cc.lk.Unlock()\n \t\tcc.re = ErrPersistEOF // don't send any more requests\n \t\treturn resp, cc.re\n \t}\n-\treturn\n+\treturn resp, err\n }\n \n // Do is convenience method that writes a request and reads a response."}, {"sha": "0bac26687d73d842b99793d5b75c142d8ee4a053", "filename": "libgo/go/http/pprof/pprof.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fpprof%2Fpprof.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -41,22 +41,22 @@ func init() {\n // command line, with arguments separated by NUL bytes.\n // The package initialization registers it as /debug/pprof/cmdline.\n func Cmdline(w http.ResponseWriter, r *http.Request) {\n-\tw.SetHeader(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n \tfmt.Fprintf(w, strings.Join(os.Args, \"\\x00\"))\n }\n \n // Heap responds with the pprof-formatted heap profile.\n // The package initialization registers it as /debug/pprof/heap.\n func Heap(w http.ResponseWriter, r *http.Request) {\n-\tw.SetHeader(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n \tpprof.WriteHeapProfile(w)\n }\n \n // Symbol looks up the program counters listed in the request,\n // responding with a table mapping program counters to function names.\n // The package initialization registers it as /debug/pprof/symbol.\n func Symbol(w http.ResponseWriter, r *http.Request) {\n-\tw.SetHeader(\"content-type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"content-type\", \"text/plain; charset=utf-8\")\n \n \t// We don't know how many symbols we have, but we\n \t// do have symbol information.  Pprof only cares whether"}, {"sha": "7050ef5ed063d96fc15fe957c72a2020580668a7", "filename": "libgo/go/http/proxy_test.go", "status": "modified", "additions": 16, "deletions": 14, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fproxy_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,31 +12,33 @@ import (\n // TODO(mattn):\n //\ttest ProxyAuth\n \n-var MatchNoProxyTests = []struct {\n+var UseProxyTests = []struct {\n \thost  string\n \tmatch bool\n }{\n-\t{\"localhost\", true},        // match completely\n-\t{\"barbaz.net\", true},       // match as .barbaz.net\n-\t{\"foobar.com:443\", true},   // have a port but match \n-\t{\"foofoobar.com\", false},   // not match as a part of foobar.com\n-\t{\"baz.com\", false},         // not match as a part of barbaz.com\n-\t{\"localhost.net\", false},   // not match as suffix of address\n-\t{\"local.localhost\", false}, // not match as prefix as address\n-\t{\"barbarbaz.net\", false},   // not match because NO_PROXY have a '.'\n-\t{\"www.foobar.com\", false},  // not match because NO_PROXY is not .foobar.com\n+\t{\"localhost\", false},      // match completely\n+\t{\"barbaz.net\", false},     // match as .barbaz.net\n+\t{\"foobar.com:443\", false}, // have a port but match \n+\t{\"foofoobar.com\", true},   // not match as a part of foobar.com\n+\t{\"baz.com\", true},         // not match as a part of barbaz.com\n+\t{\"localhost.net\", true},   // not match as suffix of address\n+\t{\"local.localhost\", true}, // not match as prefix as address\n+\t{\"barbarbaz.net\", true},   // not match because NO_PROXY have a '.'\n+\t{\"www.foobar.com\", true},  // not match because NO_PROXY is not .foobar.com\n }\n \n-func TestMatchNoProxy(t *testing.T) {\n+func TestUseProxy(t *testing.T) {\n \toldenv := os.Getenv(\"NO_PROXY\")\n \tno_proxy := \"foobar.com, .barbaz.net   , localhost\"\n \tos.Setenv(\"NO_PROXY\", no_proxy)\n \tdefer os.Setenv(\"NO_PROXY\", oldenv)\n \n-\tfor _, test := range MatchNoProxyTests {\n-\t\tif matchNoProxy(test.host) != test.match {\n+\ttr := &Transport{}\n+\n+\tfor _, test := range UseProxyTests {\n+\t\tif tr.useProxy(test.host) != test.match {\n \t\t\tif test.match {\n-\t\t\t\tt.Errorf(\"matchNoProxy(%v) = %v, want %v\", test.host, !test.match, test.match)\n+\t\t\t\tt.Errorf(\"useProxy(%v) = %v, want %v\", test.host, !test.match, test.match)\n \t\t\t} else {\n \t\t\t\tt.Errorf(\"not expected: '%s' shouldn't match as '%s'\", test.host, no_proxy)\n \t\t\t}"}, {"sha": "5274a81fa34479f2a0b74264f19678c847d56a98", "filename": "libgo/go/http/range_test.go", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frange_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frange_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frange_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,57 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package http\n+\n+import (\n+\t\"testing\"\n+)\n+\n+var ParseRangeTests = []struct {\n+\ts      string\n+\tlength int64\n+\tr      []httpRange\n+}{\n+\t{\"\", 0, nil},\n+\t{\"foo\", 0, nil},\n+\t{\"bytes=\", 0, nil},\n+\t{\"bytes=5-4\", 10, nil},\n+\t{\"bytes=0-2,5-4\", 10, nil},\n+\t{\"bytes=0-9\", 10, []httpRange{{0, 10}}},\n+\t{\"bytes=0-\", 10, []httpRange{{0, 10}}},\n+\t{\"bytes=5-\", 10, []httpRange{{5, 5}}},\n+\t{\"bytes=0-20\", 10, []httpRange{{0, 10}}},\n+\t{\"bytes=15-,0-5\", 10, nil},\n+\t{\"bytes=-5\", 10, []httpRange{{5, 5}}},\n+\t{\"bytes=-15\", 10, []httpRange{{0, 10}}},\n+\t{\"bytes=0-499\", 10000, []httpRange{{0, 500}}},\n+\t{\"bytes=500-999\", 10000, []httpRange{{500, 500}}},\n+\t{\"bytes=-500\", 10000, []httpRange{{9500, 500}}},\n+\t{\"bytes=9500-\", 10000, []httpRange{{9500, 500}}},\n+\t{\"bytes=0-0,-1\", 10000, []httpRange{{0, 1}, {9999, 1}}},\n+\t{\"bytes=500-600,601-999\", 10000, []httpRange{{500, 101}, {601, 399}}},\n+\t{\"bytes=500-700,601-999\", 10000, []httpRange{{500, 201}, {601, 399}}},\n+}\n+\n+func TestParseRange(t *testing.T) {\n+\tfor _, test := range ParseRangeTests {\n+\t\tr := test.r\n+\t\tranges, err := parseRange(test.s, test.length)\n+\t\tif err != nil && r != nil {\n+\t\t\tt.Errorf(\"parseRange(%q) returned error %q\", test.s, err)\n+\t\t}\n+\t\tif len(ranges) != len(r) {\n+\t\t\tt.Errorf(\"len(parseRange(%q)) = %d, want %d\", test.s, len(ranges), len(r))\n+\t\t\tcontinue\n+\t\t}\n+\t\tfor i := range r {\n+\t\t\tif ranges[i].start != r[i].start {\n+\t\t\t\tt.Errorf(\"parseRange(%q)[%d].start = %d, want %d\", test.s, i, ranges[i].start, r[i].start)\n+\t\t\t}\n+\t\t\tif ranges[i].length != r[i].length {\n+\t\t\t\tt.Errorf(\"parseRange(%q)[%d].length = %d, want %d\", test.s, i, ranges[i].length, r[i].length)\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "19e2ff77476a97581c0f7f151b0af4cef8a750d8", "filename": "libgo/go/http/readrequest_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Freadrequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Freadrequest_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -93,7 +93,7 @@ var reqTests = []reqTest{\n \t\t\tProto:         \"HTTP/1.1\",\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    1,\n-\t\t\tHeader:        map[string][]string{},\n+\t\t\tHeader:        Header{},\n \t\t\tClose:         false,\n \t\t\tContentLength: -1,\n \t\t\tHost:          \"test\","}, {"sha": "d82894fab08829716e6411d5dba7ee46be574eb5", "filename": "libgo/go/http/request.go", "status": "modified", "additions": 34, "deletions": 7, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -11,6 +11,7 @@ package http\n \n import (\n \t\"bufio\"\n+\t\"crypto/tls\"\n \t\"container/vector\"\n \t\"fmt\"\n \t\"io\"\n@@ -92,6 +93,9 @@ type Request struct {\n \t// following a hyphen uppercase and the rest lowercase.\n \tHeader Header\n \n+\t// Cookie records the HTTP cookies sent with the request.\n+\tCookie []*Cookie\n+\n \t// The message body.\n \tBody io.ReadCloser\n \n@@ -134,6 +138,22 @@ type Request struct {\n \t// response has multiple trailer lines with the same key, they will be\n \t// concatenated, delimited by commas.\n \tTrailer Header\n+\n+\t// RemoteAddr allows HTTP servers and other software to record\n+\t// the network address that sent the request, usually for\n+\t// logging. This field is not filled in by ReadRequest and\n+\t// has no defined format. The HTTP server in this package\n+\t// sets RemoteAddr to an \"IP:port\" address before invoking a\n+\t// handler.\n+\tRemoteAddr string\n+\n+\t// TLS allows HTTP servers and other software to record\n+\t// information about the TLS connection on which the request\n+\t// was received. This field is not filled in by ReadRequest.\n+\t// The HTTP server in this package sets the field for\n+\t// TLS-enabled connections before invoking a handler;\n+\t// otherwise it leaves the field nil.\n+\tTLS *tls.ConnectionState\n }\n \n // ProtoAtLeast returns whether the HTTP protocol used\n@@ -190,6 +210,8 @@ func (req *Request) Write(w io.Writer) os.Error {\n // WriteProxy is like Write but writes the request in the form\n // expected by an HTTP proxy.  It includes the scheme and host\n // name in the URI instead of using a separate Host: header line.\n+// If req.RawURL is non-empty, WriteProxy uses it unchanged\n+// instead of URL but still omits the Host: header.\n func (req *Request) WriteProxy(w io.Writer) os.Error {\n \treturn req.write(w, true)\n }\n@@ -206,13 +228,12 @@ func (req *Request) write(w io.Writer, usingProxy bool) os.Error {\n \t\tif req.URL.RawQuery != \"\" {\n \t\t\turi += \"?\" + req.URL.RawQuery\n \t\t}\n-\t}\n-\n-\tif usingProxy {\n-\t\tif uri == \"\" || uri[0] != '/' {\n-\t\t\turi = \"/\" + uri\n+\t\tif usingProxy {\n+\t\t\tif uri == \"\" || uri[0] != '/' {\n+\t\t\t\turi = \"/\" + uri\n+\t\t\t}\n+\t\t\turi = req.URL.Scheme + \"://\" + host + uri\n \t\t}\n-\t\turi = req.URL.Scheme + \"://\" + host + uri\n \t}\n \n \tfmt.Fprintf(w, \"%s %s HTTP/1.1\\r\\n\", valueOrDefault(req.Method, \"GET\"), uri)\n@@ -243,11 +264,15 @@ func (req *Request) write(w io.Writer, usingProxy bool) os.Error {\n \t// from Request, and introduce Request methods along the lines of\n \t// Response.{GetHeader,AddHeader} and string constants for \"Host\",\n \t// \"User-Agent\" and \"Referer\".\n-\terr = writeSortedKeyValue(w, req.Header, reqExcludeHeader)\n+\terr = writeSortedHeader(w, req.Header, reqExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\tif err = writeCookies(w, req.Cookie); err != nil {\n+\t\treturn err\n+\t}\n+\n \tio.WriteString(w, \"\\r\\n\")\n \n \t// Write body and trailer\n@@ -484,6 +509,8 @@ func ReadRequest(b *bufio.Reader) (req *Request, err os.Error) {\n \t\treturn nil, err\n \t}\n \n+\treq.Cookie = readCookies(req.Header)\n+\n \treturn req, nil\n }\n "}, {"sha": "19083adf624ee72bb209922ca9e63ed1d833969f", "filename": "libgo/go/http/request_test.go", "status": "modified", "additions": 29, "deletions": 8, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequest_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequest_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequest_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,10 +2,15 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-package http\n+package http_test\n \n import (\n \t\"bytes\"\n+\t\"fmt\"\n+\t. \"http\"\n+\t\"http/httptest\"\n+\t\"io\"\n+\t\"os\"\n \t\"reflect\"\n \t\"regexp\"\n \t\"strings\"\n@@ -141,17 +146,33 @@ func TestMultipartReader(t *testing.T) {\n }\n \n func TestRedirect(t *testing.T) {\n-\tconst (\n-\t\tstart = \"http://google.com/\"\n-\t\tendRe = \"^http://www\\\\.google\\\\.[a-z.]+/$\"\n-\t)\n-\tvar end = regexp.MustCompile(endRe)\n-\tr, url, err := Get(start)\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tswitch r.URL.Path {\n+\t\tcase \"/\":\n+\t\t\tw.Header().Set(\"Location\", \"/foo/\")\n+\t\t\tw.WriteHeader(StatusSeeOther)\n+\t\tcase \"/foo/\":\n+\t\t\tfmt.Fprintf(w, \"foo\")\n+\t\tdefault:\n+\t\t\tw.WriteHeader(StatusBadRequest)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\n+\tvar end = regexp.MustCompile(\"/foo/$\")\n+\tr, url, err := Get(ts.URL)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n \tr.Body.Close()\n \tif r.StatusCode != 200 || !end.MatchString(url) {\n-\t\tt.Fatalf(\"Get(%s) got status %d at %q, want 200 matching %q\", start, r.StatusCode, url, endRe)\n+\t\tt.Fatalf(\"Get got status %d at %q, want 200 matching /foo/$\", r.StatusCode, url)\n \t}\n }\n+\n+// TODO: stop copy/pasting this around.  move to io/ioutil?\n+type nopCloser struct {\n+\tio.Reader\n+}\n+\n+func (nopCloser) Close() os.Error { return nil }"}, {"sha": "726baa2668633f28c4daddd7ed099cd144094fab", "filename": "libgo/go/http/requestwrite_test.go", "status": "modified", "additions": 58, "deletions": 6, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Frequestwrite_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,12 +6,15 @@ package http\n \n import (\n \t\"bytes\"\n+\t\"io/ioutil\"\n \t\"testing\"\n )\n \n type reqWriteTest struct {\n-\tReq Request\n-\tRaw string\n+\tReq      Request\n+\tBody     []byte\n+\tRaw      string\n+\tRawProxy string\n }\n \n var reqWriteTests = []reqWriteTest{\n@@ -50,6 +53,8 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tForm:      map[string][]string{},\n \t\t},\n \n+\t\tnil,\n+\n \t\t\"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.techcrunch.com\\r\\n\" +\n \t\t\t\"User-Agent: Fake\\r\\n\" +\n@@ -59,6 +64,15 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t\"Accept-Language: en-us,en;q=0.5\\r\\n\" +\n \t\t\t\"Keep-Alive: 300\\r\\n\" +\n \t\t\t\"Proxy-Connection: keep-alive\\r\\n\\r\\n\",\n+\n+\t\t\"GET http://www.techcrunch.com/ HTTP/1.1\\r\\n\" +\n+\t\t\t\"User-Agent: Fake\\r\\n\" +\n+\t\t\t\"Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8\\r\\n\" +\n+\t\t\t\"Accept-Charset: ISO-8859-1,utf-8;q=0.7,*;q=0.7\\r\\n\" +\n+\t\t\t\"Accept-Encoding: gzip,deflate\\r\\n\" +\n+\t\t\t\"Accept-Language: en-us,en;q=0.5\\r\\n\" +\n+\t\t\t\"Keep-Alive: 300\\r\\n\" +\n+\t\t\t\"Proxy-Connection: keep-alive\\r\\n\\r\\n\",\n \t},\n \t// HTTP/1.1 => chunked coding; body; empty trailer\n \t{\n@@ -71,16 +85,22 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t},\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n-\t\t\tHeader:           map[string][]string{},\n-\t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n+\t\t\tHeader:           Header{},\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n \n+\t\t[]byte(\"abcdef\"),\n+\n \t\t\"GET /search HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.google.com\\r\\n\" +\n \t\t\t\"User-Agent: Go http package\\r\\n\" +\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n \t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n+\n+\t\t\"GET http://www.google.com/search HTTP/1.1\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n+\t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n \t},\n \t// HTTP/1.1 POST => chunked coding; body; empty trailer\n \t{\n@@ -93,18 +113,25 @@ var reqWriteTests = []reqWriteTest{\n \t\t\t},\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n-\t\t\tHeader:           map[string][]string{},\n+\t\t\tHeader:           Header{},\n \t\t\tClose:            true,\n-\t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t},\n \n+\t\t[]byte(\"abcdef\"),\n+\n \t\t\"POST /search HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.google.com\\r\\n\" +\n \t\t\t\"User-Agent: Go http package\\r\\n\" +\n \t\t\t\"Connection: close\\r\\n\" +\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n \t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n+\n+\t\t\"POST http://www.google.com/search HTTP/1.1\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n+\t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n \t},\n \t// default to HTTP/1.1\n \t{\n@@ -114,16 +141,26 @@ var reqWriteTests = []reqWriteTest{\n \t\t\tHost:   \"www.google.com\",\n \t\t},\n \n+\t\tnil,\n+\n \t\t\"GET /search HTTP/1.1\\r\\n\" +\n \t\t\t\"Host: www.google.com\\r\\n\" +\n \t\t\t\"User-Agent: Go http package\\r\\n\" +\n \t\t\t\"\\r\\n\",\n+\n+\t\t// Looks weird but RawURL overrides what WriteProxy would choose.\n+\t\t\"GET /search HTTP/1.1\\r\\n\" +\n+\t\t\t\"User-Agent: Go http package\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n \t},\n }\n \n func TestRequestWrite(t *testing.T) {\n \tfor i := range reqWriteTests {\n \t\ttt := &reqWriteTests[i]\n+\t\tif tt.Body != nil {\n+\t\t\ttt.Req.Body = ioutil.NopCloser(bytes.NewBuffer(tt.Body))\n+\t\t}\n \t\tvar braw bytes.Buffer\n \t\terr := tt.Req.Write(&braw)\n \t\tif err != nil {\n@@ -135,5 +172,20 @@ func TestRequestWrite(t *testing.T) {\n \t\t\tt.Errorf(\"Test %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.Raw, sraw)\n \t\t\tcontinue\n \t\t}\n+\n+\t\tif tt.Body != nil {\n+\t\t\ttt.Req.Body = ioutil.NopCloser(bytes.NewBuffer(tt.Body))\n+\t\t}\n+\t\tvar praw bytes.Buffer\n+\t\terr = tt.Req.WriteProxy(&praw)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"error writing #%d: %s\", i, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tsraw = praw.String()\n+\t\tif sraw != tt.RawProxy {\n+\t\t\tt.Errorf(\"Test Proxy %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.RawProxy, sraw)\n+\t\t\tcontinue\n+\t\t}\n \t}\n }"}, {"sha": "1f725ecdddd0b786ebe65413f386e2137c77d377", "filename": "libgo/go/http/response.go", "status": "modified", "additions": 24, "deletions": 10, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fresponse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fresponse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponse.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -46,6 +46,9 @@ type Response struct {\n \t// Keys in the map are canonicalized (see CanonicalHeaderKey).\n \tHeader Header\n \n+\t// SetCookie records the Set-Cookie requests sent with the response.\n+\tSetCookie []*Cookie\n+\n \t// Body represents the response body.\n \tBody io.ReadCloser\n \n@@ -64,10 +67,9 @@ type Response struct {\n \t// ReadResponse nor Response.Write ever closes a connection.\n \tClose bool\n \n-\t// Trailer maps trailer keys to values.  Like for Header, if the\n-\t// response has multiple trailer lines with the same key, they will be\n-\t// concatenated, delimited by commas.\n-\tTrailer map[string][]string\n+\t// Trailer maps trailer keys to values, in the same\n+\t// format as the header.\n+\tTrailer Header\n }\n \n // ReadResponse reads and returns an HTTP response from r.  The RequestMethod\n@@ -124,6 +126,8 @@ func ReadResponse(r *bufio.Reader, requestMethod string) (resp *Response, err os\n \t\treturn nil, err\n \t}\n \n+\tresp.SetCookie = readSetCookies(resp.Header)\n+\n \treturn resp, nil\n }\n \n@@ -188,11 +192,15 @@ func (resp *Response) Write(w io.Writer) os.Error {\n \t}\n \n \t// Rest of header\n-\terr = writeSortedKeyValue(w, resp.Header, respExcludeHeader)\n+\terr = writeSortedHeader(w, resp.Header, respExcludeHeader)\n \tif err != nil {\n \t\treturn err\n \t}\n \n+\tif err = writeSetCookies(w, resp.SetCookie); err != nil {\n+\t\treturn err\n+\t}\n+\n \t// End-of-header\n \tio.WriteString(w, \"\\r\\n\")\n \n@@ -206,16 +214,22 @@ func (resp *Response) Write(w io.Writer) os.Error {\n \treturn nil\n }\n \n-func writeSortedKeyValue(w io.Writer, kvm map[string][]string, exclude map[string]bool) os.Error {\n-\tkeys := make([]string, 0, len(kvm))\n-\tfor k := range kvm {\n-\t\tif !exclude[k] {\n+func writeSortedHeader(w io.Writer, h Header, exclude map[string]bool) os.Error {\n+\tkeys := make([]string, 0, len(h))\n+\tfor k := range h {\n+\t\tif exclude == nil || !exclude[k] {\n \t\t\tkeys = append(keys, k)\n \t\t}\n \t}\n \tsort.SortStrings(keys)\n \tfor _, k := range keys {\n-\t\tfor _, v := range kvm[k] {\n+\t\tfor _, v := range h[k] {\n+\t\t\tv = strings.Replace(v, \"\\n\", \" \", -1)\n+\t\t\tv = strings.Replace(v, \"\\r\", \" \", -1)\n+\t\t\tv = strings.TrimSpace(v)\n+\t\t\tif v == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n \t\t\tif _, err := fmt.Fprintf(w, \"%s: %s\\r\\n\", k, v); err != nil {\n \t\t\t\treturn err\n \t\t\t}"}, {"sha": "de0635da516c8ec5a7d2c3572581c5ccf587f17f", "filename": "libgo/go/http/responsewrite_test.go", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fresponsewrite_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,6 +6,7 @@ package http\n \n import (\n \t\"bytes\"\n+\t\"io/ioutil\"\n \t\"testing\"\n )\n \n@@ -22,8 +23,8 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string][]string{},\n-\t\t\tBody:          nopCloser{bytes.NewBufferString(\"abcdef\")},\n+\t\t\tHeader:        Header{},\n+\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n \t\t\tContentLength: 6,\n \t\t},\n \n@@ -38,8 +39,8 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:    1,\n \t\t\tProtoMinor:    0,\n \t\t\tRequestMethod: \"GET\",\n-\t\t\tHeader:        map[string][]string{},\n-\t\t\tBody:          nopCloser{bytes.NewBufferString(\"abcdef\")},\n+\t\t\tHeader:        Header{},\n+\t\t\tBody:          ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n \t\t\tContentLength: -1,\n \t\t},\n \t\t\"HTTP/1.0 200 OK\\r\\n\" +\n@@ -53,8 +54,8 @@ var respWriteTests = []respWriteTest{\n \t\t\tProtoMajor:       1,\n \t\t\tProtoMinor:       1,\n \t\t\tRequestMethod:    \"GET\",\n-\t\t\tHeader:           map[string][]string{},\n-\t\t\tBody:             nopCloser{bytes.NewBufferString(\"abcdef\")},\n+\t\t\tHeader:           Header{},\n+\t\t\tBody:             ioutil.NopCloser(bytes.NewBufferString(\"abcdef\")),\n \t\t\tContentLength:    6,\n \t\t\tTransferEncoding: []string{\"chunked\"},\n \t\t\tClose:            true,\n@@ -65,6 +66,29 @@ var respWriteTests = []respWriteTest{\n \t\t\t\"Transfer-Encoding: chunked\\r\\n\\r\\n\" +\n \t\t\t\"6\\r\\nabcdef\\r\\n0\\r\\n\\r\\n\",\n \t},\n+\n+\t// Header value with a newline character (Issue 914).\n+\t// Also tests removal of leading and trailing whitespace.\n+\t{\n+\t\tResponse{\n+\t\t\tStatusCode:    204,\n+\t\t\tProtoMajor:    1,\n+\t\t\tProtoMinor:    1,\n+\t\t\tRequestMethod: \"GET\",\n+\t\t\tHeader: Header{\n+\t\t\t\t\"Foo\": []string{\" Bar\\nBaz \"},\n+\t\t\t},\n+\t\t\tBody:             nil,\n+\t\t\tContentLength:    0,\n+\t\t\tTransferEncoding: []string{\"chunked\"},\n+\t\t\tClose:            true,\n+\t\t},\n+\n+\t\t\"HTTP/1.1 204 No Content\\r\\n\" +\n+\t\t\t\"Connection: close\\r\\n\" +\n+\t\t\t\"Foo: Bar Baz\\r\\n\" +\n+\t\t\t\"\\r\\n\",\n+\t},\n }\n \n func TestResponseWrite(t *testing.T) {\n@@ -78,7 +102,7 @@ func TestResponseWrite(t *testing.T) {\n \t\t}\n \t\tsraw := braw.String()\n \t\tif sraw != tt.Raw {\n-\t\t\tt.Errorf(\"Test %d, expecting:\\n%s\\nGot:\\n%s\\n\", i, tt.Raw, sraw)\n+\t\t\tt.Errorf(\"Test %d, expecting:\\n%q\\nGot:\\n%q\\n\", i, tt.Raw, sraw)\n \t\t\tcontinue\n \t\t}\n \t}"}, {"sha": "683de85b8670b2134afa52f8551fae1c1dd248d3", "filename": "libgo/go/http/serve_test.go", "status": "modified", "additions": 166, "deletions": 91, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fserve_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fserve_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserve_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -4,16 +4,18 @@\n \n // End-to-end serving tests\n \n-package http\n+package http_test\n \n import (\n \t\"bufio\"\n \t\"bytes\"\n \t\"fmt\"\n-\t\"io\"\n+\t. \"http\"\n+\t\"http/httptest\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"net\"\n+\t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n \t\"time\"\n@@ -143,7 +145,7 @@ func TestConsumingBodyOnNextConn(t *testing.T) {\n type stringHandler string\n \n func (s stringHandler) ServeHTTP(w ResponseWriter, r *Request) {\n-\tw.SetHeader(\"Result\", string(s))\n+\tw.Header().Set(\"Result\", string(s))\n }\n \n var handlers = []struct {\n@@ -170,13 +172,10 @@ func TestHostHandlers(t *testing.T) {\n \tfor _, h := range handlers {\n \t\tHandle(h.pattern, stringHandler(h.msg))\n \t}\n-\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\") // any port\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer l.Close()\n-\tgo Serve(l, nil)\n-\tconn, err := net.Dial(\"tcp\", \"\", l.Addr().String())\n+\tts := httptest.NewServer(nil)\n+\tdefer ts.Close()\n+\n+\tconn, err := net.Dial(\"tcp\", \"\", ts.Listener.Addr().String())\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n@@ -205,46 +204,6 @@ func TestHostHandlers(t *testing.T) {\n \t}\n }\n \n-type responseWriterMethodCall struct {\n-\tmethod                 string\n-\theaderKey, headerValue string // if method == \"SetHeader\"\n-\tbytesWritten           []byte // if method == \"Write\"\n-\tresponseCode           int    // if method == \"WriteHeader\"\n-}\n-\n-type recordingResponseWriter struct {\n-\tlog []*responseWriterMethodCall\n-}\n-\n-func (rw *recordingResponseWriter) RemoteAddr() string {\n-\treturn \"1.2.3.4\"\n-}\n-\n-func (rw *recordingResponseWriter) UsingTLS() bool {\n-\treturn false\n-}\n-\n-func (rw *recordingResponseWriter) SetHeader(k, v string) {\n-\trw.log = append(rw.log, &responseWriterMethodCall{method: \"SetHeader\", headerKey: k, headerValue: v})\n-}\n-\n-func (rw *recordingResponseWriter) Write(buf []byte) (int, os.Error) {\n-\trw.log = append(rw.log, &responseWriterMethodCall{method: \"Write\", bytesWritten: buf})\n-\treturn len(buf), nil\n-}\n-\n-func (rw *recordingResponseWriter) WriteHeader(code int) {\n-\trw.log = append(rw.log, &responseWriterMethodCall{method: \"WriteHeader\", responseCode: code})\n-}\n-\n-func (rw *recordingResponseWriter) Flush() {\n-\trw.log = append(rw.log, &responseWriterMethodCall{method: \"Flush\"})\n-}\n-\n-func (rw *recordingResponseWriter) Hijack() (io.ReadWriteCloser, *bufio.ReadWriter, os.Error) {\n-\tpanic(\"Not supported\")\n-}\n-\n // Tests for http://code.google.com/p/go/issues/detail?id=900\n func TestMuxRedirectLeadingSlashes(t *testing.T) {\n \tpaths := []string{\"//foo.txt\", \"///foo.txt\", \"/../../foo.txt\"}\n@@ -254,41 +213,24 @@ func TestMuxRedirectLeadingSlashes(t *testing.T) {\n \t\t\tt.Errorf(\"%s\", err)\n \t\t}\n \t\tmux := NewServeMux()\n-\t\tresp := new(recordingResponseWriter)\n-\t\tresp.log = make([]*responseWriterMethodCall, 0)\n+\t\tresp := httptest.NewRecorder()\n \n \t\tmux.ServeHTTP(resp, req)\n \n-\t\tdumpLog := func() {\n-\t\t\tt.Logf(\"For path %q:\", path)\n-\t\t\tfor _, call := range resp.log {\n-\t\t\t\tt.Logf(\"Got call: %s, header=%s, value=%s, buf=%q, code=%d\", call.method,\n-\t\t\t\t\tcall.headerKey, call.headerValue, call.bytesWritten, call.responseCode)\n-\t\t\t}\n-\t\t}\n-\n-\t\tif len(resp.log) != 2 {\n-\t\t\tdumpLog()\n-\t\t\tt.Errorf(\"expected 2 calls to response writer; got %d\", len(resp.log))\n-\t\t\treturn\n-\t\t}\n-\n-\t\tif resp.log[0].method != \"SetHeader\" ||\n-\t\t\tresp.log[0].headerKey != \"Location\" || resp.log[0].headerValue != \"/foo.txt\" {\n-\t\t\tdumpLog()\n-\t\t\tt.Errorf(\"Expected SetHeader of Location to /foo.txt\")\n+\t\tif loc, expected := resp.Header().Get(\"Location\"), \"/foo.txt\"; loc != expected {\n+\t\t\tt.Errorf(\"Expected Location header set to %q; got %q\", expected, loc)\n \t\t\treturn\n \t\t}\n \n-\t\tif resp.log[1].method != \"WriteHeader\" || resp.log[1].responseCode != StatusMovedPermanently {\n-\t\t\tdumpLog()\n-\t\t\tt.Errorf(\"Expected WriteHeader of StatusMovedPermanently\")\n+\t\tif code, expected := resp.Code, StatusMovedPermanently; code != expected {\n+\t\t\tt.Errorf(\"Expected response code of StatusMovedPermanently; got %d\", code)\n \t\t\treturn\n \t\t}\n \t}\n }\n \n func TestServerTimeouts(t *testing.T) {\n+\t// TODO(bradfitz): convert this to use httptest.Server\n \tl, err := net.ListenTCP(\"tcp\", &net.TCPAddr{Port: 0})\n \tif err != nil {\n \t\tt.Fatalf(\"listen error: %v\", err)\n@@ -308,7 +250,9 @@ func TestServerTimeouts(t *testing.T) {\n \turl := fmt.Sprintf(\"http://localhost:%d/\", addr.Port)\n \n \t// Hit the HTTP server successfully.\n-\tr, _, err := Get(url)\n+\ttr := &Transport{DisableKeepAlives: true} // they interfere with this test\n+\tc := &Client{Transport: tr}\n+\tr, _, err := c.Get(url)\n \tif err != nil {\n \t\tt.Fatalf(\"http Get #1: %v\", err)\n \t}\n@@ -353,39 +297,32 @@ func TestServerTimeouts(t *testing.T) {\n \n // TestIdentityResponse verifies that a handler can unset \n func TestIdentityResponse(t *testing.T) {\n-\tl, err := net.Listen(\"tcp\", \"127.0.0.1:0\")\n-\tif err != nil {\n-\t\tt.Fatalf(\"failed to listen on a port: %v\", err)\n-\t}\n-\tdefer l.Close()\n-\turlBase := \"http://\" + l.Addr().String() + \"/\"\n-\n \thandler := HandlerFunc(func(rw ResponseWriter, req *Request) {\n-\t\trw.SetHeader(\"Content-Length\", \"3\")\n-\t\trw.SetHeader(\"Transfer-Encoding\", req.FormValue(\"te\"))\n+\t\trw.Header().Set(\"Content-Length\", \"3\")\n+\t\trw.Header().Set(\"Transfer-Encoding\", req.FormValue(\"te\"))\n \t\tswitch {\n \t\tcase req.FormValue(\"overwrite\") == \"1\":\n \t\t\t_, err := rw.Write([]byte(\"foo TOO LONG\"))\n \t\t\tif err != ErrContentLength {\n \t\t\t\tt.Errorf(\"expected ErrContentLength; got %v\", err)\n \t\t\t}\n \t\tcase req.FormValue(\"underwrite\") == \"1\":\n-\t\t\trw.SetHeader(\"Content-Length\", \"500\")\n+\t\t\trw.Header().Set(\"Content-Length\", \"500\")\n \t\t\trw.Write([]byte(\"too short\"))\n \t\tdefault:\n \t\t\trw.Write([]byte(\"foo\"))\n \t\t}\n \t})\n \n-\tserver := &Server{Handler: handler}\n-\tgo server.Serve(l)\n+\tts := httptest.NewServer(handler)\n+\tdefer ts.Close()\n \n \t// Note: this relies on the assumption (which is true) that\n \t// Get sends HTTP/1.1 or greater requests.  Otherwise the\n \t// server wouldn't have the choice to send back chunked\n \t// responses.\n \tfor _, te := range []string{\"\", \"identity\"} {\n-\t\turl := urlBase + \"?te=\" + te\n+\t\turl := ts.URL + \"/?te=\" + te\n \t\tres, _, err := Get(url)\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"error with Get of %s: %v\", url, err)\n@@ -400,18 +337,18 @@ func TestIdentityResponse(t *testing.T) {\n \t\t\tt.Errorf(\"for %s expected len(res.TransferEncoding) of %d; got %d (%v)\",\n \t\t\t\turl, expected, tl, res.TransferEncoding)\n \t\t}\n+\t\tres.Body.Close()\n \t}\n \n \t// Verify that ErrContentLength is returned\n-\turl := urlBase + \"?overwrite=1\"\n-\t_, _, err = Get(url)\n+\turl := ts.URL + \"/?overwrite=1\"\n+\t_, _, err := Get(url)\n \tif err != nil {\n \t\tt.Fatalf(\"error with Get of %s: %v\", url, err)\n \t}\n-\n \t// Verify that the connection is closed when the declared Content-Length\n \t// is larger than what the handler wrote.\n-\tconn, err := net.Dial(\"tcp\", \"\", l.Addr().String())\n+\tconn, err := net.Dial(\"tcp\", \"\", ts.Listener.Addr().String())\n \tif err != nil {\n \t\tt.Fatalf(\"error dialing: %v\", err)\n \t}\n@@ -432,3 +369,141 @@ func TestIdentityResponse(t *testing.T) {\n \t\t\texpectedSuffix, string(got))\n \t}\n }\n+\n+// TestServeHTTP10Close verifies that HTTP/1.0 requests won't be kept alive.\n+func TestServeHTTP10Close(t *testing.T) {\n+\ts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tServeFile(w, r, \"testdata/file\")\n+\t}))\n+\tdefer s.Close()\n+\n+\tconn, err := net.Dial(\"tcp\", \"\", s.Listener.Addr().String())\n+\tif err != nil {\n+\t\tt.Fatal(\"dial error:\", err)\n+\t}\n+\tdefer conn.Close()\n+\n+\t_, err = fmt.Fprint(conn, \"GET / HTTP/1.0\\r\\n\\r\\n\")\n+\tif err != nil {\n+\t\tt.Fatal(\"print error:\", err)\n+\t}\n+\n+\tr := bufio.NewReader(conn)\n+\t_, err = ReadResponse(r, \"GET\")\n+\tif err != nil {\n+\t\tt.Fatal(\"ReadResponse error:\", err)\n+\t}\n+\n+\tsuccess := make(chan bool)\n+\tgo func() {\n+\t\tselect {\n+\t\tcase <-time.After(5e9):\n+\t\t\tt.Fatal(\"body not closed after 5s\")\n+\t\tcase <-success:\n+\t\t}\n+\t}()\n+\n+\t_, err = ioutil.ReadAll(r)\n+\tif err != nil {\n+\t\tt.Fatal(\"read error:\", err)\n+\t}\n+\n+\tsuccess <- true\n+}\n+\n+func TestSetsRemoteAddr(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tfmt.Fprintf(w, \"%s\", r.RemoteAddr)\n+\t}))\n+\tdefer ts.Close()\n+\n+\tres, _, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get error: %v\", err)\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ReadAll error: %v\", err)\n+\t}\n+\tip := string(body)\n+\tif !strings.HasPrefix(ip, \"127.0.0.1:\") && !strings.HasPrefix(ip, \"[::1]:\") {\n+\t\tt.Fatalf(\"Expected local addr; got %q\", ip)\n+\t}\n+}\n+\n+func TestChunkedResponseHeaders(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.Header().Set(\"Content-Length\", \"intentional gibberish\") // we check that this is deleted\n+\t\tfmt.Fprintf(w, \"I am a chunked response.\")\n+\t}))\n+\tdefer ts.Close()\n+\n+\tres, _, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Fatalf(\"Get error: %v\", err)\n+\t}\n+\tif g, e := res.ContentLength, int64(-1); g != e {\n+\t\tt.Errorf(\"expected ContentLength of %d; got %d\", e, g)\n+\t}\n+\tif g, e := res.TransferEncoding, []string{\"chunked\"}; !reflect.DeepEqual(g, e) {\n+\t\tt.Errorf(\"expected TransferEncoding of %v; got %v\", e, g)\n+\t}\n+\tif _, haveCL := res.Header[\"Content-Length\"]; haveCL {\n+\t\tt.Errorf(\"Unexpected Content-Length\")\n+\t}\n+}\n+\n+// Test304Responses verifies that 304s don't declare that they're\n+// chunking in their response headers and aren't allowed to produce\n+// output.\n+func Test304Responses(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tw.WriteHeader(StatusNotModified)\n+\t\t_, err := w.Write([]byte(\"illegal body\"))\n+\t\tif err != ErrBodyNotAllowed {\n+\t\t\tt.Errorf(\"on Write, expected ErrBodyNotAllowed, got %v\", err)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\tres, _, err := Get(ts.URL)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif len(res.TransferEncoding) > 0 {\n+\t\tt.Errorf(\"expected no TransferEncoding; got %v\", res.TransferEncoding)\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif len(body) > 0 {\n+\t\tt.Errorf(\"got unexpected body %q\", string(body))\n+\t}\n+}\n+\n+// TestHeadResponses verifies that responses to HEAD requests don't\n+// declare that they're chunking in their response headers and aren't\n+// allowed to produce output.\n+func TestHeadResponses(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\t_, err := w.Write([]byte(\"Ignored body\"))\n+\t\tif err != ErrBodyNotAllowed {\n+\t\t\tt.Errorf(\"on Write, expected ErrBodyNotAllowed, got %v\", err)\n+\t\t}\n+\t}))\n+\tdefer ts.Close()\n+\tres, err := Head(ts.URL)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif len(res.TransferEncoding) > 0 {\n+\t\tt.Errorf(\"expected no TransferEncoding; got %v\", res.TransferEncoding)\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+\tif len(body) > 0 {\n+\t\tt.Errorf(\"got unexpected body %q\", string(body))\n+\t}\n+}"}, {"sha": "8e7039371ae1d011dcfafa912020c0c7eeac3bd0", "filename": "libgo/go/http/server.go", "status": "modified", "additions": 75, "deletions": 80, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Fserver.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,7 +6,6 @@\n \n // TODO(rsc):\n //\tlogging\n-//\tcgi support\n //\tpost support\n \n package http\n@@ -49,23 +48,10 @@ type Handler interface {\n // A ResponseWriter interface is used by an HTTP handler to\n // construct an HTTP response.\n type ResponseWriter interface {\n-\t// RemoteAddr returns the address of the client that sent the current request\n-\tRemoteAddr() string\n-\n-\t// UsingTLS returns true if the client is connected using TLS\n-\tUsingTLS() bool\n-\n-\t// SetHeader sets a header line in the eventual response.\n-\t// For example, SetHeader(\"Content-Type\", \"text/html; charset=utf-8\")\n-\t// will result in the header line\n-\t//\n-\t//\tContent-Type: text/html; charset=utf-8\n-\t//\n-\t// being sent. UTF-8 encoded HTML is the default setting for\n-\t// Content-Type in this library, so users need not make that\n-\t// particular call. Calls to SetHeader after WriteHeader (or Write)\n-\t// are ignored. An empty value removes the header if previously set.\n-\tSetHeader(string, string)\n+\t// Header returns the header map that will be sent by WriteHeader.\n+\t// Changing the header after a call to WriteHeader (or Write) has\n+\t// no effect.\n+\tHeader() Header\n \n \t// Write writes the data to the connection as part of an HTTP reply.\n \t// If WriteHeader has not yet been called, Write calls WriteHeader(http.StatusOK)\n@@ -78,39 +64,52 @@ type ResponseWriter interface {\n \t// Thus explicit calls to WriteHeader are mainly used to\n \t// send error codes.\n \tWriteHeader(int)\n+}\n \n+// The Flusher interface is implemented by ResponseWriters that allow\n+// an HTTP handler to flush buffered data to the client.\n+//\n+// Note that even for ResponseWriters that support Flush,\n+// if the client is connected through an HTTP proxy,\n+// the buffered data may not reach the client until the response\n+// completes.\n+type Flusher interface {\n \t// Flush sends any buffered data to the client.\n \tFlush()\n+}\n \n+// The Hijacker interface is implemented by ResponseWriters that allow\n+// an HTTP handler to take over the connection.\n+type Hijacker interface {\n \t// Hijack lets the caller take over the connection.\n \t// After a call to Hijack(), the HTTP server library\n \t// will not do anything else with the connection.\n \t// It becomes the caller's responsibility to manage\n \t// and close the connection.\n-\tHijack() (io.ReadWriteCloser, *bufio.ReadWriter, os.Error)\n+\tHijack() (net.Conn, *bufio.ReadWriter, os.Error)\n }\n \n // A conn represents the server side of an HTTP connection.\n type conn struct {\n-\tremoteAddr string             // network address of remote side\n-\thandler    Handler            // request handler\n-\trwc        io.ReadWriteCloser // i/o connection\n-\tbuf        *bufio.ReadWriter  // buffered rwc\n-\thijacked   bool               // connection has been hijacked by handler\n-\tusingTLS   bool               // a flag indicating connection over TLS\n+\tremoteAddr string               // network address of remote side\n+\thandler    Handler              // request handler\n+\trwc        net.Conn             // i/o connection\n+\tbuf        *bufio.ReadWriter    // buffered rwc\n+\thijacked   bool                 // connection has been hijacked by handler\n+\ttlsState   *tls.ConnectionState // or nil when not using TLS        \n }\n \n // A response represents the server side of an HTTP response.\n type response struct {\n \tconn          *conn\n-\treq           *Request          // request for this response\n-\tchunking      bool              // using chunked transfer encoding for reply body\n-\twroteHeader   bool              // reply header has been written\n-\twroteContinue bool              // 100 Continue response was written\n-\theader        map[string]string // reply header parameters\n-\twritten       int64             // number of bytes written in body\n-\tcontentLength int64             // explicitly-declared Content-Length; or -1\n-\tstatus        int               // status code passed to WriteHeader\n+\treq           *Request // request for this response\n+\tchunking      bool     // using chunked transfer encoding for reply body\n+\twroteHeader   bool     // reply header has been written\n+\twroteContinue bool     // 100 Continue response was written\n+\theader        Header   // reply header parameters\n+\twritten       int64    // number of bytes written in body\n+\tcontentLength int64    // explicitly-declared Content-Length; or -1\n+\tstatus        int      // status code passed to WriteHeader\n \n \t// close connection after this reply.  set on request and\n \t// updated after response from handler if there's a\n@@ -125,10 +124,15 @@ func newConn(rwc net.Conn, handler Handler) (c *conn, err os.Error) {\n \tc.remoteAddr = rwc.RemoteAddr().String()\n \tc.handler = handler\n \tc.rwc = rwc\n-\t_, c.usingTLS = rwc.(*tls.Conn)\n \tbr := bufio.NewReader(rwc)\n \tbw := bufio.NewWriter(rwc)\n \tc.buf = bufio.NewReadWriter(br, bw)\n+\n+\tif tlsConn, ok := rwc.(*tls.Conn); ok {\n+\t\tc.tlsState = new(tls.ConnectionState)\n+\t\t*c.tlsState = tlsConn.ConnectionState()\n+\t}\n+\n \treturn c, nil\n }\n \n@@ -168,10 +172,13 @@ func (c *conn) readRequest() (w *response, err os.Error) {\n \t\treturn nil, err\n \t}\n \n+\treq.RemoteAddr = c.remoteAddr\n+\treq.TLS = c.tlsState\n+\n \tw = new(response)\n \tw.conn = c\n \tw.req = req\n-\tw.header = make(map[string]string)\n+\tw.header = make(Header)\n \tw.contentLength = -1\n \n \t// Expect 100 Continue support\n@@ -182,21 +189,10 @@ func (c *conn) readRequest() (w *response, err os.Error) {\n \treturn w, nil\n }\n \n-// UsingTLS implements the ResponseWriter.UsingTLS\n-func (w *response) UsingTLS() bool {\n-\treturn w.conn.usingTLS\n-}\n-\n-// RemoteAddr implements the ResponseWriter.RemoteAddr method\n-func (w *response) RemoteAddr() string { return w.conn.remoteAddr }\n-\n-// SetHeader implements the ResponseWriter.SetHeader method\n-// An empty value removes the header from the map.\n-func (w *response) SetHeader(hdr, val string) {\n-\tw.header[CanonicalHeaderKey(hdr)] = val, val != \"\"\n+func (w *response) Header() Header {\n+\treturn w.header\n }\n \n-// WriteHeader implements the ResponseWriter.WriteHeader method\n func (w *response) WriteHeader(code int) {\n \tif w.conn.hijacked {\n \t\tlog.Print(\"http: response.WriteHeader on hijacked connection\")\n@@ -211,82 +207,84 @@ func (w *response) WriteHeader(code int) {\n \tif code == StatusNotModified {\n \t\t// Must not have body.\n \t\tfor _, header := range []string{\"Content-Type\", \"Content-Length\", \"Transfer-Encoding\"} {\n-\t\t\tif w.header[header] != \"\" {\n+\t\t\tif w.header.Get(header) != \"\" {\n \t\t\t\t// TODO: return an error if WriteHeader gets a return parameter\n \t\t\t\t// or set a flag on w to make future Writes() write an error page?\n \t\t\t\t// for now just log and drop the header.\n \t\t\t\tlog.Printf(\"http: StatusNotModified response with header %q defined\", header)\n-\t\t\t\tw.header[header] = \"\", false\n+\t\t\t\tw.header.Del(header)\n \t\t\t}\n \t\t}\n \t} else {\n \t\t// Default output is HTML encoded in UTF-8.\n-\t\tif w.header[\"Content-Type\"] == \"\" {\n-\t\t\tw.SetHeader(\"Content-Type\", \"text/html; charset=utf-8\")\n+\t\tif w.header.Get(\"Content-Type\") == \"\" {\n+\t\t\tw.header.Set(\"Content-Type\", \"text/html; charset=utf-8\")\n \t\t}\n \t}\n \n-\tif w.header[\"Date\"] == \"\" {\n-\t\tw.SetHeader(\"Date\", time.UTC().Format(TimeFormat))\n+\tif w.header.Get(\"Date\") == \"\" {\n+\t\tw.Header().Set(\"Date\", time.UTC().Format(TimeFormat))\n \t}\n \n \t// Check for a explicit (and valid) Content-Length header.\n \tvar hasCL bool\n \tvar contentLength int64\n-\tif clenStr, ok := w.header[\"Content-Length\"]; ok {\n+\tif clenStr := w.header.Get(\"Content-Length\"); clenStr != \"\" {\n \t\tvar err os.Error\n \t\tcontentLength, err = strconv.Atoi64(clenStr)\n \t\tif err == nil {\n \t\t\thasCL = true\n \t\t} else {\n \t\t\tlog.Printf(\"http: invalid Content-Length of %q sent\", clenStr)\n-\t\t\tw.SetHeader(\"Content-Length\", \"\")\n+\t\t\tw.header.Del(\"Content-Length\")\n \t\t}\n \t}\n \n-\tte, hasTE := w.header[\"Transfer-Encoding\"]\n+\tte := w.header.Get(\"Transfer-Encoding\")\n+\thasTE := te != \"\"\n \tif hasCL && hasTE && te != \"identity\" {\n \t\t// TODO: return an error if WriteHeader gets a return parameter\n \t\t// For now just ignore the Content-Length.\n \t\tlog.Printf(\"http: WriteHeader called with both Transfer-Encoding of %q and a Content-Length of %d\",\n \t\t\tte, contentLength)\n-\t\tw.SetHeader(\"Content-Length\", \"\")\n+\t\tw.header.Del(\"Content-Length\")\n \t\thasCL = false\n \t}\n \n-\tif w.req.Method == \"HEAD\" {\n+\tif w.req.Method == \"HEAD\" || code == StatusNotModified {\n \t\t// do nothing\n \t} else if hasCL {\n-\t\tw.chunking = false\n \t\tw.contentLength = contentLength\n-\t\tw.SetHeader(\"Transfer-Encoding\", \"\")\n+\t\tw.header.Del(\"Transfer-Encoding\")\n \t} else if w.req.ProtoAtLeast(1, 1) {\n \t\t// HTTP/1.1 or greater: use chunked transfer encoding\n \t\t// to avoid closing the connection at EOF.\n \t\t// TODO: this blows away any custom or stacked Transfer-Encoding they\n \t\t// might have set.  Deal with that as need arises once we have a valid\n \t\t// use case.\n \t\tw.chunking = true\n-\t\tw.SetHeader(\"Transfer-Encoding\", \"chunked\")\n+\t\tw.header.Set(\"Transfer-Encoding\", \"chunked\")\n \t} else {\n \t\t// HTTP version < 1.1: cannot do chunked transfer\n \t\t// encoding and we don't know the Content-Length so\n \t\t// signal EOF by closing connection.\n \t\tw.closeAfterReply = true\n-\t\tw.chunking = false                   // redundant\n-\t\tw.SetHeader(\"Transfer-Encoding\", \"\") // in case already set\n+\t\tw.header.Del(\"Transfer-Encoding\") // in case already set\n \t}\n \n \tif w.req.wantsHttp10KeepAlive() && (w.req.Method == \"HEAD\" || hasCL) {\n \t\t_, connectionHeaderSet := w.header[\"Connection\"]\n \t\tif !connectionHeaderSet {\n-\t\t\tw.SetHeader(\"Connection\", \"keep-alive\")\n+\t\t\tw.header.Set(\"Connection\", \"keep-alive\")\n \t\t}\n+\t} else if !w.req.ProtoAtLeast(1, 1) {\n+\t\t// Client did not ask to keep connection alive.\n+\t\tw.closeAfterReply = true\n \t}\n \n \t// Cannot use Content-Length with non-identity Transfer-Encoding.\n \tif w.chunking {\n-\t\tw.SetHeader(\"Content-Length\", \"\")\n+\t\tw.header.Del(\"Content-Length\")\n \t}\n \tif !w.req.ProtoAtLeast(1, 0) {\n \t\treturn\n@@ -301,13 +299,10 @@ func (w *response) WriteHeader(code int) {\n \t\ttext = \"status code \" + codestring\n \t}\n \tio.WriteString(w.conn.buf, proto+\" \"+codestring+\" \"+text+\"\\r\\n\")\n-\tfor k, v := range w.header {\n-\t\tio.WriteString(w.conn.buf, k+\": \"+v+\"\\r\\n\")\n-\t}\n+\twriteSortedHeader(w.conn.buf, w.header, nil)\n \tio.WriteString(w.conn.buf, \"\\r\\n\")\n }\n \n-// Write implements the ResponseWriter.Write method\n func (w *response) Write(data []byte) (n int, err os.Error) {\n \tif w.conn.hijacked {\n \t\tlog.Print(\"http: response.Write on hijacked connection\")\n@@ -382,7 +377,7 @@ func errorKludge(w *response) {\n \tmsg += \" would ignore this error page if this text weren't here.\\n\"\n \n \t// Is it text?  (\"Content-Type\" is always in the map)\n-\tbaseType := strings.Split(w.header[\"Content-Type\"], \";\", 2)[0]\n+\tbaseType := strings.Split(w.header.Get(\"Content-Type\"), \";\", 2)[0]\n \tswitch baseType {\n \tcase \"text/html\":\n \t\tio.WriteString(w, \"<!-- \")\n@@ -402,8 +397,8 @@ func (w *response) finishRequest() {\n \t// If this was an HTTP/1.0 request with keep-alive and we sent a Content-Length\n \t// back, we can make this a keep-alive response ...\n \tif w.req.wantsHttp10KeepAlive() {\n-\t\t_, sentLength := w.header[\"Content-Length\"]\n-\t\tif sentLength && w.header[\"Connection\"] == \"keep-alive\" {\n+\t\tsentLength := w.header.Get(\"Content-Length\") != \"\"\n+\t\tif sentLength && w.header.Get(\"Connection\") == \"keep-alive\" {\n \t\t\tw.closeAfterReply = false\n \t\t}\n \t}\n@@ -425,7 +420,6 @@ func (w *response) finishRequest() {\n \t}\n }\n \n-// Flush implements the ResponseWriter.Flush method.\n func (w *response) Flush() {\n \tif !w.wroteHeader {\n \t\tw.WriteHeader(StatusOK)\n@@ -469,8 +463,9 @@ func (c *conn) serve() {\n \tc.close()\n }\n \n-// Hijack impements the ResponseWriter.Hijack method.\n-func (w *response) Hijack() (rwc io.ReadWriteCloser, buf *bufio.ReadWriter, err os.Error) {\n+// Hijack implements the Hijacker.Hijack method. Our response is both a ResponseWriter\n+// and a Hijacker.\n+func (w *response) Hijack() (rwc net.Conn, buf *bufio.ReadWriter, err os.Error) {\n \tif w.conn.hijacked {\n \t\treturn nil, nil, ErrHijacked\n \t}\n@@ -497,7 +492,7 @@ func (f HandlerFunc) ServeHTTP(w ResponseWriter, r *Request) {\n \n // Error replies to the request with the specified error message and HTTP code.\n func Error(w ResponseWriter, error string, code int) {\n-\tw.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \tw.WriteHeader(code)\n \tfmt.Fprintln(w, error)\n }\n@@ -550,7 +545,7 @@ func Redirect(w ResponseWriter, r *Request, url string, code int) {\n \t\t}\n \t}\n \n-\tw.SetHeader(\"Location\", url)\n+\tw.Header().Set(\"Location\", url)\n \tw.WriteHeader(code)\n \n \t// RFC2616 recommends that a short note \"SHOULD\" be included in the\n@@ -673,7 +668,7 @@ func (mux *ServeMux) match(path string) Handler {\n func (mux *ServeMux) ServeHTTP(w ResponseWriter, r *Request) {\n \t// Clean path to canonical form and redirect.\n \tif p := cleanPath(r.URL.Path); p != r.URL.Path {\n-\t\tw.SetHeader(\"Location\", p)\n+\t\tw.Header().Set(\"Location\", p)\n \t\tw.WriteHeader(StatusMovedPermanently)\n \t\treturn\n \t}\n@@ -826,7 +821,7 @@ func ListenAndServe(addr string, handler Handler) os.Error {\n //\t)\n //\n //\tfunc handler(w http.ResponseWriter, req *http.Request) {\n-//\t\tw.SetHeader(\"Content-Type\", \"text/plain\")\n+//\t\tw.Header().Set(\"Content-Type\", \"text/plain\")\n //\t\tw.Write([]byte(\"This is an example server.\\n\"))\n //\t}\n //"}, {"sha": "8a73ead31f9f855c4598232474333a87963fb527", "filename": "libgo/go/http/transport.go", "status": "modified", "additions": 465, "deletions": 85, "changes": 550, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,53 +9,111 @@ import (\n \t\"crypto/tls\"\n \t\"encoding/base64\"\n \t\"fmt\"\n+\t\"io\"\n+\t\"log\"\n \t\"net\"\n \t\"os\"\n \t\"strings\"\n \t\"sync\"\n )\n \n-// DefaultTransport is the default implementation of ClientTransport\n-// and is used by DefaultClient.  It establishes a new network connection for\n-// each call to Do and uses HTTP proxies as directed by the $HTTP_PROXY and\n-// $NO_PROXY (or $http_proxy and $no_proxy) environment variables.\n-var DefaultTransport ClientTransport = &transport{}\n-\n-// transport implements http.ClientTranport for the default case,\n-// using TCP connections to either the host or a proxy, serving\n-// http or https schemes.  In the future this may become public\n-// and support options on keep-alive connection duration, pipelining\n-// controls, etc.  For now this is simply a port of the old Go code\n-// client code to the http.ClientTransport interface.\n-type transport struct {\n-\t// TODO: keep-alives, pipelining, etc using a map from\n-\t// scheme/host to a connection.  Something like:\n-\tl        sync.Mutex\n-\thostConn map[string]*ClientConn\n-}\n-\n-func (ct *transport) Do(req *Request) (resp *Response, err os.Error) {\n+// DefaultTransport is the default implementation of Transport and is\n+// used by DefaultClient.  It establishes a new network connection for\n+// each call to Do and uses HTTP proxies as directed by the\n+// $HTTP_PROXY and $NO_PROXY (or $http_proxy and $no_proxy)\n+// environment variables.\n+var DefaultTransport RoundTripper = &Transport{}\n+\n+// Transport is an implementation of RoundTripper that supports http,\n+// https, and http proxies (for either http or https with CONNECT).\n+// Transport can also cache connections for future re-use.\n+type Transport struct {\n+\tlk       sync.Mutex\n+\tidleConn map[string][]*persistConn\n+\n+\t// TODO: tunables on max cached connections (total, per-server), duration\n+\t// TODO: optional pipelining\n+\n+\tIgnoreEnvironment bool // don't look at environment variables for proxy configuration\n+\tDisableKeepAlives bool\n+}\n+\n+// RoundTrip implements the RoundTripper interface.\n+func (t *Transport) RoundTrip(req *Request) (resp *Response, err os.Error) {\n+\tif req.URL == nil {\n+\t\tif req.URL, err = ParseURL(req.RawURL); err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n \tif req.URL.Scheme != \"http\" && req.URL.Scheme != \"https\" {\n \t\treturn nil, &badStringError{\"unsupported protocol scheme\", req.URL.Scheme}\n \t}\n \n-\taddr := req.URL.Host\n-\tif !hasPort(addr) {\n-\t\taddr += \":\" + req.URL.Scheme\n+\tcm, err := t.connectMethodForRequest(req)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// Get the cached or newly-created connection to either the\n+\t// host (for http or https), the http proxy, or the http proxy\n+\t// pre-CONNECTed to https server.  In any case, we'll be ready\n+\t// to send it requests.\n+\tpconn, err := t.getConn(cm)\n+\tif err != nil {\n+\t\treturn nil, err\n \t}\n \n-\tvar proxyURL *URL\n-\tproxyAuth := \"\"\n-\tproxy := \"\"\n-\tif !matchNoProxy(addr) {\n-\t\tproxy = os.Getenv(\"HTTP_PROXY\")\n-\t\tif proxy == \"\" {\n-\t\t\tproxy = os.Getenv(\"http_proxy\")\n+\treturn pconn.roundTrip(req)\n+}\n+\n+// CloseIdleConnections closes any connections which were previously\n+// connected from previous requests but are now sitting idle in\n+// a \"keep-alive\" state. It does not interrupt any connections currently\n+// in use.\n+func (t *Transport) CloseIdleConnections() {\n+\tt.lk.Lock()\n+\tdefer t.lk.Unlock()\n+\tif t.idleConn == nil {\n+\t\treturn\n+\t}\n+\tfor _, conns := range t.idleConn {\n+\t\tfor _, pconn := range conns {\n+\t\t\tpconn.close()\n \t\t}\n \t}\n+\tt.idleConn = nil\n+}\n \n-\tif proxy != \"\" {\n-\t\tproxyURL, err = ParseRequestURL(proxy)\n+//\n+// Private implementation past this point.\n+//\n+\n+func (t *Transport) getenvEitherCase(k string) string {\n+\tif t.IgnoreEnvironment {\n+\t\treturn \"\"\n+\t}\n+\tif v := t.getenv(strings.ToUpper(k)); v != \"\" {\n+\t\treturn v\n+\t}\n+\treturn t.getenv(strings.ToLower(k))\n+}\n+\n+func (t *Transport) getenv(k string) string {\n+\tif t.IgnoreEnvironment {\n+\t\treturn \"\"\n+\t}\n+\treturn os.Getenv(k)\n+}\n+\n+func (t *Transport) connectMethodForRequest(req *Request) (*connectMethod, os.Error) {\n+\tcm := &connectMethod{\n+\t\ttargetScheme: req.URL.Scheme,\n+\t\ttargetAddr:   canonicalAddr(req.URL),\n+\t}\n+\n+\tproxy := t.getenvEitherCase(\"HTTP_PROXY\")\n+\tif proxy != \"\" && t.useProxy(cm.targetAddr) {\n+\t\tproxyURL, err := ParseRequestURL(proxy)\n \t\tif err != nil {\n \t\t\treturn nil, os.ErrorString(\"invalid proxy address\")\n \t\t}\n@@ -65,83 +123,405 @@ func (ct *transport) Do(req *Request) (resp *Response, err os.Error) {\n \t\t\t\treturn nil, os.ErrorString(\"invalid proxy address\")\n \t\t\t}\n \t\t}\n-\t\taddr = proxyURL.Host\n-\t\tproxyInfo := proxyURL.RawUserinfo\n-\t\tif proxyInfo != \"\" {\n-\t\t\tenc := base64.URLEncoding\n-\t\t\tencoded := make([]byte, enc.EncodedLen(len(proxyInfo)))\n-\t\t\tenc.Encode(encoded, []byte(proxyInfo))\n-\t\t\tproxyAuth = \"Basic \" + string(encoded)\n+\t\tcm.proxyURL = proxyURL\n+\t}\n+\treturn cm, nil\n+}\n+\n+// proxyAuth returns the Proxy-Authorization header to set\n+// on requests, if applicable.\n+func (cm *connectMethod) proxyAuth() string {\n+\tif cm.proxyURL == nil {\n+\t\treturn \"\"\n+\t}\n+\tproxyInfo := cm.proxyURL.RawUserinfo\n+\tif proxyInfo != \"\" {\n+\t\tenc := base64.URLEncoding\n+\t\tencoded := make([]byte, enc.EncodedLen(len(proxyInfo)))\n+\t\tenc.Encode(encoded, []byte(proxyInfo))\n+\t\treturn \"Basic \" + string(encoded)\n+\t}\n+\treturn \"\"\n+}\n+\n+func (t *Transport) putIdleConn(pconn *persistConn) {\n+\tt.lk.Lock()\n+\tdefer t.lk.Unlock()\n+\tif t.DisableKeepAlives {\n+\t\tpconn.close()\n+\t\treturn\n+\t}\n+\tif pconn.isBroken() {\n+\t\treturn\n+\t}\n+\tkey := pconn.cacheKey\n+\tt.idleConn[key] = append(t.idleConn[key], pconn)\n+}\n+\n+func (t *Transport) getIdleConn(cm *connectMethod) (pconn *persistConn) {\n+\tt.lk.Lock()\n+\tdefer t.lk.Unlock()\n+\tif t.idleConn == nil {\n+\t\tt.idleConn = make(map[string][]*persistConn)\n+\t}\n+\tkey := cm.String()\n+\tfor {\n+\t\tpconns, ok := t.idleConn[key]\n+\t\tif !ok {\n+\t\t\treturn nil\n+\t\t}\n+\t\tif len(pconns) == 1 {\n+\t\t\tpconn = pconns[0]\n+\t\t\tt.idleConn[key] = nil, false\n+\t\t} else {\n+\t\t\t// 2 or more cached connections; pop last\n+\t\t\t// TODO: queue?\n+\t\t\tpconn = pconns[len(pconns)-1]\n+\t\t\tt.idleConn[key] = pconns[0 : len(pconns)-1]\n+\t\t}\n+\t\tif !pconn.isBroken() {\n+\t\t\treturn\n \t\t}\n \t}\n+\treturn\n+}\n+\n+// getConn dials and creates a new persistConn to the target as\n+// specified in the connectMethod.  This includes doing a proxy CONNECT\n+// and/or setting up TLS.  If this doesn't return an error, the persistConn\n+// is ready to write requests to.\n+func (t *Transport) getConn(cm *connectMethod) (*persistConn, os.Error) {\n+\tif pc := t.getIdleConn(cm); pc != nil {\n+\t\treturn pc, nil\n+\t}\n \n-\t// Connect to server or proxy\n-\tconn, err := net.Dial(\"tcp\", \"\", addr)\n+\tconn, err := net.Dial(\"tcp\", \"\", cm.addr())\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \n-\tif req.URL.Scheme == \"http\" {\n-\t\t// Include proxy http header if needed.\n-\t\tif proxyAuth != \"\" {\n-\t\t\treq.Header.Set(\"Proxy-Authorization\", proxyAuth)\n-\t\t}\n-\t} else { // https\n-\t\tif proxyURL != nil {\n-\t\t\t// Ask proxy for direct connection to server.\n-\t\t\t// addr defaults above to \":https\" but we need to use numbers\n-\t\t\taddr = req.URL.Host\n-\t\t\tif !hasPort(addr) {\n-\t\t\t\taddr += \":443\"\n-\t\t\t}\n-\t\t\tfmt.Fprintf(conn, \"CONNECT %s HTTP/1.1\\r\\n\", addr)\n-\t\t\tfmt.Fprintf(conn, \"Host: %s\\r\\n\", addr)\n-\t\t\tif proxyAuth != \"\" {\n-\t\t\t\tfmt.Fprintf(conn, \"Proxy-Authorization: %s\\r\\n\", proxyAuth)\n-\t\t\t}\n-\t\t\tfmt.Fprintf(conn, \"\\r\\n\")\n+\tpa := cm.proxyAuth()\n \n-\t\t\t// Read response.\n-\t\t\t// Okay to use and discard buffered reader here, because\n-\t\t\t// TLS server will not speak until spoken to.\n-\t\t\tbr := bufio.NewReader(conn)\n-\t\t\tresp, err := ReadResponse(br, \"CONNECT\")\n-\t\t\tif err != nil {\n-\t\t\t\treturn nil, err\n-\t\t\t}\n-\t\t\tif resp.StatusCode != 200 {\n-\t\t\t\tf := strings.Split(resp.Status, \" \", 2)\n-\t\t\t\treturn nil, os.ErrorString(f[1])\n+\tpconn := &persistConn{\n+\t\tt:        t,\n+\t\tcacheKey: cm.String(),\n+\t\tconn:     conn,\n+\t\treqch:    make(chan requestAndChan, 50),\n+\t}\n+\tnewClientConnFunc := NewClientConn\n+\n+\tswitch {\n+\tcase cm.proxyURL == nil:\n+\t\t// Do nothing.\n+\tcase cm.targetScheme == \"http\":\n+\t\tnewClientConnFunc = NewProxyClientConn\n+\t\tif pa != \"\" {\n+\t\t\tpconn.mutateRequestFunc = func(req *Request) {\n+\t\t\t\tif req.Header == nil {\n+\t\t\t\t\treq.Header = make(Header)\n+\t\t\t\t}\n+\t\t\t\treq.Header.Set(\"Proxy-Authorization\", pa)\n \t\t\t}\n \t\t}\n+\tcase cm.targetScheme == \"https\":\n+\t\tfmt.Fprintf(conn, \"CONNECT %s HTTP/1.1\\r\\n\", cm.targetAddr)\n+\t\tfmt.Fprintf(conn, \"Host: %s\\r\\n\", cm.targetAddr)\n+\t\tif pa != \"\" {\n+\t\t\tfmt.Fprintf(conn, \"Proxy-Authorization: %s\\r\\n\", pa)\n+\t\t}\n+\t\tfmt.Fprintf(conn, \"\\r\\n\")\n \n+\t\t// Read response.\n+\t\t// Okay to use and discard buffered reader here, because\n+\t\t// TLS server will not speak until spoken to.\n+\t\tbr := bufio.NewReader(conn)\n+\t\tresp, err := ReadResponse(br, \"CONNECT\")\n+\t\tif err != nil {\n+\t\t\tconn.Close()\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif resp.StatusCode != 200 {\n+\t\t\tf := strings.Split(resp.Status, \" \", 2)\n+\t\t\tconn.Close()\n+\t\t\treturn nil, os.ErrorString(f[1])\n+\t\t}\n+\t}\n+\n+\tif cm.targetScheme == \"https\" {\n \t\t// Initiate TLS and check remote host name against certificate.\n \t\tconn = tls.Client(conn, nil)\n \t\tif err = conn.(*tls.Conn).Handshake(); err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\th := req.URL.Host\n-\t\tif hasPort(h) {\n-\t\t\th = h[:strings.LastIndex(h, \":\")]\n-\t\t}\n-\t\tif err = conn.(*tls.Conn).VerifyHostname(h); err != nil {\n+\t\tif err = conn.(*tls.Conn).VerifyHostname(cm.tlsHost()); err != nil {\n \t\t\treturn nil, err\n \t\t}\n+\t\tpconn.conn = conn\n \t}\n \n-\terr = req.Write(conn)\n-\tif err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n+\tpconn.br = bufio.NewReader(pconn.conn)\n+\tpconn.cc = newClientConnFunc(conn, pconn.br)\n+\tpconn.cc.readRes = readResponseWithEOFSignal\n+\tgo pconn.readLoop()\n+\treturn pconn, nil\n+}\n+\n+// useProxy returns true if requests to addr should use a proxy,\n+// according to the NO_PROXY or no_proxy environment variable.\n+func (t *Transport) useProxy(addr string) bool {\n+\tif len(addr) == 0 {\n+\t\treturn true\n+\t}\n+\tno_proxy := t.getenvEitherCase(\"NO_PROXY\")\n+\tif no_proxy == \"*\" {\n+\t\treturn false\n+\t}\n+\n+\taddr = strings.ToLower(strings.TrimSpace(addr))\n+\tif hasPort(addr) {\n+\t\taddr = addr[:strings.LastIndex(addr, \":\")]\n+\t}\n+\n+\tfor _, p := range strings.Split(no_proxy, \",\", -1) {\n+\t\tp = strings.ToLower(strings.TrimSpace(p))\n+\t\tif len(p) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif hasPort(p) {\n+\t\t\tp = p[:strings.LastIndex(p, \":\")]\n+\t\t}\n+\t\tif addr == p || (p[0] == '.' && (strings.HasSuffix(addr, p) || addr == p[1:])) {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n+// connectMethod is the map key (in its String form) for keeping persistent\n+// TCP connections alive for subsequent HTTP requests.\n+//\n+// A connect method may be of the following types:\n+//\n+// Cache key form                Description\n+// -----------------             -------------------------\n+// ||http|foo.com                http directly to server, no proxy\n+// ||https|foo.com               https directly to server, no proxy\n+// http://proxy.com|https|foo.com  http to proxy, then CONNECT to foo.com\n+// http://proxy.com|http           http to proxy, http to anywhere after that\n+//\n+// Note: no support to https to the proxy yet.\n+//\n+type connectMethod struct {\n+\tproxyURL     *URL   // \"\" for no proxy, else full proxy URL\n+\ttargetScheme string // \"http\" or \"https\"\n+\ttargetAddr   string // Not used if proxy + http targetScheme (4th example in table)\n+}\n+\n+func (ck *connectMethod) String() string {\n+\tproxyStr := \"\"\n+\tif ck.proxyURL != nil {\n+\t\tproxyStr = ck.proxyURL.String()\n+\t}\n+\treturn strings.Join([]string{proxyStr, ck.targetScheme, ck.targetAddr}, \"|\")\n+}\n+\n+// addr returns the first hop \"host:port\" to which we need to TCP connect.\n+func (cm *connectMethod) addr() string {\n+\tif cm.proxyURL != nil {\n+\t\treturn canonicalAddr(cm.proxyURL)\n+\t}\n+\treturn cm.targetAddr\n+}\n+\n+// tlsHost returns the host name to match against the peer's\n+// TLS certificate.\n+func (cm *connectMethod) tlsHost() string {\n+\th := cm.targetAddr\n+\tif hasPort(h) {\n+\t\th = h[:strings.LastIndex(h, \":\")]\n+\t}\n+\treturn h\n+}\n+\n+type readResult struct {\n+\tres *Response // either res or err will be set\n+\terr os.Error\n+}\n+\n+type writeRequest struct {\n+\t// Set by client (in pc.roundTrip)\n+\treq   *Request\n+\tresch chan *readResult\n+\n+\t// Set by writeLoop if an error writing headers.\n+\twriteErr os.Error\n+}\n+\n+// persistConn wraps a connection, usually a persistent one\n+// (but may be used for non-keep-alive requests as well)\n+type persistConn struct {\n+\tt                 *Transport\n+\tcacheKey          string // its connectMethod.String()\n+\tconn              net.Conn\n+\tcc                *ClientConn\n+\tbr                *bufio.Reader\n+\treqch             chan requestAndChan // written by roundTrip(); read by readLoop()\n+\tmutateRequestFunc func(*Request)      // nil or func to modify each outbound request\n+\n+\tlk                   sync.Mutex // guards numExpectedResponses and broken\n+\tnumExpectedResponses int\n+\tbroken               bool // an error has happened on this connection; marked broken so it's not reused.\n+}\n+\n+func (pc *persistConn) isBroken() bool {\n+\tpc.lk.Lock()\n+\tdefer pc.lk.Unlock()\n+\treturn pc.broken\n+}\n+\n+func (pc *persistConn) expectingResponse() bool {\n+\tpc.lk.Lock()\n+\tdefer pc.lk.Unlock()\n+\treturn pc.numExpectedResponses > 0\n+}\n+\n+func (pc *persistConn) readLoop() {\n+\talive := true\n+\tfor alive {\n+\t\tpb, err := pc.br.Peek(1)\n+\t\tif err != nil {\n+\t\t\tif (err == os.EOF || err == os.EINVAL) && !pc.expectingResponse() {\n+\t\t\t\t// Remote side closed on us.  (We probably hit their\n+\t\t\t\t// max idle timeout)\n+\t\t\t\tpc.close()\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t\tif !pc.expectingResponse() {\n+\t\t\tlog.Printf(\"Unsolicited response received on idle HTTP channel starting with %q; err=%v\",\n+\t\t\t\tstring(pb), err)\n+\t\t\tpc.close()\n+\t\t\treturn\n+\t\t}\n+\n+\t\trc := <-pc.reqch\n+\t\tresp, err := pc.cc.Read(rc.req)\n+\t\tif err == nil && !rc.req.Close {\n+\t\t\tpc.t.putIdleConn(pc)\n+\t\t}\n+\t\tif err == ErrPersistEOF {\n+\t\t\t// Succeeded, but we can't send any more\n+\t\t\t// persistent connections on this again.  We\n+\t\t\t// hide this error to upstream callers.\n+\t\t\talive = false\n+\t\t\terr = nil\n+\t\t} else if err != nil {\n+\t\t\talive = false\n+\t\t}\n+\t\trc.ch <- responseAndError{resp, err}\n+\n+\t\t// Wait for the just-returned response body to be fully consumed\n+\t\t// before we race and peek on the underlying bufio reader.\n+\t\tif alive {\n+\t\t\t<-resp.Body.(*bodyEOFSignal).ch\n+\t\t}\n+\t}\n+}\n+\n+type responseAndError struct {\n+\tres *Response\n+\terr os.Error\n+}\n+\n+type requestAndChan struct {\n+\treq *Request\n+\tch  chan responseAndError\n+}\n+\n+func (pc *persistConn) roundTrip(req *Request) (resp *Response, err os.Error) {\n+\tif pc.mutateRequestFunc != nil {\n+\t\tpc.mutateRequestFunc(req)\n \t}\n \n-\treader := bufio.NewReader(conn)\n-\tresp, err = ReadResponse(reader, req.Method)\n+\tpc.lk.Lock()\n+\tpc.numExpectedResponses++\n+\tpc.lk.Unlock()\n+\n+\terr = pc.cc.Write(req)\n \tif err != nil {\n-\t\tconn.Close()\n-\t\treturn nil, err\n+\t\tpc.close()\n+\t\treturn\n \t}\n \n-\tresp.Body = readClose{resp.Body, conn}\n+\tch := make(chan responseAndError, 1)\n+\tpc.reqch <- requestAndChan{req, ch}\n+\tre := <-ch\n+\tpc.lk.Lock()\n+\tpc.numExpectedResponses--\n+\tpc.lk.Unlock()\n+\treturn re.res, re.err\n+}\n+\n+func (pc *persistConn) close() {\n+\tpc.lk.Lock()\n+\tdefer pc.lk.Unlock()\n+\tpc.broken = true\n+\tpc.cc.Close()\n+\tpc.conn.Close()\n+\tpc.mutateRequestFunc = nil\n+}\n+\n+var portMap = map[string]string{\n+\t\"http\":  \"80\",\n+\t\"https\": \"443\",\n+}\n+\n+// canonicalAddr returns url.Host but always with a \":port\" suffix\n+func canonicalAddr(url *URL) string {\n+\taddr := url.Host\n+\tif !hasPort(addr) {\n+\t\treturn addr + \":\" + portMap[url.Scheme]\n+\t}\n+\treturn addr\n+}\n+\n+func responseIsKeepAlive(res *Response) bool {\n+\t// TODO: implement.  for now just always shutting down the connection.\n+\treturn false\n+}\n+\n+// readResponseWithEOFSignal is a wrapper around ReadResponse that replaces\n+// the response body with a bodyEOFSignal-wrapped version.\n+func readResponseWithEOFSignal(r *bufio.Reader, requestMethod string) (resp *Response, err os.Error) {\n+\tresp, err = ReadResponse(r, requestMethod)\n+\tif err == nil {\n+\t\tresp.Body = &bodyEOFSignal{resp.Body, make(chan bool, 1), false}\n+\t}\n+\treturn\n+}\n+\n+// bodyEOFSignal wraps a ReadCloser but sends on ch once once\n+// the wrapped ReadCloser is fully consumed (including on Close)\n+type bodyEOFSignal struct {\n+\tbody io.ReadCloser\n+\tch   chan bool\n+\tdone bool\n+}\n+\n+func (es *bodyEOFSignal) Read(p []byte) (n int, err os.Error) {\n+\tn, err = es.body.Read(p)\n+\tif err == os.EOF && !es.done {\n+\t\tes.ch <- true\n+\t\tes.done = true\n+\t}\n+\treturn\n+}\n+\n+func (es *bodyEOFSignal) Close() (err os.Error) {\n+\terr = es.body.Close()\n+\tif err == nil && !es.done {\n+\t\tes.ch <- true\n+\t\tes.done = true\n+\t}\n \treturn\n }"}, {"sha": "5c3e1cdb582a92d0a2b11c2719e710646e1f7ba1", "filename": "libgo/go/http/transport_test.go", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fhttp%2Ftransport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhttp%2Ftransport_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,235 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Tests for transport.go\n+\n+package http_test\n+\n+import (\n+\t\"fmt\"\n+\t. \"http\"\n+\t\"http/httptest\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+\t\"time\"\n+)\n+\n+// TODO: test 5 pipelined requests with responses: 1) OK, 2) OK, Connection: Close\n+//       and then verify that the final 2 responses get errors back.\n+\n+// hostPortHandler writes back the client's \"host:port\".\n+var hostPortHandler = HandlerFunc(func(w ResponseWriter, r *Request) {\n+\tif r.FormValue(\"close\") == \"true\" {\n+\t\tw.Header().Set(\"Connection\", \"close\")\n+\t}\n+\tfmt.Fprintf(w, \"%s\", r.RemoteAddr)\n+})\n+\n+// Two subsequent requests and verify their response is the same.\n+// The response from the server is our own IP:port\n+func TestTransportKeepAlives(t *testing.T) {\n+\tts := httptest.NewServer(hostPortHandler)\n+\tdefer ts.Close()\n+\n+\tfor _, disableKeepAlive := range []bool{false, true} {\n+\t\ttr := &Transport{DisableKeepAlives: disableKeepAlive}\n+\t\tc := &Client{Transport: tr}\n+\n+\t\tfetch := func(n int) string {\n+\t\t\tres, _, err := c.Get(ts.URL)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in disableKeepAlive=%v, req #%d, GET: %v\", disableKeepAlive, n, err)\n+\t\t\t}\n+\t\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in disableKeepAlive=%v, req #%d, ReadAll: %v\", disableKeepAlive, n, err)\n+\t\t\t}\n+\t\t\treturn string(body)\n+\t\t}\n+\n+\t\tbody1 := fetch(1)\n+\t\tbody2 := fetch(2)\n+\n+\t\tbodiesDiffer := body1 != body2\n+\t\tif bodiesDiffer != disableKeepAlive {\n+\t\t\tt.Errorf(\"error in disableKeepAlive=%v. unexpected bodiesDiffer=%v; body1=%q; body2=%q\",\n+\t\t\t\tdisableKeepAlive, bodiesDiffer, body1, body2)\n+\t\t}\n+\t}\n+}\n+\n+func TestTransportConnectionCloseOnResponse(t *testing.T) {\n+\tts := httptest.NewServer(hostPortHandler)\n+\tdefer ts.Close()\n+\n+\tfor _, connectionClose := range []bool{false, true} {\n+\t\ttr := &Transport{}\n+\t\tc := &Client{Transport: tr}\n+\n+\t\tfetch := func(n int) string {\n+\t\t\treq := new(Request)\n+\t\t\tvar err os.Error\n+\t\t\treq.URL, err = ParseURL(ts.URL + fmt.Sprintf(\"?close=%v\", connectionClose))\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"URL parse error: %v\", err)\n+\t\t\t}\n+\t\t\treq.Method = \"GET\"\n+\t\t\treq.Proto = \"HTTP/1.1\"\n+\t\t\treq.ProtoMajor = 1\n+\t\t\treq.ProtoMinor = 1\n+\n+\t\t\tres, err := c.Do(req)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, Do: %v\", connectionClose, n, err)\n+\t\t\t}\n+\t\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, ReadAll: %v\", connectionClose, n, err)\n+\t\t\t}\n+\t\t\treturn string(body)\n+\t\t}\n+\n+\t\tbody1 := fetch(1)\n+\t\tbody2 := fetch(2)\n+\t\tbodiesDiffer := body1 != body2\n+\t\tif bodiesDiffer != connectionClose {\n+\t\t\tt.Errorf(\"error in connectionClose=%v. unexpected bodiesDiffer=%v; body1=%q; body2=%q\",\n+\t\t\t\tconnectionClose, bodiesDiffer, body1, body2)\n+\t\t}\n+\t}\n+}\n+\n+func TestTransportConnectionCloseOnRequest(t *testing.T) {\n+\tts := httptest.NewServer(hostPortHandler)\n+\tdefer ts.Close()\n+\n+\tfor _, connectionClose := range []bool{false, true} {\n+\t\ttr := &Transport{}\n+\t\tc := &Client{Transport: tr}\n+\n+\t\tfetch := func(n int) string {\n+\t\t\treq := new(Request)\n+\t\t\tvar err os.Error\n+\t\t\treq.URL, err = ParseURL(ts.URL)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"URL parse error: %v\", err)\n+\t\t\t}\n+\t\t\treq.Method = \"GET\"\n+\t\t\treq.Proto = \"HTTP/1.1\"\n+\t\t\treq.ProtoMajor = 1\n+\t\t\treq.ProtoMinor = 1\n+\t\t\treq.Close = connectionClose\n+\n+\t\t\tres, err := c.Do(req)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, Do: %v\", connectionClose, n, err)\n+\t\t\t}\n+\t\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"error in connectionClose=%v, req #%d, ReadAll: %v\", connectionClose, n, err)\n+\t\t\t}\n+\t\t\treturn string(body)\n+\t\t}\n+\n+\t\tbody1 := fetch(1)\n+\t\tbody2 := fetch(2)\n+\t\tbodiesDiffer := body1 != body2\n+\t\tif bodiesDiffer != connectionClose {\n+\t\t\tt.Errorf(\"error in connectionClose=%v. unexpected bodiesDiffer=%v; body1=%q; body2=%q\",\n+\t\t\t\tconnectionClose, bodiesDiffer, body1, body2)\n+\t\t}\n+\t}\n+}\n+\n+func TestTransportIdleCacheKeys(t *testing.T) {\n+\tts := httptest.NewServer(hostPortHandler)\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{DisableKeepAlives: false}\n+\tc := &Client{Transport: tr}\n+\n+\tif e, g := 0, len(tr.IdleConnKeysForTesting()); e != g {\n+\t\tt.Errorf(\"After CloseIdleConnections expected %d idle conn cache keys; got %d\", e, g)\n+\t}\n+\n+\tif _, _, err := c.Get(ts.URL); err != nil {\n+\t\tt.Error(err)\n+\t}\n+\n+\tkeys := tr.IdleConnKeysForTesting()\n+\tif e, g := 1, len(keys); e != g {\n+\t\tt.Fatalf(\"After Get expected %d idle conn cache keys; got %d\", e, g)\n+\t}\n+\n+\tif e := \"|http|\" + ts.Listener.Addr().String(); keys[0] != e {\n+\t\tt.Logf(\"Expected idle cache key %q; got %q\", e, keys[0])\n+\t}\n+\n+\ttr.CloseIdleConnections()\n+\tif e, g := 0, len(tr.IdleConnKeysForTesting()); e != g {\n+\t\tt.Errorf(\"After CloseIdleConnections expected %d idle conn cache keys; got %d\", e, g)\n+\t}\n+}\n+\n+func TestTransportServerClosingUnexpectedly(t *testing.T) {\n+\tts := httptest.NewServer(hostPortHandler)\n+\tdefer ts.Close()\n+\n+\ttr := &Transport{}\n+\tc := &Client{Transport: tr}\n+\n+\tfetch := func(n int) string {\n+\t\tres, _, err := c.Get(ts.URL)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error in req #%d, GET: %v\", n, err)\n+\t\t}\n+\t\tbody, err := ioutil.ReadAll(res.Body)\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"error in req #%d, ReadAll: %v\", n, err)\n+\t\t}\n+\t\tres.Body.Close()\n+\t\treturn string(body)\n+\t}\n+\n+\tbody1 := fetch(1)\n+\tbody2 := fetch(2)\n+\n+\tts.CloseClientConnections() // surprise!\n+\ttime.Sleep(25e6)            // idle for a bit (test is inherently racey, but expectedly)\n+\n+\tbody3 := fetch(3)\n+\n+\tif body1 != body2 {\n+\t\tt.Errorf(\"expected body1 and body2 to be equal\")\n+\t}\n+\tif body2 == body3 {\n+\t\tt.Errorf(\"expected body2 and body3 to be different\")\n+\t}\n+}\n+\n+func TestTransportNilURL(t *testing.T) {\n+\tts := httptest.NewServer(HandlerFunc(func(w ResponseWriter, r *Request) {\n+\t\tfmt.Fprintf(w, \"Hi\")\n+\t}))\n+\tdefer ts.Close()\n+\n+\treq := new(Request)\n+\treq.URL = nil // what we're actually testing\n+\treq.Method = \"GET\"\n+\treq.RawURL = ts.URL\n+\treq.Proto = \"HTTP/1.1\"\n+\treq.ProtoMajor = 1\n+\treq.ProtoMinor = 1\n+\n+\ttr := &Transport{}\n+\tres, err := tr.RoundTrip(req)\n+\tif err != nil {\n+\t\tt.Fatalf(\"unexpected RoundTrip error: %v\", err)\n+\t}\n+\tbody, err := ioutil.ReadAll(res.Body)\n+\tif g, e := string(body), \"Hi\"; g != e {\n+\t\tt.Fatalf(\"Expected response body of %q; got %q\", e, g)\n+\t}\n+}"}, {"sha": "ed6c310eb44c7e57e633b670cfcc428d876844d9", "filename": "libgo/go/io/ioutil/ioutil.go", "status": "modified", "additions": 26, "deletions": 12, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Fioutil.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -13,11 +13,17 @@ import (\n \t\"sort\"\n )\n \n+// readAll reads from r until an error or EOF and returns the data it read\n+// from the internal buffer allocated with a specified capacity.\n+func readAll(r io.Reader, capacity int64) ([]byte, os.Error) {\n+\tbuf := bytes.NewBuffer(make([]byte, 0, capacity))\n+\t_, err := buf.ReadFrom(r)\n+\treturn buf.Bytes(), err\n+}\n+\n // ReadAll reads from r until an error or EOF and returns the data it read.\n func ReadAll(r io.Reader) ([]byte, os.Error) {\n-\tvar buf bytes.Buffer\n-\t_, err := io.Copy(&buf, r)\n-\treturn buf.Bytes(), err\n+\treturn readAll(r, bytes.MinRead)\n }\n \n // ReadFile reads the file named by filename and returns the contents.\n@@ -34,16 +40,12 @@ func ReadFile(filename string) ([]byte, os.Error) {\n \tif err == nil && fi.Size < 2e9 { // Don't preallocate a huge buffer, just in case.\n \t\tn = fi.Size\n \t}\n-\t// Add a little extra in case Size is zero, and to avoid another allocation after\n-\t// Read has filled the buffer.\n-\tn += bytes.MinRead\n-\t// Pre-allocate the correct size of buffer, then set its size to zero.  The\n-\t// Buffer will read into the allocated space cheaply.  If the size was wrong,\n-\t// we'll either waste some space off the end or reallocate as needed, but\n+\t// As initial capacity for readAll, use n + a little extra in case Size is zero,\n+\t// and to avoid another allocation after Read has filled the buffer.  The readAll\n+\t// call will read into its allocated internal buffer cheaply.  If the size was\n+\t// wrong, we'll either waste some space off the end or reallocate as needed, but\n \t// in the overwhelmingly common case we'll get it just right.\n-\tbuf := bytes.NewBuffer(make([]byte, 0, n))\n-\t_, err = buf.ReadFrom(f)\n-\treturn buf.Bytes(), err\n+\treturn readAll(f, n+bytes.MinRead)\n }\n \n // WriteFile writes data to a file named by filename.\n@@ -88,3 +90,15 @@ func ReadDir(dirname string) ([]*os.FileInfo, os.Error) {\n \tsort.Sort(fi)\n \treturn fi, nil\n }\n+\n+type nopCloser struct {\n+\tio.Reader\n+}\n+\n+func (nopCloser) Close() os.Error { return nil }\n+\n+// NopCloser returns a ReadCloser with a no-op Close method wrapping\n+// the provided Reader r.\n+func NopCloser(r io.Reader) io.ReadCloser {\n+\treturn nopCloser{r}\n+}"}, {"sha": "62f8849c0a0b74c964fe59a513c16fac3107293c", "filename": "libgo/go/io/ioutil/tempfile.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,6 +6,7 @@ package ioutil\n \n import (\n \t\"os\"\n+\t\"path/filepath\"\n \t\"strconv\"\n )\n \n@@ -46,8 +47,7 @@ func TempFile(dir, prefix string) (f *os.File, err os.Error) {\n \n \tnconflict := 0\n \tfor i := 0; i < 10000; i++ {\n-\t\t// TODO(rsc): use filepath.Join\n-\t\tname := dir + \"/\" + prefix + nextSuffix()\n+\t\tname := filepath.Join(dir, prefix+nextSuffix())\n \t\tf, err = os.Open(name, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0600)\n \t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n \t\t\tif nconflict++; nconflict > 10 {\n@@ -74,8 +74,7 @@ func TempDir(dir, prefix string) (name string, err os.Error) {\n \n \tnconflict := 0\n \tfor i := 0; i < 10000; i++ {\n-\t\t// TODO(rsc): use filepath.Join\n-\t\ttry := dir + \"/\" + prefix + nextSuffix()\n+\t\ttry := filepath.Join(dir, prefix+nextSuffix())\n \t\terr = os.Mkdir(try, 0700)\n \t\tif pe, ok := err.(*os.PathError); ok && pe.Error == os.EEXIST {\n \t\t\tif nconflict++; nconflict > 10 {"}, {"sha": "80c62f672c1bd7f9380719700f97afc4ca2bef91", "filename": "libgo/go/io/ioutil/tempfile_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fioutil%2Ftempfile_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,6 +7,7 @@ package ioutil_test\n import (\n \t. \"io/ioutil\"\n \t\"os\"\n+\t\"path/filepath\"\n \t\"regexp\"\n \t\"testing\"\n )\n@@ -25,7 +26,7 @@ func TestTempFile(t *testing.T) {\n \tif f != nil {\n \t\tf.Close()\n \t\tos.Remove(f.Name())\n-\t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(dir) + \"/ioutil_test[0-9]+$\")\n+\t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(filepath.Join(dir, \"ioutil_test\")) + \"[0-9]+$\")\n \t\tif !re.MatchString(f.Name()) {\n \t\t\tt.Errorf(\"TempFile(`\"+dir+\"`, `ioutil_test`) created bad name %s\", f.Name())\n \t\t}\n@@ -45,7 +46,7 @@ func TestTempDir(t *testing.T) {\n \t}\n \tif name != \"\" {\n \t\tos.Remove(name)\n-\t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(dir) + \"/ioutil_test[0-9]+$\")\n+\t\tre := regexp.MustCompile(\"^\" + regexp.QuoteMeta(filepath.Join(dir, \"ioutil_test\")) + \"[0-9]+$\")\n \t\tif !re.MatchString(name) {\n \t\t\tt.Errorf(\"TempDir(`\"+dir+\"`, `ioutil_test`) created bad name %s\", name)\n \t\t}"}, {"sha": "00be8efa2e2058908ad29dc0171fc4d5af6f4536", "filename": "libgo/go/io/pipe.go", "status": "modified", "additions": 92, "deletions": 215, "changes": 307, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fpipe.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fio%2Fpipe.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fio%2Fpipe.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,7 +9,6 @@ package io\n \n import (\n \t\"os\"\n-\t\"runtime\"\n \t\"sync\"\n )\n \n@@ -18,208 +17,114 @@ type pipeResult struct {\n \terr os.Error\n }\n \n-// Shared pipe structure.\n+// A pipe is the shared pipe structure underlying PipeReader and PipeWriter.\n type pipe struct {\n-\t// Reader sends on cr1, receives on cr2.\n-\t// Writer does the same on cw1, cw2.\n-\tr1, w1 chan []byte\n-\tr2, w2 chan pipeResult\n-\n-\trclose chan os.Error // read close; error to return to writers\n-\twclose chan os.Error // write close; error to return to readers\n-\n-\tdone chan int // read or write half is done\n-}\n-\n-func (p *pipe) run() {\n-\tvar (\n-\t\trb    []byte      // pending Read\n-\t\twb    []byte      // pending Write\n-\t\twn    int         // amount written so far from wb\n-\t\trerr  os.Error    // if read end is closed, error to send to writers\n-\t\twerr  os.Error    // if write end is closed, error to send to readers\n-\t\tr1    chan []byte // p.cr1 or nil depending on whether Read is ok\n-\t\tw1    chan []byte // p.cw1 or nil depending on whether Write is ok\n-\t\tndone int\n-\t)\n-\n-\t// Read and Write are enabled at the start.\n-\tr1 = p.r1\n-\tw1 = p.w1\n-\n+\trl    sync.Mutex // gates readers one at a time\n+\twl    sync.Mutex // gates writers one at a time\n+\tl     sync.Mutex // protects remaining fields\n+\tdata  []byte     // data remaining in pending write\n+\trwait sync.Cond  // waiting reader\n+\twwait sync.Cond  // waiting writer\n+\trerr  os.Error   // if reader closed, error to give writes\n+\twerr  os.Error   // if writer closed, error to give reads\n+}\n+\n+func (p *pipe) read(b []byte) (n int, err os.Error) {\n+\t// One reader at a time.\n+\tp.rl.Lock()\n+\tdefer p.rl.Unlock()\n+\n+\tp.l.Lock()\n+\tdefer p.l.Unlock()\n \tfor {\n-\t\tselect {\n-\t\tcase <-p.done:\n-\t\t\tif ndone++; ndone == 2 {\n-\t\t\t\t// both reader and writer are gone\n-\t\t\t\t// close out any existing i/o\n-\t\t\t\tif r1 == nil {\n-\t\t\t\t\tp.r2 <- pipeResult{0, os.EINVAL}\n-\t\t\t\t}\n-\t\t\t\tif w1 == nil {\n-\t\t\t\t\tp.w2 <- pipeResult{0, os.EINVAL}\n-\t\t\t\t}\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tcontinue\n-\t\tcase rerr = <-p.rclose:\n-\t\t\tif w1 == nil {\n-\t\t\t\t// finish pending Write\n-\t\t\t\tp.w2 <- pipeResult{wn, rerr}\n-\t\t\t\twn = 0\n-\t\t\t\tw1 = p.w1 // allow another Write\n-\t\t\t}\n-\t\t\tif r1 == nil {\n-\t\t\t\t// Close of read side during Read.\n-\t\t\t\t// finish pending Read with os.EINVAL.\n-\t\t\t\tp.r2 <- pipeResult{0, os.EINVAL}\n-\t\t\t\tr1 = p.r1 // allow another Read\n-\t\t\t}\n-\t\t\tcontinue\n-\t\tcase werr = <-p.wclose:\n-\t\t\tif r1 == nil {\n-\t\t\t\t// finish pending Read\n-\t\t\t\tp.r2 <- pipeResult{0, werr}\n-\t\t\t\tr1 = p.r1 // allow another Read\n-\t\t\t}\n-\t\t\tif w1 == nil {\n-\t\t\t\t// Close of write side during Write.\n-\t\t\t\t// finish pending Write with os.EINVAL.\n-\t\t\t\tp.w2 <- pipeResult{wn, os.EINVAL}\n-\t\t\t\twn = 0\n-\t\t\t\tw1 = p.w1 // allow another Write\n-\t\t\t}\n-\t\t\tcontinue\n-\t\tcase rb = <-r1:\n-\t\t\tif werr != nil {\n-\t\t\t\t// write end is closed\n-\t\t\t\tp.r2 <- pipeResult{0, werr}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif rerr != nil {\n-\t\t\t\t// read end is closed\n-\t\t\t\tp.r2 <- pipeResult{0, os.EINVAL}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tr1 = nil // disable Read until this one is done\n-\t\tcase wb = <-w1:\n-\t\t\tif rerr != nil {\n-\t\t\t\t// read end is closed\n-\t\t\t\tp.w2 <- pipeResult{0, rerr}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif werr != nil {\n-\t\t\t\t// write end is closed\n-\t\t\t\tp.w2 <- pipeResult{0, os.EINVAL}\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tw1 = nil // disable Write until this one is done\n+\t\tif p.rerr != nil {\n+\t\t\treturn 0, os.EINVAL\n \t\t}\n-\n-\t\tif r1 == nil && w1 == nil {\n-\t\t\t// Have rb and wb.  Execute.\n-\t\t\tn := copy(rb, wb)\n-\t\t\twn += n\n-\t\t\twb = wb[n:]\n-\n-\t\t\t// Finish Read.\n-\t\t\tp.r2 <- pipeResult{n, nil}\n-\t\t\tr1 = p.r1 // allow another Read\n-\n-\t\t\t// Maybe finish Write.\n-\t\t\tif len(wb) == 0 {\n-\t\t\t\tp.w2 <- pipeResult{wn, nil}\n-\t\t\t\twn = 0\n-\t\t\t\tw1 = p.w1 // allow another Write\n-\t\t\t}\n+\t\tif p.data != nil {\n+\t\t\tbreak\n \t\t}\n+\t\tif p.werr != nil {\n+\t\t\treturn 0, p.werr\n+\t\t}\n+\t\tp.rwait.Wait()\n+\t}\n+\tn = copy(b, p.data)\n+\tp.data = p.data[n:]\n+\tif len(p.data) == 0 {\n+\t\tp.data = nil\n+\t\tp.wwait.Signal()\n \t}\n+\treturn\n }\n \n-// Read/write halves of the pipe.\n-// They are separate structures for two reasons:\n-//  1.  If one end becomes garbage without being Closed,\n-//      its finalizer can Close so that the other end\n-//      does not hang indefinitely.\n-//  2.  Clients cannot use interface conversions on the\n-//      read end to find the Write method, and vice versa.\n+var zero [0]byte\n \n-type pipeHalf struct {\n-\tc1     chan []byte\n-\tc2     chan pipeResult\n-\tcclose chan os.Error\n-\tdone   chan int\n-\n-\tlock   sync.Mutex\n-\tclosed bool\n+func (p *pipe) write(b []byte) (n int, err os.Error) {\n+\t// pipe uses nil to mean not available\n+\tif b == nil {\n+\t\tb = zero[:]\n+\t}\n \n-\tio       sync.Mutex\n-\tioclosed bool\n-}\n+\t// One writer at a time.\n+\tp.wl.Lock()\n+\tdefer p.wl.Unlock()\n \n-func (p *pipeHalf) rw(data []byte) (n int, err os.Error) {\n-\t// Run i/o operation.\n-\t// Check ioclosed flag under lock to make sure we're still allowed to do i/o.\n-\tp.io.Lock()\n-\tif p.ioclosed {\n-\t\tp.io.Unlock()\n-\t\treturn 0, os.EINVAL\n+\tp.l.Lock()\n+\tdefer p.l.Unlock()\n+\tp.data = b\n+\tp.rwait.Signal()\n+\tfor {\n+\t\tif p.data == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tif p.rerr != nil {\n+\t\t\terr = p.rerr\n+\t\t\tbreak\n+\t\t}\n+\t\tif p.werr != nil {\n+\t\t\terr = os.EINVAL\n+\t\t}\n+\t\tp.wwait.Wait()\n \t}\n-\tp.io.Unlock()\n-\tp.c1 <- data\n-\tres := <-p.c2\n-\treturn res.n, res.err\n+\tn = len(b) - len(p.data)\n+\tp.data = nil // in case of rerr or werr\n+\treturn\n }\n \n-func (p *pipeHalf) close(err os.Error) os.Error {\n-\t// Close pipe half.\n-\t// Only first call to close does anything.\n-\tp.lock.Lock()\n-\tif p.closed {\n-\t\tp.lock.Unlock()\n-\t\treturn os.EINVAL\n+func (p *pipe) rclose(err os.Error) {\n+\tif err == nil {\n+\t\terr = os.EPIPE\n \t}\n-\tp.closed = true\n-\tp.lock.Unlock()\n-\n-\t// First, send the close notification.\n-\tp.cclose <- err\n-\n-\t// Runner is now responding to rw operations\n-\t// with os.EINVAL.  Cut off future rw operations\n-\t// by setting ioclosed flag.\n-\tp.io.Lock()\n-\tp.ioclosed = true\n-\tp.io.Unlock()\n-\n-\t// With ioclosed set, there will be no more rw operations\n-\t// working on the channels.\n-\t// Tell the runner we won't be bothering it anymore.\n-\tp.done <- 1\n-\n-\t// Successfully torn down; can disable finalizer.\n-\truntime.SetFinalizer(p, nil)\n-\n-\treturn nil\n+\tp.l.Lock()\n+\tdefer p.l.Unlock()\n+\tp.rerr = err\n+\tp.rwait.Signal()\n+\tp.wwait.Signal()\n }\n \n-func (p *pipeHalf) finalizer() {\n-\tp.close(os.EINVAL)\n+func (p *pipe) wclose(err os.Error) {\n+\tif err == nil {\n+\t\terr = os.EOF\n+\t}\n+\tp.l.Lock()\n+\tdefer p.l.Unlock()\n+\tp.werr = err\n+\tp.rwait.Signal()\n+\tp.wwait.Signal()\n }\n \n-\n // A PipeReader is the read half of a pipe.\n type PipeReader struct {\n-\tpipeHalf\n+\tp *pipe\n }\n \n // Read implements the standard Read interface:\n // it reads data from the pipe, blocking until a writer\n // arrives or the write end is closed.\n // If the write end is closed with an error, that error is\n-// returned as err; otherwise err is nil.\n+// returned as err; otherwise err is os.EOF.\n func (r *PipeReader) Read(data []byte) (n int, err os.Error) {\n-\treturn r.rw(data)\n+\treturn r.p.read(data)\n }\n \n // Close closes the reader; subsequent writes to the\n@@ -231,15 +136,13 @@ func (r *PipeReader) Close() os.Error {\n // CloseWithError closes the reader; subsequent writes\n // to the write half of the pipe will return the error err.\n func (r *PipeReader) CloseWithError(err os.Error) os.Error {\n-\tif err == nil {\n-\t\terr = os.EPIPE\n-\t}\n-\treturn r.close(err)\n+\tr.p.rclose(err)\n+\treturn nil\n }\n \n // A PipeWriter is the write half of a pipe.\n type PipeWriter struct {\n-\tpipeHalf\n+\tp *pipe\n }\n \n // Write implements the standard Write interface:\n@@ -248,7 +151,7 @@ type PipeWriter struct {\n // If the read end is closed with an error, that err is\n // returned as err; otherwise err is os.EPIPE.\n func (w *PipeWriter) Write(data []byte) (n int, err os.Error) {\n-\treturn w.rw(data)\n+\treturn w.p.write(data)\n }\n \n // Close closes the writer; subsequent reads from the\n@@ -260,10 +163,8 @@ func (w *PipeWriter) Close() os.Error {\n // CloseWithError closes the writer; subsequent reads from the\n // read half of the pipe will return no bytes and the error err.\n func (w *PipeWriter) CloseWithError(err os.Error) os.Error {\n-\tif err == nil {\n-\t\terr = os.EOF\n-\t}\n-\treturn w.close(err)\n+\tw.p.wclose(err)\n+\treturn nil\n }\n \n // Pipe creates a synchronous in-memory pipe.\n@@ -272,34 +173,10 @@ func (w *PipeWriter) CloseWithError(err os.Error) os.Error {\n // Reads on one end are matched with writes on the other,\n // copying data directly between the two; there is no internal buffering.\n func Pipe() (*PipeReader, *PipeWriter) {\n-\tp := &pipe{\n-\t\tr1:     make(chan []byte),\n-\t\tr2:     make(chan pipeResult),\n-\t\tw1:     make(chan []byte),\n-\t\tw2:     make(chan pipeResult),\n-\t\trclose: make(chan os.Error),\n-\t\twclose: make(chan os.Error),\n-\t\tdone:   make(chan int),\n-\t}\n-\tgo p.run()\n-\n-\t// NOTE: Cannot use composite literal here:\n-\t//\tpipeHalf{c1: p.cr1, c2: p.cr2, cclose: p.crclose, cdone: p.cdone}\n-\t// because this implicitly copies the pipeHalf, which copies the inner mutex.\n-\n-\tr := new(PipeReader)\n-\tr.c1 = p.r1\n-\tr.c2 = p.r2\n-\tr.cclose = p.rclose\n-\tr.done = p.done\n-\truntime.SetFinalizer(r, (*PipeReader).finalizer)\n-\n-\tw := new(PipeWriter)\n-\tw.c1 = p.w1\n-\tw.c2 = p.w2\n-\tw.cclose = p.wclose\n-\tw.done = p.done\n-\truntime.SetFinalizer(w, (*PipeWriter).finalizer)\n-\n+\tp := new(pipe)\n+\tp.rwait.L = &p.l\n+\tp.wwait.L = &p.l\n+\tr := &PipeReader{p}\n+\tw := &PipeWriter{p}\n \treturn r, w\n }"}, {"sha": "0a65a447db999ec90527b56b17de7990f960d02e", "filename": "libgo/go/mime/multipart/multipart.go", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -17,6 +17,7 @@ import (\n \t\"bytes\"\n \t\"io\"\n \t\"mime\"\n+\t\"net/textproto\"\n \t\"os\"\n \t\"regexp\"\n \t\"strings\"\n@@ -40,7 +41,7 @@ type Part struct {\n \t// The headers of the body, if any, with the keys canonicalized\n \t// in the same fashion that the Go http.Request headers are.\n \t// i.e. \"foo-bar\" changes case to \"Foo-Bar\"\n-\tHeader map[string]string\n+\tHeader textproto.MIMEHeader\n \n \tbuffer *bytes.Buffer\n \tmr     *multiReader\n@@ -51,8 +52,8 @@ type Part struct {\n func (p *Part) FormName() string {\n \t// See http://tools.ietf.org/html/rfc2183 section 2 for EBNF\n \t// of Content-Disposition value format.\n-\tv, ok := p.Header[\"Content-Disposition\"]\n-\tif !ok {\n+\tv := p.Header.Get(\"Content-Disposition\")\n+\tif v == \"\" {\n \t\treturn \"\"\n \t}\n \td, params := mime.ParseMediaType(v)\n@@ -85,7 +86,7 @@ var devNull = devNullWriter(false)\n \n func newPart(mr *multiReader) (bp *Part, err os.Error) {\n \tbp = new(Part)\n-\tbp.Header = make(map[string]string)\n+\tbp.Header = make(map[string][]string)\n \tbp.mr = mr\n \tbp.buffer = new(bytes.Buffer)\n \tif err = bp.populateHeaders(); err != nil {\n@@ -104,10 +105,7 @@ func (bp *Part) populateHeaders() os.Error {\n \t\t\treturn nil\n \t\t}\n \t\tif matches := headerRegexp.FindStringSubmatch(line); len(matches) == 3 {\n-\t\t\tkey := matches[1]\n-\t\t\tvalue := matches[2]\n-\t\t\t// TODO: canonicalize headers ala http.Request.Header?\n-\t\t\tbp.Header[key] = value\n+\t\t\tbp.Header.Add(matches[1], matches[2])\n \t\t\tcontinue\n \t\t}\n \t\treturn os.NewError(\"Unexpected header line found parsing multipart body\")"}, {"sha": "1f3d32d7ed6e91bd20698e21fac4b8b3a7988ae4", "filename": "libgo/go/mime/multipart/multipart_test.go", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmime%2Fmultipart%2Fmultipart_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -58,7 +58,7 @@ func expectEq(t *testing.T, expected, actual, what string) {\n \n func TestFormName(t *testing.T) {\n \tp := new(Part)\n-\tp.Header = make(map[string]string)\n+\tp.Header = make(map[string][]string)\n \ttests := [...][2]string{\n \t\t{`form-data; name=\"foo\"`, \"foo\"},\n \t\t{` form-data ; name=foo`, \"foo\"},\n@@ -69,7 +69,7 @@ func TestFormName(t *testing.T) {\n \t\t{` FORM-DATA ; filename=\"foo.txt\"; name=foo; baz=quux`, \"foo\"},\n \t}\n \tfor _, test := range tests {\n-\t\tp.Header[\"Content-Disposition\"] = test[0]\n+\t\tp.Header.Set(\"Content-Disposition\", test[0])\n \t\texpected := test[1]\n \t\tactual := p.FormName()\n \t\tif actual != expected {\n@@ -114,12 +114,15 @@ never read data\n \t\tt.Error(\"Expected part1\")\n \t\treturn\n \t}\n-\tif part.Header[\"Header1\"] != \"value1\" {\n+\tif part.Header.Get(\"Header1\") != \"value1\" {\n \t\tt.Error(\"Expected Header1: value\")\n \t}\n-\tif part.Header[\"foo-bar\"] != \"baz\" {\n+\tif part.Header.Get(\"foo-bar\") != \"baz\" {\n \t\tt.Error(\"Expected foo-bar: baz\")\n \t}\n+\tif part.Header.Get(\"Foo-Bar\") != \"baz\" {\n+\t\tt.Error(\"Expected Foo-Bar: baz\")\n+\t}\n \tbuf.Reset()\n \tio.Copy(buf, part)\n \texpectEq(t, \"My value\\r\\nThe end.\",\n@@ -131,7 +134,7 @@ never read data\n \t\tt.Error(\"Expected part2\")\n \t\treturn\n \t}\n-\tif part.Header[\"foo-bar\"] != \"bazb\" {\n+\tif part.Header.Get(\"foo-bar\") != \"bazb\" {\n \t\tt.Error(\"Expected foo-bar: bazb\")\n \t}\n \tbuf.Reset()"}, {"sha": "7acee149e1f760936b6e850ac7c9a2581d2b6f97", "filename": "libgo/go/net/fd.go", "status": "modified", "additions": 34, "deletions": 36, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Ffd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Ffd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// TODO(rsc): All the prints in this file should go to standard error.\n-\n package net\n \n import (\n@@ -85,11 +83,12 @@ func (e *InvalidConnError) Timeout() bool   { return false }\n // will the fd be closed.\n \n type pollServer struct {\n-\tcr, cw   chan *netFD // buffered >= 1\n-\tpr, pw   *os.File\n-\tpending  map[int]*netFD\n-\tpoll     *pollster // low-level OS hooks\n-\tdeadline int64     // next deadline (nsec since 1970)\n+\tcr, cw     chan *netFD // buffered >= 1\n+\tpr, pw     *os.File\n+\tpoll       *pollster // low-level OS hooks\n+\tsync.Mutex           // controls pending and deadline\n+\tpending    map[int]*netFD\n+\tdeadline   int64 // next deadline (nsec since 1970)\n }\n \n func (s *pollServer) AddFD(fd *netFD, mode int) {\n@@ -103,10 +102,8 @@ func (s *pollServer) AddFD(fd *netFD, mode int) {\n \t\t}\n \t\treturn\n \t}\n-\tif err := s.poll.AddFD(intfd, mode, false); err != nil {\n-\t\tpanic(\"pollServer AddFD \" + err.String())\n-\t\treturn\n-\t}\n+\n+\ts.Lock()\n \n \tvar t int64\n \tkey := intfd << 1\n@@ -119,11 +116,27 @@ func (s *pollServer) AddFD(fd *netFD, mode int) {\n \t\tt = fd.wdeadline\n \t}\n \ts.pending[key] = fd\n+\tdoWakeup := false\n \tif t > 0 && (s.deadline == 0 || t < s.deadline) {\n \t\ts.deadline = t\n+\t\tdoWakeup = true\n+\t}\n+\n+\tif err := s.poll.AddFD(intfd, mode, false); err != nil {\n+\t\tpanic(\"pollServer AddFD \" + err.String())\n+\t}\n+\n+\ts.Unlock()\n+\n+\tif doWakeup {\n+\t\ts.Wakeup()\n \t}\n }\n \n+var wakeupbuf [1]byte\n+\n+func (s *pollServer) Wakeup() { s.pw.Write(wakeupbuf[0:]) }\n+\n func (s *pollServer) LookupFD(fd int, mode int) *netFD {\n \tkey := fd << 1\n \tif mode == 'w' {\n@@ -195,6 +208,8 @@ func (s *pollServer) CheckDeadlines() {\n \n func (s *pollServer) Run() {\n \tvar scratch [100]byte\n+\ts.Lock()\n+\tdefer s.Unlock()\n \tfor {\n \t\tvar t = s.deadline\n \t\tif t > 0 {\n@@ -204,7 +219,7 @@ func (s *pollServer) Run() {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t}\n-\t\tfd, mode, err := s.poll.WaitFD(t)\n+\t\tfd, mode, err := s.poll.WaitFD(s, t)\n \t\tif err != nil {\n \t\t\tprint(\"pollServer WaitFD: \", err.String(), \"\\n\")\n \t\t\treturn\n@@ -215,22 +230,11 @@ func (s *pollServer) Run() {\n \t\t\tcontinue\n \t\t}\n \t\tif fd == s.pr.Fd() {\n-\t\t\t// Drain our wakeup pipe.\n-\t\t\tfor nn, _ := s.pr.Read(scratch[0:]); nn > 0; {\n-\t\t\t\tnn, _ = s.pr.Read(scratch[0:])\n-\t\t\t}\n-\t\t\t// Read from channels\n-\t\tUpdate:\n-\t\t\tfor {\n-\t\t\t\tselect {\n-\t\t\t\tcase fd := <-s.cr:\n-\t\t\t\t\ts.AddFD(fd, 'r')\n-\t\t\t\tcase fd := <-s.cw:\n-\t\t\t\t\ts.AddFD(fd, 'w')\n-\t\t\t\tdefault:\n-\t\t\t\t\tbreak Update\n-\t\t\t\t}\n-\t\t\t}\n+\t\t\t// Drain our wakeup pipe (we could loop here,\n+\t\t\t// but it's unlikely that there are more than\n+\t\t\t// len(scratch) wakeup calls).\n+\t\t\ts.pr.Read(scratch[0:])\n+\t\t\ts.CheckDeadlines()\n \t\t} else {\n \t\t\tnetfd := s.LookupFD(fd, mode)\n \t\t\tif netfd == nil {\n@@ -242,19 +246,13 @@ func (s *pollServer) Run() {\n \t}\n }\n \n-var wakeupbuf [1]byte\n-\n-func (s *pollServer) Wakeup() { s.pw.Write(wakeupbuf[0:]) }\n-\n func (s *pollServer) WaitRead(fd *netFD) {\n-\ts.cr <- fd\n-\ts.Wakeup()\n+\ts.AddFD(fd, 'r')\n \t<-fd.cr\n }\n \n func (s *pollServer) WaitWrite(fd *netFD) {\n-\ts.cw <- fd\n-\ts.Wakeup()\n+\ts.AddFD(fd, 'w')\n \t<-fd.cw\n }\n "}, {"sha": "69fbc02c0c100a775919d4afa99853622d2c0a34", "filename": "libgo/go/net/fd_linux.go", "status": "modified", "additions": 52, "deletions": 30, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Ffd_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Ffd_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffd_linux.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -20,7 +20,17 @@ type pollster struct {\n \tepfd int\n \n \t// Events we're already waiting for\n+\t// Must hold pollServer lock\n \tevents map[int]uint32\n+\n+\t// An event buffer for EpollWait.\n+\t// Used without a lock, may only be used by WaitFD.\n+\twaitEventBuf [10]syscall.EpollEvent\n+\twaitEvents   []syscall.EpollEvent\n+\n+\t// An event buffer for EpollCtl, to avoid a malloc.\n+\t// Must hold pollServer lock.\n+\tctlEvent syscall.EpollEvent\n }\n \n func newpollster() (p *pollster, err os.Error) {\n@@ -29,7 +39,7 @@ func newpollster() (p *pollster, err os.Error) {\n \n \t// The arg to epoll_create is a hint to the kernel\n \t// about the number of FDs we will care about.\n-\t// We don't know.\n+\t// We don't know, and since 2.6.8 the kernel ignores it anyhow.\n \tif p.epfd, e = syscall.EpollCreate(16); e != 0 {\n \t\treturn nil, os.NewSyscallError(\"epoll_create\", e)\n \t}\n@@ -38,17 +48,18 @@ func newpollster() (p *pollster, err os.Error) {\n }\n \n func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {\n-\tvar ev syscall.EpollEvent\n+\t// pollServer is locked.\n+\n \tvar already bool\n-\tev.Fd = int32(fd)\n-\tev.Events, already = p.events[fd]\n+\tp.ctlEvent.Fd = int32(fd)\n+\tp.ctlEvent.Events, already = p.events[fd]\n \tif !repeat {\n-\t\tev.Events |= syscall.EPOLLONESHOT\n+\t\tp.ctlEvent.Events |= syscall.EPOLLONESHOT\n \t}\n \tif mode == 'r' {\n-\t\tev.Events |= readFlags\n+\t\tp.ctlEvent.Events |= readFlags\n \t} else {\n-\t\tev.Events |= writeFlags\n+\t\tp.ctlEvent.Events |= writeFlags\n \t}\n \n \tvar op int\n@@ -57,14 +68,16 @@ func (p *pollster) AddFD(fd int, mode int, repeat bool) os.Error {\n \t} else {\n \t\top = syscall.EPOLL_CTL_ADD\n \t}\n-\tif e := syscall.EpollCtl(p.epfd, op, fd, &ev); e != 0 {\n+\tif e := syscall.EpollCtl(p.epfd, op, fd, &p.ctlEvent); e != 0 {\n \t\treturn os.NewSyscallError(\"epoll_ctl\", e)\n \t}\n-\tp.events[fd] = ev.Events\n+\tp.events[fd] = p.ctlEvent.Events\n \treturn nil\n }\n \n func (p *pollster) StopWaiting(fd int, bits uint) {\n+\t// pollServer is locked.\n+\n \tevents, already := p.events[fd]\n \tif !already {\n \t\tprint(\"Epoll unexpected fd=\", fd, \"\\n\")\n@@ -82,10 +95,9 @@ func (p *pollster) StopWaiting(fd int, bits uint) {\n \t// event in the kernel.  Otherwise, delete it.\n \tevents &= ^uint32(bits)\n \tif int32(events)&^syscall.EPOLLONESHOT != 0 {\n-\t\tvar ev syscall.EpollEvent\n-\t\tev.Fd = int32(fd)\n-\t\tev.Events = events\n-\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &ev); e != 0 {\n+\t\tp.ctlEvent.Fd = int32(fd)\n+\t\tp.ctlEvent.Events = events\n+\t\tif e := syscall.EpollCtl(p.epfd, syscall.EPOLL_CTL_MOD, fd, &p.ctlEvent); e != 0 {\n \t\t\tprint(\"Epoll modify fd=\", fd, \": \", os.Errno(e).String(), \"\\n\")\n \t\t}\n \t\tp.events[fd] = events\n@@ -98,31 +110,41 @@ func (p *pollster) StopWaiting(fd int, bits uint) {\n }\n \n func (p *pollster) DelFD(fd int, mode int) {\n+\t// pollServer is locked.\n+\n \tif mode == 'r' {\n \t\tp.StopWaiting(fd, readFlags)\n \t} else {\n \t\tp.StopWaiting(fd, writeFlags)\n \t}\n }\n \n-func (p *pollster) WaitFD(nsec int64) (fd int, mode int, err os.Error) {\n-\t// Get an event.\n-\tvar evarray [1]syscall.EpollEvent\n-\tev := &evarray[0]\n-\tvar msec int = -1\n-\tif nsec > 0 {\n-\t\tmsec = int((nsec + 1e6 - 1) / 1e6)\n-\t}\n-\tn, e := syscall.EpollWait(p.epfd, evarray[0:], msec)\n-\tfor e == syscall.EAGAIN || e == syscall.EINTR {\n-\t\tn, e = syscall.EpollWait(p.epfd, evarray[0:], msec)\n-\t}\n-\tif e != 0 {\n-\t\treturn -1, 0, os.NewSyscallError(\"epoll_wait\", e)\n-\t}\n-\tif n == 0 {\n-\t\treturn -1, 0, nil\n+func (p *pollster) WaitFD(s *pollServer, nsec int64) (fd int, mode int, err os.Error) {\n+\tfor len(p.waitEvents) == 0 {\n+\t\tvar msec int = -1\n+\t\tif nsec > 0 {\n+\t\t\tmsec = int((nsec + 1e6 - 1) / 1e6)\n+\t\t}\n+\n+\t\ts.Unlock()\n+\t\tn, e := syscall.EpollWait(p.epfd, p.waitEventBuf[0:], msec)\n+\t\ts.Lock()\n+\n+\t\tif e != 0 {\n+\t\t\tif e == syscall.EAGAIN || e == syscall.EINTR {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\treturn -1, 0, os.NewSyscallError(\"epoll_wait\", e)\n+\t\t}\n+\t\tif n == 0 {\n+\t\t\treturn -1, 0, nil\n+\t\t}\n+\t\tp.waitEvents = p.waitEventBuf[0:n]\n \t}\n+\n+\tev := &p.waitEvents[0]\n+\tp.waitEvents = p.waitEvents[1:]\n+\n \tfd = int(ev.Fd)\n \n \tif ev.Events&writeFlags != 0 {"}, {"sha": "1904af0d6ad784556a8f2cdd1594a1dea532adcf", "filename": "libgo/go/net/ip.go", "status": "modified", "additions": 101, "deletions": 8, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Fip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnet%2Fip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fip.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,6 +12,8 @@\n \n package net\n \n+import \"os\"\n+\n // IP address lengths (bytes).\n const (\n \tIPv4len = 4\n@@ -39,18 +41,16 @@ type IPMask []byte\n // IPv4 address a.b.c.d.\n func IPv4(a, b, c, d byte) IP {\n \tp := make(IP, IPv6len)\n-\tfor i := 0; i < 10; i++ {\n-\t\tp[i] = 0\n-\t}\n-\tp[10] = 0xff\n-\tp[11] = 0xff\n+\tcopy(p, v4InV6Prefix)\n \tp[12] = a\n \tp[13] = b\n \tp[14] = c\n \tp[15] = d\n \treturn p\n }\n \n+var v4InV6Prefix = []byte{0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff}\n+\n // IPv4Mask returns the IP mask (in 16-byte form) of the\n // IPv4 mask a.b.c.d.\n func IPv4Mask(a, b, c, d byte) IPMask {\n@@ -140,9 +140,24 @@ func (ip IP) DefaultMask() IPMask {\n \treturn nil // not reached\n }\n \n+func allFF(b []byte) bool {\n+\tfor _, c := range b {\n+\t\tif c != 0xff {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // Mask returns the result of masking the IP address ip with mask.\n func (ip IP) Mask(mask IPMask) IP {\n \tn := len(ip)\n+\tif len(mask) == 16 && len(ip) == 4 && allFF(mask[:12]) {\n+\t\tmask = mask[12:]\n+\t}\n+\tif len(mask) == 4 && len(ip) == 16 && bytesEqual(ip[:12], v4InV6Prefix) {\n+\t\tip = ip[12:]\n+\t}\n \tif n != len(mask) {\n \t\treturn nil\n \t}\n@@ -245,6 +260,34 @@ func (ip IP) String() string {\n \treturn s\n }\n \n+// Equal returns true if ip and x are the same IP address.\n+// An IPv4 address and that same address in IPv6 form are\n+// considered to be equal.\n+func (ip IP) Equal(x IP) bool {\n+\tif len(ip) == len(x) {\n+\t\treturn bytesEqual(ip, x)\n+\t}\n+\tif len(ip) == 4 && len(x) == 16 {\n+\t\treturn bytesEqual(x[0:12], v4InV6Prefix) && bytesEqual(ip, x[12:])\n+\t}\n+\tif len(ip) == 16 && len(x) == 4 {\n+\t\treturn bytesEqual(ip[0:12], v4InV6Prefix) && bytesEqual(ip[12:], x)\n+\t}\n+\treturn false\n+}\n+\n+func bytesEqual(x, y []byte) bool {\n+\tif len(x) != len(y) {\n+\t\treturn false\n+\t}\n+\tfor i, b := range x {\n+\t\tif y[i] != b {\n+\t\t\treturn false\n+\t\t}\n+\t}\n+\treturn true\n+}\n+\n // If mask is a sequence of 1 bits followed by 0 bits,\n // return the number of 1 bits.\n func simpleMaskLength(mask IPMask) int {\n@@ -351,7 +394,6 @@ func parseIPv6(s string) IP {\n \n \t// Loop, parsing hex numbers followed by colon.\n \tj := 0\n-L:\n \tfor j < IPv6len {\n \t\t// Hex number.\n \t\tn, i1, ok := xtoi(s, i)\n@@ -432,15 +474,66 @@ L:\n \treturn p\n }\n \n+// A SyntaxError represents a malformed text string and the type of string that was expected.\n+type SyntaxError struct {\n+\tType string\n+\tText string\n+}\n+\n+func (e *SyntaxError) String() string {\n+\treturn \"invalid \" + e.Type + \": \" + e.Text\n+}\n+\n+func parseIP(s string) IP {\n+\tif p := parseIPv4(s); p != nil {\n+\t\treturn p\n+\t}\n+\tif p := parseIPv6(s); p != nil {\n+\t\treturn p\n+\t}\n+\treturn nil\n+}\n+\n // ParseIP parses s as an IP address, returning the result.\n // The string s can be in dotted decimal (\"74.125.19.99\")\n // or IPv6 (\"2001:4860:0:2001::68\") form.\n // If s is not a valid textual representation of an IP address,\n // ParseIP returns nil.\n func ParseIP(s string) IP {\n-\tp := parseIPv4(s)\n-\tif p != nil {\n+\tif p := parseIPv4(s); p != nil {\n \t\treturn p\n \t}\n \treturn parseIPv6(s)\n }\n+\n+// ParseCIDR parses s as a CIDR notation IP address and mask,\n+// like \"192.168.100.1/24\" or \"2001:DB8::/48\".\n+func ParseCIDR(s string) (ip IP, mask IPMask, err os.Error) {\n+\ti := byteIndex(s, '/')\n+\tif i < 0 {\n+\t\treturn nil, nil, &SyntaxError{\"CIDR address\", s}\n+\t}\n+\tipstr, maskstr := s[:i], s[i+1:]\n+\tip = ParseIP(ipstr)\n+\tnn, i, ok := dtoi(maskstr, 0)\n+\tif ip == nil || !ok || i != len(maskstr) || nn < 0 || nn > 8*len(ip) {\n+\t\treturn nil, nil, &SyntaxError{\"CIDR address\", s}\n+\t}\n+\tn := uint(nn)\n+\tif len(ip) == 4 {\n+\t\tv4mask := ^uint32(0xffffffff >> n)\n+\t\tmask = IPMask(IPv4(byte(v4mask>>24), byte(v4mask>>16), byte(v4mask>>8), byte(v4mask)))\n+\t\treturn ip, mask, nil\n+\t}\n+\tmask = make(IPMask, 16)\n+\tfor i := 0; i < 16; i++ {\n+\t\tif n >= 8 {\n+\t\t\tmask[i] = 0xff\n+\t\t\tn -= 8\n+\t\t\tcontinue\n+\t\t}\n+\t\tmask[i] = ^byte(0xff >> n)\n+\t\tn = 0\n+\t}\n+\treturn ip, mask, nil\n+}"}, {"sha": "d2cd8efc559753cbc4190e6ee73a07dd4f89022f", "filename": "libgo/go/netchan/common.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fcommon.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -306,7 +306,7 @@ func (nch *netChan) sender() {\n }\n \n // Receive value from local side for sending to remote side.\n-func (nch *netChan) recv() (val reflect.Value, closed bool) {\n+func (nch *netChan) recv() (val reflect.Value, ok bool) {\n \tif nch.dir != Send {\n \t\tpanic(\"recv on wrong direction of channel\")\n \t}\n@@ -317,7 +317,7 @@ func (nch *netChan) recv() (val reflect.Value, closed bool) {\n \t\tnch.space++\n \t}\n \tnch.space--\n-\treturn nch.ch.Recv(), nch.ch.Closed()\n+\treturn nch.ch.Recv()\n }\n \n // acked is called when the remote side indicates that"}, {"sha": "e91e777e306ee1ac58435ce3d8f6e73940fad5b9", "filename": "libgo/go/netchan/export.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fexport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fexport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fexport.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -181,8 +181,8 @@ func (client *expClient) run() {\n // The header is passed by value to avoid issues of overwriting.\n func (client *expClient) serveRecv(nch *netChan, hdr header, count int64) {\n \tfor {\n-\t\tval, closed := nch.recv()\n-\t\tif closed {\n+\t\tval, ok := nch.recv()\n+\t\tif !ok {\n \t\t\tif err := client.encode(&hdr, payClosed, nil); err != nil {\n \t\t\t\texpLog(\"error encoding server closed message:\", err)\n \t\t\t}"}, {"sha": "5db679a3ed6d251003ec76941e6dd38a0fd65e9d", "filename": "libgo/go/netchan/import.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fimport.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -213,8 +213,8 @@ func (imp *Importer) ImportNValues(name string, chT interface{}, dir Dir, size,\n \tif dir == Send {\n \t\tgo func() {\n \t\t\tfor i := 0; n == -1 || i < n; i++ {\n-\t\t\t\tval, closed := nch.recv()\n-\t\t\t\tif closed {\n+\t\t\t\tval, ok := nch.recv()\n+\t\t\t\tif !ok {\n \t\t\t\t\tif err = imp.encode(hdr, payClosed, nil); err != nil {\n \t\t\t\t\t\timpLog(\"error encoding client closed message:\", err)\n \t\t\t\t\t}"}, {"sha": "1b5c560872e67e1aaa7a14d23ae5719dc26a6d1f", "filename": "libgo/go/netchan/netchan_test.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnetchan%2Fnetchan_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -41,8 +41,8 @@ func exportReceive(exp *Exporter, t *testing.T, expDone chan bool) {\n \t\tt.Fatal(\"exportReceive:\", err)\n \t}\n \tfor i := 0; i < count; i++ {\n-\t\tv := <-ch\n-\t\tif closed(ch) {\n+\t\tv, ok := <-ch\n+\t\tif !ok {\n \t\t\tif i != closeCount {\n \t\t\t\tt.Errorf(\"exportReceive expected close at %d; got one at %d\", closeCount, i)\n \t\t\t}\n@@ -78,8 +78,8 @@ func importReceive(imp *Importer, t *testing.T, done chan bool) {\n \t\tt.Fatal(\"importReceive:\", err)\n \t}\n \tfor i := 0; i < count; i++ {\n-\t\tv := <-ch\n-\t\tif closed(ch) {\n+\t\tv, ok := <-ch\n+\t\tif !ok {\n \t\t\tif i != closeCount {\n \t\t\t\tt.Errorf(\"importReceive expected close at %d; got one at %d\", closeCount, i)\n \t\t\t}\n@@ -212,8 +212,8 @@ func TestExportHangup(t *testing.T) {\n \t}\n \t// Now hang up the channel.  Importer should see it close.\n \texp.Hangup(\"exportedSend\")\n-\tv = <-ich\n-\tif !closed(ich) {\n+\tv, ok := <-ich\n+\tif ok {\n \t\tt.Fatal(\"expected channel to be closed; got value\", v)\n \t}\n }\n@@ -242,8 +242,8 @@ func TestImportHangup(t *testing.T) {\n \t}\n \t// Now hang up the channel.  Exporter should see it close.\n \timp.Hangup(\"exportedRecv\")\n-\tv = <-ech\n-\tif !closed(ech) {\n+\tv, ok := <-ech\n+\tif ok {\n \t\tt.Fatal(\"expected channel to be closed; got value\", v)\n \t}\n }"}, {"sha": "9d80ccfbed464d65564cec40b65e73318b9268d3", "filename": "libgo/go/os/exec.go", "status": "modified", "additions": 31, "deletions": 12, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fexec.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -21,27 +21,46 @@ func newProcess(pid, handle int) *Process {\n \treturn p\n }\n \n-// StartProcess starts a new process with the program, arguments,\n-// and environment specified by name, argv, and envv. The fd array specifies the\n-// file descriptors to be set up in the new process: fd[0] will be Unix file\n-// descriptor 0 (standard input), fd[1] descriptor 1, and so on.  A nil entry\n-// will cause the child to have no open file descriptor with that index.\n-// If dir is not empty, the child chdirs into the directory before execing the program.\n-func StartProcess(name string, argv []string, envv []string, dir string, fd []*File) (p *Process, err Error) {\n-\tif envv == nil {\n-\t\tenvv = Environ()\n+// ProcAttr holds the attributes that will be applied to a new process\n+// started by StartProcess.\n+type ProcAttr struct {\n+\t// If Dir is non-empty, the child changes into the directory before\n+\t// creating the process.\n+\tDir string\n+\t// If Env is non-nil, it gives the environment variables for the\n+\t// new process in the form returned by Environ.\n+\t// If it is nil, the result of Environ will be used.\n+\tEnv []string\n+\t// Files specifies the open files inherited by the new process.  The\n+\t// first three entries correspond to standard input, standard output, and\n+\t// standard error.  An implementation may support additional entries,\n+\t// depending on the underlying operating system.  A nil entry corresponds\n+\t// to that file being closed when the process starts.\n+\tFiles []*File\n+}\n+\n+// StartProcess starts a new process with the program, arguments and attributes\n+// specified by name, argv and attr.\n+func StartProcess(name string, argv []string, attr *ProcAttr) (p *Process, err Error) {\n+\tsysattr := &syscall.ProcAttr{\n+\t\tDir: attr.Dir,\n+\t\tEnv: attr.Env,\n+\t}\n+\tif sysattr.Env == nil {\n+\t\tsysattr.Env = Environ()\n \t}\n \t// Create array of integer (system) fds.\n-\tintfd := make([]int, len(fd))\n-\tfor i, f := range fd {\n+\tintfd := make([]int, len(attr.Files))\n+\tfor i, f := range attr.Files {\n \t\tif f == nil {\n \t\t\tintfd[i] = -1\n \t\t} else {\n \t\t\tintfd[i] = f.Fd()\n \t\t}\n \t}\n+\tsysattr.Files = intfd\n \n-\tpid, h, e := syscall.StartProcess(name, argv, envv, dir, intfd)\n+\tpid, h, e := syscall.StartProcess(name, argv, sysattr)\n \tif e != 0 {\n \t\treturn nil, &PathError{\"fork/exec\", name, Errno(e)}\n \t}"}, {"sha": "79c3bfa36e489e8af75fbc29f3fd57033e080058", "filename": "libgo/go/os/inotify/inotify_linux_test.go", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Finotify%2Finotify_linux_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -35,6 +35,7 @@ func TestInotifyEvents(t *testing.T) {\n \t// Receive events on the event channel on a separate goroutine\n \teventstream := watcher.Event\n \tvar eventsReceived = 0\n+\tdone := make(chan bool)\n \tgo func() {\n \t\tfor event := range eventstream {\n \t\t\t// Only count relevant events\n@@ -45,6 +46,7 @@ func TestInotifyEvents(t *testing.T) {\n \t\t\t\tt.Logf(\"unexpected event received: %s\", event)\n \t\t\t}\n \t\t}\n+\t\tdone <- true\n \t}()\n \n \t// Create a file\n@@ -64,16 +66,12 @@ func TestInotifyEvents(t *testing.T) {\n \tt.Log(\"calling Close()\")\n \twatcher.Close()\n \tt.Log(\"waiting for the event channel to become closed...\")\n-\tvar i = 0\n-\tfor !closed(eventstream) {\n-\t\tif i >= 20 {\n-\t\t\tt.Fatal(\"event stream was not closed after 1 second, as expected\")\n-\t\t}\n-\t\tt.Log(\"waiting for 50 ms...\")\n-\t\ttime.Sleep(50e6) // 50 ms\n-\t\ti++\n+\tselect {\n+\tcase <-done:\n+\t\tt.Log(\"event channel closed\")\n+\tcase <-time.After(1e9):\n+\t\tt.Fatal(\"event stream was not closed after 1 second\")\n \t}\n-\tt.Log(\"event channel closed\")\n }\n \n "}, {"sha": "bb1b8e31893150aa0a7d0774dfc956ce6f63baf2", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 29, "deletions": 18, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -10,6 +10,7 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t. \"os\"\n+\t\"path/filepath\"\n \t\"strings\"\n \t\"syscall\"\n \t\"testing\"\n@@ -405,25 +406,13 @@ func TestRename(t *testing.T) {\n \t}\n }\n \n-func TestForkExec(t *testing.T) {\n-\tvar cmd, adir, expect string\n-\tvar args []string\n+func exec(t *testing.T, dir, cmd string, args []string, expect string) {\n \tr, w, err := Pipe()\n \tif err != nil {\n \t\tt.Fatalf(\"Pipe: %v\", err)\n \t}\n-\tif syscall.OS == \"windows\" {\n-\t\tcmd = Getenv(\"COMSPEC\")\n-\t\targs = []string{Getenv(\"COMSPEC\"), \"/c cd\"}\n-\t\tadir = Getenv(\"SystemRoot\")\n-\t\texpect = Getenv(\"SystemRoot\") + \"\\r\\n\"\n-\t} else {\n-\t\tcmd = \"/bin/pwd\"\n-\t\targs = []string{\"pwd\"}\n-\t\tadir = \"/\"\n-\t\texpect = \"/\\n\"\n-\t}\n-\tp, err := StartProcess(cmd, args, nil, adir, []*File{nil, w, Stderr})\n+\tattr := &ProcAttr{Dir: dir, Files: []*File{nil, w, Stderr}}\n+\tp, err := StartProcess(cmd, args, attr)\n \tif err != nil {\n \t\tt.Fatalf(\"StartProcess: %v\", err)\n \t}\n@@ -434,12 +423,34 @@ func TestForkExec(t *testing.T) {\n \tio.Copy(&b, r)\n \toutput := b.String()\n \tif output != expect {\n-\t\targs[0] = cmd\n-\t\tt.Errorf(\"exec %q returned %q wanted %q\", strings.Join(args, \" \"), output, expect)\n+\t\tt.Errorf(\"exec %q returned %q wanted %q\",\n+\t\t\tstrings.Join(append([]string{cmd}, args...), \" \"), output, expect)\n \t}\n \tp.Wait(0)\n }\n \n+func TestStartProcess(t *testing.T) {\n+\tvar dir, cmd, le string\n+\tvar args []string\n+\tif syscall.OS == \"windows\" {\n+\t\tle = \"\\r\\n\"\n+\t\tcmd = Getenv(\"COMSPEC\")\n+\t\tdir = Getenv(\"SystemRoot\")\n+\t\targs = []string{\"/c\", \"cd\"}\n+\t} else {\n+\t\tle = \"\\n\"\n+\t\tcmd = \"/bin/pwd\"\n+\t\tdir = \"/\"\n+\t\targs = []string{}\n+\t}\n+\tcmddir, cmdbase := filepath.Split(cmd)\n+\targs = append([]string{cmdbase}, args...)\n+\t// Test absolute executable path.\n+\texec(t, dir, cmd, args, dir+le)\n+\t// Test relative executable path.\n+\texec(t, cmddir, cmdbase, args, filepath.Clean(cmddir)+le)\n+}\n+\n func checkMode(t *testing.T, path string, mode uint32) {\n \tdir, err := Stat(path)\n \tif err != nil {\n@@ -747,7 +758,7 @@ func run(t *testing.T, cmd []string) string {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n-\tp, err := StartProcess(\"/bin/hostname\", []string{\"hostname\"}, nil, \"/\", []*File{nil, w, Stderr})\n+\tp, err := StartProcess(\"/bin/hostname\", []string{\"hostname\"}, &ProcAttr{Files: []*File{nil, w, Stderr}})\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "ad4053fa242a64ed50bd331e1b79f18d208225e5", "filename": "libgo/go/path/filepath/match.go", "status": "added", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,282 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath\n+\n+import (\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"utf8\"\n+)\n+\n+var ErrBadPattern = os.NewError(\"syntax error in pattern\")\n+\n+// Match returns true if name matches the shell file name pattern.\n+// The pattern syntax is:\n+//\n+//\tpattern:\n+//\t\t{ term }\n+//\tterm:\n+//\t\t'*'         matches any sequence of non-Separator characters\n+//\t\t'?'         matches any single non-Separator character\n+//\t\t'[' [ '^' ] { character-range } ']'\n+//\t\t            character class (must be non-empty)\n+//\t\tc           matches character c (c != '*', '?', '\\\\', '[')\n+//\t\t'\\\\' c      matches character c\n+//\n+//\tcharacter-range:\n+//\t\tc           matches character c (c != '\\\\', '-', ']')\n+//\t\t'\\\\' c      matches character c\n+//\t\tlo '-' hi   matches character c for lo <= c <= hi\n+//\n+// Match requires pattern to match all of name, not just a substring.\n+// The only possible error return is when pattern is malformed.\n+//\n+func Match(pattern, name string) (matched bool, err os.Error) {\n+Pattern:\n+\tfor len(pattern) > 0 {\n+\t\tvar star bool\n+\t\tvar chunk string\n+\t\tstar, chunk, pattern = scanChunk(pattern)\n+\t\tif star && chunk == \"\" {\n+\t\t\t// Trailing * matches rest of string unless it has a /.\n+\t\t\treturn strings.Index(name, string(Separator)) < 0, nil\n+\t\t}\n+\t\t// Look for match at current position.\n+\t\tt, ok, err := matchChunk(chunk, name)\n+\t\t// if we're the last chunk, make sure we've exhausted the name\n+\t\t// otherwise we'll give a false result even if we could still match\n+\t\t// using the star\n+\t\tif ok && (len(t) == 0 || len(pattern) > 0) {\n+\t\t\tname = t\n+\t\t\tcontinue\n+\t\t}\n+\t\tif err != nil {\n+\t\t\treturn false, err\n+\t\t}\n+\t\tif star {\n+\t\t\t// Look for match skipping i+1 bytes.\n+\t\t\t// Cannot skip /.\n+\t\t\tfor i := 0; i < len(name) && name[i] != Separator; i++ {\n+\t\t\t\tt, ok, err := matchChunk(chunk, name[i+1:])\n+\t\t\t\tif ok {\n+\t\t\t\t\t// if we're the last chunk, make sure we exhausted the name\n+\t\t\t\t\tif len(pattern) == 0 && len(t) > 0 {\n+\t\t\t\t\t\tcontinue\n+\t\t\t\t\t}\n+\t\t\t\t\tname = t\n+\t\t\t\t\tcontinue Pattern\n+\t\t\t\t}\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn false, err\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn false, nil\n+\t}\n+\treturn len(name) == 0, nil\n+}\n+\n+// scanChunk gets the next segment of pattern, which is a non-star string\n+// possibly preceded by a star.\n+func scanChunk(pattern string) (star bool, chunk, rest string) {\n+\tfor len(pattern) > 0 && pattern[0] == '*' {\n+\t\tpattern = pattern[1:]\n+\t\tstar = true\n+\t}\n+\tinrange := false\n+\tvar i int\n+Scan:\n+\tfor i = 0; i < len(pattern); i++ {\n+\t\tswitch pattern[i] {\n+\t\tcase '\\\\':\n+\t\t\t// error check handled in matchChunk: bad pattern.\n+\t\t\tif i+1 < len(pattern) {\n+\t\t\t\ti++\n+\t\t\t}\n+\t\tcase '[':\n+\t\t\tinrange = true\n+\t\tcase ']':\n+\t\t\tinrange = false\n+\t\tcase '*':\n+\t\t\tif !inrange {\n+\t\t\t\tbreak Scan\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn star, pattern[0:i], pattern[i:]\n+}\n+\n+// matchChunk checks whether chunk matches the beginning of s.\n+// If so, it returns the remainder of s (after the match).\n+// Chunk is all single-character operators: literals, char classes, and ?.\n+func matchChunk(chunk, s string) (rest string, ok bool, err os.Error) {\n+\tfor len(chunk) > 0 {\n+\t\tif len(s) == 0 {\n+\t\t\treturn\n+\t\t}\n+\t\tswitch chunk[0] {\n+\t\tcase '[':\n+\t\t\t// character class\n+\t\t\tr, n := utf8.DecodeRuneInString(s)\n+\t\t\ts = s[n:]\n+\t\t\tchunk = chunk[1:]\n+\t\t\t// possibly negated\n+\t\t\tnotNegated := true\n+\t\t\tif len(chunk) > 0 && chunk[0] == '^' {\n+\t\t\t\tnotNegated = false\n+\t\t\t\tchunk = chunk[1:]\n+\t\t\t}\n+\t\t\t// parse all ranges\n+\t\t\tmatch := false\n+\t\t\tnrange := 0\n+\t\t\tfor {\n+\t\t\t\tif len(chunk) > 0 && chunk[0] == ']' && nrange > 0 {\n+\t\t\t\t\tchunk = chunk[1:]\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tvar lo, hi int\n+\t\t\t\tif lo, chunk, err = getEsc(chunk); err != nil {\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t\thi = lo\n+\t\t\t\tif chunk[0] == '-' {\n+\t\t\t\t\tif hi, chunk, err = getEsc(chunk[1:]); err != nil {\n+\t\t\t\t\t\treturn\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tif lo <= r && r <= hi {\n+\t\t\t\t\tmatch = true\n+\t\t\t\t}\n+\t\t\t\tnrange++\n+\t\t\t}\n+\t\t\tif match != notNegated {\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\tcase '?':\n+\t\t\tif s[0] == Separator {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\t_, n := utf8.DecodeRuneInString(s)\n+\t\t\ts = s[n:]\n+\t\t\tchunk = chunk[1:]\n+\n+\t\tcase '\\\\':\n+\t\t\tchunk = chunk[1:]\n+\t\t\tif len(chunk) == 0 {\n+\t\t\t\terr = ErrBadPattern\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tfallthrough\n+\n+\t\tdefault:\n+\t\t\tif chunk[0] != s[0] {\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\ts = s[1:]\n+\t\t\tchunk = chunk[1:]\n+\t\t}\n+\t}\n+\treturn s, true, nil\n+}\n+\n+// getEsc gets a possibly-escaped character from chunk, for a character class.\n+func getEsc(chunk string) (r int, nchunk string, err os.Error) {\n+\tif len(chunk) == 0 || chunk[0] == '-' || chunk[0] == ']' {\n+\t\terr = ErrBadPattern\n+\t\treturn\n+\t}\n+\tif chunk[0] == '\\\\' {\n+\t\tchunk = chunk[1:]\n+\t\tif len(chunk) == 0 {\n+\t\t\terr = ErrBadPattern\n+\t\t\treturn\n+\t\t}\n+\t}\n+\tr, n := utf8.DecodeRuneInString(chunk)\n+\tif r == utf8.RuneError && n == 1 {\n+\t\terr = ErrBadPattern\n+\t}\n+\tnchunk = chunk[n:]\n+\tif len(nchunk) == 0 {\n+\t\terr = ErrBadPattern\n+\t}\n+\treturn\n+}\n+\n+// Glob returns the names of all files matching pattern or nil\n+// if there is no matching file. The syntax of patterns is the same\n+// as in Match. The pattern may describe hierarchical names such as\n+// /usr/*/bin/ed (assuming the Separator is '/').\n+//\n+func Glob(pattern string) (matches []string) {\n+\tif !hasMeta(pattern) {\n+\t\tif _, err := os.Stat(pattern); err == nil {\n+\t\t\treturn []string{pattern}\n+\t\t}\n+\t\treturn nil\n+\t}\n+\n+\tdir, file := Split(pattern)\n+\tswitch dir {\n+\tcase \"\":\n+\t\tdir = \".\"\n+\tcase string(Separator):\n+\t\t// nothing\n+\tdefault:\n+\t\tdir = dir[0 : len(dir)-1] // chop off trailing separator\n+\t}\n+\n+\tif hasMeta(dir) {\n+\t\tfor _, d := range Glob(dir) {\n+\t\t\tmatches = glob(d, file, matches)\n+\t\t}\n+\t} else {\n+\t\treturn glob(dir, file, nil)\n+\t}\n+\treturn matches\n+}\n+\n+// glob searches for files matching pattern in the directory dir\n+// and appends them to matches.\n+func glob(dir, pattern string, matches []string) []string {\n+\tfi, err := os.Stat(dir)\n+\tif err != nil {\n+\t\treturn nil\n+\t}\n+\tif !fi.IsDirectory() {\n+\t\treturn matches\n+\t}\n+\td, err := os.Open(dir, os.O_RDONLY, 0666)\n+\tif err != nil {\n+\t\treturn nil\n+\t}\n+\tdefer d.Close()\n+\n+\tnames, err := d.Readdirnames(-1)\n+\tif err != nil {\n+\t\treturn nil\n+\t}\n+\tsort.SortStrings(names)\n+\n+\tfor _, n := range names {\n+\t\tmatched, err := Match(pattern, n)\n+\t\tif err != nil {\n+\t\t\treturn matches\n+\t\t}\n+\t\tif matched {\n+\t\t\tmatches = append(matches, Join(dir, n))\n+\t\t}\n+\t}\n+\treturn matches\n+}\n+\n+// hasMeta returns true if path contains any of the magic characters\n+// recognized by Match.\n+func hasMeta(path string) bool {\n+\t// TODO(niemeyer): Should other magic characters be added here?\n+\treturn strings.IndexAny(path, \"*?[\") >= 0\n+}"}, {"sha": "a1e631647e51e50fb1714c784b10f1b27e64aba8", "filename": "libgo/go/path/filepath/match_test.go", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fmatch_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,117 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath_test\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"runtime\"\n+)\n+\n+type MatchTest struct {\n+\tpattern, s string\n+\tmatch      bool\n+\terr        os.Error\n+}\n+\n+var matchTests = []MatchTest{\n+\t{\"abc\", \"abc\", true, nil},\n+\t{\"*\", \"abc\", true, nil},\n+\t{\"*c\", \"abc\", true, nil},\n+\t{\"a*\", \"a\", true, nil},\n+\t{\"a*\", \"abc\", true, nil},\n+\t{\"a*\", \"ab/c\", false, nil},\n+\t{\"a*/b\", \"abc/b\", true, nil},\n+\t{\"a*/b\", \"a/c/b\", false, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxe/f\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxexxx/f\", true, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxe/xxx/f\", false, nil},\n+\t{\"a*b*c*d*e*/f\", \"axbxcxdxexxx/fff\", false, nil},\n+\t{\"a*b?c*x\", \"abxbbxdbxebxczzx\", true, nil},\n+\t{\"a*b?c*x\", \"abxbbxdbxebxczzy\", false, nil},\n+\t{\"ab[c]\", \"abc\", true, nil},\n+\t{\"ab[b-d]\", \"abc\", true, nil},\n+\t{\"ab[e-g]\", \"abc\", false, nil},\n+\t{\"ab[^c]\", \"abc\", false, nil},\n+\t{\"ab[^b-d]\", \"abc\", false, nil},\n+\t{\"ab[^e-g]\", \"abc\", true, nil},\n+\t{\"a\\\\*b\", \"a*b\", true, nil},\n+\t{\"a\\\\*b\", \"ab\", false, nil},\n+\t{\"a?b\", \"a\u263ab\", true, nil},\n+\t{\"a[^a]b\", \"a\u263ab\", true, nil},\n+\t{\"a???b\", \"a\u263ab\", false, nil},\n+\t{\"a[^a][^a][^a]b\", \"a\u263ab\", false, nil},\n+\t{\"[a-\u03b6]*\", \"\u03b1\", true, nil},\n+\t{\"*[a-\u03b6]\", \"A\", false, nil},\n+\t{\"a?b\", \"a/b\", false, nil},\n+\t{\"a*b\", \"a/b\", false, nil},\n+\t{\"[\\\\]a]\", \"]\", true, nil},\n+\t{\"[\\\\-]\", \"-\", true, nil},\n+\t{\"[x\\\\-]\", \"x\", true, nil},\n+\t{\"[x\\\\-]\", \"-\", true, nil},\n+\t{\"[x\\\\-]\", \"z\", false, nil},\n+\t{\"[\\\\-x]\", \"x\", true, nil},\n+\t{\"[\\\\-x]\", \"-\", true, nil},\n+\t{\"[\\\\-x]\", \"a\", false, nil},\n+\t{\"[]a]\", \"]\", false, filepath.ErrBadPattern},\n+\t{\"[-]\", \"-\", false, filepath.ErrBadPattern},\n+\t{\"[x-]\", \"x\", false, filepath.ErrBadPattern},\n+\t{\"[x-]\", \"-\", false, filepath.ErrBadPattern},\n+\t{\"[x-]\", \"z\", false, filepath.ErrBadPattern},\n+\t{\"[-x]\", \"x\", false, filepath.ErrBadPattern},\n+\t{\"[-x]\", \"-\", false, filepath.ErrBadPattern},\n+\t{\"[-x]\", \"a\", false, filepath.ErrBadPattern},\n+\t{\"\\\\\", \"a\", false, filepath.ErrBadPattern},\n+\t{\"[a-b-c]\", \"a\", false, filepath.ErrBadPattern},\n+\t{\"*x\", \"xxx\", true, nil},\n+}\n+\n+func TestMatch(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// XXX: Don't pass for windows.\n+\t\treturn\n+\t}\n+\tfor _, tt := range matchTests {\n+\t\tok, err := filepath.Match(tt.pattern, tt.s)\n+\t\tif ok != tt.match || err != tt.err {\n+\t\t\tt.Errorf(\"Match(%#q, %#q) = %v, %v want %v, nil\", tt.pattern, tt.s, ok, err, tt.match)\n+\t\t}\n+\t}\n+}\n+\n+// contains returns true if vector contains the string s.\n+func contains(vector []string, s string) bool {\n+\ts = filepath.ToSlash(s)\n+\tfor _, elem := range vector {\n+\t\tif elem == s {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+var globTests = []struct {\n+\tpattern, result string\n+}{\n+\t{\"match.go\", \"match.go\"},\n+\t{\"mat?h.go\", \"match.go\"},\n+\t{\"*\", \"match.go\"},\n+\t// Does not work in gccgo test environment.\n+\t// {\"../*/match.go\", \"../filepath/match.go\"},\n+}\n+\n+func TestGlob(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\t// XXX: Don't pass for windows.\n+\t\treturn\n+\t}\n+\tfor _, tt := range globTests {\n+\t\tmatches := filepath.Glob(tt.pattern)\n+\t\tif !contains(matches, tt.result) {\n+\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", tt.pattern, matches, tt.result)\n+\t\t}\n+\t}\n+}"}, {"sha": "6cd6cf2ab094034a4ac55ad8befbbae83c6a185a", "filename": "libgo/go/path/filepath/path.go", "status": "added", "additions": 335, "deletions": 0, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,335 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// The filepath package implements utility routines for manipulating\n+// filename paths in a way compatible with the target operating\n+// system-defined file paths.\n+package filepath\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"sort\"\n+\t\"strings\"\n+)\n+\n+const (\n+\tSeparatorString     = string(Separator)\n+\tListSeparatorString = string(ListSeparator)\n+)\n+\n+// Clean returns the shortest path name equivalent to path\n+// by purely lexical processing.  It applies the following rules\n+// iteratively until no further processing can be done:\n+//\n+//\t1. Replace multiple Separator elements with a single one.\n+//\t2. Eliminate each . path name element (the current directory).\n+//\t3. Eliminate each inner .. path name element (the parent directory)\n+//\t   along with the non-.. element that precedes it.\n+//\t4. Eliminate .. elements that begin a rooted path:\n+//\t   that is, replace \"/..\" by \"/\" at the beginning of a path,\n+//         assuming Separator is '/'.\n+//\n+// If the result of this process is an empty string, Clean\n+// returns the string \".\".\n+//\n+// See also Rob Pike, ``Lexical File Names in Plan 9 or\n+// Getting Dot-Dot right,''\n+// http://plan9.bell-labs.com/sys/doc/lexnames.html\n+func Clean(path string) string {\n+\tif path == \"\" {\n+\t\treturn \".\"\n+\t}\n+\n+\trooted := IsAbs(path)\n+\n+\t// Invariants:\n+\t//\treading from path; r is index of next byte to process.\n+\t//\twriting to buf; w is index of next byte to write.\n+\t//\tdotdot is index in buf where .. must stop, either because\n+\t//\t\tit is the leading slash or it is a leading ../../.. prefix.\n+\tprefix := volumeName(path)\n+\tpath = path[len(prefix):]\n+\tn := len(path)\n+\tbuf := []byte(path)\n+\tr, w, dotdot := 0, 0, 0\n+\tif rooted {\n+\t\tbuf[0] = Separator\n+\t\tr, w, dotdot = 1, 1, 1\n+\t}\n+\n+\tfor r < n {\n+\t\tswitch {\n+\t\tcase isSeparator(path[r]):\n+\t\t\t// empty path element\n+\t\t\tr++\n+\t\tcase path[r] == '.' && (r+1 == n || isSeparator(path[r+1])):\n+\t\t\t// . element\n+\t\t\tr++\n+\t\tcase path[r] == '.' && path[r+1] == '.' && (r+2 == n || isSeparator(path[r+2])):\n+\t\t\t// .. element: remove to last separator\n+\t\t\tr += 2\n+\t\t\tswitch {\n+\t\t\tcase w > dotdot:\n+\t\t\t\t// can backtrack\n+\t\t\t\tw--\n+\t\t\t\tfor w > dotdot && !isSeparator(buf[w]) {\n+\t\t\t\t\tw--\n+\t\t\t\t}\n+\t\t\tcase !rooted:\n+\t\t\t\t// cannot backtrack, but not rooted, so append .. element.\n+\t\t\t\tif w > 0 {\n+\t\t\t\t\tbuf[w] = Separator\n+\t\t\t\t\tw++\n+\t\t\t\t}\n+\t\t\t\tbuf[w] = '.'\n+\t\t\t\tw++\n+\t\t\t\tbuf[w] = '.'\n+\t\t\t\tw++\n+\t\t\t\tdotdot = w\n+\t\t\t}\n+\t\tdefault:\n+\t\t\t// real path element.\n+\t\t\t// add slash if needed\n+\t\t\tif rooted && w != 1 || !rooted && w != 0 {\n+\t\t\t\tbuf[w] = Separator\n+\t\t\t\tw++\n+\t\t\t}\n+\t\t\t// copy element\n+\t\t\tfor ; r < n && !isSeparator(path[r]); r++ {\n+\t\t\t\tbuf[w] = path[r]\n+\t\t\t\tw++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Turn empty string into \".\"\n+\tif w == 0 {\n+\t\tbuf[w] = '.'\n+\t\tw++\n+\t}\n+\n+\treturn prefix + string(buf[0:w])\n+}\n+\n+// ToSlash returns the result of replacing each separator character\n+// in path with a slash ('/') character.\n+func ToSlash(path string) string {\n+\tif Separator == '/' {\n+\t\treturn path\n+\t}\n+\treturn strings.Replace(path, SeparatorString, \"/\", -1)\n+}\n+\n+// FromSlash returns the result of replacing each slash ('/') character\n+// in path with a separator character.\n+func FromSlash(path string) string {\n+\tif Separator == '/' {\n+\t\treturn path\n+\t}\n+\treturn strings.Replace(path, \"/\", SeparatorString, -1)\n+}\n+\n+// SplitList splits a list of paths joined by the OS-specific ListSeparator.\n+func SplitList(path string) []string {\n+\tif path == \"\" {\n+\t\treturn []string{}\n+\t}\n+\treturn strings.Split(path, ListSeparatorString, -1)\n+}\n+\n+// Split splits path immediately following the final Separator,\n+// partitioning it into a directory and a file name components.\n+// If there are no separators in path, Split returns an empty base\n+// and file set to path.\n+func Split(path string) (dir, file string) {\n+\ti := len(path) - 1\n+\tfor i >= 0 && !isSeparator(path[i]) {\n+\t\ti--\n+\t}\n+\treturn path[:i+1], path[i+1:]\n+}\n+\n+// Join joins any number of path elements into a single path, adding\n+// a Separator if necessary.  All empty strings are ignored.\n+func Join(elem ...string) string {\n+\tfor i, e := range elem {\n+\t\tif e != \"\" {\n+\t\t\treturn Clean(strings.Join(elem[i:], SeparatorString))\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+// Ext returns the file name extension used by path.\n+// The extension is the suffix beginning at the final dot\n+// in the final element of path; it is empty if there is\n+// no dot.\n+func Ext(path string) string {\n+\tfor i := len(path) - 1; i >= 0 && !isSeparator(path[i]); i-- {\n+\t\tif path[i] == '.' {\n+\t\t\treturn path[i:]\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+// EvalSymlinks returns the path name after the evaluation of any symbolic\n+// links.\n+// If path is relative it will be evaluated relative to the current directory.\n+func EvalSymlinks(path string) (string, os.Error) {\n+\tconst maxIter = 255\n+\toriginalPath := path\n+\t// consume path by taking each frontmost path element,\n+\t// expanding it if it's a symlink, and appending it to b\n+\tvar b bytes.Buffer\n+\tfor n := 0; path != \"\"; n++ {\n+\t\tif n > maxIter {\n+\t\t\treturn \"\", os.NewError(\"EvalSymlinks: too many links in \" + originalPath)\n+\t\t}\n+\n+\t\t// find next path component, p\n+\t\ti := strings.IndexRune(path, Separator)\n+\t\tvar p string\n+\t\tif i == -1 {\n+\t\t\tp, path = path, \"\"\n+\t\t} else {\n+\t\t\tp, path = path[:i], path[i+1:]\n+\t\t}\n+\n+\t\tif p == \"\" {\n+\t\t\tif b.Len() == 0 {\n+\t\t\t\t// must be absolute path\n+\t\t\t\tb.WriteRune(Separator)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tfi, err := os.Lstat(b.String() + p)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif !fi.IsSymlink() {\n+\t\t\tb.WriteString(p)\n+\t\t\tif path != \"\" {\n+\t\t\t\tb.WriteRune(Separator)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\t// it's a symlink, put it at the front of path\n+\t\tdest, err := os.Readlink(b.String() + p)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\tif IsAbs(dest) {\n+\t\t\tb.Reset()\n+\t\t}\n+\t\tpath = dest + SeparatorString + path\n+\t}\n+\treturn Clean(b.String()), nil\n+}\n+\n+// Visitor methods are invoked for corresponding file tree entries\n+// visited by Walk. The parameter path is the full path of f relative\n+// to root.\n+type Visitor interface {\n+\tVisitDir(path string, f *os.FileInfo) bool\n+\tVisitFile(path string, f *os.FileInfo)\n+}\n+\n+func walk(path string, f *os.FileInfo, v Visitor, errors chan<- os.Error) {\n+\tif !f.IsDirectory() {\n+\t\tv.VisitFile(path, f)\n+\t\treturn\n+\t}\n+\n+\tif !v.VisitDir(path, f) {\n+\t\treturn // skip directory entries\n+\t}\n+\n+\tlist, err := readDir(path)\n+\tif err != nil {\n+\t\tif errors != nil {\n+\t\t\terrors <- err\n+\t\t}\n+\t}\n+\n+\tfor _, e := range list {\n+\t\twalk(Join(path, e.Name), e, v, errors)\n+\t}\n+}\n+\n+// readDir reads the directory named by dirname and returns\n+// a list of sorted directory entries.\n+// Copied from io/ioutil to avoid the circular import.\n+func readDir(dirname string) ([]*os.FileInfo, os.Error) {\n+\tf, err := os.Open(dirname, os.O_RDONLY, 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tlist, err := f.Readdir(-1)\n+\tf.Close()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfi := make(fileInfoList, len(list))\n+\tfor i := range list {\n+\t\tfi[i] = &list[i]\n+\t}\n+\tsort.Sort(fi)\n+\treturn fi, nil\n+}\n+\n+// A dirList implements sort.Interface.\n+type fileInfoList []*os.FileInfo\n+\n+func (f fileInfoList) Len() int           { return len(f) }\n+func (f fileInfoList) Less(i, j int) bool { return f[i].Name < f[j].Name }\n+func (f fileInfoList) Swap(i, j int)      { f[i], f[j] = f[j], f[i] }\n+\n+// Walk walks the file tree rooted at root, calling v.VisitDir or\n+// v.VisitFile for each directory or file in the tree, including root.\n+// If v.VisitDir returns false, Walk skips the directory's entries;\n+// otherwise it invokes itself for each directory entry in sorted order.\n+// An error reading a directory does not abort the Walk.\n+// If errors != nil, Walk sends each directory read error\n+// to the channel.  Otherwise Walk discards the error.\n+func Walk(root string, v Visitor, errors chan<- os.Error) {\n+\tf, err := os.Lstat(root)\n+\tif err != nil {\n+\t\tif errors != nil {\n+\t\t\terrors <- err\n+\t\t}\n+\t\treturn // can't progress\n+\t}\n+\twalk(root, f, v, errors)\n+}\n+\n+// Base returns the last element of path.\n+// Trailing path separators are removed before extracting the last element.\n+// If the path is empty, Base returns \".\".\n+// If the path consists entirely of separators, Base returns a single separator.\n+func Base(path string) string {\n+\tif path == \"\" {\n+\t\treturn \".\"\n+\t}\n+\t// Strip trailing slashes.\n+\tfor len(path) > 0 && isSeparator(path[len(path)-1]) {\n+\t\tpath = path[0 : len(path)-1]\n+\t}\n+\t// Find the last element\n+\ti := len(path) - 1\n+\tfor i >= 0 && !isSeparator(path[i]) {\n+\t\ti--\n+\t}\n+\tif i >= 0 {\n+\t\tpath = path[i+1:]\n+\t}\n+\t// If empty now, it had only slashes.\n+\tif path == \"\" {\n+\t\treturn SeparatorString\n+\t}\n+\treturn path\n+}"}, {"sha": "0249af4d87c20cb74baf32a9e1cd377d44c8e110", "filename": "libgo/go/path/filepath/path_test.go", "status": "added", "additions": 486, "deletions": 0, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,486 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath_test\n+\n+import (\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"reflect\"\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+type PathTest struct {\n+\tpath, result string\n+}\n+\n+var cleantests = []PathTest{\n+\t// Already clean\n+\t{\"\", \".\"},\n+\t{\"abc\", \"abc\"},\n+\t{\"abc/def\", \"abc/def\"},\n+\t{\"a/b/c\", \"a/b/c\"},\n+\t{\".\", \".\"},\n+\t{\"..\", \"..\"},\n+\t{\"../..\", \"../..\"},\n+\t{\"../../abc\", \"../../abc\"},\n+\t{\"/abc\", \"/abc\"},\n+\t{\"/\", \"/\"},\n+\n+\t// Remove trailing slash\n+\t{\"abc/\", \"abc\"},\n+\t{\"abc/def/\", \"abc/def\"},\n+\t{\"a/b/c/\", \"a/b/c\"},\n+\t{\"./\", \".\"},\n+\t{\"../\", \"..\"},\n+\t{\"../../\", \"../..\"},\n+\t{\"/abc/\", \"/abc\"},\n+\n+\t// Remove doubled slash\n+\t{\"abc//def//ghi\", \"abc/def/ghi\"},\n+\t{\"//abc\", \"/abc\"},\n+\t{\"///abc\", \"/abc\"},\n+\t{\"//abc//\", \"/abc\"},\n+\t{\"abc//\", \"abc\"},\n+\n+\t// Remove . elements\n+\t{\"abc/./def\", \"abc/def\"},\n+\t{\"/./abc/def\", \"/abc/def\"},\n+\t{\"abc/.\", \"abc\"},\n+\n+\t// Remove .. elements\n+\t{\"abc/def/ghi/../jkl\", \"abc/def/jkl\"},\n+\t{\"abc/def/../ghi/../jkl\", \"abc/jkl\"},\n+\t{\"abc/def/..\", \"abc\"},\n+\t{\"abc/def/../..\", \".\"},\n+\t{\"/abc/def/../..\", \"/\"},\n+\t{\"abc/def/../../..\", \"..\"},\n+\t{\"/abc/def/../../..\", \"/\"},\n+\t{\"abc/def/../../../ghi/jkl/../../../mno\", \"../../mno\"},\n+\n+\t// Combinations\n+\t{\"abc/./../def\", \"def\"},\n+\t{\"abc//./../def\", \"def\"},\n+\t{\"abc/../../././../def\", \"../../def\"},\n+}\n+\n+func TestClean(t *testing.T) {\n+\tfor _, test := range cleantests {\n+\t\tif s := filepath.ToSlash(filepath.Clean(test.path)); s != test.result {\n+\t\t\tt.Errorf(\"Clean(%q) = %q, want %q\", test.path, s, test.result)\n+\t\t}\n+\t}\n+}\n+\n+const sep = filepath.Separator\n+\n+var slashtests = []PathTest{\n+\t{\"\", \"\"},\n+\t{\"/\", string(sep)},\n+\t{\"/a/b\", string([]byte{sep, 'a', sep, 'b'})},\n+\t{\"a//b\", string([]byte{'a', sep, sep, 'b'})},\n+}\n+\n+func TestFromAndToSlash(t *testing.T) {\n+\tfor _, test := range slashtests {\n+\t\tif s := filepath.FromSlash(test.path); s != test.result {\n+\t\t\tt.Errorf(\"FromSlash(%q) = %q, want %q\", test.path, s, test.result)\n+\t\t}\n+\t\tif s := filepath.ToSlash(test.result); s != test.path {\n+\t\t\tt.Errorf(\"ToSlash(%q) = %q, want %q\", test.result, s, test.path)\n+\t\t}\n+\t}\n+}\n+\n+type SplitListTest struct {\n+\tlist   string\n+\tresult []string\n+}\n+\n+const lsep = filepath.ListSeparator\n+\n+var splitlisttests = []SplitListTest{\n+\t{\"\", []string{}},\n+\t{string([]byte{'a', lsep, 'b'}), []string{\"a\", \"b\"}},\n+\t{string([]byte{lsep, 'a', lsep, 'b'}), []string{\"\", \"a\", \"b\"}},\n+}\n+\n+func TestSplitList(t *testing.T) {\n+\tfor _, test := range splitlisttests {\n+\t\tif l := filepath.SplitList(test.list); !reflect.DeepEqual(l, test.result) {\n+\t\t\tt.Errorf(\"SplitList(%q) = %s, want %s\", test.list, l, test.result)\n+\t\t}\n+\t}\n+}\n+\n+type SplitTest struct {\n+\tpath, dir, file string\n+}\n+\n+var unixsplittests = []SplitTest{\n+\t{\"a/b\", \"a/\", \"b\"},\n+\t{\"a/b/\", \"a/b/\", \"\"},\n+\t{\"a/\", \"a/\", \"\"},\n+\t{\"a\", \"\", \"a\"},\n+\t{\"/\", \"/\", \"\"},\n+}\n+\n+func TestSplit(t *testing.T) {\n+\tvar splittests []SplitTest\n+\tsplittests = unixsplittests\n+\tfor _, test := range splittests {\n+\t\tif d, f := filepath.Split(test.path); d != test.dir || f != test.file {\n+\t\t\tt.Errorf(\"Split(%q) = %q, %q, want %q, %q\", test.path, d, f, test.dir, test.file)\n+\t\t}\n+\t}\n+}\n+\n+type JoinTest struct {\n+\telem []string\n+\tpath string\n+}\n+\n+var jointests = []JoinTest{\n+\t// zero parameters\n+\t{[]string{}, \"\"},\n+\n+\t// one parameter\n+\t{[]string{\"\"}, \"\"},\n+\t{[]string{\"a\"}, \"a\"},\n+\n+\t// two parameters\n+\t{[]string{\"a\", \"b\"}, \"a/b\"},\n+\t{[]string{\"a\", \"\"}, \"a\"},\n+\t{[]string{\"\", \"b\"}, \"b\"},\n+\t{[]string{\"/\", \"a\"}, \"/a\"},\n+\t{[]string{\"/\", \"\"}, \"/\"},\n+\t{[]string{\"a/\", \"b\"}, \"a/b\"},\n+\t{[]string{\"a/\", \"\"}, \"a\"},\n+\t{[]string{\"\", \"\"}, \"\"},\n+}\n+\n+var winjointests = []JoinTest{\n+\t{[]string{`directory`, `file`}, `directory\\file`},\n+\t{[]string{`C:\\Windows\\`, `System32`}, `C:\\Windows\\System32`},\n+\t{[]string{`C:\\Windows\\`, ``}, `C:\\Windows`},\n+\t{[]string{`C:\\`, `Windows`}, `C:\\Windows`},\n+\t{[]string{`C:`, `Windows`}, `C:\\Windows`},\n+}\n+\n+// join takes a []string and passes it to Join.\n+func join(elem []string, args ...string) string {\n+\targs = elem\n+\treturn filepath.Join(args...)\n+}\n+\n+func TestJoin(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tjointests = append(jointests, winjointests...)\n+\t}\n+\tfor _, test := range jointests {\n+\t\tif p := join(test.elem); p != filepath.FromSlash(test.path) {\n+\t\t\tt.Errorf(\"join(%q) = %q, want %q\", test.elem, p, test.path)\n+\t\t}\n+\t}\n+}\n+\n+type ExtTest struct {\n+\tpath, ext string\n+}\n+\n+var exttests = []ExtTest{\n+\t{\"path.go\", \".go\"},\n+\t{\"path.pb.go\", \".go\"},\n+\t{\"a.dir/b\", \"\"},\n+\t{\"a.dir/b.go\", \".go\"},\n+\t{\"a.dir/\", \"\"},\n+}\n+\n+func TestExt(t *testing.T) {\n+\tfor _, test := range exttests {\n+\t\tif x := filepath.Ext(test.path); x != test.ext {\n+\t\t\tt.Errorf(\"Ext(%q) = %q, want %q\", test.path, x, test.ext)\n+\t\t}\n+\t}\n+}\n+\n+type Node struct {\n+\tname    string\n+\tentries []*Node // nil if the entry is a file\n+\tmark    int\n+}\n+\n+var tree = &Node{\n+\t\"testdata\",\n+\t[]*Node{\n+\t\t&Node{\"a\", nil, 0},\n+\t\t&Node{\"b\", []*Node{}, 0},\n+\t\t&Node{\"c\", nil, 0},\n+\t\t&Node{\n+\t\t\t\"d\",\n+\t\t\t[]*Node{\n+\t\t\t\t&Node{\"x\", nil, 0},\n+\t\t\t\t&Node{\"y\", []*Node{}, 0},\n+\t\t\t\t&Node{\n+\t\t\t\t\t\"z\",\n+\t\t\t\t\t[]*Node{\n+\t\t\t\t\t\t&Node{\"u\", nil, 0},\n+\t\t\t\t\t\t&Node{\"v\", nil, 0},\n+\t\t\t\t\t},\n+\t\t\t\t\t0,\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\t0,\n+\t\t},\n+\t},\n+\t0,\n+}\n+\n+func walkTree(n *Node, path string, f func(path string, n *Node)) {\n+\tf(path, n)\n+\tfor _, e := range n.entries {\n+\t\twalkTree(e, filepath.Join(path, e.name), f)\n+\t}\n+}\n+\n+func makeTree(t *testing.T) {\n+\twalkTree(tree, tree.name, func(path string, n *Node) {\n+\t\tif n.entries == nil {\n+\t\t\tfd, err := os.Open(path, os.O_CREAT, 0660)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"makeTree: %v\", err)\n+\t\t\t}\n+\t\t\tfd.Close()\n+\t\t} else {\n+\t\t\tos.Mkdir(path, 0770)\n+\t\t}\n+\t})\n+}\n+\n+func markTree(n *Node) { walkTree(n, \"\", func(path string, n *Node) { n.mark++ }) }\n+\n+func checkMarks(t *testing.T) {\n+\twalkTree(tree, tree.name, func(path string, n *Node) {\n+\t\tif n.mark != 1 {\n+\t\t\tt.Errorf(\"node %s mark = %d; expected 1\", path, n.mark)\n+\t\t}\n+\t\tn.mark = 0\n+\t})\n+}\n+\n+// Assumes that each node name is unique. Good enough for a test.\n+func mark(name string) {\n+\tname = filepath.ToSlash(name)\n+\twalkTree(tree, tree.name, func(path string, n *Node) {\n+\t\tif n.name == name {\n+\t\t\tn.mark++\n+\t\t}\n+\t})\n+}\n+\n+type TestVisitor struct{}\n+\n+func (v *TestVisitor) VisitDir(path string, f *os.FileInfo) bool {\n+\tmark(f.Name)\n+\treturn true\n+}\n+\n+func (v *TestVisitor) VisitFile(path string, f *os.FileInfo) {\n+\tmark(f.Name)\n+}\n+\n+func TestWalk(t *testing.T) {\n+\t// TODO(brainman): enable test once Windows version is implemented.\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\tmakeTree(t)\n+\n+\t// 1) ignore error handling, expect none\n+\tv := &TestVisitor{}\n+\tfilepath.Walk(tree.name, v, nil)\n+\tcheckMarks(t)\n+\n+\t// 2) handle errors, expect none\n+\terrors := make(chan os.Error, 64)\n+\tfilepath.Walk(tree.name, v, errors)\n+\tselect {\n+\tcase err := <-errors:\n+\t\tt.Errorf(\"no error expected, found: %s\", err)\n+\tdefault:\n+\t\t// ok\n+\t}\n+\tcheckMarks(t)\n+\n+\tif os.Getuid() > 0 {\n+\t\t// introduce 2 errors: chmod top-level directories to 0\n+\t\tos.Chmod(filepath.Join(tree.name, tree.entries[1].name), 0)\n+\t\tos.Chmod(filepath.Join(tree.name, tree.entries[3].name), 0)\n+\t\t// mark respective subtrees manually\n+\t\tmarkTree(tree.entries[1])\n+\t\tmarkTree(tree.entries[3])\n+\t\t// correct double-marking of directory itself\n+\t\ttree.entries[1].mark--\n+\t\ttree.entries[3].mark--\n+\n+\t\t// 3) handle errors, expect two\n+\t\terrors = make(chan os.Error, 64)\n+\t\tos.Chmod(filepath.Join(tree.name, tree.entries[1].name), 0)\n+\t\tfilepath.Walk(tree.name, v, errors)\n+\tLoop:\n+\t\tfor i := 1; i <= 2; i++ {\n+\t\t\tselect {\n+\t\t\tcase <-errors:\n+\t\t\t\t// ok\n+\t\t\tdefault:\n+\t\t\t\tt.Errorf(\"%d. error expected, none found\", i)\n+\t\t\t\tbreak Loop\n+\t\t\t}\n+\t\t}\n+\t\tselect {\n+\t\tcase err := <-errors:\n+\t\t\tt.Errorf(\"only two errors expected, found 3rd: %v\", err)\n+\t\tdefault:\n+\t\t\t// ok\n+\t\t}\n+\t\t// the inaccessible subtrees were marked manually\n+\t\tcheckMarks(t)\n+\t}\n+\n+\t// cleanup\n+\tos.Chmod(filepath.Join(tree.name, tree.entries[1].name), 0770)\n+\tos.Chmod(filepath.Join(tree.name, tree.entries[3].name), 0770)\n+\tif err := os.RemoveAll(tree.name); err != nil {\n+\t\tt.Errorf(\"removeTree: %v\", err)\n+\t}\n+}\n+\n+var basetests = []PathTest{\n+\t{\"\", \".\"},\n+\t{\".\", \".\"},\n+\t{\"/.\", \".\"},\n+\t{\"/\", \"/\"},\n+\t{\"////\", \"/\"},\n+\t{\"x/\", \"x\"},\n+\t{\"abc\", \"abc\"},\n+\t{\"abc/def\", \"def\"},\n+\t{\"a/b/.x\", \".x\"},\n+\t{\"a/b/c.\", \"c.\"},\n+\t{\"a/b/c.x\", \"c.x\"},\n+}\n+\n+func TestBase(t *testing.T) {\n+\tfor _, test := range basetests {\n+\t\tif s := filepath.ToSlash(filepath.Base(test.path)); s != test.result {\n+\t\t\tt.Errorf(\"Base(%q) = %q, want %q\", test.path, s, test.result)\n+\t\t}\n+\t}\n+}\n+\n+type IsAbsTest struct {\n+\tpath  string\n+\tisAbs bool\n+}\n+\n+var isabstests = []IsAbsTest{\n+\t{\"\", false},\n+\t{\"/\", true},\n+\t{\"/usr/bin/gcc\", true},\n+\t{\"..\", false},\n+\t{\"/a/../bb\", true},\n+\t{\".\", false},\n+\t{\"./\", false},\n+\t{\"lala\", false},\n+}\n+\n+var winisabstests = []IsAbsTest{\n+\t{`C:\\`, true},\n+\t{`c\\`, false},\n+\t{`c::`, false},\n+\t{`/`, true},\n+\t{`\\`, true},\n+\t{`\\Windows`, true},\n+}\n+\n+func TestIsAbs(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" {\n+\t\tisabstests = append(isabstests, winisabstests...)\n+\t}\n+\tfor _, test := range isabstests {\n+\t\tif r := filepath.IsAbs(test.path); r != test.isAbs {\n+\t\t\tt.Errorf(\"IsAbs(%q) = %v, want %v\", test.path, r, test.isAbs)\n+\t\t}\n+\t}\n+}\n+\n+type EvalSymlinksTest struct {\n+\tpath, dest string\n+}\n+\n+var EvalSymlinksTestDirs = []EvalSymlinksTest{\n+\t{\"test\", \"\"},\n+\t{\"test/dir\", \"\"},\n+\t{\"test/dir/link3\", \"../../\"},\n+\t{\"test/link1\", \"../test\"},\n+\t{\"test/link2\", \"dir\"},\n+}\n+\n+var EvalSymlinksTests = []EvalSymlinksTest{\n+\t{\"test\", \"test\"},\n+\t{\"test/dir\", \"test/dir\"},\n+\t{\"test/dir/../..\", \".\"},\n+\t{\"test/link1\", \"test\"},\n+\t{\"test/link2\", \"test/dir\"},\n+\t{\"test/link1/dir\", \"test/dir\"},\n+\t{\"test/link2/..\", \"test\"},\n+\t{\"test/dir/link3\", \".\"},\n+\t{\"test/link2/link3/test\", \"test\"},\n+}\n+\n+func TestEvalSymlinks(t *testing.T) {\n+\t// Symlinks are not supported under windows.\n+\tif runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\tdefer os.RemoveAll(\"test\")\n+\tfor _, d := range EvalSymlinksTestDirs {\n+\t\tvar err os.Error\n+\t\tif d.dest == \"\" {\n+\t\t\terr = os.Mkdir(d.path, 0755)\n+\t\t} else {\n+\t\t\terr = os.Symlink(d.dest, d.path)\n+\t\t}\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t}\n+\t// relative\n+\tfor _, d := range EvalSymlinksTests {\n+\t\tif p, err := filepath.EvalSymlinks(d.path); err != nil {\n+\t\t\tt.Errorf(\"EvalSymlinks(%v) error: %v\", d.path, err)\n+\t\t} else if p != d.dest {\n+\t\t\tt.Errorf(\"EvalSymlinks(%v)=%v, want %v\", d.path, p, d.dest)\n+\t\t}\n+\t}\n+\t// absolute\n+/* These tests do not work in the gccgo test environment.\n+\tgoroot, err := filepath.EvalSymlinks(os.Getenv(\"GOROOT\"))\n+\tif err != nil {\n+\t\tt.Fatalf(\"EvalSymlinks(%q) error: %v\", os.Getenv(\"GOROOT\"), err)\n+\t}\n+\ttestroot := filepath.Join(goroot, \"src\", \"pkg\", \"path\", \"filepath\")\n+\tfor _, d := range EvalSymlinksTests {\n+\t\ta := EvalSymlinksTest{\n+\t\t\tfilepath.Join(testroot, d.path),\n+\t\t\tfilepath.Join(testroot, d.dest),\n+\t\t}\n+\t\tif p, err := filepath.EvalSymlinks(a.path); err != nil {\n+\t\t\tt.Errorf(\"EvalSymlinks(%v) error: %v\", a.path, err)\n+\t\t} else if p != a.dest {\n+\t\t\tt.Errorf(\"EvalSymlinks(%v)=%v, want %v\", a.path, p, a.dest)\n+\t\t}\n+\t}\n+*/\n+}"}, {"sha": "1bb21ec7d92a1184b42b5e30ce1d7920c8569ee4", "filename": "libgo/go/path/filepath/path_unix.go", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_unix.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath\n+\n+import \"strings\"\n+\n+const (\n+\tSeparator     = '/' // OS-specific path separator\n+\tListSeparator = ':' // OS-specific path list separator\n+)\n+\n+// isSeparator returns true if c is a directory separator character.\n+func isSeparator(c uint8) bool {\n+\treturn Separator == c\n+}\n+\n+// IsAbs returns true if the path is absolute.\n+func IsAbs(path string) bool {\n+\treturn strings.HasPrefix(path, \"/\")\n+}\n+\n+// volumeName returns the leading volume name on Windows.\n+// It returns \"\" on Unix.\n+func volumeName(path string) string {\n+\treturn \"\"\n+}"}, {"sha": "dbd1c1e401d38c1cf666a6b38a666d47f08d0cd9", "filename": "libgo/go/path/filepath/path_windows.go", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Ffilepath%2Fpath_windows.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,37 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package filepath\n+\n+const (\n+\tSeparator     = '\\\\' // OS-specific path separator\n+\tListSeparator = ':'  // OS-specific path list separator\n+)\n+\n+// isSeparator returns true if c is a directory separator character.\n+func isSeparator(c uint8) bool {\n+\t// NOTE: Windows accept / as path separator.\n+\treturn c == '\\\\' || c == '/'\n+}\n+\n+// IsAbs returns true if the path is absolute.\n+func IsAbs(path string) bool {\n+\treturn path != \"\" && (volumeName(path) != \"\" || isSeparator(path[0]))\n+}\n+\n+// volumeName return leading volume name.  \n+// If given \"C:\\foo\\bar\", return \"C:\" on windows.\n+func volumeName(path string) string {\n+\tif path == \"\" {\n+\t\treturn \"\"\n+\t}\n+\t// with drive letter\n+\tc := path[0]\n+\tif len(path) > 2 && path[1] == ':' && isSeparator(path[2]) &&\n+\t\t('0' <= c && c <= '9' || 'a' <= c && c <= 'z' ||\n+\t\t\t'A' <= c && c <= 'Z') {\n+\t\treturn path[0:2]\n+\t}\n+\treturn \"\"\n+}"}, {"sha": "efb8c5ce7fcf075d81ce04cb3101b10eadc2f298", "filename": "libgo/go/path/match.go", "status": "modified", "additions": 6, "deletions": 77, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fmatch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fmatch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fmatch.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -1,16 +1,19 @@\n+// Copyright 2010 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n package path\n \n import (\n \t\"os\"\n-\t\"sort\"\n \t\"strings\"\n \t\"utf8\"\n )\n \n var ErrBadPattern = os.NewError(\"syntax error in pattern\")\n \n // Match returns true if name matches the shell file name pattern.\n-// The syntax used by pattern is:\n+// The pattern syntax is:\n //\n //\tpattern:\n //\t\t{ term }\n@@ -75,7 +78,7 @@ Pattern:\n \treturn len(name) == 0, nil\n }\n \n-// scanChunk gets the next section of pattern, which is a non-star string\n+// scanChunk gets the next segment of pattern, which is a non-star string\n // possibly preceded by a star.\n func scanChunk(pattern string) (star bool, chunk, rest string) {\n \tfor len(pattern) > 0 && pattern[0] == '*' {\n@@ -92,7 +95,6 @@ Scan:\n \t\t\tif i+1 < len(pattern) {\n \t\t\t\ti++\n \t\t\t}\n-\t\t\tcontinue\n \t\tcase '[':\n \t\t\tinrange = true\n \t\tcase ']':\n@@ -203,76 +205,3 @@ func getEsc(chunk string) (r int, nchunk string, err os.Error) {\n \t}\n \treturn\n }\n-\n-// Glob returns the names of all files matching pattern or nil\n-// if there is no matching file. The syntax of patterns is the same\n-// as in Match. The pattern may describe hierarchical names such as\n-// /usr/*/bin/ed.\n-//\n-func Glob(pattern string) (matches []string) {\n-\tif !hasMeta(pattern) {\n-\t\tif _, err := os.Stat(pattern); err == nil {\n-\t\t\treturn []string{pattern}\n-\t\t}\n-\t\treturn nil\n-\t}\n-\n-\tdir, file := Split(pattern)\n-\tswitch dir {\n-\tcase \"\":\n-\t\tdir = \".\"\n-\tcase \"/\":\n-\t\t// nothing\n-\tdefault:\n-\t\tdir = dir[0 : len(dir)-1] // chop off trailing '/'\n-\t}\n-\n-\tif hasMeta(dir) {\n-\t\tfor _, d := range Glob(dir) {\n-\t\t\tmatches = glob(d, file, matches)\n-\t\t}\n-\t} else {\n-\t\treturn glob(dir, file, nil)\n-\t}\n-\treturn matches\n-}\n-\n-// glob searches for files matching pattern in the directory dir\n-// and appends them to matches.\n-func glob(dir, pattern string, matches []string) []string {\n-\tfi, err := os.Stat(dir)\n-\tif err != nil {\n-\t\treturn nil\n-\t}\n-\tif !fi.IsDirectory() {\n-\t\treturn matches\n-\t}\n-\td, err := os.Open(dir, os.O_RDONLY, 0666)\n-\tif err != nil {\n-\t\treturn nil\n-\t}\n-\tdefer d.Close()\n-\n-\tnames, err := d.Readdirnames(-1)\n-\tif err != nil {\n-\t\treturn nil\n-\t}\n-\tsort.SortStrings(names)\n-\n-\tfor _, n := range names {\n-\t\tmatched, err := Match(pattern, n)\n-\t\tif err != nil {\n-\t\t\treturn matches\n-\t\t}\n-\t\tif matched {\n-\t\t\tmatches = append(matches, Join(dir, n))\n-\t\t}\n-\t}\n-\treturn matches\n-}\n-\n-// hasMeta returns true if path contains any of the magic characters\n-// recognized by Match.\n-func hasMeta(path string) bool {\n-\treturn strings.IndexAny(path, \"*?[\") != -1\n-}"}, {"sha": "f377f1083b77a25bf947d8859ae8a5fef73dde5f", "filename": "libgo/go/path/match_test.go", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fmatch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fmatch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fmatch_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -75,32 +75,3 @@ func TestMatch(t *testing.T) {\n \t\t}\n \t}\n }\n-\n-// contains returns true if vector contains the string s.\n-func contains(vector []string, s string) bool {\n-\tfor _, elem := range vector {\n-\t\tif elem == s {\n-\t\t\treturn true\n-\t\t}\n-\t}\n-\treturn false\n-}\n-\n-var globTests = []struct {\n-\tpattern, result string\n-}{\n-\t{\"match.go\", \"match.go\"},\n-\t{\"mat?h.go\", \"match.go\"},\n-\t{\"*\", \"match.go\"},\n-\t// Fails in the gccgo test environment.\n-\t// {\"../*/match.go\", \"../path/match.go\"},\n-}\n-\n-func TestGlob(t *testing.T) {\n-\tfor _, tt := range globTests {\n-\t\tmatches := Glob(tt.pattern)\n-\t\tif !contains(matches, tt.result) {\n-\t\t\tt.Errorf(\"Glob(%#q) = %#v want %v\", tt.pattern, matches, tt.result)\n-\t\t}\n-\t}\n-}"}, {"sha": "658eec0938706dfd3b6bab90bb77f30a71d89cc6", "filename": "libgo/go/path/path.go", "status": "modified", "additions": 14, "deletions": 64, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -7,8 +7,6 @@\n package path\n \n import (\n-\t\"io/ioutil\"\n-\t\"os\"\n \t\"strings\"\n )\n \n@@ -107,7 +105,7 @@ func Clean(path string) string {\n // If there is no separator in path, Split returns an empty dir and\n // file set to path.\n func Split(path string) (dir, file string) {\n-\ti := strings.LastIndexAny(path, PathSeps)\n+\ti := strings.LastIndex(path, \"/\")\n \treturn path[:i+1], path[i+1:]\n }\n \n@@ -135,78 +133,30 @@ func Ext(path string) string {\n \treturn \"\"\n }\n \n-// Visitor methods are invoked for corresponding file tree entries\n-// visited by Walk. The parameter path is the full path of f relative\n-// to root.\n-type Visitor interface {\n-\tVisitDir(path string, f *os.FileInfo) bool\n-\tVisitFile(path string, f *os.FileInfo)\n-}\n-\n-func walk(path string, f *os.FileInfo, v Visitor, errors chan<- os.Error) {\n-\tif !f.IsDirectory() {\n-\t\tv.VisitFile(path, f)\n-\t\treturn\n-\t}\n-\n-\tif !v.VisitDir(path, f) {\n-\t\treturn // skip directory entries\n-\t}\n-\n-\tlist, err := ioutil.ReadDir(path)\n-\tif err != nil {\n-\t\tif errors != nil {\n-\t\t\terrors <- err\n-\t\t}\n-\t}\n-\n-\tfor _, e := range list {\n-\t\twalk(Join(path, e.Name), e, v, errors)\n-\t}\n-}\n-\n-// Walk walks the file tree rooted at root, calling v.VisitDir or\n-// v.VisitFile for each directory or file in the tree, including root.\n-// If v.VisitDir returns false, Walk skips the directory's entries;\n-// otherwise it invokes itself for each directory entry in sorted order.\n-// An error reading a directory does not abort the Walk.\n-// If errors != nil, Walk sends each directory read error\n-// to the channel.  Otherwise Walk discards the error.\n-func Walk(root string, v Visitor, errors chan<- os.Error) {\n-\tf, err := os.Lstat(root)\n-\tif err != nil {\n-\t\tif errors != nil {\n-\t\t\terrors <- err\n-\t\t}\n-\t\treturn // can't progress\n-\t}\n-\twalk(root, f, v, errors)\n-}\n-\n-// Base returns the last path element of the slash-separated name.\n-// Trailing slashes are removed before extracting the last element.  If the name is\n-// empty, \".\" is returned.  If it consists entirely of slashes, \"/\" is returned.\n-func Base(name string) string {\n-\tif name == \"\" {\n+// Base returns the last element of path.\n+// Trailing slashes are removed before extracting the last element.\n+// If the path is empty, Base returns \".\".\n+// If the path consists entirely of slashes, Base returns \"/\".\n+func Base(path string) string {\n+\tif path == \"\" {\n \t\treturn \".\"\n \t}\n \t// Strip trailing slashes.\n-\tfor len(name) > 0 && name[len(name)-1] == '/' {\n-\t\tname = name[0 : len(name)-1]\n+\tfor len(path) > 0 && path[len(path)-1] == '/' {\n+\t\tpath = path[0 : len(path)-1]\n \t}\n \t// Find the last element\n-\tif i := strings.LastIndex(name, \"/\"); i >= 0 {\n-\t\tname = name[i+1:]\n+\tif i := strings.LastIndex(path, \"/\"); i >= 0 {\n+\t\tpath = path[i+1:]\n \t}\n \t// If empty now, it had only slashes.\n-\tif name == \"\" {\n+\tif path == \"\" {\n \t\treturn \"/\"\n \t}\n-\treturn name\n+\treturn path\n }\n \n // IsAbs returns true if the path is absolute.\n func IsAbs(path string) bool {\n-\t// TODO: Add Windows support\n-\treturn strings.HasPrefix(path, \"/\")\n+\treturn len(path) > 0 && path[0] == '/'\n }"}, {"sha": "1fd57cc800ec7eccff173f03239463f2bfc81c0c", "filename": "libgo/go/path/path_test.go", "status": "modified", "additions": 0, "deletions": 159, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fpath%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -5,8 +5,6 @@\n package path\n \n import (\n-\t\"os\"\n-\t\"runtime\"\n \t\"testing\"\n )\n \n@@ -84,18 +82,7 @@ var splittests = []SplitTest{\n \t{\"/\", \"/\", \"\"},\n }\n \n-var winsplittests = []SplitTest{\n-\t{`C:\\Windows\\System32`, `C:\\Windows\\`, `System32`},\n-\t{`C:\\Windows\\`, `C:\\Windows\\`, ``},\n-\t{`C:\\Windows`, `C:\\`, `Windows`},\n-\t{`C:Windows`, `C:`, `Windows`},\n-\t{`\\\\?\\c:\\`, `\\\\?\\c:\\`, ``},\n-}\n-\n func TestSplit(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n-\t\tsplittests = append(splittests, winsplittests...)\n-\t}\n \tfor _, test := range splittests {\n \t\tif d, f := Split(test.path); d != test.dir || f != test.file {\n \t\t\tt.Errorf(\"Split(%q) = %q, %q, want %q, %q\", test.path, d, f, test.dir, test.file)\n@@ -161,152 +148,6 @@ func TestExt(t *testing.T) {\n \t}\n }\n \n-type Node struct {\n-\tname    string\n-\tentries []*Node // nil if the entry is a file\n-\tmark    int\n-}\n-\n-var tree = &Node{\n-\t\"testdata\",\n-\t[]*Node{\n-\t\t&Node{\"a\", nil, 0},\n-\t\t&Node{\"b\", []*Node{}, 0},\n-\t\t&Node{\"c\", nil, 0},\n-\t\t&Node{\n-\t\t\t\"d\",\n-\t\t\t[]*Node{\n-\t\t\t\t&Node{\"x\", nil, 0},\n-\t\t\t\t&Node{\"y\", []*Node{}, 0},\n-\t\t\t\t&Node{\n-\t\t\t\t\t\"z\",\n-\t\t\t\t\t[]*Node{\n-\t\t\t\t\t\t&Node{\"u\", nil, 0},\n-\t\t\t\t\t\t&Node{\"v\", nil, 0},\n-\t\t\t\t\t},\n-\t\t\t\t\t0,\n-\t\t\t\t},\n-\t\t\t},\n-\t\t\t0,\n-\t\t},\n-\t},\n-\t0,\n-}\n-\n-func walkTree(n *Node, path string, f func(path string, n *Node)) {\n-\tf(path, n)\n-\tfor _, e := range n.entries {\n-\t\twalkTree(e, Join(path, e.name), f)\n-\t}\n-}\n-\n-func makeTree(t *testing.T) {\n-\twalkTree(tree, tree.name, func(path string, n *Node) {\n-\t\tif n.entries == nil {\n-\t\t\tfd, err := os.Open(path, os.O_CREAT, 0660)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"makeTree: %v\", err)\n-\t\t\t}\n-\t\t\tfd.Close()\n-\t\t} else {\n-\t\t\tos.Mkdir(path, 0770)\n-\t\t}\n-\t})\n-}\n-\n-func markTree(n *Node) { walkTree(n, \"\", func(path string, n *Node) { n.mark++ }) }\n-\n-func checkMarks(t *testing.T) {\n-\twalkTree(tree, tree.name, func(path string, n *Node) {\n-\t\tif n.mark != 1 {\n-\t\t\tt.Errorf(\"node %s mark = %d; expected 1\", path, n.mark)\n-\t\t}\n-\t\tn.mark = 0\n-\t})\n-}\n-\n-// Assumes that each node name is unique. Good enough for a test.\n-func mark(name string) {\n-\twalkTree(tree, tree.name, func(path string, n *Node) {\n-\t\tif n.name == name {\n-\t\t\tn.mark++\n-\t\t}\n-\t})\n-}\n-\n-type TestVisitor struct{}\n-\n-func (v *TestVisitor) VisitDir(path string, f *os.FileInfo) bool {\n-\tmark(f.Name)\n-\treturn true\n-}\n-\n-func (v *TestVisitor) VisitFile(path string, f *os.FileInfo) {\n-\tmark(f.Name)\n-}\n-\n-func TestWalk(t *testing.T) {\n-\tmakeTree(t)\n-\n-\t// 1) ignore error handling, expect none\n-\tv := &TestVisitor{}\n-\tWalk(tree.name, v, nil)\n-\tcheckMarks(t)\n-\n-\t// 2) handle errors, expect none\n-\terrors := make(chan os.Error, 64)\n-\tWalk(tree.name, v, errors)\n-\tselect {\n-\tcase err := <-errors:\n-\t\tt.Errorf(\"no error expected, found: %s\", err)\n-\tdefault:\n-\t\t// ok\n-\t}\n-\tcheckMarks(t)\n-\n-\tif os.Getuid() != 0 {\n-\t\t// introduce 2 errors: chmod top-level directories to 0\n-\t\tos.Chmod(Join(tree.name, tree.entries[1].name), 0)\n-\t\tos.Chmod(Join(tree.name, tree.entries[3].name), 0)\n-\t\t// mark respective subtrees manually\n-\t\tmarkTree(tree.entries[1])\n-\t\tmarkTree(tree.entries[3])\n-\t\t// correct double-marking of directory itself\n-\t\ttree.entries[1].mark--\n-\t\ttree.entries[3].mark--\n-\n-\t\t// 3) handle errors, expect two\n-\t\terrors = make(chan os.Error, 64)\n-\t\tos.Chmod(Join(tree.name, tree.entries[1].name), 0)\n-\t\tWalk(tree.name, v, errors)\n-\tLoop:\n-\t\tfor i := 1; i <= 2; i++ {\n-\t\t\tselect {\n-\t\t\tcase <-errors:\n-\t\t\t\t// ok\n-\t\t\tdefault:\n-\t\t\t\tt.Errorf(\"%d. error expected, none found\", i)\n-\t\t\t\tbreak Loop\n-\t\t\t}\n-\t\t}\n-\t\tselect {\n-\t\tcase err := <-errors:\n-\t\t\tt.Errorf(\"only two errors expected, found 3rd: %v\", err)\n-\t\tdefault:\n-\t\t\t// ok\n-\t\t}\n-\t\t// the inaccessible subtrees were marked manually\n-\t\tcheckMarks(t)\n-\t}\n-\n-\t// cleanup\n-\tos.Chmod(Join(tree.name, tree.entries[1].name), 0770)\n-\tos.Chmod(Join(tree.name, tree.entries[3].name), 0770)\n-\tif err := os.RemoveAll(tree.name); err != nil {\n-\t\tt.Errorf(\"removeTree: %v\", err)\n-\t}\n-}\n-\n var basetests = []CleanTest{\n \t// Already clean\n \t{\"\", \".\"},"}, {"sha": "7e8c5eb8b9aa42c470e470d0a55d7e74771ce99a", "filename": "libgo/go/path/path_unix.go", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114321ee4f521ea9fbdd08a4c23b361181f3658/libgo%2Fgo%2Fpath%2Fpath_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114321ee4f521ea9fbdd08a4c23b361181f3658/libgo%2Fgo%2Fpath%2Fpath_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_unix.go?ref=7114321ee4f521ea9fbdd08a4c23b361181f3658", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package path\n-\n-const (\n-\tDirSeps    = `/`                  // directory separators\n-\tVolumeSeps = ``                   // volume separators\n-\tPathSeps   = DirSeps + VolumeSeps // all path separators\n-)"}, {"sha": "966eb49fb5211b09a4c78189be19228ee8a76de0", "filename": "libgo/go/path/path_windows.go", "status": "removed", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7114321ee4f521ea9fbdd08a4c23b361181f3658/libgo%2Fgo%2Fpath%2Fpath_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7114321ee4f521ea9fbdd08a4c23b361181f3658/libgo%2Fgo%2Fpath%2Fpath_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fpath%2Fpath_windows.go?ref=7114321ee4f521ea9fbdd08a4c23b361181f3658", "patch": "@@ -1,11 +0,0 @@\n-// Copyright 2010 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package path\n-\n-const (\n-\tDirSeps    = `\\/`                 // directory separators\n-\tVolumeSeps = `:`                  // volume separators\n-\tPathSeps   = DirSeps + VolumeSeps // all path separators\n-)"}, {"sha": "ac07ce5a36836fbbf8016832cb9323ffab7ac3c6", "filename": "libgo/go/reflect/all_test.go", "status": "modified", "additions": 14, "deletions": 23, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Freflect%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Freflect%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fall_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -968,28 +968,28 @@ func TestChan(t *testing.T) {\n \n \t\t// Recv\n \t\tc <- 3\n-\t\tif i := cv.Recv().(*IntValue).Get(); i != 3 {\n-\t\t\tt.Errorf(\"native send 3, reflect Recv %d\", i)\n+\t\tif i, ok := cv.Recv(); i.(*IntValue).Get() != 3 || !ok {\n+\t\t\tt.Errorf(\"native send 3, reflect Recv %d, %t\", i.(*IntValue).Get(), ok)\n \t\t}\n \n \t\t// TryRecv fail\n-\t\tval := cv.TryRecv()\n-\t\tif val != nil {\n-\t\t\tt.Errorf(\"TryRecv on empty chan: %s\", valueToString(val))\n+\t\tval, ok := cv.TryRecv()\n+\t\tif val != nil || ok {\n+\t\t\tt.Errorf(\"TryRecv on empty chan: %s, %t\", valueToString(val), ok)\n \t\t}\n \n \t\t// TryRecv success\n \t\tc <- 4\n-\t\tval = cv.TryRecv()\n+\t\tval, ok = cv.TryRecv()\n \t\tif val == nil {\n \t\t\tt.Errorf(\"TryRecv on ready chan got nil\")\n-\t\t} else if i := val.(*IntValue).Get(); i != 4 {\n-\t\t\tt.Errorf(\"native send 4, TryRecv %d\", i)\n+\t\t} else if i := val.(*IntValue).Get(); i != 4 || !ok {\n+\t\t\tt.Errorf(\"native send 4, TryRecv %d, %t\", i, ok)\n \t\t}\n \n \t\t// TrySend fail\n \t\tc <- 100\n-\t\tok := cv.TrySend(NewValue(5))\n+\t\tok = cv.TrySend(NewValue(5))\n \t\ti := <-c\n \t\tif ok {\n \t\t\tt.Errorf(\"TrySend on full chan succeeded: value %d\", i)\n@@ -1008,20 +1008,11 @@ func TestChan(t *testing.T) {\n \t\t// Close\n \t\tc <- 123\n \t\tcv.Close()\n-\t\tif cv.Closed() {\n-\t\t\tt.Errorf(\"closed too soon - 1\")\n+\t\tif i, ok := cv.Recv(); i.(*IntValue).Get() != 123 || !ok {\n+\t\t\tt.Errorf(\"send 123 then close; Recv %d, %t\", i.(*IntValue).Get(), ok)\n \t\t}\n-\t\tif i := cv.Recv().(*IntValue).Get(); i != 123 {\n-\t\t\tt.Errorf(\"send 123 then close; Recv %d\", i)\n-\t\t}\n-\t\tif cv.Closed() {\n-\t\t\tt.Errorf(\"closed too soon - 2\")\n-\t\t}\n-\t\tif i := cv.Recv().(*IntValue).Get(); i != 0 {\n-\t\t\tt.Errorf(\"after close Recv %d\", i)\n-\t\t}\n-\t\tif !cv.Closed() {\n-\t\t\tt.Errorf(\"not closed\")\n+\t\tif i, ok := cv.Recv(); i.(*IntValue).Get() != 0 || ok {\n+\t\t\tt.Errorf(\"after close Recv %d, %t\", i.(*IntValue).Get(), ok)\n \t\t}\n \t}\n \n@@ -1032,7 +1023,7 @@ func TestChan(t *testing.T) {\n \tif cv.TrySend(NewValue(7)) {\n \t\tt.Errorf(\"TrySend on sync chan succeeded\")\n \t}\n-\tif cv.TryRecv() != nil {\n+\tif v, ok := cv.TryRecv(); v != nil || ok {\n \t\tt.Errorf(\"TryRecv on sync chan succeeded\")\n \t}\n "}, {"sha": "ebc87d45b9226703b5a2adc3f2783f7265f4137b", "filename": "libgo/go/reflect/value.go", "status": "modified", "additions": 30, "deletions": 28, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Freflect%2Fvalue.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Freflect%2Fvalue.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fvalue.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -671,19 +671,12 @@ func (v *ChanValue) Get() uintptr { return *(*uintptr)(v.addr) }\n \n // implemented in ../pkg/runtime/reflect.cgo\n func makechan(typ *runtime.ChanType, size uint32) (ch *byte)\n-func chansend(ch, val *byte, pres *bool)\n-func chanrecv(ch, val *byte, pres *bool)\n-func chanclosed(ch *byte) bool\n+func chansend(ch, val *byte, selected *bool)\n+func chanrecv(ch, val *byte, selected *bool, ok *bool)\n func chanclose(ch *byte)\n func chanlen(ch *byte) int32\n func chancap(ch *byte) int32\n \n-// Closed returns the result of closed(c) on the underlying channel.\n-func (v *ChanValue) Closed() bool {\n-\tch := *(**byte)(v.addr)\n-\treturn chanclosed(ch)\n-}\n-\n // Close closes the channel.\n func (v *ChanValue) Close() {\n \tch := *(**byte)(v.addr)\n@@ -700,52 +693,61 @@ func (v *ChanValue) Cap() int {\n \treturn int(chancap(ch))\n }\n \n-// internal send; non-blocking if b != nil\n-func (v *ChanValue) send(x Value, b *bool) {\n+// internal send; non-blocking if selected != nil\n+func (v *ChanValue) send(x Value, selected *bool) {\n \tt := v.Type().(*ChanType)\n \tif t.Dir()&SendDir == 0 {\n \t\tpanic(\"send on recv-only channel\")\n \t}\n \ttypesMustMatch(t.Elem(), x.Type())\n \tch := *(**byte)(v.addr)\n-\tchansend(ch, (*byte)(x.getAddr()), b)\n+\tchansend(ch, (*byte)(x.getAddr()), selected)\n }\n \n-// internal recv; non-blocking if b != nil\n-func (v *ChanValue) recv(b *bool) Value {\n+// internal recv; non-blocking if selected != nil\n+func (v *ChanValue) recv(selected *bool) (Value, bool) {\n \tt := v.Type().(*ChanType)\n \tif t.Dir()&RecvDir == 0 {\n \t\tpanic(\"recv on send-only channel\")\n \t}\n \tch := *(**byte)(v.addr)\n \tx := MakeZero(t.Elem())\n-\tchanrecv(ch, (*byte)(x.getAddr()), b)\n-\treturn x\n+\tvar ok bool\n+\tchanrecv(ch, (*byte)(x.getAddr()), selected, &ok)\n+\treturn x, ok\n }\n \n // Send sends x on the channel v.\n func (v *ChanValue) Send(x Value) { v.send(x, nil) }\n \n // Recv receives and returns a value from the channel v.\n-func (v *ChanValue) Recv() Value { return v.recv(nil) }\n+// The receive blocks until a value is ready.\n+// The boolean value ok is true if the value x corresponds to a send\n+// on the channel, false if it is a zero value received because the channel is closed.\n+func (v *ChanValue) Recv() (x Value, ok bool) {\n+\treturn v.recv(nil)\n+}\n \n // TrySend attempts to sends x on the channel v but will not block.\n // It returns true if the value was sent, false otherwise.\n func (v *ChanValue) TrySend(x Value) bool {\n-\tvar ok bool\n-\tv.send(x, &ok)\n-\treturn ok\n+\tvar selected bool\n+\tv.send(x, &selected)\n+\treturn selected\n }\n \n // TryRecv attempts to receive a value from the channel v but will not block.\n-// It returns the value if one is received, nil otherwise.\n-func (v *ChanValue) TryRecv() Value {\n-\tvar ok bool\n-\tx := v.recv(&ok)\n-\tif !ok {\n-\t\treturn nil\n-\t}\n-\treturn x\n+// If the receive cannot finish without blocking, TryRecv instead returns x == nil.\n+// If the receive can finish without blocking, TryRecv returns x != nil.\n+// The boolean value ok is true if the value x corresponds to a send\n+// on the channel, false if it is a zero value received because the channel is closed.\n+func (v *ChanValue) TryRecv() (x Value, ok bool) {\n+\tvar selected bool\n+\tx, ok = v.recv(&selected)\n+\tif !selected {\n+\t\treturn nil, false\n+\t}\n+\treturn x, ok\n }\n \n // MakeChan creates a new channel with the specified type and buffer size."}, {"sha": "92372521175f81c4c1e991a5b6421f88b5b2e004", "filename": "libgo/go/rpc/client.go", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fclient.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -39,8 +39,9 @@ type Call struct {\n // There may be multiple outstanding Calls associated\n // with a single Client.\n type Client struct {\n-\tmutex    sync.Mutex // protects pending, seq\n+\tmutex    sync.Mutex // protects pending, seq, request\n \tsending  sync.Mutex\n+\trequest  Request\n \tseq      uint64\n \tcodec    ClientCodec\n \tpending  map[uint64]*Call\n@@ -79,21 +80,21 @@ func (client *Client) send(c *Call) {\n \tclient.mutex.Unlock()\n \n \t// Encode and send the request.\n-\trequest := new(Request)\n \tclient.sending.Lock()\n \tdefer client.sending.Unlock()\n-\trequest.Seq = c.seq\n-\trequest.ServiceMethod = c.ServiceMethod\n-\tif err := client.codec.WriteRequest(request, c.Args); err != nil {\n+\tclient.request.Seq = c.seq\n+\tclient.request.ServiceMethod = c.ServiceMethod\n+\tif err := client.codec.WriteRequest(&client.request, c.Args); err != nil {\n \t\tpanic(\"rpc: client encode error: \" + err.String())\n \t}\n }\n \n func (client *Client) input() {\n \tvar err os.Error\n+\tvar response Response\n \tfor err == nil {\n-\t\tresponse := new(Response)\n-\t\terr = client.codec.ReadResponseHeader(response)\n+\t\tresponse = Response{}\n+\t\terr = client.codec.ReadResponseHeader(&response)\n \t\tif err != nil {\n \t\t\tif err == os.EOF && !client.closing {\n \t\t\t\terr = io.ErrUnexpectedEOF\n@@ -148,8 +149,12 @@ func (call *Call) done() {\n \n // NewClient returns a new Client to handle requests to the\n // set of services at the other end of the connection.\n+// It adds a buffer to the write side of the connection so\n+// the header and payload are sent as a unit.\n func NewClient(conn io.ReadWriteCloser) *Client {\n-\treturn NewClientWithCodec(&gobClientCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(conn)})\n+\tencBuf := bufio.NewWriter(conn)\n+\tclient := &gobClientCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(encBuf), encBuf}\n+\treturn NewClientWithCodec(client)\n }\n \n // NewClientWithCodec is like NewClient but uses the specified\n@@ -164,16 +169,20 @@ func NewClientWithCodec(codec ClientCodec) *Client {\n }\n \n type gobClientCodec struct {\n-\trwc io.ReadWriteCloser\n-\tdec *gob.Decoder\n-\tenc *gob.Encoder\n+\trwc    io.ReadWriteCloser\n+\tdec    *gob.Decoder\n+\tenc    *gob.Encoder\n+\tencBuf *bufio.Writer\n }\n \n-func (c *gobClientCodec) WriteRequest(r *Request, body interface{}) os.Error {\n-\tif err := c.enc.Encode(r); err != nil {\n-\t\treturn err\n+func (c *gobClientCodec) WriteRequest(r *Request, body interface{}) (err os.Error) {\n+\tif err = c.enc.Encode(r); err != nil {\n+\t\treturn\n+\t}\n+\tif err = c.enc.Encode(body); err != nil {\n+\t\treturn\n \t}\n-\treturn c.enc.Encode(body)\n+\treturn c.encBuf.Flush()\n }\n \n func (c *gobClientCodec) ReadResponseHeader(r *Response) os.Error {\n@@ -273,6 +282,6 @@ func (client *Client) Call(serviceMethod string, args interface{}, reply interfa\n \tif client.shutdown {\n \t\treturn ErrShutdown\n \t}\n-\tcall := <-client.Go(serviceMethod, args, reply, nil).Done\n+\tcall := <-client.Go(serviceMethod, args, reply, make(chan *Call, 1)).Done\n \treturn call.Error\n }"}, {"sha": "1cc8c3173a82ab161e0e158a69a8f7824b96e998", "filename": "libgo/go/rpc/server.go", "status": "modified", "additions": 82, "deletions": 40, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -110,6 +110,7 @@\n package rpc\n \n import (\n+\t\"bufio\"\n \t\"gob\"\n \t\"http\"\n \t\"log\"\n@@ -153,29 +154,29 @@ type service struct {\n // but documented here as an aid to debugging, such as when analyzing\n // network traffic.\n type Request struct {\n-\tServiceMethod string // format: \"Service.Method\"\n-\tSeq           uint64 // sequence number chosen by client\n+\tServiceMethod string   // format: \"Service.Method\"\n+\tSeq           uint64   // sequence number chosen by client\n+\tnext          *Request // for free list in Server\n }\n \n // Response is a header written before every RPC return.  It is used internally\n // but documented here as an aid to debugging, such as when analyzing\n // network traffic.\n type Response struct {\n-\tServiceMethod string // echoes that of the Request\n-\tSeq           uint64 // echoes that of the request\n-\tError         string // error, if any.\n-}\n-\n-// ClientInfo records information about an RPC client connection.\n-type ClientInfo struct {\n-\tLocalAddr  string\n-\tRemoteAddr string\n+\tServiceMethod string    // echoes that of the Request\n+\tSeq           uint64    // echoes that of the request\n+\tError         string    // error, if any.\n+\tnext          *Response // for free list in Server\n }\n \n // Server represents an RPC Server.\n type Server struct {\n \tsync.Mutex // protects the serviceMap\n \tserviceMap map[string]*service\n+\treqLock    sync.Mutex // protects freeReq\n+\tfreeReq    *Request\n+\trespLock   sync.Mutex // protects freeResp\n+\tfreeResp   *Response\n }\n \n // NewServer returns a new Server.\n@@ -269,13 +270,6 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) os.E\n \t\t\tlog.Println(mname, \"reply type not exported:\", replyType)\n \t\t\tcontinue\n \t\t}\n-\t\tif mtype.NumIn() == 4 {\n-\t\t\tt := mtype.In(3)\n-\t\t\tif t != reflect.Typeof((*ClientInfo)(nil)) {\n-\t\t\t\tlog.Println(mname, \"last argument not *ClientInfo\")\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t}\n \t\t// Method needs one out: os.Error.\n \t\tif mtype.NumOut() != 1 {\n \t\t\tlog.Println(\"method\", mname, \"has wrong number of outs:\", mtype.NumOut())\n@@ -298,9 +292,7 @@ func (server *Server) register(rcvr interface{}, name string, useName bool) os.E\n }\n \n // A value sent as a placeholder for the response when the server receives an invalid request.\n-type InvalidRequest struct {\n-\tMarker int\n-}\n+type InvalidRequest struct{}\n \n var invalidRequest = InvalidRequest{}\n \n@@ -310,8 +302,8 @@ func _new(t *reflect.PtrType) *reflect.PtrValue {\n \treturn v\n }\n \n-func sendResponse(sending *sync.Mutex, req *Request, reply interface{}, codec ServerCodec, errmsg string) {\n-\tresp := new(Response)\n+func (server *Server) sendResponse(sending *sync.Mutex, req *Request, reply interface{}, codec ServerCodec, errmsg string) {\n+\tresp := server.getResponse()\n \t// Encode the response header\n \tresp.ServiceMethod = req.ServiceMethod\n \tif errmsg != \"\" {\n@@ -325,6 +317,7 @@ func sendResponse(sending *sync.Mutex, req *Request, reply interface{}, codec Se\n \t\tlog.Println(\"rpc: writing response:\", err)\n \t}\n \tsending.Unlock()\n+\tserver.freeResponse(resp)\n }\n \n func (m *methodType) NumCalls() (n uint) {\n@@ -334,7 +327,7 @@ func (m *methodType) NumCalls() (n uint) {\n \treturn n\n }\n \n-func (s *service) call(sending *sync.Mutex, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec) {\n+func (s *service) call(server *Server, sending *sync.Mutex, mtype *methodType, req *Request, argv, replyv reflect.Value, codec ServerCodec) {\n \tmtype.Lock()\n \tmtype.numCalls++\n \tmtype.Unlock()\n@@ -347,13 +340,15 @@ func (s *service) call(sending *sync.Mutex, mtype *methodType, req *Request, arg\n \tif errInter != nil {\n \t\terrmsg = errInter.(os.Error).String()\n \t}\n-\tsendResponse(sending, req, replyv.Interface(), codec, errmsg)\n+\tserver.sendResponse(sending, req, replyv.Interface(), codec, errmsg)\n+\tserver.freeRequest(req)\n }\n \n type gobServerCodec struct {\n-\trwc io.ReadWriteCloser\n-\tdec *gob.Decoder\n-\tenc *gob.Encoder\n+\trwc    io.ReadWriteCloser\n+\tdec    *gob.Decoder\n+\tenc    *gob.Encoder\n+\tencBuf *bufio.Writer\n }\n \n func (c *gobServerCodec) ReadRequestHeader(r *Request) os.Error {\n@@ -364,11 +359,14 @@ func (c *gobServerCodec) ReadRequestBody(body interface{}) os.Error {\n \treturn c.dec.Decode(body)\n }\n \n-func (c *gobServerCodec) WriteResponse(r *Response, body interface{}) os.Error {\n-\tif err := c.enc.Encode(r); err != nil {\n-\t\treturn err\n+func (c *gobServerCodec) WriteResponse(r *Response, body interface{}) (err os.Error) {\n+\tif err = c.enc.Encode(r); err != nil {\n+\t\treturn\n+\t}\n+\tif err = c.enc.Encode(body); err != nil {\n+\t\treturn\n \t}\n-\treturn c.enc.Encode(body)\n+\treturn c.encBuf.Flush()\n }\n \n func (c *gobServerCodec) Close() os.Error {\n@@ -382,7 +380,9 @@ func (c *gobServerCodec) Close() os.Error {\n // ServeConn uses the gob wire format (see package gob) on the\n // connection.  To use an alternate codec, use ServeCodec.\n func (server *Server) ServeConn(conn io.ReadWriteCloser) {\n-\tserver.ServeCodec(&gobServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(conn)})\n+\tbuf := bufio.NewWriter(conn)\n+\tsrv := &gobServerCodec{conn, gob.NewDecoder(conn), gob.NewEncoder(buf), buf}\n+\tserver.ServeCodec(srv)\n }\n \n // ServeCodec is like ServeConn but uses the specified codec to\n@@ -403,7 +403,8 @@ func (server *Server) ServeCodec(codec ServerCodec) {\n \n \t\t\t// send a response if we actually managed to read a header.\n \t\t\tif req != nil {\n-\t\t\t\tsendResponse(sending, req, invalidRequest, codec, err.String())\n+\t\t\t\tserver.sendResponse(sending, req, invalidRequest, codec, err.String())\n+\t\t\t\tserver.freeRequest(req)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n@@ -419,16 +420,57 @@ func (server *Server) ServeCodec(codec ServerCodec) {\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tsendResponse(sending, req, replyv.Interface(), codec, err.String())\n+\t\t\tserver.sendResponse(sending, req, replyv.Interface(), codec, err.String())\n \t\t\tcontinue\n \t\t}\n-\t\tgo service.call(sending, mtype, req, argv, replyv, codec)\n+\t\tgo service.call(server, sending, mtype, req, argv, replyv, codec)\n \t}\n \tcodec.Close()\n }\n+\n+func (server *Server) getRequest() *Request {\n+\tserver.reqLock.Lock()\n+\treq := server.freeReq\n+\tif req == nil {\n+\t\treq = new(Request)\n+\t} else {\n+\t\tserver.freeReq = req.next\n+\t\t*req = Request{}\n+\t}\n+\tserver.reqLock.Unlock()\n+\treturn req\n+}\n+\n+func (server *Server) freeRequest(req *Request) {\n+\tserver.reqLock.Lock()\n+\treq.next = server.freeReq\n+\tserver.freeReq = req\n+\tserver.reqLock.Unlock()\n+}\n+\n+func (server *Server) getResponse() *Response {\n+\tserver.respLock.Lock()\n+\tresp := server.freeResp\n+\tif resp == nil {\n+\t\tresp = new(Response)\n+\t} else {\n+\t\tserver.freeResp = resp.next\n+\t\t*resp = Response{}\n+\t}\n+\tserver.respLock.Unlock()\n+\treturn resp\n+}\n+\n+func (server *Server) freeResponse(resp *Response) {\n+\tserver.respLock.Lock()\n+\tresp.next = server.freeResp\n+\tserver.freeResp = resp\n+\tserver.respLock.Unlock()\n+}\n+\n func (server *Server) readRequest(codec ServerCodec) (req *Request, service *service, mtype *methodType, err os.Error) {\n \t// Grab the request header.\n-\treq = new(Request)\n+\treq = server.getRequest()\n \terr = codec.ReadRequestHeader(req)\n \tif err != nil {\n \t\treq = nil\n@@ -522,14 +564,14 @@ var connected = \"200 Connected to Go RPC\"\n // ServeHTTP implements an http.Handler that answers RPC requests.\n func (server *Server) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \tif req.Method != \"CONNECT\" {\n-\t\tw.SetHeader(\"Content-Type\", \"text/plain; charset=utf-8\")\n+\t\tw.Header().Set(\"Content-Type\", \"text/plain; charset=utf-8\")\n \t\tw.WriteHeader(http.StatusMethodNotAllowed)\n \t\tio.WriteString(w, \"405 must CONNECT\\n\")\n \t\treturn\n \t}\n-\tconn, _, err := w.Hijack()\n+\tconn, _, err := w.(http.Hijacker).Hijack()\n \tif err != nil {\n-\t\tlog.Print(\"rpc hijacking \", w.RemoteAddr(), \": \", err.String())\n+\t\tlog.Print(\"rpc hijacking \", req.RemoteAddr, \": \", err.String())\n \t\treturn\n \t}\n \tio.WriteString(conn, \"HTTP/1.0 \"+connected+\"\\n\\n\")"}, {"sha": "d4041ae70ce8ac406c6fff5eb5c0e04c3aa039cf", "filename": "libgo/go/rpc/server_test.go", "status": "modified", "additions": 55, "deletions": 7, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Frpc%2Fserver_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,10 +6,11 @@ package rpc\n \n import (\n \t\"fmt\"\n-\t\"http\"\n+\t\"http/httptest\"\n \t\"log\"\n \t\"net\"\n \t\"os\"\n+\t\"runtime\"\n \t\"strings\"\n \t\"sync\"\n \t\"testing\"\n@@ -103,11 +104,9 @@ func startNewServer() {\n }\n \n func startHttpServer() {\n-\tvar l net.Listener\n-\tl, httpServerAddr = listenTCP()\n-\thttpServerAddr = l.Addr().String()\n+\tserver := httptest.NewServer(nil)\n+\thttpServerAddr = server.Listener.Addr().String()\n \tlog.Println(\"Test HTTP RPC server listening on\", httpServerAddr)\n-\tgo http.Serve(l, nil)\n }\n \n func TestRPC(t *testing.T) {\n@@ -313,12 +312,12 @@ func (WriteFailCodec) WriteRequest(*Request, interface{}) os.Error {\n }\n \n func (WriteFailCodec) ReadResponseHeader(*Response) os.Error {\n-\ttime.Sleep(60e9)\n+\ttime.Sleep(120e9)\n \tpanic(\"unreachable\")\n }\n \n func (WriteFailCodec) ReadResponseBody(interface{}) os.Error {\n-\ttime.Sleep(60e9)\n+\ttime.Sleep(120e9)\n \tpanic(\"unreachable\")\n }\n \n@@ -351,3 +350,52 @@ func testSendDeadlock(client *Client) {\n \treply := new(Reply)\n \tclient.Call(\"Arith.Add\", args, reply)\n }\n+\n+func TestCountMallocs(t *testing.T) {\n+\tonce.Do(startServer)\n+\tclient, err := Dial(\"tcp\", serverAddr)\n+\tif err != nil {\n+\t\tt.Error(\"error dialing\", err)\n+\t}\n+\targs := &Args{7, 8}\n+\treply := new(Reply)\n+\tmallocs := 0 - runtime.MemStats.Mallocs\n+\tconst count = 100\n+\tfor i := 0; i < count; i++ {\n+\t\terr = client.Call(\"Arith.Add\", args, reply)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"Add: expected no error but got string %q\", err.String())\n+\t\t}\n+\t\tif reply.C != args.A+args.B {\n+\t\t\tt.Errorf(\"Add: expected %d got %d\", reply.C, args.A+args.B)\n+\t\t}\n+\t}\n+\tmallocs += runtime.MemStats.Mallocs\n+\tfmt.Printf(\"mallocs per rpc round trip: %d\\n\", mallocs/count)\n+}\n+\n+func BenchmarkEndToEnd(b *testing.B) {\n+\tb.StopTimer()\n+\tonce.Do(startServer)\n+\tclient, err := Dial(\"tcp\", serverAddr)\n+\tif err != nil {\n+\t\tfmt.Println(\"error dialing\", err)\n+\t\treturn\n+\t}\n+\n+\t// Synchronous calls\n+\targs := &Args{7, 8}\n+\treply := new(Reply)\n+\tb.StartTimer()\n+\tfor i := 0; i < b.N; i++ {\n+\t\terr = client.Call(\"Arith.Add\", args, reply)\n+\t\tif err != nil {\n+\t\t\tfmt.Printf(\"Add: expected no error but got string %q\", err.String())\n+\t\t\tbreak\n+\t\t}\n+\t\tif reply.C != args.A+args.B {\n+\t\t\tfmt.Printf(\"Add: expected %d got %d\", reply.C, args.A+args.B)\n+\t\t\tbreak\n+\t\t}\n+\t}\n+}"}, {"sha": "6370a57d8029a31de8b06b83e823d13e0a6d6ca0", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 20, "deletions": 64, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -4,8 +4,6 @@\n \n package runtime\n \n-import \"unsafe\"\n-\n // Breakpoint() executes a breakpoint trap.\n func Breakpoint()\n \n@@ -31,65 +29,6 @@ func Cgocalls() int64\n // Goroutines returns the number of goroutines that currently exist.\n func Goroutines() int32\n \n-type MemStatsType struct {\n-\t// General statistics.\n-\t// Not locked during update; approximate.\n-\tAlloc      uint64 // bytes allocated and still in use\n-\tTotalAlloc uint64 // bytes allocated (even if freed)\n-\tSys        uint64 // bytes obtained from system (should be sum of XxxSys below)\n-\tLookups    uint64 // number of pointer lookups\n-\tMallocs    uint64 // number of mallocs\n-\tFrees      uint64 // number of frees\n-\n-\t// Main allocation heap statistics.\n-\tHeapAlloc   uint64 // bytes allocated and still in use\n-\tHeapSys     uint64 // bytes obtained from system\n-\tHeapIdle    uint64 // bytes in idle spans\n-\tHeapInuse   uint64 // bytes in non-idle span\n-\tHeapObjects uint64 // total number of allocated objects\n-\n-\t// Low-level fixed-size structure allocator statistics.\n-\t//\tInuse is bytes used now.\n-\t//\tSys is bytes obtained from system.\n-\tStackInuse  uint64 // bootstrap stacks\n-\tStackSys    uint64\n-\tMSpanInuse  uint64 // mspan structures\n-\tMSpanSys    uint64\n-\tMCacheInuse uint64 // mcache structures\n-\tMCacheSys   uint64\n-\tBuckHashSys uint64 // profiling bucket hash table\n-\n-\t// Garbage collector statistics.\n-\tNextGC       uint64\n-\tPauseTotalNs uint64\n-\tPauseNs      [256]uint64 // most recent GC pause times\n-\tNumGC        uint32\n-\tEnableGC     bool\n-\tDebugGC      bool\n-\n-\t// Per-size allocation statistics.\n-\t// Not locked during update; approximate.\n-\t// 61 is NumSizeClasses in the C code.\n-\tBySize [61]struct {\n-\t\tSize    uint32\n-\t\tMallocs uint64\n-\t\tFrees   uint64\n-\t}\n-}\n-\n-var Sizeof_C_MStats int // filled in by malloc.goc\n-\n-func init() {\n-\tif Sizeof_C_MStats != unsafe.Sizeof(MemStats) {\n-\t\tprintln(Sizeof_C_MStats, unsafe.Sizeof(MemStats))\n-\t\tpanic(\"MStats vs MemStatsType size mismatch\")\n-\t}\n-}\n-\n-// MemStats holds statistics about the memory system.\n-// The statistics are only approximate, as they are not interlocked on update.\n-var MemStats MemStatsType\n-\n // Alloc allocates a block of the given size.\n // FOR TESTING AND DEBUGGING ONLY.\n func Alloc(uintptr) *byte\n@@ -102,9 +41,6 @@ func Free(*byte)\n // FOR TESTING AND DEBUGGING ONLY.\n func Lookup(*byte) (*byte, uintptr)\n \n-// GC runs a garbage collection.\n-func GC()\n-\n // MemProfileRate controls the fraction of memory allocations\n // that are recorded and reported in the memory profile.\n // The profiler aims to sample an average of\n@@ -156,4 +92,24 @@ func (r *MemProfileRecord) Stack() []uintptr {\n // where r.AllocBytes > 0 but r.AllocBytes == r.FreeBytes.\n // These are sites where memory was allocated, but it has all\n // been released back to the runtime.\n+// Most clients should use the runtime/pprof package or\n+// the testing package's -test.memprofile flag instead\n+// of calling MemProfile directly.\n func MemProfile(p []MemProfileRecord, inuseZero bool) (n int, ok bool)\n+\n+// CPUProfile returns the next chunk of binary CPU profiling stack trace data,\n+// blocking until data is available.  If profiling is turned off and all the profile\n+// data accumulated while it was on has been returned, CPUProfile returns nil.\n+// The caller must save the returned data before calling CPUProfile again.\n+// Most clients should use the runtime/pprof package or\n+// the testing package's -test.cpuprofile flag instead of calling\n+// CPUProfile directly.\n+func CPUProfile() []byte\n+\n+// SetCPUProfileRate sets the CPU profiling rate to hz samples per second.\n+// If hz <= 0, SetCPUProfileRate turns off profiling.\n+// If the profiler is on, the rate cannot be changed without first turning it off.\n+// Most clients should use the runtime/pprof package or\n+// the testing package's -test.cpuprofile flag instead of calling\n+// SetCPUProfileRate directly.\n+func SetCPUProfileRate(hz int)"}, {"sha": "2fc1892a10bf48287235d0cc4a6cec547b66e038", "filename": "libgo/go/runtime/mem.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fmem.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fmem.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fmem.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package runtime\n+\n+import \"unsafe\"\n+\n+type MemStatsType struct {\n+\t// General statistics.\n+\t// Not locked during update; approximate.\n+\tAlloc      uint64 // bytes allocated and still in use\n+\tTotalAlloc uint64 // bytes allocated (even if freed)\n+\tSys        uint64 // bytes obtained from system (should be sum of XxxSys below)\n+\tLookups    uint64 // number of pointer lookups\n+\tMallocs    uint64 // number of mallocs\n+\tFrees      uint64 // number of frees\n+\n+\t// Main allocation heap statistics.\n+\tHeapAlloc   uint64 // bytes allocated and still in use\n+\tHeapSys     uint64 // bytes obtained from system\n+\tHeapIdle    uint64 // bytes in idle spans\n+\tHeapInuse   uint64 // bytes in non-idle span\n+\tHeapObjects uint64 // total number of allocated objects\n+\n+\t// Low-level fixed-size structure allocator statistics.\n+\t//\tInuse is bytes used now.\n+\t//\tSys is bytes obtained from system.\n+\tStackInuse  uint64 // bootstrap stacks\n+\tStackSys    uint64\n+\tMSpanInuse  uint64 // mspan structures\n+\tMSpanSys    uint64\n+\tMCacheInuse uint64 // mcache structures\n+\tMCacheSys   uint64\n+\tBuckHashSys uint64 // profiling bucket hash table\n+\n+\t// Garbage collector statistics.\n+\tNextGC       uint64\n+\tPauseTotalNs uint64\n+\tPauseNs      [256]uint64 // most recent GC pause times\n+\tNumGC        uint32\n+\tEnableGC     bool\n+\tDebugGC      bool\n+\n+\t// Per-size allocation statistics.\n+\t// Not locked during update; approximate.\n+\t// 61 is NumSizeClasses in the C code.\n+\tBySize [61]struct {\n+\t\tSize    uint32\n+\t\tMallocs uint64\n+\t\tFrees   uint64\n+\t}\n+}\n+\n+var Sizeof_C_MStats int // filled in by malloc.goc\n+\n+func init() {\n+\tif Sizeof_C_MStats != unsafe.Sizeof(MemStats) {\n+\t\tprintln(Sizeof_C_MStats, unsafe.Sizeof(MemStats))\n+\t\tpanic(\"MStats vs MemStatsType size mismatch\")\n+\t}\n+}\n+\n+// MemStats holds statistics about the memory system.\n+// The statistics are only approximate, as they are not interlocked on update.\n+var MemStats MemStatsType\n+\n+// GC runs a garbage collection.\n+func GC()"}, {"sha": "fdeceb4e8dc6747e612615f92c38cceccc188b8b", "filename": "libgo/go/runtime/pprof/pprof.go", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -14,6 +14,7 @@ import (\n \t\"io\"\n \t\"os\"\n \t\"runtime\"\n+\t\"sync\"\n )\n \n // WriteHeapProfile writes a pprof-formatted heap profile to w.\n@@ -105,3 +106,71 @@ func WriteHeapProfile(w io.Writer) os.Error {\n \t}\n \treturn b.Flush()\n }\n+\n+var cpu struct {\n+\tsync.Mutex\n+\tprofiling bool\n+\tdone      chan bool\n+}\n+\n+// StartCPUProfile enables CPU profiling for the current process.\n+// While profiling, the profile will be buffered and written to w.\n+// StartCPUProfile returns an error if profiling is already enabled.\n+func StartCPUProfile(w io.Writer) os.Error {\n+\t// The runtime routines allow a variable profiling rate,\n+\t// but in practice operating systems cannot trigger signals\n+\t// at more than about 500 Hz, and our processing of the\n+\t// signal is not cheap (mostly getting the stack trace).\n+\t// 100 Hz is a reasonable choice: it is frequent enough to\n+\t// produce useful data, rare enough not to bog down the\n+\t// system, and a nice round number to make it easy to\n+\t// convert sample counts to seconds.  Instead of requiring\n+\t// each client to specify the frequency, we hard code it.\n+\tconst hz = 100\n+\n+\t// Avoid queueing behind StopCPUProfile.\n+\t// Could use TryLock instead if we had it.\n+\tif cpu.profiling {\n+\t\treturn fmt.Errorf(\"cpu profiling already in use\")\n+\t}\n+\n+\tcpu.Lock()\n+\tdefer cpu.Unlock()\n+\tif cpu.done == nil {\n+\t\tcpu.done = make(chan bool)\n+\t}\n+\t// Double-check.\n+\tif cpu.profiling {\n+\t\treturn fmt.Errorf(\"cpu profiling already in use\")\n+\t}\n+\tcpu.profiling = true\n+\truntime.SetCPUProfileRate(hz)\n+\tgo profileWriter(w)\n+\treturn nil\n+}\n+\n+func profileWriter(w io.Writer) {\n+\tfor {\n+\t\tdata := runtime.CPUProfile()\n+\t\tif data == nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tw.Write(data)\n+\t}\n+\tcpu.done <- true\n+}\n+\n+// StopCPUProfile stops the current CPU profile, if any.\n+// StopCPUProfile only returns after all the writes for the\n+// profile have completed.\n+func StopCPUProfile() {\n+\tcpu.Lock()\n+\tdefer cpu.Unlock()\n+\n+\tif !cpu.profiling {\n+\t\treturn\n+\t}\n+\tcpu.profiling = false\n+\truntime.SetCPUProfileRate(0)\n+\t<-cpu.done\n+}"}, {"sha": "603465eaa521c58b072726df89de3064d9d1e88d", "filename": "libgo/go/runtime/pprof/pprof_test.go", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fpprof%2Fpprof_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,69 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package pprof_test\n+\n+import (\n+\t\"bytes\"\n+\t\"hash/crc32\"\n+\t\"runtime\"\n+\t. \"runtime/pprof\"\n+\t\"strings\"\n+\t\"testing\"\n+\t\"unsafe\"\n+)\n+\n+func TestCPUProfile(t *testing.T) {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n+\t\treturn\n+\t}\n+\n+\tbuf := make([]byte, 100000)\n+\tvar prof bytes.Buffer\n+\tif err := StartCPUProfile(&prof); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\t// This loop takes about a quarter second on a 2 GHz laptop.\n+\t// We only need to get one 100 Hz clock tick, so we've got\n+\t// a 25x safety buffer.\n+\tfor i := 0; i < 1000; i++ {\n+\t\tcrc32.ChecksumIEEE(buf)\n+\t}\n+\tStopCPUProfile()\n+\n+\t// Convert []byte to []uintptr.\n+\tbytes := prof.Bytes()\n+\tval := *(*[]uintptr)(unsafe.Pointer(&bytes))\n+\tval = val[:len(bytes)/unsafe.Sizeof(uintptr(0))]\n+\n+\tif len(val) < 10 {\n+\t\tt.Fatalf(\"profile too short: %#x\", val)\n+\t}\n+\tif val[0] != 0 || val[1] != 3 || val[2] != 0 || val[3] != 1e6/100 || val[4] != 0 {\n+\t\tt.Fatalf(\"unexpected header %#x\", val[:5])\n+\t}\n+\n+\t// Check that profile is well formed and contains ChecksumIEEE.\n+\tfound := false\n+\tval = val[5:]\n+\tfor len(val) > 0 {\n+\t\tif len(val) < 2 || val[0] < 1 || val[1] < 1 || uintptr(len(val)) < 2+val[1] {\n+\t\t\tt.Fatalf(\"malformed profile.  leftover: %#x\", val)\n+\t\t}\n+\t\tfor _, pc := range val[2 : 2+val[1]] {\n+\t\t\tf := runtime.FuncForPC(pc)\n+\t\t\tif f == nil {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif strings.Contains(f.Name(), \"ChecksumIEEE\") {\n+\t\t\t\tfound = true\n+\t\t\t}\n+\t\t}\n+\t\tval = val[2+val[1]:]\n+\t}\n+\n+\tif !found {\n+\t\tt.Fatal(\"did not find ChecksumIEEE in the profile\")\n+\t}\n+}"}, {"sha": "5f009e54859146fb2d17345686758006d496277b", "filename": "libgo/go/strings/strings.go", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fstrings%2Fstrings.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fstrings%2Fstrings.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -119,9 +119,19 @@ func LastIndex(s, sep string) int {\n // IndexRune returns the index of the first instance of the Unicode code point\n // rune, or -1 if rune is not present in s.\n func IndexRune(s string, rune int) int {\n-\tfor i, c := range s {\n-\t\tif c == rune {\n-\t\t\treturn i\n+\tswitch {\n+\tcase rune < 0x80:\n+\t\tb := byte(rune)\n+\t\tfor i := 0; i < len(s); i++ {\n+\t\t\tif s[i] == b {\n+\t\t\t\treturn i\n+\t\t\t}\n+\t\t}\n+\tdefault:\n+\t\tfor i, c := range s {\n+\t\t\tif c == rune {\n+\t\t\t\treturn i\n+\t\t\t}\n \t\t}\n \t}\n \treturn -1"}, {"sha": "41e398782e686d6c60ef785de276106973a6dd6e", "filename": "libgo/go/strings/strings_test.go", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fstrings%2Fstrings_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrings%2Fstrings_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,6 +6,7 @@ package strings_test\n \n import (\n \t\"os\"\n+\t\"strconv\"\n \t. \"strings\"\n \t\"testing\"\n \t\"unicode\"\n@@ -116,6 +117,57 @@ func TestLastIndex(t *testing.T)    { runIndexTests(t, LastIndex, \"LastIndex\", l\n func TestIndexAny(t *testing.T)     { runIndexTests(t, IndexAny, \"IndexAny\", indexAnyTests) }\n func TestLastIndexAny(t *testing.T) { runIndexTests(t, LastIndexAny, \"LastIndexAny\", lastIndexAnyTests) }\n \n+type IndexRuneTest struct {\n+\ts    string\n+\trune int\n+\tout  int\n+}\n+\n+var indexRuneTests = []IndexRuneTest{\n+\t{\"a A x\", 'A', 2},\n+\t{\"some_text=some_value\", '=', 9},\n+\t{\"\u263aa\", 'a', 3},\n+\t{\"a\u263b\u263ab\", '\u263a', 4},\n+}\n+\n+func TestIndexRune(t *testing.T) {\n+\tfor _, test := range indexRuneTests {\n+\t\tif actual := IndexRune(test.s, test.rune); actual != test.out {\n+\t\t\tt.Errorf(\"IndexRune(%q,%d)= %v; want %v\", test.s, test.rune, actual, test.out)\n+\t\t}\n+\t}\n+}\n+\n+const benchmarkString = \"some_text=some\u263avalue\"\n+\n+func BenchmarkIndexRune(b *testing.B) {\n+\tif got := IndexRune(benchmarkString, '\u263a'); got != 14 {\n+\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tIndexRune(benchmarkString, '\u263a')\n+\t}\n+}\n+\n+func BenchmarkIndexRuneFastPath(b *testing.B) {\n+\tif got := IndexRune(benchmarkString, 'v'); got != 17 {\n+\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tIndexRune(benchmarkString, 'v')\n+\t}\n+}\n+\n+func BenchmarkIndex(b *testing.B) {\n+\tif got := Index(benchmarkString, \"v\"); got != 17 {\n+\t\tpanic(\"wrong index: got=\" + strconv.Itoa(got))\n+\t}\n+\tfor i := 0; i < b.N; i++ {\n+\t\tIndex(benchmarkString, \"v\")\n+\t}\n+}\n+\n+\n type ExplodeTest struct {\n \ts string\n \tn int"}, {"sha": "05478c630667eb705515e91305b331a850d49c45", "filename": "libgo/go/sync/waitgroup.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fsync%2Fwaitgroup.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsync%2Fwaitgroup.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -22,7 +22,7 @@ import \"runtime\"\n //       go func() {\n //           // Do something.\n //           wg.Done()\n-//       }\n+//       }()\n //   }\n //   wg.Wait()\n // "}, {"sha": "ba06de4e3ab024cbff8ddb72d5c8a3230f584426", "filename": "libgo/go/template/template.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftemplate%2Ftemplate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftemplate%2Ftemplate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftemplate%2Ftemplate.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -267,7 +267,6 @@ func (t *Template) nextItem() []byte {\n \t}\n \tleadingSpace := i > start\n \t// What's left is nothing, newline, delimited string, or plain text\n-Switch:\n \tswitch {\n \tcase i == len(t.buf):\n \t\t// EOF; nothing to do\n@@ -896,8 +895,8 @@ func (t *Template) executeRepeated(r *repeatedElement, st *state) {\n \t\t}\n \t} else if ch := iter(field); ch != nil {\n \t\tfor {\n-\t\t\te := ch.Recv()\n-\t\t\tif ch.Closed() {\n+\t\t\te, ok := ch.Recv()\n+\t\t\tif !ok {\n \t\t\t\tbreak\n \t\t\t}\n \t\t\tloopBody(st.clone(e))"}, {"sha": "b341b1f896b98e1e29daa319ade2289a73aa06bb", "filename": "libgo/go/testing/script/script.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fscript%2Fscript.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -306,8 +306,8 @@ func recvValues(multiplex chan<- interface{}, channel interface{}) {\n \tc := reflect.NewValue(channel).(*reflect.ChanValue)\n \n \tfor {\n-\t\tv := c.Recv()\n-\t\tif c.Closed() {\n+\t\tv, ok := c.Recv()\n+\t\tif !ok {\n \t\t\tmultiplex <- channelClosed{channel}\n \t\t\treturn\n \t\t}"}, {"sha": "ab8cf999a2564dd6c3d7c0b4f74f79bc60218e5c", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 57, "deletions": 4, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -43,12 +43,18 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"runtime\"\n+\t\"runtime/pprof\"\n \t\"time\"\n )\n \n-// Report as tests are run; default is silent for success.\n-var chatty = flag.Bool(\"test.v\", false, \"verbose: print additional output\")\n-var match = flag.String(\"test.run\", \"\", \"regular expression to select tests to run\")\n+var (\n+\t// Report as tests are run; default is silent for success.\n+\tchatty         = flag.Bool(\"test.v\", false, \"verbose: print additional output\")\n+\tmatch          = flag.String(\"test.run\", \"\", \"regular expression to select tests to run\")\n+\tmemProfile     = flag.String(\"test.memprofile\", \"\", \"write a memory profile to the named file after execution\")\n+\tmemProfileRate = flag.Int(\"test.memprofilerate\", 0, \"if >=0, sets runtime.MemProfileRate\")\n+\tcpuProfile     = flag.String(\"test.cpuprofile\", \"\", \"write a cpu profile to the named file during execution\")\n+)\n \n \n // Insert final newline if needed and tabs after internal newlines.\n@@ -136,8 +142,16 @@ func tRunner(t *T, test *InternalTest) {\n \n // An internal function but exported because it is cross-package; part of the implementation\n // of gotest.\n-func Main(matchString func(pat, str string) (bool, os.Error), tests []InternalTest) {\n+func Main(matchString func(pat, str string) (bool, os.Error), tests []InternalTest, benchmarks []InternalBenchmark) {\n \tflag.Parse()\n+\n+\tbefore()\n+\tRunTests(matchString, tests)\n+\tRunBenchmarks(matchString, benchmarks)\n+\tafter()\n+}\n+\n+func RunTests(matchString func(pat, str string) (bool, os.Error), tests []InternalTest) {\n \tok := true\n \tif len(tests) == 0 {\n \t\tprintln(\"testing: warning: no tests to run\")\n@@ -176,3 +190,42 @@ func Main(matchString func(pat, str string) (bool, os.Error), tests []InternalTe\n \t}\n \tprintln(\"PASS\")\n }\n+\n+// before runs before all testing.\n+func before() {\n+\tif *memProfileRate > 0 {\n+\t\truntime.MemProfileRate = *memProfileRate\n+\t}\n+\tif *cpuProfile != \"\" {\n+\t\tf, err := os.Open(*cpuProfile, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0666)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif err := pprof.StartCPUProfile(f); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't start cpu profile: %s\", err)\n+\t\t\tf.Close()\n+\t\t\treturn\n+\t\t}\n+\t\t// Could save f so after can call f.Close; not worth the effort.\n+\t}\n+\n+}\n+\n+// after runs after all testing.\n+func after() {\n+\tif *cpuProfile != \"\" {\n+\t\tpprof.StopCPUProfile() // flushes profile to disk\n+\t}\n+\tif *memProfile != \"\" {\n+\t\tf, err := os.Open(*memProfile, os.O_WRONLY|os.O_CREAT|os.O_TRUNC, 0666)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: %s\", err)\n+\t\t\treturn\n+\t\t}\n+\t\tif err = pprof.WriteHeapProfile(f); err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"testing: can't write %s: %s\", *memProfile, err)\n+\t\t}\n+\t\tf.Close()\n+\t}\n+}"}, {"sha": "3bc253c94a3908c891bdd6da4bb9093fa68f7d18", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 2, "deletions": 28, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -5,10 +5,8 @@\n package time\n \n import (\n-\t\"os\"\n-\t\"syscall\"\n-\t\"sync\"\n \t\"container/heap\"\n+\t\"sync\"\n )\n \n // The Timer type represents a single event.\n@@ -47,30 +45,6 @@ func init() {\n \ttimers.Push(&Timer{t: forever}) // sentinel\n }\n \n-// Sleep pauses the current goroutine for at least ns nanoseconds.\n-// Higher resolution sleeping may be provided by syscall.Nanosleep \n-// on some operating systems.\n-func Sleep(ns int64) os.Error {\n-\t_, err := sleep(Nanoseconds(), ns)\n-\treturn err\n-}\n-\n-// sleep takes the current time and a duration,\n-// pauses for at least ns nanoseconds, and\n-// returns the current time and an error.\n-func sleep(t, ns int64) (int64, os.Error) {\n-\t// TODO(cw): use monotonic-time once it's available\n-\tend := t + ns\n-\tfor t < end {\n-\t\terrno := syscall.Sleep(end - t)\n-\t\tif errno != 0 && errno != syscall.EINTR {\n-\t\t\treturn 0, os.NewSyscallError(\"sleep\", errno)\n-\t\t}\n-\t\tt = Nanoseconds()\n-\t}\n-\treturn t, nil\n-}\n-\n // NewTimer creates a new Timer that will send\n // the current time on its channel after at least ns nanoseconds.\n func NewTimer(ns int64) *Timer {\n@@ -151,7 +125,7 @@ func sleeper(sleeperId int64) {\n \t\t\t\tdt = maxSleepTime\n \t\t\t}\n \t\t\ttimerMutex.Unlock()\n-\t\t\tsyscall.Sleep(dt)\n+\t\t\tsysSleep(dt)\n \t\t\ttimerMutex.Lock()\n \t\t\tif currentSleeper != sleeperId {\n \t\t\t\t// Another sleeper has been started, making this one redundant."}, {"sha": "5fe4d7f15b5c3eff3d1b55c71048d04b5ce726ba", "filename": "libgo/go/time/sleep_test.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsleep_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsleep_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -132,7 +132,9 @@ func TestAfterStop(t *testing.T) {\n \t}\n }\n \n-var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8, 0}\n+// For gccgo omit 0 for now because it can take too long to start the\n+// thread.\n+var slots = []int{5, 3, 6, 6, 6, 1, 1, 2, 7, 9, 4, 8, /*0*/}\n \n type afterResult struct {\n \tslot int"}, {"sha": "63f4cbf3d7795f2805b5d240a3e9cd164479b975", "filename": "libgo/go/time/sys.go", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Fsys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsys.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -0,0 +1,62 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package time\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Seconds reports the number of seconds since the Unix epoch,\n+// January 1, 1970 00:00:00 UTC.\n+func Seconds() int64 {\n+\tsec, _, err := os.Time()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn sec\n+}\n+\n+// Nanoseconds reports the number of nanoseconds since the Unix epoch,\n+// January 1, 1970 00:00:00 UTC.\n+func Nanoseconds() int64 {\n+\tsec, nsec, err := os.Time()\n+\tif err != nil {\n+\t\tpanic(err)\n+\t}\n+\treturn sec*1e9 + nsec\n+}\n+\n+// Sleep pauses the current goroutine for at least ns nanoseconds.\n+// Higher resolution sleeping may be provided by syscall.Nanosleep \n+// on some operating systems.\n+func Sleep(ns int64) os.Error {\n+\t_, err := sleep(Nanoseconds(), ns)\n+\treturn err\n+}\n+\n+// sleep takes the current time and a duration,\n+// pauses for at least ns nanoseconds, and\n+// returns the current time and an error.\n+func sleep(t, ns int64) (int64, os.Error) {\n+\t// TODO(cw): use monotonic-time once it's available\n+\tend := t + ns\n+\tfor t < end {\n+\t\terr := sysSleep(end - t)\n+\t\tif err != nil {\n+\t\t\treturn 0, err\n+\t\t}\n+\t\tt = Nanoseconds()\n+\t}\n+\treturn t, nil\n+}\n+\n+func sysSleep(t int64) os.Error {\n+\terrno := syscall.Sleep(t)\n+\tif errno != 0 && errno != syscall.EINTR {\n+\t\treturn os.NewSyscallError(\"sleep\", errno)\n+\t}\n+\treturn nil\n+}"}, {"sha": "40338f7752a48c61c2db906be9018e660bb2ec4e", "filename": "libgo/go/time/time.go", "status": "modified", "additions": 1, "deletions": 25, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Ftime.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Ftime.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -6,30 +6,6 @@\n // displaying time.\n package time\n \n-import (\n-\t\"os\"\n-)\n-\n-// Seconds reports the number of seconds since the Unix epoch,\n-// January 1, 1970 00:00:00 UTC.\n-func Seconds() int64 {\n-\tsec, _, err := os.Time()\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\treturn sec\n-}\n-\n-// Nanoseconds reports the number of nanoseconds since the Unix epoch,\n-// January 1, 1970 00:00:00 UTC.\n-func Nanoseconds() int64 {\n-\tsec, nsec, err := os.Time()\n-\tif err != nil {\n-\t\tpanic(err)\n-\t}\n-\treturn sec*1e9 + nsec\n-}\n-\n // Days of the week.\n const (\n \tSunday = iota\n@@ -47,7 +23,7 @@ type Time struct {\n \tMonth, Day           int    // Jan-2 is 1, 2\n \tHour, Minute, Second int    // 15:04:05 is 15, 4, 5.\n \tWeekday              int    // Sunday, Monday, ...\n-\tZoneOffset           int    // seconds east of UTC, e.g. -7*60 for -0700\n+\tZoneOffset           int    // seconds east of UTC, e.g. -7*60*60 for -0700\n \tZone                 string // e.g., \"MST\"\n }\n "}, {"sha": "1d83291c097a8bd88bba1049218ed4db74c42fbe", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -19,6 +19,18 @@ func init() {\n \tos.Setenv(\"TZ\", \"America/Los_Angeles\")\n }\n \n+// We should be in PST/PDT, but if the time zone files are missing we\n+// won't be. The purpose of this test is to at least explain why some of\n+// the subsequent tests fail.\n+func TestZoneData(t *testing.T) {\n+\tlt := LocalTime()\n+\t// PST is 8 hours west, PDT is 7 hours west.  We could use the name but it's not unique.\n+\tif off := lt.ZoneOffset; off != -8*60*60 && off != -7*60*60 {\n+\t\tt.Errorf(\"Unable to find US Pacific time zone data for testing; time zone is %q offset %d\", lt.Zone, off)\n+\t\tt.Error(\"Likely problem: the time zone files have not been installed.\")\n+\t}\n+}\n+\n type TimeTest struct {\n \tseconds int64\n \tgolden  Time"}, {"sha": "1119b2d34ebdf906e14f0a96e962a891352d09c5", "filename": "libgo/go/websocket/server.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fwebsocket%2Fserver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fwebsocket%2Fserver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fserver.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -58,7 +58,7 @@ func getKeyNumber(s string) (r uint32) {\n \n // ServeHTTP implements the http.Handler interface for a Web Socket\n func (f Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n-\trwc, buf, err := w.Hijack()\n+\trwc, buf, err := w.(http.Hijacker).Hijack()\n \tif err != nil {\n \t\tpanic(\"Hijack failed: \" + err.String())\n \t\treturn\n@@ -98,7 +98,7 @@ func (f Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t}\n \n \tvar location string\n-\tif w.UsingTLS() {\n+\tif req.TLS != nil {\n \t\tlocation = \"wss://\" + req.Host + req.URL.RawPath\n \t} else {\n \t\tlocation = \"ws://\" + req.Host + req.URL.RawPath\n@@ -184,15 +184,15 @@ func (f Draft75Handler) ServeHTTP(w http.ResponseWriter, req *http.Request) {\n \t\treturn\n \t}\n \n-\trwc, buf, err := w.Hijack()\n+\trwc, buf, err := w.(http.Hijacker).Hijack()\n \tif err != nil {\n \t\tpanic(\"Hijack failed: \" + err.String())\n \t\treturn\n \t}\n \tdefer rwc.Close()\n \n \tvar location string\n-\tif w.UsingTLS() {\n+\tif req.TLS != nil {\n \t\tlocation = \"wss://\" + req.Host + req.URL.RawPath\n \t} else {\n \t\tlocation = \"ws://\" + req.Host + req.URL.RawPath"}, {"sha": "14d708a3babd1e77ce9a7f98965c4ee839f7230e", "filename": "libgo/go/websocket/websocket_test.go", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fwebsocket%2Fwebsocket_test.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"bytes\"\n \t\"fmt\"\n \t\"http\"\n+\t\"http/httptest\"\n \t\"io\"\n \t\"log\"\n \t\"net\"\n@@ -22,15 +23,11 @@ var once sync.Once\n func echoServer(ws *Conn) { io.Copy(ws, ws) }\n \n func startServer() {\n-\tl, e := net.Listen(\"tcp\", \"127.0.0.1:0\") // any available address\n-\tif e != nil {\n-\t\tlog.Fatalf(\"net.Listen tcp :0 %v\", e)\n-\t}\n-\tserverAddr = l.Addr().String()\n-\tlog.Print(\"Test WebSocket server listening on \", serverAddr)\n \thttp.Handle(\"/echo\", Handler(echoServer))\n \thttp.Handle(\"/echoDraft75\", Draft75Handler(echoServer))\n-\tgo http.Serve(l, nil)\n+\tserver := httptest.NewServer(nil)\n+\tserverAddr = server.Listener.Addr().String()\n+\tlog.Print(\"Test WebSocket server listening on \", serverAddr)\n }\n \n // Test the getChallengeResponse function with values from section"}, {"sha": "f92abe825603f79e4b44b37e831167b356abcc57", "filename": "libgo/go/xml/xml.go", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fxml%2Fxml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fgo%2Fxml%2Fxml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fxml%2Fxml.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -815,7 +815,6 @@ Input:\n \t\t\t// Parsers are required to recognize lt, gt, amp, apos, and quot\n \t\t\t// even if they have not been declared.  That's all we allow.\n \t\t\tvar i int\n-\t\tCharLoop:\n \t\t\tfor i = 0; i < len(p.tmp); i++ {\n \t\t\t\tvar ok bool\n \t\t\t\tp.tmp[i], ok = p.getc()"}, {"sha": "3696783abbe3277c496a126ba142c55dc0a10bb1", "filename": "libgo/merge.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmerge.sh?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -146,7 +146,7 @@ done\n   done\n done\n \n-runtime=\"goc2c.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c mheapmap32.c mheapmap64.c msize.c malloc.h mheapmap32.h mheapmap64.h malloc.goc mprof.goc\"\n+runtime=\"goc2c.c mcache.c mcentral.c mfinal.c mfixalloc.c mgc0.c mheap.c msize.c malloc.h malloc.goc mprof.goc\"\n for f in $runtime; do\n   oldfile=${OLDDIR}/src/pkg/runtime/$f\n   newfile=${NEWDIR}/src/pkg/runtime/$f"}, {"sha": "743af8bee9ace6886ef46ee82baf972b96da06c9", "filename": "libgo/runtime/channel.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fchannel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fchannel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fchannel.h?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -119,16 +119,21 @@ extern void __go_receive_release (struct __go_channel *);\n \n struct __go_receive_nonblocking_small\n {\n+  /* Value read from channel, or 0.  */\n   uint64_t __val;\n+  /* True if value was read from channel.  */\n   _Bool __success;\n+  /* True if channel is closed.  */\n+  _Bool __closed;\n };\n \n extern struct __go_receive_nonblocking_small\n __go_receive_nonblocking_small (struct __go_channel *);\n \n extern _Bool __go_receive_big (struct __go_channel *, void *, _Bool);\n \n-extern _Bool __go_receive_nonblocking_big (struct __go_channel *, void *);\n+extern _Bool __go_receive_nonblocking_big (struct __go_channel *, void *,\n+\t\t\t\t\t   _Bool *);\n \n extern void __go_unlock_and_notify_selects (struct __go_channel *);\n "}, {"sha": "fd3923ce272e1137ac14ba8d1c66be46d7b84fc0", "filename": "libgo/runtime/go-rec-big.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-big.c?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -9,6 +9,9 @@\n #include \"go-panic.h\"\n #include \"channel.h\"\n \n+/* Returns true if a value was received, false if the channel is\n+   closed.  */\n+\n _Bool\n __go_receive_big (struct __go_channel *channel, void *val, _Bool for_select)\n {"}, {"sha": "78db587345f7280ae7d35d8b399b43725f7b31c9", "filename": "libgo/runtime/go-rec-nb-big.c", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-nb-big.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-nb-big.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-nb-big.c?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -8,8 +8,11 @@\n \n #include \"channel.h\"\n \n+/* Return true if a value was received, false if not.  */\n+\n _Bool\n-__go_receive_nonblocking_big (struct __go_channel* channel, void *val)\n+__go_receive_nonblocking_big (struct __go_channel* channel, void *val,\n+\t\t\t      _Bool *closed)\n {\n   size_t alloc_size;\n   size_t offset;\n@@ -21,13 +24,9 @@ __go_receive_nonblocking_big (struct __go_channel* channel, void *val)\n   if (data != RECEIVE_NONBLOCKING_ACQUIRE_DATA)\n     {\n       __builtin_memset (val, 0, channel->element_size);\n-      if (data == RECEIVE_NONBLOCKING_ACQUIRE_NODATA)\n-\treturn 0;\n-      else\n-\t{\n-\t  /* Channel is closed.  */\n-\t  return 1;\n-\t}\n+      if (closed != NULL)\n+\t*closed = data == RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n+      return 0;\n     }\n \n   offset = channel->next_fetch * alloc_size;"}, {"sha": "d09901b0c88365348c1a5f6cee532b82b541a529", "filename": "libgo/runtime/go-rec-nb-small.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-nb-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-nb-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-nb-small.c?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -103,7 +103,8 @@ __go_receive_nonblocking_small (struct __go_channel *channel)\n   if (data != RECEIVE_NONBLOCKING_ACQUIRE_DATA)\n     {\n       ret.__val = 0;\n-      ret.__success = data == RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n+      ret.__success = 0;\n+      ret.__closed = data == RECEIVE_NONBLOCKING_ACQUIRE_CLOSED;\n       return ret;\n     }\n \n@@ -112,6 +113,7 @@ __go_receive_nonblocking_small (struct __go_channel *channel)\n   __go_receive_release (channel);\n \n   ret.__success = 1;\n+  ret.__closed = 0;\n \n   return ret;\n }"}, {"sha": "ee85cde566be4e5457146c9bab981a8a42f3146b", "filename": "libgo/runtime/go-rec-small.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-small.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-rec-small.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-rec-small.c?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -96,7 +96,8 @@ __go_broadcast_to_select (struct __go_channel *channel)\n }\n \n /* Prepare to receive something on a channel.  Return true if the\n-   channel is acquired, false if it is closed.  */\n+   channel is acquired (which implies that there is data available),\n+   false if it is closed.  */\n \n _Bool\n __go_receive_acquire (struct __go_channel *channel, _Bool for_select)"}, {"sha": "6ec1b9a2dc7c0342577b242325ad0efacbfaafc2", "filename": "libgo/runtime/go-reflect-chan.c", "status": "modified", "additions": 30, "deletions": 15, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-reflect-chan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fruntime%2Fgo-reflect-chan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-reflect-chan.c?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -27,7 +27,7 @@ extern void chansend (unsigned char *, unsigned char *, _Bool *)\n   asm (\"libgo_reflect.reflect.chansend\");\n \n void\n-chansend (unsigned char *ch, unsigned char *val, _Bool *pres)\n+chansend (unsigned char *ch, unsigned char *val, _Bool *selected)\n {\n   struct __go_channel *channel = (struct __go_channel *) ch;\n \n@@ -46,25 +46,26 @@ chansend (unsigned char *ch, unsigned char *val, _Bool *pres)\n       __builtin_memcpy (u.b + sizeof (uint64_t) - channel->element_size, val,\n \t\t\tchannel->element_size);\n #endif\n-      if (pres == NULL)\n+      if (selected == NULL)\n \t__go_send_small (channel, u.v, 0);\n       else\n-\t*pres = __go_send_nonblocking_small (channel, u.v);\n+\t*selected = __go_send_nonblocking_small (channel, u.v);\n     }\n   else\n     {\n-      if (pres == NULL)\n+      if (selected == NULL)\n \t__go_send_big (channel, val, 0);\n       else\n-\t*pres = __go_send_nonblocking_big (channel, val);\n+\t*selected = __go_send_nonblocking_big (channel, val);\n     }\n }\n \n-extern void chanrecv (unsigned char *, unsigned char *, _Bool *)\n+extern void chanrecv (unsigned char *, unsigned char *, _Bool *, _Bool *)\n   asm (\"libgo_reflect.reflect.chanrecv\");\n \n void\n-chanrecv (unsigned char *ch, unsigned char *val, _Bool *pres)\n+chanrecv (unsigned char *ch, unsigned char *val, _Bool *selected,\n+\t  _Bool *received)\n {\n   struct __go_channel *channel = (struct __go_channel *) ch;\n \n@@ -76,16 +77,16 @@ chanrecv (unsigned char *ch, unsigned char *val, _Bool *pres)\n \tuint64_t v;\n       } u;\n \n-      if (pres == NULL)\n-\tu.v = __go_receive_small (channel, 0);\n+      if (selected == NULL)\n+\tu.v = __go_receive_small_closed (channel, 0, received);\n       else\n \t{\n \t  struct __go_receive_nonblocking_small s;\n \n \t  s = __go_receive_nonblocking_small (channel);\n-\t  *pres = s.__success;\n-\t  if (!s.__success)\n-\t    return;\n+\t  *selected = s.__success || s.__closed;\n+\t  if (received != NULL)\n+\t    *received = s.__success;\n \t  u.v = s.__val;\n \t}\n \n@@ -98,10 +99,24 @@ chanrecv (unsigned char *ch, unsigned char *val, _Bool *pres)\n     }\n   else\n     {\n-      if (pres == NULL)\n-\t__go_receive_big (channel, val, 0);\n+      if (selected == NULL)\n+\t{\n+\t  _Bool success;\n+\n+\t  success = __go_receive_big (channel, val, 0);\n+\t  if (received != NULL)\n+\t    *received = success;\n+\t}\n       else\n-\t*pres = __go_receive_nonblocking_big (channel, val);\n+\t{\n+\t  _Bool got;\n+\t  _Bool closed;\n+\n+\t  got = __go_receive_nonblocking_big (channel, val, &closed);\n+\t  *selected = got || closed;\n+\t  if (received != NULL)\n+\t    *received = got;\n+\t}\n     }\n }\n "}, {"sha": "64b40bdc955ce8c1e2ad7700b694526dee5c3513", "filename": "libgo/syscalls/exec.go", "status": "modified", "additions": 46, "deletions": 21, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fsyscalls%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Fsyscalls%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fsyscalls%2Fexec.go?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -12,6 +12,7 @@ import \"unsafe\"\n \n func libc_fcntl(fd int, cmd int, arg int) int __asm__ (\"fcntl\")\n func libc_fork() Pid_t __asm__ (\"fork\")\n+func libc_setsid() Pid_t __asm__ (\"setsid\")\n func libc_chdir(name *byte) int __asm__ (\"chdir\")\n func libc_dup2(int, int) int __asm__ (\"dup2\")\n func libc_execve(*byte, **byte, **byte) int __asm__ (\"execve\")\n@@ -24,13 +25,16 @@ func libc_wait4(Pid_t, *int, int, *Rusage) Pid_t __asm__ (\"wait4\")\n // In the child, this function must not acquire any locks, because\n // they might have been locked at the time of the fork.  This means\n // no rescheduling, no malloc calls, and no new stack segments.\n-func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, dir *byte, fd []int, pipe int) (pid int, err int) {\n+func forkAndExecInChild(argv0 *byte, argv, envv []*byte, dir *byte, attr *ProcAttr, pipe int) (pid int, err int) {\n \t// Declare all variables at top in case any\n \t// declarations require heap allocation (e.g., err1).\n \tvar r1, r2, err1 uintptr\n \tvar nextfd int\n \tvar i int\n \n+\t// guard against side effects of shuffling fds below.\n+\tfd := append([]int(nil), attr.Files...)\n+\n \tdarwin := OS == \"darwin\"\n \n \t// About to call fork.\n@@ -48,16 +52,22 @@ func forkAndExecInChild(argv0 *byte, argv []*byte, envv []*byte, traceme bool, d\n \t// Fork succeeded, now in child.\n \n \t// Enable tracing if requested.\n-\tif traceme {\n+\tif attr.Ptrace {\n \t\tif libc_ptrace(_PTRACE_TRACEME, 0, 0, nil) < 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n \n+\t// Session ID\n+\tif attr.Setsid {\n+\t\tif libc_setsid() == Pid_t(-1) {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n \t// Chdir\n \tif dir != nil {\n-\t\tr := libc_chdir(dir)\n-\t\tif r < 0 {\n+\t\tif libc_chdir(dir) < 0 {\n \t\t\tgoto childerror\n \t\t}\n \t}\n@@ -138,22 +148,42 @@ childerror:\n \tpanic(\"unreached\")\n }\n \n-func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir string, fd []int) (pid int, err int) {\n+\n+type ProcAttr struct {\n+\tSetsid bool     // Create session.\n+\tPtrace bool     // Enable tracing.\n+\tDir    string   // Current working directory.\n+\tEnv    []string // Environment.\n+\tFiles  []int    // File descriptors.\n+}\n+\n+var zeroAttributes ProcAttr\n+\n+func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n \tvar p [2]int\n \tvar r1 int\n \tvar err1 uintptr\n \tvar wstatus WaitStatus\n \n+\tif attr == nil {\n+\t\tattr = &zeroAttributes\n+\t}\n+\n \tp[0] = -1\n \tp[1] = -1\n \n \t// Convert args to C form.\n \targv0p := StringBytePtr(argv0)\n \targvp := StringArrayPtr(argv)\n-\tenvvp := StringArrayPtr(envv)\n-\tvar dirp *byte\n-\tif len(dir) > 0 {\n-\t\tdirp = StringBytePtr(dir)\n+\tenvvp := StringArrayPtr(attr.Env)\n+\n+\tif OS == \"freebsd\" && len(argv[0]) > len(argv0) {\n+\t\targvp[0] = argv0p\n+\t}\n+\n+\tvar dir *byte\n+\tif attr.Dir != \"\" {\n+\t\tdir = StringBytePtr(attr.Dir)\n \t}\n \n \t// Acquire the fork lock so that no other threads\n@@ -173,7 +203,7 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri\n \t}\n \n \t// Kick off child.\n-\tpid, err = forkAndExecInChild(argv0p, argvp, envvp, traceme, dirp, fd, p[1])\n+\tpid, err = forkAndExecInChild(argv0p, argvp, envvp, dir, attr, p[1])\n \tif err != 0 {\n \terror:\n \t\tif p[0] >= 0 {\n@@ -216,13 +246,14 @@ func forkExec(argv0 string, argv []string, envv []string, traceme bool, dir stri\n }\n \n // Combination of fork and exec, careful to be thread safe.\n-func ForkExec(argv0 string, argv []string, envv []string, dir string, fd []int) (pid int, err int) {\n-\treturn forkExec(argv0, argv, envv, false, dir, fd)\n+func ForkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err int) {\n+\treturn forkExec(argv0, argv, attr)\n }\n \n-// PtraceForkExec is like ForkExec, but starts the child in a traced state.\n-func PtraceForkExec(argv0 string, argv []string, envv []string, dir string, fd []int) (pid int, err int) {\n-\treturn forkExec(argv0, argv, envv, true, dir, fd)\n+// StartProcess wraps ForkExec for package os.\n+func StartProcess(argv0 string, argv []string, attr *ProcAttr) (pid, handle int, err int) {\n+\tpid, err = forkExec(argv0, argv, attr)\n+\treturn pid, 0, err\n }\n \n // Ordinary exec.\n@@ -233,12 +264,6 @@ func Exec(argv0 string, argv []string, envv []string) (err int) {\n \treturn GetErrno()\n }\n \n-// StartProcess wraps ForkExec for package os.\n-func StartProcess(argv0 string, argv []string, envv []string, dir string, fd []int) (pid, handle int, err int) {\n-\tpid, err = forkExec(argv0, argv, envv, false, dir, fd)\n-\treturn pid, 0, err\n-}\n-\n func Wait4(pid int, wstatus *WaitStatus, options int, rusage *Rusage) (wpid int, errno int) {\n \tvar status int\n \tr := libc_wait4(Pid_t(pid), &status, options, rusage)"}, {"sha": "20ae0a0bd25b93be236851ae31b02d973a40415d", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 44, "deletions": 9, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8039ca76a5705ae5052b20cee64110c32545c4fc/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=8039ca76a5705ae5052b20cee64110c32545c4fc", "patch": "@@ -276,6 +276,13 @@ if $havex; then\n fi\n \n # They all compile; now generate the code to call them.\n+\n+localname() {\n+\t# The package main has been renamed to __main__ when imported.\n+\t# Adjust its uses.\n+\techo $1 | sed 's/^main\\./__main__./'\n+}\n+\n {\n \t# test functions are named TestFoo\n \t# the grep -v eliminates methods and other special names\n@@ -288,6 +295,9 @@ fi\n \t\techo 'gotest: warning: no tests matching '$pattern in _gotest_.o $xofile 1>&2\n \t\texit 2\n \tfi\n+\t# benchmarks are named BenchmarkFoo.\n+\tpattern='Benchmark([^a-z].*)?'\n+\tbenchmarks=$($NM -p -v _gotest_.o $xofile | egrep ' T .*\\.'$pattern'$' | grep -v '\\..*\\..*\\.' | sed 's/.* //' | sed 's/.*\\.\\(.*\\.\\)/\\1/')\n \n \t# package spec\n \techo 'package main'\n@@ -299,23 +309,48 @@ fi\n \tif $havex; then\n \t\techo 'import \"./_xtest_\"'\n \tfi\n-\tif [ $package != \"testing\" ]; then\n-\t\techo 'import \"testing\"'\n-\t\techo 'import __regexp__ \"regexp\"' # rename in case tested package is called regexp\n-\tfi\n+\techo 'import \"testing\"'\n+\techo 'import __os__     \"os\"' # rename in case tested package is called os\n+\techo 'import __regexp__ \"regexp\"' # rename in case tested package is called regexp\n \t# test array\n \techo\n \techo 'var tests = []testing.InternalTest {'\n \tfor i in $tests\n \tdo\n-\t\techo '\t{ \"'$i'\", '$i' },'\n+\t\tj=$(localname $i)\n+\t\techo '\t{\"'$i'\", '$j'},'\n \tdone\n \techo '}'\n-\t# body\n-\techo\n-\techo 'func main() {'\n-\techo '\ttesting.Main(__regexp__.MatchString, tests)'\n+\t# benchmark array\n+\t# The comment makes the multiline declaration\n+\t# gofmt-safe even when there are no benchmarks.\n+\techo 'var benchmarks = []testing.InternalBenchmark{ //'\n+\tfor i in $benchmarks\n+\tdo\n+\t\tj=$(localname $i)\n+\t\techo '\t{\"'$i'\", '$j'},'\n+\tdone\n \techo '}'\n+\t# body\n+\techo \\\n+'\n+var matchPat string\n+var matchRe *__regexp__.Regexp\n+\n+func matchString(pat, str string) (result bool, err __os__.Error) {\n+\tif matchRe == nil || matchPat != pat {\n+\t\tmatchPat = pat\n+\t\tmatchRe, err = __regexp__.Compile(matchPat)\n+\t\tif err != nil {\n+\t\t\treturn\n+\t\t}\n+\t}\n+\treturn matchRe.MatchString(str), nil\n+}\n+\n+func main() {\n+\ttesting.Main(matchString, tests, benchmarks)\n+}'\n }>_testmain.go\n \n case \"x$dejagnu\" in"}]}