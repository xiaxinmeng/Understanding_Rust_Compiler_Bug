{"sha": "4cebae0924248beb2077894c6dc725c306fc0a69", "node_id": "C_kwDOANBUbNoAKDRjZWJhZTA5MjQyNDhiZWIyMDc3ODk0YzZkYzcyNWMzMDZmYzBhNjk", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-23T21:40:29Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-03-23T21:40:29Z"}, "message": "analyzer: fix accessing wrong stack frame on interprocedural return [PR104979]\n\nPR analyzer/104979 reports a leak false positive when handling an\ninterprocedural return to a caller:\n\n  LHS = CALL(ARGS);\n\nwhere the LHS is a certain non-trivial compound expression.\n\nThe root cause is that parts of the LHS were being erroneously\nevaluated with respect to the stack frame of the called function,\nrather than tha of the caller.  When LHS contained a local variable\nwithin the caller as part of certain nested expressions, this local\nvariable was looked for within the called frame, rather than that of the\ncaller.  This lookup in the wrong stack frame led to the local variable\nbeing treated as uninitialized, and thus the write to LHS was considered\nas writing to a garbage location, leading to the return value being\nlost, and thus being considered as a leak.\n\nThe region_model code uses the analyzer's path_var class to try to\nextend the tree type with stack depth information.  Based on the above,\nI think that the path_var class is fundamentally broken, but it's used\nin a few other places in the analyzer, so I don't want to rip it out\nuntil the next stage 1.\n\nIn the meantime, this patch reworks how region_model::pop_frame works so\nthat the destination region for an interprocedural return value is\ncomputed after the frame is popped, so that the region_model has the\nstack frame for the *caller* at that point.  Doing so fixes the issue.\n\nI attempted a more ambitious fix which moved the storing of the return\nsvalue into the destination region from region_model::pop_region into\nregion_model::update_for_return_gcall, with pop_frame returning the\nreturn svalue.  Unfortunately, this regressed g++.dg/analyzer/pr93212.C,\nwhich returns a pointer into a stale frame.\nunbind_region_and_descendents and poison_any_pointers_to_descendents are\nonly set up to poison regions with bindings into the stale frame, not\nindividual svalues, and updating that became more invasive than I'm\ncomfortable with in stage 4.\n\nThe patch also adds assertions to verify that we have the correct\nfunction when looking up locals/SSA names in a stack frame.  There\ndoesn't seem to be a general-purpose way to get at the function of an\nSSA name, so the assertions go from SSA name to def-stmt to basic_block,\nand from there use the analyzer's supergraph to get the function from\nthe basic_block.  If there's a simpler way to do this, please let me know.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/104979\n\t* engine.cc (impl_run_checkers): Create the engine after the\n\tsupergraph, and pass the supergraph to the engine.\n\t* region-model.cc (region_model::get_lvalue_1): Pass ctxt to\n\tframe_region::get_region_for_local.\n\t(region_model::update_for_return_gcall): Pass the lvalue for the\n\tresult to pop_frame as a tree, rather than as a region.\n\t(region_model::pop_frame): Update for above change, determining\n\tthe destination region after the frame is popped and thus with\n\trespect to the caller frame rather than the called frame.\n\tLikewise, set the value of the region to the return value after\n\tthe frame is popped.\n\t(engine::engine): Add supergraph pointer.\n\t(selftest::test_stack_frames): Set the DECL_CONTECT of PARM_DECLs.\n\t(selftest::test_get_representative_path_var): Likewise.\n\t(selftest::test_state_merging): Likewise.\n\t* region-model.h (region_model::pop_frame): Convert first param\n\tfrom a const region * to a tree.\n\t(engine::engine): Add param \"sg\".\n\t(engine::m_sg): New field.\n\t* region.cc: Include \"analyzer/sm.h\" and\n\t\"analyzer/program-state.h\".\n\t(frame_region::get_region_for_local): Add \"ctxt\" param.\n\tAdd assertions that VAR_DECLs are locals, and that expr is for the\n\tcorrect function.\n\t* region.h (frame_region::get_region_for_local): Add \"ctxt\" param.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/104979\n\t* gcc.dg/analyzer/boxed-malloc-1-29.c: Deleted test, moving the\n\tnow fixed test_29 to...\n\t* gcc.dg/analyzer/boxed-malloc-1.c: ...here.\n\t* gcc.dg/analyzer/stale-frame-1.c: Add test coverage.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "2cd420cb03c012eae11d82e969706859b4c53045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2cd420cb03c012eae11d82e969706859b4c53045"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cebae0924248beb2077894c6dc725c306fc0a69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cebae0924248beb2077894c6dc725c306fc0a69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cebae0924248beb2077894c6dc725c306fc0a69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cebae0924248beb2077894c6dc725c306fc0a69/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2cd0c9a5310420e1039be5e514a818b6d381d89f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2cd0c9a5310420e1039be5e514a818b6d381d89f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2cd0c9a5310420e1039be5e514a818b6d381d89f"}], "stats": {"total": 191, "additions": 120, "deletions": 71}, "files": [{"sha": "0f40e064a225bc4d972174a97052570cd24e2300", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -5717,11 +5717,11 @@ impl_run_checkers (logger *logger)\n   FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n     node->get_untransformed_body ();\n \n-  engine eng (logger);\n-\n   /* Create the supergraph.  */\n   supergraph sg (logger);\n \n+  engine eng (&sg, logger);\n+\n   state_purge_map *purge_map = NULL;\n \n   if (flag_analyzer_state_purge)"}, {"sha": "44bd8026a3531deb32dbe7fd9d4e318cfacb6779", "filename": "gcc/analyzer/region-model.cc", "status": "modified", "additions": 28, "deletions": 22, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion-model.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion-model.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.cc?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -2081,7 +2081,7 @@ region_model::get_lvalue_1 (path_var pv, region_model_context *ctxt) const\n \tint stack_index = pv.m_stack_depth;\n \tconst frame_region *frame = get_frame_at_index (stack_index);\n \tgcc_assert (frame);\n-\treturn frame->get_region_for_local (m_mgr, expr);\n+\treturn frame->get_region_for_local (m_mgr, expr, ctxt);\n       }\n \n     case COMPONENT_REF:\n@@ -3696,20 +3696,11 @@ void\n region_model::update_for_return_gcall (const gcall *call_stmt,\n \t\t\t\t       region_model_context *ctxt)\n {\n-  /* Get the region for the result of the call, within the caller frame.  */\n-  const region *result_dst_reg = NULL;\n+  /* Get the lvalue for the result of the call, passing it to pop_frame,\n+     so that pop_frame can determine the region with respect to the\n+     *caller* frame.  */\n   tree lhs = gimple_call_lhs (call_stmt);\n-  if (lhs)\n-    {\n-      /* Normally we access the top-level frame, which is:\n-         path_var (expr, get_stack_depth () - 1)\n-         whereas here we need the caller frame, hence \"- 2\" here.  */\n-      gcc_assert (get_stack_depth () >= 2);\n-      result_dst_reg = get_lvalue (path_var (lhs, get_stack_depth () - 2),\n-           \t\t\t   ctxt);\n-    }\n-\n-  pop_frame (result_dst_reg, NULL, ctxt);\n+  pop_frame (lhs, NULL, ctxt);\n }\n \n /* Extract calling information from the superedge and update the model for the \n@@ -3928,8 +3919,9 @@ region_model::get_current_function () const\n \n /* Pop the topmost frame_region from this region_model's stack;\n \n-   If RESULT_DST_REG is non-null, copy any return value from the frame\n-   into RESULT_DST_REG's region.\n+   If RESULT_LVALUE is non-null, copy any return value from the frame\n+   into the corresponding region (evaluated with respect to the *caller*\n+   frame, rather than the called frame).\n    If OUT_RESULT is non-null, copy any return value from the frame\n    into *OUT_RESULT.\n \n@@ -3938,7 +3930,7 @@ region_model::get_current_function () const\n    POISON_KIND_POPPED_STACK svalues.  */\n \n void\n-region_model::pop_frame (const region *result_dst_reg,\n+region_model::pop_frame (tree result_lvalue,\n \t\t\t const svalue **out_result,\n \t\t\t region_model_context *ctxt)\n {\n@@ -3948,18 +3940,25 @@ region_model::pop_frame (const region *result_dst_reg,\n   const frame_region *frame_reg = m_current_frame;\n   tree fndecl = m_current_frame->get_function ()->decl;\n   tree result = DECL_RESULT (fndecl);\n+  const svalue *retval = NULL;\n   if (result && TREE_TYPE (result) != void_type_node)\n     {\n-      const svalue *retval = get_rvalue (result, ctxt);\n-      if (result_dst_reg)\n-\tset_value (result_dst_reg, retval, ctxt);\n+      retval = get_rvalue (result, ctxt);\n       if (out_result)\n \t*out_result = retval;\n     }\n \n   /* Pop the frame.  */\n   m_current_frame = m_current_frame->get_calling_frame ();\n \n+  if (result_lvalue && retval)\n+    {\n+      /* Compute result_dst_reg using RESULT_LVALUE *after* popping\n+\t the frame, but before poisoning pointers into the old frame.  */\n+      const region *result_dst_reg = get_lvalue (result_lvalue, ctxt);\n+      set_value (result_dst_reg, retval, ctxt);\n+    }\n+\n   unbind_region_and_descendents (frame_reg,POISON_KIND_POPPED_STACK);\n }\n \n@@ -4366,8 +4365,8 @@ rejected_ranges_constraint::dump_to_pp (pretty_printer *pp) const\n \n /* engine's ctor.  */\n \n-engine::engine (logger *logger)\n-: m_mgr (logger)\n+engine::engine (const supergraph *sg, logger *logger)\n+: m_sg (sg), m_mgr (logger)\n {\n }\n \n@@ -5138,16 +5137,20 @@ test_stack_frames ()\n   tree a = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"a\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (a) = parent_fndecl;\n   tree b = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"b\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (b) = parent_fndecl;\n   /* \"x\" and \"y\" in a child frame.  */\n   tree x = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"x\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (x) = child_fndecl;\n   tree y = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"y\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (y) = child_fndecl;\n \n   /* \"p\" global.  */\n   tree p = build_global_decl (\"p\", ptr_type_node);\n@@ -5258,6 +5261,7 @@ test_get_representative_path_var ()\n   tree n = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"n\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (n) = fndecl;\n \n   region_model_manager mgr;\n   test_region_model_context ctxt;\n@@ -5470,12 +5474,14 @@ test_state_merging ()\n   tree a = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"a\"),\n \t\t       integer_type_node);\n+  DECL_CONTEXT (a) = test_fndecl;\n   tree addr_of_a = build1 (ADDR_EXPR, ptr_type_node, a);\n \n   /* Param \"q\", a pointer.  */\n   tree q = build_decl (UNKNOWN_LOCATION, PARM_DECL,\n \t\t       get_identifier (\"q\"),\n \t\t       ptr_type_node);\n+  DECL_CONTEXT (q) = test_fndecl;\n \n   program_point point (program_point::origin ());\n   region_model_manager mgr;"}, {"sha": "d9e214320328fb9bff5f018346b927e6b6a4bde2", "filename": "gcc/analyzer/region-model.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion-model.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion-model.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion-model.h?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -658,7 +658,7 @@ class region_model\n \t\t\t    region_model_context *ctxt);\n   const frame_region *get_current_frame () const { return m_current_frame; }\n   function * get_current_function () const;\n-  void pop_frame (const region *result_dst,\n+  void pop_frame (tree result_lvalue,\n \t\t  const svalue **out_result,\n \t\t  region_model_context *ctxt);\n   int get_stack_depth () const;\n@@ -1262,14 +1262,15 @@ class rejected_ranges_constraint : public rejected_constraint\n class engine\n {\n public:\n-  engine (logger *logger = NULL);\n+  engine (const supergraph *sg = NULL, logger *logger = NULL);\n+  const supergraph *get_supergraph () { return m_sg; }\n   region_model_manager *get_model_manager () { return &m_mgr; }\n \n   void log_stats (logger *logger) const;\n \n private:\n+  const supergraph *m_sg;\n   region_model_manager m_mgr;\n-\n };\n \n } // namespace ana"}, {"sha": "2020ef4e4b58a747092959eda35d9eb4a1a3cc5b", "filename": "gcc/analyzer/region.cc", "status": "modified", "additions": 44, "deletions": 6, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.cc?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -59,6 +59,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"analyzer/store.h\"\n #include \"analyzer/region.h\"\n #include \"analyzer/region-model.h\"\n+#include \"analyzer/sm.h\"\n+#include \"analyzer/program-state.h\"\n \n #if ENABLE_ANALYZER\n \n@@ -842,13 +844,49 @@ frame_region::dump_to_pp (pretty_printer *pp, bool simple) const\n \n const decl_region *\n frame_region::get_region_for_local (region_model_manager *mgr,\n-\t\t\t\t    tree expr) const\n+\t\t\t\t    tree expr,\n+\t\t\t\t    const region_model_context *ctxt) const\n {\n-  // TODO: could also check that VAR_DECLs are locals\n-  gcc_assert (TREE_CODE (expr) == PARM_DECL\n-\t      || TREE_CODE (expr) == VAR_DECL\n-\t      || TREE_CODE (expr) == SSA_NAME\n-\t      || TREE_CODE (expr) == RESULT_DECL);\n+  if (CHECKING_P)\n+    {\n+      /* Verify that EXPR is a local or SSA name, and that it's for the\n+\t correct function for this stack frame.  */\n+      gcc_assert (TREE_CODE (expr) == PARM_DECL\n+\t\t  || TREE_CODE (expr) == VAR_DECL\n+\t\t  || TREE_CODE (expr) == SSA_NAME\n+\t\t  || TREE_CODE (expr) == RESULT_DECL);\n+      switch (TREE_CODE (expr))\n+\t{\n+\tdefault:\n+\t  gcc_unreachable ();\n+\tcase VAR_DECL:\n+\t  gcc_assert (!is_global_var (expr));\n+\t  /* Fall through.  */\n+\tcase PARM_DECL:\n+\tcase RESULT_DECL:\n+\t  gcc_assert (DECL_CONTEXT (expr) == m_fun->decl);\n+\t  break;\n+\tcase SSA_NAME:\n+\t  {\n+\t    if (tree var = SSA_NAME_VAR (expr))\n+\t      {\n+\t\tif (DECL_P (var))\n+\t\t  gcc_assert (DECL_CONTEXT (var) == m_fun->decl);\n+\t      }\n+\t    else if (ctxt)\n+\t      if (const extrinsic_state *ext_state = ctxt->get_ext_state ())\n+\t\tif (const supergraph *sg\n+\t\t    = ext_state->get_engine ()->get_supergraph ())\n+\t\t  {\n+\t\t    const gimple *def_stmt = SSA_NAME_DEF_STMT (expr);\n+\t\t    const supernode *snode\n+\t\t      = sg->get_supernode_for_stmt (def_stmt);\n+\t\t    gcc_assert (snode->get_function () == m_fun);\n+\t\t  }\n+\t  }\n+\t  break;\n+\t}\n+    }\n \n   /* Ideally we'd use mutable here.  */\n   map_t &mutable_locals = const_cast <map_t &> (m_locals);"}, {"sha": "dbeb485e81fba9e1b51d3d0890b39b832d440e45", "filename": "gcc/analyzer/region.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Fanalyzer%2Fregion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fregion.h?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -312,8 +312,10 @@ class frame_region : public space_region\n   int get_index () const { return m_index; }\n   int get_stack_depth () const { return m_index + 1; }\n \n-  const decl_region *get_region_for_local (region_model_manager *mgr,\n-\t\t\t\t\t   tree expr) const;\n+  const decl_region *\n+  get_region_for_local (region_model_manager *mgr,\n+\t\t\ttree expr,\n+\t\t\tconst region_model_context *ctxt) const;\n \n   unsigned get_num_locals () const { return m_locals.elements (); }\n "}, {"sha": "9e38f97fc8ec2e0c68c0b35940f839e6ba5f26d0", "filename": "gcc/testsuite/gcc.dg/analyzer/boxed-malloc-1-29.c", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2cd0c9a5310420e1039be5e514a818b6d381d89f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2cd0c9a5310420e1039be5e514a818b6d381d89f/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1-29.c?ref=2cd0c9a5310420e1039be5e514a818b6d381d89f", "patch": "@@ -1,36 +0,0 @@\n-/* Isolating this false positive from boxed-malloc-1.c since it's\n-   reported within boxed_malloc.  */\n-\n-#include <stdlib.h>\n-\n-typedef struct boxed_ptr { void *value; } boxed_ptr;\n-\n-boxed_ptr\n-boxed_malloc (size_t sz)\n-{\n-  boxed_ptr result;\n-  result.value = malloc (sz);\n-  return result; /* { dg-bogus \"leak\" \"leak false +ve (PR analyzer/104979)\" { xfail *-*-* } } */\n-}\n-\n-boxed_ptr\n-boxed_free (boxed_ptr ptr)\n-{\n-  free (ptr.value);\n-}\n-\n-const boxed_ptr boxed_null = {NULL};\n-\n-struct link\n-{\n-  boxed_ptr m_ptr;\n-};\n-\n-boxed_ptr test_29 (void)\n-{\n-  boxed_ptr res = boxed_malloc (sizeof (struct link));\n-  if (!res.value)\n-    return boxed_null;\n-  ((struct link *)res.value)->m_ptr = boxed_malloc (sizeof (struct link));\n-  return res;\n-}"}, {"sha": "435fb4f01c347bff0979fb62673cbabcc09be46e", "filename": "gcc/testsuite/gcc.dg/analyzer/boxed-malloc-1.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fboxed-malloc-1.c?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -334,6 +334,15 @@ struct link\n   boxed_ptr m_ptr;\n };\n \n+boxed_ptr test_29 (void)\n+{\n+  boxed_ptr res = boxed_malloc (sizeof (struct link));\n+  if (!res.value)\n+    return boxed_null;\n+  ((struct link *)res.value)->m_ptr = boxed_malloc (sizeof (struct link));\n+  return res;\n+}\n+\n void test_31 (void)\n {\n   struct link tmp;"}, {"sha": "c3b7186e97ace5f2e8f41036f754530a348e02d5", "filename": "gcc/testsuite/gcc.dg/analyzer/stale-frame-1.c", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cebae0924248beb2077894c6dc725c306fc0a69/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fstale-frame-1.c?ref=4cebae0924248beb2077894c6dc725c306fc0a69", "patch": "@@ -13,3 +13,32 @@ int test_1 (void)\n   called_by_test_1 ();\n   return *global_ptr; /* { dg-warning \"dereferencing pointer 'global_ptr' to within stale stack frame\" } */\n }\n+\n+static void __attribute__((noinline))\n+called_by_test_2 (int **out)\n+{\n+  int i = 42;\n+  *out = &i;  \n+}\n+\n+int test_2 (void)\n+{\n+  int *ptr;\n+  called_by_test_2 (&ptr);\n+  return *ptr; /* { dg-warning \"dereferencing pointer 'ptr' to within stale stack frame\" } */\n+}\n+\n+static int __attribute__((noinline))\n+called_by_test_3 (int **out)\n+{\n+  int i = 42;\n+  *out = &i;\n+  return i;\n+}\n+\n+int test_3 (void)\n+{\n+  int *lhs_ptr;\n+  *lhs_ptr = called_by_test_3 (&lhs_ptr); /* { dg-warning \"use of uninitialized value 'lhs_ptr'\" } */\n+  return *lhs_ptr;\n+}"}]}