{"sha": "9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTY3OGRlNDk3N2YzZWE0YTgwYmQ0MGUwNWQ2MmNlNmI3ZDdlYWQyMw==", "commit": {"author": {"name": "Douglas B Rupp", "email": "rupp@gnat.com", "date": "2001-12-04T16:37:55Z"}, "committer": {"name": "Geert Bosch", "email": "bosch@gcc.gnu.org", "date": "2001-12-04T16:37:55Z"}, "message": "* gnatchop.adb:\n\n\t(File_Time_Stamp): New procedure.\n\t(Preserve_Mode): New boolean.\n\t(Write_Unit): Pass time stamp.\n\tImplement -p switch (preserve time stamps).\n\n\t* gnatcmd.adb (CHOP): Add translation for -p (/PRESERVE).\n\n\t* gnatchop.adb: Do usage info for -p switch\n\n\t* adaint.h (__gnat_set_file_time_name): New function\n\n\t* adaint.c (__gnat_set_file_time_name): Implement\n\n\t* adaint.h: Fix typo\n\nFrom-SVN: r47613", "tree": {"sha": "cf769055937cac1e35312ec316fec27e5966ab39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf769055937cac1e35312ec316fec27e5966ab39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/comments", "author": null, "committer": null, "parents": [{"sha": "b0ca54affc43c3ae945765e0545e91675dac5413", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b0ca54affc43c3ae945765e0545e91675dac5413", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b0ca54affc43c3ae945765e0545e91675dac5413"}], "stats": {"total": 301, "additions": 297, "deletions": 4}, "files": [{"sha": "3fdfd09afc0a27d12c7ee2d96dda422c8e322b6b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "patch": "@@ -1,3 +1,21 @@\n+2001-12-04  Douglas B. <rupp@gnat.com>\n+\n+\t* gnatchop.adb:\n+\t(File_Time_Stamp): New procedure.\n+\t(Preserve_Mode): New boolean.\n+\t(Write_Unit): Pass time stamp.\n+\tImplement -p switch (preserve time stamps).\n+\t\n+\t* gnatcmd.adb (CHOP): Add translation for -p (/PRESERVE).\n+\t\n+\t* gnatchop.adb: Do usage info for -p switch\n+\t\n+\t* adaint.h (__gnat_set_file_time_name): New function\n+\t\n+\t* adaint.c (__gnat_set_file_time_name): Implement\n+\t\n+\t* adaint.h: Fix typo\n+\n 2001-12-03  Robert Dewar <dewar@gnat.com>\n \n \t* sinfo.ads: Minor reformatting. N_Freeze_Entity node does not"}, {"sha": "d54d8873d37ec651341b2bccc9b477ae07fdb6f1", "filename": "gcc/ada/adaint.c", "status": "modified", "additions": 237, "deletions": 0, "changes": 237, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fadaint.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fadaint.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.c?ref=9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "patch": "@@ -67,6 +67,62 @@\n #endif\n #include <sys/wait.h>\n \n+#if defined (__EMX__) || defined (MSDOS) || defined (_WIN32)\n+#elif defined (VMS)\n+#include <rms.h>\n+#include <atrdef.h>\n+#include <fibdef.h>\n+#include <stsdef.h>\n+#include <iodef.h>\n+#include <errno.h>\n+#include <descrip.h>\n+#include <string.h>\n+#include <unixlib.h>\n+\n+struct utimbuf\n+{\n+  time_t actime;\n+  time_t modtime;\n+};\n+\n+#define NOREAD     0x01\n+#define NOWRITE    0x02\n+#define NOEXECUTE  0x04\n+#define NODELETE   0x08\n+\n+/* use native 64-bit arithmetic */\n+#define unix_time_to_vms(X,Y) \\\n+  { unsigned long long reftime, tmptime = (X); \\\n+    $DESCRIPTOR (unixtime,\"1-JAN-1970 0:00:00.00\"); \\\n+    SYS$BINTIM (&unixtime, &reftime); \\\n+    Y = tmptime * 10000000 + reftime; }\n+\n+/* descrip.h doesn't have everything ... */\n+struct dsc$descriptor_fib\n+{\n+  unsigned long fib$l_len;\n+  struct fibdef *fib$l_addr;\n+};\n+\n+struct IOSB\n+{ \n+  unsigned short status, count;\n+  unsigned long devdep;\n+};\n+\n+static char *tryfile;\n+\n+struct vstring\n+{\n+  short length;\n+  char string [NAM$C_MAXRSS+1];\n+};\n+\n+\n+#else\n+#include <utime.h>\n+#endif\n+\n #if defined (__EMX__) || defined (MSDOS) || defined (_WIN32)\n #include <process.h>\n #endif\n@@ -872,6 +928,187 @@ __gnat_file_time_fd (fd)\n #endif\n }\n \n+/* Set the file time stamp */\n+\n+void\n+__gnat_set_file_time_name (name, time_stamp)\n+     char *name;\n+     time_t time_stamp;\n+{\n+#if defined (__EMX__) || defined (MSDOS) || defined (_WIN32)\n+#elif defined (VMS)\n+  struct FAB fab;\n+  struct NAM nam;\n+\n+  struct\n+    {\n+      unsigned long long backup, create, expire, revise;\n+      unsigned long uic;\n+      union\n+\t{\n+\t  unsigned short value;\n+\t  struct\n+\t    {\n+\t      unsigned system : 4;\n+\t      unsigned owner  : 4;\n+\t      unsigned group  : 4;\n+\t      unsigned world  : 4;\n+\t    } bits;\n+\t} prot;\n+    } Fat = { 0 };\n+\n+  ATRDEF atrlst []\n+    = {\n+      { ATR$S_CREDATE,  ATR$C_CREDATE,  &Fat.create },\n+      { ATR$S_REVDATE,  ATR$C_REVDATE,  &Fat.revise },\n+      { ATR$S_EXPDATE,  ATR$C_EXPDATE,  &Fat.expire },\n+      { ATR$S_BAKDATE,  ATR$C_BAKDATE,  &Fat.backup },\n+      n{ ATR$S_FPRO,     ATR$C_FPRO,     &Fat.prot },\n+      { ATR$S_UIC,      ATR$C_UIC,      &Fat.uic },\n+      { 0, 0, 0}\n+    };\n+\n+  FIBDEF fib;\n+  struct dsc$descriptor_fib fibdsc = {sizeof (fib), (void *) &fib};\n+\n+  struct IOSB iosb;\n+\n+  unsigned long long newtime;\n+  unsigned long long revtime;\n+  long status;\n+  short chan;\n+\n+  struct vstring file;\n+  struct dsc$descriptor_s filedsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) file.string};\n+  struct vstring device;\n+  struct dsc$descriptor_s devicedsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) device.string};\n+  struct vstring timev;\n+  struct dsc$descriptor_s timedsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_T, DSC$K_CLASS_S, (void *) timev.string};\n+  struct vstring result;\n+  struct dsc$descriptor_s resultdsc\n+    = {NAM$C_MAXRSS, DSC$K_DTYPE_VT, DSC$K_CLASS_VS, (void *) result.string};\n+\n+  tryfile = (char *) __gnat_to_host_dir_spec (name, 0);\n+\n+  /* Allocate and initialize a fab and nam structures. */\n+  fab = cc$rms_fab;\n+  nam = cc$rms_nam;\n+\n+  nam.nam$l_esa = file.string;\n+  nam.nam$b_ess = NAM$C_MAXRSS;\n+  nam.nam$l_rsa = result.string;\n+  nam.nam$b_rss = NAM$C_MAXRSS;\n+  fab.fab$l_fna = tryfile;\n+  fab.fab$b_fns = strlen (tryfile);\n+  fab.fab$l_nam = &nam;\n+\n+  /*Validate filespec syntax and device existence.  */\n+  status = SYS$PARSE (&fab, 0, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+\n+  file.string [nam.nam$b_esl] = 0;\n+\n+  /* Find matching filespec. */\n+  status = SYS$SEARCH (&fab, 0, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+\n+  file.string [nam.nam$b_esl] = 0;\n+  result.string [result.length=nam.nam$b_rsl] = 0;\n+\n+  /* Get the device name and assign an IO channel. */\n+  strncpy (device.string, nam.nam$l_dev, nam.nam$b_dev);\n+  devicedsc.dsc$w_length  = nam.nam$b_dev;\n+  chan = 0;\n+  status = SYS$ASSIGN (&devicedsc, &chan, 0, 0, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+\n+  /*  Initialize the FIB and fill in the directory id field. */\n+  bzero (&fib, sizeof (fib));\n+  fib.fib$w_did [0]  = nam.nam$w_did [0];\n+  fib.fib$w_did [1]  = nam.nam$w_did [1];\n+  fib.fib$w_did [2]  = nam.nam$w_did [2];\n+  fib.fib$l_acctl = 0;\n+  fib.fib$l_wcc = 0;\n+  strcpy (file.string, (strrchr (result.string, ']') + 1));\n+  filedsc.dsc$w_length = strlen (file.string);\n+  result.string [result.length = 0] = 0;\n+\n+  /* Open and close the file to fill in the attributes.  */\n+  status\n+    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,\n+\t\t&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+  if ((iosb.status & 1) != 1)\n+    LIB$SIGNAL (iosb.status);\n+\n+  result.string [result.length] = 0;\n+  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0,\n+                     &fibdsc, 0, 0, 0, &atrlst, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+  if ((iosb.status & 1) != 1)\n+    LIB$SIGNAL (iosb.status);\n+\n+  /* Set creation time to requested time */\n+  unix_time_to_vms (time_stamp, newtime);\n+\n+  {\n+    time_t t;\n+    struct tm *ts;\n+\n+    t = time ((time_t) 0);\n+    ts = localtime (&t);\n+\n+    /* Set revision time to now in local time. */\n+    unix_time_to_vms (t + ts->tm_gmtoff, revtime);\n+  }\n+\n+  /*  Reopen the file, modify the times and then close. */\n+  fib.fib$l_acctl = FIB$M_WRITE;\n+  status\n+    = SYS$QIOW (0, chan, IO$_ACCESS|IO$M_ACCESS, &iosb, 0, 0,\n+\t\t&fibdsc, &filedsc, &result.length, &resultdsc, &atrlst, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+  if ((iosb.status & 1) != 1)\n+    LIB$SIGNAL (iosb.status);\n+\n+  Fat.create = newtime;\n+  Fat.revise = revtime;\n+\n+  status = SYS$QIOW (0, chan, IO$_DEACCESS, &iosb, 0, 0,\n+                     &fibdsc, 0, 0, 0, &atrlst, 0);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+  if ((iosb.status & 1) != 1)\n+    LIB$SIGNAL (iosb.status);\n+\n+  /* Deassign the channel and exit. */\n+  status = SYS$DASSGN (chan);\n+  if ((status & 1) != 1)\n+    LIB$SIGNAL (status);\n+#else\n+  struct utimbuf utimbuf;\n+  time_t t;\n+\n+  /* Set modification time to requested time */\n+  utimbuf.modtime = time_stamp;\n+\n+  /* Set access time to now in local time */\n+  t = time ((time_t) 0);\n+  utimbuf.actime = mktime (localtime (&t));\n+\n+  utime (name, &utimbuf);\n+#endif\n+}\n+\n void\n __gnat_get_env_value_ptr (name, len, value)\n      char *name;"}, {"sha": "8bcdbcf46f6e75c8c816cdead06230ebddd1cd39", "filename": "gcc/ada/adaint.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fadaint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fadaint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fadaint.h?ref=9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "patch": "@@ -69,6 +69,7 @@ extern char  *__gnat_readdir                       PARAMS ((DIR *, char *));\n extern int    __gnat_readdir_is_thread_safe        PARAMS ((void));\n extern time_t __gnat_file_time_name                PARAMS ((char *));\n extern time_t __gnat_file_time_fd                  PARAMS ((int));\n+extern void   __gnat_set_file_time_name\t\t   PARAMS ((char *, time_t));\n extern void   __gnat_get_env_value_ptr             PARAMS ((char *, int *,\n \t\t\t\t\t\t\t    char **));\n extern int    __gnat_file_exists\t\t   PARAMS ((char *));"}, {"sha": "72fec21d7e7a30762db26932846e82464b6fc4a1", "filename": "gcc/ada/gnatchop.adb", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fgnatchop.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fgnatchop.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatchop.adb?ref=9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                            $Revision: 1.1 $\n+--                            $Revision$\n --                                                                          --\n --            Copyright (C) 1998-2001 Ada Core Technologies, Inc.           --\n --                                                                          --\n@@ -90,6 +90,7 @@ procedure Gnatchop is\n \n    Compilation_Mode  : Boolean := False;\n    Overwrite_Files   : Boolean := False;\n+   Preserve_Mode     : Boolean := False;\n    Quiet_Mode        : Boolean := False;\n    Source_References : Boolean := False;\n    Verbose_Mode      : Boolean := False;\n@@ -204,6 +205,10 @@ procedure Gnatchop is\n    procedure Error_Msg (Message : String);\n    --  Produce an error message on standard error output\n \n+   procedure File_Time_Stamp (Name : C_File_Name; Time : OS_Time);\n+   --  Given the name of a file or directory, Name, set the\n+   --  time stamp. This function must be used for an unopened file.\n+\n    function Files_Exist return Boolean;\n    --  Check Unit.Table for possible file names that already exist\n    --  in the file system. Returns true if files exist, False otherwise\n@@ -316,6 +321,7 @@ procedure Gnatchop is\n    procedure Write_Unit\n      (Source  : access String;\n       Num     : Unit_Num;\n+      TS_Time : OS_Time;\n       Success : out Boolean);\n    --  Write one compilation unit of the source to file\n \n@@ -333,6 +339,18 @@ procedure Gnatchop is\n       end if;\n    end Error_Msg;\n \n+   ---------------------\n+   -- File_Time_Stamp --\n+   ---------------------\n+\n+   procedure File_Time_Stamp (Name : C_File_Name; Time : OS_Time) is\n+      procedure Set_File_Time (Name : C_File_Name; Time : OS_Time);\n+      pragma Import (C, Set_File_Time, \"__gnat_set_file_time_name\");\n+\n+   begin\n+      Set_File_Time (Name, Time);\n+   end File_Time_Stamp;\n+\n    -----------------\n    -- Files_Exist --\n    -----------------\n@@ -1040,7 +1058,7 @@ procedure Gnatchop is\n       --  Scan options first\n \n       loop\n-         case Getopt (\"c gnat? h k? q r v w x\") is\n+         case Getopt (\"c gnat? h k? p q r v w x\") is\n             when ASCII.NUL =>\n                exit;\n \n@@ -1088,6 +1106,9 @@ procedure Gnatchop is\n                   Kset := True;\n                end;\n \n+            when 'p' =>\n+               Preserve_Mode     := True;\n+\n             when 'q' =>\n                Quiet_Mode        := True;\n \n@@ -1279,7 +1300,7 @@ procedure Gnatchop is\n    begin\n       Put_Line\n         (\"Usage: gnatchop [-c] [-h] [-k#] \" &\n-         \"[-r] [-q] [-v] [-w] [-x] file [file ...] [dir]\");\n+         \"[-r] [-p] [-q] [-v] [-w] [-x] file [file ...] [dir]\");\n \n       New_Line;\n       Put_Line\n@@ -1300,6 +1321,10 @@ procedure Gnatchop is\n         (\"  -k       krunch file names of generated files to \" &\n          \"no more than 8 characters\");\n \n+      Put_Line\n+        (\"  -p       preserve time stamp, output files will \" &\n+         \"have same stamp as input\");\n+\n       Put_Line\n         (\"  -q       quiet mode, no output of generated file \" &\n          \"names\");\n@@ -1347,9 +1372,11 @@ procedure Gnatchop is\n       FD      : File_Descriptor;\n       Buffer  : String_Access;\n       Success : Boolean;\n+      TS_Time : OS_Time;\n \n    begin\n       FD := Open_Read (Name'Address, Binary);\n+      TS_Time := File_Time_Stamp (FD);\n \n       if FD = Invalid_FD then\n          Error_Msg (\"cannot open \" & File.Table (Input).Name.all);\n@@ -1372,7 +1399,7 @@ procedure Gnatchop is\n \n       for Num in 1 .. Unit.Last loop\n          if Unit.Table (Num).Chop_File = Input then\n-            Write_Unit (Buffer, Num, Success);\n+            Write_Unit (Buffer, Num, TS_Time, Success);\n             exit when not Success;\n          end if;\n       end loop;\n@@ -1533,6 +1560,7 @@ procedure Gnatchop is\n    procedure Write_Unit\n      (Source  : access String;\n       Num     : Unit_Num;\n+      TS_Time : OS_Time;\n       Success : out Boolean)\n    is\n       Info   : Unit_Info renames Unit.Table (Num);\n@@ -1600,6 +1628,11 @@ procedure Gnatchop is\n       end if;\n \n       Close (FD);\n+\n+      if Preserve_Mode then\n+         File_Time_Stamp (Name'Address, TS_Time);\n+      end if;\n+\n    end Write_Unit;\n \n --  Start of processing for gnatchop"}, {"sha": "1e67d667777d2d3fde5eee576acd42e29f55e3e6", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9678de4977f3ea4a80bd40e05d62ce6b7d7ead23/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=9678de4977f3ea4a80bd40e05d62ce6b7d7ead23", "patch": "@@ -351,6 +351,9 @@ procedure GNATCmd is\n    S_Chop_Over   : aliased constant S := \"/OVERWRITE \"                     &\n                                             \"-w\";\n \n+   S_Chop_Pres   : aliased constant S := \"/PRESERVE \"                      &\n+                                            \"-p\";\n+\n    S_Chop_Quiet  : aliased constant S := \"/QUIET \"                         &\n                                             \"-q\";\n \n@@ -365,6 +368,7 @@ procedure GNATCmd is\n      S_Chop_File   'Access,\n      S_Chop_Help   'Access,\n      S_Chop_Over   'Access,\n+     S_Chop_Pres   'Access,\n      S_Chop_Quiet  'Access,\n      S_Chop_Ref    'Access,\n      S_Chop_Verb   'Access);"}]}