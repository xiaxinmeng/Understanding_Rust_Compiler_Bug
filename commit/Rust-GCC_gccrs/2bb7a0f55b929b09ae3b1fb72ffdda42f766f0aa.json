{"sha": "2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmJiN2EwZjU1YjkyOWIwOWFlM2IxZmI3MmZmZGRhNDJmNzY2ZjBhYQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T21:27:49Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-15T21:27:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r328", "tree": {"sha": "af17fede8dec5e0600a3d5b39bcd47f88d40235e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af17fede8dec5e0600a3d5b39bcd47f88d40235e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa/comments", "author": null, "committer": null, "parents": [{"sha": "00fe048c3cda113284df716a5fbb502253233359", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00fe048c3cda113284df716a5fbb502253233359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00fe048c3cda113284df716a5fbb502253233359"}], "stats": {"total": 287, "additions": 258, "deletions": 29}, "files": [{"sha": "95b3adbdab28926b45a3bf25d0554d0bf40c09eb", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 258, "deletions": 29, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=2bb7a0f55b929b09ae3b1fb72ffdda42f766f0aa", "patch": "@@ -206,6 +206,9 @@\n   \"TARGET_80387\"\n   \"\")\n \n+;; The `ble' and `blt' patterns can reverse a compare, so we must allow\n+;; an immediate operand as operand 0 in the recognizers below.\n+\n (define_insn \"\"\n   [(set (cc0)\n \t(compare (match_operand:DF 0 \"general_operand\" \"f\")\n@@ -356,9 +359,24 @@\n \n ;; General case of fullword move.\n \n+;; If generating PIC code and operands[1] is a symbolic CONST, emit a\n+;; move to get the address of the symbolic object from the GOT.\n+\n+(define_expand \"movsi\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"\")\n+\t(match_operand:SI 1 \"general_operand\" \"\"))]\n+  \"\"\n+  \"\n+{\n+  extern int flag_pic;\n+\n+  if (flag_pic && SYMBOLIC_CONST (operands[1]))\n+    emit_pic_move (operands, SImode);\n+}\")\n+\n ;; On i486, incl reg is faster than movl $1,reg.\n \n-(define_insn \"movsi\"\n+(define_insn \"\"\n   [(set (match_operand:SI 0 \"general_operand\" \"=g,r\")\n \t(match_operand:SI 1 \"general_operand\" \"ri,m\"))]\n   \"\"\n@@ -1490,10 +1508,10 @@\n ;; Remainder instructions.\n \n (define_insn \"divmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(div:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(div:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t(match_operand:SI 2 \"general_operand\" \"rm\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=&d\")\n+   (set (match_operand:SI 3 \"register_operand\" \"=&d\")\n \t(mod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"*\n@@ -1507,20 +1525,20 @@\n }\")\n \n (define_insn \"divmodhi4\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=a\")\n-\t(div:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(div:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t(match_operand:HI 2 \"general_operand\" \"rm\")))\n-   (set (match_operand:HI 3 \"general_operand\" \"=&d\")\n+   (set (match_operand:HI 3 \"register_operand\" \"=&d\")\n \t(mod:HI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"cwtd\\;idiv%W0 %2\")\n \n ;; ??? Can we make gcc zero extend operand[0]?\n (define_insn \"udivmodsi4\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(udiv:SI (match_operand:SI 1 \"general_operand\" \"0\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:SI (match_operand:SI 1 \"register_operand\" \"0\")\n \t\t (match_operand:SI 2 \"general_operand\" \"rm\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=&d\")\n+   (set (match_operand:SI 3 \"register_operand\" \"=&d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"*\n@@ -1531,10 +1549,10 @@\n \n ;; ??? Can we make gcc zero extend operand[0]?\n (define_insn \"udivmodhi4\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"=a\")\n-\t(udiv:HI (match_operand:HI 1 \"general_operand\" \"0\")\n+  [(set (match_operand:HI 0 \"register_operand\" \"=a\")\n+\t(udiv:HI (match_operand:HI 1 \"register_operand\" \"0\")\n \t\t (match_operand:HI 2 \"general_operand\" \"rm\")))\n-   (set (match_operand:HI 3 \"general_operand\" \"=&d\")\n+   (set (match_operand:HI 3 \"register_operand\" \"=&d\")\n \t(umod:HI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"*\n@@ -1547,10 +1565,10 @@\n ;;this should be a valid double division which we may want to add\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"=a\")\n-\t(udiv:DI (match_operand:DI 1 \"general_operand\" \"a\")\n-\t\t(match_operand:SI 2 \"general_operand\" \"rm\")))\n-   (set (match_operand:SI 3 \"general_operand\" \"=d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=a\")\n+\t(udiv:DI (match_operand:DI 1 \"register_operand\" \"a\")\n+\t\t (match_operand:SI 2 \"general_operand\" \"rm\")))\n+   (set (match_operand:SI 3 \"register_operand\" \"=d\")\n \t(umod:SI (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"div%L0 %2,%0\")\n@@ -2605,7 +2623,7 @@\n ;; bt on the MEM directly.\n \n (define_insn \"\"\n-  [(set (cc0) (zero_extract (match_operand:QI 0 \"nonimmediate_operand\" \"q\")\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"register_operand\" \"q\")\n \t\t\t    (const_int 1)\n \t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))]\n   \"\"\n@@ -2625,6 +2643,34 @@\n   RET;\n }\")\n \n+(define_insn \"\"\n+  [(set (cc0) (zero_extract (match_operand:QI 0 \"memory_operand\" \"m\")\n+\t\t\t    (const_int 1)\n+\t\t\t    (match_operand:SI 1 \"general_operand\" \"ri\")))\n+   (clobber (match_scratch:SI 2 \"=&r\"))]\n+  \"\"\n+  \"*\n+{\n+  /* Copy memory to scratch register; pretend it was there to start with.  */\n+  if (GET_CODE (operands[0]) == MEM)\n+    {\n+      output_asm_insn (AS2 (mov%L2,%0,%2), operands);\n+      operands[0] = operands[2];\n+    }\n+  if (GET_CODE (operands[1]) == CONST_INT)\n+    {\n+      operands[1] = gen_rtx (CONST_INT, VOIDmode, 1 << INTVAL (operands[1]));\n+      output_asm_insn (AS2 (test%L0,%1,%0), operands);\n+    }\n+  else\n+    {\n+      operands[0] = gen_rtx (REG, SImode, REGNO (operands[0]));\n+      cc_status.flags |= CC_Z_IN_NOT_C;\n+      output_asm_insn (AS2 (bt%L0,%1,%0), operands);\n+    }\n+  RET;\n+}\")\n+\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand:HI 0 \"nonimmediate_operand\" \"r\")\n \t\t\t    (const_int 1)\n@@ -2673,7 +2719,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return AS1 (setnb,%0);\n   else\n     return AS1 (sete,%0);\n@@ -2686,7 +2732,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return AS1 (setb,%0);\n   else\n     return AS1 (setne,%0);\n@@ -2753,7 +2799,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return \\\"jnc %l0\\\";\n   else\n     return \\\"je %l0\\\";\n@@ -2768,7 +2814,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return \\\"jc %l0\\\";\n   else\n     return \\\"jne %l0\\\";\n@@ -2915,7 +2961,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return \\\"jc %l0\\\";\n   else\n     return \\\"jne %l0\\\";\n@@ -2930,7 +2976,7 @@\n   \"\"\n   \"*\n {\n-  if (cc_status.flags & CC_Z_IN_NOT_C)\n+  if (cc_prev_status.flags & CC_Z_IN_NOT_C)\n     return \\\"jnc %l0\\\";\n   else\n     return \\\"je %l0\\\";\n@@ -3018,7 +3064,7 @@\n   \"jmp %l0\")\n \n (define_insn \"indirect_jump\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"a\"))]\n+  [(set (pc) (match_operand:SI 0 \"general_operand\" \"rm\"))]\n   \"\"\n   \"*\n {\n@@ -3027,6 +3073,98 @@\n   return AS1 (jmp,%*%0);\n }\")\n \n+;; Implement switch statements when generating PIC code.  Switches are\n+;; implemented by `tablejump' when not using -fpic.\n+\n+;; Emit code here to do the range checking and make the index zero based.\n+\n+(define_expand \"casesi\"\n+  [(parallel\n+    [(set (pc)\n+\t  (if_then_else (leu (minus:SI\n+\t\t\t      (match_operand:SI 0 \"general_operand\" \"\")\n+\t\t\t      (match_operand:SI 1 \"const_int_operand\" \"\"))\n+\t\t\t     (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t\t(plus:SI (mem:SI (plus:SI (pc)\n+\t\t\t\t\t\t  (minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t    (match_dup 1))))\n+\t\t\t\t (label_ref (match_operand 3 \"\" \"\")))\n+\t\t\t(pc)))\n+     (use (label_ref (match_operand 4 \"\" \"\")))\n+     (clobber (match_scratch:SI 5 \"\"))])]\n+  \"flag_pic\"\n+  \"\n+{\n+  rtx reg = gen_reg_rtx (SImode);\n+\n+  current_function_uses_pic_offset_table = 1;\n+\n+  emit_insn (gen_subsi3 (reg, operands[0], operands[1]));\n+  emit_insn (gen_cmpsi (reg, operands[2]));\n+  emit_jump_insn (gen_bgtu (operands[4]));\n+  operands[0] = reg;\n+  operands[1] = CONST0_RTX (SImode);\n+}\")\n+\n+;; Implement a casesi insn.\n+\n+;; Each entry in the \"addr_diff_vec\" looks like this as the result of the\n+;; two rules below:\n+;; \n+;; \t.long _GLOBAL_OFFSET_TABLE_+[.-.L2]\n+;; \n+;; 1. An expression involving an external reference may only use the\n+;;    addition operator, and only with an assembly-time constant.\n+;;    The example above satisfies this because \".-.L2\" is a constant.\n+;; \n+;; 2. The symbol _GLOBAL_OFFSET_TABLE_ is magic, and at link time is\n+;;    given the value of \"GOT - .\", where GOT is the actual address of\n+;;    the Global Offset Table.  Therefore, the .long above actually\n+;;    stores the value \"( GOT - . ) + [ . - .L2 ]\", or \"GOT - .L2\".  The\n+;;    expression \"GOT - .L2\" by itself would generate an error from as(1).\n+;; \n+;; The pattern below emits code that looks like this:\n+;; \n+;; \tmovl %ebx,reg\n+;; \tsubl TABLE@GOTOFF(%ebx,index,4),reg\n+;; \tjmp reg\n+;; \n+;; The addr_diff_vec contents may be directly referenced with @GOTOFF, since\n+;; the addr_diff_vec is known to be part of this module.\n+;; \n+;; The subl above calculates \"GOT - (( GOT - . ) + [ . - .L2 ])\", which\n+;; evaluates to just \".L2\".\n+\n+(define_insn \"\"\n+  [(set (pc)\n+\t(if_then_else (leu (minus:SI\n+\t\t\t    (match_operand:SI 0 \"general_operand\" \"r\")\n+\t\t\t    (match_operand:SI 1 \"const_int_operand\" \"i\"))\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n+\t\t      (plus:SI (mem:SI (plus:SI (pc)\n+\t\t\t\t\t\t(minus:SI (match_dup 0)\n+\t\t\t\t\t\t\t  (match_dup 1))))\n+\t\t\t       (label_ref (match_operand 3 \"\" \"\")))\n+\t\t      (pc)))\n+   (use (label_ref (match_operand 4 \"\" \"\")))\n+   (clobber (match_scratch:SI 5 \"=&r\"))]\n+  \"\"\n+  \"*\n+{\n+  rtx xops[4];\n+\n+  xops[0] = pic_offset_table_rtx;\n+  xops[1] = operands[5];\n+  xops[2] = operands[3];\n+  xops[3] = operands[0];\n+\n+  output_asm_insn (AS2 (mov%L1,%0,%1), xops);\n+  output_asm_insn (\\\"sub%L1 %l2@GOTOFF(%0,%3,4),%1\\\", xops);\n+  output_asm_insn (AS1 (jmp,%*%1), xops);\n+  ASM_OUTPUT_ALIGN_CODE (asm_out_file);\n+  RET;\n+}\")\n+\n (define_insn \"tablejump\"\n   [(set (pc) (match_operand:SI 0 \"general_operand\" \"rm\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n@@ -3038,9 +3176,31 @@\n   return AS1 (jmp,%*%0);\n }\")\n \n+;; Call insns.\n+\n+;; If generating PIC code, the predicate indirect_operand will fail\n+;; for operands[0] containing symbolic references on all of the named\n+;; call* patterns.  Each named pattern is followed by an unnamed pattern\n+;; that matches any call to a symbolic CONST (ie, a symbol_ref).  The\n+;; unnamed patterns are only used while generating PIC code, because\n+;; otherwise the named patterns match.\n+\n ;; Call subroutine returning no value.\n \n-(define_insn \"call_pop\"\n+(define_expand \"call_pop\"\n+  [(parallel [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n+\t\t    (match_operand:SI 1 \"general_operand\" \"\"))\n+\t      (set (reg:SI 7)\n+\t\t   (plus:SI (reg:SI 7)\n+\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"\")))])]\n+  \"\"\n+  \"\n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_insn \"\"\n   [(call (match_operand:QI 0 \"indirect_operand\" \"m\")\n \t (match_operand:SI 1 \"general_operand\" \"g\"))\n    (set (reg:SI 7) (plus:SI (reg:SI 7)\n@@ -3058,7 +3218,26 @@\n     return AS1 (call,%P0);\n }\")\n \n-(define_insn \"call\"\n+(define_insn \"\"\n+  [(call (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))\n+   (set (reg:SI 7) (plus:SI (reg:SI 7)\n+\t\t\t    (match_operand:SI 3 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"call %P0\")\n+\n+(define_expand \"call\"\n+  [(call (match_operand:QI 0 \"indirect_operand\" \"\")\n+\t (match_operand:SI 1 \"general_operand\" \"\"))]\n+  ;; Operand 1 not used on the i386.\n+  \"\"\n+  \"\n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_insn \"\"\n   [(call (match_operand:QI 0 \"indirect_operand\" \"m\")\n \t (match_operand:SI 1 \"general_operand\" \"g\"))]\n   ;; Operand 1 not used on the i386.\n@@ -3075,10 +3254,31 @@\n     return AS1 (call,%P0);\n }\")\n \n+(define_insn \"\"\n+  [(call (mem:QI (match_operand:SI 0 \"symbolic_operand\" \"\"))\n+\t (match_operand:SI 1 \"general_operand\" \"g\"))]\n+  ;; Operand 1 not used on the i386.\n+  \"\"\n+  \"call %P0\")\n+\n ;; Call subroutine, returning value in operand 0\n ;; (which must be a hard register).\n \n-(define_insn \"call_value_pop\"\n+(define_expand \"call_value_pop\"\n+  [(parallel [(set (match_operand 0 \"\" \"\")\n+\t\t   (call (match_operand:QI 1 \"indirect_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"general_operand\" \"\")))\n+\t      (set (reg:SI 7)\n+\t\t   (plus:SI (reg:SI 7)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"\")))])]\n+  \"\"\n+  \"\n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (match_operand:QI 1 \"indirect_operand\" \"m\")\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))\n@@ -3099,7 +3299,28 @@\n   RET;\n }\")\n \n-(define_insn \"call_value\"\n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:QI (match_operand:SI 1 \"symbolic_operand\" \"\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))\n+   (set (reg:SI 7) (plus:SI (reg:SI 7)\n+\t\t\t    (match_operand:SI 4 \"immediate_operand\" \"i\")))]\n+  \"\"\n+  \"call %P1\")\n+\n+(define_expand \"call_value\"\n+  [(set (match_operand 0 \"\" \"\")\n+\t(call (match_operand:QI 1 \"indirect_operand\" \"\")\n+\t      (match_operand:SI 2 \"general_operand\" \"\")))]\n+  ;; Operand 2 not used on the i386.\n+  \"\"\n+  \"\n+{\n+  if (flag_pic)\n+    current_function_uses_pic_offset_table = 1;\n+}\")\n+\n+(define_insn \"\"\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (match_operand:QI 1 \"indirect_operand\" \"m\")\n \t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n@@ -3119,6 +3340,14 @@\n   RET;\n }\")\n \n+(define_insn \"\"\n+  [(set (match_operand 0 \"\" \"=rf\")\n+\t(call (mem:QI (match_operand:SI 1 \"symbolic_operand\" \"\"))\n+\t      (match_operand:SI 2 \"general_operand\" \"g\")))]\n+  ;; Operand 2 not used on the i386.\n+  \"\"\n+  \"call %P1\")\n+\n ;; Insn emitted into the body of a function to return from a function.\n ;; This is only done if the function's epilogue is known to be simple.\n ;; See comments for simple_386_epilogue in i386.c."}]}