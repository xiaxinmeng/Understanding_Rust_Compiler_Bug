{"sha": "852dba8059832d76c74e1e6f31d65a9302a0baa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODUyZGJhODA1OTgzMmQ3NmM3NGUxZTZmMzFkNjVhOTMwMmEwYmFhNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-24T09:19:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2009-06-24T09:19:41Z"}, "message": "[multiple changes]\n\n2009-06-24  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Type_Conversion): Handle entities that are\n\tvisible through limited-with context clauses. In addition, avoid an\n\textra tag check that is not required when the class-wide\n\tdesignated types of the operand and target types are\n\tthe same entity.\n\t(Tagged_Membership): Handle entities from the limited view.\n\n2009-06-24  Emmanuel Briot  <briot@adacore.com>\n\n\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.ads, clean.adb,\n\tprj-nmsc.adb, prj-env.adb (File_Name_Data): removed\n\t(Spec_Or_Body): now a subtype of Source_Kind, to avoid using two\n\tdifferent vocabularies for similar concepts (Impl/Body_Part and\n\tSpec/Specification).\n\t(Unit_Data): now points directly to a Source_Id, rather than duplicating\n\tsome of the information in File_Name_Data. This also saves a bit of\n\tmemory. However, since we are now using a pointer we need to test\n\tfor null explicitly in several places of the code\n\nFrom-SVN: r148900", "tree": {"sha": "74771738dd04024246ed48f56765e4d1a4f1bca8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74771738dd04024246ed48f56765e4d1a4f1bca8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/852dba8059832d76c74e1e6f31d65a9302a0baa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dba8059832d76c74e1e6f31d65a9302a0baa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/852dba8059832d76c74e1e6f31d65a9302a0baa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/852dba8059832d76c74e1e6f31d65a9302a0baa7/comments", "author": null, "committer": null, "parents": [{"sha": "950d217a1ce57c2d8cdc4b54f73515409a0dbf18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/950d217a1ce57c2d8cdc4b54f73515409a0dbf18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/950d217a1ce57c2d8cdc4b54f73515409a0dbf18"}], "stats": {"total": 646, "additions": 340, "deletions": 306}, "files": [{"sha": "40d738e63168629521075d9b4a9a6a916538ec28", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -1,3 +1,24 @@\n+2009-06-24  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Type_Conversion): Handle entities that are\n+\tvisible through limited-with context clauses. In addition, avoid an\n+\textra tag check that is not required when the class-wide\n+\tdesignated types of the operand and target types are\n+\tthe same entity.\n+\t(Tagged_Membership): Handle entities from the limited view.\n+\n+2009-06-24  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* gnatcmd.adb, make.adb, mlib-prj.adb, prj.ads, clean.adb,\n+\tprj-nmsc.adb, prj-env.adb (File_Name_Data): removed\n+\t(Spec_Or_Body): now a subtype of Source_Kind, to avoid using two\n+\tdifferent vocabularies for similar concepts (Impl/Body_Part and\n+\tSpec/Specification).\n+\t(Unit_Data): now points directly to a Source_Id, rather than duplicating\n+\tsome of the information in File_Name_Data. This also saves a bit of\n+\tmemory. However, since we are now using a pointer we need to test\n+\tfor null explicitly in several places of the code\n+\n 2009-06-24  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_ch4.adb (Expand_N_Type_Conversion): return immediately"}, {"sha": "933a97bbee351c53954b27934138935be8af7465", "filename": "gcc/ada/clean.adb", "status": "modified", "additions": 42, "deletions": 22, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fclean.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fclean.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fclean.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -577,22 +577,23 @@ package body Clean is\n                      loop\n                         Unit := Project_Tree.Units.Table (Index);\n \n-                        if Ultimate_Extending_Project_Of\n-                          (Unit.File_Names (Body_Part).Project) = Project\n+                        if Unit.File_Names (Impl) /= null\n+                          and then Ultimate_Extending_Project_Of\n+                            (Unit.File_Names (Impl).Project) = Project\n                           and then\n-                            Get_Name_String\n-                              (Unit.File_Names (Body_Part).Name) =\n-                          Name (1 .. Last)\n+                            Get_Name_String (Unit.File_Names (Impl).File)\n+                            = Name (1 .. Last)\n                         then\n                            Delete_File := True;\n                            exit;\n                         end if;\n \n-                        if Ultimate_Extending_Project_Of\n-                          (Unit.File_Names (Specification).Project) = Project\n+                        if Unit.File_Names (Spec) /= null\n+                          and then Ultimate_Extending_Project_Of\n+                            (Unit.File_Names (Spec).Project) = Project\n                           and then\n                             Get_Name_String\n-                              (Unit.File_Names (Specification).Name) =\n+                              (Unit.File_Names (Spec).File) =\n                           Name (1 .. Last)\n                         then\n                            Delete_File := True;\n@@ -741,15 +742,16 @@ package body Clean is\n                            loop\n                               Unit := Project_Tree.Units.Table (Index);\n \n-                              if Unit.File_Names (Body_Part).Project /=\n+                              if Unit.File_Names (Impl) /= null\n+                                and then Unit.File_Names (Impl).Project /=\n                                 No_Project\n                               then\n                                  if Ultimate_Extending_Project_Of\n-                                   (Unit.File_Names (Body_Part).Project) =\n+                                   (Unit.File_Names (Impl).Project) =\n                                    Project\n                                  then\n                                     Get_Name_String\n-                                      (Unit.File_Names (Body_Part).Name);\n+                                      (Unit.File_Names (Impl).File);\n                                     Name_Len := Name_Len -\n                                       File_Extension\n                                         (Name (1 .. Name_Len))'Length;\n@@ -761,12 +763,13 @@ package body Clean is\n                                     end if;\n                                  end if;\n \n-                              elsif Ultimate_Extending_Project_Of\n-                                (Unit.File_Names (Specification).Project) =\n+                              elsif Unit.File_Names (Spec) /= null\n+                                and then Ultimate_Extending_Project_Of\n+                                (Unit.File_Names (Spec).Project) =\n                                 Project\n                               then\n                                  Get_Name_String\n-                                   (Unit.File_Names (Specification).Name);\n+                                   (Unit.File_Names (Spec).File);\n                                  Name_Len := Name_Len -\n                                    File_Extension\n                                      (Name (1 .. Name_Len))'Length;\n@@ -887,16 +890,33 @@ package body Clean is\n                      --  project, check for the corresponding ALI file in the\n                      --  object directory.\n \n-                     if In_Extension_Chain\n-                       (U_Data.File_Names (Body_Part).Project, Project)\n+                     if (U_Data.File_Names (Impl) /= null\n+                         and then\n+                           In_Extension_Chain\n+                             (U_Data.File_Names (Impl).Project, Project))\n                        or else\n-                         In_Extension_Chain\n-                           (U_Data.File_Names (Specification).Project, Project)\n+                         (U_Data.File_Names (Spec) /= null\n+                          and then In_Extension_Chain\n+                            (U_Data.File_Names\n+                               (Spec).Project, Project))\n                      then\n-                        File_Name1 := U_Data.File_Names (Body_Part).Name;\n-                        Index1     := U_Data.File_Names (Body_Part).Index;\n-                        File_Name2 := U_Data.File_Names (Specification).Name;\n-                        Index2     := U_Data.File_Names (Specification).Index;\n+                        if U_Data.File_Names (Impl) /= null then\n+                           File_Name1 := U_Data.File_Names (Impl).File;\n+                           Index1     := U_Data.File_Names (Impl).Index;\n+                        else\n+                           File_Name1 := No_File;\n+                           Index1     := 0;\n+                        end if;\n+\n+                        if U_Data.File_Names (Spec) /= null then\n+                           File_Name2 :=\n+                             U_Data.File_Names (Spec).File;\n+                           Index2     :=\n+                             U_Data.File_Names (Spec).Index;\n+                        else\n+                           File_Name2 := No_File;\n+                           Index2     := 0;\n+                        end if;\n \n                         --  If there is no body file name, then there may be\n                         --  only a spec."}, {"sha": "9c124ad6ec508509e0d6e7b0f699a1ab38b3180f", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -7955,9 +7955,13 @@ package body Exp_Ch4 is\n \n          begin\n             if Is_Access_Type (Target_Type) then\n-               Actual_Op_Typ   := Designated_Type (Operand_Type);\n-               Actual_Targ_Typ := Designated_Type (Target_Type);\n \n+               --  Handle entities from the limited view\n+\n+               Actual_Op_Typ :=\n+                 Available_View (Designated_Type (Operand_Type));\n+               Actual_Targ_Typ :=\n+                 Available_View (Designated_Type (Target_Type));\n             else\n                Actual_Op_Typ   := Operand_Type;\n                Actual_Targ_Typ := Target_Type;\n@@ -7978,6 +7982,7 @@ package body Exp_Ch4 is\n                --  conversion.\n \n                if Is_Class_Wide_Type (Actual_Op_Typ)\n+                 and then Actual_Op_Typ /= Actual_Targ_Typ\n                  and then Root_Op_Typ /= Actual_Targ_Typ\n                  and then Is_Ancestor (Root_Op_Typ, Actual_Targ_Typ)\n                then\n@@ -9486,8 +9491,10 @@ package body Exp_Ch4 is\n       Obj_Tag    : Node_Id;\n \n    begin\n-      Left_Type  := Etype (Left);\n-      Right_Type := Etype (Right);\n+      --  Handle entities from the limited view\n+\n+      Left_Type  := Available_View (Etype (Left));\n+      Right_Type := Available_View (Etype (Right));\n \n       if Is_Class_Wide_Type (Left_Type) then\n          Left_Type := Root_Type (Left_Type);"}, {"sha": "5b86cf607b0602ac73b7ca0eea516365eb764664", "filename": "gcc/ada/gnatcmd.adb", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fgnatcmd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fgnatcmd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnatcmd.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -418,21 +418,18 @@ procedure GNATCmd is\n                --  spec, but not the subunits.\n \n                if The_Command = List then\n-                  if\n-                    Unit_Data.File_Names (Body_Part).Name /= No_File\n-                      and then\n-                    Unit_Data.File_Names (Body_Part).Path.Name /= Slash\n+                  if Unit_Data.File_Names (Impl) /= null\n+                    and then Unit_Data.File_Names (Impl).Path.Name /= Slash\n                   then\n                      --  There is a body, check if it is for this project\n \n                      if All_Projects or else\n-                        Unit_Data.File_Names (Body_Part).Project = Project\n+                        Unit_Data.File_Names (Impl).Project = Project\n                      then\n                         Subunit := False;\n \n-                        if Unit_Data.File_Names (Specification).Name = No_File\n-                          or else Unit_Data.File_Names\n-                                    (Specification).Path.Name = Slash\n+                        if Unit_Data.File_Names (Spec) = null\n+                          or else Unit_Data.File_Names (Spec).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check if\n                            --  this is a subunit, because gnatls will complain\n@@ -443,7 +440,7 @@ procedure GNATCmd is\n                                           Sinput.P.Load_Project_File\n                                             (Get_Name_String\n                                               (Unit_Data.File_Names\n-                                                (Body_Part).Path.Name));\n+                                                (Impl).Path.Name));\n                            begin\n                               Subunit :=\n                                 Sinput.P.Source_File_Is_Subunit (Src_Ind);\n@@ -456,27 +453,25 @@ procedure GNATCmd is\n                              new String'\n                                (Get_Name_String\n                                     (Unit_Data.File_Names\n-                                         (Body_Part).Display_Name));\n+                                         (Impl).Display_File));\n                         end if;\n                      end if;\n \n-                  elsif\n-                    Unit_Data.File_Names (Specification).Name /= No_File\n-                      and then\n-                    Unit_Data.File_Names (Specification).Path.Name /= Slash\n+                  elsif Unit_Data.File_Names (Spec) /= null\n+                    and then Unit_Data.File_Names (Spec).Path.Name /= Slash\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n                      if All_Projects or else\n-                        Unit_Data.File_Names (Specification).Project = Project\n+                        Unit_Data.File_Names (Spec).Project = Project\n                      then\n                         Last_Switches.Increment_Last;\n                         Last_Switches.Table (Last_Switches.Last) :=\n                           new String'\n                             (Get_Name_String\n                                  (Unit_Data.File_Names\n-                                      (Specification).Display_Name));\n+                                      (Spec).Display_File));\n                      end if;\n                   end if;\n \n@@ -486,21 +481,19 @@ procedure GNATCmd is\n                --  but not the subunits.\n \n                elsif The_Command = Stack then\n-                  if Unit_Data.File_Names (Body_Part).Name /= No_File\n-                    and then\n-                      Unit_Data.File_Names (Body_Part).Path.Name /= Slash\n+                  if Unit_Data.File_Names (Impl) /= null\n+                    and then Unit_Data.File_Names (Impl).Path.Name /= Slash\n                   then\n                      --  There is a body. Check if .ci files for this project\n                      --  must be added.\n \n                      if Check_Project\n-                         (Unit_Data.File_Names (Body_Part).Project, Project)\n+                         (Unit_Data.File_Names (Impl).Project, Project)\n                      then\n                         Subunit := False;\n \n-                        if Unit_Data.File_Names (Specification).Name = No_File\n-                          or else Unit_Data.File_Names\n-                                    (Specification).Path.Name = Slash\n+                        if Unit_Data.File_Names (Spec) = null\n+                          or else Unit_Data.File_Names (Spec).Path.Name = Slash\n                         then\n                            --  We have a body with no spec: we need to check\n                            --  if this is a subunit, because .ci files are not\n@@ -511,7 +504,7 @@ procedure GNATCmd is\n                                           Sinput.P.Load_Project_File\n                                             (Get_Name_String\n                                               (Unit_Data.File_Names\n-                                                (Body_Part).Path.Name));\n+                                                (Impl).Path.Name));\n                            begin\n                               Subunit :=\n                                 Sinput.P.Source_File_Is_Subunit (Src_Ind);\n@@ -524,40 +517,37 @@ procedure GNATCmd is\n                              new String'\n                                (Get_Name_String\n                                     (Unit_Data.File_Names\n-                                       (Body_Part).Project.\n+                                       (Impl).Project.\n                                          Object_Directory.Name)      &\n                                 Directory_Separator                  &\n                                 MLib.Fil.Ext_To\n                                   (Get_Name_String\n                                      (Unit_Data.File_Names\n-                                        (Body_Part).Display_Name),\n+                                        (Impl).Display_File),\n                                    \"ci\"));\n                         end if;\n                      end if;\n \n-                  elsif Unit_Data.File_Names (Specification).Name /= No_File\n-                    and then\n-                      Unit_Data.File_Names (Specification).Path.Name /= Slash\n+                  elsif Unit_Data.File_Names (Spec) /= null\n+                    and then Unit_Data.File_Names (Spec).Path.Name /= Slash\n                   then\n                      --  We have a spec with no body. Check if it is for this\n                      --  project.\n \n                      if Check_Project\n-                         (Unit_Data.File_Names (Specification).Project,\n-                          Project)\n+                       (Unit_Data.File_Names (Spec).Project, Project)\n                      then\n                         Last_Switches.Increment_Last;\n                         Last_Switches.Table (Last_Switches.Last) :=\n                           new String'\n                             (Get_Name_String\n                                  (Unit_Data.File_Names\n-                                   (Specification).Project.\n+                                   (Spec).Project.\n                                       Object_Directory.Name)         &\n                              Dir_Separator                           &\n                              MLib.Fil.Ext_To\n                                (Get_Name_String\n-                                  (Unit_Data.File_Names\n-                                     (Specification).Name),\n+                                  (Unit_Data.File_Names (Spec).File),\n                                 \"ci\"));\n                      end if;\n                   end if;\n@@ -568,14 +558,13 @@ procedure GNATCmd is\n                   --  specified.\n \n                   for Kind in Spec_Or_Body loop\n-                     if Check_Project\n-                          (Unit_Data.File_Names (Kind).Project, Project)\n-                       and then Unit_Data.File_Names (Kind).Name /= No_File\n+                     if Unit_Data.File_Names (Kind) /= null\n+                       and then Check_Project\n+                         (Unit_Data.File_Names (Kind).Project, Project)\n                        and then Unit_Data.File_Names (Kind).Path.Name /= Slash\n                      then\n                         Get_Name_String\n-                          (Unit_Data.File_Names\n-                             (Kind).Path.Display_Name);\n+                          (Unit_Data.File_Names (Kind).Path.Display_Name);\n \n                         if FD /= Invalid_FD then\n                            Name_Len := Name_Len + 1;\n@@ -833,20 +822,20 @@ procedure GNATCmd is\n             loop\n                Udata := Project_Tree.Units.Table (Unit);\n \n-               if Udata.File_Names (Specification).Name /= No_File\n+               if Udata.File_Names (Spec) /= null\n                  and then\n-                   Get_Name_String (Udata.File_Names (Specification).Name) =\n+                   Get_Name_String (Udata.File_Names (Spec).File) =\n                       Line (1 .. Last)\n                then\n-                  Path := Udata.File_Names (Specification).Path.Name;\n+                  Path := Udata.File_Names (Spec).Path.Name;\n                   exit;\n \n-               elsif Udata.File_Names (Body_Part).Name /= No_File\n+               elsif Udata.File_Names (Impl) /= null\n                  and then\n-                   Get_Name_String (Udata.File_Names (Body_Part).Name) =\n+                   Get_Name_String (Udata.File_Names (Impl).File) =\n                      Line (1 .. Last)\n                then\n-                  Path := Udata.File_Names (Body_Part).Path.Name;\n+                  Path := Udata.File_Names (Impl).Path.Name;\n                   exit;\n                end if;\n             end loop;"}, {"sha": "fcbe4fed89ab546d9fb2164cc5439b0c2253bb0e", "filename": "gcc/ada/make.adb", "status": "modified", "additions": 51, "deletions": 45, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fmake.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fmake.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmake.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -1473,8 +1473,11 @@ package body Make is\n          if UID /= Prj.No_Unit_Index then\n             U_Data := Project_Tree.Units.Table (UID);\n \n-            if U_Data.File_Names (Body_Part).Name /= Sfile\n-              and then U_Data.File_Names (Specification).Name /= Sfile\n+            if (U_Data.File_Names (Impl) = null\n+                or else U_Data.File_Names (Impl).File /= Sfile)\n+              and then\n+                (U_Data.File_Names (Spec) = null\n+                 or else U_Data.File_Names (Spec).File /= Sfile)\n             then\n                Verbose_Msg (Uname, \"sources do not include \", Name_Id (Sfile));\n                return True;\n@@ -1945,15 +1948,18 @@ package body Make is\n                   for U in 1 .. Unit_Table.Last (Project_Tree.Units) loop\n                      Udata := Project_Tree.Units.Table (U);\n \n-                     if Udata.File_Names (Body_Part).Name = Source_File then\n-                        ALI_Project := Udata.File_Names (Body_Part).Project;\n+                     if Udata.File_Names (Impl) /= null\n+                       and then Udata.File_Names (Impl).File = Source_File\n+                     then\n+                        ALI_Project := Udata.File_Names (Impl).Project;\n                         exit;\n \n-                     elsif\n-                       Udata.File_Names (Specification).Name = Source_File\n+                     elsif Udata.File_Names (Spec) /= null\n+                       and then Udata.File_Names (Spec).File =\n+                         Source_File\n                      then\n                         ALI_Project :=\n-                          Udata.File_Names (Specification).Project;\n+                          Udata.File_Names (Spec).Project;\n                         exit;\n                      end if;\n                   end loop;\n@@ -2053,16 +2059,20 @@ package body Make is\n                           UID in 1 .. Unit_Table.Last (Project_Tree.Units)\n                         loop\n                            if Project_Tree.Units.Table (UID).\n-                             File_Names (Body_Part).Name = Dep.Sfile\n+                             File_Names (Impl) /= null\n+                             and then Project_Tree.Units.Table (UID).\n+                             File_Names (Impl).File = Dep.Sfile\n                            then\n                               Proj := Project_Tree.Units.Table (UID).\n-                                File_Names (Body_Part).Project;\n+                                File_Names (Impl).Project;\n \n                            elsif Project_Tree.Units.Table (UID).\n-                             File_Names (Specification).Name = Dep.Sfile\n+                             File_Names (Spec) /= null\n+                             and then Project_Tree.Units.Table (UID).\n+                             File_Names (Spec).File = Dep.Sfile\n                            then\n                               Proj := Project_Tree.Units.Table (UID).\n-                                File_Names (Specification).Project;\n+                                File_Names (Spec).Project;\n                            end if;\n \n                            --  If a source is in a project, check if it is one\n@@ -3608,28 +3618,24 @@ package body Make is\n                               if Uid /= Prj.No_Unit_Index then\n                                  Udata := Project_Tree.Units.Table (Uid);\n \n-                                 if\n-                                    Udata.File_Names (Body_Part).Name /=\n-                                                                       No_File\n+                                 if Udata.File_Names (Impl) /= null\n                                    and then\n-                                     Udata.File_Names (Body_Part).Path.Name /=\n+                                     Udata.File_Names (Impl).Path.Name /=\n                                        Slash\n                                  then\n-                                    Sfile := Udata.File_Names (Body_Part).Name;\n+                                    Sfile := Udata.File_Names (Impl).File;\n                                     Source_Index :=\n-                                      Udata.File_Names (Body_Part).Index;\n+                                      Udata.File_Names (Impl).Index;\n \n-                                 elsif\n-                                    Udata.File_Names (Specification).Name /=\n-                                                                        No_File\n+                                 elsif Udata.File_Names (Spec) /= null\n                                    and then\n                                      Udata.File_Names\n-                                       (Specification).Path.Name /= Slash\n+                                       (Spec).Path.Name /= Slash\n                                  then\n                                     Sfile :=\n-                                      Udata.File_Names (Specification).Name;\n+                                      Udata.File_Names (Spec).File;\n                                     Source_Index :=\n-                                      Udata.File_Names (Specification).Index;\n+                                      Udata.File_Names (Spec).Index;\n                                  end if;\n                               end if;\n                            end;\n@@ -4400,32 +4406,32 @@ package body Make is\n \n                      --  If there is a body, put it in the mapping\n \n-                     if Unit.File_Names (Body_Part).Name /= No_File\n-                       and then Unit.File_Names (Body_Part).Project /=\n+                     if Unit.File_Names (Impl) /= No_Source\n+                       and then Unit.File_Names (Impl).Project /=\n                                                             No_Project\n                      then\n                         Get_Name_String (Unit.Name);\n                         Add_Str_To_Name_Buffer (\"%b\");\n                         ALI_Unit := Name_Find;\n                         ALI_Name :=\n                           Lib_File_Name\n-                            (Unit.File_Names (Body_Part).Display_Name);\n-                        ALI_Project := Unit.File_Names (Body_Part).Project;\n+                            (Unit.File_Names (Impl).Display_File);\n+                        ALI_Project := Unit.File_Names (Impl).Project;\n \n                         --  Otherwise, if there is a spec, put it in the\n                         --  mapping.\n \n-                     elsif Unit.File_Names (Specification).Name /= No_File\n-                       and then Unit.File_Names (Specification).Project /=\n+                     elsif Unit.File_Names (Spec) /= No_Source\n+                       and then Unit.File_Names (Spec).Project /=\n                                                                 No_Project\n                      then\n                         Get_Name_String (Unit.Name);\n                         Add_Str_To_Name_Buffer (\"%s\");\n                         ALI_Unit := Name_Find;\n                         ALI_Name :=\n                           Lib_File_Name\n-                            (Unit.File_Names (Specification).Display_Name);\n-                        ALI_Project := Unit.File_Names (Specification).Project;\n+                            (Unit.File_Names (Spec).Display_File);\n+                        ALI_Project := Unit.File_Names (Spec).Project;\n \n                      else\n                         ALI_Name := No_File;\n@@ -7014,17 +7020,17 @@ package body Make is\n          --  If there is a source for the body, and the body has not been\n          --  locally removed.\n \n-         if Unit.File_Names (Body_Part).Name /= No_File\n-           and then Unit.File_Names (Body_Part).Path.Name /= Slash\n+         if Unit.File_Names (Impl) /= null\n+           and then Unit.File_Names (Impl).Path.Name /= Slash\n          then\n             --  And it is a source for the specified project\n \n-            if Check_Project (Unit.File_Names (Body_Part).Project) then\n+            if Check_Project (Unit.File_Names (Impl).Project) then\n \n                --  If we don't have a spec, we cannot consider the source\n                --  if it is a subunit.\n \n-               if Unit.File_Names (Specification).Name = No_File then\n+               if Unit.File_Names (Spec) = null then\n                   declare\n                      Src_Ind : Source_File_Index;\n \n@@ -7042,35 +7048,35 @@ package body Make is\n                   begin\n                      Src_Ind := Sinput.P.Load_Project_File\n                                   (Get_Name_String\n-                                     (Unit.File_Names (Body_Part).Path.Name));\n+                                     (Unit.File_Names (Impl).Path.Name));\n \n                      --  If it is a subunit, discard it\n \n                      if Sinput.P.Source_File_Is_Subunit (Src_Ind) then\n                         Sfile := No_File;\n                         Index := 0;\n                      else\n-                        Sfile := Unit.File_Names (Body_Part).Display_Name;\n-                        Index := Unit.File_Names (Body_Part).Index;\n+                        Sfile := Unit.File_Names (Impl).Display_File;\n+                        Index := Unit.File_Names (Impl).Index;\n                      end if;\n                   end;\n \n                else\n-                  Sfile := Unit.File_Names (Body_Part).Display_Name;\n-                  Index := Unit.File_Names (Body_Part).Index;\n+                  Sfile := Unit.File_Names (Impl).Display_File;\n+                  Index := Unit.File_Names (Impl).Index;\n                end if;\n             end if;\n \n-         elsif Unit.File_Names (Specification).Name /= No_File\n-           and then Unit.File_Names (Specification).Path.Name /= Slash\n-           and then Check_Project (Unit.File_Names (Specification).Project)\n+         elsif Unit.File_Names (Spec) /= null\n+           and then Unit.File_Names (Spec).Path.Name /= Slash\n+           and then Check_Project (Unit.File_Names (Spec).Project)\n          then\n             --  If there is no source for the body, but there is a source\n             --  for the spec which has not been locally removed, then we take\n             --  this one.\n \n-            Sfile := Unit.File_Names (Specification).Display_Name;\n-            Index := Unit.File_Names (Specification).Index;\n+            Sfile := Unit.File_Names (Spec).Display_File;\n+            Index := Unit.File_Names (Spec).Index;\n          end if;\n \n          --  If Put_In_Q is True, we insert into the Q"}, {"sha": "42b1ba66a3e96ce30c2fc79a6847baacb7e85993", "filename": "gcc/ada/mlib-prj.adb", "status": "modified", "additions": 38, "deletions": 35, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fmlib-prj.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fmlib-prj.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fmlib-prj.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -948,45 +948,44 @@ package body MLib.Prj is\n             loop\n                Unit := In_Tree.Units.Table (Source);\n \n-               if Unit.File_Names (Body_Part).Name /= No_File\n-                 and then Unit.File_Names (Body_Part).Path.Name /= Slash\n+               if Unit.File_Names (Impl) /= null\n+                 and then Unit.File_Names (Impl).Path.Name /= Slash\n                then\n                   if\n-                    Check_Project (Unit.File_Names (Body_Part).Project)\n+                    Check_Project (Unit.File_Names (Impl).Project)\n                   then\n-                     if Unit.File_Names (Specification).Name = No_File then\n+                     if Unit.File_Names (Spec) = null then\n                         declare\n                            Src_Ind : Source_File_Index;\n \n                         begin\n                            Src_Ind := Sinput.P.Load_Project_File\n                              (Get_Name_String\n-                                (Unit.File_Names\n-                                   (Body_Part).Path.Name));\n+                                (Unit.File_Names (Impl).Path.Name));\n \n                            --  Add the ALI file only if it is not a subunit\n \n                            if not\n                              Sinput.P.Source_File_Is_Subunit (Src_Ind)\n                            then\n                               Add_ALI_For\n-                                (Unit.File_Names (Body_Part).Name);\n+                                (Unit.File_Names (Impl).File);\n                               exit when not Bind;\n                            end if;\n                         end;\n \n                      else\n-                        Add_ALI_For (Unit.File_Names (Body_Part).Name);\n+                        Add_ALI_For (Unit.File_Names (Impl).File);\n                         exit when not Bind;\n                      end if;\n                   end if;\n \n-               elsif Unit.File_Names (Specification).Name /= No_File\n-                 and then Unit.File_Names (Specification).Path.Name /= Slash\n+               elsif Unit.File_Names (Spec) /= null\n+                 and then Unit.File_Names (Spec).Path.Name /= Slash\n                  and then Check_Project\n-                   (Unit.File_Names (Specification).Project)\n+                   (Unit.File_Names (Spec).Project)\n                then\n-                  Add_ALI_For (Unit.File_Names (Specification).Name);\n+                  Add_ALI_For (Unit.File_Names (Spec).File);\n                   exit when not Bind;\n                end if;\n             end loop;\n@@ -1424,30 +1423,29 @@ package body MLib.Prj is\n                                           loop\n                                              if In_Tree.Units.Table\n                                                  (Index).File_Names\n-                                                   (Body_Part).Name /= No_File\n+                                                   (Impl) /= null\n                                              then\n                                                 Proj :=\n                                                   In_Tree.Units.Table (Index).\n                                                   File_Names\n-                                                    (Body_Part).Project;\n+                                                    (Impl).Project;\n                                                 Fname :=\n                                                   In_Tree.Units.Table (Index).\n-                                                   File_Names (Body_Part).Name;\n+                                                   File_Names (Impl).File;\n \n                                              elsif\n                                                In_Tree.Units.Table\n                                                  (Index).File_Names\n-                                                 (Specification).Name /=\n-                                                                       No_File\n+                                                 (Spec) /= null\n                                              then\n                                                 Proj :=\n                                                   In_Tree.Units.Table\n                                                     (Index).File_Names\n-                                                     (Specification).Project;\n+                                                     (Spec).Project;\n                                                 Fname :=\n                                                   In_Tree.Units.Table\n                                                     (Index).File_Names\n-                                                     (Specification).Name;\n+                                                     (Spec).File;\n \n                                              else\n                                                 Proj := No_Project;\n@@ -1842,15 +1840,16 @@ package body MLib.Prj is\n                            loop\n                               Unit := In_Tree.Units.Table (Index);\n \n-                              if Unit.File_Names (Body_Part).Project /=\n+                              if Unit.File_Names (Impl) /= null\n+                                and then Unit.File_Names (Impl).Project /=\n                                 No_Project\n                               then\n                                  if Ultimate_Extending_Project_Of\n-                                   (Unit.File_Names (Body_Part).Project) =\n+                                   (Unit.File_Names (Impl).Project) =\n                                     For_Project\n                                  then\n                                     Get_Name_String\n-                                      (Unit.File_Names (Body_Part).Name);\n+                                      (Unit.File_Names (Impl).File);\n                                     Name_Len := Name_Len -\n                                       File_Extension\n                                         (Name (1 .. Name_Len))'Length;\n@@ -1862,12 +1861,13 @@ package body MLib.Prj is\n                                     end if;\n                                  end if;\n \n-                              elsif Ultimate_Extending_Project_Of\n-                                (Unit.File_Names (Specification).Project) =\n-                                 For_Project\n+                              elsif Unit.File_Names (Spec) /= null\n+                                and then Ultimate_Extending_Project_Of\n+                                  (Unit.File_Names (Spec).Project) =\n+                                   For_Project\n                               then\n                                  Get_Name_String\n-                                   (Unit.File_Names (Specification).Name);\n+                                   (Unit.File_Names (Spec).File);\n                                  Name_Len :=\n                                    Name_Len -\n                                    File_Extension\n@@ -1983,23 +1983,25 @@ package body MLib.Prj is\n                      for Index in 1 .. Unit_Table.Last (In_Tree.Units) loop\n                         Unit := In_Tree.Units.Table (Index);\n \n-                        if Ultimate_Extending_Project_Of\n-                            (Unit.File_Names (Body_Part).Project) = For_Project\n+                        if Unit.File_Names (Impl) /= null\n+                          and then Ultimate_Extending_Project_Of\n+                            (Unit.File_Names (Impl).Project) = For_Project\n                           and then\n                             Get_Name_String\n-                              (Unit.File_Names (Body_Part).Name) =\n+                              (Unit.File_Names (Impl).File) =\n                             Name (1 .. Last)\n                         then\n                            Delete := True;\n                            exit;\n                         end if;\n \n-                        if Ultimate_Extending_Project_Of\n-                          (Unit.File_Names (Specification).Project) =\n+                        if Unit.File_Names (Spec) /= null\n+                          and then Ultimate_Extending_Project_Of\n+                            (Unit.File_Names (Spec).Project) =\n                              For_Project\n                           and then\n                            Get_Name_String\n-                             (Unit.File_Names (Specification).Name) =\n+                             (Unit.File_Names (Spec).File) =\n                            Name (1 .. Last)\n                         then\n                            Delete := True;\n@@ -2193,9 +2195,10 @@ package body MLib.Prj is\n             --  Find and copy the immediate or inherited source\n \n             for J in Data.File_Names'Range loop\n-               if Is_Same_Or_Extension\n-                    (For_Project, Data.File_Names (J).Project)\n-                 and then Data.File_Names (J).Name = File_Name\n+               if Data.File_Names (J) /= null\n+                 and then Is_Same_Or_Extension\n+                   (For_Project, Data.File_Names (J).Project)\n+                 and then Data.File_Names (J).File = File_Name\n                then\n                   Copy_File\n                     (Get_Name_String (Data.File_Names (J).Path.Name),"}, {"sha": "1d135cf4a930f571877859de21f8f41b0e0dfdd8", "filename": "gcc/ada/prj-env.adb", "status": "modified", "additions": 86, "deletions": 79, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj-env.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj-env.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-env.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -598,7 +598,7 @@ package body Prj.Env is\n          Put (File, \"pragma Source_File_Name_Project (\");\n          Put (File, Namet.Get_Name_String (Unit_Name));\n \n-         if Unit_Kind = Specification then\n+         if Unit_Kind = Spec then\n             Put (File, \", Spec_File_Name => \"\"\");\n          else\n             Put (File, \", Body_File_Name => \"\"\");\n@@ -681,18 +681,22 @@ package body Prj.Env is\n                  In_Tree.Units.Table (Current_Unit);\n \n             begin\n-               if Unit.File_Names (Specification).Needs_Pragma then\n+               if Unit.File_Names (Spec) /= null\n+                 and then Unit.File_Names (Spec).Naming_Exception\n+               then\n                   Put (Unit.Name,\n-                       Unit.File_Names (Specification).Name,\n-                       Specification,\n-                       Unit.File_Names (Specification).Index);\n+                       Unit.File_Names (Spec).File,\n+                       Spec,\n+                       Unit.File_Names (Spec).Index);\n                end if;\n \n-               if Unit.File_Names (Body_Part).Needs_Pragma then\n+               if Unit.File_Names (Impl) /= null\n+                 and then Unit.File_Names (Impl).Naming_Exception\n+               then\n                   Put (Unit.Name,\n-                       Unit.File_Names (Body_Part).Name,\n-                       Body_Part,\n-                       Unit.File_Names (Body_Part).Index);\n+                       Unit.File_Names (Impl).File,\n+                       Impl,\n+                       Unit.File_Names (Impl).Index);\n                end if;\n \n                Current_Unit := Current_Unit + 1;\n@@ -743,7 +747,7 @@ package body Prj.Env is\n \n    procedure Create_Mapping (In_Tree : Project_Tree_Ref) is\n       The_Unit_Data : Unit_Data;\n-      Data          : File_Name_Data;\n+      Data          : Source_Id;\n \n    begin\n       Fmap.Reset_Tables;\n@@ -754,32 +758,32 @@ package body Prj.Env is\n          --  Process only if the unit has a valid name\n \n          if The_Unit_Data.Name /= No_Name then\n-            Data := The_Unit_Data.File_Names (Specification);\n+            Data := The_Unit_Data.File_Names (Spec);\n \n             --  If there is a spec, put it in the mapping\n \n-            if Data.Name /= No_File then\n+            if Data /= null then\n                if Data.Path.Name = Slash then\n-                  Fmap.Add_Forbidden_File_Name (Data.Name);\n+                  Fmap.Add_Forbidden_File_Name (Data.File);\n                else\n                   Fmap.Add_To_File_Map\n                     (Unit_Name => Unit_Name_Type (The_Unit_Data.Name),\n-                     File_Name => Data.Name,\n+                     File_Name => Data.File,\n                      Path_Name => File_Name_Type (Data.Path.Name));\n                end if;\n             end if;\n \n-            Data := The_Unit_Data.File_Names (Body_Part);\n+            Data := The_Unit_Data.File_Names (Impl);\n \n             --  If there is a body (or subunit) put it in the mapping\n \n-            if Data.Name /= No_File then\n+            if Data /= null then\n                if Data.Path.Name = Slash then\n-                  Fmap.Add_Forbidden_File_Name (Data.Name);\n+                  Fmap.Add_Forbidden_File_Name (Data.File);\n                else\n                   Fmap.Add_To_File_Map\n                     (Unit_Name => Unit_Name_Type (The_Unit_Data.Name),\n-                     File_Name => Data.Name,\n+                     File_Name => Data.File,\n                      Path_Name => File_Name_Type (Data.Path.Name));\n                end if;\n             end if;\n@@ -807,7 +811,7 @@ package body Prj.Env is\n       Source        : Source_Id;\n       Suffix        : File_Name_Type;\n       The_Unit_Data : Unit_Data;\n-      Data          : File_Name_Data;\n+      Data          : Source_Id;\n       Iter          : Source_Iterator;\n \n       procedure Put_Name_Buffer;\n@@ -861,7 +865,7 @@ package body Prj.Env is\n \n          --  Line with the file name\n \n-         Get_Name_String (Data.Name);\n+         Get_Name_String (Data.File);\n          Put_Name_Buffer;\n \n          --  Line with the path name\n@@ -928,23 +932,23 @@ package body Prj.Env is\n                --  Case of unit has a valid name\n \n                if The_Unit_Data.Name /= No_Name then\n-                  Data := The_Unit_Data.File_Names (Specification);\n+                  Data := The_Unit_Data.File_Names (Spec);\n \n                   --  If there is a spec, put it mapping in the file if it is\n                   --  from a project in the closure of Project.\n \n-                  if Data.Name /= No_File\n+                  if Data /= No_Source\n                     and then Project_Boolean_Htable.Get (Present, Data.Project)\n                   then\n                      Put_Data (Spec => True);\n                   end if;\n \n-                  Data := The_Unit_Data.File_Names (Body_Part);\n+                  Data := The_Unit_Data.File_Names (Impl);\n \n                   --  If there is a body (or subunit) put its mapping in the\n                   --  file if it is from a project in the closure of Project.\n \n-                  if Data.Name /= No_File\n+                  if Data /= No_Source\n                     and then Project_Boolean_Htable.Get (Present, Data.Project)\n                   then\n                      Put_Data (Spec => False);\n@@ -1160,16 +1164,18 @@ package body Prj.Env is\n             --  Check for body\n \n             if not Main_Project_Only\n-              or else Unit.File_Names (Body_Part).Project = The_Project\n+              or else\n+                (Unit.File_Names (Impl) /= null\n+                 and then Unit.File_Names (Impl).Project = The_Project)\n             then\n                declare\n-                  Current_Name : constant File_Name_Type :=\n-                                   Unit.File_Names (Body_Part).Name;\n-\n+                  Current_Name : File_Name_Type;\n                begin\n                   --  Case of a body present\n \n-                  if Current_Name /= No_File then\n+                  if Unit.File_Names (Impl) /= null then\n+                     Current_Name := Unit.File_Names (Impl).File;\n+\n                      if Current_Verbosity = High then\n                         Write_Str  (\"   Comparing with \"\"\");\n                         Write_Str  (Get_Name_String (Current_Name));\n@@ -1190,7 +1196,7 @@ package body Prj.Env is\n \n                         if Full_Path then\n                            return Get_Name_String\n-                             (Unit.File_Names (Body_Part).Path.Name);\n+                             (Unit.File_Names (Impl).Path.Name);\n \n                         else\n                            return Get_Name_String (Current_Name);\n@@ -1206,7 +1212,7 @@ package body Prj.Env is\n \n                         if Full_Path then\n                            return Get_Name_String\n-                             (Unit.File_Names (Body_Part).Path.Name);\n+                             (Unit.File_Names (Impl).Path.Name);\n \n                         else\n                            return Extended_Body_Name;\n@@ -1224,16 +1230,19 @@ package body Prj.Env is\n             --  Check for spec\n \n             if not Main_Project_Only\n-              or else Unit.File_Names (Specification).Project = The_Project\n+              or else\n+                (Unit.File_Names (Spec) /= null\n+                 and then Unit.File_Names (Spec).Project =\n+                   The_Project)\n             then\n                declare\n-                  Current_Name : constant File_Name_Type :=\n-                                   Unit.File_Names (Specification).Name;\n+                  Current_Name : File_Name_Type;\n \n                begin\n                   --  Case of spec present\n \n-                  if Current_Name /= No_File then\n+                  if Unit.File_Names (Spec) /= null then\n+                     Current_Name := Unit.File_Names (Spec).File;\n                      if Current_Verbosity = High then\n                         Write_Str  (\"   Comparing with \"\"\");\n                         Write_Str  (Get_Name_String (Current_Name));\n@@ -1253,7 +1262,7 @@ package body Prj.Env is\n \n                         if Full_Path then\n                            return Get_Name_String\n-                             (Unit.File_Names (Specification).Path.Name);\n+                             (Unit.File_Names (Spec).Path.Name);\n                         else\n                            return Get_Name_String (Current_Name);\n                         end if;\n@@ -1268,7 +1277,7 @@ package body Prj.Env is\n \n                         if Full_Path then\n                            return Get_Name_String\n-                             (Unit.File_Names (Specification).Path.Name);\n+                             (Unit.File_Names (Spec).Path.Name);\n                         else\n                            return Extended_Spec_Name;\n                         end if;\n@@ -1406,40 +1415,43 @@ package body Prj.Env is\n          loop\n             Unit := In_Tree.Units.Table (Id);\n \n-            if (Unit.File_Names (Specification).Name /= No_File\n-                 and then\n-                   Namet.Get_Name_String\n-                     (Unit.File_Names (Specification).Name) = Original_Name)\n-              or else (Unit.File_Names (Specification).Path /=\n-                                                         No_Path_Information\n-                         and then\n-                           Namet.Get_Name_String\n-                           (Unit.File_Names (Specification).Path.Name) =\n-                                                              Original_Name)\n+            if Unit.File_Names (Spec) /= null\n+              and then Unit.File_Names (Spec).File /= No_File\n+              and then\n+                (Namet.Get_Name_String\n+                     (Unit.File_Names (Spec).File) = Original_Name\n+                 or else (Unit.File_Names (Spec).Path /=\n+                            No_Path_Information\n+                          and then\n+                            Namet.Get_Name_String\n+                              (Unit.File_Names (Spec).Path.Name) =\n+                            Original_Name))\n             then\n                Project := Ultimate_Extension_Of\n-                          (Project => Unit.File_Names (Specification).Project);\n-               Path := Unit.File_Names (Specification).Path.Display_Name;\n+                          (Project => Unit.File_Names (Spec).Project);\n+               Path := Unit.File_Names (Spec).Path.Display_Name;\n \n                if Current_Verbosity > Default then\n-                  Write_Str (\"Done: Specification.\");\n+                  Write_Str (\"Done: Spec.\");\n                   Write_Eol;\n                end if;\n \n                return;\n \n-            elsif (Unit.File_Names (Body_Part).Name /= No_File\n-                    and then\n-                      Namet.Get_Name_String\n-                        (Unit.File_Names (Body_Part).Name) = Original_Name)\n-              or else (Unit.File_Names (Body_Part).Path /= No_Path_Information\n-                         and then Namet.Get_Name_String\n-                                    (Unit.File_Names (Body_Part).Path.Name) =\n-                                                             Original_Name)\n+            elsif Unit.File_Names (Impl) /= null\n+              and then Unit.File_Names (Impl).File /= No_File\n+              and then\n+                (Namet.Get_Name_String\n+                   (Unit.File_Names (Impl).File) = Original_Name\n+                 or else (Unit.File_Names (Impl).Path /=\n+                            No_Path_Information\n+                          and then Namet.Get_Name_String\n+                            (Unit.File_Names (Impl).Path.Name) =\n+                            Original_Name))\n             then\n                Project := Ultimate_Extension_Of\n-                            (Project => Unit.File_Names (Body_Part).Project);\n-               Path := Unit.File_Names (Body_Part).Path.Display_Name;\n+                            (Project => Unit.File_Names (Impl).Project);\n+               Path := Unit.File_Names (Impl).Path.Display_Name;\n \n                if Current_Verbosity > Default then\n                   Write_Str (\"Done: Body.\");\n@@ -1490,38 +1502,37 @@ package body Prj.Env is\n          Write_Str  (\"   \");\n          Write_Line (Namet.Get_Name_String (Unit.Name));\n \n-         if Unit.File_Names (Specification).Name /= No_File then\n-            if Unit.File_Names (Specification).Project = No_Project then\n+         if Unit.File_Names (Spec).File /= No_File then\n+            if Unit.File_Names (Spec).Project = No_Project then\n                Write_Line (\"   No project\");\n \n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (Unit.File_Names (Specification).Project.Path.Name);\n+                 (Unit.File_Names (Spec).Project.Path.Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n \n             Write_Str  (\"      spec: \");\n             Write_Line\n               (Namet.Get_Name_String\n-               (Unit.File_Names (Specification).Name));\n+               (Unit.File_Names (Spec).File));\n          end if;\n \n-         if Unit.File_Names (Body_Part).Name /= No_File then\n-            if Unit.File_Names (Body_Part).Project = No_Project then\n+         if Unit.File_Names (Impl).File /= No_File then\n+            if Unit.File_Names (Impl).Project = No_Project then\n                Write_Line (\"   No project\");\n \n             else\n                Write_Str  (\"   Project: \");\n                Get_Name_String\n-                 (Unit.File_Names (Body_Part).Project.Path.Name);\n+                 (Unit.File_Names (Impl).Project.Path.Name);\n                Write_Line (Name_Buffer (1 .. Name_Len));\n             end if;\n \n             Write_Str  (\"      body: \");\n             Write_Line\n-              (Namet.Get_Name_String\n-               (Unit.File_Names (Body_Part).Name));\n+              (Namet.Get_Name_String (Unit.File_Names (Impl).File));\n          end if;\n       end loop;\n \n@@ -1574,13 +1585,10 @@ package body Prj.Env is\n       loop\n          Unit := In_Tree.Units.Table (Current);\n \n-         --  Check for body\n-\n-         Current_Name := Unit.File_Names (Body_Part).Name;\n-\n          --  Case of a body present\n \n-         if Current_Name /= No_File then\n+         if Unit.File_Names (Impl) /= null then\n+            Current_Name := Unit.File_Names (Impl).File;\n \n             --  If it has the name of the original name or the body name,\n             --  we have found the project.\n@@ -1589,16 +1597,15 @@ package body Prj.Env is\n               or else Current_Name = The_Original_Name\n               or else Current_Name = The_Body_Name\n             then\n-               Result := Unit.File_Names (Body_Part).Project;\n+               Result := Unit.File_Names (Impl).Project;\n                exit;\n             end if;\n          end if;\n \n          --  Check for spec\n \n-         Current_Name := Unit.File_Names (Specification).Name;\n-\n-         if Current_Name /= No_File then\n+         if Unit.File_Names (Spec) /= null then\n+            Current_Name := Unit.File_Names (Spec).File;\n \n             --  If name same as the original name, or the spec name, we have\n             --  found the project.\n@@ -1607,7 +1614,7 @@ package body Prj.Env is\n               or else Current_Name = The_Original_Name\n               or else Current_Name = The_Spec_Name\n             then\n-               Result := Unit.File_Names (Specification).Project;\n+               Result := Unit.File_Names (Spec).Project;\n                exit;\n             end if;\n          end if;"}, {"sha": "a203f8378dfcf1c75222812690e5556cb3938523", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 52, "deletions": 62, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -850,9 +850,9 @@ package body Prj.Nmsc is\n \n       if Get_Mode = Ada_Only then\n          Prepare_Ada_Naming_Exceptions\n-           (Project.Naming.Bodies, In_Tree, Body_Part);\n+           (Project.Naming.Bodies, In_Tree, Impl);\n          Prepare_Ada_Naming_Exceptions\n-           (Project.Naming.Specs, In_Tree, Specification);\n+           (Project.Naming.Specs, In_Tree, Spec);\n       end if;\n \n       --  Find the sources\n@@ -1702,7 +1702,7 @@ package body Prj.Nmsc is\n \n                   if Lang_Index /= No_Language_Index then\n                      case Current_Array.Name is\n-                        when Name_Specification_Suffix | Name_Spec_Suffix =>\n+                        when Name_Spec_Suffix | Name_Specification_Suffix =>\n \n                            --  Attribute Spec_Suffix (<language>)\n \n@@ -2978,7 +2978,7 @@ package body Prj.Nmsc is\n \n                if Exceptions = No_Array_Element then\n                   Exceptions := Value_Of\n-                    (Name_Specification,\n+                    (Name_Spec,\n                      In_Arrays => Naming.Decl.Arrays,\n                      In_Tree   => In_Tree);\n                end if;\n@@ -3282,7 +3282,7 @@ package body Prj.Nmsc is\n             if Suffix = Nil_Variable_Value then\n                Suffix := Value_Of\n                  (Name                    => Lang,\n-                  Attribute_Or_Array_Name => Name_Specification_Suffix,\n+                  Attribute_Or_Array_Name => Name_Spec_Suffix,\n                   In_Package              => Naming_Id,\n                   In_Tree                 => In_Tree);\n             end if;\n@@ -4133,7 +4133,7 @@ package body Prj.Nmsc is\n                   Suffix := Element.Next;\n                end loop;\n \n-               --  Put the resulting array as the specification suffixes\n+               --  Put the resulting array as the Spec suffixes\n \n                Project.Naming.Spec_Suffix := Spec_Suffixs;\n             end if;\n@@ -4541,30 +4541,28 @@ package body Prj.Nmsc is\n \n                         UData := In_Tree.Units.Table (The_Unit_Id);\n \n-                        if UData.File_Names (Body_Part).Name /= No_File\n+                        if UData.File_Names (Impl) /= null\n                           and then\n-                            UData.File_Names (Body_Part).Path.Name /=\n+                            UData.File_Names (Impl).Path.Name /=\n                              Slash\n                         then\n                            if Check_Project\n-                             (UData.File_Names (Body_Part).Project,\n+                             (UData.File_Names (Impl).Project,\n                               Project, Extending)\n                            then\n                               --  There is a body for this unit.\n                               --  If there is no spec, we need to check that it\n                               --  is not a subunit.\n \n-                              if UData.File_Names (Specification).Name =\n-                                No_File\n-                              then\n+                              if UData.File_Names (Spec) = null then\n                                  declare\n                                     Src_Ind : Source_File_Index;\n \n                                  begin\n                                     Src_Ind := Sinput.P.Load_Project_File\n                                       (Get_Name_String\n                                          (UData.File_Names\n-                                            (Body_Part).Path.Name));\n+                                            (Impl).Path.Name));\n \n                                     if Sinput.P.Source_File_Is_Subunit\n                                       (Src_Ind)\n@@ -4584,7 +4582,7 @@ package body Prj.Nmsc is\n                               --  ALI file for its body to the Interface ALIs.\n \n                               Add_ALI_For\n-                                (UData.File_Names (Body_Part).Name);\n+                                (UData.File_Names (Impl).File);\n \n                            else\n                               Error_Msg\n@@ -4594,13 +4592,12 @@ package body Prj.Nmsc is\n                                    (Interfaces).Location);\n                            end if;\n \n-                        elsif UData.File_Names (Specification).Name /=\n-                             No_File\n+                        elsif UData.File_Names (Spec) /= null\n                           and then UData.File_Names\n-                                     (Specification).Path.Name /= Slash\n+                                     (Spec).Path.Name /= Slash\n                           and then Check_Project\n                                      (UData.File_Names\n-                                        (Specification).Project,\n+                                        (Spec).Project,\n                                       Project, Extending)\n \n                         then\n@@ -4609,7 +4606,7 @@ package body Prj.Nmsc is\n                            --  Interface ALIs.\n \n                            Add_ALI_For\n-                             (UData.File_Names (Specification).Name);\n+                             (UData.File_Names (Spec).File);\n \n                         else\n                            Error_Msg\n@@ -6360,7 +6357,7 @@ package body Prj.Nmsc is\n       if Info_Id /= No_Ada_Naming_Exception then\n          Exception_Id := Info_Id;\n          Unit_Name := No_Name;\n-         Unit_Kind := Specification;\n+         Unit_Kind := Spec;\n \n       else\n          Exception_Id := No_Ada_Naming_Exception;\n@@ -6376,8 +6373,8 @@ package body Prj.Nmsc is\n             In_Tree         => In_Tree);\n \n          case Kind is\n-            when Spec       => Unit_Kind := Specification;\n-            when Impl | Sep => Unit_Kind := Body_Part;\n+            when Spec       => Unit_Kind := Spec;\n+            when Impl | Sep => Unit_Kind := Impl;\n          end case;\n       end if;\n    end Get_Unit;\n@@ -7770,7 +7767,7 @@ package body Prj.Nmsc is\n \n                if Index /= No_Unit_Index then\n                   Unit.File_Names (Kind).Path.Name    := Slash;\n-                  Unit.File_Names (Kind).Needs_Pragma := False;\n+                  Unit.File_Names (Kind).Naming_Exception := False;\n                   In_Tree.Units.Table (Index) := Unit;\n                end if;\n \n@@ -7815,7 +7812,9 @@ package body Prj.Nmsc is\n                   Unit := In_Tree.Units.Table (Index);\n \n                   for Kind in Spec_Or_Body'Range loop\n-                     if Unit.File_Names (Kind).Name = Excluded.File then\n+                     if Unit.File_Names (Kind) /= null\n+                       and then Unit.File_Names (Kind).File = Excluded.File\n+                     then\n                         Exclude (Unit.File_Names (Kind).Project, Index, Kind);\n                         exit For_Each_Unit;\n                      end if;\n@@ -7829,7 +7828,7 @@ package body Prj.Nmsc is\n                   exit when Source = No_Source;\n \n                   if Source.File = Excluded.File then\n-                     Exclude (Source.Project, No_Unit_Index, Specification);\n+                     Exclude (Source.Project, No_Unit_Index, Spec);\n                      exit;\n                   end if;\n \n@@ -8105,29 +8104,21 @@ package body Prj.Nmsc is\n          if The_Unit /= No_Unit_Index then\n             UData := In_Tree.Units.Table (The_Unit);\n \n-            if (UData.File_Names (Unit_Kind).Name = Canonical_File\n-                 and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n-              or else UData.File_Names (Unit_Kind).Name = No_File\n-              or else Is_Extending\n-                        (Project.Extends, UData.File_Names (Unit_Kind).Project)\n+            if UData.File_Names (Unit_Kind) = null\n+              or else\n+                ((UData.File_Names (Unit_Kind).File = Canonical_File\n+                  and then UData.File_Names (Unit_Kind).Path.Name = Slash)\n+                 or else UData.File_Names (Unit_Kind).File = No_File\n+                 or else Is_Extending\n+                   (Project.Extends, UData.File_Names (Unit_Kind).Project))\n             then\n-               if UData.File_Names (Unit_Kind).Path.Name = Slash then\n+               if UData.File_Names (Unit_Kind) /= null\n+                 and then UData.File_Names (Unit_Kind).Path.Name = Slash\n+               then\n                   Remove_Forbidden_File_Name\n-                    (UData.File_Names (Unit_Kind).Name);\n+                    (UData.File_Names (Unit_Kind).File);\n                end if;\n \n-               --  Record the file name in the hash table Files_Htable\n-\n-               Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n-\n-               UData.File_Names (Unit_Kind) :=\n-                 (Name         => Canonical_File,\n-                  Index        => Unit_Ind,\n-                  Display_Name => File_Name,\n-                  Path         => (Canonical_Path, Path_Name),\n-                  Project      => Project,\n-                  Needs_Pragma => Needs_Pragma);\n-               In_Tree.Units.Table (The_Unit) := UData;\n                To_Record       := True;\n                Source_Recorded := True;\n \n@@ -8189,31 +8180,24 @@ package body Prj.Nmsc is\n                   Location);\n \n             else\n+               UData.Name := Unit_Name;\n                Unit_Table.Increment_Last (In_Tree.Units);\n                The_Unit := Unit_Table.Last (In_Tree.Units);\n                Units_Htable.Set (In_Tree.Units_HT, Unit_Name, The_Unit);\n \n-               Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n-\n-               UData.Name := Unit_Name;\n-               UData.File_Names (Unit_Kind) :=\n-                 (Name         => Canonical_File,\n-                  Index        => Unit_Ind,\n-                  Display_Name => File_Name,\n-                  Path         => (Canonical_Path, Path_Name),\n-                  Project      => Project,\n-                  Needs_Pragma => Needs_Pragma);\n-               In_Tree.Units.Table (The_Unit) := UData;\n-\n                Source_Recorded := True;\n                To_Record := True;\n             end if;\n          end if;\n \n          if To_Record then\n+            Files_Htable.Set (Proc_Data.Units, Canonical_File, Project);\n+\n             case Unit_Kind is\n-               when Body_Part      => Kind := Impl;\n-               when Specification  => Kind := Spec;\n+               when Impl      =>\n+                  Kind := Impl;\n+               when Spec  =>\n+                  Kind := Spec;\n             end case;\n \n             Add_Source\n@@ -8226,8 +8210,13 @@ package body Prj.Nmsc is\n                Display_File        => File_Name,\n                Unit                => Unit_Name,\n                Path                => (Canonical_Path, Path_Name),\n+               Naming_Exception    => Needs_Pragma,\n                Kind                => Kind,\n+               Index               => Unit_Ind,\n                Other_Part          => No_Source);  --  ??? Can we find file ?\n+\n+            UData.File_Names (Unit_Kind) := Source;\n+            In_Tree.Units.Table (The_Unit) := UData;\n          end if;\n       end Record_Unit;\n \n@@ -8451,7 +8440,7 @@ package body Prj.Nmsc is\n \n             if Specs then\n                if not Check_Project\n-                 (The_Unit_Data.File_Names (Specification).Project,\n+                 (The_Unit_Data.File_Names (Spec).Project,\n                   Project, Extending)\n                then\n                   Error_Msg\n@@ -8462,9 +8451,10 @@ package body Prj.Nmsc is\n                end if;\n \n             else\n-               if not Check_Project\n-                 (The_Unit_Data.File_Names (Body_Part).Project,\n-                  Project, Extending)\n+               if The_Unit_Data.File_Names (Impl) = null\n+                 or else not Check_Project\n+                   (The_Unit_Data.File_Names (Impl).Project,\n+                    Project, Extending)\n                then\n                   Error_Msg\n                     (Project, In_Tree,"}, {"sha": "0ea15df84541ca6779e30c56862decb149271448", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 5, "deletions": 14, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/852dba8059832d76c74e1e6f31d65a9302a0baa7/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=852dba8059832d76c74e1e6f31d65a9302a0baa7", "patch": "@@ -626,6 +626,7 @@ package Prj is\n \n       Lang_Kind           : Language_Kind         := File_Based;\n       --  Kind of the language\n+      --  ??? Should be in Language itself\n \n       Compiled            : Boolean               := True;\n       --  False when there is no compiler for the language\n@@ -675,6 +676,8 @@ package Prj is\n \n       Path                : Path_Information      := No_Path_Information;\n       --  Path name of the source\n+      --  Path.Name is set to Slash for an excluded file that does not belong\n+      --  in the project in fact\n \n       Source_TS           : Time_Stamp_Type       := Empty_Time_Stamp;\n       --  Time stamp of the source file\n@@ -1342,20 +1345,8 @@ package Prj is\n    Project_Error : exception;\n    --  Raised by some subprograms in Prj.Attr\n \n-   type Spec_Or_Body is (Specification, Body_Part);\n-\n-   type File_Name_Data is record\n-      Name         : File_Name_Type   := No_File;\n-      Index        : Int              := 0;\n-      Display_Name : File_Name_Type   := No_File;\n-      Path         : Path_Information := No_Path_Information;\n-      Project      : Project_Id       := No_Project;\n-      Needs_Pragma : Boolean          := False;\n-   end record;\n-   --  File and Path name of a spec or body\n-\n-   type File_Names_Data is array (Spec_Or_Body) of File_Name_Data;\n-\n+   subtype Spec_Or_Body is Source_Kind range Spec .. Impl;\n+   type File_Names_Data is array (Spec_Or_Body) of Source_Id;\n    type Unit_Index is new Nat;\n    No_Unit_Index : constant Unit_Index := 0;\n    type Unit_Data is record"}]}