{"sha": "b78fd1642a52a841780204061dbf23827cbca334", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjc4ZmQxNjQyYTUyYTg0MTc4MDIwNDA2MWRiZjIzODI3Y2JjYTMzNA==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-06-13T19:38:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-06-13T19:38:11Z"}, "message": "read-rtl.c (mapping): Remove index field.\n\ngcc/\n\t* read-rtl.c (mapping): Remove index field.  Add current_value field.\n\tDefine heap vectors.\n\t(iterator_group): Fix long line.  Remove num_builtins field and\n\tuses_iterator fields.  Make apply_iterator take a void * parameter.\n\t(iterator_use, atttribute_use): New structures.\n\t(iterator_traverse_data, BELLWETHER_CODE, bellwether_codes): Delete.\n\t(current_iterators, iterator_uses, attribute_uses): New variables.\n\t(uses_mode_iterator_p, uses_code_iterator_p): Delete.\n\t(apply_mode_iterator, apply_code_iterator): Take a void * parameter.\n\t(map_attr_string, apply_iterator_to_string): Remove iterator\n\tand value parameters.  Look through all current iterator values\n\tfor a matching attribute.\n\t(mode_attr_index, apply_mode_maps): Delete.\n\t(apply_iterator_to_rtx): Replace with...\n\t(copy_rtx_for_iterators): ...this new function.\n\t(uses_iterator_p, apply_iterator_traverse): Delete.\n\t(apply_attribute_uses, add_current_iterators, apply_iterators): New\n\tfunctions.\n\t(add_mapping): Remove index field.  Set current_value field.\n\t(initialize_iterators): Don't set num_builtins and uses_iterator_p\n\tfields.\n\t(find_iterator): Delete.\n\t(record_iterator_use, record_attribute_use): New functions.\n\t(record_potential_iterator_use): New function.\n\t(check_code_iterator): Remove handling of bellwether codes.\n\t(read_rtx): Remove mode maps.  Truncate iterator and attribute uses.\n\t(read_rtx_code, read_nested_rtx, read_rtx_variadic): Remove mode_maps\n\tparameter.  Use the first code iterator value instead of the\n\tbellwether_codes array.  Use record_potential_iterator_use\n\tfor modes.\n\nFrom-SVN: r188525", "tree": {"sha": "bf3e0190d0515ca1aa0a57fa970415483653cc18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bf3e0190d0515ca1aa0a57fa970415483653cc18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b78fd1642a52a841780204061dbf23827cbca334", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78fd1642a52a841780204061dbf23827cbca334", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78fd1642a52a841780204061dbf23827cbca334", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78fd1642a52a841780204061dbf23827cbca334/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "638a085f5c16d6557ffa7f40b73ef80d354ed8bd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/638a085f5c16d6557ffa7f40b73ef80d354ed8bd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/638a085f5c16d6557ffa7f40b73ef80d354ed8bd"}], "stats": {"total": 637, "additions": 318, "deletions": 319}, "files": [{"sha": "684361f11770dc319c3c44a132d52dd410415ab5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78fd1642a52a841780204061dbf23827cbca334/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78fd1642a52a841780204061dbf23827cbca334/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b78fd1642a52a841780204061dbf23827cbca334", "patch": "@@ -1,3 +1,36 @@\n+2012-06-13  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* read-rtl.c (mapping): Remove index field.  Add current_value field.\n+\tDefine heap vectors.\n+\t(iterator_group): Fix long line.  Remove num_builtins field and\n+\tuses_iterator fields.  Make apply_iterator take a void * parameter.\n+\t(iterator_use, atttribute_use): New structures.\n+\t(iterator_traverse_data, BELLWETHER_CODE, bellwether_codes): Delete.\n+\t(current_iterators, iterator_uses, attribute_uses): New variables.\n+\t(uses_mode_iterator_p, uses_code_iterator_p): Delete.\n+\t(apply_mode_iterator, apply_code_iterator): Take a void * parameter.\n+\t(map_attr_string, apply_iterator_to_string): Remove iterator\n+\tand value parameters.  Look through all current iterator values\n+\tfor a matching attribute.\n+\t(mode_attr_index, apply_mode_maps): Delete.\n+\t(apply_iterator_to_rtx): Replace with...\n+\t(copy_rtx_for_iterators): ...this new function.\n+\t(uses_iterator_p, apply_iterator_traverse): Delete.\n+\t(apply_attribute_uses, add_current_iterators, apply_iterators): New\n+\tfunctions.\n+\t(add_mapping): Remove index field.  Set current_value field.\n+\t(initialize_iterators): Don't set num_builtins and uses_iterator_p\n+\tfields.\n+\t(find_iterator): Delete.\n+\t(record_iterator_use, record_attribute_use): New functions.\n+\t(record_potential_iterator_use): New function.\n+\t(check_code_iterator): Remove handling of bellwether codes.\n+\t(read_rtx): Remove mode maps.  Truncate iterator and attribute uses.\n+\t(read_rtx_code, read_nested_rtx, read_rtx_variadic): Remove mode_maps\n+\tparameter.  Use the first code iterator value instead of the\n+\tbellwether_codes array.  Use record_potential_iterator_use\n+\tfor modes.\n+\n 2012-06-13  Oleg Endo  <olegendo@gcc.gnu.org>\n \n \tPR target/53568"}, {"sha": "c588722a4ec3cba4c0cec4cf00560b10e766960f", "filename": "gcc/read-rtl.c", "status": "modified", "additions": 285, "deletions": 319, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b78fd1642a52a841780204061dbf23827cbca334/gcc%2Fread-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b78fd1642a52a841780204061dbf23827cbca334/gcc%2Fread-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fread-rtl.c?ref=b78fd1642a52a841780204061dbf23827cbca334", "patch": "@@ -41,7 +41,7 @@ struct map_value {\n };\n \n /* Maps an iterator or attribute name to a list of (integer, string) pairs.\n-   The integers are mode or code values; the strings are either C conditions\n+   The integers are iterator values; the strings are either C conditions\n    or attribute values.  */\n struct mapping {\n   /* The name of the iterator or attribute.  */\n@@ -50,82 +50,80 @@ struct mapping {\n   /* The group (modes or codes) to which the iterator or attribute belongs.  */\n   struct iterator_group *group;\n \n-  /* Gives a unique number to the attribute or iterator.  Numbers are\n-     allocated consecutively, starting at 0.  */\n-  int index;\n-\n   /* The list of (integer, string) pairs.  */\n   struct map_value *values;\n+\n+  /* For iterators, records the current value of the iterator.  */\n+  struct map_value *current_value;\n };\n \n-/* A structure for abstracting the common parts of code and mode iterators.  */\n+/* Vector definitions for the above.  */\n+typedef struct mapping *mapping_ptr;\n+DEF_VEC_P (mapping_ptr);\n+DEF_VEC_ALLOC_P (mapping_ptr, heap);\n+\n+/* A structure for abstracting the common parts of iterators.  */\n struct iterator_group {\n-  /* Tables of \"mapping\" structures, one for attributes and one for iterators.  */\n+  /* Tables of \"mapping\" structures, one for attributes and one for\n+     iterators.  */\n   htab_t attrs, iterators;\n \n-  /* The number of \"real\" modes or codes (and by extension, the first\n-     number available for use as an iterator placeholder).  */\n-  int num_builtins;\n-\n-  /* Treat the given string as the name of a standard mode or code and\n+  /* Treat the given string as the name of a standard mode, etc., and\n      return its integer value.  */\n   int (*find_builtin) (const char *);\n \n-  /* Return true if the given rtx uses the given mode or code.  */\n-  bool (*uses_iterator_p) (rtx, int);\n+  /* Make the given pointer use the given iterator value.  */\n+  void (*apply_iterator) (void *, int);\n+};\n \n-  /* Make the given rtx use the given mode or code.  */\n-  void (*apply_iterator) (rtx, int);\n+/* Records one use of an iterator.  */\n+struct iterator_use {\n+  /* The iterator itself.  */\n+  struct mapping *iterator;\n+\n+  /* The location of the use, as passed to the apply_iterator callback.  */\n+  void *ptr;\n };\n \n-/* A structure used to pass data from read_rtx to apply_iterator_traverse\n-   via htab_traverse.  */\n-struct iterator_traverse_data {\n-  /* Instruction queue.  */\n-  rtx queue;\n-  /* Attributes seen for modes.  */\n-  struct map_value *mode_maps;\n-  /* The last unknown attribute used as a mode.  */\n-  const char *unknown_mode_attr;\n+/* Vector definitions for the above.  */\n+typedef struct iterator_use iterator_use;\n+DEF_VEC_O (iterator_use);\n+DEF_VEC_ALLOC_O (iterator_use, heap);\n+\n+/* Records one use of an attribute (the \"<[iterator:]attribute>\" syntax)\n+   in a non-string rtx field.  */\n+struct attribute_use {\n+  /* The group that describes the use site.  */\n+  struct iterator_group *group;\n+\n+  /* The name of the attribute, possibly with an \"iterator:\" prefix.  */\n+  const char *value;\n+\n+  /* The location of the use, as passed to GROUP's apply_iterator callback.  */\n+  void *ptr;\n };\n \n-/* If CODE is the number of a code iterator, return a real rtx code that\n-   has the same format.  Return CODE otherwise.  */\n-#define BELLWETHER_CODE(CODE) \\\n-  ((CODE) < NUM_RTX_CODE ? CODE : bellwether_codes[CODE - NUM_RTX_CODE])\n-\n-static int find_mode (const char *);\n-static bool uses_mode_iterator_p (rtx, int);\n-static void apply_mode_iterator (rtx, int);\n-static int find_code (const char *);\n-static bool uses_code_iterator_p (rtx, int);\n-static void apply_code_iterator (rtx, int);\n-static const char *apply_iterator_to_string (const char *, struct mapping *, int);\n-static rtx apply_iterator_to_rtx (rtx, struct mapping *, int,\n-\t\t\t\t  struct map_value *, const char **);\n-static bool uses_iterator_p (rtx, struct mapping *);\n-static const char *add_condition_to_string (const char *, const char *);\n-static void add_condition_to_rtx (rtx, const char *);\n-static int apply_iterator_traverse (void **, void *);\n-static struct mapping *add_mapping (struct iterator_group *, htab_t t,\n-\t\t\t\t    const char *);\n-static struct map_value **add_map_value (struct map_value **,\n-\t\t\t\t\t int, const char *);\n-static void initialize_iterators (void);\n-static void read_conditions (void);\n+/* Vector definitions for the above.  */\n+typedef struct attribute_use attribute_use;\n+DEF_VEC_O (attribute_use);\n+DEF_VEC_ALLOC_O (attribute_use, heap);\n+\n static void validate_const_int (const char *);\n-static int find_iterator (struct iterator_group *, const char *);\n-static struct mapping *read_mapping (struct iterator_group *, htab_t);\n-static void check_code_iterator (struct mapping *);\n-static rtx read_rtx_code (const char *, struct map_value **);\n-static rtx read_nested_rtx (struct map_value **);\n-static rtx read_rtx_variadic (struct map_value **, rtx);\n+static rtx read_rtx_code (const char *);\n+static rtx read_nested_rtx (void);\n+static rtx read_rtx_variadic (rtx);\n \n /* The mode and code iterator structures.  */\n static struct iterator_group modes, codes;\n \n-/* Index I is the value of BELLWETHER_CODE (I + NUM_RTX_CODE).  */\n-static enum rtx_code *bellwether_codes;\n+/* All iterators used in the current rtx.  */\n+static VEC (mapping_ptr, heap) *current_iterators;\n+\n+/* The list of all iterator uses in the current rtx.  */\n+static VEC (iterator_use, heap) *iterator_uses;\n+\n+/* The list of all attribute uses in the current rtx.  */\n+static VEC (attribute_use, heap) *attribute_uses;\n \n /* Implementations of the iterator_group callbacks for modes.  */\n \n@@ -141,16 +139,10 @@ find_mode (const char *name)\n   fatal_with_file_and_line (\"unknown mode `%s'\", name);\n }\n \n-static bool\n-uses_mode_iterator_p (rtx x, int mode)\n-{\n-  return (int) GET_MODE (x) == mode;\n-}\n-\n static void\n-apply_mode_iterator (rtx x, int mode)\n+apply_mode_iterator (void *loc, int mode)\n {\n-  PUT_MODE (x, (enum machine_mode) mode);\n+  PUT_MODE ((rtx) loc, (enum machine_mode) mode);\n }\n \n /* Implementations of the iterator_group callbacks for codes.  */\n@@ -167,122 +159,64 @@ find_code (const char *name)\n   fatal_with_file_and_line (\"unknown rtx code `%s'\", name);\n }\n \n-static bool\n-uses_code_iterator_p (rtx x, int code)\n-{\n-  return (int) GET_CODE (x) == code;\n-}\n-\n static void\n-apply_code_iterator (rtx x, int code)\n+apply_code_iterator (void *loc, int code)\n {\n-  PUT_CODE (x, (enum rtx_code) code);\n+  PUT_CODE ((rtx) loc, (enum rtx_code) code);\n }\n \n-/* Map a code or mode attribute string P to the underlying string for\n-   ITERATOR and VALUE.  */\n+/* Map attribute string P to its current value.  Return null if the attribute\n+   isn't known.  */\n \n static struct map_value *\n-map_attr_string (const char *p, struct mapping *iterator, int value)\n+map_attr_string (const char *p)\n {\n   const char *attr;\n+  struct mapping *iterator;\n+  unsigned int i;\n   struct mapping *m;\n   struct map_value *v;\n+  int iterator_name_len;\n \n-  /* If there's a \"iterator:\" prefix, check whether the iterator name matches.\n-     Set ATTR to the start of the attribute name.  */\n+  /* Peel off any \"iterator:\" prefix.  Set ATTR to the start of the\n+     attribute name.  */\n   attr = strchr (p, ':');\n   if (attr == 0)\n-    attr = p;\n+    {\n+      iterator_name_len = -1;\n+      attr = p;\n+    }\n   else\n     {\n-      if (strncmp (p, iterator->name, attr - p) != 0\n-\t  || iterator->name[attr - p] != 0)\n-\treturn 0;\n+      iterator_name_len = attr - p;\n       attr++;\n     }\n \n-  /* Find the attribute specification.  */\n-  m = (struct mapping *) htab_find (iterator->group->attrs, &attr);\n-  if (m == 0)\n-    return 0;\n-\n-  /* Find the attribute value for VALUE.  */\n-  for (v = m->values; v != 0; v = v->next)\n-    if (v->number == value)\n-      break;\n-\n-  return v;\n-}\n-\n-/* Given an attribute string used as a machine mode, return an index\n-   to store in the machine mode to be translated by\n-   apply_iterator_to_rtx.  */\n-\n-static unsigned int\n-mode_attr_index (struct map_value **mode_maps, const char *string)\n-{\n-  char *p;\n-  struct map_value *mv;\n-\n-  /* Copy the attribute string into permanent storage, without the\n-     angle brackets around it.  */\n-  obstack_grow0 (&string_obstack, string + 1, strlen (string) - 2);\n-  p = XOBFINISH (&string_obstack, char *);\n-\n-  mv = XNEW (struct map_value);\n-  mv->number = *mode_maps == 0 ? 0 : (*mode_maps)->number + 1;\n-  mv->string = p;\n-  mv->next = *mode_maps;\n-  *mode_maps = mv;\n-\n-  /* We return a code which we can map back into this string: the\n-     number of machine modes + the number of mode iterators + the index\n-     we just used.  */\n-  return MAX_MACHINE_MODE + htab_elements (modes.iterators) + mv->number;\n-}\n-\n-/* Apply MODE_MAPS to the top level of X, expanding cases where an\n-   attribute is used for a mode.  ITERATOR is the current iterator we are\n-   expanding, and VALUE is the value to which we are expanding it.\n-   This sets *UNKNOWN to true if we find a mode attribute which has not\n-   yet been defined, and does not change it otherwise.  */\n-\n-static void\n-apply_mode_maps (rtx x, struct map_value *mode_maps, struct mapping *iterator,\n-\t\t int value, const char **unknown)\n-{\n-  unsigned int offset;\n-  int indx;\n-  struct map_value *pm;\n-\n-  offset = MAX_MACHINE_MODE + htab_elements (modes.iterators);\n-  if (GET_MODE (x) < offset)\n-    return;\n-\n-  indx = GET_MODE (x) - offset;\n-  for (pm = mode_maps; pm; pm = pm->next)\n+  FOR_EACH_VEC_ELT (mapping_ptr, current_iterators, i, iterator)\n     {\n-      if (pm->number == indx)\n-\t{\n-\t  struct map_value *v;\n+      /* If an iterator name was specified, check that it matches.  */\n+      if (iterator_name_len >= 0\n+\t  && (strncmp (p, iterator->name, iterator_name_len) != 0\n+\t      || iterator->name[iterator_name_len] != 0))\n+\tcontinue;\n \n-\t  v = map_attr_string (pm->string, iterator, value);\n-\t  if (v)\n-\t    PUT_MODE (x, (enum machine_mode) find_mode (v->string));\n-\t  else\n-\t    *unknown = pm->string;\n-\t  return;\n-\t}\n+      /* Find the attribute specification.  */\n+      m = (struct mapping *) htab_find (iterator->group->attrs, &attr);\n+      if (m)\n+\t/* Find the attribute value associated with the current\n+\t   iterator value.  */\n+\tfor (v = m->values; v; v = v->next)\n+\t  if (v->number == iterator->current_value->number)\n+\t    return v;\n     }\n+  return NULL;\n }\n \n-/* Given that ITERATOR is being expanded as VALUE, apply the appropriate\n-   string substitutions to STRING.  Return the new string if any changes\n-   were needed, otherwise return STRING itself.  */\n+/* Apply the current iterator values to STRING.  Return the new string\n+   if any changes were needed, otherwise return STRING itself.  */\n \n static const char *\n-apply_iterator_to_string (const char *string, struct mapping *iterator, int value)\n+apply_iterator_to_string (const char *string)\n {\n   char *base, *copy, *p, *start, *end;\n   struct map_value *v;\n@@ -296,7 +230,7 @@ apply_iterator_to_string (const char *string, struct mapping *iterator, int valu\n       p = start + 1;\n \n       *end = 0;\n-      v = map_attr_string (p, iterator, value);\n+      v = map_attr_string (p);\n       *end = '>';\n       if (v == 0)\n \tcontinue;\n@@ -317,55 +251,39 @@ apply_iterator_to_string (const char *string, struct mapping *iterator, int valu\n   return string;\n }\n \n-/* Return a copy of ORIGINAL in which all uses of ITERATOR have been\n-   replaced by VALUE.  MODE_MAPS holds information about attribute\n-   strings used for modes.  This sets *UNKNOWN_MODE_ATTR to the value of\n-   an unknown mode attribute, and does not change it otherwise.  */\n+/* Return a deep copy of X, substituting the current iterator\n+   values into any strings.  */\n \n static rtx\n-apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n-\t\t       struct map_value *mode_maps,\n-\t\t       const char **unknown_mode_attr)\n+copy_rtx_for_iterators (rtx original)\n {\n-  struct iterator_group *group;\n   const char *format_ptr;\n   int i, j;\n   rtx x;\n-  enum rtx_code bellwether_code;\n \n   if (original == 0)\n     return original;\n \n   /* Create a shallow copy of ORIGINAL.  */\n-  bellwether_code = BELLWETHER_CODE (GET_CODE (original));\n-  x = rtx_alloc (bellwether_code);\n-  memcpy (x, original, RTX_CODE_SIZE (bellwether_code));\n-\n-  /* Change the mode or code itself.  */\n-  group = iterator->group;\n-  if (group->uses_iterator_p (x, iterator->index + group->num_builtins))\n-    group->apply_iterator (x, value);\n-\n-  if (mode_maps)\n-    apply_mode_maps (x, mode_maps, iterator, value, unknown_mode_attr);\n+  x = rtx_alloc (GET_CODE (original));\n+  memcpy (x, original, RTX_CODE_SIZE (GET_CODE (original)));\n \n   /* Change each string and recursively change each rtx.  */\n-  format_ptr = GET_RTX_FORMAT (bellwether_code);\n+  format_ptr = GET_RTX_FORMAT (GET_CODE (original));\n   for (i = 0; format_ptr[i] != 0; i++)\n     switch (format_ptr[i])\n       {\n       case 'T':\n-\tXTMPL (x, i) = apply_iterator_to_string (XTMPL (x, i), iterator, value);\n+\tXTMPL (x, i) = apply_iterator_to_string (XTMPL (x, i));\n \tbreak;\n \n       case 'S':\n       case 's':\n-\tXSTR (x, i) = apply_iterator_to_string (XSTR (x, i), iterator, value);\n+\tXSTR (x, i) = apply_iterator_to_string (XSTR (x, i));\n \tbreak;\n \n       case 'e':\n-\tXEXP (x, i) = apply_iterator_to_rtx (XEXP (x, i), iterator, value,\n-\t\t\t\t\t     mode_maps, unknown_mode_attr);\n+\tXEXP (x, i) = copy_rtx_for_iterators (XEXP (x, i));\n \tbreak;\n \n       case 'V':\n@@ -374,9 +292,8 @@ apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n \t  {\n \t    XVEC (x, i) = rtvec_alloc (XVECLEN (original, i));\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      XVECEXP (x, i, j) = apply_iterator_to_rtx (XVECEXP (original, i, j),\n-\t\t\t\t\t\t\t iterator, value, mode_maps,\n-\t\t\t\t\t\t\t unknown_mode_attr);\n+\t      XVECEXP (x, i, j)\n+\t\t= copy_rtx_for_iterators (XVECEXP (original, i, j));\n \t  }\n \tbreak;\n \n@@ -386,45 +303,6 @@ apply_iterator_to_rtx (rtx original, struct mapping *iterator, int value,\n   return x;\n }\n \n-/* Return true if X (or some subexpression of X) uses iterator ITERATOR.  */\n-\n-static bool\n-uses_iterator_p (rtx x, struct mapping *iterator)\n-{\n-  struct iterator_group *group;\n-  const char *format_ptr;\n-  int i, j;\n-\n-  if (x == 0)\n-    return false;\n-\n-  group = iterator->group;\n-  if (group->uses_iterator_p (x, iterator->index + group->num_builtins))\n-    return true;\n-\n-  format_ptr = GET_RTX_FORMAT (BELLWETHER_CODE (GET_CODE (x)));\n-  for (i = 0; format_ptr[i] != 0; i++)\n-    switch (format_ptr[i])\n-      {\n-      case 'e':\n-\tif (uses_iterator_p (XEXP (x, i), iterator))\n-\t  return true;\n-\tbreak;\n-\n-      case 'V':\n-      case 'E':\n-\tif (XVEC (x, i))\n-\t  for (j = 0; j < XVECLEN (x, i); j++)\n-\t    if (uses_iterator_p (XVECEXP (x, i, j), iterator))\n-\t      return true;\n-\tbreak;\n-\n-      default:\n-\tbreak;\n-      }\n-  return false;\n-}\n-\n /* Return a condition that must satisfy both ORIGINAL and EXTRA.  If ORIGINAL\n    has the form \"&& ...\" (as used in define_insn_and_splits), assume that\n    EXTRA is already satisfied.  Empty strings are treated like \"true\".  */\n@@ -466,52 +344,117 @@ add_condition_to_rtx (rtx x, const char *extra)\n     }\n }\n \n-/* A htab_traverse callback.  Search the EXPR_LIST given by DATA\n-   for rtxes that use the iterator in *SLOT.  Replace each such rtx\n-   with a list of expansions.  */\n+/* Apply the current iterator values to all attribute_uses.  */\n+\n+static void\n+apply_attribute_uses (void)\n+{\n+  struct map_value *v;\n+  attribute_use *ause;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (attribute_use, attribute_uses, i, ause)\n+    {\n+      v = map_attr_string (ause->value);\n+      if (!v)\n+\tfatal_with_file_and_line (\"unknown iterator value `%s'\", ause->value);\n+      ause->group->apply_iterator (ause->ptr,\n+\t\t\t\t   ause->group->find_builtin (v->string));\n+    }\n+}\n+\n+/* A htab_traverse callback for iterators.  Add all used iterators\n+   to current_iterators.  */\n \n static int\n-apply_iterator_traverse (void **slot, void *data)\n+add_current_iterators (void **slot, void *data ATTRIBUTE_UNUSED)\n {\n-  struct iterator_traverse_data *mtd = (struct iterator_traverse_data *) data;\n   struct mapping *iterator;\n-  struct map_value *v;\n-  rtx elem, new_elem, original, x;\n \n   iterator = (struct mapping *) *slot;\n-  for (elem = mtd->queue; elem != 0; elem = XEXP (elem, 1))\n-    if (uses_iterator_p (XEXP (elem, 0), iterator))\n-      {\n-\t/* For each iterator we expand, we set UNKNOWN_MODE_ATTR to NULL.\n-\t   If apply_iterator_rtx finds an unknown attribute for a mode,\n-\t   it will set it to the attribute.  We want to know whether\n-\t   the attribute is unknown after we have expanded all\n-\t   possible iterators, so setting it to NULL here gives us the\n-\t   right result when the hash table traversal is complete.  */\n-\tmtd->unknown_mode_attr = NULL;\n-\n-\toriginal = XEXP (elem, 0);\n-\tfor (v = iterator->values; v != 0; v = v->next)\n-\t  {\n-\t    x = apply_iterator_to_rtx (original, iterator, v->number,\n-\t\t\t\t       mtd->mode_maps,\n-\t\t\t\t       &mtd->unknown_mode_attr);\n-\t    add_condition_to_rtx (x, v->string);\n-\t    if (v != iterator->values)\n-\t      {\n-\t\t/* Insert a new EXPR_LIST node after ELEM and put the\n-\t\t   new expansion there.  */\n-\t\tnew_elem = rtx_alloc (EXPR_LIST);\n-\t\tXEXP (new_elem, 1) = XEXP (elem, 1);\n-\t\tXEXP (elem, 1) = new_elem;\n-\t\telem = new_elem;\n-\t      }\n-\t    XEXP (elem, 0) = x;\n-\t  }\n-    }\n+  if (iterator->current_value)\n+    VEC_safe_push (mapping_ptr, heap, current_iterators, iterator);\n   return 1;\n }\n \n+/* Expand all iterators in the current rtx, which is given as ORIGINAL.\n+   Build a list of expanded rtxes in the EXPR_LIST pointed to by QUEUE.  */\n+\n+static void\n+apply_iterators (rtx original, rtx *queue)\n+{\n+  unsigned int i;\n+  const char *condition;\n+  iterator_use *iuse;\n+  struct mapping *iterator;\n+  struct map_value *v;\n+  rtx x;\n+\n+  if (VEC_empty (iterator_use, iterator_uses))\n+    {\n+      /* Raise an error if any attributes were used.  */\n+      apply_attribute_uses ();\n+      XEXP (*queue, 0) = original;\n+      XEXP (*queue, 1) = NULL_RTX;\n+      return;\n+    }\n+\n+  /* Clear out the iterators from the previous run.  */\n+  FOR_EACH_VEC_ELT (mapping_ptr, current_iterators, i, iterator)\n+    iterator->current_value = NULL;\n+  VEC_truncate (mapping_ptr, current_iterators, 0);\n+\n+  /* Mark the iterators that we need this time.  */\n+  FOR_EACH_VEC_ELT (iterator_use, iterator_uses, i, iuse)\n+    iuse->iterator->current_value = iuse->iterator->values;\n+\n+  /* Get the list of iterators that are in use, preserving the\n+     definition order within each group.  */\n+  htab_traverse (modes.iterators, add_current_iterators, NULL);\n+  htab_traverse (codes.iterators, add_current_iterators, NULL);\n+  gcc_assert (!VEC_empty (mapping_ptr, current_iterators));\n+\n+  for (;;)\n+    {\n+      /* Apply the current iterator values.  Accumulate a condition to\n+\t say when the resulting rtx can be used.  */\n+      condition = NULL;\n+      FOR_EACH_VEC_ELT (iterator_use, iterator_uses, i, iuse)\n+\t{\n+\t  v = iuse->iterator->current_value;\n+\t  iuse->iterator->group->apply_iterator (iuse->ptr, v->number);\n+\t  condition = join_c_conditions (condition, v->string);\n+\t}\n+      apply_attribute_uses ();\n+      x = copy_rtx_for_iterators (original);\n+      add_condition_to_rtx (x, condition);\n+\n+      /* Add the new rtx to the end of the queue.  */\n+      XEXP (*queue, 0) = x;\n+      XEXP (*queue, 1) = NULL_RTX;\n+\n+      /* Lexicographically increment the iterator value sequence.\n+\t That is, cycle through iterator values, starting from the right,\n+\t and stopping when one of them doesn't wrap around.  */\n+      i = VEC_length (mapping_ptr, current_iterators);\n+      for (;;)\n+\t{\n+\t  if (i == 0)\n+\t    return;\n+\t  i--;\n+\t  iterator = VEC_index (mapping_ptr, current_iterators, i);\n+\t  iterator->current_value = iterator->current_value->next;\n+\t  if (iterator->current_value)\n+\t    break;\n+\t  iterator->current_value = iterator->values;\n+\t}\n+\n+      /* At least one more rtx to go.  Allocate room for it.  */\n+      XEXP (*queue, 1) = rtx_alloc (EXPR_LIST);\n+      queue = &XEXP (*queue, 1);\n+    }\n+}\n+\n /* Add a new \"mapping\" structure to hashtable TABLE.  NAME is the name\n    of the mapping and GROUP is the group to which it belongs.  */\n \n@@ -524,8 +467,8 @@ add_mapping (struct iterator_group *group, htab_t table, const char *name)\n   m = XNEW (struct mapping);\n   m->name = xstrdup (name);\n   m->group = group;\n-  m->index = htab_elements (table);\n   m->values = 0;\n+  m->current_value = NULL;\n \n   slot = htab_find_slot (table, m, INSERT);\n   if (*slot != 0)\n@@ -566,17 +509,13 @@ initialize_iterators (void)\n   modes.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   modes.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n-  modes.num_builtins = MAX_MACHINE_MODE;\n   modes.find_builtin = find_mode;\n-  modes.uses_iterator_p = uses_mode_iterator_p;\n   modes.apply_iterator = apply_mode_iterator;\n \n   codes.attrs = htab_create (13, leading_string_hash, leading_string_eq_p, 0);\n   codes.iterators = htab_create (13, leading_string_hash,\n \t\t\t\t leading_string_eq_p, 0);\n-  codes.num_builtins = NUM_RTX_CODE;\n   codes.find_builtin = find_code;\n-  codes.uses_iterator_p = uses_code_iterator_p;\n   codes.apply_iterator = apply_code_iterator;\n \n   lower = add_mapping (&modes, modes.attrs, \"mode\");\n@@ -714,18 +653,60 @@ validate_const_int (const char *string)\n     fatal_with_file_and_line (\"invalid decimal constant \\\"%s\\\"\\n\", string);\n }\n \n-/* Search GROUP for a mode or code called NAME and return its numerical\n-   identifier.  */\n+/* Record that PTR uses iterator ITERATOR.  */\n \n-static int\n-find_iterator (struct iterator_group *group, const char *name)\n+static void\n+record_iterator_use (struct mapping *iterator, void *ptr)\n+{\n+  struct iterator_use *iuse;\n+\n+  iuse = VEC_safe_push (iterator_use, heap, iterator_uses, NULL);\n+  iuse->iterator = iterator;\n+  iuse->ptr = ptr;\n+}\n+\n+/* Record that PTR uses attribute VALUE, which must match a built-in\n+   value from group GROUP.  */\n+\n+static void\n+record_attribute_use (struct iterator_group *group, void *ptr,\n+\t\t      const char *value)\n+{\n+  struct attribute_use *ause;\n+\n+  ause = VEC_safe_push (attribute_use, heap, attribute_uses, NULL);\n+  ause->group = group;\n+  ause->value = value;\n+  ause->ptr = ptr;\n+}\n+\n+/* Interpret NAME as either a built-in value, iterator or attribute\n+   for group GROUP.  PTR is the value to pass to GROUP's apply_iterator\n+   callback.  */\n+\n+static void\n+record_potential_iterator_use (struct iterator_group *group, void *ptr,\n+\t\t\t       const char *name)\n {\n   struct mapping *m;\n+  size_t len;\n \n-  m = (struct mapping *) htab_find (group->iterators, &name);\n-  if (m != 0)\n-    return m->index + group->num_builtins;\n-  return group->find_builtin (name);\n+  len = strlen (name);\n+  if (name[0] == '<' && name[len - 1] == '>')\n+    {\n+      /* Copy the attribute string into permanent storage, without the\n+\t angle brackets around it.  */\n+      obstack_grow0 (&string_obstack, name + 1, len - 2);\n+      record_attribute_use (group, ptr, XOBFINISH (&string_obstack, char *));\n+    }\n+  else\n+    {\n+      m = (struct mapping *) htab_find (group->iterators, &name);\n+      if (m != 0)\n+\trecord_iterator_use (m, ptr);\n+      else\n+\tgroup->apply_iterator (ptr, group->find_builtin (name));\n+    }\n }\n \n /* Finish reading a declaration of the form:\n@@ -787,7 +768,7 @@ read_mapping (struct iterator_group *group, htab_t table)\n }\n \n /* Check newly-created code iterator ITERATOR to see whether every code has the\n-   same format.  Initialize the iterator's entry in bellwether_codes.  */\n+   same format.  */\n \n static void\n check_code_iterator (struct mapping *iterator)\n@@ -800,10 +781,6 @@ check_code_iterator (struct mapping *iterator)\n     if (strcmp (GET_RTX_FORMAT (bellwether), GET_RTX_FORMAT (v->number)) != 0)\n       fatal_with_file_and_line (\"code iterator `%s' combines \"\n \t\t\t\t\"different rtx formats\", iterator->name);\n-\n-  bellwether_codes = XRESIZEVEC (enum rtx_code, bellwether_codes,\n-\t\t\t\t iterator->index + 1);\n-  bellwether_codes[iterator->index] = bellwether;\n }\n \n /* Read an rtx-related declaration from the MD file, given that it\n@@ -815,8 +792,6 @@ bool\n read_rtx (const char *rtx_name, rtx *x)\n {\n   static rtx queue_head;\n-  struct map_value *mode_maps;\n-  struct iterator_traverse_data mtd;\n \n   /* Do one-time initialization.  */\n   if (queue_head == 0)\n@@ -853,32 +828,24 @@ read_rtx (const char *rtx_name, rtx *x)\n       return false;\n     }\n \n-  mode_maps = 0;\n-  XEXP (queue_head, 0) = read_rtx_code (rtx_name, &mode_maps);\n-  XEXP (queue_head, 1) = 0;\n-\n-  mtd.queue = queue_head;\n-  mtd.mode_maps = mode_maps;\n-  mtd.unknown_mode_attr = mode_maps ? mode_maps->string : NULL;\n-  htab_traverse (modes.iterators, apply_iterator_traverse, &mtd);\n-  htab_traverse (codes.iterators, apply_iterator_traverse, &mtd);\n-  if (mtd.unknown_mode_attr)\n-    fatal_with_file_and_line (\"undefined attribute '%s' used for mode\",\n-\t\t\t      mtd.unknown_mode_attr);\n+  apply_iterators (read_rtx_code (rtx_name), &queue_head);\n+  VEC_truncate (iterator_use, iterator_uses, 0);\n+  VEC_truncate (attribute_use, attribute_uses, 0);\n \n   *x = queue_head;\n   return true;\n }\n \n /* Subroutine of read_rtx and read_nested_rtx.  CODE_NAME is the name of\n    either an rtx code or a code iterator.  Parse the rest of the rtx and\n-   return it.  MODE_MAPS is as for iterator_traverse_data.  */\n+   return it.  */\n \n static rtx\n-read_rtx_code (const char *code_name, struct map_value **mode_maps)\n+read_rtx_code (const char *code_name)\n {\n   int i;\n-  RTX_CODE real_code, bellwether_code;\n+  RTX_CODE code;\n+  struct mapping *iterator;\n   const char *format_ptr;\n   struct md_name name;\n   rtx return_rtx;\n@@ -893,30 +860,30 @@ read_rtx_code (const char *code_name, struct map_value **mode_maps)\n       rtx value;\t\t/* Value of this node.  */\n     };\n \n-  real_code = (enum rtx_code) find_iterator (&codes, code_name);\n-  bellwether_code = BELLWETHER_CODE (real_code);\n+  /* If this code is an iterator, build the rtx using the iterator's\n+     first value.  */\n+  iterator = (struct mapping *) htab_find (codes.iterators, &code_name);\n+  if (iterator != 0)\n+    code = (enum rtx_code) iterator->values->number;\n+  else\n+    code = (enum rtx_code) codes.find_builtin (code_name);\n \n   /* If we end up with an insn expression then we free this space below.  */\n-  return_rtx = rtx_alloc (bellwether_code);\n-  format_ptr = GET_RTX_FORMAT (bellwether_code);\n-  PUT_CODE (return_rtx, real_code);\n+  return_rtx = rtx_alloc (code);\n+  format_ptr = GET_RTX_FORMAT (code);\n+  PUT_CODE (return_rtx, code);\n+\n+  if (iterator)\n+    record_iterator_use (iterator, return_rtx);\n \n   /* If what follows is `: mode ', read it and\n      store the mode in the rtx.  */\n \n   i = read_skip_spaces ();\n   if (i == ':')\n     {\n-      unsigned int mode;\n-\n       read_name (&name);\n-      if (name.string[0] != '<' || name.string[strlen (name.string) - 1] != '>')\n-\tmode = find_iterator (&modes, name.string);\n-      else\n-\tmode = mode_attr_index (mode_maps, name.string);\n-      PUT_MODE (return_rtx, (enum machine_mode) mode);\n-      if (GET_MODE (return_rtx) != mode)\n-\tfatal_with_file_and_line (\"mode too large\");\n+      record_potential_iterator_use (&modes, return_rtx, name.string);\n     }\n   else\n     unread_char (i);\n@@ -931,7 +898,7 @@ read_rtx_code (const char *code_name, struct map_value **mode_maps)\n \n       case 'e':\n       case 'u':\n-\tXEXP (return_rtx, i) = read_nested_rtx (mode_maps);\n+\tXEXP (return_rtx, i) = read_nested_rtx ();\n \tbreak;\n \n       case 'V':\n@@ -965,7 +932,7 @@ read_rtx_code (const char *code_name, struct map_value **mode_maps)\n \t\tfatal_expected_char (']', c);\n \t      unread_char (c);\n \t      list_counter++;\n-\t      obstack_ptr_grow (&vector_stack, read_nested_rtx (mode_maps));\n+\t      obstack_ptr_grow (&vector_stack, read_nested_rtx ());\n \t    }\n \t  if (list_counter > 0)\n \t    {\n@@ -1075,17 +1042,16 @@ read_rtx_code (const char *code_name, struct map_value **mode_maps)\n   if (c == '('\n       && (GET_CODE (return_rtx) == AND\n \t  || GET_CODE (return_rtx) == IOR))\n-    return read_rtx_variadic (mode_maps, return_rtx);\n+    return read_rtx_variadic (return_rtx);\n \n   unread_char (c);\n   return return_rtx;\n }\n \n-/* Read a nested rtx construct from the MD file and return it.\n-   MODE_MAPS is as for iterator_traverse_data.  */\n+/* Read a nested rtx construct from the MD file and return it.  */\n \n static rtx\n-read_nested_rtx (struct map_value **mode_maps)\n+read_nested_rtx (void)\n {\n   struct md_name name;\n   int c;\n@@ -1099,7 +1065,7 @@ read_nested_rtx (struct map_value **mode_maps)\n   if (strcmp (name.string, \"nil\") == 0)\n     return_rtx = NULL;\n   else\n-    return_rtx = read_rtx_code (name.string, mode_maps);\n+    return_rtx = read_rtx_code (name.string);\n \n   c = read_skip_spaces ();\n   if (c != ')')\n@@ -1115,7 +1081,7 @@ read_nested_rtx (struct map_value **mode_maps)\n    is just past the leading parenthesis of x3.  Only works\n    for THINGs which are dyadic expressions, e.g. AND, IOR.  */\n static rtx\n-read_rtx_variadic (struct map_value **mode_maps, rtx form)\n+read_rtx_variadic (rtx form)\n {\n   char c = '(';\n   rtx p = form, q;\n@@ -1128,7 +1094,7 @@ read_rtx_variadic (struct map_value **mode_maps, rtx form)\n       PUT_MODE (q, GET_MODE (p));\n \n       XEXP (q, 0) = XEXP (p, 1);\n-      XEXP (q, 1) = read_nested_rtx (mode_maps);\n+      XEXP (q, 1) = read_nested_rtx ();\n \n       XEXP (p, 1) = q;\n       p = q;"}]}