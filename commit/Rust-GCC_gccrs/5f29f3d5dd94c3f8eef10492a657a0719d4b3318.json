{"sha": "5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWYyOWYzZDVkZDk0YzNmOGVlZjEwNDkyYTY1N2EwNzE5ZDRiMzMxOA==", "commit": {"author": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-11-27T09:19:33Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "kyrylo.tkachov@arm.com", "date": "2020-11-27T09:19:33Z"}, "message": "aarch64: Introduce --param=aarch64-autovec-preference to select autovec preference in backend\n\nThis is a patch that introduces the aarch64-autovec-preference that can\ntake values from 0 - 4, 0 being the default.\nIt can be used to override the autovectorisation preferences in the\nbackend:\n0 - use default scheme\n1 - only use Advanced SIMD\n2 - only use SVE\n3 - use Advanced SIMD and SVE, prefer Advanced SIMD in the event of a\ntie (as determined by costs)\n4 - use Advanced SIMD and SVE, prefer SVE in the event of a tie (as\ndetermined by costs)\n\nIt can valuable for experimentation when comparing SVE and Advanced SIMD\nautovectorisation strategies.\n\nIt achieves this adjusting the order of the interleaved SVE and Advanced\nSIMD modes in aarch64_autovectorize_vector_modes.\nIt also adjusts aarch64_preferred_simd_mode to use the new comparison\nfunction to pick Advanced SIMD or SVE to start with.\n\nBootstrapped and tested on aarch64-none-linux-gnu.\n\ngcc/\n\t* config/aarch64/aarch64.opt\n\t(-param=aarch64-autovec-preference): Define.\n\t* config/aarch64/aarch64.c (aarch64_override_options_internal):\n\tSet aarch64_sve_compare_costs to 0 when preferring only Advanced\n\tSIMD.\n\t(aarch64_cmp_autovec_modes): Define.\n\t(aarch64_preferred_simd_mode): Adjust to use the above.\n\t(aarch64_autovectorize_vector_modes): Likewise.\n\t* doc/invoke.texi: Document aarch64-autovec-preference param.", "tree": {"sha": "6d1829b47c16ddc2cb72df9e9bd39bae4059ccf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d1829b47c16ddc2cb72df9e9bd39bae4059ccf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/comments", "author": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ktkachov-arm", "id": 74917949, "node_id": "MDQ6VXNlcjc0OTE3OTQ5", "avatar_url": "https://avatars.githubusercontent.com/u/74917949?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ktkachov-arm", "html_url": "https://github.com/ktkachov-arm", "followers_url": "https://api.github.com/users/ktkachov-arm/followers", "following_url": "https://api.github.com/users/ktkachov-arm/following{/other_user}", "gists_url": "https://api.github.com/users/ktkachov-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/ktkachov-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ktkachov-arm/subscriptions", "organizations_url": "https://api.github.com/users/ktkachov-arm/orgs", "repos_url": "https://api.github.com/users/ktkachov-arm/repos", "events_url": "https://api.github.com/users/ktkachov-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/ktkachov-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "def0e5b83ddb5d4916d0e804b9044f73ffb2923c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/def0e5b83ddb5d4916d0e804b9044f73ffb2923c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/def0e5b83ddb5d4916d0e804b9044f73ffb2923c"}], "stats": {"total": 97, "additions": 91, "deletions": 6}, "files": [{"sha": "0208efd88f17fd01ae16bb5033a5dd6b06a7b9fc", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 71, "deletions": 6, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "patch": "@@ -14442,6 +14442,12 @@ aarch64_override_options_internal (struct gcc_options *opts)\n   SET_OPTION_IF_UNSET (opts, &global_options_set,\n \t\t       param_sched_autopref_queue_depth, queue_depth);\n \n+  /* If using Advanced SIMD only for autovectorization disable SVE vector costs\n+     comparison.  */\n+  if (aarch64_autovec_preference == 1)\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t aarch64_sve_compare_costs, 0);\n+\n   /* Set up parameters to be used in prefetching algorithm.  Do not\n      override the defaults unless we are tuning for a core we have\n      researched values for.  */\n@@ -17282,11 +17288,65 @@ aarch64_simd_container_mode (scalar_mode mode, poly_int64 width)\n   return word_mode;\n }\n \n+static HOST_WIDE_INT aarch64_estimated_poly_value (poly_int64);\n+\n+/* Compare an SVE mode SVE_M and an Advanced SIMD mode ASIMD_M\n+   and return whether the SVE mode should be preferred over the\n+   Advanced SIMD one in aarch64_autovectorize_vector_modes.  */\n+static bool\n+aarch64_cmp_autovec_modes (machine_mode sve_m, machine_mode asimd_m)\n+{\n+  /* Take into account the aarch64-autovec-preference param if non-zero.  */\n+  bool only_asimd_p = aarch64_autovec_preference == 1;\n+  bool only_sve_p = aarch64_autovec_preference == 2;\n+\n+  if (only_asimd_p)\n+    return false;\n+  if (only_sve_p)\n+    return true;\n+\n+  /* The preference in case of a tie in costs.  */\n+  bool prefer_asimd = aarch64_autovec_preference == 3;\n+  bool prefer_sve = aarch64_autovec_preference == 4;\n+\n+  aarch64_sve_vector_bits_enum tune_width = aarch64_tune_params.sve_width;\n+\n+  poly_int64 nunits_sve = GET_MODE_NUNITS (sve_m);\n+  poly_int64 nunits_asimd = GET_MODE_NUNITS (asimd_m);\n+  /* If the CPU information does not have an SVE width registered use the\n+     generic poly_int comparison that prefers SVE.  If a preference is\n+     explicitly requested avoid this path.  */\n+  if (tune_width == SVE_SCALABLE\n+      && !prefer_asimd\n+      && !prefer_sve)\n+    return maybe_gt (nunits_sve, nunits_asimd);\n+\n+  /* Otherwise estimate the runtime width of the modes involved.  */\n+  HOST_WIDE_INT est_sve = aarch64_estimated_poly_value (nunits_sve);\n+  HOST_WIDE_INT est_asimd = aarch64_estimated_poly_value (nunits_asimd);\n+\n+  /* Preferring SVE means picking it first unless the Advanced SIMD mode\n+     is clearly wider.  */\n+  if (prefer_sve)\n+    return est_sve >= est_asimd;\n+  /* Conversely, preferring Advanced SIMD means picking SVE only if SVE\n+     is clearly wider.  */\n+  if (prefer_asimd)\n+    return est_sve > est_asimd;\n+\n+  /* In the default case prefer Advanced SIMD over SVE in case of a tie.  */\n+  return est_sve > est_asimd;\n+}\n+\n /* Return 128-bit container as the preferred SIMD mode for MODE.  */\n static machine_mode\n aarch64_preferred_simd_mode (scalar_mode mode)\n {\n-  poly_int64 bits = TARGET_SVE ? BITS_PER_SVE_VECTOR : 128;\n+  /* Take into account explicit auto-vectorization ISA preferences through\n+     aarch64_cmp_autovec_modes.  */\n+  poly_int64 bits\n+    = (TARGET_SVE && aarch64_cmp_autovec_modes (VNx16QImode, V16QImode))\n+       ? BITS_PER_SVE_VECTOR : 128;\n   return aarch64_simd_container_mode (mode, bits);\n }\n \n@@ -17348,19 +17408,24 @@ aarch64_autovectorize_vector_modes (vector_modes *modes, bool)\n      - If an Advanced SIMD main loop with N bytes ends up being cheaper\n        than an SVE main loop with N bytes then by default we'll try to\n        use the SVE loop to vectorize the epilogue instead.  */\n-  unsigned int sve_i = TARGET_SVE ? 0 : ARRAY_SIZE (sve_modes);\n+\n+  bool only_asimd_p = aarch64_autovec_preference == 1;\n+  bool only_sve_p = aarch64_autovec_preference == 2;\n+\n+  unsigned int sve_i = (TARGET_SVE && !only_asimd_p) ? 0 : ARRAY_SIZE (sve_modes);\n   unsigned int advsimd_i = 0;\n-  while (advsimd_i < ARRAY_SIZE (advsimd_modes))\n+\n+  while (!only_sve_p && advsimd_i < ARRAY_SIZE (advsimd_modes))\n     {\n       if (sve_i < ARRAY_SIZE (sve_modes)\n-\t  && maybe_gt (GET_MODE_NUNITS (sve_modes[sve_i]),\n-\t\t       GET_MODE_NUNITS (advsimd_modes[advsimd_i])))\n+\t  && aarch64_cmp_autovec_modes (sve_modes[sve_i],\n+\t\t\t\t\tadvsimd_modes[advsimd_i]))\n \tmodes->safe_push (sve_modes[sve_i++]);\n       else\n \tmodes->safe_push (advsimd_modes[advsimd_i++]);\n     }\n   while (sve_i < ARRAY_SIZE (sve_modes))\n-    modes->safe_push (sve_modes[sve_i++]);\n+   modes->safe_push (sve_modes[sve_i++]);\n \n   unsigned int flags = 0;\n   /* Consider enabling VECT_COMPARE_COSTS for SVE, both so that we"}, {"sha": "1b3d942e0f5d1dc9b88a5df0ef71416cfcfca2c8", "filename": "gcc/config/aarch64/aarch64.opt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fconfig%2Faarch64%2Faarch64.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.opt?ref=5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "patch": "@@ -275,3 +275,5 @@ The number of Newton iterations for calculating the reciprocal for float type.\n Target Joined UInteger Var(aarch64_double_recp_precision) Init(2) IntegerRange(1, 5) Param\n The number of Newton iterations for calculating the reciprocal for double type.  The precision of division is proportional to this param when division approximation is enabled.  The default value is 2.\n \n+-param=aarch64-autovec-preference=\n+Target Joined UInteger Var(aarch64_autovec_preference) Init(0) IntegerRange(0, 4) Param"}, {"sha": "5547d793c8703f530880c76a715e4bdbebe93394", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f29f3d5dd94c3f8eef10492a657a0719d4b3318/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=5f29f3d5dd94c3f8eef10492a657a0719d4b3318", "patch": "@@ -14125,6 +14125,24 @@ The number of Newton iterations for calculating the reciprocal for double type.\n The precision of division is propotional to this param when division\n approximation is enabled.  The default value is 2.\n \n+@item aarch64-autovec-preference\n+Force an ISA selection strategy for auto-vectorization.  Accepts values from\n+0 to 4, inclusive.\n+@table @samp\n+@item 0\n+Use the default heuristics.\n+@item 1\n+Use only Advanced SIMD for auto-vectorization.\n+@item 2\n+Use only SVE for auto-vectorization.\n+@item 3\n+Use both Advanced SIMD and SVE.  Prefer Advanced SIMD when the costs are\n+deemed equal.\n+@item 4\n+Use both Advanced SIMD and SVE.  Prefer SVE when the costs are deemed equal.\n+@end table\n+The default value is 0.\n+\n @end table\n \n @end table"}]}