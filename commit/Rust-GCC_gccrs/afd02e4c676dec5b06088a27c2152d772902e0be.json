{"sha": "afd02e4c676dec5b06088a27c2152d772902e0be", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWZkMDJlNGM2NzZkZWM1YjA2MDg4YTI3YzIxNTJkNzcyOTAyZTBiZQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2018-11-21T18:40:37Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2018-11-21T18:40:37Z"}, "message": "PR libstdc++/88113 use size_type consistently instead of size_t\n\nOn 16-bit msp430-elf size_t is either 16 bits or 20 bits, and so can't\nrepresent all values of the uint32_t type used for bitset::size_type.\nUsing the smaller of size_t and uint32_t for size_type ensures it fits\nin size_t.\n\n\tPR libstdc++/88113\n\t* src/c++17/memory_resource.cc (bitset::size_type): Use the smaller\n\tof uint32_t and size_t.\n\t(bitset::size(), bitset::free(), bitset::update_next_word())\n\t(bitset::max_blocks_per_chunk(), bitset::max_word_index()): Use\n\tsize_type consistently instead of size_t.\n\t(chunk): Adjust static_assert checking sizeof(chunk).\n\nFrom-SVN: r266352", "tree": {"sha": "db39b72dbf03665f8a60d374f1be08578b689aa0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db39b72dbf03665f8a60d374f1be08578b689aa0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/afd02e4c676dec5b06088a27c2152d772902e0be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd02e4c676dec5b06088a27c2152d772902e0be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/afd02e4c676dec5b06088a27c2152d772902e0be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/afd02e4c676dec5b06088a27c2152d772902e0be/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4cd5da011d6174e7cb152913acac760fb4a84c11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cd5da011d6174e7cb152913acac760fb4a84c11", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cd5da011d6174e7cb152913acac760fb4a84c11"}], "stats": {"total": 39, "additions": 27, "deletions": 12}, "files": [{"sha": "aaf17591726257f63882cabde7e96b754cf99093", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd02e4c676dec5b06088a27c2152d772902e0be/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd02e4c676dec5b06088a27c2152d772902e0be/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=afd02e4c676dec5b06088a27c2152d772902e0be", "patch": "@@ -1,3 +1,13 @@\n+2018-11-21  Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/88113\n+\t* src/c++17/memory_resource.cc (bitset::size_type): Use the smaller\n+\tof uint32_t and size_t.\n+\t(bitset::size(), bitset::free(), bitset::update_next_word())\n+\t(bitset::max_blocks_per_chunk(), bitset::max_word_index()): Use\n+\tsize_type consistently instead of size_t.\n+\t(chunk): Adjust static_assert checking sizeof(chunk).\n+\n 2018-11-20  Ville Voutilainen  <ville.voutilainen@gmail.com>\n \n \tHousekeeping for the effective targets of optional's tests."}, {"sha": "6198e6b68caf9d1a558bd08838c1e481f1fb6e7d", "filename": "libstdc++-v3/src/c++17/memory_resource.cc", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/afd02e4c676dec5b06088a27c2152d772902e0be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/afd02e4c676dec5b06088a27c2152d772902e0be/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fc%2B%2B17%2Fmemory_resource.cc?ref=afd02e4c676dec5b06088a27c2152d772902e0be", "patch": "@@ -252,11 +252,13 @@ namespace pmr\n \n   namespace {\n \n-  // Simple bitset with runtime size. Tracks used blocks in a pooled chunk.\n+  // Simple bitset with runtime size.\n+  // Tracks which blocks in a pool chunk are used/unused.\n   struct bitset\n   {\n     using word = uint64_t;\n-    using size_type = uint32_t;\n+    using size_type // unsigned integer type with no more than 32 bits\n+      = conditional_t<numeric_limits<size_t>::digits <= 32, size_t, uint32_t>;\n \n     static constexpr unsigned bits_per_word = numeric_limits<word>::digits;\n \n@@ -269,7 +271,7 @@ namespace pmr\n       __builtin_memset(_M_words, 0, last_word * sizeof(*_M_words));\n       // Set bits beyond _M_size, so they are not treated as free blocks:\n       if (const size_type extra_bits = num_blocks % bits_per_word)\n-\t_M_words[last_word] = (word)-1 << extra_bits;\n+\t_M_words[last_word] = word(-1) << extra_bits;\n       __glibcxx_assert( empty() );\n       __glibcxx_assert( free() == num_blocks );\n     }\n@@ -278,12 +280,12 @@ namespace pmr\n     ~bitset() = default;\n \n     // Number of blocks\n-    size_t size() const noexcept { return _M_size; }\n+    size_type size() const noexcept { return _M_size; }\n \n     // Number of free blocks (unset bits)\n-    size_t free() const noexcept\n+    size_type free() const noexcept\n     {\n-      size_t n = 0;\n+      size_type n = 0;\n       for (size_type i = _M_next_word; i < nwords(); ++i)\n \tn += (bits_per_word - std::__popcount(_M_words[i]));\n       return n;\n@@ -376,7 +378,7 @@ namespace pmr\n     // this function saturates _M_next_word at max_word_index().\n     void update_next_word() noexcept\n     {\n-      size_t next = _M_next_word;\n+      size_type next = _M_next_word;\n       while (_M_words[next] == word(-1) && ++next < nwords())\n \t{ }\n       _M_next_word = std::min(next, max_word_index());\n@@ -397,11 +399,11 @@ namespace pmr\n     { return (_M_size + bits_per_word - 1) / bits_per_word; }\n \n     // Maximum value that can be stored in bitset::_M_size member (approx 500k)\n-    static constexpr size_t max_blocks_per_chunk() noexcept\n-    { return (1ull << _S_size_digits) - 1; }\n+    static constexpr size_type max_blocks_per_chunk() noexcept\n+    { return (size_type(1) << _S_size_digits) - 1; }\n \n     // Maximum value that can be stored in bitset::_M_next_word member (8191).\n-    static constexpr size_t max_word_index() noexcept\n+    static constexpr size_type max_word_index() noexcept\n     { return (max_blocks_per_chunk() + bits_per_word - 1) / bits_per_word; }\n \n     word* data() const noexcept { return _M_words; }\n@@ -519,9 +521,12 @@ namespace pmr\n     { return std::less<const void*>{}(p, c._M_p); }\n   };\n \n-  // For 64-bit this is 3*sizeof(void*) and for 32-bit it's 4*sizeof(void*).\n+  // For 64-bit pointers this is the size of three pointers i.e. 24 bytes.\n+  // For 32-bit and 20-bit pointers it's four pointers (16 bytes).\n+  // For 16-bit pointers it's five pointers (10 bytes).\n   // TODO pad 64-bit to 4*sizeof(void*) to avoid splitting across cache lines?\n-  static_assert(sizeof(chunk) == 2 * sizeof(uint32_t) + 2 * sizeof(void*));\n+  static_assert(sizeof(chunk)\n+      == sizeof(bitset::size_type) + sizeof(uint32_t) + 2 * sizeof(void*));\n \n   // An oversized allocation that doesn't fit in a pool.\n   struct big_block"}]}