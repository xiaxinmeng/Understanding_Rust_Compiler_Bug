{"sha": "6d5363fa3de2cf709bfc8becf7cd031a1b245cbc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmQ1MzYzZmEzZGUyY2Y3MDliZmM4YmVjZjdjZDAzMWExYjI0NWNiYw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-13T22:50:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-05-13T22:50:40Z"}, "message": "(combined mult/arithmetic recognizers): Switch on.\n\nAdd special pattern for reload.\n\nFrom-SVN: r4442", "tree": {"sha": "2644a6ef0a0f119cab7380261e383cb4e45ad3be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2644a6ef0a0f119cab7380261e383cb4e45ad3be"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc/comments", "author": null, "committer": null, "parents": [{"sha": "0d4d817479e431da6b0f4db09ec419b61aeb7f94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4d817479e431da6b0f4db09ec419b61aeb7f94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4d817479e431da6b0f4db09ec419b61aeb7f94"}], "stats": {"total": 57, "additions": 38, "deletions": 19}, "files": [{"sha": "cae751f0b383dbdfbcfc2aabdac812ababf728e0", "filename": "gcc/config/arm/arm.md", "status": "modified", "additions": 38, "deletions": 19, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc/gcc%2Fconfig%2Farm%2Farm.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6d5363fa3de2cf709bfc8becf7cd031a1b245cbc/gcc%2Fconfig%2Farm%2Farm.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.md?ref=6d5363fa3de2cf709bfc8becf7cd031a1b245cbc", "patch": "@@ -686,7 +686,7 @@\n ;; storehi is not allowed.\n \n (define_expand \"restorehi\"\n-  [(set (mem:QI (match_operand 1 \"\" \"\"))\n+  [(set (mem:QI (match_operand:SI 1 \"\" \"\"))\n \t(match_dup 2))\n    (set (reg:SI 10)\n \t(ashiftrt:SI (match_operand 0 \"\" \"\") (const_int 8)))\n@@ -705,12 +705,12 @@\n \n (define_expand \"storehi\"\n   [;; store the low byte\n-   (set (mem:QI (match_operand 1 \"\" \"\")) (match_dup 3))\n+   (set (mem:QI (match_operand:SI 1 \"\" \"\")) (match_dup 3))\n    ;; extract the high byte\n    (set (match_dup 2)\n \t(ashiftrt:SI (match_operand 0 \"\" \"\") (const_int 8)))\n    ;; store the high byte\n-   (set (mem:QI (plus (match_dup 1) (const_int 1)))\n+   (set (mem:QI (plus:SI (match_dup 1) (const_int 1)))\n \t(subreg:QI (match_dup 2) 0))]\t;explicit subreg safe\n   \"\"\n   \"\n@@ -724,9 +724,9 @@\n \n (define_expand \"storeinthi\"\n   [;; store the low byte\n-   (set (mem:QI (match_operand 1 \"\" \"\")) (match_operand 0 \"\" \"\"))\n+   (set (mem:QI (match_operand:SI 1 \"\" \"\")) (match_operand 0 \"\" \"\"))\n    ;; store the high byte\n-   (set (mem:QI (plus (match_dup 1) (const_int 1)))\n+   (set (mem:QI (plus:SI (match_dup 1) (const_int 1)))\n \t(match_dup 2))]\n   \"\"\n   \"\n@@ -1247,8 +1247,8 @@\n ;  \"*\n ;  return (output_arithmetic_with_shift (operands, TRUE, FALSE));\n ;\")\n-\f\n-;; Patterns to allow combination of arithmetic and multiplication\n+\n+;; Patterns to allow combination of arithmetic and left shift\n \n ;(define_insn \"\"\n ;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n@@ -1262,18 +1262,37 @@\n ;  return (output_arithmetic_with_immediate_multiply (operands, FALSE));\n ;\")\n \n-; Uncomment this to show combiner problem (see ../COMBINER-PROBLEM).\n-;(define_insn \"\"\n-;  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-;        (match_operator:SI 1 \"shiftable_operator\"\n-;\t  [(mult:SI\n-;\t    (match_operand:SI 3 \"register_operand\" \"r\")\n-;\t    (match_operand:SI 4 \"power_of_two_operand\" \"n\"))\n-;\t   (match_operand:SI 2 \"register_operand\" \"r\")]))]\n-;  \"\"\n-;  \"*\n-;  return (output_arithmetic_with_immediate_multiply (operands, TRUE));\n-;\")\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n+        (match_operator:SI 1 \"shiftable_operator\"\n+\t  [(mult:SI\n+\t    (match_operand:SI 3 \"register_operand\" \"r\")\n+\t    (match_operand:SI 4 \"power_of_two_operand\" \"n\"))\n+\t   (match_operand:SI 2 \"register_operand\" \"r\")]))]\n+  \"\"\n+  \"*\n+  return (output_arithmetic_with_immediate_multiply (operands, TRUE));\n+\")\n+\n+;; This variant of the above insn can occur if the first operand is the\n+;; frame pointer and we eliminate that.  This is a kludge, but there doesn't\n+;; seem to be a way around it.\n+\n+(define_insn \"\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(plus:SI (plus:SI (mult:SI (match_operand:SI 3 \"register_operand\" \"r\")\n+\t\t\t\t   (match_operand:SI 4 \"power_of_two_operand\" \"n\"))\n+\t\t\t  (match_operand:SI 2 \"register_operand\" \"r\"))\n+\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")))]\n+  \"reload_in_progress\"\n+  \"*\n+{\n+  int shift = int_log2 (INTVAL (operands[4]));\n+  operands[4] = GEN_INT (shift);\n+  arm_output_asm_insn (\\\"add\\\\t%0, %2, %3, asl#%4\\\", operands);\n+  operands[2] = operands[0];\n+  return output_add_immediate (operands);\n+}\")\n \f\n ;; Peephole optimizations.\n "}]}