{"sha": "d73b1f074b027d0bf173cbe7b6dc88df5307889c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDczYjFmMDc0YjAyN2QwYmYxNzNjYmU3YjZkYzg4ZGY1MzA3ODg5Yw==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-31T04:19:35Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2001-12-31T04:19:35Z"}, "message": "cfglayout.c (scope_def, [...]): Remove.\n\n        * cfglayout.c (scope_def, scope_forest_info, forest,\n        relate_bbs_with_scopes, make_new_scope, build_scope_forest,\n        remove_scope_notes, insert_intra_before_1, insert_intra_1,\n        insert_intra_bb_scope_notes, insert_inter_bb_scope_notes,\n        rebuild_scope_notes, free_scope_forest_1, dump_scope_forest,\n        dump_scope_forest_1, get_next_bb_note, get_prev_bb_note): Remove.\n        (fixup_reorder_chain): Don't set scope for bb.\n        (insn_scopes, scope_to_insns_initialize, set_block_levels,\n        change_scope, scope_to_insns_finalize): New.\n        (cfg_layout_initialize, cfg_layout_finalize): Update to match.\n        * cfglayout.h (scope_def, scope): Remove.\n        (reorder_block_def): Remove scope member.\n        (scope_to_insns_initialize, scope_to_insns_finalize): Declare.\n        * haifa-sched.c: Revert reemit_other_notes change.\n        * sched-ebb.c (schedule_ebbs): Don't call remove_unnecessary_notes.\n        Use scope_to_insns_initialize and scope_to_insns_finalize.\n        * sched-rgn.c (schedule_insns): Likewise.\n\n        * gcc.dg/debug-6.c: New.\n\nFrom-SVN: r48412", "tree": {"sha": "eda556eeb126b284e63a737eeba7cb809f6af60e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eda556eeb126b284e63a737eeba7cb809f6af60e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d73b1f074b027d0bf173cbe7b6dc88df5307889c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73b1f074b027d0bf173cbe7b6dc88df5307889c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d73b1f074b027d0bf173cbe7b6dc88df5307889c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d73b1f074b027d0bf173cbe7b6dc88df5307889c/comments", "author": null, "committer": null, "parents": [{"sha": "eb3aaa5b8614583989296fe7a7ce16baf7c258f4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb3aaa5b8614583989296fe7a7ce16baf7c258f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb3aaa5b8614583989296fe7a7ce16baf7c258f4"}], "stats": {"total": 879, "additions": 189, "deletions": 690}, "files": [{"sha": "45d5f2dd090a2e36e803c7475a46e71cebd0066d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -1,3 +1,25 @@\n+2001-12-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* cfglayout.c (scope_def, scope_forest_info, forest,\n+\trelate_bbs_with_scopes, make_new_scope, build_scope_forest,\n+\tremove_scope_notes, insert_intra_before_1, insert_intra_1,\n+\tinsert_intra_bb_scope_notes, insert_inter_bb_scope_notes,\n+\trebuild_scope_notes, free_scope_forest_1, dump_scope_forest,\n+\tdump_scope_forest_1, get_next_bb_note, get_prev_bb_note): Remove.\n+\t(fixup_reorder_chain): Don't set scope for bb.\n+\t(insn_scopes, scope_to_insns_initialize, set_block_levels,\n+\tchange_scope, scope_to_insns_finalize): New.\n+\t(cfg_layout_initialize, cfg_layout_finalize): Update to match.\n+\t* cfglayout.h (scope_def, scope): Remove.\n+\t(reorder_block_def): Remove scope member.\n+\t(scope_to_insns_initialize, scope_to_insns_finalize): Declare.\n+\t* haifa-sched.c: Revert reemit_other_notes change.\n+\t* sched-ebb.c (schedule_ebbs): Don't call remove_unnecessary_notes.\n+\tUse scope_to_insns_initialize and scope_to_insns_finalize.\n+\t* sched-rgn.c (schedule_insns): Likewise.\n+\n+2001-12-31  Graham Stott  <grahams@redhat.com>\n+\n 2001-12-31  Graham Stott  <grahams@redhat.com>\n \n \t* c-lex.c: Include tree.h before expr.h"}, {"sha": "ef5206bb69aa6a155c5e3e14b7bb3fbf779293f5", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 96, "deletions": 624, "changes": 720, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -20,6 +20,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #include \"config.h\"\n #include \"system.h\"\n+#include \"tree.h\"\n #include \"rtl.h\"\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n@@ -31,85 +32,24 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n /* The contents of the current function definition are allocated\n    in this obstack, and all are freed at the end of the function.  */\n-\n extern struct obstack flow_obstack;\n \n-/* Structure to hold information about lexical scopes.  */\n-struct scope_def\n-{\n-  int level;\n-\n-  /* The NOTE_INSN_BLOCK_BEG that started this scope.  */\n-  rtx note_beg;\n-\n-  /* The NOTE_INSN_BLOCK_END that ended this scope.  */\n-  rtx note_end;\n-\n-  /* The bb containing note_beg (if any).  */\n-  basic_block bb_beg;\n-\n-  /* The bb containing note_end (if any).  */\n-  basic_block bb_end;\n-\n-  /* List of basic blocks contained within this scope.  */\n-  basic_block *bbs;\n-\n-  /* Number of blocks contained within this scope.  */\n-  int num_bbs;\n-\n-  /* The outer scope or NULL if outermost scope.  */\n-  struct scope_def *outer;\n-\n-  /* The first inner scope or NULL if innermost scope.  */\n-  struct scope_def *inner;\n-\n-  /* The last inner scope or NULL if innermost scope.  */\n-  struct scope_def *inner_last;\n-\n-  /* Link to the next (sibling) scope.  */\n-  struct scope_def *next;\n-};\n-\n-/* Structure to hold information about the scope forest.  */\n-typedef struct\n-{\n-  /* Number of trees in forest.  */\n-  int num_trees;\n-\n-  /* List of tree roots.  */\n-  scope *trees;\n-} scope_forest_info;\n-\n /* Holds the interesting trailing notes for the function.  */\n static rtx function_tail_eff_head;\n \n-/* The scope forest of current function.  */\n-static scope_forest_info forest;\n-\n static rtx skip_insns_after_block\tPARAMS ((basic_block));\n static void record_effective_endpoints\tPARAMS ((void));\n static rtx label_for_bb\t\t\tPARAMS ((basic_block));\n static void fixup_reorder_chain\t\tPARAMS ((void));\n \n-static void relate_bbs_with_scopes\tPARAMS ((scope));\n-static scope make_new_scope\t\tPARAMS ((int, rtx));\n-static void build_scope_forest\t\tPARAMS ((scope_forest_info *));\n-static void remove_scope_notes\t\tPARAMS ((void));\n-static void insert_intra_before_1\tPARAMS ((scope, rtx *, basic_block));\n-static void insert_intra_1\t\tPARAMS ((scope, rtx *, basic_block));\n-static void insert_intra_bb_scope_notes PARAMS ((basic_block));\n-static void insert_inter_bb_scope_notes PARAMS ((basic_block, basic_block));\n-static void rebuild_scope_notes\t\tPARAMS ((scope_forest_info *));\n-static void free_scope_forest_1\t\tPARAMS ((scope));\n-static void free_scope_forest\t\tPARAMS ((scope_forest_info *));\n-void dump_scope_forest\t\t\tPARAMS ((scope_forest_info *));\n-static void dump_scope_forest_1\t\tPARAMS ((scope, int));\n-\n-static rtx get_next_bb_note\t\tPARAMS ((rtx));\n-static rtx get_prev_bb_note\t\tPARAMS ((rtx));\n+static void set_block_levels\t\tPARAMS ((tree, int));\n+static void change_scope\t\tPARAMS ((rtx, tree, tree));\n \n void verify_insn_chain\t\t\tPARAMS ((void));\n static void fixup_fallthru_exit_predecessor PARAMS ((void));\n+\n+/* Map insn uid to lexical block.  */\n+static varray_type insn_scopes;\n \f\n /* Skip over inter-block insns occurring after BB which are typically\n    associated with BB (e.g., barriers). If there are any such insns,\n@@ -245,608 +185,144 @@ record_effective_endpoints ()\n   function_tail_eff_head = next_insn;\n }\n \f\n-/* Return the next NOTE_INSN_BASIC_BLOCK after X.  */\n-\n-static rtx\n-get_next_bb_note (x)\n-     rtx x;\n-{\n-  for (; x; x = NEXT_INSN (x))\n-    if (NOTE_INSN_BASIC_BLOCK_P (x))\n-      return x;\n-\n-  return NULL;\n-}\n-\n-/* Return the fist NOTE_INSN_BASIC_BLOCK before X.  */\n-\n-static rtx\n-get_prev_bb_note (x)\n-     rtx x;\n-{\n-  for (; x; x = PREV_INSN (x))\n-    if (NOTE_INSN_BASIC_BLOCK_P (x))\n-      return x;\n+/* Build a varray mapping INSN_UID to lexical block.  Return it.  */\n \n-  return NULL;\n-}\n-\n-/* Determine and record the relationships between basic blocks and\n-   scopes in scope tree S.  */\n-\n-static void\n-relate_bbs_with_scopes (s)\n-     scope s;\n-{\n-  scope p;\n-  int i, bbi1, bbi2, bbs_spanned;\n-  rtx bbnote;\n-\n-  for (p = s->inner; p; p = p->next)\n-    relate_bbs_with_scopes (p);\n-\n-  bbi1 = bbi2 = -1;\n-  bbs_spanned = 0;\n-\n-  /* If the begin and end notes are both inside the same basic block,\n-     or if they are both outside of basic blocks, then we know immediately\n-     how they are related. Otherwise, we need to poke around to make the\n-     determination.  */\n-  if (s->bb_beg != s->bb_end)\n-    {\n-      if (s->bb_beg && s->bb_end)\n-        {\n-\t  /* Both notes are in different bbs. This implies that all the\n-\t     basic blocks spanned by the pair of notes are contained in\n-             this scope.  */\n-\t  bbi1 = s->bb_beg->index;\n-\t  bbi2 = s->bb_end->index;\n-\t  bbs_spanned = 1;\n-\t}\n-      else if (! s->bb_beg)\n-        {\n-\t  /* First note is outside of a bb. If the scope spans more than\n-\t     one basic block, then they all are contained within this\n-             scope. Otherwise, this scope is contained within the basic\n-\t     block.  */\n-\t  bbnote = get_next_bb_note (s->note_beg);\n-\t  if (! bbnote)\n-\t    abort ();\n-\n-\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_end)\n-\t    {\n-\t      bbs_spanned = 0;\n-\t      s->bb_beg = NOTE_BASIC_BLOCK (bbnote);\n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = NOTE_BASIC_BLOCK (bbnote)->index;\n-\t      bbi2 = s->bb_end->index;\n-\t      s->bb_end = NULL;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-      else /* ! s->bb_end */\n-        {\n-\t  /* Second note is outside of a bb. If the scope spans more than\n-\t     one basic block, then they all are contained within this\n-             scope. Otherwise, this scope is contained within the basic\n-\t     block.  */\n-\t  bbnote = get_prev_bb_note (s->note_end);\n-\t  if (! bbnote)\n-\t    abort ();\n-\n-\t  if (NOTE_BASIC_BLOCK (bbnote) == s->bb_beg)\n-\t    {\n-\t      bbs_spanned = 0;\n-\t      s->bb_end = NOTE_BASIC_BLOCK (bbnote);\n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = s->bb_beg->index;\n-\t      bbi2 = NOTE_BASIC_BLOCK (bbnote)->index;\n-\t      s->bb_beg = NULL;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      if (s->bb_beg)\n-        /* Both notes are in the same bb, which implies the block\n-\t   contains this scope.  */\n-\tbbs_spanned = 0;\n-      else\n-\t{\n-\t  /* Both notes are outside of any bbs. This implies that all the\n-\t     basic blocks spanned by the pair of notes are contained in\n-             this scope. \n-\t     There is a degenerate case to consider. If the notes do not\n-\t     span any basic blocks, then it is an empty scope that can\n-\t     safely be deleted or ignored. Mark these with level = -1.  */\n-\t  rtx x1 = get_next_bb_note (s->note_beg);\n-\t  rtx x2 = get_prev_bb_note (s->note_end);\n-\n-\t  if (! (x1 && x2))\n-\t    {\n-\t      s->level = -1; \n-\t      bbs_spanned = 0; \n-\t    }\n-\t  else\n-\t    {\n-\t      bbi1 = NOTE_BASIC_BLOCK (x1)->index;\n-\t      bbi2 = NOTE_BASIC_BLOCK (x2)->index;\n-\t      bbs_spanned = 1;\n-\t    }\n-\t}\n-    }\n-\n-  /* If the scope spans one or more basic blocks, we record them. We\n-     only record the bbs that are immediately contained within this\n-     scope. Note that if a scope is contained within a bb, we can tell\n-     by checking that bb_beg = bb_end and that they are non-null.  */\n-  if (bbs_spanned)\n-    {\n-      int j = 0;\n-\n-      s->num_bbs = 0;\n-      for (i = bbi1; i <= bbi2; i++)\n-\tif (! RBI (BASIC_BLOCK (i))->scope)\n-\t  s->num_bbs++;\n-\n-      s->bbs = xmalloc (s->num_bbs * sizeof (basic_block));\n-      for (i = bbi1; i <= bbi2; i++)\n-\t{\n-\t  basic_block curr_bb = BASIC_BLOCK (i);\n-\t  if (! RBI (curr_bb)->scope)\n-\t    {\n-\t      s->bbs[j++] = curr_bb;\n-\t      RBI (curr_bb)->scope = s;\n-\t    }\n-\t}\n-    }\n-  else\n-    s->num_bbs = 0;\n-}\n-\n-/* Allocate and initialize a new scope structure with scope level LEVEL,\n-   and record the NOTE beginning the scope.  */\n-\n-static scope \n-make_new_scope (level, note)\n-     int level;\n-     rtx note;\n-{\n-  scope new_scope = xcalloc (1, sizeof (struct scope_def));\n-\n-  new_scope->level = level;\n-  new_scope->note_beg = note;\n-  return new_scope;\n-}\n-\n-\n-/* Build a forest representing the scope structure of the function.\n-   Return a pointer to a structure describing the forest.  */\n-\n-static void\n-build_scope_forest (forest)\n-    scope_forest_info *forest;\n+void\n+scope_to_insns_initialize ()\n {\n-  rtx x;\n-  int level, bbi, i;\n-  basic_block curr_bb;\n-  scope root, curr_scope = 0;\n-\n-  forest->num_trees = 0;\n-  forest->trees = NULL;\n-  level = -1;\n-  root = NULL;\n-  curr_bb = NULL;\n-  bbi = 0;\n-\n-  for (x = get_insns (); x; x = NEXT_INSN (x))\n-    {\n-      if (bbi < n_basic_blocks && x == BASIC_BLOCK (bbi)->head)\n-\tcurr_bb = BASIC_BLOCK (bbi);\n-\n-      if (GET_CODE (x) == NOTE)\n-\t{\n-\t  if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG)\n-\t    {\n-\t      if (root)\n-\t\t{\n-\t\t  scope new_scope;\n-\n-\t\t  if (! curr_scope)\n-\t\t    abort();\n-\n-\t\t  level++;\n-\t\t  new_scope = make_new_scope (level, x);\n-\t\t  new_scope->outer = curr_scope;\n-\t\t  new_scope->next = NULL;\n-\t\t  if (! curr_scope->inner)\n-\t\t    {\n-\t\t      curr_scope->inner = new_scope;\n-\t\t      curr_scope->inner_last = new_scope;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      curr_scope->inner_last->next = new_scope;\n-\t\t      curr_scope->inner_last = new_scope;\n-\t\t    }\n-\t\t  curr_scope = curr_scope->inner_last;\n-\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  int ntrees = forest->num_trees;\n-\n-\t\t  level++;\n-\t          curr_scope = make_new_scope (level, x);\n-\t\t  root = curr_scope;\n-\t\t  forest->trees = xrealloc (forest->trees,\n-\t\t\t\t\t    sizeof (scope) * (ntrees + 1));\n-\t\t  forest->trees[forest->num_trees++] = root;\n-\t\t}\n-\n-\t      curr_scope->bb_beg = curr_bb;\n-\t    }\n-\t  else if (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END)\n-\t    {\n-\t      curr_scope->bb_end = curr_bb;\n-\t      curr_scope->note_end = x;\n-\t      level--;\n-\t      curr_scope = curr_scope->outer;\n-\t      if (level == -1)\n-\t\troot = NULL;\n-\t    }\n-\t}\n-\n-      if (curr_bb && curr_bb->end == x)\n-\t{\n-\t  curr_bb = NULL;\n-\t  bbi++;\n-\t}\n-    } \n-\n-  for (i = 0; i < forest->num_trees; i++)\n-    relate_bbs_with_scopes (forest->trees[i]);\n-}\n-\f\n-/* Remove all NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes from the insn\n-   chain.  */\n+  tree block = NULL;\n+  rtx insn, next;\n \n-static void\n-remove_scope_notes ()\n-{\n-  rtx x, next;\n-  basic_block currbb = NULL;\n+  VARRAY_TREE_INIT (insn_scopes, get_max_uid (), \"insn scopes\");\n \n-  for (x = get_insns (); x; x = next)\n+  for (insn = get_insns (); insn; insn = next)\n     {\n-      next = NEXT_INSN (x);\n-      if (NOTE_INSN_BASIC_BLOCK_P (x))\n-\tcurrbb = NOTE_BASIC_BLOCK (x);\n+      next = NEXT_INSN (insn);\n \n-      if (GET_CODE (x) == NOTE\n-\t  && (NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_BEG\n-\t      || NOTE_LINE_NUMBER (x) == NOTE_INSN_BLOCK_END))\n+      if (active_insn_p (insn)\n+\t  && GET_CODE (PATTERN (insn)) != ADDR_VEC\n+\t  && GET_CODE (PATTERN (insn)) != ADDR_DIFF_VEC)\n+\tVARRAY_TREE (insn_scopes, INSN_UID (insn)) = block;\n+      else if (GET_CODE (insn) == NOTE)\n \t{\n-\t  /* Check if the scope note happens to be the end of a bb.  */\n-\t  if (currbb && x == currbb->end)\n-\t    currbb->end = PREV_INSN (x);\n-\t  if (currbb && x == currbb->head)\n-\t    abort ();\n-\n-\t  if (PREV_INSN (x))\n+\t  switch (NOTE_LINE_NUMBER (insn))\n \t    {\n-\t      NEXT_INSN (PREV_INSN (x)) = next;\n-\t      if (next)\n-\t        PREV_INSN (next) = PREV_INSN (x);\n-\n-              NEXT_INSN (x) = NULL;\n-              PREV_INSN (x) = NULL;\n+\t    case NOTE_INSN_BLOCK_BEG:\n+\t      block = NOTE_BLOCK (insn);\n+\t      delete_insn (insn);\n+\t      break;\n+\t    case NOTE_INSN_BLOCK_END:\n+\t      block = BLOCK_SUPERCONTEXT (block);\n+\t      delete_insn (insn);\n+\t      break;\n+\t    default:\n+\t      break;\n \t    }\n-\t  else\n-\t    abort ();\n \t}\n     }\n }\n-\f\n-/* Insert scope note pairs for a contained scope tree S after insn IP.  */\n \n-static void\n-insert_intra_1 (s, ip, bb)\n-     scope s;\n-     rtx *ip;\n-     basic_block bb;\n-{\n-  scope p;\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_after (NOTE_INSN_BLOCK_BEG, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n-    } \n-\n-  for (p = s->inner; p; p = p->next)\n-    insert_intra_1 (p, ip, bb);\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_after (NOTE_INSN_BLOCK_END, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n-    }\n-}\n-\n-/* Insert scope note pairs for a contained scope tree S before insn IP.  */\n+/* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n+   found in the block tree.  */\n \n static void\n-insert_intra_before_1 (s, ip, bb)\n-     scope s;\n-     rtx *ip;\n-     basic_block bb;\n-{\n-  scope p;\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_before (NOTE_INSN_BLOCK_END, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_end);\n-    } \n-\n-  for (p = s->inner; p; p = p->next)\n-    insert_intra_before_1 (p, ip, bb);\n-\n-  if (NOTE_BLOCK (s->note_beg))\n-    {  \n-      *ip = emit_note_before (NOTE_INSN_BLOCK_BEG, *ip);\n-      NOTE_BLOCK (*ip) = NOTE_BLOCK (s->note_beg);\n-    }\n-}\n-\n-/* Insert NOTE_INSN_BLOCK_END notes and NOTE_INSN_BLOCK_BEG notes for\n-   scopes that are contained within BB.  */\n-\n-static void\n-insert_intra_bb_scope_notes (bb)\n-     basic_block bb;\n+set_block_levels (block, level)\n+     tree block;\n+     int level;\n {\n-  scope s = RBI (bb)->scope;\n-  scope p;\n-  rtx ip;\n-\n-  if (! s)\n-    return;\n-\n-  ip = bb->head;\n-  if (GET_CODE (ip) == CODE_LABEL)\n-    ip = NEXT_INSN (ip);\n-\n-  for (p = s->inner; p; p = p->next)\n+  while (block)\n     {\n-      if (p->bb_beg != NULL && p->bb_beg == p->bb_end && p->bb_beg == bb)\n-\tinsert_intra_1 (p, &ip, bb);\n+      BLOCK_NUMBER (block) = level;\n+      set_block_levels (BLOCK_SUBBLOCKS (block), level + 1);\n+      block = BLOCK_CHAIN (block);\n     }\n }\n \n-/* Given two consecutive basic blocks BB1 and BB2 with different scopes,\n-   insert NOTE_INSN_BLOCK_END notes after BB1 and NOTE_INSN_BLOCK_BEG\n-   notes before BB2 such that the notes are correctly balanced. If BB1 or\n-   BB2 is NULL, we are inserting scope notes for the first and last basic\n-   blocks, respectively.  */\n+/* Emit lexical block notes needed to change scope from S1 to S2.  */\n \n static void\n-insert_inter_bb_scope_notes (bb1, bb2)\n-     basic_block bb1;\n-     basic_block bb2;\n+change_scope (orig_insn, s1, s2)\n+     rtx orig_insn;\n+     tree s1, s2;\n {\n-  rtx ip;\n-  scope com;\n-\n-  /* It is possible that a basic block is not contained in any scope.\n-     In that case, we either open or close a scope but not both.  */\n-  if (bb1 && bb2)\n-    {\n-      scope s1 = RBI (bb1)->scope;\n-      scope s2 = RBI (bb2)->scope;\n+  rtx insn = orig_insn;\n+  tree com = NULL_TREE;\n+  tree ts1 = s1, ts2 = s2;\n+  tree s;\n \n-      if (! s1 && ! s2)\n-\treturn;\n-\n-      if (! s1)\n-\tbb1 = NULL;\n-      else if (! s2)\n-\tbb2 = NULL;\n-    }\n-\n-  /* Find common ancestor scope.  */\n-  if (bb1 && bb2)\n+  while (ts1 != ts2)\n     {\n-      scope s1 = RBI (bb1)->scope;\n-      scope s2 = RBI (bb2)->scope;\n-\n-      while (s1 != s2)\n+      if (ts1 == NULL || ts2 == NULL)\n+\tabort ();\n+      if (BLOCK_NUMBER (ts1) > BLOCK_NUMBER (ts2))\n+\tts1 = BLOCK_SUPERCONTEXT (ts1);\n+      else if (BLOCK_NUMBER (ts1) < BLOCK_NUMBER (ts2))\n+\tts2 = BLOCK_SUPERCONTEXT (ts2);\n+      else\n \t{\n-\t  if (s1->level > s2->level)\n-\t    s1 = s1->outer;\n-\t  else if (s2->level > s1->level)\n-\t    s2 = s2->outer;\n-\t  else\n-\t    {\n-\t      s1 = s1->outer;\n-\t      s2 = s2->outer;\n-\t    }\n+\t  ts1 = BLOCK_SUPERCONTEXT (ts1);\n+\t  ts2 = BLOCK_SUPERCONTEXT (ts2);\n \t}\n-\n-      com = s1;\n     }\n-  else\n-    com = NULL;\n+  com = ts1;\n \n   /* Close scopes.  */\n-  if (bb1)\n+  s = s1;\n+  while (s != com)\n     {\n-      rtx end = bb1->end;\n-      scope s, p;\n-\n-      ip = RBI (bb1)->eff_end;\n-      for (s = RBI (bb1)->scope; s != com; s = s->outer)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_after (NOTE_INSN_BLOCK_END, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_end);\n-\t    }\n-\n-\t  /* Now emit all sibling scopes which don't span any basic\n-\t     blocks.  */\n-\t  if (s->outer)\n-\t    for (p = s->outer->inner; p; p = p->next)\n-\t      if (p != s && p->bb_beg == bb1 && p->bb_beg == p->bb_end)\n-\t\tinsert_intra_1 (p, &ip, bb1);\n-\t}\n-\n-      /* Emitting note may move the end of basic block to unwanted place.  */\n-      bb1->end = end;\n+      rtx note = emit_note_before (NOTE_INSN_BLOCK_END, insn);\n+      NOTE_BLOCK (note) = s;\n+      s = BLOCK_SUPERCONTEXT (s);\n     }\n \n   /* Open scopes.  */\n-  if (bb2)\n+  s = s2;\n+  while (s != com)\n     {\n-      scope s, p;\n-\n-      ip = bb2->head;\n-      for (s = RBI (bb2)->scope; s != com; s = s->outer)\n-\t{\n-\t  if (NOTE_BLOCK (s->note_beg))\n-\t    {  \n-\t      ip = emit_note_before (NOTE_INSN_BLOCK_BEG, ip);\n-\t      NOTE_BLOCK (ip) = NOTE_BLOCK (s->note_beg);\n-\t    }\n-\n-\t  /* Now emit all sibling scopes which don't span any basic\n-\t     blocks.  */\n-\t  if (s->outer)\n-\t    for (p = s->outer->inner; p; p = p->next)\n-\t      if (p != s && p->bb_beg == bb2 && p->bb_beg == p->bb_end)\n-\t\tinsert_intra_before_1 (p, &ip, bb2);\n-\t}\n+      insn = emit_note_before (NOTE_INSN_BLOCK_BEG, insn);\n+      NOTE_BLOCK (insn) = s;\n+      s = BLOCK_SUPERCONTEXT (s);\n     }\n }\n \n-\n /* Rebuild all the NOTE_INSN_BLOCK_BEG and NOTE_INSN_BLOCK_END notes based\n-   on the scope forest and the newly reordered basic blocks.  */\n-\n-static void\n-rebuild_scope_notes (forest)\n-    scope_forest_info *forest;\n-{\n-  int i;\n-\n-  if (forest->num_trees == 0)\n-    return;\n-\n-  /* Start by opening the scopes before the first basic block.  */\n-  insert_inter_bb_scope_notes (NULL, BASIC_BLOCK (0));\n-\n-  /* Then, open and close scopes as needed between blocks.  */\n-  for (i = 0; i < n_basic_blocks - 1; i++)\n-    {\n-      basic_block bb1 = BASIC_BLOCK (i);\n-      basic_block bb2 = BASIC_BLOCK (i + 1);\n-\n-      if (RBI (bb1)->scope != RBI (bb2)->scope)\n-\tinsert_inter_bb_scope_notes (bb1, bb2);\n-      insert_intra_bb_scope_notes (bb1);\n-    }\n-\n-  /* Finally, close the scopes after the last basic block.  */\n-  insert_inter_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1), NULL);\n-  insert_intra_bb_scope_notes (BASIC_BLOCK (n_basic_blocks - 1));\n-}\n-\f\n-/* Free the storage associated with the scope tree at S.  */\n-\n-static void\n-free_scope_forest_1 (s)\n-    scope s;\n-{\n-  scope p, next;\n-\n-  for (p = s->inner; p; p = next)\n-    {\n-      next = p->next;\n-      free_scope_forest_1 (p);\n-    }\n-\n-  if (s->bbs)\n-    free (s->bbs);\n-  free (s);\n-}\n-\n-/* Free the storage associated with the scope forest.  */\n-\n-static void\n-free_scope_forest (forest)\n-    scope_forest_info *forest;\n-{\n-  int i;\n-\n-  for (i = 0; i < forest->num_trees; i++)\n-    free_scope_forest_1 (forest->trees[i]);\n-}\n-\f\n-/* Visualize the scope forest.  */\n+   on the scope tree and the newly reordered instructions.  */\n \n void\n-dump_scope_forest (forest)\n-    scope_forest_info *forest;\n+scope_to_insns_finalize ()\n {\n-  int i;\n-\n-  if (forest->num_trees == 0)\n-    fprintf (stderr, \"\\n< Empty scope forest >\\n\");\n-  else\n-    fprintf (stderr, \"\\n< Scope forest >\\n\");\n+  tree cur_block = DECL_INITIAL (cfun->decl);\n+  rtx insn, note;\n \n-  for (i = 0; i < forest->num_trees; i++)\n-    dump_scope_forest_1 (forest->trees[i], 0);\n-}\n+  /* Tag the blocks with a depth number so that change_scope can find\n+     the common parent easily.  */\n+  set_block_levels (cur_block, 0);\n \n-/* Recursive portion of dump_scope_forest.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      tree this_block;\n \n-static void\n-dump_scope_forest_1 (s, indent)\n-     scope s;\n-     int indent;\n-{\n-  scope p;\n-  int i;\n+      if ((size_t) INSN_UID (insn) >= insn_scopes->num_elements)\n+\tcontinue;\n+      this_block = VARRAY_TREE (insn_scopes, INSN_UID (insn));\n+      if (! this_block)\n+\tcontinue;\n \n-  if (s->bb_beg != NULL && s->bb_beg == s->bb_end\n-      && RBI (s->bb_beg)->scope\n-      && RBI (s->bb_beg)->scope->level + 1 == s->level)\n-    {\n-      fprintf (stderr, \"%*s\", indent, \"\");\n-      fprintf (stderr, \"BB%d:\\n\", s->bb_beg->index);\n+      if (this_block != cur_block)\n+\t{\n+\t  change_scope (insn, cur_block, this_block);\n+\t  cur_block = this_block;\n+\t}\n     }\n \n-  fprintf (stderr, \"%*s\", indent, \"\");\n-  fprintf (stderr, \"{ level %d (block %p)\\n\", s->level,\n-\t   (PTR) NOTE_BLOCK (s->note_beg));\n+  VARRAY_FREE (insn_scopes);\n \n-  fprintf (stderr, \"%*s%s\", indent, \"\", \"bbs:\");\n-  for (i = 0; i < s->num_bbs; i++)\n-    fprintf (stderr, \" %d\", s->bbs[i]->index);\n-  fprintf (stderr, \"\\n\");\n-  \n-  for (p = s->inner; p; p = p->next)\n-    dump_scope_forest_1 (p, indent + 2);\n+  /* change_scope emits before the insn, not after.  */\n+  note = emit_note (NULL, NOTE_INSN_DELETED);\n+  change_scope (note, cur_block, DECL_INITIAL (cfun->decl));\n+  delete_insn (note);\n \n-  fprintf (stderr, \"%*s\", indent, \"\");\n-  fprintf (stderr, \"}\\n\");\n+  reorder_blocks ();\n }\n \f\n /* Given a reorder chain, rearrange the code to match.  */\n@@ -994,7 +470,6 @@ fixup_reorder_chain ()\n \t  alloc_aux_for_block (nb, sizeof (struct reorder_block_def));\n \t  RBI (nb)->eff_head = nb->head;\n \t  RBI (nb)->eff_end = NEXT_INSN (nb->end);\n-\t  RBI (nb)->scope = RBI (bb)->scope;\n \t  RBI (nb)->visited = 1;\n \t  RBI (nb)->next = RBI (bb)->next;\n \t  RBI (bb)->next = nb;\n@@ -1091,8 +566,7 @@ cfg_layout_initialize ()\n {\n   alloc_aux_for_blocks (sizeof (struct reorder_block_def));\n \n-  build_scope_forest (&forest);\n-  remove_scope_notes ();\n+  scope_to_insns_initialize ();\n \n   record_effective_endpoints ();\n }\n@@ -1110,9 +584,7 @@ cfg_layout_finalize ()\n   verify_insn_chain ();\n #endif\n \n-  rebuild_scope_notes (&forest);\n-  free_scope_forest (&forest);\n-  reorder_blocks ();\n+  scope_to_insns_finalize ();\n \n   free_aux_for_blocks ();\n "}, {"sha": "3b12e505f65fc75e59e6e7483acee4473d64bcec", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -18,15 +18,11 @@\n    Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    02111-1307, USA.  */\n \n-struct scope_def;\n-typedef struct scope_def *scope;\n-\n /* Structure to hold information about the blocks during reordering.  */\n typedef struct reorder_block_def\n {\n   rtx eff_head;\n   rtx eff_end;\n-  scope scope;\n   basic_block next;\n   int visited;\n } *reorder_block_def;\n@@ -35,3 +31,6 @@ typedef struct reorder_block_def\n \n extern void cfg_layout_initialize\tPARAMS ((void));\n extern void cfg_layout_finalize\t\tPARAMS ((void));\n+\n+extern void scope_to_insns_initialize\tPARAMS ((void));\n+extern void scope_to_insns_finalize\tPARAMS ((void));"}, {"sha": "7b9a2e821268e0a217c02a23322e9af2e6a539ae", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 18, "deletions": 56, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -319,7 +319,6 @@ static void adjust_priority PARAMS ((rtx));\n static rtx unlink_other_notes PARAMS ((rtx, rtx));\n static rtx unlink_line_notes PARAMS ((rtx, rtx));\n static rtx reemit_notes PARAMS ((rtx, rtx));\n-static rtx reemit_other_notes PARAMS ((rtx, rtx));\n \n static rtx *ready_lastpos PARAMS ((struct ready_list *));\n static void ready_sort PARAMS ((struct ready_list *));\n@@ -1576,60 +1575,6 @@ reemit_notes (insn, last)\n   return retval;\n }\n \n-\n-/* NOTE_LIST is the end of a chain of notes previously found among the\n-   insns.  Insert them at the beginning of the insns.  Actually, insert\n-   NOTE_INSN_BLOCK_END notes at the end of the insns.  Doing otherwise\n-   tends to collapse lexical blocks into empty regions, which is somewhat\n-   less than useful.  */\n-/* ??? Ideally we'd mark each insn with the block it originated from,\n-   and preserve that information.  This requires some moderately\n-   sophisticated block reconstruction code, since block nestings must\n-   be preserved.  */\n-\n-static rtx\n-reemit_other_notes (head, tail)\n-     rtx head, tail;\n-{\n-  bool saw_block_beg = false;\n-\n-  while (note_list)\n-    {\n-      rtx note_tail = note_list;\n-      note_list = PREV_INSN (note_tail);\n-\n-      if (NOTE_LINE_NUMBER (note_tail) == NOTE_INSN_BLOCK_END\n-\t  /* We can only extend the lexical block while we havn't\n-\t     seen a BLOCK_BEG note.  Otherwise we risk mis-nesting\n-\t     the notes.  */\n-\t  && ! saw_block_beg)\n-\t{\n-\t  rtx insert_after = tail;\n-\t  if (GET_CODE (NEXT_INSN (tail)) == BARRIER)\n-\t    insert_after = NEXT_INSN (tail);\n-\n-\t  PREV_INSN (note_tail) = insert_after;\n-\t  NEXT_INSN (note_tail) = NEXT_INSN (insert_after);\n-\t  if (NEXT_INSN (insert_after))\n-\t    PREV_INSN (NEXT_INSN (insert_after)) = note_tail;\n-\t  NEXT_INSN (insert_after) = note_tail;\n-\t}\n-      else\n-\t{\n-\t  if (NOTE_LINE_NUMBER (note_tail) == NOTE_INSN_BLOCK_BEG)\n-\t    saw_block_beg = true;\n-\n-\t  PREV_INSN (note_tail) = PREV_INSN (head);\n-\t  NEXT_INSN (PREV_INSN (head)) = note_tail;\n-\t  NEXT_INSN (note_tail) = head;\n-\t  PREV_INSN (head) = note_tail;\n-\t  head = note_tail;\n-\t}\n-    }\n-\n-  return head;\n-}\n-\n /* Move INSN, and all insns which should be issued before it,\n    due to SCHED_GROUP_P flag.  Reemit notes if needed.\n \n@@ -1855,7 +1800,24 @@ schedule_block (b, rgn_n_insns)\n   head = NEXT_INSN (prev_head);\n   tail = last;\n \n-  head = reemit_other_notes (head, tail);\n+  /* Restore-other-notes: NOTE_LIST is the end of a chain of notes\n+     previously found among the insns.  Insert them at the beginning\n+     of the insns.  */\n+  if (note_list != 0)\n+    {\n+      rtx note_head = note_list;\n+\n+      while (PREV_INSN (note_head))\n+\t{\n+\t  note_head = PREV_INSN (note_head);\n+\t}\n+\n+      PREV_INSN (note_head) = PREV_INSN (head);\n+      NEXT_INSN (PREV_INSN (head)) = note_head;\n+      PREV_INSN (head) = note_list;\n+      NEXT_INSN (note_list) = head;\n+      head = note_head;\n+    }\n \n   /* Debugging.  */\n   if (sched_verbose)"}, {"sha": "31b5f3c19a113c12e639517a23e2894517078992", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -36,6 +36,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"cfglayout.h\"\n #include \"sched-int.h\"\n \f\n /* The number of insns to be scheduled in total.  */\n@@ -285,9 +286,7 @@ schedule_ebbs (dump_file)\n   if (n_basic_blocks == 0)\n     return;\n \n-  /* Remove lexical block notes for empty regions.  These get shuffled\n-     about during scheduling and confuse the debugging issue.  */\n-  remove_unnecessary_notes ();\n+  scope_to_insns_initialize ();\n \n   sched_init (dump_file);\n \n@@ -357,5 +356,7 @@ schedule_ebbs (dump_file)\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n \n+  scope_to_insns_finalize ();\n+\n   sched_finish ();\n }"}, {"sha": "892c03fb27663ddc1addd702b21493f0e134b84e", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -60,6 +60,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"except.h\"\n #include \"toplev.h\"\n #include \"recog.h\"\n+#include \"cfglayout.h\"\n #include \"sched-int.h\"\n \n /* Define when we want to do count REG_DEAD notes before and after scheduling\n@@ -2896,9 +2897,7 @@ schedule_insns (dump_file)\n   if (n_basic_blocks == 0)\n     return;\n \n-  /* Remove lexical block notes for empty regions.  These get shuffled\n-     about during scheduling and confuse the debugging issue.  */\n-  remove_unnecessary_notes ();\n+  scope_to_insns_initialize ();\n \n   nr_inter = 0;\n   nr_spec = 0;\n@@ -2986,6 +2985,8 @@ schedule_insns (dump_file)\n   if (write_symbols != NO_DEBUG)\n     rm_redundant_line_notes ();\n \n+  scope_to_insns_finalize ();\n+\n   if (sched_verbose)\n     {\n       if (reload_completed == 0 && flag_schedule_interblock)"}, {"sha": "f47c334b05ed0434aeb690d6019e34650c103275", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -1,3 +1,7 @@\n+2001-12-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* gcc.dg/debug-6.c: New.\n+\n 2001-12-30  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.c-torture/compile/20011229-2.c: New test."}, {"sha": "1ed8679c9d43b98c564f311471411c4f047b35c8", "filename": "gcc/testsuite/gcc.dg/debug-6.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d73b1f074b027d0bf173cbe7b6dc88df5307889c/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fdebug-6.c?ref=d73b1f074b027d0bf173cbe7b6dc88df5307889c", "patch": "@@ -0,0 +1,38 @@\n+/* Verify that bb-reorder re-inserts nested scopes properly.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -g -dA\" } */\n+/* { dg-final { scan-assembler \"xyzzy\" } } */\n+\n+extern void abort (void);\n+\n+struct A { char *a, *b, *c, *d; };\n+\n+static int\n+bar2 (struct A *x)\n+{\n+  int a = x->c - x->b;\n+  x->c += 26;\n+  return a;\n+}\n+   \n+void fnptr (int *);\n+\n+void\n+foo (void)\n+{\n+  struct A e;\n+\n+  if (bar2 (&e) < 0)\n+    abort ();\n+  {\n+    int xyzzy;\n+    fnptr (&xyzzy);\n+  }\n+  {\n+    struct A *f;\n+  \n+    f = &e;\n+    if (f->c - f->a > f->d - f->a)\n+      f->c = f->d;\n+  }\n+}"}]}