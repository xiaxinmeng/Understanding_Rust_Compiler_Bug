{"sha": "72b3bc895f023bf451357659cfe96c966945bdf9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzJiM2JjODk1ZjAyM2JmNDUxMzU3NjU5Y2ZlOTZjOTY2OTQ1YmRmOQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-03-20T21:06:24Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-03-20T21:06:24Z"}, "message": "Fix verifier ICE on wrong comdat local flag [PR93347]\n\ngcc/ChangeLog:\n\n2020-03-20  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/93347\n\t* cgraph.c (symbol_table::create_edge): Update calls_comdat_local flag.\n\t(cgraph_edge::redirect_callee): Move here; likewise.\n\t(cgraph_node::remove_callees): Update calls_comdat_local flag.\n\t(cgraph_node::verify_node): Verify that calls_comdat_local flag match\n\treality.\n\t(cgraph_node::check_calls_comdat_local_p): New member function.\n\t* cgraph.h (cgraph_node::check_calls_comdat_local_p): Declare.\n\t(cgraph_edge::redirect_callee): Move offline.\n\t* ipa-fnsummary.c (compute_fn_summary): Do not compute\n\tcalls_comdat_local flag here.\n\t* ipa-inline-transform.c (inline_call): Fix updating of\n\tcalls_comdat_local flag.\n\t* ipa-split.c (split_function): Use true instead of 1 to set the flag.\n\t* symtab.c (symtab_node::add_to_same_comdat_group): Update\n\tcalls_comdat_local flag.\n\ngcc/testsuite/ChangeLog:\n\n2020-03-20  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* g++.dg/torture/pr93347.C: New test.", "tree": {"sha": "b50df34185a414a85416a84b69ca390fa091d954", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b50df34185a414a85416a84b69ca390fa091d954"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/72b3bc895f023bf451357659cfe96c966945bdf9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b3bc895f023bf451357659cfe96c966945bdf9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72b3bc895f023bf451357659cfe96c966945bdf9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72b3bc895f023bf451357659cfe96c966945bdf9/comments", "author": null, "committer": null, "parents": [{"sha": "a89349e664ff420f33612d47e486954de5848e49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a89349e664ff420f33612d47e486954de5848e49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a89349e664ff420f33612d47e486954de5848e49"}], "stats": {"total": 437, "additions": 407, "deletions": 30}, "files": [{"sha": "7f00a1367a2ed2ebd4eb9ed02a83a47f02b2b2aa", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -1,3 +1,22 @@\n+2020-03-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/93347\n+\t* cgraph.c (symbol_table::create_edge): Update calls_comdat_local flag.\n+\t(cgraph_edge::redirect_callee): Move here; likewise.\n+\t(cgraph_node::remove_callees): Update calls_comdat_local flag.\n+\t(cgraph_node::verify_node): Verify that calls_comdat_local flag match\n+\treality.\n+\t(cgraph_node::check_calls_comdat_local_p): New member function.\n+\t* cgraph.h (cgraph_node::check_calls_comdat_local_p): Declare.\n+\t(cgraph_edge::redirect_callee): Move offline.\n+\t* ipa-fnsummary.c (compute_fn_summary): Do not compute\n+\tcalls_comdat_local flag here.\n+\t* ipa-inline-transform.c (inline_call): Fix updating of\n+\tcalls_comdat_local flag.\n+\t* ipa-split.c (split_function): Use true instead of 1 to set the flag.\n+\t* symtab.c (symtab_node::add_to_same_comdat_group): Update\n+\tcalls_comdat_local flag.\n+\n 2020-03-20  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-slp.c (vect_analyze_slp_instance): Dump SLP tree"}, {"sha": "6b780f80eb355080afa37c2bde84af1d926d886f", "filename": "gcc/cgraph.c", "status": "modified", "additions": 60, "deletions": 4, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -557,7 +557,8 @@ cgraph_node::get_create (tree decl)\n }\n \n /* Mark ALIAS as an alias to DECL.  DECL_NODE is cgraph node representing\n-   the function body is associated with (not necessarily cgraph_node (DECL).  */\n+   the function body is associated with\n+   (not necessarily cgraph_node (DECL)).  */\n \n cgraph_node *\n cgraph_node::create_alias (tree alias, tree target)\n@@ -914,6 +915,10 @@ symbol_table::create_edge (cgraph_node *caller, cgraph_node *callee,\n   else\n     edge->in_polymorphic_cdtor = caller->thunk.thunk_p;\n \n+  if (callee && symtab->state != LTO_STREAMING\n+      && edge->callee->comdat_local_p ())\n+    edge->caller->calls_comdat_local = true;\n+\n   return edge;\n }\n \n@@ -1341,6 +1346,34 @@ cgraph_edge::make_direct (cgraph_edge *edge, cgraph_node *callee)\n   return edge;\n }\n \n+/* Redirect callee of the edge to N.  The function does not update underlying\n+   call expression.  */\n+\n+void\n+cgraph_edge::redirect_callee (cgraph_node *n)\n+{\n+  bool loc = callee->comdat_local_p ();\n+  /* Remove from callers list of the current callee.  */\n+  remove_callee ();\n+\n+  /* Insert to callers list of the new callee.  */\n+  set_callee (n);\n+\n+  if (!inline_failed)\n+    return;\n+  if (!loc && n->comdat_local_p ())\n+    {\n+      cgraph_node *to = caller->inlined_to ? caller->inlined_to : caller;\n+      to->calls_comdat_local = true;\n+    }\n+  else if (loc && !n->comdat_local_p ())\n+    {\n+      cgraph_node *to = caller->inlined_to ? caller->inlined_to : caller;\n+      gcc_checking_assert (to->calls_comdat_local);\n+      to->calls_comdat_local = to->check_calls_comdat_local_p ();\n+    }\n+}\n+\n /* If necessary, change the function declaration in the call statement\n    associated with E so that it corresponds to the edge callee.  Speculations\n    can be resolved in the process and EDGE can be removed and deallocated.\n@@ -1674,6 +1707,8 @@ cgraph_node::remove_callees (void)\n {\n   cgraph_edge *e, *f;\n \n+  calls_comdat_local = false;\n+\n   /* It is sufficient to remove the edges from the lists of callers of\n      the callees.  The callee list of the node can be zapped with one\n      assignment.  */\n@@ -3369,10 +3404,18 @@ cgraph_node::verify_node (void)\n       error (\"inline clone is forced to output\");\n       error_found = true;\n     }\n-  if (calls_comdat_local && !same_comdat_group)\n+  if (symtab->state != LTO_STREAMING)\n     {\n-      error (\"calls_comdat_local is set outside of a comdat group\");\n-      error_found = true;\n+      if (calls_comdat_local && !same_comdat_group)\n+\t{\n+\t  error (\"calls_comdat_local is set outside of a comdat group\");\n+\t  error_found = true;\n+\t}\n+      if (!inlined_to && calls_comdat_local != check_calls_comdat_local_p ())\n+\t{\n+\t  error (\"invalid calls_comdat_local flag\");\n+\t  error_found = true;\n+\t}\n     }\n   if (DECL_IS_MALLOC (decl)\n       && !POINTER_TYPE_P (TREE_TYPE (TREE_TYPE (decl))))\n@@ -4044,6 +4087,19 @@ cgraph_edge::num_speculative_call_targets_p (void)\n   return indirect_info ? indirect_info->num_speculative_call_targets : 0;\n }\n \n+/* Check if function calls comdat local.  This is used to recompute\n+   calls_comdat_local flag after function transformations.  */\n+bool\n+cgraph_node::check_calls_comdat_local_p ()\n+{\n+  for (cgraph_edge *e = callees; e; e = e->next_callee)\n+    if (e->inline_failed\n+\t? e->callee->comdat_local_p ()\n+\t: e->callee->check_calls_comdat_local_p ())\n+      return true;\n+  return false;\n+}\n+\n /* A stashed copy of \"symtab\" for use by selftest::symbol_table_test.\n    This needs to be a global so that it can be a GC root, and thus\n    prevent the stashed copy from being garbage-collected if the GC runs"}, {"sha": "43de3b4a8acb8dbcdf54472d2c3d9967b942e51c", "filename": "gcc/cgraph.h", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -1326,6 +1326,10 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node\n   /* Return true if this node represents a former, i.e. an expanded, thunk.  */\n   inline bool former_thunk_p (void);\n \n+  /* Check if function calls comdat local.  This is used to recompute\n+     calls_comdat_local flag after function transformations.  */\n+  bool check_calls_comdat_local_p ();\n+\n   /* Return true if function should be optimized for size.  */\n   bool optimize_for_size_p (void);\n \n@@ -3298,19 +3302,6 @@ cgraph_edge::set_callee (cgraph_node *n)\n   callee = n;\n }\n \n-/* Redirect callee of the edge to N.  The function does not update underlying\n-   call expression.  */\n-\n-inline void\n-cgraph_edge::redirect_callee (cgraph_node *n)\n-{\n-  /* Remove from callers list of the current callee.  */\n-  remove_callee ();\n-\n-  /* Insert to callers list of the new callee.  */\n-  set_callee (n);\n-}\n-\n /* Return true when the edge represents a direct recursion.  */\n \n inline bool"}, {"sha": "b411bc4d6603806dab16ee1466f6d170cdab7fcb", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -2944,10 +2944,6 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n        analyze_function_body (node, early);\n        pop_cfun ();\n      }\n-  for (e = node->callees; e; e = e->next_callee)\n-    if (e->callee->comdat_local_p ())\n-      break;\n-  node->calls_comdat_local = (e != NULL);\n \n   /* Inlining characteristics are maintained by the cgraph_mark_inline.  */\n   size_info->size = size_info->self_size;"}, {"sha": "eed992d314da1312560fa9966d9dc6d87b41a875", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 1, "deletions": 8, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -504,14 +504,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   if (callee->calls_comdat_local)\n     to->calls_comdat_local = true;\n   else if (to->calls_comdat_local && comdat_local)\n-    {\n-      struct cgraph_edge *se = to->callees;\n-      for (; se; se = se->next_callee)\n-\tif (se->inline_failed && se->callee->comdat_local_p ())\n-\t  break;\n-      if (se == NULL)\n-\tto->calls_comdat_local = false;\n-    }\n+    to->calls_comdat_local = to->check_calls_comdat_local_p ();\n \n   /* FIXME: This assert suffers from roundoff errors, disable it for GCC 5\n      and revisit it after conversion to sreals in GCC 6."}, {"sha": "973e72cea045635f67ada97776c9c7b7a227ada4", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -1363,7 +1363,7 @@ split_function (basic_block return_bb, class split_point *split_point,\n     {\n       /* TODO: call is versionable if we make sure that all\n \t callers are inside of a comdat group.  */\n-      cur_node->calls_comdat_local = 1;\n+      cur_node->calls_comdat_local = true;\n       node->add_to_same_comdat_group (cur_node);\n     }\n "}, {"sha": "3022acfc1ea09369a8e1e91c8f9ae62fe94c48b6", "filename": "gcc/symtab.c", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -473,6 +473,17 @@ symtab_node::add_to_same_comdat_group (symtab_node *old_node)\n \t;\n       n->same_comdat_group = this;\n     }\n+\n+  cgraph_node *n;\n+  if (comdat_local_p ()\n+      && (n = dyn_cast <cgraph_node *> (this)) != NULL)\n+    {\n+      for (cgraph_edge *e = n->callers; e; e = e->next_caller)\n+\tif (e->caller->inlined_to)\n+\t  e->caller->inlined_to->calls_comdat_local = true;\n+\telse\n+\t  e->caller->calls_comdat_local = true;\n+    }\n }\n \n /* Dissolve the same_comdat_group list in which NODE resides.  */"}, {"sha": "50c42e2b51f8089cd9da3c1a2d96f754a613ea96", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -1,3 +1,8 @@\n+2020-03-20  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/93347\n+\t* g++.dg/torture/pr93347.C: New test.\n+\n 2020-03-20  Patrick Palka  <ppalka@redhat.com>\n \n \tPR c++/69694"}, {"sha": "3b5cc265a1a569769814f5718c8f313184f98691", "filename": "gcc/testsuite/g++.dg/torture/pr93347.C", "status": "added", "additions": 306, "deletions": 0, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/72b3bc895f023bf451357659cfe96c966945bdf9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr93347.C?ref=72b3bc895f023bf451357659cfe96c966945bdf9", "patch": "@@ -0,0 +1,306 @@\n+// { dg-additional-options \"--param early-inlining-insns=3 --param ipa-cp-eval-threshold=100\" }\n+\n+namespace Test1 {\n+  struct A {\n+    virtual int f() final;\n+  };\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test11fEPNS_1AE\n+  int f(A *a) {\n+    // CHECK: call i32 @_ZN5Test11A1fEv\n+    return a->f();\n+  }\n+}\n+\n+namespace Test2 {\n+  struct A final {\n+    virtual int f();\n+  };\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test21fEPNS_1AE\n+  int f(A *a) {\n+    // CHECK: call i32 @_ZN5Test21A1fEv\n+    return a->f();\n+  }\n+}\n+\n+namespace Test2a {\n+  struct A {\n+    virtual ~A() final {}\n+    virtual int f();\n+  };\n+\n+  // CHECK-LABEL: define i32 @_ZN6Test2a1fEPNS_1AE\n+  int f(A *a) {\n+    // CHECK: call i32 @_ZN6Test2a1A1fEv\n+    return a->f();\n+  }\n+}\n+\n+\n+namespace Test3 {\n+  struct A {\n+    virtual int f();  };\n+\n+  struct B final : A { };\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test31fEPNS_1BE\n+  int f(B *b) {\n+    // CHECK: call i32 @_ZN5Test31A1fEv\n+    return b->f();\n+  }\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test31fERNS_1BE\n+  int f(B &b) {\n+    // CHECK: call i32 @_ZN5Test31A1fEv\n+    return b.f();\n+  }\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test31fEPv\n+  int f(void *v) {\n+    // CHECK: call i32 @_ZN5Test31A1fEv\n+    return static_cast<B*>(v)->f();\n+  }\n+}\n+\n+namespace Test4 {\n+  struct A {\n+    virtual void f();\n+    virtual int operator-();\n+  };\n+\n+  struct B final : A {\n+    virtual void f();\n+    virtual int operator-();\n+  };\n+\n+  // CHECK-LABEL: define void @_ZN5Test41fEPNS_1BE\n+  void f(B* d) {\n+    // CHECK: call void @_ZN5Test41B1fEv\n+    static_cast<A*>(d)->f();\n+    // CHECK: call i32 @_ZN5Test41BngEv\n+    -static_cast<A&>(*d);\n+  }\n+}\n+\n+namespace Test5 {\n+  struct A {\n+    virtual void f();\n+    virtual int operator-();\n+  };\n+\n+  struct B : A {\n+    virtual void f();\n+    virtual int operator-();\n+  };\n+\n+  struct C final : B {\n+  };\n+\n+  // CHECK-LABEL: define void @_ZN5Test51fEPNS_1CE\n+  void f(C* d) {\n+    // FIXME: It should be possible to devirtualize this case, but that is\n+    // not implemented yet.\n+    // CHECK: getelementptr\n+    // CHECK-NEXT: %[[FUNC:.*]] = load\n+    // CHECK-NEXT: call void %[[FUNC]]\n+    static_cast<A*>(d)->f();\n+  }\n+  // CHECK-LABEL: define void @_ZN5Test53fopEPNS_1CE\n+  void fop(C* d) {\n+    // FIXME: It should be possible to devirtualize this case, but that is\n+    // not implemented yet.\n+    // CHECK: getelementptr\n+    // CHECK-NEXT: %[[FUNC:.*]] = load\n+    // CHECK-NEXT: call i32 %[[FUNC]]\n+    -static_cast<A&>(*d);\n+  }\n+}\n+\n+namespace Test6 {\n+  struct A {\n+    virtual ~A();\n+  };\n+\n+  struct B : public A {\n+    virtual ~B();\n+  };\n+\n+  struct C {\n+    virtual ~C();\n+  };\n+\n+  struct D final : public C, public B {\n+  };\n+\n+  // CHECK-LABEL: define void @_ZN5Test61fEPNS_1DE\n+  void f(D* d) {\n+    // CHECK: call void @_ZN5Test61DD1Ev\n+    static_cast<A*>(d)->~A();\n+  }\n+}\n+\n+namespace Test7 {\n+  struct foo {\n+    virtual void g() {}\n+  };\n+\n+  struct bar {\n+    virtual int f() { return 0; }\n+  };\n+\n+  struct zed final : public foo, public bar {\n+    int z;\n+    virtual int f() {return z;}\n+  };\n+\n+  // CHECK-LABEL: define i32 @_ZN5Test71fEPNS_3zedE\n+  int f(zed *z) {\n+    // CHECK: alloca\n+    // CHECK-NEXT: store\n+    // CHECK-NEXT: load\n+    // CHECK-NEXT: call i32 @_ZN5Test73zed1fEv\n+    // CHECK-NEXT: ret\n+    return static_cast<bar*>(z)->f();\n+  }\n+}\n+\n+namespace Test8 {\n+  struct A { virtual ~A() {} };\n+  struct B {\n+    int b;\n+    virtual int foo() { return b; }\n+  };\n+  struct C final : A, B {  };\n+  // CHECK-LABEL: define i32 @_ZN5Test84testEPNS_1CE\n+  int test(C *c) {\n+    // CHECK: %[[THIS:.*]] = phi\n+    // CHECK-NEXT: call i32 @_ZN5Test81B3fooEv(%\"struct.Test8::B\"* %[[THIS]])\n+    return static_cast<B*>(c)->foo();\n+  }\n+}\n+\n+namespace Test9 {\n+  struct A {\n+    int a;\n+  };\n+  struct B {\n+    int b;\n+  };\n+  struct C : public B, public A {\n+  };\n+  struct RA {\n+    virtual A *f() {\n+      return 0;\n+    }\n+    virtual A *operator-() {\n+      return 0;\n+    }\n+  };\n+  struct RC final : public RA {\n+    virtual C *f() {\n+      C *x = new C();\n+      x->a = 1;\n+      x->b = 2;\n+      return x;\n+    }\n+    virtual C *operator-() {\n+      C *x = new C();\n+      x->a = 1;\n+      x->b = 2;\n+      return x;\n+    }\n+  };\n+  // CHECK: define {{.*}} @_ZN5Test91fEPNS_2RCE\n+  A *f(RC *x) {\n+    // FIXME: It should be possible to devirtualize this case, but that is\n+    // not implemented yet.\n+    // CHECK: load\n+    // CHECK: bitcast\n+    // CHECK: [[F_PTR_RA:%.+]] = bitcast\n+    // CHECK: [[VTABLE:%.+]] = load {{.+}} [[F_PTR_RA]]\n+    // CHECK: [[VFN:%.+]] = getelementptr inbounds {{.+}} [[VTABLE]], i{{[0-9]+}} 0\n+    // CHECK-NEXT: %[[FUNC:.*]] = load {{.+}} [[VFN]]\n+    // CHECK-NEXT: = call {{.*}} %[[FUNC]]\n+    return static_cast<RA*>(x)->f();\n+  }\n+  // CHECK: define {{.*}} @_ZN5Test93fopEPNS_2RCE\n+  A *fop(RC *x) {\n+    // FIXME: It should be possible to devirtualize this case, but that is\n+    // not implemented yet.\n+    // CHECK: load\n+    // CHECK: bitcast\n+    // CHECK: [[F_PTR_RA:%.+]] = bitcast\n+    // CHECK: [[VTABLE:%.+]] = load {{.+}} [[F_PTR_RA]]\n+    // CHECK: [[VFN:%.+]] = getelementptr inbounds {{.+}} [[VTABLE]], i{{[0-9]+}} 1\n+    // CHECK-NEXT: %[[FUNC:.*]] = load {{.+}} [[VFN]]\n+    // CHECK-NEXT: = call {{.*}} %[[FUNC]]\n+    return -static_cast<RA&>(*x);\n+  }\n+}\n+\n+namespace Test10 {\n+  struct A {\n+    virtual int f();\n+  };\n+\n+  struct B : A {\n+    int f() final;\n+  };\n+\n+  // CHECK-LABEL: define i32 @_ZN6Test101fEPNS_1BE\n+  int f(B *b) {\n+    // CHECK: call i32 @_ZN6Test101B1fEv\n+    return static_cast<A *>(b)->f();\n+  }\n+}\n+\n+namespace Test11 {\n+  // Check that the definitions of Derived's operators are emitted.\n+\n+  // CHECK-LABEL: define linkonce_odr void @_ZN6Test111SIiE4foo1Ev(\n+  // CHECK: call void @_ZN6Test111SIiE7DerivedclEv(\n+  // CHECK: call zeroext i1 @_ZN6Test111SIiE7DerivedeqERKNS_4BaseE(\n+  // CHECK: call zeroext i1 @_ZN6Test111SIiE7DerivedntEv(\n+  // CHECK: call dereferenceable(4) %\"class.Test11::Base\"* @_ZN6Test111SIiE7DerivedixEi(\n+  // CHECK: define linkonce_odr void @_ZN6Test111SIiE7DerivedclEv(\n+  // CHECK: define linkonce_odr zeroext i1 @_ZN6Test111SIiE7DerivedeqERKNS_4BaseE(\n+  // CHECK: define linkonce_odr zeroext i1 @_ZN6Test111SIiE7DerivedntEv(\n+  // CHECK: define linkonce_odr dereferenceable(4) %\"class.Test11::Base\"* @_ZN6Test111SIiE7DerivedixEi(\n+  class Base {\n+  public:\n+    virtual void operator()() {}\n+    virtual bool operator==(const Base &other) { return false; }\n+    virtual bool operator!() { return false; }\n+    virtual Base &operator[](int i) { return *this; }\n+  };\n+\n+  template<class T>\n+  struct S {\n+    class Derived final : public Base {\n+    public:\n+      void operator()() override {}\n+      bool operator==(const Base &other) override { return true; }\n+      bool operator!() override { return true; }\n+      Base &operator[](int i) override { return *this; }\n+    };\n+\n+    Derived *ptr = nullptr, *ptr2 = nullptr;\n+\n+    void foo1() {\n+      if (ptr && ptr2) {\n+        // These calls get devirtualized. Linkage fails if the definitions of\n+        // the called functions are not emitted.\n+        (*ptr)();\n+        (void)(*ptr == *ptr2);\n+        (void)(!(*ptr));\n+        (void)((*ptr)[1]);\n+      }\n+    }\n+  };\n+\n+  void foo2() {\n+    S<int> *s = new S<int>;\n+    s->foo1();\n+  }\n+}"}]}