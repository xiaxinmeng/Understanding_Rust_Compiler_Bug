{"sha": "8b0b334af3439179947522206b2478a28b908e61", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGIwYjMzNGFmMzQzOTE3OTk0NzUyMjIwNmIyNDc4YTI4YjkwOGU2MQ==", "commit": {"author": {"name": "Qing Zhao", "email": "qing.zhao@oracle.com", "date": "2018-05-31T20:01:42Z"}, "committer": {"name": "Qing Zhao", "email": "qinzhao@gcc.gnu.org", "date": "2018-05-31T20:01:42Z"}, "message": "2nd Patch for PR78009\nPatch for PR83026\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=78809\nInline strcmp with small constant strings\n\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=83026\nmissing strlen optimization for strcmp of unequal strings\n\nThe design doc for PR78809 is at:\nhttps://www.mail-archive.com/gcc@gcc.gnu.org/msg83822.html\n\nthis patch is for the second part of change of PR78809 and PR83026:\n\nB. for strncmp (s1, s2, n) (!)= 0 or strcmp (s1, s2) (!)= 0\n\n   B.1. (PR83026) When the lengths of both arguments are constant and\n        it's a strcmp:\n      * if the lengths are NOT equal, we can safely fold the call\n        to a non-zero value.\n      * otherwise, do nothing now.\n\n   B.2. (PR78809) When the length of one argument is constant, try to replace\n   the call with a __builtin_str(n)cmp_eq call where possible, i.e:\n\n   strncmp (s, STR, C) (!)= 0 in which, s is a pointer to a string, STR is a\n   string with constant length, C is a constant.\n     if (C <= strlen(STR) && sizeof_array(s) > C)\n       {\n         replace this call with\n         __builtin_strncmp_eq (s, STR, C) (!)= 0\n       }\n     if (C > strlen(STR)\n       {\n         it can be safely treated as a call to strcmp (s, STR) (!)= 0\n         can handled by the following strcmp.\n       }\n\n   strcmp (s, STR) (!)= 0 in which, s is a pointer to a string, STR is a\n   string with constant length.\n     if  (sizeof_array(s) > strlen(STR))\n       {\n         replace this call with\n         __builtin_strcmp_eq (s, STR, strlen(STR)+1) (!)= 0\n       }\n\n   later when expanding the new __builtin_str(n)cmp_eq calls, first expand them\n   as __builtin_memcmp_eq, if the expansion does not succeed, change them back\n   to call to __builtin_str(n)cmp.\n\nadding test case strcmpopt_2.c and strcmpopt_4.c into gcc.dg for part B of\nPR78809 adding test case strcmpopt_3.c into gcc.dg for PR83026\n\nFrom-SVN: r261039", "tree": {"sha": "1788b6670d6db9169fdfad6b15c80815fe4af24d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1788b6670d6db9169fdfad6b15c80815fe4af24d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8b0b334af3439179947522206b2478a28b908e61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0b334af3439179947522206b2478a28b908e61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8b0b334af3439179947522206b2478a28b908e61", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8b0b334af3439179947522206b2478a28b908e61/comments", "author": {"login": "qingzhao69", "id": 89154636, "node_id": "MDQ6VXNlcjg5MTU0NjM2", "avatar_url": "https://avatars.githubusercontent.com/u/89154636?v=4", "gravatar_id": "", "url": "https://api.github.com/users/qingzhao69", "html_url": "https://github.com/qingzhao69", "followers_url": "https://api.github.com/users/qingzhao69/followers", "following_url": "https://api.github.com/users/qingzhao69/following{/other_user}", "gists_url": "https://api.github.com/users/qingzhao69/gists{/gist_id}", "starred_url": "https://api.github.com/users/qingzhao69/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/qingzhao69/subscriptions", "organizations_url": "https://api.github.com/users/qingzhao69/orgs", "repos_url": "https://api.github.com/users/qingzhao69/repos", "events_url": "https://api.github.com/users/qingzhao69/events{/privacy}", "received_events_url": "https://api.github.com/users/qingzhao69/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "28c84b6247e1ff5f3c7aa4c4912c361012fa3904", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28c84b6247e1ff5f3c7aa4c4912c361012fa3904", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28c84b6247e1ff5f3c7aa4c4912c361012fa3904"}], "stats": {"total": 502, "additions": 485, "deletions": 17}, "files": [{"sha": "370344c66e6dd299bfa57feac63a61e5252f806c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -1,3 +1,25 @@\n+2018-05-31  Qing Zhao <qing.zhao@oracle.com>\n+\n+\tPR middle-end/78809\n+\tPR middle-end/83026\n+\t* builtins.c (expand_builtin): Add the handling of BUILT_IN_STRCMP_EQ\n+\tand BUILT_IN_STRNCMP_EQ.\n+\t* builtins.def: Add new builtins BUILT_IN_STRCMP_EQ and\n+\tBUILT_IN_STRNCMP_EQ.\n+\t* gimple-fold.c (gimple_fold_builtin_string_compare): Add the\n+\thandling of BUILTIN_IN_STRCMP_EQ and BUILT_IN_STRNCMP_EQ.\n+\t(gimple_fold_builtin): Likewise.\n+\t* tree-ssa-strlen.c (compute_string_length): New function.\n+\t(determine_min_obsize): New function.\n+\t(handle_builtin_string_cmp): New function to handle calls to\n+\tstring compare functions.\n+\t(strlen_optimize_stmt): Add handling to builtin string compare\n+\tcalls.\n+\t* tree-ssa-structalias.c (find_func_aliases_for_builtin_call):\n+\tAdd the handling of BUILT_IN_STRCMP_EQ and BUILT_IN_STRNCMP_EQ.\n+\t* tree.c (build_common_builtin_nodes): Add new defines of\n+\tBUILT_IN_STRNCMP_EQ and BUILT_IN_STRCMP_EQ.\n+\n 2018-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/85984"}, {"sha": "c96ac38e8e9adc1ba1f496e5c89a79405882fdac", "filename": "gcc/builtins.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -7139,12 +7139,45 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n \treturn target;\n       break;\n \n+    /* Expand it as BUILT_IN_MEMCMP_EQ first. If not successful, change it \n+       back to a BUILT_IN_STRCMP. Remember to delete the 3rd paramater\n+       when changing it to a strcmp call.  */\n+    case BUILT_IN_STRCMP_EQ:\n+      target = expand_builtin_memcmp (exp, target, true);\n+      if (target)\n+\treturn target;\n+\n+      /* Change this call back to a BUILT_IN_STRCMP.  */\n+      TREE_OPERAND (exp, 1) \n+\t= build_fold_addr_expr (builtin_decl_explicit (BUILT_IN_STRCMP));\n+\n+      /* Delete the last parameter.  */\n+      unsigned int i;\n+      vec<tree, va_gc> *arg_vec;\n+      vec_alloc (arg_vec, 2);\n+      for (i = 0; i < 2; i++)\n+\targ_vec->quick_push (CALL_EXPR_ARG (exp, i));\n+      exp = build_call_vec (TREE_TYPE (exp), CALL_EXPR_FN (exp), arg_vec);\n+      /* FALLTHROUGH */\n+\n     case BUILT_IN_STRCMP:\n       target = expand_builtin_strcmp (exp, target);\n       if (target)\n \treturn target;\n       break;\n \n+    /* Expand it as BUILT_IN_MEMCMP_EQ first. If not successful, change it\n+       back to a BUILT_IN_STRNCMP.  */\n+    case BUILT_IN_STRNCMP_EQ:\n+      target = expand_builtin_memcmp (exp, target, true);\n+      if (target)\n+\treturn target;\n+\n+      /* Change it back to a BUILT_IN_STRNCMP.  */\n+      TREE_OPERAND (exp, 1) \n+\t= build_fold_addr_expr (builtin_decl_explicit (BUILT_IN_STRNCMP));\n+      /* FALLTHROUGH */\n+\n     case BUILT_IN_STRNCMP:\n       target = expand_builtin_strncmp (exp, target, mode);\n       if (target)"}, {"sha": "58b469844a7a8b80c50e3359dd649d07f184ac94", "filename": "gcc/builtins.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -971,6 +971,11 @@ DEF_BUILTIN_STUB (BUILT_IN_ALLOCA_WITH_ALIGN_AND_MAX, \"__builtin_alloca_with_ali\n    equality with zero.  */\n DEF_BUILTIN_STUB (BUILT_IN_MEMCMP_EQ, \"__builtin_memcmp_eq\")\n \n+/* An internal version of strcmp/strncmp, used when the result is only \n+   tested for equality with zero.  */\n+DEF_BUILTIN_STUB (BUILT_IN_STRCMP_EQ, \"__builtin_strcmp_eq\")\n+DEF_BUILTIN_STUB (BUILT_IN_STRNCMP_EQ, \"__builtin_strncmp_eq\")\n+\n /* Object size checking builtins.  */\n DEF_GCC_BUILTIN\t       (BUILT_IN_OBJECT_SIZE, \"object_size\", BT_FN_SIZE_CONST_PTR_INT, ATTR_PURE_NOTHROW_LEAF_LIST)\n DEF_EXT_LIB_BUILTIN_CHKP (BUILT_IN_MEMCPY_CHK, \"__memcpy_chk\", BT_FN_PTR_PTR_CONST_PTR_SIZE_SIZE, ATTR_RET1_NOTHROW_NONNULL_LEAF)"}, {"sha": "9bbe7f1d9092c268562059748e81442958ac9c1f", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -2215,12 +2215,14 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n       switch (fcode)\n \t{\n \tcase BUILT_IN_STRCMP:\n+\tcase BUILT_IN_STRCMP_EQ:\n \t  {\n \t    r = strcmp (p1, p2);\n \t    known_result = true;\n \t    break;\n \t  }\n \tcase BUILT_IN_STRNCMP:\n+\tcase BUILT_IN_STRNCMP_EQ:\n \t  {\n \t    if (length == -1)\n \t      break;\n@@ -2254,6 +2256,7 @@ gimple_fold_builtin_string_compare (gimple_stmt_iterator *gsi)\n \n   bool nonzero_length = length >= 1\n     || fcode == BUILT_IN_STRCMP\n+    || fcode == BUILT_IN_STRCMP_EQ\n     || fcode == BUILT_IN_STRCASECMP;\n \n   location_t loc = gimple_location (stmt);\n@@ -3687,8 +3690,10 @@ gimple_fold_builtin (gimple_stmt_iterator *gsi)\n     case BUILT_IN_STRSTR:\n       return gimple_fold_builtin_strstr (gsi);\n     case BUILT_IN_STRCMP:\n+    case BUILT_IN_STRCMP_EQ:\n     case BUILT_IN_STRCASECMP:\n     case BUILT_IN_STRNCMP:\n+    case BUILT_IN_STRNCMP_EQ:\n     case BUILT_IN_STRNCASECMP:\n       return gimple_fold_builtin_string_compare (gsi);\n     case BUILT_IN_MEMCHR:"}, {"sha": "677d8e00d18ea8179bb43f371b1911f70e34ad03", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -1,3 +1,12 @@\n+2018-05-31  Qing Zhao <qing.zhao@oracle.com>\n+\n+\tPR middle-end/78809\n+\t* gcc.dg/strcmpopt_2.c: New test.\n+\t* gcc.dg/strcmpopt_3.c: New test.\n+\n+\tPR middle-end/83026\n+\t* gcc.dg/strcmpopt_3.c: New test.\n+\n 2018-05-31  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/85984"}, {"sha": "0131b8f7d69d644eb428a88d3162e95f6d826ee0", "filename": "gcc/testsuite/gcc.dg/strcmpopt_2.c", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_2.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -0,0 +1,67 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+char s[100] = {'a','b','c','d'};\n+typedef struct { char s[8]; int x; } S;\n+\n+__attribute__ ((noinline)) int \n+f1 (S *s) \n+{ \n+  return __builtin_strcmp (s->s, \"abc\") != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f2 (void) \n+{ \n+  return __builtin_strcmp (s, \"abc\") != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f3 (S *s) \n+{ \n+  return __builtin_strcmp (\"abc\", s->s) != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f4 (void) \n+{ \n+  return __builtin_strcmp (\"abc\", s) != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f5 (S *s) \n+{ \n+  return __builtin_strncmp (s->s, \"abc\", 3) != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f6 (void) \n+{ \n+  return __builtin_strncmp (s, \"abc\", 2) != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f7 (S *s) \n+{ \n+  return __builtin_strncmp (\"abc\", s->s, 3) != 0; \n+}\n+\n+__attribute__ ((noinline)) int \n+f8 (void) \n+{ \n+  return __builtin_strncmp (\"abc\", s, 2) != 0; \n+}\n+\n+int main (void)\n+{\n+  S ss = {{'a','b','c'}, 2};\n+\n+  if (f1 (&ss) != 0 || f2 () != 1 || f3 (&ss) != 0 ||\n+      f4 () != 1 || f5 (&ss) != 0 || f6 () != 0 ||\n+      f7 (&ss) != 0 || f8 () != 0)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 8 \"strlen\" } } */"}, {"sha": "86a0d7a08b3a4c081d83c782b1e586e9694d1318", "filename": "gcc/testsuite/gcc.dg/strcmpopt_3.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_3.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+__attribute__ ((noinline)) int \n+f1 (void) \n+{ \n+  char *s0= \"abcd\";\n+  char s[8];\n+  __builtin_strcpy (s, s0);\n+  return __builtin_strcmp(s, \"abc\") != 0; \n+}\n+\n+__attribute__ ((noinline)) int\n+f2 (void) \n+{ \n+  char *s0 = \"ab\";\n+  char s[8];\n+  __builtin_strcpy (s, s0);\n+  return __builtin_strcmp(\"abc\", s) != 0; \n+}\n+\n+int main (void)\n+{\n+  if (f1 () != 1 \n+      || f2 () != 1)\n+    __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"strcmp\" 0 \"strlen\" } } */"}, {"sha": "d727bc363e5c353997407580fa81ac0cddd2ccf6", "filename": "gcc/testsuite/gcc.dg/strcmpopt_4.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstrcmpopt_4.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-strlen\" } */\n+\n+typedef struct { char s[8]; int x; } S;\n+extern int max_i;\n+\n+int\n+f1 (S * s)\n+{ \n+  int result, i;\n+  for (i = 0; i < max_i; i++)\n+    result += __builtin_strcmp (s->s, \"abc\") != 0 ? 2 : 1;\n+  return result;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"cmp_eq \\\\(\" 1 \"strlen\" } } */"}, {"sha": "7a89174d6aaa45bac9c9ce8575a41061365fad41", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 287, "deletions": 17, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"params.h\"\n #include \"ipa-chkp.h\"\n #include \"tree-hash-traits.h\"\n+#include \"tree-object-size.h\"\n #include \"builtins.h\"\n #include \"target.h\"\n #include \"diagnostic-core.h\"\n@@ -2627,27 +2628,28 @@ handle_builtin_malloc (enum built_in_function bcode, gimple_stmt_iterator *gsi)\n \n /* Handle a call to memset.\n    After a call to calloc, memset(,0,) is unnecessary.\n-   memset(malloc(n),0,n) is calloc(n,1).  */\n+   memset(malloc(n),0,n) is calloc(n,1). \n+   return true when the call is transfomred, false otherwise.  */\n \n static bool\n handle_builtin_memset (gimple_stmt_iterator *gsi)\n {\n   gimple *stmt2 = gsi_stmt (*gsi);\n   if (!integer_zerop (gimple_call_arg (stmt2, 1)))\n-    return true;\n+    return false;\n   tree ptr = gimple_call_arg (stmt2, 0);\n   int idx1 = get_stridx (ptr);\n   if (idx1 <= 0)\n-    return true;\n+    return false;\n   strinfo *si1 = get_strinfo (idx1);\n   if (!si1)\n-    return true;\n+    return false;\n   gimple *stmt1 = si1->stmt;\n   if (!stmt1 || !is_gimple_call (stmt1))\n-    return true;\n+    return false;\n   tree callee1 = gimple_call_fndecl (stmt1);\n   if (!valid_builtin_call (stmt1))\n-    return true;\n+    return false;\n   enum built_in_function code1 = DECL_FUNCTION_CODE (callee1);\n   tree size = gimple_call_arg (stmt2, 2);\n   if (code1 == BUILT_IN_CALLOC)\n@@ -2663,7 +2665,7 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n       si1->stmt = gsi_stmt (gsi1);\n     }\n   else\n-    return true;\n+    return false;\n   tree lhs = gimple_call_lhs (stmt2);\n   unlink_stmt_vdef (stmt2);\n   if (lhs)\n@@ -2677,12 +2679,13 @@ handle_builtin_memset (gimple_stmt_iterator *gsi)\n       release_defs (stmt2);\n     }\n \n-  return false;\n+  return true;\n }\n \n /* Handle a call to memcmp.  We try to handle small comparisons by\n    converting them to load and compare, and replacing the call to memcmp\n-   with a __builtin_memcmp_eq call where possible.  */\n+   with a __builtin_memcmp_eq call where possible. \n+   return true when call is transformed, return false otherwise.  */\n \n static bool\n handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n@@ -2697,7 +2700,7 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n   imm_use_iterator iter;\n \n   if (!res)\n-    return true;\n+    return false;\n \n   FOR_EACH_IMM_USE_FAST (use_p, iter, res)\n     {\n@@ -2711,17 +2714,17 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \t  tree_code code = gimple_assign_rhs_code (asgn);\n \t  if ((code != EQ_EXPR && code != NE_EXPR)\n \t      || !integer_zerop (gimple_assign_rhs2 (asgn)))\n-\t    return true;\n+\t    return false;\n \t}\n       else if (gimple_code (ustmt) == GIMPLE_COND)\n \t{\n \t  tree_code code = gimple_cond_code (ustmt);\n \t  if ((code != EQ_EXPR && code != NE_EXPR)\n \t      || !integer_zerop (gimple_cond_rhs (ustmt)))\n-\t    return true;\n+\t    return false;\n \t}\n       else\n-\treturn true;\n+\treturn false;\n     }\n \n   if (tree_fits_uhwi_p (len)\n@@ -2756,12 +2759,274 @@ handle_builtin_memcmp (gimple_stmt_iterator *gsi)\n \t\t\t\t\t\t   boolean_type_node,\n \t\t\t\t\t\t   arg1, arg2));\n \t  gimplify_and_update_call_from_tree (gsi, res);\n-\t  return false;\n+\t  return true;\n \t}\n     }\n \n   gimple_call_set_fndecl (stmt2, builtin_decl_explicit (BUILT_IN_MEMCMP_EQ));\n-  return false;\n+  return true;\n+}\n+\n+/* Given an index to the strinfo vector, compute the string length for the\n+   corresponding string. Return -1 when unknown.  */\n+ \n+static HOST_WIDE_INT \n+compute_string_length (int idx)\n+{\n+  HOST_WIDE_INT string_leni = -1; \n+  gcc_assert (idx != 0);\n+\n+  if (idx < 0)\n+   return ~idx;\n+\n+  strinfo *si = get_strinfo (idx);\n+  if (si)\n+    {\n+      tree const_string_len = get_string_length (si);\n+      if (const_string_len && tree_fits_shwi_p (const_string_len))\n+\tstring_leni = tree_to_shwi (const_string_len);\n+    }\n+\n+  if (string_leni < 0)\n+    return -1;\n+\n+  return string_leni;\n+}\n+\n+/* Determine the minimum size of the object referenced by DEST expression which\n+   must have a pointer type. \n+   Return the minimum size of the object if successful or NULL when the size \n+   cannot be determined.  */\n+static tree\n+determine_min_objsize (tree dest)\n+{\n+  unsigned HOST_WIDE_INT size = 0;\n+\n+  if (compute_builtin_object_size (dest, 2, &size))\n+    return build_int_cst (sizetype, size);\n+\n+  /* Try to determine the size of the object through the RHS of the \n+     assign statement.  */\n+  if (TREE_CODE (dest) == SSA_NAME)\n+    {\n+      gimple *stmt = SSA_NAME_DEF_STMT (dest);\n+      if (!is_gimple_assign (stmt))\n+\treturn NULL_TREE;\n+\n+      if (!gimple_assign_single_p (stmt)\n+\t  && !gimple_assign_unary_nop_p (stmt))\n+\treturn NULL_TREE;\n+\n+      dest = gimple_assign_rhs1 (stmt);\n+      return determine_min_objsize (dest);\n+    }\n+\n+  /* Try to determine the size of the object from its type.  */\n+  if (TREE_CODE (dest) != ADDR_EXPR)\n+    return NULL_TREE;\n+\n+  tree type = TREE_TYPE (dest);\n+  if (TREE_CODE (type) == POINTER_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  type = TYPE_MAIN_VARIANT (type);\n+\n+  /* We cannot determine the size of the array if it's a flexible array, \n+     which is declared at the end of a structure.  */\n+  if (TREE_CODE (type) == ARRAY_TYPE\n+      && !array_at_struct_end_p (dest))\n+    {\n+      tree size_t = TYPE_SIZE_UNIT (type);\n+      if (size_t && TREE_CODE (size_t) == INTEGER_CST \n+\t  && !integer_zerop (size_t))\n+        return size_t;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Handle a call to strcmp or strncmp. When the result is ONLY used to do \n+   equality test against zero:\n+\n+   A. When the lengths of both arguments are constant and it's a strcmp:\n+      * if the lengths are NOT equal, we can safely fold the call\n+        to a non-zero value.\n+      * otherwise, do nothing now.\n+  \n+   B. When the length of one argument is constant, try to replace the call with\n+   a __builtin_str(n)cmp_eq call where possible, i.e:\n+\n+   strncmp (s, STR, C) (!)= 0 in which, s is a pointer to a string, STR is a \n+   string with constant length , C is a constant.\n+     if (C <= strlen(STR) && sizeof_array(s) > C)\n+       {\n+         replace this call with\n+         strncmp_eq (s, STR, C) (!)= 0\n+       }\n+     if (C > strlen(STR)\n+       {\n+         it can be safely treated as a call to strcmp (s, STR) (!)= 0\n+         can handled by the following strcmp.\n+       }\n+\n+   strcmp (s, STR) (!)= 0 in which, s is a pointer to a string, STR is a \n+   string with constant length.\n+     if  (sizeof_array(s) > strlen(STR))\n+       {\n+         replace this call with\n+         strcmp_eq (s, STR, strlen(STR)+1) (!)= 0\n+       }\n+\n+   Return true when the call is transformed, return false otherwise. \n+ */ \n+\n+static bool\n+handle_builtin_string_cmp (gimple_stmt_iterator *gsi)\n+{\n+  gcall *stmt = as_a <gcall *> (gsi_stmt (*gsi));\n+  tree res = gimple_call_lhs (stmt);\n+  use_operand_p use_p;\n+  imm_use_iterator iter;\n+  tree arg1 = gimple_call_arg (stmt, 0);\n+  tree arg2 = gimple_call_arg (stmt, 1);\n+  int idx1 = get_stridx (arg1);\n+  int idx2 = get_stridx (arg2);\n+  HOST_WIDE_INT length = -1;\n+  bool is_ncmp = false;\n+\n+  if (!res)\n+    return false;\n+\n+  /* When both arguments are unknown, do nothing.  */\n+  if (idx1 == 0 && idx2 == 0)\n+    return false;\n+\n+  /* Handle strncmp function.  */\n+  if (gimple_call_num_args (stmt) == 3)\n+    {\n+      tree len = gimple_call_arg (stmt, 2);\n+      if (tree_fits_shwi_p (len))\n+        length = tree_to_shwi (len);\n+\n+      is_ncmp = true;\n+    }\n+\n+  /* For strncmp, if the length argument is NOT known, do nothing.  */\n+  if (is_ncmp && length < 0)\n+    return false;\n+\n+  /* When the result is ONLY used to do equality test against zero.  */\n+  FOR_EACH_IMM_USE_FAST (use_p, iter, res) \n+    {    \n+      gimple *use_stmt = USE_STMT (use_p);\n+\n+      if (is_gimple_debug (use_stmt))\n+        continue;\n+      if (gimple_code (use_stmt) == GIMPLE_ASSIGN)\n+\t{    \n+\t  tree_code code = gimple_assign_rhs_code (use_stmt);\n+\t  if (code == COND_EXPR) \n+\t    {\n+\t      tree cond_expr = gimple_assign_rhs1 (use_stmt);\n+\t      if ((TREE_CODE (cond_expr) != EQ_EXPR \n+\t\t   && (TREE_CODE (cond_expr) != NE_EXPR))\n+\t\t  || !integer_zerop (TREE_OPERAND (cond_expr, 1)))\n+\t\treturn false;\n+\t    }\n+\t  else if (code == EQ_EXPR || code == NE_EXPR)\n+\t    {\n+\t      if (!integer_zerop (gimple_assign_rhs2 (use_stmt)))\n+\t\treturn false;\n+            }\n+\t  else \n+\t    return false;\n+\t}\n+      else if (gimple_code (use_stmt) == GIMPLE_COND)\n+\t{\n+\t  tree_code code = gimple_cond_code (use_stmt);\n+\t  if ((code != EQ_EXPR && code != NE_EXPR)\n+\t      || !integer_zerop (gimple_cond_rhs (use_stmt)))\n+\t    return false;\n+\t}\n+      else\n+        return false;\n+    }\n+  \n+  /* When the lengths of both arguments are known, and they are unequal, we can \n+     safely fold the call to a non-zero value for strcmp;\n+     othewise, do nothing now.  */\n+  if (idx1 != 0 && idx2 != 0)\n+    {\n+      HOST_WIDE_INT const_string_leni1 = compute_string_length (idx1);\n+      HOST_WIDE_INT const_string_leni2 = compute_string_length (idx2);\n+\n+      if (!is_ncmp \n+\t  && const_string_leni1 != -1\n+\t  && const_string_leni2 != -1\n+\t  && const_string_leni1 != const_string_leni2) \n+\t{\n+\t  replace_call_with_value (gsi, integer_one_node); \n+\t  return true;\n+\t}\n+      return false;\n+    }\n+\n+  /* When the length of one argument is constant.  */\n+  tree var_string = NULL_TREE;\n+  HOST_WIDE_INT const_string_leni = -1;\n+  \n+  if (idx1)\n+    {\n+      const_string_leni = compute_string_length (idx1);\n+      var_string = arg2;\n+    } \n+  else \n+    {\n+      gcc_checking_assert (idx2);\n+      const_string_leni = compute_string_length (idx2);\n+      var_string = arg1;\n+    } \n+\n+  if (const_string_leni < 0) \n+    return false;\n+ \n+  unsigned HOST_WIDE_INT var_sizei = 0;\n+  /* try to determine the minimum size of the object pointed by var_string.  */\n+  tree size = determine_min_objsize (var_string);\n+\n+  if (!size)\n+    return false;\n+ \n+  if (tree_fits_uhwi_p (size))\n+    var_sizei = tree_to_uhwi (size);\n+\n+  if (var_sizei == 0)\n+    return false;\n+\n+  /* For strncmp, if length > const_string_leni , this call can be safely \n+     transformed to a strcmp.  */\n+  if (is_ncmp && length > const_string_leni)\n+    is_ncmp = false;\n+\n+  unsigned HOST_WIDE_INT final_length \n+    = is_ncmp ? length : const_string_leni + 1;\n+\n+  /* Replace strcmp or strncmp with the corresponding str(n)cmp_eq.  */\n+  if (var_sizei > final_length) \n+    {\n+      tree fn \n+\t= (is_ncmp \n+\t   ? builtin_decl_implicit (BUILT_IN_STRNCMP_EQ) \n+\t   : builtin_decl_implicit (BUILT_IN_STRCMP_EQ));\n+      if (!fn)\n+\treturn false;\n+      tree const_string_len = build_int_cst (size_type_node, final_length); \n+      update_gimple_call (gsi, fn, 3, arg1, arg2, const_string_len);\n+    }\n+  else \n+    return false;\n+\n+  return true;\n }\n \n /* Handle a POINTER_PLUS_EXPR statement.\n@@ -3209,11 +3474,16 @@ strlen_check_and_optimize_stmt (gimple_stmt_iterator *gsi, bool *cleanup_eh)\n \t    handle_builtin_malloc (DECL_FUNCTION_CODE (callee), gsi);\n \t    break;\n \t  case BUILT_IN_MEMSET:\n-\t    if (!handle_builtin_memset (gsi))\n+\t    if (handle_builtin_memset (gsi))\n \t      return false;\n \t    break;\n \t  case BUILT_IN_MEMCMP:\n-\t    if (!handle_builtin_memcmp (gsi))\n+\t    if (handle_builtin_memcmp (gsi))\n+\t      return false;\n+\t    break;\n+\t  case BUILT_IN_STRCMP:\n+\t  case BUILT_IN_STRNCMP:\n+\t    if (handle_builtin_string_cmp (gsi))\n \t      return false;\n \t    break;\n \t  default:"}, {"sha": "14ab83a9469d6c4378fed54ede3771779bd0c6dd", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -4498,7 +4498,9 @@ find_func_aliases_for_builtin_call (struct function *fn, gcall *t)\n          that use the memory pointed to by their arguments (but not\n \t transitively).  */\n       case BUILT_IN_STRCMP:\n+      case BUILT_IN_STRCMP_EQ:\n       case BUILT_IN_STRNCMP:\n+      case BUILT_IN_STRNCMP_EQ:\n       case BUILT_IN_STRCASECMP:\n       case BUILT_IN_STRNCASECMP:\n       case BUILT_IN_MEMCMP:"}, {"sha": "85ce99373db9044a0843e394de01520ee50ecea3", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8b0b334af3439179947522206b2478a28b908e61/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=8b0b334af3439179947522206b2478a28b908e61", "patch": "@@ -10277,6 +10277,14 @@ build_common_builtin_nodes (void)\n \t\t\t\"__builtin_memcmp_eq\",\n \t\t\tECF_PURE | ECF_NOTHROW | ECF_LEAF);\n \n+  local_define_builtin (\"__builtin_strncmp_eq\", ftype, BUILT_IN_STRNCMP_EQ,\n+\t\t\t\"__builtin_strncmp_eq\",\n+\t\t\tECF_PURE | ECF_NOTHROW | ECF_LEAF);\n+\n+  local_define_builtin (\"__builtin_strcmp_eq\", ftype, BUILT_IN_STRCMP_EQ,\n+\t\t\t\"__builtin_strcmp_eq\",\n+\t\t\tECF_PURE | ECF_NOTHROW | ECF_LEAF);\n+\n   /* If there's a possibility that we might use the ARM EABI, build the\n     alternate __cxa_end_cleanup node used to resume from C++.  */\n   if (targetm.arm_eabi_unwinder)"}]}