{"sha": "03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDNkYjlhYjU5NDgxZTA3ZGUwZjhiNjUxZTZjYzVjMGY3ZDI2YjMzMA==", "commit": {"author": {"name": "Dominik Vogt", "email": "vogt@linux.vnet.ibm.com", "date": "2017-04-25T07:37:50Z"}, "committer": {"name": "Andreas Krebbel", "email": "krebbel@gcc.gnu.org", "date": "2017-04-25T07:37:50Z"}, "message": "S/390: PR80080: Optimize atomic patterns.\n\nThe attached patch optimizes the atomic_exchange and atomic_compare\npatterns on s390 and s390x (mostly limited to SImode and DImode).\nAmong general optimizaation, the changes fix most of the problems\nreported in PR 80080:\nhttps://gcc.gnu.org/bugzilla/show_bug.cgi?id=80080\n\ngcc/ChangeLog:\n\n2017-04-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\tPR target/80080\n\t* s390-protos.h (s390_expand_cs_hqi): Removed.\n\t(s390_expand_cs, s390_expand_atomic_exchange_tdsi): New prototypes.\n\t* config/s390/s390.c (s390_emit_compare_and_swap): Handle all integer\n\tmodes as well as CCZ1mode and CCZmode.\n\t(s390_expand_atomic_exchange_tdsi, s390_expand_atomic): Adapt to new\n\tsignature of s390_emit_compare_and_swap.\n\t(s390_expand_cs_hqi): Likewise, make static.\n\t(s390_expand_cs_tdsi): Generate an explicit compare before trying\n\tcompare-and-swap, in some cases.\n\t(s390_expand_cs): Wrapper function.\n\t(s390_expand_atomic_exchange_tdsi): New backend specific expander for\n\tatomic_exchange.\n\t(s390_match_ccmode_set): Allow CCZmode <-> CCZ1 mode.\n\t* config/s390/s390.md (\"atomic_compare_and_swap<mode>\"): Merge the\n\tpatterns for small and large integers.  Forbid symref memory operands.\n\tMove expander to s390.c.  Require cc register.\n\t(\"atomic_compare_and_swap<DGPR:mode><CCZZ1:mode>_internal\")\n\t(\"*atomic_compare_and_swap<TDI:mode><CCZZ1:mode>_1\")\n\t(\"*atomic_compare_and_swapdi<CCZZ1:mode>_2\")\n\t(\"*atomic_compare_and_swapsi<CCZZ1:mode>_3\"): Use s_operand to forbid\n\tsymref memory operands.  Remove CC mode and call s390_match_ccmode\n\tinstead.\n\t(\"atomic_exchange<mode>\"): Allow and implement all integer modes.\n\ngcc/testsuite/ChangeLog:\n\n2017-04-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n\n\tPR target/80080\n\t* gcc.target/s390/md/atomic_compare_exchange-1.c: New test.\n\t* gcc.target/s390/md/atomic_compare_exchange-1.inc: New test.\n\t* gcc.target/s390/md/atomic_exchange-1.inc: New test.\n\nFrom-SVN: r247132", "tree": {"sha": "28e95dc2ae7b20ece9816a634395a3f623677a51", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28e95dc2ae7b20ece9816a634395a3f623677a51"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "html_url": "https://github.com/Rust-GCC/gccrs/commit/03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/comments", "author": {"login": "vogtd", "id": 9690100, "node_id": "MDQ6VXNlcjk2OTAxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/9690100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vogtd", "html_url": "https://github.com/vogtd", "followers_url": "https://api.github.com/users/vogtd/followers", "following_url": "https://api.github.com/users/vogtd/following{/other_user}", "gists_url": "https://api.github.com/users/vogtd/gists{/gist_id}", "starred_url": "https://api.github.com/users/vogtd/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vogtd/subscriptions", "organizations_url": "https://api.github.com/users/vogtd/orgs", "repos_url": "https://api.github.com/users/vogtd/repos", "events_url": "https://api.github.com/users/vogtd/events{/privacy}", "received_events_url": "https://api.github.com/users/vogtd/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "97160c9b3b6e524efd7ee4e12dfcd82519d27246", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97160c9b3b6e524efd7ee4e12dfcd82519d27246", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97160c9b3b6e524efd7ee4e12dfcd82519d27246"}], "stats": {"total": 1061, "additions": 988, "deletions": 73}, "files": [{"sha": "c70d790dc5e48cfa2e628093ab8a98a58d0a0348", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -1,3 +1,30 @@\n+2017-04-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\tPR target/80080\n+\t* s390-protos.h (s390_expand_cs_hqi): Removed.\n+\t(s390_expand_cs, s390_expand_atomic_exchange_tdsi): New prototypes.\n+\t* config/s390/s390.c (s390_emit_compare_and_swap): Handle all integer\n+\tmodes as well as CCZ1mode and CCZmode.\n+\t(s390_expand_atomic_exchange_tdsi, s390_expand_atomic): Adapt to new\n+\tsignature of s390_emit_compare_and_swap.\n+\t(s390_expand_cs_hqi): Likewise, make static.\n+\t(s390_expand_cs_tdsi): Generate an explicit compare before trying\n+\tcompare-and-swap, in some cases.\n+\t(s390_expand_cs): Wrapper function.\n+\t(s390_expand_atomic_exchange_tdsi): New backend specific expander for\n+\tatomic_exchange.\n+\t(s390_match_ccmode_set): Allow CCZmode <-> CCZ1 mode.\n+\t* config/s390/s390.md (\"atomic_compare_and_swap<mode>\"): Merge the\n+\tpatterns for small and large integers.  Forbid symref memory operands.\n+\tMove expander to s390.c.  Require cc register.\n+\t(\"atomic_compare_and_swap<DGPR:mode><CCZZ1:mode>_internal\")\n+\t(\"*atomic_compare_and_swap<TDI:mode><CCZZ1:mode>_1\")\n+\t(\"*atomic_compare_and_swapdi<CCZZ1:mode>_2\")\n+\t(\"*atomic_compare_and_swapsi<CCZZ1:mode>_3\"): Use s_operand to forbid\n+\tsymref memory operands.  Remove CC mode and call s390_match_ccmode\n+\tinstead.\n+\t(\"atomic_exchange<mode>\"): Allow and implement all integer modes.\n+\n 2017-04-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n \n \t* config/s390/s390.md (define_peephole2): New peephole to help"}, {"sha": "3fdb32059cd91c36520c42fb10955fef3615a99b", "filename": "gcc/config/s390/s390-protos.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390-protos.h?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -112,8 +112,8 @@ extern void s390_expand_vec_strlen (rtx, rtx, rtx);\n extern void s390_expand_vec_movstr (rtx, rtx, rtx);\n extern bool s390_expand_addcc (enum rtx_code, rtx, rtx, rtx, rtx, rtx);\n extern bool s390_expand_insv (rtx, rtx, rtx, rtx);\n-extern void s390_expand_cs_hqi (machine_mode, rtx, rtx, rtx,\n-\t\t\t\trtx, rtx, bool);\n+extern void s390_expand_cs (machine_mode, rtx, rtx, rtx, rtx, rtx, bool);\n+extern void s390_expand_atomic_exchange_tdsi (rtx, rtx, rtx);\n extern void s390_expand_atomic (machine_mode, enum rtx_code,\n \t\t\t\trtx, rtx, rtx, bool);\n extern void s390_expand_tbegin (rtx, rtx, rtx, bool);"}, {"sha": "c16391aa8d51dbacf7a738c323012fad3657ea84", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 176, "deletions": 8, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -1306,6 +1306,7 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n   set_mode = GET_MODE (SET_DEST (set));\n   switch (set_mode)\n     {\n+    case CCZ1mode:\n     case CCSmode:\n     case CCSRmode:\n     case CCUmode:\n@@ -1328,7 +1329,8 @@ s390_match_ccmode_set (rtx set, machine_mode req_mode)\n \n     case CCZmode:\n       if (req_mode != CCSmode && req_mode != CCUmode && req_mode != CCTmode\n-\t  && req_mode != CCSRmode && req_mode != CCURmode)\n+\t  && req_mode != CCSRmode && req_mode != CCURmode\n+\t  && req_mode != CCZ1mode)\n         return 0;\n       break;\n \n@@ -1762,11 +1764,31 @@ s390_emit_compare (enum rtx_code code, rtx op0, rtx op1)\n \n static rtx\n s390_emit_compare_and_swap (enum rtx_code code, rtx old, rtx mem,\n-\t\t\t    rtx cmp, rtx new_rtx)\n+\t\t\t    rtx cmp, rtx new_rtx, machine_mode ccmode)\n {\n-  emit_insn (gen_atomic_compare_and_swapsi_internal (old, mem, cmp, new_rtx));\n-  return s390_emit_compare (code, gen_rtx_REG (CCZ1mode, CC_REGNUM),\n-\t\t\t    const0_rtx);\n+  rtx cc;\n+\n+  cc = gen_rtx_REG (ccmode, CC_REGNUM);\n+  switch (GET_MODE (mem))\n+    {\n+    case SImode:\n+      emit_insn (gen_atomic_compare_and_swapsi_internal (old, mem, cmp,\n+\t\t\t\t\t\t\t new_rtx, cc));\n+      break;\n+    case DImode:\n+      emit_insn (gen_atomic_compare_and_swapdi_internal (old, mem, cmp,\n+\t\t\t\t\t\t\t new_rtx, cc));\n+      break;\n+    case TImode:\n+\temit_insn (gen_atomic_compare_and_swapti_internal (old, mem, cmp,\n+\t\t\t\t\t\t\t   new_rtx, cc));\n+      break;\n+    case QImode:\n+    case HImode:\n+    default:\n+      gcc_unreachable ();\n+    }\n+  return s390_emit_compare (code, cc, const0_rtx);\n }\n \n /* Emit a jump instruction to TARGET and return it.  If COND is\n@@ -6723,7 +6745,7 @@ s390_two_part_insv (struct alignment_context *ac, rtx *seq1, rtx *seq2,\n    the memory location, CMP the old value to compare MEM with and NEW_RTX the\n    value to set if CMP == MEM.  */\n \n-void\n+static void\n s390_expand_cs_hqi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n \t\t    rtx cmp, rtx new_rtx, bool is_weak)\n {\n@@ -6770,7 +6792,7 @@ s390_expand_cs_hqi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n   emit_insn (seq2);\n   emit_insn (seq3);\n \n-  cc = s390_emit_compare_and_swap (EQ, res, ac.memsi, cmpv, newv);\n+  cc = s390_emit_compare_and_swap (EQ, res, ac.memsi, cmpv, newv, CCZ1mode);\n   if (is_weak)\n     emit_insn (gen_cstorecc4 (btarget, cc, XEXP (cc, 0), XEXP (cc, 1)));\n   else\n@@ -6799,6 +6821,151 @@ s390_expand_cs_hqi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n \t\t\t\t\t      NULL_RTX, 1, OPTAB_DIRECT), 1);\n }\n \n+/* Variant of s390_expand_cs for SI, DI and TI modes.  */\n+static void\n+s390_expand_cs_tdsi (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n+\t\t     rtx cmp, rtx new_rtx, bool is_weak)\n+{\n+  rtx output = vtarget;\n+  rtx_code_label *skip_cs_label = NULL;\n+  bool do_const_opt = false;\n+\n+  if (!register_operand (output, mode))\n+    output = gen_reg_rtx (mode);\n+\n+  /* If IS_WEAK is true and the INPUT value is a constant, compare the memory\n+     with the constant first and skip the compare_and_swap because its very\n+     expensive and likely to fail anyway.\n+     Note 1: This is done only for IS_WEAK.  C11 allows optimizations that may\n+     cause spurious in that case.\n+     Note 2: It may be useful to do this also for non-constant INPUT.\n+     Note 3: Currently only targets with \"load on condition\" are supported\n+     (z196 and newer).  */\n+\n+  if (TARGET_Z196\n+      && (mode == SImode || mode == DImode))\n+    do_const_opt = (is_weak && CONST_INT_P (cmp));\n+\n+  if (do_const_opt)\n+    {\n+      const int very_unlikely = REG_BR_PROB_BASE / 100 - 1;\n+      rtx cc = gen_rtx_REG (CCZmode, CC_REGNUM);\n+\n+      skip_cs_label = gen_label_rtx ();\n+      emit_move_insn (btarget, const0_rtx);\n+      if (CONST_INT_P (cmp) && INTVAL (cmp) == 0)\n+\t{\n+\t  rtvec lt = rtvec_alloc (2);\n+\n+\t  /* Load-and-test + conditional jump.  */\n+\t  RTVEC_ELT (lt, 0)\n+\t    = gen_rtx_SET (cc, gen_rtx_COMPARE (CCZmode, mem, cmp));\n+\t  RTVEC_ELT (lt, 1) = gen_rtx_SET (output, mem);\n+\t  emit_insn (gen_rtx_PARALLEL (VOIDmode, lt));\n+\t}\n+      else\n+\t{\n+\t  emit_move_insn (output, mem);\n+\t  emit_insn (gen_rtx_SET (cc, gen_rtx_COMPARE (CCZmode, output, cmp)));\n+\t}\n+      s390_emit_jump (skip_cs_label, gen_rtx_NE (VOIDmode, cc, const0_rtx));\n+      add_int_reg_note (get_last_insn (), REG_BR_PROB, very_unlikely);\n+      /* If the jump is not taken, OUTPUT is the expected value.  */\n+      cmp = output;\n+      /* Reload newval to a register manually, *after* the compare and jump\n+\t above.  Otherwise Reload might place it before the jump.  */\n+    }\n+  else\n+    cmp = force_reg (mode, cmp);\n+  new_rtx = force_reg (mode, new_rtx);\n+  s390_emit_compare_and_swap (EQ, output, mem, cmp, new_rtx,\n+\t\t\t      (do_const_opt) ? CCZmode : CCZ1mode);\n+  if (skip_cs_label != NULL)\n+    emit_label (skip_cs_label);\n+\n+  /* We deliberately accept non-register operands in the predicate\n+     to ensure the write back to the output operand happens *before*\n+     the store-flags code below.  This makes it easier for combine\n+     to merge the store-flags code with a potential test-and-branch\n+     pattern following (immediately!) afterwards.  */\n+  if (output != vtarget)\n+    emit_move_insn (vtarget, output);\n+\n+  if (do_const_opt)\n+    {\n+      rtx cc, cond, ite;\n+\n+      /* Do not use gen_cstorecc4 here because it writes either 1 or 0, but\n+\t btarget has already been initialized with 0 above.  */\n+      cc = gen_rtx_REG (CCZmode, CC_REGNUM);\n+      cond = gen_rtx_EQ (VOIDmode, cc, const0_rtx);\n+      ite = gen_rtx_IF_THEN_ELSE (SImode, cond, const1_rtx, btarget);\n+      emit_insn (gen_rtx_SET (btarget, ite));\n+    }\n+  else\n+    {\n+      rtx cc, cond;\n+\n+      cc = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n+      cond = gen_rtx_EQ (SImode, cc, const0_rtx);\n+      emit_insn (gen_cstorecc4 (btarget, cond, cc, const0_rtx));\n+    }\n+}\n+\n+/* Expand an atomic compare and swap operation.  MEM is the memory location,\n+   CMP the old value to compare MEM with and NEW_RTX the value to set if\n+   CMP == MEM.  */\n+\n+void\n+s390_expand_cs (machine_mode mode, rtx btarget, rtx vtarget, rtx mem,\n+\t\trtx cmp, rtx new_rtx, bool is_weak)\n+{\n+  switch (mode)\n+    {\n+    case TImode:\n+    case DImode:\n+    case SImode:\n+      s390_expand_cs_tdsi (mode, btarget, vtarget, mem, cmp, new_rtx, is_weak);\n+      break;\n+    case HImode:\n+    case QImode:\n+      s390_expand_cs_hqi (mode, btarget, vtarget, mem, cmp, new_rtx, is_weak);\n+      break;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Expand an atomic_exchange operation simulated with a compare-and-swap loop.\n+   The memory location MEM is set to INPUT.  OUTPUT is set to the previous value\n+   of MEM.  */\n+\n+void\n+s390_expand_atomic_exchange_tdsi (rtx output, rtx mem, rtx input)\n+{\n+  machine_mode mode = GET_MODE (mem);\n+  rtx_code_label *csloop;\n+\n+  if (TARGET_Z196\n+      && (mode == DImode || mode == SImode)\n+      && CONST_INT_P (input) && INTVAL (input) == 0)\n+    {\n+      emit_move_insn (output, const0_rtx);\n+      if (mode == DImode)\n+\temit_insn (gen_atomic_fetch_anddi (output, mem, const0_rtx, input));\n+      else\n+\temit_insn (gen_atomic_fetch_andsi (output, mem, const0_rtx, input));\n+      return;\n+    }\n+\n+  input = force_reg (mode, input);\n+  emit_move_insn (output, mem);\n+  csloop = gen_label_rtx ();\n+  emit_label (csloop);\n+  s390_emit_jump (csloop, s390_emit_compare_and_swap (NE, output, mem, output,\n+\t\t\t\t\t\t      input, CCZ1mode));\n+}\n+\n /* Expand an atomic operation CODE of mode MODE.  MEM is the memory location\n    and VAL the value to play with.  If AFTER is true then store the value\n    MEM holds after the operation, if AFTER is false then store the value MEM\n@@ -6878,7 +7045,8 @@ s390_expand_atomic (machine_mode mode, enum rtx_code code,\n     }\n \n   s390_emit_jump (csloop, s390_emit_compare_and_swap (NE, cmp,\n-\t\t\t\t\t\t      ac.memsi, cmp, new_rtx));\n+\t\t\t\t\t\t      ac.memsi, cmp, new_rtx,\n+\t\t\t\t\t\t      CCZ1mode));\n \n   /* Return the correct part of the bitfield.  */\n   if (target)"}, {"sha": "8a700edab94a030b0f27405a7d0ff11839d0a279", "filename": "gcc/config/s390/s390.md", "status": "modified", "additions": 47, "deletions": 63, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Fconfig%2Fs390%2Fs390.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.md?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -10230,100 +10230,74 @@\n \n (define_expand \"atomic_compare_and_swap<mode>\"\n   [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n-   (match_operand:DGPR 1 \"nonimmediate_operand\");; oldval output\n-   (match_operand:DGPR 2 \"memory_operand\")\t;; memory\n-   (match_operand:DGPR 3 \"register_operand\")\t;; expected intput\n-   (match_operand:DGPR 4 \"register_operand\")\t;; newval intput\n+   (match_operand:DINT 1 \"nonimmediate_operand\");; oldval output\n+   (match_operand:DINT 2 \"s_operand\")\t\t;; memory\n+   (match_operand:DINT 3 \"general_operand\")\t;; expected intput\n+   (match_operand:DINT 4 \"general_operand\")\t;; newval intput\n    (match_operand:SI 5 \"const_int_operand\")\t;; is_weak\n    (match_operand:SI 6 \"const_int_operand\")\t;; success model\n    (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n   \"\"\n {\n-  rtx cc, cmp, output = operands[1];\n-\n-  if (!register_operand (output, <MODE>mode))\n-    output = gen_reg_rtx (<MODE>mode);\n-\n-  if (MEM_ALIGN (operands[2]) < GET_MODE_BITSIZE (GET_MODE (operands[2])))\n+  if (GET_MODE_BITSIZE (<MODE>mode) >= 16\n+      && GET_MODE_BITSIZE (<MODE>mode) > MEM_ALIGN (operands[2]))\n     FAIL;\n \n-  emit_insn (gen_atomic_compare_and_swap<mode>_internal\n-\t     (output, operands[2], operands[3], operands[4]));\n-\n-  /* We deliberately accept non-register operands in the predicate\n-     to ensure the write back to the output operand happens *before*\n-     the store-flags code below.  This makes it easier for combine\n-     to merge the store-flags code with a potential test-and-branch\n-     pattern following (immediately!) afterwards.  */\n-  if (output != operands[1])\n-    emit_move_insn (operands[1], output);\n-\n-  cc = gen_rtx_REG (CCZ1mode, CC_REGNUM);\n-  cmp = gen_rtx_EQ (SImode, cc, const0_rtx);\n-  emit_insn (gen_cstorecc4 (operands[0], cmp, cc, const0_rtx));\n-  DONE;\n-})\n-\n-(define_expand \"atomic_compare_and_swap<mode>\"\n-  [(match_operand:SI 0 \"register_operand\")\t;; bool success output\n-   (match_operand:HQI 1 \"nonimmediate_operand\")\t;; oldval output\n-   (match_operand:HQI 2 \"memory_operand\")\t;; memory\n-   (match_operand:HQI 3 \"general_operand\")\t;; expected intput\n-   (match_operand:HQI 4 \"general_operand\")\t;; newval intput\n-   (match_operand:SI 5 \"const_int_operand\")\t;; is_weak\n-   (match_operand:SI 6 \"const_int_operand\")\t;; success model\n-   (match_operand:SI 7 \"const_int_operand\")]\t;; failure model\n-  \"\"\n-{\n-  s390_expand_cs_hqi (<MODE>mode, operands[0], operands[1], operands[2],\n-\t\t      operands[3], operands[4], INTVAL (operands[5]));\n-  DONE;\n-})\n+  s390_expand_cs (<MODE>mode, operands[0], operands[1], operands[2],\n+\t\t  operands[3], operands[4], INTVAL (operands[5]));\n+  DONE;})\n \n (define_expand \"atomic_compare_and_swap<mode>_internal\"\n   [(parallel\n      [(set (match_operand:DGPR 0 \"register_operand\")\n-\t   (match_operand:DGPR 1 \"memory_operand\"))\n+\t   (match_operand:DGPR 1 \"s_operand\"))\n       (set (match_dup 1)\n \t   (unspec_volatile:DGPR\n \t     [(match_dup 1)\n \t      (match_operand:DGPR 2 \"register_operand\")\n \t      (match_operand:DGPR 3 \"register_operand\")]\n \t     UNSPECV_CAS))\n-      (set (reg:CCZ1 CC_REGNUM)\n-\t   (compare:CCZ1 (match_dup 1) (match_dup 2)))])]\n-  \"\")\n+      (set (match_operand 4 \"cc_reg_operand\")\n+\t   (match_dup 5))])]\n+  \"GET_MODE (operands[4]) == CCZmode\n+   || GET_MODE (operands[4]) == CCZ1mode\"\n+{\n+  operands[5]\n+    = gen_rtx_COMPARE (GET_MODE (operands[4]), operands[1], operands[2]);\n+})\n \n ; cdsg, csg\n (define_insn \"*atomic_compare_and_swap<mode>_1\"\n   [(set (match_operand:TDI 0 \"register_operand\" \"=r\")\n-\t(match_operand:TDI 1 \"memory_operand\" \"+S\"))\n+\t(match_operand:TDI 1 \"s_operand\" \"+S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:TDI\n \t  [(match_dup 1)\n \t   (match_operand:TDI 2 \"register_operand\" \"0\")\n \t   (match_operand:TDI 3 \"register_operand\" \"r\")]\n \t  UNSPECV_CAS))\n-   (set (reg:CCZ1 CC_REGNUM)\n-\t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n-  \"TARGET_ZARCH\"\n+   (set (reg CC_REGNUM)\n+\t(compare (match_dup 1) (match_dup 2)))]\n+  \"TARGET_ZARCH\n+   && s390_match_ccmode (insn, CCZ1mode)\"\n   \"c<td>sg\\t%0,%3,%S1\"\n   [(set_attr \"op_type\" \"RSY\")\n    (set_attr \"type\"   \"sem\")])\n \n ; cds, cdsy\n (define_insn \"*atomic_compare_and_swapdi_2\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:DI 1 \"memory_operand\" \"+Q,S\"))\n+\t(match_operand:DI 1 \"s_operand\" \"+Q,S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:DI\n \t  [(match_dup 1)\n \t   (match_operand:DI 2 \"register_operand\" \"0,0\")\n \t   (match_operand:DI 3 \"register_operand\" \"r,r\")]\n \t  UNSPECV_CAS))\n-   (set (reg:CCZ1 CC_REGNUM)\n-\t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n-  \"!TARGET_ZARCH\"\n+   (set (reg CC_REGNUM)\n+\t(compare (match_dup 1) (match_dup 2)))]\n+  \"!TARGET_ZARCH\n+   && s390_match_ccmode (insn, CCZ1mode)\"\n   \"@\n    cds\\t%0,%3,%S1\n    cdsy\\t%0,%3,%S1\"\n@@ -10334,16 +10308,16 @@\n ; cs, csy\n (define_insn \"*atomic_compare_and_swapsi_3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,r\")\n-\t(match_operand:SI 1 \"memory_operand\" \"+Q,S\"))\n+\t(match_operand:SI 1 \"s_operand\" \"+Q,S\"))\n    (set (match_dup 1)\n \t(unspec_volatile:SI\n \t  [(match_dup 1)\n \t   (match_operand:SI 2 \"register_operand\" \"0,0\")\n \t   (match_operand:SI 3 \"register_operand\" \"r,r\")]\n \t  UNSPECV_CAS))\n-   (set (reg:CCZ1 CC_REGNUM)\n-\t(compare:CCZ1 (match_dup 1) (match_dup 2)))]\n-  \"\"\n+   (set (reg CC_REGNUM)\n+\t(compare (match_dup 1) (match_dup 2)))]\n+  \"s390_match_ccmode (insn, CCZ1mode)\"\n   \"@\n    cs\\t%0,%3,%S1\n    csy\\t%0,%3,%S1\"\n@@ -10430,15 +10404,25 @@\n   DONE;\n })\n \n+;; Pattern to implement atomic_exchange with a compare-and-swap loop.  The code\n+;; generated by the middleend is not good.\n (define_expand \"atomic_exchange<mode>\"\n-  [(match_operand:HQI 0 \"register_operand\")\t\t;; val out\n-   (match_operand:HQI 1 \"memory_operand\")\t\t;; memory\n-   (match_operand:HQI 2 \"general_operand\")\t\t;; val in\n+  [(match_operand:DINT 0 \"register_operand\")\t\t;; val out\n+   (match_operand:DINT 1 \"s_operand\")\t\t\t;; memory\n+   (match_operand:DINT 2 \"general_operand\")\t\t;; val in\n    (match_operand:SI 3 \"const_int_operand\")]\t\t;; model\n   \"\"\n {\n-  s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1],\n-\t\t      operands[2], false);\n+  if (<MODE>mode != QImode\n+      && MEM_ALIGN (operands[1]) < GET_MODE_BITSIZE (<MODE>mode))\n+    FAIL;\n+  if (<MODE>mode == HImode || <MODE>mode == QImode)\n+    s390_expand_atomic (<MODE>mode, SET, operands[0], operands[1], operands[2],\n+\t\t\tfalse);\n+  else if (<MODE>mode == SImode || TARGET_ZARCH)\n+    s390_expand_atomic_exchange_tdsi (operands[0], operands[1], operands[2]);\n+  else\n+    FAIL;\n   DONE;\n })\n "}, {"sha": "e4a9f0ed7240cd6703a4de64f0f5e6766ff0c0cd", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -1,3 +1,10 @@\n+2017-04-25  Dominik Vogt  <vogt@linux.vnet.ibm.com>\n+\n+\tPR target/80080\n+\t* gcc.target/s390/md/atomic_compare_exchange-1.c: New test.\n+\t* gcc.target/s390/md/atomic_compare_exchange-1.inc: New test.\n+\t* gcc.target/s390/md/atomic_exchange-1.inc: New test.\n+\n 2017-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/80501"}, {"sha": "5cc026da9dbba37c4da1e924803e0efc20704bc4", "filename": "gcc/testsuite/gcc.target/s390/md/atomic_compare_exchange-1.c", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.c?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -0,0 +1,84 @@\n+/* Machine description pattern tests.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+/* { dg-do run { target { s390_useable_hw } } } */\n+\n+#include <stdio.h>\n+\n+struct\n+{\n+#ifdef __s390xx__\n+  __int128 dummy128;\n+  __int128 mem128;\n+#endif\n+  long long dummy64;\n+  long long mem64;\n+  int dummy32;\n+  int mem32;\n+  short mem16l;\n+  short mem16h;\n+  char mem8ll;\n+  char mem8lh;\n+  char mem8hl;\n+  char mem8hh;\n+} mem_s;\n+\n+#define TYPE char\n+#define FN(SUFFIX) f8 ## SUFFIX\n+#define FNS(SUFFIX) \"f8\" #SUFFIX\n+#include \"atomic_compare_exchange-1.inc\"\n+\n+#define TYPE short\n+#define FN(SUFFIX) f16 ##SUFFIX\n+#define FNS(SUFFIX) \"f16\" #SUFFIX\n+#include \"atomic_compare_exchange-1.inc\"\n+\n+#define TYPE int\n+#define FN(SUFFIX) f32 ## SUFFIX\n+#define FNS(SUFFIX) \"f32\" #SUFFIX\n+#include \"atomic_compare_exchange-1.inc\"\n+\n+#define TYPE long long\n+#define FN(SUFFIX) f64 ## SUFFIX\n+#define FNS(SUFFIX) \"f64\" #SUFFIX\n+#include \"atomic_compare_exchange-1.inc\"\n+\n+#ifdef __s390xx__\n+#define TYPE __int128\n+#define FN(SUFFIX) f128 ## SUFFIX\n+#define FNS(SUFFIX) \"f128\" #SUFFIX\n+#include \"atomic_compare_exchange-1.inc\"\n+#endif\n+\n+int main(void)\n+{\n+  int err_count = 0;\n+  int i;\n+\n+  for (i = -1; i <= 2; i++)\n+    {\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f8_validate(&mem_s.mem8ll, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f8_validate(&mem_s.mem8lh, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f8_validate(&mem_s.mem8hl, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f8_validate(&mem_s.mem8hh, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f16_validate(&mem_s.mem16l, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f16_validate(&mem_s.mem16h, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f32_validate(&mem_s.mem32, i, 1);\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f64_validate(&mem_s.mem64, i, 1);\n+#ifdef __s390xx__\n+      __builtin_memset(&mem_s, 0x99, sizeof(mem_s));\n+      err_count += f128_validate(&mem_s.mem128, i, 1);\n+#endif\n+    }\n+\n+  return err_count;\n+}"}, {"sha": "199aaa3a16252aea839fbabcf768961d4c288060", "filename": "gcc/testsuite/gcc.target/s390/md/atomic_compare_exchange-1.inc", "status": "added", "additions": 336, "deletions": 0, "changes": 336, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_compare_exchange-1.inc?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -0,0 +1,336 @@\n+/* -*-c-*- */\n+\n+#undef NEW\n+#define NEW 3\n+\n+__attribute__ ((noinline))\n+int FN(_bo)(TYPE *mem, TYPE *old_ret, TYPE old)\n+{\n+  *old_ret = old;\n+  return __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN(_o)(TYPE *mem, TYPE *old_ret, TYPE old)\n+{\n+  *old_ret = old;\n+  __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+__attribute__ ((noinline))\n+int FN(_b)(TYPE *mem, TYPE old)\n+{\n+  return __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN()(TYPE *mem, TYPE old)\n+{\n+  __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+/* Const != 0 old value.  */\n+__attribute__ ((noinline))\n+int FN(_c1_bo)(TYPE *mem, TYPE *old_ret)\n+{\n+  *old_ret = 1;\n+  return __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN(_c1_o)(TYPE *mem, TYPE *old_ret)\n+{\n+  *old_ret = 1;\n+  __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+__attribute__ ((noinline))\n+int FN(_c1_b)(TYPE *mem)\n+{\n+  TYPE old = 1;\n+  return __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN(_c1)(TYPE *mem)\n+{\n+  TYPE old = 1;\n+  __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+/* Const == 0 old value.  */\n+__attribute__ ((noinline))\n+int FN(_c0_bo)(TYPE *mem, TYPE *old_ret)\n+{\n+  *old_ret = 0;\n+  return __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN(_c0_o)(TYPE *mem, TYPE *old_ret)\n+{\n+  *old_ret = 0;\n+  __atomic_compare_exchange_n (mem, (void *)old_ret, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+__attribute__ ((noinline))\n+int FN(_c0_b)(TYPE *mem)\n+{\n+  TYPE old = 0;\n+  return __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+}\n+\n+__attribute__ ((noinline))\n+void FN(_c0)(TYPE *mem)\n+{\n+  TYPE old = 0;\n+  __atomic_compare_exchange_n (mem, (void *)&old, NEW, 1, 2, 0);\n+  return;\n+}\n+\n+int FN(_validate_mem)(TYPE *mem, TYPE expected_mem)\n+{\n+  if (*mem != expected_mem)\n+    {\n+      fprintf(stderr, \"  BAD: mem %d != expected mem %d\\n\",\n+\t      *mem, expected_mem);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int FN(_validate_rc)(int rc, int expected_rc)\n+{\n+  if (rc != expected_rc)\n+    {\n+      fprintf(stderr, \"  BAD: rc %d != expected rc %d\\n\",\n+\t      rc, expected_rc);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int FN(_validate_old_ret)(int old_ret, int expected_old_ret)\n+{\n+  if (old_ret != expected_old_ret)\n+    {\n+      fprintf(stderr, \"  BAD: old_ret %d != expected old_ret %d\\n\",\n+\t      old_ret, expected_old_ret);\n+      return 1;\n+    }\n+\n+  return 0;\n+}\n+\n+int FN(_validate)(TYPE *mem, TYPE init_mem, TYPE old)\n+{\n+  int err_count = 0;\n+  int rc;\n+  TYPE expected_mem;\n+  int expected_rc;\n+  TYPE old_ret;\n+  int failed;\n+  const char *fname;\n+\n+  fprintf(stderr, \"%s: init_mem %d @ %p\\n\", __FUNCTION__, init_mem, mem);\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_bo);\n+    rc = FN(_bo)(mem, &old_ret, old);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS(_o);\n+    FN(_o)(mem, &old_ret, old);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_b);\n+    rc = FN(_b)(mem, old);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS();\n+    FN()(mem, old);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_c1_bo);\n+    rc = FN(_c1_bo)(mem, &old_ret);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS(_c1_o);\n+    FN(_c1_o)(mem, &old_ret);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_c1_b);\n+    rc = FN(_c1_b)(mem);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 1;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS(_c1);\n+    FN(_c1)(mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 0;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_c0_bo);\n+    rc = FN(_c0_bo)(mem, &old_ret);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 0;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS(_c0_o);\n+    FN(_c0_o)(mem, &old_ret);\n+    failed |= FN(_validate_old_ret)(old_ret, init_mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 0;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    expected_rc = (init_mem == old);\n+    fname = FNS(_c0_b);\n+    rc = FN(_c0_b)(mem);\n+    failed |= FN(_validate_rc)(rc, expected_rc);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+  {\n+    failed = 0;\n+    old = 0;\n+    *mem = init_mem;\n+    expected_mem = (init_mem == old) ? NEW : *mem;\n+    fname = FNS(_c0);\n+    FN(_c0)(mem);\n+    failed |= FN(_validate_mem)(mem, expected_mem);\n+    if (failed)\n+      {\n+\tfprintf(stderr, \"  FAIL: %s: near line %d\\n\", fname, __LINE__ - 3);\n+\terr_count++;\n+      }\n+  }\n+\n+  return err_count;\n+}\n+\n+#undef TYPE\n+#undef MEM\n+#undef FN\n+#undef FNS"}, {"sha": "f82b21310155b771c84e0fb71ff6987416bceff2", "filename": "gcc/testsuite/gcc.target/s390/md/atomic_exchange-1.c", "status": "added", "additions": 309, "deletions": 0, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_exchange-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/03db9ab59481e07de0f8b651e6cc5c0f7d26b330/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_exchange-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fs390%2Fmd%2Fatomic_exchange-1.c?ref=03db9ab59481e07de0f8b651e6cc5c0f7d26b330", "patch": "@@ -0,0 +1,309 @@\n+/* Machine description pattern tests.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-lpthread -latomic\" } */\n+/* { dg-do run { target { s390_useable_hw } } } */\n+\n+/**/\n+\n+char\n+ae_8_0 (char *lock)\n+{\n+  return __atomic_exchange_n (lock, 0, 2);\n+}\n+\n+char\n+ae_8_1 (char *lock)\n+{\n+  return __atomic_exchange_n (lock, 1, 2);\n+}\n+\n+char g8;\n+\n+char\n+ae_8_g_0 (void)\n+{\n+  return __atomic_exchange_n (&g8, 0, 2);\n+}\n+\n+char\n+ae_8_g_1 (void)\n+{\n+  return __atomic_exchange_n (&g8, 1, 2);\n+}\n+\n+/**/\n+\n+short\n+ae_16_0 (short *lock)\n+{\n+  return __atomic_exchange_n (lock, 0, 2);\n+}\n+\n+short\n+ae_16_1 (short *lock)\n+{\n+  return __atomic_exchange_n (lock, 1, 2);\n+}\n+\n+short g16;\n+\n+short\n+ae_16_g_0 (void)\n+{\n+  return __atomic_exchange_n (&g16, 0, 2);\n+}\n+\n+short\n+ae_16_g_1 (void)\n+{\n+  return __atomic_exchange_n (&g16, 1, 2);\n+}\n+\n+/**/\n+\n+int\n+ae_32_0 (int *lock)\n+{\n+  return __atomic_exchange_n (lock, 0, 2);\n+}\n+\n+int\n+ae_32_1 (int *lock)\n+{\n+  return __atomic_exchange_n (lock, 1, 2);\n+}\n+\n+int g32;\n+\n+int\n+ae_32_g_0 (void)\n+{\n+  return __atomic_exchange_n (&g32, 0, 2);\n+}\n+\n+int\n+ae_32_g_1 (void)\n+{\n+  return __atomic_exchange_n (&g32, 1, 2);\n+}\n+\n+/**/\n+\n+long long\n+ae_64_0 (long long *lock)\n+{\n+  return __atomic_exchange_n (lock, 0, 2);\n+}\n+\n+long long\n+ae_64_1 (long long *lock)\n+{\n+  return __atomic_exchange_n (lock, 1, 2);\n+}\n+\n+long long g64;\n+\n+long long\n+ ae_64_g_0 (void)\n+{\n+  return __atomic_exchange_n (&g64, 0, 2);\n+}\n+\n+long long\n+ae_64_g_1 (void)\n+{\n+  return __atomic_exchange_n (&g64, 1, 2);\n+}\n+\n+/**/\n+\n+#ifdef __s390x__\n+__int128\n+ae_128_0 (__int128 *lock)\n+{\n+  return __atomic_exchange_n (lock, 0, 2);\n+}\n+\n+__int128\n+ae_128_1 (__int128 *lock)\n+{\n+  return __atomic_exchange_n (lock, 1, 2);\n+}\n+\n+__int128 g128;\n+\n+__int128\n+ae_128_g_0 (void)\n+{\n+  return __atomic_exchange_n (&g128, 0, 2);\n+}\n+\n+__int128\n+ae_128_g_1 (void)\n+{\n+  return __atomic_exchange_n (&g128, 1, 2);\n+}\n+\n+#endif\n+\n+int main(void)\n+{\n+  int i;\n+\n+  for (i = 0; i <= 2; i++)\n+    {\n+      int oval = i;\n+\n+      {\n+\tchar lock;\n+\tchar rval;\n+\n+\tlock = oval;\n+\trval = ae_8_0 (&lock);\n+\tif (lock != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tlock = oval;\n+\trval = ae_8_1 (&lock);\n+\tif (lock != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg8 = oval;\n+\trval = ae_8_g_0 ();\n+\tif (g8 != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg8 = oval;\n+\trval = ae_8_g_1 ();\n+\tif (g8 != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+      }\n+      {\n+\tshort lock;\n+\tshort rval;\n+\n+\tlock = oval;\n+\trval = ae_16_0 (&lock);\n+\tif (lock != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tlock = oval;\n+\trval = ae_16_1 (&lock);\n+\tif (lock != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg16 = oval;\n+\trval = ae_16_g_0 ();\n+\tif (g16 != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg16 = oval;\n+\trval = ae_16_g_1 ();\n+\tif (g16 != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+      }\n+      {\n+\tint lock;\n+\tint rval;\n+\n+\tlock = oval;\n+\trval = ae_32_0 (&lock);\n+\tif (lock != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tlock = oval;\n+\trval = ae_32_1 (&lock);\n+\tif (lock != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg32 = oval;\n+\trval = ae_32_g_0 ();\n+\tif (g32 != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg32 = oval;\n+\trval = ae_32_g_1 ();\n+\tif (g32 != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+      }\n+      {\n+\tlong long lock;\n+\tlong long rval;\n+\n+\tlock = oval;\n+\trval = ae_64_0 (&lock);\n+\tif (lock != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tlock = oval;\n+\trval = ae_64_1 (&lock);\n+\tif (lock != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg64 = oval;\n+\trval = ae_64_g_0 ();\n+\tif (g64 != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg64 = oval;\n+\trval = ae_64_g_1 ();\n+\tif (g64 != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+      }\n+\n+#ifdef __s390x__\n+      {\n+\t__int128 lock;\n+\t__int128 rval;\n+\n+\tlock = oval;\n+\trval = ae_128_0 (&lock);\n+\tif (lock != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tlock = oval;\n+\trval = ae_128_1 (&lock);\n+\tif (lock != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg128 = oval;\n+\trval = ae_128_g_0 ();\n+\tif (g128 != 0)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+\tg128 = oval;\n+\trval = ae_128_g_1 ();\n+\tif (g128 != 1)\n+\t  __builtin_abort ();\n+\tif (rval != oval)\n+\t  __builtin_abort ();\n+      }\n+#endif\n+    }\n+\n+  return 0;\n+}"}]}