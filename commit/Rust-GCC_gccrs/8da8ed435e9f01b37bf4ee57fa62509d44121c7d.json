{"sha": "8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRhOGVkNDM1ZTlmMDFiMzdiZjRlZTU3ZmE2MjUwOWQ0NDEyMWM3ZA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-07-16T12:21:29Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-07-16T12:21:29Z"}, "message": "Implement EAF_NOT_RETURNED tracking in ipa-modref\n\n2021-07-16  Jan Hubicka  <hubicka@ucw.cz>\n\n\t* ipa-modref.c (struct escape_entry): Use eaf_fleags_t.\n\t(dump_eaf_flags): Dump EAF_NOT_RETURNED\n\t(eaf_flags_useful_p): Use eaf_fleags_t; handle const functions\n\tand EAF_NOT_RETURNED.\n\t(modref_summary::useful_p): Likewise.\n\t(modref_summary_lto::useful_p): Likewise.\n\t(struct) modref_summary_lto: Use eaf_fleags_t.\n\t(deref_flags): Handle EAF_NOT_RETURNED.\n\t(struct escape_point): Use min_flags.\n\t(modref_lattice::init): Add EAF_NOT_RETURNED.\n\t(merge_call_lhs_flags): Ignore EAF_NOT_RETURNED functions\n\t(analyze_ssa_name_flags): Clear EAF_NOT_RETURNED on return;\n\thandle call flags.\n\t(analyze_parms): Also analyze const functions; update conition on\n\tflags usefulness.\n\t(modref_write): Update streaming.\n\t(read_section): Update streaming.\n\t(remap_arg_flags): Use eaf_flags_t.\n\t(modref_merge_call_site_flags): Hanlde EAF_NOT_RETURNED.\n\t* ipa-modref.h: (eaf_flags_t): New typedef.\n\t(struct modref_summary): Use eaf_flags_t.\n\t* tree-core.h (EAF_NOT_RETURNED): New constant.", "tree": {"sha": "aa883b93b12f1b616f68dc4deac8775870a394a3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/aa883b93b12f1b616f68dc4deac8775870a394a3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/comments", "author": null, "committer": null, "parents": [{"sha": "ce777eaedfdc55850b429f97b2093f2de5da09de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ce777eaedfdc55850b429f97b2093f2de5da09de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ce777eaedfdc55850b429f97b2093f2de5da09de"}], "stats": {"total": 77, "additions": 54, "deletions": 23}, "files": [{"sha": "7b849c1cd7b19fc40988e66e2e018f028b83eff1", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 49, "deletions": 22, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "patch": "@@ -86,6 +86,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"stringpool.h\"\n #include \"tree-ssanames.h\"\n \n+\n namespace {\n \n /* We record fnspec specifiers for call edges since they depends on actual\n@@ -135,7 +136,7 @@ struct escape_entry\n   /* Argument it escapes to.  */\n   unsigned int arg;\n   /* Minimal flags known about the argument.  */\n-  char min_flags;\n+  eaf_flags_t min_flags;\n   /* Does it escape directly or indirectly?  */\n   bool direct;\n };\n@@ -155,6 +156,8 @@ dump_eaf_flags (FILE *out, int flags, bool newline = true)\n     fprintf (out, \" nodirectescape\");\n   if (flags & EAF_UNUSED)\n     fprintf (out, \" unused\");\n+  if (flags & EAF_NOT_RETURNED)\n+    fprintf (out, \" not_returned\");\n   if (newline)\n   fprintf (out, \"\\n\");\n }\n@@ -278,12 +281,17 @@ modref_summary::~modref_summary ()\n /* Return true if FLAGS holds some useful information.  */\n \n static bool\n-eaf_flags_useful_p (vec <unsigned char> &flags, int ecf_flags)\n+eaf_flags_useful_p (vec <eaf_flags_t> &flags, int ecf_flags)\n {\n   for (unsigned i = 0; i < flags.length (); i++)\n-    if (ecf_flags & ECF_PURE)\n+    if (ecf_flags & ECF_CONST)\n       {\n-\tif (flags[i] & (EAF_UNUSED | EAF_DIRECT))\n+\tif (flags[i] & (EAF_UNUSED | EAF_NOT_RETURNED))\n+\t  return true;\n+      }\n+    else if (ecf_flags & ECF_PURE)\n+      {\n+\tif (flags[i] & (EAF_UNUSED | EAF_DIRECT | EAF_NOT_RETURNED))\n \t  return true;\n       }\n     else\n@@ -300,13 +308,15 @@ eaf_flags_useful_p (vec <unsigned char> &flags, int ecf_flags)\n bool\n modref_summary::useful_p (int ecf_flags, bool check_flags)\n {\n-  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+  if (ecf_flags & ECF_NOVOPS)\n     return false;\n   if (arg_flags.length () && !check_flags)\n     return true;\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n     return true;\n   arg_flags.release ();\n+  if (ecf_flags & ECF_CONST)\n+    return false;\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -325,7 +335,7 @@ struct GTY(()) modref_summary_lto\n      more verbose and thus more likely to hit the limits.  */\n   modref_records_lto *loads;\n   modref_records_lto *stores;\n-  auto_vec<unsigned char> GTY((skip)) arg_flags;\n+  auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   bool writes_errno;\n \n   modref_summary_lto ();\n@@ -356,13 +366,15 @@ modref_summary_lto::~modref_summary_lto ()\n bool\n modref_summary_lto::useful_p (int ecf_flags, bool check_flags)\n {\n-  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+  if (ecf_flags & ECF_NOVOPS)\n     return false;\n   if (arg_flags.length () && !check_flags)\n     return true;\n   if (check_flags && eaf_flags_useful_p (arg_flags, ecf_flags))\n     return true;\n   arg_flags.release ();\n+  if (ecf_flags & ECF_CONST)\n+    return false;\n   if (loads && !loads->every_base)\n     return true;\n   if (ecf_flags & ECF_PURE)\n@@ -1317,6 +1329,8 @@ deref_flags (int flags, bool ignore_stores)\n       if ((flags & EAF_NOESCAPE) || ignore_stores)\n \tret |= EAF_NOESCAPE;\n     }\n+  if (flags & EAF_NOT_RETURNED)\n+    ret |= EAF_NOT_RETURNED;\n   return ret;\n }\n \n@@ -1332,7 +1346,7 @@ struct escape_point\n   int arg;\n   /* Flags already known about the argument (this can save us from recording\n      esape points if local analysis did good job already).  */\n-  char min_flags;\n+  eaf_flags_t min_flags;\n   /* Does value escape directly or indiretly?  */\n   bool direct;\n };\n@@ -1366,7 +1380,7 @@ void\n modref_lattice::init ()\n {\n   flags = EAF_DIRECT | EAF_NOCLOBBER | EAF_NOESCAPE | EAF_UNUSED\n-\t  | EAF_NODIRECTESCAPE;\n+\t  | EAF_NODIRECTESCAPE | EAF_NOT_RETURNED;\n   open = true;\n   known = false;\n }\n@@ -1539,6 +1553,9 @@ merge_call_lhs_flags (gcall *call, int arg, int index, bool deref,\n       && (flags & ERF_RETURN_ARG_MASK) != arg)\n     return;\n \n+  if (gimple_call_arg_flags (call, arg) & (EAF_NOT_RETURNED | EAF_UNUSED))\n+    return;\n+\n   /* If return value is SSA name determine its flags.  */\n   if (TREE_CODE (gimple_call_lhs (call)) == SSA_NAME)\n     {\n@@ -1613,9 +1630,12 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n       if (greturn *ret = dyn_cast <greturn *> (use_stmt))\n \t{\n \t  if (gimple_return_retval (ret) == name)\n-\t    lattice[index].merge (~EAF_UNUSED);\n+\t    lattice[index].merge (~(EAF_UNUSED | EAF_NOT_RETURNED));\n \t  else if (memory_access_to (gimple_return_retval (ret), name))\n-\t    lattice[index].merge_direct_load ();\n+\t    {\n+\t      lattice[index].merge_direct_load ();\n+\t      lattice[index].merge (~EAF_NOT_RETURNED);\n+\t    }\n \t}\n       /* Account for LHS store, arg loads and flags from callee function.  */\n       else if (gcall *call = dyn_cast <gcall *> (use_stmt))\n@@ -1666,7 +1686,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t  {\n \t\t    if (!(ecf_flags & (ECF_CONST | ECF_NOVOPS)))\n \t\t      {\n-\t\t\tint call_flags = gimple_call_arg_flags (call, i);\n+\t\t\tint call_flags = gimple_call_arg_flags (call, i)\n+\t\t\t\t\t | EAF_NOT_RETURNED;\n \t\t\tif (ignore_stores)\n \t\t\t  call_flags |= EAF_NOCLOBBER | EAF_NOESCAPE\n \t\t\t\t\t| EAF_NODIRECTESCAPE;\n@@ -1689,7 +1710,8 @@ analyze_ssa_name_flags (tree name, vec<modref_lattice> &lattice, int depth,\n \t\t    else\n \t\t      {\n \t\t\tint call_flags = deref_flags\n-\t\t\t   (gimple_call_arg_flags (call, i), ignore_stores);\n+\t\t\t   (gimple_call_arg_flags (call, i)\n+\t\t\t    | EAF_NOT_RETURNED, ignore_stores);\n \t\t\tif (!record_ipa)\n \t\t\t  lattice[index].merge (call_flags);\n \t\t\telse\n@@ -1819,8 +1841,8 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n   unsigned int count = 0;\n   int ecf_flags = flags_from_decl_or_type (current_function_decl);\n \n-  /* For const functions we have nothing to gain by EAF flags.  */\n-  if (ecf_flags & (ECF_CONST | ECF_NOVOPS))\n+  /* For novops functions we have nothing to gain by EAF flags.  */\n+  if (ecf_flags & ECF_NOVOPS)\n     return;\n \n   for (tree parm = DECL_ARGUMENTS (current_function_decl); parm;\n@@ -1863,7 +1885,11 @@ analyze_parms (modref_summary *summary, modref_summary_lto *summary_lto,\n       /* For pure functions we have implicit NOCLOBBER\n \t and NOESCAPE.  */\n       if (ecf_flags & ECF_PURE)\n-\tflags &= ~(EAF_NOCLOBBER | EAF_NOESCAPE | EAF_NODIRECTESCAPE);\n+\tflags &= (EAF_UNUSED | EAF_DIRECT | EAF_NOT_RETURNED);\n+      /* Only useful flags for const function are EAF_NOT_RETURNED and\n+\t EAF_UNUSED.  */\n+      if (ecf_flags & ECF_CONST)\n+\tflags &= (EAF_UNUSED | EAF_NOT_RETURNED);\n \n       if (flags)\n \t{\n@@ -2518,7 +2544,7 @@ modref_write ()\n \n \t  streamer_write_uhwi (ob, r->arg_flags.length ());\n \t  for (unsigned int i = 0; i < r->arg_flags.length (); i++)\n-\t    streamer_write_char_stream (ob->main_stream, r->arg_flags[i]);\n+\t    streamer_write_uhwi (ob, r->arg_flags[i]);\n \n \t  write_modref_records (r->loads, ob);\n \t  write_modref_records (r->stores, ob);\n@@ -2609,7 +2635,7 @@ read_section (struct lto_file_decl_data *file_data, const char *data,\n \tmodref_sum_lto->arg_flags.reserve_exact (args);\n       for (unsigned int i = 0; i < args; i++)\n \t{\n-\t  unsigned char flags = streamer_read_uchar (&ib);\n+\t  eaf_flags_t flags = streamer_read_uhwi (&ib);\n \t  if (modref_sum)\n \t    modref_sum->arg_flags.quick_push (flags);\n \t  if (modref_sum_lto)\n@@ -2713,9 +2739,9 @@ modref_read (void)\n /* Recompute arg_flags for param adjustments in INFO.  */\n \n static void\n-remap_arg_flags (auto_vec <unsigned char> &arg_flags, clone_info *info)\n+remap_arg_flags (auto_vec <eaf_flags_t> &arg_flags, clone_info *info)\n {\n-  auto_vec<unsigned char> old = arg_flags.copy ();\n+  auto_vec<eaf_flags_t> old = arg_flags.copy ();\n   int max = -1;\n   size_t i;\n   ipa_adjusted_param *p;\n@@ -3665,8 +3691,9 @@ modref_merge_call_site_flags (escape_summary *sum,\n \t  flags |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n \t  flags_lto |= EAF_NOESCAPE | EAF_NOCLOBBER | EAF_NODIRECTESCAPE;\n \t}\n-      flags |= ee->min_flags;\n-      flags_lto |= ee->min_flags;\n+      /* Returning the value is already accounted to at local propagation.  */\n+      flags |= ee->min_flags | EAF_NOT_RETURNED;\n+      flags_lto |= ee->min_flags | EAF_NOT_RETURNED;\n       if (!(flags & EAF_UNUSED)\n \t  && cur_summary && ee->parm_index < cur_summary->arg_flags.length ())\n \t{"}, {"sha": "498cc2414ace2619cc37975047784320cc22583b", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "patch": "@@ -21,6 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define IPA_MODREF_H\n \n typedef modref_tree <alias_set_type> modref_records;\n+typedef unsigned short eaf_flags_t;\n \n /* Single function summary.  */\n \n@@ -29,7 +30,7 @@ struct GTY(()) modref_summary\n   /* Load and stores in function (transitively closed to all callees)  */\n   modref_records *loads;\n   modref_records *stores;\n-  auto_vec<unsigned char> GTY((skip)) arg_flags;\n+  auto_vec<eaf_flags_t> GTY((skip)) arg_flags;\n   bool writes_errno;\n \n   modref_summary ();"}, {"sha": "93916090432fac0d57607aa0f68652698df93db8", "filename": "gcc/tree-core.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8da8ed435e9f01b37bf4ee57fa62509d44121c7d/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=8da8ed435e9f01b37bf4ee57fa62509d44121c7d", "patch": "@@ -114,6 +114,9 @@ struct die_struct;\n    referenced by it can escape.  */\n #define EAF_NODIRECTESCAPE\t(1 << 4)\n \n+/* Nonzero if the argument does not escape to return value.  */\n+#define EAF_NOT_RETURNED\t(1 << 8)\n+\n /* Call return flags.  */\n /* Mask for the argument number that is returned.  Lower two bits of\n    the return flags, encodes argument slots zero to three.  */"}]}