{"sha": "6ec9201068573cc842e105a20aad853282472b37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmVjOTIwMTA2ODU3M2NjODQyZTEwNWEyMGFhZDg1MzI4MjQ3MmIzNw==", "commit": {"author": {"name": "Michael Hayes", "email": "mhayes@redhat.com", "date": "2001-01-01T00:03:17Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "2001-01-01T00:03:17Z"}, "message": "loop.h (struct loop_movables): New.\n\n\t* loop.h (struct loop_movables): New.\n\t(LOOP_MOVABLES): New.\n\t(struct loop_info): Add movables field.\n\t* loop.c (struct movables): Delete.  Replace all uses\n\twith struct loop_movables.\n\t(the_movables): Delete.  Replace all uses with movables\n\tfield in loop_info.\n\t(loop_movables_add, loop_movables_free): New functions.\n\t(scan_loop): Use xmalloc instead of alloca for movables.\n\tCall loop_movables_free.\n\nFrom-SVN: r38573", "tree": {"sha": "a50a0e17ce6f5e07b22d95be7aca07995b403fa4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a50a0e17ce6f5e07b22d95be7aca07995b403fa4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ec9201068573cc842e105a20aad853282472b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec9201068573cc842e105a20aad853282472b37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ec9201068573cc842e105a20aad853282472b37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ec9201068573cc842e105a20aad853282472b37/comments", "author": null, "committer": null, "parents": [{"sha": "685efa54548aed93f34a130959721df4fd053a79", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/685efa54548aed93f34a130959721df4fd053a79", "html_url": "https://github.com/Rust-GCC/gccrs/commit/685efa54548aed93f34a130959721df4fd053a79"}], "stats": {"total": 126, "additions": 89, "deletions": 37}, "files": [{"sha": "c93980c83e5f46b211ae3a56b2c890d69da0f6a6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec9201068573cc842e105a20aad853282472b37/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec9201068573cc842e105a20aad853282472b37/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ec9201068573cc842e105a20aad853282472b37", "patch": "@@ -1,5 +1,18 @@\n 2001-01-01  Michael Hayes  <mhayes@redhat.com>\n \n+\t* loop.h (struct loop_movables): New.\n+\t(LOOP_MOVABLES): New.\n+\t(struct loop_info): Add movables field.\n+\t* loop.c (struct movables): Delete.  Replace all uses\n+\twith struct loop_movables.\n+\t(the_movables): Delete.  Replace all uses with movables\n+\tfield in loop_info.\n+\t(loop_movables_add, loop_movables_free): New functions.\n+\t(scan_loop): Use xmalloc instead of alloca for movables.\n+\tCall loop_movables_free.\n+\t\n+2001-01-01  Michael Hayes  <mhayes@redhat.com>\t\n+\n \t* loop.c (debug_loops): New.\n \n 2000-12-31  Philip Blundell  <philb@gnu.org>"}, {"sha": "dc917610a568328d06da66a54d03cc9908410631", "filename": "gcc/loop.c", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec9201068573cc842e105a20aad853282472b37/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec9201068573cc842e105a20aad853282472b37/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=6ec9201068573cc842e105a20aad853282472b37", "patch": "@@ -132,17 +132,6 @@ struct movable\n   struct movable *next;\n };\n \n-struct movables\n-{\n-  /* Head of movable chain.  */\n-  struct movable *head;\n-  /* Last movable in chain.  */\n-  struct movable *last;\n-  /* Number of movables in the loop.  */\n-  int num;\n-};\n-\n-static struct movables the_movables;\n \n FILE *loop_dump_stream;\n \n@@ -170,15 +159,19 @@ static void replace_call_address PARAMS ((rtx, rtx, rtx));\n #endif\n static rtx skip_consec_insns PARAMS ((rtx, int));\n static int libcall_benefit PARAMS ((rtx));\n-static void ignore_some_movables PARAMS ((struct movables *));\n-static void force_movables PARAMS ((struct movables *));\n-static void combine_movables PARAMS ((struct movables *, struct loop_regs *));\n-static int regs_match_p PARAMS ((rtx, rtx, struct movables *));\n-static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct movables *,\n+static void ignore_some_movables PARAMS ((struct loop_movables *));\n+static void force_movables PARAMS ((struct loop_movables *));\n+static void combine_movables PARAMS ((struct loop_movables *,\n+\t\t\t\t      struct loop_regs *));\n+static int regs_match_p PARAMS ((rtx, rtx, struct loop_movables *));\n+static int rtx_equal_for_loop_p PARAMS ((rtx, rtx, struct loop_movables *,\n \t\t\t\t\t struct loop_regs *));\n static void add_label_notes PARAMS ((rtx, rtx));\n-static void move_movables PARAMS ((struct loop *loop, struct movables *,\n+static void move_movables PARAMS ((struct loop *loop, struct loop_movables *,\n \t\t\t\t   int, int));\n+static void loop_movables_add PARAMS((struct loop_movables *,\n+\t\t\t\t      struct movable *));\n+static void loop_movables_free PARAMS((struct loop_movables *));\n static int count_nonfixed_reads PARAMS ((const struct loop *, rtx));\n static void strength_reduce PARAMS ((struct loop *, int, int));\n static void find_single_use_in_loop PARAMS ((rtx, rtx, varray_type));\n@@ -517,7 +510,7 @@ scan_loop (loop, flags)\n   /* The SET from an insn, if it is the only SET in the insn.  */\n   rtx set, set1;\n   /* Chain describing insns movable in current loop.  */\n-  struct movables *movables = &the_movables;\n+  struct loop_movables *movables = LOOP_MOVABLES (loop);\n   /* Ratio of extra register life span we can justify\n      for saving an instruction.  More if loop doesn't call subroutines\n      since in that case saving an insn makes more difference\n@@ -809,7 +802,7 @@ scan_loop (loop, flags)\n \t\t  continue;\n \t\t}\n \n-\t      m = (struct movable *) alloca (sizeof (struct movable));\n+\t      m = (struct movable *) xmalloc (sizeof (struct movable));\n \t      m->next = 0;\n \t      m->insn = p;\n \t      m->set_src = src;\n@@ -841,11 +834,7 @@ scan_loop (loop, flags)\n \t\tm->savings += libcall_benefit (p);\n \t      VARRAY_INT (regs->set_in_loop, regno) = move_insn ? -2 : -1;\n \t      /* Add M to the end of the chain MOVABLES.  */\n-\t      if (movables->head == 0)\n-\t\tmovables->head = m;\n-\t      else\n-\t\tmovables->last->next = m;\n-\t      movables->last = m;\n+\t      loop_movables_add (movables, m);\n \n \t      if (m->consec > 0)\n \t\t{\n@@ -950,11 +939,7 @@ scan_loop (loop, flags)\n \t\t  m->savings = 1;\n \t\t  VARRAY_INT (regs->set_in_loop, regno) = -1;\n \t\t  /* Add M to the end of the chain MOVABLES.  */\n-\t\t  if (movables->head == 0)\n-\t\t    movables->head = m;\n-\t\t  else\n-\t\t    movables->last->next = m;\n-\t\t  movables->last = m;\n+\t\t  loop_movables_add (movables, m);\n \t\t}\n \t    }\n \t}\n@@ -1057,6 +1042,10 @@ scan_loop (loop, flags)\n \tdelete_insn (update_end);\n     }\n \n+\n+  /* The movable information is required for strength reduction.  */\n+  loop_movables_free (movables);\n+\n   VARRAY_FREE (regs->single_usage);\n   VARRAY_FREE (regs->set_in_loop);\n   VARRAY_FREE (regs->n_times_set);\n@@ -1256,7 +1245,7 @@ skip_consec_insns (insn, count)\n \n static void\n ignore_some_movables (movables)\n-     struct movables *movables;\n+     struct loop_movables *movables;\n {\n   register struct movable *m, *m1;\n \n@@ -1288,7 +1277,7 @@ ignore_some_movables (movables)\n \n static void\n force_movables (movables)\n-     struct movables *movables;\n+     struct loop_movables *movables;\n {\n   register struct movable *m, *m1;\n   for (m1 = movables->head; m1; m1 = m1->next)\n@@ -1327,7 +1316,7 @@ force_movables (movables)\n \n static void\n combine_movables (movables, regs)\n-     struct movables *movables;\n+     struct loop_movables *movables;\n      struct loop_regs *regs;\n {\n   register struct movable *m;\n@@ -1447,7 +1436,7 @@ combine_movables (movables, regs)\n static int\n regs_match_p (x, y, movables)\n      rtx x, y;\n-     struct movables *movables;\n+     struct loop_movables *movables;\n {\n   unsigned int xn = REGNO (x);\n   unsigned int yn = REGNO (y);\n@@ -1476,7 +1465,7 @@ regs_match_p (x, y, movables)\n static int\n rtx_equal_for_loop_p (x, y, movables, regs)\n      rtx x, y;\n-     struct movables *movables;\n+     struct loop_movables *movables;\n      struct loop_regs *regs;\n {\n   register int i;\n@@ -1633,7 +1622,7 @@ add_label_notes (x, insns)\n static void\n move_movables (loop, movables, threshold, insn_count)\n      struct loop *loop;\n-     struct movables *movables;\n+     struct loop_movables *movables;\n      int threshold;\n      int insn_count;\n {\n@@ -2136,6 +2125,34 @@ move_movables (loop, movables, threshold, insn_count)\n   free (reg_map);\n   free (already_moved);\n }\n+\n+\n+static void\n+loop_movables_add (movables, m)\n+     struct loop_movables *movables;\n+     struct movable *m;\n+{\n+  if (movables->head == 0)\n+    movables->head = m;\n+  else\n+    movables->last->next = m;\n+  movables->last = m;\n+}\n+\n+\n+static void\n+loop_movables_free (movables)\n+     struct loop_movables *movables;\n+{\n+  struct movable *m;\n+  struct movable *m_next;\n+\n+  for (m = movables->head; m; m = m_next)\n+    {\n+      m_next = m->next;\n+      free (m);\n+    }\n+}  \n \f\n #if 0\n /* Scan X and replace the address of any MEM in it with ADDR.\n@@ -6020,8 +6037,9 @@ simplify_giv_expr (loop, x, ext_val, benefit)\n \t  if (loop_invariant_p (loop, x) == 1)\n \t    {\n \t      struct movable *m;\n+\t      struct loop_movables *movables = LOOP_MOVABLES (loop);\n \n-\t      for (m = the_movables.head; m; m = m->next)\n+\t      for (m = movables->head; m; m = m->next)\n \t\tif (rtx_equal_p (x, m->set_dest))\n \t\t  {\n \t\t    /* Ok, we found a match.  Substitute and simplify.  */\n@@ -7317,7 +7335,7 @@ check_dbra_loop (loop, insn_count)\n \t   && ! loop_info->has_volatile\n \t   && reversible_mem_store\n \t   && (bl->giv_count + bl->biv_count + loop_info->num_mem_sets\n-\t       + the_movables.num + compare_and_branch == insn_count)\n+\t       + LOOP_MOVABLES (loop)->num + compare_and_branch == insn_count)\n \t   && (bl == ivs->loop_iv_list && bl->next == 0))\n \t  || no_use_except_counting)\n \t{"}, {"sha": "441d3a5b58dafee8c51426c330fd0511b6608477", "filename": "gcc/loop.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ec9201068573cc842e105a20aad853282472b37/gcc%2Floop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ec9201068573cc842e105a20aad853282472b37/gcc%2Floop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.h?ref=6ec9201068573cc842e105a20aad853282472b37", "patch": "@@ -28,6 +28,9 @@ Boston, MA 02111-1307, USA.  */\n /* Get the loop info pointer of a loop.  */\n #define LOOP_INFO(LOOP) ((struct loop_info *) (LOOP)->aux)\n \n+/* Get a pointer to the loop movables structure.  */\n+#define LOOP_MOVABLES(LOOP) (&LOOP_INFO (loop)->movables)\n+\n /* Get a pointer to the loop registers structure.  */\n #define LOOP_REGS(LOOP) (&LOOP_INFO (loop)->regs)\n \n@@ -236,12 +239,28 @@ struct loop_regs\n   int multiple_uses;\n };\n \n+\n+struct loop_movables\n+{\n+  /* Head of movable chain.  */\n+  struct movable *head;\n+  /* Last movable in chain.  */\n+  struct movable *last;\n+  /* Number of movables in the loop.  */\n+  int num;\n+};\n+\n+\n /* Information pertaining to a loop.  */\n \n struct loop_info\n {\n   /* Nonzero if there is a subroutine call in the current loop.  */\n   int has_call;\n+  /* Nonzero if there is a libcall in the current loop.  */\n+  int has_libcall;\n+  /* Nonzero if there is a non constant call in the current loop.  */\n+  int has_nonconst_call;\n   /* Nonzero if there is a volatile memory reference in the current\n      loop.  */\n   int has_volatile;\n@@ -304,6 +323,8 @@ struct loop_info\n   int num_mem_sets;\n   /* The insn where the first of these was found.  */\n   rtx first_loop_store_insn;\n+  /* The chain of movable insns in loop.  */\n+  struct loop_movables movables;\n   /* The registers used the in loop.  */\n   struct loop_regs regs;\n   /* The induction variable information in loop.  */"}]}