{"sha": "5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "node_id": "C_kwDOANBUbNoAKDU1NTliZGM4NjYzNWIyZmY2Y2JhYTYwZTkzM2E3OTg5ZmYyMTJlMWY", "commit": {"author": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-04-07T16:41:37Z"}, "committer": {"name": "David Faust", "email": "david.faust@oracle.com", "date": "2022-04-07T16:57:46Z"}, "message": "Emit loop initializer for repeat arrays\n\nThis commit changes how arrays of repeating elements, e.g. [5; 12] are\ncompiled. Rather than create a constructor which explicitly initializes\neach element to the given value (which causes compiler OOM for large\narrays), we emit instructions to allocate the array then initialize the\nelements in a loop.\n\nHowever, we can only take this approach outside of const contexts -\nconst arrays must still use the old approach.", "tree": {"sha": "96e6621e8cb28606efa91c030d2b9de4c77339f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e6621e8cb28606efa91c030d2b9de4c77339f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/comments", "author": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dafaust", "id": 4460334, "node_id": "MDQ6VXNlcjQ0NjAzMzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4460334?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dafaust", "html_url": "https://github.com/dafaust", "followers_url": "https://api.github.com/users/dafaust/followers", "following_url": "https://api.github.com/users/dafaust/following{/other_user}", "gists_url": "https://api.github.com/users/dafaust/gists{/gist_id}", "starred_url": "https://api.github.com/users/dafaust/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dafaust/subscriptions", "organizations_url": "https://api.github.com/users/dafaust/orgs", "repos_url": "https://api.github.com/users/dafaust/repos", "events_url": "https://api.github.com/users/dafaust/events{/privacy}", "received_events_url": "https://api.github.com/users/dafaust/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b829e7c0a21c94672d09732e4a791e0471f41c13", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b829e7c0a21c94672d09732e4a791e0471f41c13", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b829e7c0a21c94672d09732e4a791e0471f41c13"}], "stats": {"total": 167, "additions": 156, "deletions": 11}, "files": [{"sha": "de9d03f6d9d458d6641e8b7f36a723be92e453a9", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -250,6 +250,10 @@ class Context\n     fn_stack.push_back (fncontext{fn, ret_addr});\n   }\n   void pop_fn () { fn_stack.pop_back (); }\n+\n+  bool in_fn () { return fn_stack.size () != 0; }\n+\n+  // Note: it is undefined behavior to call peek_fn () if fn_stack is empty.\n   fncontext peek_fn () { return fn_stack.back (); }\n \n   void push_type (tree t) { type_decls.push_back (t); }\n@@ -301,6 +305,14 @@ class Context\n     return pop;\n   }\n \n+  void push_const_context (void) { const_context++; }\n+  void pop_const_context (void)\n+  {\n+    if (const_context > 0)\n+      const_context--;\n+  }\n+  bool const_context_p (void) { return (const_context > 0); }\n+\n   std::string mangle_item (const TyTy::BaseType *ty,\n \t\t\t   const Resolver::CanonicalPath &path) const\n   {\n@@ -341,6 +353,9 @@ class Context\n   std::vector<::Bvariable *> var_decls;\n   std::vector<tree> const_decls;\n   std::vector<tree> func_decls;\n+\n+  // Nonzero iff we are currently compiling something inside a constant context.\n+  unsigned int const_context = 0;\n };\n \n } // namespace Compile"}, {"sha": "49a6f2f75bf027e7c81f8d30491e7878e661167d", "filename": "gcc/rust/backend/rust-compile-expr.cc", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.cc?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -1163,19 +1163,54 @@ CompileExpr::array_copied_expr (Location expr_locus,\n   unsigned HOST_WIDE_INT len\n     = wi::ext (max - min + 1, precision, sign).to_uhwi ();\n \n-  // create the constructor\n-  size_t idx = 0;\n-  std::vector<unsigned long> indexes;\n-  std::vector<tree> constructor;\n-  for (unsigned HOST_WIDE_INT i = 0; i < len; i++)\n-    {\n-      constructor.push_back (translated_expr);\n-      indexes.push_back (idx++);\n+  // In a const context we must initialize the entire array, which entails\n+  // allocating for each element. If the user wants a huge array, we will OOM\n+  // and die horribly.\n+  if (ctx->const_context_p ())\n+    {\n+      size_t idx = 0;\n+      std::vector<unsigned long> indexes;\n+      std::vector<tree> constructor;\n+      for (unsigned HOST_WIDE_INT i = 0; i < len; i++)\n+\t{\n+\t  constructor.push_back (translated_expr);\n+\t  indexes.push_back (idx++);\n+\t}\n+\n+      return ctx->get_backend ()->array_constructor_expression (array_type,\n+\t\t\t\t\t\t\t\tindexes,\n+\t\t\t\t\t\t\t\tconstructor,\n+\t\t\t\t\t\t\t\texpr_locus);\n     }\n \n-  return ctx->get_backend ()->array_constructor_expression (array_type, indexes,\n-\t\t\t\t\t\t\t    constructor,\n-\t\t\t\t\t\t\t    expr_locus);\n+  else\n+    {\n+      // Create a new block scope in which to initialize the array\n+      tree fndecl = NULL_TREE;\n+      if (ctx->in_fn ())\n+\tfndecl = ctx->peek_fn ().fndecl;\n+\n+      std::vector<Bvariable *> locals;\n+      tree enclosing_scope = ctx->peek_enclosing_scope ();\n+      tree init_block\n+\t= ctx->get_backend ()->block (fndecl, enclosing_scope, locals,\n+\t\t\t\t      expr_locus, expr_locus);\n+      ctx->push_block (init_block);\n+\n+      tree tmp;\n+      tree stmts\n+\t= ctx->get_backend ()->array_initializer (fndecl, init_block,\n+\t\t\t\t\t\t  array_type, capacity_expr,\n+\t\t\t\t\t\t  translated_expr, &tmp,\n+\t\t\t\t\t\t  expr_locus);\n+      ctx->add_statement (stmts);\n+\n+      tree block = ctx->pop_block ();\n+\n+      // The result is a compound expression which creates a temporary array,\n+      // initializes all the elements in a loop, and then yeilds the array.\n+      return ctx->get_backend ()->compound_expression (block, tmp, expr_locus);\n+    }\n }\n \n tree"}, {"sha": "80b7cebfb5fbd662978095e43c9fa0a8eddb4c7a", "filename": "gcc/rust/backend/rust-compile-item.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Fbackend%2Frust-compile-item.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-item.cc?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -92,9 +92,11 @@ CompileItem::visit (HIR::ConstantItem &constant)\n   rust_assert (ok);\n \n   HIR::Expr *const_value_expr = constant.get_expr ();\n+  ctx->push_const_context ();\n   tree const_expr\n     = compile_constant_item (ctx, resolved_type, canonical_path,\n \t\t\t     const_value_expr, constant.get_locus ());\n+  ctx->pop_const_context ();\n \n   ctx->push_const (const_expr);\n   ctx->insert_const_decl (constant.get_mappings ().get_hirid (), const_expr);"}, {"sha": "17b7bae6e990077e009c78053592e681edecfe34", "filename": "gcc/rust/rust-backend.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Frust-backend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Frust-backend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-backend.h?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -275,6 +275,10 @@ class Backend\n \t\t\t\tconst std::vector<tree> &vals, Location)\n     = 0;\n \n+  virtual tree array_initializer (tree, tree, tree, tree, tree, tree *,\n+\t\t\t\t  Location)\n+    = 0;\n+\n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n   virtual tree array_index_expression (tree array, tree index, Location) = 0;"}, {"sha": "334e9e504894233fab5b8bf6bcc55c4f338bd701", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -246,6 +246,8 @@ class Gcc_backend : public Backend\n   tree array_constructor_expression (tree, const std::vector<unsigned long> &,\n \t\t\t\t     const std::vector<tree> &, Location);\n \n+  tree array_initializer (tree, tree, tree, tree, tree, tree *, Location);\n+\n   tree array_index_expression (tree array, tree index, Location);\n \n   tree call_expression (tree caller, tree fn, const std::vector<tree> &args,\n@@ -1694,6 +1696,77 @@ Gcc_backend::array_constructor_expression (\n   return ret;\n }\n \n+// Build insns to create an array, initialize all elements of the array to\n+// value, and return it\n+tree\n+Gcc_backend::array_initializer (tree fndecl, tree block, tree array_type,\n+\t\t\t\ttree length, tree value, tree *tmp,\n+\t\t\t\tLocation locus)\n+{\n+  std::vector<tree> stmts;\n+\n+  // Temporary array we initialize with the desired value.\n+  tree t = NULL_TREE;\n+  Bvariable *tmp_array = this->temporary_variable (fndecl, block, array_type,\n+\t\t\t\t\t\t   NULL_TREE, true, locus, &t);\n+  tree arr = tmp_array->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // Temporary for the array length used for initialization loop guard.\n+  Bvariable *tmp_len = this->temporary_variable (fndecl, block, size_type_node,\n+\t\t\t\t\t\t length, true, locus, &t);\n+  tree len = tmp_len->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // Temporary variable for pointer used to initialize elements.\n+  tree ptr_type = this->pointer_type (TREE_TYPE (array_type));\n+  tree ptr_init\n+    = build1_loc (locus.gcc_location (), ADDR_EXPR, ptr_type,\n+\t\t  this->array_index_expression (arr, integer_zero_node, locus));\n+  Bvariable *tmp_ptr = this->temporary_variable (fndecl, block, ptr_type,\n+\t\t\t\t\t\t ptr_init, false, locus, &t);\n+  tree ptr = tmp_ptr->get_tree (locus);\n+  stmts.push_back (t);\n+\n+  // push statement list for the loop\n+  std::vector<tree> loop_stmts;\n+\n+  // Loop exit condition:\n+  //   if (length == 0) break;\n+  t = this->comparison_expression (ComparisonOperator::EQUAL, len,\n+\t\t\t\t   this->zero_expression (TREE_TYPE (len)),\n+\t\t\t\t   locus);\n+\n+  t = this->exit_expression (t, locus);\n+  loop_stmts.push_back (t);\n+\n+  // Assign value to the current pointer position\n+  //   *ptr = value;\n+  t = this->assignment_statement (build_fold_indirect_ref (ptr), value, locus);\n+  loop_stmts.push_back (t);\n+\n+  // Move pointer to next element\n+  //   ptr++;\n+  tree size = TYPE_SIZE_UNIT (TREE_TYPE (ptr_type));\n+  t = build2 (POSTINCREMENT_EXPR, ptr_type, ptr, convert (ptr_type, size));\n+  loop_stmts.push_back (t);\n+\n+  // Decrement loop counter.\n+  //   length--;\n+  t = build2 (POSTDECREMENT_EXPR, TREE_TYPE (len), len,\n+\t      convert (TREE_TYPE (len), integer_one_node));\n+  loop_stmts.push_back (t);\n+\n+  // pop statments and finish loop\n+  tree loop_body = this->statement_list (loop_stmts);\n+  stmts.push_back (this->loop_expression (loop_body, locus));\n+\n+  // Return the temporary in the provided pointer and the statement list which\n+  // initializes it.\n+  *tmp = tmp_array->get_tree (locus);\n+  return this->statement_list (stmts);\n+}\n+\n // Return an expression representing ARRAY[INDEX]\n \n tree"}, {"sha": "58950a17a1563f9c1e57d0ae16eb8273d6ad5120", "filename": "gcc/testsuite/rust/compile/torture/arrays5.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays5.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays5.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays5.rs?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -0,0 +1,6 @@\n+\n+// Checks that we don't try to allocate a 4TB array during compilation\n+fn main () {\n+    let x = [0; 4 * 1024 * 1024 * 1024 * 1024];\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "c7212d3f1832c6837abcccd1457062228886d8db", "filename": "gcc/testsuite/rust/compile/torture/arrays6.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5559bdc86635b2ff6cbaa60e933a7989ff212e1f/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Farrays6.rs?ref=5559bdc86635b2ff6cbaa60e933a7989ff212e1f", "patch": "@@ -0,0 +1,10 @@\n+\n+// Checks that we don't try to allocate a 4TB array during compilation\n+fn foo() -> [u8; 4 * 1024 * 1024 * 1024 * 1024] {\n+    [0; 4 * 1024 * 1024 * 1024 * 1024]\n+}\n+\n+fn main () {\n+    let x = foo ();\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}]}