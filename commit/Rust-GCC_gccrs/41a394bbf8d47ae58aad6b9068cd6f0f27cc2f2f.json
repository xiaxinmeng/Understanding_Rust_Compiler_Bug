{"sha": "41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFhMzk0YmJmOGQ0N2FlNThhYWQ2YjkwNjhjZDZmMGYyN2NjMmYyZg==", "commit": {"author": {"name": "Daniel Kraft", "email": "d@domob.eu", "date": "2009-12-08T11:39:20Z"}, "committer": {"name": "Daniel Kraft", "email": "domob@gcc.gnu.org", "date": "2009-12-08T11:39:20Z"}, "message": "re PR fortran/41177 (Wrong base-object checks for type-bound procedures)\n\n2008-12-08  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/41177\n\t* gfortran.dg/typebound_proc_4.f03: Remove check for wrong error.\n\t* gfortran.dg/typebound_proc_13.f03: New test.\n\n2008-12-08  Daniel Kraft  <d@domob.eu>\n\n\tPR fortran/41177\n\t* gfortran.h (struct symbol_attribute): New flag `class_pointer'.\n\t* symbol.c (gfc_build_class_symbol): Set the new flag.\n\t* resolve.c (update_compcall_arglist): Remove wrong check for\n\tnon-scalar base-object.\n\t(check_typebound_baseobject): Add the correct version here as well\n\tas some 'not implemented' message check in the old case.\n\t(resolve_typebound_procedure): Check that the passed-object dummy\n\targument is scalar, non-pointer and non-allocatable as it should be.\n\nFrom-SVN: r155086", "tree": {"sha": "97e379b084f6fe3298f9879b4b2d00a044c7693f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/97e379b084f6fe3298f9879b4b2d00a044c7693f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/comments", "author": {"login": "domob1812", "id": 4943644, "node_id": "MDQ6VXNlcjQ5NDM2NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/4943644?v=4", "gravatar_id": "", "url": "https://api.github.com/users/domob1812", "html_url": "https://github.com/domob1812", "followers_url": "https://api.github.com/users/domob1812/followers", "following_url": "https://api.github.com/users/domob1812/following{/other_user}", "gists_url": "https://api.github.com/users/domob1812/gists{/gist_id}", "starred_url": "https://api.github.com/users/domob1812/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/domob1812/subscriptions", "organizations_url": "https://api.github.com/users/domob1812/orgs", "repos_url": "https://api.github.com/users/domob1812/repos", "events_url": "https://api.github.com/users/domob1812/events{/privacy}", "received_events_url": "https://api.github.com/users/domob1812/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "72d099cb27a5fedea22e2d69ce8d03e71120fddc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/72d099cb27a5fedea22e2d69ce8d03e71120fddc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/72d099cb27a5fedea22e2d69ce8d03e71120fddc"}], "stats": {"total": 125, "additions": 113, "deletions": 12}, "files": [{"sha": "2eaf6d00f54f2dc1a459c9430cd4ae2bcfc9417a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -1,3 +1,15 @@\n+2008-12-08  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/41177\n+\t* gfortran.h (struct symbol_attribute): New flag `class_pointer'.\n+\t* symbol.c (gfc_build_class_symbol): Set the new flag.\n+\t* resolve.c (update_compcall_arglist): Remove wrong check for\n+\tnon-scalar base-object.\n+\t(check_typebound_baseobject): Add the correct version here as well\n+\tas some 'not implemented' message check in the old case.\n+\t(resolve_typebound_procedure): Check that the passed-object dummy\n+\targument is scalar, non-pointer and non-allocatable as it should be.\n+\n 2009-12-08  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/40961"}, {"sha": "340e0149902675a7f5248106a40c44826d6ca894", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -654,6 +654,11 @@ typedef struct\n     dummy:1, result:1, assign:1, threadprivate:1, not_always_present:1,\n     implied_index:1, subref_array_pointer:1, proc_pointer:1;\n \n+  /* For CLASS containers, the pointer attribute is sometimes set internally\n+     even though it was not directly specified.  In this case, keep the\n+     \"real\" (original) value here.  */\n+  unsigned class_pointer:1;\n+\n   ENUM_BITFIELD (save_state) save:2;\n \n   unsigned data:1,\t\t/* Symbol is named in a DATA statement.  */"}, {"sha": "8d2be53b2cd19052f4d6d2f2fd257f29929866c8", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 41, "deletions": 8, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -4781,12 +4781,6 @@ update_compcall_arglist (gfc_expr* e)\n   if (!po)\n     return FAILURE;\n \n-  if (po->rank > 0)\n-    {\n-      gfc_error (\"Passed-object at %L must be scalar\", &e->where);\n-      return FAILURE;\n-    }\n-\n   if (tbp->nopass || e->value.compcall.ignore_pass)\n     {\n       gfc_free_expr (po);\n@@ -4889,6 +4883,22 @@ check_typebound_baseobject (gfc_expr* e)\n       return FAILURE;\n     }\n \n+  /* If the procedure called is NOPASS, the base object must be scalar.  */\n+  if (e->value.compcall.tbp->nopass && base->rank > 0)\n+    {\n+      gfc_error (\"Base object for NOPASS type-bound procedure call at %L must\"\n+\t\t \" be scalar\", &e->where);\n+      return FAILURE;\n+    }\n+\n+  /* FIXME: Remove once PR 41177 (this problem) is fixed completely.  */\n+  if (base->rank > 0)\n+    {\n+      gfc_error (\"Non-scalar base object at %L currently not implemented\",\n+\t\t &e->where);\n+      return FAILURE;\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -10038,8 +10048,11 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t  me_arg = proc->formal->sym;\n \t}\n \n-      /* Now check that the argument-type matches.  */\n+      /* Now check that the argument-type matches and the passed-object\n+\t dummy argument is generally fine.  */\n+\n       gcc_assert (me_arg);\n+\n       if (me_arg->ts.type != BT_CLASS)\n \t{\n \t  gfc_error (\"Non-polymorphic passed-object dummy argument of '%s'\"\n@@ -10055,7 +10068,27 @@ resolve_typebound_procedure (gfc_symtree* stree)\n \t\t     me_arg->name, &where, resolve_bindings_derived->name);\n \t  goto error;\n \t}\n-\n+  \n+      gcc_assert (me_arg->ts.type == BT_CLASS);\n+      if (me_arg->ts.u.derived->components->as\n+\t  && me_arg->ts.u.derived->components->as->rank > 0)\n+\t{\n+\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must be\"\n+\t\t     \" scalar\", proc->name, &where);\n+\t  goto error;\n+\t}\n+      if (me_arg->ts.u.derived->components->attr.allocatable)\n+\t{\n+\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must not\"\n+\t\t     \" be ALLOCATABLE\", proc->name, &where);\n+\t  goto error;\n+\t}\n+      if (me_arg->ts.u.derived->components->attr.class_pointer)\n+\t{\n+\t  gfc_error (\"Passed-object dummy argument of '%s' at %L must not\"\n+\t\t     \" be POINTER\", proc->name, &where);\n+\t  goto error;\n+\t}\n     }\n \n   /* If we are extending some type, check that we don't override a procedure"}, {"sha": "08477c4f577b42f91aeb68725e941f364448944b", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -4681,6 +4681,7 @@ gfc_build_class_symbol (gfc_typespec *ts, symbol_attribute *attr,\n       c->ts.type = BT_DERIVED;\n       c->attr.access = ACCESS_PRIVATE;\n       c->ts.u.derived = ts->u.derived;\n+      c->attr.class_pointer = attr->pointer;\n       c->attr.pointer = attr->pointer || attr->dummy;\n       c->attr.allocatable = attr->allocatable;\n       c->attr.dimension = attr->dimension;"}, {"sha": "cafd4671db8ae0a7fc473be98c015cf2b9444a20", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -1,3 +1,9 @@\n+2008-12-08  Daniel Kraft  <d@domob.eu>\n+\n+\tPR fortran/41177\n+\t* gfortran.dg/typebound_proc_4.f03: Remove check for wrong error.\n+\t* gfortran.dg/typebound_proc_13.f03: New test.\n+\n 2009-12-08  Olga Golovanevsky  <olga@il.ibm.com>\n \t    Jakub Jelinek <jakub@redhat.com>\t\n "}, {"sha": "6cb5e69e3e9409d29144b95387176b4636852499", "filename": "gcc/testsuite/gfortran.dg/typebound_call_4.f03", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_call_4.f03?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -37,10 +37,6 @@ SUBROUTINE test ()\n     CALL arr(1)%myobj%proc ()\n     WRITE (*,*) arr(2)%myobj%func ()\n \n-    ! Base-object must be scalar.\n-    CALL arr(:)%myobj%proc () ! { dg-error \"scalar\" }\n-    WRITE (*,*) arr(:)%myobj%func () ! { dg-error \"scalar\" }\n-\n     ! Can't CALL a function or take the result of a SUBROUTINE.\n     CALL arr(1)%myobj%func () ! { dg-error \"SUBROUTINE\" }\n     WRITE (*,*) arr(2)%myobj%proc () ! { dg-error \"FUNCTION\" }"}, {"sha": "3f978f28b45600ad0180fea7ccb456e63a003f78", "filename": "gcc/testsuite/gfortran.dg/typebound_proc_13.f03", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_13.f03", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_13.f03", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftypebound_proc_13.f03?ref=41a394bbf8d47ae58aad6b9068cd6f0f27cc2f2f", "patch": "@@ -0,0 +1,48 @@\n+! { dg-do compile }\n+\n+! PR fortran/41177\n+! Test for additional errors with type-bound procedure bindings.\n+! Namely that non-scalar base objects are rejected for TBP calls which are\n+! NOPASS, and that passed-object dummy arguments must be scalar, non-POINTER\n+! and non-ALLOCATABLE.\n+\n+MODULE m\n+  IMPLICIT NONE\n+\n+  TYPE t\n+  CONTAINS\n+    PROCEDURE, NOPASS :: myproc\n+  END TYPE t\n+\n+  TYPE t2\n+  CONTAINS\n+    PROCEDURE, PASS :: nonscalar ! { dg-error \"must be scalar\" }\n+    PROCEDURE, PASS :: is_pointer ! { dg-error \"must not be POINTER\" }\n+    PROCEDURE, PASS :: is_allocatable ! { dg-error \"must not be ALLOCATABLE\" }\n+  END TYPE t2\n+\n+CONTAINS\n+\n+  SUBROUTINE myproc ()\n+  END SUBROUTINE myproc\n+\n+  SUBROUTINE nonscalar (me)\n+    CLASS(t2), INTENT(IN) :: me(:)\n+  END SUBROUTINE nonscalar\n+\n+  SUBROUTINE is_pointer (me)\n+    CLASS(t2), POINTER, INTENT(IN) :: me\n+  END SUBROUTINE is_pointer\n+\n+  SUBROUTINE is_allocatable (me)\n+    CLASS(t2), ALLOCATABLE, INTENT(IN) :: me\n+  END SUBROUTINE is_allocatable\n+\n+  SUBROUTINE test ()\n+    TYPE(t) :: arr(2)\n+    CALL arr%myproc () ! { dg-error \"must be scalar\" }\n+  END SUBROUTINE test\n+\n+END MODULE m\n+\n+! { dg-final { cleanup-modules \"m\" } }"}]}