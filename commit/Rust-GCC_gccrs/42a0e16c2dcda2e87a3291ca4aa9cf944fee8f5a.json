{"sha": "42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJhMGUxNmMyZGNkYTJlODdhMzI5MWNhNGFhOWNmOTQ0ZmVlOGY1YQ==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-06T23:12:41Z"}, "committer": {"name": "Erik Edelmann", "email": "eedelman@gcc.gnu.org", "date": "2006-03-06T23:12:41Z"}, "message": "trans-array.c (gfc_trans_dealloc_allocated): New function.\n\nfortran/\n2005-03-06  Paul Thomas  <pault@gcc.gnu.org>\n            Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        * trans-array.c (gfc_trans_dealloc_allocated): New function.\n        (gfc_trans_deferred_array): Use it, instead of inline code.\n        * trans-array.h: Prototype for gfc_trans_dealloc_allocated().\n        * trans-expr.c (gfc_conv_function_call): Deallocate allocated\n        ALLOCATABLE, INTENT(OUT) arguments upon procedure entry.\n\n\ntestsuite/\n2005-03-06  Paul Thomas  <pault@gcc.gnu.org>\n            Erik Edelmann  <eedelman@gcc.gnu.org>\n\n        * gfortran.dg/allocatable_dummy_1.f90: Take into account that\n        INTENT(OUT) arguments shall be deallocated upon procedure entry.\n\n\nCo-Authored-By: Erik Edelmann <eedelman@gcc.gnu.org>\n\nFrom-SVN: r111795", "tree": {"sha": "14bd2a8f3c2db1490455660b4df051b8316fdbb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14bd2a8f3c2db1490455660b4df051b8316fdbb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/comments", "author": null, "committer": null, "parents": [{"sha": "c09a1bf1a26983051a572cf9d7e8bd9164e4588b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c09a1bf1a26983051a572cf9d7e8bd9164e4588b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c09a1bf1a26983051a572cf9d7e8bd9164e4588b"}], "stats": {"total": 88, "additions": 70, "deletions": 18}, "files": [{"sha": "a254807e40fbbd0c3ab06c798bca710f26aff725", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -1,3 +1,12 @@\n+2005-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+            Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\t* trans-array.c (gfc_trans_dealloc_allocated): New function.\n+\t(gfc_trans_deferred_array): Use it, instead of inline code.\n+\t* trans-array.h: Prototype for gfc_trans_dealloc_allocated().\n+\t* trans-expr.c (gfc_conv_function_call): Deallocate allocated\n+\tALLOCATABLE, INTENT(OUT) arguments upon procedure entry.\n+\n 2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26107"}, {"sha": "9f5337b093fe613f894973bfbd7a7a58e0ac7b1f", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 29, "deletions": 14, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -4297,6 +4297,34 @@ gfc_conv_array_parameter (gfc_se * se, gfc_expr * expr, gfc_ss * ss, int g77)\n }\n \n \n+/* Generate code to deallocate the symbol 'sym', if it is allocated.  */\n+\n+tree\n+gfc_trans_dealloc_allocated (gfc_symbol * sym)\n+{ \n+  tree tmp;\n+  tree descriptor;\n+  tree deallocate;\n+  stmtblock_t block;\n+\n+  gcc_assert (sym->attr.allocatable);\n+\n+  gfc_start_block (&block);\n+  descriptor = sym->backend_decl;\n+  deallocate = gfc_array_deallocate (descriptor, null_pointer_node);\n+\n+  tmp = gfc_conv_descriptor_data_get (descriptor);\n+  tmp = build2 (NE_EXPR, boolean_type_node, tmp,\n+                build_int_cst (TREE_TYPE (tmp), 0));\n+  tmp = build3_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  tmp = gfc_finish_block (&block);\n+\n+  return tmp;\n+}\n+\n+\n /* NULLIFY an allocatable/pointer array on function entry, free it on exit.  */\n \n tree\n@@ -4305,8 +4333,6 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   tree type;\n   tree tmp;\n   tree descriptor;\n-  tree deallocate;\n-  stmtblock_t block;\n   stmtblock_t fnblock;\n   locus loc;\n \n@@ -4359,18 +4385,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n   /* Allocatable arrays need to be freed when they go out of scope.  */\n   if (sym->attr.allocatable)\n     {\n-      gfc_start_block (&block);\n-\n-      /* Deallocate if still allocated at the end of the procedure.  */\n-      deallocate = gfc_array_deallocate (descriptor, null_pointer_node);\n-\n-      tmp = gfc_conv_descriptor_data_get (descriptor);\n-      tmp = build2 (NE_EXPR, boolean_type_node, tmp, \n-\t\t    build_int_cst (TREE_TYPE (tmp), 0));\n-      tmp = build3_v (COND_EXPR, tmp, deallocate, build_empty_stmt ());\n-      gfc_add_expr_to_block (&block, tmp);\n-\n-      tmp = gfc_finish_block (&block);\n+      tmp = gfc_trans_dealloc_allocated (sym);\n       gfc_add_expr_to_block (&fnblock, tmp);\n     }\n "}, {"sha": "fed1bf0a4872fdc8d8af2572a4a28564683758ad", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -42,6 +42,8 @@ tree gfc_trans_auto_array_allocation (tree, gfc_symbol *, tree);\n tree gfc_trans_dummy_array_bias (gfc_symbol *, tree, tree);\n /* Generate entry and exit code for g77 calling convention arrays.  */\n tree gfc_trans_g77_array (gfc_symbol *, tree);\n+/* Generate code to deallocate the symbol 'sym', if it is allocated.  */\n+tree gfc_trans_dealloc_allocated (gfc_symbol * sym);\n /* Add initialization for deferred arrays.  */\n tree gfc_trans_deferred_array (gfc_symbol *, tree);\n /* Generate an initializer for a static pointer or allocatable array.  */"}, {"sha": "8c63b11b1a510bb19378621023abcc3fbe85a532", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -1914,6 +1914,16 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\tgfc_conv_aliased_arg (&parmse, arg->expr, f);\n \t      else\n \t        gfc_conv_array_parameter (&parmse, arg->expr, argss, f);\n+\n+              /* If an ALLOCATABLE dummy argument has INTENT(OUT) and is \n+                 allocated on entry, it must be deallocated.  */\n+              if (formal && formal->sym->attr.allocatable\n+                  && formal->sym->attr.intent == INTENT_OUT)\n+                {\n+                  tmp = gfc_trans_dealloc_allocated (arg->expr->symtree->n.sym);\n+                  gfc_add_expr_to_block (&se->pre, tmp);\n+                }\n+\n \t    } \n \t}\n "}, {"sha": "ea84f843869b6033bbeac2f8195ab89a242417dc", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -1,3 +1,9 @@\n+2005-03-06  Paul Thomas  <pault@gcc.gnu.org>\n+            Erik Edelmann  <eedelman@gcc.gnu.org>\n+\n+\t* gfortran.dg/allocatable_dummy_1.f90: Take into account that\n+\tINTENT(OUT) arguments shall be deallocated upon procedure entry.\n+\n 2006-03-06  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/26107"}, {"sha": "db65d71e6d83615112487252b2f2d4e2c4c97513", "filename": "gcc/testsuite/gfortran.dg/allocatable_dummy_1.f90", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fallocatable_dummy_1.f90?ref=42a0e16c2dcda2e87a3291ca4aa9cf944fee8f5a", "patch": "@@ -4,29 +4,39 @@ program alloc_dummy\n \n     implicit none\n     integer, allocatable :: a(:)\n+    integer, allocatable :: b(:)\n \n     call init(a)\n     if (.NOT.allocated(a)) call abort()\n     if (.NOT.all(a == [ 1, 2, 3 ])) call abort()\n \n+    call useit(a, b)\n+    if (.NOT.all(b == [ 1, 2, 3 ])) call abort()\n+\n     call kill(a)\n     if (allocated(a)) call abort()\n \n+    call kill(b)\n+    if (allocated(b)) call abort()\n \n contains\n \n     subroutine init(x)\n         integer, allocatable, intent(out) :: x(:)\n-\n         allocate(x(3))\n         x = [ 1, 2, 3 ]\n     end subroutine init\n \n-    \n+    subroutine useit(x, y)\n+        integer, allocatable, intent(in)  :: x(:)\n+        integer, allocatable, intent(out) :: y(:)\n+        if (allocated(y)) call abort()\n+        allocate (y(3))\n+        y = x\n+    end subroutine useit\n+\n     subroutine kill(x)\n         integer, allocatable, intent(out) :: x(:)\n-\n-        deallocate(x)\n     end subroutine kill\n \n end program alloc_dummy"}]}