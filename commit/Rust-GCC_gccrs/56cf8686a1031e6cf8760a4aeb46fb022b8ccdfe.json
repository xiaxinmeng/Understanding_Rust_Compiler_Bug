{"sha": "56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZjZjg2ODZhMTAzMWU2Y2Y4NzYwYTRhZWI0NmZiMDIyYjhjY2RmZQ==", "commit": {"author": {"name": "Sebastian Pop", "email": "pop@cri.ensmp.fr", "date": "2004-07-13T16:43:32Z"}, "committer": {"name": "Sebastian Pop", "email": "spop@gcc.gnu.org", "date": "2004-07-13T16:43:32Z"}, "message": "Makefile.in (OBJS-common): Add tree-data-ref.o.\n\n\t* Makefile.in (OBJS-common): Add tree-data-ref.o.\n\t(tree-scalar-evolution.o): Add missing dependences on tree-pass.h flags.h.\n\t(tree-data-ref.o): New rule.\n\t* lambda.h: New file.\n\t* tree-data-ref.c: New file.\n\t* tree-data-ref.h: New file.\n\t* tree.c (int_cst_value, tree_fold_gcd): New functions.\n\t* tree.h (int_cst_value, tree_fold_gcd): Declared here.\n\nFrom-SVN: r84630", "tree": {"sha": "1101b2fcf7a39280f30b07e99c538a7e41c97874", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1101b2fcf7a39280f30b07e99c538a7e41c97874"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/comments", "author": null, "committer": {"login": "sebpop", "id": 568397, "node_id": "MDQ6VXNlcjU2ODM5Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/568397?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sebpop", "html_url": "https://github.com/sebpop", "followers_url": "https://api.github.com/users/sebpop/followers", "following_url": "https://api.github.com/users/sebpop/following{/other_user}", "gists_url": "https://api.github.com/users/sebpop/gists{/gist_id}", "starred_url": "https://api.github.com/users/sebpop/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sebpop/subscriptions", "organizations_url": "https://api.github.com/users/sebpop/orgs", "repos_url": "https://api.github.com/users/sebpop/repos", "events_url": "https://api.github.com/users/sebpop/events{/privacy}", "received_events_url": "https://api.github.com/users/sebpop/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39fb05d07106a838f2ea758b8ae10f9c94d2a515", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39fb05d07106a838f2ea758b8ae10f9c94d2a515", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39fb05d07106a838f2ea758b8ae10f9c94d2a515"}], "stats": {"total": 2201, "additions": 2199, "deletions": 2}, "files": [{"sha": "5e87e5e3907d1b03a9f67285c72c8d87a53328a4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -1,3 +1,14 @@\n+2004-07-13  Sebastian Pop  <pop@cri.ensmp.fr>\n+\n+\t* Makefile.in (OBJS-common): Add tree-data-ref.o.\n+\t(tree-scalar-evolution.o): Add missing dependences on tree-pass.h flags.h.\n+\t(tree-data-ref.o): New rule.\n+\t* lambda.h: New file.\n+\t* tree-data-ref.c: New file.\n+\t* tree-data-ref.h: New file.\n+\t* tree.c (int_cst_value, tree_fold_gcd): New functions.\n+\t* tree.h (int_cst_value, tree_fold_gcd): Declared here.\n+\t\n 2004-07-13  Eric Botcazou  <ebotcazou@libertysurf.fr>\n \n \tPR target/13926"}, {"sha": "68b7252ded9bf6ae3fc18e7e5f36bcaab9fb681c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -888,7 +888,7 @@ C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n # Language-independent object files.\n \n OBJS-common = \\\n- tree-chrec.o tree-scalar-evolution.o\t\t\t\t\t   \\\n+ tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n  tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n  tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o tree-vn.o             \\\n@@ -1722,7 +1722,11 @@ tree-chrec.o: tree-chrec.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n tree-scalar-evolution.o: tree-scalar-evolution.c $(CONFIG_H) $(SYSTEM_H) \\\n    coretypes.h $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) diagnostic.h $(TREE_FLOW_H) $(TREE_DUMP_H) \\\n-   $(TIMEVAR_H) cfgloop.h $(SCEV_H)\n+   $(TIMEVAR_H) cfgloop.h $(SCEV_H) tree-pass.h flags.h\n+tree-data-ref.o: tree-data-ref.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(BASIC_BLOCK_H) diagnostic.h \\\n+   $(TREE_FLOW_H) $(TREE_DUMP_H) $(TIMEVAR_H) cfgloop.h \\\n+   tree-data-ref.h $(SCEV_H) tree-pass.h lambda.h\n tree-gimple.o : tree-gimple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n \t$(RTL_H) $(TREE_GIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\"}, {"sha": "60ed8accbf2cbae7110fbba3417321f6362714e8", "filename": "gcc/lambda.h", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Flambda.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Flambda.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda.h?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -0,0 +1,57 @@\n+/* Lambda matrix interface.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Daniel Berlin <dberlin@dberlin.org>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+ \n+#ifndef LAMBDA_H\n+#define LAMBDA_H\n+\n+typedef int *lambda_vector;\n+\n+/* Allocate a new vector of given SIZE.  */\n+\n+static inline lambda_vector\n+lambda_vector_new (int size)\n+{\n+  return ggc_alloc_cleared (size * sizeof(int));\n+}\n+\n+/* Clear out vector VEC1 of length SIZE.  */\n+\n+static inline void\n+lambda_vector_clear (lambda_vector vec1, int size)\n+{\n+  memset (vec1, 0, size * sizeof (int));\n+}\n+\n+/* Print out a vector VEC of length N to OUTFILE.  */\n+\n+static inline void\n+print_lambda_vector (FILE * outfile, lambda_vector vector, int n)\n+{\n+  int i;\n+\n+  for (i = 0; i < n; i++)\n+    fprintf (outfile, \"%3d \", vector[i]);\n+  fprintf (outfile, \"\\n\");\n+}\n+\n+\n+#endif /* LAMBDA_H  */\n+"}, {"sha": "1f14bcb011d32685fbdca7361bb8b4b5204d3776", "filename": "gcc/tree-data-ref.c", "status": "added", "additions": 1874, "deletions": 0, "changes": 1874, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -0,0 +1,1874 @@\n+/* Data references and dependences detectors.\n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+/* This pass walks a given loop structure searching for array\n+   references.  The information about the array accesses is recorded\n+   in DATA_REFERENCE structures. \n+   \n+   The basic test for determining the dependences is: \n+   given two access functions chrec1 and chrec2 to a same array, and \n+   x and y two vectors from the iteration domain, the same element of \n+   the array is accessed twice at iterations x and y if and only if:\n+   |             chrec1 (x) == chrec2 (y).\n+   \n+   The goals of this analysis are:\n+   \n+   - to determine the independence: the relation between two\n+     independent accesses is qualified with the chrec_known (this\n+     information allows a loop parallelization),\n+     \n+   - when two data references access the same data, to qualify the\n+     dependence relation with classic dependence representations:\n+     \n+       - distance vectors\n+       - direction vectors\n+       - loop carried level dependence\n+       - polyhedron dependence\n+     or with the chains of recurrences based representation,\n+     \n+   - to define a knowledge base for storing the data dependeces \n+     information,\n+     \n+   - to define an interface to access this data.\n+   \n+   \n+   Definitions:\n+   \n+   - subscript: given two array accesses a subscript is the tuple\n+   composed of the access functions for a given dimension.  Example:\n+   Given A[f1][f2][f3] and B[g1][g2][g3], there are three subscripts:\n+   (f1, g1), (f2, g2), (f3, g3).\n+\n+   - Diophantine equation: an equation whose coefficients and\n+   solutions are integer constants, for example the equation \n+   |   3*x + 2*y = 1\n+   has an integer solution x = 1 and y = -1.\n+     \n+   References:\n+   \n+   - \"Advanced Compilation for High Performance Computing\" by Randy\n+   Allen and Ken Kennedy.\n+   http://citeseer.ist.psu.edu/goff91practical.html \n+   \n+   - \"Loop Transformations for Restructuring Compilers - The Foundations\" \n+   by Utpal Banerjee.\n+\n+   \n+*/\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"errors.h\"\n+#include \"ggc.h\"\n+#include \"tree.h\"\n+\n+/* These RTL headers are needed for basic-block.h.  */\n+#include \"rtl.h\"\n+#include \"basic-block.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"tree-chrec.h\"\n+#include \"tree-data-ref.h\"\n+#include \"tree-scalar-evolution.h\"\n+#include \"tree-pass.h\"\n+#include \"lambda.h\"\n+\n+static unsigned int data_ref_id = 0;\n+\n+\f\n+\n+/* Returns true iff A divides B.  */\n+\n+static inline bool \n+tree_fold_divides_p (tree type, \n+\t\t     tree a, \n+\t\t     tree b)\n+{\n+  if (integer_onep (a))\n+    return true;\n+  \n+  /* Determines whether (A == gcd (A, B)).  */\n+  return integer_zerop \n+    (fold (build (MINUS_EXPR, type, a, tree_fold_gcd (a, b))));\n+}\n+\n+/* Bezout: Let A1 and A2 be two integers; there exist two integers U11\n+   and U12 such that, \n+   \n+   |  U11 * A1 + U12 * A2 = gcd (A1, A2).\n+   \n+   This function computes the greatest common divisor using the\n+   Blankinship algorithm.  The gcd is returned, and the coefficients\n+   of the unimodular matrix U are (U11, U12, U21, U22) such that, \n+\n+   |  U.A = S\n+   \n+   |  (U11 U12) (A1) = (gcd)\n+   |  (U21 U22) (A2)   (0)\n+   \n+   FIXME: Use lambda_..._hermite for implementing this function.\n+*/\n+\n+static tree \n+tree_fold_bezout (tree a1, \n+\t\t  tree a2,\n+\t\t  tree *u11, tree *u12,\n+\t\t  tree *u21, tree *u22)\n+{\n+  tree s1, s2;\n+  \n+  /* Initialize S with the coefficients of A.  */\n+  s1 = a1;\n+  s2 = a2;\n+  \n+  /* Initialize the U matrix */\n+  *u11 = integer_one_node; \n+  *u12 = integer_zero_node;\n+  *u21 = integer_zero_node;\n+  *u22 = integer_one_node;\n+  \n+  if (integer_zerop (a1)\n+      || integer_zerop (a2))\n+    return integer_zero_node;\n+  \n+  while (!integer_zerop (s2))\n+    {\n+      int sign;\n+      tree z, zu21, zu22, zs2;\n+      \n+      sign = tree_int_cst_sgn (s1) * tree_int_cst_sgn (s2);\n+      z = fold (build (FLOOR_DIV_EXPR, integer_type_node, \n+\t\t       fold (build1 (ABS_EXPR, integer_type_node, s1)), \n+\t\t       fold (build1 (ABS_EXPR, integer_type_node, s2))));\n+      zu21 = fold (build (MULT_EXPR, integer_type_node, z, *u21));\n+      zu22 = fold (build (MULT_EXPR, integer_type_node, z, *u22));\n+      zs2 = fold (build (MULT_EXPR, integer_type_node, z, s2));\n+      \n+      /* row1 -= z * row2.  */\n+      if (sign < 0)\n+\t{\n+\t  *u11 = fold (build (PLUS_EXPR, integer_type_node, *u11, zu21));\n+\t  *u12 = fold (build (PLUS_EXPR, integer_type_node, *u12, zu22));\n+\t  s1 = fold (build (PLUS_EXPR, integer_type_node, s1, zs2));\n+\t}\n+      else if (sign > 0)\n+\t{\n+\t  *u11 = fold (build (MINUS_EXPR, integer_type_node, *u11, zu21));\n+\t  *u12 = fold (build (MINUS_EXPR, integer_type_node, *u12, zu22));\n+\t  s1 = fold (build (MINUS_EXPR, integer_type_node, s1, zs2));\n+\t}\n+      else\n+\t/* Should not happen.  */\n+\tabort ();\n+      \n+      /* Interchange row1 and row2.  */\n+      {\n+\ttree flip;\n+\t\n+\tflip = *u11;\n+\t*u11 = *u21;\n+\t*u21 = flip;\n+\n+\tflip = *u12;\n+\t*u12 = *u22;\n+\t*u22 = flip;\n+\t\n+\tflip = s1;\n+\ts1 = s2;\n+\ts2 = flip;\n+      }\n+    }\n+  \n+  if (tree_int_cst_sgn (s1) < 0)\n+    {\n+      *u11 = fold (build (MULT_EXPR, integer_type_node, *u11, \n+\t\t\t  integer_minus_one_node));\n+      *u12 = fold (build (MULT_EXPR, integer_type_node, *u12, \n+\t\t\t\t integer_minus_one_node));\n+      s1 = fold (build (MULT_EXPR, integer_type_node, s1, integer_minus_one_node));\n+    }\n+  \n+  return s1;\n+}\n+\n+\f\n+\n+/* Dump into FILE all the data references from DATAREFS.  */ \n+\n+void \n+dump_data_references (FILE *file, \n+\t\t      varray_type datarefs)\n+{\n+  unsigned int i;\n+  \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (datarefs); i++)\n+    dump_data_reference (file, VARRAY_GENERIC_PTR (datarefs, i));\n+}\n+\n+/* Dump into FILE all the dependence relations from DDR.  */ \n+\n+void \n+dump_data_dependence_relations (FILE *file, \n+\t\t\t\tvarray_type ddr)\n+{\n+  unsigned int i;\n+  \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (ddr); i++)\n+    dump_data_dependence_relation (file, VARRAY_GENERIC_PTR (ddr, i));\n+}\n+\n+/* Dump function for a DATA_REFERENCE structure.  */\n+\n+void \n+dump_data_reference (FILE *outf, \n+\t\t     struct data_reference *dr)\n+{\n+  unsigned int i;\n+  \n+  fprintf (outf, \"(Data Ref %d: \\n  stmt: \", DR_ID (dr));\n+  print_generic_stmt (outf, DR_STMT (dr), 0);\n+  fprintf (outf, \"  ref: \");\n+  print_generic_stmt (outf, DR_REF (dr), 0);\n+  fprintf (outf, \"  base_name: \");\n+  print_generic_stmt (outf, DR_BASE_NAME (dr), 0);\n+  \n+  for (i = 0; i < DR_NUM_DIMENSIONS (dr); i++)\n+    {\n+      fprintf (outf, \"  Access function %d: \", i);\n+      print_generic_stmt (outf, DR_ACCESS_FN (dr, i), 0);\n+    }\n+  fprintf (outf, \")\\n\");\n+}\n+\n+/* Dump function for a DATA_DEPENDENCE_RELATION structure.  */\n+\n+void \n+dump_data_dependence_relation (FILE *outf, \n+\t\t\t       struct data_dependence_relation *ddr)\n+{\n+  unsigned int i;\n+  struct data_reference *dra, *drb;\n+  \n+  dra = DDR_A (ddr);\n+  drb = DDR_B (ddr);\n+  \n+  if (dra && drb)\n+    fprintf (outf, \"(Data Dep (A = %d, B = %d):\", DR_ID (dra), DR_ID (drb));\n+  else\n+    fprintf (outf, \"(Data Dep:\");\n+\n+  if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n+    fprintf (outf, \"    (don't know)\\n\");\n+  \n+  else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+    fprintf (outf, \"    (no dependence)\\n\");\n+  \n+  else\n+    {\n+      for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+\t{\n+\t  tree chrec;\n+\t  struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+\t  \n+\t  fprintf (outf, \"\\n (subscript %d:\\n\", i);\n+\t  fprintf (outf, \"  access_fn_A: \");\n+\t  print_generic_stmt (outf, DR_ACCESS_FN (dra, i), 0);\n+\t  fprintf (outf, \"  access_fn_B: \");\n+\t  print_generic_stmt (outf, DR_ACCESS_FN (drb, i), 0);\n+\t  \n+\t  chrec = SUB_CONFLICTS_IN_A (subscript);\n+\t  fprintf (outf, \"  iterations_that_access_an_element_twice_in_A: \");\n+\t  print_generic_stmt (outf, chrec, 0);\n+\t  if (chrec == chrec_known)\n+\t    fprintf (outf, \"    (no dependence)\\n\");\n+\t  else if (chrec_contains_undetermined (chrec))\n+\t    fprintf (outf, \"    (don't know)\\n\");\n+\t  else\n+\t    {\n+\t      tree last_iteration = SUB_LAST_CONFLICT_IN_A (subscript);\n+\t      fprintf (outf, \"  last_iteration_that_access_an_element_twice_in_A: \");\n+\t      print_generic_stmt (outf, last_iteration, 0);\n+\t    }\n+\t  \n+\t  chrec = SUB_CONFLICTS_IN_B (subscript);\n+\t  fprintf (outf, \"  iterations_that_access_an_element_twice_in_B: \");\n+\t  print_generic_stmt (outf, chrec, 0);\n+\t  if (chrec == chrec_known)\n+\t    fprintf (outf, \"    (no dependence)\\n\");\n+\t  else if (chrec_contains_undetermined (chrec))\n+\t    fprintf (outf, \"    (don't know)\\n\");\n+\t  else\n+\t    {\n+\t      tree last_iteration = SUB_LAST_CONFLICT_IN_B (subscript);\n+\t      fprintf (outf, \"  last_iteration_that_access_an_element_twice_in_B: \");\n+\t      print_generic_stmt (outf, last_iteration, 0);\n+\t    }\n+      \n+\t  fprintf (outf, \" )\\n\");\n+\t}\n+  \n+      fprintf (outf, \" (Distance Vector: \\n\");\n+      for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+\t{\n+\t  struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+      \n+\t  fprintf (outf, \"(\");\n+\t  print_generic_stmt (outf, SUB_DISTANCE (subscript), 0);\n+\t  fprintf (outf, \")\\n\");\n+\t}\n+      fprintf (outf, \" )\\n\");\n+    }\n+\n+  fprintf (outf, \")\\n\");\n+}\n+\n+\n+\n+/* Dump function for a DATA_DEPENDENCE_DIRECTION structure.  */\n+\n+void\n+dump_data_dependence_direction (FILE *file, \n+\t\t\t\tenum data_dependence_direction dir)\n+{\n+  switch (dir)\n+    {\n+    case dir_positive: \n+      fprintf (file, \"+\");\n+      break;\n+      \n+    case dir_negative:\n+      fprintf (file, \"-\");\n+      break;\n+      \n+    case dir_equal:\n+      fprintf (file, \"=\");\n+      break;\n+      \n+    case dir_positive_or_negative:\n+      fprintf (file, \"+-\");\n+      break;\n+      \n+    case dir_positive_or_equal: \n+      fprintf (file, \"+=\");\n+      break;\n+      \n+    case dir_negative_or_equal: \n+      fprintf (file, \"-=\");\n+      break;\n+      \n+    case dir_star: \n+      fprintf (file, \"*\"); \n+      break;\n+      \n+    default: \n+      break;\n+    }\n+}\n+\n+\f\n+\n+/* Given an ARRAY_REF node REF, records its access functions.\n+   Example: given A[i][3], record in ACCESS_FNS the opnd1 function,\n+   ie. the constant \"3\", then recursively call the function on opnd0,\n+   ie. the ARRAY_REF \"A[i]\".  The function returns the base name:\n+   \"A\".  */\n+\n+static tree\n+analyze_array_indexes (struct loop *loop,\n+\t\t       varray_type access_fns, \n+\t\t       tree ref)\n+{\n+  tree opnd0, opnd1;\n+  tree access_fn;\n+  \n+  opnd0 = TREE_OPERAND (ref, 0);\n+  opnd1 = TREE_OPERAND (ref, 1);\n+  \n+  /* The detection of the evolution function for this data access is\n+     postponed until the dependence test.  This lazy strategy avoids\n+     the computation of access functions that are of no interest for\n+     the optimizers.  */\n+  access_fn = instantiate_parameters \n+    (loop, analyze_scalar_evolution (loop, opnd1));\n+  \n+  VARRAY_PUSH_TREE (access_fns, access_fn);\n+  \n+  /* Recursively record other array access functions.  */\n+  if (TREE_CODE (opnd0) == ARRAY_REF)\n+    return analyze_array_indexes (loop, access_fns, opnd0);\n+  \n+  /* Return the base name of the data access.  */\n+  else\n+    return opnd0;\n+}\n+\n+/* For a data reference REF contained in the statemet STMT, initialize\n+   a DATA_REFERENCE structure, and return it.  IS_READ flag has to be\n+   set to true when REF is in the right hand side of an\n+   assignment.  */\n+\n+struct data_reference *\n+analyze_array (tree stmt, tree ref, bool is_read)\n+{\n+  struct data_reference *res;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(analyze_array \\n\");\n+      fprintf (dump_file, \"  (ref = \");\n+      print_generic_stmt (dump_file, ref, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  res = ggc_alloc (sizeof (struct data_reference));\n+  \n+  DR_ID (res) = data_ref_id++;\n+  DR_STMT (res) = stmt;\n+  DR_REF (res) = ref;\n+  VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 3, \"access_fns\");\n+  DR_BASE_NAME (res) = analyze_array_indexes \n+    (loop_containing_stmt (stmt), DR_ACCESS_FNS (res), ref);\n+  DR_IS_READ (res) = is_read;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+  \n+  return res;\n+}\n+\n+/* For a data reference REF contained in the statemet STMT, initialize\n+   a DATA_REFERENCE structure, and return it.  */\n+\n+struct data_reference *\n+init_data_ref (tree stmt, \n+\t       tree ref,\n+\t       tree base,\n+\t       tree access_fn)\n+{\n+  struct data_reference *res;\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(init_data_ref \\n\");\n+      fprintf (dump_file, \"  (ref = \");\n+      print_generic_stmt (dump_file, ref, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  res = ggc_alloc (sizeof (struct data_reference));\n+  \n+  DR_ID (res) = data_ref_id++;\n+  DR_STMT (res) = stmt;\n+  DR_REF (res) = ref;\n+  VARRAY_TREE_INIT (DR_ACCESS_FNS (res), 5, \"access_fns\");\n+  DR_BASE_NAME (res) = base;\n+  VARRAY_PUSH_TREE (DR_ACCESS_FNS (res), access_fn);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+  \n+  return res;\n+}\n+\n+\f\n+\n+/* When there exists a dependence relation, determine its distance\n+   vector.  */\n+\n+static void\n+compute_distance_vector (struct data_dependence_relation *ddr)\n+{\n+  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+    {\n+      unsigned int i;\n+      \n+      for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+ \t{\n+ \t  tree conflicts_a, conflicts_b, difference;\n+ \t  struct subscript *subscript;\n+ \t  \n+ \t  subscript = DDR_SUBSCRIPT (ddr, i);\n+ \t  conflicts_a = SUB_CONFLICTS_IN_A (subscript);\n+ \t  conflicts_b = SUB_CONFLICTS_IN_B (subscript);\n+ \t  difference = chrec_fold_minus \n+\t    (integer_type_node, conflicts_b, conflicts_a);\n+ \t  \n+ \t  if (evolution_function_is_constant_p (difference))\n+ \t    SUB_DISTANCE (subscript) = difference;\n+ \t  \n+ \t  else\n+ \t    SUB_DISTANCE (subscript) = chrec_dont_know;\n+ \t}\n+    }\n+}\n+\n+/* Initialize a ddr.  */\n+\n+struct data_dependence_relation *\n+initialize_data_dependence_relation (struct data_reference *a, \n+\t\t\t\t     struct data_reference *b)\n+{\n+  struct data_dependence_relation *res;\n+  \n+  res = ggc_alloc (sizeof (struct data_dependence_relation));\n+  DDR_A (res) = a;\n+  DDR_B (res) = b;\n+\n+  if (a == NULL || b == NULL \n+      || DR_BASE_NAME (a) == NULL_TREE\n+      || DR_BASE_NAME (b) == NULL_TREE)\n+    DDR_ARE_DEPENDENT (res) = chrec_dont_know;    \n+\n+  /* When the dimensions of A and B differ, we directly initialize\n+     the relation to \"there is no dependence\": chrec_known.  */\n+  else if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n+\t   || array_base_name_differ_p (a, b))\n+    DDR_ARE_DEPENDENT (res) = chrec_known;\n+  \n+  else\n+    {\n+      unsigned int i;\n+      DDR_ARE_DEPENDENT (res) = NULL_TREE;\n+      DDR_SUBSCRIPTS_VECTOR_INIT (res, DR_NUM_DIMENSIONS (a));\n+      \n+      for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+\t{\n+\t  struct subscript *subscript;\n+\t  \n+\t  subscript = ggc_alloc (sizeof (struct subscript));\n+\t  SUB_CONFLICTS_IN_A (subscript) = chrec_dont_know;\n+\t  SUB_CONFLICTS_IN_B (subscript) = chrec_dont_know;\n+\t  SUB_LAST_CONFLICT_IN_A (subscript) = chrec_dont_know;\n+\t  SUB_LAST_CONFLICT_IN_B (subscript) = chrec_dont_know;\n+\t  SUB_DISTANCE (subscript) = chrec_dont_know;\n+\t  SUB_DIRECTION (subscript) = dir_star;\n+\t  VARRAY_PUSH_GENERIC_PTR (DDR_SUBSCRIPTS (res), subscript);\n+\t}\n+    }\n+  \n+  return res;\n+}\n+\n+/* Set DDR_ARE_DEPENDENT to CHREC and finalize the subscript overlap\n+   description.  */\n+\n+static inline void\n+finalize_ddr_dependent (struct data_dependence_relation *ddr, \n+\t\t\ttree chrec)\n+{\n+  DDR_ARE_DEPENDENT (ddr) = chrec;  \n+  varray_clear (DDR_SUBSCRIPTS (ddr));\n+}\n+\n+\f\n+\n+/* This section contains the classic Banerjee tests.  */\n+\n+/* Returns true iff CHREC_A and CHREC_B are not dependent on any index\n+   variables, i.e., if the ZIV (Zero Index Variable) test is true.  */\n+\n+static inline bool\n+ziv_subscript_p (tree chrec_a, \n+\t\t tree chrec_b)\n+{\n+  return (evolution_function_is_constant_p (chrec_a)\n+\t  && evolution_function_is_constant_p (chrec_b));\n+}\n+\n+/* Returns true iff CHREC_A and CHREC_B are dependent on an index\n+   variable, i.e., if the SIV (Single Index Variable) test is true.  */\n+\n+static bool\n+siv_subscript_p (tree chrec_a,\n+\t\t tree chrec_b)\n+{\n+  if ((evolution_function_is_constant_p (chrec_a)\n+       && evolution_function_is_univariate_p (chrec_b))\n+      || (evolution_function_is_constant_p (chrec_b)\n+\t  && evolution_function_is_univariate_p (chrec_a)))\n+    return true;\n+  \n+  if (evolution_function_is_univariate_p (chrec_a)\n+      && evolution_function_is_univariate_p (chrec_b))\n+    {\n+      switch (TREE_CODE (chrec_a))\n+\t{\n+\tcase POLYNOMIAL_CHREC:\n+\t  switch (TREE_CODE (chrec_b))\n+\t    {\n+\t    case POLYNOMIAL_CHREC:\n+\t      if (CHREC_VARIABLE (chrec_a) != CHREC_VARIABLE (chrec_b))\n+\t\treturn false;\n+\t      \n+\t    default:\n+\t      return true;\n+\t    }\n+\t  \n+\tdefault:\n+\t  return true;\n+\t}\n+    }\n+  \n+  return false;\n+}\n+\n+/* Analyze a ZIV (Zero Index Variable) subscript.  *OVERLAPS_A and\n+   *OVERLAPS_B are initialized to the functions that describe the\n+   relation between the elements accessed twice by CHREC_A and\n+   CHREC_B.  For k >= 0, the following property is verified:\n+\n+   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+\n+static void \n+analyze_ziv_subscript (tree chrec_a, \n+\t\t       tree chrec_b, \n+\t\t       tree *overlaps_a,\n+\t\t       tree *overlaps_b)\n+{\n+  tree difference;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(analyze_ziv_subscript \\n\");\n+  \n+  difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n+  \n+  switch (TREE_CODE (difference))\n+    {\n+    case INTEGER_CST:\n+      if (integer_zerop (difference))\n+\t{\n+\t  /* The difference is equal to zero: the accessed index\n+\t     overlaps for each iteration in the loop.  */\n+\t  *overlaps_a = integer_zero_node;\n+\t  *overlaps_b = integer_zero_node;\n+\t}\n+      else\n+\t{\n+\t  /* The accesses do not overlap.  */\n+\t  *overlaps_a = chrec_known;\n+\t  *overlaps_b = chrec_known;\t  \n+\t}\n+      break;\n+      \n+    default:\n+      /* We're not sure whether the indexes overlap.  For the moment, \n+\t conservatively answer \"don't know\".  */\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\t  \n+      break;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Analyze a SIV (Single Index Variable) subscript where CHREC_A is a\n+   constant, and CHREC_B is an affine function.  *OVERLAPS_A and\n+   *OVERLAPS_B are initialized to the functions that describe the\n+   relation between the elements accessed twice by CHREC_A and\n+   CHREC_B.  For k >= 0, the following property is verified:\n+\n+   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+\n+static void\n+analyze_siv_subscript_cst_affine (tree chrec_a, \n+\t\t\t\t  tree chrec_b,\n+\t\t\t\t  tree *overlaps_a, \n+\t\t\t\t  tree *overlaps_b)\n+{\n+  bool value0, value1, value2;\n+  tree difference = chrec_fold_minus \n+    (integer_type_node, CHREC_LEFT (chrec_b), chrec_a);\n+  \n+  if (!chrec_is_positive (initial_condition (difference), &value0))\n+    {\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+      return;\n+    }\n+  else\n+    {\n+      if (value0 == false)\n+\t{\n+\t  if (!chrec_is_positive (CHREC_RIGHT (chrec_b), &value1))\n+\t    {\n+\t      *overlaps_a = chrec_dont_know;\n+\t      *overlaps_b = chrec_dont_know;      \n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (value1 == true)\n+\t\t{\n+\t\t  /* Example:  \n+\t\t     chrec_a = 12\n+\t\t     chrec_b = {10, +, 1}\n+\t\t  */\n+\t\t  \n+\t\t  if (tree_fold_divides_p \n+\t\t      (integer_type_node, CHREC_RIGHT (chrec_b), difference))\n+\t\t    {\n+\t\t      *overlaps_a = integer_zero_node;\n+\t\t      *overlaps_b = fold \n+\t\t\t(build (EXACT_DIV_EXPR, integer_type_node, \n+\t\t\t\tfold (build1 (ABS_EXPR, integer_type_node, difference)), \n+\t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      return;\n+\t\t    }\n+\t\t  \n+\t\t  /* When the step does not divides the difference, there are\n+\t\t     no overlaps.  */\n+\t\t  else\n+\t\t    {\n+\t\t      *overlaps_a = chrec_known;\n+\t\t      *overlaps_b = chrec_known;      \n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      \n+\t      else\n+\t\t{\n+\t\t  /* Example:  \n+\t\t     chrec_a = 12\n+\t\t     chrec_b = {10, +, -1}\n+\t\t     \n+\t\t     In this case, chrec_a will not overlap with chrec_b.  */\n+\t\t  *overlaps_a = chrec_known;\n+\t\t  *overlaps_b = chrec_known;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+      else \n+\t{\n+\t  if (!chrec_is_positive (CHREC_RIGHT (chrec_b), &value2))\n+\t    {\n+\t      *overlaps_a = chrec_dont_know;\n+\t      *overlaps_b = chrec_dont_know;      \n+\t      return;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (value2 == false)\n+\t\t{\n+\t\t  /* Example:  \n+\t\t     chrec_a = 3\n+\t\t     chrec_b = {10, +, -1}\n+\t\t  */\n+\t\t  if (tree_fold_divides_p \n+\t\t      (integer_type_node, CHREC_RIGHT (chrec_b), difference))\n+\t\t    {\n+\t\t      *overlaps_a = integer_zero_node;\n+\t\t      *overlaps_b = fold \n+\t\t\t(build (EXACT_DIV_EXPR, integer_type_node, difference, \n+\t\t\t\tCHREC_RIGHT (chrec_b)));\n+\t\t      return;\n+\t\t    }\n+\t\t  \n+\t\t  /* When the step does not divides the difference, there\n+\t\t     are no overlaps.  */\n+\t\t  else\n+\t\t    {\n+\t\t      *overlaps_a = chrec_known;\n+\t\t      *overlaps_b = chrec_known;      \n+\t\t      return;\n+\t\t    }\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Example:  \n+\t\t     chrec_a = 3  \n+\t\t     chrec_b = {4, +, 1}\n+\t\t \n+\t\t     In this case, chrec_a will not overlap with chrec_b.  */\n+\t\t  *overlaps_a = chrec_known;\n+\t\t  *overlaps_b = chrec_known;\n+\t\t  return;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Analyze a SIV (Single Index Variable) subscript where CHREC_A is an\n+   affine function, and CHREC_B is a constant.  *OVERLAPS_A and\n+   *OVERLAPS_B are initialized to the functions that describe the\n+   relation between the elements accessed twice by CHREC_A and\n+   CHREC_B.  For k >= 0, the following property is verified:\n+\n+   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+\n+static void\n+analyze_siv_subscript_affine_cst (tree chrec_a, \n+\t\t\t\t  tree chrec_b,\n+\t\t\t\t  tree *overlaps_a, \n+\t\t\t\t  tree *overlaps_b)\n+{\n+  analyze_siv_subscript_cst_affine (chrec_b, chrec_a, overlaps_b, overlaps_a);\n+}\n+\n+/* Determines the overlapping elements due to accesses CHREC_A and\n+   CHREC_B, that are affine functions.  This is a part of the\n+   subscript analyzer.  */\n+\n+static void\n+analyze_subscript_affine_affine (tree chrec_a, \n+\t\t\t\t tree chrec_b,\n+\t\t\t\t tree *overlaps_a, \n+\t\t\t\t tree *overlaps_b)\n+{\n+  tree left_a, left_b, right_a, right_b;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(analyze_subscript_affine_affine \\n\");\n+  \n+  /* For determining the initial intersection, we have to solve a\n+     Diophantine equation.  This is the most time consuming part.\n+     \n+     For answering to the question: \"Is there a dependence?\" we have\n+     to prove that there exists a solution to the Diophantine\n+     equation, and that the solution is in the iteration domain,\n+     ie. the solution is positive or zero, and that the solution\n+     happens before the upper bound loop.nb_iterations.  Otherwise\n+     there is no dependence.  This function outputs a description of\n+     the iterations that hold the intersections.  */\n+\n+  left_a = CHREC_LEFT (chrec_a);\n+  left_b = CHREC_LEFT (chrec_b);\n+  right_a = CHREC_RIGHT (chrec_a);\n+  right_b = CHREC_RIGHT (chrec_b);\n+  \n+  if (chrec_zerop (chrec_fold_minus (integer_type_node, left_a, left_b)))\n+    {\n+      /* The first element accessed twice is on the first\n+\t iteration.  */\n+      *overlaps_a = build_polynomial_chrec \n+\t(CHREC_VARIABLE (chrec_b), integer_zero_node, integer_one_node);\n+      *overlaps_b = build_polynomial_chrec \n+\t(CHREC_VARIABLE (chrec_a), integer_zero_node, integer_one_node);\n+    }\n+  \n+  else if (TREE_CODE (left_a) == INTEGER_CST\n+\t   && TREE_CODE (left_b) == INTEGER_CST\n+\t   && TREE_CODE (right_a) == INTEGER_CST \n+\t   && TREE_CODE (right_b) == INTEGER_CST\n+\t   \n+\t   /* Both functions should have the same evolution sign.  */\n+\t   && ((tree_int_cst_sgn (right_a) > 0 \n+\t\t&& tree_int_cst_sgn (right_b) > 0)\n+\t       || (tree_int_cst_sgn (right_a) < 0\n+\t\t   && tree_int_cst_sgn (right_b) < 0)))\n+    {\n+      /* Here we have to solve the Diophantine equation.  Reference\n+\t book: \"Loop Transformations for Restructuring Compilers - The\n+\t Foundations\" by Utpal Banerjee, pages 59-80.\n+\t \n+\t ALPHA * X0 = BETA * Y0 + GAMMA.  \n+\t \n+\t with:\n+\t ALPHA = RIGHT_A\n+\t BETA = RIGHT_B\n+\t GAMMA = LEFT_B - LEFT_A\n+\t CHREC_A = {LEFT_A, +, RIGHT_A}\n+\t CHREC_B = {LEFT_B, +, RIGHT_B}\n+\t \n+\t The Diophantine equation has a solution if and only if gcd\n+\t (ALPHA, BETA) divides GAMMA.  This is commonly known under\n+\t the name of the \"gcd-test\".\n+      */\n+      tree alpha, beta, gamma;\n+      tree la, lb;\n+      tree gcd_alpha_beta;\n+      tree u11, u12, u21, u22;\n+\n+      /* Both alpha and beta have to be integer_type_node. The gcd\n+\t function does not work correctly otherwise.  */\n+      alpha = copy_node (right_a);\n+      beta = copy_node (right_b);\n+      la = copy_node (left_a);\n+      lb = copy_node (left_b);\n+      TREE_TYPE (alpha) = integer_type_node;\n+      TREE_TYPE (beta) = integer_type_node;\n+      TREE_TYPE (la) = integer_type_node;\n+      TREE_TYPE (lb) = integer_type_node;\n+      \n+      gamma = fold (build (MINUS_EXPR, integer_type_node, lb, la));\n+      \n+      /* FIXME: Use lambda_*_Hermite for implementing Bezout.  */\n+      gcd_alpha_beta = tree_fold_bezout \n+\t(alpha, \n+\t fold (build (MULT_EXPR, integer_type_node, beta, \n+\t\t      integer_minus_one_node)),\n+\t &u11, &u12, \n+\t &u21, &u22);\n+      \n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fprintf (dump_file, \"  (alpha = \");\n+\t  print_generic_expr (dump_file, alpha, 0);\n+\t  fprintf (dump_file, \")\\n  (beta = \");\n+\t  print_generic_expr (dump_file, beta, 0);\n+\t  fprintf (dump_file, \")\\n  (gamma = \");\n+\t  print_generic_expr (dump_file, gamma, 0);\n+\t  fprintf (dump_file, \")\\n  (gcd_alpha_beta = \");\n+\t  print_generic_expr (dump_file, gcd_alpha_beta, 0);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+      \n+      /* The classic \"gcd-test\".  */\n+      if (!tree_fold_divides_p (integer_type_node, gcd_alpha_beta, gamma))\n+\t{\n+\t  /* The \"gcd-test\" has determined that there is no integer\n+\t     solution, ie. there is no dependence.  */\n+\t  *overlaps_a = chrec_known;\n+\t  *overlaps_b = chrec_known;\n+\t}\n+      \n+      else\n+\t{\n+\t  /* The solutions are given by:\n+\t     | \n+\t     | [GAMMA/GCD_ALPHA_BETA  t].[u11 u12]  = [X]\n+\t     |                           [u21 u22]    [Y]\n+\t     \n+\t     For a given integer t.  Using the following variables,\n+\t     \n+\t     | i0 = u11 * gamma / gcd_alpha_beta\n+\t     | j0 = u12 * gamma / gcd_alpha_beta\n+\t     | i1 = u21\n+\t     | j1 = u22\n+\t     \n+\t     the solutions are:\n+\t     \n+\t     | x = i0 + i1 * t, \n+\t     | y = j0 + j1 * t.  */\n+\t  \n+\t  tree i0, j0, i1, j1, t;\n+\t  tree gamma_gcd;\n+\t  \n+\t  /* X0 and Y0 are the first iterations for which there is a\n+\t     dependence.  X0, Y0 are two solutions of the Diophantine\n+\t     equation: chrec_a (X0) = chrec_b (Y0).  */\n+\t  tree x0, y0;\n+      \n+\t  /* Exact div because in this case gcd_alpha_beta divides\n+\t     gamma.  */\n+\t  gamma_gcd = fold (build (EXACT_DIV_EXPR, integer_type_node, gamma, \n+\t\t\t\t   gcd_alpha_beta));\n+\t  i0 = fold (build (MULT_EXPR, integer_type_node, u11, gamma_gcd));\n+\t  j0 = fold (build (MULT_EXPR, integer_type_node, u12, gamma_gcd));\n+\t  i1 = u21;\n+\t  j1 = u22;\n+\t  \n+\t  if ((tree_int_cst_sgn (i1) == 0\n+\t       && tree_int_cst_sgn (i0) < 0)\n+\t      || (tree_int_cst_sgn (j1) == 0\n+\t\t  && tree_int_cst_sgn (j0) < 0))\n+\t    {\n+\t      /* There is no solution.  \n+\t\t FIXME: The case \"i0 > nb_iterations, j0 > nb_iterations\" \n+\t\t falls in here, but for the moment we don't look at the \n+\t\t upper bound of the iteration domain.  */\n+\t      *overlaps_a = chrec_known;\n+\t      *overlaps_b = chrec_known;\n+  \t    }\n+\t  \n+\t  else \n+\t    {\n+\t      if (tree_int_cst_sgn (i1) > 0)\n+\t\t{\n+\t\t  t = fold \n+\t\t    (build (CEIL_DIV_EXPR, integer_type_node, \n+\t\t\t    fold (build (MULT_EXPR, integer_type_node, i0, \n+\t\t\t\t\t integer_minus_one_node)), \n+\t\t\t    i1));\n+\t\t  \n+\t\t  if (tree_int_cst_sgn (j1) > 0)\n+\t\t    {\n+\t\t      t = fold \n+\t\t\t(build (MAX_EXPR, integer_type_node, t,\n+\t\t\t\tfold (build (CEIL_DIV_EXPR, integer_type_node,\n+\t\t\t\t\t     fold (build \n+\t\t\t\t\t\t   (MULT_EXPR,\n+\t\t\t\t\t\t    integer_type_node, j0,\n+\t\t\t\t\t\t    integer_minus_one_node)),\n+\t\t\t\t\t     j1))));\n+\t\t      \n+\t\t      x0 = fold \n+\t\t\t(build (PLUS_EXPR, integer_type_node, i0, \n+\t\t\t\tfold (build \n+\t\t\t\t      (MULT_EXPR, integer_type_node, i1, t))));\n+\t\t      y0 = fold \n+\t\t\t(build (PLUS_EXPR, integer_type_node, j0, \n+\t\t\t\tfold (build \n+\t\t\t\t      (MULT_EXPR, integer_type_node, j1, t))));\n+\t\t      \n+\t\t      *overlaps_a = build_polynomial_chrec \n+\t\t\t(CHREC_VARIABLE (chrec_b), x0, u21);\n+\t\t      *overlaps_b = build_polynomial_chrec \n+\t\t\t(CHREC_VARIABLE (chrec_a), y0, u22);\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      /* FIXME: For the moment, the upper bound of the\n+\t\t\t iteration domain for j is not checked. */\n+\t\t      *overlaps_a = chrec_dont_know;\n+\t\t      *overlaps_b = chrec_dont_know;\n+\t\t    }\n+\t\t}\n+\t      \n+\t      else\n+\t\t{\n+\t\t  /* FIXME: For the moment, the upper bound of the\n+\t\t     iteration domain for i is not checked. */\n+\t\t  *overlaps_a = chrec_dont_know;\n+\t\t  *overlaps_b = chrec_dont_know;\n+\t\t}\n+\t    }\n+\t}\n+    }\n+  \n+  else\n+    {\n+      /* For the moment, \"don't know\".  */\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (overlaps_a = \");\n+      print_generic_expr (dump_file, *overlaps_a, 0);\n+      fprintf (dump_file, \")\\n  (overlaps_b = \");\n+      print_generic_expr (dump_file, *overlaps_b, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Analyze a SIV (Single Index Variable) subscript.  *OVERLAPS_A and\n+   *OVERLAPS_B are initialized to the functions that describe the\n+   relation between the elements accessed twice by CHREC_A and\n+   CHREC_B.  For k >= 0, the following property is verified:\n+\n+   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+\n+static void\n+analyze_siv_subscript (tree chrec_a, \n+\t\t       tree chrec_b,\n+\t\t       tree *overlaps_a, \n+\t\t       tree *overlaps_b)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(analyze_siv_subscript \\n\");\n+  \n+  if (evolution_function_is_constant_p (chrec_a)\n+      && evolution_function_is_affine_p (chrec_b))\n+    analyze_siv_subscript_cst_affine (chrec_a, chrec_b, \n+\t\t\t\t      overlaps_a, overlaps_b);\n+  \n+  else if (evolution_function_is_affine_p (chrec_a)\n+\t   && evolution_function_is_constant_p (chrec_b))\n+    analyze_siv_subscript_affine_cst (chrec_a, chrec_b, \n+\t\t\t\t      overlaps_a, overlaps_b);\n+  \n+  else if (evolution_function_is_affine_p (chrec_a)\n+\t   && evolution_function_is_affine_p (chrec_b)\n+\t   && (CHREC_VARIABLE (chrec_a) == CHREC_VARIABLE (chrec_b)))\n+    analyze_subscript_affine_affine (chrec_a, chrec_b, \n+\t\t\t\t     overlaps_a, overlaps_b);\n+  else\n+    {\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Return true when the evolution steps of an affine CHREC divide the\n+   constant CST.  */\n+\n+static bool\n+chrec_steps_divide_constant_p (tree chrec, \n+\t\t\t       tree cst)\n+{\n+  switch (TREE_CODE (chrec))\n+    {\n+    case POLYNOMIAL_CHREC:\n+      return (tree_fold_divides_p (integer_type_node, CHREC_RIGHT (chrec), cst)\n+\t      && chrec_steps_divide_constant_p (CHREC_LEFT (chrec), cst));\n+      \n+    default:\n+      /* On the initial condition, return true.  */\n+      return true;\n+    }\n+}\n+\n+/* Analyze a MIV (Multiple Index Variable) subscript.  *OVERLAPS_A and\n+   *OVERLAPS_B are initialized to the functions that describe the\n+   relation between the elements accessed twice by CHREC_A and\n+   CHREC_B.  For k >= 0, the following property is verified:\n+\n+   CHREC_A (*OVERLAPS_A (k)) = CHREC_B (*OVERLAPS_B (k)).  */\n+\n+static void\n+analyze_miv_subscript (tree chrec_a, \n+\t\t       tree chrec_b, \n+\t\t       tree *overlaps_a, \n+\t\t       tree *overlaps_b)\n+{\n+  /* FIXME:  This is a MIV subscript, not yet handled.\n+     Example: (A[{1, +, 1}_1] vs. A[{1, +, 1}_2]) that comes from \n+     (A[i] vs. A[j]).  \n+     \n+     In the SIV test we had to solve a Diophantine equation with two\n+     variables.  In the MIV case we have to solve a Diophantine\n+     equation with 2*n variables (if the subscript uses n IVs).\n+  */\n+  tree difference;\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(analyze_miv_subscript \\n\");\n+  \n+  difference = chrec_fold_minus (integer_type_node, chrec_a, chrec_b);\n+  \n+  if (chrec_zerop (difference))\n+    {\n+      /* Access functions are the same: all the elements are accessed\n+\t in the same order.  */\n+      *overlaps_a = integer_zero_node;\n+      *overlaps_b = integer_zero_node;\n+    }\n+  \n+  else if (evolution_function_is_constant_p (difference)\n+\t   /* For the moment, the following is verified:\n+\t      evolution_function_is_affine_multivariate_p (chrec_a) */\n+\t   && !chrec_steps_divide_constant_p (chrec_a, difference))\n+    {\n+      /* testsuite/.../ssa-chrec-33.c\n+\t {{21, +, 2}_1, +, -2}_2  vs.  {{20, +, 2}_1, +, -2}_2 \n+        \n+\t The difference is 1, and the evolution steps are equal to 2,\n+\t consequently there are no overlapping elements.  */\n+      *overlaps_a = chrec_known;\n+      *overlaps_b = chrec_known;\n+    }\n+  \n+  else if (evolution_function_is_univariate_p (chrec_a)\n+\t   && evolution_function_is_univariate_p (chrec_b))\n+    {\n+      /* testsuite/.../ssa-chrec-35.c\n+\t {0, +, 1}_2  vs.  {0, +, 1}_3\n+\t the overlapping elements are respectively located at iterations:\n+\t {0, +, 1}_3 and {0, +, 1}_2.\n+      */\n+      if (evolution_function_is_affine_p (chrec_a)\n+\t  && evolution_function_is_affine_p (chrec_b))\n+\tanalyze_subscript_affine_affine (chrec_a, chrec_b, \n+\t\t\t\t\t overlaps_a, overlaps_b);\n+      else\n+\t{\n+\t  *overlaps_a = chrec_dont_know;\n+\t  *overlaps_b = chrec_dont_know;\n+\t}\n+    }\n+  \n+  else\n+    {\n+      /* When the analysis is too difficult, answer \"don't know\".  */\n+      *overlaps_a = chrec_dont_know;\n+      *overlaps_b = chrec_dont_know;\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Determines the iterations for which CHREC_A is equal to CHREC_B.\n+   OVERLAP_ITERATIONS_A and OVERLAP_ITERATIONS_B are initialized with\n+   two functions that describe the iterations that contain conflicting\n+   elements.\n+   \n+   Remark: For an integer k >= 0, the following equality is true:\n+   \n+   CHREC_A (OVERLAP_ITERATIONS_A (k)) == CHREC_B (OVERLAP_ITERATIONS_B (k)).\n+*/\n+\n+static void \n+analyze_overlapping_iterations (tree chrec_a, \n+\t\t\t\ttree chrec_b, \n+\t\t\t\ttree *overlap_iterations_a, \n+\t\t\t\ttree *overlap_iterations_b)\n+{\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(analyze_overlapping_iterations \\n\");\n+      fprintf (dump_file, \"  (chrec_a = \");\n+      print_generic_expr (dump_file, chrec_a, 0);\n+      fprintf (dump_file, \")\\n  chrec_b = \");\n+      print_generic_expr (dump_file, chrec_b, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  if (chrec_a == NULL_TREE\n+      || chrec_b == NULL_TREE\n+      || chrec_contains_undetermined (chrec_a)\n+      || chrec_contains_undetermined (chrec_b)\n+      || chrec_contains_symbols (chrec_a)\n+      || chrec_contains_symbols (chrec_b))\n+    {\n+      *overlap_iterations_a = chrec_dont_know;\n+      *overlap_iterations_b = chrec_dont_know;\n+    }\n+  \n+  else if (ziv_subscript_p (chrec_a, chrec_b))\n+    analyze_ziv_subscript (chrec_a, chrec_b, \n+\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+  \n+  else if (siv_subscript_p (chrec_a, chrec_b))\n+    analyze_siv_subscript (chrec_a, chrec_b, \n+\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+  \n+  else\n+    analyze_miv_subscript (chrec_a, chrec_b, \n+\t\t\t   overlap_iterations_a, overlap_iterations_b);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"  (overlap_iterations_a = \");\n+      print_generic_expr (dump_file, *overlap_iterations_a, 0);\n+      fprintf (dump_file, \")\\n  (overlap_iterations_b = \");\n+      print_generic_expr (dump_file, *overlap_iterations_b, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+}\n+\n+\f\n+\n+/* This section contains the affine functions dependences detector.  */\n+\n+/* Computes the conflicting iterations, and initialize DDR.  */\n+\n+static void\n+subscript_dependence_tester (struct data_dependence_relation *ddr)\n+{\n+  unsigned int i;\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \"(subscript_dependence_tester \\n\");\n+  \n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (ddr); i++)\n+    {\n+      tree overlaps_a, overlaps_b;\n+      struct subscript *subscript = DDR_SUBSCRIPT (ddr, i);\n+      \n+      analyze_overlapping_iterations (DR_ACCESS_FN (dra, i), \n+\t\t\t\t      DR_ACCESS_FN (drb, i),\n+\t\t\t\t      &overlaps_a, &overlaps_b);\n+      \n+      if (chrec_contains_undetermined (overlaps_a)\n+ \t  || chrec_contains_undetermined (overlaps_b))\n+ \t{\n+ \t  finalize_ddr_dependent (ddr, chrec_dont_know);\n+\t  break;\n+ \t}\n+      \n+      else if (overlaps_a == chrec_known\n+ \t       || overlaps_b == chrec_known)\n+ \t{\n+ \t  finalize_ddr_dependent (ddr, chrec_known);\n+ \t  break;\n+ \t}\n+      \n+      else\n+ \t{\n+ \t  SUB_CONFLICTS_IN_A (subscript) = overlaps_a;\n+ \t  SUB_CONFLICTS_IN_B (subscript) = overlaps_b;\n+ \t}\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Compute the classic per loop distance vector.\n+\n+   RES is the data dependence relation to build a vector from.\n+   CLASSIC_DIST is the varray to place the vector in.\n+   NB_LOOPS is the total number of loops we are considering.\n+   FIRST_LOOP is the loop->num of the first loop.  */\n+\n+static void\n+build_classic_dist_vector (struct data_dependence_relation *res, \n+\t\t\t   varray_type *classic_dist, \n+\t\t\t   int nb_loops, unsigned int first_loop)\n+{\n+  unsigned i;\n+  lambda_vector dist_v, init_v;\n+  \n+  dist_v = lambda_vector_new (nb_loops);\n+  init_v = lambda_vector_new (nb_loops);\n+  lambda_vector_clear (dist_v, nb_loops);\n+  lambda_vector_clear (init_v, nb_loops);\n+  \n+  if (DDR_ARE_DEPENDENT (res) != NULL_TREE)\n+    return;\n+  \n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (res); i++)\n+    {\n+      struct subscript *subscript = DDR_SUBSCRIPT (res, i);\n+\n+      if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n+\treturn;\n+\n+      if (TREE_CODE (SUB_CONFLICTS_IN_A (subscript)) == POLYNOMIAL_CHREC)\n+\t{\n+\t  int dist;\n+\t  int loop_nb;\n+\t  loop_nb = CHREC_VARIABLE (SUB_CONFLICTS_IN_A (subscript));\n+\t  loop_nb -= first_loop;\n+\t  /* If the loop number is still greater than the number of\n+\t     loops we've been asked to analyze, or negative,\n+\t     something is borked.  */\n+\t  if (loop_nb < 0 || loop_nb >= nb_loops)\n+\t    abort ();\n+\t  dist = int_cst_value (SUB_DISTANCE (subscript));\n+\n+\t  /* This is the subscript coupling test.  \n+\t     | loop i = 0, N, 1\n+\t     |   T[i+1][i] = ...\n+\t     |   ... = T[i][i]\n+\t     | endloop\n+\t     There is no dependence.  */\n+\t  if (init_v[loop_nb] != 0\n+\t      && dist_v[loop_nb] != dist)\n+\t    {\n+\t      finalize_ddr_dependent (res, chrec_known);\n+\t      return;\n+\t    }\n+\n+\t  dist_v[loop_nb] = dist;\n+\t  init_v[loop_nb] = 1;\n+\t}\n+    }\n+  \n+  /* There is a distance of 1 on all the outer loops: \n+     \n+     Example: there is a dependence of distance 1 on loop_1 for the array A.\n+     | loop_1\n+     |   A[5] = ...\n+     | endloop\n+  */\n+  {\n+    struct loop *lca, *loop_a, *loop_b;\n+    struct data_reference *a = DDR_A (res);\n+    struct data_reference *b = DDR_B (res);\n+    int lca_nb;\n+    loop_a = loop_containing_stmt (DR_STMT (a));\n+    loop_b = loop_containing_stmt (DR_STMT (b));\n+    \n+    /* Get the common ancestor loop.  */\n+    lca = find_common_loop (loop_a, loop_b); \n+    \n+    lca_nb = lca->num;\n+    lca_nb -= first_loop;\n+    if (lca_nb < 0 || lca_nb >= nb_loops)\n+      abort ();\n+    /* For each outer loop where init_v is not set, the accesses are\n+       in dependence of distance 1 in the loop.  */\n+    if (lca != loop_a\n+\t&& lca != loop_b\n+\t&& init_v[lca_nb] == 0)\n+      dist_v[lca_nb] = 1;\n+    \n+    lca = lca->outer;\n+    \n+    if (lca)\n+      {\n+\tlca_nb = lca->num - first_loop;\n+\twhile (lca->depth != 0)\n+\t  {\n+\t    if (lca_nb < 0 || lca_nb >= nb_loops)\n+\t      abort ();\n+\t    if (init_v[lca_nb] == 0)\n+\t      dist_v[lca_nb] = 1;\n+\t    lca = lca->outer;\n+\t    lca_nb = lca->num - first_loop;\n+\t  \n+\t  }\n+      }\n+  }\n+  \n+  VARRAY_PUSH_GENERIC_PTR (*classic_dist, dist_v);\n+}\n+\n+/* Compute the classic per loop direction vector.  \n+\n+   RES is the data dependence relation to build a vector from.\n+   CLASSIC_DIR is the varray to place the vector in.\n+   NB_LOOPS is the total number of loops we are considering.\n+   FIRST_LOOP is the loop->num of the first loop.  */\n+\n+static void\n+build_classic_dir_vector (struct data_dependence_relation *res, \n+\t\t\t  varray_type *classic_dir, \n+\t\t\t  int nb_loops, unsigned int first_loop)\n+{\n+  unsigned i;\n+  lambda_vector dir_v, init_v;\n+  \n+  dir_v = lambda_vector_new (nb_loops);\n+  init_v = lambda_vector_new (nb_loops);\n+  lambda_vector_clear (dir_v, nb_loops);\n+  lambda_vector_clear (init_v, nb_loops);\n+  \n+  if (DDR_ARE_DEPENDENT (res) != NULL_TREE)\n+    return;\n+  \n+  for (i = 0; i < DDR_NUM_SUBSCRIPTS (res); i++)\n+    {\n+      struct subscript *subscript = DDR_SUBSCRIPT (res, i);\n+\n+      if (TREE_CODE (SUB_CONFLICTS_IN_A (subscript)) == POLYNOMIAL_CHREC\n+\t  && TREE_CODE (SUB_CONFLICTS_IN_B (subscript)) == POLYNOMIAL_CHREC)\n+\t{\n+\t  int loop_nb;\n+\t  \n+\t  enum data_dependence_direction dir = dir_star;\n+\t  loop_nb = CHREC_VARIABLE (SUB_CONFLICTS_IN_A (subscript));\n+\t  loop_nb -= first_loop;\n+\n+\t  /* If the loop number is still greater than the number of\n+\t     loops we've been asked to analyze, or negative,\n+\t     something is borked.  */\n+\t  if (loop_nb < 0 || loop_nb >= nb_loops)\n+\t    abort ();\t  \n+\t  if (chrec_contains_undetermined (SUB_DISTANCE (subscript)))\n+\t    {\n+\t      \n+\t    }\n+\t  else\n+\t    {\n+\t      int dist = int_cst_value (SUB_DISTANCE (subscript));\n+\t      \n+\t      if (dist == 0)\n+\t\tdir = dir_equal;\n+\t      else if (dist > 0)\n+\t\tdir = dir_positive;\n+\t      else if (dist < 0)\n+\t\tdir = dir_negative;\n+\t    }\n+\t  \n+\t  /* This is the subscript coupling test.  \n+\t     | loop i = 0, N, 1\n+\t     |   T[i+1][i] = ...\n+\t     |   ... = T[i][i]\n+\t     | endloop\n+\t     There is no dependence.  */\n+\t  if (init_v[loop_nb] != 0\n+\t      && dir != dir_star\n+\t      && (enum data_dependence_direction) dir_v[loop_nb] != dir\n+\t      && (enum data_dependence_direction) dir_v[loop_nb] != dir_star)\n+\t    {\n+\t      finalize_ddr_dependent (res, chrec_known);\n+\t      return;\n+\t    }\n+\t  \n+\t  dir_v[loop_nb] = dir;\n+\t  init_v[loop_nb] = 1;\n+\t}\n+    }\n+  \n+  /* There is a distance of 1 on all the outer loops: \n+     \n+     Example: there is a dependence of distance 1 on loop_1 for the array A.\n+     | loop_1\n+     |   A[5] = ...\n+     | endloop\n+  */\n+  {\n+    struct loop *lca, *loop_a, *loop_b;\n+    struct data_reference *a = DDR_A (res);\n+    struct data_reference *b = DDR_B (res);\n+    int lca_nb;\n+    loop_a = loop_containing_stmt (DR_STMT (a));\n+    loop_b = loop_containing_stmt (DR_STMT (b));\n+    \n+    /* Get the common ancestor loop.  */\n+    lca = find_common_loop (loop_a, loop_b); \n+    lca_nb = lca->num - first_loop;\n+\n+    if (lca_nb < 0 || lca_nb >= nb_loops)\n+      abort ();\n+    /* For each outer loop where init_v is not set, the accesses are\n+       in dependence of distance 1 in the loop.  */\n+    if (lca != loop_a\n+\t&& lca != loop_b\n+\t&& init_v[lca_nb] == 0)\n+      dir_v[lca_nb] = dir_positive;\n+    \n+    lca = lca->outer;\n+    if (lca)\n+      {\n+\tlca_nb = lca->num - first_loop;\n+\twhile (lca->depth != 0)\n+\t  {\n+\t    if (lca_nb < 0 || lca_nb >= nb_loops)\n+\t      abort ();\n+\t    if (init_v[lca_nb] == 0)\n+\t      dir_v[lca_nb] = dir_positive;\n+\t    lca = lca->outer;\n+\t    lca_nb = lca->num - first_loop;\n+\t   \n+\t  }\n+      }\n+  }\n+  \n+  VARRAY_PUSH_GENERIC_PTR (*classic_dir, dir_v);\n+}\n+\n+/* Returns true when all the access functions of A are affine or\n+   constant.  */\n+\n+static bool \n+access_functions_are_affine_or_constant_p (struct data_reference *a)\n+{\n+  unsigned int i;\n+  varray_type fns = DR_ACCESS_FNS (a);\n+  \n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (fns); i++)\n+    if (!evolution_function_is_constant_p (VARRAY_TREE (fns, i))\n+\t&& !evolution_function_is_affine_multivariate_p (VARRAY_TREE (fns, i)))\n+      return false;\n+  \n+  return true;\n+}\n+\n+/* This computes the affine dependence relation between A and B.\n+   CHREC_KNOWN is used for representing the independence between two\n+   accesses, while CHREC_DONT_KNOW is used for representing the unknown\n+   relation.\n+   \n+   Note that it is possible to stop the computation of the dependence\n+   relation the first time we detect a CHREC_KNOWN element for a given\n+   subscript.  */\n+\n+void\n+compute_affine_dependence (struct data_dependence_relation *ddr)\n+{\n+  struct data_reference *dra = DDR_A (ddr);\n+  struct data_reference *drb = DDR_B (ddr);\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      fprintf (dump_file, \"(compute_affine_dependence (%d, %d)\\n\", \n+\t       DR_ID (dra), DR_ID (drb));\n+      fprintf (dump_file, \"  (stmt_a = \\n\");\n+      print_generic_expr (dump_file, DR_STMT (dra), 0);\n+      fprintf (dump_file, \")\\n  (stmt_b = \\n\");\n+      print_generic_expr (dump_file, DR_STMT (drb), 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+  \n+  /* Analyze only when the dependence relation is not yet known.  */\n+  if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+    {\n+      if (access_functions_are_affine_or_constant_p (dra)\n+\t  && access_functions_are_affine_or_constant_p (drb))\n+\tsubscript_dependence_tester (ddr);\n+      \n+      /* As a last case, if the dependence cannot be determined, or if\n+\t the dependence is considered too difficult to determine, answer\n+\t \"don't know\".  */\n+      else\n+\tfinalize_ddr_dependent (ddr, chrec_dont_know);\n+    }\n+  \n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \")\\n\");\n+}\n+\n+/* Compute a subset of the data dependence relation graph.  Don't\n+   compute read-read relations, and avoid the computation of the\n+   opposite relation, ie. when AB has been computed, don't compute BA.\n+   DATAREFS contains a list of data references, and the result is set\n+   in DEPENDENCE_RELATIONS.  */\n+\n+static void \n+compute_rw_wr_ww_dependences (varray_type datarefs, \n+\t\t\t      varray_type *dependence_relations)\n+{\n+  unsigned int i, j, N;\n+\n+  N = VARRAY_ACTIVE_SIZE (datarefs);\n+\n+  for (i = 0; i < N; i++)\n+    for (j = i; j < N; j++)\n+      {\n+\tstruct data_reference *a, *b;\n+\tstruct data_dependence_relation *ddr;\n+\n+\ta = VARRAY_GENERIC_PTR (datarefs, i);\n+\tb = VARRAY_GENERIC_PTR (datarefs, j);\n+\n+\t/* Don't compute the \"read-read\" relations.  */\n+\tif (DR_IS_READ (a) && DR_IS_READ (b))\n+\t  continue;\n+\n+\tddr = initialize_data_dependence_relation (a, b);\n+\n+\tVARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+\tcompute_affine_dependence (ddr);\n+\tcompute_distance_vector (ddr);\n+      }\n+}\n+\n+/* Search the data references in LOOP, and record the information into\n+   DATAREFS.  Returns chrec_dont_know when failing to analyze a\n+   difficult case, returns NULL_TREE otherwise.\n+   \n+   FIXME: This is a \"dumb\" walker over all the trees in the loop body.\n+   Find another technique that avoids this costly walk.  This is\n+   acceptable for the moment, since this function is used only for\n+   debugging purposes.  */\n+\n+static tree \n+find_data_references_in_loop (struct loop *loop, varray_type *datarefs)\n+{\n+  basic_block bb;\n+  block_stmt_iterator bsi;\n+  \n+  FOR_EACH_BB (bb)\n+    {\n+      if (!flow_bb_inside_loop_p (loop, bb))\n+\tcontinue;\n+      \n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+        {\n+\t  tree stmt = bsi_stmt (bsi);\n+\t  stmt_ann_t ann = stmt_ann (stmt);\n+\n+\t  if (TREE_CODE (stmt) != MODIFY_EXPR)\n+\t    continue;\n+\n+\t  if (!VUSE_OPS (ann)\n+\t      && !V_MUST_DEF_OPS (ann)\n+\t      && !V_MAY_DEF_OPS (ann))\n+\t    continue;\n+\n+\t  /* In the GIMPLE representation, a modify expression\n+  \t     contains a single load or store to memory.  */\n+\t  if (TREE_CODE (TREE_OPERAND (stmt, 0)) == ARRAY_REF)\n+\t    VARRAY_PUSH_GENERIC_PTR \n+\t\t    (*datarefs, analyze_array (stmt, TREE_OPERAND (stmt, 0), \n+\t\t\t\t\t       false));\n+\n+\t  else if (TREE_CODE (TREE_OPERAND (stmt, 1)) == ARRAY_REF)\n+\t    VARRAY_PUSH_GENERIC_PTR \n+\t\t    (*datarefs, analyze_array (stmt, TREE_OPERAND (stmt, 1), \n+\t\t\t\t\t       true));\n+\n+  \t  else\n+\t    return chrec_dont_know;\n+\t}\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+\f\n+\n+/* This section contains all the entry points.  */\n+\n+/* Given a loop nest LOOP, the following vectors are returned:\n+   *DATAREFS is initialized to all the array elements contained in this loop, \n+   *DEPENDENCE_RELATIONS contains the relations between the data references, \n+   *CLASSIC_DIST contains the set of distance vectors,\n+   *CLASSIC_DIR contains the set of direction vectors.  */\n+\n+void\n+compute_data_dependences_for_loop (unsigned nb_loops, \n+\t\t\t\t   struct loop *loop,\n+\t\t\t\t   varray_type *datarefs,\n+\t\t\t\t   varray_type *dependence_relations,\n+\t\t\t\t   varray_type *classic_dist, \n+\t\t\t\t   varray_type *classic_dir)\n+{\n+  unsigned int i;\n+\n+  /* If one of the data references is not computable, give up without\n+     spending time to compute other dependences.  */\n+  if (find_data_references_in_loop (loop, datarefs) == chrec_dont_know)\n+    {\n+      struct data_dependence_relation *ddr;\n+\n+      /* Insert a single relation into dependence_relations:\n+\t chrec_dont_know.  */\n+      ddr = initialize_data_dependence_relation (NULL, NULL);\n+      VARRAY_PUSH_GENERIC_PTR (*dependence_relations, ddr);\n+      build_classic_dist_vector (ddr, classic_dist, nb_loops, loop->num);\n+      build_classic_dir_vector (ddr, classic_dir, nb_loops, loop->num);\n+      return;\n+    }\n+\n+  compute_rw_wr_ww_dependences (*datarefs, dependence_relations);\n+\n+  for (i = 0; i < VARRAY_ACTIVE_SIZE (*dependence_relations); i++)\n+    {\n+      struct data_dependence_relation *ddr;\n+      ddr = VARRAY_GENERIC_PTR (*dependence_relations, i);\n+      build_classic_dist_vector (ddr, classic_dist, nb_loops, loop->num);\n+      build_classic_dir_vector (ddr, classic_dir, nb_loops, loop->num);    \n+    }\n+}\n+\n+/* Entry point (for testing only).  Analyze all the data references\n+   and the dependence relations.\n+\n+   The data references are computed first.  \n+   \n+   A relation on these nodes is represented by a complete graph.  Some\n+   of the relations could be of no interest, thus the relations can be\n+   computed on demand.\n+   \n+   In the following function we compute all the relations.  This is\n+   just a first implementation that is here for:\n+   - for showing how to ask for the dependence relations, \n+   - for the debugging the whole dependence graph,\n+   - for the dejagnu testcases and maintenance.\n+   \n+   It is possible to ask only for a part of the graph, avoiding to\n+   compute the whole dependence graph.  The computed dependences are\n+   stored in a knowledge base (KB) such that later queries don't\n+   recompute the same information.  The implementation of this KB is\n+   transparent to the optimizer, and thus the KB can be changed with a\n+   more efficient implementation, or the KB could be disabled.  */\n+\n+void \n+analyze_all_data_dependences (struct loops *loops)\n+{\n+  unsigned int i;\n+  varray_type datarefs;\n+  varray_type dependence_relations;\n+  varray_type classic_dist, classic_dir;\n+  int nb_data_refs = 10;\n+\n+  VARRAY_GENERIC_PTR_INIT (classic_dist, 10, \"classic_dist\");\n+  VARRAY_GENERIC_PTR_INIT (classic_dir, 10, \"classic_dir\");\n+  VARRAY_GENERIC_PTR_INIT (datarefs, nb_data_refs, \"datarefs\");\n+  VARRAY_GENERIC_PTR_INIT (dependence_relations, \n+\t\t\t   nb_data_refs * nb_data_refs,\n+\t\t\t   \"dependence_relations\");\n+\n+  /* Compute DDs on the whole function.  */\n+  compute_data_dependences_for_loop (loops->num, loops->parray[0], \n+\t\t\t\t     &datarefs, &dependence_relations, \n+\t\t\t\t     &classic_dist, &classic_dir);\n+\n+  if (dump_file)\n+    {\n+      dump_data_dependence_relations (dump_file, dependence_relations);\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  /* Don't dump distances in order to avoid to update the\n+     testsuite.  */\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (classic_dist); i++)\n+\t{\n+\t  fprintf (dump_file, \"DISTANCE_V (\");\n+\t  print_lambda_vector (dump_file, \n+\t\t\t       VARRAY_GENERIC_PTR (classic_dist, i),\n+\t\t\t       loops->num);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (classic_dir); i++)\n+\t{\n+\t  fprintf (dump_file, \"DIRECTION_V (\");\n+\t  print_lambda_vector (dump_file, \n+\t\t\t       VARRAY_GENERIC_PTR (classic_dir, i),\n+\t\t\t       loops->num);\n+\t  fprintf (dump_file, \")\\n\");\n+\t}\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_STATS))\n+    {\n+      unsigned nb_top_relations = 0;\n+      unsigned nb_bot_relations = 0;\n+      unsigned nb_basename_differ = 0;\n+      unsigned nb_chrec_relations = 0;\n+\n+      for (i = 0; i < VARRAY_ACTIVE_SIZE (dependence_relations); i++)\n+\t{\n+\t  struct data_dependence_relation *ddr;\n+\t  ddr = VARRAY_GENERIC_PTR (dependence_relations, i);\n+\t  \n+\t  if (chrec_contains_undetermined (DDR_ARE_DEPENDENT (ddr)))\n+\t    nb_top_relations++;\n+\t  \n+\t  else if (DDR_ARE_DEPENDENT (ddr) == chrec_known)\n+\t    {\n+\t      struct data_reference *a = DDR_A (ddr);\n+\t      struct data_reference *b = DDR_B (ddr);\n+\t      \n+\t      if (DR_NUM_DIMENSIONS (a) != DR_NUM_DIMENSIONS (b)\n+\t\t  || array_base_name_differ_p (a, b))\n+\t\tnb_basename_differ++;\n+\t      else\n+\t\tnb_bot_relations++;\n+\t    }\n+\t  \n+\t  else \n+\t    nb_chrec_relations++;\n+\t}\n+      \n+      fprintf (dump_file, \"\\n(\\n\");\n+      fprintf (dump_file, \"%d\\tnb_top_relations\\n\", nb_top_relations);\n+      fprintf (dump_file, \"%d\\tnb_bot_relations\\n\", nb_bot_relations);\n+      fprintf (dump_file, \"%d\\tnb_basename_differ\\n\", nb_basename_differ);\n+      fprintf (dump_file, \"%d\\tnb_distance_relations\\n\", (int) VARRAY_ACTIVE_SIZE (classic_dist));\n+      fprintf (dump_file, \"%d\\tnb_chrec_relations\\n\", nb_chrec_relations);\n+      fprintf (dump_file, \"\\n)\\n\");\n+      \n+      gather_stats_on_scev_database ();\n+    }\n+  \n+  varray_clear (dependence_relations);\n+  varray_clear (datarefs);\n+  varray_clear (classic_dist);\n+  varray_clear (classic_dir);\n+}\n+\n+"}, {"sha": "a31b0af32c329495aa1ce4f218cb9283f01cc913", "filename": "gcc/tree-data-ref.h", "status": "added", "additions": 188, "deletions": 0, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -0,0 +1,188 @@\n+/* Data references and dependences detectors. \n+   Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Sebastian Pop <s.pop@laposte.net>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#ifndef GCC_TREE_DATA_REF_H\n+#define GCC_TREE_DATA_REF_H\n+\n+struct data_reference GTY(())\n+{\n+  /* An identifier.  */\n+  unsigned int id;\n+  \n+  /* A pointer to the statement that contains this DR.  */\n+  tree stmt;\n+  \n+  /* A pointer to the ARRAY_REF node.  */\n+  tree ref;\n+\n+  /* The name of the array.  */\n+  tree base_name;\n+  \n+  /* A list of chrecs.  */\n+  varray_type access_fns;\n+\n+  /* Auxiliary info specific to a pass.  */\n+  int aux;\n+\n+  /* True when the data reference is in RHS of a stmt.  */\n+  bool is_read;\n+\n+};\n+\n+#define DR_ID(DR) DR->id\n+#define DR_STMT(DR) DR->stmt\n+#define DR_REF(DR) DR->ref\n+#define DR_BASE_NAME(DR) DR->base_name\n+#define DR_ACCESS_FNS(DR) DR->access_fns\n+#define DR_ACCESS_FN(DR, I) VARRAY_TREE (DR_ACCESS_FNS (DR), I)\n+#define DR_NUM_DIMENSIONS(DR) VARRAY_ACTIVE_SIZE (DR_ACCESS_FNS (DR))\n+#define DR_IS_READ(DR) DR->is_read\n+\n+enum data_dependence_direction {\n+  dir_positive, \n+  dir_negative, \n+  dir_equal, \n+  dir_positive_or_negative,\n+  dir_positive_or_equal,\n+  dir_negative_or_equal,\n+  dir_star,\n+  dir_independent\n+};\n+\n+/* What is a subscript?  Given two array accesses a subscript is the\n+   tuple composed of the access functions for a given dimension.\n+   Example: Given A[f1][f2][f3] and B[g1][g2][g3], there are three\n+   subscripts: (f1, g1), (f2, g2), (f3, g3).  These three subscripts\n+   are stored in the data_dependence_relation structure under the form\n+   of an array of subscripts.  */\n+\n+struct subscript GTY(()) \n+{\n+  /* A description of the iterations for which the elements are\n+     accessed twice.  */\n+  tree conflicting_iterations_in_a;\n+  tree conflicting_iterations_in_b;\n+  \n+  /* These fields store the information about the iteration domain\n+     validity of the dependence relation.  */\n+  tree last_conflict_in_a;\n+  tree last_conflict_in_b;\n+  \n+  /* Distance from the iteration that access a conflicting element in\n+     A to the iteration that access this same conflicting element in\n+     B.  The distance is a tree scalar expression, ie. a constant or a\n+     symbolic expression, but certainly not a chrec function.  */\n+  tree distance;\n+  \n+  /* Direction (or sign) of the distance.  This more abstract (less\n+     precise) information is extracted from the distance field, for\n+     the convenience of some analyzers.  */\n+  enum data_dependence_direction direction;\n+};\n+\n+#define SUB_CONFLICTS_IN_A(SUB) SUB->conflicting_iterations_in_a\n+#define SUB_CONFLICTS_IN_B(SUB) SUB->conflicting_iterations_in_b\n+#define SUB_LAST_CONFLICT_IN_A(SUB) SUB->last_conflict_in_a\n+#define SUB_LAST_CONFLICT_IN_B(SUB) SUB->last_conflict_in_b\n+#define SUB_DISTANCE(SUB) SUB->distance\n+#define SUB_DIRECTION(SUB) SUB->direction\n+\n+/* A data_dependence_relation represents a relation between two\n+   data_references A and B.  */\n+\n+struct data_dependence_relation GTY(())\n+{\n+  \n+  struct data_reference *a;\n+  struct data_reference *b;\n+\n+  /* A \"yes/no/maybe\" field for the dependence relation:\n+     \n+     - when \"ARE_DEPENDENT == NULL_TREE\", there exist a dependence\n+       relation between A and B, and the description of this relation\n+       is given in the SUBSCRIPTS array,\n+     \n+     - when \"ARE_DEPENDENT == chrec_known\", there is no dependence and\n+       SUBSCRIPTS is empty,\n+     \n+     - when \"ARE_DEPENDENT == chrec_dont_know\", there may be a dependence,\n+       but the analyzer cannot be more specific.  */\n+  tree are_dependent;\n+  \n+  /* For each subscript in the dependence test, there is an element in\n+     this array.  This is the attribute that labels the edge A->B of\n+     the data_dependence_relation.  */\n+  varray_type subscripts;\n+};\n+\n+#define DDR_A(DDR) DDR->a\n+#define DDR_B(DDR) DDR->b\n+#define DDR_ARE_DEPENDENT(DDR) DDR->are_dependent\n+#define DDR_SUBSCRIPTS(DDR) DDR->subscripts\n+#define DDR_SUBSCRIPTS_VECTOR_INIT(DDR, N) \\\n+  VARRAY_GENERIC_PTR_INIT (DDR_SUBSCRIPTS (DDR), N, \"subscripts_vector\");\n+#define DDR_SUBSCRIPT(DDR, I) VARRAY_GENERIC_PTR (DDR_SUBSCRIPTS (DDR), I)\n+#define DDR_NUM_SUBSCRIPTS(DDR) VARRAY_ACTIVE_SIZE (DDR_SUBSCRIPTS (DDR))\n+\n+\f\n+\n+struct data_dependence_relation *initialize_data_dependence_relation \n+(struct data_reference *, struct data_reference *);\n+void compute_affine_dependence (struct data_dependence_relation *);\n+extern void analyze_all_data_dependences (struct loops *);\n+extern void compute_data_dependences_for_loop (unsigned, struct loop *, \n+\t\t\t\t\t       varray_type *, varray_type *, \n+\t\t\t\t\t       varray_type *, varray_type *);\n+extern struct data_reference * init_data_ref (tree, tree, tree, tree);\n+extern struct data_reference *analyze_array (tree, tree, bool);\n+\n+extern void dump_data_reference (FILE *, struct data_reference *);\n+extern void dump_data_references (FILE *, varray_type);\n+extern void dump_data_dependence_relation (FILE *, \n+\t\t\t\t\t   struct data_dependence_relation *);\n+extern void dump_data_dependence_relations (FILE *, varray_type);\n+extern void dump_data_dependence_direction (FILE *, \n+\t\t\t\t\t    enum data_dependence_direction);\n+\n+\f\n+\n+/* Inline functions.  */\n+\n+/* This is the simplest data dependence test: determines whether the\n+   data references A and B access the same array.  */\n+\n+static inline bool\n+array_base_name_differ_p (struct data_reference *a, \n+\t\t\t  struct data_reference *b)\n+{\n+  if (DR_BASE_NAME (a) == DR_BASE_NAME (b))\n+    return false;\n+  \n+  if (TREE_CODE (DR_BASE_NAME (a)) == INDIRECT_REF\n+      && TREE_CODE (DR_BASE_NAME (b)) == INDIRECT_REF\n+      && TREE_OPERAND (DR_BASE_NAME (a), 0) \n+      == TREE_OPERAND (DR_BASE_NAME (b), 0))\n+    return false;\n+  \n+  return true;\n+}\n+\n+#endif  /* GCC_TREE_DATA_REF_H  */"}, {"sha": "09a963304632474367607b9bde8e2470552fea0c", "filename": "gcc/tree.c", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -5737,5 +5737,66 @@ find_compatible_field (tree record, tree orig_field)\n   return orig_field;\n }\n \n+/* Return value of a constant X.  */\n+\n+HOST_WIDE_INT\n+int_cst_value (tree x)\n+{\n+  unsigned bits = TYPE_PRECISION (TREE_TYPE (x));\n+  unsigned HOST_WIDE_INT val = TREE_INT_CST_LOW (x);\n+  bool negative = ((val >> (bits - 1)) & 1) != 0;\n+\n+  if (bits > HOST_BITS_PER_WIDE_INT)\n+    abort ();\n+\n+  if (negative)\n+    val |= (~(unsigned HOST_WIDE_INT) 0) << (bits - 1) << 1;\n+  else\n+    val &= ~((~(unsigned HOST_WIDE_INT) 0) << (bits - 1) << 1);\n+\n+  return val;\n+}\n+\n+/* Returns the greatest common divisor of A and B, which must be\n+   INTEGER_CSTs.  */\n+\n+tree \n+tree_fold_gcd (tree a, tree b)\n+{\n+  tree a_mod_b;\n+  tree type = TREE_TYPE (a);\n+  \n+#if defined ENABLE_CHECKING\n+  if (TREE_CODE (a) != INTEGER_CST\n+      || TREE_CODE (b) != INTEGER_CST)\n+    abort ();\n+#endif\n+  \n+  if (integer_zerop (a)) \n+    return b;\n+  \n+  if (integer_zerop (b)) \n+    return a;\n+  \n+  if (tree_int_cst_sgn (a) == -1)\n+    a = fold (build (MULT_EXPR, type, a,\n+\t\t     convert (type, integer_minus_one_node)));\n+  \n+  if (tree_int_cst_sgn (b) == -1)\n+    b = fold (build (MULT_EXPR, type, b,\n+\t\t     convert (type, integer_minus_one_node)));\n+ \n+  while (1)\n+    {\n+      a_mod_b = fold (build (CEIL_MOD_EXPR, type, a, b));\n+ \n+      if (!TREE_INT_CST_LOW (a_mod_b)\n+\t  && !TREE_INT_CST_HIGH (a_mod_b))\n+\treturn b;\n+\n+      a = b;\n+      b = a_mod_b;\n+    }\n+}\n \n #include \"gt-tree.h\""}, {"sha": "d364434f3bed0c33b636c10eea227e531709f92c", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=56cf8686a1031e6cf8760a4aeb46fb022b8ccdfe", "patch": "@@ -3480,6 +3480,8 @@ extern void build_common_tree_nodes (int);\n extern void build_common_tree_nodes_2 (int);\n extern tree build_nonstandard_integer_type (unsigned HOST_WIDE_INT, int);\n extern tree build_range_type (tree, tree, tree);\n+extern HOST_WIDE_INT int_cst_value (tree);\n+extern tree tree_fold_gcd (tree, tree);\n \n extern bool fields_compatible_p (tree, tree);\n extern tree find_compatible_field (tree, tree);"}]}