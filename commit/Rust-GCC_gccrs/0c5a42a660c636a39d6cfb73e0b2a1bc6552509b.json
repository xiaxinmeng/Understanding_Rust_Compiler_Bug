{"sha": "0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGM1YTQyYTY2MGM2MzZhMzlkNmNmYjczZTBiMmExYmM2NTUyNTA5Yg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-22T05:13:13Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-03-22T05:13:13Z"}, "message": "re PR fortran/17298 (gfortran ICE: Not Implemented: Scalarization of non-elemental intrinsic: __transfer1)\n\n2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/17298\n\t*trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): New\n\tfunction to implement array valued TRANSFER intrinsic.\n\t(gfc_conv_intrinsic_function): Call the new function if TRANSFER\n\tand non-null se->ss.\n\t(gfc_walk_intrinsic_function): Treat TRANSFER as one of the\n\tspecial cases by calling gfc_walk_intrinsic_libfunc directly.\n\n2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/17298\n\t* gfortran.dg/transfer_array_intrinsic_1.f90: New test.\n\t* gfortran.dg/transfer_array_intrinsic_2.f90: New test.\n\nFrom-SVN: r112278", "tree": {"sha": "160547b8a0cbfdbccc504f41d26d8910f3255691", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/160547b8a0cbfdbccc504f41d26d8910f3255691"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/comments", "author": null, "committer": null, "parents": [{"sha": "ac382b62f1e24481216e7cd58aa57633f99154dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac382b62f1e24481216e7cd58aa57633f99154dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac382b62f1e24481216e7cd58aa57633f99154dd"}], "stats": {"total": 392, "additions": 389, "deletions": 3}, "files": [{"sha": "7e36bff416ae44da2c601eb92ed9feb1091ac2d4", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "patch": "@@ -1,3 +1,13 @@\n+2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/17298\n+\t*trans-intrinsic.c (gfc_conv_intrinsic_array_transfer): New\n+\tfunction to implement array valued TRANSFER intrinsic.\n+\t(gfc_conv_intrinsic_function): Call the new function if TRANSFER\n+\tand non-null se->ss.\n+\t(gfc_walk_intrinsic_function): Treat TRANSFER as one of the\n+\tspecial cases by calling gfc_walk_intrinsic_libfunc directly.\n+\n 2006-03-21  Toon Moene  <toon@moene.indiv.nluug.nl>\n \n \t* options.c (gfc_init_options): Initialize"}, {"sha": "87d3a742a05b660dcc498e4541cf1cf04f4e59d8", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 232, "deletions": 3, "changes": 235, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "patch": "@@ -2461,6 +2461,221 @@ gfc_conv_intrinsic_adjust (gfc_se * se, gfc_expr * expr, tree fndecl)\n }\n \n \n+/* Array transfer statement.\n+     DEST(1:N) = TRANSFER (SOURCE, MOLD[, SIZE])\n+   where:\n+     typeof<DEST> = typeof<MOLD>\n+   and:\n+     N = min (sizeof (SOURCE(:)), sizeof (DEST(:)),\n+\t      sizeof (DEST(0) * SIZE).  */\n+\n+static void\n+gfc_conv_intrinsic_array_transfer (gfc_se * se, gfc_expr * expr)\n+{\n+  tree tmp;\n+  tree extent;\n+  tree source;\n+  tree source_bytes;\n+  tree dest_word_len;\n+  tree size_words;\n+  tree size_bytes;\n+  tree upper;\n+  tree lower;\n+  tree stride;\n+  tree stmt;\n+  gfc_actual_arglist *arg;\n+  gfc_se argse;\n+  gfc_ss *ss;\n+  gfc_ss_info *info;\n+  stmtblock_t block;\n+  int n;\n+\n+  gcc_assert (se->loop);\n+  info = &se->ss->data.info;\n+\n+  /* Convert SOURCE.  The output from this stage is:-\n+\tsource_bytes = length of the source in bytes\n+\tsource = pointer to the source data.  */\n+  arg = expr->value.function.actual;\n+  gfc_init_se (&argse, NULL);\n+  ss = gfc_walk_expr (arg->expr);\n+\n+  source_bytes = gfc_create_var (gfc_array_index_type, NULL);\n+\n+  /* Obtain the pointer to source and the length of source in bytes.  */\n+  if (ss == gfc_ss_terminator)\n+    {\n+      gfc_conv_expr_reference (&argse, arg->expr);\n+      source = argse.expr;\n+\n+      /* Obtain the source word length.  */\n+      tmp = size_in_bytes(TREE_TYPE(TREE_TYPE (source)));\n+      tmp =  fold_convert (gfc_array_index_type, tmp);\n+    }\n+  else\n+    {\n+      gfc_init_se (&argse, NULL);\n+      argse.want_pointer = 0;\n+      gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+      source = gfc_conv_descriptor_data_get (argse.expr);\n+\n+      /* Repack the source if not a full variable array.  */\n+      if (!(arg->expr->expr_type == EXPR_VARIABLE\n+\t      && arg->expr->ref->u.ar.type == AR_FULL))\n+\t{\n+\t  tmp = build_fold_addr_expr (argse.expr);\n+\t  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+\t  source = build_function_call_expr (gfor_fndecl_in_pack, tmp);\n+\t  source = gfc_evaluate_now (source, &argse.pre);\n+\n+\t  /* Free the temporary.  */\n+\t  gfc_start_block (&block);\n+\t  tmp = convert (pvoid_type_node, source);\n+\t  tmp = gfc_chainon_list (NULL_TREE, tmp);\n+\t  tmp = build_function_call_expr (gfor_fndecl_internal_free, tmp);\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t  stmt = gfc_finish_block (&block);\n+\n+\t  /* Clean up if it was repacked.  */\n+\t  gfc_init_block (&block);\n+\t  tmp = gfc_conv_array_data (argse.expr);\n+\t  tmp = build2 (NE_EXPR, boolean_type_node, source, tmp);\n+\t  tmp = build3_v (COND_EXPR, tmp, stmt, build_empty_stmt ());\n+\t  gfc_add_expr_to_block (&block, tmp);\n+\t  gfc_add_block_to_block (&block, &se->post);\n+\t  gfc_init_block (&se->post);\n+\t  gfc_add_block_to_block (&se->post, &block);\n+\t}\n+\n+      /* Obtain the source word length.  */\n+      tmp = gfc_get_element_type (TREE_TYPE(argse.expr));\n+      tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n+\n+      /* Obtain the size of the array in bytes.  */\n+      extent = gfc_create_var (gfc_array_index_type, NULL);\n+      for (n = 0; n < arg->expr->rank; n++)\n+\t{\n+\t  tree idx;\n+\t  idx = gfc_rank_cst[n];\n+\t  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+\t  stride = gfc_conv_descriptor_stride (argse.expr, idx);\n+\t  lower = gfc_conv_descriptor_lbound (argse.expr, idx);\n+\t  upper = gfc_conv_descriptor_ubound (argse.expr, idx);\n+\t  tmp = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\tupper, lower);\n+\t  gfc_add_modify_expr (&argse.pre, extent, tmp);\n+\t  tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t\textent, gfc_index_one_node);\n+\t  tmp = build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\ttmp, source_bytes);\n+\t}\n+    }\n+\n+  gfc_add_modify_expr (&argse.pre, source_bytes, tmp);\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+\n+  /* Now convert MOLD.  The sole output is:\n+\tdest_word_len = destination word length in bytes.  */\n+  arg = arg->next;\n+\n+  gfc_init_se (&argse, NULL);\n+  ss = gfc_walk_expr (arg->expr);\n+\n+  if (ss == gfc_ss_terminator)\n+    {\n+      gfc_conv_expr_reference (&argse, arg->expr);\n+      tmp = TREE_TYPE(TREE_TYPE (argse.expr));\n+      tmp =  fold_convert (gfc_array_index_type, size_in_bytes(tmp));\n+    }\n+  else\n+    {\n+      gfc_init_se (&argse, NULL);\n+      argse.want_pointer = 0;\n+      gfc_conv_expr_descriptor (&argse, arg->expr, ss);\n+      tmp = gfc_get_element_type (TREE_TYPE(argse.expr));\n+      tmp = fold_convert (gfc_array_index_type, size_in_bytes (tmp));\n+    }\n+\n+  dest_word_len = gfc_create_var (gfc_array_index_type, NULL);\n+  gfc_add_modify_expr (&se->pre, dest_word_len, tmp);\n+\n+  /* Finally convert SIZE, if it is present.  */\n+  arg = arg->next;\n+  size_words = gfc_create_var (gfc_array_index_type, NULL);\n+\n+  if (arg->expr)\n+    {\n+      gfc_init_se (&argse, NULL);\n+      gfc_conv_expr_reference (&argse, arg->expr);\n+      tmp = convert (gfc_array_index_type,\n+\t\t\t build_fold_indirect_ref (argse.expr));\n+      gfc_add_block_to_block (&se->pre, &argse.pre);\n+      gfc_add_block_to_block (&se->post, &argse.post);\n+    }\n+  else\n+    tmp = NULL_TREE;\n+\n+  size_bytes = gfc_create_var (gfc_array_index_type, NULL);\n+  if (tmp != NULL_TREE)\n+    {\n+      tmp = build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t    tmp, dest_word_len);\n+      tmp = build2 (MIN_EXPR, gfc_array_index_type, tmp, source_bytes);\n+    }\n+  else\n+    tmp = source_bytes;\n+\n+  gfc_add_modify_expr (&se->pre, size_bytes, tmp);\n+  gfc_add_modify_expr (&se->pre, size_words,\n+\t\t       build2 (CEIL_DIV_EXPR, gfc_array_index_type,\n+\t\t\t       size_bytes, dest_word_len));\n+\n+  /* Evaluate the bounds of the result.  If the loop range exists, we have\n+     to check if it is too large.  If so, we modify loop->to be consistent\n+     with min(size, size(source)).  Otherwise, size is made consistent with\n+     the loop range, so that the right number of bytes is transferred.*/\n+  n = se->loop->order[0];\n+  if (se->loop->to[n] != NULL_TREE)\n+    {\n+      tmp = fold_build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t\t se->loop->to[n], se->loop->from[n]);\n+      tmp = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t    tmp, gfc_index_one_node);\n+      tmp = build2 (MIN_EXPR, gfc_array_index_type,\n+\t\t    tmp, size_words);\n+      gfc_add_modify_expr (&se->pre, size_words, tmp);\n+      gfc_add_modify_expr (&se->pre, size_bytes,\n+\t\t\t   build2 (MULT_EXPR, gfc_array_index_type,\n+\t\t\t   size_words, dest_word_len));\n+      upper = build2 (PLUS_EXPR, gfc_array_index_type,\n+\t\t      size_words, se->loop->from[n]);\n+      upper = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t      upper, gfc_index_one_node);\n+    }\n+  else\n+    {\n+      upper = build2 (MINUS_EXPR, gfc_array_index_type,\n+\t\t      size_words, gfc_index_one_node);\n+      se->loop->from[n] = gfc_index_zero_node;\n+    }\n+\n+  se->loop->to[n] = upper;\n+\n+  /* Build a destination descriptor, using the pointer, source, as the\n+     data field.  This is already allocated so set callee_alloc.  */\n+  tmp = gfc_typenode_for_spec (&expr->ts);\n+  gfc_trans_create_temp_array (&se->pre, &se->post, se->loop,\n+\t\t\t       info, tmp, false, false, true);\n+\n+  tmp = fold_convert (pvoid_type_node, source);\n+  gfc_conv_descriptor_data_set (&se->pre, info->descriptor, tmp);\n+  se->expr = info->descriptor;\n+  if (expr->ts.type == BT_CHARACTER)\n+    se->string_length = dest_word_len;\n+}\n+\n+\n /* Scalar transfer statement.\n    TRANSFER (source, mold) = *(typeof<mold> *)&source.  */\n \n@@ -2473,8 +2688,6 @@ gfc_conv_intrinsic_transfer (gfc_se * se, gfc_expr * expr)\n   tree ptr;\n   gfc_ss *ss;\n \n-  gcc_assert (!se->ss);\n-\n   /* Get a pointer to the source.  */\n   arg = expr->value.function.actual;\n   ss = gfc_walk_expr (arg->expr);\n@@ -3374,7 +3587,20 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       break;\n \n     case GFC_ISYM_TRANSFER:\n-      gfc_conv_intrinsic_transfer (se, expr);\n+      if (se->ss)\n+\t{\n+\t  if (se->ss->useflags)\n+\t    {\n+\t      /* Access the previously obtained result.  */\n+\t      gfc_conv_tmp_array_ref (se);\n+\t      gfc_advance_se_ss_chain (se);\n+\t      break;\n+\t    }\n+\t  else\n+\t    gfc_conv_intrinsic_array_transfer (se, expr);\n+\t}\n+      else\n+\tgfc_conv_intrinsic_transfer (se, expr);\n       break;\n \n     case GFC_ISYM_TTYNAM:\n@@ -3558,6 +3784,9 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n     case GFC_ISYM_UBOUND:\n       return gfc_walk_intrinsic_bound (ss, expr);\n \n+    case GFC_ISYM_TRANSFER:\n+      return gfc_walk_intrinsic_libfunc (ss, expr);\n+\n     default:\n       /* This probably meant someone forgot to add an intrinsic to the above\n          list(s) when they implemented it, or something's gone horribly wrong."}, {"sha": "20bb9c6568bf4c84c0acf8f901e0f3fdd73abf97", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "patch": "@@ -1,3 +1,9 @@\n+2006-03-22  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/17298\n+\t* gfortran.dg/transfer_array_intrinsic_1.f90: New test.\n+\t* gfortran.dg/transfer_array_intrinsic_2.f90: New test.\n+\n 2006-03-21  Janis Johnson  <janis187@us.ibm.com>\n \n \t* lib/gcc-dg.exp (cleanup-modules): New proc."}, {"sha": "c3d334dd8abfb0fe65fdd2505e364956fa796e12", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_1.f90", "status": "added", "additions": 118, "deletions": 0, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_1.f90?ref=0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "patch": "@@ -0,0 +1,118 @@\n+! { dg-do run }\n+! Tests the patch to implement the array version of the TRANSFER\n+! intrinsic (PR17298).\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+\n+   character(8) :: ch(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n+\n+! tests numeric transfers(including PR testcase).\n+\n+   call test1 ()\n+\n+! tests numeric/character transfers.\n+\n+   call test2 ()\n+\n+! Test dummies, automatic objects and assumed character length.\n+\n+   call test3 (ch, ch, ch, 8)\n+\n+contains\n+\n+   subroutine test1 ()\n+     complex(4) :: z = (1.0, 2.0)\n+     real(4) :: cmp(2), a(4, 4)\n+     integer(2) :: it(4, 2, 4), jt(32)\n+\n+! The PR testcase.\n+\n+     cmp = transfer (z, cmp) * 2.0\n+     if (any (cmp .ne. (/2.0, 4.0/))) call abort ()\n+\n+! Check that size smaller than the source word length is OK.\n+\n+     z = (-1.0, -2.0)\n+     cmp = transfer (z, cmp, 1) * 8.0\n+     if (any (cmp .ne. (/-8.0, 4.0/))) call abort ()\n+\n+! Check multi-dimensional sources and that transfer works as an actual\n+! argument of reshape.\n+\n+     a = reshape ((/(rand (), i = 1, 16)/), (/4,4/))\n+     jt = transfer (a, it)\n+     it = reshape (jt, (/4, 2, 4/))\n+     if (any (reshape (transfer (it, a), (/4,4/)) .ne. a)) call abort ()\n+\n+   end subroutine test1\n+\n+   subroutine test2 ()\n+     integer(4) :: y(4), z(2)\n+     character(4) :: ch(4)\n+     y = (/(i + ishft (i + 1, 8) + ishft (i + 2, 16) &\n+              + ishft (i + 3, 24), i = 65, 80 , 4)/)\n+\n+! Check source array sections in both directions.\n+\n+     ch = \"wxyz\"\n+     ch = transfer (y(2:4:2), ch)\n+     if (any (ch .ne. (/\"EFGH\",\"MNOP\",\"wxyz\",\"wxyz\"/))) call abort ()\n+     ch = \"wxyz\"\n+     ch = transfer (y(4:2:-2), ch)\n+     if (any (ch .ne. (/\"MNOP\",\"EFGH\",\"wxyz\",\"wxyz\"/))) call abort ()\n+\n+! Check that a complete array transfers with size absent.\n+\n+     ch = transfer (y, ch)\n+     if (any (ch .ne. (/\"ABCD\",\"EFGH\",\"IJKL\",\"MNOP\"/))) call abort ()\n+\n+! Check that a character array section is OK\n+\n+     z = transfer (ch(2:3), y)\n+     if (any (z .ne. y(2:3))) call abort ()\n+\n+! Check dest array sections in both directions.\n+\n+     ch = \"wxyz\"\n+     ch(3:4) = transfer (y, ch, 2)\n+     if (any (ch .ne. (/\"wxyz\",\"wxyz\",\"ABCD\",\"EFGH\"/))) call abort ()\n+     ch = \"wxyz\"\n+     ch(3:2:-1) = transfer (y, ch, 3)\n+     if (any (ch .ne. (/\"wxyz\",\"EFGH\",\"ABCD\",\"wxyz\"/))) call abort ()\n+\n+! Check that too large a value of size is cut off.\n+\n+     ch = \"wxyz\"\n+     ch(1:2) = transfer (y, ch, 3)\n+     if (any (ch .ne. (/\"ABCD\",\"EFGH\",\"wxyz\",\"wxyz\"/))) call abort ()\n+\n+! Make sure that character to numeric is OK.\n+\n+     z = transfer (ch, y)\n+     if (any (y(1:2) .ne. z)) call abort ()\n+\n+   end subroutine test2\n+\n+   subroutine test3 (ch1, ch2, ch3, clen)\n+     integer clen\n+     character(8) :: ch1(:)\n+     character(*) :: ch2(2)\n+     character(clen) :: ch3(2)\n+     character(8) :: cntrl(2) = (/\"lmnoPQRS\",\"LMNOpqrs\"/)\n+     integer(8) :: ic(2)\n+     ic = transfer (cntrl, ic)\n+\n+! Check assumed shape.\n+\n+     if (any (ic .ne. transfer (ch1, ic))) call abort ()\n+\n+! Check assumed character length.\n+\n+     if (any (ic .ne. transfer (ch2, ic))) call abort ()\n+\n+! Check automatic character length.\n+\n+     if (any (ic .ne. transfer (ch3, ic))) call abort ()\n+\n+  end subroutine test3\n+\n+end"}, {"sha": "7c35b61b987009a2b62bf104432332a075e76d0f", "filename": "gcc/testsuite/gfortran.dg/transfer_array_intrinsic_2.f90", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c5a42a660c636a39d6cfb73e0b2a1bc6552509b/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ftransfer_array_intrinsic_2.f90?ref=0c5a42a660c636a39d6cfb73e0b2a1bc6552509b", "patch": "@@ -0,0 +1,23 @@\n+! { dg-do run }\n+! { dg-options \"-fpack-derived\" }\n+   call test3()\n+contains\n+   subroutine test3 ()\n+     type mytype\n+       sequence\n+       real(8) :: x = 3.14159\n+       character(4) :: ch = \"wxyz\"\n+       integer(2) :: i = 77\n+     end type mytype\n+     type(mytype) :: z(2)\n+     character(1) :: c(32)\n+     character(4) :: chr\n+     real(8) :: a\n+     integer(2) :: l\n+     equivalence (a, c(15)), (chr, c(23)), (l, c(27))\n+     c = transfer(z, c)\n+     if (a .ne. z(1)%x) call abort ()\n+     if (chr .ne. z(1)%ch) call abort ()\n+     if (l .ne. z(1)%i) call abort ()\n+   end subroutine test3\n+end"}]}