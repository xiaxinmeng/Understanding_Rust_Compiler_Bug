{"sha": "9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWEwZGRlZWUwZmJkNmRhZjNkOThlZjQxNWJkYzQ1MzViMjcyYWZmOA==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:14:55Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2010-06-23T09:14:55Z"}, "message": "[multiple changes]\n\n2010-06-23  Thomas Quinot  <quinot@adacore.com>\n\n\t* sem_util.adb: Minor code cleanup: test for proper entity instead of\n\ttesting just Chars attribute when checking whether a given scope is\n\tSystem.\n\t* exp_ch4.adb, einfo.adb: Minor reformatting.\n\n2010-06-23  Vincent Celier  <celier@adacore.com>\n\n\tPR ada/44633\n\t* switch-m.adb (Normalize_Compiler_Switches): Take into account\n\tswitches -gnatB, -gnatD=nn, -gnatG (incuding -gnatG=nn), -gnatI,\n\t-gnatl=file, -gnatS, -gnatjnn, -gnateI=nn and -gnatWx.\n\n2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_res.adb (Resolve_Membership_Op): If left operand is a mixed mode\n\toperation with a universal real operand, and the right operand is a\n\trange with universal bounds, find unique fixed point that may be\n\tcandidate, and warn appropriately.\n\nFrom-SVN: r161264", "tree": {"sha": "ba972e95496f83c1a9713a42a9e7348d0dc60a2b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ba972e95496f83c1a9713a42a9e7348d0dc60a2b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/comments", "author": null, "committer": null, "parents": [{"sha": "bb481772fee85ad4f32f54687d6e0dacaa4e8e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bb481772fee85ad4f32f54687d6e0dacaa4e8e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bb481772fee85ad4f32f54687d6e0dacaa4e8e3a"}], "stats": {"total": 269, "additions": 178, "deletions": 91}, "files": [{"sha": "12e60cc7fef5669ae4c92abc088b78bbfa916d0b", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -1,3 +1,24 @@\n+2010-06-23  Thomas Quinot  <quinot@adacore.com>\n+\n+\t* sem_util.adb: Minor code cleanup: test for proper entity instead of\n+\ttesting just Chars attribute when checking whether a given scope is\n+\tSystem.\n+\t* exp_ch4.adb, einfo.adb: Minor reformatting.\n+\n+2010-06-23  Vincent Celier  <celier@adacore.com>\n+\n+\tPR ada/44633\n+\t* switch-m.adb (Normalize_Compiler_Switches): Take into account\n+\tswitches -gnatB, -gnatD=nn, -gnatG (incuding -gnatG=nn), -gnatI,\n+\t-gnatl=file, -gnatS, -gnatjnn, -gnateI=nn and -gnatWx.\n+\n+2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_res.adb (Resolve_Membership_Op): If left operand is a mixed mode\n+\toperation with a universal real operand, and the right operand is a\n+\trange with universal bounds, find unique fixed point that may be\n+\tcandidate, and warn appropriately.\n+\n 2010-06-23  Ed Schonberg  <schonberg@adacore.com>\n \n \t* sem_res.adb (Resolve_Intrinsic_Operator): Add guards to handle"}, {"sha": "f1145a1ac0738a414f295028ae38b6c6f2fbae82", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -5856,7 +5856,7 @@ package body Einfo is\n \n       return Convention (Id) in Foreign_Convention\n         or else (Convention (Id) = Convention_Intrinsic\n-                 and then Present (Interface_Name (Id)));\n+                   and then Present (Interface_Name (Id)));\n    end Has_Foreign_Convention;\n \n    ---------------------------"}, {"sha": "cf9f8d78fb4a07c5ed1f2dc07fb42f54d5a85cef", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 30, "deletions": 38, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -4378,9 +4378,9 @@ package body Exp_Ch4 is\n \n       --  Check case of explicit test for an expression in range of its\n       --  subtype. This is suspicious usage and we replace it with a 'Valid\n-      --  test and give a warning. For floating point types however, this\n-      --  is a standard way to check for finite numbers, and using 'Valid\n-      --  would typically be a pessimization\n+      --  test and give a warning. For floating point types however, this is a\n+      --  standard way to check for finite numbers, and using 'Valid vould\n+      --  typically be a pessimization.\n \n       if Is_Scalar_Type (Etype (Lop))\n         and then not Is_Floating_Point_Type (Etype (Lop))\n@@ -4420,9 +4420,9 @@ package body Exp_Ch4 is\n                         and then Comes_From_Source (N)\n                         and then not In_Instance;\n             --  This must be true for any of the optimization warnings, we\n-            --  clearly want to give them only for source with the flag on.\n-            --  We also skip these warnings in an instance since it may be\n-            --  the case that different instantiations have different ranges.\n+            --  clearly want to give them only for source with the flag on. We\n+            --  also skip these warnings in an instance since it may be the\n+            --  case that different instantiations have different ranges.\n \n             Warn2 : constant Boolean :=\n                       Warn1\n@@ -4431,8 +4431,8 @@ package body Exp_Ch4 is\n             --  For the case where only one bound warning is elided, we also\n             --  insist on an explicit range and an integer type. The reason is\n             --  that the use of enumeration ranges including an end point is\n-            --  common, as is the use of a subtype name, one of whose bounds\n-            --  is the same as the type of the expression.\n+            --  common, as is the use of a subtype name, one of whose bounds is\n+            --  the same as the type of the expression.\n \n          begin\n             --  If test is explicit x'first .. x'last, replace by valid check\n@@ -4477,8 +4477,8 @@ package body Exp_Ch4 is\n                return;\n             end if;\n \n-            --  If we have an explicit range, do a bit of optimization based\n-            --  on range analysis (we may be able to kill one or both checks).\n+            --  If we have an explicit range, do a bit of optimization based on\n+            --  range analysis (we may be able to kill one or both checks).\n \n             Lcheck := Compile_Time_Compare (Lop, Lo, Assume_Valid => False);\n             Ucheck := Compile_Time_Compare (Lop, Hi, Assume_Valid => False);\n@@ -4493,8 +4493,7 @@ package body Exp_Ch4 is\n                   Error_Msg_N (\"\\?value is known to be out of range\", N);\n                end if;\n \n-               Rewrite (N,\n-                 New_Reference_To (Standard_False, Loc));\n+               Rewrite (N, New_Reference_To (Standard_False, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n                Set_Is_Static_Expression (N, Static);\n \n@@ -4509,8 +4508,7 @@ package body Exp_Ch4 is\n                   Error_Msg_N (\"\\?value is known to be in range\", N);\n                end if;\n \n-               Rewrite (N,\n-                 New_Reference_To (Standard_True, Loc));\n+               Rewrite (N, New_Reference_To (Standard_True, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n                Set_Is_Static_Expression (N, Static);\n \n@@ -4624,9 +4622,7 @@ package body Exp_Ch4 is\n                   --  Update decoration of relocated node referenced by the\n                   --  SCIL node.\n \n-                  if Generate_SCIL\n-                    and then Present (SCIL_Node)\n-                  then\n+                  if Generate_SCIL and then Present (SCIL_Node) then\n                      Set_SCIL_Node (N, SCIL_Node);\n                   end if;\n                end if;\n@@ -4666,12 +4662,10 @@ package body Exp_Ch4 is\n                  Make_Raise_Program_Error (Loc,\n                    Reason => PE_Unchecked_Union_Restriction));\n \n-               --  Prevent Gigi from generating incorrect code by rewriting\n-               --  the test as a standard False.\n-\n-               Rewrite (N,\n-                 New_Occurrence_Of (Standard_False, Loc));\n+               --  Prevent Gigi from generating incorrect code by rewriting the\n+               --  test as False.\n \n+               Rewrite (N, New_Occurrence_Of (Standard_False, Loc));\n                return;\n             end if;\n \n@@ -4682,40 +4676,38 @@ package body Exp_Ch4 is\n             end if;\n \n             if not Is_Constrained (Typ) then\n-               Rewrite (N,\n-                 New_Reference_To (Standard_True, Loc));\n+               Rewrite (N, New_Reference_To (Standard_True, Loc));\n                Analyze_And_Resolve (N, Rtyp);\n \n             --  For the constrained array case, we have to check the subscripts\n             --  for an exact match if the lengths are non-zero (the lengths\n             --  must match in any case).\n \n             elsif Is_Array_Type (Typ) then\n-\n                Check_Subscripts : declare\n-                  function Construct_Attribute_Reference\n+                  function Build_Attribute_Reference\n                     (E   : Node_Id;\n                      Nam : Name_Id;\n                      Dim : Nat) return Node_Id;\n-                  --  Build attribute reference E'Nam(Dim)\n+                  --  Build attribute reference E'Nam (Dim)\n \n-                  -----------------------------------\n-                  -- Construct_Attribute_Reference --\n-                  -----------------------------------\n+                  -------------------------------\n+                  -- Build_Attribute_Reference --\n+                  -------------------------------\n \n-                  function Construct_Attribute_Reference\n+                  function Build_Attribute_Reference\n                     (E   : Node_Id;\n                      Nam : Name_Id;\n                      Dim : Nat) return Node_Id\n                   is\n                   begin\n                      return\n                        Make_Attribute_Reference (Loc,\n-                         Prefix => E,\n+                         Prefix         => E,\n                          Attribute_Name => Nam,\n-                         Expressions => New_List (\n+                         Expressions    => New_List (\n                            Make_Integer_Literal (Loc, Dim)));\n-                  end Construct_Attribute_Reference;\n+                  end Build_Attribute_Reference;\n \n                --  Start of processing for Check_Subscripts\n \n@@ -4724,21 +4716,21 @@ package body Exp_Ch4 is\n                      Evolve_And_Then (Cond,\n                        Make_Op_Eq (Loc,\n                          Left_Opnd  =>\n-                           Construct_Attribute_Reference\n+                           Build_Attribute_Reference\n                              (Duplicate_Subexpr_No_Checks (Obj),\n                               Name_First, J),\n                          Right_Opnd =>\n-                           Construct_Attribute_Reference\n+                           Build_Attribute_Reference\n                              (New_Occurrence_Of (Typ, Loc), Name_First, J)));\n \n                      Evolve_And_Then (Cond,\n                        Make_Op_Eq (Loc,\n                          Left_Opnd  =>\n-                           Construct_Attribute_Reference\n+                           Build_Attribute_Reference\n                              (Duplicate_Subexpr_No_Checks (Obj),\n                               Name_Last, J),\n                          Right_Opnd =>\n-                           Construct_Attribute_Reference\n+                           Build_Attribute_Reference\n                              (New_Occurrence_Of (Typ, Loc), Name_Last, J)));\n                   end loop;\n "}, {"sha": "33b48d60c31f52f55b070ce03e735c12368d485e", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -7036,6 +7036,18 @@ package body Sem_Res is\n          T := Intersect_Types (L, R);\n       end if;\n \n+      --  If mixed-mode operations are present and operands are all literal,\n+      --  the only interpretation involves Duration, which is probably not\n+      --  the intention of the programmer.\n+\n+      if T = Any_Fixed then\n+         T := Unique_Fixed_Point_Type (N);\n+\n+         if T = Any_Type then\n+            return;\n+         end if;\n+      end if;\n+\n       Resolve (L, T);\n       Check_Unset_Reference (L);\n "}, {"sha": "6339e3e9c65449d9277542a83c13dfb4baaa6335", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -1770,8 +1770,7 @@ package body Sem_Util is\n             --  appear in the target-specific extension to System.\n \n             if No (Id)\n-              and then Chars (B_Scope) = Name_System\n-              and then Scope (B_Scope) = Standard_Standard\n+              and then B_Scope = RTU_Entity (System)\n               and then Present_System_Aux\n             then\n                B_Scope := System_Aux_Id;\n@@ -7225,7 +7224,7 @@ package body Sem_Util is\n             and then Scope (Op) = System_Aux_Id)\n            or else\n            (True_VMS_Target\n-             and then Chars (Scope (Scope (Op))) = Name_System));\n+             and then Scope (Scope (Op)) = RTU_Entity (System)));\n    end Is_VMS_Operator;\n \n    -----------------"}, {"sha": "11491d3de42eb238a25b355fe0d006b4006469c5", "filename": "gcc/ada/switch-m.adb", "status": "modified", "additions": 112, "deletions": 49, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fswitch-m.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8/gcc%2Fada%2Fswitch-m.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-m.adb?ref=9a0ddeee0fbd6daf3d98ef415bdc4535b272aff8", "patch": "@@ -215,9 +215,9 @@ package body Switch.M is\n \n                   --  One-letter switches\n \n-                  when 'a' | 'A' | 'b' | 'c' | 'C' | 'D' | 'E' | 'f' |\n-                       'F' | 'g' | 'h' | 'H' | 'l' | 'L' | 'n' | 'N' |\n-                       'o' | 'O' | 'p' | 'P' | 'q' | 'Q' | 'r' | 's' |\n+                  when 'a' | 'A' | 'b' | 'B' | 'c' | 'C' | 'E' | 'f' |\n+                       'F' | 'g' | 'h' | 'H' | 'I' | 'L' | 'n' | 'N' |\n+                       'o' | 'p' | 'P' | 'q' | 'Q' | 'r' | 's' | 'S' |\n                        't' | 'u' | 'U' | 'v' | 'x' | 'X' | 'Z' =>\n                      Storing (First_Stored) := C;\n                      Add_Switch_Component\n@@ -226,10 +226,14 @@ package body Switch.M is\n \n                   --  One-letter switches followed by a positive number\n \n-                  when 'k' | 'm' | 'T' =>\n+                  when 'D' | 'G' | 'j' | 'k' | 'm' | 'T' =>\n                      Storing (First_Stored) := C;\n                      Last_Stored := First_Stored;\n \n+                     if Ptr <= Max and then Switch_Chars (Ptr) = '=' then\n+                        Ptr := Ptr + 1;\n+                     end if;\n+\n                      loop\n                         Ptr := Ptr + 1;\n                         exit when Ptr > Max\n@@ -268,68 +272,93 @@ package body Switch.M is\n \n                   when 'e' =>\n \n-                     --  Store -gnateD, -gnatep=, -gnateG and -gnateS in the\n-                     --  ALI file. The other -gnate switches do not need to be\n-                     --  stored.\n+                     --  Some of the gnate... switches are not stored\n \n                      Storing (First_Stored) := 'e';\n                      Ptr := Ptr + 1;\n \n-                     if Ptr > Max\n-                       or else (Switch_Chars (Ptr) /= 'D'\n-                                 and then Switch_Chars (Ptr) /= 'G'\n-                                 and then Switch_Chars (Ptr) /= 'p'\n-                                 and then Switch_Chars (Ptr) /= 'S')\n-                     then\n+                     if Ptr > Max then\n                         Last := 0;\n                         return;\n-                     end if;\n \n-                     --  Processing for -gnateD\n+                     else\n+                        case Switch_Chars (Ptr) is\n \n-                     if Switch_Chars (Ptr) = 'D' then\n-                        Storing (First_Stored + 1 ..\n-                                 First_Stored + Max - Ptr + 1) :=\n-                          Switch_Chars (Ptr .. Max);\n-                        Add_Switch_Component\n-                          (Storing (Storing'First ..\n-                                      First_Stored + Max - Ptr + 1));\n+                           when 'D' =>\n+                              Storing (First_Stored + 1 ..\n+                                         First_Stored + Max - Ptr + 1) :=\n+                                  Switch_Chars (Ptr .. Max);\n+                              Add_Switch_Component\n+                                (Storing (Storing'First ..\n+                                   First_Stored + Max - Ptr + 1));\n+                              Ptr := Max + 1;\n \n-                     --  Processing for -gnatep=\n+                           when 'G' =>\n+                              Ptr := Ptr + 1;\n+                              Add_Switch_Component (\"-gnateG\");\n \n-                     elsif Switch_Chars (Ptr) = 'p' then\n-                        Ptr := Ptr + 1;\n+                           when 'I' =>\n+                              Ptr := Ptr + 1;\n \n-                        if Ptr = Max then\n-                           Last := 0;\n-                           return;\n-                        end if;\n+                              declare\n+                                 First : constant Positive := Ptr - 1;\n+                              begin\n+                                 if Ptr <= Max and then\n+                                   Switch_Chars (Ptr) = '='\n+                                 then\n+                                    Ptr := Ptr + 1;\n+                                 end if;\n+\n+                                 while Ptr <= Max and then\n+                                       Switch_Chars (Ptr) in '0' .. '9'\n+                                 loop\n+                                    Ptr := Ptr + 1;\n+                                 end loop;\n+\n+                                 Storing (First_Stored + 1 ..\n+                                            First_Stored + Ptr - First) :=\n+                                     Switch_Chars (First .. Ptr - 1);\n+                                 Add_Switch_Component\n+                                   (Storing (Storing'First ..\n+                                      First_Stored + Ptr - First));\n+                              end;\n+\n+                           when 'p' =>\n+                              Ptr := Ptr + 1;\n \n-                        if Switch_Chars (Ptr) = '=' then\n-                           Ptr := Ptr + 1;\n-                        end if;\n+                              if Ptr = Max then\n+                                 Last := 0;\n+                                 return;\n+                              end if;\n \n-                        --  To normalize, always put a '=' after -gnatep.\n-                        --  Because that could lengthen the switch string,\n-                        --  declare a local variable.\n+                              if Switch_Chars (Ptr) = '=' then\n+                                 Ptr := Ptr + 1;\n+                              end if;\n \n-                        declare\n-                           To_Store : String (1 .. Max - Ptr + 9);\n-                        begin\n-                           To_Store (1 .. 8) := \"-gnatep=\";\n-                           To_Store (9 .. Max - Ptr + 9) :=\n-                             Switch_Chars (Ptr .. Max);\n-                           Add_Switch_Component (To_Store);\n-                        end;\n+                                 --  To normalize, always put a '=' after\n+                                 --  -gnatep. Because that could lengthen the\n+                                 --  switch string, declare a local variable.\n \n-                     elsif Switch_Chars (Ptr) = 'G' then\n-                        Add_Switch_Component (\"-gnateG\");\n+                              declare\n+                                 To_Store : String (1 .. Max - Ptr + 9);\n+                              begin\n+                                 To_Store (1 .. 8) := \"-gnatep=\";\n+                                 To_Store (9 .. Max - Ptr + 9) :=\n+                                   Switch_Chars (Ptr .. Max);\n+                                 Add_Switch_Component (To_Store);\n+                              end;\n \n-                     elsif Switch_Chars (Ptr) = 'S' then\n-                        Add_Switch_Component (\"-gnateS\");\n-                     end if;\n+                              return;\n \n-                     return;\n+                           when 'S' =>\n+                              Ptr := Ptr + 1;\n+                              Add_Switch_Component (\"-gnateS\");\n+\n+                           when others =>\n+                              Last := 0;\n+                              return;\n+                        end case;\n+                     end if;\n \n                   when 'i' =>\n                      Storing (First_Stored) := 'i';\n@@ -360,6 +389,20 @@ package body Switch.M is\n                         return;\n                      end if;\n \n+                  --  -gnatl may be -gnatl=<file name>\n+\n+                  when 'l' =>\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr > Max or else Switch_Chars (Ptr) /= '=' then\n+                        Add_Switch_Component (\"-gnatl\");\n+\n+                     else\n+                        Add_Switch_Component\n+                          (\"-gnatl\" & Switch_Chars (Ptr .. Max));\n+                        return;\n+                     end if;\n+\n                   --  -gnatR may be followed by '0', '1', '2' or '3',\n                   --  then by 's'\n \n@@ -395,6 +438,26 @@ package body Switch.M is\n                      Add_Switch_Component\n                        (Storing (Storing'First .. Last_Stored));\n \n+                  --  -gnatWx, x = 'h'. 'u', 's', 'e', '8' or 'b'\n+\n+                  when 'W' =>\n+                     Storing (First_Stored) := 'W';\n+                     Ptr := Ptr + 1;\n+\n+                     if Ptr <= Max then\n+                        case Switch_Chars (Ptr) is\n+                           when 'h' | 'u' | 's' | 'e' | '8' | 'b' =>\n+                              Storing (First_Stored + 1) := Switch_Chars (Ptr);\n+                              Add_Switch_Component\n+                                (Storing (Storing'First .. First_Stored + 1));\n+                              Ptr := Ptr + 1;\n+\n+                           when others =>\n+                              Last := 0;\n+                              return;\n+                        end case;\n+                     end if;\n+\n                   --  Multiple switches\n \n                   when 'V' | 'w' | 'y' =>"}]}