{"sha": "9fb832ce382d649b7687426e6bc4e5d3715cb78a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiODMyY2UzODJkNjQ5Yjc2ODc0MjZlNmJjNGU1ZDM3MTVjYjc4YQ==", "commit": {"author": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-20T01:40:10Z"}, "committer": {"name": "Kewen Lin", "email": "linkw@linux.ibm.com", "date": "2020-07-20T02:13:28Z"}, "message": "vect: Support length-based partial vectors approach\n\nPower9 supports vector load/store instruction lxvl/stxvl which allow\nus to operate partial vectors with one specific length.  This patch\nextends some of current mask-based partial vectors support code for\nlength-based approach, also adds some length specific support code.\nSo far it assumes that we can only have one partial vectors approach\nat the same time, it will disable to use partial vectors if both\napproaches co-exist.\n\nLike the description of optab len_load/len_store, the length-based\napproach can have two flavors, one is length in bytes, the other is\nlength in lanes.  This patch is mainly implemented and tested for\nlength in bytes, but as Richard S. suggested, most of code has\nconsidered both flavors.\n\nThis also introduces one parameter vect-partial-vector-usage allow\nusers to control when the loop vectorizer considers using partial\nvectors as an alternative to falling back to scalar code.\n\ngcc/ChangeLog:\n\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal):\n\tSet param_vect_partial_vector_usage to 0 explicitly.\n\t* doc/invoke.texi (vect-partial-vector-usage): Document new option.\n\t* optabs-query.c (get_len_load_store_mode): New function.\n\t* optabs-query.h (get_len_load_store_mode): New declare.\n\t* params.opt (vect-partial-vector-usage): New.\n\t* tree-vect-loop-manip.c (vect_set_loop_controls_directly): Add the\n\thandlings for vectorization using length-based partial vectors, call\n\tvect_gen_len for length generation, and rename some variables with\n\titems instead of scalars.\n\t(vect_set_loop_condition_partial_vectors): Add the handlings for\n\tvectorization using length-based partial vectors.\n\t(vect_do_peeling): Allow remaining eiters less than epilogue vf for\n\tLOOP_VINFO_USING_PARTIAL_VECTORS_P.\n\t* tree-vect-loop.c (_loop_vec_info::_loop_vec_info): Init\n\tepil_using_partial_vectors_p.\n\t(_loop_vec_info::~_loop_vec_info): Call release_vec_loop_controls\n\tfor lengths destruction.\n\t(vect_verify_loop_lens): New function.\n\t(vect_analyze_loop): Add handlings for epilogue of loop when it's\n\tmarked to use vectorization using partial vectors.\n\t(vect_analyze_loop_2): Add the check to allow only one vectorization\n\tapproach using partial vectorization at the same time.  Check param\n\tvect-partial-vector-usage for partial vectors decision.  Mark\n\tLOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P if the epilogue is\n\tconsiderable to use partial vectors.  Call release_vec_loop_controls\n\tfor lengths destruction.\n\t(vect_estimate_min_profitable_iters): Adjust for loop vectorization\n\tusing length-based partial vectors.\n\t(vect_record_loop_mask): Init factor to 1 for vectorization using\n\tmask-based partial vectors.\n\t(vect_record_loop_len): New function.\n\t(vect_get_loop_len): Likewise.\n\t* tree-vect-stmts.c (check_load_store_for_partial_vectors): Add\n\tchecks for vectorization using length-based partial vectors.  Factor\n\tsome code to lambda function get_valid_nvectors.\n\t(vectorizable_store): Add handlings when using length-based partial\n\tvectors.\n\t(vectorizable_load): Likewise.\n\t(vect_gen_len): New function.\n\t* tree-vectorizer.h (struct rgroup_controls): Add field factor\n\tmainly for length-based partial vectors.\n\t(vec_loop_lens): New typedef.\n\t(_loop_vec_info): Add lens and epil_using_partial_vectors_p.\n\t(LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P): New macro.\n\t(LOOP_VINFO_LENS): Likewise.\n\t(LOOP_VINFO_FULLY_WITH_LENGTH_P): Likewise.\n\t(vect_record_loop_len): New declare.\n\t(vect_get_loop_len): Likewise.\n\t(vect_gen_len): Likewise.", "tree": {"sha": "3b2bbe610050f8c47da747491c465de3889f1138", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b2bbe610050f8c47da747491c465de3889f1138"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fb832ce382d649b7687426e6bc4e5d3715cb78a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb832ce382d649b7687426e6bc4e5d3715cb78a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fb832ce382d649b7687426e6bc4e5d3715cb78a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fb832ce382d649b7687426e6bc4e5d3715cb78a/comments", "author": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jedilyn", "id": 38515402, "node_id": "MDQ6VXNlcjM4NTE1NDAy", "avatar_url": "https://avatars.githubusercontent.com/u/38515402?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jedilyn", "html_url": "https://github.com/jedilyn", "followers_url": "https://api.github.com/users/jedilyn/followers", "following_url": "https://api.github.com/users/jedilyn/following{/other_user}", "gists_url": "https://api.github.com/users/jedilyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/jedilyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jedilyn/subscriptions", "organizations_url": "https://api.github.com/users/jedilyn/orgs", "repos_url": "https://api.github.com/users/jedilyn/repos", "events_url": "https://api.github.com/users/jedilyn/events{/privacy}", "received_events_url": "https://api.github.com/users/jedilyn/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ca6f6698c70c4fa0c98822c73364063fa13ceea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ca6f6698c70c4fa0c98822c73364063fa13ceea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ca6f6698c70c4fa0c98822c73364063fa13ceea"}], "stats": {"total": 647, "additions": 552, "deletions": 95}, "files": [{"sha": "141854e5d824f9ff36064b9dd1da233735d4514d", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -4629,6 +4629,11 @@ rs6000_option_override_internal (bool global_init_p)\n       SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n \t\t\t   param_max_completely_peeled_insns, 400);\n \n+      /* Temporarily disable it for now since lxvl/stxvl on the default\n+\t supported hardware Power9 has unexpected performance behaviors.  */\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_vect_partial_vector_usage, 0);\n+\n       /* Use the 'model' -fsched-pressure algorithm by default.  */\n       SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n \t\t\t   param_sched_pressure_algorithm,"}, {"sha": "ba18e05fb1abd0034afb73fd4a20feac27133149", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -13448,6 +13448,15 @@ by the copy loop headers pass.\n @item vect-epilogues-nomask\n Enable loop epilogue vectorization using smaller vector size.\n \n+@item vect-partial-vector-usage\n+Controls when the loop vectorizer considers using partial vector loads\n+and stores as an alternative to falling back to scalar code.  0 stops\n+the vectorizer from ever using partial vector loads and stores.  1 allows\n+partial vector loads and stores if vectorization removes the need for the\n+code to iterate.  2 allows partial vector loads and stores in all loops.\n+The parameter only has an effect on targets that support partial\n+vector loads and stores.\n+\n @item slp-max-insns-in-bb\n Maximum number of instructions in basic block to be\n considered for SLP vectorization."}, {"sha": "be241057e4faee89d523d6ddbc24f57566816b46", "filename": "gcc/optabs-query.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Foptabs-query.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Foptabs-query.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.c?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -606,6 +606,33 @@ can_vec_mask_load_store_p (machine_mode mode,\n   return false;\n }\n \n+/* If target supports vector load/store with length for vector mode MODE,\n+   return the corresponding vector mode, otherwise return opt_machine_mode ().\n+   There are two flavors for vector load/store with length, one is to measure\n+   length with bytes, the other is to measure length with lanes.\n+   As len_{load,store} optabs point out, for the flavor with bytes, we use\n+   VnQI to wrap the other supportable same size vector modes.  */\n+\n+opt_machine_mode\n+get_len_load_store_mode (machine_mode mode, bool is_load)\n+{\n+  optab op = is_load ? len_load_optab : len_store_optab;\n+  gcc_assert (VECTOR_MODE_P (mode));\n+\n+  /* Check if length in lanes supported for this mode directly.  */\n+  if (direct_optab_handler (op, mode))\n+    return mode;\n+\n+  /* Check if length in bytes supported for same vector size VnQI.  */\n+  machine_mode vmode;\n+  poly_uint64 nunits = GET_MODE_SIZE (mode);\n+  if (related_vector_mode (mode, QImode, nunits).exists (&vmode)\n+      && direct_optab_handler (op, vmode))\n+    return vmode;\n+\n+  return opt_machine_mode ();\n+}\n+\n /* Return true if there is a compare_and_swap pattern.  */\n \n bool"}, {"sha": "603ea8cac0d1b565a30583fd260efae53e43fc24", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -188,6 +188,7 @@ enum insn_code find_widening_optab_handler_and_mode (optab, machine_mode,\n \t\t\t\t\t\t     machine_mode *);\n int can_mult_highpart_p (machine_mode, bool);\n bool can_vec_mask_load_store_p (machine_mode, machine_mode, bool);\n+opt_machine_mode get_len_load_store_mode (machine_mode, bool);\n bool can_compare_and_swap_p (machine_mode, bool);\n bool can_atomic_exchange_p (machine_mode, bool);\n bool can_atomic_load_p (machine_mode);"}, {"sha": "b36eee0e71f24a3201879b73c1cd0de3298cac32", "filename": "gcc/params.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -972,4 +972,8 @@ Bound on number of runtime checks inserted by the vectorizer's loop versioning f\n Common Joined UInteger Var(param_vect_max_version_for_alignment_checks) Init(6) Param Optimization\n Bound on number of runtime checks inserted by the vectorizer's loop versioning for alignment check.\n \n+-param=vect-partial-vector-usage=\n+Common Joined UInteger Var(param_vect_partial_vector_usage) Init(2) IntegerRange(0, 2) Param Optimization\n+Controls how loop vectorizer uses partial vectors.  0 means never, 1 means only for loops whose need to iterate can be removed, 2 means for all loops.  The default value is 2.\n+\n ; This comment is to ensure we retain the blank line above."}, {"sha": "490e7befea398aba1a8576370130de9f8edba857", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 109, "deletions": 73, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -399,19 +399,20 @@ vect_maybe_permute_loop_masks (gimple_seq *seq, rgroup_controls *dest_rgm,\n \n    It is known that:\n \n-     NITERS * RGC->max_nscalars_per_iter\n+     NITERS * RGC->max_nscalars_per_iter * RGC->factor\n \n    does not overflow.  However, MIGHT_WRAP_P says whether an induction\n    variable that starts at 0 and has step:\n \n-     VF * RGC->max_nscalars_per_iter\n+     VF * RGC->max_nscalars_per_iter * RGC->factor\n \n    might overflow before hitting a value above:\n \n-     (NITERS + NITERS_SKIP) * RGC->max_nscalars_per_iter\n+     (NITERS + NITERS_SKIP) * RGC->max_nscalars_per_iter * RGC->factor\n \n    This means that we cannot guarantee that such an induction variable\n-   would ever hit a value that produces a set of all-false masks for RGC.  */\n+   would ever hit a value that produces a set of all-false masks or zero\n+   lengths for RGC.  */\n \n static tree\n vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n@@ -422,40 +423,46 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n {\n   tree compare_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n   tree iv_type = LOOP_VINFO_RGROUP_IV_TYPE (loop_vinfo);\n+  bool use_masks_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n+\n   tree ctrl_type = rgc->type;\n-  unsigned int nscalars_per_iter = rgc->max_nscalars_per_iter;\n-  poly_uint64 nscalars_per_ctrl = TYPE_VECTOR_SUBPARTS (ctrl_type);\n+  unsigned int nitems_per_iter = rgc->max_nscalars_per_iter * rgc->factor;\n+  poly_uint64 nitems_per_ctrl = TYPE_VECTOR_SUBPARTS (ctrl_type) * rgc->factor;\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n+  tree length_limit = NULL_TREE;\n+  /* For length, we need length_limit to ensure length in range.  */\n+  if (!use_masks_p)\n+    length_limit = build_int_cst (compare_type, nitems_per_ctrl);\n \n-  /* Calculate the maximum number of scalar values that the rgroup\n+  /* Calculate the maximum number of item values that the rgroup\n      handles in total, the number that it handles for each iteration\n      of the vector loop, and the number that it should skip during the\n      first iteration of the vector loop.  */\n-  tree nscalars_total = niters;\n-  tree nscalars_step = build_int_cst (iv_type, vf);\n-  tree nscalars_skip = niters_skip;\n-  if (nscalars_per_iter != 1)\n+  tree nitems_total = niters;\n+  tree nitems_step = build_int_cst (iv_type, vf);\n+  tree nitems_skip = niters_skip;\n+  if (nitems_per_iter != 1)\n     {\n       /* We checked before setting LOOP_VINFO_USING_PARTIAL_VECTORS_P that\n \t these multiplications don't overflow.  */\n-      tree compare_factor = build_int_cst (compare_type, nscalars_per_iter);\n-      tree iv_factor = build_int_cst (iv_type, nscalars_per_iter);\n-      nscalars_total = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n-\t\t\t\t     nscalars_total, compare_factor);\n-      nscalars_step = gimple_build (preheader_seq, MULT_EXPR, iv_type,\n-\t\t\t\t    nscalars_step, iv_factor);\n-      if (nscalars_skip)\n-\tnscalars_skip = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n-\t\t\t\t      nscalars_skip, compare_factor);\n-    }\n-\n-  /* Create an induction variable that counts the number of scalars\n+      tree compare_factor = build_int_cst (compare_type, nitems_per_iter);\n+      tree iv_factor = build_int_cst (iv_type, nitems_per_iter);\n+      nitems_total = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n+\t\t\t\t   nitems_total, compare_factor);\n+      nitems_step = gimple_build (preheader_seq, MULT_EXPR, iv_type,\n+\t\t\t\t  nitems_step, iv_factor);\n+      if (nitems_skip)\n+\tnitems_skip = gimple_build (preheader_seq, MULT_EXPR, compare_type,\n+\t\t\t\t    nitems_skip, compare_factor);\n+    }\n+\n+  /* Create an induction variable that counts the number of items\n      processed.  */\n   tree index_before_incr, index_after_incr;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n   standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n-  create_iv (build_int_cst (iv_type, 0), nscalars_step, NULL_TREE, loop,\n+  create_iv (build_int_cst (iv_type, 0), nitems_step, NULL_TREE, loop,\n \t     &incr_gsi, insert_after, &index_before_incr, &index_after_incr);\n \n   tree zero_index = build_int_cst (compare_type, 0);\n@@ -466,70 +473,70 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n       /* In principle the loop should stop iterating once the incremented\n \t IV reaches a value greater than or equal to:\n \n-\t   NSCALARS_TOTAL +[infinite-prec] NSCALARS_SKIP\n+\t   NITEMS_TOTAL +[infinite-prec] NITEMS_SKIP\n \n \t However, there's no guarantee that this addition doesn't overflow\n \t the comparison type, or that the IV hits a value above it before\n \t wrapping around.  We therefore adjust the limit down by one\n \t IV step:\n \n-\t   (NSCALARS_TOTAL +[infinite-prec] NSCALARS_SKIP)\n-\t   -[infinite-prec] NSCALARS_STEP\n+\t   (NITEMS_TOTAL +[infinite-prec] NITEMS_SKIP)\n+\t   -[infinite-prec] NITEMS_STEP\n \n \t and compare the IV against this limit _before_ incrementing it.\n \t Since the comparison type is unsigned, we actually want the\n \t subtraction to saturate at zero:\n \n-\t   (NSCALARS_TOTAL +[infinite-prec] NSCALARS_SKIP)\n-\t   -[sat] NSCALARS_STEP\n+\t   (NITEMS_TOTAL +[infinite-prec] NITEMS_SKIP)\n+\t   -[sat] NITEMS_STEP\n \n-\t And since NSCALARS_SKIP < NSCALARS_STEP, we can reassociate this as:\n+\t And since NITEMS_SKIP < NITEMS_STEP, we can reassociate this as:\n \n-\t   NSCALARS_TOTAL -[sat] (NSCALARS_STEP - NSCALARS_SKIP)\n+\t   NITEMS_TOTAL -[sat] (NITEMS_STEP - NITEMS_SKIP)\n \n \t where the rightmost subtraction can be done directly in\n \t COMPARE_TYPE.  */\n       test_index = index_before_incr;\n       tree adjust = gimple_convert (preheader_seq, compare_type,\n-\t\t\t\t    nscalars_step);\n-      if (nscalars_skip)\n+\t\t\t\t    nitems_step);\n+      if (nitems_skip)\n \tadjust = gimple_build (preheader_seq, MINUS_EXPR, compare_type,\n-\t\t\t       adjust, nscalars_skip);\n+\t\t\t       adjust, nitems_skip);\n       test_limit = gimple_build (preheader_seq, MAX_EXPR, compare_type,\n-\t\t\t\t nscalars_total, adjust);\n+\t\t\t\t nitems_total, adjust);\n       test_limit = gimple_build (preheader_seq, MINUS_EXPR, compare_type,\n \t\t\t\t test_limit, adjust);\n       test_gsi = &incr_gsi;\n \n       /* Get a safe limit for the first iteration.  */\n-      if (nscalars_skip)\n+      if (nitems_skip)\n \t{\n-\t  /* The first vector iteration can handle at most NSCALARS_STEP\n-\t     scalars.  NSCALARS_STEP <= CONST_LIMIT, and adding\n-\t     NSCALARS_SKIP to that cannot overflow.  */\n+\t  /* The first vector iteration can handle at most NITEMS_STEP\n+\t     items.  NITEMS_STEP <= CONST_LIMIT, and adding\n+\t     NITEMS_SKIP to that cannot overflow.  */\n \t  tree const_limit = build_int_cst (compare_type,\n \t\t\t\t\t    LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t\t\t\t    * nscalars_per_iter);\n+\t\t\t\t\t    * nitems_per_iter);\n \t  first_limit = gimple_build (preheader_seq, MIN_EXPR, compare_type,\n-\t\t\t\t      nscalars_total, const_limit);\n+\t\t\t\t      nitems_total, const_limit);\n \t  first_limit = gimple_build (preheader_seq, PLUS_EXPR, compare_type,\n-\t\t\t\t      first_limit, nscalars_skip);\n+\t\t\t\t      first_limit, nitems_skip);\n \t}\n       else\n \t/* For the first iteration it doesn't matter whether the IV hits\n-\t   a value above NSCALARS_TOTAL.  That only matters for the latch\n+\t   a value above NITEMS_TOTAL.  That only matters for the latch\n \t   condition.  */\n-\tfirst_limit = nscalars_total;\n+\tfirst_limit = nitems_total;\n     }\n   else\n     {\n       /* Test the incremented IV, which will always hit a value above\n \t the bound before wrapping.  */\n       test_index = index_after_incr;\n-      test_limit = nscalars_total;\n-      if (nscalars_skip)\n+      test_limit = nitems_total;\n+      if (nitems_skip)\n \ttest_limit = gimple_build (preheader_seq, PLUS_EXPR, compare_type,\n-\t\t\t\t   test_limit, nscalars_skip);\n+\t\t\t\t   test_limit, nitems_skip);\n       test_gsi = &loop_cond_gsi;\n \n       first_limit = test_limit;\n@@ -547,18 +554,17 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n   unsigned int i;\n   FOR_EACH_VEC_ELT_REVERSE (rgc->controls, i, ctrl)\n     {\n-      /* Previous controls will cover BIAS scalars.  This control covers the\n+      /* Previous controls will cover BIAS items.  This control covers the\n \t next batch.  */\n-      poly_uint64 bias = nscalars_per_ctrl * i;\n+      poly_uint64 bias = nitems_per_ctrl * i;\n       tree bias_tree = build_int_cst (compare_type, bias);\n-      gimple *tmp_stmt;\n \n       /* See whether the first iteration of the vector loop is known\n \t to have a full control.  */\n       poly_uint64 const_limit;\n       bool first_iteration_full\n \t= (poly_int_tree_p (first_limit, &const_limit)\n-\t   && known_ge (const_limit, (i + 1) * nscalars_per_ctrl));\n+\t   && known_ge (const_limit, (i + 1) * nitems_per_ctrl));\n \n       /* Rather than have a new IV that starts at BIAS and goes up to\n \t TEST_LIMIT, prefer to use the same 0-based IV for each control\n@@ -574,7 +580,7 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t\t\t\t\t  bias_tree);\n \t}\n \n-      /* Create the initial control.  First include all scalars that\n+      /* Create the initial control.  First include all items that\n \t are within the loop limit.  */\n       tree init_ctrl = NULL_TREE;\n       if (!first_iteration_full)\n@@ -591,27 +597,38 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t    }\n \t  else\n \t    {\n-\t      /* FIRST_LIMIT is the maximum number of scalars handled by the\n+\t      /* FIRST_LIMIT is the maximum number of items handled by the\n \t\t first iteration of the vector loop.  Test the portion\n \t\t associated with this control.  */\n \t      start = bias_tree;\n \t      end = first_limit;\n \t    }\n \n-\t  init_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"max_mask\");\n-\t  tmp_stmt = vect_gen_while (init_ctrl, start, end);\n-\t  gimple_seq_add_stmt (preheader_seq, tmp_stmt);\n+\t  if (use_masks_p)\n+\t    {\n+\t      init_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"max_mask\");\n+\t      gimple *tmp_stmt = vect_gen_while (init_ctrl, start, end);\n+\t      gimple_seq_add_stmt (preheader_seq, tmp_stmt);\n+\t    }\n+\t  else\n+\t    {\n+\t      init_ctrl = make_temp_ssa_name (compare_type, NULL, \"max_len\");\n+\t      gimple_seq seq = vect_gen_len (init_ctrl, start,\n+\t\t\t\t\t     end, length_limit);\n+\t      gimple_seq_add_seq (preheader_seq, seq);\n+\t    }\n \t}\n \n       /* Now AND out the bits that are within the number of skipped\n-\t scalars.  */\n+\t items.  */\n       poly_uint64 const_skip;\n-      if (nscalars_skip\n-\t  && !(poly_int_tree_p (nscalars_skip, &const_skip)\n+      if (nitems_skip\n+\t  && !(poly_int_tree_p (nitems_skip, &const_skip)\n \t       && known_le (const_skip, bias)))\n \t{\n+\t  gcc_assert (use_masks_p);\n \t  tree unskipped_mask = vect_gen_while_not (preheader_seq, ctrl_type,\n-\t\t\t\t\t\t    bias_tree, nscalars_skip);\n+\t\t\t\t\t\t    bias_tree, nitems_skip);\n \t  if (init_ctrl)\n \t    init_ctrl = gimple_build (preheader_seq, BIT_AND_EXPR, ctrl_type,\n \t\t\t\t      init_ctrl, unskipped_mask);\n@@ -620,13 +637,28 @@ vect_set_loop_controls_directly (class loop *loop, loop_vec_info loop_vinfo,\n \t}\n \n       if (!init_ctrl)\n-\t/* First iteration is full.  */\n-\tinit_ctrl = build_minus_one_cst (ctrl_type);\n+\t{\n+\t  /* First iteration is full.  */\n+\t  if (use_masks_p)\n+\t    init_ctrl = build_minus_one_cst (ctrl_type);\n+\t  else\n+\t    init_ctrl = length_limit;\n+\t}\n \n       /* Get the control value for the next iteration of the loop.  */\n-      next_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"next_mask\");\n-      gcall *call = vect_gen_while (next_ctrl, test_index, this_test_limit);\n-      gsi_insert_before (test_gsi, call, GSI_SAME_STMT);\n+      if (use_masks_p)\n+\t{\n+\t  next_ctrl = make_temp_ssa_name (ctrl_type, NULL, \"next_mask\");\n+\t  gcall *call = vect_gen_while (next_ctrl, test_index, this_test_limit);\n+\t  gsi_insert_before (test_gsi, call, GSI_SAME_STMT);\n+\t}\n+      else\n+\t{\n+\t  next_ctrl = make_temp_ssa_name (compare_type, NULL, \"next_len\");\n+\t  gimple_seq seq = vect_gen_len (next_ctrl, test_index, this_test_limit,\n+\t\t\t\t\t length_limit);\n+\t  gsi_insert_seq_before (test_gsi, seq, GSI_SAME_STMT);\n+\t}\n \n       vect_set_loop_control (loop, ctrl, init_ctrl, next_ctrl);\n     }\n@@ -652,6 +684,7 @@ vect_set_loop_condition_partial_vectors (class loop *loop,\n   gimple_seq preheader_seq = NULL;\n   gimple_seq header_seq = NULL;\n \n+  bool use_masks_p = LOOP_VINFO_FULLY_MASKED_P (loop_vinfo);\n   tree compare_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n   unsigned int compare_precision = TYPE_PRECISION (compare_type);\n   tree orig_niters = niters;\n@@ -686,28 +719,30 @@ vect_set_loop_condition_partial_vectors (class loop *loop,\n   tree test_ctrl = NULL_TREE;\n   rgroup_controls *rgc;\n   unsigned int i;\n-  vec_loop_masks *masks = &LOOP_VINFO_MASKS (loop_vinfo);\n-  FOR_EACH_VEC_ELT (*masks, i, rgc)\n+  auto_vec<rgroup_controls> *controls = use_masks_p\n+\t\t\t\t\t  ? &LOOP_VINFO_MASKS (loop_vinfo)\n+\t\t\t\t\t  : &LOOP_VINFO_LENS (loop_vinfo);\n+  FOR_EACH_VEC_ELT (*controls, i, rgc)\n     if (!rgc->controls.is_empty ())\n       {\n \t/* First try using permutes.  This adds a single vector\n \t   instruction to the loop for each mask, but needs no extra\n \t   loop invariants or IVs.  */\n \tunsigned int nmasks = i + 1;\n-\tif ((nmasks & 1) == 0)\n+\tif (use_masks_p && (nmasks & 1) == 0)\n \t  {\n-\t    rgroup_controls *half_rgc = &(*masks)[nmasks / 2 - 1];\n+\t    rgroup_controls *half_rgc = &(*controls)[nmasks / 2 - 1];\n \t    if (!half_rgc->controls.is_empty ()\n \t\t&& vect_maybe_permute_loop_masks (&header_seq, rgc, half_rgc))\n \t      continue;\n \t  }\n \n \t/* See whether zero-based IV would ever generate all-false masks\n-\t   before wrapping around.  */\n+\t   or zero length before wrapping around.  */\n+\tunsigned nitems_per_iter = rgc->max_nscalars_per_iter * rgc->factor;\n \tbool might_wrap_p\n \t  = (iv_limit == -1\n-\t     || (wi::min_precision (iv_limit * rgc->max_nscalars_per_iter,\n-\t\t\t\t    UNSIGNED)\n+\t     || (wi::min_precision (iv_limit * nitems_per_iter, UNSIGNED)\n \t\t > compare_precision));\n \n \t/* Set up all controls for this group.  */\n@@ -2568,7 +2603,8 @@ vect_do_peeling (loop_vec_info loop_vinfo, tree niters, tree nitersm1,\n   if (vect_epilogues\n       && LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n       && prolog_peeling >= 0\n-      && known_eq (vf, lowest_vf))\n+      && known_eq (vf, lowest_vf)\n+      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (epilogue_vinfo))\n     {\n       unsigned HOST_WIDE_INT eiters\n \t= (LOOP_VINFO_INT_NITERS (loop_vinfo)"}, {"sha": "e933441b922c2561ed8bcf007e6fba63d3452e4c", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 211, "deletions": 6, "changes": 217, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -816,6 +816,7 @@ _loop_vec_info::_loop_vec_info (class loop *loop_in, vec_info_shared *shared)\n     vectorizable (false),\n     can_use_partial_vectors_p (true),\n     using_partial_vectors_p (false),\n+    epil_using_partial_vectors_p (false),\n     peeling_for_gaps (false),\n     peeling_for_niter (false),\n     no_data_dependencies (false),\n@@ -898,6 +899,7 @@ _loop_vec_info::~_loop_vec_info ()\n   free (bbs);\n \n   release_vec_loop_controls (&masks);\n+  release_vec_loop_controls (&lens);\n   delete ivexpr_map;\n   delete scan_map;\n   epilogue_vinfos.release ();\n@@ -1072,6 +1074,81 @@ vect_verify_full_masking (loop_vec_info loop_vinfo)\n   return true;\n }\n \n+/* Check whether we can use vector access with length based on precison\n+   comparison.  So far, to keep it simple, we only allow the case that the\n+   precision of the target supported length is larger than the precision\n+   required by loop niters.  */\n+\n+static bool\n+vect_verify_loop_lens (loop_vec_info loop_vinfo)\n+{\n+  if (LOOP_VINFO_LENS (loop_vinfo).is_empty ())\n+    return false;\n+\n+  unsigned int max_nitems_per_iter = 1;\n+  unsigned int i;\n+  rgroup_controls *rgl;\n+  /* Find the maximum number of items per iteration for every rgroup.  */\n+  FOR_EACH_VEC_ELT (LOOP_VINFO_LENS (loop_vinfo), i, rgl)\n+    {\n+      unsigned nitems_per_iter = rgl->max_nscalars_per_iter * rgl->factor;\n+      max_nitems_per_iter = MAX (max_nitems_per_iter, nitems_per_iter);\n+    }\n+\n+  /* Work out how many bits we need to represent the length limit.  */\n+  unsigned int min_ni_prec\n+    = vect_min_prec_for_max_niters (loop_vinfo, max_nitems_per_iter);\n+\n+  /* Now use the maximum of below precisions for one suitable IV type:\n+     - the IV's natural precision\n+     - the precision needed to hold: the maximum number of scalar\n+       iterations multiplied by the scale factor (min_ni_prec above)\n+     - the Pmode precision\n+\n+     If min_ni_prec is less than the precision of the current niters,\n+     we perfer to still use the niters type.  Prefer to use Pmode and\n+     wider IV to avoid narrow conversions.  */\n+\n+  unsigned int ni_prec\n+    = TYPE_PRECISION (TREE_TYPE (LOOP_VINFO_NITERS (loop_vinfo)));\n+  min_ni_prec = MAX (min_ni_prec, ni_prec);\n+  min_ni_prec = MAX (min_ni_prec, GET_MODE_BITSIZE (Pmode));\n+\n+  tree iv_type = NULL_TREE;\n+  opt_scalar_int_mode tmode_iter;\n+  FOR_EACH_MODE_IN_CLASS (tmode_iter, MODE_INT)\n+    {\n+      scalar_mode tmode = tmode_iter.require ();\n+      unsigned int tbits = GET_MODE_BITSIZE (tmode);\n+\n+      /* ??? Do we really want to construct one IV whose precision exceeds\n+\t BITS_PER_WORD?  */\n+      if (tbits > BITS_PER_WORD)\n+\tbreak;\n+\n+      /* Find the first available standard integral type.  */\n+      if (tbits >= min_ni_prec && targetm.scalar_mode_supported_p (tmode))\n+\t{\n+\t  iv_type = build_nonstandard_integer_type (tbits, true);\n+\t  break;\n+\t}\n+    }\n+\n+  if (!iv_type)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't vectorize with length-based partial vectors\"\n+\t\t\t \" because there is no suitable iv type.\\n\");\n+      return false;\n+    }\n+\n+  LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo) = iv_type;\n+  LOOP_VINFO_RGROUP_IV_TYPE (loop_vinfo) = iv_type;\n+\n+  return true;\n+}\n+\n /* Calculate the cost of one scalar iteration of the loop.  */\n static void\n vect_compute_single_scalar_iteration_cost (loop_vec_info loop_vinfo)\n@@ -2168,11 +2245,48 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       return ok;\n     }\n \n-  /* Decide whether to use a fully-masked loop for this vectorization\n-     factor.  */\n-  LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo)\n-    = (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n-       && vect_verify_full_masking (loop_vinfo));\n+  /* For now, we don't expect to mix both masking and length approaches for one\n+     loop, disable it if both are recorded.  */\n+  if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+      && !LOOP_VINFO_MASKS (loop_vinfo).is_empty ()\n+      && !LOOP_VINFO_LENS (loop_vinfo).is_empty ())\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't vectorize a loop with partial vectors\"\n+\t\t\t \" because we don't expect to mix different\"\n+\t\t\t \" approaches with partial vectors for the\"\n+\t\t\t \" same loop.\\n\");\n+      LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+    }\n+\n+  /* Decide whether to vectorize a loop with partial vectors for\n+     this vectorization factor.  */\n+  if (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo))\n+    {\n+      if (param_vect_partial_vector_usage == 0)\n+\tLOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+      else if (vect_verify_full_masking (loop_vinfo)\n+\t       || vect_verify_loop_lens (loop_vinfo))\n+\t{\n+\t  /* The epilogue and other known niters less than VF\n+\t    cases can still use vector access with length fully.  */\n+\t  if (param_vect_partial_vector_usage == 1\n+\t      && !LOOP_VINFO_EPILOGUE_P (loop_vinfo)\n+\t      && !vect_known_niters_smaller_than_vf (loop_vinfo))\n+\t    {\n+\t      LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+\t      LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n+\t    }\n+\t  else\n+\t    LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = true;\n+\t}\n+      else\n+\tLOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+    }\n+  else\n+    LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+\n   if (dump_enabled_p ())\n     {\n       if (LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo))\n@@ -2404,6 +2518,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n     = init_cost (LOOP_VINFO_LOOP (loop_vinfo));\n   /* Reset accumulated rgroup information.  */\n   release_vec_loop_controls (&LOOP_VINFO_MASKS (loop_vinfo));\n+  release_vec_loop_controls (&LOOP_VINFO_LENS (loop_vinfo));\n   /* Reset assorted flags.  */\n   LOOP_VINFO_PEELING_FOR_NITER (loop_vinfo) = false;\n   LOOP_VINFO_PEELING_FOR_GAPS (loop_vinfo) = false;\n@@ -2690,7 +2805,10 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t\tlowest_th = ordered_min (lowest_th, th);\n \t    }\n \t  else\n-\t    delete loop_vinfo;\n+\t    {\n+\t      delete loop_vinfo;\n+\t      loop_vinfo = opt_loop_vec_info::success (NULL);\n+\t    }\n \n \t  /* Only vectorize epilogues if PARAM_VECT_EPILOGUES_NOMASK is\n \t     enabled, SIMDUID is not set, it is the innermost loop and we have\n@@ -2715,13 +2833,31 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n       else\n \t{\n \t  delete loop_vinfo;\n+\t  loop_vinfo = opt_loop_vec_info::success (NULL);\n \t  if (fatal)\n \t    {\n \t      gcc_checking_assert (first_loop_vinfo == NULL);\n \t      break;\n \t    }\n \t}\n \n+      /* Handle the case that the original loop can use partial\n+\t vectorization, but want to only adopt it for the epilogue.\n+\t The retry should be in the same mode as original.  */\n+      if (vect_epilogues\n+\t  && loop_vinfo\n+\t  && LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P (loop_vinfo))\n+\t{\n+\t  gcc_assert (LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo)\n+\t\t      && !LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo));\n+\t  if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t\t     \"***** Re-trying analysis with same vector mode\"\n+\t\t\t     \" %s for epilogue with partial vectors.\\n\",\n+\t\t\t     GET_MODE_NAME (loop_vinfo->vector_mode));\n+\t  continue;\n+\t}\n+\n       if (mode_i < vector_modes.length ()\n \t  && VECTOR_MODE_P (autodetected_vector_mode)\n \t  && (related_vector_mode (vector_modes[mode_i],\n@@ -3562,6 +3698,11 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \t\t\t    target_cost_data, num_masks - 1, vector_stmt,\n \t\t\t    NULL, NULL_TREE, 0, vect_body);\n     }\n+  else if (LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo))\n+    {\n+      peel_iters_prologue = 0;\n+      peel_iters_epilogue = 0;\n+    }\n   else if (npeel < 0)\n     {\n       peel_iters_prologue = assumed_vf / 2;\n@@ -8194,6 +8335,7 @@ vect_record_loop_mask (loop_vec_info loop_vinfo, vec_loop_masks *masks,\n     {\n       rgm->max_nscalars_per_iter = nscalars_per_iter;\n       rgm->type = truth_type_for (vectype);\n+      rgm->factor = 1;\n     }\n }\n \n@@ -8246,6 +8388,69 @@ vect_get_loop_mask (gimple_stmt_iterator *gsi, vec_loop_masks *masks,\n   return mask;\n }\n \n+/* Record that LOOP_VINFO would need LENS to contain a sequence of NVECTORS\n+   lengths for controlling an operation on VECTYPE.  The operation splits\n+   each element of VECTYPE into FACTOR separate subelements, measuring the\n+   length as a number of these subelements.  */\n+\n+void\n+vect_record_loop_len (loop_vec_info loop_vinfo, vec_loop_lens *lens,\n+\t\t      unsigned int nvectors, tree vectype, unsigned int factor)\n+{\n+  gcc_assert (nvectors != 0);\n+  if (lens->length () < nvectors)\n+    lens->safe_grow_cleared (nvectors);\n+  rgroup_controls *rgl = &(*lens)[nvectors - 1];\n+\n+  /* The number of scalars per iteration, scalar occupied bytes and\n+     the number of vectors are both compile-time constants.  */\n+  unsigned int nscalars_per_iter\n+    = exact_div (nvectors * TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t LOOP_VINFO_VECT_FACTOR (loop_vinfo)).to_constant ();\n+\n+  if (rgl->max_nscalars_per_iter < nscalars_per_iter)\n+    {\n+      /* For now, we only support cases in which all loads and stores fall back\n+\t to VnQI or none do.  */\n+      gcc_assert (!rgl->max_nscalars_per_iter\n+\t\t  || (rgl->factor == 1 && factor == 1)\n+\t\t  || (rgl->max_nscalars_per_iter * rgl->factor\n+\t\t      == nscalars_per_iter * factor));\n+      rgl->max_nscalars_per_iter = nscalars_per_iter;\n+      rgl->type = vectype;\n+      rgl->factor = factor;\n+    }\n+}\n+\n+/* Given a complete set of length LENS, extract length number INDEX for an\n+   rgroup that operates on NVECTORS vectors, where 0 <= INDEX < NVECTORS.  */\n+\n+tree\n+vect_get_loop_len (loop_vec_info loop_vinfo, vec_loop_lens *lens,\n+\t\t   unsigned int nvectors, unsigned int index)\n+{\n+  rgroup_controls *rgl = &(*lens)[nvectors - 1];\n+\n+  /* Populate the rgroup's len array, if this is the first time we've\n+     used it.  */\n+  if (rgl->controls.is_empty ())\n+    {\n+      rgl->controls.safe_grow_cleared (nvectors);\n+      for (unsigned int i = 0; i < nvectors; ++i)\n+\t{\n+\t  tree len_type = LOOP_VINFO_RGROUP_COMPARE_TYPE (loop_vinfo);\n+\t  gcc_assert (len_type != NULL_TREE);\n+\t  tree len = make_temp_ssa_name (len_type, NULL, \"loop_len\");\n+\n+\t  /* Provide a dummy definition until the real one is available.  */\n+\t  SSA_NAME_DEF_STMT (len) = gimple_build_nop ();\n+\t  rgl->controls[i] = len;\n+\t}\n+    }\n+\n+  return rgl->controls[index];\n+}\n+\n /* Scale profiling counters by estimation for LOOP which is vectorized\n    by factor VF.  */\n "}, {"sha": "31af46ae19c8683963b4cfc52c70425982d85354", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 154, "deletions": 13, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -1713,29 +1713,58 @@ check_load_store_for_partial_vectors (loop_vec_info loop_vinfo, tree vectype,\n       return;\n     }\n \n-  machine_mode mask_mode;\n-  if (!VECTOR_MODE_P (vecmode)\n-      || !targetm.vectorize.get_mask_mode (vecmode).exists (&mask_mode)\n-      || !can_vec_mask_load_store_p (vecmode, mask_mode, is_load))\n+  if (!VECTOR_MODE_P (vecmode))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"can't use a fully-masked loop because the target\"\n-\t\t\t \" doesn't have the appropriate masked load or\"\n-\t\t\t \" store.\\n\");\n+\t\t\t \"can't operate on partial vectors when emulating\"\n+\t\t\t \" vector operations.\\n\");\n       LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n       return;\n     }\n+\n   /* We might load more scalars than we need for permuting SLP loads.\n      We checked in get_group_load_store_type that the extra elements\n      don't leak into a new vector.  */\n+  auto get_valid_nvectors = [] (poly_uint64 size, poly_uint64 nunits)\n+  {\n+    unsigned int nvectors;\n+    if (can_div_away_from_zero_p (size, nunits, &nvectors))\n+      return nvectors;\n+    gcc_unreachable ();\n+  };\n+\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n   poly_uint64 vf = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n-  unsigned int nvectors;\n-  if (can_div_away_from_zero_p (group_size * vf, nunits, &nvectors))\n-    vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype, scalar_mask);\n-  else\n-    gcc_unreachable ();\n+  machine_mode mask_mode;\n+  bool using_partial_vectors_p = false;\n+  if (targetm.vectorize.get_mask_mode (vecmode).exists (&mask_mode)\n+      && can_vec_mask_load_store_p (vecmode, mask_mode, is_load))\n+    {\n+      unsigned int nvectors = get_valid_nvectors (group_size * vf, nunits);\n+      vect_record_loop_mask (loop_vinfo, masks, nvectors, vectype, scalar_mask);\n+      using_partial_vectors_p = true;\n+    }\n+\n+  machine_mode vmode;\n+  if (get_len_load_store_mode (vecmode, is_load).exists (&vmode))\n+    {\n+      unsigned int nvectors = get_valid_nvectors (group_size * vf, nunits);\n+      vec_loop_lens *lens = &LOOP_VINFO_LENS (loop_vinfo);\n+      unsigned factor = (vecmode == vmode) ? 1 : GET_MODE_UNIT_SIZE (vecmode);\n+      vect_record_loop_len (loop_vinfo, lens, nvectors, vectype, factor);\n+      using_partial_vectors_p = true;\n+    }\n+\n+  if (!using_partial_vectors_p)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"can't operate on partial vectors because the\"\n+\t\t\t \" target doesn't have the appropriate partial\"\n+\t\t\t \" vectorization load or store.\\n\");\n+      LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P (loop_vinfo) = false;\n+    }\n }\n \n /* Return the mask input to a masked load or store.  VEC_MASK is the vectorized\n@@ -7694,6 +7723,14 @@ vectorizable_store (vec_info *vinfo,\n     = (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n        ? &LOOP_VINFO_MASKS (loop_vinfo)\n        : NULL);\n+  vec_loop_lens *loop_lens\n+    = (loop_vinfo && LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo)\n+       ? &LOOP_VINFO_LENS (loop_vinfo)\n+       : NULL);\n+\n+  /* Shouldn't go with length-based approach if fully masked.  */\n+  gcc_assert (!loop_lens || !loop_masks);\n+\n   /* Targets with store-lane instructions must not require explicit\n      realignment.  vect_supportable_dr_alignment always returns either\n      dr_aligned or dr_unaligned_supported for masked operations.  */\n@@ -8033,6 +8070,41 @@ vectorizable_store (vec_info *vinfo,\n \t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n \t\t  new_stmt = call;\n \t\t}\n+\t      else if (loop_lens)\n+\t\t{\n+\t\t  tree final_len\n+\t\t    = vect_get_loop_len (loop_vinfo, loop_lens,\n+\t\t\t\t\t vec_num * ncopies, vec_num * j + i);\n+\t\t  align = least_bit_hwi (misalign | align);\n+\t\t  tree ptr = build_int_cst (ref_type, align);\n+\t\t  machine_mode vmode = TYPE_MODE (vectype);\n+\t\t  opt_machine_mode new_ovmode\n+\t\t    = get_len_load_store_mode (vmode, false);\n+\t\t  machine_mode new_vmode = new_ovmode.require ();\n+\t\t  /* Need conversion if it's wrapped with VnQI.  */\n+\t\t  if (vmode != new_vmode)\n+\t\t    {\n+\t\t      tree new_vtype\n+\t\t\t= build_vector_type_for_mode (unsigned_intQI_type_node,\n+\t\t\t\t\t\t      new_vmode);\n+\t\t      tree var\n+\t\t\t= vect_get_new_ssa_name (new_vtype, vect_simple_var);\n+\t\t      vec_oprnd\n+\t\t\t= build1 (VIEW_CONVERT_EXPR, new_vtype, vec_oprnd);\n+\t\t      gassign *new_stmt\n+\t\t\t= gimple_build_assign (var, VIEW_CONVERT_EXPR,\n+\t\t\t\t\t       vec_oprnd);\n+\t\t      vect_finish_stmt_generation (vinfo, stmt_info, new_stmt,\n+\t\t\t\t\t\t   gsi);\n+\t\t      vec_oprnd = var;\n+\t\t    }\n+\t\t  gcall *call\n+\t\t    = gimple_build_call_internal (IFN_LEN_STORE, 4, dataref_ptr,\n+\t\t\t\t\t\t  ptr, final_len, vec_oprnd);\n+\t\t  gimple_call_set_nothrow (call, true);\n+\t\t  vect_finish_stmt_generation (vinfo, stmt_info, call, gsi);\n+\t\t  new_stmt = call;\n+\t\t}\n \t      else\n \t\t{\n \t\t  data_ref = fold_build2 (MEM_REF, vectype,\n@@ -8577,7 +8649,7 @@ vectorizable_load (vec_info *vinfo,\n       unsigned HOST_WIDE_INT cst_offset = 0;\n       tree dr_offset;\n \n-      gcc_assert (!LOOP_VINFO_FULLY_MASKED_P (loop_vinfo));\n+      gcc_assert (!LOOP_VINFO_USING_PARTIAL_VECTORS_P (loop_vinfo));\n       gcc_assert (!nested_in_vect_loop);\n \n       if (grouped_load)\n@@ -8859,6 +8931,14 @@ vectorizable_load (vec_info *vinfo,\n     = (loop_vinfo && LOOP_VINFO_FULLY_MASKED_P (loop_vinfo)\n        ? &LOOP_VINFO_MASKS (loop_vinfo)\n        : NULL);\n+  vec_loop_lens *loop_lens\n+    = (loop_vinfo && LOOP_VINFO_FULLY_WITH_LENGTH_P (loop_vinfo)\n+       ? &LOOP_VINFO_LENS (loop_vinfo)\n+       : NULL);\n+\n+  /* Shouldn't go with length-based approach if fully masked.  */\n+  gcc_assert (!loop_lens || !loop_masks);\n+\n   /* Targets with store-lane instructions must not require explicit\n      realignment.  vect_supportable_dr_alignment always returns either\n      dr_aligned or dr_unaligned_supported for masked operations.  */\n@@ -9247,6 +9327,43 @@ vectorizable_load (vec_info *vinfo,\n \t\t\tnew_stmt = call;\n \t\t\tdata_ref = NULL_TREE;\n \t\t      }\n+\t\t    else if (loop_lens && memory_access_type != VMAT_INVARIANT)\n+\t\t      {\n+\t\t\ttree final_len\n+\t\t\t  = vect_get_loop_len (loop_vinfo, loop_lens,\n+\t\t\t\t\t       vec_num * ncopies,\n+\t\t\t\t\t       vec_num * j + i);\n+\t\t\talign = least_bit_hwi (misalign | align);\n+\t\t\ttree ptr = build_int_cst (ref_type, align);\n+\t\t\tgcall *call\n+\t\t\t  = gimple_build_call_internal (IFN_LEN_LOAD, 3,\n+\t\t\t\t\t\t\tdataref_ptr, ptr,\n+\t\t\t\t\t\t\tfinal_len);\n+\t\t\tgimple_call_set_nothrow (call, true);\n+\t\t\tnew_stmt = call;\n+\t\t\tdata_ref = NULL_TREE;\n+\n+\t\t\t/* Need conversion if it's wrapped with VnQI.  */\n+\t\t\tmachine_mode vmode = TYPE_MODE (vectype);\n+\t\t\topt_machine_mode new_ovmode\n+\t\t\t  = get_len_load_store_mode (vmode, true);\n+\t\t\tmachine_mode new_vmode = new_ovmode.require ();\n+\t\t\tif (vmode != new_vmode)\n+\t\t\t  {\n+\t\t\t    tree qi_type = unsigned_intQI_type_node;\n+\t\t\t    tree new_vtype\n+\t\t\t      = build_vector_type_for_mode (qi_type, new_vmode);\n+\t\t\t    tree var = vect_get_new_ssa_name (new_vtype,\n+\t\t\t\t\t\t\t      vect_simple_var);\n+\t\t\t    gimple_set_lhs (call, var);\n+\t\t\t    vect_finish_stmt_generation (vinfo, stmt_info, call,\n+\t\t\t\t\t\t\t gsi);\n+\t\t\t    tree op = build1 (VIEW_CONVERT_EXPR, vectype, var);\n+\t\t\t    new_stmt\n+\t\t\t      = gimple_build_assign (vec_dest,\n+\t\t\t\t\t\t     VIEW_CONVERT_EXPR, op);\n+\t\t\t  }\n+\t\t      }\n \t\t    else\n \t\t      {\n \t\t\ttree ltype = vectype;\n@@ -11967,3 +12084,27 @@ vect_get_vector_types_for_stmt (vec_info *vinfo, stmt_vec_info stmt_info,\n   *nunits_vectype_out = nunits_vectype;\n   return opt_result::success ();\n }\n+\n+/* Generate and return statement sequence that sets vector length LEN that is:\n+\n+   min_of_start_and_end = min (START_INDEX, END_INDEX);\n+   left_len = END_INDEX - min_of_start_and_end;\n+   rhs = min (left_len, LEN_LIMIT);\n+   LEN = rhs;  */\n+\n+gimple_seq\n+vect_gen_len (tree len, tree start_index, tree end_index, tree len_limit)\n+{\n+  gimple_seq stmts = NULL;\n+  tree len_type = TREE_TYPE (len);\n+  gcc_assert (TREE_TYPE (start_index) == len_type);\n+\n+  tree min = gimple_build (&stmts, MIN_EXPR, len_type, start_index, end_index);\n+  tree left_len = gimple_build (&stmts, MINUS_EXPR, len_type, end_index, min);\n+  tree rhs = gimple_build (&stmts, MIN_EXPR, len_type, left_len, len_limit);\n+  gimple* stmt = gimple_build_assign (len, rhs);\n+  gimple_seq_add_stmt (&stmts, stmt);\n+\n+  return stmts;\n+}\n+"}, {"sha": "5466c78c20bdf341b8a64af6ba2970edc9f31a2b", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fb832ce382d649b7687426e6bc4e5d3715cb78a/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=9fb832ce382d649b7687426e6bc4e5d3715cb78a", "patch": "@@ -480,14 +480,21 @@ is_a_helper <_bb_vec_info *>::test (vec_info *i)\n    first level being indexed by nV - 1 (since nV == 0 doesn't exist) and\n    the second being indexed by the mask index 0 <= i < nV.  */\n \n-/* The controls (like masks) needed by rgroups with nV vectors,\n+/* The controls (like masks or lengths) needed by rgroups with nV vectors,\n    according to the description above.  */\n struct rgroup_controls {\n   /* The largest nS for all rgroups that use these controls.  */\n   unsigned int max_nscalars_per_iter;\n \n-  /* The type of control to use, based on the highest nS recorded above.\n-     For mask-based approach, it's used for mask_type.  */\n+  /* For the largest nS recorded above, the loop controls divide each scalar\n+     into FACTOR equal-sized pieces.  This is useful if we need to split\n+     element-based accesses into byte-based accesses.  */\n+  unsigned int factor;\n+\n+  /* This is a vector type with MAX_NSCALARS_PER_ITER * VF / nV elements.\n+     For mask-based controls, it is the type of the masks in CONTROLS.\n+     For length-based controls, it can be any vector type that has the\n+     specified number of elements; the type of the elements doesn't matter.  */\n   tree type;\n \n   /* A vector of nV controls, in iteration order.  */\n@@ -496,6 +503,8 @@ struct rgroup_controls {\n \n typedef auto_vec<rgroup_controls> vec_loop_masks;\n \n+typedef auto_vec<rgroup_controls> vec_loop_lens;\n+\n typedef auto_vec<std::pair<data_reference*, tree> > drs_init_vec;\n \n /*-----------------------------------------------------------------*/\n@@ -543,6 +552,10 @@ typedef class _loop_vec_info : public vec_info {\n      on inactive scalars.  */\n   vec_loop_masks masks;\n \n+  /* The lengths that a loop with length should use to avoid operating\n+     on inactive scalars.  */\n+  vec_loop_lens lens;\n+\n   /* Set of scalar conditions that have loop mask applied.  */\n   scalar_cond_masked_set_type scalar_cond_masked_set;\n \n@@ -651,6 +664,10 @@ typedef class _loop_vec_info : public vec_info {\n      the vector loop can handle fewer than VF scalars.  */\n   bool using_partial_vectors_p;\n \n+  /* True if we've decided to use partially-populated vectors for the\n+     epilogue of loop.  */\n+  bool epil_using_partial_vectors_p;\n+\n   /* When we have grouped data accesses with gaps, we may introduce invalid\n      memory accesses.  We peel the last iteration of the loop to prevent\n      this.  */\n@@ -714,9 +731,12 @@ typedef class _loop_vec_info : public vec_info {\n #define LOOP_VINFO_VECTORIZABLE_P(L)       (L)->vectorizable\n #define LOOP_VINFO_CAN_USE_PARTIAL_VECTORS_P(L) (L)->can_use_partial_vectors_p\n #define LOOP_VINFO_USING_PARTIAL_VECTORS_P(L) (L)->using_partial_vectors_p\n+#define LOOP_VINFO_EPIL_USING_PARTIAL_VECTORS_P(L)                             \\\n+  (L)->epil_using_partial_vectors_p\n #define LOOP_VINFO_VECT_FACTOR(L)          (L)->vectorization_factor\n #define LOOP_VINFO_MAX_VECT_FACTOR(L)      (L)->max_vectorization_factor\n #define LOOP_VINFO_MASKS(L)                (L)->masks\n+#define LOOP_VINFO_LENS(L)                 (L)->lens\n #define LOOP_VINFO_MASK_SKIP_NITERS(L)     (L)->mask_skip_niters\n #define LOOP_VINFO_RGROUP_COMPARE_TYPE(L)  (L)->rgroup_compare_type\n #define LOOP_VINFO_RGROUP_IV_TYPE(L)       (L)->rgroup_iv_type\n@@ -754,6 +774,10 @@ typedef class _loop_vec_info : public vec_info {\n   (LOOP_VINFO_USING_PARTIAL_VECTORS_P (L)\t\\\n    && !LOOP_VINFO_MASKS (L).is_empty ())\n \n+#define LOOP_VINFO_FULLY_WITH_LENGTH_P(L)\t\\\n+  (LOOP_VINFO_USING_PARTIAL_VECTORS_P (L)\t\\\n+   && !LOOP_VINFO_LENS (L).is_empty ())\n+\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIGNMENT(L)\t\\\n   ((L)->may_misalign_stmts.length () > 0)\n #define LOOP_REQUIRES_VERSIONING_FOR_ALIAS(L)\t\t\\\n@@ -1953,6 +1977,11 @@ extern void vect_record_loop_mask (loop_vec_info, vec_loop_masks *,\n \t\t\t\t   unsigned int, tree, tree);\n extern tree vect_get_loop_mask (gimple_stmt_iterator *, vec_loop_masks *,\n \t\t\t\tunsigned int, tree, unsigned int);\n+extern void vect_record_loop_len (loop_vec_info, vec_loop_lens *, unsigned int,\n+\t\t\t\t  tree, unsigned int);\n+extern tree vect_get_loop_len (loop_vec_info, vec_loop_lens *, unsigned int,\n+\t\t\t       unsigned int);\n+extern gimple_seq vect_gen_len (tree, tree, tree, tree);\n extern stmt_vec_info info_for_reduction (vec_info *, stmt_vec_info);\n \n /* Drive for loop transformation stage.  */"}]}