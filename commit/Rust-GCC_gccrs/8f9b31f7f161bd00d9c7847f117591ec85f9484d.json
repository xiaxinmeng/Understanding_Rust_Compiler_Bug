{"sha": "8f9b31f7f161bd00d9c7847f117591ec85f9484d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGY5YjMxZjdmMTYxYmQwMGQ5Yzc4NDdmMTE3NTkxZWM4NWY5NDg0ZA==", "commit": {"author": {"name": "Trevor Saunders", "email": "tbsaunde+gcc@tbsaunde.org", "date": "2017-05-14T00:38:53Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2017-05-14T00:38:53Z"}, "message": "move several bitmaps from gc memory to the default obstack and use auto_bitmap\n\nThese places where probably trying to use the default bitmap obstack,\nbut passing 0 to bitmap_initialize actually uses gc allocation.  In any\ncase they are all cleaned up before going out of scope so using\nauto_bitmap should be fine.\n\ngcc/ChangeLog:\n\n2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n\n\t* haifa-sched.c (estimate_shadow_tick): Replace manual bitmap\n\tmanagement with auto_bitmap.\n\t(fix_inter_tick): Likewise.\n\t(fix_recovery_deps): Likewise.\n\t* ira.c (add_store_equivs): Likewise.\n\t(find_moveable_pseudos): Likewise.\n\t(split_live_ranges_for_shrink_wrap): Likewise.\n\t* print-rtl.c (rtx_reuse_manager::rtx_reuse_manager): Likewise.\n\t(rtx_reuse_manager::seen_def_p): Likewise.\n\t(rtx_reuse_manager::set_seen_def): Likewise.\n\t* print-rtl.h (class rtx_reuse_manager): Likewise.\n\nFrom-SVN: r248022", "tree": {"sha": "d8ac6eee25a394987b1ddd260544bce385bd0857", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d8ac6eee25a394987b1ddd260544bce385bd0857"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8f9b31f7f161bd00d9c7847f117591ec85f9484d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b31f7f161bd00d9c7847f117591ec85f9484d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f9b31f7f161bd00d9c7847f117591ec85f9484d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f9b31f7f161bd00d9c7847f117591ec85f9484d/comments", "author": null, "committer": null, "parents": [{"sha": "0e3de1d41eb6179eac75c8ae44c16c1ba1d2f5dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e3de1d41eb6179eac75c8ae44c16c1ba1d2f5dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e3de1d41eb6179eac75c8ae44c16c1ba1d2f5dd"}], "stats": {"total": 128, "additions": 52, "deletions": 76}, "files": [{"sha": "d73ea2e393ccbfbce4e717c86b8eb007cf4f0445", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8f9b31f7f161bd00d9c7847f117591ec85f9484d", "patch": "@@ -1,3 +1,17 @@\n+2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n+\n+\t* haifa-sched.c (estimate_shadow_tick): Replace manual bitmap\n+\tmanagement with auto_bitmap.\n+\t(fix_inter_tick): Likewise.\n+\t(fix_recovery_deps): Likewise.\n+\t* ira.c (add_store_equivs): Likewise.\n+\t(find_moveable_pseudos): Likewise.\n+\t(split_live_ranges_for_shrink_wrap): Likewise.\n+\t* print-rtl.c (rtx_reuse_manager::rtx_reuse_manager): Likewise.\n+\t(rtx_reuse_manager::seen_def_p): Likewise.\n+\t(rtx_reuse_manager::set_seen_def): Likewise.\n+\t* print-rtl.h (class rtx_reuse_manager): Likewise.\n+\n 2017-05-13  Trevor Saunders  <tbsaunde+gcc@tbsaunde.org>\n \n \t* bt-load.c (combine_btr_defs): Use auto_bitmap to manage bitmap"}, {"sha": "1fcc01d04aea6c39072096734c06f09290f3dd67", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=8f9b31f7f161bd00d9c7847f117591ec85f9484d", "patch": "@@ -4843,14 +4843,12 @@ estimate_insn_tick (bitmap processed, rtx_insn *insn, int budget)\n static int\n estimate_shadow_tick (struct delay_pair *p)\n {\n-  bitmap_head processed;\n+  auto_bitmap processed;\n   int t;\n   bool cutoff;\n-  bitmap_initialize (&processed, 0);\n \n-  cutoff = !estimate_insn_tick (&processed, p->i2,\n+  cutoff = !estimate_insn_tick (processed, p->i2,\n \t\t\t\tmax_insn_queue_index + pair_delay (p));\n-  bitmap_clear (&processed);\n   if (cutoff)\n     return max_insn_queue_index;\n   t = INSN_TICK_ESTIMATE (p->i2) - (clock_var + pair_delay (p) + 1);\n@@ -7515,15 +7513,13 @@ static void\n fix_inter_tick (rtx_insn *head, rtx_insn *tail)\n {\n   /* Set of instructions with corrected INSN_TICK.  */\n-  bitmap_head processed;\n+  auto_bitmap processed;\n   /* ??? It is doubtful if we should assume that cycle advance happens on\n      basic block boundaries.  Basically insns that are unconditionally ready\n      on the start of the block are more preferable then those which have\n      a one cycle dependency over insn from the previous block.  */\n   int next_clock = clock_var + 1;\n \n-  bitmap_initialize (&processed, 0);\n-\n   /* Iterates over scheduled instructions and fix their INSN_TICKs and\n      INSN_TICKs of dependent instructions, so that INSN_TICKs are consistent\n      across different blocks.  */\n@@ -7539,7 +7535,7 @@ fix_inter_tick (rtx_insn *head, rtx_insn *tail)\n \t  gcc_assert (tick >= MIN_TICK);\n \n \t  /* Fix INSN_TICK of instruction from just scheduled block.  */\n-\t  if (bitmap_set_bit (&processed, INSN_LUID (head)))\n+\t  if (bitmap_set_bit (processed, INSN_LUID (head)))\n \t    {\n \t      tick -= next_clock;\n \n@@ -7563,7 +7559,7 @@ fix_inter_tick (rtx_insn *head, rtx_insn *tail)\n \t\t  /* If NEXT has its INSN_TICK calculated, fix it.\n \t\t     If not - it will be properly calculated from\n \t\t     scratch later in fix_tick_ready.  */\n-\t\t  && bitmap_set_bit (&processed, INSN_LUID (next)))\n+\t\t  && bitmap_set_bit (processed, INSN_LUID (next)))\n \t\t{\n \t\t  tick -= next_clock;\n \n@@ -7580,7 +7576,6 @@ fix_inter_tick (rtx_insn *head, rtx_insn *tail)\n \t    }\n \t}\n     }\n-  bitmap_clear (&processed);\n }\n \n /* Check if NEXT is ready to be added to the ready or queue list.\n@@ -8617,9 +8612,7 @@ fix_recovery_deps (basic_block rec)\n {\n   rtx_insn *note, *insn, *jump;\n   auto_vec<rtx_insn *, 10> ready_list;\n-  bitmap_head in_ready;\n-\n-  bitmap_initialize (&in_ready, 0);\n+  auto_bitmap in_ready;\n \n   /* NOTE - a basic block note.  */\n   note = NEXT_INSN (BB_HEAD (rec));\n@@ -8642,7 +8635,7 @@ fix_recovery_deps (basic_block rec)\n \t    {\n \t      sd_delete_dep (sd_it);\n \n-\t      if (bitmap_set_bit (&in_ready, INSN_LUID (consumer)))\n+\t      if (bitmap_set_bit (in_ready, INSN_LUID (consumer)))\n \t\tready_list.safe_push (consumer);\n \t    }\n \t  else\n@@ -8657,8 +8650,6 @@ fix_recovery_deps (basic_block rec)\n     }\n   while (insn != note);\n \n-  bitmap_clear (&in_ready);\n-\n   /* Try to add instructions to the ready or queue list.  */\n   unsigned int i;\n   rtx_insn *temp;"}, {"sha": "36a779bd37f0e5e0c060dac19ffbab688c326675", "filename": "gcc/ira.c", "status": "modified", "additions": 28, "deletions": 56, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=8f9b31f7f161bd00d9c7847f117591ec85f9484d", "patch": "@@ -3635,16 +3635,15 @@ update_equiv_regs (void)\n static void\n add_store_equivs (void)\n {\n-  bitmap_head seen_insns;\n+  auto_bitmap seen_insns;\n \n-  bitmap_initialize (&seen_insns, NULL);\n   for (rtx_insn *insn = get_insns (); insn; insn = NEXT_INSN (insn))\n     {\n       rtx set, src, dest;\n       unsigned regno;\n       rtx_insn *init_insn;\n \n-      bitmap_set_bit (&seen_insns, INSN_UID (insn));\n+      bitmap_set_bit (seen_insns, INSN_UID (insn));\n \n       if (! INSN_P (insn))\n \tcontinue;\n@@ -3665,7 +3664,7 @@ add_store_equivs (void)\n \t  && ! reg_equiv[regno].pdx_subregs\n \t  && reg_equiv[regno].init_insns != NULL\n \t  && (init_insn = reg_equiv[regno].init_insns->insn ()) != 0\n-\t  && bitmap_bit_p (&seen_insns, INSN_UID (init_insn))\n+\t  && bitmap_bit_p (seen_insns, INSN_UID (init_insn))\n \t  && ! find_reg_note (init_insn, REG_EQUIV, NULL_RTX)\n \t  && validate_equiv_mem (init_insn, src, dest) == valid_reload\n \t  && ! memref_used_between_p (dest, init_insn, insn)\n@@ -3685,7 +3684,6 @@ add_store_equivs (void)\n \t\t     INSN_UID (insn));\n \t}\n     }\n-  bitmap_clear (&seen_insns);\n }\n \n /* Scan all regs killed in an insn to see if any of them are registers\n@@ -4485,9 +4483,8 @@ find_moveable_pseudos (void)\n      moved freely downwards, but are otherwise transparent to a block.  */\n   bitmap_head *bb_moveable_reg_sets = XNEWVEC (bitmap_head,\n \t\t\t\t\t       last_basic_block_for_fn (cfun));\n-  bitmap_head live, used, set, interesting, unusable_as_input;\n+  auto_bitmap live, used, set, interesting, unusable_as_input;\n   bitmap_iterator bi;\n-  bitmap_initialize (&interesting, 0);\n \n   first_moveable_pseudo = max_regs;\n   pseudo_replaced_reg.release ();\n@@ -4497,10 +4494,6 @@ find_moveable_pseudos (void)\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   i = 0;\n-  bitmap_initialize (&live, 0);\n-  bitmap_initialize (&used, 0);\n-  bitmap_initialize (&set, 0);\n-  bitmap_initialize (&unusable_as_input, 0);\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       rtx_insn *insn;\n@@ -4511,13 +4504,13 @@ find_moveable_pseudos (void)\n       bitmap_initialize (local, 0);\n       bitmap_initialize (transp, 0);\n       bitmap_initialize (moveable, 0);\n-      bitmap_copy (&live, df_get_live_out (bb));\n-      bitmap_and_into (&live, df_get_live_in (bb));\n-      bitmap_copy (transp, &live);\n+      bitmap_copy (live, df_get_live_out (bb));\n+      bitmap_and_into (live, df_get_live_in (bb));\n+      bitmap_copy (transp, live);\n       bitmap_clear (moveable);\n-      bitmap_clear (&live);\n-      bitmap_clear (&used);\n-      bitmap_clear (&set);\n+      bitmap_clear (live);\n+      bitmap_clear (used);\n+      bitmap_clear (set);\n       FOR_BB_INSNS (bb, insn)\n \tif (NONDEBUG_INSN_P (insn))\n \t  {\n@@ -4531,38 +4524,34 @@ find_moveable_pseudos (void)\n \t    if (use\n \t\t&& def\n \t\t&& DF_REF_REGNO (use) == DF_REF_REGNO (def)\n-\t\t&& !bitmap_bit_p (&set, DF_REF_REGNO (use))\n+\t\t&& !bitmap_bit_p (set, DF_REF_REGNO (use))\n \t\t&& rtx_moveable_p (&PATTERN (insn), OP_IN))\n \t      {\n \t\tunsigned regno = DF_REF_REGNO (use);\n \t\tbitmap_set_bit (moveable, regno);\n-\t\tbitmap_set_bit (&set, regno);\n-\t\tbitmap_set_bit (&used, regno);\n+\t\tbitmap_set_bit (set, regno);\n+\t\tbitmap_set_bit (used, regno);\n \t\tbitmap_clear_bit (transp, regno);\n \t\tcontinue;\n \t      }\n \t    FOR_EACH_INSN_INFO_USE (use, insn_info)\n \t      {\n \t\tunsigned regno = DF_REF_REGNO (use);\n-\t\tbitmap_set_bit (&used, regno);\n+\t\tbitmap_set_bit (used, regno);\n \t\tif (bitmap_clear_bit (moveable, regno))\n \t\t  bitmap_clear_bit (transp, regno);\n \t      }\n \n \t    FOR_EACH_INSN_INFO_DEF (def, insn_info)\n \t      {\n \t\tunsigned regno = DF_REF_REGNO (def);\n-\t\tbitmap_set_bit (&set, regno);\n+\t\tbitmap_set_bit (set, regno);\n \t\tbitmap_clear_bit (transp, regno);\n \t\tbitmap_clear_bit (moveable, regno);\n \t      }\n \t  }\n     }\n \n-  bitmap_clear (&live);\n-  bitmap_clear (&used);\n-  bitmap_clear (&set);\n-\n   FOR_EACH_BB_FN (bb, cfun)\n     {\n       bitmap local = bb_local + bb->index;\n@@ -4605,7 +4594,7 @@ find_moveable_pseudos (void)\n \t\tif (dump_file)\n \t\t  fprintf (dump_file, \"Ignoring reg %d, has equiv memory\\n\",\n \t\t\t   regno);\n-\t\tbitmap_set_bit (&unusable_as_input, regno);\n+\t\tbitmap_set_bit (unusable_as_input, regno);\n \t\tcontinue;\n \t      }\n \n@@ -4665,7 +4654,7 @@ find_moveable_pseudos (void)\n \t\tcontinue;\n \t      }\n \n-\t    bitmap_set_bit (&interesting, regno);\n+\t    bitmap_set_bit (interesting, regno);\n \t    /* If we get here, we know closest_use is a non-NULL insn\n \t       (as opposed to const_0_rtx).  */\n \t    closest_uses[regno] = as_a <rtx_insn *> (closest_use);\n@@ -4684,7 +4673,7 @@ find_moveable_pseudos (void)\n \t  }\n     }\n \n-  EXECUTE_IF_SET_IN_BITMAP (&interesting, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (interesting, 0, i, bi)\n     {\n       df_ref def = DF_REG_DEF_CHAIN (i);\n       rtx_insn *def_insn = DF_REF_INSN (def);\n@@ -4728,7 +4717,7 @@ find_moveable_pseudos (void)\n       FOR_EACH_INSN_USE (use, def_insn)\n \t{\n \t  unsigned regno = DF_REF_REGNO (use);\n-\t  if (bitmap_bit_p (&unusable_as_input, regno))\n+\t  if (bitmap_bit_p (unusable_as_input, regno))\n \t    {\n \t      all_ok = false;\n \t      if (dump_file)\n@@ -4794,8 +4783,6 @@ find_moveable_pseudos (void)\n       bitmap_clear (bb_transp_live + bb->index);\n       bitmap_clear (bb_moveable_reg_sets + bb->index);\n     }\n-  bitmap_clear (&interesting);\n-  bitmap_clear (&unusable_as_input);\n   free (uid_luid);\n   free (closest_uses);\n   free (bb_local);\n@@ -4875,14 +4862,12 @@ split_live_ranges_for_shrink_wrap (void)\n   basic_block bb, call_dom = NULL;\n   basic_block first = single_succ (ENTRY_BLOCK_PTR_FOR_FN (cfun));\n   rtx_insn *insn, *last_interesting_insn = NULL;\n-  bitmap_head need_new, reachable;\n+  auto_bitmap need_new, reachable;\n   vec<basic_block> queue;\n \n   if (!SHRINK_WRAPPING_ENABLED)\n     return false;\n \n-  bitmap_initialize (&need_new, 0);\n-  bitmap_initialize (&reachable, 0);\n   queue.create (n_basic_blocks_for_fn (cfun));\n \n   FOR_EACH_BB_FN (bb, cfun)\n@@ -4891,22 +4876,18 @@ split_live_ranges_for_shrink_wrap (void)\n \t{\n \t  if (bb == first)\n \t    {\n-\t      bitmap_clear (&need_new);\n-\t      bitmap_clear (&reachable);\n \t      queue.release ();\n \t      return false;\n \t    }\n \n-\t  bitmap_set_bit (&need_new, bb->index);\n-\t  bitmap_set_bit (&reachable, bb->index);\n+\t  bitmap_set_bit (need_new, bb->index);\n+\t  bitmap_set_bit (reachable, bb->index);\n \t  queue.quick_push (bb);\n \t  break;\n \t}\n \n   if (queue.is_empty ())\n     {\n-      bitmap_clear (&need_new);\n-      bitmap_clear (&reachable);\n       queue.release ();\n       return false;\n     }\n@@ -4919,7 +4900,7 @@ split_live_ranges_for_shrink_wrap (void)\n       bb = queue.pop ();\n       FOR_EACH_EDGE (e, ei, bb->succs)\n \tif (e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun)\n-\t    && bitmap_set_bit (&reachable, e->dest->index))\n+\t    && bitmap_set_bit (reachable, e->dest->index))\n \t  queue.quick_push (e->dest);\n     }\n   queue.release ();\n@@ -4931,32 +4912,23 @@ split_live_ranges_for_shrink_wrap (void)\n \tcontinue;\n \n       if (DF_REG_DEF_COUNT (REGNO (dest)) > 1)\n-\t{\n-\t  bitmap_clear (&need_new);\n-\t  bitmap_clear (&reachable);\n-\t  return false;\n-\t}\n+\treturn false;\n \n       for (df_ref use = DF_REG_USE_CHAIN (REGNO(dest));\n \t   use;\n \t   use = DF_REF_NEXT_REG (use))\n \t{\n \t  int ubbi = DF_REF_BB (use)->index;\n-\t  if (bitmap_bit_p (&reachable, ubbi))\n-\t    bitmap_set_bit (&need_new, ubbi);\n+\t  if (bitmap_bit_p (reachable, ubbi))\n+\t    bitmap_set_bit (need_new, ubbi);\n \t}\n       last_interesting_insn = insn;\n     }\n \n-  bitmap_clear (&reachable);\n   if (!last_interesting_insn)\n-    {\n-      bitmap_clear (&need_new);\n-      return false;\n-    }\n+    return false;\n \n-  call_dom = nearest_common_dominator_for_set (CDI_DOMINATORS, &need_new);\n-  bitmap_clear (&need_new);\n+  call_dom = nearest_common_dominator_for_set (CDI_DOMINATORS, need_new);\n   if (call_dom == first)\n     return false;\n "}, {"sha": "20bdafdb580cd43cb548febe440ce2866052b0bd", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=8f9b31f7f161bd00d9c7847f117591ec85f9484d", "patch": "@@ -90,7 +90,6 @@ rtx_writer::rtx_writer (FILE *outf, int ind, bool simple, bool compact,\n rtx_reuse_manager::rtx_reuse_manager ()\n : m_next_id (0)\n {\n-  bitmap_initialize (&m_defs_seen, NULL);\n }\n \n /* Determine if X is of a kind suitable for dumping via reuse_rtx.  */\n@@ -158,15 +157,15 @@ rtx_reuse_manager::has_reuse_id (const_rtx x, int *out)\n bool\n rtx_reuse_manager::seen_def_p (int reuse_id)\n {\n-  return bitmap_bit_p (&m_defs_seen, reuse_id);\n+  return bitmap_bit_p (m_defs_seen, reuse_id);\n }\n \n /* Record that the definition of the given reuse ID has been seen.  */\n \n void\n rtx_reuse_manager::set_seen_def (int reuse_id)\n {\n-  bitmap_set_bit (&m_defs_seen, reuse_id);\n+  bitmap_set_bit (m_defs_seen, reuse_id);\n }\n \n #endif /* #ifndef GENERATOR_FILE */"}, {"sha": "eee949a1792726fac4c87659b82fab37f17f575a", "filename": "gcc/print-rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fprint-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8f9b31f7f161bd00d9c7847f117591ec85f9484d/gcc%2Fprint-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.h?ref=8f9b31f7f161bd00d9c7847f117591ec85f9484d", "patch": "@@ -153,7 +153,7 @@ class rtx_reuse_manager\n  private:\n   hash_map<const_rtx, int> m_rtx_occurrence_count;\n   hash_map<const_rtx, int> m_rtx_reuse_ids;\n-  bitmap_head m_defs_seen;\n+  auto_bitmap m_defs_seen;\n   int m_next_id;\n };\n "}]}