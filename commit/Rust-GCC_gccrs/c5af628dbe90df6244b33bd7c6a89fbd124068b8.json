{"sha": "c5af628dbe90df6244b33bd7c6a89fbd124068b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzVhZjYyOGRiZTkwZGY2MjQ0YjMzYmQ3YzZhODlmYmQxMjQwNjhiOA==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-07-16T15:25:43Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-07-16T15:25:43Z"}, "message": "rs6000.c (rs6000_emit_sISEL): Let rs6000_emit_int_cmove do all the work.\n\n\t* config/rs6000/rs6000.c (rs6000_emit_sISEL): Let rs6000_emit_int_cmove\n\tdo all the work.\n\t(rs6000_emit_int_cmove): Use function pointers for insn generation.\n\tDon't force values into registers unnecessarily.\n\t(output_isel): Assert that we're not given conditions we can't handle.\n\tDelete corresponding code.\n\t* config/rs6000/rs6000.md (isel_signed_<mode>): Use\n\tscc_comparison_operator constraint.  Permit 0 for the consequent\n\toperand.  Permit any GPR for the alternative operand.\n\t(isel_unsigned_<mode>): Likewise.\n\nFrom-SVN: r162263", "tree": {"sha": "b6415535bcf129a547077d04dde2e0785807981c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b6415535bcf129a547077d04dde2e0785807981c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c5af628dbe90df6244b33bd7c6a89fbd124068b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5af628dbe90df6244b33bd7c6a89fbd124068b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5af628dbe90df6244b33bd7c6a89fbd124068b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5af628dbe90df6244b33bd7c6a89fbd124068b8/comments", "author": null, "committer": null, "parents": [{"sha": "8d63d4055e5e853eb82141ee6bb7823904423f3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d63d4055e5e853eb82141ee6bb7823904423f3c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d63d4055e5e853eb82141ee6bb7823904423f3c"}], "stats": {"total": 136, "additions": 59, "deletions": 77}, "files": [{"sha": "353ccd388f91381fa0ba9b2ba7a2ad1002d83ce6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c5af628dbe90df6244b33bd7c6a89fbd124068b8", "patch": "@@ -1,3 +1,16 @@\n+2010-07-16  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* config/rs6000/rs6000.c (rs6000_emit_sISEL): Let rs6000_emit_int_cmove\n+\tdo all the work.\n+\t(rs6000_emit_int_cmove): Use function pointers for insn generation.\n+\tDon't force values into registers unnecessarily.\n+\t(output_isel): Assert that we're not given conditions we can't handle.\n+\tDelete corresponding code.\n+\t* config/rs6000/rs6000.md (isel_signed_<mode>): Use\n+\tscc_comparison_operator constraint.  Permit 0 for the consequent\n+\toperand.  Permit any GPR for the alternative operand.\n+\t(isel_unsigned_<mode>): Likewise.\n+\n 2010-07-16  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/44942"}, {"sha": "d96c1d6f32df99c1457562039c5d4a0639077c1f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 36, "deletions": 67, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=c5af628dbe90df6244b33bd7c6a89fbd124068b8", "patch": "@@ -15997,53 +15997,12 @@ rs6000_generate_compare (rtx cmp, enum machine_mode mode)\n }\n \n \n-/* Emit the RTL for an sCOND pattern.  */\n+/* Emit the RTL for an sISEL pattern.  */\n \n void\n-rs6000_emit_sISEL (enum machine_mode mode, rtx operands[])\n+rs6000_emit_sISEL (enum machine_mode mode ATTRIBUTE_UNUSED, rtx operands[])\n {\n-  rtx condition_rtx;\n-  enum machine_mode op_mode;\n-  enum rtx_code cond_code;\n-  rtx result = operands[0];\n-\n-  condition_rtx = rs6000_generate_compare (operands[1], mode);\n-  cond_code = GET_CODE (condition_rtx);\n-\n-  op_mode = GET_MODE (XEXP (operands[1], 0));\n-  if (op_mode == VOIDmode)\n-    op_mode = GET_MODE (XEXP (operands[1], 1));\n-\n-  if (TARGET_POWERPC64 && GET_MODE (result) == DImode)\n-    {\n-      PUT_MODE (condition_rtx, DImode);\n-      if (cond_code == GEU || cond_code == GTU || cond_code == LEU\n-         || cond_code == LTU)\n-       emit_insn (gen_isel_unsigned_di (result, condition_rtx,\n-\t\t\t\t\tforce_reg (DImode, const1_rtx),\n-\t\t\t\t\tforce_reg (DImode, const0_rtx),\n-\t\t\t\t\tXEXP (condition_rtx, 0)));\n-      else\n-       emit_insn (gen_isel_signed_di (result, condition_rtx,\n-\t\t\t\t      force_reg (DImode, const1_rtx),\n-\t\t\t\t      force_reg (DImode, const0_rtx),\n-\t\t\t\t      XEXP (condition_rtx, 0)));\n-    }\n-  else\n-    {\n-      PUT_MODE (condition_rtx, SImode);\n-      if (cond_code == GEU || cond_code == GTU || cond_code == LEU\n-\t || cond_code == LTU)\n-       emit_insn (gen_isel_unsigned_si (result, condition_rtx,\n-\t\t\t\t\tforce_reg (SImode, const1_rtx),\n-\t\t\t\t\tforce_reg (SImode, const0_rtx),\n-\t\t\t\t\tXEXP (condition_rtx, 0)));\n-      else\n-       emit_insn (gen_isel_signed_si (result, condition_rtx,\n-\t\t\t\t      force_reg (SImode, const1_rtx),\n-\t\t\t\t      force_reg (SImode, const0_rtx),\n-\t\t\t\t      XEXP (condition_rtx, 0)));\n-    }\n+  rs6000_emit_int_cmove (operands[0], operands[1], const1_rtx, const0_rtx);\n }\n \n void\n@@ -16710,6 +16669,9 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n {\n   rtx condition_rtx, cr;\n   enum machine_mode mode = GET_MODE (dest);\n+  enum rtx_code cond_code;\n+  rtx (*isel_func) (rtx, rtx, rtx, rtx, rtx);\n+  bool signedp;\n \n   if (mode != SImode && (!TARGET_POWERPC64 || mode != DImode))\n     return 0;\n@@ -16718,27 +16680,37 @@ rs6000_emit_int_cmove (rtx dest, rtx op, rtx true_cond, rtx false_cond)\n      compare, it just looks at the CRx bits set by a previous compare\n      instruction.  */\n   condition_rtx = rs6000_generate_compare (op, mode);\n+  cond_code = GET_CODE (condition_rtx);\n   cr = XEXP (condition_rtx, 0);\n+  signedp = GET_MODE (cr) == CCmode;\n \n-  if (mode == SImode)\n-    {\n-      if (GET_MODE (cr) == CCmode)\n-\temit_insn (gen_isel_signed_si (dest, condition_rtx,\n-\t\t\t\t       true_cond, false_cond, cr));\n-      else\n-\temit_insn (gen_isel_unsigned_si (dest, condition_rtx,\n-\t\t\t\t\t true_cond, false_cond, cr));\n-    }\n-  else\n+  isel_func = (mode == SImode\n+\t       ? (signedp ? gen_isel_signed_si : gen_isel_unsigned_si)\n+\t       : (signedp ? gen_isel_signed_di : gen_isel_unsigned_di));\n+\n+  switch (cond_code)\n     {\n-      if (GET_MODE (cr) == CCmode)\n-\temit_insn (gen_isel_signed_di (dest, condition_rtx,\n-\t\t\t\t       true_cond, false_cond, cr));\n-      else\n-\temit_insn (gen_isel_unsigned_di (dest, condition_rtx,\n-\t\t\t\t\t true_cond, false_cond, cr));\n+    case LT: case GT: case LTU: case GTU: case EQ:\n+      /* isel handles these directly.  */\n+      break;\n+\n+    default:\n+      /* We need to swap the sense of the comparison.  */\n+      {\n+\trtx t = true_cond;\n+\ttrue_cond = false_cond;\n+\tfalse_cond = t;\n+\tPUT_CODE (condition_rtx, reverse_condition (cond_code));\n+      }\n+      break;\n     }\n \n+  false_cond = force_reg (mode, false_cond);\n+  if (true_cond != const0_rtx)\n+    true_cond = force_reg (mode, true_cond);\n+\n+  emit_insn (isel_func (dest, condition_rtx, true_cond, false_cond, cr));\n+\n   return 1;\n }\n \n@@ -16748,13 +16720,10 @@ output_isel (rtx *operands)\n   enum rtx_code code;\n \n   code = GET_CODE (operands[1]);\n-  if (code == GE || code == GEU || code == LE || code == LEU || code == NE)\n-    {\n-      PUT_CODE (operands[1], reverse_condition (code));\n-      return \"isel %0,%3,%2,%j1\";\n-    }\n-  else\n-    return \"isel %0,%2,%3,%j1\";\n+\n+  gcc_assert (!(code == GE || code == GEU || code == LE || code == LEU || code == NE));\n+\n+  return \"isel %0,%2,%3,%j1\";\n }\n \n void"}, {"sha": "09669159c770046b8a281ceb1be609251fcde337", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c5af628dbe90df6244b33bd7c6a89fbd124068b8/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=c5af628dbe90df6244b33bd7c6a89fbd124068b8", "patch": "@@ -6091,27 +6091,27 @@\n ;; change the mode underneath our feet and then gets confused trying\n ;; to reload the value.\n (define_insn \"isel_signed_<mode>\"\n-  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(if_then_else:GPR\n-\t (match_operator 1 \"comparison_operator\"\n-\t\t\t [(match_operand:CC 4 \"cc_reg_operand\" \"y\")\n+\t (match_operator 1 \"scc_comparison_operator\"\n+\t\t\t [(match_operand:CC 4 \"cc_reg_operand\" \"y,y\")\n \t\t\t  (const_int 0)])\n-\t (match_operand:GPR 2 \"gpc_reg_operand\" \"b\")\n-\t (match_operand:GPR 3 \"gpc_reg_operand\" \"b\")))]\n+\t (match_operand:GPR 2 \"reg_or_cint_operand\" \"O,b\")\n+\t (match_operand:GPR 3 \"gpc_reg_operand\" \"r,r\")))]\n   \"TARGET_ISEL<sel>\"\n   \"*\n { return output_isel (operands); }\"\n   [(set_attr \"type\" \"isel\")\n    (set_attr \"length\" \"4\")])\n \n (define_insn \"isel_unsigned_<mode>\"\n-  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r,r\")\n \t(if_then_else:GPR\n-\t (match_operator 1 \"comparison_operator\"\n-\t\t\t [(match_operand:CCUNS 4 \"cc_reg_operand\" \"y\")\n+\t (match_operator 1 \"scc_comparison_operator\"\n+\t\t\t [(match_operand:CCUNS 4 \"cc_reg_operand\" \"y,y\")\n \t\t\t  (const_int 0)])\n-\t (match_operand:GPR 2 \"gpc_reg_operand\" \"b\")\n-\t (match_operand:GPR 3 \"gpc_reg_operand\" \"b\")))]\n+\t (match_operand:GPR 2 \"reg_or_cint_operand\" \"O,b\")\n+\t (match_operand:GPR 3 \"gpc_reg_operand\" \"r,r\")))]\n   \"TARGET_ISEL<sel>\"\n   \"*\n { return output_isel (operands); }\""}]}