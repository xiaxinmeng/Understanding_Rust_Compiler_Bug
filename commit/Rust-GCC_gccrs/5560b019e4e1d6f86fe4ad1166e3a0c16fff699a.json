{"sha": "5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTU2MGIwMTllNGUxZDZmODZmZTRhZDExNjZlM2EwYzE2ZmZmNjk5YQ==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-05-12T18:32:17Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-05-12T18:32:17Z"}, "message": "CharViewBufferImpl.java, [...]: New files, not yet to be compiled.\n\n2003-05-12  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/nio/CharViewBufferImpl.java,\n\tgnu/java/nio/DirectByteBufferImpl.java,\n\tgnu/java/nio/DoubleViewBufferImpl.java,\n\tgnu/java/nio/FloatViewBufferImpl.java,\n\tgnu/java/nio/IntViewBufferImpl.java,\n\tgnu/java/nio/LongViewBufferImpl.java,\n\tgnu/java/nio/ShortViewBufferImpl.java,\n\tgnu/java/nio/natDirectByteBufferImpl.cc:\n\tNew files, not yet to be compiled.\n\nFrom-SVN: r66727", "tree": {"sha": "e264ba96080adcb968ca68d4705796474ef706ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e264ba96080adcb968ca68d4705796474ef706ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/comments", "author": null, "committer": null, "parents": [{"sha": "6e81c6f49c3e2ae1d91b54a53313e05ee1b4812d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e81c6f49c3e2ae1d91b54a53313e05ee1b4812d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e81c6f49c3e2ae1d91b54a53313e05ee1b4812d"}], "stats": {"total": 1426, "additions": 1426, "deletions": 0}, "files": [{"sha": "584defb5b30274139496f3355eeede472974c429", "filename": "libjava/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -1,3 +1,15 @@\n+2003-05-12  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/nio/CharViewBufferImpl.java,\n+\tgnu/java/nio/DirectByteBufferImpl.java,\n+\tgnu/java/nio/DoubleViewBufferImpl.java,\n+\tgnu/java/nio/FloatViewBufferImpl.java,\n+\tgnu/java/nio/IntViewBufferImpl.java,\n+\tgnu/java/nio/LongViewBufferImpl.java,\n+\tgnu/java/nio/ShortViewBufferImpl.java,\n+\tgnu/java/nio/natDirectByteBufferImpl.cc:\n+\tNew files, not yet to be compiled.\n+\n 2003-05-10  Michael Koch  <konqueror@gmx.de>\n \n \t* javax/swing/plaf/ButtonUI.java,"}, {"sha": "62c8fdd9dc9d8030f93f988b80c2760609644706", "filename": "libjava/gnu/java/nio/CharViewBufferImpl.java", "status": "added", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FCharViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FCharViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FCharViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,167 @@\n+/* CharViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.CharBuffer;\n+\n+class CharViewBufferImpl extends CharBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public CharViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 1, bb.remaining () >> 1, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from CharByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public CharViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from CharViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public char get ()\n+  {\n+    char result = bb.getChar ((position () >> 1) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public char get (int index)\n+  {\n+    return bb.getChar ((index >> 1) + offset);\n+  }\n+\n+  public CharBuffer put (char value)\n+  {\n+    bb.putChar ((position () >> 1) + offset, value);\n+    return this;\n+  }\n+  \n+  public CharBuffer put (int index, char value)\n+  {\n+    bb.putChar ((index >> 1) + offset, value);\n+    return this;\n+  }\n+\n+  public CharBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putChar ((i >> 1) + offset,\n+                          bb.getChar (((i + position ()) >> 1) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public CharBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new CharViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public CharBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new CharViewBufferImpl (bb, (position () >> 1) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public CharSequence subSequence (int start, int end)\n+  {\n+    if (start < 0\n+        || start > length ()\n+        || end < start\n+        || end > length ())\n+      throw new IndexOutOfBoundsException ();\n+\n+    return new CharViewBufferImpl (bb, array_offset, capacity (), position () + end, position () + start, -1, isReadOnly ());\n+  }\n+\n+  public CharBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new CharViewBufferImpl (bb, (position () >> 1) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "0c08ab489dbd32b9f73d23be5f28f391cede972c", "filename": "libjava/gnu/java/nio/DirectByteBufferImpl.java", "status": "added", "additions": 423, "deletions": 0, "changes": 423, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDirectByteBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,423 @@\n+/* DirectByteBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.CharBuffer;\n+import java.nio.DoubleBuffer;\n+import java.nio.FloatBuffer;\n+import java.nio.IntBuffer;\n+import java.nio.LongBuffer;\n+import java.nio.ShortBuffer;\n+import gnu.gcj.RawData;\n+\n+public class DirectByteBufferImpl extends ByteBuffer\n+{\n+  private RawData address;\n+  private int offset;\n+  private boolean readOnly;\n+  \n+  public DirectByteBufferImpl (RawData address, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (capacity, limit, position, mark);\n+    this.address = address;\n+    this.offset = offset;\n+    this.readOnly = readOnly;\n+  }\n+\n+  private static native RawData allocateImpl (int capacity);\n+  private static native void freeImpl (RawData address);\n+  \n+  protected void finalize () throws Throwable\n+  {\n+    freeImpl (address);\n+  }\n+  \n+  public static ByteBuffer allocateDirect (int capacity)\n+  {\n+    RawData address = allocateImpl (capacity);\n+\n+    if (address == 0)\n+      throw new InternalError (\"Not enough memory to create direct buffer\");\n+    \n+    return new DirectByteBufferImpl (address, 0, capacity, capacity, 0, -1, false);\n+  }\n+  \n+  private native byte getImpl (int index);\n+  private native void putImpl (int index, byte value);\n+\n+  public byte get ()\n+  {\n+    byte result = getImpl (position () + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public byte get (int index)\n+  {\n+    return getImpl (index);\n+  }\n+\n+  public ByteBuffer put (byte value)\n+  {\n+    putImpl (position (), value);\n+    position (position () + 1);\n+    return this;\n+  }\n+  \n+  public ByteBuffer put (int index, byte value)\n+  {\n+    putImpl (index, value);\n+    return this;\n+  }\n+  \n+  public ByteBuffer compact ()\n+  {\n+    // FIXME this can sure be optimized using memcpy()  \n+    int copied = 0;\n+    \n+    while (remaining () > 0)\n+      {\n+\tput (copied, get ());\n+\tcopied++;\n+      }\n+\n+    position (copied);\n+    return this;\n+  }\n+\n+  public ByteBuffer duplicate ()\n+  {\n+    return new DirectByteBufferImpl (\n+      address, offset, capacity (), limit (), position (), -1, isReadOnly ());\n+  }\n+\n+  public ByteBuffer slice ()\n+  {\n+    return new DirectByteBufferImpl (address, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+\n+  public ByteBuffer asReadOnlyBuffer ()\n+  {\n+    return new DirectByteBufferImpl (\n+      address, offset, capacity (), limit (), position (), -1, true);\n+  }\n+\n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+\n+  public boolean isDirect ()\n+  {\n+    return true;\n+  }\n+\n+  public CharBuffer asCharBuffer ()\n+  {\n+    return new CharViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  public DoubleBuffer asDoubleBuffer ()\n+  {\n+    return new DoubleViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  public FloatBuffer asFloatBuffer ()\n+  {\n+    return new FloatViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  public IntBuffer asIntBuffer ()\n+  {\n+    return new IntViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  public LongBuffer asLongBuffer ()\n+  {\n+    return new LongViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  public ShortBuffer asShortBuffer ()\n+  {\n+    return new ShortViewBufferImpl (this, position () + offset, remaining (), remaining (), 0, -1, isReadOnly ());\n+  }\n+  \n+  final public char getChar ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (char) (((get () & 0xff) << 8) + (get () & 0xff));\n+  }\n+  \n+  final public ByteBuffer putChar (char value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00) >> 8));\n+    put ((byte) (((int) value) & 0x00ff));\n+    return this;\n+  }\n+  \n+  final public char getChar (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (char) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n+  }\n+  \n+  final public ByteBuffer putChar (int index, char value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+    put (index + 1, (byte) (((int) value) & 0x00ff));\n+    return this;\n+  }\n+\n+  final public short getShort ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (short) (((get () & 0xff) << 8) + (get () & 0xff));\n+  }\n+  \n+  final public ByteBuffer putShort (short value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00) >> 8));\n+    put ((byte) (((int) value) & 0x00ff));\n+    return this;\n+  }\n+  \n+  final public short getShort (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (short) (((get (index) & 0xff) << 8) + (get (index + 1) & 0xff));\n+  }\n+  \n+  final public ByteBuffer putShort (int index, short value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00) >> 8));\n+    put (index + 1, (byte) (((int) value) & 0x00ff));\n+    return this;\n+  }\n+\n+  final public int getInt ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (int) (((get () & 0xff) << 24)\n+                  + (get () & 0xff) << 16\n+                  + (get () & 0xff) << 8\n+                  + (get () & 0xff));\n+  }\n+  \n+  final public ByteBuffer putInt (int value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x000000ff));\n+    return this;\n+  }\n+  \n+  final public int getInt (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (int) (((get (index) & 0xff) << 24)\n+                  + (get (index + 1) & 0xff) << 16\n+                  + (get (index + 2) & 0xff) << 8\n+                  + (get (index + 3) & 0xff));\n+  }\n+  \n+  final public ByteBuffer putInt (int index, int value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put (index + 3, (byte) (((int) value) & 0x000000ff));\n+    return this;\n+  }\n+\n+  final public long getLong ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (long) (((get () & 0xff) << 56)\n+                   + (get () & 0xff) << 48\n+                   + (get () & 0xff) << 40\n+                   + (get () & 0xff) << 32\n+                   + (get () & 0xff) << 24\n+                   + (get () & 0xff) << 16\n+                   + (get () & 0xff) << 8\n+                   + (get () & 0xff));\n+  }\n+  \n+  final public ByteBuffer putLong (long value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put ((byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put ((byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put ((byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put ((byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x00000000000000ff));\n+    return this;\n+  }\n+  \n+  final public long getLong (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (long) (((get (index) & 0xff) << 56)\n+                   + (get (index + 1) & 0xff) << 48\n+                   + (get (index + 2) & 0xff) << 40\n+                   + (get (index + 3) & 0xff) << 32\n+                   + (get (index + 4) & 0xff) << 24\n+                   + (get (index + 5) & 0xff) << 16\n+                   + (get (index + 6) & 0xff) << 8\n+                   + (get (index + 7) & 0xff));\n+  }\n+  \n+  final public ByteBuffer putLong (int index, long value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put (index + 3, (byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put (index + 4, (byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put (index + 5, (byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put (index + 6, (byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put (index + 7, (byte) (((int) value) & 0x00000000000000ff));\n+    return this;\n+  }\n+\n+  final public float getFloat ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (float) (((get () & 0xff) << 24)\n+                    + (get () & 0xff) << 16\n+                    + (get () & 0xff) << 8\n+                    + (get () & 0xff));\n+  }\n+  \n+  final public ByteBuffer putFloat (float value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x000000ff));\n+    return this;\n+  }\n+  \n+  final public float getFloat (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (float) (((get (index) & 0xff) << 24)\n+                    + (get (index + 1) & 0xff) << 16\n+                    + (get (index + 2) & 0xff) << 8\n+                    + (get (index + 3) & 0xff));\n+  }\n+\n+  final public ByteBuffer putFloat (int index, float value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff000000) >> 24));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff0000) >> 16));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff00) >> 8));\n+    put (index + 3, (byte) (((int) value) & 0x000000ff));\n+    return this;\n+  }\n+\n+  final public double getDouble ()\n+  {\n+    // FIXME: this handles big endian only\n+    return (double) (((get () & 0xff) << 56)\n+                     + (get () & 0xff) << 48\n+                     + (get () & 0xff) << 40\n+                     + (get () & 0xff) << 32\n+                     + (get () & 0xff) << 24\n+                     + (get () & 0xff) << 16\n+                     + (get () & 0xff) << 8\n+                     + (get () & 0xff));\n+  }\n+\n+  final public ByteBuffer putDouble (double value)\n+  {\n+    // FIXME: this handles big endian only\n+    put ((byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put ((byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put ((byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put ((byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put ((byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put ((byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put ((byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put ((byte) (((int) value) & 0x00000000000000ff));\n+    return this;\n+  }\n+  \n+  final public double getDouble (int index)\n+  {\n+    // FIXME: this handles big endian only\n+    return (double) (((get (index) & 0xff) << 56)\n+                     + (get (index + 1) & 0xff) << 48\n+                     + (get (index + 2) & 0xff) << 40\n+                     + (get (index + 3) & 0xff) << 32\n+                     + (get (index + 4) & 0xff) << 24\n+                     + (get (index + 5) & 0xff) << 16\n+                     + (get (index + 6) & 0xff) << 8\n+                     + (get (index + 7) & 0xff));\n+  }\n+  \n+  final public ByteBuffer putDouble (int index, double value)\n+  {\n+    // FIXME: this handles big endian only\n+    put (index, (byte) ((((int) value) & 0xff00000000000000) >> 56));\n+    put (index + 1, (byte) ((((int) value) & 0x00ff000000000000) >> 48));\n+    put (index + 2, (byte) ((((int) value) & 0x0000ff0000000000) >> 40));\n+    put (index + 3, (byte) ((((int) value) & 0x000000ff00000000) >> 32));\n+    put (index + 4, (byte) ((((int) value) & 0x00000000ff000000) >> 24));\n+    put (index + 5, (byte) ((((int) value) & 0x0000000000ff0000) >> 16));\n+    put (index + 6, (byte) ((((int) value) & 0x000000000000ff00) >> 8));\n+    put (index + 7, (byte) (((int) value) & 0x00000000000000ff));\n+    return this;\n+  }\n+}"}, {"sha": "d34e88661241f1e5f719dfe9362c33f7df088f93", "filename": "libjava/gnu/java/nio/DoubleViewBufferImpl.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FDoubleViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,156 @@\n+/* DoubleViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.DoubleBuffer;\n+\n+class DoubleViewBufferImpl extends DoubleBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public DoubleViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 3, bb.remaining () >> 3, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from DoubleByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public DoubleViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from DoubleViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public double get ()\n+  {\n+    double result = bb.getDouble ((position () >> 3) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public double get (int index)\n+  {\n+    return bb.getDouble ((index >> 3) + offset);\n+  }\n+\n+  public DoubleBuffer put (double value)\n+  {\n+    bb.putDouble ((position () >> 3) + offset, value);\n+    return this;\n+  }\n+  \n+  public DoubleBuffer put (int index, double value)\n+  {\n+    bb.putDouble ((index >> 3) + offset, value);\n+    return this;\n+  }\n+\n+  public DoubleBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putDouble ((i >> 3) + offset,\n+                          bb.getDouble (((i + position ()) >> 3) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public DoubleBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new DoubleViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public DoubleBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new DoubleViewBufferImpl (bb, (position () >> 3) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public DoubleBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new DoubleViewBufferImpl (bb, (position () >> 3) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "78299f97307fb79c86085519d8110000b328dc2d", "filename": "libjava/gnu/java/nio/FloatViewBufferImpl.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FFloatViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FFloatViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FFloatViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,156 @@\n+/* FloatViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.FloatBuffer;\n+\n+class FloatViewBufferImpl extends FloatBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public FloatViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 2, bb.remaining () >> 2, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from FloatByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public FloatViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from FloatViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public float get ()\n+  {\n+    float result = bb.getFloat ((position () >> 2) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public float get (int index)\n+  {\n+    return bb.getFloat ((index >> 2) + offset);\n+  }\n+\n+  public FloatBuffer put (float value)\n+  {\n+    bb.putFloat ((position () >> 2) + offset, value);\n+    return this;\n+  }\n+  \n+  public FloatBuffer put (int index, float value)\n+  {\n+    bb.putFloat ((index >> 2) + offset, value);\n+    return this;\n+  }\n+\n+  public FloatBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putFloat ((i >> 2) + offset,\n+                          bb.getFloat (((i + position ()) >> 2) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public FloatBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new FloatViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public FloatBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new FloatViewBufferImpl (bb, (position () >> 2) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public FloatBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new FloatViewBufferImpl (bb, (position () >> 2) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "0bf5a08247b73db0f4a46ecb97f753c12f4c9d25", "filename": "libjava/gnu/java/nio/IntViewBufferImpl.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FIntViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FIntViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FIntViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,156 @@\n+/* IntViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.IntBuffer;\n+\n+class IntViewBufferImpl extends IntBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public IntViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 2, bb.remaining () >> 2, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from IntByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public IntViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from IntViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public int get ()\n+  {\n+    int result = bb.getInt ((position () >> 2) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public int get (int index)\n+  {\n+    return bb.getInt ((index >> 2) + offset);\n+  }\n+\n+  public IntBuffer put (int value)\n+  {\n+    bb.putInt ((position () >> 2) + offset, value);\n+    return this;\n+  }\n+  \n+  public IntBuffer put (int index, int value)\n+  {\n+    bb.putInt ((index >> 2) + offset, value);\n+    return this;\n+  }\n+\n+  public IntBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putInt ((i >> 2) + offset,\n+                          bb.getInt (((i + position ()) >> 2) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public IntBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new IntViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public IntBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new IntViewBufferImpl (bb, (position () >> 2) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public IntBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new IntViewBufferImpl (bb, (position () >> 2) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "2311fee5945cffe71e844d3c4f7049051d20ef27", "filename": "libjava/gnu/java/nio/LongViewBufferImpl.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FLongViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FLongViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FLongViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,156 @@\n+/* LongViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.LongBuffer;\n+\n+class LongViewBufferImpl extends LongBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public LongViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 3, bb.remaining () >> 3, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from LongByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public LongViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from LongViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public long get ()\n+  {\n+    long result = bb.getLong ((position () >> 3) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public long get (int index)\n+  {\n+    return bb.getLong ((index >> 3) + offset);\n+  }\n+\n+  public LongBuffer put (long value)\n+  {\n+    bb.putLong ((position () >> 3) + offset, value);\n+    return this;\n+  }\n+  \n+  public LongBuffer put (int index, long value)\n+  {\n+    bb.putLong ((index >> 3) + offset, value);\n+    return this;\n+  }\n+\n+  public LongBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putLong ((i >> 3) + offset,\n+                          bb.getLong (((i + position ()) >> 3) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public LongBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new LongViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public LongBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new LongViewBufferImpl (bb, (position () >> 3) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public LongBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new LongViewBufferImpl (bb, (position () >> 3) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "91cbff7b0fb53ffdcd5219ad13d295bf5d9ad75e", "filename": "libjava/gnu/java/nio/ShortViewBufferImpl.java", "status": "added", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FShortViewBufferImpl.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FShortViewBufferImpl.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FShortViewBufferImpl.java?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,156 @@\n+/* ShortViewBufferImpl.java -- \n+   Copyright (C) 2003 Free Software Foundation, Inc.\n+\n+This file is part of GNU Classpath.\n+\n+GNU Classpath is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU Classpath is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU Classpath; see the file COPYING.  If not, write to the\n+Free Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA\n+02111-1307 USA.\n+\n+Linking this library statically or dynamically with other modules is\n+making a combined work based on this library.  Thus, the terms and\n+conditions of the GNU General Public License cover the whole\n+combination.\n+\n+As a special exception, the copyright holders of this library give you\n+permission to link this library with independent modules to produce an\n+executable, regardless of the license terms of these independent\n+modules, and to copy and distribute the resulting executable under\n+terms of your choice, provided that you also meet, for each linked\n+independent module, the terms and conditions of the license of that\n+module.  An independent module is a module which is not derived from\n+or based on this library.  If you modify this library, you may extend\n+this exception to your version of the library, but you are not\n+obligated to do so.  If you do not wish to do so, delete this\n+exception statement from your version. */\n+\n+\n+package gnu.java.nio;\n+\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.nio.ShortBuffer;\n+\n+class ShortViewBufferImpl extends ShortBuffer\n+{\n+  private boolean readOnly;\n+  private int offset;\n+  private ByteBuffer bb;\n+  private ByteOrder endian;\n+  \n+  public ShortViewBufferImpl (ByteBuffer bb, boolean readOnly)\n+  {\n+    super (bb.remaining () >> 1, bb.remaining () >> 1, bb.position (), 0);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from ShortByteBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public ShortViewBufferImpl (ByteBuffer bb, int offset, int capacity,\n+                               int limit, int position, int mark,\n+                               boolean readOnly)\n+  {\n+    super (limit, limit, offset, position);\n+    this.bb = bb;\n+    this.readOnly = readOnly;\n+    // FIXME: What if this is called from ShortViewBufferImpl and ByteBuffer has changed its endianess ?\n+    this.endian = bb.order ();\n+  }\n+\n+  public short get ()\n+  {\n+    short result = bb.getShort ((position () >> 1) + offset);\n+    position (position () + 1);\n+    return result;\n+  }\n+\n+  public short get (int index)\n+  {\n+    return bb.getShort ((index >> 1) + offset);\n+  }\n+\n+  public ShortBuffer put (short value)\n+  {\n+    bb.putShort ((position () >> 1) + offset, value);\n+    return this;\n+  }\n+  \n+  public ShortBuffer put (int index, short value)\n+  {\n+    bb.putShort ((index >> 1) + offset, value);\n+    return this;\n+  }\n+\n+  public ShortBuffer compact ()\n+  {\n+    if (position () > 0)\n+      {\n+        // Copy all data from position() to limit() to the beginning of the\n+        // buffer, set position to end of data and limit to capacity\n+        // XXX: This can surely be optimized, for direct and non-direct buffers\n+        \n+        int count = limit () - position ();\n+              \n+        for (int i = 0; i < count; i++)\n+          {\n+            bb.putShort ((i >> 1) + offset,\n+                          bb.getShort (((i + position ()) >> 1) + offset));\n+          }\n+\n+        position (count);\n+        limit (capacity ());\n+      }\n+\n+    return this;\n+  }\n+  \n+  public ShortBuffer duplicate ()\n+  {\n+    // Create a copy of this object that shares its content\n+    // FIXME: mark is not correct\n+    return new ShortViewBufferImpl (bb, offset, capacity (), limit (),\n+                                     position (), -1, isReadOnly ());\n+  }\n+  \n+  public ShortBuffer slice ()\n+  {\n+    // Create a sliced copy of this object that shares its content.\n+    return new ShortViewBufferImpl (bb, (position () >> 1) + offset,\n+                                      remaining (), remaining (), 0, -1,\n+                                     isReadOnly ());\n+  }\n+  \n+  public ShortBuffer asReadOnlyBuffer ()\n+  {\n+    // Create a copy of this object that shares its content and is read-only\n+    return new ShortViewBufferImpl (bb, (position () >> 1) + offset,\n+                                     remaining (), remaining (), 0, -1, true);\n+  }\n+  \n+  public boolean isReadOnly ()\n+  {\n+    return readOnly;\n+  }\n+  \n+  public boolean isDirect ()\n+  {\n+    return bb.isDirect ();\n+  }\n+  \n+  public ByteOrder order ()\n+  {\n+    return ByteOrder.LITTLE_ENDIAN;\n+  }\n+}"}, {"sha": "317bc226b6c088c8337940437c876edaebfd5c52", "filename": "libjava/gnu/java/nio/natDirectByteBufferImpl.cc", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5560b019e4e1d6f86fe4ad1166e3a0c16fff699a/libjava%2Fgnu%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnio%2FnatDirectByteBufferImpl.cc?ref=5560b019e4e1d6f86fe4ad1166e3a0c16fff699a", "patch": "@@ -0,0 +1,44 @@\n+// natDirectByteBufferImpl.cc\n+\n+/* Copyright (C) 2003  Free Software Foundation\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+\n+#include <gnu/java/nio/DirectByteBufferImpl.h>\n+\n+jlong\n+gnu::java::nio::DirectByteBufferImpl::allocateImpl (jint capacity)\n+{\n+  // FIXME: implement this\n+  return 0;\n+}\n+\n+void\n+gnu::java::nio::DirectByteBufferImpl::freeImpl (jlong address)\n+{\n+  // FIXME: implement this\n+}\n+\n+jbyte\n+gnu::java::nio::DirectByteBufferImpl::getImpl (jint index)\n+{\n+  // FIXME: implement this\n+  // Dont forget: add offset to index\n+  return 0;\n+}\n+\n+void\n+gnu::java::nio::DirectByteBufferImpl::putImpl (jint index, jbyte value)\n+{\n+  // FIXME: implement this\n+  // Dont forget: add offset to index\n+}"}]}