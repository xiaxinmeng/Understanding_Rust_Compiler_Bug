{"sha": "8144a1a8120beac962f0dfa6dc76dbd00b407aad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE0NGExYTgxMjBiZWFjOTYyZjBkZmE2ZGM3NmRiZDAwYjQwN2FhZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard@codesourcery.com", "date": "2007-09-11T09:24:59Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-09-11T09:24:59Z"}, "message": "mips.h (CONSTANT_POOL_COST): Move to...\n\ngcc/\n2007-09-11  Richard Sandiford  <richard@codesourcery.com>\n\t    Nigel Stephens  <nigel@mips.com>\n\t    David Ung  <davidu@mips.com>\n\t\n\t* config/mips/mips.h (CONSTANT_POOL_COST): Move to...\n\t* config/mips/mips.c: ...here and set to 4 for TARGET_MIPS16.\n\t(mips16_constant_cost, mips_immediate_operand_p, mips_binary_cost)\n\t(mips_fp_mult_cost, mips_fp_div_cost, mips_sign_extend_cost)\n\t(mips_zero_extend_cost): New functions.\n\t(mips_rtx_costs): Treat COMPARE constants as having zero cost.\n\tUse the new functions.  Tweak many cost estimates, both here\n\tand in the new subroutines.  Return false when the cost of the\n\toperands has not been calculated.  Check for *clear_upper32.\n\tCheck for floating-point multiply-add, reciprocal and rsqrt\n\tpatterns.  Handle comparison and rotation codes.\n\nCo-Authored-By: David Ung <davidu@mips.com>\nCo-Authored-By: Nigel Stephens <nigel@mips.com>\n\nFrom-SVN: r128364", "tree": {"sha": "8868dfe9c20b978af85a3ed83bcf1a7276e310f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8868dfe9c20b978af85a3ed83bcf1a7276e310f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8144a1a8120beac962f0dfa6dc76dbd00b407aad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8144a1a8120beac962f0dfa6dc76dbd00b407aad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8144a1a8120beac962f0dfa6dc76dbd00b407aad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8144a1a8120beac962f0dfa6dc76dbd00b407aad/comments", "author": null, "committer": null, "parents": [{"sha": "b61c7743b70af09c6675005924700cd4b485e68b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b61c7743b70af09c6675005924700cd4b485e68b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b61c7743b70af09c6675005924700cd4b485e68b"}], "stats": {"total": 661, "additions": 501, "deletions": 160}, "files": [{"sha": "e5523d03bead81c999dbf8f7050a20174c0cc59c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8144a1a8120beac962f0dfa6dc76dbd00b407aad", "patch": "@@ -1,3 +1,19 @@\n+2007-09-11  Richard Sandiford  <richard@codesourcery.com>\n+\t    Nigel Stephens  <nigel@mips.com>\n+\t    David Ung  <davidu@mips.com>\n+\n+\t* config/mips/mips.h (CONSTANT_POOL_COST): Move to...\n+\t* config/mips/mips.c: ...here and set to 4 for TARGET_MIPS16.\n+\t(mips16_constant_cost, mips_immediate_operand_p, mips_binary_cost)\n+\t(mips_fp_mult_cost, mips_fp_div_cost, mips_sign_extend_cost)\n+\t(mips_zero_extend_cost): New functions.\n+\t(mips_rtx_costs): Treat COMPARE constants as having zero cost.\n+\tUse the new functions.  Tweak many cost estimates, both here\n+\tand in the new subroutines.  Return false when the cost of the\n+\toperands has not been calculated.  Check for *clear_upper32.\n+\tCheck for floating-point multiply-add, reciprocal and rsqrt\n+\tpatterns.  Handle comparison and rotation codes.\n+\n 2007-09-11  Danny Smith  <dannysmith@users.sourceforge.net>\n \n \t* config/i386/cygming.h (TARGET_STRIP_NAME_ENCODING): Don't"}, {"sha": "34c4420016838e70204cb9e092f57ca9f39b553a", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 485, "deletions": 155, "changes": 640, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8144a1a8120beac962f0dfa6dc76dbd00b407aad", "patch": "@@ -2863,247 +2863,577 @@ mips_lwxs_address_p (rtx addr)\n   return false;\n }\n \n+/* The cost of loading values from the constant pool.  It should be\n+   larger than the cost of any constant we want to synthesize inline.  */\n+\n+#define CONSTANT_POOL_COST COSTS_N_INSNS (TARGET_MIPS16 ? 4 : 8)\n+\n+/* Return the cost of X when used as an operand to the MIPS16 instruction\n+   that implements CODE.  Return -1 if there is no such instruction, or if\n+   X is not a valid immediate operand for it.  */\n+\n+static int\n+mips16_constant_cost (int code, HOST_WIDE_INT x)\n+{\n+  switch (code)\n+    {\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      /* Shifts by between 1 and 8 bits (inclusive) are unextended,\n+\t other shifts are extended.  The shift patterns truncate the shift\n+\t count to the right size, so there are no out-of-range values.  */\n+      if (IN_RANGE (x, 1, 8))\n+\treturn 0;\n+      return COSTS_N_INSNS (1);\n+\n+    case PLUS:\n+      if (IN_RANGE (x, -128, 127))\n+\treturn 0;\n+      if (SMALL_OPERAND (x))\n+\treturn COSTS_N_INSNS (1);\n+      return -1;\n+\n+    case LEU:\n+      /* Like LE, but reject the always-true case.  */\n+      if (x == -1)\n+\treturn -1;\n+    case LE:\n+      /* We add 1 to the immediate and use SLT.  */\n+      x += 1;\n+    case XOR:\n+      /* We can use CMPI for an xor with an unsigned 16-bit X.  */\n+    case LT:\n+    case LTU:\n+      if (IN_RANGE (x, 0, 255))\n+\treturn 0;\n+      if (SMALL_OPERAND_UNSIGNED (x))\n+\treturn COSTS_N_INSNS (1);\n+      return -1;\n+\n+    case EQ:\n+    case NE:\n+      /* Equality comparisons with 0 are cheap.  */\n+      if (x == 0)\n+\treturn 0;\n+      return -1;\n+\n+    default:\n+      return -1;\n+    }\n+}\n+\n+/* Return true if there is a non-MIPS16 instruction that implements CODE\n+   and if that instruction accepts X as an immediate operand.  */\n+\n+static int\n+mips_immediate_operand_p (int code, HOST_WIDE_INT x)\n+{\n+  switch (code)\n+    {\n+    case ASHIFT:\n+    case ASHIFTRT:\n+    case LSHIFTRT:\n+      /* All shift counts are truncated to a valid constant.  */\n+      return true;\n+\n+    case ROTATE:\n+    case ROTATERT:\n+      /* Likewise rotates, if the target supports rotates at all.  */\n+      return ISA_HAS_ROR;\n+\n+    case AND:\n+    case IOR:\n+    case XOR:\n+      /* These instructions take 16-bit unsigned immediates.  */\n+      return SMALL_OPERAND_UNSIGNED (x);\n+\n+    case PLUS:\n+    case LT:\n+    case LTU:\n+      /* These instructions take 16-bit signed immediates.  */\n+      return SMALL_OPERAND (x);\n+\n+    case EQ:\n+    case NE:\n+    case GT:\n+    case GTU:\n+      /* The \"immediate\" forms of these instructions are really\n+\t implemented as comparisons with register 0.  */\n+      return x == 0;\n+\n+    case GE:\n+    case GEU:\n+      /* Likewise, meaning that the only valid immediate operand is 1.  */\n+      return x == 1;\n+\n+    case LE:\n+      /* We add 1 to the immediate and use SLT.  */\n+      return SMALL_OPERAND (x + 1);\n+\n+    case LEU:\n+      /* Likewise SLTU, but reject the always-true case.  */\n+      return SMALL_OPERAND (x + 1) && x + 1 != 0;\n+\n+    case SIGN_EXTRACT:\n+    case ZERO_EXTRACT:\n+      /* The bit position and size are immediate operands.  */\n+      return ISA_HAS_EXT_INS;\n+\n+    default:\n+      /* By default assume that $0 can be used for 0.  */\n+      return x == 0;\n+    }\n+}\n+\n+/* Return the cost of binary operation X, given that the instruction\n+   sequence for a word-sized or smaller operation has cost SINGLE_COST\n+   and that the sequence of a double-word operation has cost DOUBLE_COST.  */\n+\n+static int\n+mips_binary_cost (rtx x, int single_cost, int double_cost)\n+{\n+  int cost;\n+\n+  if (GET_MODE_SIZE (GET_MODE (x)) == UNITS_PER_WORD * 2)\n+    cost = double_cost;\n+  else\n+    cost = single_cost;\n+  return (cost\n+\t  + rtx_cost (XEXP (x, 0), 0)\n+\t  + rtx_cost (XEXP (x, 1), GET_CODE (x)));\n+}\n+\n+/* Return the cost of floating-point multiplications of mode MODE.  */\n+\n+static int\n+mips_fp_mult_cost (enum machine_mode mode)\n+{\n+  return mode == DFmode ? mips_cost->fp_mult_df : mips_cost->fp_mult_sf;\n+}\n+\n+/* Return the cost of floating-point divisions of mode MODE.  */\n+\n+static int\n+mips_fp_div_cost (enum machine_mode mode)\n+{\n+  return mode == DFmode ? mips_cost->fp_div_df : mips_cost->fp_div_sf;\n+}\n+\n+/* Return the cost of sign-extending OP to mode MODE, not including the\n+   cost of OP itself.  */\n+\n+static int\n+mips_sign_extend_cost (enum machine_mode mode, rtx op)\n+{\n+  if (MEM_P (op))\n+    /* Extended loads are as cheap as unextended ones.  */\n+    return 0;\n+\n+  if (TARGET_64BIT && mode == DImode && GET_MODE (op) == SImode)\n+    /* A sign extension from SImode to DImode in 64-bit mode is free.  */\n+    return 0;\n+\n+  if (ISA_HAS_SEB_SEH || GENERATE_MIPS16E)\n+    /* We can use SEB or SEH.  */\n+    return COSTS_N_INSNS (1);\n+\n+  /* We need to use a shift left and a shift right.  */\n+  return COSTS_N_INSNS (TARGET_MIPS16 ? 4 : 2);\n+}\n+\n+/* Return the cost of zero-extending OP to mode MODE, not including the\n+   cost of OP itself.  */\n+\n+static int\n+mips_zero_extend_cost (enum machine_mode mode, rtx op)\n+{\n+  if (MEM_P (op))\n+    /* Extended loads are as cheap as unextended ones.  */\n+    return 0;\n+\n+  if (TARGET_64BIT && mode == DImode && GET_MODE (op) == SImode)\n+    /* We need a shift left by 32 bits and a shift right by 32 bits.  */\n+    return COSTS_N_INSNS (TARGET_MIPS16 ? 4 : 2);\n+\n+  if (GENERATE_MIPS16E)\n+    /* We can use ZEB or ZEH.  */\n+    return COSTS_N_INSNS (1);\n+\n+  if (TARGET_MIPS16)\n+    /* We need to load 0xff or 0xffff into a register and use AND.  */\n+    return COSTS_N_INSNS (GET_MODE (op) == QImode ? 2 : 3);\n+\n+  /* We can use ANDI.  */\n+  return COSTS_N_INSNS (1);\n+}\n+\n+/* Implement TARGET_RTX_COSTS.  */\n+\n static bool\n mips_rtx_costs (rtx x, int code, int outer_code, int *total)\n {\n   enum machine_mode mode = GET_MODE (x);\n   bool float_mode_p = FLOAT_MODE_P (mode);\n+  int cost;\n+  rtx addr;\n+\n+  /* The cost of a COMPARE is hard to define for MIPS.  COMPAREs don't\n+     appear in the instruction stream, and the cost of a comparison is\n+     really the cost of the branch or scc condition.  At the time of\n+     writing, gcc only uses an explicit outer COMPARE code when optabs\n+     is testing whether a constant is expensive enough to force into a\n+     register.  We want optabs to pass such constants through the MIPS\n+     expanders instead, so make all constants very cheap here.  */\n+  if (outer_code == COMPARE)\n+    {\n+      gcc_assert (CONSTANT_P (x));\n+      *total = 0;\n+      return true;\n+    }\n \n   switch (code)\n     {\n     case CONST_INT:\n-      if (TARGET_MIPS16)\n-        {\n-\t  /* A number between 1 and 8 inclusive is efficient for a shift.\n-\t     Otherwise, we will need an extended instruction.  */\n-\t  if ((outer_code) == ASHIFT || (outer_code) == ASHIFTRT\n-\t      || (outer_code) == LSHIFTRT)\n-\t    {\n-\t      if (INTVAL (x) >= 1 && INTVAL (x) <= 8)\n-\t\t*total = 0;\n-\t      else\n-\t\t*total = COSTS_N_INSNS (1);\n-\t      return true;\n-\t    }\n-\n-\t  /* We can use cmpi for an xor with an unsigned 16-bit value.  */\n-\t  if ((outer_code) == XOR\n-\t      && INTVAL (x) >= 0 && INTVAL (x) < 0x10000)\n-\t    {\n-\t      *total = 0;\n-\t      return true;\n-\t    }\n-\n-\t  /* We may be able to use slt or sltu for a comparison with a\n-\t     signed 16-bit value.  (The boundary conditions aren't quite\n-\t     right, but this is just a heuristic anyhow.)  */\n-\t  if (((outer_code) == LT || (outer_code) == LE\n-\t       || (outer_code) == GE || (outer_code) == GT\n-\t       || (outer_code) == LTU || (outer_code) == LEU\n-\t       || (outer_code) == GEU || (outer_code) == GTU)\n-\t      && INTVAL (x) >= -0x8000 && INTVAL (x) < 0x8000)\n-\t    {\n-\t      *total = 0;\n-\t      return true;\n-\t    }\n+      /* Treat *clear_upper32-style ANDs as having zero cost in the\n+\t second operand.  The cost is entirely in the first operand.\n+\n+\t ??? This is needed because we would otherwise try to CSE\n+\t the constant operand.  Although that's the right thing for\n+\t instructions that continue to be a register operation throughout\n+\t compilation, it is disastrous for instructions that could\n+\t later be converted into a memory operation.  */\n+      if (TARGET_64BIT\n+\t  && outer_code == AND\n+\t  && UINTVAL (x) == 0xffffffff)\n+\t{\n+\t  *total = 0;\n+\t  return true;\n+\t}\n \n-\t  /* Equality comparisons with 0 are cheap.  */\n-\t  if (((outer_code) == EQ || (outer_code) == NE)\n-\t      && INTVAL (x) == 0)\n+      if (TARGET_MIPS16)\n+\t{\n+\t  cost = mips16_constant_cost (outer_code, INTVAL (x));\n+\t  if (cost >= 0)\n \t    {\n-\t      *total = 0;\n+\t      *total = cost;\n \t      return true;\n \t    }\n-\n-\t  /* Constants in the range 0...255 can be loaded with an unextended\n-\t     instruction.  They are therefore as cheap as a register move.\n-\n-\t     Given the choice between \"li R1,0...255\" and \"move R1,R2\"\n-\t     (where R2 is a known constant), it is usually better to use \"li\",\n-\t     since we do not want to unnecessarily extend the lifetime\n-\t     of R2.  */\n-\t  if (outer_code == SET\n-\t      && INTVAL (x) >= 0\n-\t      && INTVAL (x) < 256)\n+\t}\n+      else\n+\t{\n+\t  /* When not optimizing for size, we care more about the cost\n+\t     of hot code, and hot code is often in a loop.  If a constant\n+\t     operand needs to be forced into a register, we will often be\n+\t     able to hoist the constant load out of the loop, so the load\n+\t     should not contribute to the cost.  */\n+\t  if (!optimize_size\n+\t      || mips_immediate_operand_p (outer_code, INTVAL (x)))\n \t    {\n \t      *total = 0;\n \t      return true;\n \t    }\n \t}\n-      else\n-\t{\n-\t  /* These can be used anywhere. */\n-\t  *total = 0;\n-\t  return true;\n-\t}\n-\n-      /* Otherwise fall through to the handling below because\n-\t we'll need to construct the constant.  */\n+      /* Fall through.  */\n \n     case CONST:\n     case SYMBOL_REF:\n     case LABEL_REF:\n     case CONST_DOUBLE:\n-      if (LEGITIMATE_CONSTANT_P (x))\n+      cost = mips_const_insns (x);\n+      if (cost > 0)\n \t{\n-\t  *total = COSTS_N_INSNS (1);\n+\t  /* If the constant is likely to be stored in a GPR, SETs of\n+\t     single-insn constants are as cheap as register sets; we\n+\t     never want to CSE them.\n+\n+\t     Don't reduce the cost of storing a floating-point zero in\n+\t     FPRs.  If we have a zero in an FPR for other reasons, we\n+\t     can get better cfg-cleanup and delayed-branch results by\n+\t     using it consistently, rather than using $0 sometimes and\n+\t     an FPR at other times.  Also, moves between floating-point\n+\t     registers are sometimes cheaper than (D)MTC1 $0.  */\n+\t  if (cost == 1\n+\t      && outer_code == SET\n+\t      && !(float_mode_p && TARGET_HARD_FLOAT))\n+\t    cost = 0;\n+\t  /* When non-MIPS16 code loads a constant N>1 times, we rarely\n+\t     want to CSE the constant itself.  It is usually better to\n+\t     have N copies of the last operation in the sequence and one\n+\t     shared copy of the other operations.  (Note that this is\n+\t     not true for MIPS16 code, where the final operation in the\n+\t     sequence is often an extended instruction.)\n+\n+\t     Also, if we have a CONST_INT, we don't know whether it is\n+\t     for a word or doubleword operation, so we cannot rely on\n+\t     the result of mips_build_integer.  */\n+\t  else if (!TARGET_MIPS16\n+\t\t   && (outer_code == SET || mode == VOIDmode))\n+\t    cost = 1;\n+\t  *total = COSTS_N_INSNS (cost);\n \t  return true;\n \t}\n-      else\n+      /* The value will need to be fetched from the constant pool.  */\n+      *total = CONSTANT_POOL_COST;\n+      return true;\n+\n+    case MEM:\n+      /* If the address is legitimate, return the number of\n+\t instructions it needs.  */\n+      addr = XEXP (x, 0);\n+      cost = mips_address_insns (addr, mode, true);\n+      if (cost > 0)\n \t{\n-\t  /* The value will need to be fetched from the constant pool.  */\n-\t  *total = CONSTANT_POOL_COST;\n+\t  *total = COSTS_N_INSNS (cost + 1);\n \t  return true;\n \t}\n-\n-    case MEM:\n-      {\n-\t/* If the address is legitimate, return the number of\n-\t   instructions it needs.  */\n-\trtx addr = XEXP (x, 0);\n-\tint n = mips_address_insns (addr, GET_MODE (x), true);\n-\tif (n > 0)\n-\t  {\n-\t    *total = COSTS_N_INSNS (n + 1);\n-\t    return true;\n-\t  }\n-\t/* Check for scaled indexed address.  */\n-\tif (mips_lwxs_address_p (addr))\n-\t  {\n-\t    *total = COSTS_N_INSNS (2);\n-\t    return true;\n-\t  }\n-\t/* Otherwise use the default handling.  */\n-\treturn false;\n-      }\n+      /* Check for a scaled indexed address.  */\n+      if (mips_lwxs_address_p (addr))\n+\t{\n+\t  *total = COSTS_N_INSNS (2);\n+\t  return true;\n+\t}\n+      /* Otherwise use the default handling.  */\n+      return false;\n \n     case FFS:\n       *total = COSTS_N_INSNS (6);\n-      return true;\n+      return false;\n \n     case NOT:\n-      *total = COSTS_N_INSNS ((mode == DImode && !TARGET_64BIT) ? 2 : 1);\n-      return true;\n+      *total = COSTS_N_INSNS (GET_MODE_SIZE (mode) > UNITS_PER_WORD ? 2 : 1);\n+      return false;\n \n     case AND:\n+      /* Check for a *clear_upper32 pattern and treat it like a zero\n+\t extension.  See the pattern's comment for details.  */\n+      if (TARGET_64BIT\n+\t  && mode == DImode\n+\t  && CONST_INT_P (XEXP (x, 1))\n+\t  && UINTVAL (XEXP (x, 1)) == 0xffffffff)\n+\t{\n+\t  *total = (mips_zero_extend_cost (mode, XEXP (x, 0))\n+\t\t    + rtx_cost (XEXP (x, 0), 0));\n+\t  return true;\n+\t}\n+      /* Fall through.  */\n+\n     case IOR:\n     case XOR:\n-      if (mode == DImode && !TARGET_64BIT)\n-        {\n-          *total = COSTS_N_INSNS (2);\n-          return true;\n-        }\n-      return false;\n+      /* Double-word operations use two single-word operations.  */\n+      *total = mips_binary_cost (x, COSTS_N_INSNS (1), COSTS_N_INSNS (2));\n+      return true;\n \n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n-      if (mode == DImode && !TARGET_64BIT)\n-        {\n-          *total = COSTS_N_INSNS ((GET_CODE (XEXP (x, 1)) == CONST_INT)\n-                                  ? 4 : 12);\n-          return true;\n-        }\n-      return false;\n+    case ROTATE:\n+    case ROTATERT:\n+      if (CONSTANT_P (XEXP (x, 1)))\n+\t*total = mips_binary_cost (x, COSTS_N_INSNS (1), COSTS_N_INSNS (4));\n+      else\n+\t*total = mips_binary_cost (x, COSTS_N_INSNS (1), COSTS_N_INSNS (12));\n+      return true;\n \n     case ABS:\n       if (float_mode_p)\n-        *total = COSTS_N_INSNS (1);\n+        *total = mips_cost->fp_add;\n       else\n         *total = COSTS_N_INSNS (4);\n-      return true;\n+      return false;\n \n     case LO_SUM:\n-      *total = COSTS_N_INSNS (1);\n+      /* Low-part immediates need an extended MIPS16 instruction.  */\n+      *total = (COSTS_N_INSNS (TARGET_MIPS16 ? 2 : 1)\n+\t\t+ rtx_cost (XEXP (x, 0), 0));\n+      return true;\n+\n+    case LT:\n+    case LTU:\n+    case LE:\n+    case LEU:\n+    case GT:\n+    case GTU:\n+    case GE:\n+    case GEU:\n+    case EQ:\n+    case NE:\n+    case UNORDERED:\n+    case LTGT:\n+      /* Branch comparisons have VOIDmode, so use the first operand's\n+\t mode instead.  */\n+      mode = GET_MODE (XEXP (x, 0));\n+      if (FLOAT_MODE_P (mode))\n+\t{\n+\t  *total = mips_cost->fp_add;\n+\t  return false;\n+\t}\n+      *total = mips_binary_cost (x, COSTS_N_INSNS (1), COSTS_N_INSNS (4));\n       return true;\n \n-    case PLUS:\n     case MINUS:\n+      if (float_mode_p\n+\t  && ISA_HAS_NMADD_NMSUB\n+\t  && TARGET_FUSED_MADD\n+\t  && !HONOR_NANS (mode)\n+\t  && !HONOR_SIGNED_ZEROS (mode))\n+\t{\n+\t  /* See if we can use NMADD or NMSUB.  See mips.md for the\n+\t     associated patterns.  */\n+\t  rtx op0 = XEXP (x, 0);\n+\t  rtx op1 = XEXP (x, 1);\n+\t  if (GET_CODE (op0) == MULT && GET_CODE (XEXP (op0, 0)) == NEG)\n+\t    {\n+\t      *total = (mips_fp_mult_cost (mode)\n+\t\t\t+ rtx_cost (XEXP (XEXP (op0, 0), 0), 0)\n+\t\t\t+ rtx_cost (XEXP (op0, 1), 0)\n+\t\t\t+ rtx_cost (op1, 0));\n+\t      return true;\n+\t    }\n+\t  if (GET_CODE (op1) == MULT)\n+\t    {\n+\t      *total = (mips_fp_mult_cost (mode)\n+\t\t\t+ rtx_cost (op0, 0)\n+\t\t\t+ rtx_cost (XEXP (op1, 0), 0)\n+\t\t\t+ rtx_cost (XEXP (op1, 1), 0));\n+\t      return true;\n+\t    }\n+\t}\n+      /* Fall through.  */\n+\n+    case PLUS:\n       if (float_mode_p)\n \t{\n-\t  *total = mips_cost->fp_add;\n-\t  return true;\n+\t  if (ISA_HAS_FP4\n+\t      && TARGET_FUSED_MADD\n+\t      && GET_CODE (XEXP (x, 0)) == MULT)\n+\t    *total = 0;\n+\t  else\n+\t    *total = mips_cost->fp_add;\n+\t  return false;\n \t}\n \n-      else if (mode == DImode && !TARGET_64BIT)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n-      return false;\n+      /* Double-word operations require three single-word operations and\n+\t an SLTU.  The MIPS16 version then needs to move the result of\n+\t the SLTU from $24 to a MIPS16 register.  */\n+      *total = mips_binary_cost (x, COSTS_N_INSNS (1),\n+\t\t\t\t COSTS_N_INSNS (TARGET_MIPS16 ? 5 : 4));\n+      return true;\n \n     case NEG:\n-      if (mode == DImode && !TARGET_64BIT)\n-        {\n-          *total = COSTS_N_INSNS (4);\n-          return true;\n-        }\n+      if (float_mode_p\n+\t  && ISA_HAS_NMADD_NMSUB\n+\t  && TARGET_FUSED_MADD\n+\t  && !HONOR_NANS (mode)\n+\t  && HONOR_SIGNED_ZEROS (mode))\n+\t{\n+\t  /* See if we can use NMADD or NMSUB.  See mips.md for the\n+\t     associated patterns.  */\n+\t  rtx op = XEXP (x, 0);\n+\t  if ((GET_CODE (op) == PLUS || GET_CODE (op) == MINUS)\n+\t      && GET_CODE (XEXP (op, 0)) == MULT)\n+\t    {\n+\t      *total = (mips_fp_mult_cost (mode)\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 0), 0)\n+\t\t\t+ rtx_cost (XEXP (XEXP (op, 0), 1), 0)\n+\t\t\t+ rtx_cost (XEXP (op, 1), 0));\n+\t      return true;\n+\t    }\n+\t}\n+\n+      if (float_mode_p)\n+\t*total = mips_cost->fp_add;\n+      else\n+\t*total = COSTS_N_INSNS (GET_MODE_SIZE (mode) > UNITS_PER_WORD ? 4 : 1);\n       return false;\n \n     case MULT:\n-      if (mode == SFmode)\n-\t*total = mips_cost->fp_mult_sf;\n-\n-      else if (mode == DFmode)\n-\t*total = mips_cost->fp_mult_df;\n-\n-      else if (mode == SImode)\n-\t*total = mips_cost->int_mult_si;\n-\n-      else\n+      if (float_mode_p)\n+\t*total = mips_fp_mult_cost (mode);\n+      else if (mode == DImode && !TARGET_64BIT)\n+\t/* Synthesized from 2 mulsi3s, 1 mulsidi3 and two additions,\n+\t   where the mulsidi3 always includes an MFHI and an MFLO.  */\n+\t*total = (optimize_size\n+\t\t  ? COSTS_N_INSNS (ISA_HAS_MUL3 ? 7 : 9)\n+\t\t  : mips_cost->int_mult_si * 3 + 6);\n+      else if (optimize_size)\n+\t*total = (ISA_HAS_MUL3 ? 1 : 2);\n+      else if (mode == DImode)\n \t*total = mips_cost->int_mult_di;\n-\n-      return true;\n+      else\n+\t*total = mips_cost->int_mult_si;\n+      return false;\n \n     case DIV:\n+      /* Check for a reciprocal.  */\n+      if (float_mode_p && XEXP (x, 0) == CONST1_RTX (mode))\n+\t{\n+\t  if (ISA_HAS_FP4\n+\t      && flag_unsafe_math_optimizations\n+\t      && (outer_code == SQRT || GET_CODE (XEXP (x, 1)) == SQRT))\n+\t    {\n+\t      /* An rsqrt<mode>a or rsqrt<mode>b pattern.  Count the\n+\t\t division as being free.  */\n+\t      *total = rtx_cost (XEXP (x, 1), 0);\n+\t      return true;\n+\t    }\n+\t  if (!ISA_MIPS1)\n+\t    {\n+\t      *total = mips_fp_div_cost (mode) + rtx_cost (XEXP (x, 1), 0);\n+\t      return true;\n+\t    }\n+\t}\n+      /* Fall through.  */\n+\n+    case SQRT:\n     case MOD:\n       if (float_mode_p)\n \t{\n-\t  if (mode == SFmode)\n-\t    *total = mips_cost->fp_div_sf;\n-\t  else\n-\t    *total = mips_cost->fp_div_df;\n-\n-\t  return true;\n+\t  *total = mips_fp_div_cost (mode);\n+\t  return false;\n \t}\n       /* Fall through.  */\n \n     case UDIV:\n     case UMOD:\n-      if (mode == DImode)\n+      if (optimize_size)\n+\t{\n+\t  /* It is our responsibility to make division by a power of 2\n+\t     as cheap as 2 register additions if we want the division\n+\t     expanders to be used for such operations; see the setting\n+\t     of sdiv_pow2_cheap in optabs.c.  Using (D)DIV for MIPS16\n+\t     should always produce shorter code than using\n+\t     expand_sdiv2_pow2.  */\n+\t  if (TARGET_MIPS16\n+\t      && CONST_INT_P (XEXP (x, 1))\n+\t      && exact_log2 (INTVAL (XEXP (x, 1))) >= 0)\n+\t    {\n+\t      *total = COSTS_N_INSNS (2) + rtx_cost (XEXP (x, 0), 0);\n+\t      return true;\n+\t    }\n+\t  *total = COSTS_N_INSNS (mips_idiv_insns ());\n+\t}\n+      else if (mode == DImode)\n         *total = mips_cost->int_div_di;\n       else\n \t*total = mips_cost->int_div_si;\n-\n-      return true;\n+      return false;\n \n     case SIGN_EXTEND:\n-      /* A sign extend from SImode to DImode in 64-bit mode is often\n-         zero instructions, because the result can often be used\n-         directly by another instruction; we'll call it one.  */\n-      if (TARGET_64BIT && mode == DImode\n-          && GET_MODE (XEXP (x, 0)) == SImode)\n-        *total = COSTS_N_INSNS (1);\n-      else\n-        *total = COSTS_N_INSNS (2);\n-      return true;\n+      *total = mips_sign_extend_cost (mode, XEXP (x, 0));\n+      return false;\n \n     case ZERO_EXTEND:\n-      if (TARGET_64BIT && mode == DImode\n-          && GET_MODE (XEXP (x, 0)) == SImode)\n-        *total = COSTS_N_INSNS (2);\n-      else\n-        *total = COSTS_N_INSNS (1);\n-      return true;\n+      *total = mips_zero_extend_cost (mode, XEXP (x, 0));\n+      return false;\n \n     case FLOAT:\n     case UNSIGNED_FLOAT:\n     case FIX:\n     case FLOAT_EXTEND:\n     case FLOAT_TRUNCATE:\n-    case SQRT:\n       *total = mips_cost->fp_add;\n-      return true;\n+      return false;\n \n     default:\n       return false;"}, {"sha": "ca534bf3ff63c89141c2f1e9e11b54504863c00d", "filename": "gcc/config/mips/mips.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2Fconfig%2Fmips%2Fmips.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8144a1a8120beac962f0dfa6dc76dbd00b407aad/gcc%2Fconfig%2Fmips%2Fmips.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.h?ref=8144a1a8120beac962f0dfa6dc76dbd00b407aad", "patch": "@@ -2389,11 +2389,6 @@ typedef struct mips_args {\n #define FUNCTION_MODE SImode\n \n \f\n-/* The cost of loading values from the constant pool.  It should be\n-   larger than the cost of any constant we want to synthesize in-line.  */\n-\n-#define CONSTANT_POOL_COST COSTS_N_INSNS (8)\n-\n /* A C expression for the cost of moving data from a register in\n    class FROM to one in class TO.  The classes are expressed using\n    the enumeration values such as `GENERAL_REGS'.  A value of 2 is"}]}