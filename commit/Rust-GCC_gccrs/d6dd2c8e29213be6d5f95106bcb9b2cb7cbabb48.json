{"sha": "d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZkZDJjOGUyOTIxM2JlNmQ1Zjk1MTA2YmNiOWIyY2I3Y2JhYmI0OA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2015-12-22T20:47:58Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2015-12-22T20:47:58Z"}, "message": "re PR c++/67376 (Comparison with pointer to past-the-end of array fails inside constant expression)\n\n\tPR c++/67376\n\t* fold-const.c (size_low_cst): Removed.\n\t(fold_comparison): For POINTER_PLUS_EXPR where base is ADDR_EXPR\n\tcall get_inner_reference and handle INDIRECT_REF base of it.  Use\n\toffset_int for computation of the bitpos.\n\t(fold_binary_loc) <case EQ_EXPR, NE_EXPR>: Formatting\n\tfixes for X +- Y CMP X and C - X CMP X folding.  Add X CMP X +- Y\n\tand X CMP C - X folding.\n\n\t* g++.dg/cpp0x/constexpr-67376.C: New test.\n\nFrom-SVN: r231909", "tree": {"sha": "2db18c0a05eec9cf42467509904fc197af7af259", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2db18c0a05eec9cf42467509904fc197af7af259"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b5c4bc31baa52fc4ef51a89dcf97413f34c86d70"}], "stats": {"total": 156, "additions": 112, "deletions": 44}, "files": [{"sha": "73ab7d4081899ddc55f5700f7ef55e0262b11f9a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "patch": "@@ -1,3 +1,14 @@\n+2015-12-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/67376\n+\t* fold-const.c (size_low_cst): Removed.\n+\t(fold_comparison): For POINTER_PLUS_EXPR where base is ADDR_EXPR\n+\tcall get_inner_reference and handle INDIRECT_REF base of it.  Use\n+\toffset_int for computation of the bitpos.\n+\t(fold_binary_loc) <case EQ_EXPR, NE_EXPR>: Formatting\n+\tfixes for X +- Y CMP X and C - X CMP X folding.  Add X CMP X +- Y\n+\tand X CMP C - X folding.\n+\n 2015-12-22  Richard Henderson  <rth@redhat.com>\n \n \tPR ipa/67811"}, {"sha": "4fd09795e6d5652054fb49f63d59b0ea4e17798c", "filename": "gcc/fold-const.c", "status": "modified", "additions": 79, "deletions": 44, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "patch": "@@ -8294,20 +8294,6 @@ pointer_may_wrap_p (tree base, tree offset, HOST_WIDE_INT bitpos)\n   return total.to_uhwi () > (unsigned HOST_WIDE_INT) size;\n }\n \n-/* Return the HOST_WIDE_INT least significant bits of T, a sizetype\n-   kind INTEGER_CST.  This makes sure to properly sign-extend the\n-   constant.  */\n-\n-static HOST_WIDE_INT\n-size_low_cst (const_tree t)\n-{\n-  HOST_WIDE_INT w = TREE_INT_CST_ELT (t, 0);\n-  int prec = TYPE_PRECISION (TREE_TYPE (t));\n-  if (prec < HOST_BITS_PER_WIDE_INT)\n-    return sext_hwi (w, prec);\n-  return w;\n-}\n-\n /* Subroutine of fold_binary.  This routine performs all of the\n    transformations that are common to the equality/inequality\n    operators (EQ_EXPR and NE_EXPR) and the ordering operators\n@@ -8436,18 +8422,30 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  STRIP_SIGN_NOPS (base0);\n \t  if (TREE_CODE (base0) == ADDR_EXPR)\n \t    {\n-\t      base0 = TREE_OPERAND (base0, 0);\n-\t      indirect_base0 = true;\n+\t      base0\n+\t\t= get_inner_reference (TREE_OPERAND (base0, 0),\n+\t\t\t\t       &bitsize, &bitpos0, &offset0, &mode,\n+\t\t\t\t       &unsignedp, &reversep, &volatilep,\n+\t\t\t\t       false);\n+\t      if (TREE_CODE (base0) == INDIRECT_REF)\n+\t\tbase0 = TREE_OPERAND (base0, 0);\n+\t      else\n+\t\tindirect_base0 = true;\n \t    }\n-\t  offset0 = TREE_OPERAND (arg0, 1);\n-\t  if (tree_fits_shwi_p (offset0))\n+\t  if (offset0 == NULL_TREE || integer_zerop (offset0))\n+\t    offset0 = TREE_OPERAND (arg0, 1);\n+\t  else\n+\t    offset0 = size_binop (PLUS_EXPR, offset0,\n+\t\t\t\t  TREE_OPERAND (arg0, 1));\n+\t  if (TREE_CODE (offset0) == INTEGER_CST)\n \t    {\n-\t      HOST_WIDE_INT off = size_low_cst (offset0);\n-\t      if ((HOST_WIDE_INT) (((unsigned HOST_WIDE_INT) off)\n-\t\t\t\t   * BITS_PER_UNIT)\n-\t\t  / BITS_PER_UNIT == (HOST_WIDE_INT) off)\n+\t      offset_int tem = wi::sext (wi::to_offset (offset0),\n+\t\t\t\t\t TYPE_PRECISION (sizetype));\n+\t      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+\t      tem += bitpos0;\n+\t      if (wi::fits_shwi_p (tem))\n \t\t{\n-\t\t  bitpos0 = off * BITS_PER_UNIT;\n+\t\t  bitpos0 = tem.to_shwi ();\n \t\t  offset0 = NULL_TREE;\n \t\t}\n \t    }\n@@ -8471,18 +8469,30 @@ fold_comparison (location_t loc, enum tree_code code, tree type,\n \t  STRIP_SIGN_NOPS (base1);\n \t  if (TREE_CODE (base1) == ADDR_EXPR)\n \t    {\n-\t      base1 = TREE_OPERAND (base1, 0);\n-\t      indirect_base1 = true;\n+\t      base1\n+\t\t= get_inner_reference (TREE_OPERAND (base1, 0),\n+\t\t\t\t       &bitsize, &bitpos1, &offset1, &mode,\n+\t\t\t\t       &unsignedp, &reversep, &volatilep,\n+\t\t\t\t       false);\n+\t      if (TREE_CODE (base1) == INDIRECT_REF)\n+\t\tbase1 = TREE_OPERAND (base1, 0);\n+\t      else\n+\t\tindirect_base1 = true;\n \t    }\n-\t  offset1 = TREE_OPERAND (arg1, 1);\n-\t  if (tree_fits_shwi_p (offset1))\n+\t  if (offset1 == NULL_TREE || integer_zerop (offset1))\n+\t    offset1 = TREE_OPERAND (arg1, 1);\n+\t  else\n+\t    offset1 = size_binop (PLUS_EXPR, offset1,\n+\t\t\t\t  TREE_OPERAND (arg1, 1));\n+\t  if (TREE_CODE (offset1) == INTEGER_CST)\n \t    {\n-\t      HOST_WIDE_INT off = size_low_cst (offset1);\n-\t      if ((HOST_WIDE_INT) (((unsigned HOST_WIDE_INT) off)\n-\t\t\t\t   * BITS_PER_UNIT)\n-\t\t  / BITS_PER_UNIT == (HOST_WIDE_INT) off)\n+\t      offset_int tem = wi::sext (wi::to_offset (offset1),\n+\t\t\t\t\t TYPE_PRECISION (sizetype));\n+\t      tem = wi::lshift (tem, LOG2_BITS_PER_UNIT);\n+\t      tem += bitpos1;\n+\t      if (wi::fits_shwi_p (tem))\n \t\t{\n-\t\t  bitpos1 = off * BITS_PER_UNIT;\n+\t\t  bitpos1 = tem.to_shwi ();\n \t\t  offset1 = NULL_TREE;\n \t\t}\n \t    }\n@@ -10575,12 +10585,27 @@ fold_binary_loc (location_t loc,\n \t      || POINTER_TYPE_P (TREE_TYPE (arg0))))\n \t{\n \t  tree val = TREE_OPERAND (arg0, 1);\n-\t  return omit_two_operands_loc (loc, type,\n-\t\t\t\t    fold_build2_loc (loc, code, type,\n-\t\t\t\t\t\t val,\n-\t\t\t\t\t\t build_int_cst (TREE_TYPE (val),\n-\t\t\t\t\t\t\t\t0)),\n-\t\t\t\t    TREE_OPERAND (arg0, 0), arg1);\n+\t  val = fold_build2_loc (loc, code, type, val,\n+\t\t\t\t build_int_cst (TREE_TYPE (val), 0));\n+\t  return omit_two_operands_loc (loc, type, val,\n+\t\t\t\t\tTREE_OPERAND (arg0, 0), arg1);\n+\t}\n+\n+      /* Transform comparisons of the form X CMP X +- Y to Y CMP 0.  */\n+      if ((TREE_CODE (arg1) == PLUS_EXPR\n+\t   || TREE_CODE (arg1) == POINTER_PLUS_EXPR\n+\t   || TREE_CODE (arg1) == MINUS_EXPR)\n+\t  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg1,\n+\t\t\t\t\t\t\t\t\t0)),\n+\t\t\t      arg0, 0)\n+\t  && (INTEGRAL_TYPE_P (TREE_TYPE (arg1))\n+\t      || POINTER_TYPE_P (TREE_TYPE (arg1))))\n+\t{\n+\t  tree val = TREE_OPERAND (arg1, 1);\n+\t  val = fold_build2_loc (loc, code, type, val,\n+\t\t\t\t build_int_cst (TREE_TYPE (val), 0));\n+\t  return omit_two_operands_loc (loc, type, val,\n+\t\t\t\t\tTREE_OPERAND (arg1, 0), arg0);\n \t}\n \n       /* Transform comparisons of the form C - X CMP X if C % 2 == 1.  */\n@@ -10590,12 +10615,22 @@ fold_binary_loc (location_t loc,\n \t\t\t\t\t\t\t\t\t1)),\n \t\t\t      arg1, 0)\n \t  && wi::extract_uhwi (TREE_OPERAND (arg0, 0), 0, 1) == 1)\n-\t{\n-\t  return omit_two_operands_loc (loc, type,\n-\t\t\t\t    code == NE_EXPR\n-\t\t\t\t    ? boolean_true_node : boolean_false_node,\n-\t\t\t\t    TREE_OPERAND (arg0, 1), arg1);\n-\t}\n+\treturn omit_two_operands_loc (loc, type,\n+\t\t\t\t      code == NE_EXPR\n+\t\t\t\t      ? boolean_true_node : boolean_false_node,\n+\t\t\t\t      TREE_OPERAND (arg0, 1), arg1);\n+\n+      /* Transform comparisons of the form X CMP C - X if C % 2 == 1.  */\n+      if (TREE_CODE (arg1) == MINUS_EXPR\n+\t  && TREE_CODE (TREE_OPERAND (arg1, 0)) == INTEGER_CST\n+\t  && operand_equal_p (tree_strip_nop_conversions (TREE_OPERAND (arg1,\n+\t\t\t\t\t\t\t\t\t1)),\n+\t\t\t      arg0, 0)\n+\t  && wi::extract_uhwi (TREE_OPERAND (arg1, 0), 0, 1) == 1)\n+\treturn omit_two_operands_loc (loc, type,\n+\t\t\t\t      code == NE_EXPR\n+\t\t\t\t      ? boolean_true_node : boolean_false_node,\n+\t\t\t\t      TREE_OPERAND (arg1, 1), arg0);\n \n       /* If this is an EQ or NE comparison with zero and ARG0 is\n \t (1 << foo) & bar, convert it to (bar >> foo) & 1.  Both require"}, {"sha": "b0eb4691f13ad6532ac7b221b82c99e1ae3468b7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "patch": "@@ -1,3 +1,8 @@\n+2015-12-22  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR c++/67376\n+\t* g++.dg/cpp0x/constexpr-67376.C: New test.\n+\n 2015-12-22  Richard Henderson  <rth@redhat.com>\n \n \t* g++.dg/tm/noexcept-1.C: Update expected must_not_throw count."}, {"sha": "41043c8e54e8a9589727c0be77ec43c8589e042f", "filename": "gcc/testsuite/g++.dg/cpp0x/constexpr-67376.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-67376.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-67376.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fconstexpr-67376.C?ref=d6dd2c8e29213be6d5f95106bcb9b2cb7cbabb48", "patch": "@@ -0,0 +1,17 @@\n+// PR c++/67376\n+// { dg-do compile { target c++11 } }\n+\n+struct A { int e[2]; };\n+constexpr A a { { 0, 1 } };\n+static_assert (a.e + 1 != a.e, \"\");\n+static_assert (a.e != a.e + 1, \"\");\n+static_assert (a.e + 2 != a.e, \"\");\n+static_assert (a.e != a.e + 2, \"\");\n+static_assert (a.e + 1 > a.e, \"\");\n+static_assert (a.e < a.e + 1, \"\");\n+static_assert (a.e + 2 > a.e, \"\");\n+static_assert (a.e < a.e + 2, \"\");\n+static_assert (a.e + 1 >= a.e, \"\");\n+static_assert (a.e <= a.e + 1, \"\");\n+static_assert (a.e + 2 >= a.e, \"\");\n+static_assert (a.e <= a.e + 2, \"\");"}]}