{"sha": "af979a98bce444082cd5fc5d358dcdf3f65fdfce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWY5NzlhOThiY2U0NDQwODJjZDVmYzVkMzU4ZGNkZjNmNjVmZGZjZQ==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-05-14T19:25:25Z"}, "committer": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2021-05-15T19:04:56Z"}, "message": "rs6000: Emit ROP-mitigation instructions in prologue and epilogue\n\n2021-05-14  Bill Schmidt  <wschmidt@linux.ibm.com>\n\ngcc/\n\t* config/rs6000/rs6000-internal.h (rs6000_stack): Add\n\trop_hash_save_offset and rop_hash_size.\n\t* config/rs6000/rs6000-logue.c (rs6000_stack_info): Compute\n\trop_hash_size and rop_hash_save_offset.\n\t(debug_stack_info): Dump rop_hash_save_offset and rop_hash_size.\n\t(rs6000_emit_prologue): Emit hashst[p] in prologue.\n\t(rs6000_emit_epilogue): Emit hashchk[p] in epilogue.\n\t* config/rs6000/rs6000.md (unspec): Add UNSPEC_HASHST and\n\tUNSPEC_HASHCHK.\n\t(hashst): New define_insn.\n\t(hashchk): Likewise.", "tree": {"sha": "9a7f0afa2db2779b53e327b625825988c16a7591", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a7f0afa2db2779b53e327b625825988c16a7591"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af979a98bce444082cd5fc5d358dcdf3f65fdfce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af979a98bce444082cd5fc5d358dcdf3f65fdfce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af979a98bce444082cd5fc5d358dcdf3f65fdfce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af979a98bce444082cd5fc5d358dcdf3f65fdfce/comments", "author": null, "committer": null, "parents": [{"sha": "0df864ed1d24bbb0cf7504814e2f48e496ea5669", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0df864ed1d24bbb0cf7504814e2f48e496ea5669", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0df864ed1d24bbb0cf7504814e2f48e496ea5669"}], "stats": {"total": 107, "additions": 100, "deletions": 7}, "files": [{"sha": "88cf9bd56925defa20d0a277ab5704fe9ef9def1", "filename": "gcc/config/rs6000/rs6000-internal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-internal.h?ref=af979a98bce444082cd5fc5d358dcdf3f65fdfce", "patch": "@@ -39,6 +39,7 @@ typedef struct rs6000_stack {\n   int gp_save_offset;\t\t/* offset to save GP regs from initial SP */\n   int fp_save_offset;\t\t/* offset to save FP regs from initial SP */\n   int altivec_save_offset;\t/* offset to save AltiVec regs from initial SP */\n+  int rop_hash_save_offset;\t/* offset to save ROP hash from initial SP */\n   int lr_save_offset;\t\t/* offset to save LR from initial SP */\n   int cr_save_offset;\t\t/* offset to save CR from initial SP */\n   int vrsave_save_offset;\t/* offset to save VRSAVE from initial SP */\n@@ -53,6 +54,7 @@ typedef struct rs6000_stack {\n   int gp_size;\t\t\t/* size of saved GP registers */\n   int fp_size;\t\t\t/* size of saved FP registers */\n   int altivec_size;\t\t/* size of saved AltiVec registers */\n+  int rop_hash_size;\t\t/* size of ROP hash slot */\n   int cr_size;\t\t\t/* size to hold CR if not in fixed area */\n   int vrsave_size;\t\t/* size to hold VRSAVE */\n   int altivec_padding_size;\t/* size of altivec alignment padding */"}, {"sha": "13c00e740d6ac70a427fd7821cd9821e055bb064", "filename": "gcc/config/rs6000/rs6000-logue.c", "status": "modified", "additions": 67, "deletions": 7, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c?ref=af979a98bce444082cd5fc5d358dcdf3f65fdfce", "patch": "@@ -595,19 +595,21 @@ rs6000_savres_strategy (rs6000_stack_t *info,\n \t\t+---------------------------------------+\n \t\t| Parameter save area (+padding*) (P)\t|  32\n \t\t+---------------------------------------+\n-\t\t| Alloca space (A)\t\t\t|  32+P\n+\t\t| Optional ROP hash slot (R)\t\t|  32+P\n \t\t+---------------------------------------+\n-\t\t| Local variable space (L)\t\t|  32+P+A\n+\t\t| Alloca space (A)\t\t\t|  32+P+R\n \t\t+---------------------------------------+\n-\t\t| Save area for AltiVec registers (W)\t|  32+P+A+L\n+\t\t| Local variable space (L)\t\t|  32+P+R+A\n \t\t+---------------------------------------+\n-\t\t| AltiVec alignment padding (Y)\t\t|  32+P+A+L+W\n+\t\t| Save area for AltiVec registers (W)\t|  32+P+R+A+L\n \t\t+---------------------------------------+\n-\t\t| Save area for GP registers (G)\t|  32+P+A+L+W+Y\n+\t\t| AltiVec alignment padding (Y)\t\t|  32+P+R+A+L+W\n \t\t+---------------------------------------+\n-\t\t| Save area for FP registers (F)\t|  32+P+A+L+W+Y+G\n+\t\t| Save area for GP registers (G)\t|  32+P+R+A+L+W+Y\n \t\t+---------------------------------------+\n-\told SP->| back chain to caller's caller\t\t|  32+P+A+L+W+Y+G+F\n+\t\t| Save area for FP registers (F)\t|  32+P+R+A+L+W+Y+G\n+\t\t+---------------------------------------+\n+\told SP->| back chain to caller's caller\t\t|  32+P+R+A+L+W+Y+G+F\n \t\t+---------------------------------------+\n \n      * If the alloca area is present, the parameter save area is\n@@ -716,6 +718,19 @@ rs6000_stack_info (void)\n \n   /* Does this function call anything (apart from sibling calls)?  */\n   info->calls_p = (!crtl->is_leaf || cfun->machine->ra_needs_full_frame);\n+  info->rop_hash_size = 0;\n+\n+  if (TARGET_POWER10\n+      && info->calls_p\n+      && DEFAULT_ABI == ABI_ELFv2\n+      && rs6000_rop_protect)\n+    info->rop_hash_size = 8;\n+  else if (rs6000_rop_protect && DEFAULT_ABI != ABI_ELFv2)\n+    {\n+      /* We can't check this in rs6000_option_override_internal since\n+\t DEFAULT_ABI isn't established yet.  */\n+      error (\"%qs requires the ELFv2 ABI\", \"-mrop-protect\");\n+    }\n \n   /* Determine if we need to save the condition code registers.  */\n   if (save_reg_p (CR2_REGNO)\n@@ -808,6 +823,11 @@ rs6000_stack_info (void)\n \n \t  /* Adjust for AltiVec case.  */\n \t  info->ehrd_offset = info->altivec_save_offset - ehrd_size;\n+\n+\t  /* Adjust for ROP protection.  */\n+\t  info->rop_hash_save_offset\n+\t    = info->altivec_save_offset - info->rop_hash_size;\n+\t  info->ehrd_offset -= info->rop_hash_size;\n \t}\n       else\n \tinfo->ehrd_offset = info->gp_save_offset - ehrd_size;\n@@ -849,6 +869,7 @@ rs6000_stack_info (void)\n \t\t\t\t  + info->gp_size\n \t\t\t\t  + info->altivec_size\n \t\t\t\t  + info->altivec_padding_size\n+\t\t\t\t  + info->rop_hash_size\n \t\t\t\t  + ehrd_size\n \t\t\t\t  + ehcr_size\n \t\t\t\t  + info->cr_size\n@@ -987,6 +1008,10 @@ debug_stack_info (rs6000_stack_t *info)\n     fprintf (stderr, \"\\tvrsave_save_offset  = %5d\\n\",\n \t     info->vrsave_save_offset);\n \n+  if (info->rop_hash_size)\n+    fprintf (stderr, \"\\trop_hash_save_offset = %5d\\n\",\n+\t     info->rop_hash_save_offset);\n+\n   if (info->lr_save_p)\n     fprintf (stderr, \"\\tlr_save_offset      = %5d\\n\", info->lr_save_offset);\n \n@@ -1026,6 +1051,9 @@ debug_stack_info (rs6000_stack_t *info)\n     fprintf (stderr, \"\\taltivec_padding_size= %5d\\n\",\n \t     info->altivec_padding_size);\n \n+  if (info->rop_hash_size)\n+    fprintf (stderr, \"\\trop_hash_size       = %5d\\n\", info->rop_hash_size);\n+\n   if (info->cr_size)\n     fprintf (stderr, \"\\tcr_size             = %5d\\n\", info->cr_size);\n \n@@ -3252,6 +3280,22 @@ rs6000_emit_prologue (void)\n \t}\n     }\n \n+  /* The ROP hash store must occur before a stack frame is created,\n+     since the hash operates on r1.  */\n+  /* NOTE: The hashst isn't needed if we're going to do a sibcall,\n+     but there's no way to know that here.  Harmless except for\n+     performance, of course.  */\n+  if (TARGET_POWER10 && rs6000_rop_protect && info->rop_hash_size != 0)\n+    {\n+      gcc_assert (DEFAULT_ABI == ABI_ELFv2);\n+      rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+      rtx addr = gen_rtx_PLUS (Pmode, stack_ptr,\n+\t\t\t       GEN_INT (info->rop_hash_save_offset));\n+      rtx mem = gen_rtx_MEM (Pmode, addr);\n+      rtx reg0 = gen_rtx_REG (Pmode, 0);\n+      emit_insn (gen_hashst (mem, reg0));\n+    }\n+\n   /* If we need to save CR, put it into r12 or r11.  Choose r12 except when\n      r12 will be needed by out-of-line gpr save.  */\n   cr_save_regno = ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_ELFv2)\n@@ -4980,6 +5024,22 @@ rs6000_emit_epilogue (enum epilogue_type epilogue_type)\n       emit_insn (gen_add3_insn (sp_reg_rtx, sp_reg_rtx, sa));\n     }\n \n+  /* The ROP hash check must occur after the stack pointer is restored\n+     (since the hash involves r1), and is not performed for a sibcall.  */\n+  if (TARGET_POWER10\n+      && rs6000_rop_protect\n+      && info->rop_hash_size != 0\n+      && epilogue_type != EPILOGUE_TYPE_SIBCALL)\n+    {\n+      gcc_assert (DEFAULT_ABI == ABI_ELFv2);\n+      rtx stack_ptr = gen_rtx_REG (Pmode, STACK_POINTER_REGNUM);\n+      rtx addr = gen_rtx_PLUS (Pmode, stack_ptr,\n+\t\t\t       GEN_INT (info->rop_hash_save_offset));\n+      rtx mem = gen_rtx_MEM (Pmode, addr);\n+      rtx reg0 = gen_rtx_REG (Pmode, 0);\n+      emit_insn (gen_hashchk (reg0, mem));\n+    }\n+\n   if (epilogue_type != EPILOGUE_TYPE_SIBCALL && restoring_FPRs_inline)\n     {\n       if (cfa_restores)"}, {"sha": "0bfeb24d9e8727798a349526f93c9bcae3c86248", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af979a98bce444082cd5fc5d358dcdf3f65fdfce/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=af979a98bce444082cd5fc5d358dcdf3f65fdfce", "patch": "@@ -154,6 +154,8 @@\n    UNSPEC_CNTTZDM\n    UNSPEC_PDEPD\n    UNSPEC_PEXTD\n+   UNSPEC_HASHST\n+   UNSPEC_HASHCHK\n   ])\n \n ;;\n@@ -14948,6 +14950,35 @@\n   \"TARGET_P9_MISC && TARGET_64BIT\"\n   \"cmpeqb %0,%1,%2\"\n   [(set_attr \"type\" \"logical\")])\n+\n+\n+;; ROP mitigation instructions.\n+\n+(define_insn \"hashst\"\n+  [(set (match_operand:DI 0 \"simple_offsettable_mem_operand\" \"=m\")\n+        (unspec_volatile:DI [(match_operand:DI 1 \"int_reg_operand\" \"r\")]\n+\t\t\t    UNSPEC_HASHST))]\n+  \"TARGET_POWER10 && rs6000_rop_protect\"\n+{\n+  static char templ[32];\n+  const char *p = rs6000_privileged ? \"p\" : \"\";\n+  sprintf (templ, \"hashst%s %%1,%%0\", p);\n+  return templ;\n+}\n+  [(set_attr \"type\" \"store\")])\n+\n+(define_insn \"hashchk\"\n+  [(unspec_volatile [(match_operand:DI 0 \"int_reg_operand\" \"r\")\n+\t\t     (match_operand:DI 1 \"simple_offsettable_mem_operand\" \"m\")]\n+\t\t    UNSPEC_HASHCHK)]\n+  \"TARGET_POWER10 && rs6000_rop_protect\"\n+{\n+  static char templ[32];\n+  const char *p = rs6000_privileged ? \"p\" : \"\";\n+  sprintf (templ, \"hashchk%s %%0,%%1\", p);\n+  return templ;\n+}\n+  [(set_attr \"type\" \"load\")])\n \f\n \n (include \"sync.md\")"}]}