{"sha": "073089a7e016eaee614755fc4d54e74007de779b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDczMDg5YTdlMDE2ZWFlZTYxNDc1NWZjNGQ1NGU3NDAwN2RlNzc5Yg==", "commit": {"author": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-26T18:23:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-09-26T18:23:33Z"}, "message": "re PR rtl-optimization/11741 (internal compiler error at gcse.c:5318)\n\n\n\tPR optimization/11741\n\t* gcse.c (pre_insert_copy_insn): Tweak the logic for finding the\n\tappropriate set to match that in hash_scan_insn.  Fall back to\n\tthe original copy method, if we can't validate changing insn.\n\t(pre_delete): Only delete instructions that have a single_set,\n\tinstead of aborting when we encounter an PARALLEL insn with more\n\tthen one SET.\n\n\t* gcc.dg/20030926-1.c: New test case.\n\nFrom-SVN: r71827", "tree": {"sha": "5040023f54434be9483c111c7a2cbc52d48270c4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5040023f54434be9483c111c7a2cbc52d48270c4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/073089a7e016eaee614755fc4d54e74007de779b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073089a7e016eaee614755fc4d54e74007de779b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/073089a7e016eaee614755fc4d54e74007de779b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/073089a7e016eaee614755fc4d54e74007de779b/comments", "author": null, "committer": null, "parents": [{"sha": "43ab026f2a019405f7e5af2a35ac41467dc35111", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ab026f2a019405f7e5af2a35ac41467dc35111", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ab026f2a019405f7e5af2a35ac41467dc35111"}], "stats": {"total": 135, "additions": 98, "deletions": 37}, "files": [{"sha": "22bfb29e87646f49ceada4b8dd4ef5d64d4447c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073089a7e016eaee614755fc4d54e74007de779b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073089a7e016eaee614755fc4d54e74007de779b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=073089a7e016eaee614755fc4d54e74007de779b", "patch": "@@ -1,3 +1,14 @@\n+2003-09-26  Roger Sayle  <roger@eyesopen.com>\n+\t    Richard Henderson  <rth@redhat.com>\n+\n+\tPR optimization/11741\n+\t* gcse.c (pre_insert_copy_insn): Tweak the logic for finding the\n+\tappropriate set to match that in hash_scan_insn.  Fall back to\n+\tthe original copy method, if we can't validate changing insn.\n+\t(pre_delete): Only delete instructions that have a single_set,\n+\tinstead of aborting when we encounter an PARALLEL insn with more\n+\tthen one SET.\n+\n 2003-09-26  Andreas Krebbel  <krebbel1@de.ibm.com>\n \n \t* config/s390/s390.md (\"builtin_setjmp_setup\"): Insn deleted."}, {"sha": "8e78e5b08e64783da833bf7b501ba45c49d8820d", "filename": "gcc/gcse.c", "status": "modified", "additions": 48, "deletions": 22, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=073089a7e016eaee614755fc4d54e74007de779b", "patch": "@@ -5353,42 +5353,68 @@ pre_edge_insert (struct edge_list *edge_list, struct expr **index_map)\n   return did_insert;\n }\n \n-/* Copy the result of INSN to REG.  INDX is the expression number.\n+/* Copy the result of EXPR->EXPR generated by INSN to EXPR->REACHING_REG.\n    Given \"old_reg <- expr\" (INSN), instead of adding after it\n      reaching_reg <- old_reg\n    it's better to do the following:\n      reaching_reg <- expr\n      old_reg      <- reaching_reg\n    because this way copy propagation can discover additional PRE\n-   opportunuties.  */\n+   opportunuties.  But if this fails, we try the old way.  */\n \n static void\n pre_insert_copy_insn (struct expr *expr, rtx insn)\n {\n   rtx reg = expr->reaching_reg;\n   int regno = REGNO (reg);\n   int indx = expr->bitmap_index;\n-  rtx set = single_set (insn);\n-  rtx new_insn;\n-  rtx new_set;\n+  rtx pat = PATTERN (insn);\n+  rtx set, new_insn;\n   rtx old_reg;\n+  int i;\n \n-  if (!set)\n+  /* This block matches the logic in hash_scan_insn.  */\n+  if (GET_CODE (pat) == SET)\n+    set = pat;\n+  else if (GET_CODE (pat) == PARALLEL)\n+    {\n+      /* Search through the parallel looking for the set whose\n+\t source was the expression that we're interested in.  */\n+      set = NULL_RTX;\n+      for (i = 0; i < XVECLEN (pat, 0); i++)\n+\t{\n+\t  rtx x = XVECEXP (pat, 0, i);\n+\t  if (GET_CODE (x) == SET\n+\t      && expr_equiv_p (SET_SRC (x), expr->expr))\n+\t    {\n+\t      set = x;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  else\n     abort ();\n \n   old_reg = SET_DEST (set);\n-  new_insn = emit_insn_after (gen_move_insn (old_reg,\n-                                             reg),\n-                              insn);\n-  new_set = single_set (new_insn);\n \n-  if (!new_set)\n-    abort();\n-  SET_DEST (set) = reg;\n+  /* Check if we can modify the set destination in the original insn.  */\n+  if (validate_change (insn, &SET_DEST (set), reg, 0))\n+    {\n+      new_insn = gen_move_insn (old_reg, reg);\n+      new_insn = emit_insn_after (new_insn, insn);\n+\n+      /* Keep register set table up to date.  */\n+      replace_one_set (REGNO (old_reg), insn, new_insn);\n+      record_one_set (regno, insn);\n+    }\n+  else\n+    {\n+      new_insn = gen_move_insn (reg, old_reg);\n+      new_insn = emit_insn_after (new_insn, insn);\n \n-  /* Keep register set table up to date.  */\n-  replace_one_set (REGNO (old_reg), insn, new_insn);\n-  record_one_set (regno, insn);\n+      /* Keep register set table up to date.  */\n+      record_one_set (regno, new_insn);\n+    }\n \n   gcse_create_count++;\n \n@@ -5505,7 +5531,9 @@ pre_delete (void)\n \n   changed = 0;\n   for (i = 0; i < expr_hash_table.size; i++)\n-    for (expr = expr_hash_table.table[i]; expr != NULL; expr = expr->next_same_hash)\n+    for (expr = expr_hash_table.table[i];\n+\t expr != NULL;\n+\t expr = expr->next_same_hash)\n       {\n \tint indx = expr->bitmap_index;\n \n@@ -5518,12 +5546,10 @@ pre_delete (void)\n \t    rtx set;\n \t    basic_block bb = BLOCK_FOR_INSN (insn);\n \n-\t    if (TEST_BIT (pre_delete_map[bb->index], indx))\n+\t    /* We only delete insns that have a single_set.  */\n+\t    if (TEST_BIT (pre_delete_map[bb->index], indx)\n+\t\t&& (set = single_set (insn)) != 0)\n \t      {\n-\t\tset = single_set (insn);\n-\t\tif (! set)\n-\t\t  abort ();\n-\n \t\t/* Create a pseudo-reg to store the result of reaching\n \t\t   expressions into.  Get the mode for the new pseudo from\n \t\t   the mode of the original destination pseudo.  */"}, {"sha": "ae27c3533120d2798e54a98e96ed1c7576387306", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=073089a7e016eaee614755fc4d54e74007de779b", "patch": "@@ -1,3 +1,8 @@\n+2003-09-26  Roger Sayle  <roger@eyesopen.com>\n+\n+\tPR optimization/11741\n+\t* gcc.dg/20030926-1.c: New test case.\n+\n 2003-09-25  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n \n \tPR c++/5655\n@@ -10,26 +15,31 @@\n \t* lib/objc.exp (objc_target_compile): Do not point at libobjc headers\n \tif libobjc has not been built.\n \t* objc/execute/IMP.m, objc/execute/_cmd.m, objc/execute/bf-common.h,\n-\tobjc/execute/bycopy-3.m, objc/execute/class-{1-14}.m, objc/execute/class-self-2.m,\n-\tobjc/execute/many_args_method.m, objc/execute/nested-3.m, objc/execute/np-2.m,\n+\tobjc/execute/bycopy-3.m, objc/execute/class-{1-14}.m,\n+\tobjc/execute/class-self-2.m, objc/execute/many_args_method.m,\n+\tobjc/execute/nested-3.m, objc/execute/np-2.m,\n \tobjc/execute/object_is_class.m, objc/execute/object_is_meta_class.m,\n \tobjc/execute/redefining_self.m, objc/execute/root_methods.m,\n-\tobjc/execute/static-{1-2}.m, objc/execute/string-{1-4}.m, objc/execute/va_method.m,\n-\tobjc.dg/comp-types-4.m, objc.dg/headers.m, objc.dg/special/unclaimed-category-1.h,\n-\tobjc.dg/special/unclaimed-category-1.m: Make usable with NeXT as well as GNU runtime.\n+\tobjc/execute/static-{1-2}.m, objc/execute/string-{1-4}.m,\n+\tobjc/execute/va_method.m, objc.dg/comp-types-4.m, objc.dg/headers.m,\n+\tobjc.dg/special/unclaimed-category-1.h,\n+\tobjc.dg/special/unclaimed-category-1.m: Make usable with NeXT as\n+\twell as GNU runtime.\n \t* execute/next_mapping.h: New header, for GNU->NeXT impedance matching.\n-\t* execute/cascading-1.m, execute/function-message-1.m, objc.dg/anon-1.m,\n-\tobjc.dg/bitfield-{3-4}.m, objc.dg/call-super-{1-3}.m, objc.dg/category-1.m,\n-\tobjc.dg/const-str-{3-6}.m, objc.dg/encode-{1-4}.m, objc.dg/func-ptr-1.m,\n-\tobjc.dg/gnu-runtime-1.m, objc.dg/image-info.m, objc.dg/method-{3-12}.m,\n-\tobjc.dg/missing-proto-{1-3}.m, objc.dg/nested-func-1.m, objc.dg/proto-lossage-2.m,\n-\tobjc.dg/proto-qual-1.m, objc.dg/sizeof-1.m, objc.dg/static-1.m, objc.dg/symtab-1.m,\n-\tobjc.dg/try-catch-{1-4}.m, objc.dg/type-size-{1-2}.m, objc.dg/zero-link-{1-2}.m:\n-\tNew test cases.\n+\t* execute/cascading-1.m, execute/function-message-1.m,\n+\tobjc.dg/anon-1.m, objc.dg/bitfield-{3-4}.m,\n+\tobjc.dg/call-super-{1-3}.m, objc.dg/category-1.m,\n+\tobjc.dg/const-str-{3-6}.m, objc.dg/encode-{1-4}.m,\n+\tobjc.dg/func-ptr-1.m, objc.dg/gnu-runtime-1.m, objc.dg/image-info.m,\n+\tobjc.dg/method-{3-12}.m, objc.dg/missing-proto-{1-3}.m,\n+\tobjc.dg/nested-func-1.m, objc.dg/proto-lossage-2.m,\n+\tobjc.dg/proto-qual-1.m, objc.dg/sizeof-1.m, objc.dg/static-1.m,\n+\tobjc.dg/symtab-1.m, objc.dg/try-catch-{1-4}.m,\n+\tobjc.dg/type-size-{1-2}.m, objc.dg/zero-link-{1-2}.m: New test cases.\n \t* objc.dg/bitfield-2.m: Run only on Darwin.\n \t* objc.dg/class-2.m, objc.dg/comp-types-1.m, objc.dg/desig-init-1.m,\n-\tobjc.dg/method-{1-2}.m, objc.dg/proto-hier-1.m, objc.dg/proto-lossage-1.m:\n-\tAdjust for message wording changes.\n+\tobjc.dg/method-{1-2}.m, objc.dg/proto-hier-1.m,\n+\tobjc.dg/proto-lossage-1.m: Adjust for message wording changes.\n \t* objc.dg/const-str-1.m: Fix constant string layout.\n  \n 2003-09-24  Alexandre Oliva  <aoliva@redhat.com>"}, {"sha": "085cb9b4da1d17e188e761add6df436ffb8afc43", "filename": "gcc/testsuite/gcc.dg/20030926-1.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Ftestsuite%2Fgcc.dg%2F20030926-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/073089a7e016eaee614755fc4d54e74007de779b/gcc%2Ftestsuite%2Fgcc.dg%2F20030926-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20030926-1.c?ref=073089a7e016eaee614755fc4d54e74007de779b", "patch": "@@ -0,0 +1,14 @@\n+/* PR optimization/11741  */\n+/* { dg-do compile { target i?86-*-* x86_64-*-* } } */\n+/* { dg-options \"-O2 -minline-all-stringops -march=pentium4\" } */\n+\n+void\n+foo (char *p)\n+{\n+  for (;;)\n+    {\n+      memcpy (p, p + 1, strlen (p));\n+      p++;\n+    }\n+}\n+"}]}