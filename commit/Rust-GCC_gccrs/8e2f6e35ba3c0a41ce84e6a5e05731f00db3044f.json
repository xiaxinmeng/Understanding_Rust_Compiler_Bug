{"sha": "8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGUyZjZlMzViYTNjMGE0MWNlODRlNmE1ZTA1NzMxZjAwZGIzMDQ0Zg==", "commit": {"author": {"name": "Bernd Schmidt", "email": "crux@pool.informatik.rwth-aachen.de", "date": "1998-10-19T09:47:55Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1998-10-19T09:47:55Z"}, "message": "combine.c (recog_for_combine): Lose PADDED_SCRATCHES arg.\n\n\t* combine.c (recog_for_combine): Lose PADDED_SCRATCHES arg.  All\n\tcallers changed.\n\t(try_combine): Don't update max_scratch.\n\t* flow.c (max_scratch, num_scratch): Delete variables.\n\t(life_analysis_1): Don't initialize max_scratch.\n\t(propagate_block): Don't update max_scratch.\n\t(mark_set_1): Don't increment num_scratch.\n\t* regs.h (max_scratch): Delete declaration.\n\nFrom-SVN: r23172", "tree": {"sha": "5cc75d1ec07f21f993ad6ecedcd6cd7f5894aa7e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5cc75d1ec07f21f993ad6ecedcd6cd7f5894aa7e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/comments", "author": null, "committer": null, "parents": [{"sha": "02bc9733948fb3f06d4aa1ad1c93f4c67688545c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02bc9733948fb3f06d4aa1ad1c93f4c67688545c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02bc9733948fb3f06d4aa1ad1c93f4c67688545c"}], "stats": {"total": 93, "additions": 28, "deletions": 65}, "files": [{"sha": "d29853128cbb993b276aac559762de2f12d46605", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "patch": "@@ -1,3 +1,14 @@\n+Mon Oct 19 10:45:40 1998  Bernd Schmidt <crux@pool.informatik.rwth-aachen.de> \n+\n+\t* combine.c (recog_for_combine): Lose PADDED_SCRATCHES arg.  All\n+\tcallers changed.\n+\t(try_combine): Don't update max_scratch.\n+\t* flow.c (max_scratch, num_scratch): Delete variables.\n+\t(life_analysis_1): Don't initialize max_scratch.\n+\t(propagate_block): Don't update max_scratch.\n+\t(mark_set_1): Don't increment num_scratch.\n+\t* regs.h (max_scratch): Delete declaration.\n+\n Mon Oct 19 10:28:15 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* sched.c (update_flow_info): Handle death notes made invalid by"}, {"sha": "19df1047684182dbaa0ade64e5312f0b3f8e33fa", "filename": "gcc/combine.c", "status": "modified", "additions": 17, "deletions": 44, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "patch": "@@ -426,7 +426,7 @@ static int merge_outer_ops\tPROTO((enum rtx_code *, HOST_WIDE_INT *,\n \t\t\t\t       enum machine_mode, int *));\n static rtx simplify_shift_const\tPROTO((rtx, enum rtx_code, enum machine_mode,\n \t\t\t\t       rtx, int));\n-static int recog_for_combine\tPROTO((rtx *, rtx, rtx *, int *));\n+static int recog_for_combine\tPROTO((rtx *, rtx, rtx *));\n static rtx gen_lowpart_for_combine  PROTO((enum machine_mode, rtx));\n static rtx gen_rtx_combine PVPROTO((enum rtx_code code, enum machine_mode mode,\n \t\t\t\t  ...));\n@@ -1356,8 +1356,6 @@ try_combine (i3, i2, i1)\n   int i3_subst_into_i2 = 0;\n   /* Notes that I1, I2 or I3 is a MULT operation.  */\n   int have_mult = 0;\n-  /* Number of clobbers of SCRATCH we had to add.  */\n-  int i3_scratches = 0, i2_scratches = 0, other_scratches = 0;\n \n   int maxreg;\n   rtx temp;\n@@ -1834,8 +1832,7 @@ try_combine (i3, i2, i1)\n   mark_used_regs_combine (newpat);\n \n   /* Is the result of combination a valid instruction?  */\n-  insn_code_number\n-    = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+  insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \n   /* If the result isn't valid, see if it is a PARALLEL of two SETs where\n      the second SET's destination is a register that is unused.  In that case,\n@@ -1856,8 +1853,7 @@ try_combine (i3, i2, i1)\n       && asm_noperands (newpat) < 0)\n     {\n       newpat = XVECEXP (newpat, 0, 0);\n-      insn_code_number\n-\t= recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n     }\n \n   else if (insn_code_number < 0 && GET_CODE (newpat) == PARALLEL\n@@ -1870,8 +1866,7 @@ try_combine (i3, i2, i1)\n \t   && asm_noperands (newpat) < 0)\n     {\n       newpat = XVECEXP (newpat, 0, 1);\n-      insn_code_number\n-\t= recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+      insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n     }\n \n   /* If we were combining three insns and the result is a simple SET\n@@ -1940,8 +1935,7 @@ try_combine (i3, i2, i1)\n \t  if (REGNO (i2dest) >= FIRST_PSEUDO_REGISTER)\n \t    SUBST (regno_reg_rtx[REGNO (i2dest)], ni2dest);\n \n-\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes,\n-\t\t\t\t\t      &i2_scratches);\n+\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n \t  /* If I2 or I3 has multiple SETs, we won't know how to track\n \t     register status, so don't use these insns.  If I2's destination\n@@ -1950,8 +1944,8 @@ try_combine (i3, i2, i1)\n \t  if (i2_code_number >= 0 && i2set && i3set\n \t      && (next_real_insn (i2) == i3\n \t\t  || ! reg_used_between_p (SET_DEST (i2set), i2, i3)))\n-\t    insn_code_number = recog_for_combine (&newi3pat, i3, &new_i3_notes,\n-\t\t\t\t\t\t  &i3_scratches); \n+\t    insn_code_number = recog_for_combine (&newi3pat, i3,\n+\t\t\t\t\t\t  &new_i3_notes);\n \t  if (insn_code_number >= 0)\n \t    newpat = newi3pat;\n \n@@ -2038,14 +2032,12 @@ try_combine (i3, i2, i1)\n \n \t  newi2pat = gen_rtx_combine (SET, VOIDmode, newdest, *split);\n \t  SUBST (*split, newdest);\n-\t  i2_code_number\n-\t    = recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n+\t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n \t  /* If the split point was a MULT and we didn't have one before,\n \t     don't use one now.  */\n \t  if (i2_code_number >= 0 && ! (split_code == MULT && ! have_mult))\n-\t    insn_code_number\n-\t      = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+\t    insn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \t}\n     }\n \n@@ -2099,12 +2091,10 @@ try_combine (i3, i2, i1)\n       newpat = XVECEXP (newpat, 0, 1);\n       SUBST (SET_SRC (newpat),\n \t     gen_lowpart_for_combine (GET_MODE (SET_SRC (newpat)), ni2dest));\n-      i2_code_number\n-\t= recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n+      i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n       if (i2_code_number >= 0)\n-\tinsn_code_number\n-\t  = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+\tinsn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n \n       if (insn_code_number >= 0)\n \t{\n@@ -2191,12 +2181,10 @@ try_combine (i3, i2, i1)\n \t  newpat = XVECEXP (newpat, 0, 0);\n \t}\n \n-      i2_code_number\n-\t= recog_for_combine (&newi2pat, i2, &new_i2_notes, &i2_scratches);\n+      i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n       if (i2_code_number >= 0)\n-\tinsn_code_number\n-\t  = recog_for_combine (&newpat, i3, &new_i3_notes, &i3_scratches);\n+\tinsn_code_number = recog_for_combine (&newpat, i3, &new_i3_notes);\n     }\n \n   /* If it still isn't recognized, fail and change things back the way they\n@@ -2218,9 +2206,8 @@ try_combine (i3, i2, i1)\n \n       CLEAR_HARD_REG_SET (newpat_used_regs);\n \n-      other_code_number\n-\t= recog_for_combine (&other_pat, undobuf.other_insn,\n-\t\t\t     &new_other_notes, &other_scratches);\n+      other_code_number = recog_for_combine (&other_pat, undobuf.other_insn,\n+\t\t\t\t\t     &new_other_notes);\n \n       if (other_code_number < 0 && ! check_asm_operands (other_pat))\n \t{\n@@ -2537,12 +2524,6 @@ try_combine (i3, i2, i1)\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies);\n \n-    /* If we added any (clobber (scratch)), add them to the max for a\n-       block.  This is a very pessimistic calculation, since we might\n-       have had them already and this might not be the worst block, but\n-       it's not worth doing any better.  */\n-    max_scratch += i3_scratches + i2_scratches + other_scratches;\n-\n     /* If I3 is now an unconditional jump, ensure that it has a \n        BARRIER following it since it may have initially been a\n        conditional jump.  It may also be the last nonnote insn.  */\n@@ -4653,7 +4634,7 @@ simplify_set (x)\n \t      rtx pat = PATTERN (other_insn), note = 0;\n \t      int scratches;\n \n-\t      if ((recog_for_combine (&pat, other_insn, &note, &scratches) < 0\n+\t      if ((recog_for_combine (&pat, other_insn, &note) < 0\n \t\t   && ! check_asm_operands (pat)))\n \t\t{\n \t\t  PUT_CODE (*cc_use, old_code);\n@@ -9052,27 +9033,21 @@ simplify_shift_const (x, code, result_mode, varop, count)\n    PNOTES is a pointer to a location where any REG_UNUSED notes added for\n    the CLOBBERs are placed.\n \n-   PADDED_SCRATCHES is set to the number of (clobber (scratch)) patterns\n-   we had to add.\n-\n    The value is the final insn code from the pattern ultimately matched,\n    or -1.  */\n \n static int\n-recog_for_combine (pnewpat, insn, pnotes, padded_scratches)\n+recog_for_combine (pnewpat, insn, pnotes)\n      rtx *pnewpat;\n      rtx insn;\n      rtx *pnotes;\n-     int *padded_scratches;\n {\n   register rtx pat = *pnewpat;\n   int insn_code_number;\n   int num_clobbers_to_add = 0;\n   int i;\n   rtx notes = 0;\n \n-  *padded_scratches = 0;\n-\n   /* If PAT is a PARALLEL, check to see if it contains the CLOBBER\n      we use to indicate that something didn't match.  If we find such a\n      thing, force rejection.  */\n@@ -9134,8 +9109,6 @@ recog_for_combine (pnewpat, insn, pnotes, padded_scratches)\n \t  if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == REG\n \t      && ! reg_dead_at_p (XEXP (XVECEXP (newpat, 0, i), 0), insn))\n \t    return -1;\n-\t  else if (GET_CODE (XEXP (XVECEXP (newpat, 0, i), 0)) == SCRATCH)\n-\t    (*padded_scratches)++;\n \t  notes = gen_rtx_EXPR_LIST (REG_UNUSED,\n \t\t\t\t     XEXP (XVECEXP (newpat, 0, i), 0), notes);\n \t}"}, {"sha": "94251ff384209f23c2347fb2dc54da15a91f0526", "filename": "gcc/flow.c", "status": "modified", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "patch": "@@ -167,15 +167,6 @@ int n_basic_blocks;\n \n int max_regno;\n \n-/* Maximum number of SCRATCH rtx's used in any basic block of this\n-   function.  */\n-\n-int max_scratch;\n-\n-/* Number of SCRATCH rtx's in the current block.  */\n-\n-static int num_scratch;\n-\n /* Indexed by n, giving various register information */\n \n varray_type reg_n_info;\n@@ -1544,8 +1535,6 @@ life_analysis_1 (f, nregs)\n      basic_block_live_at_start[i]).  This is ok now because\n      basic_block_live_at_end[i] is no longer used past this point.  */\n \n-  max_scratch = 0;\n-\n   for (i = 0; i < n_basic_blocks; i++)\n     {\n       propagate_block (basic_block_live_at_end[i],\n@@ -1733,8 +1722,6 @@ propagate_block (old, first, last, final, significant, bnum)\n     {\n       register int i;\n \n-      num_scratch = 0;\n-\n       /* Process the regs live at the end of the block.\n \t Mark them as not local to any one basic block. */\n       EXECUTE_IF_SET_IN_REG_SET (old, 0, i,\n@@ -1962,9 +1949,6 @@ propagate_block (old, first, last, final, significant, bnum)\n \n   FREE_REG_SET (dead);\n   FREE_REG_SET (live);\n-\n-  if (num_scratch > max_scratch)\n-    max_scratch = num_scratch;\n }\n \f\n /* Return 1 if X (the body of an insn, or part of it) is just dead stores\n@@ -2412,7 +2396,6 @@ mark_set_1 (needed, dead, x, insn, significant)\n     {\n       REG_NOTES (insn)\n \t= gen_rtx_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (insn));\n-      num_scratch++;\n     }\n }\n \f"}, {"sha": "d513093bf0d50eb5bc711dce1fb12cc15a9f2290", "filename": "gcc/regs.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=8e2f6e35ba3c0a41ce84e6a5e05731f00db3044f", "patch": "@@ -38,10 +38,6 @@ Boston, MA 02111-1307, USA.  */\n \n extern int max_regno;\n \n-/* Maximum number of SCRATCH rtx's in each block of this function.  */\n-\n-extern int max_scratch;\n-\n /* Register information indexed by register number */\n typedef struct reg_info_def {\n \t\t\t\t/* fields set by reg_scan */"}]}