{"sha": "4c5b1160776382772fc0a33130dfaf621699fdbf", "node_id": "C_kwDOANBUbNoAKDRjNWIxMTYwNzc2MzgyNzcyZmMwYTMzMTMwZGZhZjYyMTY5OWZkYmY", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-24T06:52:12Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-10-25T11:40:10Z"}, "message": "tree-optimization/107176 - SCEV analysis association issue\n\nThe following fixes a wrong-code issue caused by SCEV analysis\nassociating an addition due trying to use tail-recursion in\nfollow_ssa_edge_expr.  That causes us to apply a conversion at\nthe wrong point and thus miscompute the scalar evolution of\nan induction variable.  This reverts the PR66375 fix and\nrevisits the PR42512 fix by keeping the evolution symbolic\nup to the point we process the first linear function when\nwe then can check for the supported cases and substitute the\nwhole symbolic expression with the built chrec substituting\nthe proper initial value.\n\nTo simplify passing around things and to clarify scoping of\nthe involved functions this change wraps the SCEV DFS walking\ncode into a class.\n\n\tPR tree-optimization/107176\n\tPR tree-optimization/66375\n\tPR tree-optimization/42512\n\t* tree-scalar-evolution.cc (follow_ssa_edge_expr): Revert\n\tthe PR66375 fix, do not not associate PLUS_EXPR to be able\n\tto use tail-recursion.\n\t(follow_ssa_edge_binary): Likewise.\n\t(interpret_loop_phi): Revert PR42512 fix, do not throw\n\taway analyze_evolution_in_loop result after the fact.\n\t(follow_ssa_edge_expr): When reaching halting_phi initalize\n\tthe evolution to the symbolic value of the PHI result.\n\t(add_to_evolution_1): When adding the first evolution verify\n\twe can handle the expression wrapping the symbolic evolution\n\tand replace that in full using the initial condition.\n\t(class scev_dfs): New, contains ...\n\t(follow_ssa_edge_expr, follow_ssa_edge_binary,\n\tfollow_ssa_edge_in_condition_phi_branch,\n\tfollow_ssa_edge_in_condition_phi,\n\tfollow_ssa_edge_inner_loop_phi,\n\tadd_to_evolution, add_to_evolution_1): ... these with\n\tloop and halting_phi arguments in class data.\n\t(scev_dfs::get_ev): New toplevel DFS entry, start with\n\ta chrec_dont_know evolution.\n\t(analyze_evolution_in_loop): Use scev_dfs.\n\n\t* gcc.dg/torture/pr107176.c: New testcase.", "tree": {"sha": "e62c6cc7b34750164fa02c4518434162d155778c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e62c6cc7b34750164fa02c4518434162d155778c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c5b1160776382772fc0a33130dfaf621699fdbf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5b1160776382772fc0a33130dfaf621699fdbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c5b1160776382772fc0a33130dfaf621699fdbf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c5b1160776382772fc0a33130dfaf621699fdbf/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cb21297f9259ceedd5f5dd7c3973535f14124d6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb21297f9259ceedd5f5dd7c3973535f14124d6d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb21297f9259ceedd5f5dd7c3973535f14124d6d"}], "stats": {"total": 342, "additions": 185, "deletions": 157}, "files": [{"sha": "c4f7b6d7336c66e9a294dae0b2adb100e9712c17", "filename": "gcc/testsuite/gcc.dg/torture/pr107176.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5b1160776382772fc0a33130dfaf621699fdbf/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107176.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5b1160776382772fc0a33130dfaf621699fdbf/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107176.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr107176.c?ref=4c5b1160776382772fc0a33130dfaf621699fdbf", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do run } */\n+\n+__INT32_TYPE__ a;\n+__INT64_TYPE__ b;\n+static inline __INT64_TYPE__ c(__UINT32_TYPE__ d)\n+{\n+  return d;\n+}\n+static inline void e(__INT32_TYPE__ d)\n+{\n+  a = d;\n+}\n+int main()\n+{\n+  b = 0;\n+  for (; b < 1; b = c(b - 90) + 90 + 1)\n+    ;\n+  e(b >> 2);\n+  if (a != 1073741824)\n+    __builtin_abort();\n+  return 0;\n+}"}, {"sha": "7e2a3e986619de87e4ae9daf16198be1f13b917c", "filename": "gcc/tree-scalar-evolution.cc", "status": "modified", "additions": 163, "deletions": 157, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c5b1160776382772fc0a33130dfaf621699fdbf/gcc%2Ftree-scalar-evolution.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c5b1160776382772fc0a33130dfaf621699fdbf/gcc%2Ftree-scalar-evolution.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.cc?ref=4c5b1160776382772fc0a33130dfaf621699fdbf", "patch": "@@ -577,6 +577,51 @@ get_scalar_evolution (basic_block instantiated_below, tree scalar)\n   return res;\n }\n \n+\f\n+/* Depth first search algorithm.  */\n+\n+enum t_bool {\n+  t_false,\n+  t_true,\n+  t_dont_know\n+};\n+\n+class scev_dfs\n+{\n+public:\n+  scev_dfs (class loop *loop_, gphi *phi_, tree init_cond_)\n+      : loop (loop_), loop_phi_node (phi_), init_cond (init_cond_) {}\n+  t_bool get_ev (tree *, tree);\n+\n+private:\n+  t_bool follow_ssa_edge_expr (gimple *, tree, tree *, int);\n+  t_bool follow_ssa_edge_binary (gimple *at_stmt,\n+\t\t\t\t tree type, tree rhs0, enum tree_code code,\n+\t\t\t\t tree rhs1, tree *evolution_of_loop, int limit);\n+  t_bool follow_ssa_edge_in_condition_phi_branch (int i,\n+\t\t\t\t\t\t  gphi *condition_phi,\n+\t\t\t\t\t\t  tree *evolution_of_branch,\n+\t\t\t\t\t\t  tree init_cond, int limit);\n+  t_bool follow_ssa_edge_in_condition_phi (gphi *condition_phi,\n+\t\t\t\t\t   tree *evolution_of_loop, int limit);\n+  t_bool follow_ssa_edge_inner_loop_phi (gphi *loop_phi_node,\n+\t\t\t\t\t tree *evolution_of_loop, int limit);\n+  tree add_to_evolution (tree chrec_before, enum tree_code code,\n+\t\t\t tree to_add, gimple *at_stmt);\n+  tree add_to_evolution_1 (tree chrec_before, tree to_add, gimple *at_stmt);\n+\n+  class loop *loop;\n+  gphi *loop_phi_node;\n+  tree init_cond;\n+};\n+\n+t_bool\n+scev_dfs::get_ev (tree *ev_fn, tree arg)\n+{\n+  *ev_fn = chrec_dont_know;\n+  return follow_ssa_edge_expr (loop_phi_node, arg, ev_fn, 0);\n+}\n+\n /* Helper function for add_to_evolution.  Returns the evolution\n    function for an assignment of the form \"a = b + c\", where \"a\" and\n    \"b\" are on the strongly connected component.  CHREC_BEFORE is the\n@@ -587,12 +632,12 @@ get_scalar_evolution (basic_block instantiated_below, tree scalar)\n    evolution the expression TO_ADD, otherwise construct an evolution\n    part for this loop.  */\n \n-static tree\n-add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n-\t\t    gimple *at_stmt)\n+tree\n+scev_dfs::add_to_evolution_1 (tree chrec_before, tree to_add, gimple *at_stmt)\n {\n   tree type, left, right;\n-  class loop *loop = get_loop (cfun, loop_nb), *chloop;\n+  unsigned loop_nb = loop->num;\n+  class loop *chloop;\n \n   switch (TREE_CODE (chrec_before))\n     {\n@@ -631,7 +676,7 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \t  gcc_assert (flow_loop_nested_p (loop, chloop));\n \n \t  /* Search the evolution in LOOP_NB.  */\n-\t  left = add_to_evolution_1 (loop_nb, CHREC_LEFT (chrec_before),\n+\t  left = add_to_evolution_1 (CHREC_LEFT (chrec_before),\n \t\t\t\t     to_add, at_stmt);\n \t  right = CHREC_RIGHT (chrec_before);\n \t  right = chrec_convert_rhs (chrec_type (left), right, at_stmt);\n@@ -646,6 +691,17 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \n       left = chrec_before;\n       right = chrec_convert_rhs (chrec_type (left), to_add, at_stmt);\n+      /* When we add the first evolution we need to replace the symbolic\n+\t evolution we've put in when the DFS reached the loop PHI node\n+\t with the initial value.  There's only a limited cases of\n+\t extra operations ontop of that symbol allowed, namely\n+\t sign-conversions we can look through.  For other cases we leave\n+\t the symbolic initial condition which causes build_polynomial_chrec\n+\t to return chrec_dont_know.  See PR42512, PR66375 and PR107176 for\n+\t cases we mishandled before.  */\n+      STRIP_NOPS (chrec_before);\n+      if (chrec_before == gimple_phi_result (loop_phi_node))\n+\tleft = fold_convert (TREE_TYPE (left), init_cond);\n       return build_polynomial_chrec (loop_nb, left, right);\n     }\n }\n@@ -784,9 +840,9 @@ add_to_evolution_1 (unsigned loop_nb, tree chrec_before, tree to_add,\n \n */\n \n-static tree\n-add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n-\t\t  tree to_add, gimple *at_stmt)\n+tree\n+scev_dfs::add_to_evolution (tree chrec_before, enum tree_code code,\n+\t\t\t    tree to_add, gimple *at_stmt)\n {\n   tree type = chrec_type (to_add);\n   tree res = NULL_TREE;\n@@ -803,7 +859,7 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n       fprintf (dump_file, \"(add_to_evolution \\n\");\n-      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop_nb);\n+      fprintf (dump_file, \"  (loop_nb = %d)\\n\", loop->num);\n       fprintf (dump_file, \"  (chrec_before = \");\n       print_generic_expr (dump_file, chrec_before);\n       fprintf (dump_file, \")\\n  (to_add = \");\n@@ -816,7 +872,7 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n \t\t\t\t  ? build_real (type, dconstm1)\n \t\t\t\t  : build_int_cst_type (type, -1));\n \n-  res = add_to_evolution_1 (loop_nb, chrec_before, to_add, at_stmt);\n+  res = add_to_evolution_1 (chrec_before, to_add, at_stmt);\n \n   if (dump_file && (dump_flags & TDF_SCEV))\n     {\n@@ -828,64 +884,14 @@ add_to_evolution (unsigned loop_nb, tree chrec_before, enum tree_code code,\n   return res;\n }\n \n-\f\n-\n-/* This section selects the loops that will be good candidates for the\n-   scalar evolution analysis.  For the moment, greedily select all the\n-   loop nests we could analyze.  */\n-\n-/* For a loop with a single exit edge, return the COND_EXPR that\n-   guards the exit edge.  If the expression is too difficult to\n-   analyze, then give up.  */\n-\n-gcond *\n-get_loop_exit_condition (const class loop *loop)\n-{\n-  gcond *res = NULL;\n-  edge exit_edge = single_exit (loop);\n-\n-  if (dump_file && (dump_flags & TDF_SCEV))\n-    fprintf (dump_file, \"(get_loop_exit_condition \\n  \");\n-\n-  if (exit_edge)\n-    {\n-      gimple *stmt;\n-\n-      stmt = last_stmt (exit_edge->src);\n-      if (gcond *cond_stmt = safe_dyn_cast <gcond *> (stmt))\n-\tres = cond_stmt;\n-    }\n-\n-  if (dump_file && (dump_flags & TDF_SCEV))\n-    {\n-      print_gimple_stmt (dump_file, res, 0);\n-      fprintf (dump_file, \")\\n\");\n-    }\n-\n-  return res;\n-}\n-\n-\f\n-/* Depth first search algorithm.  */\n-\n-enum t_bool {\n-  t_false,\n-  t_true,\n-  t_dont_know\n-};\n-\n-\n-static t_bool follow_ssa_edge_expr (class loop *loop, gimple *, tree, gphi *,\n-\t\t\t\t    tree *, int);\n \n /* Follow the ssa edge into the binary expression RHS0 CODE RHS1.\n    Return true if the strongly connected component has been found.  */\n \n-static t_bool\n-follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n-\t\t\ttree type, tree rhs0, enum tree_code code, tree rhs1,\n-\t\t\tgphi *halting_phi, tree *evolution_of_loop,\n-\t\t\tint limit)\n+t_bool\n+scev_dfs::follow_ssa_edge_binary (gimple *at_stmt, tree type, tree rhs0,\n+\t\t\t\t  enum tree_code code, tree rhs1,\n+\t\t\t\t  tree *evolution_of_loop, int limit)\n {\n   t_bool res = t_false;\n   tree evol;\n@@ -907,23 +913,18 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t      limit++;\n \n \t      evol = *evolution_of_loop;\n-\t      evol = add_to_evolution\n-\t\t  (loop->num,\n-\t\t   chrec_convert (type, evol, at_stmt),\n-\t\t   code, rhs1, at_stmt);\n-\t      res = follow_ssa_edge_expr\n-\t\t(loop, at_stmt, rhs0, halting_phi, &evol, limit);\n+\t      res = follow_ssa_edge_expr (at_stmt, rhs0, &evol, limit);\n \t      if (res == t_true)\n-\t\t*evolution_of_loop = evol;\n+\t\t*evolution_of_loop = add_to_evolution\n+\t\t    (chrec_convert (type, evol, at_stmt), code, rhs1, at_stmt);\n \t      else if (res == t_false)\n \t\t{\n-\t\t  *evolution_of_loop = add_to_evolution\n-\t\t      (loop->num,\n-\t\t       chrec_convert (type, *evolution_of_loop, at_stmt),\n-\t\t       code, rhs0, at_stmt);\n \t\t  res = follow_ssa_edge_expr\n-\t\t    (loop, at_stmt, rhs1, halting_phi,\n-\t\t     evolution_of_loop, limit);\n+\t\t    (at_stmt, rhs1, evolution_of_loop, limit);\n+\t\t  if (res == t_true)\n+\t\t    *evolution_of_loop = add_to_evolution\n+\t\t\t(chrec_convert (type, *evolution_of_loop, at_stmt),\n+\t\t\t code, rhs0, at_stmt);\n \t\t}\n \t    }\n \n@@ -935,13 +936,11 @@ follow_ssa_edge_binary (class loop *loop, gimple *at_stmt,\n \t{\n \t  /* Match an assignment under the form:\n \t     \"a = ... + c\".  */\n-\t  *evolution_of_loop = add_to_evolution\n-\t      (loop->num, chrec_convert (type, *evolution_of_loop,\n-\t\t\t\t\t at_stmt),\n-\t       code, rhs0, at_stmt);\n-\t  res = follow_ssa_edge_expr\n-\t    (loop, at_stmt, rhs1, halting_phi,\n-\t     evolution_of_loop, limit);\n+\t  res = follow_ssa_edge_expr (at_stmt, rhs1, evolution_of_loop, limit);\n+\t  if (res == t_true)\n+\t    *evolution_of_loop = add_to_evolution\n+\t\t(chrec_convert (type, *evolution_of_loop, at_stmt),\n+\t\t code, rhs0, at_stmt);\n \t}\n \n       else\n@@ -989,13 +988,11 @@ backedge_phi_arg_p (gphi *phi, int i)\n    true if the strongly connected component has been found following\n    this path.  */\n \n-static inline t_bool\n-follow_ssa_edge_in_condition_phi_branch (int i,\n-\t\t\t\t\t class loop *loop,\n-\t\t\t\t\t gphi *condition_phi,\n-\t\t\t\t\t gphi *halting_phi,\n-\t\t\t\t\t tree *evolution_of_branch,\n-\t\t\t\t\t tree init_cond, int limit)\n+t_bool\n+scev_dfs::follow_ssa_edge_in_condition_phi_branch (int i,\n+\t\t\t\t\t\t   gphi *condition_phi,\n+\t\t\t\t\t\t   tree *evolution_of_branch,\n+\t\t\t\t\t\t   tree init_cond, int limit)\n {\n   tree branch = PHI_ARG_DEF (condition_phi, i);\n   *evolution_of_branch = chrec_dont_know;\n@@ -1008,7 +1005,7 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n   if (TREE_CODE (branch) == SSA_NAME)\n     {\n       *evolution_of_branch = init_cond;\n-      return follow_ssa_edge_expr (loop, condition_phi, branch, halting_phi,\n+      return follow_ssa_edge_expr (condition_phi, branch,\n \t\t\t\t   evolution_of_branch, limit);\n     }\n \n@@ -1025,17 +1022,14 @@ follow_ssa_edge_in_condition_phi_branch (int i,\n /* This function merges the branches of a condition-phi-node in a\n    loop.  */\n \n-static t_bool\n-follow_ssa_edge_in_condition_phi (class loop *loop,\n-\t\t\t\t  gphi *condition_phi,\n-\t\t\t\t  gphi *halting_phi,\n-\t\t\t\t  tree *evolution_of_loop, int limit)\n+t_bool\n+scev_dfs::follow_ssa_edge_in_condition_phi (gphi *condition_phi,\n+\t\t\t\t\t    tree *evolution_of_loop, int limit)\n {\n   int i, n;\n   tree init = *evolution_of_loop;\n   tree evolution_of_branch;\n-  t_bool res = follow_ssa_edge_in_condition_phi_branch (0, loop, condition_phi,\n-\t\t\t\t\t\t\thalting_phi,\n+  t_bool res = follow_ssa_edge_in_condition_phi_branch (0, condition_phi,\n \t\t\t\t\t\t\t&evolution_of_branch,\n \t\t\t\t\t\t\tinit, limit);\n   if (res == t_false || res == t_dont_know)\n@@ -1053,8 +1047,7 @@ follow_ssa_edge_in_condition_phi (class loop *loop,\n \n       /* Increase the limit by the PHI argument number to avoid exponential\n \t time and memory complexity.  */\n-      res = follow_ssa_edge_in_condition_phi_branch (i, loop, condition_phi,\n-\t\t\t\t\t\t     halting_phi,\n+      res = follow_ssa_edge_in_condition_phi_branch (i, condition_phi,\n \t\t\t\t\t\t     &evolution_of_branch,\n \t\t\t\t\t\t     init, limit + i);\n       if (res == t_false || res == t_dont_know)\n@@ -1072,11 +1065,9 @@ follow_ssa_edge_in_condition_phi (class loop *loop,\n    it follows the edges in the parent loop.  The inner loop is\n    considered as a single statement.  */\n \n-static t_bool\n-follow_ssa_edge_inner_loop_phi (class loop *outer_loop,\n-\t\t\t\tgphi *loop_phi_node,\n-\t\t\t\tgphi *halting_phi,\n-\t\t\t\ttree *evolution_of_loop, int limit)\n+t_bool\n+scev_dfs::follow_ssa_edge_inner_loop_phi (gphi *loop_phi_node,\n+\t\t\t\t\t  tree *evolution_of_loop, int limit)\n {\n   class loop *loop = loop_containing_stmt (loop_phi_node);\n   tree ev = analyze_scalar_evolution (loop, PHI_RESULT (loop_phi_node));\n@@ -1096,9 +1087,8 @@ follow_ssa_edge_inner_loop_phi (class loop *outer_loop,\n \t  /* Follow the edges that exit the inner loop.  */\n \t  bb = gimple_phi_arg_edge (loop_phi_node, i)->src;\n \t  if (!flow_bb_inside_loop_p (loop, bb))\n-\t    res = follow_ssa_edge_expr (outer_loop, loop_phi_node,\n-\t\t\t\t\targ, halting_phi,\n-\t\t\t\t\tevolution_of_loop, limit);\n+\t    res = follow_ssa_edge_expr (loop_phi_node,\n+\t\t\t\t\targ, evolution_of_loop, limit);\n \t  if (res == t_true)\n \t    break;\n \t}\n@@ -1112,18 +1102,17 @@ follow_ssa_edge_inner_loop_phi (class loop *outer_loop,\n \n   /* Otherwise, compute the overall effect of the inner loop.  */\n   ev = compute_overall_effect_of_inner_loop (loop, ev);\n-  return follow_ssa_edge_expr (outer_loop, loop_phi_node, ev, halting_phi,\n-\t\t\t       evolution_of_loop, limit);\n+  return follow_ssa_edge_expr (loop_phi_node, ev, evolution_of_loop, limit);\n }\n \n /* Follow the ssa edge into the expression EXPR.\n    Return true if the strongly connected component has been found.  */\n \n-static t_bool\n-follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n-\t\t      gphi *halting_phi, tree *evolution_of_loop,\n-\t\t      int limit)\n+t_bool\n+scev_dfs::follow_ssa_edge_expr (gimple *at_stmt, tree expr,\n+\t\t\t\ttree *evolution_of_loop, int limit)\n {\n+  gphi *halting_phi = loop_phi_node;\n   enum tree_code code;\n   tree type, rhs0, rhs1 = NULL_TREE;\n \n@@ -1161,14 +1150,17 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n \t       record their evolutions.  Finally, merge the collected\n \t       information and set the approximation to the main\n \t       variable.  */\n-\t    return follow_ssa_edge_in_condition_phi\n-\t\t(loop, phi, halting_phi, evolution_of_loop, limit);\n+\t    return follow_ssa_edge_in_condition_phi (phi, evolution_of_loop,\n+\t\t\t\t\t\t     limit);\n \n \t  /* When the analyzed phi is the halting_phi, the\n \t     depth-first search is over: we have found a path from\n \t     the halting_phi to itself in the loop.  */\n \t  if (phi == halting_phi)\n-\t    return t_true;\n+\t    {\n+\t      *evolution_of_loop = expr;\n+\t      return t_true;\n+\t    }\n \n \t  /* Otherwise, the evolution of the HALTING_PHI depends\n \t     on the evolution of another loop-phi-node, i.e. the\n@@ -1179,9 +1171,8 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n \n \t  /* Inner loop.  */\n \t  if (flow_loop_nested_p (loop, def_loop))\n-\t    return follow_ssa_edge_inner_loop_phi\n-\t\t(loop, phi, halting_phi, evolution_of_loop,\n-\t\t limit + 1);\n+\t    return follow_ssa_edge_inner_loop_phi (phi, evolution_of_loop,\n+\t\t\t\t\t\t   limit + 1);\n \n \t  /* Outer loop.  */\n \t  return t_false;\n@@ -1239,7 +1230,7 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n     CASE_CONVERT:\n       {\n \t/* This assignment is under the form \"a_1 = (cast) rhs.  */\n-\tt_bool res = follow_ssa_edge_expr (loop, at_stmt, rhs0, halting_phi,\n+\tt_bool res = follow_ssa_edge_expr (at_stmt, rhs0,\n \t\t\t\t\t   evolution_of_loop, limit);\n \t*evolution_of_loop = chrec_convert (type, *evolution_of_loop, at_stmt);\n \treturn res;\n@@ -1268,18 +1259,18 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n \t  && (TREE_CODE (rhs1) != SSA_NAME || code == MINUS_EXPR))\n \t{\n \t  /* Match an assignment under the form:\n-\t     \"a = b +- ...\".\n-\t     Use tail-recursion for the simple case.  */\n-\t  *evolution_of_loop = add_to_evolution\n-\t      (loop->num, chrec_convert (type, *evolution_of_loop,\n-\t\t\t\t\t at_stmt),\n-\t       code, rhs1, at_stmt);\n-\t  expr = rhs0;\n-\t  goto tail_recurse;\n+\t     \"a = b +- ...\".  */\n+\t  t_bool res = follow_ssa_edge_expr (at_stmt, rhs0,\n+\t\t\t\t\t     evolution_of_loop, limit);\n+\t  if (res == t_true)\n+\t    *evolution_of_loop = add_to_evolution\n+\t\t(chrec_convert (type, *evolution_of_loop, at_stmt),\n+\t\t code, rhs1, at_stmt);\n+\t  return res;\n \t}\n       /* Else search for the SCC in both rhs0 and rhs1.  */\n-      return follow_ssa_edge_binary (loop, at_stmt, type, rhs0, code, rhs1,\n-\t\t\t\t     halting_phi, evolution_of_loop, limit);\n+      return follow_ssa_edge_binary (at_stmt, type, rhs0, code, rhs1,\n+\t\t\t\t     evolution_of_loop, limit);\n \n     case ASSERT_EXPR:\n       /* This assignment is of the form: \"a_1 = ASSERT_EXPR <a_2, ...>\"\n@@ -1291,6 +1282,42 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n       return t_false;\n     }\n }\n+\f\n+\n+/* This section selects the loops that will be good candidates for the\n+   scalar evolution analysis.  For the moment, greedily select all the\n+   loop nests we could analyze.  */\n+\n+/* For a loop with a single exit edge, return the COND_EXPR that\n+   guards the exit edge.  If the expression is too difficult to\n+   analyze, then give up.  */\n+\n+gcond *\n+get_loop_exit_condition (const class loop *loop)\n+{\n+  gcond *res = NULL;\n+  edge exit_edge = single_exit (loop);\n+\n+  if (dump_file && (dump_flags & TDF_SCEV))\n+    fprintf (dump_file, \"(get_loop_exit_condition \\n  \");\n+\n+  if (exit_edge)\n+    {\n+      gimple *stmt;\n+\n+      stmt = last_stmt (exit_edge->src);\n+      if (gcond *cond_stmt = safe_dyn_cast <gcond *> (stmt))\n+\tres = cond_stmt;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_SCEV))\n+    {\n+      print_gimple_stmt (dump_file, res, 0);\n+      fprintf (dump_file, \")\\n\");\n+    }\n+\n+  return res;\n+}\n \n \f\n /* Simplify PEELED_CHREC represented by (init_cond, arg) in LOOP.\n@@ -1381,7 +1408,7 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n   for (i = 0; i < n; i++)\n     {\n       tree arg = PHI_ARG_DEF (loop_phi_node, i);\n-      tree ev_fn;\n+      tree ev_fn = chrec_dont_know;\n       t_bool res;\n \n       /* Select the edges that enter the loop body.  */\n@@ -1394,9 +1421,8 @@ analyze_evolution_in_loop (gphi *loop_phi_node,\n \t  bool val = false;\n \n \t  /* Pass in the initial condition to the follow edge function.  */\n-\t  ev_fn = init_cond;\n-\t  res = follow_ssa_edge_expr (loop, loop_phi_node, arg,\n-\t\t\t\t      loop_phi_node, &ev_fn, 0);\n+\t  scev_dfs dfs (loop, loop_phi_node, init_cond);\n+\t  res = dfs.get_ev (&ev_fn, arg);\n \n \t  /* If ev_fn has no evolution in the inner loop, and the\n \t     init_cond is not equal to ev_fn, then we have an\n@@ -1551,34 +1577,14 @@ analyze_initial_condition (gphi *loop_phi_node)\n static tree\n interpret_loop_phi (class loop *loop, gphi *loop_phi_node)\n {\n-  tree res;\n   class loop *phi_loop = loop_containing_stmt (loop_phi_node);\n   tree init_cond;\n \n   gcc_assert (phi_loop == loop);\n \n   /* Otherwise really interpret the loop phi.  */\n   init_cond = analyze_initial_condition (loop_phi_node);\n-  res = analyze_evolution_in_loop (loop_phi_node, init_cond);\n-\n-  /* Verify we maintained the correct initial condition throughout\n-     possible conversions in the SSA chain.  */\n-  if (res != chrec_dont_know)\n-    {\n-      tree new_init = res;\n-      if (CONVERT_EXPR_P (res)\n-\t  && TREE_CODE (TREE_OPERAND (res, 0)) == POLYNOMIAL_CHREC)\n-\tnew_init = fold_convert (TREE_TYPE (res),\n-\t\t\t\t CHREC_LEFT (TREE_OPERAND (res, 0)));\n-      else if (TREE_CODE (res) == POLYNOMIAL_CHREC)\n-\tnew_init = CHREC_LEFT (res);\n-      STRIP_USELESS_TYPE_CONVERSION (new_init);\n-      if (TREE_CODE (new_init) == POLYNOMIAL_CHREC\n-\t  || !operand_equal_p (init_cond, new_init, 0))\n-\treturn chrec_dont_know;\n-    }\n-\n-  return res;\n+  return analyze_evolution_in_loop (loop_phi_node, init_cond);\n }\n \n /* This function merges the branches of a condition-phi-node,"}]}