{"sha": "728936bb9200245a354a6a3d259c86795de5b6a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzI4OTM2YmI5MjAwMjQ1YTM1NGE2YTNkMjU5Yzg2Nzk1ZGU1YjZhMg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-04-17T14:16:36Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-04-17T14:16:36Z"}, "message": "uintp.h (UI_Lt): Declare.\n\n\t* uintp.h (UI_Lt): Declare.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Do the size\n\tcomputation in sizetype.\n\t<E_Array_Subtype>: Use unified handling for all index types.  Do not\n\tgenerate MAX_EXPR-based expressions, only COND_EXPR-based ones.  Add\n\tbypass for PATs.\n\t(annotate_value): Change test for negative values.\n\t(validate_size): Apply test for negative values on GNAT nodes.\n\t(set_rm_size): Likewise.\n\t* gcc-interface/misc.c (gnat_init): Set unsigned types for sizetypes.\n\t* gcc-interface/utils.c (rest_of_record_type_compilation): Change test\n\tfor negative values.\n\t(max_size) <MINUS_EXPR>: Do not reassociate a COND_EXPR on the LHS.\n\t(builtin_type_for_size): Adjust definition of signed_size_type_node.\n\t* gcc-interface/utils2.c (compare_arrays): Optimize comparison of\n\tlengths against zero.\n\nFrom-SVN: r158466", "tree": {"sha": "7bfc84cbad5fe9e5614c7e2adf4638dcbff4f0ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bfc84cbad5fe9e5614c7e2adf4638dcbff4f0ee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/728936bb9200245a354a6a3d259c86795de5b6a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728936bb9200245a354a6a3d259c86795de5b6a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/728936bb9200245a354a6a3d259c86795de5b6a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/728936bb9200245a354a6a3d259c86795de5b6a2/comments", "author": null, "committer": null, "parents": [{"sha": "1b78f5757ac38afb7c5acc14e95f12fef41adc84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b78f5757ac38afb7c5acc14e95f12fef41adc84", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b78f5757ac38afb7c5acc14e95f12fef41adc84"}], "stats": {"total": 262, "additions": 153, "deletions": 109}, "files": [{"sha": "b68d53570c43c57b97841f600aa792277323b6fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -1,3 +1,22 @@\n+2010-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* uintp.h (UI_Lt): Declare.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Array_Type>: Do the size\n+\tcomputation in sizetype.\n+\t<E_Array_Subtype>: Use unified handling for all index types.  Do not\n+\tgenerate MAX_EXPR-based expressions, only COND_EXPR-based ones.  Add\n+\tbypass for PATs.\n+\t(annotate_value): Change test for negative values.\n+\t(validate_size): Apply test for negative values on GNAT nodes.\n+\t(set_rm_size): Likewise.\n+\t* gcc-interface/misc.c (gnat_init): Set unsigned types for sizetypes.\n+\t* gcc-interface/utils.c (rest_of_record_type_compilation): Change test\n+\tfor negative values.\n+\t(max_size) <MINUS_EXPR>: Do not reassociate a COND_EXPR on the LHS.\n+\t(builtin_type_for_size): Adjust definition of signed_size_type_node.\n+\t* gcc-interface/utils2.c (compare_arrays): Optimize comparison of\n+\tlengths against zero.\n+\n 2010-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* back-end.adb (Call_Back_End): Pass Standard_Character to gigi."}, {"sha": "b8e8a5b10bf0b021df76d1110006cb6cd2ee07cf", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 63, "deletions": 76, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -2112,15 +2112,6 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t       gnat_base_index = Next_Index (gnat_base_index))\n \t    {\n \t      tree gnu_index_type = get_unpadded_type (Etype (gnat_index));\n-\t      const int prec_comp\n-\t\t= compare_tree_int (rm_size (gnu_index_type),\n-\t\t\t\t    TYPE_PRECISION (sizetype));\n-\t      const bool subrange_p = (prec_comp < 0\n-\t\t\t\t       && (TYPE_UNSIGNED (gnu_index_type)\n-\t\t\t\t\t   || !TYPE_UNSIGNED (sizetype)))\n- \t\t\t\t      || (prec_comp == 0\n- \t\t\t\t\t  && TYPE_UNSIGNED (gnu_index_type)\n- \t\t\t\t\t     == TYPE_UNSIGNED (sizetype));\n \t      tree gnu_orig_min = TYPE_MIN_VALUE (gnu_index_type);\n \t      tree gnu_orig_max = TYPE_MAX_VALUE (gnu_index_type);\n \t      tree gnu_min = convert (sizetype, gnu_orig_min);\n@@ -2129,7 +2120,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t= get_unpadded_type (Etype (gnat_base_index));\n \t      tree gnu_base_orig_min = TYPE_MIN_VALUE (gnu_base_index_type);\n \t      tree gnu_base_orig_max = TYPE_MAX_VALUE (gnu_base_index_type);\n-\t      tree gnu_high, gnu_low;\n+\t      tree gnu_high;\n \n \t      /* See if the base array type is already flat.  If it is, we\n \t\t are probably compiling an ACATS test but it will cause the\n@@ -2145,8 +2136,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t      /* Similarly, if one of the values overflows in sizetype and the\n \t\t range is null, use 1..0 for the sizetype bounds.  */\n-\t      else if (!subrange_p\n-\t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n+\t      else if (TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && (TREE_OVERFLOW (gnu_min) || TREE_OVERFLOW (gnu_max))\n \t\t       && tree_int_cst_lt (gnu_orig_max, gnu_orig_min))\n@@ -2159,8 +2149,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t      /* If the minimum and maximum values both overflow in sizetype,\n \t\t but the difference in the original type does not overflow in\n \t\t sizetype, ignore the overflow indication.  */\n-\t      else if (!subrange_p\n-\t\t       && TREE_CODE (gnu_min) == INTEGER_CST\n+\t      else if (TREE_CODE (gnu_min) == INTEGER_CST\n \t\t       && TREE_CODE (gnu_max) == INTEGER_CST\n \t\t       && TREE_OVERFLOW (gnu_min) && TREE_OVERFLOW (gnu_max)\n \t\t       && !TREE_OVERFLOW\n@@ -2179,57 +2168,47 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t deal with the \"superflat\" case.  There are three ways to do\n \t\t this.  If we can prove that the array can never be superflat,\n \t\t we can just use the high bound of the index type.  */\n-\t      else if (Nkind (gnat_index) == N_Range\n-\t\t       && cannot_be_superflat_p (gnat_index))\n+\t      else if ((Nkind (gnat_index) == N_Range\n+\t\t        && cannot_be_superflat_p (gnat_index))\n+\t\t       /* Packed Array Types are never superflat.  */\n+\t\t       || Is_Packed_Array_Type (gnat_entity))\n \t\tgnu_high = gnu_max;\n \n-\t      /* Otherwise, if we can prove that the low bound minus one and\n-\t\t the high bound cannot overflow, we can just use the expression\n-\t\t MAX (hb, lb - 1).  Similarly, if we can prove that the high\n-\t\t bound plus one and the low bound cannot overflow, we can use\n-\t\t the high bound as-is and MIN (hb + 1, lb) for the low bound.\n-\t\t Otherwise, we have to fall back to the most general expression\n-\t\t (hb >= lb) ? hb : lb - 1.  Note that the comparison must be\n-\t\t done in the original index type, to avoid any overflow during\n-\t\t the conversion.  */\n-\t      else\n+\t      /* Otherwise, if the high bound is constant but the low bound is\n+\t\t not, we use the expression (hb >= lb) ? lb : hb + 1 for the\n+\t\t lower bound.  Note that the comparison must be done in the\n+\t\t original type to avoid any overflow during the conversion.  */\n+\t      else if (TREE_CODE (gnu_max) == INTEGER_CST\n+\t\t       && TREE_CODE (gnu_min) != INTEGER_CST)\n \t\t{\n-\t\t  gnu_high = size_binop (MINUS_EXPR, gnu_min, size_one_node);\n-\t\t  gnu_low = size_binop (PLUS_EXPR, gnu_max, size_one_node);\n-\n-\t\t  /* If gnu_high is a constant that has overflowed, the low\n-\t\t     bound is the smallest integer so cannot be the maximum.\n-\t\t     If gnu_low is a constant that has overflowed, the high\n-\t\t     bound is the highest integer so cannot be the minimum.  */\n-\t\t  if ((TREE_CODE (gnu_high) == INTEGER_CST\n-\t\t       && TREE_OVERFLOW (gnu_high))\n-\t\t      || (TREE_CODE (gnu_low) == INTEGER_CST\n-\t\t\t   && TREE_OVERFLOW (gnu_low)))\n-\t\t    gnu_high = gnu_max;\n-\n-\t\t  /* If the index type is a subrange and gnu_high a constant\n-\t\t     that hasn't overflowed, we can use the maximum.  */\n-\t\t  else if (subrange_p && TREE_CODE (gnu_high) == INTEGER_CST)\n-\t\t    gnu_high = size_binop (MAX_EXPR, gnu_max, gnu_high);\n-\n-\t\t  /* If the index type is a subrange and gnu_low a constant\n-\t\t     that hasn't overflowed, we can use the minimum.  */\n-\t\t  else if (subrange_p && TREE_CODE (gnu_low) == INTEGER_CST)\n-\t\t    {\n-\t\t      gnu_high = gnu_max;\n-\t\t      gnu_min = size_binop (MIN_EXPR, gnu_min, gnu_low);\n-\t\t    }\n-\n-\t\t  else\n-\t\t    gnu_high\n-\t\t      = build_cond_expr (sizetype,\n-\t\t\t\t\t build_binary_op (GE_EXPR,\n-\t\t\t\t\t\t\t  boolean_type_node,\n-\t\t\t\t\t\t\t  gnu_orig_max,\n-\t\t\t\t\t\t\t  gnu_orig_min),\n-\t\t\t\t\t gnu_max, gnu_high);\n+\t\t  gnu_high = gnu_max;\n+\t\t  gnu_min\n+\t\t    = build_cond_expr (sizetype,\n+\t\t\t\t       build_binary_op (GE_EXPR,\n+\t\t\t\t\t\t\tboolean_type_node,\n+\t\t\t\t\t\t\tgnu_orig_max,\n+\t\t\t\t\t\t\tgnu_orig_min),\n+\t\t\t\t       gnu_min,\n+\t\t\t\t       size_binop (PLUS_EXPR, gnu_max,\n+\t\t\t\t\t\t   size_one_node));\n \t\t}\n \n+\t      /* Finally we use (hb >= lb) ? hb : lb - 1 for the upper bound\n+\t\t in all the other cases.  Note that, here as well as above,\n+\t\t the condition used in the comparison must be equivalent to\n+\t\t the condition (length != 0).  This is relied upon in order\n+\t\t to optimize array comparisons in compare_arrays.  */\n+\t      else\n+\t\tgnu_high\n+\t\t  = build_cond_expr (sizetype,\n+\t\t\t\t     build_binary_op (GE_EXPR,\n+\t\t\t\t\t\t      boolean_type_node,\n+\t\t\t\t\t\t      gnu_orig_max,\n+\t\t\t\t\t\t      gnu_orig_min),\n+\t\t\t\t     gnu_max,\n+\t\t\t\t     size_binop (MINUS_EXPR, gnu_min,\n+\t\t\t\t\t\t size_one_node));\n+\n \t      gnu_index_types[index]\n \t\t= create_index_type (gnu_min, gnu_high, gnu_index_type,\n \t\t\t\t     gnat_entity);\n@@ -2299,7 +2278,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t      && TREE_CODE (TREE_TYPE (gnu_index_type))\n \t\t\t != INTEGER_TYPE)\n \t\t  || TYPE_BIASED_REPRESENTATION_P (gnu_index_type)\n-\t\t  || prec_comp > 0)\n+\t\t  || compare_tree_int (rm_size (gnu_index_type),\n+\t\t\t\t       TYPE_PRECISION (sizetype)) > 0)\n \t\tneed_index_type_struct = true;\n \t    }\n \n@@ -7128,9 +7108,11 @@ annotate_value (tree gnu_size)\n \t this is in bitsizetype.  */\n       gnu_size = convert (bitsizetype, gnu_size);\n \n-      /* For a negative value, use NEGATE_EXPR of the opposite.  Such values\n-\t appear in expressions containing aligning patterns.  */\n-      if (tree_int_cst_sgn (gnu_size) < 0)\n+      /* For a negative value, build NEGATE_EXPR of the opposite.  Such values\n+\t appear in expressions containing aligning patterns.  Note that, since\n+\t sizetype is sign-extended but nonetheless unsigned, we don't directly\n+\t use tree_int_cst_sgn.  */\n+      if (TREE_INT_CST_HIGH (gnu_size) < 0)\n \t{\n \t  tree op_size = fold_build1 (NEGATE_EXPR, bitsizetype, gnu_size);\n \t  return annotate_value (build1 (NEGATE_EXPR, bitsizetype, op_size));\n@@ -7498,6 +7480,10 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n   if (uint_size == No_Uint)\n     return NULL_TREE;\n \n+  /* Ignore a negative size since that corresponds to our back-annotation.  */\n+  if (UI_Lt (uint_size, Uint_0))\n+    return NULL_TREE;\n+\n   /* Find the node to use for errors.  */\n   if ((Ekind (gnat_object) == E_Component\n        || Ekind (gnat_object) == E_Discriminant)\n@@ -7522,9 +7508,8 @@ validate_size (Uint uint_size, tree gnu_type, Entity_Id gnat_object,\n       return NULL_TREE;\n     }\n \n-  /* Ignore a negative size since that corresponds to our back-annotation.\n-     Also ignore a zero size if it is not permitted.  */\n-  if (tree_int_cst_sgn (size) < 0 || (integer_zerop (size) && !zero_ok))\n+  /* Ignore a zero size if it is not permitted.  */\n+  if (!zero_ok && integer_zerop (size))\n     return NULL_TREE;\n \n   /* The size of objects is always a multiple of a byte.  */\n@@ -7611,6 +7596,10 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n   if (uint_size == No_Uint)\n     return;\n \n+  /* Ignore a negative size since that corresponds to our back-annotation.  */\n+  if (UI_Lt (uint_size, Uint_0))\n+    return;\n+\n   /* Only issue an error if a Value_Size clause was explicitly given.\n      Otherwise, we'd be duplicating an error on the Size clause.  */\n   gnat_attr_node\n@@ -7627,15 +7616,13 @@ set_rm_size (Uint uint_size, tree gnu_type, Entity_Id gnat_entity)\n       return;\n     }\n \n-  /* Ignore a negative size since that corresponds to our back-annotation.\n-     Also ignore a zero size unless a Value_Size clause exists, or a size\n-     clause exists, or this is an integer type, in which case the front-end\n-     will have always set it.  */\n-  if (tree_int_cst_sgn (size) < 0\n-      || (integer_zerop (size)\n-\t  && No (gnat_attr_node)\n-\t  && !Has_Size_Clause (gnat_entity)\n-\t  && !Is_Discrete_Or_Fixed_Point_Type (gnat_entity)))\n+  /* Ignore a zero size unless a Value_Size clause exists, or a size clause\n+     exists, or this is an integer type, in which case the front-end will\n+     have always set it.  */\n+  if (No (gnat_attr_node)\n+      && integer_zerop (size)\n+      && !Has_Size_Clause (gnat_entity)\n+      && !Is_Discrete_Or_Fixed_Point_Type (gnat_entity))\n     return;\n \n   old_size = rm_size (gnu_type);"}, {"sha": "6923105afa24241edea009ad7e627f93a413e6b7", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -391,13 +391,16 @@ gnat_init (void)\n   /* Do little here, most of the standard declarations are set up after the\n      front-end has been run.  Use the same `char' as C, this doesn't really\n      matter since we'll use the explicit `unsigned char' for Character.  */\n-  build_common_tree_nodes (flag_signed_char, true);\n-\n-  /* In Ada, we use a signed type for SIZETYPE.  Use the signed type\n-     corresponding to the width of Pmode.  In most cases when ptr_mode\n-     and Pmode differ, C will use the width of ptr_mode for SIZETYPE.\n-     But we get far better code using the width of Pmode.  */\n-  size_type_node = gnat_type_for_mode (Pmode, 0);\n+  build_common_tree_nodes (flag_signed_char, false);\n+\n+  /* In Ada, we use the unsigned type corresponding to the width of Pmode as\n+     SIZETYPE.  In most cases when ptr_mode and Pmode differ, C will use the\n+     width of ptr_mode for SIZETYPE, but we get better code using the width\n+     of Pmode.  Note that, although we manipulate negative offsets for some\n+     internal constructs and rely on compile time overflow detection in size\n+     computations, using unsigned types for SIZETYPEs is fine since they are\n+     treated specially by the middle-end, in particular sign-extended.  */\n+  size_type_node = gnat_type_for_mode (Pmode, 1);\n   set_sizetype (size_type_node);\n   TYPE_NAME (sizetype) = get_identifier (\"size_type\");\n "}, {"sha": "7b403a7bab810ddfcf78352c8c5cbc6117b25449", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 5, "deletions": 19, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -839,11 +839,13 @@ rest_of_record_type_compilation (tree record_type)\n \t      align = tree_low_cst (TREE_OPERAND (curpos, 1), 1);\n \n \t      /* An offset which is a bitwise AND with a negative power of 2\n-\t\t means an alignment corresponding to this power of 2.  */\n+\t\t means an alignment corresponding to this power of 2.  Note\n+\t\t that, as sizetype is sign-extended but nonetheless unsigned,\n+\t\t we don't directly use tree_int_cst_sgn.  */\n \t      offset = remove_conversions (offset, true);\n \t      if (TREE_CODE (offset) == BIT_AND_EXPR\n \t\t  && host_integerp (TREE_OPERAND (offset, 1), 0)\n-\t\t  && tree_int_cst_sgn (TREE_OPERAND (offset, 1)) < 0)\n+\t\t  && TREE_INT_CST_HIGH (TREE_OPERAND (offset, 1)) < 0)\n \t\t{\n \t\t  unsigned int pow\n \t\t    = - tree_low_cst (TREE_OPERAND (offset, 1), 0);\n@@ -2175,22 +2177,6 @@ max_size (tree exp, bool max_p)\n \t  if (code == COMPOUND_EXPR)\n \t    return max_size (TREE_OPERAND (exp, 1), max_p);\n \n-\t  /* Calculate \"(A ? B : C) - D\" as \"A ? B - D : C - D\" which\n-\t     may provide a tighter bound on max_size.  */\n-\t  if (code == MINUS_EXPR\n-\t      && TREE_CODE (TREE_OPERAND (exp, 0)) == COND_EXPR)\n-\t    {\n-\t      tree lhs = fold_build2 (MINUS_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (TREE_OPERAND (exp, 0), 1),\n-\t\t\t\t      TREE_OPERAND (exp, 1));\n-\t      tree rhs = fold_build2 (MINUS_EXPR, type,\n-\t\t\t\t      TREE_OPERAND (TREE_OPERAND (exp, 0), 2),\n-\t\t\t\t      TREE_OPERAND (exp, 1));\n-\t      return fold_build2 (max_p ? MAX_EXPR : MIN_EXPR, type,\n-\t\t\t\t  max_size (lhs, max_p),\n-\t\t\t\t  max_size (rhs, max_p));\n-\t    }\n-\n \t  {\n \t    tree lhs = max_size (TREE_OPERAND (exp, 0), max_p);\n \t    tree rhs = max_size (TREE_OPERAND (exp, 1),\n@@ -4707,7 +4693,7 @@ builtin_type_for_size (int size, bool unsignedp)\n static void\n install_builtin_elementary_types (void)\n {\n-  signed_size_type_node = size_type_node;\n+  signed_size_type_node = gnat_signed_type (size_type_node);\n   pid_type_node = integer_type_node;\n   void_list_node = build_void_list_node ();\n "}, {"sha": "31c513699afbb455ad697d903cf4aa8798e745be", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -351,14 +351,26 @@ compare_arrays (tree result_type, tree a1, tree a2)\n \t  if (EXPR_P (comparison))\n \t    SET_EXPR_LOCATION (comparison, input_location);\n \n-\t  this_a1_is_null = build_binary_op (EQ_EXPR, result_type, length1,\n-\t\t\t\t\t     size_zero_node);\n-\t  if (EXPR_P (this_a1_is_null))\n+\t  /* If the length expression is of the form (cond ? val : 0), assume\n+\t     that cond is equivalent to (length != 0).  That's guaranteed by\n+\t     construction of the array types in gnat_to_gnu_entity.  */\n+\t  if (TREE_CODE (length1) == COND_EXPR\n+\t      && integer_zerop (TREE_OPERAND (length1, 2)))\n+\t    this_a1_is_null = invert_truthvalue (TREE_OPERAND (length1, 0));\n+\t  else\n+\t    this_a1_is_null = build_binary_op (EQ_EXPR, result_type, length1,\n+\t\t\t\t\t       size_zero_node);\n+          if (EXPR_P (this_a1_is_null))\n \t    SET_EXPR_LOCATION (this_a1_is_null, input_location);\n \n-\t  this_a2_is_null = build_binary_op (EQ_EXPR, result_type, length2,\n-\t\t\t\t\t     size_zero_node);\n-\t  if (EXPR_P (this_a2_is_null))\n+\t  /* Likewise for the second array.  */\n+\t  if (TREE_CODE (length2) == COND_EXPR\n+\t      && integer_zerop (TREE_OPERAND (length2, 2)))\n+\t    this_a2_is_null = invert_truthvalue (TREE_OPERAND (length2, 0));\n+\t  else\n+\t    this_a2_is_null = build_binary_op (EQ_EXPR, result_type, length2,\n+\t\t\t\t\t       size_zero_node);\n+          if (EXPR_P (this_a2_is_null))\n \t    SET_EXPR_LOCATION (this_a2_is_null, input_location);\n \t}\n "}, {"sha": "630fcd18e06d2ff375aaf7732e31eb6f66763d2a", "filename": "gcc/ada/uintp.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fuintp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Fada%2Fuintp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.h?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -75,6 +75,10 @@ typedef struct {const int *Array; Vector_Template *Bounds; }\n #define Vector_To_Uint uintp__vector_to_uint\n extern Uint Vector_To_Uint\t\t(Int_Vector, Boolean);\n \n+/* Compare integer values for less than.  */\n+#define UI_Lt uintp__ui_lt\n+extern Boolean UI_Lt\t\t\t(Uint, Uint);\n+\n /* Universal integers are represented by the Uint type which is an index into\n    the Uints_Ptr table containing Uint_Entry values.  A Uint_Entry contains an\n    index and length for getting the \"digits\" of the universal integer from the"}, {"sha": "ac81da73654e3f21e3035317d36a4fdbbb1c2ed7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -1,3 +1,9 @@\n+2010-04-17  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/sizetype.adb: Rename into...\n+\t* gnat.dg/sizetype1.adb: ...this.\n+\t* gnat.dg/sizetype2.adb: New test.\n+\n 2010-04-16  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/43572"}, {"sha": "e5d12c61e094b124f206aa6f6715e74fc29595d2", "filename": "gcc/testsuite/gnat.dg/sizetype1.adb", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype1.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype1.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype1.adb?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -2,7 +2,7 @@\n \n with Interfaces.C; use Interfaces.C;\n \n-procedure Sizetype is\n+procedure Sizetype1 is\n \n    TC_String : String(1..8) := \"abcdefgh\";\n    TC_No_nul : constant char_array := To_C(TC_String, False);", "previous_filename": "gcc/testsuite/gnat.dg/sizetype.adb"}, {"sha": "4593936c8261c411c61b7e06e5699a11a0960eaf", "filename": "gcc/testsuite/gnat.dg/sizetype2.adb", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/728936bb9200245a354a6a3d259c86795de5b6a2/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsizetype2.adb?ref=728936bb9200245a354a6a3d259c86795de5b6a2", "patch": "@@ -0,0 +1,27 @@\n+-- { dg-do run }\n+\n+procedure Sizetype2 is\n+\n+  function Ident_Int (X : Integer) return Integer is\n+  begin\n+     return X;\n+  end;\n+\n+  type A is array (Integer range <>) of Boolean;\n+  subtype T1 is A (Ident_Int (- 6) .. Ident_Int (Integer'Last - 4));\n+  subtype T2 is A (- 6 .. Ident_Int (Integer'Last - 4));\n+  subtype T3 is A (Ident_Int (- 6) .. Integer'Last - 4);\n+\n+begin\n+  if T1'Size /= 17179869200 then\n+    raise Program_Error;\n+  end if;\n+\n+  if T2'Size /= 17179869200 then\n+    raise Program_Error;\n+  end if;\n+\n+  if T3'Size /= 17179869200 then\n+    raise Program_Error;\n+  end if;\n+end;"}]}