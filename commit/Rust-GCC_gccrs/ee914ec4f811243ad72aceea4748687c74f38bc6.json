{"sha": "ee914ec4f811243ad72aceea4748687c74f38bc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWU5MTRlYzRmODExMjQzYWQ3MmFjZWVhNDc0ODY4N2M3NGYzOGJjNg==", "commit": {"author": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-08-27T21:01:37Z"}, "committer": {"name": "Jeff Law", "email": "jlaw@localhost.localdomain", "date": "2021-08-27T21:01:37Z"}, "message": "Support limited setcc for H8\n\ngcc/\n\n\t* config/h8300/bitfield.md (cstore<mode>4): Remove expander.\n\t* config/h8300/h8300.c (h8300_expand_branch): Remove function.\n\t* config/h8300/h8300-protos.h (h8300_expadn_branch): Remove prototype.\n\t* config/h8300/h8300.md (eqne): New code iterator.\n\t(geultu, geultu_to_c): Similarly.\n\t* config/h8300/testcompare.md (cstore<mode>4): Dummy expander.\n\t(store_c_<mode>, store_c_i_<mode>): New define_insn_and_splits\n\t(cmp<mode>_c): New pattern", "tree": {"sha": "828b93a8960fe4c65aa95aae24652c2b82bbd2ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/828b93a8960fe4c65aa95aae24652c2b82bbd2ba"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee914ec4f811243ad72aceea4748687c74f38bc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee914ec4f811243ad72aceea4748687c74f38bc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee914ec4f811243ad72aceea4748687c74f38bc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee914ec4f811243ad72aceea4748687c74f38bc6/comments", "author": null, "committer": null, "parents": [{"sha": "10c834f976c349970ee4b8eb3b4fce140972f256", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10c834f976c349970ee4b8eb3b4fce140972f256", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10c834f976c349970ee4b8eb3b4fce140972f256"}], "stats": {"total": 124, "additions": 89, "deletions": 35}, "files": [{"sha": "0d28c750a6ad048fd76aae76aa4ff25911494f9c", "filename": "gcc/config/h8300/bitfield.md", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fbitfield.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fbitfield.md?ref=ee914ec4f811243ad72aceea4748687c74f38bc6", "patch": "@@ -338,17 +338,6 @@\n }\n   [(set_attr \"length_table\" \"bitfield\")])\n \n-;;(define_expand \"cstore<mode>4\"\n-;;  [(use (match_operator 1 \"eqne_operator\"\n-;;         [(match_operand:QHSI 2 \"h8300_dst_operand\" \"\")\n-;;          (match_operand:QHSI 3 \"h8300_src_operand\" \"\")]))\n-;;   (clobber (match_operand:QHSI 0 \"register_operand\"))]\n-;;  \"TARGET_H8300SX\"\n-;;  {\n-;;    h8300_expand_store (operands);\n-;;    DONE;\n-;;  })\n-\n ;;(define_insn \"*bstzhireg\"\n ;;  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n ;;\t(match_operator:HI 1 \"eqne_operator\" [(cc0) (const_int 0)]))]"}, {"sha": "4a9624f91d6d3f7151f9572f885ac42ac5e30faa", "filename": "gcc/config/h8300/h8300-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300-protos.h?ref=ee914ec4f811243ad72aceea4748687c74f38bc6", "patch": "@@ -45,7 +45,6 @@ extern int compute_a_shift_cc (rtx *, rtx_code);\n #ifdef HAVE_ATTR_cc\n extern enum attr_cc compute_plussi_cc (rtx *);\n #endif\n-extern void h8300_expand_branch (rtx[]);\n extern void h8300_expand_store (rtx[]);\n extern bool expand_a_shift (machine_mode, enum rtx_code, rtx[]);\n extern int h8300_shift_needs_scratch_p (int, machine_mode, rtx_code);"}, {"sha": "a63c3220e66afe31bf359d29261685f732bcfcab", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 23, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=ee914ec4f811243ad72aceea4748687c74f38bc6", "patch": "@@ -3256,30 +3256,8 @@ compute_logical_op_length (machine_mode mode, rtx_code code, rtx *operands, rtx_\n   return length;\n }\n \n-\f\n #if 0\n-/* Expand a conditional branch.  */\n-\n-void\n-h8300_expand_branch (rtx operands[])\n-{\n-  enum rtx_code code = GET_CODE (operands[0]);\n-  rtx op0 = operands[1];\n-  rtx op1 = operands[2];\n-  rtx label = operands[3];\n-  rtx tmp;\n-\n-  tmp = gen_rtx_COMPARE (VOIDmode, op0, op1);\n-  emit_insn (gen_rtx_SET (cc0_rtx, tmp));\n-\n-  tmp = gen_rtx_fmt_ee (code, VOIDmode, cc0_rtx, const0_rtx);\n-  tmp = gen_rtx_IF_THEN_ELSE (VOIDmode, tmp,\n-\t\t\t      gen_rtx_LABEL_REF (VOIDmode, label),\n-\t\t\t      pc_rtx);\n-  emit_jump_insn (gen_rtx_SET (pc_rtx, tmp));\n-}\n-\n-\n+\f\n /* Expand a conditional store.  */\n \n void"}, {"sha": "89bfcf11126c40bebcba8abd36e7354dfaa58ba3", "filename": "gcc/config/h8300/h8300.md", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Fh8300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.md?ref=ee914ec4f811243ad72aceea4748687c74f38bc6", "patch": "@@ -233,6 +233,14 @@\n (define_code_iterator logicals [ior xor and])\n \n (define_code_iterator ors [ior xor])\n+\n+(define_code_iterator eqne [eq ne])\n+\n+;; For storing the C flag, map from the unsigned comparison to the right\n+;; code for testing the C bit.\n+(define_code_iterator geultu [geu ltu])\n+(define_code_attr geultu_to_c [(geu \"eq\") (ltu \"ne\")])\n+\n \f\n (include \"movepush.md\")\n (include \"mova.md\")"}, {"sha": "9ff7a51077e34f8c3b9dd81c753681df9913119f", "filename": "gcc/config/h8300/testcompare.md", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee914ec4f811243ad72aceea4748687c74f38bc6/gcc%2Fconfig%2Fh8300%2Ftestcompare.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Ftestcompare.md?ref=ee914ec4f811243ad72aceea4748687c74f38bc6", "patch": "@@ -70,6 +70,22 @@\n   \"mov.w\t%e0,%e0\"\n   [(set_attr \"length\" \"2\")])\n \n+(define_insn \"*cmp<mode>_c\"\n+  [(set (reg:CCC CC_REG)\n+\t(ltu (match_operand:QHSI 0 \"h8300_dst_operand\" \"rQ\")\n+\t     (match_operand:QHSI 1 \"h8300_src_operand\" \"rQi\")))]\n+  \"reload_completed\"\n+  {\n+    if (<MODE>mode == QImode)\n+      return \"cmp.b\t%X1,%X0\";\n+    else if (<MODE>mode == HImode)\n+      return \"cmp.w\t%T1,%T0\";\n+    else if (<MODE>mode == SImode)\n+      return \"cmp.l\t%S1,%S0\";\n+    gcc_unreachable ();\n+  }\n+  [(set_attr \"length_table\" \"add\")])\n+\n (define_insn \"*cmpqi\"\n   [(set (reg:CC CC_REG)\n \t(compare (match_operand:QI 0 \"h8300_dst_operand\" \"rQ\")\n@@ -144,3 +160,67 @@\n   [(parallel [(set (reg:CCZN CC_REG) (compare:CCZN (match_dup 1) (const_int 0)))\n \t      (set (match_dup 0) (match_dup 1))])])\n \n+;; This exists solely to convince ifcvt to try some store-flag sequences.\n+;;\n+;; Essentially we don't want to expose a general store-flag capability.\n+;; The only generally useful/profitable case is when we want to test the\n+;; C bit.  In that case we can use addx, subx, bst, or bist to get the bit\n+;; into a GPR.\n+;;\n+;; Others could be handled with stc, shifts and masking, but it likely isn't\n+;; profitable.\n+;;\n+(define_expand \"cstore<mode>4\"\n+  [(use (match_operator 1 \"eqne_operator\"\n+         [(match_operand:QHSI 2 \"h8300_dst_operand\" \"\")\n+          (match_operand:QHSI 3 \"h8300_src_operand\" \"\")]))\n+   (clobber (match_operand:QHSI 0 \"register_operand\"))]\n+  \"\"\n+  {\n+    FAIL;\n+  })\n+\n+;; Storing the C bit is pretty simple since there are many ways to\n+;; introduce it into a GPR.  addx, subx and a variety of bit manipulation\n+;; instructions\n+;;\n+(define_insn \"*store_c_<mode>\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(eqne:QHSI (reg:CCC CC_REG) (const_int 0)))]\n+  \"reload_completed\"\n+  {\n+    if (<CODE> == NE)\n+      {\n+\tif (<MODE>mode == QImode)\n+\t  return \"xor.b\\t%X0,%X0\\;bst\\t#0,%X0\";\n+\telse if (<MODE>mode == HImode)\n+\t  return \"xor.w\\t%T0,%T0\\;bst\\t#0,%s0\";\n+\telse if (<MODE>mode == SImode)\n+\t  return \"xor.l\\t%S0,%S0\\;bst\\t#0,%w0\";\n+\tgcc_unreachable ();\n+      }\n+    else if (<CODE> == EQ)\n+      {\n+\tif (<MODE>mode == QImode)\n+\t  return \"xor.b\\t%X0,%X0\\;bist\\t#0,%X0\";\n+\telse if (<MODE>mode == HImode)\n+\t  return \"xor.w\\t%T0,%T0\\;bist\\t#0,%s0\";\n+\telse if (<MODE>mode == SImode)\n+\t  return \"xor.l\\t%S0,%S0\\;bist\\t#0,%w0\";\n+\tgcc_unreachable ();\n+      }\n+  }\n+  [(set (attr \"length\") (symbol_ref \"<MODE>mode == SImode ? 6 : 4\"))])\n+\n+;; Recognize this scc and generate code we can match\n+(define_insn_and_split \"*store_c_i_<mode>\"\n+  [(set (match_operand:QHSI 0 \"register_operand\" \"=r\")\n+\t(geultu:QHSI (match_operand:QHSI 1 \"register_operand\" \"r\")\n+\t\t     (match_operand:QHSI 2 \"register_operand\" \"r\")))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (reg:CCC CC_REG)\n+\t(ltu:CCC (match_dup 1) (match_dup 2)))\n+   (set (match_dup 0)\n+\t(<geultu_to_c>:QHSI (reg:CCC CC_REG) (const_int 0)))])"}]}