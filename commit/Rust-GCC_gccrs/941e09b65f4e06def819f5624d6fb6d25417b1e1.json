{"sha": "941e09b65f4e06def819f5624d6fb6d25417b1e1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQxZTA5YjY1ZjRlMDZkZWY4MTlmNTYyNGQ2ZmI2ZDI1NDE3YjFlMQ==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.phys.columbia.edu", "date": "1998-12-15T11:17:06Z"}, "committer": {"name": "Dave Brolley", "email": "brolley@gcc.gnu.org", "date": "1998-12-15T11:17:06Z"}, "message": "cpplib.c: Make all directive handlers read their own arguments.\n\n1998-12-14 00:56 -0500  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n\t* cpplib.c: Make all directive handlers read their own\n          arguments.\n\t  (struct directive): Remove last two arguments from FUNC\n          member prototype. Remove `command_reads_line' member\n          entirely.\n\t  (directive_table): Remove initializations of\n          command_reads_line flag.  Pretty-print.\n\t  (eval_if_expression, do_define, do_line, do_include,\n          do_undef, do_error, do_pragma, do_ident, do_if, do_xifdef,\n          do_else, do_elif, do_sccs, do_assert, do_unassert,\n          do_warning): Take only two args.\n\t  (cpp_define): Call do_define with two args and the text to\n\t  define stuffed into a buffer.\n\t  (make_assertion): Call do_assert with two args.\n\t  (handle_directive): Call do_line with two args. Call\n\t  kt->func with two args.  Remove command_reads_line\n\t  processing.\n\t  (do_define, do_undef, do_error, do_warning, do_pragma,\n\t  do_sccs): Read the rest of the line here.\n\t  (do_ident): Gobble rest of line, as cccp does.\n\t  (cpp_undef): New function.\n\t  (cpp_start_read): Call cpp_undef instead of do_undef.\n\nFrom-SVN: r24326", "tree": {"sha": "b159c3f4e8c5f6ede1944dfdb5b3496afa086930", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b159c3f4e8c5f6ede1944dfdb5b3496afa086930"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/941e09b65f4e06def819f5624d6fb6d25417b1e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941e09b65f4e06def819f5624d6fb6d25417b1e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/941e09b65f4e06def819f5624d6fb6d25417b1e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/941e09b65f4e06def819f5624d6fb6d25417b1e1/comments", "author": null, "committer": null, "parents": [{"sha": "7061aa5a9e81cc89a5854c55a9f650737274beb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7061aa5a9e81cc89a5854c55a9f650737274beb3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7061aa5a9e81cc89a5854c55a9f650737274beb3"}], "stats": {"total": 367, "additions": 195, "deletions": 172}, "files": [{"sha": "ea9f1d09178c4e65ec67e66518082c0cff152f6e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941e09b65f4e06def819f5624d6fb6d25417b1e1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941e09b65f4e06def819f5624d6fb6d25417b1e1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=941e09b65f4e06def819f5624d6fb6d25417b1e1", "patch": "@@ -1,3 +1,29 @@\n+1998-12-15  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n+\n+\t* cpplib.c: Make all directive handlers read their own\n+          arguments.\n+\t  (struct directive): Remove last two arguments from FUNC\n+          member prototype. Remove `command_reads_line' member\n+          entirely.\n+\t  (directive_table): Remove initializations of\n+          command_reads_line flag.  Pretty-print.\n+\t  (eval_if_expression, do_define, do_line, do_include,\n+          do_undef, do_error, do_pragma, do_ident, do_if, do_xifdef,\n+          do_else, do_elif, do_sccs, do_assert, do_unassert,\n+          do_warning): Take only two args.\n+\n+\t  (cpp_define): Call do_define with two args and the text to\n+\t  define stuffed into a buffer.\n+\t  (make_assertion): Call do_assert with two args.\n+\t  (handle_directive): Call do_line with two args. Call\n+\t  kt->func with two args.  Remove command_reads_line\n+\t  processing.\n+\t  (do_define, do_undef, do_error, do_warning, do_pragma,\n+\t  do_sccs): Read the rest of the line here.\n+\t  (do_ident): Gobble rest of line, as cccp does.\n+\t  (cpp_undef): New function.\n+\t  (cpp_start_read): Call cpp_undef instead of do_undef.\n+\n 1998-12-15  Zack Weinberg  <zack@rabi.phys.columbia.edu>\n \n \t* cpphash.h (union hash_value): Remove `keydef' member, add a"}, {"sha": "537d2dce4043aed0eb4df02c7604bc142aa9b3c9", "filename": "gcc/cpplib.c", "status": "modified", "additions": 169, "deletions": 172, "changes": 341, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/941e09b65f4e06def819f5624d6fb6d25417b1e1/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/941e09b65f4e06def819f5624d6fb6d25417b1e1/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=941e09b65f4e06def819f5624d6fb6d25417b1e1", "patch": "@@ -159,7 +159,7 @@ extern void fancy_abort ();\n static int check_macro_name\t\tPROTO ((cpp_reader *, U_CHAR *, char *));\n static int compare_defs\t\t\tPROTO ((cpp_reader *,\n \t\t\t\t\t\tDEFINITION *, DEFINITION *));\n-static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *, U_CHAR *, int));\n+static HOST_WIDE_INT eval_if_expression\tPROTO ((cpp_reader *));\n static int change_newlines\t\tPROTO ((U_CHAR *, int));\n static void push_macro_expansion PARAMS ((cpp_reader *,\n \t\t\t\t\t  U_CHAR *, int, HASHNODE *));\n@@ -243,34 +243,33 @@ static struct default_include {\n struct directive {\n   int length;\t\t\t/* Length of name */\n   int (*func)\t\t\t/* Function to handle directive */\n-    PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n+    PARAMS ((cpp_reader *, struct directive *));\n   char *name;\t\t\t/* Name of directive */\n   enum node_type type;\t\t/* Code which describes which directive.  */\n-  char command_reads_line;      /* One if rest of line is read by func.  */\n };\n \n /* These functions are declared to return int instead of void since they\n    are going to be placed in a table and some old compilers have trouble with\n    pointers to functions returning void.  */\n \n-static int do_define PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_line PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_include PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_undef PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_error PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_pragma PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_ident PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_if PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_xifdef PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_else PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_elif PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_endif PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n+static int do_define PARAMS ((cpp_reader *, struct directive *));\n+static int do_line PARAMS ((cpp_reader *, struct directive *));\n+static int do_include PARAMS ((cpp_reader *, struct directive *));\n+static int do_undef PARAMS ((cpp_reader *, struct directive *));\n+static int do_error PARAMS ((cpp_reader *, struct directive *));\n+static int do_pragma PARAMS ((cpp_reader *, struct directive *));\n+static int do_ident PARAMS ((cpp_reader *, struct directive *));\n+static int do_if PARAMS ((cpp_reader *, struct directive *));\n+static int do_xifdef PARAMS ((cpp_reader *, struct directive *));\n+static int do_else PARAMS ((cpp_reader *, struct directive *));\n+static int do_elif PARAMS ((cpp_reader *, struct directive *));\n+static int do_endif PARAMS ((cpp_reader *, struct directive *));\n #ifdef SCCS_DIRECTIVE\n-static int do_sccs PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n+static int do_sccs PARAMS ((cpp_reader *, struct directive *));\n #endif\n-static int do_assert PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_unassert PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n-static int do_warning PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHAR *));\n+static int do_assert PARAMS ((cpp_reader *, struct directive *));\n+static int do_unassert PARAMS ((cpp_reader *, struct directive *));\n+static int do_warning PARAMS ((cpp_reader *, struct directive *));\n \n #define IS_INCLUDE_DIRECTIVE_TYPE(t) \\\n ((int) T_INCLUDE <= (int) (t) && (int) (t) <= (int) T_IMPORT)\n@@ -279,28 +278,28 @@ static int do_warning PARAMS ((cpp_reader *, struct directive *, U_CHAR *, U_CHA\n    The initialize_builtins function assumes #define is the very first.  */\n \n static struct directive directive_table[] = {\n-  {  6, do_define, \"define\", T_DEFINE, 0},\n-  {  5, do_xifdef, \"ifdef\", T_IFDEF, 1},\n-  {  6, do_xifdef, \"ifndef\", T_IFNDEF, 1},\n-  {  7, do_include, \"include\", T_INCLUDE, 1},\n-  { 12, do_include, \"include_next\", T_INCLUDE_NEXT, 1},\n-  {  6, do_include, \"import\", T_IMPORT, 1},\n-  {  5, do_endif, \"endif\", T_ENDIF, 1},\n-  {  4, do_else, \"else\", T_ELSE, 1},\n-  {  2, do_if, \"if\", T_IF, 1},\n-  {  4, do_elif, \"elif\", T_ELIF, 1},\n-  {  5, do_undef, \"undef\", T_UNDEF, 0},\n-  {  5, do_error, \"error\", T_ERROR, 0},\n-  {  7, do_warning, \"warning\", T_WARNING, 0},\n-  {  6, do_pragma, \"pragma\", T_PRAGMA, 0},\n-  {  4, do_line, \"line\", T_LINE, 1},\n-  {  5, do_ident, \"ident\", T_IDENT, 1},\n+  {  6, do_define,   \"define\",       T_DEFINE },\n+  {  5, do_xifdef,   \"ifdef\",        T_IFDEF },\n+  {  6, do_xifdef,   \"ifndef\",       T_IFNDEF },\n+  {  7, do_include,  \"include\",      T_INCLUDE },\n+  { 12, do_include,  \"include_next\", T_INCLUDE_NEXT },\n+  {  6, do_include,  \"import\",       T_IMPORT },\n+  {  5, do_endif,    \"endif\",        T_ENDIF },\n+  {  4, do_else,     \"else\",         T_ELSE },\n+  {  2, do_if,       \"if\",           T_IF },\n+  {  4, do_elif,     \"elif\",         T_ELIF },\n+  {  5, do_undef,    \"undef\",        T_UNDEF },\n+  {  5, do_error,    \"error\",        T_ERROR },\n+  {  7, do_warning,  \"warning\",      T_WARNING },\n+  {  6, do_pragma,   \"pragma\",       T_PRAGMA },\n+  {  4, do_line,     \"line\",         T_LINE },\n+  {  5, do_ident,    \"ident\",        T_IDENT },\n #ifdef SCCS_DIRECTIVE\n-  {  4, do_sccs, \"sccs\", T_SCCS, 0},\n+  {  4, do_sccs,     \"sccs\",         T_SCCS },\n #endif\n-  {  6, do_assert, \"assert\", T_ASSERT, 1},\n-  {  8, do_unassert, \"unassert\", T_UNASSERT, 1},\n-  {  -1, 0, \"\", T_UNUSED, 0},\n+  {  6, do_assert,   \"assert\",       T_ASSERT },\n+  {  8, do_unassert, \"unassert\",     T_UNASSERT },\n+  {  -1, 0, \"\", T_UNUSED }\n };\n \f\n /* table to tell if char can be part of a C identifier.  */\n@@ -467,7 +466,11 @@ cpp_define (pfile, str)\n     *q = 0;\n   }\n   \n-  do_define (pfile, NULL, buf, buf + strlen (buf));\n+  if (cpp_push_buffer (pfile, buf, strlen (buf)) != NULL)\n+    {\n+      do_define (pfile, NULL);\n+      cpp_pop_buffer (pfile);\n+    }\n }\n \f\n /* Process the string STR as if it appeared as the body of a #assert.\n@@ -508,10 +511,10 @@ make_assertion (pfile, option, str)\n     cpp_error (pfile, \"malformed option `%s %s'\", option, str);\n     return;\n   }\n-  \n+\n   if (cpp_push_buffer (pfile, buf, strlen (buf)) != NULL)\n     {\n-      do_assert (pfile, NULL, NULL, NULL);\n+      do_assert (pfile, NULL);\n       cpp_pop_buffer (pfile);\n     }\n }\n@@ -793,8 +796,7 @@ handle_directive (pfile)\n { int c;\n   register struct directive *kt;\n   int ident_length;\n-  long after_ident;\n-  U_CHAR *ident, *line_end;\n+  U_CHAR *ident;\n   long old_written = CPP_WRITTEN (pfile);\n \n   cpp_skip_hspace (pfile);\n@@ -805,7 +807,7 @@ handle_directive (pfile)\n       /* Handle # followed by a line number.  */\n       if (CPP_PEDANTIC (pfile))\n \tcpp_pedwarn (pfile, \"`#' followed by integer\");\n-      do_line (pfile, NULL, NULL, NULL);\n+      do_line (pfile, NULL);\n       goto done_a_directive;\n     }\n \n@@ -851,40 +853,23 @@ handle_directive (pfile)\n   for (kt = directive_table; ; kt++) {\n     if (kt->length <= 0)\n       goto not_a_directive;\n-    if (kt->length == ident_length && !strncmp (kt->name, ident, ident_length)) \n+    if (kt->length == ident_length\n+\t&& !strncmp (kt->name, ident, ident_length)) \n       break;\n   }\n \n-  if (kt->command_reads_line)\n-    after_ident = 0;\n-  else\n-    {\n-      /* Nonzero means do not delete comments within the directive.\n-         #define needs this when -traditional.  */\n-\tint comments = CPP_TRADITIONAL (pfile) && kt->type == T_DEFINE;\n-\tint save_put_out_comments = CPP_OPTIONS (pfile)->put_out_comments;\n-\tCPP_OPTIONS (pfile)->put_out_comments = comments;\n-\tafter_ident = CPP_WRITTEN (pfile);\n-\tcopy_rest_of_line (pfile);\n-\tCPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n-    }\n-\n   /* We may want to pass through #define, #pragma, and #include.\n      Other directives may create output, but we don't want the directive\n      itself out, so we pop it now.  For example conditionals may emit\n-     #failed ... #endfailed stuff.  But note that popping the buffer\n-     means the parameters to kt->func may point after pfile->limit\n-     so these parameters are invalid as soon as something gets appended\n-     to the token_buffer.  */\n+     #failed ... #endfailed stuff.  */\n \n-  line_end = CPP_PWRITTEN (pfile);\n   if (! (kt->type == T_DEFINE\n \t || kt->type == T_PRAGMA\n \t || (IS_INCLUDE_DIRECTIVE_TYPE (kt->type)\n \t     && CPP_OPTIONS (pfile)->dump_includes)))\n     CPP_SET_WRITTEN (pfile, old_written);\n \n-  (*kt->func) (pfile, kt, pfile->token_buffer + after_ident, line_end);\n+  (*kt->func) (pfile, kt);\n \n   if (kt->type == T_DEFINE)\n     {\n@@ -911,7 +896,7 @@ handle_directive (pfile)\n \n /* Pass a directive through to the output file.\n    BUF points to the contents of the directive, as a contiguous string.\n-   LIMIT points to the first character past the end of the directive.\n+m   LIMIT points to the first character past the end of the directive.\n    KEYWORD is the keyword-table entry for the directive.  */\n \n static void\n@@ -1533,28 +1518,44 @@ comp_def_part (first, beg1, len1, beg2, len2, last)\n }\n \n /* Process a #define command.\n-BUF points to the contents of the #define command, as a contiguous string.\n-LIMIT points to the first character past the end of the definition.\n KEYWORD is the keyword-table entry for #define,\n or NULL for a \"predefined\" macro.  */\n \n static int\n-do_define (pfile, keyword, buf, limit)\n+do_define (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword;\n-     U_CHAR *buf, *limit;\n {\n   int hashcode;\n   MACRODEF mdef;\n   HASHNODE *hp;\n+  int save_put_out_comments;\n+  long here;\n+  U_CHAR *macro, *buf, *end;\n+\n+  here = CPP_WRITTEN (pfile);\n+  \n+  save_put_out_comments = CPP_OPTIONS (pfile)->put_out_comments;\n+  CPP_OPTIONS (pfile)->put_out_comments = CPP_TRADITIONAL (pfile);\n+  copy_rest_of_line (pfile);\n+  CPP_OPTIONS (pfile)->put_out_comments = save_put_out_comments;\n+\n+  /* Copy out the line so we can pop the token buffer. */\n+  buf = pfile->token_buffer + here;\n+  end = CPP_PWRITTEN (pfile);\n+  macro = alloca (end - buf + 1);\n+  bcopy (buf, macro, end - buf + 1);\n+  end = macro + (end - buf);\n+\n+  CPP_SET_WRITTEN (pfile, here);\n \n #if 0\n   /* If this is a precompiler run (with -pcp) pass thru #define commands.  */\n   if (pcp_outfile && keyword)\n-    pass_thru_directive (buf, limit, pfile, keyword);\n+    pass_thru_directive (macro, end, pfile, keyword);\n #endif\n \n-  mdef = create_definition (buf, limit, pfile, keyword == NULL);\n+  mdef = create_definition (macro, end, pfile, keyword == NULL);\n   if (mdef.defn == 0)\n     goto nope;\n \n@@ -1580,7 +1581,7 @@ do_define (pfile, keyword, buf, limit)\n \t  /* If we are passing through #define and #undef directives, do\n \t     that for this re-definition now.  */\n \t  if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\t    pass_thru_directive (buf, limit, pfile, keyword);\n+\t    pass_thru_directive (macro, end, pfile, keyword);\n \n \t  msg = (U_CHAR *) alloca (mdef.symlen + 22);\n \t  *msg = '`';\n@@ -1600,7 +1601,7 @@ do_define (pfile, keyword, buf, limit)\n       /* If we are passing through #define and #undef directives, do\n \t that for this new definition now.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (buf, limit, pfile, keyword);\n+\tpass_thru_directive (macro, end, pfile, keyword);\n       install (mdef.symnam, mdef.symlen, T_MACRO, 0,\n \t       (char *) mdef.defn, hashcode);\n     }\n@@ -2871,10 +2872,9 @@ get_directive_token (pfile)\n    This is safe.  */\n \n static int\n-do_include (pfile, keyword, unused1, unused2)\n+do_include (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword;\n-     U_CHAR *unused1 ATTRIBUTE_UNUSED, *unused2 ATTRIBUTE_UNUSED;\n {\n   int importing = (keyword->type == T_IMPORT);\n   int skip_dirs = (keyword->type == T_INCLUDE_NEXT);\n@@ -3147,10 +3147,9 @@ convert_string (pfile, result, in, limit, handle_escapes)\n #define FNAME_HASHSIZE 37\n \n static int\n-do_line (pfile, keyword, unused1, unused2)\n+do_line (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *unused1 ATTRIBUTE_UNUSED, *unused2 ATTRIBUTE_UNUSED;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n   int new_lineno;\n@@ -3278,43 +3277,79 @@ do_line (pfile, keyword, unused1, unused2)\n  */\n \n static int\n-do_undef (pfile, keyword, buf, limit)\n+do_undef (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword;\n-     U_CHAR *buf, *limit;\n {\n   int sym_length;\n   HASHNODE *hp;\n-  U_CHAR *orig_buf = buf;\n+  U_CHAR *buf, *name, *limit;\n+  int c;\n+  long here = CPP_WRITTEN (pfile);\n+  enum cpp_token token;\n+\n+  cpp_skip_hspace (pfile);\n+  c = GETC();\n+  if (! is_idstart[c])\n+  {\n+      cpp_error (pfile, \"token after #undef is not an identifier\");\n+      skip_rest_of_line (pfile);\n+      return 1;\n+  }\n+\n+  parse_name (pfile, c);\n+  buf = pfile->token_buffer + here;\n+  limit = CPP_PWRITTEN(pfile);\n+\n+  /* Copy out the token so we can pop the token buffer. */\n+  name = alloca (limit - buf + 1);\n+  bcopy(buf, name, limit - buf);\n+  name[limit - buf] = '\\0';\n+\n+  token = get_directive_token (pfile);\n+  if (token != CPP_VSPACE)\n+  {\n+      cpp_pedwarn (pfile, \"junk on line after #undef\");\n+      skip_rest_of_line (pfile);\n+  }\n+\n+  CPP_SET_WRITTEN (pfile, here);\n \n #if 0\n   /* If this is a precompiler run (with -pcp) pass thru #undef commands.  */\n   if (pcp_outfile && keyword)\n     pass_thru_directive (buf, limit, pfile, keyword);\n #endif\n \n-  SKIP_WHITE_SPACE (buf);\n-  sym_length = check_macro_name (pfile, buf, \"macro\");\n+  sym_length = check_macro_name (pfile, name, \"macro\");\n \n-  while ((hp = cpp_lookup (pfile, buf, sym_length, -1)) != NULL)\n+  while ((hp = cpp_lookup (pfile, name, sym_length, -1)) != NULL)\n     {\n       /* If we are generating additional info for debugging (with -g) we\n \t need to pass through all effective #undef commands.  */\n       if (CPP_OPTIONS (pfile)->debug_output && keyword)\n-\tpass_thru_directive (orig_buf, limit, pfile, keyword);\n+\tpass_thru_directive (name, name+sym_length, pfile, keyword);\n       if (hp->type != T_MACRO)\n \tcpp_warning (pfile, \"undefining `%s'\", hp->name);\n       delete_macro (hp);\n     }\n \n-  if (CPP_PEDANTIC (pfile)) {\n-    buf += sym_length;\n-    SKIP_WHITE_SPACE (buf);\n-    if (buf != limit)\n-      cpp_pedwarn (pfile, \"garbage after `#undef' directive\");\n-  }\n   return 0;\n }\n+\n+/* Wrap do_undef for -U processing. */\n+static void\n+cpp_undef (pfile, macro)\n+     cpp_reader *pfile;\n+     U_CHAR *macro;\n+{\n+    if (cpp_push_buffer (pfile, macro, strlen(macro)))\n+    {\n+\tdo_undef (pfile, NULL);\n+\tcpp_pop_buffer (pfile);\n+    }\n+}\n+\n \f\n /*\n  * Report an error detected by the program we are processing.\n@@ -3323,77 +3358,78 @@ do_undef (pfile, keyword, buf, limit)\n  */\n \n static int\n-do_error (pfile, keyword, buf, limit)\n+do_error (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf, *limit;\n {\n-  int length = limit - buf;\n-  U_CHAR *copy = (U_CHAR *) alloca (length + 1);\n-  bcopy (buf, copy, length);\n-  copy[length] = 0;\n-  SKIP_WHITE_SPACE (copy);\n-  cpp_error (pfile, \"#error %s\", copy);\n+  long here = CPP_WRITTEN (pfile);\n+  U_CHAR *text;\n+  copy_rest_of_line (pfile);\n+  text = pfile->token_buffer + here;\n+  SKIP_WHITE_SPACE(text);\n+\n+  cpp_error (pfile, \"#error %s\", text);\n+  CPP_SET_WRITTEN (pfile, here);\n   return 0;\n }\n \n /*\n  * Report a warning detected by the program we are processing.\n  * Use the text of the line in the warning message, then continue.\n- * (We use error because it prints the filename & line#.)\n  */\n \n static int\n-do_warning (pfile, keyword, buf, limit)\n+do_warning (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf, *limit;\n {\n-  int length = limit - buf;\n-  U_CHAR *copy = (U_CHAR *) alloca (length + 1);\n-  bcopy (buf, copy, length);\n-  copy[length] = 0;\n-  SKIP_WHITE_SPACE (copy);\n+  U_CHAR *text;\n+  long here = CPP_WRITTEN(pfile);\n+  copy_rest_of_line (pfile);\n+  text = pfile->token_buffer + here;\n+  SKIP_WHITE_SPACE(text);\n \n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#warning'\");\n \n   /* Use `pedwarn' not `warning', because #warning isn't in the C Standard;\n      if -pedantic-errors is given, #warning should cause an error.  */\n-  cpp_pedwarn (pfile, \"#warning %s\", copy);\n+  cpp_pedwarn (pfile, \"#warning %s\", text);\n+  CPP_SET_WRITTEN (pfile, here);\n   return 0;\n }\n \n /* Report program identification.  */\n \n static int\n-do_ident (pfile, keyword, buf, limit)\n+do_ident (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n-/*  long old_written = CPP_WRITTEN (pfile);*/\n-\n   /* Allow #ident in system headers, since that's not user's fault.  */\n   if (CPP_PEDANTIC (pfile) && !CPP_BUFFER (pfile)->system_header_p)\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#ident'\");\n \n-  /* Leave rest of line to be read by later calls to cpp_get_token.  */\n+  skip_rest_of_line (pfile);  /* Correct?  Appears to match cccp.  */\n \n   return 0;\n }\n \n-/* #pragma and its argument line have already been copied to the output file.\n-   Just check for some recognized pragmas that need validation here.  */\n+/* Just check for some recognized pragmas that need validation here,\n+   and leave the text in the token buffer to be output. */\n \n static int\n-do_pragma (pfile, keyword, buf, limit)\n+do_pragma (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf, *limit ATTRIBUTE_UNUSED;\n {\n-  while (*buf == ' ' || *buf == '\\t')\n-    buf++;\n+  long here = CPP_WRITTEN (pfile);\n+  U_CHAR *buf;\n+  \n+  copy_rest_of_line (pfile);\n+  buf = pfile->token_buffer + here;\n+  SKIP_WHITE_SPACE (buf);\n+  \n   if (!strncmp (buf, \"once\", 4))\n     {\n       cpp_buffer *ip = NULL;\n@@ -3444,44 +3480,17 @@ do_pragma (pfile, keyword, buf, limit)\n   return 0;\n }\n \n-#if 0\n-/* This was a fun hack, but #pragma seems to start to be useful.\n-   By failing to recognize it, we pass it through unchanged to cc1.  */\n-\n-/*\n- * the behavior of the #pragma directive is implementation defined.\n- * this implementation defines it as follows.\n- */\n-\n-static int\n-do_pragma ()\n-{\n-  close (0);\n-  if (open (\"/dev/tty\", O_RDONLY, 0666) != 0)\n-    goto nope;\n-  close (1);\n-  if (open (\"/dev/tty\", O_WRONLY, 0666) != 1)\n-    goto nope;\n-  execl (\"/usr/games/hack\", \"#pragma\", 0);\n-  execl (\"/usr/games/rogue\", \"#pragma\", 0);\n-  execl (\"/usr/new/emacs\", \"-f\", \"hanoi\", \"9\", \"-kill\", 0);\n-  execl (\"/usr/local/emacs\", \"-f\", \"hanoi\", \"9\", \"-kill\", 0);\n-nope:\n-  fatal (\"You are in a maze of twisty compiler features, all different\");\n-}\n-#endif\n-\n #ifdef SCCS_DIRECTIVE\n /* Just ignore #sccs, on systems where we define it at all.  */\n \n static int\n-do_sccs (pfile, keyword, buf, limit)\n+do_sccs (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n   if (CPP_PEDANTIC (pfile))\n     cpp_pedwarn (pfile, \"ANSI C does not allow `#sccs'\");\n+  skip_rest_of_line (pfile);\n   return 0;\n }\n #endif\n@@ -3500,12 +3509,11 @@ do_sccs (pfile, keyword, buf, limit)\n  */\n \n static int\n-do_if (pfile, keyword, buf, limit)\n+do_if (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf, *limit;\n {\n-  HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);\n+  HOST_WIDE_INT value = eval_if_expression (pfile);\n   conditional_skip (pfile, value == 0, T_IF, NULL_PTR);\n   return 0;\n }\n@@ -3516,10 +3524,9 @@ do_if (pfile, keyword, buf, limit)\n  */\n \n static int\n-do_elif (pfile, keyword, buf, limit)\n+do_elif (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf, *limit;\n {\n   if (pfile->if_stack == CPP_BUFFER (pfile)->if_stack) {\n     cpp_error (pfile, \"`#elif' not within a conditional\");\n@@ -3542,7 +3549,7 @@ do_elif (pfile, keyword, buf, limit)\n   if (pfile->if_stack->if_succeeded)\n     skip_if_group (pfile, 0);\n   else {\n-    HOST_WIDE_INT value = eval_if_expression (pfile, buf, limit - buf);\n+    HOST_WIDE_INT value = eval_if_expression (pfile);\n     if (value == 0)\n       skip_if_group (pfile, 0);\n     else {\n@@ -3559,10 +3566,8 @@ do_elif (pfile, keyword, buf, limit)\n  */\n \n static HOST_WIDE_INT\n-eval_if_expression (pfile, buf, length)\n+eval_if_expression (pfile)\n      cpp_reader *pfile;\n-     U_CHAR *buf ATTRIBUTE_UNUSED;\n-     int length ATTRIBUTE_UNUSED;\n {\n   HASHNODE *save_defined;\n   HOST_WIDE_INT value;\n@@ -3587,10 +3592,9 @@ eval_if_expression (pfile, buf, length)\n  */\n \n static int\n-do_xifdef (pfile, keyword, unused1, unused2)\n+do_xifdef (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword;\n-     U_CHAR *unused1 ATTRIBUTE_UNUSED, *unused2 ATTRIBUTE_UNUSED;\n {\n   int skip;\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n@@ -3868,10 +3872,9 @@ skip_if_group (pfile, any)\n  */\n \n static int\n-do_else (pfile, keyword, buf, limit)\n+do_else (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n \n@@ -3911,10 +3914,9 @@ do_else (pfile, keyword, buf, limit)\n  */\n \n static int\n-do_endif (pfile, keyword, buf, limit)\n+do_endif (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n   if (CPP_PEDANTIC (pfile))\n     validate_else (pfile, \"#endif\");\n@@ -4830,7 +4832,7 @@ cpp_start_read (pfile, fname)\n \t    case 'U':\n \t      if (opts->debug_output)\n \t\toutput_line_command (pfile, 0, same_file);\n-\t      do_undef (pfile, NULL, pend->arg, pend->arg + strlen (pend->arg));\n+\t      cpp_undef (pfile, pend->arg);\n \t      break;\n \t    case 'D':\n \t      if (opts->debug_output)\n@@ -6006,10 +6008,9 @@ parse_assertion (pfile)\n }\n \n static int\n-do_assert (pfile, keyword, buf, limit)\n+do_assert (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n   char *sym;\n   int ret, c;\n@@ -6073,10 +6074,9 @@ do_assert (pfile, keyword, buf, limit)\n }\n \n static int\n-do_unassert (pfile, keyword, buf, limit)\n+do_unassert (pfile, keyword)\n      cpp_reader *pfile;\n      struct directive *keyword ATTRIBUTE_UNUSED;\n-     U_CHAR *buf ATTRIBUTE_UNUSED, *limit ATTRIBUTE_UNUSED;\n {\n   int c, ret;\n   char *sym;\n@@ -6569,9 +6569,6 @@ cpp_perror_with_name (pfile, name)\n  *\n  * Possibly different enum token codes for each C/C++ token.\n  *\n- * Should clean up remaining directives to that do_XXX functions\n- *   only take two arguments and all have command_reads_line.\n- *\n  * Find and cleanup remaining uses of static variables,\n  *\n  * Support for trigraphs."}]}