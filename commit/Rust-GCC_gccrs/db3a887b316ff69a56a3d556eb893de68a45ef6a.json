{"sha": "db3a887b316ff69a56a3d556eb893de68a45ef6a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGIzYTg4N2IzMTZmZjY5YTU2YTNkNTU2ZWI4OTNkZTY4YTQ1ZWY2YQ==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "1999-01-18T03:01:26Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1999-01-18T03:01:26Z"}, "message": "flow.c (last_mem_set): Delete variable.\n\n        * flow.c (last_mem_set): Delete variable.  References removed.\n        (mem_set_list): New variable.\n        (life_analysis): Initialize and finalize alias analysis.\n        (propagate_block); Initialize mem_set_list.  Clear for CALL_INSNs.\n        (insn_dead_p): For a store to memory, search the entire mem_set_list\n        for a match.\n        (mark_set_1): Kill entries on the mem_set_list for aliased writes or\n        changes to their addresses.  Add new entries to the mem_set_list for\n        memory writes writes.\n        (mark_used_regs): Kill entries on the mem_set_list which may be\n        referenced by a load operation.\n\nCo-Authored-By: Jeffrey A Law <law@cygnus.com>\n\nFrom-SVN: r24734", "tree": {"sha": "5b167ce3ab89fb45fd43e6c17c1691a58121fda4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b167ce3ab89fb45fd43e6c17c1691a58121fda4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/db3a887b316ff69a56a3d556eb893de68a45ef6a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3a887b316ff69a56a3d556eb893de68a45ef6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/db3a887b316ff69a56a3d556eb893de68a45ef6a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/db3a887b316ff69a56a3d556eb893de68a45ef6a/comments", "author": null, "committer": null, "parents": [{"sha": "586fd9391263c7f7e7cc60c9c0e14954c2917384", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/586fd9391263c7f7e7cc60c9c0e14954c2917384", "html_url": "https://github.com/Rust-GCC/gccrs/commit/586fd9391263c7f7e7cc60c9c0e14954c2917384"}], "stats": {"total": 104, "additions": 86, "deletions": 18}, "files": [{"sha": "e8ca377edfd3e0882676891d4434886e10397d77", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3a887b316ff69a56a3d556eb893de68a45ef6a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3a887b316ff69a56a3d556eb893de68a45ef6a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=db3a887b316ff69a56a3d556eb893de68a45ef6a", "patch": "@@ -1,3 +1,18 @@\n+Mon Jan 18 03:52:56 1999  Christian Bruel <Christian.Bruel@st.com>\n+\t\t\t  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* flow.c (last_mem_set): Delete variable.  References removed.\n+\t(mem_set_list): New variable.\n+\t(life_analysis): Initialize and finalize alias analysis.\n+\t(propagate_block); Initialize mem_set_list.  Clear for CALL_INSNs.\n+\t(insn_dead_p): For a store to memory, search the entire mem_set_list\n+\tfor a match.\n+\t(mark_set_1): Kill entries on the mem_set_list for aliased writes or\n+\tchanges to their addresses.  Add new entries to the mem_set_list for\n+\tmemory writes writes.\n+\t(mark_used_regs): Kill entries on the mem_set_list which may be\n+\treferenced by a load operation.\n+\n Mon Jan 18 01:01:02 1999  Jeffrey A Law  (law@cygnus.com)\n \n \t* alias.c (base_alias_check): Add missing return for differing"}, {"sha": "e30972ce11048537d2967dceb7372d266ebaa830", "filename": "gcc/flow.c", "status": "modified", "additions": 71, "deletions": 18, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/db3a887b316ff69a56a3d556eb893de68a45ef6a/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/db3a887b316ff69a56a3d556eb893de68a45ef6a/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=db3a887b316ff69a56a3d556eb893de68a45ef6a", "patch": "@@ -246,10 +246,10 @@ static int loop_depth;\n \n static int cc0_live;\n \n-/* During propagate_block, this contains the last MEM stored into.  It\n-   is used to eliminate consecutive stores to the same location.  */\n+/* During propagate_block, this contains a list of all the MEMs we are\n+   tracking for dead store elimination.  */\n \n-static rtx last_mem_set;\n+static rtx mem_set_list;\n \n /* Set of registers that may be eliminable.  These are handled specially\n    in updating regs_ever_live.  */\n@@ -1147,7 +1147,11 @@ life_analysis (f, nregs, file)\n   SET_HARD_REG_BIT (elim_reg_set, FRAME_POINTER_REGNUM);\n #endif\n \n+  /* We want alias analysis information for local dead store elimination.  */\n+  init_alias_analysis ();\n   life_analysis_1 (f, nregs);\n+  end_alias_analysis ();\n+\n   if (file)\n     dump_flow_info (file);\n \n@@ -1739,7 +1743,7 @@ propagate_block (old, first, last, final, significant, bnum)\n   live = ALLOCA_REG_SET ();\n \n   cc0_live = 0;\n-  last_mem_set = 0;\n+  mem_set_list = NULL_RTX;\n \n   /* Include any notes at the end of the block in the scan.\n      This is in case the block ends with a call to setjmp.  */\n@@ -1963,7 +1967,7 @@ propagate_block (old, first, last, final, significant, bnum)\n \t\t\t\t      final, insn);\n \n \t\t  /* Calls also clobber memory.  */\n-\t\t  last_mem_set = 0;\n+\t\t  mem_set_list = NULL_RTX;\n \t\t}\n \n \t      /* Update OLD for the registers used or set.  */\n@@ -2041,9 +2045,21 @@ insn_dead_p (x, needed, call_ok, notes)\n \treturn ! cc0_live;\n #endif\n       \n-      if (GET_CODE (r) == MEM && last_mem_set && ! MEM_VOLATILE_P (r)\n-\t  && rtx_equal_p (r, last_mem_set))\n-\treturn 1;\n+      if (GET_CODE (r) == MEM && ! MEM_VOLATILE_P (r))\n+\t{\n+\t  rtx temp;\n+\t  /* Walk the set of memory locations we are currently tracking\n+\t     and see if one is an identical match to this memory location.\n+\t     If so, this memory write is dead (remember, we're walking\n+\t     backwards from the end of the block to the start.  */\n+\t  temp = mem_set_list;\n+\t  while (temp)\n+\t    {\n+\t      if (rtx_equal_p (XEXP (temp, 0), r))\n+\t\treturn 1;\n+\t      temp = XEXP (temp, 1);\n+\t    }\n+\t}\n \n       while (GET_CODE (r) == SUBREG || GET_CODE (r) == STRICT_LOW_PART\n \t     || GET_CODE (r) == ZERO_EXTRACT)\n@@ -2290,21 +2306,39 @@ mark_set_1 (needed, dead, x, insn, significant)\n \t || GET_CODE (reg) == STRICT_LOW_PART)\n     reg = XEXP (reg, 0);\n \n-  /* If we are writing into memory or into a register mentioned in the\n-     address of the last thing stored into memory, show we don't know\n-     what the last store was.  If we are writing memory, save the address\n-     unless it is volatile.  */\n+  /* If this set is a MEM, then it kills any aliased writes. \n+     If this set is a REG, then it kills any MEMs which use the reg.  */\n   if (GET_CODE (reg) == MEM\n-      || (GET_CODE (reg) == REG\n-\t  && last_mem_set != 0 && reg_overlap_mentioned_p (reg, last_mem_set)))\n-    last_mem_set = 0;\n+      || GET_CODE (reg) == REG)\n+    {\n+      rtx temp = mem_set_list;\n+      rtx prev = NULL_RTX;\n+\n+      while (temp)\n+\t{\n+\t  if ((GET_CODE (reg) == MEM\n+\t       && output_dependence (XEXP (temp, 0), reg))\n+\t      || (GET_CODE (reg) == REG\n+\t\t  && reg_overlap_mentioned_p (reg, XEXP (temp, 0))))\n+\t    {\n+\t      /* Splice this entry out of the list.  */\n+\t      if (prev)\n+\t\tXEXP (prev, 1) = XEXP (temp, 1);\n+\t      else\n+\t\tmem_set_list = XEXP (temp, 1);\n+\t    }\n+\t  else\n+\t    prev = temp;\n+\t  temp = XEXP (temp, 1);\n+\t}\n+    }\n     \n   if (GET_CODE (reg) == MEM && ! side_effects_p (reg)\n       /* There are no REG_INC notes for SP, so we can't assume we'll see \n \t everything that invalidates it.  To be safe, don't eliminate any\n \t stores though SP; none of them should be redundant anyway.  */\n       && ! reg_mentioned_p (stack_pointer_rtx, reg))\n-    last_mem_set = reg;\n+    mem_set_list = gen_rtx_EXPR_LIST (VOIDmode, reg, mem_set_list);\n \n   if (GET_CODE (reg) == REG\n       && (regno = REGNO (reg), regno != FRAME_POINTER_REGNUM)\n@@ -2699,9 +2733,28 @@ mark_used_regs (needed, live, x, final, insn)\n \t something that can be stored into.  */\n       if (GET_CODE (XEXP (x, 0)) == SYMBOL_REF\n \t  && CONSTANT_POOL_ADDRESS_P (XEXP (x, 0)))\n-\t; /* needn't clear last_mem_set */\n+\t; /* needn't clear the memory set list */\n       else\n-\tlast_mem_set = 0;\n+\t{\n+\t  rtx temp = mem_set_list;\n+\t  rtx prev = NULL_RTX;\n+\n+\t  while (temp)\n+\t    {\n+\t      if (anti_dependence (XEXP (temp, 0), GET_MODE (x),\n+\t\t\t\t   x, rtx_addr_varies_p))\n+\t\t{\n+\t\t  /* Splice temp out of the list.  */\n+\t\t  if (prev)\n+\t\t    XEXP (prev, 1) = XEXP (temp, 1);\n+\t\t  else\n+\t\t    mem_set_list = XEXP (temp, 1);\n+\t\t}\n+\t      else\n+\t\tprev = temp;\n+\t      temp = XEXP (temp, 1);\n+\t    }\n+\t}\n \n #ifdef AUTO_INC_DEC\n       if (final)"}]}