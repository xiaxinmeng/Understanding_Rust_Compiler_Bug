{"sha": "d3ae802402b03e5df0518f1b71e0eeeff99ada28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhZTgwMjQwMmIwM2U1ZGYwNTE4ZjFiNzFlMGVlZWZmOTlhZGEyOA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-17T21:23:32Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2020-11-17T21:28:08Z"}, "message": "extend cache_integer_cst\n\nThis modules-related patch extends cache_integer_cst.  Currently, when\ngiven a small cst, that cst is added to the type's small and /must\nnot/ already be there.  Large values are fine if they are already in\nthe large cache.  This adds a parameter to indicate small duplicates\nare ok, and it returns the cached value -- either what was already\ntehre, or the newly inserted const.\n\n\tgcc/\n\t* tree.h (cache_integer_cst): Add defaulted might_duplicate parm.\n\t* tree.c (cache_integer_cst): Return the integer cst, add\n\tmight_duplicate parm to permit finding a small duplicate.", "tree": {"sha": "f84b089cf1b1b55e7d8b94ce53f856126bf596aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84b089cf1b1b55e7d8b94ce53f856126bf596aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3ae802402b03e5df0518f1b71e0eeeff99ada28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ae802402b03e5df0518f1b71e0eeeff99ada28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3ae802402b03e5df0518f1b71e0eeeff99ada28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3ae802402b03e5df0518f1b71e0eeeff99ada28/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e0da4aed176a8de042a8482beb65499e29448556", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0da4aed176a8de042a8482beb65499e29448556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0da4aed176a8de042a8482beb65499e29448556"}], "stats": {"total": 38, "additions": 28, "deletions": 10}, "files": [{"sha": "004385548c94bd854de828b5e9135f59ead371ff", "filename": "gcc/tree.c", "status": "modified", "additions": 27, "deletions": 9, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ae802402b03e5df0518f1b71e0eeeff99ada28/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ae802402b03e5df0518f1b71e0eeeff99ada28/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=d3ae802402b03e5df0518f1b71e0eeeff99ada28", "patch": "@@ -1755,8 +1755,15 @@ wide_int_to_tree (tree type, const poly_wide_int_ref &value)\n   return build_poly_int_cst (type, value);\n }\n \n-void\n-cache_integer_cst (tree t)\n+/* Insert INTEGER_CST T into a cache of integer constants.  And return\n+   the cached constant (which may or may not be T).  If MIGHT_DUPLICATE\n+   is false, and T falls into the type's 'smaller values' range, there\n+   cannot be an existing entry.  Otherwise, if MIGHT_DUPLICATE is true,\n+   or the value is large, should an existing entry exist, it is\n+   returned (rather than inserting T).  */\n+\n+tree\n+cache_integer_cst (tree t, bool might_duplicate ATTRIBUTE_UNUSED)\n {\n   tree type = TREE_TYPE (t);\n   int ix = -1;\n@@ -1770,7 +1777,7 @@ cache_integer_cst (tree t)\n   switch (TREE_CODE (type))\n     {\n     case NULLPTR_TYPE:\n-      gcc_assert (integer_zerop (t));\n+      gcc_checking_assert (integer_zerop (t));\n       /* Fallthru.  */\n \n     case POINTER_TYPE:\n@@ -1850,21 +1857,32 @@ cache_integer_cst (tree t)\n \t  TYPE_CACHED_VALUES (type) = make_tree_vec (limit);\n \t}\n \n-      gcc_assert (TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) == NULL_TREE);\n-      TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n+      if (tree r = TREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix))\n+\t{\n+\t  gcc_checking_assert (might_duplicate);\n+\t  t = r;\n+\t}\n+      else\n+\tTREE_VEC_ELT (TYPE_CACHED_VALUES (type), ix) = t;\n     }\n   else\n     {\n       /* Use the cache of larger shared ints.  */\n       tree *slot = int_cst_hash_table->find_slot (t, INSERT);\n-      /* If there is already an entry for the number verify it's the\n-         same.  */\n-      if (*slot)\n-\tgcc_assert (wi::to_wide (tree (*slot)) == wi::to_wide (t));\n+      if (tree r = *slot)\n+\t{\n+\t  /* If there is already an entry for the number verify it's the\n+\t     same value.  */\n+\t  gcc_checking_assert (wi::to_wide (tree (r)) == wi::to_wide (t));\n+\t  /* And return the cached value.  */\n+\t  t = r;\n+\t}\n       else\n \t/* Otherwise insert this one into the hash table.  */\n \t*slot = t;\n     }\n+\n+  return t;\n }\n \n "}, {"sha": "20f66a02403b98b5b0cb7873f610aea4f96d879e", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3ae802402b03e5df0518f1b71e0eeeff99ada28/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3ae802402b03e5df0518f1b71e0eeeff99ada28/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=d3ae802402b03e5df0518f1b71e0eeeff99ada28", "patch": "@@ -5124,7 +5124,7 @@ extern const_tree strip_invariant_refs (const_tree);\n extern tree lhd_gcc_personality (void);\n extern void assign_assembler_name_if_needed (tree);\n extern bool warn_deprecated_use (tree, tree);\n-extern void cache_integer_cst (tree);\n+extern tree cache_integer_cst (tree, bool might_duplicate = false);\n extern const char *combined_fn_name (combined_fn);\n \n /* Compare and hash for any structure which begins with a canonical"}]}