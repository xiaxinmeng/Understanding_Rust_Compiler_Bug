{"sha": "ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWMwODdiYTM0ZTNlNGY4Y2U2MGM4M2Q1Y2E3NTRjMTVhOWJkZjc4NQ==", "commit": {"author": {"name": "Nina Dinka Ranns", "email": "dinka.ranns@gmail.com", "date": "2019-04-28T21:17:50Z"}, "committer": {"name": "Ville Voutilainen", "email": "ville@gcc.gnu.org", "date": "2019-04-28T21:17:50Z"}, "message": "Adding noexcept-specification on tuple constructors (LWG 2899)\n\n2019-04-28 Nina Dinka Ranns <dinka.ranns@gmail.com>\n\n* libstdc++-v3/include/std/tuple:\n(tuple()): Add noexcept-specification.\n(tuple(const _Elements&...)): Likewise\n(tuple(_UElements&&...)): Likewise\n(tuple(const tuple<_UElements...>&)): Likewise\n(tuple(tuple<_UElements...>&&)): Likewise\n(tuple(const _T1&, const _T2&)): Likewise\n(tuple(_U1&&, _U2&&)): Likewise\n(tuple(const tuple<_U1, _U2>&): Likewise\n(tuple(tuple<_U1, _U2>&&): Likewise\n(tuple(const pair<_U1, _U2>&): Likewise\n(tuple(pair<_U1, _U2>&&): Likewise\n* libstdc++-v3/testsuite/20_util/tuple/cons/noexcept_specs.cc: New\n\nFrom-SVN: r270632", "tree": {"sha": "7b5001b31a96e4245932c185492a8a69709a694f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b5001b31a96e4245932c185492a8a69709a694f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/comments", "author": {"login": "NinaRanns", "id": 57705710, "node_id": "MDQ6VXNlcjU3NzA1NzEw", "avatar_url": "https://avatars.githubusercontent.com/u/57705710?v=4", "gravatar_id": "", "url": "https://api.github.com/users/NinaRanns", "html_url": "https://github.com/NinaRanns", "followers_url": "https://api.github.com/users/NinaRanns/followers", "following_url": "https://api.github.com/users/NinaRanns/following{/other_user}", "gists_url": "https://api.github.com/users/NinaRanns/gists{/gist_id}", "starred_url": "https://api.github.com/users/NinaRanns/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/NinaRanns/subscriptions", "organizations_url": "https://api.github.com/users/NinaRanns/orgs", "repos_url": "https://api.github.com/users/NinaRanns/repos", "events_url": "https://api.github.com/users/NinaRanns/events{/privacy}", "received_events_url": "https://api.github.com/users/NinaRanns/received_events", "type": "User", "site_admin": false}, "committer": {"login": "villevoutilainen", "id": 963599, "node_id": "MDQ6VXNlcjk2MzU5OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/963599?v=4", "gravatar_id": "", "url": "https://api.github.com/users/villevoutilainen", "html_url": "https://github.com/villevoutilainen", "followers_url": "https://api.github.com/users/villevoutilainen/followers", "following_url": "https://api.github.com/users/villevoutilainen/following{/other_user}", "gists_url": "https://api.github.com/users/villevoutilainen/gists{/gist_id}", "starred_url": "https://api.github.com/users/villevoutilainen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/villevoutilainen/subscriptions", "organizations_url": "https://api.github.com/users/villevoutilainen/orgs", "repos_url": "https://api.github.com/users/villevoutilainen/repos", "events_url": "https://api.github.com/users/villevoutilainen/events{/privacy}", "received_events_url": "https://api.github.com/users/villevoutilainen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b9a5a80c539f068d5674531e7f650fa0a88c552f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9a5a80c539f068d5674531e7f650fa0a88c552f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9a5a80c539f068d5674531e7f650fa0a88c552f"}], "stats": {"total": 999, "additions": 999, "deletions": 0}, "files": [{"sha": "15020ee66646601b52cf432a98a3e42e6348344f", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "patch": "@@ -1,3 +1,20 @@\n+2019-04-28 Nina Dinka Ranns <dinka.ranns@gmail.com>\n+\n+\tAdding noexcept-specification on tuple constructors (LWG 2899)\n+\t* libstdc++-v3/include/std/tuple:\n+\t(tuple()): Add noexcept-specification.\n+\t(tuple(const _Elements&...)): Likewise\n+\t(tuple(_UElements&&...)): Likewise\n+\t(tuple(const tuple<_UElements...>&)): Likewise\n+\t(tuple(tuple<_UElements...>&&)): Likewise\n+\t(tuple(const _T1&, const _T2&)): Likewise\n+\t(tuple(_U1&&, _U2&&)): Likewise\n+\t(tuple(const tuple<_U1, _U2>&): Likewise\n+\t(tuple(tuple<_U1, _U2>&&): Likewise\n+\t(tuple(const pair<_U1, _U2>&): Likewise\n+\t(tuple(pair<_U1, _U2>&&): Likewise\n+\t* libstdc++-v3/testsuite/20_util/tuple/cons/noexcept_specs.cc: New\n+\n 2019-04-27  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR libstdc++/87106"}, {"sha": "fba28f963cd7180b65b06ea138d0b91ab98fb250", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "patch": "@@ -552,13 +552,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return\n \t    __and_<is_nothrow_assignable<_Elements&, _UElements>...>::value;\n \t}\n+      template<typename... _UElements>\n+\tstatic constexpr bool __nothrow_constructible()\n+\t{\n+\t  return\n+\t    __and_<is_nothrow_constructible<_Elements, _UElements>...>::value;\n+\t}\n \n     public:\n       template<typename _Dummy = void,\n                typename enable_if<_TC2<_Dummy>::\n                                     _ImplicitlyDefaultConstructibleTuple(),\n                                   bool>::type = true>\n       constexpr tuple()\n+      noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n       : _Inherited() { }\n \n       template<typename _Dummy = void,\n@@ -569,6 +576,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                                     _ImplicitlyDefaultConstructibleTuple(),\n                                   bool>::type = false>\n       explicit constexpr tuple()\n+      noexcept(__and_<is_nothrow_default_constructible<_Elements>...>::value)\n       : _Inherited() { }\n \n       // Shortcut for the cases where constructors taking _Elements...\n@@ -586,6 +594,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                  && (sizeof...(_Elements) >= 1),\n                bool>::type=true>\n         constexpr tuple(const _Elements&... __elements)\n+        noexcept(__nothrow_constructible<const _Elements&...>())\n       : _Inherited(__elements...) { }\n \n       template<typename _Dummy = void,\n@@ -597,6 +606,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                  && (sizeof...(_Elements) >= 1),\n                bool>::type=false>\n       explicit constexpr tuple(const _Elements&... __elements)\n+      noexcept(__nothrow_constructible<const _Elements&...>())\n       : _Inherited(__elements...) { }\n \n       // Shortcut for the cases where constructors taking _UElements...\n@@ -624,6 +634,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                   && (sizeof...(_Elements) >= 1),\n         bool>::type=true>\n         constexpr tuple(_UElements&&... __elements)\n+        noexcept(__nothrow_constructible<_UElements...>())\n         : _Inherited(std::forward<_UElements>(__elements)...) { }\n \n       template<typename... _UElements, typename\n@@ -635,6 +646,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                   && (sizeof...(_Elements) >= 1),\n         bool>::type=false>\n         explicit constexpr tuple(_UElements&&... __elements)\n+        noexcept(__nothrow_constructible<_UElements...>())\n \t: _Inherited(std::forward<_UElements>(__elements)...) {\t}\n \n       constexpr tuple(const tuple&) = default;\n@@ -656,6 +668,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _NonNestedTuple<const tuple<_UElements...>&>(),\n         bool>::type=true>\n         constexpr tuple(const tuple<_UElements...>& __in)\n+        noexcept(__nothrow_constructible<const _UElements&...>())\n         : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n         { }\n \n@@ -668,6 +681,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _NonNestedTuple<const tuple<_UElements...>&>(),\n         bool>::type=false>\n         explicit constexpr tuple(const tuple<_UElements...>& __in)\n+        noexcept(__nothrow_constructible<const _UElements&...>())\n         : _Inherited(static_cast<const _Tuple_impl<0, _UElements...>&>(__in))\n         { }\n \n@@ -680,6 +694,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=true>\n         constexpr tuple(tuple<_UElements...>&& __in)\n+        noexcept(__nothrow_constructible<_UElements...>())\n         : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n       template<typename... _UElements, typename _Dummy = void, typename\n@@ -691,6 +706,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _NonNestedTuple<tuple<_UElements...>&&>(),\n         bool>::type=false>\n         explicit constexpr tuple(tuple<_UElements...>&& __in)\n+        noexcept(__nothrow_constructible<_UElements...>())\n         : _Inherited(static_cast<_Tuple_impl<0, _UElements...>&&>(__in)) { }\n \n       // Allocator-extended constructors.\n@@ -908,6 +924,13 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\tis_nothrow_assignable<_T2&, _U2>>::value;\n \t}\n \n+      template<typename _U1, typename _U2>\n+    static constexpr bool __nothrow_constructible()\n+    {\n+      return __and_<is_nothrow_constructible<_T1, _U1>,\n+\t\t\tis_nothrow_constructible<_T2, _U2>>::value;\n+    }\n+\n     public:\n       template <typename _U1 = _T1,\n                 typename _U2 = _T2,\n@@ -916,6 +939,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                                      __is_implicitly_default_constructible<_U2>>\n                                    ::value, bool>::type = true>\n \tconstexpr tuple()\n+\tnoexcept(__and_<is_nothrow_default_constructible<_T1>,\n+\t\t\tis_nothrow_default_constructible<_T2>>::value)\n \t: _Inherited() { }\n \n       template <typename _U1 = _T1,\n@@ -929,6 +954,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                              __is_implicitly_default_constructible<_U2>>>>\n                   ::value, bool>::type = false>\n \texplicit constexpr tuple()\n+\tnoexcept(__and_<is_nothrow_default_constructible<_T1>,\n+\t\t\tis_nothrow_default_constructible<_T2>>::value)\n \t: _Inherited() { }\n \n       // Shortcut for the cases where constructors taking _T1, _T2\n@@ -943,6 +970,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                            _ImplicitlyConvertibleTuple<_T1, _T2>(),\n \tbool>::type = true>\n         constexpr tuple(const _T1& __a1, const _T2& __a2)\n+        noexcept(__nothrow_constructible<const _T1&, const _T2&>())\n         : _Inherited(__a1, __a2) { }\n \n       template<typename _Dummy = void, typename\n@@ -952,6 +980,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                            _ImplicitlyConvertibleTuple<_T1, _T2>(),\n \tbool>::type = false>\n         explicit constexpr tuple(const _T1& __a1, const _T2& __a2)\n+        noexcept(__nothrow_constructible<const _T1&, const _T2&>())\n         : _Inherited(__a1, __a2) { }\n \n       // Shortcut for the cases where constructors taking _U1, _U2\n@@ -966,6 +995,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n \tbool>::type = true>\n         constexpr tuple(_U1&& __a1, _U2&& __a2)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -976,6 +1006,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t          && !is_same<__remove_cvref_t<_U1>, allocator_arg_t>::value,\n \tbool>::type = false>\n         explicit constexpr tuple(_U1&& __a1, _U2&& __a2)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__a1), std::forward<_U2>(__a2)) { }\n \n       constexpr tuple(const tuple&) = default;\n@@ -989,6 +1020,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyConvertibleTuple<_U1, _U2>(),\n \tbool>::type = true>\n         constexpr tuple(const tuple<_U1, _U2>& __in)\n+        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -998,6 +1030,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyConvertibleTuple<_U1, _U2>(),\n \tbool>::type = false>\n         explicit constexpr tuple(const tuple<_U1, _U2>& __in)\n+        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(static_cast<const _Tuple_impl<0, _U1, _U2>&>(__in)) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -1007,6 +1040,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n \tbool>::type = true>\n         constexpr tuple(tuple<_U1, _U2>&& __in)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -1016,6 +1050,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n \tbool>::type = false>\n         explicit constexpr tuple(tuple<_U1, _U2>&& __in)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(static_cast<_Tuple_impl<0, _U1, _U2>&&>(__in)) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -1025,6 +1060,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyConvertibleTuple<_U1, _U2>(),\n \tbool>::type = true>\n         constexpr tuple(const pair<_U1, _U2>& __in)\n+        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(__in.first, __in.second) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -1034,6 +1070,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyConvertibleTuple<_U1, _U2>(),\n \tbool>::type = false>\n         explicit constexpr tuple(const pair<_U1, _U2>& __in)\n+        noexcept(__nothrow_constructible<const _U1&, const _U2&>())\n \t: _Inherited(__in.first, __in.second) { }\n \n       template<typename _U1, typename _U2, typename\n@@ -1043,6 +1080,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n \tbool>::type = true>\n         constexpr tuple(pair<_U1, _U2>&& __in)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n \n@@ -1053,6 +1091,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n                     _ImplicitlyMoveConvertibleTuple<_U1, _U2>(),\n \tbool>::type = false>\n         explicit constexpr tuple(pair<_U1, _U2>&& __in)\n+        noexcept(__nothrow_constructible<_U1, _U2>())\n \t: _Inherited(std::forward<_U1>(__in.first),\n \t\t     std::forward<_U2>(__in.second)) { }\n "}, {"sha": "da9ef1c26b2c1854bc30579fb77dfbf129a9ac87", "filename": "libstdc++-v3/testsuite/20_util/tuple/cons/noexcept_specs.cc", "status": "added", "additions": 943, "deletions": 0, "changes": 943, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Ftuple%2Fcons%2Fnoexcept_specs.cc?ref=ec087ba34e3e4f8ce60c83d5ca754c15a9bdf785", "patch": "@@ -0,0 +1,943 @@\n+//{ dg-do run { target c++11 } }\n+\n+// 2019-04-10  Nina Dinka Ranns  <dinka.ranns@gmail.com>\n+//\n+// Copyright (C) 2019 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <tuple>\n+#include <testsuite_tr1.h>\n+#include <utility>\n+\n+using namespace __gnu_test;\n+\n+bool throwing_ctor_called = false;\n+\n+namespace test_trait{\n+   template <bool B>\n+   using bool_constant = std::integral_constant<bool, B>;\n+\n+   template<typename From, typename To,\n+           bool = std::__or_<std::is_void<From>, std::is_function<To>,\n+\t\t   std::is_array<To>>::value>\n+    struct is_nt_convertible_helper\n+    : std::is_void<To>\n+    { };\n+\n+  template<typename From, typename To>\n+    class is_nt_convertible_helper<From, To, false>\n+    {\n+      template<typename To1>\n+\tstatic void test_aux(To1) noexcept;\n+\n+      template<typename From1, typename To1>\n+\tstatic bool_constant<noexcept(test_aux<To1>({std::declval<From1>()}))>\n+\ttest(int);\n+\n+      template<typename, typename>\n+\tstatic std::false_type\n+\ttest(...);\n+\n+    public:\n+      using type = decltype(test<From, To>(0));\n+    };\n+\n+  /// is_nothrow_convertible\n+  template<typename From, typename To>\n+    struct is_nothrow_convertible\n+    : public is_nt_convertible_helper<From, To>::type\n+    { };\n+}\n+\n+template<typename T>\n+bool  checkDefaultThrowConstruct()\n+{\n+  throwing_ctor_called = false;\n+  bool deduced_nothrow = std::is_nothrow_constructible<T>::value;\n+  T t{};\n+  return throwing_ctor_called != deduced_nothrow;\n+}\n+template<typename T, typename U>\n+bool  checkCopyThrowConstruct()\n+{\n+  throwing_ctor_called = false;\n+  bool deduced_nothrow = std::is_nothrow_constructible<T, U&>::value;\n+  U u;\n+  T t{u};\n+  return throwing_ctor_called != deduced_nothrow;\n+}\n+template<typename T, typename U>\n+bool  checkMoveThrowConstruct()\n+{\n+  throwing_ctor_called = false;\n+  bool deduced_nothrow = std::is_nothrow_constructible<T, U&&>::value;\n+  U u;\n+  T t{std::move(u)};\n+  return throwing_ctor_called != deduced_nothrow;\n+}\n+\n+typedef std::tuple<int> IT;\n+typedef std::tuple<const int> CIT;\n+typedef std::tuple<int&&> RVIT;\n+typedef std::tuple<int, int> IIT;\n+typedef std::pair<int, int> IIP;\n+typedef std::tuple<int, int, int> IIIT;\n+\n+namespace DefaultConstructionTests\n+{\n+  struct NoexceptDC\n+  {\n+    NoexceptDC() noexcept(true){}\n+  };\n+\n+  struct ExceptDC\n+  {\n+    ExceptDC() noexcept(false)\n+      {  throwing_ctor_called = true; }\n+  };\n+\n+  struct ExplicitNoexceptDC\n+  {\n+    explicit ExplicitNoexceptDC() noexcept(true)\n+        {}\n+  };\n+\n+  struct ExplicitExceptDC\n+  {\n+    explicit ExplicitExceptDC() noexcept(false)\n+        {  throwing_ctor_called = true; }\n+  };\n+\n+  typedef std::tuple<NoexceptDC> NDT;\n+  typedef std::tuple<ExceptDC> EDT;\n+  typedef std::tuple<ExplicitNoexceptDC> X_NDT;\n+  typedef std::tuple<ExplicitExceptDC> X_EDT;\n+\n+  typedef std::tuple<NoexceptDC,NoexceptDC> NNDT;\n+  typedef std::tuple<ExceptDC,ExceptDC> EEDT;\n+  typedef std::tuple<ExceptDC,NoexceptDC> ENDT;\n+  typedef std::tuple<ExplicitNoexceptDC,NoexceptDC> X_NNDT;\n+  typedef std::tuple<ExplicitExceptDC,ExceptDC> X_EEDT;\n+  typedef std::tuple<ExceptDC,ExplicitNoexceptDC> X_ENDT;\n+\n+  typedef std::tuple<long, NoexceptDC, NoexceptDC> LNDNDT;\n+  typedef std::tuple<long, NoexceptDC, ExceptDC> LNDEDT;\n+  typedef std::tuple<long, ExplicitNoexceptDC, NoexceptDC> X_LNEDNDT;\n+  typedef std::tuple<long, ExplicitNoexceptDC, ExceptDC> X_LNEDEDT;\n+  typedef std::tuple<long, ExplicitExceptDC, ExceptDC> X_LEEDEDT;\n+\n+\n+  /* if it has E in the name, it contains a type that throws when default constructed */\n+  static_assert(std::is_nothrow_constructible<IT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<NDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<EDT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<X_NDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<X_EDT>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<NNDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<EEDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<ENDT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<X_NNDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<X_EEDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<X_ENDT>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIIT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<LNDNDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<LNDEDT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<X_LNEDNDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<X_LNEDEDT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<X_LEEDEDT>::value, \"\");\n+\n+  void Run()\n+  {\n+    VERIFY( checkDefaultThrowConstruct<IT>() );\n+    VERIFY( checkDefaultThrowConstruct<NDT>() );\n+    VERIFY( checkDefaultThrowConstruct<EDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_NDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_EDT>() );\n+\n+    VERIFY( checkDefaultThrowConstruct<IIT>() );\n+    VERIFY( checkDefaultThrowConstruct<NNDT>() );\n+    VERIFY( checkDefaultThrowConstruct<EEDT>() );\n+    VERIFY( checkDefaultThrowConstruct<ENDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_NNDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_EEDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_ENDT>() );\n+\n+    VERIFY( checkDefaultThrowConstruct<IIIT>() );\n+    VERIFY( checkDefaultThrowConstruct<LNDNDT>() );\n+    VERIFY( checkDefaultThrowConstruct<LNDEDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_LNEDNDT>() );\n+    VERIFY( checkDefaultThrowConstruct<X_LNEDEDT>() );\n+  }\n+}\n+namespace AllNoThrow\n+{\n+  static_assert(std::is_nothrow_constructible<IT, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IT, const int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IT, int&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IT, const int&&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IT, IT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IT, const IT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IT, CIT>::value, \"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<int&, IT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const int&, IT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<int&&, IT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const int&&, IT>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIT, int&, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, const int&, const int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, int&&, int&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, const int&&, const int&&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIT, IIT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, const IIT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, IIP>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIT, const IIP>::value, \"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIT, IIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIT &, IIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIP, IIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIP, IIT>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIIT, IIIT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, const IIIT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, IIIT&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, const IIIT&&>::value, \"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIIT&, IIIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIIT &, IIIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIIT&&, IIIT>::value, \"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIIT&&, IIIT>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IIIT, int&, int&, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, const int&, const int&, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, int&&, int&&, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IIIT, const int&&, const int&&, int&>::value, \"\");\n+}\n+namespace ThrowCopyNothrowConversion\n+{\n+  struct A\n+  {\n+    A() noexcept(true)\n+        {}\n+\n+    A(const int&) noexcept(true)\n+      {}\n+\n+    A(const A&) noexcept(false)\n+      {  throwing_ctor_called = true; }\n+\n+  };\n+\n+  typedef std::tuple<A> AT;\n+  typedef std::tuple<A,A> AAT;\n+  typedef std::pair<A,A> AAP;\n+  typedef std::tuple<int,A> IAT;\n+  typedef std::pair<int,A> IAP;\n+  typedef std::tuple<A,A,A> AAAT;\n+  typedef std::tuple<int,int,A> IIAT;\n+\n+/* one element tests */\n+  static_assert(std::is_nothrow_constructible<AT,int>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,const int>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,int&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,const int &>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<AT,IT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,const IT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,IT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,const IT &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,std::tuple<int&>>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AT,const std::tuple<int&&>>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<int,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const int,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<int&,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const int &,AT>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IT,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IT,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IT&,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IT &,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<std::tuple<int&>,AT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const std::tuple<int&&>,AT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<AT,A>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,const A>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,A&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,const A &>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<AT,AT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,const AT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,AT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,const AT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,std::tuple<A&>>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AT,const std::tuple<A&&>>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<A,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const A,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<A&,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const A &,AT>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<AT,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AT,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<AT&,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AT &,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<A&>,AT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const std::tuple<A&&>,AT>::value,\"\");\n+\n+/* two element tests */\n+\n+  static_assert(std::is_nothrow_constructible<AAT,IIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,const IIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,IIT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,const IIT &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,IIP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,const IIP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,IIP&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,const IIP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,std::tuple<int&,int&>>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIT,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIT,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIT&,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIT &,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIP,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIP,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIP&,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIP &,AAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<std::tuple<int&,int&>,AAT>::value,\"\");\n+\n+\n+  static_assert(!std::is_nothrow_constructible<AAT,AAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const AAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,AAT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const AAT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,AAP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const AAP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,AAP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const AAP &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,std::tuple<A&,A&>>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<AAT,IAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const IAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,IAT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const IAT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,IAP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const IAP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,IAP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const IAP &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,std::tuple<A&,int&>>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<AAT,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AAT,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<AAT&,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AAT &,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<AAP,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AAP,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<AAP&,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const AAP &,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<A&,A&>,AAT>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<IAT,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IAT,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IAT&,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IAT &,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IAP,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IAP,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IAP&,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IAP &,AAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<A&,int&>,AAT>::value,\"\");\n+\n+\n+  static_assert(std::is_nothrow_constructible<AAT,int&,const int&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAT,int&&,const int&&>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<AAT,A&,const A&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,A&&,const A&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAT,const A &&,const int&&>::value,\"\");\n+\n+/* three element tests */\n+  static_assert(std::is_nothrow_constructible<AAAT,IIIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAAT,const IIIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAAT,IIIT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<AAAT,const IIIT &>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIIT,AAAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIIT,AAAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIIT&,AAAT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const IIIT &,AAAT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<AAAT,IIAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAAT,const IIAT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAAT,IIAT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAAT,const IIAT &>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<IIAT,AAAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIAT,AAAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IIAT&,AAAT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIAT &,AAAT>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<AAAT,int&,const int&,int&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<AAAT,int &,const A &&,const int&&>::value,\"\");\n+\n+  void Run()\n+  {\n+    VERIFY( (checkCopyThrowConstruct<AT,int>()) );\n+    VERIFY( (checkMoveThrowConstruct<AT,int>()) );\n+    VERIFY( (checkCopyThrowConstruct<AT,A>()) );\n+    VERIFY( (checkMoveThrowConstruct<AT,A>()) );\n+    VERIFY( (checkCopyThrowConstruct<AT,AT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AT,AT>()) );\n+    VERIFY( (checkCopyThrowConstruct<AT,IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AT,IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AT,CIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<AAT,AAT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAT,AAT>()) );\n+    VERIFY( (checkCopyThrowConstruct<AAT,IIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAT,IIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<AAT,IIP>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAT,IIP>()) );\n+\n+    VERIFY( (checkCopyThrowConstruct<AAT,std::tuple<int,A>>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAT,std::tuple<int,A>>()) );\n+    VERIFY( (checkCopyThrowConstruct<AAT,std::pair<int,A>>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAT,std::pair<int,A>>()) );\n+\n+    VERIFY( (checkCopyThrowConstruct<AAAT,AAAT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAAT,AAAT>()) );\n+    VERIFY( (checkCopyThrowConstruct<AAAT,IIAT>()) );\n+    VERIFY( (checkMoveThrowConstruct<AAAT,IIAT>()) );\n+  }\n+}\n+namespace NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion\n+{\n+  struct B\n+  {\n+    B() noexcept(true)\n+        {}\n+\n+    B(const int&) noexcept(false)\n+      {  throwing_ctor_called = true; }\n+\n+    B(int&&) noexcept(true)\n+      {}\n+\n+    B(const B&) noexcept(true)\n+      {}\n+\n+    B(B&&) noexcept(false)\n+      {  throwing_ctor_called = true; }\n+  };\n+\n+\n+  struct D\n+  {\n+    D() noexcept(true)\n+        {}\n+\n+    explicit\n+    D(const int&) noexcept(false)\n+    {  throwing_ctor_called = true; }\n+\n+    explicit\n+    D(int&&) noexcept(true)\n+        {}\n+\n+    explicit\n+    D(const D&) noexcept(true)\n+      {}\n+\n+    explicit\n+    D(D&&) noexcept(false)\n+    {  throwing_ctor_called = true; }\n+\n+  };\n+\n+  typedef std::tuple<B> BT;\n+  typedef std::tuple<B,B> BBT;\n+  typedef std::pair<B,B> BBP;\n+  typedef std::tuple<D> DT;\n+  typedef std::tuple<D,D> DDT;\n+  typedef std::pair<D,D> DDP;\n+  typedef std::tuple<int,D> IDT;\n+  typedef std::pair<int,D> IDP;\n+  typedef std::tuple<int,B> IBT;\n+  typedef std::pair<int,B> IBP;\n+  typedef std::tuple<D,B> DBT;\n+  typedef std::pair<D,B> DBP;\n+  typedef std::tuple<B,B,B> BBBT;\n+  typedef std::tuple<D,D,D> DDDT;\n+  typedef std::tuple<int,D,int> IDIT;\n+  typedef std::tuple<int,B,int> IBIT;\n+  typedef std::tuple<int,D,B> IDBT;\n+\n+/* one element tests */\n+  static_assert(std::is_nothrow_constructible<BT, int>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, const int>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, int&>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, const int &>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<BT, IT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT,const IT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, IT&>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, const IT &>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, std::tuple<int&>>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<BT, const std::tuple<int&&>>::value, \"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<int,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const int,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<int&,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const int &,BT>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IT,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IT,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IT&,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IT &,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<int&>,BT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const std::tuple<int&&>,BT>::value,\"\");\n+\n+\n+  static_assert(!std::is_nothrow_constructible<BT, B>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT,const B>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, B&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, const B &>::value, \"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BT, BT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT,const BT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, BT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, const BT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, std::tuple<B&>>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<BT, const std::tuple<B&&>>::value, \"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<B,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const B,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<B&,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const B &,BT>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<BT,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BT,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<BT&,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BT &,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<std::tuple<B&>,BT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const std::tuple<B&&>,BT>::value,\"\");\n+\n+/* explicit */\n+  static_assert(std::is_nothrow_constructible<DT, int>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, const int>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, int&>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, const int &>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<DT, IT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT,const IT>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, IT&>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, const IT &>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, std::tuple<int&>>::value, \"\");\n+  static_assert(!std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DT, D>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT,const D>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, D&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const D &>::value, \"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DT, DT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT,const DT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, DT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const DT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, std::tuple<D&>>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const std::tuple<D&&>>::value, \"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<DT,DT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DT,DT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<DT&,DT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DT &,DT>::value,\"\");\n+\n+/* two elements tests */\n+  static_assert(std::is_nothrow_constructible<BBT,IIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,IIT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IIT &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,IIP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IIP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,IIP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IIP &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,std::tuple<int&,int&>>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIT,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIT,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IIT&,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIT &,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IIP,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIP,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IIP&,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIP &,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<int&,int&>,BBT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BBT,BBT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,const BBT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,BBT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,const BBT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,BBP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,const BBP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,BBP&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,const BBP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,std::tuple<B&,B&>>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BBT,IBT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IBT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,IBT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IBT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,IBP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IBP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,IBP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const IBP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,std::tuple<const B&,int&&>>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<BBT,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBT,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<BBT&,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBT &,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<BBP,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBP,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<BBP&,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBP &,BBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<std::tuple<B&,int&&>,BBT>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<IBT,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IBT,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IBT&,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IBT &,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IBP,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IBP,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IBP&,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IBP &,BBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<std::tuple<B&,int&>,BBT>::value,\"\");\n+\n+\n+  static_assert(!std::is_nothrow_constructible<BBT,int&,const int&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBT,int&&,const B&>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<BBT,B&,const B&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,B&&,const B&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBT,const B &&,const int&&>::value,\"\");\n+\n+/* explicit */\n+  static_assert(std::is_nothrow_constructible<DDT,IIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IIT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IIT &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,IIP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IIP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IIP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IIP &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,std::tuple<int&,int&>>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDT,DDT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const DDT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,DDT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const DDT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,DDP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const DDP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,DDP&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const DDP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,std::tuple<D&,D&>>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDT,IDT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IDT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IDT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IDT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IDP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IDP>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IDP&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const IDP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,std::tuple<const D&,int&&>>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<DDT,DDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DDT,DDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<DDT&,DDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DDT &,DDT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDT,int&,const int&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,int&&,const D&>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<DDT,D&,const D&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,D&&,const D&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,const D &&,const int&&>::value,\"\");\n+\n+/* three elements tests */\n+  static_assert(std::is_nothrow_constructible<BBBT,IIIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBBT,const IIIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBBT,IIIT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBBT,const IIIT &>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IIIT,BBBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIIT,BBBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<IIIT&,BBBT>::value,\"\");\n+  static_assert(!test_trait::is_nothrow_convertible<const IIIT &,BBBT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BBBT,BBBT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBBT,const BBBT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBBT,BBBT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBBT,const BBBT &>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<BBBT,BBBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBBT,BBBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<BBBT&,BBBT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const BBBT &,BBBT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BBBT,int&,const int&,int&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBBT,int&, B&&,const int&&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBBT,int&&, B&,const B&&>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<BBBT,std::tuple<int&,const int&,int&&>>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<BBBT,std::tuple<int &, B&&,const int&&>>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<BBBT,std::tuple<int &&, B&,const B&&>>::value,\"\");\n+\n+/* explicit */\n+  static_assert(std::is_nothrow_constructible<DDDT,IIIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDDT,const IIIT>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDDT,IIIT&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDDT,const IIIT &>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDDT,DDDT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDDT,const DDDT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDDT,DDDT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDDT,const DDDT &>::value,\"\");\n+\n+  static_assert(!test_trait::is_nothrow_convertible<DDDT,DDDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DDDT,DDDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<DDDT&,DDDT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<const DDDT &,DDDT>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDDT,int&,const int&,int&&>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDDT,int &, D&&,const int&&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDDT,int &&, D&,const D&&>::value,\"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DDDT,std::tuple<int&,const int&,int&&>>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDDT,std::tuple<int &, D&&,const int&&>>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDDT,std::tuple<int &&, D&,const D&&>>::value,\"\");\n+\n+\n+  void Run()\n+  {\n+    VERIFY( (checkCopyThrowConstruct<BT, int>()) );\n+    VERIFY( (checkMoveThrowConstruct<BT, int>()) );\n+    VERIFY( (checkCopyThrowConstruct<BT, B>()) );\n+    VERIFY( (checkMoveThrowConstruct<BT, B>()) );\n+    VERIFY( (checkCopyThrowConstruct<BT, IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<BT, IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<BT, CIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<BBT, IIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<BBT, IIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<BBT, IIP>()) );\n+    VERIFY( (checkMoveThrowConstruct<BBT, IIP>()) );\n+    VERIFY( (checkCopyThrowConstruct<BBT, BBP>()) );\n+    VERIFY( (checkMoveThrowConstruct<BBT, BBP>()) );\n+    VERIFY( (checkCopyThrowConstruct<BBT, std::tuple<B, int>>()) );\n+    VERIFY( (checkMoveThrowConstruct<BBT, std::tuple<B, int>>()) );\n+\n+    VERIFY( (checkCopyThrowConstruct<DT, int>()) );\n+    VERIFY( (checkMoveThrowConstruct<DT, int>()) );\n+    VERIFY( (checkCopyThrowConstruct<DT, D>()) );\n+    VERIFY( (checkMoveThrowConstruct<DT, D>()) );\n+    VERIFY( (checkCopyThrowConstruct<DT, IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DT, IT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DT, CIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<DDT, IIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, IIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<DDT, IIP>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, IIP>()) );\n+    VERIFY( (checkCopyThrowConstruct<DDT, DDP>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, DDP>()) );\n+    VERIFY( (checkCopyThrowConstruct<DDT, std::tuple<D, int>>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, std::tuple<D, int>>()) );\n+\n+    VERIFY( (checkCopyThrowConstruct<DBT, IIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DBT, IIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<DBT, DBT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DBT, DBT>()) );\n+    VERIFY( (checkCopyThrowConstruct<DBT, DBP>()) );\n+    VERIFY( (checkMoveThrowConstruct<DBT, DBP>()) );\n+    VERIFY( (checkCopyThrowConstruct<DBT, IIP>()) );\n+    VERIFY( (checkMoveThrowConstruct<DBT, IIP>()) );\n+\n+\n+    VERIFY( (checkCopyThrowConstruct<IDIT, IIIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IDIT, IIIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<IDIT, IDIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IDIT, IDIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<IBIT, IIIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IBIT, IIIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<IBIT, IBIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IBIT, IBIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<IDBT, IIIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IDBT, IIIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<IDBT, IDBT>()) );\n+    VERIFY( (checkMoveThrowConstruct<IDBT, IDBT>()) );\n+\n+  }\n+}\n+namespace ThrowCopy\n+{\n+  struct C\n+  {\n+    C() noexcept(true)\n+       {}\n+\n+    explicit\n+    C(const C&) noexcept(true) {}\n+\n+  };\n+\n+  typedef std::tuple<C> CT;\n+  typedef std::tuple<C,C> CCT;\n+  typedef std::pair<C,C> CCP;\n+  typedef std::tuple<int,int,C> IICT;\n+\n+  static_assert(std::is_nothrow_constructible<CT, C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, const C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, C&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, const C &&>::value, \"\");\n+\n+\n+  static_assert(std::is_nothrow_constructible<CCT, C&, C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const C&, const C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, C&&, C&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const C &&, const C &&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IICT, int, int, C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, int, int, const C&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, int, int, C&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, int, int, const C &&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<CT, CT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, const CT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, CT&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CT, const CT &&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<CCT, CCT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const CCT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, CCT&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const CCT &&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<CCT, CCP&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const CCP&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, CCP&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<CCT, const CCP &&>::value, \"\");\n+\n+  static_assert(std::is_nothrow_constructible<IICT, IICT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, const IICT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, IICT&&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<IICT, const IICT &&>::value, \"\");\n+\n+}\n+namespace ThrowMoveNothrowConversion\n+{\n+  struct D\n+  {\n+  D() noexcept(true)\n+  {}\n+\n+  explicit\n+  D(const int&) noexcept(true)\n+  {}\n+\n+  explicit\n+  D(int&&) noexcept(false)\n+  {  throwing_ctor_called = true; }\n+\n+  };\n+\n+  typedef std::tuple<D> DT;\n+  typedef std::tuple<D,D> DDT;\n+  typedef std::pair<D,D> DDP;\n+  typedef std::tuple<int,D,int> IDIT;\n+\n+\n+  static_assert(!std::is_nothrow_constructible<DT, int>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const int>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, int&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const int &>::value, \"\");\n+\n+  static_assert(!std::is_nothrow_constructible<DT, IT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT,const IT>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, IT&>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const IT &>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, std::tuple<int&>>::value, \"\");\n+  static_assert(std::is_nothrow_constructible<DT, const std::tuple<int&&>>::value, \"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<DT,DT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<D,DT>::value,\"\");\n+\n+/* two elements tests */\n+  static_assert(!std::is_nothrow_constructible<DDT,IIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const IIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,IIT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const IIT &>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,IIP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const IIP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,IIP&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,const IIP &>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,std::tuple<int&,int&>>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<DDT,DDT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,DDP>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<DDT,std::tuple<int&,D>>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<DDT,std::pair<D,int&&>>::value,\"\");\n+\n+  static_assert(std::is_convertible<DDT,DDT>::value,\"\");\n+\n+/* three elements tests */\n+  static_assert(!std::is_nothrow_constructible<IDIT,IIIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<IDIT,const IIIT>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<IDIT,IIIT&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<IDIT,const IIIT &>::value,\"\");\n+\n+  static_assert(test_trait::is_nothrow_convertible<IDIT,IDIT>::value,\"\");\n+  static_assert(test_trait::is_nothrow_convertible<IDIT,IDIT>::value,\"\");\n+\n+  static_assert(std::is_nothrow_constructible<IDIT,int&,const int&,int&&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<IDIT,int &, D&&,const int&&>::value,\"\");\n+  static_assert(std::is_nothrow_constructible<IDIT,std::tuple<int&,const int&,int&&>>::value,\"\");\n+  static_assert(!std::is_nothrow_constructible<IDIT,std::tuple<int &, int&&,const int&&>>::value,\"\");\n+\n+  void Run()\n+  {\n+    VERIFY( (checkCopyThrowConstruct<DDT, IIT>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, IIT>()) );\n+    VERIFY( (checkCopyThrowConstruct<DDT, std::tuple<D, int>>()) );\n+    VERIFY( (checkMoveThrowConstruct<DDT, std::tuple<D, int>>()) );\n+  }\n+}\n+\n+int main()\n+{\n+\n+  DefaultConstructionTests::Run();\n+\n+  ThrowCopyNothrowConversion::Run();\n+\n+  NothrowCopyThrowMoveThrowCopyConversionNothrowMoveConversion::Run();\n+\n+  ThrowMoveNothrowConversion::Run();\n+\n+}\n+"}]}