{"sha": "c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "node_id": "C_kwDOANBUbNoAKGM4NGU3ZDlkYjJkMzNiNzY4NGIwYTZiNGIzYWI5ZDU1NDBhZGFjMjc", "commit": {"author": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2023-06-13T18:14:27Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2023-06-14T08:26:31Z"}, "message": "gccrs: fortify resolve_method_address to match the types\n\nFixes #2019\n\ngcc/rust/ChangeLog:\n\n\t* backend/rust-compile-base.cc (HIRCompileBase::resolve_method_address):\n\tmatch the fntype to the candidate\n\ngcc/testsuite/ChangeLog:\n\n\t* rust/compile/issue-2019-2.rs: New test.\n\t* rust/compile/issue-2019-3.rs: New test.\n\nSigned-off-by: Philip Herron <herron.philip@googlemail.com>", "tree": {"sha": "9ed80010d9c2beb09c200f1ef5104532780ed00c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9ed80010d9c2beb09c200f1ef5104532780ed00c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c021eef8aa73cc0a3a4e992018cab414a17db4c8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c021eef8aa73cc0a3a4e992018cab414a17db4c8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c021eef8aa73cc0a3a4e992018cab414a17db4c8"}], "stats": {"total": 138, "additions": 132, "deletions": 6}, "files": [{"sha": "988c675cf0393e4f651dc120a4ab58b2f5f2ddf1", "filename": "gcc/rust/backend/rust-compile-base.cc", "status": "modified", "additions": 43, "deletions": 6, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Frust%2Fbackend%2Frust-compile-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-base.cc?ref=c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "patch": "@@ -770,6 +770,10 @@ HIRCompileBase::resolve_method_address (TyTy::FnType *fntype,\n \t\t\t\t\tTyTy::BaseType *receiver,\n \t\t\t\t\tLocation expr_locus)\n {\n+  rust_debug_loc (expr_locus, \"resolve_method_address for %s and receiver %s\",\n+\t\t  fntype->debug_str ().c_str (),\n+\t\t  receiver->debug_str ().c_str ());\n+\n   DefId id = fntype->get_id ();\n   rust_assert (id != UNKNOWN_DEFID);\n \n@@ -823,13 +827,46 @@ HIRCompileBase::resolve_method_address (TyTy::FnType *fntype,\n \t\t\t\t\tctx, fntype, true, expr_locus);\n     }\n \n-  // FIXME this will be a case to return error_mark_node, there is\n-  // an error scenario where a Trait Foo has a method Bar, but this\n-  // receiver does not implement this trait or has an incompatible\n-  // implementation and we should just return error_mark_node\n+  const Resolver::PathProbeCandidate *selectedCandidate = nullptr;\n+  rust_debug_loc (expr_locus, \"resolved to %lu candidates\", candidates.size ());\n+\n+  // filter for the possible case of non fn type items\n+  std::set<Resolver::PathProbeCandidate> filteredFunctionCandidates;\n+  for (auto &candidate : candidates)\n+    {\n+      bool is_fntype = candidate.ty->get_kind () == TyTy::TypeKind::FNDEF;\n+      if (!is_fntype)\n+\tcontinue;\n+\n+      filteredFunctionCandidates.insert (candidate);\n+    }\n+\n+  // look for the exact fntype\n+  for (auto &candidate : filteredFunctionCandidates)\n+    {\n+      bool compatable\n+\t= Resolver::types_compatable (TyTy::TyWithLocation (candidate.ty),\n+\t\t\t\t      TyTy::TyWithLocation (fntype), expr_locus,\n+\t\t\t\t      false);\n+\n+      rust_debug_loc (candidate.locus, \"candidate: %s vs %s compatable=%s\",\n+\t\t      candidate.ty->debug_str ().c_str (),\n+\t\t      fntype->debug_str ().c_str (),\n+\t\t      compatable ? \"true\" : \"false\");\n+\n+      if (compatable)\n+\t{\n+\t  selectedCandidate = &candidate;\n+\t  break;\n+\t}\n+    }\n+\n+  // FIXME eventually this should just return error mark node when we support\n+  // going through all the passes\n+  rust_assert (selectedCandidate != nullptr);\n \n-  rust_assert (candidates.size () == 1);\n-  auto &candidate = *candidates.begin ();\n+  // lets compile it\n+  const Resolver::PathProbeCandidate &candidate = *selectedCandidate;\n   rust_assert (candidate.is_impl_candidate ());\n   rust_assert (candidate.ty->get_kind () == TyTy::TypeKind::FNDEF);\n   TyTy::FnType *candidate_call = static_cast<TyTy::FnType *> (candidate.ty);"}, {"sha": "37c8e30b10603bff77d5500b96f0ba758ee6ea86", "filename": "gcc/testsuite/rust/compile/issue-2019-2.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-2.rs?ref=c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "patch": "@@ -0,0 +1,30 @@\n+#[lang = \"add\"]\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+impl Add for u32 {\n+    type Output = u32;\n+\n+    fn add(self, other: u32) -> u32 {\n+        self + other\n+    }\n+}\n+\n+impl<'a> Add<u32> for &'a u32 {\n+    type Output = <u32 as Add<u32>>::Output;\n+\n+    fn add(self, other: u32) -> <u32 as Add<u32>>::Output {\n+        Add::add(*self, other)\n+    }\n+}\n+\n+impl<'a> Add<&'a u32> for u32 {\n+    type Output = <u32 as Add<u32>>::Output;\n+\n+    fn add(self, other: &'a u32) -> <u32 as Add<u32>>::Output {\n+        Add::add(self, *other)\n+    }\n+}"}, {"sha": "67890388be31ef3648806be0b557fcfe2eba0c18", "filename": "gcc/testsuite/rust/compile/issue-2019-3.rs", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-3.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-3.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fissue-2019-3.rs?ref=c84e7d9db2d33b7684b0a6b4b3ab9d5540adac27", "patch": "@@ -0,0 +1,59 @@\n+macro_rules! forward_ref_binop {\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty) => {\n+        forward_ref_binop!(impl $imp, $method for $t, $u,\n+                #[stable(feature = \"rust1\", since = \"1.0.0\")]);\n+    };\n+    (impl $imp:ident, $method:ident for $t:ty, $u:ty, #[$attr:meta]) => {\n+        #[$attr]\n+        impl<'a> $imp<$u> for &'a $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, other)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a> $imp<&'a $u> for $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(self, *other)\n+            }\n+        }\n+\n+        #[$attr]\n+        impl<'a, 'b> $imp<&'a $u> for &'b $t {\n+            type Output = <$t as $imp<$u>>::Output;\n+\n+            #[inline]\n+            fn $method(self, other: &'a $u) -> <$t as $imp<$u>>::Output {\n+                $imp::$method(*self, *other)\n+            }\n+        }\n+    }\n+}\n+\n+#[lang = \"add\"]\n+pub trait Add<RHS = Self> {\n+    type Output;\n+\n+    fn add(self, rhs: RHS) -> Self::Output;\n+}\n+\n+macro_rules! add_impl {\n+    ($($t:ty)*) => ($(\n+        #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        impl Add for $t {\n+            type Output = $t;\n+\n+            fn add(self, other: $t) -> $t { self + other }\n+        }\n+\n+        forward_ref_binop! { impl Add, add for $t, $t }\n+    )*)\n+}\n+\n+add_impl! { usize u8 u16 u32 u64 /*u128*/ isize i8 i16 i32 i64 /*i128*/ f32 f64 }"}]}