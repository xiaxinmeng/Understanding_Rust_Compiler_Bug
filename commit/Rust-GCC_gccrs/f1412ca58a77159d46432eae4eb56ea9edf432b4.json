{"sha": "f1412ca58a77159d46432eae4eb56ea9edf432b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjE0MTJjYTU4YTc3MTU5ZDQ2NDMyZWFlNGViNTZlYTllZGY0MzJiNA==", "commit": {"author": {"name": "Francois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-04-03T21:05:14Z"}, "committer": {"name": "Fran\u00e7ois-Xavier Coudert", "email": "fxcoudert@gcc.gnu.org", "date": "2007-04-03T21:05:14Z"}, "message": "re PR fortran/31304 (REPEAT argument NCOPIES is not converted as it should)\n\n\tPR fortran/31304\n\n\t* fortran/gfortran.h (gfc_charlen_int_kind): New prototype.\n\t* fortran/trans-types.c (gfc_charlen_int_kind): New variable.\n\t(gfc_init_types): Define gfc_charlen_int_kind. \n\t* fortran/trans.h (gfor_fndecl_string_repeat): Remove prototype.\n\t* fortran/trans-decl.c (gfor_fndecl_string_repeat): Delete.\n\t(gfc_build_intrinsic_function_decls): Don't set\n\tgfor_fndecl_string_repeat.\n\t* fortran/trans-intrinsic.c (gfc_conv_intrinsic_repeat): Rewrite\n\tso that we don't have to call a library function.\n\t* fortran/simplify.c (gfc_simplify_repeat): Perform the necessary\n\tchecks on the NCOPIES argument, and work with arbitrary size\n\targuments.\n\n\t* intrinsics/string_intrinsics.c (string_repeat): Remove.\n\n\t* gfortran.dg/repeat_2.f90: New test.\n\t* gfortran.dg/repeat_3.f90: New test.\n\t* gfortran.dg/repeat_4.f90: New test.\n\nFrom-SVN: r123481", "tree": {"sha": "6af7d5c4118c4c4b7db6fce6a67c9a5054967ba7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6af7d5c4118c4c4b7db6fce6a67c9a5054967ba7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1412ca58a77159d46432eae4eb56ea9edf432b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1412ca58a77159d46432eae4eb56ea9edf432b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1412ca58a77159d46432eae4eb56ea9edf432b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1412ca58a77159d46432eae4eb56ea9edf432b4/comments", "author": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "committer": {"login": "fxcoudert", "id": 1980544, "node_id": "MDQ6VXNlcjE5ODA1NDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1980544?v=4", "gravatar_id": "", "url": "https://api.github.com/users/fxcoudert", "html_url": "https://github.com/fxcoudert", "followers_url": "https://api.github.com/users/fxcoudert/followers", "following_url": "https://api.github.com/users/fxcoudert/following{/other_user}", "gists_url": "https://api.github.com/users/fxcoudert/gists{/gist_id}", "starred_url": "https://api.github.com/users/fxcoudert/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/fxcoudert/subscriptions", "organizations_url": "https://api.github.com/users/fxcoudert/orgs", "repos_url": "https://api.github.com/users/fxcoudert/repos", "events_url": "https://api.github.com/users/fxcoudert/events{/privacy}", "received_events_url": "https://api.github.com/users/fxcoudert/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ff2ea58742c65bfe2e779b6e8085a9b387724597", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff2ea58742c65bfe2e779b6e8085a9b387724597", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff2ea58742c65bfe2e779b6e8085a9b387724597"}], "stats": {"total": 406, "additions": 345, "deletions": 61}, "files": [{"sha": "f43ac735215cca0d2257261c57e809b85a924910", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -1,3 +1,19 @@\n+2007-04-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31304\n+\t* fortran/gfortran.h (gfc_charlen_int_kind): New prototype.\n+\t* fortran/trans-types.c (gfc_charlen_int_kind): New variable.\n+\t(gfc_init_types): Define gfc_charlen_int_kind. \n+\t* fortran/trans.h (gfor_fndecl_string_repeat): Remove prototype.\n+\t* fortran/trans-decl.c (gfor_fndecl_string_repeat): Delete.\n+\t(gfc_build_intrinsic_function_decls): Don't set\n+\tgfor_fndecl_string_repeat.\n+\t* fortran/trans-intrinsic.c (gfc_conv_intrinsic_repeat): Rewrite\n+\tso that we don't have to call a library function.\n+\t* fortran/simplify.c (gfc_simplify_repeat): Perform the necessary\n+\tchecks on the NCOPIES argument, and work with arbitrary size\n+\targuments.\n+\n 2007-03-31  Tobias Burnus  <burnus@net-b.de>\n \n \t* intrinsic.c (add_functions): Fix name of dummy argument"}, {"sha": "3ef490265028da3659dd2ec64155f125e361e799", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -1844,6 +1844,7 @@ extern int gfc_default_logical_kind;\n extern int gfc_default_complex_kind;\n extern int gfc_c_int_kind;\n extern int gfc_intio_kind;\n+extern int gfc_charlen_int_kind;\n extern int gfc_numeric_storage_size;\n extern int gfc_character_storage_size;\n "}, {"sha": "27f30ae2c141eb51c9bb370b43fdaf7548640b24", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 60, "deletions": 7, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -2788,23 +2788,76 @@ gfc_expr *\n gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n {\n   gfc_expr *result;\n-  int i, j, len, ncopies, nlen;\n+  int i, j, len, ncop, nlen;\n+  mpz_t ncopies;\n \n-  if (e->expr_type != EXPR_CONSTANT || n->expr_type != EXPR_CONSTANT)\n+  /* If NCOPIES isn't a constant, there's nothing we can do.  */\n+  if (n->expr_type != EXPR_CONSTANT)\n     return NULL;\n \n-  if (n != NULL && (gfc_extract_int (n, &ncopies) != NULL || ncopies < 0))\n+  /* If NCOPIES is negative, it's an error.  */\n+  if (mpz_sgn (n->value.integer) < 0)\n     {\n-      gfc_error (\"Invalid second argument of REPEAT at %L\", &n->where);\n+      gfc_error (\"Argument NCOPIES of REPEAT intrinsic is negative at %L\",\n+\t\t &n->where);\n       return &gfc_bad_expr;\n     }\n \n+  /* If we don't know the character length, we can do no more.  */\n+  if (e->ts.cl == NULL || e->ts.cl->length == NULL\n+      || e->ts.cl->length->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  /* If the source length is 0, any value of NCOPIES is valid\n+     and everything behaves as if NCOPIES == 0.  */\n+  mpz_init (ncopies);\n+  if (mpz_sgn (e->ts.cl->length->value.integer) == 0)\n+    mpz_set_ui (ncopies, 0);\n+  else\n+    mpz_set (ncopies, n->value.integer);\n+\n+  /* Check that NCOPIES isn't too large.  */\n+  if (mpz_sgn (e->ts.cl->length->value.integer) != 0)\n+    {\n+      mpz_t max;\n+      int i;\n+\n+      /* Compute the maximum value allowed for NCOPIES: huge(cl) / len.  */\n+      mpz_init (max);\n+      i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n+      mpz_tdiv_q (max, gfc_integer_kinds[i].huge,\n+\t\t  e->ts.cl->length->value.integer);\n+\n+      /* The check itself.  */\n+      if (mpz_cmp (ncopies, max) > 0)\n+\t{\n+\t  mpz_clear (max);\n+\t  mpz_clear (ncopies);\n+\t  gfc_error (\"Argument NCOPIES of REPEAT intrinsic is too large at %L\",\n+\t\t     &n->where);\n+\t  return &gfc_bad_expr;\n+\t}\n+\n+      mpz_clear (max);\n+    }\n+  mpz_clear (ncopies);\n+\n+  /* For further simplication, we need the character string to be\n+     constant.  */\n+  if (e->expr_type != EXPR_CONSTANT)\n+    return NULL;\n+\n+  if (mpz_sgn (e->ts.cl->length->value.integer) != 0)\n+    gcc_assert (gfc_extract_int (n, &ncop) == NULL);\n+  else\n+    ncop = 0;\n+\n   len = e->value.character.length;\n-  nlen = ncopies * len;\n+  nlen = ncop * len;\n \n   result = gfc_constant_result (BT_CHARACTER, e->ts.kind, &e->where);\n \n-  if (ncopies == 0)\n+  if (ncop == 0)\n     {\n       result->value.character.string = gfc_getmem (1);\n       result->value.character.length = 0;\n@@ -2815,7 +2868,7 @@ gfc_simplify_repeat (gfc_expr *e, gfc_expr *n)\n   result->value.character.length = nlen;\n   result->value.character.string = gfc_getmem (nlen + 1);\n \n-  for (i = 0; i < ncopies; i++)\n+  for (i = 0; i < ncop; i++)\n     for (j = 0; j < len; j++)\n       result->value.character.string[j + i * len]\n       = e->value.character.string[j];"}, {"sha": "6cd13048512208e468bb9a5c22a06b5b7ab4497e", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -129,7 +129,6 @@ tree gfor_fndecl_string_index;\n tree gfor_fndecl_string_scan;\n tree gfor_fndecl_string_verify;\n tree gfor_fndecl_string_trim;\n-tree gfor_fndecl_string_repeat;\n tree gfor_fndecl_adjustl;\n tree gfor_fndecl_adjustr;\n \n@@ -2036,15 +2035,6 @@ gfc_build_intrinsic_function_decls (void)\n                                      gfc_charlen_type_node,\n                                      pchar_type_node);\n \n-  gfor_fndecl_string_repeat =\n-    gfc_build_library_function_decl (get_identifier (PREFIX(\"string_repeat\")),\n-                                     void_type_node,\n-                                     4,\n-                                     pchar_type_node,\n-                                     gfc_charlen_type_node,\n-                                     pchar_type_node,\n-                                     gfc_int4_type_node);\n-\n   gfor_fndecl_ttynam =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"ttynam\")),\n                                      void_type_node,"}, {"sha": "25c8e1e8b1a67f3a4054b62ebd0e444390267499", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 92, "deletions": 22, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -3378,41 +3378,111 @@ gfc_conv_intrinsic_trim (gfc_se * se, gfc_expr * expr)\n static void\n gfc_conv_intrinsic_repeat (gfc_se * se, gfc_expr * expr)\n {\n-  tree gfc_int4_type_node = gfc_get_int_type (4);\n-  tree tmp;\n-  tree len;\n-  tree args;\n-  tree ncopies;\n-  tree var;\n-  tree type;\n-  tree cond;\n+  tree args, ncopies, dest, dlen, src, slen, ncopies_type;\n+  tree type, cond, tmp, count, exit_label, n, max, largest;\n+  stmtblock_t block, body;\n+  int i;\n \n+  /* Get the arguments.  */\n   args = gfc_conv_intrinsic_function_args (se, expr);\n-  len = TREE_VALUE (args);\n-  tmp = gfc_advance_chain (args, 2);\n-  ncopies = TREE_VALUE (tmp);\n-\n-  /* Check that ncopies is not negative.  */\n+  slen = fold_convert (size_type_node, gfc_evaluate_now (TREE_VALUE (args),\n+\t\t\t\t\t\t\t &se->pre));\n+  src = TREE_VALUE (TREE_CHAIN (args));\n+  ncopies = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (args)));\n   ncopies = gfc_evaluate_now (ncopies, &se->pre);\n+  ncopies_type = TREE_TYPE (ncopies);\n+\n+  /* Check that NCOPIES is not negative.  */\n   cond = fold_build2 (LT_EXPR, boolean_type_node, ncopies,\n-\t\t      build_int_cst (TREE_TYPE (ncopies), 0));\n+\t\t      build_int_cst (ncopies_type, 0));\n   gfc_trans_runtime_check (cond,\n \t\t\t   \"Argument NCOPIES of REPEAT intrinsic is negative\",\n \t\t\t   &se->pre, &expr->where);\n \n+  /* If the source length is zero, any non negative value of NCOPIES\n+     is valid, and nothing happens.  */\n+  n = gfc_create_var (ncopies_type, \"ncopies\");\n+  cond = fold_build2 (EQ_EXPR, boolean_type_node, slen,\n+\t\t      build_int_cst (size_type_node, 0));\n+  tmp = fold_build3 (COND_EXPR, ncopies_type, cond,\n+\t\t     build_int_cst (ncopies_type, 0), ncopies);\n+  gfc_add_modify_expr (&se->pre, n, tmp);\n+  ncopies = n;\n+\n+  /* Check that ncopies is not too large: ncopies should be less than\n+     (or equal to) MAX / slen, where MAX is the maximal integer of\n+     the gfc_charlen_type_node type.  If slen == 0, we need a special\n+     case to avoid the division by zero.  */\n+  i = gfc_validate_kind (BT_INTEGER, gfc_charlen_int_kind, false);\n+  max = gfc_conv_mpz_to_tree (gfc_integer_kinds[i].huge, gfc_charlen_int_kind);\n+  max = fold_build2 (TRUNC_DIV_EXPR, size_type_node,\n+\t\t     fold_convert (size_type_node, max), slen);\n+  largest = TYPE_PRECISION (size_type_node) > TYPE_PRECISION (ncopies_type)\n+\t      ? size_type_node : ncopies_type;\n+  cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t      fold_convert (largest, ncopies),\n+\t\t      fold_convert (largest, max));\n+  tmp = fold_build2 (EQ_EXPR, boolean_type_node, slen,\n+\t\t     build_int_cst (size_type_node, 0));\n+  cond = fold_build3 (COND_EXPR, boolean_type_node, tmp, boolean_false_node,\n+\t\t      cond);\n+  gfc_trans_runtime_check (cond,\n+\t\t\t   \"Argument NCOPIES of REPEAT intrinsic is too large\",\n+\t\t\t   &se->pre, &expr->where);\n+\n   /* Compute the destination length.  */\n-  len = fold_build2 (MULT_EXPR, gfc_int4_type_node, len, ncopies);\n+  dlen = fold_build2 (MULT_EXPR, gfc_charlen_type_node, slen, ncopies);\n   type = gfc_get_character_type (expr->ts.kind, expr->ts.cl);\n-  var = gfc_conv_string_tmp (se, build_pointer_type (type), len);\n+  dest = gfc_conv_string_tmp (se, build_pointer_type (type), dlen);\n+\n+  /* Generate the code to do the repeat operation:\n+       for (i = 0; i < ncopies; i++)\n+         memmove (dest + (i * slen), src, slen);  */\n+  gfc_start_block (&block);\n+  count = gfc_create_var (ncopies_type, \"count\");\n+  gfc_add_modify_expr (&block, count, build_int_cst (ncopies_type, 0));\n+  exit_label = gfc_build_label_decl (NULL_TREE);\n+\n+  /* Start the loop body.  */\n+  gfc_start_block (&body);\n \n-  /* Create the argument list and generate the function call.  */\n-  tmp = build_call_expr (gfor_fndecl_string_repeat, 4, var,\n-\t\t\t TREE_VALUE (args),\n-\t\t\t TREE_VALUE (TREE_CHAIN (args)), ncopies);\n+  /* Exit the loop if count >= ncopies.  */\n+  cond = fold_build2 (GE_EXPR, boolean_type_node, count, ncopies);\n+  tmp = build1_v (GOTO_EXPR, exit_label);\n+  TREE_USED (exit_label) = 1;\n+  tmp = fold_build3 (COND_EXPR, void_type_node, cond, tmp,\n+\t\t     build_empty_stmt ());\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Call memmove (dest + (i*slen), src, slen).  */\n+  tmp = fold_build2 (MULT_EXPR, gfc_charlen_type_node, slen,\n+\t\t     fold_convert (gfc_charlen_type_node, count));\n+  tmp = fold_build2 (PLUS_EXPR, pchar_type_node, dest,\n+\t\t     fold_convert (pchar_type_node, tmp));\n+  tmp = build_call_expr (built_in_decls[BUILT_IN_MEMMOVE], 3,\n+\t\t\t tmp, src, slen);\n+  gfc_add_expr_to_block (&body, tmp);\n+\n+  /* Increment count.  */\n+  tmp = build2 (PLUS_EXPR, ncopies_type, count,\n+\t\tbuild_int_cst (TREE_TYPE (count), 1));\n+  gfc_add_modify_expr (&body, count, tmp);\n+\n+  /* Build the loop.  */\n+  tmp = build1_v (LOOP_EXPR, gfc_finish_block (&body));\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  /* Add the exit label.  */\n+  tmp = build1_v (LABEL_EXPR, exit_label);\n+  gfc_add_expr_to_block (&block, tmp);\n+\n+  /* Finish the block.  */\n+  tmp = gfc_finish_block (&block);\n   gfc_add_expr_to_block (&se->pre, tmp);\n \n-  se->expr = var;\n-  se->string_length = len;\n+  /* Set the result value.  */\n+  se->expr = dest;\n+  se->string_length = dlen;\n }\n \n "}, {"sha": "c0233a1fde5356d63035abf0513f3370d3dca884", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -97,6 +97,9 @@ int gfc_c_int_kind;\n    kind=8, this will be set to 8, otherwise it is set to 4.  */\n int gfc_intio_kind; \n \n+/* The integer kind used to store character lengths.  */\n+int gfc_charlen_int_kind;\n+\n /* The size of the numeric storage unit and character storage unit.  */\n int gfc_numeric_storage_size;\n int gfc_character_storage_size;\n@@ -607,7 +610,8 @@ gfc_init_types (void)\n   boolean_false_node = build_int_cst (boolean_type_node, 0);\n \n   /* ??? Shouldn't this be based on gfc_index_integer_kind or so?  */\n-  gfc_charlen_type_node = gfc_get_int_type (4);\n+  gfc_charlen_int_kind = 4;\n+  gfc_charlen_type_node = gfc_get_int_type (gfc_charlen_int_kind);\n }\n \n /* Get the type node for the given type and kind.  */"}, {"sha": "97d4d0f6b6292f629f4474baab4c4bd19f7c682f", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -533,7 +533,6 @@ extern GTY(()) tree gfor_fndecl_string_index;\n extern GTY(()) tree gfor_fndecl_string_scan;\n extern GTY(()) tree gfor_fndecl_string_verify;\n extern GTY(()) tree gfor_fndecl_string_trim;\n-extern GTY(()) tree gfor_fndecl_string_repeat;\n extern GTY(()) tree gfor_fndecl_adjustl;\n extern GTY(()) tree gfor_fndecl_adjustr;\n "}, {"sha": "b9c4127695c3d3c83a0948d5f67dbb3ae2f7ee84", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -1,3 +1,10 @@\n+2007-04-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31304\n+\t* gfortran.dg/repeat_2.f90: New test.\n+\t* gfortran.dg/repeat_3.f90: New test.\n+\t* gfortran.dg/repeat_4.f90: New test.\n+\n 2007-04-03  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* gcc.dg/tls/opt-3.c: Use -mregparm=3 only for ilp32 on x86_64 targets."}, {"sha": "d38718a20a0e3d68eacaa07452610ac0a5537435", "filename": "gcc/testsuite/gfortran.dg/repeat_2.f90", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_2.f90?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -0,0 +1,92 @@\n+! REPEAT intrinsic\n+!\n+! { dg-do run }\n+subroutine foo(i, j, s, t)\n+  implicit none\n+  integer, intent(in) :: i, j\n+  character(len=i), intent(in) :: s\n+  character(len=i*j), intent(in) :: t\n+\n+  if (repeat(s,j) /= t) call abort\n+  call bar(j,s,t)\n+end subroutine foo\n+\n+subroutine bar(j, s, t)\n+  implicit none\n+  integer, intent(in) :: j\n+  character(len=*), intent(in) :: s\n+  character(len=len(s)*j), intent(in) :: t\n+\n+  if (repeat(s,j) /= t) call abort\n+end subroutine bar\n+\n+program test\n+  implicit none\n+  character(len=0), parameter :: s0 = \"\"\n+  character(len=1), parameter :: s1 = \"a\"\n+  character(len=2), parameter :: s2 = \"ab\"\n+  character(len=0) :: t0\n+  character(len=1) :: t1\n+  character(len=2) :: t2\n+  integer :: i\n+\n+  t0 = \"\"\n+  t1 = \"a\"\n+  t2 = \"ab\"\n+\n+  if (repeat(t0, 0) /= \"\") call abort\n+  if (repeat(t1, 0) /= \"\") call abort\n+  if (repeat(t2, 0) /= \"\") call abort\n+  if (repeat(t0, 1) /= \"\") call abort\n+  if (repeat(t1, 1) /= \"a\") call abort\n+  if (repeat(t2, 1) /= \"ab\") call abort\n+  if (repeat(t0, 2) /= \"\") call abort\n+  if (repeat(t1, 2) /= \"aa\") call abort\n+  if (repeat(t2, 2) /= \"abab\") call abort\n+\n+  if (repeat(s0, 0) /= \"\") call abort\n+  if (repeat(s1, 0) /= \"\") call abort\n+  if (repeat(s2, 0) /= \"\") call abort\n+  if (repeat(s0, 1) /= \"\") call abort\n+  if (repeat(s1, 1) /= \"a\") call abort\n+  if (repeat(s2, 1) /= \"ab\") call abort\n+  if (repeat(s0, 2) /= \"\") call abort\n+  if (repeat(s1, 2) /= \"aa\") call abort\n+  if (repeat(s2, 2) /= \"abab\") call abort\n+\n+  i = 0\n+  if (repeat(t0, i) /= \"\") call abort\n+  if (repeat(t1, i) /= \"\") call abort\n+  if (repeat(t2, i) /= \"\") call abort\n+  i = 1\n+  if (repeat(t0, i) /= \"\") call abort\n+  if (repeat(t1, i) /= \"a\") call abort\n+  if (repeat(t2, i) /= \"ab\") call abort\n+  i = 2\n+  if (repeat(t0, i) /= \"\") call abort\n+  if (repeat(t1, i) /= \"aa\") call abort\n+  if (repeat(t2, i) /= \"abab\") call abort\n+\n+  i = 0\n+  if (repeat(s0, i) /= \"\") call abort\n+  if (repeat(s1, i) /= \"\") call abort\n+  if (repeat(s2, i) /= \"\") call abort\n+  i = 1\n+  if (repeat(s0, i) /= \"\") call abort\n+  if (repeat(s1, i) /= \"a\") call abort\n+  if (repeat(s2, i) /= \"ab\") call abort\n+  i = 2\n+  if (repeat(s0, i) /= \"\") call abort\n+  if (repeat(s1, i) /= \"aa\") call abort\n+  if (repeat(s2, i) /= \"abab\") call abort\n+\n+  call foo(0,0,\"\",\"\")\n+  call foo(0,1,\"\",\"\")\n+  call foo(0,2,\"\",\"\")\n+  call foo(1,0,\"a\",\"\")\n+  call foo(1,1,\"a\",\"a\")\n+  call foo(1,2,\"a\",\"aa\")\n+  call foo(2,0,\"ab\",\"\")\n+  call foo(2,1,\"ab\",\"ab\")\n+  call foo(2,2,\"ab\",\"abab\")\n+end program test"}, {"sha": "d571fc6e32a4fef58594c409bba4219574d38058", "filename": "gcc/testsuite/gfortran.dg/repeat_3.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_3.f90?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -0,0 +1,29 @@\n+! REPEAT intrinsic, test for PR 31304\n+! We check that REPEAT accepts all kind arguments for NCOPIES\n+!\n+! { dg-do run }\n+program test\n+  implicit none\n+\n+  integer(kind=1) i1\n+  integer(kind=2) i2\n+  integer(kind=4) i4\n+  integer(kind=4) i8\n+  real(kind=8) r\n+  character(len=2) s1, s2\n+\n+  i1 = 1 ; i2 = 1 ; i4 = 1 ; i8 = 1\n+  r = 1\n+  s1 = '42'\n+  r = nearest(r,r)\n+\n+  s2 = repeat(s1,i1)\n+  if (s2 /= s1) call abort\n+  s2 = repeat(s1,i2)\n+  if (s2 /= s1) call abort\n+  s2 = repeat(s1,i4)\n+  if (s2 /= s1) call abort\n+  s2 = repeat(s1,i8)\n+  if (s2 /= s1) call abort\n+\n+end program test"}, {"sha": "de74d4e85e9d4e11e4c3e4f78ee883c60bd42f06", "filename": "gcc/testsuite/gfortran.dg/repeat_4.f90", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Frepeat_4.f90?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -0,0 +1,38 @@\n+! REPEAT intrinsic -- various checks should be enforced\n+!\n+! { dg-do compile }\n+program test\n+  implicit none\n+  character(len=0), parameter :: s0 = \"\"\n+  character(len=1), parameter :: s1 = \"a\"\n+  character(len=2), parameter :: s2 = \"ab\"\n+  character(len=0) :: t0\n+  character(len=1) :: t1\n+  character(len=2) :: t2\n+\n+  t0 = \"\" ; t1 = \"a\" ; t2 = \"ab\"\n+\n+  ! Check for negative NCOPIES argument\n+  print *, repeat(s0, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+  print *, repeat(s1, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+  print *, repeat(s2, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+  print *, repeat(t0, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+  print *, repeat(t1, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+  print *, repeat(t2, -1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is negative\" }\n+\n+  ! Check for too large NCOPIES argument and limit cases\n+  print *, repeat(t0, huge(0))\n+  print *, repeat(t1, huge(0))\n+  print *, repeat(t2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0)) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+\n+  print *, repeat(t0, huge(0)/2)\n+  print *, repeat(t1, huge(0)/2)\n+  print *, repeat(t2, huge(0)/2)\n+\n+  print *, repeat(t0, huge(0)/2+1)\n+  print *, repeat(t1, huge(0)/2+1)\n+  print *, repeat(t2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+  print *, repeat(s2, huge(0)/2+1) ! { dg-error \"Argument NCOPIES of REPEAT intrinsic is too large \" }\n+\n+end program test"}, {"sha": "87ad838829eab40a9e0cafc8feaff7944040349a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -1,3 +1,8 @@\n+2007-04-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n+\n+\tPR fortran/31304\n+\tintrinsics/string_intrinsics.c (string_repeat): Remove.\n+\n 2007-04-01  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/31052"}, {"sha": "1a4b1593270b84184eaf69647290c344b2005d16", "filename": "libgfortran/intrinsics/string_intrinsics.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1412ca58a77159d46432eae4eb56ea9edf432b4/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1412ca58a77159d46432eae4eb56ea9edf432b4/libgfortran%2Fintrinsics%2Fstring_intrinsics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fintrinsics%2Fstring_intrinsics.c?ref=f1412ca58a77159d46432eae4eb56ea9edf432b4", "patch": "@@ -73,9 +73,6 @@ export_proto(string_verify);\n extern void string_trim (GFC_INTEGER_4 *, void **, GFC_INTEGER_4, const char *);\n export_proto(string_trim);\n \n-extern void string_repeat (char *, GFC_INTEGER_4, const char *, GFC_INTEGER_4);\n-export_proto(string_repeat);\n-\n /* Strings of unequal length are extended with pad characters.  */\n \n GFC_INTEGER_4\n@@ -352,20 +349,3 @@ string_verify (GFC_INTEGER_4 slen, const char * str, GFC_INTEGER_4 setlen,\n \n   return 0;\n }\n-\n-\n-/* Concatenate several copies of a string.  */\n-\n-void\n-string_repeat (char * dest, GFC_INTEGER_4 slen, \n-               const char * src, GFC_INTEGER_4 ncopies)\n-{\n-  int i;\n-\n-  /* We don't need to check that ncopies is non-negative here, because\n-     the front-end already generates code for that check.  */\n-  for (i = 0; i < ncopies; i++) \n-    {\n-      memmove (dest + (i * slen), src, slen);\n-    }\n-}"}]}