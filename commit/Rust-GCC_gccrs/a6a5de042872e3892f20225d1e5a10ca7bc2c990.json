{"sha": "a6a5de042872e3892f20225d1e5a10ca7bc2c990", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTZhNWRlMDQyODcyZTM4OTJmMjAyMjVkMWU1YTEwY2E3YmMyYzk5MA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2005-11-18T17:59:37Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2005-11-18T17:59:37Z"}, "message": "re PR target/24914 (gcc fails when built with --with-cpu=ep9312 --with-fpu=maverick)\n\n\tPR target/24914\n\t* arm.c (arm_hard_regno_mode_ok): Co-processor registers aren't ok\n\twhen not generating code to use that co-processor.\n\nFrom-SVN: r107187", "tree": {"sha": "363047f85f3f0503fd059d35803a91e342638058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/363047f85f3f0503fd059d35803a91e342638058"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a6a5de042872e3892f20225d1e5a10ca7bc2c990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a5de042872e3892f20225d1e5a10ca7bc2c990", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6a5de042872e3892f20225d1e5a10ca7bc2c990", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6a5de042872e3892f20225d1e5a10ca7bc2c990/comments", "author": null, "committer": null, "parents": [{"sha": "e5e0238e33f171d850971b3c982d31e5aaf2265d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5e0238e33f171d850971b3c982d31e5aaf2265d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5e0238e33f171d850971b3c982d31e5aaf2265d"}], "stats": {"total": 38, "additions": 26, "deletions": 12}, "files": [{"sha": "031402b5d186e46dc0bf6b2af866735ed6516c48", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a5de042872e3892f20225d1e5a10ca7bc2c990/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a5de042872e3892f20225d1e5a10ca7bc2c990/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a6a5de042872e3892f20225d1e5a10ca7bc2c990", "patch": "@@ -1,3 +1,9 @@\n+2005-11-18  Richard Earnshaw  <richard.earnshaw@arm.com>\n+\n+\tPR target/24914\n+\t* arm.c (arm_hard_regno_mode_ok): Co-processor registers aren't ok\n+\twhen not generating code to use that co-processor.\n+\n 2005-11-18  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* tree-flow.h (reserve_phi_args_for_new_edge, create_phi_node,"}, {"sha": "6165545ae4f6f8c152be5db27ac6ad314ebc083d", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a6a5de042872e3892f20225d1e5a10ca7bc2c990/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a6a5de042872e3892f20225d1e5a10ca7bc2c990/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=a6a5de042872e3892f20225d1e5a10ca7bc2c990", "patch": "@@ -11818,7 +11818,9 @@ int\n arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n {\n   if (GET_MODE_CLASS (mode) == MODE_CC)\n-    return regno == CC_REGNUM || regno == VFPCC_REGNUM;\n+    return (regno == CC_REGNUM\n+\t    || (TARGET_HARD_FLOAT && TARGET_VFP\n+\t\t&& regno == VFPCC_REGNUM));\n \n   if (TARGET_THUMB)\n     /* For the Thumb we only allow values bigger than SImode in\n@@ -11828,15 +11830,17 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n        start of an even numbered register pair.  */\n     return (ARM_NUM_REGS (mode) < 2) || (regno < LAST_LO_REGNUM);\n \n-  if (IS_CIRRUS_REGNUM (regno))\n+  if (TARGET_HARD_FLOAT && TARGET_MAVERICK\n+      && IS_CIRRUS_REGNUM (regno))\n     /* We have outlawed SI values in Cirrus registers because they\n        reside in the lower 32 bits, but SF values reside in the\n        upper 32 bits.  This causes gcc all sorts of grief.  We can't\n        even split the registers into pairs because Cirrus SI values\n        get sign extended to 64bits-- aldyh.  */\n     return (GET_MODE_CLASS (mode) == MODE_FLOAT) || (mode == DImode);\n \n-  if (IS_VFP_REGNUM (regno))\n+  if (TARGET_HARD_FLOAT && TARGET_VFP\n+      && IS_VFP_REGNUM (regno))\n     {\n       if (mode == SFmode || mode == SImode)\n \treturn TRUE;\n@@ -11847,28 +11851,32 @@ arm_hard_regno_mode_ok (unsigned int regno, enum machine_mode mode)\n       return FALSE;\n     }\n \n-  if (IS_IWMMXT_GR_REGNUM (regno))\n-    return mode == SImode;\n-\n-  if (IS_IWMMXT_REGNUM (regno))\n-    return VALID_IWMMXT_REG_MODE (mode);\n+  if (TARGET_REALLY_IWMMXT)\n+    {\n+      if (IS_IWMMXT_GR_REGNUM (regno))\n+\treturn mode == SImode;\n \n+      if (IS_IWMMXT_REGNUM (regno))\n+\treturn VALID_IWMMXT_REG_MODE (mode);\n+    }\n+  \n   /* We allow any value to be stored in the general registers.\n      Restrict doubleword quantities to even register pairs so that we can\n      use ldrd.  */\n   if (regno <= LAST_ARM_REGNUM)\n     return !(TARGET_LDRD && GET_MODE_SIZE (mode) > 4 && (regno & 1) != 0);\n \n-  if (   regno == FRAME_POINTER_REGNUM\n+  if (regno == FRAME_POINTER_REGNUM\n       || regno == ARG_POINTER_REGNUM)\n     /* We only allow integers in the fake hard registers.  */\n     return GET_MODE_CLASS (mode) == MODE_INT;\n \n   /* The only registers left are the FPA registers\n      which we only allow to hold FP values.  */\n-  return GET_MODE_CLASS (mode) == MODE_FLOAT\n-    && regno >= FIRST_FPA_REGNUM\n-    && regno <= LAST_FPA_REGNUM;\n+  return (TARGET_HARD_FLOAT && TARGET_FPA\n+\t  && GET_MODE_CLASS (mode) == MODE_FLOAT\n+\t  && regno >= FIRST_FPA_REGNUM\n+\t  && regno <= LAST_FPA_REGNUM);\n }\n \n int"}]}