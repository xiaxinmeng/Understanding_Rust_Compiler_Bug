{"sha": "2c6e3f5540bc82374b7f71333f550cfccca93a74", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM2ZTNmNTU0MGJjODIzNzRiN2Y3MTMzM2Y1NTBjZmNjY2E5M2E3NA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-10-19T21:41:15Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-10-19T21:41:15Z"}, "message": "charset.c (cpp_init_iconv): Initialize utf8_cset_desc.\n\n\t* charset.c (cpp_init_iconv): Initialize utf8_cset_desc.\n\t(_cpp_destroy_iconv): Destroy utf8_cset_desc, char16_cset_desc\n\tand char32_cset_desc.\n\t(converter_for_type): Handle CPP_UTF8STRING.\n\t(cpp_interpret_string): Handle CPP_UTF8STRING and raw-strings.\n\t* directives.c (get__Pragma_string): Handle CPP_UTF8STRING.\n\t(parse_include): Reject raw strings.\n\t* include/cpplib.h (CPP_UTF8STRING): New token type.\n\t* internal.h (struct cpp_reader): Add utf8_cset_desc field.\n\t* lex.c (lex_raw_string): New function.\n\t(lex_string): Handle u8 string literals, call lex_raw_string\n\tfor raw string literals.\n\t(_cpp_lex_direct): Call lex_string even for u8\" and {,u,U,L,u8}R\"\n\tsequences.\n\t* macro.c (stringify_arg): Handle CPP_UTF8STRING.\n\n\t* c-common.c (c_parse_error): Handle CPP_UTF8STRING.\n\t* c-lex.c (c_lex_with_flags): Likewise.  Test C_LEX_STRING_NO_JOIN\n\tinstead of C_LEX_RAW_STRINGS.\n\t(lex_string): Handle CPP_UTF8STRING.\n\t* c-parser.c (c_parser_postfix_expression): Likewise.\n\t* c-pragma.h (C_LEX_RAW_STRINGS): Rename to ...\n\t(C_LEX_STRING_NO_JOIN): ... this.\n\n\t* parser.c (cp_lexer_print_token, cp_parser_is_string_literal,\n\tcp_parser_string_literal, cp_parser_primary_expression): Likewise.\n\t(cp_lexer_get_preprocessor_token): Use C_LEX_STRING_JOIN instead\n\tof C_LEX_RAW_STRINGS.\n\n\t* gcc.dg/raw-string-1.c: New test.\n\t* gcc.dg/raw-string-2.c: New test.\n\t* gcc.dg/raw-string-3.c: New test.\n\t* gcc.dg/raw-string-4.c: New test.\n\t* gcc.dg/raw-string-5.c: New test.\n\t* gcc.dg/raw-string-6.c: New test.\n\t* gcc.dg/raw-string-7.c: New test.\n\t* gcc.dg/utf8-1.c: New test.\n\t* gcc.dg/utf8-2.c: New test.\n\t* gcc.dg/utf-badconcat2.c: New test.\n\t* gcc.dg/utf-dflt2.c: New test.\n\t* gcc.dg/cpp/include6.c: New test.\n\t* g++.dg/ext/raw-string-1.C: New test.\n\t* g++.dg/ext/raw-string-2.C: New test.\n\t* g++.dg/ext/raw-string-3.C: New test.\n\t* g++.dg/ext/raw-string-4.C: New test.\n\t* g++.dg/ext/raw-string-5.C: New test.\n\t* g++.dg/ext/raw-string-6.C: New test.\n\t* g++.dg/ext/raw-string-7.C: New test.\n\t* g++.dg/ext/utf8-1.C: New test.\n\t* g++.dg/ext/utf8-2.C: New test.\n\t* g++.dg/ext/utf-badconcat2.C: New test.\n\t* g++.dg/ext/utf-dflt2.C: New test.\n\nFrom-SVN: r152995", "tree": {"sha": "2156a8d43e7b0cb0eb28776c7a735b606e1caea8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2156a8d43e7b0cb0eb28776c7a735b606e1caea8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c6e3f5540bc82374b7f71333f550cfccca93a74", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6e3f5540bc82374b7f71333f550cfccca93a74", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c6e3f5540bc82374b7f71333f550cfccca93a74", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6e3f5540bc82374b7f71333f550cfccca93a74/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4d696ad0116dafa47b891ceb0db246ad8b81c8ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d696ad0116dafa47b891ceb0db246ad8b81c8ff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d696ad0116dafa47b891ceb0db246ad8b81c8ff"}], "stats": {"total": 1272, "additions": 1244, "deletions": 28}, "files": [{"sha": "548cc0b36ed98364c3d66ff5b6bb96fd2b1fdc7b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -1,3 +1,13 @@\n+2009-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.c (c_parse_error): Handle CPP_UTF8STRING.\n+\t* c-lex.c (c_lex_with_flags): Likewise.  Test C_LEX_STRING_NO_JOIN\n+\tinstead of C_LEX_RAW_STRINGS.\n+\t(lex_string): Handle CPP_UTF8STRING.\n+\t* c-parser.c (c_parser_postfix_expression): Likewise.\n+\t* c-pragma.h (C_LEX_RAW_STRINGS): Rename to ...\n+\t(C_LEX_STRING_NO_JOIN): ... this.\n+\n 2009-10-19  Anatoly Sokolov  <aesok@post.ru>\n \n \t* config/cris/cris.c (cris_function_value, cris_libcall_value,"}, {"sha": "16e17b39d1d8d0141df73f84fae0a77856f0f621", "filename": "gcc/c-common.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -8181,7 +8181,8 @@ c_parse_error (const char *gmsgid, enum cpp_ttype token_type,\n   else if (token_type == CPP_STRING \n \t   || token_type == CPP_WSTRING \n \t   || token_type == CPP_STRING16\n-\t   || token_type == CPP_STRING32)\n+\t   || token_type == CPP_STRING32\n+\t   || token_type == CPP_UTF8STRING)\n     message = catenate_messages (gmsgid, \" before string constant\");\n   else if (token_type == CPP_NUMBER)\n     message = catenate_messages (gmsgid, \" before numeric constant\");"}, {"sha": "fd3df8c0a48377bcc50ae23259ed29d7210ee443", "filename": "gcc/c-lex.c", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-lex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-lex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lex.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -365,6 +365,7 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n \t    case CPP_WSTRING:\n \t    case CPP_STRING16:\n \t    case CPP_STRING32:\n+\t    case CPP_UTF8STRING:\n \t      type = lex_string (tok, value, true, true);\n \t      break;\n \n@@ -423,7 +424,8 @@ c_lex_with_flags (tree *value, location_t *loc, unsigned char *cpp_flags,\n     case CPP_WSTRING:\n     case CPP_STRING16:\n     case CPP_STRING32:\n-      if ((lex_flags & C_LEX_RAW_STRINGS) == 0)\n+    case CPP_UTF8STRING:\n+      if ((lex_flags & C_LEX_STRING_NO_JOIN) == 0)\n \t{\n \t  type = lex_string (tok, value, false,\n \t\t\t     (lex_flags & C_LEX_STRING_NO_TRANSLATE) == 0);\n@@ -871,12 +873,13 @@ interpret_fixed (const cpp_token *token, unsigned int flags)\n   return value;\n }\n \n-/* Convert a series of STRING, WSTRING, STRING16 and/or STRING32 tokens\n-   into a tree, performing string constant concatenation.  TOK is the\n-   first of these.  VALP is the location to write the string into.\n-   OBJC_STRING indicates whether an '@' token preceded the incoming token.\n+/* Convert a series of STRING, WSTRING, STRING16, STRING32 and/or\n+   UTF8STRING tokens into a tree, performing string constant\n+   concatenation.  TOK is the first of these.  VALP is the location\n+   to write the string into. OBJC_STRING indicates whether an '@' token\n+   preceded the incoming token.\n    Returns the CPP token type of the result (CPP_STRING, CPP_WSTRING,\n-   CPP_STRING32, CPP_STRING16, or CPP_OBJC_STRING).\n+   CPP_STRING32, CPP_STRING16, CPP_UTF8STRING, or CPP_OBJC_STRING).\n \n    This is unfortunately more work than it should be.  If any of the\n    strings in the series has an L prefix, the result is a wide string\n@@ -921,6 +924,7 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n     case CPP_WSTRING:\n     case CPP_STRING16:\n     case CPP_STRING32:\n+    case CPP_UTF8STRING:\n       if (type != tok->type)\n \t{\n \t  if (type == CPP_STRING)\n@@ -966,6 +970,7 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n \t{\n \tdefault:\n \tcase CPP_STRING:\n+\tcase CPP_UTF8STRING:\n \t  value = build_string (1, \"\");\n \t  break;\n \tcase CPP_STRING16:\n@@ -991,6 +996,7 @@ lex_string (const cpp_token *tok, tree *valp, bool objc_string, bool translate)\n     {\n     default:\n     case CPP_STRING:\n+    case CPP_UTF8STRING:\n       TREE_TYPE (value) = char_array_type_node;\n       break;\n     case CPP_STRING16:"}, {"sha": "767d97fbe581bc980d0cc82b99291a9cb19476f7", "filename": "gcc/c-parser.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parser.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -5349,6 +5349,7 @@ c_parser_postfix_expression (c_parser *parser)\n     case CPP_STRING16:\n     case CPP_STRING32:\n     case CPP_WSTRING:\n+    case CPP_UTF8STRING:\n       expr.value = c_parser_peek_token (parser)->value;\n       expr.original_code = STRING_CST;\n       c_parser_consume_token (parser);"}, {"sha": "be085ee11152ea85711b6f2ea11e8dfbb0acd4c3", "filename": "gcc/c-pragma.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-pragma.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fc-pragma.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.h?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -118,9 +118,9 @@ extern enum cpp_ttype pragma_lex (tree *);\n    so that 0 means to translate and join strings.  */\n #define C_LEX_STRING_NO_TRANSLATE 1 /* Do not lex strings into\n \t\t\t\t       execution character set.  */\n-#define C_LEX_RAW_STRINGS         2 /* Return raw strings -- no\n-\t\t\t\t       concatenation, no\n-\t\t\t\t       translation.  */\n+#define C_LEX_STRING_NO_JOIN\t  2 /* Do not concatenate strings\n+\t\t\t\t       nor translate them into execution\n+\t\t\t\t       character set.  */\n \n /* This is not actually available to pragma parsers.  It's merely a\n    convenient location to declare this function for c-lex, after"}, {"sha": "a068a432b1f3a47c9055d1e9f61213b99117b504", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -1,3 +1,10 @@\n+2009-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* parser.c (cp_lexer_print_token, cp_parser_is_string_literal,\n+\tcp_parser_string_literal, cp_parser_primary_expression): Likewise.\n+\t(cp_lexer_get_preprocessor_token): Use C_LEX_STRING_JOIN instead\n+\tof C_LEX_RAW_STRINGS.\n+\n 2009-10-15  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/38888"}, {"sha": "7fd995f9e83f705ea0e4ecc554526f96e05db4fb", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -402,7 +402,7 @@ cp_lexer_get_preprocessor_token (cp_lexer *lexer, cp_token *token)\n    /* Get a new token from the preprocessor.  */\n   token->type\n     = c_lex_with_flags (&token->u.value, &token->location, &token->flags,\n-\t\t\tlexer == NULL ? 0 : C_LEX_RAW_STRINGS);\n+\t\t\tlexer == NULL ? 0 : C_LEX_STRING_NO_JOIN);\n   token->keyword = RID_MAX;\n   token->pragma_kind = PRAGMA_NONE;\n \n@@ -792,6 +792,7 @@ cp_lexer_print_token (FILE * stream, cp_token *token)\n     case CPP_STRING16:\n     case CPP_STRING32:\n     case CPP_WSTRING:\n+    case CPP_UTF8STRING:\n       fprintf (stream, \" \\\"%s\\\"\", TREE_STRING_POINTER (token->u.value));\n       break;\n \n@@ -2065,7 +2066,8 @@ cp_parser_is_string_literal (cp_token* token)\n   return (token->type == CPP_STRING ||\n \t  token->type == CPP_STRING16 ||\n \t  token->type == CPP_STRING32 ||\n-\t  token->type == CPP_WSTRING);\n+\t  token->type == CPP_WSTRING ||\n+\t  token->type == CPP_UTF8STRING);\n }\n \n /* Returns nonzero if TOKEN is the indicated KEYWORD.  */\n@@ -3004,6 +3006,7 @@ cp_parser_string_literal (cp_parser *parser, bool translate, bool wide_ok)\n \t{\n \tdefault:\n \tcase CPP_STRING:\n+\tcase CPP_UTF8STRING:\n \t  TREE_TYPE (value) = char_array_type_node;\n \t  break;\n \tcase CPP_STRING16:\n@@ -3233,6 +3236,7 @@ cp_parser_primary_expression (cp_parser *parser,\n     case CPP_STRING16:\n     case CPP_STRING32:\n     case CPP_WSTRING:\n+    case CPP_UTF8STRING:\n       /* ??? Should wide strings be allowed when parser->translate_strings_p\n \t is false (i.e. in attributes)?  If not, we can kill the third\n \t argument to cp_parser_string_literal.  */"}, {"sha": "c91c4d427c349b7c9bf960189abb5605c4126709", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -1,5 +1,29 @@\n 2009-10-19  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* gcc.dg/raw-string-1.c: New test.\n+\t* gcc.dg/raw-string-2.c: New test.\n+\t* gcc.dg/raw-string-3.c: New test.\n+\t* gcc.dg/raw-string-4.c: New test.\n+\t* gcc.dg/raw-string-5.c: New test.\n+\t* gcc.dg/raw-string-6.c: New test.\n+\t* gcc.dg/raw-string-7.c: New test.\n+\t* gcc.dg/utf8-1.c: New test.\n+\t* gcc.dg/utf8-2.c: New test.\n+\t* gcc.dg/utf-badconcat2.c: New test.\n+\t* gcc.dg/utf-dflt2.c: New test.\n+\t* gcc.dg/cpp/include6.c: New test.\n+\t* g++.dg/ext/raw-string-1.C: New test.\n+\t* g++.dg/ext/raw-string-2.C: New test.\n+\t* g++.dg/ext/raw-string-3.C: New test.\n+\t* g++.dg/ext/raw-string-4.C: New test.\n+\t* g++.dg/ext/raw-string-5.C: New test.\n+\t* g++.dg/ext/raw-string-6.C: New test.\n+\t* g++.dg/ext/raw-string-7.C: New test.\n+\t* g++.dg/ext/utf8-1.C: New test.\n+\t* g++.dg/ext/utf8-2.C: New test.\n+\t* g++.dg/ext/utf-badconcat2.C: New test.\n+\t* g++.dg/ext/utf-dflt2.C: New test.\n+\n \t* gcc.dg/cleanup-13.c: New test.\n \n 2009-10-19  Janus Weil  <janus@gcc.gnu.org>"}, {"sha": "0e8abf8b498f00e756af7272dd930498987d74aa", "filename": "gcc/testsuite/g++.dg/ext/raw-string-1.C", "status": "added", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-1.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,96 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+const char s0[] = R\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char s1[] = \"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char s2[] = R\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char s3[] = \"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char t0[] = u8R\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char t1[] = u8\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char t2[] = u8R\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char t3[] = u8\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char16_t u0[] = uR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char16_t u1[] = u\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char16_t u2[] = uR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char16_t u3[] = u\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char32_t U0[] = UR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char32_t U1[] = U\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char32_t U2[] = UR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char32_t U3[] = U\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const wchar_t L0[] = LR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const wchar_t L1[] = L\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const wchar_t L2[] = LR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const wchar_t L3[] = L\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+int\n+main (void)\n+{\n+  if (sizeof (s0) != sizeof (s1)\n+      || __builtin_memcmp (s0, s1, sizeof (s0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (s2) != sizeof (s3)\n+      || __builtin_memcmp (s2, s3, sizeof (s2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (t0) != sizeof (t1)\n+      || __builtin_memcmp (t0, t1, sizeof (t0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (t2) != sizeof (t3)\n+      || __builtin_memcmp (t2, t3, sizeof (t2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (u0) != sizeof (u1)\n+      || __builtin_memcmp (u0, u1, sizeof (u0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (u2) != sizeof (u3)\n+      || __builtin_memcmp (u2, u3, sizeof (u2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (U0) != sizeof (U1)\n+      || __builtin_memcmp (U0, U1, sizeof (U0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (U2) != sizeof (U3)\n+      || __builtin_memcmp (U2, U3, sizeof (U2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (L0) != sizeof (L1)\n+      || __builtin_memcmp (L0, L1, sizeof (L0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (L2) != sizeof (L3)\n+      || __builtin_memcmp (L2, L3, sizeof (L2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (R\"*[]*\") != 1\n+      || __builtin_memcmp (R\"*[]*\", \"\", 1) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "c7eb602afecd594ece03cd45ab6d32173493fa26", "filename": "gcc/testsuite/g++.dg/ext/raw-string-2.C", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-2.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,104 @@\n+// { dg-do run }\n+// { dg-options \"-std=c++0x\" }\n+\n+#define R\n+#define u\n+#define uR\n+#define U\n+#define UR\n+#define u8\n+#define u8R\n+#define L\n+#define LR\n+\n+const char s00[] = R\"[a]\" \"[b]\";\n+const char s01[] = \"[a]\" R\"*[b]*\";\n+const char s02[] = R\"[a]\" R\"[b]\";\n+const char s03[] = R\"-[a]-\" u8\"[b]\";\n+const char s04[] = \"[a]\" u8R\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char s05[] = R\"[a]\" u8R\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char s06[] = u8R\";([a];(\" \"[b]\";\n+const char s07[] = u8\"[a]\" R\"[b]\";\n+const char s08[] = u8R\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char s09[] = u8R\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" u8\"[b]\";\n+const char s10[] = u8\"[a]\" u8R\"0123456789abcdef[b]0123456789abcdef\";\n+const char s11[] = u8R\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" u8R\"w[b]w\";\n+\n+const char16_t u03[] = R\"-[a]-\" u\"[b]\";\n+const char16_t u04[] = \"[a]\" uR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char16_t u05[] = R\"[a]\" uR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char16_t u06[] = uR\";([a];(\" \"[b]\";\n+const char16_t u07[] = u\"[a]\" R\"[b]\";\n+const char16_t u08[] = uR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char16_t u09[] = uR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" u\"[b]\";\n+const char16_t u10[] = u\"[a]\" uR\"0123456789abcdef[b]0123456789abcdef\";\n+const char16_t u11[] = uR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" uR\"w[b]w\";\n+\n+const char32_t U03[] = R\"-[a]-\" U\"[b]\";\n+const char32_t U04[] = \"[a]\" UR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char32_t U05[] = R\"[a]\" UR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char32_t U06[] = UR\";([a];(\" \"[b]\";\n+const char32_t U07[] = U\"[a]\" R\"[b]\";\n+const char32_t U08[] = UR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char32_t U09[] = UR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" U\"[b]\";\n+const char32_t U10[] = U\"[a]\" UR\"0123456789abcdef[b]0123456789abcdef\";\n+const char32_t U11[] = UR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" UR\"w[b]w\";\n+\n+const wchar_t L03[] = R\"-[a]-\" L\"[b]\";\n+const wchar_t L04[] = \"[a]\" LR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const wchar_t L05[] = R\"[a]\" LR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const wchar_t L06[] = LR\";([a];(\" \"[b]\";\n+const wchar_t L07[] = L\"[a]\" R\"[b]\";\n+const wchar_t L08[] = LR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const wchar_t L09[] = LR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" L\"[b]\";\n+const wchar_t L10[] = L\"[a]\" LR\"0123456789abcdef[b]0123456789abcdef\";\n+const wchar_t L11[] = LR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" LR\"w[b]w\";\n+\n+int\n+main (void)\n+{\n+#define TEST(str, val) \\\n+  if (sizeof (str) != sizeof (val) \\\n+      || __builtin_memcmp (str, val, sizeof (str)) != 0) \\\n+    __builtin_abort ()\n+  TEST (s00, \"a[b]\");\n+  TEST (s01, \"[a]b\");\n+  TEST (s02, \"ab\");\n+  TEST (s03, \"a[b]\");\n+  TEST (s04, \"[a]b\");\n+  TEST (s05, \"ab\");\n+  TEST (s06, \"a[b]\");\n+  TEST (s07, \"[a]b\");\n+  TEST (s08, \"ab\");\n+  TEST (s09, \"a[b]\");\n+  TEST (s10, \"[a]b\");\n+  TEST (s11, \"ab\");\n+  TEST (u03, u\"a[b]\");\n+  TEST (u04, u\"[a]b\");\n+  TEST (u05, u\"ab\");\n+  TEST (u06, u\"a[b]\");\n+  TEST (u07, u\"[a]b\");\n+  TEST (u08, u\"ab\");\n+  TEST (u09, u\"a[b]\");\n+  TEST (u10, u\"[a]b\");\n+  TEST (u11, u\"ab\");\n+  TEST (U03, U\"a[b]\");\n+  TEST (U04, U\"[a]b\");\n+  TEST (U05, U\"ab\");\n+  TEST (U06, U\"a[b]\");\n+  TEST (U07, U\"[a]b\");\n+  TEST (U08, U\"ab\");\n+  TEST (U09, U\"a[b]\");\n+  TEST (U10, U\"[a]b\");\n+  TEST (U11, U\"ab\");\n+  TEST (L03, L\"a[b]\");\n+  TEST (L04, L\"[a]b\");\n+  TEST (L05, L\"ab\");\n+  TEST (L06, L\"a[b]\");\n+  TEST (L07, L\"[a]b\");\n+  TEST (L08, L\"ab\");\n+  TEST (L09, L\"a[b]\");\n+  TEST (L10, L\"[a]b\");\n+  TEST (L11, L\"ab\");\n+  return 0;\n+}"}, {"sha": "46c486209050f302e5293ecccd0bb11e09f2d2e8", "filename": "gcc/testsuite/g++.dg/ext/raw-string-3.C", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-3.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,58 @@\n+// If c++98, the {,u,u8,U,L}R prefix should be parsed as separate\n+// token.\n+// { dg-do compile }\n+// { dg-options \"-std=c++98\" }\n+\n+const void\t*s0\t= R\"[a]\";\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 6 }\n+const void\t*s1\t= uR\"[a]\";\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 8 }\n+const void\t*s2\t= UR\"[a]\";\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 10 }\n+const void\t*s3\t= u8R\"[a]\";\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 12 }\n+const void\t*s4\t= LR\"[a]\";\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 14 }\n+\n+const int\ti0\t= R'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 17 }\n+const int\ti1\t= uR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 19 }\n+const int\ti2\t= UR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 21 }\n+const int\ti3\t= u8R'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 23 }\n+const int\ti4\t= LR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 25 }\n+\n+#define R\t\"a\"\n+#define uR\t\"b\"\n+#define UR\t\"c\"\n+#define u8R\t\"d\"\n+#define LR\t\"e\"\n+\n+const void\t*s5\t= R\"[a]\";\n+const void\t*s6\t= uR\"[a]\";\n+const void\t*s7\t= UR\"[a]\";\n+const void\t*s8\t= u8R\"[a]\";\n+const void\t*s9\t= LR\"[a]\";\n+\n+#undef R\n+#undef uR\n+#undef UR\n+#undef u8R\n+#undef LR\n+\n+#define R\t1 +\n+#define uR\t2 +\n+#define UR\t3 +\n+#define u8R\t4 +\n+#define LR\t5 +\n+\n+const int\ti5\t= R'a';\n+const int\ti6\t= uR'a';\n+const int\ti7\t= UR'a';\n+const int\ti8\t= u8R'a';\n+const int\ti9\t= LR'a';\n+\n+int main () {}"}, {"sha": "03179befac81a4a50642cdd0369de7be61059c62", "filename": "gcc/testsuite/g++.dg/ext/raw-string-4.C", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-4.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,28 @@\n+// R is not applicable for character literals.\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+const int\ti0\t= R'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 5 }\n+const int\ti1\t= uR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 7 }\n+const int\ti2\t= UR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 9 }\n+const int\ti3\t= u8R'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 11 }\n+const int\ti4\t= LR'a';\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 13 }\n+\n+#define R\t1 +\n+#define uR\t2 +\n+#define UR\t3 +\n+#define u8R\t4 +\n+#define LR\t5 +\n+\n+const int\ti5\t= R'a';\n+const int\ti6\t= uR'a';\n+const int\ti7\t= UR'a';\n+const int\ti8\t= u8R'a';\n+const int\ti9\t= LR'a';\n+\n+int main () {}"}, {"sha": "b815eb23b165e4a572fe32b8d7857da118882e32", "filename": "gcc/testsuite/g++.dg/ext/raw-string-5.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-5.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,23 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+const void *s0 = R\"0123456789abcdefg[]0123456789abcdefg\";\n+\t// { dg-error \"raw string delimiter longer\" \"\" { target *-*-* } 4 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 4 }\n+const void *s1 = R\" [] \";\n+\t// { dg-error \"invalid character\" \"\" { target *-*-* } 7 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 7 }\n+const void *s2 = R\"\t[]\t\";\n+\t// { dg-error \"invalid character\" \"\" { target *-*-* } 10 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 10 }\n+const void *s3 = R\"][]]\";\n+\t// { dg-error \"invalid character\" \"\" { target *-*-* } 13 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 13 }\n+const void *s4 = R\"@[]@\";\n+\t// { dg-error \"invalid character\" \"\" { target *-*-* } 16 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 16 }\n+const void *s5 = R\"$[]$\";\n+\t// { dg-error \"invalid character\" \"\" { target *-*-* } 19 }\n+\t// { dg-error \"stray\" \"\" { target *-*-* } 19 }\n+\n+int main () {}"}, {"sha": "a97d95d56938aab1688f1fc2eb90e2f7ad13a571", "filename": "gcc/testsuite/g++.dg/ext/raw-string-6.C", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-6.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,5 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+const void *s0 = R\"ouch[]ouCh\";\t// { dg-error \"at end of input\" }\n+\t// { dg-error \"unterminated raw string\" \"\" { target *-*-* } 4 }"}, {"sha": "0f479193433ddc6bcf6c2226137fe5361dc3933f", "filename": "gcc/testsuite/g++.dg/ext/raw-string-7.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fraw-string-7.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,23 @@\n+// The trailing whitespace after \\ and before newline extension\n+// breaks full compliance for raw strings.\n+// { dg-do run { xfail *-*-* } }\n+// { dg-options \"-std=c++0x\" }\n+\n+// Note, there is a single space after \\ on the following line.\n+const char *s0 = R\"[\\ \n+]\";\n+// { dg-bogus \"backslash and newline separated by space\" \"\" { xfail *-*-* } 7 }\n+\n+// Note, there is a single tab after \\ on the following line.\n+const char *s1 = R\"[\\\t\n+]\";\n+// { dg-bogus \"backslash and newline separated by space\" \"\" { xfail *-*-* } 12 }\n+\n+int\n+main (void)\n+{\n+  if (__builtin_strcmp (s0, \"\\\\ \\n\") != 0\n+      || __builtin_strcmp (s1, \"\\\\\\t\\n\") != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "499b323fc19b719d9bdc5052467e8e819d3b7f82", "filename": "gcc/testsuite/g++.dg/ext/utf-badconcat2.C", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-badconcat2.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,15 @@\n+// Test unsupported concatenation of UTF-8 string literals.\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+const void *s0\t= u8\"a\"   \"b\";\n+const void *s1\t=   \"a\" u8\"b\";\n+const void *s2\t= u8\"a\" u8\"b\";\n+const void *s3\t= u8\"a\"  u\"b\";\t// { dg-error \"non-standard concatenation\" }\n+const void *s4\t=  u\"a\" u8\"b\";\t// { dg-error \"non-standard concatenation\" }\n+const void *s5\t= u8\"a\"  U\"b\";\t// { dg-error \"non-standard concatenation\" }\n+const void *s6\t=  U\"a\" u8\"b\";\t// { dg-error \"non-standard concatenation\" }\n+const void *s7\t= u8\"a\"  L\"b\";\t// { dg-error \"non-standard concatenation\" }\n+const void *s8\t=  L\"a\" u8\"b\";\t// { dg-error \"non-standard concatenation\" }\n+\n+int main () {}"}, {"sha": "fd2222f672e577ec12fae0d0b856c55006aa9b6d", "filename": "gcc/testsuite/g++.dg/ext/utf-dflt2.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf-dflt2.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,12 @@\n+// In C++0x, the u8 prefix should be parsed as separate tokens.\n+// { dg-do compile }\n+// { dg-options \"-std=c++98\" }\n+\n+const void\t*s0 = u8\"a\";\t\t// { dg-error \"was not declared\" }\n+\t\t// { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 5 }\n+\n+#define u8\t\"a\"\n+\n+const void\t*s1 = u8\"a\";\n+\n+int main () {}"}, {"sha": "203b326af794c0073fa943c056761678f80c4b51", "filename": "gcc/testsuite/g++.dg/ext/utf8-1.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-1.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,45 @@\n+// { dg-do run }\n+// { dg-require-iconv \"ISO-8859-2\" }\n+// { dg-options \"-std=c++0x -fexec-charset=ISO-8859-2\" }\n+\n+const char *str1 = \"h\\u00e1\\U0000010Dky \";\n+const char *str2 = \"\\u010d\\u00E1rky\\n\";\n+const char *str3 = u8\"h\\u00e1\\U0000010Dky \";\n+const char *str4 = u8\"\\u010d\\u00E1rky\\n\";\n+const char *str5 = \"h\\u00e1\\U0000010Dky \" \"\\u010d\\u00E1rky\\n\";\n+const char *str6 = u8\"h\\u00e1\\U0000010Dky \" \"\\u010d\\u00E1rky\\n\";\n+const char *str7 = \"h\\u00e1\\U0000010Dky \" u8\"\\u010d\\u00E1rky\\n\";\n+#define u8\n+const char *str8 = u8\"h\\u00e1\\U0000010Dky \" u8\"\\u010d\\u00E1rky\\n\";\n+\n+const char latin2_1[] = \"\\x68\\xe1\\xe8\\x6b\\x79\\x20\";\n+const char latin2_2[] = \"\\xe8\\xe1\\x72\\x6b\\x79\\n\";\n+const char utf8_1[] = \"\\x68\\xc3\\xa1\\xc4\\x8d\\x6b\\x79\\x20\";\n+const char utf8_2[] = \"\\xc4\\x8d\\xc3\\xa1\\x72\\x6b\\x79\\n\";\n+\n+int\n+main (void)\n+{\n+  if (__builtin_strcmp (str1, latin2_1) != 0\n+      || __builtin_strcmp (str2, latin2_2) != 0\n+      || __builtin_strcmp (str3, utf8_1) != 0\n+      || __builtin_strcmp (str4, utf8_2) != 0\n+      || __builtin_strncmp (str5, latin2_1, sizeof (latin2_1) - 1) != 0\n+      || __builtin_strcmp (str5 + sizeof (latin2_1) - 1, latin2_2) != 0\n+      || __builtin_strncmp (str6, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str6 + sizeof (utf8_1) - 1, utf8_2) != 0\n+      || __builtin_strncmp (str7, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str7 + sizeof (utf8_1) - 1, utf8_2) != 0\n+      || __builtin_strncmp (str8, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str8 + sizeof (utf8_1) - 1, utf8_2) != 0)\n+    __builtin_abort ();\n+  if (sizeof (\"a\" u8\"b\"[0]) != 1\n+      || sizeof (u8\"a\" \"b\"[0]) != 1\n+      || sizeof (u8\"a\" u8\"b\"[0]) != 1\n+      || sizeof (\"a\" \"\\u010d\") != 3\n+      || sizeof (\"a\" u8\"\\u010d\") != 4\n+      || sizeof (u8\"a\" \"\\u010d\") != 4\n+      || sizeof (u8\"a\" \"\\u010d\") != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "417a8bfdc1ea9dda1867f4c50c0e284e6b9e0ba3", "filename": "gcc/testsuite/g++.dg/ext/utf8-2.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Futf8-2.C?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+// { dg-options \"-std=c++0x\" }\n+\n+const char\ts0[]\t= u8\"ab\";\n+const char16_t\ts1[]\t= u8\"ab\";\t// { dg-error \"from non-wide\" }\n+const char32_t  s2[]    = u8\"ab\";\t// { dg-error \"from non-wide\" }\n+const wchar_t   s3[]    = u8\"ab\";\t// { dg-error \"from non-wide\" }\n+\n+const char      t0[0]   = u8\"ab\";\t// { dg-error \"chars is too long\" }\n+const char      t1[1]   = u8\"ab\";\t// { dg-error \"chars is too long\" }\n+const char      t2[2]   = u8\"ab\";\t// { dg-error \"chars is too long\" }\n+const char      t3[3]   = u8\"ab\";\n+const char      t4[4]   = u8\"ab\";\n+\n+const char      u0[0]   = u8\"\\u2160.\";\t// { dg-error \"chars is too long\" }\n+const char      u1[1]   = u8\"\\u2160.\";\t// { dg-error \"chars is too long\" }\n+const char      u2[2]   = u8\"\\u2160.\";\t// { dg-error \"chars is too long\" }\n+const char      u3[3]   = u8\"\\u2160.\";\t// { dg-error \"chars is too long\" }\n+const char      u4[4]   = u8\"\\u2160.\";\t// { dg-error \"chars is too long\" }\n+const char      u5[5]   = u8\"\\u2160.\";\n+const char      u6[6]   = u8\"\\u2160.\";"}, {"sha": "2bb1320daa2bd5b0b0b69912342ee3f0c47003fd", "filename": "gcc/testsuite/gcc.dg/cpp/include6.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Finclude6.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do preprocess } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <stddef.h>\n+#include \"stddef.h\"\n+#include L\"stddef.h\"\t\t/* { dg-error \"include expects\" } */\n+#include u\"stddef.h\"\t\t/* { dg-error \"include expects\" } */\n+#include U\"stddef.h\"\t\t/* { dg-error \"include expects\" } */\n+#include u8\"stddef.h\"\t\t/* { dg-error \"include expects\" } */\n+#include R\"[stddef.h]\"\t\t/* { dg-error \"include expects\" } */\n+#include LR\"[stddef.h]\"\t\t/* { dg-error \"include expects\" } */\n+#include uR\"[stddef.h]\"\t\t/* { dg-error \"include expects\" } */\n+#include UR\"[stddef.h]\"\t\t/* { dg-error \"include expects\" } */\n+#include u8R\"[stddef.h]\"\t/* { dg-error \"include expects\" } */"}, {"sha": "b499e5cce690b2a9544204eabb21e2a6182ef7bd", "filename": "gcc/testsuite/gcc.dg/raw-string-1.c", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-1.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,101 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <wchar.h>\n+\n+typedef __CHAR16_TYPE__\tchar16_t;\n+typedef __CHAR32_TYPE__ char32_t;\n+\n+const char s0[] = R\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char s1[] = \"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char s2[] = R\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char s3[] = \"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char t0[] = u8R\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char t1[] = u8\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char t2[] = u8R\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char t3[] = u8\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char16_t u0[] = uR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char16_t u1[] = u\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char16_t u2[] = uR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char16_t u3[] = u\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const char32_t U0[] = UR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const char32_t U1[] = U\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const char32_t U2[] = UR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const char32_t U3[] = U\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+const wchar_t L0[] = LR\"[a\\\n+\\u010d\\U0000010D\\\\\\'\\\"\\?\\a\\b\\f\\n\\r\\t\\v\\0\\00\\000\\xa\\xabb\n+c]\";\n+const wchar_t L1[] = L\"a\\U0000010d\\u010d\\\\\\\\\\\\'\\\\\\\"\\\\?\\\\a\\\\b\\\\f\\\\n\\\\r\\\\t\\\\v\\\\0\\\\00\\\\000\\\\xa\\\\xabb\\nc\";\n+const wchar_t L2[] = LR\"*|*[a\\\n+b\n+c]\"\n+c]*|\"\n+c]*|*\";\n+const wchar_t L3[] = L\"ab\\nc]\\\"\\nc]*|\\\"\\nc\";\n+\n+int\n+main (void)\n+{\n+  if (sizeof (s0) != sizeof (s1)\n+      || __builtin_memcmp (s0, s1, sizeof (s0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (s2) != sizeof (s3)\n+      || __builtin_memcmp (s2, s3, sizeof (s2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (t0) != sizeof (t1)\n+      || __builtin_memcmp (t0, t1, sizeof (t0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (t2) != sizeof (t3)\n+      || __builtin_memcmp (t2, t3, sizeof (t2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (u0) != sizeof (u1)\n+      || __builtin_memcmp (u0, u1, sizeof (u0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (u2) != sizeof (u3)\n+      || __builtin_memcmp (u2, u3, sizeof (u2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (U0) != sizeof (U1)\n+      || __builtin_memcmp (U0, U1, sizeof (U0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (U2) != sizeof (U3)\n+      || __builtin_memcmp (U2, U3, sizeof (U2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (L0) != sizeof (L1)\n+      || __builtin_memcmp (L0, L1, sizeof (L0)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (L2) != sizeof (L3)\n+      || __builtin_memcmp (L2, L3, sizeof (L2)) != 0)\n+    __builtin_abort ();\n+  if (sizeof (R\"*[]*\") != 1\n+      || __builtin_memcmp (R\"*[]*\", \"\", 1) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "533abe2bc897a6b13558a497b9d3fa91f1ee9e7c", "filename": "gcc/testsuite/gcc.dg/raw-string-2.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-2.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,109 @@\n+/* { dg-do run } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <wchar.h>\n+\n+typedef __CHAR16_TYPE__\tchar16_t;\n+typedef __CHAR32_TYPE__ char32_t;\n+\n+#define R\n+#define u\n+#define uR\n+#define U\n+#define UR\n+#define u8\n+#define u8R\n+#define L\n+#define LR\n+\n+const char s00[] = R\"[a]\" \"[b]\";\n+const char s01[] = \"[a]\" R\"*[b]*\";\n+const char s02[] = R\"[a]\" R\"[b]\";\n+const char s03[] = R\"-[a]-\" u8\"[b]\";\n+const char s04[] = \"[a]\" u8R\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char s05[] = R\"[a]\" u8R\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char s06[] = u8R\";([a];(\" \"[b]\";\n+const char s07[] = u8\"[a]\" R\"[b]\";\n+const char s08[] = u8R\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char s09[] = u8R\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" u8\"[b]\";\n+const char s10[] = u8\"[a]\" u8R\"0123456789abcdef[b]0123456789abcdef\";\n+const char s11[] = u8R\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" u8R\"w[b]w\";\n+\n+const char16_t u03[] = R\"-[a]-\" u\"[b]\";\n+const char16_t u04[] = \"[a]\" uR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char16_t u05[] = R\"[a]\" uR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char16_t u06[] = uR\";([a];(\" \"[b]\";\n+const char16_t u07[] = u\"[a]\" R\"[b]\";\n+const char16_t u08[] = uR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char16_t u09[] = uR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" u\"[b]\";\n+const char16_t u10[] = u\"[a]\" uR\"0123456789abcdef[b]0123456789abcdef\";\n+const char16_t u11[] = uR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" uR\"w[b]w\";\n+\n+const char32_t U03[] = R\"-[a]-\" U\"[b]\";\n+const char32_t U04[] = \"[a]\" UR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const char32_t U05[] = R\"[a]\" UR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const char32_t U06[] = UR\";([a];(\" \"[b]\";\n+const char32_t U07[] = U\"[a]\" R\"[b]\";\n+const char32_t U08[] = UR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const char32_t U09[] = UR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" U\"[b]\";\n+const char32_t U10[] = U\"[a]\" UR\"0123456789abcdef[b]0123456789abcdef\";\n+const char32_t U11[] = UR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" UR\"w[b]w\";\n+\n+const wchar_t L03[] = R\"-[a]-\" L\"[b]\";\n+const wchar_t L04[] = \"[a]\" LR\"MNOPQRSTUVWXYZ[b]MNOPQRSTUVWXYZ\";\n+const wchar_t L05[] = R\"[a]\" LR\"wxyzABCDEFGHIJKL[b]wxyzABCDEFGHIJKL\";\n+const wchar_t L06[] = LR\";([a];(\" \"[b]\";\n+const wchar_t L07[] = L\"[a]\" R\"[b]\";\n+const wchar_t L08[] = LR\"[a]\" R\"_{}#()<>%:;.?*+-[b]_{}#()<>%:;.?*+-\";\n+const wchar_t L09[] = LR\"/^&|~!=,\"'\\[a]/^&|~!=,\"'\\\" L\"[b]\";\n+const wchar_t L10[] = L\"[a]\" LR\"0123456789abcdef[b]0123456789abcdef\";\n+const wchar_t L11[] = LR\"ghijklmnopqrstuv[a]ghijklmnopqrstuv\" LR\"w[b]w\";\n+\n+int\n+main (void)\n+{\n+#define TEST(str, val) \\\n+  if (sizeof (str) != sizeof (val) \\\n+      || __builtin_memcmp (str, val, sizeof (str)) != 0) \\\n+    __builtin_abort ()\n+  TEST (s00, \"a[b]\");\n+  TEST (s01, \"[a]b\");\n+  TEST (s02, \"ab\");\n+  TEST (s03, \"a[b]\");\n+  TEST (s04, \"[a]b\");\n+  TEST (s05, \"ab\");\n+  TEST (s06, \"a[b]\");\n+  TEST (s07, \"[a]b\");\n+  TEST (s08, \"ab\");\n+  TEST (s09, \"a[b]\");\n+  TEST (s10, \"[a]b\");\n+  TEST (s11, \"ab\");\n+  TEST (u03, u\"a[b]\");\n+  TEST (u04, u\"[a]b\");\n+  TEST (u05, u\"ab\");\n+  TEST (u06, u\"a[b]\");\n+  TEST (u07, u\"[a]b\");\n+  TEST (u08, u\"ab\");\n+  TEST (u09, u\"a[b]\");\n+  TEST (u10, u\"[a]b\");\n+  TEST (u11, u\"ab\");\n+  TEST (U03, U\"a[b]\");\n+  TEST (U04, U\"[a]b\");\n+  TEST (U05, U\"ab\");\n+  TEST (U06, U\"a[b]\");\n+  TEST (U07, U\"[a]b\");\n+  TEST (U08, U\"ab\");\n+  TEST (U09, U\"a[b]\");\n+  TEST (U10, U\"[a]b\");\n+  TEST (U11, U\"ab\");\n+  TEST (L03, L\"a[b]\");\n+  TEST (L04, L\"[a]b\");\n+  TEST (L05, L\"ab\");\n+  TEST (L06, L\"a[b]\");\n+  TEST (L07, L\"[a]b\");\n+  TEST (L08, L\"ab\");\n+  TEST (L09, L\"a[b]\");\n+  TEST (L10, L\"[a]b\");\n+  TEST (L11, L\"ab\");\n+  return 0;\n+}"}, {"sha": "9226411d2e0d883c705546e506ba8761ad7deb7c", "filename": "gcc/testsuite/gcc.dg/raw-string-3.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-3.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,53 @@\n+/* If not gnu99, the {,u,u8,U,L}R prefix should be parsed as separate\n+   token. */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+const void\t*s0\t= R\"[a]\";\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 6 } */\n+const void\t*s1\t= uR\"[a]\";\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 8 } */\n+const void\t*s2\t= UR\"[a]\";\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 10 } */\n+const void\t*s3\t= u8R\"[a]\";\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 12 } */\n+const void\t*s4\t= LR\"[a]\";\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 14 } */\n+\n+const int\ti0\t= R'a';\t\t/* { dg-error \"expected ',' or ';'\" } */\n+const int\ti1\t= uR'a';\t/* { dg-error \"expected ',' or ';'\" } */\n+const int\ti2\t= UR'a';\t/* { dg-error \"expected ',' or ';'\" } */\n+const int\ti3\t= u8R'a';\t/* { dg-error \"expected ',' or ';'\" } */\n+const int\ti4\t= LR'a';\t/* { dg-error \"expected ',' or ';'\" } */\n+\n+#define R\t\"a\"\n+#define uR\t\"b\"\n+#define UR\t\"c\"\n+#define u8R\t\"d\"\n+#define LR\t\"e\"\n+\n+const void\t*s5\t= R\"[a]\";\n+const void\t*s6\t= uR\"[a]\";\n+const void\t*s7\t= UR\"[a]\";\n+const void\t*s8\t= u8R\"[a]\";\n+const void\t*s9\t= LR\"[a]\";\n+\n+#undef R\n+#undef uR\n+#undef UR\n+#undef u8R\n+#undef LR\n+\n+#define R\t1 +\n+#define uR\t2 +\n+#define UR\t3 +\n+#define u8R\t4 +\n+#define LR\t5 +\n+\n+const int\ti5\t= R'a';\n+const int\ti6\t= uR'a';\n+const int\ti7\t= UR'a';\n+const int\ti8\t= u8R'a';\n+const int\ti9\t= LR'a';\n+\n+int main () {}"}, {"sha": "24d56ed7464cd5adaf9d3fc013a122ecadab2c09", "filename": "gcc/testsuite/gcc.dg/raw-string-4.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-4.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,28 @@\n+/* R is not applicable for character literals.  */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+const int\ti0\t= R'a';\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 5 } */\n+const int\ti1\t= uR'a';\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 7 } */\n+const int\ti2\t= UR'a';\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 9 } */\n+const int\ti3\t= u8R'a';\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 11 } */\n+const int\ti4\t= LR'a';\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 13 } */\n+\n+#define R\t1 +\n+#define uR\t2 +\n+#define UR\t3 +\n+#define u8R\t4 +\n+#define LR\t5 +\n+\n+const int\ti5\t= R'a';\n+const int\ti6\t= uR'a';\n+const int\ti7\t= UR'a';\n+const int\ti8\t= u8R'a';\n+const int\ti9\t= LR'a';\n+\n+int main () {}"}, {"sha": "3dbf97ded90820b6d09b6c7c48a35b7fb7873ce5", "filename": "gcc/testsuite/gcc.dg/raw-string-5.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-5.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+const void *s0 = R\"0123456789abcdefg[]0123456789abcdefg\";\n+\t/* { dg-error \"raw string delimiter longer\" \"\" { target *-*-* } 4 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 4 } */\n+const void *s1 = R\" [] \";\n+\t/* { dg-error \"invalid character\" \"\" { target *-*-* } 7 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 7 } */\n+const void *s2 = R\"\t[]\t\";\n+\t/* { dg-error \"invalid character\" \"\" { target *-*-* } 10 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 10 } */\n+const void *s3 = R\"][]]\";\n+\t/* { dg-error \"invalid character\" \"\" { target *-*-* } 13 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 13 } */\n+const void *s4 = R\"@[]@\";\n+\t/* { dg-error \"invalid character\" \"\" { target *-*-* } 16 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 16 } */\n+const void *s5 = R\"$[]$\";\n+\t/* { dg-error \"invalid character\" \"\" { target *-*-* } 19 } */\n+\t/* { dg-error \"stray\" \"\" { target *-*-* } 19 } */\n+\n+int main () {}"}, {"sha": "338087a25fde8058ca9c751993b7c47839fa62b7", "filename": "gcc/testsuite/gcc.dg/raw-string-6.c", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-6.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,5 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+const void *s0 = R\"ouch[]ouCh\";\t/* { dg-error \"expected expression at end of input\" } */\n+\t/* { dg-error \"unterminated raw string\" \"\" { target *-*-* } 4 } */"}, {"sha": "5bb4bec20856e77b320f88c8645665f9cb630930", "filename": "gcc/testsuite/gcc.dg/raw-string-7.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fraw-string-7.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,23 @@\n+/* The trailing whitespace after \\ and before newline extension\n+   breaks full compliance for raw strings.  */\n+/* { dg-do run { xfail *-*-* } } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+/* Note, there is a single space after \\ on the following line.  */\n+const void *s0 = R\"[\\ \n+]\";\n+/* { dg-bogus \"backslash and newline separated by space\" \"\" { xfail *-*-* } 7 } */\n+\n+/* Note, there is a single tab after \\ on the following line.  */\n+const void *s1 = R\"[\\\t\n+]\";\n+/* { dg-bogus \"backslash and newline separated by space\" \"\" { xfail *-*-* } 12 } */\n+\n+int\n+main (void)\n+{\n+  if (__builtin_strcmp (s0, \"\\\\ \\n\") != 0\n+      || __builtin_strcmp (s1, \"\\\\\\t\\n\") != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "ea71a7f6857911e5d615b59f77598e94d1679a65", "filename": "gcc/testsuite/gcc.dg/utf-badconcat2.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf-badconcat2.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,15 @@\n+/* Test unsupported concatenation of UTF-8 string literals. */\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+void\t*s0\t= u8\"a\"   \"b\";\n+void\t*s1\t=   \"a\" u8\"b\";\n+void\t*s2\t= u8\"a\" u8\"b\";\n+void\t*s3\t= u8\"a\"  u\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s4\t=  u\"a\" u8\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s5\t= u8\"a\"  U\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s6\t=  U\"a\" u8\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s7\t= u8\"a\"  L\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+void\t*s8\t=  L\"a\" u8\"b\";\t/* { dg-error \"non-standard concatenation\" } */\n+\n+int main () {}"}, {"sha": "ab101f45b787a8eb2fbe8c7c92b97662a133cbb3", "filename": "gcc/testsuite/gcc.dg/utf-dflt2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf-dflt2.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,12 @@\n+/* If not gnu99, the u8 prefix should be parsed as separate tokens. */\n+/* { dg-do compile } */\n+/* { dg-options \"\" } */\n+\n+const void\t*s0 = u8\"a\";\t\t/* { dg-error \"undeclared\" } */\n+\t\t/* { dg-error \"expected ',' or ';'\" \"\" { target *-*-* } 5 } */\n+\n+#define u8\t\"a\"\n+\n+const void\t*s1 = u8\"a\";\n+\n+int main () {}"}, {"sha": "e287e0656887d706eea7cd2f5406e5349f6bc5a5", "filename": "gcc/testsuite/gcc.dg/utf8-1.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-1.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do run } */\n+/* { dg-require-iconv \"ISO-8859-2\" } */\n+/* { dg-options \"-std=gnu99 -fexec-charset=ISO-8859-2\" } */\n+\n+const char *str1 = \"h\\u00e1\\U0000010Dky \";\n+const char *str2 = \"\\u010d\\u00E1rky\\n\";\n+const char *str3 = u8\"h\\u00e1\\U0000010Dky \";\n+const char *str4 = u8\"\\u010d\\u00E1rky\\n\";\n+const char *str5 = \"h\\u00e1\\U0000010Dky \" \"\\u010d\\u00E1rky\\n\";\n+const char *str6 = u8\"h\\u00e1\\U0000010Dky \" \"\\u010d\\u00E1rky\\n\";\n+const char *str7 = \"h\\u00e1\\U0000010Dky \" u8\"\\u010d\\u00E1rky\\n\";\n+#define u8\n+const char *str8 = u8\"h\\u00e1\\U0000010Dky \" u8\"\\u010d\\u00E1rky\\n\";\n+\n+const char latin2_1[] = \"\\x68\\xe1\\xe8\\x6b\\x79\\x20\";\n+const char latin2_2[] = \"\\xe8\\xe1\\x72\\x6b\\x79\\n\";\n+const char utf8_1[] = \"\\x68\\xc3\\xa1\\xc4\\x8d\\x6b\\x79\\x20\";\n+const char utf8_2[] = \"\\xc4\\x8d\\xc3\\xa1\\x72\\x6b\\x79\\n\";\n+\n+int\n+main (void)\n+{\n+  if (__builtin_strcmp (str1, latin2_1) != 0\n+      || __builtin_strcmp (str2, latin2_2) != 0\n+      || __builtin_strcmp (str3, utf8_1) != 0\n+      || __builtin_strcmp (str4, utf8_2) != 0\n+      || __builtin_strncmp (str5, latin2_1, sizeof (latin2_1) - 1) != 0\n+      || __builtin_strcmp (str5 + sizeof (latin2_1) - 1, latin2_2) != 0\n+      || __builtin_strncmp (str6, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str6 + sizeof (utf8_1) - 1, utf8_2) != 0\n+      || __builtin_strncmp (str7, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str7 + sizeof (utf8_1) - 1, utf8_2) != 0\n+      || __builtin_strncmp (str8, utf8_1, sizeof (utf8_1) - 1) != 0\n+      || __builtin_strcmp (str8 + sizeof (utf8_1) - 1, utf8_2) != 0)\n+    __builtin_abort ();\n+  if (sizeof (\"a\" u8\"b\"[0]) != 1\n+      || sizeof (u8\"a\" \"b\"[0]) != 1\n+      || sizeof (u8\"a\" u8\"b\"[0]) != 1\n+      || sizeof (\"a\" \"\\u010d\") != 3\n+      || sizeof (\"a\" u8\"\\u010d\") != 4\n+      || sizeof (u8\"a\" \"\\u010d\") != 4\n+      || sizeof (u8\"a\" \"\\u010d\") != 4)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "9c0442fde3f1f212dae31256afdb854756a1c152", "filename": "gcc/testsuite/gcc.dg/utf8-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Futf8-2.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-std=gnu99\" } */\n+\n+#include <wchar.h>\n+\n+typedef __CHAR16_TYPE__\tchar16_t;\n+typedef __CHAR32_TYPE__ char32_t;\n+\n+const char\ts0[]\t= u8\"ab\";\n+const char16_t\ts1[]\t= u8\"ab\";\t/* { dg-error \"from non-wide\" } */\n+const char32_t  s2[]    = u8\"ab\";\t/* { dg-error \"from non-wide\" } */\n+const wchar_t   s3[]    = u8\"ab\";\t/* { dg-error \"from non-wide\" } */\n+\n+const char      t0[0]   = u8\"ab\";\t/* { dg-warning \"chars is too long\" } */\n+const char      t1[1]   = u8\"ab\";\t/* { dg-warning \"chars is too long\" } */\n+const char      t2[2]   = u8\"ab\";\n+const char      t3[3]   = u8\"ab\";\n+const char      t4[4]   = u8\"ab\";\n+\n+const char      u0[0]   = u8\"\\u2160.\";\t/* { dg-warning \"chars is too long\" } */\n+const char      u1[1]   = u8\"\\u2160.\";\t/* { dg-warning \"chars is too long\" } */\n+const char      u2[2]   = u8\"\\u2160.\";\t/* { dg-warning \"chars is too long\" } */\n+const char      u3[3]   = u8\"\\u2160.\";\t/* { dg-warning \"chars is too long\" } */\n+const char      u4[4]   = u8\"\\u2160.\";\n+const char      u5[5]   = u8\"\\u2160.\";\n+const char      u6[6]   = u8\"\\u2160.\";"}, {"sha": "5946b29dc566ed0209ef67088b222a77d1b961aa", "filename": "libcpp/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2FChangeLog?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -1,3 +1,21 @@\n+2009-10-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* charset.c (cpp_init_iconv): Initialize utf8_cset_desc.\n+\t(_cpp_destroy_iconv): Destroy utf8_cset_desc, char16_cset_desc\n+\tand char32_cset_desc.\n+\t(converter_for_type): Handle CPP_UTF8STRING.\n+\t(cpp_interpret_string): Handle CPP_UTF8STRING and raw-strings.\n+\t* directives.c (get__Pragma_string): Handle CPP_UTF8STRING.\n+\t(parse_include): Reject raw strings.\n+\t* include/cpplib.h (CPP_UTF8STRING): New token type.\n+\t* internal.h (struct cpp_reader): Add utf8_cset_desc field.\n+\t* lex.c (lex_raw_string): New function.\n+\t(lex_string): Handle u8 string literals, call lex_raw_string\n+\tfor raw string literals.\n+\t(_cpp_lex_direct): Call lex_string even for u8\" and {,u,U,L,u8}R\"\n+\tsequences.\n+\t* macro.c (stringify_arg): Handle CPP_UTF8STRING.\n+\n 2009-10-14  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR preprocessor/41543"}, {"sha": "837ccd77aab1dfaead2afacbc2e1565900e588c6", "filename": "libcpp/charset.c", "status": "modified", "additions": 51, "deletions": 1, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fcharset.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fcharset.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fcharset.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -721,6 +721,8 @@ cpp_init_iconv (cpp_reader *pfile)\n \n   pfile->narrow_cset_desc = init_iconv_desc (pfile, ncset, SOURCE_CHARSET);\n   pfile->narrow_cset_desc.width = CPP_OPTION (pfile, char_precision);\n+  pfile->utf8_cset_desc = init_iconv_desc (pfile, \"UTF-8\", SOURCE_CHARSET);\n+  pfile->utf8_cset_desc.width = CPP_OPTION (pfile, char_precision);\n   pfile->char16_cset_desc = init_iconv_desc (pfile,\n \t\t\t\t\t     be ? \"UTF-16BE\" : \"UTF-16LE\",\n \t\t\t\t\t     SOURCE_CHARSET);\n@@ -741,6 +743,12 @@ _cpp_destroy_iconv (cpp_reader *pfile)\n     {\n       if (pfile->narrow_cset_desc.func == convert_using_iconv)\n \ticonv_close (pfile->narrow_cset_desc.cd);\n+      if (pfile->utf8_cset_desc.func == convert_using_iconv)\n+\ticonv_close (pfile->utf8_cset_desc.cd);\n+      if (pfile->char16_cset_desc.func == convert_using_iconv)\n+\ticonv_close (pfile->char16_cset_desc.cd);\n+      if (pfile->char32_cset_desc.func == convert_using_iconv)\n+\ticonv_close (pfile->char32_cset_desc.cd);\n       if (pfile->wide_cset_desc.func == convert_using_iconv)\n \ticonv_close (pfile->wide_cset_desc.cd);\n     }\n@@ -1339,6 +1347,8 @@ converter_for_type (cpp_reader *pfile, enum cpp_ttype type)\n     {\n     default:\n \treturn pfile->narrow_cset_desc;\n+    case CPP_UTF8STRING:\n+\treturn pfile->utf8_cset_desc;\n     case CPP_CHAR16:\n     case CPP_STRING16:\n \treturn pfile->char16_cset_desc;\n@@ -1373,7 +1383,47 @@ cpp_interpret_string (cpp_reader *pfile, const cpp_string *from, size_t count,\n   for (i = 0; i < count; i++)\n     {\n       p = from[i].text;\n-      if (*p == 'L' || *p == 'u' || *p == 'U') p++;\n+      if (*p == 'u')\n+\t{\n+\t  if (*++p == '8')\n+\t    p++;\n+\t}\n+      else if (*p == 'L' || *p == 'U') p++;\n+      if (*p == 'R')\n+\t{\n+\t  const uchar *prefix;\n+\n+\t  /* Skip over 'R\"'.  */\n+\t  p += 2;\n+\t  prefix = p;\n+\t  while (*p != '[')\n+\t    p++;\n+\t  p++;\n+\t  limit = from[i].text + from[i].len;\n+\t  if (limit >= p + (p - prefix) + 1)\n+\t    limit -= (p - prefix) + 1;\n+\n+\t  for (;;)\n+\t    {\n+\t      base = p;\n+\t      while (p < limit && (*p != '\\\\' || (p[1] != 'u' && p[1] != 'U')))\n+\t\tp++;\n+\t      if (p > base)\n+\t\t{\n+\t\t  /* We have a run of normal characters; these can be fed\n+\t\t     directly to convert_cset.  */\n+\t\t  if (!APPLY_CONVERSION (cvt, base, p - base, &tbuf))\n+\t\t    goto fail;\n+\t\t}\n+\t      if (p == limit)\n+\t\tbreak;\n+\n+\t      p = convert_ucn (pfile, p + 1, limit, &tbuf, cvt);\n+\t    }\n+\n+\t  continue;\n+\t}\n+\n       p++; /* Skip leading quote.  */\n       limit = from[i].text + from[i].len - 1; /* Skip trailing quote.  */\n "}, {"sha": "01bb599e26696f2f29057d8994feb11fc6c4c882", "filename": "libcpp/directives.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fdirectives.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fdirectives.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fdirectives.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -697,7 +697,8 @@ parse_include (cpp_reader *pfile, int *pangle_brackets,\n   /* Allow macro expansion.  */\n   header = get_token_no_padding (pfile);\n   *location = header->src_loc;\n-  if (header->type == CPP_STRING || header->type == CPP_HEADER_NAME)\n+  if ((header->type == CPP_STRING && header->val.str.text[0] != 'R')\n+      || header->type == CPP_HEADER_NAME)\n     {\n       fname = XNEWVEC (char, header->val.str.len - 1);\n       memcpy (fname, header->val.str.text + 1, header->val.str.len - 2);\n@@ -1537,7 +1538,8 @@ get__Pragma_string (cpp_reader *pfile)\n   if (string->type == CPP_EOF)\n     _cpp_backup_tokens (pfile, 1);\n   if (string->type != CPP_STRING && string->type != CPP_WSTRING\n-      && string->type != CPP_STRING32 && string->type != CPP_STRING16)\n+      && string->type != CPP_STRING32 && string->type != CPP_STRING16\n+      && string->type != CPP_UTF8STRING)\n     return NULL;\n \n   paren = get_token_no_padding (pfile);"}, {"sha": "e95f01a412a5e19817a330a496ede089a8ee59f6", "filename": "libcpp/include/cpplib.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Finclude%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Finclude%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finclude%2Fcpplib.h?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -127,6 +127,7 @@ struct _cpp_file;\n   TK(WSTRING,\t\tLITERAL) /* L\"string\" */\t\t\t\\\n   TK(STRING16,\t\tLITERAL) /* u\"string\" */\t\t\t\\\n   TK(STRING32,\t\tLITERAL) /* U\"string\" */\t\t\t\\\n+  TK(UTF8STRING,\tLITERAL) /* u8\"string\" */\t\t\t\\\n   TK(OBJC_STRING,\tLITERAL) /* @\"string\" - Objective-C */\t\t\\\n   TK(HEADER_NAME,\tLITERAL) /* <stdio.h> in #include */\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -728,10 +729,10 @@ extern const unsigned char *cpp_macro_definition (cpp_reader *,\n extern void _cpp_backup_tokens (cpp_reader *, unsigned int);\n extern const cpp_token *cpp_peek_token (cpp_reader *, int);\n \n-/* Evaluate a CPP_CHAR or CPP_WCHAR token.  */\n+/* Evaluate a CPP_*CHAR* token.  */\n extern cppchar_t cpp_interpret_charconst (cpp_reader *, const cpp_token *,\n \t\t\t\t\t  unsigned int *, int *);\n-/* Evaluate a vector of CPP_STRING or CPP_WSTRING tokens.  */\n+/* Evaluate a vector of CPP_*STRING* tokens.  */\n extern bool cpp_interpret_string (cpp_reader *,\n \t\t\t\t  const cpp_string *, size_t,\n \t\t\t\t  cpp_string *, enum cpp_ttype);"}, {"sha": "aaa231c2ab1cb8f70137d09464745e07681d83a4", "filename": "libcpp/internal.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Finternal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Finternal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Finternal.h?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -396,6 +396,10 @@ struct cpp_reader\n      execution character set.  */\n   struct cset_converter narrow_cset_desc;\n \n+  /* Descriptor for converting from the source character set to the\n+     UTF-8 execution character set.  */\n+  struct cset_converter utf8_cset_desc;\n+\n   /* Descriptor for converting from the source character set to the\n      UTF-16 execution character set.  */\n   struct cset_converter char16_cset_desc;"}, {"sha": "55bffa9a326e71a1b1d28b6d2122300401d94342", "filename": "libcpp/lex.c", "status": "modified", "additions": 213, "deletions": 10, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Flex.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -617,12 +617,192 @@ create_literal (cpp_reader *pfile, cpp_token *token, const uchar *base,\n   token->val.str.text = dest;\n }\n \n+/* Lexes a raw string.  The stored string contains the spelling, including\n+   double quotes, delimiter string, '[' and ']', any leading\n+   'L', 'u', 'U' or 'u8' and 'R' modifier.  It returns the type of the\n+   literal, or CPP_OTHER if it was not properly terminated.\n+\n+   The spelling is NUL-terminated, but it is not guaranteed that this\n+   is the first NUL since embedded NULs are preserved.  */\n+\n+static void\n+lex_raw_string (cpp_reader *pfile, cpp_token *token, const uchar *base,\n+\t\tconst uchar *cur)\n+{\n+  source_location saw_NUL = 0;\n+  const uchar *raw_prefix;\n+  unsigned int raw_prefix_len = 0;\n+  enum cpp_ttype type;\n+  size_t total_len = 0;\n+  _cpp_buff *first_buff = NULL, *last_buff = NULL;\n+\n+  type = (*base == 'L' ? CPP_WSTRING :\n+\t  *base == 'U' ? CPP_STRING32 :\n+\t  *base == 'u' ? (base[1] == '8' ? CPP_UTF8STRING : CPP_STRING16)\n+\t  : CPP_STRING);\n+\n+  raw_prefix = cur + 1;\n+  while (raw_prefix_len < 16)\n+    {\n+      switch (raw_prefix[raw_prefix_len])\n+\t{\n+\tcase ' ': case '[': case ']': case '\\t':\n+\tcase '\\v': case '\\f': case '\\n': default:\n+\t  break;\n+\t/* Basic source charset except the above chars.  */\n+\tcase 'a': case 'b': case 'c': case 'd': case 'e': case 'f':\n+\tcase 'g': case 'h': case 'i': case 'j': case 'k': case 'l':\n+\tcase 'm': case 'n': case 'o': case 'p': case 'q': case 'r':\n+\tcase 's': case 't': case 'u': case 'v': case 'w': case 'x':\n+\tcase 'y': case 'z':\n+\tcase 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n+\tcase 'G': case 'H': case 'I': case 'J': case 'K': case 'L':\n+\tcase 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+\tcase 'S': case 'T': case 'U': case 'V': case 'W': case 'X':\n+\tcase 'Y': case 'Z':\n+\tcase '0': case '1': case '2': case '3': case '4': case '5':\n+\tcase '6': case '7': case '8': case '9':\n+\tcase '_': case '{': case '}': case '#': case '(': case ')':\n+\tcase '<': case '>': case '%': case ':': case ';': case '.':\n+\tcase '?': case '*': case '+': case '-': case '/': case '^':\n+\tcase '&': case '|': case '~': case '!': case '=': case ',':\n+\tcase '\\\\': case '\"': case '\\'':\n+\t  raw_prefix_len++;\n+\t  continue;\n+\t}\n+      break;\n+    }\n+\n+  if (raw_prefix[raw_prefix_len] != '[')\n+    {\n+      int col = CPP_BUF_COLUMN (pfile->buffer, raw_prefix + raw_prefix_len)\n+\t\t+ 1;\n+      if (raw_prefix_len == 16)\n+\tcpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc, col,\n+\t\t\t     \"raw string delimiter longer than 16 characters\");\n+      else\n+\tcpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc, col,\n+\t\t\t     \"invalid character '%c' in raw string delimiter\",\n+\t\t\t     (int) raw_prefix[raw_prefix_len]);\n+      pfile->buffer->cur = raw_prefix - 1;\n+      create_literal (pfile, token, base, raw_prefix - 1 - base, CPP_OTHER);\n+      return;\n+    }\n+\n+  cur = raw_prefix + raw_prefix_len + 1;\n+  for (;;)\n+    {\n+      cppchar_t c = *cur++;\n+\n+      if (c == ']'\n+\t  && strncmp ((const char *) cur, (const char *) raw_prefix,\n+\t\t      raw_prefix_len) == 0\n+\t  && cur[raw_prefix_len] == '\"')\n+\t{\n+\t  cur += raw_prefix_len + 1;\n+\t  break;\n+\t}\n+      else if (c == '\\n')\n+\t{\n+\t  if (pfile->state.in_directive\n+\t      || pfile->state.parsing_args\n+\t      || pfile->state.in_deferred_pragma)\n+\t    {\n+\t      cur--;\n+\t      type = CPP_OTHER;\n+\t      cpp_error_with_line (pfile, CPP_DL_ERROR, token->src_loc, 0,\n+\t\t\t\t   \"unterminated raw string\");\n+\t      break;\n+\t    }\n+\n+\t  /* raw strings allow embedded non-escaped newlines, which\n+\t     complicates this routine a lot.  */\n+\t  if (first_buff == NULL)\n+\t    {\n+\t      total_len = cur - base;\n+\t      first_buff = last_buff = _cpp_get_buff (pfile, total_len);\n+\t      memcpy (BUFF_FRONT (last_buff), base, total_len);\n+\t      raw_prefix = BUFF_FRONT (last_buff) + (raw_prefix - base);\n+\t      BUFF_FRONT (last_buff) += total_len;\n+\t    }\n+\t  else\n+\t    {\n+\t      size_t len = cur - base;\n+\t      size_t cur_len = len > BUFF_ROOM (last_buff)\n+\t\t\t       ? BUFF_ROOM (last_buff) : len;\n+\n+\t      total_len += len;\n+\t      memcpy (BUFF_FRONT (last_buff), base, cur_len);\n+\t      BUFF_FRONT (last_buff) += cur_len;\n+\t      if (len > cur_len)\n+\t\t{\n+\t\t  last_buff = _cpp_append_extend_buff (pfile, last_buff,\n+\t\t\t\t\t\t       len - cur_len);\n+\t\t  memcpy (BUFF_FRONT (last_buff), base + cur_len,\n+\t\t\t  len - cur_len);\n+\t\t  BUFF_FRONT (last_buff) += len - cur_len;\n+\t\t}\n+\t    }\n+\n+\t  if (pfile->buffer->cur < pfile->buffer->rlimit)\n+\t    CPP_INCREMENT_LINE (pfile, 0);\n+\t  pfile->buffer->need_line = true;\n+\n+\t  if (!_cpp_get_fresh_line (pfile))\n+\t    {\n+\t      source_location src_loc = token->src_loc;\n+\t      token->type = CPP_EOF;\n+\t      /* Tell the compiler the line number of the EOF token.  */\n+\t      token->src_loc = pfile->line_table->highest_line;\n+\t      token->flags = BOL;\n+\t      if (first_buff != NULL)\n+\t\t_cpp_release_buff (pfile, first_buff);\n+\t      cpp_error_with_line (pfile, CPP_DL_ERROR, src_loc, 0,\n+\t\t\t\t   \"unterminated raw string\");\n+\t      return;\n+\t    }\n+\n+\t  cur = base = pfile->buffer->cur;\n+\t}\n+      else if (c == '\\0' && !saw_NUL)\n+\tLINEMAP_POSITION_FOR_COLUMN (saw_NUL, pfile->line_table,\n+\t\t\t\t     CPP_BUF_COLUMN (pfile->buffer, cur));\n+    }\n+\n+  if (saw_NUL && !pfile->state.skipping)\n+    cpp_error_with_line (pfile, CPP_DL_WARNING, saw_NUL, 0,\n+\t       \"null character(s) preserved in literal\");\n+\n+  pfile->buffer->cur = cur;\n+  if (first_buff == NULL)\n+    create_literal (pfile, token, base, cur - base, type);\n+  else\n+    {\n+      uchar *dest = _cpp_unaligned_alloc (pfile, total_len + (cur - base) + 1);\n+\n+      token->type = type;\n+      token->val.str.len = total_len + (cur - base);\n+      token->val.str.text = dest;\n+      last_buff = first_buff;\n+      while (last_buff != NULL)\n+\t{\n+\t  memcpy (dest, last_buff->base,\n+\t\t  BUFF_FRONT (last_buff) - last_buff->base);\n+\t  dest += BUFF_FRONT (last_buff) - last_buff->base;\n+\t  last_buff = last_buff->next;\n+\t}\n+      _cpp_release_buff (pfile, first_buff);\n+      memcpy (dest, base, cur - base);\n+      dest[cur - base] = '\\0';\n+    }\n+}\n+\n /* Lexes a string, character constant, or angle-bracketed header file\n    name.  The stored string contains the spelling, including opening\n-   quote and leading any leading 'L', 'u' or 'U'.  It returns the type\n-   of the literal, or CPP_OTHER if it was not properly terminated, or\n-   CPP_LESS for an unterminated header name which must be relexed as\n-   normal tokens.\n+   quote and any leading 'L', 'u', 'U' or 'u8' and optional\n+   'R' modifier.  It returns the type of the literal, or CPP_OTHER\n+   if it was not properly terminated, or CPP_LESS for an unterminated\n+   header name which must be relexed as normal tokens.\n \n    The spelling is NUL-terminated, but it is not guaranteed that this\n    is the first NUL since embedded NULs are preserved.  */\n@@ -636,12 +816,24 @@ lex_string (cpp_reader *pfile, cpp_token *token, const uchar *base)\n \n   cur = base;\n   terminator = *cur++;\n-  if (terminator == 'L' || terminator == 'u' || terminator == 'U')\n+  if (terminator == 'L' || terminator == 'U')\n     terminator = *cur++;\n-  if (terminator == '\\\"')\n+  else if (terminator == 'u')\n+    {\n+      terminator = *cur++;\n+      if (terminator == '8')\n+\tterminator = *cur++;\n+    }\n+  if (terminator == 'R')\n+    {\n+      lex_raw_string (pfile, token, base, cur);\n+      return;\n+    }\n+  if (terminator == '\"')\n     type = (*base == 'L' ? CPP_WSTRING :\n \t    *base == 'U' ? CPP_STRING32 :\n-\t    *base == 'u' ? CPP_STRING16 : CPP_STRING);\n+\t    *base == 'u' ? (base[1] == '8' ? CPP_UTF8STRING : CPP_STRING16)\n+\t\t\t : CPP_STRING);\n   else if (terminator == '\\'')\n     type = (*base == 'L' ? CPP_WCHAR :\n \t    *base == 'U' ? CPP_CHAR32 :\n@@ -1101,10 +1293,21 @@ _cpp_lex_direct (cpp_reader *pfile)\n     case 'L':\n     case 'u':\n     case 'U':\n-      /* 'L', 'u' or 'U' may introduce wide characters or strings.  */\n+    case 'R':\n+      /* 'L', 'u', 'U', 'u8' or 'R' may introduce wide characters,\n+\t wide strings or raw strings.  */\n       if (c == 'L' || CPP_OPTION (pfile, uliterals))\n \t{\n-\t  if (*buffer->cur == '\\'' || *buffer->cur == '\"')\n+\t  if ((*buffer->cur == '\\'' && c != 'R')\n+\t      || *buffer->cur == '\"'\n+\t      || (*buffer->cur == 'R'\n+\t\t  && c != 'R'\n+\t\t  && buffer->cur[1] == '\"'\n+\t\t  && CPP_OPTION (pfile, uliterals))\n+\t      || (*buffer->cur == '8'\n+\t\t  && c == 'u'\n+\t\t  && (buffer->cur[1] == '\"'\n+\t\t      || (buffer->cur[1] == 'R' && buffer->cur[2] == '\"'))))\n \t    {\n \t      lex_string (pfile, result, buffer->cur - 1);\n \t      break;\n@@ -1120,7 +1323,7 @@ _cpp_lex_direct (cpp_reader *pfile)\n     case 'y': case 'z':\n     case 'A': case 'B': case 'C': case 'D': case 'E': case 'F':\n     case 'G': case 'H': case 'I': case 'J': case 'K':\n-    case 'M': case 'N': case 'O': case 'P': case 'Q': case 'R':\n+    case 'M': case 'N': case 'O': case 'P': case 'Q':\n     case 'S': case 'T':           case 'V': case 'W': case 'X':\n     case 'Y': case 'Z':\n       result->type = CPP_NAME;"}, {"sha": "1d284cf9f8a9043fea21789d04d45d4b0a332a2f", "filename": "libcpp/macro.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c6e3f5540bc82374b7f71333f550cfccca93a74/libcpp%2Fmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcpp%2Fmacro.c?ref=2c6e3f5540bc82374b7f71333f550cfccca93a74", "patch": "@@ -379,7 +379,8 @@ stringify_arg (cpp_reader *pfile, macro_arg *arg)\n       escape_it = (token->type == CPP_STRING || token->type == CPP_CHAR\n \t\t   || token->type == CPP_WSTRING || token->type == CPP_WCHAR\n \t\t   || token->type == CPP_STRING32 || token->type == CPP_CHAR32\n-\t\t   || token->type == CPP_STRING16 || token->type == CPP_CHAR16);\n+\t\t   || token->type == CPP_STRING16 || token->type == CPP_CHAR16\n+\t\t   || token->type == CPP_UTF8STRING);\n \n       /* Room for each char being written in octal, initial space and\n \t final quote and NUL.  */"}]}