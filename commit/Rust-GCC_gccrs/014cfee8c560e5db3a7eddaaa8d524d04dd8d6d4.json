{"sha": "014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDE0Y2ZlZThjNTYwZTVkYjNhN2VkZGFhYThkNTI0ZDA0ZGQ4ZDZkNA==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T19:40:00Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-01-20T19:40:00Z"}, "message": "Initial revision\n\nFrom-SVN: r224", "tree": {"sha": "f893e8a99c76bbef77f4da2fac48052c9e0bb512", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f893e8a99c76bbef77f4da2fac48052c9e0bb512"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4/comments", "author": null, "committer": null, "parents": [{"sha": "b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4b4db944dc23dd538b742b4735fb4bf74b8cffa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4b4db944dc23dd538b742b4735fb4bf74b8cffa"}], "stats": {"total": 1513, "additions": 1513, "deletions": 0}, "files": [{"sha": "bf9ef3719d295184beb5a84fadc1cde2cb0c9c38", "filename": "gcc/config/pyr/pyr.h", "status": "added", "additions": 1432, "deletions": 0, "changes": 1432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4/gcc%2Fconfig%2Fpyr%2Fpyr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4/gcc%2Fconfig%2Fpyr%2Fpyr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpyr%2Fpyr.h?ref=014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "patch": "@@ -0,0 +1,1432 @@\n+/* Definitions of target machine parameters for GNU compiler,\n+   for Pyramid 90x, 9000, and MIServer Series.\n+   Copyright (C) 1989 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\f\n+/*\n+ * If you're going to change this, and you haven't already,\n+ * you should get and read\n+ * \t``OSx Operating System Porting Guide'',\n+ *\t  publication number 4100-0066-A\n+ *\t  Revision A\n+ *\t  Pyramid Technology Corporation.\n+ *\n+ * or whatever the most recent version is.  In any case, page and\n+ * section number references given herein refer to this document.\n+ *\n+ *  The instruction table for gdb lists the available insns and\n+ *  the valid addressing modes.\n+ *\n+ *  Any other information on the Pyramid architecture is proprietary\n+ *  and hard to get. (Pyramid cc -S and adb are also useful.)\n+ *\n+ */\n+\n+/*** Run-time compilation parameters selecting different hardware subsets. ***/\n+\n+/* Names to predefine in the preprocessor for this target machine.  */\n+\n+#define CPP_PREDEFINES \"-Dpyr -Dunix\"\n+\n+/* Print subsidiary information on the compiler version in use.  */\n+\n+#define TARGET_VERSION fprintf (stderr, \" (pyr)\");\n+\n+extern int target_flags;\n+\n+/* Nonzero if compiling code that Unix assembler can assemble.  */\n+#define TARGET_UNIX_ASM (target_flags & 1)\n+\n+/* Use the indexed addressing modes (were once not known to work).\n+   Leaving this in means we can disable them and so find out what\n+   they win us.  */\n+#define TARGET_INDEX (target_flags & 2)\n+\n+/* Implement stdarg in the same fashion used on all other machines.  */\n+#define TARGET_GNU_STDARG   (target_flags & 4)\n+\n+/* Compile using RETD to pop off the args.\n+   This will not work unless you use prototypes at least\n+   for all functions that can take varying numbers of args.\n+   This contravenes the Pyramid calling convention, so we don't\n+   do it yet.  */\n+\n+#define TARGET_RETD (target_flags & 8)\n+\n+/* Macros used in the machine description to test the flags.  */\n+\n+/* Macro to define tables used to set the flags.\n+   This is a list in braces of pairs in braces,\n+   each pair being { \"NAME\", VALUE }\n+   where VALUE is the bits to set or minus the bits to clear.\n+   An empty string NAME is used to identify the default VALUE.\n+\n+   -mgnu will be useful if we ever have GAS on a pyramid.\n+   -mindex was used to enable indexing when I didn't understand\n+    how pyramid's indexing modes worked.  */\n+\n+#define TARGET_SWITCHES  \\\n+  { {\"unix\", 1},  \t\t\\\n+    {\"gnu\", -1},  \t\t\\\n+    {\"index\", 2},\t\t\\\n+    {\"noindex\", -2},\t\t\\\n+    {\"gnu-stdarg\", 4},\t\t\\\n+    {\"nognu-stdarg\", -4},\t\\\n+    {\"retd\", 8},\t\t\\\n+    {\"no-retd\", -8},\t\t\\\n+    { \"\", TARGET_DEFAULT}}\n+\n+/* Default target_flags if no switches specified.\n+\n+   (equivalent to \"-munix -mindex -mgnu-stdarg\")  */\n+\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT (1 + 2 + 4)\n+#endif\n+\n+/* Never allow $ in identifiers */\n+\n+#define DOLLARS_IN_IDENTIFIERS 0\n+\f\n+/*** Target machine storage layout ***/\n+\n+/* Define this if most significant bit is lowest numbered\n+   in instructions that operate on numbered bit-fields.\n+   This is not true on the pyramid.  */\n+#define BITS_BIG_ENDIAN 0\n+\n+/* Define this if most significant byte of a word is the lowest numbered.  */\n+#define BYTES_BIG_ENDIAN 1\n+\n+/* Define this if most significant word of a multiword number is the lowest\n+   numbered.  */\n+#define WORDS_BIG_ENDIAN 1\n+\n+/* Number of bits in an addressable storage unit */\n+#define BITS_PER_UNIT 8\n+\n+/* Width in bits of a \"word\", which is the contents of a machine register.\n+   Note that this is not necessarily the width of data type `int';\n+   if using 16-bit ints on a 68000, this would still be 32.\n+   But on a machine with 16-bit registers, this would be 16.  */\n+#define BITS_PER_WORD 32\n+\n+/* Width of a word, in units (bytes).  */\n+#define UNITS_PER_WORD 4\n+\n+/* Width in bits of a pointer.\n+   See also the macro `Pmode' defined below.  */\n+#define POINTER_SIZE 32\n+\n+/* Allocation boundary (in *bits*) for storing arguments in argument list.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Boundary (in *bits*) on which stack pointer should be aligned.  */\n+#define STACK_BOUNDARY 32\n+\n+/* Allocation boundary (in *bits*) for the code of a function.  */\n+#define FUNCTION_BOUNDARY 32\n+\n+/* Alignment of field after `int : 0' in a structure.  */\n+#define EMPTY_FIELD_BOUNDARY 32\n+\n+/* No data type wants to be aligned rounder than this.  */\n+#define BIGGEST_ALIGNMENT 32\n+\n+/* Specified types of bitfields affect alignment of those fields\n+   and of the structure as a whole.  */\n+#define PCC_BITFIELD_TYPE_MATTERS\n+\n+/* Make strings word-aligned so strcpy from constants will be faster. \n+   Pyramid documentation says the best alignment is to align\n+   on the size of a cache line, which is 32 bytes.\n+   Newer pyrs have single insns that do strcmp() and strcpy(), so this\n+   may not actually win anything.   */\n+\n+#define CONSTANT_ALIGNMENT(EXP, ALIGN)  \\\n+  (TREE_CODE (EXP) == STRING_CST\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Make arrays of chars word-aligned for the same reasons.  */\n+#define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n+  (TREE_CODE (TYPE) == ARRAY_TYPE\t\t\\\n+   && TYPE_MODE (TREE_TYPE (TYPE)) == QImode\t\\\n+   && (ALIGN) < BITS_PER_WORD ? BITS_PER_WORD : (ALIGN))\n+\n+/* Define this if move instructions will actually fail to work\n+   when given unaligned data.  */\n+#define STRICT_ALIGNMENT\n+\f\n+/*** Standard register usage.  ***/\n+\n+/* Number of actual hardware registers.\n+   The hardware registers are assigned numbers for the compiler\n+   from 0 to just below FIRST_PSEUDO_REGISTER.\n+   All registers that the compiler knows about must be given numbers,\n+   even those that are not normally considered general registers.  */\n+\n+/* Nota Bene:\n+   Pyramids have 64 addressable 32-bit registers, arranged as four\n+   groups of sixteen registers each. Pyramid names the groups\n+   global, parameter, local, and temporary.\n+\n+   The sixteen global registers are fairly conventional; the last\n+   four are overloaded with a PSW, frame pointer, stack pointer, and pc.\n+   The non-dedicated global registers used to be reserved for Pyramid\n+   operating systems, and still have cryptic and undocumented uses for\n+   certain library calls.  We do not use global registers gr0 through\n+   gr11.\n+\n+   The parameter, local, and temporary registers provide register\n+   windowing.  Each procedure call has its own set of these 48\n+   registers, which constitute its call frame. (These frames are\n+   not allocated on the conventional stack, but contiguously\n+   on a separate stack called the control stack.)\n+   Register windowing is a facility whereby the temporary registers\n+   of frame n become the parameter registers of frame n+1, viz.:\n+\n+                                      0         15 0         15 0         15\n+                                     +------------+------------+------------+\n+frame n+1                            |            |            |            |\n+                                     +------------+------------+------------+\n+                                        Parameter     Local       Temporary\n+\n+                                          ^\n+                                          | These 16 regs are the same.\n+                                          v\n+\n+            0         15 0         15 0         15\n+           +------------+------------+------------+\n+frame n    |            |            |            |\n+           +------------+------------+------------+\n+             Parameter     Local       Temporary\n+\n+   New frames are automatically allocated on the control stack by the\n+   call instruction and de-allocated by the return insns \"ret\" and\n+   \"retd\".  The control-stack grows contiguously upward from a\n+   well-known address in memory; programs are free to allocate\n+   a variable sized, conventional frame on the data stack, which\n+   grows downwards in memory from just below the control stack.\n+\n+   Temporary registers are used for parameter passing, and are not\n+   preserved across calls.  TR0 through TR11 correspond to\n+   gcc's ``input'' registers; PR0 through TR11 the ``output''\n+   registers. The call insn stores the PC and PSW in PR14 and PR15 of\n+   the frame it creates; the return insns restore these into the PC\n+   and PSW. The same is true for interrupts; TR14 and TR15 of the\n+   current frame are reserved and should never be used, since an\n+   interrupt may occur at any time and clobber them.\n+\n+   An interesting quirk is the ability to take the address of a\n+   variable in a windowed register.  This done by adding the memory\n+   address of the base of the current window frame, to the offset\n+   within the frame of the desired register.  The resulting address\n+   can be treated just like any other pointer; if a quantity is stored\n+   into that address, the appropriate register also changes.\n+   GCC does not, and according to RMS will not, support this feature,\n+   even though some programs rely on this (mis)feature.\n+ */\n+\n+#define PYR_GREG(n) (n)\n+#define PYR_PREG(n) (16+(n))\n+#define PYR_LREG(n) (32+(n))\n+#define PYR_TREG(n) (48+(n))\n+\n+#define FIRST_PSEUDO_REGISTER 64\n+\n+/* 1 for registers that have pervasive standard uses\n+   and are not available for the register allocator.\n+\n+   On the pyramid, these are LOGPSW, CFP, SP, PC, and all the other \n+   global regs.  */\n+\n+#define FIXED_REGISTERS \\\n+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+\n+/* 1 for registers not available across function calls.\n+   These must include the FIXED_REGISTERS and also any\n+   registers that can be used without being saved.\n+   The latter must include the registers where values are returned\n+   and the register where structure-value addresses are passed.\n+   Aside from that, you can include as many other registers as you like.  */\n+#define CALL_USED_REGISTERS \\\n+  {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1,\t\\\n+   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\\\n+   1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1}\n+\n+/* #define DEFAULT_CALLER_SAVES */\n+\n+/* Return number of consecutive hard regs needed starting at reg REGNO\n+   to hold something of mode MODE.\n+   This is ordinarily the length in words of a value of mode MODE\n+   but can be less for certain modes in special long registers.\n+   On the pyramid, all registers are one word long.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)   \\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n+   On the pyramid, all registers can hold all modes.  */\n+\n+/* -->FIXME: this is not the case for 64-bit quantities in tr11/12 through\n+   --> TR14/15.  This should be fixed,  but to do it correctly, we also\n+   --> need to fix MODES_TIEABLE_P. Yuk.  We ignore this, since GCC should\n+   --> do the \"right\" thing due to FIXED_REGISTERS. */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+/* Value is 1 if it is a good idea to tie two pseudo registers\n+   when one has mode MODE1 and one has mode MODE2.\n+   If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n+   for any hard reg, then this must be 0 for correct output.  */\n+#define MODES_TIEABLE_P(MODE1, MODE2) 1\n+\n+/* Specify the registers used for certain standard purposes.\n+   The values of these macros are register numbers.  */\n+\n+/* Pyramid pc is overloaded on global register 15.  */\n+#define PC_REGNUM PYR_GREG(15)\n+\n+/* Register to use for pushing function arguments.\n+   --> on Pyramids, the data stack pointer. */\n+#define STACK_POINTER_REGNUM PYR_GREG(14)\n+\n+/* Base register for access to local variables of the function.\n+   Pyramid uses CFP (GR13) as both frame pointer and argument pointer. */\n+#define FRAME_POINTER_REGNUM 13 /* PYR_GREG(13) */\n+\n+/* Value should be nonzero if functions must have frame pointers.\n+   Zero means the frame pointer need not be set up (and parms\n+   may be accessed via the stack pointer) in functions that seem suitable.\n+   This is computed in `reload', in reload1.c.\n+\n+   Setting this to 1 can't break anything.  Since the Pyramid has\n+   register windows, I don't know if defining this to be zero can\n+   win anything.  It could changed later, if it wins. */\n+#define FRAME_POINTER_REQUIRED 1\n+\n+/* Base register for access to arguments of the function.  */\n+#define ARG_POINTER_REGNUM 13 /* PYR_GREG(13) */\n+\n+/* Register in which static-chain is passed to a function.  */\n+/* If needed, Pyramid says to use temporary register 12. */\n+#define STATIC_CHAIN_REGNUM PYR_TREG(12)\n+\n+/* Register in which address to store a structure value\n+   is passed to a function.\n+   On a Pyramid, this is temporary register 0 (TR0).   */\n+\n+#define STRUCT_VALUE_REGNUM PYR_TREG(0)\n+#define STRUCT_VALUE_INCOMING_REGNUM PYR_PREG(0)\n+\f\n+/* Define the classes of registers for register constraints in the\n+   machine description.  Also define ranges of constants.\n+\n+   One of the classes must always be named ALL_REGS and include all hard regs.\n+   If there is more than one class, another class must be named NO_REGS\n+   and contain no registers.\n+\n+   The name GENERAL_REGS must be the name of a class (or an alias for\n+   another name such as ALL_REGS).  This is the class of registers\n+   that is allowed by \"g\" or \"r\" in a register constraint.\n+   Also, registers outside this class are allocated only when\n+   instructions express preferences for them.\n+\n+   The classes must be numbered in nondecreasing order; that is,\n+   a larger-numbered class must never be contained completely\n+   in a smaller-numbered class.\n+\n+   For any two classes, it is very desirable that there be another\n+   class that represents their union.  */\n+\n+/* The pyramid has only one kind of registers, so NO_REGS and ALL_REGS\n+   are the only classes.  */\n+\n+enum reg_class { NO_REGS, ALL_REGS, LIM_REG_CLASSES };\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+/* Since GENERAL_REGS is the same class as ALL_REGS,\n+   don't give it a different class number; just make it an alias.  */\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+/* Give names of register classes as strings for dump file.   */\n+\n+#define REG_CLASS_NAMES \\\n+ {\"NO_REGS\", \"ALL_REGS\" }\n+\n+/* Define which registers fit in which classes.\n+   This is an initializer for a vector of HARD_REG_SET\n+   of length N_REG_CLASSES.  */\n+\n+#define REG_CLASS_CONTENTS {{0,0}, {0xffffffff,0xffffffff}}\n+\n+/* The same information, inverted:\n+   Return the class number of the smallest class containing\n+   reg number REGNO.  This could be a conditional expression\n+   or could index an array.  */\n+\n+#define REGNO_REG_CLASS(REGNO) ALL_REGS\n+\n+/* The class value for index registers, and the one for base regs.  */\n+\n+#define BASE_REG_CLASS ALL_REGS\n+#define INDEX_REG_CLASS ALL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine description.  */\n+\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* Given an rtx X being reloaded into a reg required to be\n+   in class CLASS, return the class of reg to actually use.\n+   In general this is just CLASS; but on some machines\n+   in some cases it is preferable to use a more restrictive class.  */\n+\n+#define PREFERRED_RELOAD_CLASS(X,CLASS)  (CLASS)\n+\n+/* Return the maximum number of consecutive registers\n+   needed to represent mode MODE in a register of class CLASS.  */\n+/* On the pyramid, this is always the size of MODE in words,\n+   since all registers are the same size.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\\\n+ ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* The letters I, J, K, L and M in a register constraint string\n+   can be used to stand for particular ranges of immediate operands.\n+   This macro defines what the ranges are.\n+   C is the letter, and VALUE is a constant value.\n+   Return 1 if VALUE is in the range specified by C.\n+\n+   --> For the Pyramid, 'I' can be used for the 6-bit signed integers\n+   --> (-32 to 31) allowed as immediate short operands in many\n+   --> instructions. 'J' cane be used for any value that doesn't fit\n+   --> in 6 bits.  */\n+\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)  \\\n+  ((C) == 'I' ? (VALUE) >= -32 && (VALUE) < 32 : \\\n+   (C) == 'J' ? (VALUE) < -32 || (VALUE) >= 32 : \\\n+   (C) == 'K' ? (VALUE) == 0xff || (VALUE) == 0xffff : 0)\n+\n+/* Similar, but for floating constants, and defining letters G and H.\n+   Here VALUE is the CONST_DOUBLE rtx itself.  */\n+\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C) 0\n+\n+\f\n+/*** Stack layout; function entry, exit and calling.  ***/\n+\n+/* Define this if pushing a word on the stack\n+   makes the stack pointer a smaller address.  */\n+#define STACK_GROWS_DOWNWARD\n+\n+/* Define this if the nominal address of the stack frame\n+   is at the high-address end of the local variables;\n+   that is, each additional local variable allocated\n+   goes at a more negative offset in the frame.  */\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* Offset within stack frame to start allocating local variables at.\n+   If FRAME_GROWS_DOWNWARD, this is the offset to the END of the\n+   first local allocated.  Otherwise, it is the offset to the BEGINNING\n+   of the first local allocated.  */\n+/* FIXME: this used to work when defined as 0.  But that makes gnu\n+   stdargs clobber the first arg.  What gives?? */\n+#define STARTING_FRAME_OFFSET 0\n+\n+/* Offset of first parameter from the argument pointer register value.  */\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+/* Value is the number of bytes of arguments automatically\n+   popped when returning from a subroutine call.\n+   FUNTYPE is the data type of the function (as a tree),\n+   or for a library call it is an identifier node for the subroutine name.\n+   SIZE is the number of bytes of arguments passed on the stack.\n+\n+   The Pyramid OSx Porting Guide says we are never to do this;\n+   using RETD in this way violates the Pyramid calling convention.\n+   We may nevertheless provide this as an option.   */\n+\n+#define RETURN_POPS_ARGS(FUNTYPE,SIZE)   \\\n+  ((TARGET_RETD && TREE_CODE (FUNTYPE) != IDENTIFIER_NODE\t\\\n+    && (TYPE_ARG_TYPES (FUNTYPE) == 0\t\t\t\t\\\n+\t|| (TREE_VALUE (tree_last (TYPE_ARG_TYPES (FUNTYPE)))\t\\\n+\t    == void_type_node)))\t\t\t\t\\\n+   ? (SIZE) : 0)\n+\n+/* Define how to find the value returned by a function.\n+   VALTYPE is the data type of the value (as a tree).\n+   If the precise function being called is known, FUNC is its FUNCTION_DECL;\n+   otherwise, FUNC is 0.  */\n+\n+/* --> Pyramid has register windows.\n+   --> The caller sees the return value is in TR0(/TR1) regardless of\n+   --> its type.   */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), PYR_TREG(0))\n+\n+/* --> but the callee has to leave it in PR0(/PR1) */\n+\n+#define FUNCTION_OUTGOING_VALUE(VALTYPE, FUNC)\t\\\n+  gen_rtx (REG, TYPE_MODE (VALTYPE), PYR_PREG(0))\n+\n+/* Define how to find the value returned by a library function\n+   assuming the value has mode MODE.  */\n+\n+/* --> On Pyramid the return value is in TR0/TR1 regardless.  */\n+\n+#define LIBCALL_VALUE(MODE)  gen_rtx (REG, MODE, PYR_TREG(0))\n+\n+/* Define this if PCC uses the nonreentrant convention for returning\n+   structure and union values.  */\n+\n+#define PCC_STATIC_STRUCT_RETURN\n+\n+/* 1 if N is a possible register number for a function value\n+   as seen by the caller.\n+\n+  On the Pyramid, TR0 is the only register thus used.   */\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == PYR_TREG(0))\n+\n+/* 1 if N is a possible register number for function argument passing.\n+   On the Pyramid, the first twelve temporary registers are available.  */\n+\n+/* FIXME FIXME FIXME\n+   it's not clear whether this macro should be defined from the point\n+   of view of the caller or the callee.  Since it's never actually used\n+   in GNU CC, the point is somewhat moot :-).\n+\n+   This definition is consistent with register usage in the md's for\n+   other register-window architectures (sparc and spur).\n+ */\n+#define FUNCTION_ARG_REGNO_P(N) ((PYR_TREG(0) <= (N)) && ((N) <= PYR_TREG(11)))\n+\f\n+/*** Parameter passing: FUNCTION_ARG and FUNCTION_INCOMING_ARG ***/\n+\n+/* Define a data type for recording info about an argument list\n+   during the scan of that argument list.  This data type should\n+   hold all necessary information about the function itself\n+   and about the args processed so far, enough to enable macros\n+   such as FUNCTION_ARG to determine where the next arg should go.\n+\n+   On Pyramids, each parameter is passed either completely on the stack\n+   or completely in registers.  No parameter larger than a double may\n+   be passed in a register.  Also, no struct or union may be passed in\n+   a register, even if it would fit.\n+\n+    So parameters are not necessarily passed \"consecutively\".\n+    Thus we need a vector data type: one element to record how many\n+    parameters have been passed in registers and on the stack,\n+    respectively.\n+\n+    ((These constraints seem like a gross waste of registers. But if we\n+    ignore the constraint about structs & unions, we won`t be able to\n+    freely mix gcc-compiled code and pyr cc-compiled code.  It looks\n+    like better argument passing conventions, and a machine-dependent\n+    flag to enable them, might be a win.))   */\n+\n+\n+#define CUMULATIVE_ARGS int\n+\n+/* Define the number of registers that can hold paramters.\n+   This macro is used only in other macro definitions below.   */\n+#define NPARM_REGS 12\n+\n+/* Decide whether or not a parameter can be put in a register.\n+   (We may still have problems with libcalls. GCC doesn't seem\n+   to know about anything more than the machine mode.  I trust\n+   structures are never passed to a libcall...\n+\n+   If compiling with -mgnu-stdarg, this definition should make\n+   functions using the gcc-supplied stdarg, and calls to such\n+   functions (declared with an arglist ending in\"...\"),  work.\n+   But such fns won't be able to call pyr cc-compiled\n+   varargs fns (eg, printf(), _doprnt.)\n+\n+   If compiling with -mnognu-stdarg, this definition should make\n+   calls to pyr cc-compiled functions work.  Functions using\n+   the gcc-supplied stdarg will be utterly broken.\n+   There will be no better solution until RMS can be persuaded that\n+   one is needed.\n+\n+   This macro is used only in other macro definitions below.\n+   (well, it may be used in pyr.c, because the damn pyramid cc\n+   can't handle the macro definition of PARAM_SAFE_FOR_REG_P !   */\n+\n+\n+#define INNER_PARAM_SAFE_HELPER(TYPE) \\\n+ ((TARGET_GNU_STDARG ? (! TREE_ADDRESSABLE ((tree)TYPE)): 1)\t\\\n+   && (TREE_CODE ((tree)TYPE) != RECORD_TYPE)\t\t\t\\\n+   && (TREE_CODE ((tree)TYPE) != UNION_TYPE))\n+\n+#ifdef __GNUC__\n+#define PARAM_SAFE_HELPER(TYPE) \\\n+  INNER_PARAM_SAFE_HELPER((TYPE))\n+#else\n+extern int inner_param_safe_helper();\n+#define PARAM_SAFE_HELPER(TYPE) \\\n+  inner_param_safe_helper((tree)(TYPE))\n+#endif\n+\n+/* Be careful with the expression (long) (TYPE) == 0.\n+   Writing it in more obvious/correct forms makes the Pyr cc\n+   dump core!   */\n+#define PARAM_SAFE_FOR_REG_P(MODE, TYPE, NAMED) \\\n+  (((MODE) != BLKmode)\t\t\t\t\\\n+   && ((TARGET_GNU_STDARG) ? (NAMED) : 1)\t\\\n+   && ((((long)(TYPE))==0) || PARAM_SAFE_HELPER((TYPE))))\n+\n+/* Initialize a variable CUM of type CUMULATIVE_ARGS\n+   for a call to a function whose data type is FNTYPE.\n+   For a library call, FNTYPE is 0.   */\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME) \\\n+  ((CUM) = (FNTYPE && !flag_pcc_struct_return && aggregate_value_p (FNTYPE)))\n+\n+/* Determine where to put an argument to a function.\n+   Value is zero to push the argument on the stack,\n+   or a hard register in which to store the argument.\n+\n+   MODE is the argument's machine mode.\n+   TYPE is the data type of the argument (as a tree).\n+    This is null for libcalls where that information may\n+    not be available.\n+   CUM is a variable of type CUMULATIVE_ARGS which gives info about\n+    the preceding args and about the function being called.\n+   NAMED is nonzero if this argument is a named parameter\n+    (otherwise it is an extra parameter matching an ellipsis). */\n+\n+#define FUNCTION_ARG_HELPER(CUM, MODE, TYPE, NAMED) \\\n+(PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\t\t\t\\\n+ ? (NPARM_REGS >= ((CUM)\t\t\t\t\t\\\n+\t\t   + ((MODE) == BLKmode\t\t\t\t\\\n+\t\t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n+\t\t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n+    ? gen_rtx (REG, (MODE), PYR_TREG(CUM))\t\t\t\\\n+    : 0)\t\t\t\t\t\t\t\\\n+ : 0)\n+#ifdef __GNUC__\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED) \\\n+\tFUNCTION_ARG_HELPER(CUM, MODE, TYPE, NAMED)\n+#else\n+/*****************  Avoid bug in Pyramid OSx compiler... ******************/\n+#define FUNCTION_ARG  (rtx) pyr_function_arg\n+extern void* pyr_function_arg ();\n+#endif\n+\n+/* Define where a function finds its arguments.\n+   This is different from FUNCTION_ARG because of register windows.  */\n+\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED) \\\n+(PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\t\t\\\n+ ? (NPARM_REGS >= ((CUM)\t\t\t\t\\\n+\t   + ((MODE) == BLKmode\t\t\t\t\\\n+\t      ? (int_size_in_bytes (TYPE) + 3) / 4\t\\\n+\t      : (GET_MODE_SIZE (MODE) + 3) / 4))\t\\\n+    ? gen_rtx (REG, (MODE), PYR_PREG(CUM))\t\t\\\n+    : 0)\t\t\t\t\t\t\\\n+ : 0)\n+\n+/* Update the data in CUM to advance over an argument\n+   of mode MODE and data type TYPE.\n+   (TYPE is null for libcalls where that information may not be available.)  */\n+\n+#define FUNCTION_ARG_ADVANCE(CUM,MODE,TYPE,NAMED)  \\\n+((CUM)\t+=  (PARAM_SAFE_FOR_REG_P(MODE,TYPE,NAMED)\t\\\n+\t     ? ((MODE) != BLKmode\t\t\t\\\n+\t\t? (GET_MODE_SIZE (MODE) + 3) / 4\t\\\n+\t\t: (int_size_in_bytes (TYPE) + 3) / 4)\t\\\n+\t     : 0))\n+\n+/* This macro generates the assembly code for function entry.\n+   FILE is a stdio stream to output the code to.\n+   SIZE is an int: how many units of temporary storage to allocate.\n+   Refer to the array `regs_ever_live' to determine which registers\n+   to save; `regs_ever_live[I]' is nonzero if register number I\n+   is ever used in the function.  This macro is responsible for\n+   knowing which registers should not be saved even if used.  */\n+\n+#if FRAME_POINTER_REQUIRED\n+\n+/* We always have frame pointers */\n+\n+/* Don't set up a frame pointer if it's not referenced.  */\n+\n+#define FUNCTION_PROLOGUE(FILE, SIZE) \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  int _size = (SIZE) + current_function_pretend_args_size;\t\t\\\n+  if (_size + current_function_args_size != 0\t\t\t\t\\\n+      || current_function_calls_alloca)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tadsf $%d\\n\", _size);\t\t\t\t\\\n+      if (current_function_pretend_args_size > 0)\t\t\t\\\n+      fprintf (FILE, \"\\tsubw $%d,cfp\\n\",\t\t\t\t\\\n+\t  current_function_pretend_args_size);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+#else /* !FRAME_POINTER_REQUIRED */\n+\n+/* Don't set up a frame pointer if `frame_pointer_needed' tells us\n+   there is no need.  Also, don't set up a frame pointer if it's not\n+   referenced.  */\n+\n+/* The definition used to be broken.  Write a new one.  */\n+\n+#endif /* !FRAME_POINTER_REQUIRED */\n+\n+/* Output assembler code to FILE to increment profiler label # LABELNO\n+   for profiling a function entry.  */\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+   fprintf (FILE, \"\\tmova LP%d,tr0\\n\\tcall mcount\\n\", (LABELNO));\n+\n+/* Output assembler code to FILE to initialize this source file's\n+   basic block profiling info, if that has not already been done.\n+   Don't know if this works on Pyrs. */\n+\n+#if 0 /* don't do basic_block profiling yet */\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)  \\\n+  fprintf (FILE, \\\n+           \"\\tmtstw LPBX0,tr0\\n\\tbne LPI%d\\n\\tmova LP%d,TR0\\n\\tcall __bb_init_func\\nLPI%d:\\n\", \\\n+           LABELNO, LABELNO);\n+\n+/* Output assembler code to increment the count associated with\n+   the basic block number BLOCKNO.  Not sure how to do this on pyrs. */\n+#define BLOCK_PROFILER(FILE, BLOCKNO)  \\\n+    fprintf (FILE, \"\\taddw\", 4 * BLOCKNO)\n+#endif /* don't do basic_block profiling yet */\n+\n+/* When returning from a function, the stack pointer does not matter\n+   (as long as there is a frame pointer).  */\n+\n+/* This should return non-zero when we really set up a frame pointer.\n+   Otherwise, GCC is directed to preserve sp by returning zero.  */\n+extern int current_function_pretend_args_size;\n+extern int current_function_args_size;\n+extern int current_function_calls_alloca;\n+#define EXIT_IGNORE_STACK \\\n+  (get_frame_size () + current_function_pretend_args_size\t\t\\\n+   + current_function_args_size != 0\t\t\t\t\t\\\n+   || current_function_calls_alloca)\t\t\t\t\t\\\n+\n+/* If the memory address ADDR is relative to the frame pointer,\n+   correct it to be relative to the stack pointer instead.\n+   This is for when we don't use a frame pointer.\n+   ADDR should be a variable name.  */\n+\f\n+/*** Addressing modes, and classification of registers for them.  ***/\n+\n+/* #define HAVE_POST_INCREMENT */\t/* pyramid has none of these */\n+/* #define HAVE_POST_DECREMENT */\n+\n+/* #define HAVE_PRE_DECREMENT */\n+/* #define HAVE_PRE_INCREMENT */\n+\n+/* Macros to check register numbers against specific register classes.  */\n+\n+/* These assume that REGNO is a hard or pseudo reg number.\n+   They give nonzero only if REGNO is a hard reg of the suitable class\n+   or a pseudo reg currently allocated to a suitable hard reg.\n+   Since they use reg_renumber, they are safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+\n+/* All registers except gr0 OK as index or base registers.  */\n+\n+#define REGNO_OK_FOR_BASE_P(regno) \\\n+((0 < (regno) && (regno) < FIRST_PSEUDO_REGISTER) || reg_renumber[regno] > 0)\n+\n+#define REGNO_OK_FOR_INDEX_P(regno)  \\\n+((0 < (regno) && (regno) < FIRST_PSEUDO_REGISTER) || reg_renumber[regno] > 0)\n+\n+/* Maximum number of registers that can appear in a valid memory address.  */\n+\n+#define MAX_REGS_PER_ADDRESS 2     /* check MAX_REGS_PER_ADDRESS */\n+\n+/* 1 if X is an rtx for a constant that is a valid address.  */\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+/* Nonzero if the constant value X is a legitimate general operand.\n+   It is given that X satisfies CONSTANT_P or is a CONST_DOUBLE.  */\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+/* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n+   and check its validity for a certain class.\n+   We have two alternate definitions for each of them.\n+   The usual definition accepts all pseudo regs; the other rejects\n+   them unless they have been allocated suitable hard regs.\n+   The symbol REG_OK_STRICT causes the latter definition to be used.\n+\n+   Most source files want to accept pseudo regs in the hope that\n+   they will get allocated to the class that the insn wants them to be in.\n+   Source files for reload pass need to be strict.\n+   After reload, it makes no difference, since pseudo regs have\n+   been eliminated by then.  */\n+\n+#ifndef REG_OK_STRICT\n+\n+/* Nonzero if X is a hard reg that can be used as an index\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_INDEX_P(X) 1\n+/* Nonzero if X is a hard reg that can be used as a base reg\n+   or if it is a pseudo reg.  */\n+#define REG_OK_FOR_BASE_P(X) 1\n+\n+#else\n+\n+/* Nonzero if X is a hard reg that can be used as an index.  */\n+#define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+/* Nonzero if X is a hard reg that can be used as a base reg.  */\n+#define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+\n+#endif\n+\f\n+/* GO_IF_LEGITIMATE_ADDRESS recognizes an RTL expression\n+   that is a valid memory address for an instruction.\n+   The MODE argument is the machine mode for the MEM expression\n+   that wants to use this address.\n+\n+   The other macros defined here are used only in GO_IF_LEGITIMATE_ADDRESS,\n+   except for CONSTANT_ADDRESS_P which is actually machine-independent.  */\n+\n+\n+/* Go to ADDR if X is indexable -- ie, neither indexed nor offset.\n+   Note that X is indexable iff x is offset.  */\n+#define GO_IF_INDEXABLE_ADDRESS(X, ADDR)  \\\n+{ register rtx xfoob = (X);\t\t\t\t\t\t\\\n+  if ((CONSTANT_ADDRESS_P (xfoob))\t\t\t\t\t\\\n+      || (GET_CODE (xfoob) == REG && (REG_OK_FOR_BASE_P (xfoob))))\t\\\n+\t  goto ADDR;\t\t\t\t\t\t\t\\\n+ }\n+\n+\n+/* Go to label ADDR if X is a valid address that doesn't use indexing.\n+   This is so if X is either a simple address, or the contents of a register\n+   plus an offset.\n+   This macro also gets used in output-pyramid.h in the function that\n+   recognizes non-indexed operands.  */\n+\n+#define GO_IF_NONINDEXED_ADDRESS(X, ADDR)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+      goto ADDR;\t\t\t\t\t\t\t\\\n+  GO_IF_INDEXABLE_ADDRESS (X, ADDR);\t\t\t\t\t\\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t\\\n+    { /* Handle offset(reg) represented with offset on left */\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (X, 0)))\t\t\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 1)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 1)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+      /* Handle offset(reg) represented with offset on right */\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (X, 1)))\t\t\t\t\\\n+\t{ if (GET_CODE (XEXP (X, 0)) == REG\t\t\t\t\\\n+\t      && REG_OK_FOR_BASE_P (XEXP (X, 0)))\t\t\t\\\n+\t    goto ADDR;\t\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* 1 if PROD is either a reg or a reg times a valid offset multiplier\n+   (ie, 2, 4, or 8).\n+   This macro's expansion uses the temporary variables xfoo0 and xfoo1\n+   that must be declared in the surrounding context.  */\n+#define INDEX_TERM_P(PROD, MODE)   \\\n+((GET_CODE (PROD) == REG && REG_OK_FOR_BASE_P (PROD))\t\t\t\\\n+  || (GET_CODE (PROD) == MULT\t\t\t\t\t\t\\\n+      &&\t\t\t\t\t\t\t\t\\\n+      (xfoo0 = XEXP (PROD, 0), xfoo1 = XEXP (PROD, 1),\t\t\t\\\n+       ((GET_CODE (xfoo0) == CONST_INT\t\t\t\t\t\\\n+         && (INTVAL (xfoo0) == 1\t\t\t\t\t\\\n+\t     || INTVAL (xfoo0) == 2\t\t\t\t\t\\\n+\t     || INTVAL (xfoo0) == 4\t\t\t\t\t\\\n+\t     || INTVAL (xfoo0) == 8)\t\t\t\t\t\\\n+         && GET_CODE (xfoo1) == REG\t\t\t\t\t\\\n+         && REG_OK_FOR_INDEX_P (xfoo1))\t\t\t\t\t\\\n+        ||\t\t\t\t\t\t\t\t\\\n+        (GET_CODE (xfoo1) == CONST_INT\t\t\t\t\t\\\n+\t && (INTVAL (xfoo1) == 1\t\t\t\t\t\\\n+\t     || INTVAL (xfoo1) == 2\t\t\t\t\t\\\n+\t     || INTVAL (xfoo1) == 4\t\t\t\t\t\\\n+\t     || INTVAL (xfoo1) == 8)\t\t\t\t\t\\\n+        && GET_CODE (xfoo0) == REG\t\t\t\t\t\\\n+        && REG_OK_FOR_INDEX_P (xfoo0))))))\n+\n+\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)  \\\n+{ register rtx xone, xtwo, xfoo0, xfoo1;\t\t\t\t\\\n+  GO_IF_NONINDEXED_ADDRESS (X, ADDR);\t\t\t\t\t\\\n+  if (TARGET_INDEX && GET_CODE (X) == PLUS)\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Handle <address>[index] represented with index-sum outermost */\\\n+      xone = XEXP (X, 0);\t\t\t\t\t\t\\\n+      xtwo = XEXP (X, 1);\t\t\t\t\t\t\\\n+      if (INDEX_TERM_P (xone, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_INDEXABLE_ADDRESS (xtwo, ADDR); }\t\t\t\\\n+      /* Handle <address>[index] represented with index-sum innermost */\\\n+      if (INDEX_TERM_P (xtwo, MODE))\t\t\t\t\t\\\n+\t{ GO_IF_INDEXABLE_ADDRESS (xone, ADDR); }\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Try machine-dependent ways of modifying an illegitimate address\n+   to be legitimate.  If we find one, return the new, valid address.\n+   This macro is used in only one place: `memory_address' in explow.c.\n+\n+   OLDX is the address as it was before break_out_memory_refs was called.\n+   In some cases it is useful to look at this to decide what needs to be done.\n+\n+   MODE and WIN are passed so that this macro can use\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   It is always safe for this macro to do nothing.  It exists to recognize\n+   opportunities to optimize the output.\n+\n+   --> FIXME: We haven't yet figured out what optimizations are useful\n+   --> on Pyramids.   */\n+\n+#define LEGITIMIZE_ADDRESS(X,OLDX,MODE,WIN)  {}\n+\n+/* Go to LABEL if ADDR (a legitimate address expression)\n+   has an effect that depends on the machine mode it is used for.\n+   There don't seem to be any such modes on pyramids. */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)\n+\f\n+/*** Miscellaneous Parameters ***/\n+\n+/* Specify the machine mode that this machine uses\n+   for the index in the tablejump instruction.  */\n+#define CASE_VECTOR_MODE SImode\n+\n+/* Define this if the tablejump instruction expects the table\n+   to contain offsets from the address of the table.\n+   Do not define this if the table should contain absolute addresses.  */\n+/*#define CASE_VECTOR_PC_RELATIVE*/\n+\n+/* Specify the tree operation to be used to convert reals to integers.  */\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+/* This is the kind of divide that is easiest to do in the general case.\n+   It's just a guess. I have no idea of insn cost on pyrs. */\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* Define this as 1 if `char' should by default be signed; else as 0.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* This flag, if defined, says the same insns that convert to a signed fixnum\n+   also convert validly to an unsigned one.  */\n+/* This is untrue for pyramid.  The cvtdw instruction generates a trap\n+   for input operands that are out-of-range for a signed int.  */\n+/* #define FIXUNS_TRUNC_LIKE_FIX_TRUNC */\n+\n+/* Define this macro if the preprocessor should silently ignore\n+  '#sccs' directives. */\n+/* #define SCCS_DIRECTIVE */\n+\n+/* Define this macro if the preprocessor should silently ignore\n+  '#ident' directives. */\n+/* #define IDENT_DIRECTIVE */\n+\n+/* Max number of bytes we can move from memory to memory\n+   in one reasonably fast instruction.  */\n+#define MOVE_MAX 8\n+\n+/* Define this if zero-extension is slow (more than one real instruction).  */\n+/* #define SLOW_ZERO_EXTEND */\n+\n+/* number of bits in an 'int' on target machine */\n+#define INT_TYPE_SIZE 32\n+\n+/* 1 if byte access requires more than one instruction */\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* Define if shifts truncate the shift count\n+   which implies one can omit a sign-extension or zero-extension\n+   of a shift count.  */\n+#define SHIFT_COUNT_TRUNCATED\n+\n+/* Value is 1 if truncating an integer of INPREC bits to OUTPREC bits\n+   is done just by pretending it is already truncated.  */\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+/* Define this macro if it is as good or better to call a constant\n+   function address than to call an address kept in a register.  */\n+/* #define NO_FUNCTION_CSE */\n+\n+/* When a prototype says `char' or `short', really pass an `int'.  */\n+#define PROMOTE_PROTOTYPES\n+\n+/* There are no flag store insns on a pyr. */\n+/* #define STORE_FLAG_VALUE */\n+\n+/* Specify the machine mode that pointers have.\n+   After generation of rtl, the compiler makes no further distinction\n+   between pointers and any other objects of this machine mode.  */\n+#define Pmode SImode\n+\n+/* A function address in a call instruction\n+   is a byte address (for indexing purposes)\n+   so give the MEM rtx a byte's mode.  */\n+#define FUNCTION_MODE QImode\n+\n+/* Compute the cost of computing a constant rtl expression RTX\n+   whose rtx-code is CODE.  The body of this macro is a portion\n+   of a switch statement.  If the code is computed here,\n+   return it with a return statement.  Otherwise, break from the switch.  */\n+\n+#define CONST_COSTS(RTX,CODE) \\\n+  case CONST_INT:\t\t\t\t\t\t\\\n+    if (CONST_OK_FOR_LETTER_P (INTVAL (RTX),'I')) return 0;\t\\\n+  case CONST:\t\t\t\t\t\t\t\\\n+  case LABEL_REF:\t\t\t\t\t\t\\\n+  case SYMBOL_REF:\t\t\t\t\t\t\\\n+    return 4;\t\t\t\t\t\t\t\\\n+  case CONST_DOUBLE:\t\t\t\t\t\t\\\n+    return 6;\n+\f\n+/*** Condition Code Information ***/\n+\n+/* Tell final.c how to eliminate redundant test instructions.  */\n+\n+/* Here we define machine-dependent flags and fields in cc_status\n+   (see `conditions.h').  No extra ones are needed for the pyr.  */\n+\n+/* Store in cc_status the expressions\n+   that the condition codes will describe\n+   after execution of an instruction whose pattern is EXP.\n+   Do not alter them if the instruction would not alter the cc's.  */\n+\n+/* This is a very simple definition of NOTICE_UPDATE_CC.\n+   Many cases can be optimized, to improve condition code usage.\n+   Maybe we should handle this entirely in the md, since it complicated\n+   to describe the way pyr sets cc.  */\n+\n+#define TRULY_UNSIGNED_COMPARE_P(X) \\\n+  (X == GEU || X == GTU || X == LEU || X == LTU)\n+#define CC_VALID_FOR_UNSIGNED 2\n+\n+#define CC_STATUS_MDEP_INIT cc_status.mdep = 0\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) \\\n+  notice_update_cc(EXP, INSN)\n+\f\n+/*** Output of Assembler Code ***/\n+\n+/* Output at beginning of assembler file.  */\n+\n+#define ASM_FILE_START(FILE) \\\n+  fprintf (FILE, ((TARGET_UNIX_ASM)? \"\" : \"#NO_APP\\n\"));\n+\n+/* Output to assembler file text saying following lines\n+   may contain character constants, extra white space, comments, etc.  */\n+\n+#define ASM_APP_ON ((TARGET_UNIX_ASM) ? \"\" : \"#APP\\n\")\n+\n+/* Output to assembler file text saying following lines\n+   no longer contain unusual constructs.  */\n+\n+#define ASM_APP_OFF ((TARGET_UNIX_ASM) ? \"\" : \"#NO_APP\\n\")\n+\n+/* Output before read-only data.  */\n+\n+#define TEXT_SECTION_ASM_OP \".text\"\n+\n+/* Output before writable data.  */\n+\n+#define DATA_SECTION_ASM_OP \".data\"\n+\n+/* How to refer to registers in assembler output.\n+   This sequence is indexed by compiler's hard-register-number (see above).  */\n+\n+#define REGISTER_NAMES \\\n+{\"gr0\", \"gr1\", \"gr2\", \"gr3\", \"gr4\", \"gr5\", \"gr6\", \"gr7\", \"gr8\", \\\n+ \"gr9\", \"gr10\", \"gr11\", \"logpsw\", \"cfp\", \"sp\", \"pc\", \\\n+ \"pr0\", \"pr1\", \"pr2\", \"pr3\", \"pr4\", \"pr5\", \"pr6\", \"pr7\", \\\n+ \"pr8\", \"pr9\", \"pr10\", \"pr11\", \"pr12\", \"pr13\", \"pr14\", \"pr15\", \\\n+ \"lr0\", \"lr1\", \"lr2\", \"lr3\", \"lr4\", \"lr5\", \"lr6\", \"lr7\", \\\n+ \"lr8\", \"lr9\", \"lr10\", \"lr11\", \"lr12\", \"lr13\", \"lr14\", \"lr15\", \\\n+ \"tr0\", \"tr1\", \"tr2\", \"tr3\", \"tr4\", \"tr5\", \"tr6\", \"tr7\", \\\n+ \"tr8\", \"tr9\", \"tr10\", \"tr11\", \"tr12\", \"tr13\", \"tr14\", \"tr15\"}\n+\n+/* How to renumber registers for dbx and gdb.  */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n+\n+/* Our preference is for dbx rather than sdb.\n+   Yours may be different. */\n+#define DBX_DEBUGGING_INFO\n+/* #define SDB_DEBUGGING_INFO */\n+\n+/* Don't use the `xsfoo;' construct in DBX output; this system\n+   doesn't support it.  */\n+\n+#define DBX_NO_XREFS 1\n+\n+/* Do not break .stabs pseudos into continuations.  */\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* This is the char to use for continuation (in case we need to turn\n+   continuation back on).  */\n+\n+#define DBX_CONTIN_CHAR '?'\n+\n+/* This is how to output the definition of a user-level label named NAME,\n+   such as the label on a static function or variable NAME.  */\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME)\t\\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+/* This is how to output a command to make the user-level label named NAME\n+   defined for reference from other files.  */\n+\n+#define ASM_GLOBALIZE_LABEL(FILE,NAME)\t\\\n+  do { fputs (\".globl \", FILE); assemble_name (FILE, NAME); fputs (\"\\n\", FILE);} while (0)\n+\n+/* This is how to output a reference to a user-level label named NAME.  */\n+\n+#define ASM_OUTPUT_LABELREF(FILE,NAME)\t\\\n+   fprintf (FILE, \"_%s\", NAME);\n+\n+/* This is how to output an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.  */\n+\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE,PREFIX,NUM)\t\\\n+  fprintf (FILE, \"%s%d:\\n\", PREFIX, NUM)\n+\n+/* This is how to store into the string LABEL\n+   the symbol_ref name of an internal numbered label where\n+   PREFIX is the class of label and NUM is the number within the class.\n+   This is suitable for output with `assemble_name'.  */\n+\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL,PREFIX,NUM)\t\\\n+  sprintf (LABEL, \"*%s%d\", PREFIX, NUM)\n+\n+/* This is how to output an assembler line defining a `double' constant.  */\n+\n+#define ASM_OUTPUT_DOUBLE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.double 0d%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining a `float' constant.  */\n+\n+#define ASM_OUTPUT_FLOAT(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.float 0f%.20e\\n\", (VALUE))\n+\n+/* This is how to output an assembler line defining an `int' constant.  */\n+\n+#define ASM_OUTPUT_INT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.word \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* Likewise for `char' and `short' constants.  */\n+\n+#define ASM_OUTPUT_SHORT(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.half \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+#define ASM_OUTPUT_CHAR(FILE,VALUE)  \\\n+( fprintf (FILE, \"\\t.byte \"),\t\t\t\\\n+  output_addr_const (FILE, (VALUE)),\t\t\\\n+  fprintf (FILE, \"\\n\"))\n+\n+/* This is how to output an assembler line for a numeric constant byte.  */\n+\n+#define ASM_OUTPUT_BYTE(FILE,VALUE)  \\\n+  fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+/* This is how to output an insn to push a register on the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tsubw $4,sp\\n\\tmovw %s,(sp)\\n\", reg_names[REGNO])\n+\n+/* This is how to output an insn to pop a register from the stack.\n+   It need not be very fast code.  */\n+\n+#define ASM_OUTPUT_REG_POP(FILE,REGNO)  \\\n+  fprintf (FILE, \"\\tmovw (sp),%s\\n\\taddw $4,sp\\n\", reg_names[REGNO])\n+\n+/* Store in OUTPUT a string (made with alloca) containing\n+   an assembler-name for a local static variable named NAME.\n+   LABELNO is an integer which is different for each call.  */\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\\\n+( (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10),\t\\\n+  sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO)))\n+\n+/* This is how to output an element of a case-vector that is absolute.  */\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  fprintf (FILE, \"\\t.word L%d\\n\", VALUE)\n+\n+/* This is how to output an element of a case-vector that is relative.  */\n+\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, VALUE, REL)  \\\n+  fprintf (FILE, \"\\t.word L%d-L%d\\n\", VALUE, REL)\n+\n+/* This is how to output an assembler line\n+   that says to advance the location counter\n+   to a multiple of 2**LOG bytes.\n+\n+   On Pyramids, the text segment must always be word aligned.\n+   On Pyramids, .align takes only args between 2 and 5.\n+  */\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG)  \\\n+  fprintf (FILE, \"\\t.align %d\\n\", (LOG) < 2 ? 2 : (LOG))\n+\n+#define ASM_OUTPUT_SKIP(FILE,SIZE)  \\\n+  fprintf (FILE, \"\\t.space %u\\n\", (SIZE))\n+\n+/* This says how to output an assembler line\n+   to define a global common symbol.  */\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".comm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* This says how to output an assembler line\n+   to define a local common symbol.  */\n+\n+#define ASM_OUTPUT_LOCAL(FILE, NAME, SIZE, ROUNDED)  \\\n+( fputs (\".lcomm \", (FILE)),\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* Define the parentheses used to group arithmetic operations\n+   in assembler code.  */\n+\n+#define ASM_OPEN_PAREN \"(\"\n+#define ASM_CLOSE_PAREN \")\"\n+\n+/* Define results of standard character escape sequences.  */\n+#define TARGET_BELL 007\n+#define TARGET_BS 010\n+#define TARGET_TAB 011\n+#define TARGET_NEWLINE 012\n+#define TARGET_VT 013\n+#define TARGET_FF 014\n+#define TARGET_CR 015\n+\n+/* Print operand X (an rtx) in assembler syntax to file FILE.\n+   CODE is a letter or dot (`z' in `%z0') or 0 if no letter was specified.\n+   For `%' followed by punctuation, CODE is the punctuation and X is null.\n+   On the Pyr, we support the conventional CODE characters:\n+\n+   'f' for float insn (print a CONST_DOUBLE as a float rather than in hex)\n+   which are never used. */\n+\n+/* FIXME : should be more robust with CONST_DOUBLE. */\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  \\\n+{ if (GET_CODE (X) == REG)\t\t\t\t\t\t\\\n+    fprintf (FILE, \"%s\", reg_names [REGNO (X)]);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == MEM)\t\t\t\t\t\t\\\n+    output_address (XEXP (X, 0));\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) == SFmode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      union { float f; int i; } u1;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      u1.f = u.d;\t\t\t\t\t\t\t\\\n+      if (CODE == 'f')\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"$0f%.0e\", u1.f);\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+        fprintf (FILE, \"$0x%x\", u1.i); }\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (GET_CODE (X) == CONST_DOUBLE && GET_MODE (X) != DImode)\t\\\n+    { union { double d; int i[2]; } u;\t\t\t\t\t\\\n+      u.i[0] = CONST_DOUBLE_LOW (X); u.i[1] = CONST_DOUBLE_HIGH (X);\t\\\n+      fprintf (FILE, \"$0d%.20e\", u.d); }\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (CODE == 'N')\t\t\t\t\t\t\t\\\n+    switch (GET_CODE (X))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case EQ:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n+      case NE:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n+      case GT:\t\t\t\t\t\t\t\t\\\n+      case GTU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n+      case LT:\t\t\t\t\t\t\t\t\\\n+      case LTU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n+      case GE:\t\t\t\t\t\t\t\t\\\n+      case GEU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n+      case LE:\t\t\t\t\t\t\t\t\\\n+      case LEU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (CODE == 'C')\t\t\t\t\t\t\t\\\n+    switch (GET_CODE (X))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case EQ:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n+      case NE:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n+      case GT:\t\t\t\t\t\t\t\t\\\n+      case GTU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n+      case LT:\t\t\t\t\t\t\t\t\\\n+      case LTU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n+      case GE:\t\t\t\t\t\t\t\t\\\n+      case GEU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n+      case LE:\t\t\t\t\t\t\t\t\\\n+      case LEU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else if (CODE == 'R')\t\t\t\t\t\t\t\\\n+    switch (GET_CODE (X))\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+      case EQ:\tfputs (\"eq\", FILE);\tbreak;\t\t\t\t\\\n+      case NE:\tfputs (\"ne\", FILE);\tbreak;\t\t\t\t\\\n+      case GT:\t\t\t\t\t\t\t\t\\\n+      case GTU:\tfputs (\"lt\", FILE);\tbreak;\t\t\t\t\\\n+      case LT:\t\t\t\t\t\t\t\t\\\n+      case LTU:\tfputs (\"gt\", FILE);\tbreak;\t\t\t\t\\\n+      case GE:\t\t\t\t\t\t\t\t\\\n+      case GEU:\tfputs (\"le\", FILE);\tbreak;\t\t\t\t\\\n+      case LE:\t\t\t\t\t\t\t\t\\\n+      case LEU:\tfputs (\"ge\", FILE);\tbreak;\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  else { putc ('$', FILE); output_addr_const (FILE, X); }\t\t\\\n+}\n+\n+/* Print a memory operand whose address is ADDR, on file FILE.  */\n+/* This is horrendously complicated.  */\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  \\\n+{\t\t\t\t\t\t\t\t\t\\\n+  register rtx reg1, reg2, breg, ireg;\t\t\t\t\t\\\n+  register rtx addr = ADDR;\t\t\t\t\t\t\\\n+  rtx offset, scale;\t\t\t\t\t\t\t\\\n+ retry:\t\t\t\t\t\t\t\t\t\\\n+  switch (GET_CODE (addr))\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+    case MEM:\t\t\t\t\t\t\t\t\\\n+      fprintf (stderr, \"bad Mem \"); debug_rtx (addr);\t\t\t\\\n+      addr = XEXP (addr, 0);\t\t\t\t\t\t\\\n+      abort ();\t\t\t\t\t\t\t\t\\\n+    case REG:\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"(%s)\", reg_names [REGNO (addr)]);\t\t\t\\\n+      break;\t\t\t\t\t\t\t\t\\\n+    case PLUS:\t\t\t\t\t\t\t\t\\\n+      reg1 = 0;\treg2 = 0;\t\t\t\t\t\t\\\n+      ireg = 0;\tbreg = 0;\t\t\t\t\t\t\\\n+      offset = 0;\t\t\t\t\t\t\t\\\n+      if (CONSTANT_ADDRESS_P (XEXP (addr, 0))\t\t\t\t\\\n+\t  || GET_CODE (XEXP (addr, 0)) == MEM)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (CONSTANT_ADDRESS_P (XEXP (addr, 1))\t\t\t\\\n+\t       || GET_CODE (XEXP (addr, 1)) == MEM)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  offset = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) != PLUS) ;\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == MULT)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 0)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 0);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 1);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else if (GET_CODE (XEXP (addr, 1)) == REG)\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  reg1 = XEXP (addr, 1);\t\t\t\t\t\\\n+\t  addr = XEXP (addr, 0);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (addr) == REG || GET_CODE (addr) == MULT)\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (reg1 == 0)\t\t\t\t\t\t\\\n+\t    reg1 = addr;\t\t\t\t\t\t\\\n+          else\t\t\t\t\t\t\t\t\\\n+\t    reg2 = addr;\t\t\t\t\t\t\\\n+\t  addr = 0;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (offset != 0) \t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (addr != 0) {\t\t\t\t\t\t\\\n+\t    fprintf (stderr, \"\\nBad addr \"); debug_rtx (addr);\t\t\\\n+\t    abort ();}\t\t\t\t\t\t\t\\\n+\t  addr = offset;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      if (reg1 != 0 && GET_CODE (reg1) == MULT)\t\t\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else if (reg2 != 0 && GET_CODE (reg2) == MULT)\t\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      else if (reg2 != 0 || GET_CODE (addr) == MEM)\t\t\t\\\n+\t{ breg = reg2; ireg = reg1; }\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{ breg = reg1; ireg = reg2; }\t\t\t\t\t\\\n+      if (addr != 0)\t\t\t\t\t\t\t\\\n+\toutput_address (offset);\t\t\t\t\t\\\n+      if (breg != 0)\t\t\t\t\t\t\t\\\n+\t{ if (GET_CODE (breg) != REG)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf (stderr, \"bad Breg\"); debug_rtx (addr);\t\t\\\n+\t      abort ();\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"(%s)\", reg_names[REGNO (breg)]); }\t\t\\\n+      if (ireg != 0)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (GET_CODE (ireg) == MULT)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      scale = XEXP (ireg, 1);\t\t\t\t\t\\\n+\t      ireg = XEXP (ireg, 0);\t\t\t\t\t\\\n+\t      if (GET_CODE (ireg) != REG)\t\t\t\t\\\n+\t        { register rtx tem;\t\t\t\t\t\\\n+\t\t  tem = ireg; ireg = scale; scale = tem;\t\t\\\n+\t        }\t\t\t\t\t\t\t\\\n+ \t      if (GET_CODE (ireg) != REG) {\t\t\t\t\\\n+\t\t      fprintf (stderr, \"bad idx \"); debug_rtx (addr);\t\\\n+\t\tabort (); }\t\t\t\t\t\t\\\n+\t      if ((GET_CODE (scale) == CONST_INT) && (INTVAL(scale) >= 1))\\\n+\t\tfprintf (FILE, \"[%s*0x%x]\", reg_names[REGNO (ireg)],\t\\\n+\t\t\t INTVAL(scale));\t\t\t\t\\\n+\t      else\t\t\t\t\t\t\t\\\n+\t\tfprintf (FILE, \"[%s*1]\", reg_names[REGNO (ireg)]);\t\\\n+ \t    } \t\t\t\t\t\t\t\t\\\n+\t  else if (GET_CODE (ireg) == REG)\t\t\t\t\\\n+\t      fprintf (FILE, \"[%s*1]\", reg_names[REGNO (ireg)]);\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf (stderr, \"Not indexed at all!\"); debug_rtx (addr);\\\n+\t      abort ();\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t }\t\t\t\t\t\t\t\t\\\n+       break;\t\t\t\t\t\t\t\t\\\n+    default:\t\t\t\t\t\t\t\t\\\n+      output_addr_const (FILE, addr);\t\t\t\t\t\\\n+   }\t\t\t\t\t\t\t\t\t\\\n+}"}, {"sha": "23d255cb9eb50ceae28130ba08bf619226212bdb", "filename": "gcc/gbl-ctors.h", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4/gcc%2Fgbl-ctors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4/gcc%2Fgbl-ctors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgbl-ctors.h?ref=014cfee8c560e5db3a7eddaaa8d524d04dd8d6d4", "patch": "@@ -0,0 +1,81 @@\n+/* Definitions relating to the special __do_global_init function used\n+   for getting g++ file-scope static objects constructed.  This file\n+   wil get included either by libgcc2.c (for systems that don't support\n+   a .init section) or by crtstuff.c (for those that do).\n+\n+   Written by Ron Guilmette (rfg@ncd.com)\n+\n+Copyright (C) 1991 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/*\tThis file contains definitions and declarations of things\n+\trelating to the normal start-up-time invocation of C++\n+\tfile-scope static object constructors.  These declarations\n+\tand definitions are used by *both* libgcc2.c and by crtstuff.c.\n+\n+\tNote that this file should only be compiled with GCC.\n+*/\n+\n+#ifdef sun\n+extern void on_exit (void*, void*);\n+#define ON_EXIT(FUNC,ARG) on_exit ((FUNC), (ARG))\n+#else\n+#ifdef HAVE_ATEXIT\n+extern void atexit (void (*) (void));\n+#define ON_EXIT(FUNC,ARG) atexit ((FUNC))\n+#endif\n+#endif\n+\n+/*  Declare a pointer to void function type.  */\n+\n+typedef void (*func_ptr) (void);\n+\n+/* Declare the set of symbols use as begin and end markers for the lists\n+   of global object constructors and global object descructors.  */\n+\n+extern func_ptr __CTOR_LIST__[];\n+extern func_ptr __DTOR_LIST__[];\n+\n+/* Declare the routine which need to get invoked at program exit time.  */\n+\n+extern void __do_global_dtors ();\n+\n+/* Define a macro with the code which needs to be executed at program\n+   start-up time.  This macro is used in two places in crtstuff.c (for\n+   systems which support a .init section) and in one place in libgcc2.c\n+   (for those system which do *not* support a .init section).  For all\n+   three places where this code might appear, it must be identical, so\n+   we define it once here as a macro to avoid various instances getting\n+   out-of-sync with one another.  */\n+\n+/* The first word may or may not contain the number of pointers in the table.\n+   In all cases, the table is null-terminated.\n+   We ignore the first word and scan up to the null.  */\n+\n+/* Some systems use a different strategy for finding the ctors.\n+   For example, svr3.  */\n+#ifndef DO_GLOBAL_CTORS_BODY\n+#define DO_GLOBAL_CTORS_BODY\t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  func_ptr *p;\t\t\t\t\t\t\t\t\\\n+  ON_EXIT (__do_global_dtors, 0);\t\t\t\t\t\\\n+  for (p = __CTOR_LIST__ + 1; *p; )\t\t\t\t\t\\\n+    (*p++) ();\t\t\t\t\t\t\t\t\\\n+} while (0)\n+#endif\n+"}]}