{"sha": "2597da229a2261de8576099213ffdef4bf946a7c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjU5N2RhMjI5YTIyNjFkZTg1NzYwOTkyMTNmZmRlZjRiZjk0NmE3Yw==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2013-02-12T14:53:45Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2013-02-12T14:53:45Z"}, "message": "arm-protos.h (struct cpu_vec_costs): New struct type.\n\n2013-02-05  Christophe Lyon <christophe.lyon@linaro.org>\n\n\t* config/arm/arm-protos.h (struct cpu_vec_costs): New struct type.\n\t(struct tune_params): Add vec_costs field.\n\t* config/arm/arm.c (arm_builtin_vectorization_cost)\n\t(arm_add_stmt_cost): New functions.\n\t(TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST)\n\t(TARGET_VECTORIZE_ADD_STMT_COST): Define.\n\t(arm_default_vec_cost): New struct of type cpu_vec_costs.\n\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune)\n\t(arm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune)\n\t(arm_cortex_a15_tune, arm_cortex_a5_tune, arm_cortex_a9_tune)\n\t(arm_v6m_tune, arm_fa726te_tune): Define new vec_costs field.\n\nFrom-SVN: r195977", "tree": {"sha": "632f166a13b2e090eba199f0717558186acc354e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/632f166a13b2e090eba199f0717558186acc354e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2597da229a2261de8576099213ffdef4bf946a7c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2597da229a2261de8576099213ffdef4bf946a7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2597da229a2261de8576099213ffdef4bf946a7c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2597da229a2261de8576099213ffdef4bf946a7c/comments", "author": null, "committer": null, "parents": [{"sha": "43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43320568b265d6f0448e6f8ae7e6a8ace3a13be0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43320568b265d6f0448e6f8ae7e6a8ace3a13be0"}], "stats": {"total": 170, "additions": 170, "deletions": 0}, "files": [{"sha": "0be8139732333ecad46609618f0d18b48c318291", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2597da229a2261de8576099213ffdef4bf946a7c", "patch": "@@ -1,3 +1,17 @@\n+2013-02-12  Christophe Lyon <christophe.lyon@linaro.org>\n+\n+\t* config/arm/arm-protos.h (struct cpu_vec_costs): New struct type.\n+\t(struct tune_params): Add vec_costs field.\n+\t* config/arm/arm.c (arm_builtin_vectorization_cost)\n+\t(arm_add_stmt_cost): New functions.\n+\t(TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST)\n+\t(TARGET_VECTORIZE_ADD_STMT_COST): Define.\n+\t(arm_default_vec_cost): New struct of type cpu_vec_costs.\n+\t(arm_slowmul_tune, arm_fastmul_tune, arm_strongarm_tune)\n+\t(arm_xscale_tune, arm_9e_tune, arm_v6t2_tune, arm_cortex_tune)\n+\t(arm_cortex_a15_tune, arm_cortex_a5_tune, arm_cortex_a9_tune)\n+\t(arm_v6m_tune, arm_fa726te_tune): Define new vec_costs field.\n+\n 2013-02-12  Richard Biener  <rguenther@suse.de>\n \n \tPR lto/56295"}, {"sha": "ffa00c0f7b74cdb296158f8459af992f21273843", "filename": "gcc/config/arm/arm-protos.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2Fconfig%2Farm%2Farm-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2Fconfig%2Farm%2Farm-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm-protos.h?ref=2597da229a2261de8576099213ffdef4bf946a7c", "patch": "@@ -224,6 +224,27 @@ extern const char *arm_mangle_type (const_tree);\n \n extern void arm_order_regs_for_local_alloc (void);\n \n+/* Vectorizer cost model implementation.  */\n+struct cpu_vec_costs {\n+  const int scalar_stmt_cost;   /* Cost of any scalar operation, excluding\n+\t\t\t\t   load and store.  */\n+  const int scalar_load_cost;   /* Cost of scalar load.  */\n+  const int scalar_store_cost;  /* Cost of scalar store.  */\n+  const int vec_stmt_cost;      /* Cost of any vector operation, excluding\n+                                   load, store, vector-to-scalar and\n+                                   scalar-to-vector operation.  */\n+  const int vec_to_scalar_cost;    /* Cost of vect-to-scalar operation.  */\n+  const int scalar_to_vec_cost;    /* Cost of scalar-to-vector operation.  */\n+  const int vec_align_load_cost;   /* Cost of aligned vector load.  */\n+  const int vec_unalign_load_cost; /* Cost of unaligned vector load.  */\n+  const int vec_unalign_store_cost; /* Cost of unaligned vector load.  */\n+  const int vec_store_cost;        /* Cost of vector store.  */\n+  const int cond_taken_branch_cost;    /* Cost of taken branch for vectorizer\n+\t\t\t\t\t  cost model.  */\n+  const int cond_not_taken_branch_cost;/* Cost of not taken branch for\n+\t\t\t\t\t  vectorizer cost model.  */\n+};\n+\n #ifdef RTX_CODE\n /* This needs to be here because we need RTX_CODE and similar.  */\n \n@@ -246,6 +267,8 @@ struct tune_params\n      performance. The first element covers Thumb state and the second one\n      is for ARM state.  */\n   bool logical_op_non_short_circuit[2];\n+  /* Vectorizer costs.  */\n+  const struct cpu_vec_costs* vec_costs;\n };\n \n extern const struct tune_params *current_tune;"}, {"sha": "677d6da027d269ea8f299d9fbb86ce39016dc5f9", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2597da229a2261de8576099213ffdef4bf946a7c/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=2597da229a2261de8576099213ffdef4bf946a7c", "patch": "@@ -268,6 +268,16 @@ static int arm_cortex_a5_branch_cost (bool, bool);\n \n static bool arm_vectorize_vec_perm_const_ok (enum machine_mode vmode,\n \t\t\t\t\t     const unsigned char *sel);\n+\n+static int arm_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+\t\t\t\t\t   tree vectype,\n+\t\t\t\t\t   int misalign ATTRIBUTE_UNUSED);\n+static unsigned arm_add_stmt_cost (void *data, int count,\n+\t\t\t\t   enum vect_cost_for_stmt kind,\n+\t\t\t\t   struct _stmt_vec_info *stmt_info,\n+\t\t\t\t   int misalign,\n+\t\t\t\t   enum vect_cost_model_location where);\n+\n static void arm_canonicalize_comparison (int *code, rtx *op0, rtx *op1,\n \t\t\t\t\t bool op0_preserve_value);\n \f\n@@ -629,6 +639,12 @@ static const struct attribute_spec arm_attribute_table[] =\n #define TARGET_VECTORIZE_VEC_PERM_CONST_OK \\\n   arm_vectorize_vec_perm_const_ok\n \n+#undef TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST\n+#define TARGET_VECTORIZE_BUILTIN_VECTORIZATION_COST \\\n+  arm_builtin_vectorization_cost\n+#undef TARGET_VECTORIZE_ADD_STMT_COST\n+#define TARGET_VECTORIZE_ADD_STMT_COST arm_add_stmt_cost\n+\n #undef TARGET_CANONICALIZE_COMPARISON\n #define TARGET_CANONICALIZE_COMPARISON \\\n   arm_canonicalize_comparison\n@@ -891,6 +907,23 @@ struct processors\n   l1_size, \\\n   l1_line_size\n \n+/* arm generic vectorizer costs.  */\n+static const\n+struct cpu_vec_costs arm_default_vec_cost = {\n+  1,\t\t\t\t\t/* scalar_stmt_cost.  */\n+  1,\t\t\t\t\t/* scalar load_cost.  */\n+  1,\t\t\t\t\t/* scalar_store_cost.  */\n+  1,\t\t\t\t\t/* vec_stmt_cost.  */\n+  1,\t\t\t\t\t/* vec_to_scalar_cost.  */\n+  1,\t\t\t\t\t/* scalar_to_vec_cost.  */\n+  1,\t\t\t\t\t/* vec_align_load_cost.  */\n+  1,\t\t\t\t\t/* vec_unalign_load_cost.  */\n+  1,\t\t\t\t\t/* vec_unalign_store_cost.  */\n+  1,\t\t\t\t\t/* vec_store_cost.  */\n+  3,\t\t\t\t\t/* cond_taken_branch_cost.  */\n+  1,\t\t\t\t\t/* cond_not_taken_branch_cost.  */\n+};\n+\n const struct tune_params arm_slowmul_tune =\n {\n   arm_slowmul_rtx_costs,\n@@ -902,6 +935,7 @@ const struct tune_params arm_slowmul_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_fastmul_tune =\n@@ -915,6 +949,7 @@ const struct tune_params arm_fastmul_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n /* StrongARM has early execution of branches, so a sequence that is worth\n@@ -931,6 +966,7 @@ const struct tune_params arm_strongarm_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_xscale_tune =\n@@ -944,6 +980,7 @@ const struct tune_params arm_xscale_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_9e_tune =\n@@ -957,6 +994,7 @@ const struct tune_params arm_9e_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_v6t2_tune =\n@@ -970,6 +1008,7 @@ const struct tune_params arm_v6t2_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n /* Generic Cortex tuning.  Use more specific tunings if appropriate.  */\n@@ -984,6 +1023,7 @@ const struct tune_params arm_cortex_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_cortex_a15_tune =\n@@ -997,6 +1037,7 @@ const struct tune_params arm_cortex_a15_tune =\n   arm_default_branch_cost,\n   true,\t\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n /* Branches can be dual-issued on Cortex-A5, so conditional execution is\n@@ -1013,6 +1054,7 @@ const struct tune_params arm_cortex_a5_tune =\n   arm_cortex_a5_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_cortex_a9_tune =\n@@ -1026,6 +1068,7 @@ const struct tune_params arm_cortex_a9_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n /* The arm_v6m_tune is duplicated from arm_cortex_tune, rather than\n@@ -1041,6 +1084,7 @@ const struct tune_params arm_v6m_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {false, false},\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n const struct tune_params arm_fa726te_tune =\n@@ -1054,6 +1098,7 @@ const struct tune_params arm_fa726te_tune =\n   arm_default_branch_cost,\n   false,\t\t\t\t\t/* Prefer LDRD/STRD.  */\n   {true, true},\t\t\t\t\t/* Prefer non short circuit.  */\n+  &arm_default_vec_cost,                        /* Vectorizer costs.  */\n };\n \n \n@@ -8696,6 +8741,94 @@ arm_memory_move_cost (enum machine_mode mode, reg_class_t rclass,\n     }\n }\n \n+/* Vectorizer cost model implementation.  */\n+\n+/* Implement targetm.vectorize.builtin_vectorization_cost.  */\n+static int\n+arm_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n+\t\t\t\ttree vectype,\n+\t\t\t\tint misalign ATTRIBUTE_UNUSED)\n+{\n+  unsigned elements;\n+\n+  switch (type_of_cost)\n+    {\n+      case scalar_stmt:\n+        return current_tune->vec_costs->scalar_stmt_cost;\n+\n+      case scalar_load:\n+        return current_tune->vec_costs->scalar_load_cost;\n+\n+      case scalar_store:\n+        return current_tune->vec_costs->scalar_store_cost;\n+\n+      case vector_stmt:\n+        return current_tune->vec_costs->vec_stmt_cost;\n+\n+      case vector_load:\n+        return current_tune->vec_costs->vec_align_load_cost;\n+\n+      case vector_store:\n+        return current_tune->vec_costs->vec_store_cost;\n+\n+      case vec_to_scalar:\n+        return current_tune->vec_costs->vec_to_scalar_cost;\n+\n+      case scalar_to_vec:\n+        return current_tune->vec_costs->scalar_to_vec_cost;\n+\n+      case unaligned_load:\n+        return current_tune->vec_costs->vec_unalign_load_cost;\n+\n+      case unaligned_store:\n+        return current_tune->vec_costs->vec_unalign_store_cost;\n+\n+      case cond_branch_taken:\n+        return current_tune->vec_costs->cond_taken_branch_cost;\n+\n+      case cond_branch_not_taken:\n+        return current_tune->vec_costs->cond_not_taken_branch_cost;\n+\n+      case vec_perm:\n+      case vec_promote_demote:\n+        return current_tune->vec_costs->vec_stmt_cost;\n+\n+      case vec_construct:\n+\telements = TYPE_VECTOR_SUBPARTS (vectype);\n+\treturn elements / 2 + 1;\n+\n+      default:\n+        gcc_unreachable ();\n+    }\n+}\n+\n+/* Implement targetm.vectorize.add_stmt_cost.  */\n+\n+static unsigned\n+arm_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n+\t\t   struct _stmt_vec_info *stmt_info, int misalign,\n+\t\t   enum vect_cost_model_location where)\n+{\n+  unsigned *cost = (unsigned *) data;\n+  unsigned retval = 0;\n+\n+  if (flag_vect_cost_model)\n+    {\n+      tree vectype = stmt_info ? stmt_vectype (stmt_info) : NULL_TREE;\n+      int stmt_cost = arm_builtin_vectorization_cost (kind, vectype, misalign);\n+\n+      /* Statements in an inner loop relative to the loop being\n+\t vectorized are weighted more heavily.  The value here is\n+\t arbitrary and could potentially be improved with analysis.  */\n+      if (where == vect_body && stmt_info && stmt_in_inner_loop_p (stmt_info))\n+\tcount *= 50;  /* FIXME.  */\n+\n+      retval = (unsigned) (count * stmt_cost);\n+      cost[where] += retval;\n+    }\n+\n+  return retval;\n+}\n \n /* Return true if and only if this insn can dual-issue only as older.  */\n static bool"}]}