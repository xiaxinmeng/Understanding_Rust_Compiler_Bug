{"sha": "96eb7d7a642085f651e9940f0ee75568d7c4441d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTZlYjdkN2E2NDIwODVmNjUxZTk5NDBmMGVlNzU1NjhkN2M0NDQxZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-10-16T09:50:44Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-10-16T09:50:44Z"}, "message": "Deal with incoming POLY_INT_CST ranges (PR92033)\n\nThis patch makes value_range_base::set convert POLY_INT_CST bounds\ninto the worst-case INTEGER_CST bounds.  The main case in which this\ngives useful ranges is a lower bound of A + B * X becoming A when B >= 0.\nE.g.:\n\n  [32 + 16X, 100] -> [32, 100]\n  [32 + 16X, 32 + 16X] -> [32, MAX]\n\nBut the same thing can be useful for the upper bound with negative\nX coefficients.\n\n2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\tPR middle-end/92033\n\t* poly-int.h (constant_lower_bound_with_limit): New function.\n\t(constant_upper_bound_with_limit): Likewise.\n\t* doc/poly-int.texi: Document them.\n\t* tree-vrp.c (value_range_base::set): Convert POLY_INT_CST bounds\n\tinto the worst-case INTEGER_CST bounds.\n\nFrom-SVN: r277056", "tree": {"sha": "f7eca938631203946dc47f7d9408210613dc0571", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f7eca938631203946dc47f7d9408210613dc0571"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/96eb7d7a642085f651e9940f0ee75568d7c4441d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96eb7d7a642085f651e9940f0ee75568d7c4441d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/96eb7d7a642085f651e9940f0ee75568d7c4441d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/96eb7d7a642085f651e9940f0ee75568d7c4441d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4307a485c39fd1c317d6cead2707a903052c4753", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4307a485c39fd1c317d6cead2707a903052c4753", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4307a485c39fd1c317d6cead2707a903052c4753"}], "stats": {"total": 62, "additions": 62, "deletions": 0}, "files": [{"sha": "072eb8ce8bdcabd6bc8a9788ebe32ff6421d2701", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=96eb7d7a642085f651e9940f0ee75568d7c4441d", "patch": "@@ -1,3 +1,12 @@\n+2019-10-16  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\tPR middle-end/92033\n+\t* poly-int.h (constant_lower_bound_with_limit): New function.\n+\t(constant_upper_bound_with_limit): Likewise.\n+\t* doc/poly-int.texi: Document them.\n+\t* tree-vrp.c (value_range_base::set): Convert POLY_INT_CST bounds\n+\tinto the worst-case INTEGER_CST bounds.\n+\n 2019-10-16  Feng Xue  <fxue@os.amperecomputing.com>\n \n \tPR ipa/91088"}, {"sha": "d60bb02aabf264792a54631cb5567ca0d30c7c6d", "filename": "gcc/doc/poly-int.texi", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Fdoc%2Fpoly-int.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Fdoc%2Fpoly-int.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpoly-int.texi?ref=96eb7d7a642085f651e9940f0ee75568d7c4441d", "patch": "@@ -803,6 +803,18 @@ the assertion is known to hold.\n @item constant_lower_bound (@var{a})\n Assert that @var{a} is nonnegative and return the smallest value it can have.\n \n+@item constant_lower_bound_with_limit (@var{a}, @var{b})\n+Return the least value @var{a} can have, given that the context in\n+which @var{a} appears guarantees that the answer is no less than @var{b}.\n+In other words, the caller is asserting that @var{a} is greater than or\n+equal to @var{b} even if @samp{known_ge (@var{a}, @var{b})} doesn't hold.\n+\n+@item constant_upper_bound_with_limit (@var{a}, @var{b})\n+Return the greatest value @var{a} can have, given that the context in\n+which @var{a} appears guarantees that the answer is no greater than @var{b}.\n+In other words, the caller is asserting that @var{a} is less than or equal\n+to @var{b} even if @samp{known_le (@var{a}, @var{b})} doesn't hold.\n+\n @item lower_bound (@var{a}, @var{b})\n Return a value that is always less than or equal to both @var{a} and @var{b}.\n It will be the greatest such value for some indeterminate values"}, {"sha": "67759ad58cc0f5befc5de1c06992e70effd8e176", "filename": "gcc/poly-int.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=96eb7d7a642085f651e9940f0ee75568d7c4441d", "patch": "@@ -1528,6 +1528,29 @@ constant_lower_bound (const poly_int_pod<N, Ca> &a)\n   return a.coeffs[0];\n }\n \n+/* Return the constant lower bound of A, given that it is no less than B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_COEFF (Ca, Cb)\n+constant_lower_bound_with_limit (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (known_ge (a, b))\n+    return a.coeffs[0];\n+  return b;\n+}\n+\n+/* Return the constant upper bound of A, given that it is no greater\n+   than B.  */\n+\n+template<unsigned int N, typename Ca, typename Cb>\n+inline POLY_CONST_COEFF (Ca, Cb)\n+constant_upper_bound_with_limit (const poly_int_pod<N, Ca> &a, const Cb &b)\n+{\n+  if (known_le (a, b))\n+    return a.coeffs[0];\n+  return b;\n+}\n+\n /* Return a value that is known to be no greater than A and B.  This\n    will be the greatest lower bound for some indeterminate values but\n    not necessarily for all.  */"}, {"sha": "21910b36518000469529076c8a57ae2a9a00d805", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/96eb7d7a642085f651e9940f0ee75568d7c4441d/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=96eb7d7a642085f651e9940f0ee75568d7c4441d", "patch": "@@ -727,6 +727,24 @@ value_range_base::set (enum value_range_kind kind, tree min, tree max)\n       return;\n     }\n \n+  /* Convert POLY_INT_CST bounds into worst-case INTEGER_CST bounds.  */\n+  if (POLY_INT_CST_P (min))\n+    {\n+      tree type_min = vrp_val_min (TREE_TYPE (min), true);\n+      widest_int lb\n+\t= constant_lower_bound_with_limit (wi::to_poly_widest (min),\n+\t\t\t\t\t   wi::to_widest (type_min));\n+      min = wide_int_to_tree (TREE_TYPE (min), lb);\n+    }\n+  if (POLY_INT_CST_P (max))\n+    {\n+      tree type_max = vrp_val_max (TREE_TYPE (max), true);\n+      widest_int ub\n+\t= constant_upper_bound_with_limit (wi::to_poly_widest (max),\n+\t\t\t\t\t   wi::to_widest (type_max));\n+      max = wide_int_to_tree (TREE_TYPE (max), ub);\n+    }\n+\n   /* Nothing to canonicalize for symbolic ranges.  */\n   if (TREE_CODE (min) != INTEGER_CST\n       || TREE_CODE (max) != INTEGER_CST)"}]}