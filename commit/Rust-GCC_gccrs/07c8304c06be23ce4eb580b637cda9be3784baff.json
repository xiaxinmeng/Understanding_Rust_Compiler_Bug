{"sha": "07c8304c06be23ce4eb580b637cda9be3784baff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDdjODMwNGMwNmJlMjNjZTRlYjU4MGI2MzdjZGE5YmUzNzg0YmFmZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-06-17T13:44:58Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-06-17T13:44:58Z"}, "message": "tree-ssa-alias.c (aliasing_component_refs_p): Consider only the access path from base to first VIEW_CONVERT_EXPR or BIT_FIELD_REF.\n\n\t* tree-ssa-alias.c (aliasing_component_refs_p): Consider only\n\tthe access path from base to first VIEW_CONVERT_EXPR or\n\tBIT_FIELD_REF.\n\nFrom-SVN: r272383", "tree": {"sha": "f447202e0d1b503367cedadefa93ff1912505dfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f447202e0d1b503367cedadefa93ff1912505dfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/07c8304c06be23ce4eb580b637cda9be3784baff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c8304c06be23ce4eb580b637cda9be3784baff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/07c8304c06be23ce4eb580b637cda9be3784baff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/07c8304c06be23ce4eb580b637cda9be3784baff/comments", "author": null, "committer": null, "parents": [{"sha": "2fcae10971238306fb88fb1be06a6a004bec064b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2fcae10971238306fb88fb1be06a6a004bec064b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2fcae10971238306fb88fb1be06a6a004bec064b"}], "stats": {"total": 45, "additions": 28, "deletions": 17}, "files": [{"sha": "f11854438aa8442457a19c9f5eef2536c7826ef8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c8304c06be23ce4eb580b637cda9be3784baff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c8304c06be23ce4eb580b637cda9be3784baff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=07c8304c06be23ce4eb580b637cda9be3784baff", "patch": "@@ -1,3 +1,9 @@\n+2019-06-17  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* tree-ssa-alias.c (aliasing_component_refs_p): Consider only\n+\tthe access path from base to first VIEW_CONVERT_EXPR or\n+\tBIT_FIELD_REF.\n+\n 2019-06-17  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* tree-ssa-alias.c (nonoverlapping_component_refs_p): Also truncate"}, {"sha": "867b4cb53f2804aaf72d640992c0d2781708adca", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/07c8304c06be23ce4eb580b637cda9be3784baff/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/07c8304c06be23ce4eb580b637cda9be3784baff/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=07c8304c06be23ce4eb580b637cda9be3784baff", "patch": "@@ -874,7 +874,6 @@ aliasing_component_refs_p (tree ref1,\n      disambiguating q->i and p->a.j.  */\n   tree base1, base2;\n   tree type1, type2;\n-  tree *refp;\n   int same_p1 = 0, same_p2 = 0;\n   bool maybe_match = false;\n   tree end_struct_ref1 = NULL, end_struct_ref2 = NULL;\n@@ -903,6 +902,9 @@ aliasing_component_refs_p (tree ref1,\n \t  gcc_checking_assert (!end_struct_ref1);\n           end_struct_ref1 = base1;\n \t}\n+      if (TREE_CODE (base1) == VIEW_CONVERT_EXPR\n+\t  || TREE_CODE (base1) == BIT_FIELD_REF)\n+\tref1 = TREE_OPERAND (base1, 0);\n       base1 = TREE_OPERAND (base1, 0);\n     }\n   type1 = TREE_TYPE (base1);\n@@ -918,6 +920,9 @@ aliasing_component_refs_p (tree ref1,\n \t  gcc_checking_assert (!end_struct_ref2);\n \t  end_struct_ref2 = base2;\n \t}\n+      if (TREE_CODE (base2) == VIEW_CONVERT_EXPR\n+\t  || TREE_CODE (base2) == BIT_FIELD_REF)\n+\tref2 = TREE_OPERAND (base2, 0);\n       base2 = TREE_OPERAND (base2, 0);\n     }\n   type2 = TREE_TYPE (base2);\n@@ -934,23 +939,23 @@ aliasing_component_refs_p (tree ref1,\n       || (end_struct_ref2\n \t  && compare_type_sizes (TREE_TYPE (end_struct_ref2), type1) >= 0))\n     {\n-      refp = &ref2;\n+      tree ref = ref2;\n       while (true)\n \t{\n \t  /* We walk from inner type to the outer types. If type we see is\n \t     already too large to be part of type1, terminate the search.  */\n-\t  int cmp = compare_type_sizes (type1, TREE_TYPE (*refp));\n+\t  int cmp = compare_type_sizes (type1, TREE_TYPE (ref));\n \n \t  if (cmp < 0\n \t      && (!end_struct_ref1\n \t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref1),\n-\t\t\t\t\t TREE_TYPE (*refp)) < 0))\n+\t\t\t\t\t TREE_TYPE (ref)) < 0))\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n \t  if (cmp == 0)\n \t    {\n-\t      same_p2 = same_type_for_tbaa (TREE_TYPE (*refp), type1);\n+\t      same_p2 = same_type_for_tbaa (TREE_TYPE (ref), type1);\n \t      if (same_p2 == 1)\n \t\tbreak;\n \t      /* In case we can't decide whether types are same try to\n@@ -960,9 +965,9 @@ aliasing_component_refs_p (tree ref1,\n \t      if (same_p2 == -1)\n \t\tmaybe_match = true;\n \t    }\n-\t  if (!handled_component_p (*refp))\n+\t  if (!handled_component_p (ref))\n \t    break;\n-\t  refp = &TREE_OPERAND (*refp, 0);\n+\t  ref = TREE_OPERAND (ref, 0);\n \t}\n       if (same_p2 == 1)\n \t{\n@@ -977,13 +982,13 @@ aliasing_component_refs_p (tree ref1,\n \t  if (TREE_CODE (TREE_TYPE (base1)) == ARRAY_TYPE\n \t      && (!TYPE_SIZE (TREE_TYPE (base1))\n \t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base1))) != INTEGER_CST\n-\t\t  || (*refp == base2 && !ref2_is_decl)))\n+\t\t  || (ref == base2 && !ref2_is_decl)))\n \t    {\n \t      ++alias_stats.aliasing_component_refs_p_may_alias;\n \t      return true;\n \t    }\n \n-\t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n+\t  get_ref_base_and_extent (ref, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset2 -= offadj;\n \t  get_ref_base_and_extent (base1, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset1 -= offadj;\n@@ -1005,28 +1010,28 @@ aliasing_component_refs_p (tree ref1,\n       || (end_struct_ref1\n \t  && compare_type_sizes (TREE_TYPE (end_struct_ref1), type1) <= 0))\n     {\n-      refp = &ref1;\n+      tree ref = ref1;\n       while (true)\n \t{\n-\t  int cmp = compare_type_sizes (type2, TREE_TYPE (*refp));\n+\t  int cmp = compare_type_sizes (type2, TREE_TYPE (ref));\n \t  if (cmp < 0\n \t      && (!end_struct_ref2\n \t\t  || compare_type_sizes (TREE_TYPE (end_struct_ref2),\n-\t\t\t\t\t TREE_TYPE (*refp)) < 0))\n+\t\t\t\t\t TREE_TYPE (ref)) < 0))\n \t    break;\n \t  /* If types may be of same size, see if we can decide about their\n \t     equality.  */\n \t  if (cmp == 0)\n \t    {\n-\t      same_p1 = same_type_for_tbaa (TREE_TYPE (*refp), type2);\n+\t      same_p1 = same_type_for_tbaa (TREE_TYPE (ref), type2);\n \t      if (same_p1 == 1)\n \t\tbreak;\n \t      if (same_p1 == -1)\n \t\tmaybe_match = true;\n \t    }\n-\t  if (!handled_component_p (*refp))\n+\t  if (!handled_component_p (ref))\n \t    break;\n-\t  refp = &TREE_OPERAND (*refp, 0);\n+\t  ref = TREE_OPERAND (ref, 0);\n \t}\n       if (same_p1 == 1)\n \t{\n@@ -1036,13 +1041,13 @@ aliasing_component_refs_p (tree ref1,\n \t  if (TREE_CODE (TREE_TYPE (base2)) == ARRAY_TYPE\n \t      && (!TYPE_SIZE (TREE_TYPE (base2))\n \t\t  || TREE_CODE (TYPE_SIZE (TREE_TYPE (base2))) != INTEGER_CST\n-\t\t  || (*refp == base1 && !ref2_is_decl)))\n+\t\t  || (ref == base1 && !ref2_is_decl)))\n \t    {\n \t      ++alias_stats.aliasing_component_refs_p_may_alias;\n \t      return true;\n \t    }\n \n-\t  get_ref_base_and_extent (*refp, &offadj, &sztmp, &msztmp, &reverse);\n+\t  get_ref_base_and_extent (ref, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset1 -= offadj;\n \t  get_ref_base_and_extent (base2, &offadj, &sztmp, &msztmp, &reverse);\n \t  offset2 -= offadj;"}]}