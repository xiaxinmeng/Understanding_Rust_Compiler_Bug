{"sha": "9e259dd1ff3f146f89ff4261d9e48685b378b693", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWUyNTlkZDFmZjNmMTQ2Zjg5ZmY0MjYxZDllNDg2ODViMzc4YjY5Mw==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2002-08-09T19:57:01Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2002-08-09T19:57:01Z"}, "message": "call.c (standard_conversion): Use build_ptrmem_type.\n\n\t* call.c (standard_conversion): Use build_ptrmem_type.\n\t* cp-tree.h (build_ptrmem_type): New function.\n\t(adjust_result_of_qualified_name_lookup): Likewise.\n\t* decl.c (grokvardecl): Do not look for OFFSET_TYPEs to indicate\n\tstatic data members.\n\t(build_ptrmem_type): New function.\n\t(grokdeclarator): Do not use build_offset_type when encountering a\n\tqualified name.\n\t* parse.y (parse_finish_call_expr): Use\n\tadjust_result_of_qualified_name_lookup.\n\t* search.c (adjust_result_of_qualified_name_lookup): New function.\n\t* typeck.c (qualify_type_recursive): Use TYPE_PTRMEM_* rather than\n\taccessing OFFSET_TYPEs directly.\n\n\t* g++.dg/template/crash1.C: New test.\n\nFrom-SVN: r56169", "tree": {"sha": "6030774638e6194b3c13b4773a3d8af79ad7378f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6030774638e6194b3c13b4773a3d8af79ad7378f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9e259dd1ff3f146f89ff4261d9e48685b378b693", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e259dd1ff3f146f89ff4261d9e48685b378b693", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9e259dd1ff3f146f89ff4261d9e48685b378b693", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9e259dd1ff3f146f89ff4261d9e48685b378b693/comments", "author": null, "committer": null, "parents": [{"sha": "c512fd7b336467456ed0734543da1ba0597a8a75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c512fd7b336467456ed0734543da1ba0597a8a75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c512fd7b336467456ed0734543da1ba0597a8a75"}], "stats": {"total": 253, "additions": 161, "deletions": 92}, "files": [{"sha": "bb028f6273ff0d5d50dd858e356807ca94b2aec5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -1,3 +1,19 @@\n+2002-08-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* call.c (standard_conversion): Use build_ptrmem_type.\n+\t* cp-tree.h (build_ptrmem_type): New function.\n+\t(adjust_result_of_qualified_name_lookup): Likewise.\n+\t* decl.c (grokvardecl): Do not look for OFFSET_TYPEs to indicate\n+\tstatic data members.\n+\t(build_ptrmem_type): New function.\n+\t(grokdeclarator): Do not use build_offset_type when encountering a\n+\tqualified name.\n+\t* parse.y (parse_finish_call_expr): Use\n+\tadjust_result_of_qualified_name_lookup.\n+\t* search.c (adjust_result_of_qualified_name_lookup): New function.\n+\t* typeck.c (qualify_type_recursive): Use TYPE_PTRMEM_* rather than\n+\taccessing OFFSET_TYPEs directly.\n+\t\n 2002-08-08  Mike Stump  <mrs@apple.com>\n \n \t* call.c (add_builtin_candidate): legal -> valid, illegal -> invalid."}, {"sha": "cbd7faf31a92af6d311c0e81dd1fcc519319852e", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -838,8 +838,7 @@ standard_conversion (to, from, expr)\n \t\t  (TREE_TYPE (TREE_TYPE (from)),\n \t\t   TREE_TYPE (TREE_TYPE (to)))))\n \t    {\n-\t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n-\t      from = build_pointer_type (from);\n+\t      from = build_ptrmem_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n \t      conv = build_conv (PMEM_CONV, from, conv);\n \t    }\n \t}"}, {"sha": "44a52fc8e78e760cbb045b4885bf87948ee27614", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -3682,6 +3682,7 @@ extern void expand_static_init\t\t\tPARAMS ((tree, tree));\n extern tree start_handler_parms                 PARAMS ((tree, tree));\n extern int complete_array_type\t\t\tPARAMS ((tree, tree, int));\n extern tree build_ptrmemfunc_type\t\tPARAMS ((tree));\n+extern tree build_ptrmem_type                   (tree, tree);\n /* the grokdeclarator prototype is in decl.h */\n extern int parmlist_is_exprlist\t\t\tPARAMS ((tree));\n extern int copy_fn_p\t\t\t\tPARAMS ((tree));\n@@ -4056,7 +4057,8 @@ extern tree find_vbase_instance                 PARAMS ((tree, tree));\n extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n extern tree binfo_via_virtual                   PARAMS ((tree, tree));\n extern tree build_baselink                      (tree, tree, tree, tree);\n-\n+extern tree adjust_result_of_qualified_name_lookup\n+                                                (tree, tree, tree);\n /* in semantics.c */\n extern void init_cp_semantics                   PARAMS ((void));\n extern tree finish_expr_stmt                    PARAMS ((tree));"}, {"sha": "2a185148f51c6ffe7ebba0f70f7fc885511ee18c", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 72, "deletions": 58, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -9137,64 +9137,68 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n   return decl;\n }\n \n+/* Create a VAR_DECL named NAME with the indicated TYPE.  \n+\n+   If SCOPE is non-NULL, it is the class type or namespace containing\n+   the variable.  If SCOPE is NULL, the variable should is created in\n+   the innermost enclosings scope.  */\n+\n static tree\n-grokvardecl (type, declarator, specbits_in, initialized, constp, in_namespace)\n+grokvardecl (type, name, specbits_in, initialized, constp, scope)\n      tree type;\n-     tree declarator;\n+     tree name;\n      RID_BIT_TYPE *specbits_in;\n      int initialized;\n      int constp;\n-     tree in_namespace;\n+     tree scope;\n {\n   tree decl;\n   RID_BIT_TYPE specbits;\n \n+  my_friendly_assert (!name || TREE_CODE (name) == IDENTIFIER_NODE, \n+\t\t      20020808);\n+\n   specbits = *specbits_in;\n \n-  if (TREE_CODE (type) == OFFSET_TYPE)\n+  /* Compute the scope in which to place the variable.  */\n+  if (!scope)\n     {\n-      /* If you declare a static member so that it\n-\t can be initialized, the code will reach here.  */\n-      tree basetype = TYPE_OFFSET_BASETYPE (type);\n-      type = TREE_TYPE (type);\n-      decl = build_lang_decl (VAR_DECL, declarator, type);\n-      DECL_CONTEXT (decl) = basetype;\n-    }\n+      /* An explicit \"extern\" specifier indicates a namespace-scope\n+\t variable.  */\n+      if (RIDBIT_SETP (RID_EXTERN, specbits))\n+\tscope = current_namespace;\n+      else if (!at_function_scope_p ())\n+\t{\n+\t  scope = current_scope ();\n+\t  if (!scope)\n+\t    scope = current_namespace;\n+\t}\n+    }\n+\n+  if (scope\n+      && (/* If the variable is a namespace-scope variable declared in a\n+\t     template, we need DECL_LANG_SPECIFIC.  */\n+\t  (TREE_CODE (scope) == NAMESPACE_DECL && processing_template_decl)\n+\t  /* Similarly for namespace-scope variables with language linkage\n+\t     other than C++.  */\n+\t  || (TREE_CODE (scope) == NAMESPACE_DECL \n+\t      && current_lang_name != lang_name_cplusplus)\n+\t  /* Similarly for static data members.  */\n+\t  || TYPE_P (scope)))\n+    decl = build_lang_decl (VAR_DECL, name, type);\n   else\n-    {\n-      tree context;\n-\n-      if (in_namespace)\n-\tcontext = in_namespace;\n-      else if (namespace_bindings_p () || RIDBIT_SETP (RID_EXTERN, specbits))\n-\tcontext = current_namespace;\n-      else\n-\tcontext = NULL_TREE;\n-\n-      /* For namespace-scope variables, declared in a template, we\n-\t need the full lang_decl.  The same is true for\n-\t namespace-scope variables that do not have C++ language\n-\t linkage.  */\n-      if (context \n-\t  && (processing_template_decl \n-\t      || current_lang_name != lang_name_cplusplus))\n-\tdecl = build_lang_decl (VAR_DECL, declarator, type);\n-      else\n-\tdecl = build_decl (VAR_DECL, declarator, type);\n-\n-      if (context)\n-\tset_decl_namespace (decl, context, 0);\n+    decl = build_decl (VAR_DECL, name, type);\n \n-      context = DECL_CONTEXT (decl);\n-      if (declarator && context && current_lang_name != lang_name_c)\n-\t/* We can't mangle lazily here because we don't have any\n-\t   way to recover whether or not a variable was `extern\n-\t   \"C\"' later.  */\n-\tmangle_decl (decl);\n-    }\n+  if (scope && TREE_CODE (scope) == NAMESPACE_DECL)\n+    set_decl_namespace (decl, scope, 0);\n+  else\n+    DECL_CONTEXT (decl) = scope;\n \n-  if (in_namespace)\n-    set_decl_namespace (decl, in_namespace, 0);\n+  if (name && scope && current_lang_name != lang_name_c)\n+    /* We can't mangle lazily here because we don't have any\n+       way to recover whether or not a variable was `extern\n+       \"C\"' later.  */\n+    mangle_decl (decl);\n \n   if (RIDBIT_SETP (RID_EXTERN, specbits))\n     {\n@@ -9320,6 +9324,14 @@ build_ptrmemfunc_type (type)\n   return t;\n }\n \n+/* Create and return a pointer to data member type.  */\n+\n+tree\n+build_ptrmem_type (tree class_type, tree member_type)\n+{\n+  return build_pointer_type (build_offset_type (class_type, member_type));\n+}\n+\n /* DECL is a VAR_DECL defined in-class, whose TYPE is also given.\n    Check to see that the definition is valid.  Issue appropriate error\n    messages.  Return 1 if the definition is particularly bad, or 0\n@@ -9811,6 +9823,12 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n \t\ttree attributes;\n \n+\t\tif (decl_context != NORMAL)\n+\t\t  {\n+\t\t    error (\"variable declaration is not allowed here\");\n+\t\t    return error_mark_node;\n+\t\t  }\n+\n \t\t*next = TREE_OPERAND (decl, 0);\n \t\tinit = CALL_DECLARATOR_PARMS (decl);\n \n@@ -9835,7 +9853,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t  }\n \t\telse\n \t\t  error (\"invalid declarator\");\n-\t\treturn 0;\n+\t\treturn NULL_TREE;\n \t      }\n \t    innermost_code = TREE_CODE (decl);\n \t    if (decl_context == FIELD && ctype == NULL_TREE)\n@@ -10580,7 +10598,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \n   /* Now figure out the structure of the declarator proper.\n      Descend through it, creating more complex types, until we reach\n-     the declared identifier (or NULL_TREE, in an absolute declarator).  */\n+     the declared identifier (or NULL_TREE, in an abstract declarator).  */\n \n   while (declarator && TREE_CODE (declarator) != IDENTIFIER_NODE\n \t && TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n@@ -10892,9 +10910,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      continue;\n \t    }\n \n-\t  if (TREE_CODE (type) == OFFSET_TYPE\n-\t      && (TREE_CODE (TREE_TYPE (type)) == VOID_TYPE\n-\t\t  || TREE_CODE (TREE_TYPE (type)) == REFERENCE_TYPE))\n+\t  if (ctype\n+\t      && (TREE_CODE (type) == VOID_TYPE\n+\t\t  || TREE_CODE (type) == REFERENCE_TYPE))\n \t    {\n \t      error (\"cannot declare pointer to `%#T' member\",\n \t\t\tTREE_TYPE (type));\n@@ -10917,6 +10935,8 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t    }\n \t  else if (TREE_CODE (type) == METHOD_TYPE)\n \t    type = build_ptrmemfunc_type (build_pointer_type (type));\n+\t  else if (ctype)\n+\t    type = build_ptrmem_type (ctype, type);\n \t  else\n \t    type = build_pointer_type (type);\n \n@@ -11102,7 +11122,6 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t\t  ctype, name, current_class_type);\n \t\t\treturn void_type_node;\n \t\t      }\n-\t\t    type = build_offset_type (ctype, type);\n \t\t  }\n \t\telse\n \t          {\n@@ -11121,14 +11140,9 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\tif (declarator && TREE_CODE (declarator) == CALL_EXPR)\n \t\t  /* In this case, we will deal with it later.  */\n \t\t  ;\n-\t\telse\n-\t\t  {\n-\t\t    if (TREE_CODE (type) == FUNCTION_TYPE)\n-\t\t      type = build_cplus_method_type (ctype, TREE_TYPE (type),\n-\t\t\t\t\t\t      TYPE_ARG_TYPES (type));\n-\t\t    else\n-\t\t      type = build_offset_type (ctype, type);\n-\t\t  }\n+\t\telse if (TREE_CODE (type) == FUNCTION_TYPE)\n+\t\t  type = build_cplus_method_type (ctype, TREE_TYPE (type),\n+\t\t\t\t\t\t  TYPE_ARG_TYPES (type));\n \t      }\n \t  }\n \t  break;\n@@ -11846,7 +11860,7 @@ friend declaration requires class-key, i.e. `friend %#T'\",\n \tdecl = grokvardecl (type, declarator, &specbits,\n \t\t\t    initialized,\n \t\t\t    (type_quals & TYPE_QUAL_CONST) != 0,\n-\t\t\t    in_namespace);\n+\t\t\t    ctype ? ctype : in_namespace);\n \tbad_specifiers (decl, \"variable\", virtualp, quals != NULL_TREE,\n \t\t\tinlinep, friendp, raises != NULL_TREE);\n "}, {"sha": "1134939f84042cf456354e5e7996a550e6cae2a0", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 3, "deletions": 16, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -4156,22 +4156,9 @@ parse_finish_call_expr (tree fn, tree args, int koenig)\n \t\t\t\t  BASELINK_FUNCTIONS (fn),\n \t\t\t\t  template_args);\n \t\t}\n-\t      if (BASELINK_P (fn) \n-\t\t  && current_class_type \n-\t\t  && DERIVED_FROM_P (scope, current_class_type))\n-\t\t{\n-\t\t  scope = lookup_base (current_class_type, scope,\n-\t\t\t\t       ba_ignore | ba_quiet, NULL);\n-\t\t  if (scope)\n-\t\t    {\n-\t\t      BASELINK_ACCESS_BINFO (fn) = scope;\n-\t\t      BASELINK_BINFO (fn) \n-\t\t\t= lookup_base (scope,\n-\t\t\t\t       BINFO_TYPE (BASELINK_BINFO (fn)),\n-\t\t\t\t       ba_ignore | ba_quiet,\n-\t\t\t\t       NULL);\n-\t\t    }\n-\t\t}\n+\t      if (current_class_type)\n+\t\tfn = (adjust_result_of_qualified_name_lookup \n+\t\t      (fn, scope, current_class_type));\n \t    }\n \t}\n       disallow_virtual = true;"}, {"sha": "e4e8baa9ad274c7f5d5971c4df41950977799dbb", "filename": "gcc/cp/search.c", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -1640,6 +1640,50 @@ lookup_fnfields_1 (type, name)\n \n   return -1;\n }\n+\n+/* DECL is the result of a qualified name lookup.  QUALIFYING_CLASS\n+   was the class used to qualify the name.  CONTEXT_CLASS is the class\n+   corresponding to the object in which DECL will be used.  Return a\n+   possibly modified version of DECL that takes into account the\n+   CONTEXT_CLASS.\n+\n+   In particular, consider an expression like `B::m' in the context of\n+   a derived class `D'.  If `B::m' has been resolved to a BASELINK,\n+   then the most derived class indicated by the BASELINK_BINFO will be\n+   `B', not `D'.  This function makes that adjustment.  */\n+\n+tree\n+adjust_result_of_qualified_name_lookup (tree decl, \n+\t\t\t\t\ttree qualifying_class,\n+\t\t\t\t\ttree context_class)\n+{\n+  my_friendly_assert (CLASS_TYPE_P (qualifying_class), 20020808);\n+  my_friendly_assert (CLASS_TYPE_P (context_class), 20020808);\n+\n+  if (BASELINK_P (decl) \n+      && DERIVED_FROM_P (qualifying_class, context_class))\n+    {\n+      tree base;\n+\n+      /* Look for the QUALIFYING_CLASS as a base of the\n+\t CONTEXT_CLASS.  If QUALIFYING_CLASS is ambiguous, we cannot\n+\t be sure yet than an error has occurred; perhaps the function\n+\t chosen by overload resolution will be static.  */\n+      base = lookup_base (context_class, qualifying_class,\n+\t\t\t  ba_ignore | ba_quiet, NULL);\n+      if (base)\n+\t{\n+\t  BASELINK_ACCESS_BINFO (decl) = base;\n+\t  BASELINK_BINFO (decl) \n+\t    = lookup_base (base, BINFO_TYPE (BASELINK_BINFO (decl)),\n+\t\t\t   ba_ignore | ba_quiet,\n+\t\t\t   NULL);\n+\t}\n+    }\n+\n+  return decl;\n+}\n+\n \f\n /* Walk the class hierarchy dominated by TYPE.  FN is called for each\n    type in the hierarchy, in a breadth-first preorder traversal."}, {"sha": "f8bc3786358bfeb0f5186dde56acc2bedb2b1251", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -203,28 +203,33 @@ qualify_type_recursive (t1, t2)\n   if ((TYPE_PTR_P (t1) && TYPE_PTR_P (t2))\n       || (TYPE_PTRMEM_P (t1) && TYPE_PTRMEM_P (t2)))\n     {\n-      tree tt1 = TREE_TYPE (t1);\n-      tree tt2 = TREE_TYPE (t2);\n+      tree tt1;\n+      tree tt2;\n       tree b1;\n       int type_quals;\n       tree tgt;\n       tree attributes = (*targetm.merge_type_attributes) (t1, t2);\n \n-      if (TREE_CODE (tt1) == OFFSET_TYPE)\n+      if (TYPE_PTRMEM_P (t1))\n \t{\n-\t  b1 = TYPE_OFFSET_BASETYPE (tt1);\n-\t  tt1 = TREE_TYPE (tt1);\n-\t  tt2 = TREE_TYPE (tt2);\n+\t  b1 = TYPE_PTRMEM_CLASS_TYPE (t1);\n+\t  tt1 = TYPE_PTRMEM_POINTED_TO_TYPE (t1);\n+\t  tt2 = TYPE_PTRMEM_POINTED_TO_TYPE (t2);\n \t}\n       else\n-\tb1 = NULL_TREE;\n+\t{\n+\t  b1 = NULL_TREE;\n+\t  tt1 = TREE_TYPE (t1);\n+\t  tt2 = TREE_TYPE (t2);\n+\t}\n \n       type_quals = (cp_type_quals (tt1) | cp_type_quals (tt2));\n       tgt = qualify_type_recursive (tt1, tt2);\n       tgt = cp_build_qualified_type (tgt, type_quals);\n       if (b1)\n-\ttgt = build_offset_type (b1, tgt);\n-      t1 = build_pointer_type (tgt);\n+\tt1 = build_ptrmem_type (b1, tgt);\n+      else\n+\tt1 = build_pointer_type (tgt);\n       t1 = build_type_attribute_variant (t1, attributes);\n     }\n   return t1;\n@@ -4390,9 +4395,7 @@ unary_complex_lvalue (code, arg)\n \t      return error_mark_node;\n \t    }\n \n-\t  type = build_offset_type (DECL_FIELD_CONTEXT (t), TREE_TYPE (t));\n-\t  type = build_pointer_type (type);\n-\n+\t  type = build_ptrmem_type (DECL_FIELD_CONTEXT (t), TREE_TYPE (t));\n \t  t = make_ptrmem_cst (type, TREE_OPERAND (arg, 1));\n \t  return t;\n \t}"}, {"sha": "c1bd99ba9e7198af98f77cea3ff350f30b419e52", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -1,3 +1,7 @@\n+2002-08-09  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/template/crash1.C: New test.\n+\n 2002-08-08  Jakub Jelinek  <jakub@redhat.com>\n \n \t* gcc.dg/tls/opt-2.c: New test."}, {"sha": "e3c83bcd22f57ab2258bdc0f2d61ea9216f3ae74", "filename": "gcc/testsuite/g++.dg/template/crash1.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9e259dd1ff3f146f89ff4261d9e48685b378b693/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fcrash1.C?ref=9e259dd1ff3f146f89ff4261d9e48685b378b693", "patch": "@@ -1,7 +1,7 @@\n // { dg-do compile }\n \n-// Copyright (C) 2001 Free Software Foundation, Inc.\n-// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@nathan@codesourcery.com>\n+// Copyright (C) 2001, 2002 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 29 Dec 2001 <nathan@codesourcery.com>\n \n // PR 5125. ICE\n \n@@ -13,5 +13,5 @@ class S\n \n template <class I>\n void S::Foo(int (*f)(TYPO&o) )\n-{ // { dg-error \"template definition of non-template|prototype\" \"\" }\n+{ // { dg-error \"template definition|variable declaration|prototype\" \"\" }\n }"}]}