{"sha": "9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWZiZjU2ZjdhMWMwMWY2OTgzNWIwZGQ3MjJjNGRmNWQ2ZDgzYWIwYg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@markmitchell.com", "date": "1998-10-13T14:34:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1998-10-13T14:34:26Z"}, "message": "cp-tree.h (specializations_of_same_template_p): Remove.\n\n\t* cp-tree.h (specializations_of_same_template_p): Remove.\n\t* search.c (get_template_base): Don't use it.\n\t(get_template_base_recursive): Likewise.\n\t* pt.c (specializations_of_same_template_p): Remove.\n\t(unify): Don't use it.\n\t(lookup_template_class): Find the correct parent when setting\n\tCLASSTYPE_TI_TEMPLATE.\n\nFrom-SVN: r23053", "tree": {"sha": "9a6e95385ba03c0beb5272022ade38179623beb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9a6e95385ba03c0beb5272022ade38179623beb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/comments", "author": null, "committer": null, "parents": [{"sha": "29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29a65e3dd4ee3a58d4fd49cdaf2b52dc499f5a2e"}], "stats": {"total": 119, "additions": 82, "deletions": 37}, "files": [{"sha": "2a59ec0d41260697fd546a39a3a8169ef65d5542", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "patch": "@@ -1,3 +1,13 @@\n+1998-10-13  Mark Mitchell  <mark@markmitchell.com>\n+\n+\t* cp-tree.h (specializations_of_same_template_p): Remove.\n+\t* search.c (get_template_base): Don't use it.\n+\t(get_template_base_recursive): Likewise.\n+\t* pt.c (specializations_of_same_template_p): Remove.\n+\t(unify): Don't use it.\n+\t(lookup_template_class): Find the correct parent when setting\n+\tCLASSTYPE_TI_TEMPLATE.\n+\t\n 1998-10-12  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* tinfo.cc (operator==): Always compare names."}, {"sha": "6632f8adff8c3f914d0b064a8469785ee2cdae49", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "patch": "@@ -2869,7 +2869,6 @@ extern int is_specialization_of                 PROTO((tree, tree));\n extern int comp_template_args                   PROTO((tree, tree));\n extern void maybe_process_partial_specialization PROTO((tree));\n extern void maybe_check_template_type           PROTO((tree));\n-extern int specializations_of_same_template_p   PROTO((tree, tree));\n \n extern int processing_specialization;\n extern int processing_explicit_instantiation;"}, {"sha": "ea021fa80258c915e9ca471cd395d92dcfa7567b", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 70, "deletions": 32, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "patch": "@@ -756,22 +756,6 @@ is_specialization_of (decl, tmpl)\n   return 0;\n }\n \n-/* Returns nonzero if T1 and T2 are instances of the same template.\n-   (They may have different template arguments.)  */\n-\n-int\n-specializations_of_same_template_p (t1, t2)\n-     tree t1;\n-     tree t2;\n-{\n-  /* For now, we only deal with instances of class templates, since\n-     that is the only way in which this function is used.  */\n-\n-  return (most_general_template (CLASSTYPE_TI_TEMPLATE (t1))\n-\t  == most_general_template (CLASSTYPE_TI_TEMPLATE (t2)));\n-}\n-\n-\n /* Register the specialization SPEC as a specialization of TMPL with\n    the indicated ARGS.  Returns SPEC, or an equivalent prior\n    declaration, if available.  */\n@@ -3201,22 +3185,26 @@ classtype_mangled_name (t)\n   if (CLASSTYPE_TEMPLATE_INFO (t)\n       /* Specializations have already had their names set up in\n \t lookup_template_class.  */\n-      && !CLASSTYPE_TEMPLATE_SPECIALIZATION (t)\n+      && !CLASSTYPE_TEMPLATE_SPECIALIZATION (t))\n+    {\n+      tree tmpl = most_general_template (CLASSTYPE_TI_TEMPLATE (t));\n+\n       /* For non-primary templates, the template parameters are\n \t implicit from their surrounding context.  */\n-      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (t)))\n-    {\n-      tree name = DECL_NAME (CLASSTYPE_TI_TEMPLATE (t));\n-      char *mangled_name = mangle_class_name_for_template\n-\t(IDENTIFIER_POINTER (name),\n-\t DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (t)),\n-\t CLASSTYPE_TI_ARGS (t));\n-      tree id = get_identifier (mangled_name);\n-      IDENTIFIER_TEMPLATE (id) = name;\n-      return id;\n+      if (PRIMARY_TEMPLATE_P (tmpl))\n+\t{\n+\t  tree name = DECL_NAME (tmpl);\n+\t  char *mangled_name = mangle_class_name_for_template\n+\t    (IDENTIFIER_POINTER (name), \n+\t     DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n+\t     CLASSTYPE_TI_ARGS (t));\n+\t  tree id = get_identifier (mangled_name);\n+\t  IDENTIFIER_TEMPLATE (id) = name;\n+\t  return id;\n+\t}\n     }\n-  else\n-    return TYPE_IDENTIFIER (t);\n+\n+  return TYPE_IDENTIFIER (t);\n }\n \n static void\n@@ -3603,10 +3591,59 @@ lookup_template_class (d1, arglist, in_decl, context, entering_scope)\n       else\n \ttype_decl = TYPE_NAME (t);\n \n-      /* Set up the template information.  */\n+      /* Set up the template information.  We have to figure out which\n+\t template is the immediate parent if this is a full\n+\t instantiation.  */\n+      if (parm_depth == 1 || is_partial_instantiation\n+\t  || !PRIMARY_TEMPLATE_P (template))\n+\t/* This case is easy; there are no member templates involved.  */\n+\tfound = template;\n+      else\n+\t{\n+\t  /* This is a full instantiation of a member template.  There\n+\t     should be some partial instantiation of which this is an\n+\t     instance.  */\n+\n+\t  for (found = DECL_TEMPLATE_INSTANTIATIONS (template);\n+\t       found; found = TREE_CHAIN (found))\n+\t    {\n+\t      int success;\n+\t      tree tmpl = CLASSTYPE_TI_TEMPLATE (TREE_VALUE (found));\n+\n+\t      /* We only want partial instantiations, here, not\n+\t\t specializations or full instantiations.  */\n+\t      if (CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_VALUE (found))\n+\t\t  || !uses_template_parms (TREE_VALUE (found)))\n+\t\tcontinue;\n+\n+\t      /* Temporarily reduce by one the number of levels in the\n+\t\t ARGLIST and in FOUND so as to avoid comparing the\n+\t\t last set of arguments.  */\n+\t      TREE_VEC_LENGTH (arglist)--;\n+\t      TREE_VEC_LENGTH (TREE_PURPOSE (found)) --;\n+\n+\t      /* See if the arguments match.  If they do, then TMPL is\n+\t\t the partial instantiation we want.  */\n+\t      success = comp_template_args (TREE_PURPOSE (found), arglist);\n+\n+\t      /* Restore the argument vectors to their full size.  */\n+\t      TREE_VEC_LENGTH (arglist)++;\n+\t      TREE_VEC_LENGTH (TREE_PURPOSE (found))++;\n+\n+\t      if (success)\n+\t\t{\n+\t\t  found = tmpl;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  if (!found)\n+\t    my_friendly_abort (0);\n+\t}\n+\n       arglist = copy_to_permanent (arglist);\n       SET_TYPE_TEMPLATE_INFO (t,\n-\t\t\t      tree_cons (template, arglist, NULL_TREE));\n+\t\t\t      tree_cons (found, arglist, NULL_TREE));  \n       DECL_TEMPLATE_INSTANTIATIONS (template) \n \t= tree_cons (arglist, t, \n \t\t     DECL_TEMPLATE_INSTANTIATIONS (template));\n@@ -7363,7 +7400,8 @@ unify (tparms, targs, parm, arg, strict, explicit_mask)\n \t       derivation is involved.  */\n \t    t = get_template_base (CLASSTYPE_TI_TEMPLATE (parm), arg);\n \t  else if (CLASSTYPE_TEMPLATE_INFO (arg) \n-\t\t   && specializations_of_same_template_p (parm, arg))\n+\t\t   && (CLASSTYPE_TI_TEMPLATE (parm) \n+\t\t       == CLASSTYPE_TI_TEMPLATE (arg)))\n \t    /* Perhaps PARM is something like S<U> and ARG is S<int>.\n \t       Then, we should unify `int' and `U'.  */\n \t    t = arg;"}, {"sha": "be6cffc9757cbf988c808167c51fe16d0a2aef8d", "filename": "gcc/cp/search.c", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=9fbf56f7a1c01f69835b0dd722c4df5d6d83ab0b", "patch": "@@ -3317,8 +3317,7 @@ get_template_base_recursive (binfo, rval, template, via_virtual)\n   tree type = BINFO_TYPE (binfo);\n \n   if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && specializations_of_same_template_p (TREE_TYPE (template), \n-\t\t\t\t\t     type))\n+      && CLASSTYPE_TI_TEMPLATE (type) == template)\n     {\n       if (rval == NULL_TREE || rval == type)\n \treturn type;\n@@ -3376,8 +3375,7 @@ get_template_base (template, binfo)\n     my_friendly_abort (92);\n \n   if (CLASSTYPE_TEMPLATE_INFO (type)\n-      && specializations_of_same_template_p (TREE_TYPE (template), \n-\t\t\t\t\t     type))\n+      && CLASSTYPE_TI_TEMPLATE (type) == template)\n     return type;\n \n   rval = get_template_base_recursive (binfo, NULL_TREE, template, 0);"}]}