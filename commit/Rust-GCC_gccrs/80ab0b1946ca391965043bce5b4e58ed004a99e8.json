{"sha": "80ab0b1946ca391965043bce5b4e58ed004a99e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODBhYjBiMTk0NmNhMzkxOTY1MDQzYmNlNWI0ZTU4ZWQwMDRhOTllOA==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-09-11T10:09:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-09-11T10:09:41Z"}, "message": "tree-data-ref.c (dump_rdg_vertex, [...]): Move ...\n\n2013-09-11  Richard Biener  <rguenther@suse.de>\n\n\t* tree-data-ref.c (dump_rdg_vertex, debug_rdg_vertex,\n\tdump_rdg_component, debug_rdg_component, dump_rdg, debug_rdg,\n\tdot_rdg_1, dot_rdg, rdg_vertex_for_stmt, create_rdg_edge_for_ddr,\n\tcreate_rdg_edges_for_scalar, create_rdg_edges, create_rdg_vertices,\n\tstmts_from_loop, known_dependences_p, build_empty_rdg,\n\tbuild_rdg, free_rdg, rdg_defs_used_in_other_loops_p): Move ...\n\t* tree-loop-distribution.c: ... here.\n\t* tree-data-ref.h (struct rdg_vertex, RDGV_STMT, RDGV_DATAREFS,\n\tRDGV_HAS_MEM_WRITE, RDGV_HAS_MEM_READS, RDG_STMT, RDG_DATAREFS,\n\tRDG_MEM_WRITE_STMT, RDG_MEM_READS_STMT, enum rdg_dep_type,\n\tstruct rdg_edge, RDGE_TYPE, RDGE_LEVEL, RDGE_RELATION): Move ...\n\t* tree-loop-distribution.c: ... here.\n\t* tree-loop-distribution.c: Include gimple-pretty-print.h.\n\t(struct partition_s): Add loops member.\n\t(partition_alloc, partition_free, rdg_flag_uses, rdg_flag_vertex,\n\trdg_flag_vertex_and_dependent, rdg_flag_loop_exits,\n\tbuild_rdg_partition_for_component, rdg_build_partitions): Adjust.\n\nFrom-SVN: r202492", "tree": {"sha": "d1c333750d976df95678b5910c4cd358e3f5cdeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1c333750d976df95678b5910c4cd358e3f5cdeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80ab0b1946ca391965043bce5b4e58ed004a99e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ab0b1946ca391965043bce5b4e58ed004a99e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ab0b1946ca391965043bce5b4e58ed004a99e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ab0b1946ca391965043bce5b4e58ed004a99e8/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "85a772214402901c17d47196add4c508e25866c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/85a772214402901c17d47196add4c508e25866c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/85a772214402901c17d47196add4c508e25866c2"}], "stats": {"total": 1174, "additions": 589, "deletions": 585}, "files": [{"sha": "467377802bf613ad328ff239a22338d658ed731a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80ab0b1946ca391965043bce5b4e58ed004a99e8", "patch": "@@ -1,3 +1,23 @@\n+2013-09-11  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-data-ref.c (dump_rdg_vertex, debug_rdg_vertex,\n+\tdump_rdg_component, debug_rdg_component, dump_rdg, debug_rdg,\n+\tdot_rdg_1, dot_rdg, rdg_vertex_for_stmt, create_rdg_edge_for_ddr,\n+\tcreate_rdg_edges_for_scalar, create_rdg_edges, create_rdg_vertices,\n+\tstmts_from_loop, known_dependences_p, build_empty_rdg,\n+\tbuild_rdg, free_rdg, rdg_defs_used_in_other_loops_p): Move ...\n+\t* tree-loop-distribution.c: ... here.\n+\t* tree-data-ref.h (struct rdg_vertex, RDGV_STMT, RDGV_DATAREFS,\n+\tRDGV_HAS_MEM_WRITE, RDGV_HAS_MEM_READS, RDG_STMT, RDG_DATAREFS,\n+\tRDG_MEM_WRITE_STMT, RDG_MEM_READS_STMT, enum rdg_dep_type,\n+\tstruct rdg_edge, RDGE_TYPE, RDGE_LEVEL, RDGE_RELATION): Move ...\n+\t* tree-loop-distribution.c: ... here.\n+\t* tree-loop-distribution.c: Include gimple-pretty-print.h.\n+\t(struct partition_s): Add loops member.\n+\t(partition_alloc, partition_free, rdg_flag_uses, rdg_flag_vertex,\n+\trdg_flag_vertex_and_dependent, rdg_flag_loop_exits,\n+\tbuild_rdg_partition_for_component, rdg_build_partitions): Adjust.\n+\n 2013-09-11  Alexander Ivchenko  <alexander.ivchenko@intel.com>\n \t    Maxim Kuznetsov  <maxim.kuznetsov@intel.com>\n \t    Sergey Lega  <sergey.s.lega@intel.com>"}, {"sha": "4d99eb3940fd0df1de8713b81ea9f23830f85ffa", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 0, "deletions": 468, "changes": 468, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=80ab0b1946ca391965043bce5b4e58ed004a99e8", "patch": "@@ -4798,471 +4798,3 @@ free_data_refs (vec<data_reference_p> datarefs)\n     free_data_ref (dr);\n   datarefs.release ();\n }\n-\n-\f\n-\n-/* Dump vertex I in RDG to FILE.  */\n-\n-static void\n-dump_rdg_vertex (FILE *file, struct graph *rdg, int i)\n-{\n-  struct vertex *v = &(rdg->vertices[i]);\n-  struct graph_edge *e;\n-\n-  fprintf (file, \"(vertex %d: (%s%s) (in:\", i,\n-\t   RDG_MEM_WRITE_STMT (rdg, i) ? \"w\" : \"\",\n-\t   RDG_MEM_READS_STMT (rdg, i) ? \"r\" : \"\");\n-\n-  if (v->pred)\n-    for (e = v->pred; e; e = e->pred_next)\n-      fprintf (file, \" %d\", e->src);\n-\n-  fprintf (file, \") (out:\");\n-\n-  if (v->succ)\n-    for (e = v->succ; e; e = e->succ_next)\n-      fprintf (file, \" %d\", e->dest);\n-\n-  fprintf (file, \")\\n\");\n-  print_gimple_stmt (file, RDGV_STMT (v), 0, TDF_VOPS|TDF_MEMSYMS);\n-  fprintf (file, \")\\n\");\n-}\n-\n-/* Call dump_rdg_vertex on stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_rdg_vertex (struct graph *rdg, int i)\n-{\n-  dump_rdg_vertex (stderr, rdg, i);\n-}\n-\n-/* Dump component C of RDG to FILE.  If DUMPED is non-null, set the\n-   dumped vertices to that bitmap.  */\n-\n-static void\n-dump_rdg_component (FILE *file, struct graph *rdg, int c, bitmap dumped)\n-{\n-  int i;\n-\n-  fprintf (file, \"(%d\\n\", c);\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    if (rdg->vertices[i].component == c)\n-      {\n-\tif (dumped)\n-\t  bitmap_set_bit (dumped, i);\n-\n-\tdump_rdg_vertex (file, rdg, i);\n-      }\n-\n-  fprintf (file, \")\\n\");\n-}\n-\n-/* Call dump_rdg_vertex on stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_rdg_component (struct graph *rdg, int c)\n-{\n-  dump_rdg_component (stderr, rdg, c, NULL);\n-}\n-\n-/* Dump the reduced dependence graph RDG to FILE.  */\n-\n-void\n-dump_rdg (FILE *file, struct graph *rdg)\n-{\n-  int i;\n-  bitmap dumped = BITMAP_ALLOC (NULL);\n-\n-  fprintf (file, \"(rdg\\n\");\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    if (!bitmap_bit_p (dumped, i))\n-      dump_rdg_component (file, rdg, rdg->vertices[i].component, dumped);\n-\n-  fprintf (file, \")\\n\");\n-  BITMAP_FREE (dumped);\n-}\n-\n-/* Call dump_rdg on stderr.  */\n-\n-DEBUG_FUNCTION void\n-debug_rdg (struct graph *rdg)\n-{\n-  dump_rdg (stderr, rdg);\n-}\n-\n-static void\n-dot_rdg_1 (FILE *file, struct graph *rdg)\n-{\n-  int i;\n-\n-  fprintf (file, \"digraph RDG {\\n\");\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    {\n-      struct vertex *v = &(rdg->vertices[i]);\n-      struct graph_edge *e;\n-\n-      /* Highlight reads from memory.  */\n-      if (RDG_MEM_READS_STMT (rdg, i))\n-       fprintf (file, \"%d [style=filled, fillcolor=green]\\n\", i);\n-\n-      /* Highlight stores to memory.  */\n-      if (RDG_MEM_WRITE_STMT (rdg, i))\n-       fprintf (file, \"%d [style=filled, fillcolor=red]\\n\", i);\n-\n-      if (v->succ)\n-       for (e = v->succ; e; e = e->succ_next)\n-         switch (RDGE_TYPE (e))\n-           {\n-           case input_dd:\n-             fprintf (file, \"%d -> %d [label=input] \\n\", i, e->dest);\n-             break;\n-\n-           case output_dd:\n-             fprintf (file, \"%d -> %d [label=output] \\n\", i, e->dest);\n-             break;\n-\n-           case flow_dd:\n-             /* These are the most common dependences: don't print these. */\n-             fprintf (file, \"%d -> %d \\n\", i, e->dest);\n-             break;\n-\n-           case anti_dd:\n-             fprintf (file, \"%d -> %d [label=anti] \\n\", i, e->dest);\n-             break;\n-\n-           default:\n-             gcc_unreachable ();\n-           }\n-    }\n-\n-  fprintf (file, \"}\\n\\n\");\n-}\n-\n-/* Display the Reduced Dependence Graph using dotty.  */\n-extern void dot_rdg (struct graph *);\n-\n-DEBUG_FUNCTION void\n-dot_rdg (struct graph *rdg)\n-{\n-  /* When debugging, enable the following code.  This cannot be used\n-     in production compilers because it calls \"system\".  */\n-#if 0\n-  FILE *file = fopen (\"/tmp/rdg.dot\", \"w\");\n-  gcc_assert (file != NULL);\n-\n-  dot_rdg_1 (file, rdg);\n-  fclose (file);\n-\n-  system (\"dotty /tmp/rdg.dot &\");\n-#else\n-  dot_rdg_1 (stderr, rdg);\n-#endif\n-}\n-\n-/* Returns the index of STMT in RDG.  */\n-\n-int\n-rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple stmt)\n-{\n-  int index = gimple_uid (stmt);\n-  gcc_checking_assert (index == -1 || RDG_STMT (rdg, index) == stmt);\n-  return index;\n-}\n-\n-/* Creates an edge in RDG for each distance vector from DDR.  The\n-   order that we keep track of in the RDG is the order in which\n-   statements have to be executed.  */\n-\n-static void\n-create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n-{\n-  struct graph_edge *e;\n-  int va, vb;\n-  data_reference_p dra = DDR_A (ddr);\n-  data_reference_p drb = DDR_B (ddr);\n-  unsigned level = ddr_dependence_level (ddr);\n-\n-  /* For non scalar dependences, when the dependence is REVERSED,\n-     statement B has to be executed before statement A.  */\n-  if (level > 0\n-      && !DDR_REVERSED_P (ddr))\n-    {\n-      data_reference_p tmp = dra;\n-      dra = drb;\n-      drb = tmp;\n-    }\n-\n-  va = rdg_vertex_for_stmt (rdg, DR_STMT (dra));\n-  vb = rdg_vertex_for_stmt (rdg, DR_STMT (drb));\n-\n-  if (va < 0 || vb < 0)\n-    return;\n-\n-  e = add_edge (rdg, va, vb);\n-  e->data = XNEW (struct rdg_edge);\n-\n-  RDGE_LEVEL (e) = level;\n-  RDGE_RELATION (e) = ddr;\n-\n-  /* Determines the type of the data dependence.  */\n-  if (DR_IS_READ (dra) && DR_IS_READ (drb))\n-    RDGE_TYPE (e) = input_dd;\n-  else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n-    RDGE_TYPE (e) = output_dd;\n-  else if (DR_IS_WRITE (dra) && DR_IS_READ (drb))\n-    RDGE_TYPE (e) = flow_dd;\n-  else if (DR_IS_READ (dra) && DR_IS_WRITE (drb))\n-    RDGE_TYPE (e) = anti_dd;\n-}\n-\n-/* Creates dependence edges in RDG for all the uses of DEF.  IDEF is\n-   the index of DEF in RDG.  */\n-\n-static void\n-create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n-{\n-  use_operand_p imm_use_p;\n-  imm_use_iterator iterator;\n-\n-  FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, def)\n-    {\n-      struct graph_edge *e;\n-      int use = rdg_vertex_for_stmt (rdg, USE_STMT (imm_use_p));\n-\n-      if (use < 0)\n-\tcontinue;\n-\n-      e = add_edge (rdg, idef, use);\n-      e->data = XNEW (struct rdg_edge);\n-      RDGE_TYPE (e) = flow_dd;\n-      RDGE_RELATION (e) = NULL;\n-    }\n-}\n-\n-/* Creates the edges of the reduced dependence graph RDG.  */\n-\n-static void\n-create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs)\n-{\n-  int i;\n-  struct data_dependence_relation *ddr;\n-  def_operand_p def_p;\n-  ssa_op_iter iter;\n-\n-  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n-    if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n-      create_rdg_edge_for_ddr (rdg, ddr);\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    FOR_EACH_PHI_OR_STMT_DEF (def_p, RDG_STMT (rdg, i),\n-\t\t\t      iter, SSA_OP_DEF)\n-      create_rdg_edges_for_scalar (rdg, DEF_FROM_PTR (def_p), i);\n-}\n-\n-/* Build the vertices of the reduced dependence graph RDG.  Return false\n-   if that failed.  */\n-\n-static bool\n-create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop,\n-\t\t     vec<data_reference_p> *datarefs)\n-{\n-  int i;\n-  gimple stmt;\n-\n-  FOR_EACH_VEC_ELT (stmts, i, stmt)\n-    {\n-      struct vertex *v = &(rdg->vertices[i]);\n-\n-      /* Record statement to vertex mapping.  */\n-      gimple_set_uid (stmt, i);\n-\n-      v->data = XNEW (struct rdg_vertex);\n-      RDGV_STMT (v) = stmt;\n-      RDGV_DATAREFS (v).create (0);\n-      RDGV_HAS_MEM_WRITE (v) = false;\n-      RDGV_HAS_MEM_READS (v) = false;\n-      if (gimple_code (stmt) == GIMPLE_PHI)\n-\tcontinue;\n-\n-      unsigned drp = datarefs->length ();\n-      if (!find_data_references_in_stmt (loop, stmt, datarefs))\n-\treturn false;\n-      for (unsigned j = drp; j < datarefs->length (); ++j)\n-\t{\n-\t  data_reference_p dr = (*datarefs)[j];\n-\t  if (DR_IS_READ (dr))\n-\t    RDGV_HAS_MEM_READS (v) = true;\n-\t  else\n-\t    RDGV_HAS_MEM_WRITE (v) = true;\n-\t  RDGV_DATAREFS (v).safe_push (dr);\n-\t}\n-    }\n-  return true;\n-}\n-\n-/* Initialize STMTS with all the statements of LOOP.  When\n-   INCLUDE_PHIS is true, include also the PHI nodes.  The order in\n-   which we discover statements is important as\n-   generate_loops_for_partition is using the same traversal for\n-   identifying statements. */\n-\n-static void\n-stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n-{\n-  unsigned int i;\n-  basic_block *bbs = get_loop_body_in_dom_order (loop);\n-\n-  for (i = 0; i < loop->num_nodes; i++)\n-    {\n-      basic_block bb = bbs[i];\n-      gimple_stmt_iterator bsi;\n-      gimple stmt;\n-\n-      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\tstmts->safe_push (gsi_stmt (bsi));\n-\n-      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n-\t{\n-\t  stmt = gsi_stmt (bsi);\n-\t  if (gimple_code (stmt) != GIMPLE_LABEL && !is_gimple_debug (stmt))\n-\t    stmts->safe_push (stmt);\n-\t}\n-    }\n-\n-  free (bbs);\n-}\n-\n-/* Returns true when all the dependences are computable.  */\n-\n-static bool\n-known_dependences_p (vec<ddr_p> dependence_relations)\n-{\n-  ddr_p ddr;\n-  unsigned int i;\n-\n-  FOR_EACH_VEC_ELT (dependence_relations, i, ddr)\n-    if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n-      return false;\n-\n-  return true;\n-}\n-\n-/* Build the Reduced Dependence Graph (RDG) with one vertex per\n-   statement of the loop nest, and one edge per data dependence or\n-   scalar dependence.  */\n-\n-struct graph *\n-build_empty_rdg (int n_stmts)\n-{\n-  struct graph *rdg = new_graph (n_stmts);\n-  return rdg;\n-}\n-\n-/* Build the Reduced Dependence Graph (RDG) with one vertex per\n-   statement of the loop nest, and one edge per data dependence or\n-   scalar dependence.  */\n-\n-struct graph *\n-build_rdg (struct loop *loop)\n-{\n-  struct graph *rdg;\n-  vec<loop_p> loop_nest;\n-  vec<gimple> stmts;\n-  vec<data_reference_p> datarefs;\n-  vec<ddr_p> dependence_relations;\n-\n-  loop_nest.create (3);\n-  if (!find_loop_nest (loop, &loop_nest))\n-    {\n-      loop_nest.release ();\n-      return NULL;\n-    }\n-\n-  stmts.create (10);\n-  stmts_from_loop (loop, &stmts);\n-  rdg = build_empty_rdg (stmts.length ());\n-  datarefs.create (10);\n-  if (!create_rdg_vertices (rdg, stmts, loop, &datarefs))\n-    {\n-      stmts.release ();\n-      free_rdg (rdg);\n-      return NULL;\n-    }\n-  stmts.release ();\n-  dependence_relations.create (100);\n-  if (!compute_all_dependences (datarefs, &dependence_relations, loop_nest,\n-\t\t\t\tfalse)\n-      || !known_dependences_p (dependence_relations))\n-    {\n-      loop_nest.release ();\n-      datarefs.release ();\n-      dependence_relations.release ();\n-      free_rdg (rdg);\n-      return NULL;\n-    }\n-  loop_nest.release ();\n-  create_rdg_edges (rdg, dependence_relations);\n-  dependence_relations.release ();\n-\n-  return rdg;\n-}\n-\n-/* Free the reduced dependence graph RDG.  */\n-\n-void\n-free_rdg (struct graph *rdg)\n-{\n-  int i;\n-\n-  for (i = 0; i < rdg->n_vertices; i++)\n-    {\n-      struct vertex *v = &(rdg->vertices[i]);\n-      struct graph_edge *e;\n-\n-      for (e = v->succ; e; e = e->succ_next)\n-\t{\n-\t  free_dependence_relation (RDGE_RELATION (e));\n-\t  free (e->data);\n-\t}\n-\n-      if (v->data)\n-\t{\n-\t  gimple_set_uid (RDGV_STMT (v), -1);\n-\t  free_data_refs (RDGV_DATAREFS (v));\n-\t  free (v->data);\n-\t}\n-    }\n-\n-  free_graph (rdg);\n-}\n-\n-/* Determines whether the statement from vertex V of the RDG has a\n-   definition used outside the loop that contains this statement.  */\n-\n-bool\n-rdg_defs_used_in_other_loops_p (struct graph *rdg, int v)\n-{\n-  gimple stmt = RDG_STMT (rdg, v);\n-  struct loop *loop = loop_containing_stmt (stmt);\n-  use_operand_p imm_use_p;\n-  imm_use_iterator iterator;\n-  ssa_op_iter it;\n-  def_operand_p def_p;\n-\n-  if (!loop)\n-    return true;\n-\n-  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, it, SSA_OP_DEF)\n-    {\n-      FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, DEF_FROM_PTR (def_p))\n-\t{\n-\t  if (loop_containing_stmt (USE_STMT (imm_use_p)) != loop)\n-\t    return true;\n-\t}\n-    }\n-\n-  return false;\n-}"}, {"sha": "5dda3e594b2d508abbca8d55fa89971c15e0c793", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 0, "deletions": 86, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=80ab0b1946ca391965043bce5b4e58ed004a99e8", "patch": "@@ -515,79 +515,6 @@ ddr_dependence_level (ddr_p ddr)\n   return level;\n }\n \n-\f\n-\n-/* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n-typedef struct rdg_vertex\n-{\n-  /* The statement represented by this vertex.  */\n-  gimple stmt;\n-\n-  /* Vector of data-references in this statement.  */\n-  vec<data_reference_p> datarefs;\n-\n-  /* True when the statement contains a write to memory.  */\n-  bool has_mem_write;\n-\n-  /* True when the statement contains a read from memory.  */\n-  bool has_mem_reads;\n-} *rdg_vertex_p;\n-\n-#define RDGV_STMT(V)     ((struct rdg_vertex *) ((V)->data))->stmt\n-#define RDGV_DATAREFS(V) ((struct rdg_vertex *) ((V)->data))->datarefs\n-#define RDGV_HAS_MEM_WRITE(V) ((struct rdg_vertex *) ((V)->data))->has_mem_write\n-#define RDGV_HAS_MEM_READS(V) ((struct rdg_vertex *) ((V)->data))->has_mem_reads\n-#define RDG_STMT(RDG, I) RDGV_STMT (&(RDG->vertices[I]))\n-#define RDG_DATAREFS(RDG, I) RDGV_DATAREFS (&(RDG->vertices[I]))\n-#define RDG_MEM_WRITE_STMT(RDG, I) RDGV_HAS_MEM_WRITE (&(RDG->vertices[I]))\n-#define RDG_MEM_READS_STMT(RDG, I) RDGV_HAS_MEM_READS (&(RDG->vertices[I]))\n-\n-void debug_rdg_vertex (struct graph *, int);\n-void debug_rdg_component (struct graph *, int);\n-void dump_rdg (FILE *, struct graph *);\n-void debug_rdg (struct graph *);\n-int rdg_vertex_for_stmt (struct graph *, gimple);\n-\n-/* Data dependence type.  */\n-\n-enum rdg_dep_type\n-{\n-  /* Read After Write (RAW).  */\n-  flow_dd = 'f',\n-\n-  /* Write After Read (WAR).  */\n-  anti_dd = 'a',\n-\n-  /* Write After Write (WAW).  */\n-  output_dd = 'o',\n-\n-  /* Read After Read (RAR).  */\n-  input_dd = 'i'\n-};\n-\n-/* Dependence information attached to an edge of the RDG.  */\n-\n-typedef struct rdg_edge\n-{\n-  /* Type of the dependence.  */\n-  enum rdg_dep_type type;\n-\n-  /* Levels of the dependence: the depth of the loops that carry the\n-     dependence.  */\n-  unsigned level;\n-\n-  /* Dependence relation between data dependences, NULL when one of\n-     the vertices is a scalar.  */\n-  ddr_p relation;\n-} *rdg_edge_p;\n-\n-#define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n-#define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n-#define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n-\n-struct graph *build_rdg (struct loop *);\n-void free_rdg (struct graph *);\n-\n /* Return the index of the variable VAR in the LOOP_NEST array.  */\n \n static inline int\n@@ -604,8 +531,6 @@ index_in_loop_nest (int var, vec<loop_p> loop_nest)\n   return var_index;\n }\n \n-bool rdg_defs_used_in_other_loops_p (struct graph *, int);\n-\n /* Returns true when the data reference DR the form \"A[i] = ...\"\n    with a stride equal to its unit type size.  */\n \n@@ -626,19 +551,8 @@ adjacent_dr_p (struct data_reference *dr)\n \t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (DR_REF (dr))));\n }\n \n-/* In tree-data-ref.c  */\n void split_constant_offset (tree , tree *, tree *);\n \n-/* Strongly connected components of the reduced data dependence graph.  */\n-\n-typedef struct rdg_component\n-{\n-  int num;\n-  vec<int> vertices;\n-} *rdgc;\n-\n-\n-\n /* Compute the greatest common divisor of a VECTOR of SIZE numbers.  */\n \n static inline int"}, {"sha": "5f6a14b410fdfecc038a9fa2c1b23c134d97a0c8", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 569, "deletions": 31, "changes": 600, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80ab0b1946ca391965043bce5b4e58ed004a99e8/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=80ab0b1946ca391965043bce5b4e58ed004a99e8", "patch": "@@ -50,6 +50,545 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-data-ref.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-pass.h\"\n+#include \"gimple-pretty-print.h\"\n+\n+\n+/* A Reduced Dependence Graph (RDG) vertex representing a statement.  */\n+typedef struct rdg_vertex\n+{\n+  /* The statement represented by this vertex.  */\n+  gimple stmt;\n+\n+  /* Vector of data-references in this statement.  */\n+  vec<data_reference_p> datarefs;\n+\n+  /* True when the statement contains a write to memory.  */\n+  bool has_mem_write;\n+\n+  /* True when the statement contains a read from memory.  */\n+  bool has_mem_reads;\n+} *rdg_vertex_p;\n+\n+#define RDGV_STMT(V)     ((struct rdg_vertex *) ((V)->data))->stmt\n+#define RDGV_DATAREFS(V) ((struct rdg_vertex *) ((V)->data))->datarefs\n+#define RDGV_HAS_MEM_WRITE(V) ((struct rdg_vertex *) ((V)->data))->has_mem_write\n+#define RDGV_HAS_MEM_READS(V) ((struct rdg_vertex *) ((V)->data))->has_mem_reads\n+#define RDG_STMT(RDG, I) RDGV_STMT (&(RDG->vertices[I]))\n+#define RDG_DATAREFS(RDG, I) RDGV_DATAREFS (&(RDG->vertices[I]))\n+#define RDG_MEM_WRITE_STMT(RDG, I) RDGV_HAS_MEM_WRITE (&(RDG->vertices[I]))\n+#define RDG_MEM_READS_STMT(RDG, I) RDGV_HAS_MEM_READS (&(RDG->vertices[I]))\n+\n+/* Data dependence type.  */\n+\n+enum rdg_dep_type\n+{\n+  /* Read After Write (RAW).  */\n+  flow_dd = 'f',\n+\n+  /* Write After Read (WAR).  */\n+  anti_dd = 'a',\n+\n+  /* Write After Write (WAW).  */\n+  output_dd = 'o',\n+\n+  /* Read After Read (RAR).  */\n+  input_dd = 'i'\n+};\n+\n+/* Dependence information attached to an edge of the RDG.  */\n+\n+typedef struct rdg_edge\n+{\n+  /* Type of the dependence.  */\n+  enum rdg_dep_type type;\n+\n+  /* Levels of the dependence: the depth of the loops that carry the\n+     dependence.  */\n+  unsigned level;\n+\n+  /* Dependence relation between data dependences, NULL when one of\n+     the vertices is a scalar.  */\n+  ddr_p relation;\n+} *rdg_edge_p;\n+\n+#define RDGE_TYPE(E)        ((struct rdg_edge *) ((E)->data))->type\n+#define RDGE_LEVEL(E)       ((struct rdg_edge *) ((E)->data))->level\n+#define RDGE_RELATION(E)    ((struct rdg_edge *) ((E)->data))->relation\n+\n+/* Strongly connected components of the reduced data dependence graph.  */\n+\n+typedef struct rdg_component\n+{\n+  int num;\n+  vec<int> vertices;\n+} *rdgc;\n+\n+/* Dump vertex I in RDG to FILE.  */\n+\n+static void\n+dump_rdg_vertex (FILE *file, struct graph *rdg, int i)\n+{\n+  struct vertex *v = &(rdg->vertices[i]);\n+  struct graph_edge *e;\n+\n+  fprintf (file, \"(vertex %d: (%s%s) (in:\", i,\n+\t   RDG_MEM_WRITE_STMT (rdg, i) ? \"w\" : \"\",\n+\t   RDG_MEM_READS_STMT (rdg, i) ? \"r\" : \"\");\n+\n+  if (v->pred)\n+    for (e = v->pred; e; e = e->pred_next)\n+      fprintf (file, \" %d\", e->src);\n+\n+  fprintf (file, \") (out:\");\n+\n+  if (v->succ)\n+    for (e = v->succ; e; e = e->succ_next)\n+      fprintf (file, \" %d\", e->dest);\n+\n+  fprintf (file, \")\\n\");\n+  print_gimple_stmt (file, RDGV_STMT (v), 0, TDF_VOPS|TDF_MEMSYMS);\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Call dump_rdg_vertex on stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_rdg_vertex (struct graph *rdg, int i)\n+{\n+  dump_rdg_vertex (stderr, rdg, i);\n+}\n+\n+/* Dump component C of RDG to FILE.  If DUMPED is non-null, set the\n+   dumped vertices to that bitmap.  */\n+\n+static void\n+dump_rdg_component (FILE *file, struct graph *rdg, int c, bitmap dumped)\n+{\n+  int i;\n+\n+  fprintf (file, \"(%d\\n\", c);\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    if (rdg->vertices[i].component == c)\n+      {\n+\tif (dumped)\n+\t  bitmap_set_bit (dumped, i);\n+\n+\tdump_rdg_vertex (file, rdg, i);\n+      }\n+\n+  fprintf (file, \")\\n\");\n+}\n+\n+/* Call dump_rdg_vertex on stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_rdg_component (struct graph *rdg, int c)\n+{\n+  dump_rdg_component (stderr, rdg, c, NULL);\n+}\n+\n+/* Dump the reduced dependence graph RDG to FILE.  */\n+\n+static void\n+dump_rdg (FILE *file, struct graph *rdg)\n+{\n+  int i;\n+  bitmap dumped = BITMAP_ALLOC (NULL);\n+\n+  fprintf (file, \"(rdg\\n\");\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    if (!bitmap_bit_p (dumped, i))\n+      dump_rdg_component (file, rdg, rdg->vertices[i].component, dumped);\n+\n+  fprintf (file, \")\\n\");\n+  BITMAP_FREE (dumped);\n+}\n+\n+/* Call dump_rdg on stderr.  */\n+\n+DEBUG_FUNCTION void\n+debug_rdg (struct graph *rdg)\n+{\n+  dump_rdg (stderr, rdg);\n+}\n+\n+static void\n+dot_rdg_1 (FILE *file, struct graph *rdg)\n+{\n+  int i;\n+\n+  fprintf (file, \"digraph RDG {\\n\");\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    {\n+      struct vertex *v = &(rdg->vertices[i]);\n+      struct graph_edge *e;\n+\n+      /* Highlight reads from memory.  */\n+      if (RDG_MEM_READS_STMT (rdg, i))\n+       fprintf (file, \"%d [style=filled, fillcolor=green]\\n\", i);\n+\n+      /* Highlight stores to memory.  */\n+      if (RDG_MEM_WRITE_STMT (rdg, i))\n+       fprintf (file, \"%d [style=filled, fillcolor=red]\\n\", i);\n+\n+      if (v->succ)\n+       for (e = v->succ; e; e = e->succ_next)\n+         switch (RDGE_TYPE (e))\n+           {\n+           case input_dd:\n+             fprintf (file, \"%d -> %d [label=input] \\n\", i, e->dest);\n+             break;\n+\n+           case output_dd:\n+             fprintf (file, \"%d -> %d [label=output] \\n\", i, e->dest);\n+             break;\n+\n+           case flow_dd:\n+             /* These are the most common dependences: don't print these. */\n+             fprintf (file, \"%d -> %d \\n\", i, e->dest);\n+             break;\n+\n+           case anti_dd:\n+             fprintf (file, \"%d -> %d [label=anti] \\n\", i, e->dest);\n+             break;\n+\n+           default:\n+             gcc_unreachable ();\n+           }\n+    }\n+\n+  fprintf (file, \"}\\n\\n\");\n+}\n+\n+/* Display the Reduced Dependence Graph using dotty.  */\n+\n+DEBUG_FUNCTION void\n+dot_rdg (struct graph *rdg)\n+{\n+  /* When debugging, enable the following code.  This cannot be used\n+     in production compilers because it calls \"system\".  */\n+#if 0\n+  FILE *file = fopen (\"/tmp/rdg.dot\", \"w\");\n+  gcc_assert (file != NULL);\n+\n+  dot_rdg_1 (file, rdg);\n+  fclose (file);\n+\n+  system (\"dotty /tmp/rdg.dot &\");\n+#else\n+  dot_rdg_1 (stderr, rdg);\n+#endif\n+}\n+\n+/* Returns the index of STMT in RDG.  */\n+\n+static int\n+rdg_vertex_for_stmt (struct graph *rdg ATTRIBUTE_UNUSED, gimple stmt)\n+{\n+  int index = gimple_uid (stmt);\n+  gcc_checking_assert (index == -1 || RDG_STMT (rdg, index) == stmt);\n+  return index;\n+}\n+\n+/* Creates an edge in RDG for each distance vector from DDR.  The\n+   order that we keep track of in the RDG is the order in which\n+   statements have to be executed.  */\n+\n+static void\n+create_rdg_edge_for_ddr (struct graph *rdg, ddr_p ddr)\n+{\n+  struct graph_edge *e;\n+  int va, vb;\n+  data_reference_p dra = DDR_A (ddr);\n+  data_reference_p drb = DDR_B (ddr);\n+  unsigned level = ddr_dependence_level (ddr);\n+\n+  /* For non scalar dependences, when the dependence is REVERSED,\n+     statement B has to be executed before statement A.  */\n+  if (level > 0\n+      && !DDR_REVERSED_P (ddr))\n+    {\n+      data_reference_p tmp = dra;\n+      dra = drb;\n+      drb = tmp;\n+    }\n+\n+  va = rdg_vertex_for_stmt (rdg, DR_STMT (dra));\n+  vb = rdg_vertex_for_stmt (rdg, DR_STMT (drb));\n+\n+  if (va < 0 || vb < 0)\n+    return;\n+\n+  e = add_edge (rdg, va, vb);\n+  e->data = XNEW (struct rdg_edge);\n+\n+  RDGE_LEVEL (e) = level;\n+  RDGE_RELATION (e) = ddr;\n+\n+  /* Determines the type of the data dependence.  */\n+  if (DR_IS_READ (dra) && DR_IS_READ (drb))\n+    RDGE_TYPE (e) = input_dd;\n+  else if (DR_IS_WRITE (dra) && DR_IS_WRITE (drb))\n+    RDGE_TYPE (e) = output_dd;\n+  else if (DR_IS_WRITE (dra) && DR_IS_READ (drb))\n+    RDGE_TYPE (e) = flow_dd;\n+  else if (DR_IS_READ (dra) && DR_IS_WRITE (drb))\n+    RDGE_TYPE (e) = anti_dd;\n+}\n+\n+/* Creates dependence edges in RDG for all the uses of DEF.  IDEF is\n+   the index of DEF in RDG.  */\n+\n+static void\n+create_rdg_edges_for_scalar (struct graph *rdg, tree def, int idef)\n+{\n+  use_operand_p imm_use_p;\n+  imm_use_iterator iterator;\n+\n+  FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, def)\n+    {\n+      struct graph_edge *e;\n+      int use = rdg_vertex_for_stmt (rdg, USE_STMT (imm_use_p));\n+\n+      if (use < 0)\n+\tcontinue;\n+\n+      e = add_edge (rdg, idef, use);\n+      e->data = XNEW (struct rdg_edge);\n+      RDGE_TYPE (e) = flow_dd;\n+      RDGE_RELATION (e) = NULL;\n+    }\n+}\n+\n+/* Creates the edges of the reduced dependence graph RDG.  */\n+\n+static void\n+create_rdg_edges (struct graph *rdg, vec<ddr_p> ddrs)\n+{\n+  int i;\n+  struct data_dependence_relation *ddr;\n+  def_operand_p def_p;\n+  ssa_op_iter iter;\n+\n+  FOR_EACH_VEC_ELT (ddrs, i, ddr)\n+    if (DDR_ARE_DEPENDENT (ddr) == NULL_TREE)\n+      create_rdg_edge_for_ddr (rdg, ddr);\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    FOR_EACH_PHI_OR_STMT_DEF (def_p, RDG_STMT (rdg, i),\n+\t\t\t      iter, SSA_OP_DEF)\n+      create_rdg_edges_for_scalar (rdg, DEF_FROM_PTR (def_p), i);\n+}\n+\n+/* Build the vertices of the reduced dependence graph RDG.  Return false\n+   if that failed.  */\n+\n+static bool\n+create_rdg_vertices (struct graph *rdg, vec<gimple> stmts, loop_p loop,\n+\t\t     vec<data_reference_p> *datarefs)\n+{\n+  int i;\n+  gimple stmt;\n+\n+  FOR_EACH_VEC_ELT (stmts, i, stmt)\n+    {\n+      struct vertex *v = &(rdg->vertices[i]);\n+\n+      /* Record statement to vertex mapping.  */\n+      gimple_set_uid (stmt, i);\n+\n+      v->data = XNEW (struct rdg_vertex);\n+      RDGV_STMT (v) = stmt;\n+      RDGV_DATAREFS (v).create (0);\n+      RDGV_HAS_MEM_WRITE (v) = false;\n+      RDGV_HAS_MEM_READS (v) = false;\n+      if (gimple_code (stmt) == GIMPLE_PHI)\n+\tcontinue;\n+\n+      unsigned drp = datarefs->length ();\n+      if (!find_data_references_in_stmt (loop, stmt, datarefs))\n+\treturn false;\n+      for (unsigned j = drp; j < datarefs->length (); ++j)\n+\t{\n+\t  data_reference_p dr = (*datarefs)[j];\n+\t  if (DR_IS_READ (dr))\n+\t    RDGV_HAS_MEM_READS (v) = true;\n+\t  else\n+\t    RDGV_HAS_MEM_WRITE (v) = true;\n+\t  RDGV_DATAREFS (v).safe_push (dr);\n+\t}\n+    }\n+  return true;\n+}\n+\n+/* Initialize STMTS with all the statements of LOOP.  When\n+   INCLUDE_PHIS is true, include also the PHI nodes.  The order in\n+   which we discover statements is important as\n+   generate_loops_for_partition is using the same traversal for\n+   identifying statements. */\n+\n+static void\n+stmts_from_loop (struct loop *loop, vec<gimple> *stmts)\n+{\n+  unsigned int i;\n+  basic_block *bbs = get_loop_body_in_dom_order (loop);\n+\n+  for (i = 0; i < loop->num_nodes; i++)\n+    {\n+      basic_block bb = bbs[i];\n+      gimple_stmt_iterator bsi;\n+      gimple stmt;\n+\n+      for (bsi = gsi_start_phis (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\tstmts->safe_push (gsi_stmt (bsi));\n+\n+      for (bsi = gsi_start_bb (bb); !gsi_end_p (bsi); gsi_next (&bsi))\n+\t{\n+\t  stmt = gsi_stmt (bsi);\n+\t  if (gimple_code (stmt) != GIMPLE_LABEL && !is_gimple_debug (stmt))\n+\t    stmts->safe_push (stmt);\n+\t}\n+    }\n+\n+  free (bbs);\n+}\n+\n+/* Returns true when all the dependences are computable.  */\n+\n+static bool\n+known_dependences_p (vec<ddr_p> dependence_relations)\n+{\n+  ddr_p ddr;\n+  unsigned int i;\n+\n+  FOR_EACH_VEC_ELT (dependence_relations, i, ddr)\n+    if (DDR_ARE_DEPENDENT (ddr) == chrec_dont_know)\n+      return false;\n+\n+  return true;\n+}\n+\n+/* Build the Reduced Dependence Graph (RDG) with one vertex per\n+   statement of the loop nest, and one edge per data dependence or\n+   scalar dependence.  */\n+\n+struct graph *\n+build_empty_rdg (int n_stmts)\n+{\n+  struct graph *rdg = new_graph (n_stmts);\n+  return rdg;\n+}\n+\n+/* Free the reduced dependence graph RDG.  */\n+\n+static void\n+free_rdg (struct graph *rdg)\n+{\n+  int i;\n+\n+  for (i = 0; i < rdg->n_vertices; i++)\n+    {\n+      struct vertex *v = &(rdg->vertices[i]);\n+      struct graph_edge *e;\n+\n+      for (e = v->succ; e; e = e->succ_next)\n+\t{\n+\t  free_dependence_relation (RDGE_RELATION (e));\n+\t  free (e->data);\n+\t}\n+\n+      if (v->data)\n+\t{\n+\t  gimple_set_uid (RDGV_STMT (v), -1);\n+\t  free_data_refs (RDGV_DATAREFS (v));\n+\t  free (v->data);\n+\t}\n+    }\n+\n+  free_graph (rdg);\n+}\n+\n+/* Build the Reduced Dependence Graph (RDG) with one vertex per\n+   statement of the loop nest, and one edge per data dependence or\n+   scalar dependence.  */\n+\n+static struct graph *\n+build_rdg (struct loop *loop)\n+{\n+  struct graph *rdg;\n+  vec<loop_p> loop_nest;\n+  vec<gimple> stmts;\n+  vec<data_reference_p> datarefs;\n+  vec<ddr_p> dependence_relations;\n+\n+  loop_nest.create (3);\n+  if (!find_loop_nest (loop, &loop_nest))\n+    {\n+      loop_nest.release ();\n+      return NULL;\n+    }\n+\n+  stmts.create (10);\n+  stmts_from_loop (loop, &stmts);\n+  rdg = build_empty_rdg (stmts.length ());\n+  datarefs.create (10);\n+  if (!create_rdg_vertices (rdg, stmts, loop, &datarefs))\n+    {\n+      stmts.release ();\n+      free_rdg (rdg);\n+      return NULL;\n+    }\n+  stmts.release ();\n+  dependence_relations.create (100);\n+  if (!compute_all_dependences (datarefs, &dependence_relations, loop_nest,\n+\t\t\t\tfalse)\n+      || !known_dependences_p (dependence_relations))\n+    {\n+      loop_nest.release ();\n+      datarefs.release ();\n+      dependence_relations.release ();\n+      free_rdg (rdg);\n+      return NULL;\n+    }\n+  loop_nest.release ();\n+  create_rdg_edges (rdg, dependence_relations);\n+  dependence_relations.release ();\n+\n+  return rdg;\n+}\n+\n+/* Determines whether the statement from vertex V of the RDG has a\n+   definition used outside the loop that contains this statement.  */\n+\n+static bool\n+rdg_defs_used_in_other_loops_p (struct graph *rdg, int v)\n+{\n+  gimple stmt = RDG_STMT (rdg, v);\n+  struct loop *loop = loop_containing_stmt (stmt);\n+  use_operand_p imm_use_p;\n+  imm_use_iterator iterator;\n+  ssa_op_iter it;\n+  def_operand_p def_p;\n+\n+  if (!loop)\n+    return true;\n+\n+  FOR_EACH_PHI_OR_STMT_DEF (def_p, stmt, it, SSA_OP_DEF)\n+    {\n+      FOR_EACH_IMM_USE_FAST (imm_use_p, iterator, DEF_FROM_PTR (def_p))\n+\t{\n+\t  if (loop_containing_stmt (USE_STMT (imm_use_p)) != loop)\n+\t    return true;\n+\t}\n+    }\n+\n+  return false;\n+}\n+\n+\n \n enum partition_kind {\n     PKIND_NORMAL, PKIND_REDUCTION, PKIND_MEMSET, PKIND_MEMCPY\n@@ -58,6 +597,7 @@ enum partition_kind {\n typedef struct partition_s\n {\n   bitmap stmts;\n+  bitmap loops;\n   bool has_writes;\n   enum partition_kind kind;\n   /* data-references a kind != PKIND_NORMAL partition is about.  */\n@@ -69,10 +609,11 @@ typedef struct partition_s\n /* Allocate and initialize a partition from BITMAP.  */\n \n static partition_t\n-partition_alloc (bitmap stmts)\n+partition_alloc (bitmap stmts, bitmap loops)\n {\n   partition_t partition = XCNEW (struct partition_s);\n   partition->stmts = stmts ? stmts : BITMAP_ALLOC (NULL);\n+  partition->loops = loops ? loops : BITMAP_ALLOC (NULL);\n   partition->has_writes = false;\n   partition->kind = PKIND_NORMAL;\n   return partition;\n@@ -84,6 +625,7 @@ static void\n partition_free (partition_t partition)\n {\n   BITMAP_FREE (partition->stmts);\n+  BITMAP_FREE (partition->loops);\n   free (partition);\n }\n \n@@ -626,13 +1168,13 @@ has_upstream_mem_writes (int u)\n }\n \n static void rdg_flag_vertex_and_dependent (struct graph *, int, partition_t,\n-\t\t\t\t\t   bitmap, bitmap);\n+\t\t\t\t\t   bitmap);\n \n /* Flag the uses of U stopping following the information from\n    upstream_mem_writes.  */\n \n static void\n-rdg_flag_uses (struct graph *rdg, int u, partition_t partition, bitmap loops,\n+rdg_flag_uses (struct graph *rdg, int u, partition_t partition,\n \t       bitmap processed)\n {\n   struct vertex *x = &(rdg->vertices[u]);\n@@ -647,8 +1189,7 @@ rdg_flag_uses (struct graph *rdg, int u, partition_t partition, bitmap loops,\n       int v = anti_dep->dest;\n \n       if (!already_processed_vertex_p (processed, v))\n-\trdg_flag_vertex_and_dependent (rdg, v, partition, loops,\n-\t\t\t\t       processed);\n+\trdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n     }\n \n   if (is_gimple_assign (stmt) && has_upstream_mem_writes (u))\n@@ -667,8 +1208,7 @@ rdg_flag_uses (struct graph *rdg, int u, partition_t partition, bitmap loops,\n \t      int v = rdg_vertex_for_stmt (rdg, USE_STMT (use_p));\n \n \t      if (!already_processed_vertex_p (processed, v))\n-\t\trdg_flag_vertex_and_dependent (rdg, v, partition, loops,\n-\t\t\t\t\t       processed);\n+\t\trdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n \t    }\n \t}\n     }\n@@ -678,15 +1218,15 @@ rdg_flag_uses (struct graph *rdg, int u, partition_t partition, bitmap loops,\n    in LOOPS.  */\n \n static void\n-rdg_flag_vertex (struct graph *rdg, int v, partition_t partition, bitmap loops)\n+rdg_flag_vertex (struct graph *rdg, int v, partition_t partition)\n {\n   struct loop *loop;\n \n   if (!bitmap_set_bit (partition->stmts, v))\n     return;\n \n   loop = loop_containing_stmt (RDG_STMT (rdg, v));\n-  bitmap_set_bit (loops, loop->num);\n+  bitmap_set_bit (partition->loops, loop->num);\n \n   if (rdg_cannot_recompute_vertex_p (rdg, v))\n     {\n@@ -700,21 +1240,21 @@ rdg_flag_vertex (struct graph *rdg, int v, partition_t partition, bitmap loops)\n \n static void\n rdg_flag_vertex_and_dependent (struct graph *rdg, int v, partition_t partition,\n-\t\t\t       bitmap loops, bitmap processed)\n+\t\t\t       bitmap processed)\n {\n   unsigned i;\n   vec<int> nodes;\n   nodes.create (3);\n   int x;\n \n   bitmap_set_bit (processed, v);\n-  rdg_flag_uses (rdg, v, partition, loops, processed);\n+  rdg_flag_uses (rdg, v, partition, processed);\n   graphds_dfs (rdg, &v, 1, &nodes, false, remaining_stmts);\n-  rdg_flag_vertex (rdg, v, partition, loops);\n+  rdg_flag_vertex (rdg, v, partition);\n \n   FOR_EACH_VEC_ELT (nodes, i, x)\n     if (!already_processed_vertex_p (processed, x))\n-      rdg_flag_vertex_and_dependent (rdg, x, partition, loops, processed);\n+      rdg_flag_vertex_and_dependent (rdg, x, partition, processed);\n \n   nodes.release ();\n }\n@@ -745,31 +1285,31 @@ collect_condition_stmts (struct loop *loop, vec<gimple> *conds)\n    RDG.  */\n \n static void\n-rdg_flag_loop_exits (struct graph *rdg, bitmap loops, partition_t partition,\n+rdg_flag_loop_exits (struct graph *rdg, partition_t partition,\n \t\t     bitmap processed)\n {\n   unsigned i;\n   bitmap_iterator bi;\n   vec<gimple> conds;\n   conds.create (3);\n \n-  EXECUTE_IF_SET_IN_BITMAP (loops, 0, i, bi)\n+  EXECUTE_IF_SET_IN_BITMAP (partition->loops, 0, i, bi)\n     collect_condition_stmts (get_loop (cfun, i), &conds);\n \n   while (!conds.is_empty ())\n     {\n       gimple cond = conds.pop ();\n       int v = rdg_vertex_for_stmt (rdg, cond);\n-      bitmap new_loops = BITMAP_ALLOC (NULL);\n-\n       if (!already_processed_vertex_p (processed, v))\n-\trdg_flag_vertex_and_dependent (rdg, v, partition, new_loops, processed);\n-\n-      EXECUTE_IF_SET_IN_BITMAP (new_loops, 0, i, bi)\n-\tif (bitmap_set_bit (loops, i))\n-\t  collect_condition_stmts (get_loop (cfun, i), &conds);\n-\n-      BITMAP_FREE (new_loops);\n+\t{\n+\t  bitmap saved_loops = BITMAP_ALLOC (NULL);\n+\t  bitmap_copy (saved_loops, partition->loops);\n+\t  rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n+\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (partition->loops, saved_loops,\n+\t\t\t\t\t  0, i, bi)\n+\t    collect_condition_stmts (get_loop (cfun, i), &conds);\n+\t  BITMAP_FREE (saved_loops);\n+\t}\n     }\n \n   conds.release ();\n@@ -783,18 +1323,16 @@ static partition_t\n build_rdg_partition_for_component (struct graph *rdg, rdgc c)\n {\n   int i, v;\n-  partition_t partition = partition_alloc (NULL);\n-  bitmap loops = BITMAP_ALLOC (NULL);\n+  partition_t partition = partition_alloc (NULL, NULL);\n   bitmap processed = BITMAP_ALLOC (NULL);\n \n   FOR_EACH_VEC_ELT (c->vertices, i, v)\n     if (!already_processed_vertex_p (processed, v))\n-      rdg_flag_vertex_and_dependent (rdg, v, partition, loops, processed);\n+      rdg_flag_vertex_and_dependent (rdg, v, partition, processed);\n \n-  rdg_flag_loop_exits (rdg, loops, partition, processed);\n+  rdg_flag_loop_exits (rdg, partition, processed);\n \n   BITMAP_FREE (processed);\n-  BITMAP_FREE (loops);\n   return partition;\n }\n \n@@ -1080,7 +1618,7 @@ rdg_build_partitions (struct graph *rdg, vec<rdgc> components,\n {\n   int i;\n   rdgc x;\n-  partition_t partition = partition_alloc (NULL);\n+  partition_t partition = partition_alloc (NULL, NULL);\n \n   FOR_EACH_VEC_ELT (components, i, x)\n     {\n@@ -1105,7 +1643,7 @@ rdg_build_partitions (struct graph *rdg, vec<rdgc> components,\n \t    }\n \n \t  partitions->safe_push (partition);\n-\t  partition = partition_alloc (NULL);\n+\t  partition = partition_alloc (NULL, NULL);\n \t}\n     }\n "}]}