{"sha": "55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "node_id": "C_kwDOANBUbNoAKDU1ZDgzY2RmMjNiNWYyODRiNGUwYmQwYTZkMWFmM2Q5NDdiMmU3YzM", "commit": {"author": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-02-02T10:39:03Z"}, "committer": {"name": "Tamar Christina", "email": "tamar.christina@arm.com", "date": "2022-02-02T10:39:03Z"}, "message": "vect: Simplify and extend the complex numbers validation routines.\n\nThis patch boosts the analysis for complex mul,fma and fms in order to ensure\nthat it doesn't create an incorrect output.\n\nEssentially it adds an extra verification to check that the two nodes it's going\nto combine do the same operations on compatible values.  The reason it needs to\ndo this is that if one computation differs from the other then with the current\nimplementation we have no way to deal with it since we have to remove the\npermute.\n\nWhen we can keep the permute around we can probably handle these by unrolling.\n\nWhile implementing this since I have to do the traversal anyway I took advantage\nof it by simplifying the code a bit.  Previously we would determine whether\nsomething is a conjugate and then try to figure out which conjugate it is and\nthen try to see if the permutes match what we expect.\n\nNow the code that does the traversal will detect this in one go and return to us\nwhether the operation is something that can be combined and whether a conjugate\nis present.\n\nSecondly because it does this I can now simplify the checking code itself to\nessentially just try to apply fixed patterns to each operation.\n\nThe patterns represent the order operations should appear in. For instance a\ncomplex MUL operation combines :\n\n  Left 1 + Right 1\n  Left 2 + Right 2\n\nwith a permute on the nodes consisting of:\n\n  { Even, Even } + { Odd, Odd  }\n  { Even, Odd  } + { Odd, Even }\n\nBy abstracting over these patterns the checking code becomes quite simple.\n\nAs part of this I was checking the order of the operands which was left in\n\"slp\" order. as in, the same order they showed up in during SLP, which means\nthat the accumulator is first.  However it looks like I didn't document this\nand the x86 optab was implemented assuming the same order as FMA, i.e. that\nthe accumulator is last.\n\nI have this changed the order to match that of FMA and FMS which corrects the\nx86 codegen and will update the Arm targets.  This has now also been\ndocumented.\n\ngcc/ChangeLog:\n\n\tPR tree-optimization/102819\n\tPR tree-optimization/103169\n\t* doc/md.texi: Update docs for cfms, cfma.\n\t* tree-data-ref.h (same_data_refs): Accept optional offset.\n\t* tree-vect-slp-patterns.cc (is_linear_load_p): Fix issue with repeating\n\tpatterns.\n\t(vect_normalize_conj_loc): Remove.\n\t(is_eq_or_top): Change to take two nodes.\n\t(enum _conj_status, compatible_complex_nodes_p,\n\tvect_validate_multiplication): New.\n\t(class complex_add_pattern, complex_add_pattern::matches,\n\tcomplex_add_pattern::recognize, class complex_mul_pattern,\n\tcomplex_mul_pattern::recognize, class complex_fms_pattern,\n\tcomplex_fms_pattern::recognize, class complex_operations_pattern,\n\tcomplex_operations_pattern::recognize, addsub_pattern::recognize): Pass\n\tnew cache.\n\t(complex_fms_pattern::matches, complex_mul_pattern::matches): Pass new\n\tcache and use new validation code.\n\t* tree-vect-slp.cc (vect_match_slp_patterns_2, vect_match_slp_patterns,\n\tvect_analyze_slp): Pass along cache.\n\t(compatible_calls_p): Expose.\n\t* tree-vectorizer.h (compatible_calls_p, slp_node_hash,\n\tslp_compat_nodes_map_t): New.\n\t(class vect_pattern): Update signatures include new cache.\n\ngcc/testsuite/ChangeLog:\n\n\tPR tree-optimization/102819\n\tPR tree-optimization/103169\n\t* g++.dg/vect/pr99149.cc: xfail for now.\n\t* gcc.dg/vect/complex/pr102819-1.c: New test.\n\t* gcc.dg/vect/complex/pr102819-2.c: New test.\n\t* gcc.dg/vect/complex/pr102819-3.c: New test.\n\t* gcc.dg/vect/complex/pr102819-4.c: New test.\n\t* gcc.dg/vect/complex/pr102819-5.c: New test.\n\t* gcc.dg/vect/complex/pr102819-6.c: New test.\n\t* gcc.dg/vect/complex/pr102819-7.c: New test.\n\t* gcc.dg/vect/complex/pr102819-8.c: New test.\n\t* gcc.dg/vect/complex/pr102819-9.c: New test.\n\t* gcc.dg/vect/complex/pr103169.c: New test.", "tree": {"sha": "2062fe07adf965b3db5a4cc12b689c070b0a4e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2062fe07adf965b3db5a4cc12b689c070b0a4e99"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/comments", "author": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "TamarChristinaArm", "id": 48126768, "node_id": "MDQ6VXNlcjQ4MTI2NzY4", "avatar_url": "https://avatars.githubusercontent.com/u/48126768?v=4", "gravatar_id": "", "url": "https://api.github.com/users/TamarChristinaArm", "html_url": "https://github.com/TamarChristinaArm", "followers_url": "https://api.github.com/users/TamarChristinaArm/followers", "following_url": "https://api.github.com/users/TamarChristinaArm/following{/other_user}", "gists_url": "https://api.github.com/users/TamarChristinaArm/gists{/gist_id}", "starred_url": "https://api.github.com/users/TamarChristinaArm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/TamarChristinaArm/subscriptions", "organizations_url": "https://api.github.com/users/TamarChristinaArm/orgs", "repos_url": "https://api.github.com/users/TamarChristinaArm/repos", "events_url": "https://api.github.com/users/TamarChristinaArm/events{/privacy}", "received_events_url": "https://api.github.com/users/TamarChristinaArm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "756eabacfcd767e39eea63257a026f61a4c4e661", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/756eabacfcd767e39eea63257a026f61a4c4e661", "html_url": "https://github.com/Rust-GCC/gccrs/commit/756eabacfcd767e39eea63257a026f61a4c4e661"}], "stats": {"total": 667, "additions": 458, "deletions": 209}, "files": [{"sha": "f3619c505c025f158c2bc64756531877378b22e1", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 28, "deletions": 24, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -6360,12 +6360,13 @@ Perform a vector multiply and accumulate that is semantically the same as\n a multiply and accumulate of complex numbers.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n+  complex TYPE op3[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] += a[i] * b[i];\n+      op0[i] = op1[i] * op2[i] + op3[i];\n     @}\n @end smallexample\n \n@@ -6383,12 +6384,13 @@ the same as a multiply and accumulate of complex numbers where the second\n multiply arguments is conjugated.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n+  complex TYPE op3[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] += a[i] * conj (b[i]);\n+      op0[i] = op1[i] * conj (op2[i]) + op3[i];\n     @}\n @end smallexample\n \n@@ -6405,12 +6407,13 @@ Perform a vector multiply and subtract that is semantically the same as\n a multiply and subtract of complex numbers.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n+  complex TYPE op3[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] -= a[i] * b[i];\n+      op0[i] = op1[i] * op2[i] - op3[i];\n     @}\n @end smallexample\n \n@@ -6428,12 +6431,13 @@ the same as a multiply and subtract of complex numbers where the second\n multiply arguments is conjugated.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n+  complex TYPE op3[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] -= a[i] * conj (b[i]);\n+      op0[i] = op1[i] * conj (op2[i]) - op3[i];\n     @}\n @end smallexample\n \n@@ -6450,12 +6454,12 @@ Perform a vector multiply that is semantically the same as multiply of\n complex numbers.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] = a[i] * b[i];\n+      op0[i] = op1[i] * op2[i];\n     @}\n @end smallexample\n \n@@ -6472,12 +6476,12 @@ Perform a vector multiply by conjugate that is semantically the same as a\n multiply of complex numbers where the second multiply arguments is conjugated.\n \n @smallexample\n-  complex TYPE c[N];\n-  complex TYPE a[N];\n-  complex TYPE b[N];\n+  complex TYPE op0[N];\n+  complex TYPE op1[N];\n+  complex TYPE op2[N];\n   for (int i = 0; i < N; i += 1)\n     @{\n-      c[i] = a[i] * conj (b[i]);\n+      op0[i] = op1[i] * conj (op2[i]);\n     @}\n @end smallexample\n "}, {"sha": "bb9f5fa89f12b184368bf5488d6e9432c2166463", "filename": "gcc/testsuite/g++.dg/vect/pr99149.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fvect%2Fpr99149.cc?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -24,4 +24,4 @@ class mp {\n } n;\n main() { n.j(); }\n \n-/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_MUL\" 1 \"slp2\" } } */\n+/* { dg-final { scan-tree-dump-times \"stmt.*COMPLEX_MUL\" 1 \"slp2\" { xfail { vect_float } } } } */"}, {"sha": "46b9a55f05279d732fa1418e02f779cf693ede07", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-1.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void bad1(float v1, float v2)\n+{\n+  for (int r = 0; r < 100; r += 4)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * (f[2][r] + v2) - f[1][i] * (f[2][i] + v1);\n+      f[0][i] = f[1][r] * (f[2][i] + v1) + f[1][i] * (f[2][r] + v2);\n+      f[0][r+2] = f[1][r+2] * (f[2][r+2] + v2) - f[1][i+2] * (f[2][i+2] + v1);\n+      f[0][i+2] = f[1][r+2] * (f[2][i+2] + v1) + f[1][i+2] * (f[2][r+2] + v2);\n+      //                  ^^^^^^^             ^^^^^^^\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "ffe646efe57f7ad07541b0fb96601596f46dc5f8", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-2.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-2.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void bad1(float v1, float v2)\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * (f[2][r] + v1) - f[1][i] * (f[2][i] + v2);\n+      f[0][i] = f[1][r] * (f[2][i] + v1) + f[1][i] * (f[2][r] + v2);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "5f98aa204d8b11b0cb433f8965dbb72cf8940de1", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-3.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-3.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void good1(float v1, float v2)\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * (f[2][r] + v2) - f[1][i] * (f[2][i] + v1);\n+      f[0][i] = f[1][r] * (f[2][i] + v1) + f[1][i] * (f[2][r] + v2);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "882851789c5085e734000609114be480d3b08bd0", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-4.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-4.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void good1()\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * f[2][r] - f[1][i] * f[2][i];\n+      f[0][i] = f[1][r] * f[2][i] + f[1][i] * f[2][r];\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "6a2d549d65f3f27d407fb0bd469473e6a5c333ae", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-5.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-5.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void good2()\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * (f[2][r] + 1) - f[1][i] * (f[2][i] + 1);\n+      f[0][i] = f[1][r] * (f[2][i] + 1) + f[1][i] * (f[2][r] + 1);\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "71e66dbe3b29eec1fffb8df9b216022fdc0af54e", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-6.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-6.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void bad1()\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * f[2][r] - f[1][i] * f[3][i];\n+      f[0][i] = f[1][r] * f[2][i] + f[1][i] * f[3][r];\n+      //                  ^^^^^^^             ^^^^^^^\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "536672f3c8bb474ad5fa4bb61b3a36b555acf3cf", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-7.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-7.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void bad2()\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * (f[2][r] + 1) - f[1][i] * f[2][i];\n+      f[0][i] = f[1][r] * (f[2][i] + 1) + f[1][i] * f[2][r];\n+      //                          ^^^^\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "07b48148688b7d530e5891d023d558b58a485c23", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-8.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-8.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+float f[12][100];\n+\n+void bad3()\n+{\n+  for (int r = 0; r < 100; r += 2)\n+    {\n+      int i = r + 1;\n+      f[0][r] = f[1][r] * f[2][r] - f[1][r] * f[2][i];\n+      f[0][i] = f[1][r] * f[2][i] + f[1][i] * f[2][r];\n+      //                            ^^^^^^^\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"Found COMPLEX_MUL\" \"vect\" { target { vect_float } } } } */\n+"}, {"sha": "7655852434b21b381fe7ee316e8caf3d485b8ee1", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr102819-9.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr102819-9.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+\n+#include <stdio.h>\n+#include <complex.h>\n+\n+#define N 200\n+#define TYPE float\n+#define TYPE2 float\n+\n+void g (TYPE2 complex a[restrict N], TYPE complex b[restrict N], TYPE complex c[restrict N])\n+{\n+  for (int i=0; i < N; i++)\n+    {\n+      c[i] -=  a[i] * b[0];\n+    }\n+}\n+\n+/* The pattern overlaps with COMPLEX_ADD so we need to support consuming ADDs in COMPLEX_FMS.  */\n+\n+/* { dg-final { scan-tree-dump \"Found COMPLEX_FMS\" \"vect\" { xfail { vect_float } } } } */"}, {"sha": "1bfabbd85a0eedfb4156a82574324126e9083fc5", "filename": "gcc/testsuite/gcc.dg/vect/complex/pr103169.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr103169.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr103169.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fcomplex%2Fpr103169.c?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile { target { vect_double } } } */\n+/* { dg-add-options arm_v8_3a_complex_neon } */\n+/* { dg-additional-options \"-O2 -fvect-cost-model=unlimited\" } */\n+\n+_Complex double b_0, c_0;\n+\n+void\n+mul270snd (void)\n+{\n+  c_0 = b_0 * 1.0iF * 1.0iF;\n+}\n+"}, {"sha": "f643a95b29b53f76c9fd56844bc5b4265b7bb821", "filename": "gcc/tree-data-ref.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-data-ref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-data-ref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.h?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -600,10 +600,11 @@ same_data_refs_base_objects (data_reference_p a, data_reference_p b)\n }\n \n /* Return true when the data references A and B are accessing the same\n-   memory object with the same access functions.  */\n+   memory object with the same access functions.  Optionally skip the\n+   last OFFSET dimensions in the data reference.  */\n \n static inline bool\n-same_data_refs (data_reference_p a, data_reference_p b)\n+same_data_refs (data_reference_p a, data_reference_p b, int offset = 0)\n {\n   unsigned int i;\n \n@@ -614,7 +615,7 @@ same_data_refs (data_reference_p a, data_reference_p b)\n   if (!same_data_refs_base_objects (a, b))\n     return false;\n \n-  for (i = 0; i < DR_NUM_DIMENSIONS (a); i++)\n+  for (i = offset; i < DR_NUM_DIMENSIONS (a); i++)\n     if (!eq_evolutions_p (DR_ACCESS_FN (a, i), DR_ACCESS_FN (b, i)))\n       return false;\n "}, {"sha": "879d17fd947c47a75f480846f97ea631dc55f123", "filename": "gcc/tree-vect-slp-patterns.cc", "status": "modified", "additions": 227, "deletions": 174, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vect-slp-patterns.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vect-slp-patterns.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp-patterns.cc?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -149,12 +149,13 @@ is_linear_load_p (load_permutation_t loads)\n   int valid_patterns = 4;\n   FOR_EACH_VEC_ELT (loads, i, load)\n     {\n-      if (candidates[0] != PERM_UNKNOWN && load != 1)\n+      unsigned adj_load = load % 2;\n+      if (candidates[0] != PERM_UNKNOWN && adj_load != 1)\n \t{\n \t  candidates[0] = PERM_UNKNOWN;\n \t  valid_patterns--;\n \t}\n-      if (candidates[1] != PERM_UNKNOWN && load != 0)\n+      if (candidates[1] != PERM_UNKNOWN && adj_load != 0)\n \t{\n \t  candidates[1] = PERM_UNKNOWN;\n \t  valid_patterns--;\n@@ -596,11 +597,12 @@ class complex_add_pattern : public complex_pattern\n   public:\n     void build (vec_info *);\n     static internal_fn\n-    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n-\t     vec<slp_tree> *);\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     slp_compat_nodes_map_t *, slp_tree *, vec<slp_tree> *);\n \n     static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    recognize (slp_tree_to_load_perm_map_t *, slp_compat_nodes_map_t *,\n+\t       slp_tree *);\n \n     static vect_pattern*\n     mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n@@ -647,6 +649,7 @@ complex_add_pattern::build (vec_info *vinfo)\n internal_fn\n complex_add_pattern::matches (complex_operation_t op,\n \t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      slp_compat_nodes_map_t * /* compat_cache */,\n \t\t\t      slp_tree *node, vec<slp_tree> *ops)\n {\n   internal_fn ifn = IFN_LAST;\n@@ -692,13 +695,14 @@ complex_add_pattern::matches (complex_operation_t op,\n \n vect_pattern*\n complex_add_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_compat_nodes_map_t *compat_cache,\n \t\t\t\tslp_tree *node)\n {\n   auto_vec<slp_tree> ops;\n   complex_operation_t op\n     = vect_detect_pair_op (*node, true, &ops);\n   internal_fn ifn\n-    = complex_add_pattern::matches (op, perm_cache, node, &ops);\n+    = complex_add_pattern::matches (op, perm_cache, compat_cache, node, &ops);\n   if (ifn == IFN_LAST)\n     return NULL;\n \n@@ -709,147 +713,214 @@ complex_add_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n  * complex_mul_pattern\n  ******************************************************************************/\n \n-/* Check to see if either of the trees in ARGS are a NEGATE_EXPR.  If the first\n-   child (args[0]) is a NEGATE_EXPR then NEG_FIRST_P is set to TRUE.\n-\n-   If a negate is found then the values in ARGS are reordered such that the\n-   negate node is always the second one and the entry is replaced by the child\n-   of the negate node.  */\n+/* Helper function to check if PERM is KIND or PERM_TOP.  */\n \n static inline bool\n-vect_normalize_conj_loc (vec<slp_tree> &args, bool *neg_first_p = NULL)\n+is_eq_or_top (slp_tree_to_load_perm_map_t *perm_cache,\n+\t      slp_tree op1, complex_perm_kinds_t kind1,\n+\t      slp_tree op2, complex_perm_kinds_t kind2)\n {\n-  gcc_assert (args.length () == 2);\n-  bool neg_found = false;\n-\n-  if (vect_match_expression_p (args[0], NEGATE_EXPR))\n-    {\n-      std::swap (args[0], args[1]);\n-      neg_found = true;\n-      if (neg_first_p)\n-\t*neg_first_p = true;\n-    }\n-  else if (vect_match_expression_p (args[1], NEGATE_EXPR))\n-    {\n-      neg_found = true;\n-      if (neg_first_p)\n-\t*neg_first_p = false;\n-    }\n+  complex_perm_kinds_t perm1 = linear_loads_p (perm_cache, op1);\n+  if (perm1 != kind1 && perm1 != PERM_TOP)\n+    return false;\n \n-  if (neg_found)\n-    args[1] = SLP_TREE_CHILDREN (args[1])[0];\n+  complex_perm_kinds_t perm2 = linear_loads_p (perm_cache, op2);\n+  if (perm2 != kind2 && perm2 != PERM_TOP)\n+    return false;\n \n-  return neg_found;\n+  return true;\n }\n \n-/* Helper function to check if PERM is KIND or PERM_TOP.  */\n+enum _conj_status { CONJ_NONE, CONJ_FST, CONJ_SND };\n \n static inline bool\n-is_eq_or_top (complex_perm_kinds_t perm, complex_perm_kinds_t kind)\n+compatible_complex_nodes_p (slp_compat_nodes_map_t *compat_cache,\n+\t\t\t    slp_tree a, int *pa, slp_tree b, int *pb)\n {\n-  return perm == kind || perm == PERM_TOP;\n-}\n+  bool *tmp;\n+  std::pair<slp_tree, slp_tree> key = std::make_pair(a, b);\n+  if ((tmp = compat_cache->get (key)) != NULL)\n+    return *tmp;\n \n-/* Helper function that checks to see if LEFT_OP and RIGHT_OP are both MULT_EXPR\n-   nodes but also that they represent an operation that is either a complex\n-   multiplication or a complex multiplication by conjugated value.\n+   compat_cache->put (key, false);\n \n-   Of the negation is expected to be in the first half of the tree (As required\n-   by an FMS pattern) then NEG_FIRST is true.  If the operation is a conjugate\n-   operation then CONJ_FIRST_OPERAND is set to indicate whether the first or\n-   second operand contains the conjugate operation.  */\n+  if (SLP_TREE_CHILDREN (a).length () != SLP_TREE_CHILDREN (b).length ())\n+    return false;\n \n-static inline bool\n-vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n-\t\t\t      const vec<slp_tree> &left_op,\n-\t\t\t      const vec<slp_tree> &right_op,\n-\t\t\t     bool neg_first, bool *conj_first_operand,\n-\t\t\t     bool fms)\n-{\n-  /* The presence of a negation indicates that we have either a conjugate or a\n-     rotation.  We need to distinguish which one.  */\n-  *conj_first_operand = false;\n-  complex_perm_kinds_t kind;\n-\n-  /* Complex conjugates have the negation on the imaginary part of the\n-     number where rotations affect the real component.  So check if the\n-     negation is on a dup of lane 1.  */\n-  if (fms)\n+  if (SLP_TREE_DEF_TYPE (a) != SLP_TREE_DEF_TYPE (b))\n+    return false;\n+\n+  /* Only internal nodes can be loads, as such we can't check further if they\n+     are externals.  */\n+  if (SLP_TREE_DEF_TYPE (a) != vect_internal_def)\n     {\n-      /* Canonicalization for fms is not consistent. So have to test both\n-\t variants to be sure.  This needs to be fixed in the mid-end so\n-\t this part can be simpler.  */\n-      kind = linear_loads_p (perm_cache, right_op[0]);\n-      if (!((is_eq_or_top (linear_loads_p (perm_cache, right_op[0]), PERM_ODDODD)\n-\t   && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n-\t\t\t     PERM_ODDEVEN))\n-\t  || (kind == PERM_ODDEVEN\n-\t      && is_eq_or_top (linear_loads_p (perm_cache, right_op[1]),\n-\t\t\t     PERM_ODDODD))))\n-\treturn false;\n+      for (unsigned i = 0; i < SLP_TREE_SCALAR_OPS (a).length (); i++)\n+\t{\n+\t  tree op1 = SLP_TREE_SCALAR_OPS (a)[pa[i % 2]];\n+\t  tree op2 = SLP_TREE_SCALAR_OPS (b)[pb[i % 2]];\n+\t  if (!operand_equal_p (op1, op2, 0))\n+\t    return false;\n+\t}\n+\n+      compat_cache->put (key, true);\n+      return true;\n     }\n+\n+  auto a_stmt = STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (a));\n+  auto b_stmt = STMT_VINFO_STMT (SLP_TREE_REPRESENTATIVE (b));\n+\n+  if (gimple_code (a_stmt) != gimple_code (b_stmt))\n+    return false;\n+\n+  /* code, children, type, externals, loads, constants  */\n+  if (gimple_num_args (a_stmt) != gimple_num_args (b_stmt))\n+    return false;\n+\n+  /* At this point, a and b are known to be the same gimple operations.  */\n+  if (is_gimple_call (a_stmt))\n+    {\n+\tif (!compatible_calls_p (dyn_cast <gcall *> (a_stmt),\n+\t\t\t\t dyn_cast <gcall *> (b_stmt)))\n+\t  return false;\n+    }\n+  else if (!is_gimple_assign (a_stmt))\n+    return false;\n   else\n     {\n-      if (linear_loads_p (perm_cache, right_op[1]) != PERM_ODDODD\n-\t  && !is_eq_or_top (linear_loads_p (perm_cache, right_op[0]),\n-\t\t\t    PERM_ODDEVEN))\n+      tree_code acode = gimple_assign_rhs_code (a_stmt);\n+      tree_code bcode = gimple_assign_rhs_code (b_stmt);\n+      if ((acode == REALPART_EXPR || acode == IMAGPART_EXPR)\n+\t  && (bcode == REALPART_EXPR || bcode == IMAGPART_EXPR))\n+\treturn true;\n+\n+      if (acode != bcode)\n \treturn false;\n     }\n \n-  /* Deal with differences in indexes.  */\n-  int index1 = fms ? 1 : 0;\n-  int index2 = fms ? 0 : 1;\n-\n-  /* Check if the conjugate is on the second first or second operand.  The\n-     order of the node with the conjugate value determines this, and the dup\n-     node must be one of lane 0 of the same DR as the neg node.  */\n-  kind = linear_loads_p (perm_cache, left_op[index1]);\n-  if (kind == PERM_TOP)\n+  if (!SLP_TREE_LOAD_PERMUTATION (a).exists ()\n+      || !SLP_TREE_LOAD_PERMUTATION (b).exists ())\n     {\n-      if (linear_loads_p (perm_cache, left_op[index2]) == PERM_EVENODD)\n-\treturn true;\n+      for (unsigned i = 0; i < gimple_num_args (a_stmt); i++)\n+\t{\n+\t  tree t1 = gimple_arg (a_stmt, i);\n+\t  tree t2 = gimple_arg (b_stmt, i);\n+\t  if (TREE_CODE (t1) != TREE_CODE (t2))\n+\t    return false;\n+\n+\t  /* If SSA name then we will need to inspect the children\n+\t     so we can punt here.  */\n+\t  if (TREE_CODE (t1) == SSA_NAME)\n+\t    continue;\n+\n+\t  if (!operand_equal_p (t1, t2, 0))\n+\t    return false;\n+\t}\n     }\n-  else if (kind == PERM_EVENODD && !neg_first)\n+  else\n     {\n-      if ((kind = linear_loads_p (perm_cache, left_op[index2])) != PERM_EVENEVEN)\n+      auto dr1 = STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (a));\n+      auto dr2 = STMT_VINFO_DATA_REF (SLP_TREE_REPRESENTATIVE (b));\n+      /* Don't check the last dimension as that's checked by the lineary\n+\t checks.  This check is also much stricter than what we need\n+\t because it doesn't consider loading from adjacent elements\n+\t in the same struct as loading from the same base object.\n+\t But for now, I'll play it safe.  */\n+      if (!same_data_refs (dr1, dr2, 1))\n \treturn false;\n-      return true;\n     }\n-  else if (kind == PERM_EVENEVEN && neg_first)\n+\n+  for (unsigned i = 0; i < SLP_TREE_CHILDREN (a).length (); i++)\n     {\n-      if ((kind = linear_loads_p (perm_cache, left_op[index2])) != PERM_EVENODD)\n+      if (!compatible_complex_nodes_p (compat_cache,\n+\t\t\t\t       SLP_TREE_CHILDREN (a)[i], pa,\n+\t\t\t\t       SLP_TREE_CHILDREN (b)[i], pb))\n \treturn false;\n-\n-      *conj_first_operand = true;\n-      return true;\n     }\n-  else\n-    return false;\n-\n-  if (kind != PERM_EVENEVEN)\n-    return false;\n \n+  compat_cache->put (key, true);\n   return true;\n }\n \n-/* Helper function to help distinguish between a conjugate and a rotation in a\n-   complex multiplication.  The operations have similar shapes but the order of\n-   the load permutes are different.  This function returns TRUE when the order\n-   is consistent with a multiplication or multiplication by conjugated\n-   operand but returns FALSE if it's a multiplication by rotated operand.  */\n-\n static inline bool\n vect_validate_multiplication (slp_tree_to_load_perm_map_t *perm_cache,\n-\t\t\t      const vec<slp_tree> &op,\n-\t\t\t      complex_perm_kinds_t permKind)\n+\t\t\t      slp_compat_nodes_map_t *compat_cache,\n+\t\t\t      vec<slp_tree> &left_op,\n+\t\t\t      vec<slp_tree> &right_op,\n+\t\t\t      bool subtract,\n+\t\t\t      enum _conj_status *_status)\n {\n-  /* The left node is the more common case, test it first.  */\n-  if (!is_eq_or_top (linear_loads_p (perm_cache, op[0]), permKind))\n+  auto_vec<slp_tree> ops;\n+  enum _conj_status stats = CONJ_NONE;\n+\n+  /* The complex operations can occur in two layouts and two permute sequences\n+     so declare them and re-use them.  */\n+  int styles[][4] = { { 0, 2, 1, 3} /* {L1, R1} + {L2, R2}.  */\n+\t\t    , { 0, 3, 1, 2} /* {L1, R2} + {L2, R1}.  */\n+\t\t    };\n+\n+  /* Now for the corresponding permutes that go with these values.  */\n+  complex_perm_kinds_t perms[][4]\n+    = { { PERM_EVENEVEN, PERM_ODDODD, PERM_EVENODD, PERM_ODDEVEN }\n+      , { PERM_EVENODD, PERM_ODDEVEN, PERM_EVENEVEN, PERM_ODDODD }\n+      };\n+\n+  /* These permutes are used during comparisons of externals on which\n+     we require strict equality.  */\n+  int cq[][4][2]\n+    = { { { 0, 0 }, { 1, 1 }, { 0, 1 }, { 1, 0 } }\n+      , { { 0, 1 }, { 1, 0 }, { 0, 0 }, { 1, 1 } }\n+      };\n+\n+  /* Default to style and perm 0, most operations use this one.  */\n+  int style = 0;\n+  int perm = subtract ? 1 : 0;\n+\n+  /* Check if we have a negate operation, if so absorb the node and continue\n+     looking.  */\n+  bool neg0 = vect_match_expression_p (right_op[0], NEGATE_EXPR);\n+  bool neg1 = vect_match_expression_p (right_op[1], NEGATE_EXPR);\n+\n+  /* Determine which style we're looking at.  We only have different ones\n+     whenever a conjugate is involved.  */\n+  if (neg0 && neg1)\n+    ;\n+  else if (neg0)\n     {\n-      if (!is_eq_or_top (linear_loads_p (perm_cache, op[1]), permKind))\n-\treturn false;\n+      right_op[0] = SLP_TREE_CHILDREN (right_op[0])[0];\n+      stats = CONJ_FST;\n+      if (subtract)\n+\tperm = 0;\n     }\n-  return true;\n+  else if (neg1)\n+    {\n+      right_op[1] = SLP_TREE_CHILDREN (right_op[1])[0];\n+      stats = CONJ_SND;\n+      perm = 1;\n+    }\n+\n+  *_status = stats;\n+\n+  /* Flatten the inputs after we've remapped them.  */\n+  ops.create (4);\n+  ops.safe_splice (left_op);\n+  ops.safe_splice (right_op);\n+\n+  /* Extract out the elements to check.  */\n+  slp_tree op0 = ops[styles[style][0]];\n+  slp_tree op1 = ops[styles[style][1]];\n+  slp_tree op2 = ops[styles[style][2]];\n+  slp_tree op3 = ops[styles[style][3]];\n+\n+  /* Do cheapest test first.  If failed no need to analyze further.  */\n+  if (linear_loads_p (perm_cache, op0) != perms[perm][0]\n+      || linear_loads_p (perm_cache, op1) != perms[perm][1]\n+      || !is_eq_or_top (perm_cache, op2, perms[perm][2], op3, perms[perm][3]))\n+    return false;\n+\n+  return compatible_complex_nodes_p (compat_cache, op0, cq[perm][0], op1,\n+\t\t\t\t     cq[perm][1])\n+\t && compatible_complex_nodes_p (compat_cache, op2, cq[perm][2], op3,\n+\t\t\t\t\tcq[perm][3]);\n }\n \n /* This function combines two nodes containing only even and only odd lanes\n@@ -908,11 +979,12 @@ class complex_mul_pattern : public complex_pattern\n   public:\n     void build (vec_info *);\n     static internal_fn\n-    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n-\t     vec<slp_tree> *);\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     slp_compat_nodes_map_t *, slp_tree *, vec<slp_tree> *);\n \n     static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    recognize (slp_tree_to_load_perm_map_t *, slp_compat_nodes_map_t *,\n+\t       slp_tree *);\n \n     static vect_pattern*\n     mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n@@ -943,6 +1015,7 @@ class complex_mul_pattern : public complex_pattern\n internal_fn\n complex_mul_pattern::matches (complex_operation_t op,\n \t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      slp_compat_nodes_map_t *compat_cache,\n \t\t\t      slp_tree *node, vec<slp_tree> *ops)\n {\n   internal_fn ifn = IFN_LAST;\n@@ -990,29 +1063,20 @@ complex_mul_pattern::matches (complex_operation_t op,\n       || linear_loads_p (perm_cache, left_op[1]) == PERM_ODDEVEN)\n     return IFN_LAST;\n \n-  bool neg_first = false;\n-  bool conj_first_operand = false;\n-  bool is_neg = vect_normalize_conj_loc (right_op, &neg_first);\n+  enum _conj_status status;\n+  if (!vect_validate_multiplication (perm_cache, compat_cache, left_op,\n+\t\t\t\t     right_op, false, &status))\n+    return IFN_LAST;\n \n-  if (!is_neg)\n+  if (status == CONJ_NONE)\n     {\n-      /* A multiplication needs to multiply agains the real pair, otherwise\n-\t the pattern matches that of FMS.   */\n-      if (!vect_validate_multiplication (perm_cache, left_op, PERM_EVENEVEN)\n-\t  || vect_normalize_conj_loc (left_op))\n-\treturn IFN_LAST;\n       if (add0)\n \tifn = IFN_COMPLEX_FMA;\n       else\n \tifn = IFN_COMPLEX_MUL;\n     }\n   else\n     {\n-      if (!vect_validate_multiplication (perm_cache, left_op, right_op,\n-\t\t\t\t\t neg_first, &conj_first_operand,\n-\t\t\t\t\t false))\n-\treturn IFN_LAST;\n-\n       if(add0)\n \tifn = IFN_COMPLEX_FMA_CONJ;\n       else\n@@ -1029,19 +1093,13 @@ complex_mul_pattern::matches (complex_operation_t op,\n     ops->quick_push (add0);\n \n   complex_perm_kinds_t kind = linear_loads_p (perm_cache, left_op[0]);\n-  if (kind == PERM_EVENODD)\n+  if (kind == PERM_EVENODD || kind == PERM_TOP)\n     {\n       ops->quick_push (left_op[1]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (left_op[0]);\n     }\n-  else if (kind == PERM_TOP)\n-    {\n-      ops->quick_push (left_op[1]);\n-      ops->quick_push (right_op[1]);\n-      ops->quick_push (left_op[0]);\n-    }\n-  else if (kind == PERM_EVENEVEN && !conj_first_operand)\n+  else if (kind == PERM_EVENEVEN && status != CONJ_SND)\n     {\n       ops->quick_push (left_op[0]);\n       ops->quick_push (right_op[0]);\n@@ -1061,13 +1119,14 @@ complex_mul_pattern::matches (complex_operation_t op,\n \n vect_pattern*\n complex_mul_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_compat_nodes_map_t *compat_cache,\n \t\t\t\tslp_tree *node)\n {\n   auto_vec<slp_tree> ops;\n   complex_operation_t op\n     = vect_detect_pair_op (*node, true, &ops);\n   internal_fn ifn\n-    = complex_mul_pattern::matches (op, perm_cache, node, &ops);\n+    = complex_mul_pattern::matches (op, perm_cache, compat_cache, node, &ops);\n   if (ifn == IFN_LAST)\n     return NULL;\n \n@@ -1115,9 +1174,9 @@ complex_mul_pattern::build (vec_info *vinfo)\n \n \t/* First re-arrange the children.  */\n \tSLP_TREE_CHILDREN (*this->m_node).safe_grow (3);\n-\tSLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[0];\n-\tSLP_TREE_CHILDREN (*this->m_node)[1] = this->m_ops[3];\n-\tSLP_TREE_CHILDREN (*this->m_node)[2] = newnode;\n+\tSLP_TREE_CHILDREN (*this->m_node)[0] = this->m_ops[3];\n+\tSLP_TREE_CHILDREN (*this->m_node)[1] = newnode;\n+\tSLP_TREE_CHILDREN (*this->m_node)[2] = this->m_ops[0];\n \n \t/* Tell the builder to expect an extra argument.  */\n \tthis->m_num_args++;\n@@ -1147,11 +1206,12 @@ class complex_fms_pattern : public complex_pattern\n   public:\n     void build (vec_info *);\n     static internal_fn\n-    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n-\t     vec<slp_tree> *);\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     slp_compat_nodes_map_t *, slp_tree *, vec<slp_tree> *);\n \n     static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    recognize (slp_tree_to_load_perm_map_t *, slp_compat_nodes_map_t *,\n+\t       slp_tree *);\n \n     static vect_pattern*\n     mkInstance (slp_tree *node, vec<slp_tree> *m_ops, internal_fn ifn)\n@@ -1182,6 +1242,7 @@ class complex_fms_pattern : public complex_pattern\n internal_fn\n complex_fms_pattern::matches (complex_operation_t op,\n \t\t\t      slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t      slp_compat_nodes_map_t *compat_cache,\n \t\t\t      slp_tree * ref_node, vec<slp_tree> *ops)\n {\n   internal_fn ifn = IFN_LAST;\n@@ -1197,6 +1258,8 @@ complex_fms_pattern::matches (complex_operation_t op,\n   if (!vect_match_expression_p (root, MINUS_EXPR))\n     return IFN_LAST;\n \n+  /* TODO: Support invariants here, with the new layout CADD now\n+\t   can match before we get a chance to try CFMS.  */\n   auto nodes = SLP_TREE_CHILDREN (root);\n   if (!vect_match_expression_p (nodes[1], MULT_EXPR)\n       || vect_detect_pair_op (nodes[0]) != PLUS_MINUS)\n@@ -1217,16 +1280,14 @@ complex_fms_pattern::matches (complex_operation_t op,\n       || !vect_match_expression_p (l0node[1], MULT_EXPR))\n     return IFN_LAST;\n \n-  bool is_neg = vect_normalize_conj_loc (left_op);\n-\n-  bool conj_first_operand = false;\n-  if (!vect_validate_multiplication (perm_cache, right_op, left_op, false,\n-\t\t\t\t     &conj_first_operand, true))\n+  enum _conj_status status;\n+  if (!vect_validate_multiplication (perm_cache, compat_cache, right_op,\n+\t\t\t\t     left_op, true, &status))\n     return IFN_LAST;\n \n-  if (!is_neg)\n+  if (status == CONJ_NONE)\n     ifn = IFN_COMPLEX_FMS;\n-  else if (is_neg)\n+  else\n     ifn = IFN_COMPLEX_FMS_CONJ;\n \n   if (!vect_pattern_validate_optab (ifn, *ref_node))\n@@ -1243,26 +1304,12 @@ complex_fms_pattern::matches (complex_operation_t op,\n       ops->quick_push (right_op[1]);\n       ops->quick_push (left_op[1]);\n     }\n-  else if (kind == PERM_TOP)\n-    {\n-      ops->quick_push (l0node[0]);\n-      ops->quick_push (right_op[1]);\n-      ops->quick_push (right_op[0]);\n-      ops->quick_push (left_op[0]);\n-    }\n-  else if (kind == PERM_EVENEVEN && !is_neg)\n-    {\n-      ops->quick_push (l0node[0]);\n-      ops->quick_push (right_op[1]);\n-      ops->quick_push (right_op[0]);\n-      ops->quick_push (left_op[0]);\n-    }\n   else\n     {\n       ops->quick_push (l0node[0]);\n       ops->quick_push (right_op[1]);\n       ops->quick_push (right_op[0]);\n-      ops->quick_push (left_op[1]);\n+      ops->quick_push (left_op[0]);\n     }\n \n   return ifn;\n@@ -1272,13 +1319,14 @@ complex_fms_pattern::matches (complex_operation_t op,\n \n vect_pattern*\n complex_fms_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\tslp_compat_nodes_map_t *compat_cache,\n \t\t\t\tslp_tree *node)\n {\n   auto_vec<slp_tree> ops;\n   complex_operation_t op\n     = vect_detect_pair_op (*node, true, &ops);\n   internal_fn ifn\n-    = complex_fms_pattern::matches (op, perm_cache, node, &ops);\n+    = complex_fms_pattern::matches (op, perm_cache, compat_cache, node, &ops);\n   if (ifn == IFN_LAST)\n     return NULL;\n \n@@ -1305,9 +1353,9 @@ complex_fms_pattern::build (vec_info *vinfo)\n   SLP_TREE_CHILDREN (*this->m_node).create (3);\n \n   /* First re-arrange the children.  */\n-  SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[0]);\n   SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[1]);\n   SLP_TREE_CHILDREN (*this->m_node).quick_push (newnode);\n+  SLP_TREE_CHILDREN (*this->m_node).quick_push (this->m_ops[0]);\n \n   /* And then rewrite the node itself.  */\n   complex_pattern::build (vinfo);\n@@ -1334,11 +1382,12 @@ class complex_operations_pattern : public complex_pattern\n   public:\n     void build (vec_info *);\n     static internal_fn\n-    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *, slp_tree *,\n-\t     vec<slp_tree> *);\n+    matches (complex_operation_t op, slp_tree_to_load_perm_map_t *,\n+\t     slp_compat_nodes_map_t *, slp_tree *, vec<slp_tree> *);\n \n     static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    recognize (slp_tree_to_load_perm_map_t *, slp_compat_nodes_map_t *,\n+\t       slp_tree *);\n };\n \n /* Dummy matches implementation for proxy object.  */\n@@ -1347,6 +1396,7 @@ internal_fn\n complex_operations_pattern::\n matches (complex_operation_t /* op */,\n \t slp_tree_to_load_perm_map_t * /* perm_cache */,\n+\t slp_compat_nodes_map_t * /* compat_cache */,\n \t slp_tree * /* ref_node */, vec<slp_tree> * /* ops */)\n {\n   return IFN_LAST;\n@@ -1356,22 +1406,23 @@ matches (complex_operation_t /* op */,\n \n vect_pattern*\n complex_operations_pattern::recognize (slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t\t       slp_compat_nodes_map_t *ccache,\n \t\t\t\t       slp_tree *node)\n {\n   auto_vec<slp_tree> ops;\n   complex_operation_t op\n     = vect_detect_pair_op (*node, true, &ops);\n   internal_fn ifn = IFN_LAST;\n \n-  ifn  = complex_fms_pattern::matches (op, perm_cache, node, &ops);\n+  ifn  = complex_fms_pattern::matches (op, perm_cache, ccache, node, &ops);\n   if (ifn != IFN_LAST)\n     return complex_fms_pattern::mkInstance (node, &ops, ifn);\n \n-  ifn  = complex_mul_pattern::matches (op, perm_cache, node, &ops);\n+  ifn  = complex_mul_pattern::matches (op, perm_cache, ccache, node, &ops);\n   if (ifn != IFN_LAST)\n     return complex_mul_pattern::mkInstance (node, &ops, ifn);\n \n-  ifn  = complex_add_pattern::matches (op, perm_cache, node, &ops);\n+  ifn  = complex_add_pattern::matches (op, perm_cache, ccache, node, &ops);\n   if (ifn != IFN_LAST)\n     return complex_add_pattern::mkInstance (node, &ops, ifn);\n \n@@ -1398,11 +1449,13 @@ class addsub_pattern : public vect_pattern\n     void build (vec_info *);\n \n     static vect_pattern*\n-    recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    recognize (slp_tree_to_load_perm_map_t *, slp_compat_nodes_map_t *,\n+\t       slp_tree *);\n };\n \n vect_pattern *\n-addsub_pattern::recognize (slp_tree_to_load_perm_map_t *, slp_tree *node_)\n+addsub_pattern::recognize (slp_tree_to_load_perm_map_t *,\n+\t\t\t   slp_compat_nodes_map_t *, slp_tree *node_)\n {\n   slp_tree node = *node_;\n   if (SLP_TREE_CODE (node) != VEC_PERM_EXPR"}, {"sha": "e2cc7218c2b11ffe9c378121d0f1b83fec1a8f78", "filename": "gcc/tree-vect-slp.cc", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vect-slp.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vect-slp.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.cc?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -804,7 +804,7 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char swap,\n /* Return true if call statements CALL1 and CALL2 are similar enough\n    to be combined into the same SLP group.  */\n \n-static bool\n+bool\n compatible_calls_p (gcall *call1, gcall *call2)\n {\n   unsigned int nargs = gimple_call_num_args (call1);\n@@ -2916,6 +2916,7 @@ optimize_load_redistribution (scalar_stmts_to_slp_tree_map_t *bst_map,\n static bool\n vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n \t\t\t   slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t   slp_compat_nodes_map_t *compat_cache,\n \t\t\t   hash_set<slp_tree> *visited)\n {\n   unsigned i;\n@@ -2927,11 +2928,13 @@ vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n   slp_tree child;\n   FOR_EACH_VEC_ELT (SLP_TREE_CHILDREN (node), i, child)\n     found_p |= vect_match_slp_patterns_2 (&SLP_TREE_CHILDREN (node)[i],\n-\t\t\t\t\t  vinfo, perm_cache, visited);\n+\t\t\t\t\t  vinfo, perm_cache, compat_cache,\n+\t\t\t\t\t  visited);\n \n   for (unsigned x = 0; x < num__slp_patterns; x++)\n     {\n-      vect_pattern *pattern = slp_patterns[x] (perm_cache, ref_node);\n+      vect_pattern *pattern\n+\t= slp_patterns[x] (perm_cache, compat_cache, ref_node);\n       if (pattern)\n \t{\n \t  pattern->build (vinfo);\n@@ -2952,7 +2955,8 @@ vect_match_slp_patterns_2 (slp_tree *ref_node, vec_info *vinfo,\n static bool\n vect_match_slp_patterns (slp_instance instance, vec_info *vinfo,\n \t\t\t hash_set<slp_tree> *visited,\n-\t\t\t slp_tree_to_load_perm_map_t *perm_cache)\n+\t\t\t slp_tree_to_load_perm_map_t *perm_cache,\n+\t\t\t slp_compat_nodes_map_t *compat_cache)\n {\n   DUMP_VECT_SCOPE (\"vect_match_slp_patterns\");\n   slp_tree *ref_node = &SLP_INSTANCE_TREE (instance);\n@@ -2962,7 +2966,8 @@ vect_match_slp_patterns (slp_instance instance, vec_info *vinfo,\n \t\t     \"Analyzing SLP tree %p for patterns\\n\",\n \t\t     SLP_INSTANCE_TREE (instance));\n \n-  return vect_match_slp_patterns_2 (ref_node, vinfo, perm_cache, visited);\n+  return vect_match_slp_patterns_2 (ref_node, vinfo, perm_cache, compat_cache,\n+\t\t\t\t    visited);\n }\n \n /* STMT_INFO is a store group of size GROUP_SIZE that we are considering\n@@ -3446,12 +3451,14 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \n   hash_set<slp_tree> visited_patterns;\n   slp_tree_to_load_perm_map_t perm_cache;\n+  slp_compat_nodes_map_t compat_cache;\n \n   /* See if any patterns can be found in the SLP tree.  */\n   bool pattern_found = false;\n   FOR_EACH_VEC_ELT (LOOP_VINFO_SLP_INSTANCES (vinfo), i, instance)\n     pattern_found |= vect_match_slp_patterns (instance, vinfo,\n-\t\t\t\t\t      &visited_patterns, &perm_cache);\n+\t\t\t\t\t      &visited_patterns, &perm_cache,\n+\t\t\t\t\t      &compat_cache);\n \n   /* If any were found optimize permutations of loads.  */\n   if (pattern_found)"}, {"sha": "ec479d3055dc071be9e8333952db60858c9cb06d", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=55d83cdf23b5f284b4e0bd0a6d1af3d947b2e7c3", "patch": "@@ -2301,6 +2301,7 @@ extern void duplicate_and_interleave (vec_info *, gimple_seq *, tree,\n extern int vect_get_place_in_interleaving_chain (stmt_vec_info, stmt_vec_info);\n extern slp_tree vect_create_new_slp_node (unsigned, tree_code);\n extern void vect_free_slp_tree (slp_tree);\n+extern bool compatible_calls_p (gcall *, gcall *);\n \n /* In tree-vect-patterns.cc.  */\n extern void\n@@ -2339,6 +2340,12 @@ typedef enum _complex_perm_kinds {\n typedef hash_map <slp_tree, complex_perm_kinds_t>\n   slp_tree_to_load_perm_map_t;\n \n+/* Cache from nodes pair to being compatible or not.  */\n+typedef pair_hash <nofree_ptr_hash <_slp_tree>,\n+\t\t   nofree_ptr_hash <_slp_tree>> slp_node_hash;\n+typedef hash_map <slp_node_hash, bool> slp_compat_nodes_map_t;\n+\n+\n /* Vector pattern matcher base class.  All SLP pattern matchers must inherit\n    from this type.  */\n \n@@ -2371,7 +2378,8 @@ class vect_pattern\n   public:\n \n     /* Create a new instance of the pattern matcher class of the given type.  */\n-    static vect_pattern* recognize (slp_tree_to_load_perm_map_t *, slp_tree *);\n+    static vect_pattern* recognize (slp_tree_to_load_perm_map_t *,\n+\t\t\t\t    slp_compat_nodes_map_t *, slp_tree *);\n \n     /* Build the pattern from the data collected so far.  */\n     virtual void build (vec_info *) = 0;\n@@ -2385,6 +2393,7 @@ class vect_pattern\n \n /* Function pointer to create a new pattern matcher from a generic type.  */\n typedef vect_pattern* (*vect_pattern_decl_t) (slp_tree_to_load_perm_map_t *,\n+\t\t\t\t\t      slp_compat_nodes_map_t *,\n \t\t\t\t\t      slp_tree *);\n \n /* List of supported pattern matchers.  */"}]}