{"sha": "d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDQzNTg0Y2ExMjNmMDNjMjRhYTdlNTlhNDNlY2YyYmQzYTZlNDg2Mw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:54:05Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2017-01-23T11:54:05Z"}, "message": "[multiple changes]\n\n2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch5.adb, freeze.adb, par-ch4.adb, scng.adb, sem_ch13.adb,\n\tsem_ch3.adb, sem_ch5.adb, sem_ch5.ads, sem_util.adb, sinfo.ads: Minor\n\treformatting.\n\t* exp_ch9.adb: minor style fix in comment.\n\n2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch4.adb (Analyze_Allocator): Handle properly a type derived\n\tfor a limited record extension with unknown discriminants whose\n\tfull view has no discriminants.\n\n2017-01-23  Yannick Moy  <moy@adacore.com>\n\n\t* exp_spark.adb: Alphabetize with clauses.\n\nFrom-SVN: r244788", "tree": {"sha": "5c7896f94b60c3c0c1fe404b8c967066aca643fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c7896f94b60c3c0c1fe404b8c967066aca643fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/comments", "author": null, "committer": null, "parents": [{"sha": "0f83b0444cf59c7d73fd870e71f6cac3c69a134e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f83b0444cf59c7d73fd870e71f6cac3c69a134e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f83b0444cf59c7d73fd870e71f6cac3c69a134e"}], "stats": {"total": 450, "additions": 255, "deletions": 195}, "files": [{"sha": "c28e5af6b9b0d14feb4ef6e26e2a08718a3a3da2", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -1,3 +1,20 @@\n+2017-01-23  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch5.adb, freeze.adb, par-ch4.adb, scng.adb, sem_ch13.adb,\n+\tsem_ch3.adb, sem_ch5.adb, sem_ch5.ads, sem_util.adb, sinfo.ads: Minor\n+\treformatting.\n+\t* exp_ch9.adb: minor style fix in comment.\n+\n+2017-01-23  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch4.adb (Analyze_Allocator): Handle properly a type derived\n+\tfor a limited record extension with unknown discriminants whose\n+\tfull view has no discriminants.\n+\n+2017-01-23  Yannick Moy  <moy@adacore.com>\n+\n+\t* exp_spark.adb: Alphabetize with clauses.\n+\n 2017-01-23  Yannick Moy  <moy@adacore.com>\n \n \t* sem_util.adb (Has_Enabled_Property): Treat"}, {"sha": "6a808a35a30eb567a9902c8e2b3da5590bf05882", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 104, "deletions": 75, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -75,15 +75,15 @@ package body Exp_Ch5 is\n    --  of formal container iterators.\n \n    function Change_Of_Representation (N : Node_Id) return Boolean;\n-   --  Determine if the right hand side of assignment N is a type conversion\n+   --  Determine if the right-hand side of assignment N is a type conversion\n    --  which requires a change of representation. Called only for the array\n    --  and record cases.\n \n    procedure Expand_Assign_Array (N : Node_Id; Rhs : Node_Id);\n    --  N is an assignment which assigns an array value. This routine process\n    --  the various special cases and checks required for such assignments,\n-   --  including change of representation. Rhs is normally simply the right\n-   --  hand side of the assignment, except that if the right hand side is a\n+   --  including change of representation. Rhs is normally simply the right-\n+   --  hand side of the assignment, except that if the right-hand side is a\n    --  type conversion or a qualified expression, then the RHS is the actual\n    --  expression inside any such type conversions or qualifications.\n \n@@ -98,14 +98,14 @@ package body Exp_Ch5 is\n    --  N is an assignment statement which assigns an array value. This routine\n    --  expands the assignment into a loop (or nested loops for the case of a\n    --  multi-dimensional array) to do the assignment component by component.\n-   --  Larray and Rarray are the entities of the actual arrays on the left\n-   --  hand and right hand sides. L_Type and R_Type are the types of these\n-   --  arrays (which may not be the same, due to either sliding, or to a\n-   --  change of representation case). Ndim is the number of dimensions and\n-   --  the parameter Rev indicates if the loops run normally (Rev = False),\n-   --  or reversed (Rev = True). The value returned is the constructed\n-   --  loop statement. Auxiliary declarations are inserted before node N\n-   --  using the standard Insert_Actions mechanism.\n+   --  Larray and Rarray are the entities of the actual arrays on the left-hand\n+   --  and right-hand sides. L_Type and R_Type are the types of these arrays\n+   --  (which may not be the same, due to either sliding, or to a change of\n+   --  representation case). Ndim is the number of dimensions and the parameter\n+   --  Rev indicates if the loops run normally (Rev = False), or reversed\n+   --  (Rev = True). The value returned is the constructed loop statement.\n+   --  Auxiliary declarations are inserted before node N using the standard\n+   --  Insert_Actions mechanism.\n \n    procedure Expand_Assign_Record (N : Node_Id);\n    --  N is an assignment of an untagged record value. This routine handles\n@@ -359,7 +359,7 @@ package body Exp_Ch5 is\n \n    begin\n       --  Deal with length check. Note that the length check is done with\n-      --  respect to the right hand side as given, not a possible underlying\n+      --  respect to the right-hand side as given, not a possible underlying\n       --  renamed object, since this would generate incorrect extra checks.\n \n       Apply_Length_Check (Rhs, L_Type);\n@@ -420,8 +420,8 @@ package body Exp_Ch5 is\n       end if;\n \n       --  We certainly must use a loop for change of representation and also\n-      --  we use the operand of the conversion on the right hand side as the\n-      --  effective right hand side (the component types must match in this\n+      --  we use the operand of the conversion on the right-hand side as the\n+      --  effective right-hand side (the component types must match in this\n       --  situation).\n \n       if Crep then\n@@ -717,7 +717,7 @@ package body Exp_Ch5 is\n             Act_L_Array := Get_Referenced_Object (Prefix (Act_Lhs));\n             Act_R_Array := Get_Referenced_Object (Prefix (Act_Rhs));\n \n-            --  If both left and right hand arrays are entity names, and refer\n+            --  If both left- and right-hand arrays are entity names, and refer\n             --  to different entities, then we know that the move is safe (the\n             --  two storage areas are completely disjoint).\n \n@@ -1004,7 +1004,7 @@ package body Exp_Ch5 is\n             then\n \n                --  Call TSS procedure for array assignment, passing the\n-               --  explicit bounds of right and left hand sides.\n+               --  explicit bounds of right- and left-hand sides.\n \n                declare\n                   Proc    : constant Entity_Id :=\n@@ -1080,7 +1080,7 @@ package body Exp_Ch5 is\n    --       end loop;\n    --    end;\n \n-   --  Here Rev is False, and Tm1Xn are the subscript types for the right hand\n+   --  Here Rev is False, and Tm1Xn are the subscript types for the right-hand\n    --  side. The declarations of R2b and R4b are inserted before the original\n    --  assignment statement.\n \n@@ -1276,7 +1276,7 @@ package body Exp_Ch5 is\n       L_Typ : constant Entity_Id  := Base_Type (Etype (Lhs));\n \n    begin\n-      --  If change of representation, then extract the real right hand side\n+      --  If change of representation, then extract the real right-hand side\n       --  from the type conversion, and proceed with component-wise assignment,\n       --  since the two types are not the same as far as the back end is\n       --  concerned.\n@@ -1340,7 +1340,7 @@ package body Exp_Ch5 is\n          --  Given C, the entity for a discriminant or component, build an\n          --  assignment for the corresponding field values. The flag U_U\n          --  signals the presence of an Unchecked_Union and forces the usage\n-         --  of the inferred discriminant value of C as the right hand side\n+         --  of the inferred discriminant value of C as the right-hand side\n          --  of the assignment.\n \n          function Make_Field_Assigns (CI : List_Id) return List_Id;\n@@ -1452,7 +1452,7 @@ package body Exp_Ch5 is\n \n          begin\n             --  In the case of an Unchecked_Union, use the discriminant\n-            --  constraint value as on the right hand side of the assignment.\n+            --  constraint value as on the right-hand side of the assignment.\n \n             if U_U then\n                Expr :=\n@@ -1617,14 +1617,15 @@ package body Exp_Ch5 is\n    -------------------------------------\n \n    procedure Expand_Assign_With_Target_Names (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      LHS : constant Node_Id := Name (N);\n-      RHS : constant Node_Id := Expression (N);\n-      Ent : Entity_Id;\n+      LHS     : constant Node_Id    := Name (N);\n+      LHS_Typ : constant Entity_Id  := Etype (LHS);\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      RHS     : constant Node_Id    := Expression (N);\n \n-      New_RHS : Node_Id;\n+      Ent : Entity_Id;\n+      --  The entity of the left-hand side\n \n-      function  Replace_Target (N : Node_Id) return Traverse_Result;\n+      function Replace_Target (N : Node_Id) return Traverse_Result;\n       --  Replace occurrences of the target name by the proper entity: either\n       --  the entity of the LHS in simple cases, or the formal of the\n       --  constructed procedure otherwise.\n@@ -1633,7 +1634,7 @@ package body Exp_Ch5 is\n       -- Replace_Target --\n       --------------------\n \n-      function  Replace_Target (N : Node_Id) return Traverse_Result is\n+      function Replace_Target (N : Node_Id) return Traverse_Result is\n       begin\n          if Nkind (N) = N_Target_Name then\n             Rewrite (N, New_Occurrence_Of (Ent, Sloc (N)));\n@@ -1645,74 +1646,104 @@ package body Exp_Ch5 is\n \n       procedure Replace_Target_Name is new Traverse_Proc (Replace_Target);\n \n-   begin\n+      --  Local variables\n+\n+      New_RHS : Node_Id;\n+      Proc_Id : Entity_Id;\n \n+   --  Start of processing for Expand_Assign_With_Target_Names\n+\n+   begin\n       New_RHS := New_Copy_Tree (RHS);\n \n+      --  The left-hand side is a direct name\n+\n       if Is_Entity_Name (LHS)\n-         and then not Is_Renaming_Of_Object (Entity (LHS))\n+        and then not Is_Renaming_Of_Object (Entity (LHS))\n       then\n          Ent := Entity (LHS);\n          Replace_Target_Name (New_RHS);\n+\n+         --  Generate:\n+         --    LHS := ... LHS ...;\n+\n          Rewrite (N,\n            Make_Assignment_Statement (Loc,\n-             Name => Relocate_Node (LHS),\n+             Name       => Relocate_Node (LHS),\n              Expression => New_RHS));\n \n+      --  The left-hand side is not a direct name, but is side-effect free.\n+      --  Capture its value in a temporary to avoid multiple evaluations.\n+\n       elsif Side_Effect_Free (LHS) then\n          Ent := Make_Temporary (Loc, 'T');\n+         Replace_Target_Name (New_RHS);\n+\n+         --  Generate:\n+         --    T : LHS_Typ := LHS;\n+\n          Insert_Before_And_Analyze (N,\n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Ent,\n-             Object_Definition   => New_Occurrence_Of (Etype (LHS), Loc),\n+             Object_Definition   => New_Occurrence_Of (LHS_Typ, Loc),\n              Expression          => New_Copy_Tree (LHS)));\n-         Replace_Target_Name (New_RHS);\n+\n+         --  Generate:\n+         --    LHS := ... T ...;\n+\n          Rewrite (N,\n            Make_Assignment_Statement (Loc,\n-             Name => Relocate_Node (LHS),\n+             Name       => Relocate_Node (LHS),\n              Expression => New_RHS));\n \n+      --  Otherwise wrap the whole assignment statement in a procedure with an\n+      --  IN OUT parameter. The original assignment then becomes a call to the\n+      --  procedure with the left-hand side as an actual.\n+\n       else\n          Ent := Make_Temporary (Loc, 'T');\n+         Replace_Target_Name (New_RHS);\n \n-         declare\n-            Proc : constant Entity_Id :=\n-              Make_Defining_Identifier (Loc, Chars => New_Internal_Name ('P'));\n-            Formals : constant List_Id := New_List (\n-              Make_Parameter_Specification (Loc,\n-                Defining_Identifier => Ent,\n-                In_Present          => True,\n-                Out_Present         => True,\n-                Parameter_Type      => New_Occurrence_Of (Etype (LHS), Loc)));\n-            Spec : constant Node_Id :=\n-              Make_Procedure_Specification (Loc,\n-                 Defining_Unit_Name => Proc,\n-                 Parameter_Specifications => Formals);\n-            Subp_Body : Node_Id;\n-            Call      : Node_Id;\n-         begin\n-            Replace_Target_Name (New_RHS);\n+         --  Generate:\n+         --    procedure P (T : in out LHS_Typ) is\n+         --    begin\n+         --       T := ... T ...;\n+         --    end P;\n \n-            Subp_Body :=\n-               Make_Subprogram_Body (Loc,\n-                  Specification => Spec,\n-                  Declarations  => Empty_List,\n-                  Handled_Statement_Sequence =>\n-                  Make_Handled_Sequence_Of_Statements (Loc,\n-                    Statements => New_List (\n-                      Make_Assignment_Statement (Loc,\n-                         Name => New_Occurrence_Of (Ent, Loc),\n-                         Expression => New_RHS))));\n-\n-            Insert_Before_And_Analyze (N, Subp_Body);\n-            Call := Make_Procedure_Call_Statement (Loc,\n-              Name => New_Occurrence_Of (Proc, Loc),\n-              Parameter_Associations => New_List (Relocate_Node (LHS)));\n-            Rewrite (N, Call);\n-         end;\n+         Proc_Id := Make_Temporary (Loc, 'P');\n+\n+         Insert_Before_And_Analyze (N,\n+           Make_Subprogram_Body (Loc,\n+             Specification              =>\n+               Make_Procedure_Specification (Loc,\n+                 Defining_Unit_Name       => Proc_Id,\n+                 Parameter_Specifications => New_List (\n+                   Make_Parameter_Specification (Loc,\n+                     Defining_Identifier => Ent,\n+                     In_Present          => True,\n+                     Out_Present         => True,\n+                     Parameter_Type      =>\n+                       New_Occurrence_Of (LHS_Typ, Loc)))),\n+\n+             Declarations               => Empty_List,\n+\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (\n+                   Make_Assignment_Statement (Loc,\n+                     Name       => New_Occurrence_Of (Ent, Loc),\n+                     Expression => New_RHS)))));\n+\n+         --  Generate:\n+         --    P (LHS);\n+\n+         Rewrite (N,\n+           Make_Procedure_Call_Statement (Loc,\n+             Name                   => New_Occurrence_Of (Proc_Id, Loc),\n+             Parameter_Associations => New_List (Relocate_Node (LHS))));\n       end if;\n \n-      --  Analyze rewritten node, either as assignment or procedure call.\n+      --  Analyze rewritten node, either as assignment or procedure call\n \n       Analyze (N);\n    end Expand_Assign_With_Target_Names;\n@@ -1762,9 +1793,7 @@ package body Exp_Ch5 is\n       --  Separate expansion if RHS contain target names. Note that assignment\n       --  may already have been expanded if RHS is aggregate.\n \n-      if Nkind (N) = N_Assignment_Statement\n-        and then Has_Target_Names (N)\n-      then\n+      if Nkind (N) = N_Assignment_Statement and then Has_Target_Names (N) then\n          Expand_Assign_With_Target_Names (N);\n          return;\n       end if;\n@@ -1922,7 +1951,7 @@ package body Exp_Ch5 is\n             --  where the reference was not expanded in the original tree,\n             --  since it was on the left side of an assignment. But in the\n             --  pre-assignment statement (the object definition), BPAR_Expr\n-            --  will end up on the right hand side, and must be reexpanded. To\n+            --  will end up on the right-hand side, and must be reexpanded. To\n             --  achieve this, we reset the analyzed flag of all selected and\n             --  indexed components down to the actual indexed component for\n             --  the packed array.\n@@ -2273,7 +2302,7 @@ package body Exp_Ch5 is\n          begin\n             --  In the controlled case, we ensure that function calls are\n             --  evaluated before finalizing the target. In all cases, it makes\n-            --  the expansion easier if the side-effects are removed first.\n+            --  the expansion easier if the side effects are removed first.\n \n             Remove_Side_Effects (Lhs);\n             Remove_Side_Effects (Rhs);\n@@ -2599,7 +2628,7 @@ package body Exp_Ch5 is\n             if Validity_Checks_On\n               and then Validity_Check_Copies\n             then\n-               --  Skip this if left hand side is an array or record component\n+               --  Skip this if left-hand side is an array or record component\n                --  and elementary component validity checks are suppressed.\n \n                if Nkind_In (Lhs, N_Selected_Component, N_Indexed_Component)\n@@ -4810,7 +4839,7 @@ package body Exp_Ch5 is\n       if not Ctrl_Act then\n          null;\n \n-      --  The left hand side is an uninitialized temporary object\n+      --  The left-hand side is an uninitialized temporary object\n \n       elsif Nkind (L) = N_Type_Conversion\n         and then Is_Entity_Name (Expression (L))"}, {"sha": "55fcbe6f0d4609e895a432747c695288302cf2b6", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -8727,7 +8727,7 @@ package body Exp_Ch9 is\n \n       function Static_Component_Size (Comp : Entity_Id) return Boolean;\n       --  When compiling under the Ravenscar profile, private components must\n-      --  have a static size, or else a protected object  will require heap\n+      --  have a static size, or else a protected object will require heap\n       --  allocation, violating the corresponding restriction. It is preferable\n       --  to make this check here, because it provides a better error message\n       --  than the back-end, which refers to the object as a whole."}, {"sha": "b80ef8294d08fa1d2fdfc335d8e31b44deafa386", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -33,14 +33,14 @@ with Namet;    use Namet;\n with Nlists;   use Nlists;\n with Nmake;    use Nmake;\n with Rtsfind;  use Rtsfind;\n+with Sem_Eval; use Sem_Eval;\n with Sem_Res;  use Sem_Res;\n with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n+with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n-with Uintp; use Uintp;\n-with Sem_Eval; use Sem_Eval;\n-with Stand; use Stand;\n+with Uintp;    use Uintp;\n \n package body Exp_SPARK is\n "}, {"sha": "4d8e52cee742eb2bf60943328251d2eeb3523159", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -1332,8 +1332,6 @@ package body Freeze is\n    -------------------------------\n \n    procedure Check_Expression_Function (N : Node_Id; Nam : Entity_Id) is\n-      Decl : Node_Id;\n-\n       function Find_Constant (Nod : Node_Id) return Traverse_Result;\n       --  Function to search for deferred constant\n \n@@ -1376,6 +1374,10 @@ package body Freeze is\n \n       procedure Check_Deferred is new Traverse_Proc (Find_Constant);\n \n+      --  Local variables\n+\n+      Decl : Node_Id;\n+\n    --  Start of processing for Check_Expression_Function\n \n    begin"}, {"sha": "776b2284b5d428026ae52148fd50ba0d74b29ddd", "filename": "gcc/ada/par-ch4.adb", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fpar-ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fpar-ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch4.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -232,6 +232,7 @@ package body Ch4 is\n \n       --  Loop through designators in qualified name\n       --  AI12-0125 : target_name\n+\n       if Token = Tok_At_Sign then\n          Scan_Reserved_Identifier (Force_Msg => False);\n       end if;\n@@ -2331,15 +2332,15 @@ package body Ch4 is\n       --  Come here at end of simple expression, where we do a couple of\n       --  special checks to improve error recovery.\n \n-      --  Special test to improve error recovery. If the current token\n-      --  is a period, then someone is trying to do selection on something\n-      --  that is not a name, e.g. a qualified expression.\n+      --  Special test to improve error recovery. If the current token is a\n+      --  period, then someone is trying to do selection on something that is\n+      --  not a name, e.g. a qualified expression.\n \n       if Token = Tok_Dot then\n          Error_Msg_SC (\"prefix for selection is not a name\");\n \n-         --  If qualified expression, comment and continue, otherwise\n-         --  something is pretty nasty so do an Error_Resync call.\n+         --  If qualified expression, comment and continue, otherwise something\n+         --  is pretty nasty so do an Error_Resync call.\n \n          if Ada_Version < Ada_2012\n            and then Nkind (Node1) = N_Qualified_Expression\n@@ -2797,7 +2798,7 @@ package body Ch4 is\n                Error_Msg_SC (\"parentheses required for unary minus\");\n                Scan; -- past minus\n \n-            when Tok_At_Sign =>    --  AI12-0125 : target_name\n+            when Tok_At_Sign =>  --  AI12-0125 : target_name\n                if Ada_Version < Ada_2020 then\n                   Error_Msg_SC (\"target name is an Ada 2020 extension\");\n                   Error_Msg_SC (\"\\compile with -gnatX\");"}, {"sha": "ba3c9502b9369417fd6714d32f74adf8300f8752", "filename": "gcc/ada/scng.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fscng.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fscng.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fscng.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -158,9 +158,9 @@ package body Scng is\n             | Tok_And\n             | Tok_Apostrophe\n             | Tok_Array\n-            | Tok_At_Sign\n             | Tok_Asterisk\n             | Tok_At\n+            | Tok_At_Sign\n             | Tok_Body\n             | Tok_Box\n             | Tok_Char_Literal\n@@ -1618,6 +1618,7 @@ package body Scng is\n \n             else\n                --  AI12-0125-03 : @ is target_name\n+\n                Accumulate_Checksum ('@');\n                Scan_Ptr := Scan_Ptr + 1;\n                Token := Tok_At_Sign;\n@@ -2438,6 +2439,7 @@ package body Scng is\n          --  Invalid graphic characters\n          --  Note that '@' is handled elsewhere, because following AI12-125\n          --  it denotes the target_name of an assignment.\n+\n          when '#' | '$' | '?' | '`' | '\\' | '^' | '~' =>\n \n             --  If Set_Special_Character has been called for this character,"}, {"sha": "db0b1d8c364a192336c757949ae0a770626a6f8c", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 76, "deletions": 84, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -352,16 +352,16 @@ package body Sem_Ch13 is\n    -----------------------------------------\n \n    procedure Adjust_Record_For_Reverse_Bit_Order (R : Entity_Id) is\n-      Comp : Node_Id;\n-      CC   : Node_Id;\n-\n       Max_Machine_Scalar_Size : constant Uint :=\n                                   UI_From_Int\n                                     (Standard_Long_Long_Integer_Size);\n       --  We use this as the maximum machine scalar size\n \n+      SSU : constant Uint := UI_From_Int (System_Storage_Unit);\n+\n+      CC     : Node_Id;\n+      Comp   : Node_Id;\n       Num_CC : Natural;\n-      SSU    : constant Uint := UI_From_Int (System_Storage_Unit);\n \n    begin\n       --  Processing here used to depend on Ada version: the behavior was\n@@ -380,12 +380,12 @@ package body Sem_Ch13 is\n       --  same byte offset and processing them together. Same approach is still\n       --  valid in later versions including Ada 2012.\n \n-      --  This first loop through components does two things. First it\n-      --  deals with the case of components with component clauses whose\n-      --  length is greater than the maximum machine scalar size (either\n-      --  accepting them or rejecting as needed). Second, it counts the\n-      --  number of components with component clauses whose length does\n-      --  not exceed this maximum for later processing.\n+      --  This first loop through components does two things. First it deals\n+      --  with the case of components with component clauses whose length is\n+      --  greater than the maximum machine scalar size (either accepting them\n+      --  or rejecting as needed). Second, it counts the number of components\n+      --  with component clauses whose length does not exceed this maximum for\n+      --  later processing.\n \n       Num_CC := 0;\n       Comp   := First_Component_Or_Discriminant (R);\n@@ -402,8 +402,8 @@ package body Sem_Ch13 is\n \n                if Lbit >= Max_Machine_Scalar_Size then\n \n-                  --  This is allowed only if first bit is zero, and\n-                  --  last bit + 1 is a multiple of storage unit size.\n+                  --  This is allowed only if first bit is zero, and last bit\n+                  --  + 1 is a multiple of storage unit size.\n \n                   if Fbit = 0 and then (Lbit + 1) mod SSU = 0 then\n \n@@ -435,28 +435,25 @@ package body Sem_Ch13 is\n                      Error_Msg_Uint_1 := Lbit + 1;\n                      Error_Msg_Uint_2 := Max_Machine_Scalar_Size;\n                      Error_Msg_F\n-                       (\"\\last bit + 1 (^) exceeds maximum machine \"\n-                        & \"scalar size (^)\",\n-                        First_Bit (CC));\n+                       (\"\\last bit + 1 (^) exceeds maximum machine scalar \"\n+                        & \"size (^)\", First_Bit (CC));\n \n                      if (Lbit + 1) mod SSU /= 0 then\n                         Error_Msg_Uint_1 := SSU;\n                         Error_Msg_F\n                           (\"\\and is not a multiple of Storage_Unit (^) \"\n-                           & \"(RM 13.5.1(10))\",\n-                           First_Bit (CC));\n+                           & \"(RM 13.5.1(10))\", First_Bit (CC));\n \n                      else\n                         Error_Msg_Uint_1 := Fbit;\n                         Error_Msg_F\n                           (\"\\and first bit (^) is non-zero \"\n-                           & \"(RM 13.4.1(10))\",\n-                           First_Bit (CC));\n+                           & \"(RM 13.4.1(10))\", First_Bit (CC));\n                      end if;\n                   end if;\n \n-               --  OK case of machine scalar related component clause,\n-               --  For now, just count them.\n+               --  OK case of machine scalar related component clause. For now,\n+               --  just count them.\n \n                else\n                   Num_CC := Num_CC + 1;\n@@ -467,16 +464,14 @@ package body Sem_Ch13 is\n          Next_Component_Or_Discriminant (Comp);\n       end loop;\n \n-      --  We need to sort the component clauses on the basis of the\n-      --  Position values in the clause, so we can group clauses with\n-      --  the same Position together to determine the relevant machine\n-      --  scalar size.\n+      --  We need to sort the component clauses on the basis of the Position\n+      --  values in the clause, so we can group clauses with the same Position\n+      --  together to determine the relevant machine scalar size.\n \n       Sort_CC : declare\n          Comps : array (0 .. Num_CC) of Entity_Id;\n-         --  Array to collect component and discriminant entities. The\n-         --  data starts at index 1, the 0'th entry is for the sort\n-         --  routine.\n+         --  Array to collect component and discriminant entities. The data\n+         --  starts at index 1, the 0'th entry is for the sort routine.\n \n          function CP_Lt (Op1, Op2 : Natural) return Boolean;\n          --  Compare routine for Sort\n@@ -486,25 +481,26 @@ package body Sem_Ch13 is\n \n          package Sorting is new GNAT.Heap_Sort_G (CP_Move, CP_Lt);\n \n+         MaxL : Uint;\n+         --  Maximum last bit value of any component in this set\n+\n+         MSS : Uint;\n+         --  Corresponding machine scalar size\n+\n          Start : Natural;\n          Stop  : Natural;\n          --  Start and stop positions in the component list of the set of\n          --  components with the same starting position (that constitute\n          --  components in a single machine scalar).\n \n-         MaxL  : Uint;\n-         --  Maximum last bit value of any component in this set\n-\n-         MSS   : Uint;\n-         --  Corresponding machine scalar size\n-\n          -----------\n          -- CP_Lt --\n          -----------\n \n          function CP_Lt (Op1, Op2 : Natural) return Boolean is\n          begin\n-            return Position (Component_Clause (Comps (Op1))) <\n+            return\n+              Position (Component_Clause (Comps (Op1))) <\n               Position (Component_Clause (Comps (Op2)));\n          end CP_Lt;\n \n@@ -529,12 +525,12 @@ package body Sem_Ch13 is\n                CC   : constant Node_Id := Component_Clause (Comp);\n \n             begin\n-               --  Collect only component clauses whose last bit is less\n-               --  than machine scalar size. Any component clause whose\n-               --  last bit exceeds this value does not take part in\n-               --  machine scalar layout considerations. The test for\n-               --  Error_Posted makes sure we exclude component clauses\n-               --  for which we already posted an error.\n+               --  Collect only component clauses whose last bit is less than\n+               --  machine scalar size. Any component clause whose last bit\n+               --  exceeds this value does not take part in machine scalar\n+               --  layout considerations. The test for Error_Posted makes sure\n+               --  we exclude component clauses for which we already posted an\n+               --  error.\n \n                if Present (CC)\n                  and then not Error_Posted (Last_Bit (CC))\n@@ -553,10 +549,10 @@ package body Sem_Ch13 is\n \n          Sorting.Sort (Num_CC);\n \n-         --  We now have all the components whose size does not exceed\n-         --  the max machine scalar value, sorted by starting position.\n-         --  In this loop we gather groups of clauses starting at the\n-         --  same position, to process them in accordance with AI-133.\n+         --  We now have all the components whose size does not exceed the max\n+         --  machine scalar value, sorted by starting position. In this loop we\n+         --  gather groups of clauses starting at the same position, to process\n+         --  them in accordance with AI-133.\n \n          Stop := 0;\n          while Stop < Num_CC loop\n@@ -583,14 +579,14 @@ package body Sem_Ch13 is\n                end if;\n             end loop;\n \n-            --  Now we have a group of component clauses from Start to\n-            --  Stop whose positions are identical, and MaxL is the\n-            --  maximum last bit value of any of these components.\n+            --  Now we have a group of component clauses from Start to Stop\n+            --  whose positions are identical, and MaxL is the maximum last\n+            --  bit value of any of these components.\n \n-            --  We need to determine the corresponding machine scalar\n-            --  size. This loop assumes that machine scalar sizes are\n-            --  even, and that each possible machine scalar has twice\n-            --  as many bits as the next smaller one.\n+            --  We need to determine the corresponding machine scalar size.\n+            --  This loop assumes that machine scalar sizes are even, and that\n+            --  each possible machine scalar has twice as many bits as the next\n+            --  smaller one.\n \n             MSS := Max_Machine_Scalar_Size;\n             while MSS mod 2 = 0\n@@ -600,10 +596,9 @@ package body Sem_Ch13 is\n                MSS := MSS / 2;\n             end loop;\n \n-            --  Here is where we fix up the Component_Bit_Offset value\n-            --  to account for the reverse bit order. Some examples of\n-            --  what needs to be done for the case of a machine scalar\n-            --  size of 8 are:\n+            --  Here is where we fix up the Component_Bit_Offset value to\n+            --  account for the reverse bit order. Some examples of what needs\n+            --  to be done for the case of a machine scalar size of 8 are:\n \n             --    First_Bit .. Last_Bit     Component_Bit_Offset\n             --      old          new          old       new\n@@ -617,8 +612,8 @@ package body Sem_Ch13 is\n             --     1 .. 4       3 .. 6         1         3\n             --     4 .. 7       0 .. 3         4         0\n \n-            --  The rule is that the first bit is obtained by subtracting\n-            --  the old ending bit from machine scalar size - 1.\n+            --  The rule is that the first bit is obtained by subtracting the\n+            --  old ending bit from machine scalar size - 1.\n \n             for C in Start .. Stop loop\n                declare\n@@ -634,19 +629,19 @@ package body Sem_Ch13 is\n                   if Warn_On_Reverse_Bit_Order then\n                      Error_Msg_Uint_1 := MSS;\n                      Error_Msg_N\n-                       (\"info: reverse bit order in machine \" &\n-                        \"scalar of length^?V?\", First_Bit (CC));\n+                       (\"info: reverse bit order in machine scalar of \"\n+                        & \"length^?V?\", First_Bit (CC));\n                      Error_Msg_Uint_1 := NFB;\n                      Error_Msg_Uint_2 := NLB;\n \n                      if Bytes_Big_Endian then\n                         Error_Msg_NE\n-                          (\"\\big-endian range for component \"\n-                           & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n+                          (\"\\big-endian range for component & is ^ .. ^?V?\",\n+                           First_Bit (CC), Comp);\n                      else\n                         Error_Msg_NE\n-                          (\"\\little-endian range for component\"\n-                           & \"& is ^ .. ^?V?\", First_Bit (CC), Comp);\n+                          (\"\\little-endian range for component & is ^ .. ^?V?\",\n+                           First_Bit (CC), Comp);\n                      end if;\n                   end if;\n \n@@ -663,8 +658,8 @@ package body Sem_Ch13 is\n    ------------------------------------------------\n \n    procedure Adjust_Record_For_Reverse_Bit_Order_Ada_95 (R : Entity_Id) is\n-      Comp : Node_Id;\n       CC   : Node_Id;\n+      Comp : Node_Id;\n \n    begin\n       --  For Ada 95, we just renumber bits within a storage unit. We do the\n@@ -707,8 +702,8 @@ package body Sem_Ch13 is\n                     and then CSZ mod System_Storage_Unit = 0\n                   then\n                      Error_Msg_N\n-                       (\"info: multi-byte field specified with \"\n-                        & \"non-standard Bit_Order?V?\", CLC);\n+                       (\"info: multi-byte field specified with non-standard \"\n+                        & \"Bit_Order?V?\", CLC);\n \n                      if Bytes_Big_Endian then\n                         Error_Msg_N\n@@ -724,11 +719,11 @@ package body Sem_Ch13 is\n \n                   else\n                      Error_Msg_N\n-                       (\"attempt to specify non-contiguous field \"\n-                        & \"not permitted\", CLC);\n+                       (\"attempt to specify non-contiguous field not \"\n+                        & \"permitted\", CLC);\n                      Error_Msg_N\n-                       (\"\\caused by non-standard Bit_Order \"\n-                        & \"specified in legacy Ada 95 mode\", CLC);\n+                       (\"\\caused by non-standard Bit_Order specified in \"\n+                        & \"legacy Ada 95 mode\", CLC);\n                   end if;\n \n                --  Case where field fits in one storage unit\n@@ -740,14 +735,14 @@ package body Sem_Ch13 is\n                     and then Warn_On_Reverse_Bit_Order\n                   then\n                      Error_Msg_N\n-                       (\"info: Bit_Order clause does not affect \" &\n-                        \"byte ordering?V?\", Pos);\n+                       (\"info: Bit_Order clause does not affect byte \"\n+                        & \"ordering?V?\", Pos);\n                      Error_Msg_Uint_1 :=\n                        Intval (Pos) + Intval (FB) /\n                        System_Storage_Unit;\n                      Error_Msg_N\n-                       (\"info: position normalized to ^ before bit \" &\n-                        \"order interpreted?V?\", Pos);\n+                       (\"info: position normalized to ^ before bit order \"\n+                        & \"interpreted?V?\", Pos);\n                   end if;\n \n                   --  Here is where we fix up the Component_Bit_Offset value\n@@ -769,16 +764,13 @@ package body Sem_Ch13 is\n                   --  The rule is that the first bit is is obtained by\n                   --  subtracting the old ending bit from storage_unit - 1.\n \n-                  Set_Component_Bit_Offset\n-                    (Comp,\n-                     (Storage_Unit_Offset * System_Storage_Unit) +\n-                       (System_Storage_Unit - 1) -\n-                       (Start_Bit + CSZ - 1));\n+                  Set_Component_Bit_Offset (Comp,\n+                    (Storage_Unit_Offset * System_Storage_Unit) +\n+                      (System_Storage_Unit - 1) -\n+                      (Start_Bit + CSZ - 1));\n \n-                  Set_Normalized_First_Bit\n-                    (Comp,\n-                     Component_Bit_Offset (Comp) mod\n-                       System_Storage_Unit);\n+                  Set_Normalized_First_Bit (Comp,\n+                    Component_Bit_Offset (Comp) mod System_Storage_Unit);\n                end if;\n             end;\n          end if;"}, {"sha": "1f774c00a62ece2d3284ff60460d45e25acad08d", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -2634,12 +2634,11 @@ package body Sem_Ch3 is\n \n          elsif not Analyzed (Next_Decl) and then Is_Body (Next_Decl) then\n \n-            --  Check for an edge case that may cause premature freezing of a\n-            --  private type.\n-\n-            --  If there is an type which depends on a private type from an\n-            --  enclosing package that is in the same scope as a non-completing\n-            --  expression function then we cannot freeze here.\n+            --  Check for an edge case that may cause premature freezing of\n+            --  a private type. If there is a type which depends on another\n+            --  private type from an enclosing package that is in the same\n+            --  scope as a non-completing expression function then we cannot\n+            --  freeze here.\n \n             Ignore_Freezing := False;\n "}, {"sha": "26d78b6370b6e79fc571b2afcb6ac819fcb10480", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -716,6 +716,23 @@ package body Sem_Ch4 is\n                then\n                   null;\n \n+               --  An unusual case arises when the parent of a derived type is\n+               --  a limited record extension  with unknown discriminants, and\n+               --  its full view has no discriminants.\n+               --\n+               --  A more general fix might be to create the proper underlying\n+               --  type for such a derived type, but it is a record type with\n+               --  no private attributes, so this required extending the\n+               --  meaning of this attribute. ???\n+\n+               elsif Ekind (Etype (Type_Id)) = E_Record_Type_With_Private\n+                 and then Present (Underlying_Type (Etype (Type_Id)))\n+                 and then\n+                   not Has_Discriminants (Underlying_Type (Etype (Type_Id)))\n+                 and then not Comes_From_Source (Parent (N))\n+               then\n+                  null;\n+\n                elsif Is_Class_Wide_Type (Type_Id) then\n                   Error_Msg_N\n                     (\"initialization required in class-wide allocation\", N);"}, {"sha": "bc7693cb5c44d599ce89e1b1837357630215dd52", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -284,7 +284,8 @@ package body Sem_Ch5 is\n    --  Start of processing for Analyze_Assignment\n \n    begin\n-      --  Save LHS for use in target names (AI12-125).\n+      --  Save LHS for use in target names (AI12-125)\n+\n       Current_LHS := Lhs;\n \n       Mark_Coextensions (N, Rhs);\n@@ -574,9 +575,7 @@ package body Sem_Ch5 is\n       --  the context of the assignment statement. Restore the expander mode\n       --  now so that assignment statement can be properly expanded.\n \n-      if  Nkind (N) = N_Assignment_Statement\n-        and then Has_Target_Names (N)\n-      then\n+      if Nkind (N) = N_Assignment_Statement and then Has_Target_Names (N) then\n          Expander_Mode_Restore;\n       end if;\n \n@@ -3543,6 +3542,7 @@ package body Sem_Ch5 is\n       if No (Current_LHS) then\n          Error_Msg_N (\"target name can only appear within an assignment\", N);\n          Set_Etype (N, Any_Type);\n+\n       else\n          Set_Has_Target_Names (Parent (Current_LHS));\n          Set_Etype (N, Etype (Current_LHS));"}, {"sha": "99a29510d771b8706520791db5e0ef7b8cbb3a3d", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -41,8 +41,8 @@ package Sem_Ch5 is\n    procedure Analyze_Loop_Parameter_Specification (N : Node_Id);\n    procedure Analyze_Loop_Statement               (N : Node_Id);\n    procedure Analyze_Null_Statement               (N : Node_Id);\n-   procedure Analyze_Target_Name                  (N : Node_Id);\n    procedure Analyze_Statements                   (L : List_Id);\n+   procedure Analyze_Target_Name                  (N : Node_Id);\n \n    procedure Analyze_Label_Entity (E : Entity_Id);\n    --  This procedure performs direct analysis of the label entity E. It"}, {"sha": "3f7144290528dc4d5f9be071a1dda6e35ef3349e", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -9140,16 +9140,16 @@ package body Sem_Util is\n \n       begin\n          --  Protected objects always have the properties Async_Readers and\n-         --  Async_Writers. (SPARK RM 7.1.2(16))\n+         --  Async_Writers (SPARK RM 7.1.2(16)).\n \n          if Property = Name_Async_Readers\n            or else Property = Name_Async_Writers\n          then\n             return True;\n \n-         --  Protected objects that have Part_Of components also inherit\n-         --  their properties Effective_Reads and Effective_Writes. (SPARK\n-         --  RM 7.1.2(16))\n+         --  Protected objects that have Part_Of components also inherit their\n+         --  properties Effective_Reads and Effective_Writes\n+         --  (SPARK RM 7.1.2(16)).\n \n          elsif Present (Constits) then\n             Constit_Elmt := First_Elmt (Constits);\n@@ -9352,8 +9352,9 @@ package body Sem_Util is\n             --  (SPARK RM 7.1.2(16))\n \n             if Is_Protected_Type (Etype (Item_Id)) then\n-               return Property = Name_Async_Readers\n-                 or else Property = Name_Async_Writers;\n+               return\n+                 Property = Name_Async_Readers\n+                   or else Property = Name_Async_Writers;\n             else\n                return True;\n             end if;\n@@ -9377,8 +9378,8 @@ package body Sem_Util is\n \n       --  By default, protected objects only have the properties Async_Readers\n       --  and Async_Writers. If they have Part_Of components, they also inherit\n-      --  their properties Effective_Reads and Effective_Writes. (SPARK RM\n-      --  7.1.2(16))\n+      --  their properties Effective_Reads and Effective_Writes\n+      --  (SPARK RM 7.1.2(16)).\n \n       elsif Ekind (Item_Id) = E_Protected_Object then\n          return Protected_Object_Has_Enabled_Property;"}, {"sha": "4ff8fb1da9fb7c5a7dc46acb0c215216c931d2dd", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d43584ca123f03c24aa7e59a43ecf2bd3a6e4863/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=d43584ca123f03c24aa7e59a43ecf2bd3a6e4863", "patch": "@@ -1538,15 +1538,15 @@ package Sinfo is\n    --    A flag present in an N_Task_Definition node to flag the presence of a\n    --    Storage_Size pragma.\n \n+   --  Has_Target_Names (Flag8-Sem)\n+   --    Present in assignment statements. Indicates that the RHS contains\n+   --    target names (see AI12-0125-3) and must be expanded accordingly.\n+\n    --  Has_Wide_Character (Flag11-Sem)\n    --    Present in string literals, set if any wide character (i.e. character\n    --    code outside the Character range but within Wide_Character range)\n    --    appears in the string. Used to implement pragma preference rules.\n \n-   --  Has_Target_Names (Flag8-Sem)\n-   --    Present in assignment statements. Indicates that the RHS contains\n-   --    target names (see AI12-0125-3) and must be expanded accordingly.\n-\n    --  Has_Wide_Wide_Character (Flag13-Sem)\n    --    Present in string literals, set if any wide character (i.e. character\n    --    code outside the Wide_Character range) appears in the string. Used to"}]}