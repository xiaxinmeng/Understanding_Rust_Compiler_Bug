{"sha": "78d310c2c138f824e912f84eb0f6718e335238eb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhkMzEwYzJjMTM4ZjgyNGU5MTJmODRlYjBmNjcxOGUzMzUyMzhlYg==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "joern.rennecke@st.com", "date": "2006-11-03T14:52:19Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2006-11-03T14:52:19Z"}, "message": "crt1.asm: Fix #ifdef indent.\n\ngcc:\n\n2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n\n\t* config/sh/crt1.asm: Fix #ifdef indent.\n\n2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n\tMerged from STMicroelectronics sources:\n\t2006-10-06  Andrew Stubbs  <andrew.stubbs@st.com>\n\t  * config/sh/crt1.asm (vbr_600): Add missing #if.\n\t2006-08-03  J\"orn Rennecke  <joern.rennecke@st.com>\n\t  * sh.opt (mfused-madd): New option.\n\t  * sh.md (mac_media, macsf3): Make conditional on TARGET_FMAC.\n\t2006-07-04  Andrew Stubbs  <andrew.stubbs@st.com>\n\t  * config/sh/crt1.asm (vbr_start): Move to new section .test.vbr.\n\t  Remove pointless handler at VBR+0.\n\t  (vbr_200, vbr_300, vbr_500): Remove pointless handler.\n\t  (vbr_600): Save and restore mach and macl, fpul and fpscr and fr0 to\n\t  fr7. Make sure the timer handler is called with the correct FPU\n\t  precision setting, according to the ABI.\n\t2006-06-14  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * config/sh/sh.opt (m2a-single, m2a-single-only): Fix Condition.\n\t  * config/sh/sh.h (SUPPORT_SH2A_NOFPU): Fix condition.\n\t  (SUPPORT_SH2A_SINGLE_ONLY, SUPPORT_SH2A_SINGLE_ONLY): Likewise.\n\t2006-06-09  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * sh.md (cmpgeusi_t): Change into define_insn_and_split.  Accept\n\t  zero as second operand.\n\t2006-04-28  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * config/sh/divtab-sh4-300.c, config/sh/lib1funcs-4-300.asm:\n\t  Fixed some bugs related to negative values, in particular -0\n\t  and overflow at -0x80000000.\n\t  * config/sh/divcost-analysis: Added sh4-300 figures.\n\t2006-04-27  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * config/sh/t-sh (MULTILIB_MATCHES): Add -m4-300* / -m4-340 options.\n\t2006-04-26  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * config/sh/t-sh (OPT_EXTRA_PARTS): Add libgcc-4-300.a.\n\t  ($(T)div_table-4-300.o, $(T)libgcc-4-300.a): New rules.\n\t  * config/sh/divtab-sh4-300.c, config/sh/lib1funcs-4-300.asm:\n\tNew files.\n\t  * config/sh/embed-elf.h (LIBGCC_SPEC): Use -lgcc-4-300 for -m4-300* /\n\t  -m4-340.\n\t2006-04-24  J\"orn Rennecke <joern.rennecke@st.com>\n\t  SH4-300 scheduling description & fixes to SH4-[12]00 description:\n\t  * sh.md: New instruction types: fstore, movi8, fpscr_toggle, gp_mac,\n\t  mac_mem, mem_mac, dfp_mul, fp_cmp.\n\t  (insn_class, dfp_comp, any_fp_comp): Update.\n\t  (push_fpul, movsf_ie, fpu_switch, toggle_sz, toggle_pr): Update type.\n\t  (cmpgtsf_t, \"cmpeqsf_t, cmpgtsf_t_i4, cmpeqsf_t_i4): Likewise.\n\t  (muldf3_i): Likewise.\n\t  (movsi_i): Split rI08 alternative into two separate alternatives.\n\t  Update type.\n\t  (movsi_ie, movsi_i_lowpart): Likewise.\n\t  (movqi_i): Split ri alternative into two separate alternatives.\n\t  Update type.\n\t  * sh1.md (sh1_load_store, sh1_fp): Update.\n\t  * sh4.md (sh4_store, sh4_mac_gp, fp_arith, fp_double_arith): Update.\n\t  (mac_mem, sh4_fpscr_toggle): New insn_reservations.\n\t  * sh4a.md (sh4a_mov, sh4a_load, sh4a_store, sh4a_fp_arith): Update.\n\t  (sh4a_fp_double_arith): Likewise.\n\t  * sh4-300.md: New file.\n\t  * sh.c (sh_handle_option): Handle m4-300* options.\n\t  (sh_adjust_cost): Fix latency of auto-increments.\n\t  Handle SH4-300 differently than other SH4s.  Check for new insn types.\n\t  * sh.h (OVERRIDE_OPTIONS): Initilize sh_branch_cost if it has not\n\t  been set by an option.\n\t  * sh.opt (m4-300, m4-100-nofpu, m4-200-nofpu): New options.\n\t  (m4-300-nofpu, -m4-340, m4-300-single, m4-300-single-only): Likewise.\n\t  (mbranch-cost=): Likewise.\n\t  * superh.h (STARTFILE_SPEC): Take -m4-340 into account.\n\n\t  * sh.md (mulsf3): Remove special expansion code.\n\t  (mulsf3_ie): Now a define_insn_and_split.\n\t  (macsf3): Allow for TARGET_SH4.\n\n\t  * sh.md (cbranchsi4, cbranchdi4, cbranchdi4_i): New patterns.\n\t  * sh.c (prepare_cbranch_operands, expand_cbranchsi4): New functions.\n\t  (expand_cbranchdi4): Likewise.\n\t  (sh_rtx_costs): Give lower cost for certain CONST_INT values and for\n\t  CONST_DOUBLE if the outer code is COMPARE.\n\t  * sh.h (OPTIMIZATION_OPTIONS): If not optimizing for size, set\n\t  TARGET_CBRANCHDI4 and TARGET_EXPAND_CBRANCHDI4.\n\t  (OVERRIDE_OPTIONS): For TARGET_SHMEDIA, clear TARGET_CBRANCHDI4.\n\t  (LEGITIMATE_CONSTANT_P): Also allow DImode and VOIDmode CONST_DOUBLEs.\n\t  Remove redundant fp_{zero,one}_operand checks.\n\t  * sh.opt (mcbranchdi, mexpand-cbranchdi, mcmpeqdi): New options.\n\t  * sh-protos.h (prepare_cbranch_operands, expand_cbranchsi4): Declare.\n\t  (expand_cbranchdi4): Likewise.\n\t2006-04-20  J\"orn Rennecke <joern.rennecke@st.com>\n\t  * sh.h (LOCAL_ALIGNMENT): Use DATA_ALIGNMENT.\n\ngcc/testsuite:\n\n2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n\n\t* testsuite/gcc.c-torture/execute/arith-rand-ll.c:\n\tAlso test for bogus rest sign.\n\nFrom-SVN: r118458", "tree": {"sha": "3d97ecce23a07db27ad8719a95481e47559cea2f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d97ecce23a07db27ad8719a95481e47559cea2f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78d310c2c138f824e912f84eb0f6718e335238eb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d310c2c138f824e912f84eb0f6718e335238eb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78d310c2c138f824e912f84eb0f6718e335238eb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78d310c2c138f824e912f84eb0f6718e335238eb/comments", "author": null, "committer": null, "parents": [{"sha": "47c07d96b1c8e56efb61114c2f48724f32561a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47c07d96b1c8e56efb61114c2f48724f32561a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47c07d96b1c8e56efb61114c2f48724f32561a22"}], "stats": {"total": 2361, "additions": 2131, "deletions": 230}, "files": [{"sha": "5212852822f8be3c25ea23a0743581f68e467b4d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,3 +1,91 @@\n+2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n+\n+\t* config/sh/crt1.asm: Fix #ifdef indent.\n+\n+2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n+\tMerged from STMicroelectronics sources:\n+\t2006-10-06  Andrew Stubbs  <andrew.stubbs@st.com>\n+\t  * config/sh/crt1.asm (vbr_600): Add missing #if.\n+\t2006-08-03  J\"orn Rennecke  <joern.rennecke@st.com>\n+\t  * sh.opt (mfused-madd): New option.\n+\t  * sh.md (mac_media, macsf3): Make conditional on TARGET_FMAC.\n+\t2006-07-04  Andrew Stubbs  <andrew.stubbs@st.com>\n+\t  * config/sh/crt1.asm (vbr_start): Move to new section .test.vbr.\n+\t  Remove pointless handler at VBR+0.\n+\t  (vbr_200, vbr_300, vbr_500): Remove pointless handler.\n+\t  (vbr_600): Save and restore mach and macl, fpul and fpscr and fr0 to\n+\t  fr7. Make sure the timer handler is called with the correct FPU\n+\t  precision setting, according to the ABI.\n+\t2006-06-14  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * config/sh/sh.opt (m2a-single, m2a-single-only): Fix Condition.\n+\t  * config/sh/sh.h (SUPPORT_SH2A_NOFPU): Fix condition.\n+\t  (SUPPORT_SH2A_SINGLE_ONLY, SUPPORT_SH2A_SINGLE_ONLY): Likewise.\n+\t2006-06-09  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * sh.md (cmpgeusi_t): Change into define_insn_and_split.  Accept\n+\t  zero as second operand.\n+\t2006-04-28  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * config/sh/divtab-sh4-300.c, config/sh/lib1funcs-4-300.asm:\n+\t  Fixed some bugs related to negative values, in particular -0\n+\t  and overflow at -0x80000000.\n+\t  * config/sh/divcost-analysis: Added sh4-300 figures.\n+\t2006-04-27  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * config/sh/t-sh (MULTILIB_MATCHES): Add -m4-300* / -m4-340 options.\n+\t2006-04-26  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * config/sh/t-sh (OPT_EXTRA_PARTS): Add libgcc-4-300.a.\n+\t  ($(T)div_table-4-300.o, $(T)libgcc-4-300.a): New rules.\n+\t  * config/sh/divtab-sh4-300.c, config/sh/lib1funcs-4-300.asm:\n+\tNew files.\n+\t  * config/sh/embed-elf.h (LIBGCC_SPEC): Use -lgcc-4-300 for -m4-300* /\n+\t  -m4-340.\n+\t2006-04-24  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  SH4-300 scheduling description & fixes to SH4-[12]00 description:\n+\t  * sh.md: New instruction types: fstore, movi8, fpscr_toggle, gp_mac,\n+\t  mac_mem, mem_mac, dfp_mul, fp_cmp.\n+\t  (insn_class, dfp_comp, any_fp_comp): Update.\n+\t  (push_fpul, movsf_ie, fpu_switch, toggle_sz, toggle_pr): Update type.\n+\t  (cmpgtsf_t, \"cmpeqsf_t, cmpgtsf_t_i4, cmpeqsf_t_i4): Likewise.\n+\t  (muldf3_i): Likewise.\n+\t  (movsi_i): Split rI08 alternative into two separate alternatives.\n+\t  Update type.\n+\t  (movsi_ie, movsi_i_lowpart): Likewise.\n+\t  (movqi_i): Split ri alternative into two separate alternatives.\n+\t  Update type.\n+\t  * sh1.md (sh1_load_store, sh1_fp): Update.\n+\t  * sh4.md (sh4_store, sh4_mac_gp, fp_arith, fp_double_arith): Update.\n+\t  (mac_mem, sh4_fpscr_toggle): New insn_reservations.\n+\t  * sh4a.md (sh4a_mov, sh4a_load, sh4a_store, sh4a_fp_arith): Update.\n+\t  (sh4a_fp_double_arith): Likewise.\n+\t  * sh4-300.md: New file.\n+\t  * sh.c (sh_handle_option): Handle m4-300* options.\n+\t  (sh_adjust_cost): Fix latency of auto-increments.\n+\t  Handle SH4-300 differently than other SH4s.  Check for new insn types.\n+\t  * sh.h (OVERRIDE_OPTIONS): Initilize sh_branch_cost if it has not\n+\t  been set by an option.\n+\t  * sh.opt (m4-300, m4-100-nofpu, m4-200-nofpu): New options.\n+\t  (m4-300-nofpu, -m4-340, m4-300-single, m4-300-single-only): Likewise.\n+\t  (mbranch-cost=): Likewise.\n+\t  * superh.h (STARTFILE_SPEC): Take -m4-340 into account.\n+\n+\t  * sh.md (mulsf3): Remove special expansion code.\n+\t  (mulsf3_ie): Now a define_insn_and_split.\n+\t  (macsf3): Allow for TARGET_SH4.\n+\n+\t  * sh.md (cbranchsi4, cbranchdi4, cbranchdi4_i): New patterns.\n+\t  * sh.c (prepare_cbranch_operands, expand_cbranchsi4): New functions.\n+\t  (expand_cbranchdi4): Likewise.\n+\t  (sh_rtx_costs): Give lower cost for certain CONST_INT values and for\n+\t  CONST_DOUBLE if the outer code is COMPARE.\n+\t  * sh.h (OPTIMIZATION_OPTIONS): If not optimizing for size, set\n+\t  TARGET_CBRANCHDI4 and TARGET_EXPAND_CBRANCHDI4.\n+\t  (OVERRIDE_OPTIONS): For TARGET_SHMEDIA, clear TARGET_CBRANCHDI4.\n+\t  (LEGITIMATE_CONSTANT_P): Also allow DImode and VOIDmode CONST_DOUBLEs.\n+\t  Remove redundant fp_{zero,one}_operand checks.\n+\t  * sh.opt (mcbranchdi, mexpand-cbranchdi, mcmpeqdi): New options.\n+\t  * sh-protos.h (prepare_cbranch_operands, expand_cbranchsi4): Declare.\n+\t  (expand_cbranchdi4): Likewise.\n+\t2006-04-20  J\"orn Rennecke <joern.rennecke@st.com>\n+\t  * sh.h (LOCAL_ALIGNMENT): Use DATA_ALIGNMENT.\n+\n 2006-11-02  Andrew Pinski  <andrew_pinski@playstation.sony.com>\n \n \t* doc/md.texi (RS6000 constraints): Document H, Z, a, t, and W"}, {"sha": "7aa684434d7e2182be471f572774ccbb46b5a311", "filename": "gcc/config/sh/crt1.asm", "status": "modified", "additions": 51, "deletions": 83, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fcrt1.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fcrt1.asm?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,4 +1,5 @@\n-/* Copyright (C) 2000, 2001, 2003, 2004, 2005 Free Software Foundation, Inc.\n+/* Copyright (C) 2000, 2001, 2003, 2004, 2005, 2006\n+   Free Software Foundation, Inc.\n    This file was pretty much copied from newlib.\n \n This file is part of GCC.\n@@ -894,25 +895,12 @@ ___main:\n \tnop\n #ifdef VBR_SETUP\n ! Exception handlers\t\n-\t.balign 256\n+\t.section .text.vbr, \"ax\"\n vbr_start:\n-\tmov.l 2f, r0     ! load the old vbr setting (if any)\n-\tmov.l @r0, r0\n-\tcmp/eq #0, r0\n-\tbf 1f\n-\t! no previous vbr - jump to own generic handler\n-\tbra handler\n-\tnop\n-1:\t! there was a previous handler - chain them\n-\tjmp @r0\n-\tnop\n-\t.balign 4\n-2:\n-\t.long old_vbr\n \n-\t.balign 256\n+\t.org 0x100\n vbr_100:\n-\t#ifdef PROFILE\n+#ifdef PROFILE\n \t! Note on register usage.\n \t! we use r0..r3 as scratch in this code. If we are here due to a trapa for profiling\n \t! then this is OK as we are just before executing any function code.\n@@ -1017,50 +1005,7 @@ handler_100:\n 2:\t\n \t.long old_vbr\n \n-\t.balign 256\n-vbr_200:\n-\tmov.l 2f, r0     ! load the old vbr setting (if any)\n-\tmov.l @r0, r0\n-\tcmp/eq #0, r0\n-\tbf 1f\n-\t! no previous vbr - jump to own generic handler\n-\tbra handler\n-\tnop\t\n-1:\t! there was a previous handler - chain them\n-\tadd #0x7f, r0\t ! 0x7f\n-\tadd #0x7f, r0\t ! 0xfe\n-\tadd #0x7f, r0\t ! 0x17d\n-\tadd #0x7f, r0    ! 0x1fc\n-\tadd #0x4, r0     ! add 0x200 without corrupting another register\n-\tjmp @r0\n-\tnop\n-\t.balign 4\n-2:\n-\t.long old_vbr\n-\n-\t.balign 256\n-vbr_300:\n-\tmov.l 2f, r0     ! load the old vbr setting (if any)\n-\tmov.l @r0, r0\n-\tcmp/eq #0, r0\n-\tbf 1f\n-\t! no previous vbr - jump to own generic handler\n-\tbra handler\n-\tnop\t\n-1:\t! there was a previous handler - chain them\n-\trotcr r0\n-\trotcr r0\n-\tadd #0x7f, r0\t ! 0x1fc\n-\tadd #0x41, r0\t ! 0x300\n-\trotcl r0\n-\trotcl r0\t ! Add 0x300 without corrupting another register\n-\tjmp @r0\n-\tnop\n-\t.balign 4\n-2:\n-\t.long old_vbr\n-\n-\t.balign 256\t\n+\t.org 0x400\n vbr_400:\t! Should be at vbr+0x400\n \tmov.l 2f, r0     ! load the old vbr setting (if any)\n \tmov.l @r0, r0\n@@ -1103,28 +1048,7 @@ handler:\n \tjmp @r2\n \tnop\n \n-\t.balign 256\n-vbr_500:\n-\tmov.l 2f, r0     ! load the old vbr setting (if any)\n-\tmov.l @r0, r0\n-\tcmp/eq #0, r0\n-\t! no previous vbr - jump to own generic handler\n-\tbt handler\n-\t! there was a previous handler - chain them\n-\trotcr r0\n-\trotcr r0\n-\tadd #0x7f, r0\t ! 0x1fc\n-\tadd #0x7f, r0\t ! 0x3f8\n-\tadd #0x42, r0\t ! 0x500\n-\trotcl r0\n-\trotcl r0\t ! Add 0x500 without corrupting another register\n-\tjmp @r0\n-\tnop\n-\t.balign 4\n-2:\n-\t.long old_vbr\n-\n-\t.balign 256\n+\t.org 0x600\n vbr_600:\n #ifdef PROFILE\t\n \t! Should be at vbr+0x600\n@@ -1140,11 +1064,48 @@ vbr_600:\n \tmov.l\tr6,@-r15\n \tmov.l\tr7,@-r15\n \tsts.l\tpr,@-r15\n+\tsts.l\tmach,@-r15\n+\tsts.l\tmacl,@-r15\n+#if defined(__SH_FPU_ANY__)\n+\t! Save fpul and fpscr, save fr0-fr7 in 64 bit mode\n+\t! and set the pervading precision for the timer_handler\n+\tmov\t#0,r0\n+\tsts.l\tfpul,@-r15\n+\tsts.l\tfpscr,@-r15\n+\tlds\tr0,fpscr\t! Clear fpscr\n+\tfmov\tfr0,@-r15\n+\tfmov\tfr1,@-r15\n+\tfmov\tfr2,@-r15\n+\tfmov\tfr3,@-r15\n+\tmov.l\tpervading_precision_k,r0\n+\tfmov\tfr4,@-r15\n+\tfmov\tfr5,@-r15\n+\tmov.l\t@r0,r0\n+\tfmov\tfr6,@-r15\n+\tfmov\tfr7,@-r15\n+\tlds\tr0,fpscr\n+#endif /* __SH_FPU_ANY__ */\n \t! Pass interrupted pc to timer_handler as first parameter (r4).\n \tstc    spc, r4\n \tmov.l timer_handler_k, r0\n \tjsr @r0\n \tnop\n+#if defined(__SH_FPU_ANY__)\n+\tmov\t#0,r0\n+\tlds\tr0,fpscr\t! Clear the fpscr\n+\tfmov\t@r15+,fr7\n+\tfmov\t@r15+,fr6\n+\tfmov\t@r15+,fr5\n+\tfmov\t@r15+,fr4\n+\tfmov\t@r15+,fr3\n+\tfmov\t@r15+,fr2\n+\tfmov\t@r15+,fr1\n+\tfmov\t@r15+,fr0\n+\tlds.l\t@r15+,fpscr\n+\tlds.l\t@r15+,fpul\n+#endif /* __SH_FPU_ANY__ */\n+\tlds.l @r15+,macl\n+\tlds.l @r15+,mach\n \tlds.l @r15+,pr\n \tmov.l @r15+,r7\n \tmov.l @r15+,r6\n@@ -1157,6 +1118,13 @@ vbr_600:\n \tstc sgr, r15    ! Restore r15, destroyed by this sequence. \n \trte\n \tnop\n+#if defined(__SH_FPU_ANY__)\n+\t.balign 4\n+pervading_precision_k:\n+#define CONCAT1(A,B) A##B\n+#define CONCAT(A,B) CONCAT1(A,B)\n+\t.long CONCAT(__USER_LABEL_PREFIX__,__fpscr_values)+4\n+#endif\n #else\n \tmov.l 2f, r0     ! Load the old vbr setting (if any).\n \tmov.l @r0, r0"}, {"sha": "0296269bb521b8325ac80032cc8d6a6e347e315a", "filename": "gcc/config/sh/divcost-analysis", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fdivcost-analysis", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fdivcost-analysis", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fdivcost-analysis?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -38,12 +38,17 @@ div_r8_neg -> div_r8_neg_end: 18\n div_le128_neg -> div_by_1_neg: 4\n div_le128_neg -> rts          18\n \n-                    absolute divisor range:\n+         sh4-200    absolute divisor range:\n             1  [2..128]  [129..64K) [64K..|divident|/256] >=64K,>|divident/256|\n udiv       18     22         38            32                   30\n sdiv pos:  20     24         41            35                   32\n sdiv neg:  15     25         42            36                   33\n \n+         sh4-300    absolute divisor range:\n+                 8 bit      16 bit       24 bit              > 24 bit\n+udiv              15         35            28                   25\n+sdiv              14         36            34                   31\n+\n \n fp-based:\n "}, {"sha": "448b0b8af8e0d3ac24256db08989839019a32d15", "filename": "gcc/config/sh/divtab-sh4-300.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fdivtab-sh4-300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fdivtab-sh4-300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fdivtab-sh4-300.c?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -0,0 +1,81 @@\n+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* Calculate division table for ST40-300 integer division\n+   Contributed by Joern Rennecke\n+   joern.rennecke@st.com  */\n+\n+#include <stdio.h>\n+#include <math.h>\n+\n+int\n+main ()\n+{\n+  int i, j;\n+  double q, r, err, max_err = 0, max_s_err = 0;\n+\n+  puts(\"/* This table has been generated by divtab-sh4.c.  */\");\n+  puts (\"\\t.balign 4\");\n+  for (i = -128; i < 128; i++)\n+    {\n+      int n = 0;\n+      if (i == 0)\n+\t{\n+\t  /* output some dummy number for 1/0.  */\n+\t  puts (\"LOCAL(div_table_clz):\\n\\t.byte\\t0\");\n+\t  continue;\n+\t}\n+      for (j = i < 0 ? -i : i; j < 128; j += j)\n+\tn++;\n+      printf (\"\\t.byte\\t%d\\n\", n - 7);\n+    }\n+  puts(\"\\\n+/* 1/-128 .. 1/127, normalized.  There is an implicit leading 1 in bit 32,\\n\\\n+   or in bit 33 for powers of two.  */\\n\\\n+\t.balign 4\");\n+  for (i = -128; i < 128; i++)\n+    {\n+      if (i == 0)\n+\t{\n+\t  puts (\"LOCAL(div_table_inv):\\n\\t.long\\t0x0\");\n+\t  continue;\n+\t}\n+      j = i < 0 ? -i : i;\n+      while (j < 64)\n+\tj += j;\n+      q = 4.*(1<<30)*128/j;\n+      r = ceil (q);\n+      printf (\"\\t.long\\t0x%X\\n\", (unsigned) r);\n+      err = r - q;\n+      if (err > max_err)\n+\tmax_err = err;\n+      err = err * j / 128;\n+      if (err > max_s_err)\n+\tmax_s_err = err;\n+    }\n+  printf (\"\\t/* maximum error: %f scaled: %f*/\\n\", max_err, max_s_err);\n+  exit (0);\n+}"}, {"sha": "0d817cacf850dcd5f71a594e6e3cfeccb0dca822", "filename": "gcc/config/sh/embed-elf.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fembed-elf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fembed-elf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fembed-elf.h?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -32,6 +32,7 @@ Boston, MA 02110-1301, USA.  */\n #define LIBGCC_SPEC \"%{!shared: \\\n   %{m4-100*:-lic_invalidate_array_4-100} \\\n   %{m4-200*:-lic_invalidate_array_4-200} \\\n+  %{m4-300*|-m4-340:-lic_invalidate_array_4a %{!Os: -lgcc-4-300}} \\\n   %{m4a*:-lic_invalidate_array_4a}} \\\n   %{Os: -lgcc-Os-4-200} \\\n   -lgcc \\"}, {"sha": "b07912425afb05d55cff0c5146b1d6b7b7553844", "filename": "gcc/config/sh/lib1funcs-4-300.asm", "status": "added", "additions": 938, "deletions": 0, "changes": 938, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Flib1funcs-4-300.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Flib1funcs-4-300.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs-4-300.asm?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -0,0 +1,938 @@\n+/* Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n+\n+This file is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file into combinations with other programs,\n+and to distribute those combinations without any restriction coming\n+from the use of this file.  (The General Public License restrictions\n+do apply in other respects; for example, they cover modification of\n+the file, and distribution when not linked into a combine\n+executable.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* libgcc routines for the STMicroelectronics ST40-300 CPU.\n+   Contributed by J\"orn Rennecke joern.rennecke@st.com.  */\n+\n+#include \"lib1funcs.h\"\n+\n+#ifdef L_div_table\n+#if defined (__SH3__) || defined (__SH3E__) || defined (__SH4__) || defined (__SH4_SINGLE__) || defined (__SH4_SINGLE_ONLY__) || defined (__SH4_NOFPU__)\n+/* This code used shld, thus is not suitable for SH1 / SH2.  */\n+\n+/* Signed / unsigned division without use of FPU, optimized for SH4-300.\n+   Uses a lookup table for divisors in the range -128 .. +127, and\n+   div1 with case distinction for larger divisors in three more ranges.\n+   The code is lumped together with the table to allow the use of mova.  */\n+#ifdef __LITTLE_ENDIAN__\n+#define L_LSB 0\n+#define L_LSWMSB 1\n+#define L_MSWLSB 2\n+#else\n+#define L_LSB 3\n+#define L_LSWMSB 2\n+#define L_MSWLSB 1\n+#endif\n+\n+\t.global\tGLOBAL(udivsi3_i4i)\n+\t.global\tGLOBAL(sdivsi3_i4i)\n+\tFUNC(GLOBAL(udivsi3_i4i))\n+\tFUNC(GLOBAL(sdivsi3_i4i))\n+\n+\t.balign 4\n+LOCAL(div_ge8m): ! 10 cycles up to here\n+\trotcr r1 ! signed shift must use original sign from r4\n+\tdiv0s r5,r4\n+\tmov #24,r7\n+\tshld r7,r6\n+\tshad r0,r1\n+\trotcl r6\n+\tdiv1 r5,r1\n+\tswap.w r5,r0 ! detect -0x80000000 : 0x800000\n+\trotcl r6\n+\tswap.w r4,r7\n+\tdiv1 r5,r1\n+\tswap.b r7,r7\n+\trotcl r6\n+\tor r7,r0\n+\tdiv1 r5,r1\n+\tswap.w r0,r7\n+\trotcl r6\n+\tor r7,r0\n+\tdiv1 r5,r1\n+\tadd #-0x80,r0\n+\trotcl r6\n+\textu.w r0,r0\n+\tdiv1 r5,r1\n+\tneg r0,r0\n+\trotcl r6\n+\tswap.w r0,r0\n+\tdiv1 r5,r1\n+\tmov.l @r15+,r7\n+\tand r6,r0\n+\trotcl r6\n+\tdiv1 r5,r1\n+\tshll2 r0\n+\trotcl r6\n+\texts.b r0,r0\n+\tdiv1 r5,r1\n+\tswap.w r0,r0\n+\texts.w r0,r1\n+\texts.b r6,r0\n+\tmov.l @r15+,r6\n+\trotcl r0\n+\trts\n+\tsub r1,r0\n+\t! 31 cycles up to here\n+\n+\t.balign 4\n+LOCAL(udiv_ge64k): ! 3 cycles up to here\n+\tmov r4,r0\n+\tshlr8 r0\n+\tdiv0u\n+\tcmp/hi r0,r5\n+\tbt LOCAL(udiv_r8)\n+\tmov.l r5,@-r15\n+\tshll8 r5\n+\t! 7 cycles up to here\n+\t.rept 8\n+\tdiv1 r5,r0\n+\t.endr\n+\textu.b r4,r1 ! 15 cycles up to here\n+\textu.b r0,r6\n+\txor r1,r0\n+\txor r6,r0\n+\tswap.b r6,r6\n+\t.rept 8\n+\tdiv1 r5,r0\n+\t.endr ! 25 cycles up to here\n+\textu.b r0,r0\n+\tmov.l @r15+,r5\n+\tor r6,r0\n+\tmov.l @r15+,r6\n+\trts\n+\trotcl r0 ! 28 cycles up to here\n+\n+\t.balign 4\n+LOCAL(udiv_r8): ! 6 cycles up to here\n+\tmov.l r4,@-r15\n+\tshll16 r4\n+\tshll8 r4\n+\t!\n+\tshll r4\n+\tmov r0,r1\n+\tdiv1 r5,r1\n+\tmov r4,r0\n+\trotcl r0\n+\tmov.l @r15+,r4\n+\tdiv1 r5,r1\n+\t! 12 cycles up to here\n+\t.rept 6\n+\trotcl r0; div1 r5,r1\n+\t.endr\n+\tmov.l @r15+,r6 ! 24 cycles up to here\n+\trts\n+\trotcl r0\n+\n+\t.balign 4\n+LOCAL(div_ge32k): ! 6 cycles up to here\n+\tmov.l r7,@-r15\n+\tswap.w r5,r6\n+\texts.b r6,r7\n+\texts.w r6,r6\n+\tcmp/eq r6,r7\n+\textu.b r1,r6\n+\tbf/s LOCAL(div_ge8m)\n+\tcmp/hi r1,r4 ! copy sign bit of r4 into T\n+\trotcr r1 ! signed shift must use original sign from r4\n+\tdiv0s r5,r4\n+\tshad r0,r1\n+\tshll8 r5\n+\tdiv1 r5,r1\n+\tmov r5,r7 ! detect r4 == 0x80000000 && r5 == 0x8000(00)\n+\tdiv1 r5,r1\n+\tshlr8 r7\n+\tdiv1 r5,r1\n+\tswap.w r4,r0\n+\tdiv1 r5,r1\n+\tswap.b r0,r0\n+\tdiv1 r5,r1\n+\tor r0,r7\n+\tdiv1 r5,r1\n+\tadd #-80,r7\n+\tdiv1 r5,r1\n+\tswap.w r7,r0\n+\tdiv1 r5,r1\n+\tor r0,r7\n+\textu.b r1,r0\n+\txor r6,r1\n+\txor r0,r1\n+\texts.b r0,r0\n+\tdiv1 r5,r1\n+\textu.w r7,r7\n+\tdiv1 r5,r1\n+\tneg r7,r7 ! upper 16 bit of r7 == 0 if r4 == 0x80000000 && r5 == 0x8000\n+\tdiv1 r5,r1\n+\tand r0,r7\n+\tdiv1 r5,r1\n+\tswap.w r7,r7 ! 26 cycles up to here.\n+\tdiv1 r5,r1\n+\tshll8 r0\n+\tdiv1 r5,r1\n+\texts.w r7,r7\n+\tdiv1 r5,r1\n+\tadd r0,r0\n+\tdiv1 r5,r1\n+\tsub r7,r0\n+\textu.b r1,r1\n+\tmov.l @r15+,r7\n+\trotcl r1\n+\tmov.l @r15+,r6\n+\tadd r1,r0\n+\tmov #-8,r1\n+\trts\n+\tshad r1,r5 ! 34 cycles up to here\n+\n+\t.balign 4\n+GLOBAL(udivsi3_i4i):\n+\tmov.l r6,@-r15\n+\textu.w r5,r6\n+\tcmp/eq r5,r6\n+\tmov #0x7f,r0\n+\tbf LOCAL(udiv_ge64k)\n+\tcmp/hi r0,r5\n+\tbf LOCAL(udiv_le128)\n+\tmov r4,r1\n+\tshlr8 r1\n+\tdiv0u\n+\tshlr r1\n+\tshll16 r6\n+\tdiv1 r6,r1\n+\textu.b r4,r0 ! 7 cycles up to here\n+\t.rept 8\n+\tdiv1 r6,r1\n+\t.endr     ! 15 cycles up to here\n+\txor r1,r0 ! xor dividend with result lsb\n+\t.rept 6\n+\tdiv1 r6,r1\n+\t.endr\n+\tmov.l r7,@-r15 ! 21 cycles up to here\n+\tdiv1 r6,r1\n+\textu.b r0,r7\n+\tdiv1 r6,r1\n+\tshll8 r7\n+\textu.w r1,r0\n+\txor r7,r1 ! replace lsb of result with lsb of dividend\n+\tdiv1 r6,r1\n+\tmov #0,r7\n+\tdiv1 r6,r1\n+\t!\n+\tdiv1 r6,r1\n+\tbra LOCAL(div_end)\n+\tdiv1 r6,r1 ! 28 cycles up to here\n+\n+\t/* This is link-compatible with a GLOBAL(sdivsi3) call,\n+\t   but we effectively clobber only r1, macl and mach  */\n+        /* Because negative quotients are calculated as one's complements,\n+\t   -0x80000000 divided by the smallest positive number of a number\n+\t   range (0x80, 0x8000, 0x800000) causes saturation in the one's\n+           complement representation, and we have to suppress the\n+\t   one's -> two's complement adjustment.  Since positive numbers\n+\t   don't get such an adjustment, it's OK to also compute one's -> two's\n+\t   complement adjustment suppression for a dividend of 0.  */\n+\t.balign 4\n+GLOBAL(sdivsi3_i4i):\n+\tmov.l r6,@-r15\n+\texts.b r5,r6\n+\tcmp/eq r5,r6\n+\tmov #-1,r1\n+\tbt/s LOCAL(div_le128)\n+\tcmp/pz r4\n+\taddc r4,r1\n+\texts.w r5,r6\n+\tcmp/eq r5,r6\n+\tmov #-7,r0\n+\tbf/s LOCAL(div_ge32k)\n+\tcmp/hi r1,r4 ! copy sign bit of r4 into T\n+\trotcr r1\n+\tshll16 r6  ! 7 cycles up to here\n+\tshad r0,r1\n+\tdiv0s r5,r4\n+\tdiv1 r6,r1\n+\tmov.l r7,@-r15\n+\tdiv1 r6,r1\n+\tmov r4,r0 ! re-compute adjusted dividend\n+\tdiv1 r6,r1\n+\tmov #-31,r7\n+\tdiv1 r6,r1\n+\tshad r7,r0\n+\tdiv1 r6,r1\n+\tadd r4,r0 ! adjusted dividend\n+\tdiv1 r6,r1\n+\tmov.l r8,@-r15\n+\tdiv1 r6,r1\n+\tswap.w r4,r8 ! detect special case r4 = 0x80000000, r5 = 0x80\n+\tdiv1 r6,r1\n+\tswap.b r8,r8\n+\txor r1,r0 ! xor dividend with result lsb\n+\tdiv1 r6,r1\n+\tdiv1 r6,r1\n+\tor r5,r8\n+\tdiv1 r6,r1\n+\tadd #-0x80,r8 ! r8 is 0 iff there is a match\n+\tdiv1 r6,r1\n+\tswap.w r8,r7 ! or upper 16 bits...\n+\tdiv1 r6,r1\n+\tor r7,r8 !...into lower 16 bits\n+\tdiv1 r6,r1\n+\textu.w r8,r8\n+\tdiv1 r6,r1\n+\textu.b r0,r7\n+\tdiv1 r6,r1\n+\tshll8 r7\n+\texts.w r1,r0\n+\txor r7,r1 ! replace lsb of result with lsb of dividend\n+\tdiv1 r6,r1\n+\tneg r8,r8 ! upper 16 bits of r8 are now 0xffff iff we want end adjm.\n+\tdiv1 r6,r1\n+\tand r0,r8\n+\tdiv1 r6,r1\n+\tswap.w r8,r7\n+\tdiv1 r6,r1\n+\tmov.l @r15+,r8 ! 58 insns, 29 cycles up to here\n+LOCAL(div_end):\n+\tdiv1 r6,r1\n+\tshll8 r0\n+\tdiv1 r6,r1\n+\texts.w r7,r7\n+\tdiv1 r6,r1\n+\tadd r0,r0\n+\tdiv1 r6,r1\n+\tsub r7,r0\n+\textu.b r1,r1\n+\tmov.l @r15+,r7\n+\trotcl r1\n+\tmov.l @r15+,r6\n+\trts\n+\tadd r1,r0\n+\n+\t.balign 4\n+LOCAL(udiv_le128): ! 4 cycles up to here (or 7 for mispredict)\n+\tmova LOCAL(div_table_inv),r0\n+\tshll2 r6\n+\tmov.l @(r0,r6),r1\n+\tmova LOCAL(div_table_clz),r0\n+\tlds r4,mach\n+\t!\n+\t!\n+\t!\n+\ttst r1,r1\n+\t!\n+\tbt 0f\n+\tdmulu.l r1,r4\n+0:\tmov.b @(r0,r5),r1\n+\tclrt\n+\t!\n+\t!\n+\tsts mach,r0\n+\taddc r4,r0\n+\trotcr r0\n+\tmov.l @r15+,r6\n+\trts\n+\tshld r1,r0\n+\n+\t.balign 4\n+LOCAL(div_le128): ! 3 cycles up to here (or 6 for mispredict)\n+\tmova LOCAL(div_table_inv),r0\n+\tshll2 r6\n+\tmov.l @(r0,r6),r1\n+\tmova LOCAL(div_table_clz),r0\n+\tneg r4,r6\n+\tbf 0f\n+\tmov r4,r6\n+0:\tlds r6,mach\n+\ttst r1,r1\n+\tbt 0f\n+\tdmulu.l r1,r6\n+0:\tdiv0s r4,r5\n+\tmov.b @(r0,r5),r1\n+\tbt/s LOCAL(le128_neg)\n+\tclrt\n+\t!\n+\tsts mach,r0\n+\taddc r6,r0\n+\trotcr r0\n+\tmov.l @r15+,r6\n+\trts\n+\tshld r1,r0\n+\n+/* Could trap divide by zero for the cost of one cycle more mispredict penalty:\n+...\n+\tdmulu.l r1,r6\n+0:\tdiv0s r4,r5\n+\tbt/s LOCAL(le128_neg)\n+\ttst r5,r5\n+\tbt LOCAL(div_by_zero)\n+\tmov.b @(r0,r5),r1\n+\tsts mach,r0\n+\taddc r6,r0\n+...\n+LOCAL(div_by_zero):\n+\ttrapa #\n+\t.balign 4\n+LOCAL(le128_neg):\n+\tbt LOCAL(div_by_zero)\n+\tmov.b @(r0,r5),r1\n+\tsts mach,r0\n+\taddc r6,r0\n+...  */\n+\n+\t.balign 4\n+LOCAL(le128_neg):\n+\tsts mach,r0\n+\taddc r6,r0\n+\trotcr r0\n+\tmov.l @r15+,r6\n+\tshad r1,r0\n+\trts\n+\tneg r0,r0\n+\tENDFUNC(GLOBAL(udivsi3_i4i))\n+\tENDFUNC(GLOBAL(sdivsi3_i4i))\n+\n+/* This table has been generated by divtab-sh4.c.  */\n+\t.balign 4\n+\t.byte\t-7\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-1\n+\t.byte\t-1\n+\t.byte\t0\n+LOCAL(div_table_clz):\n+\t.byte\t0\n+\t.byte\t0\n+\t.byte\t-1\n+\t.byte\t-1\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-2\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-3\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-4\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-5\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+\t.byte\t-6\n+/* 1/-128 .. 1/127, normalized.  There is an implicit leading 1 in bit 32,\n+   or in bit 33 for powers of two.  */\n+\t.balign 4\n+\t.long   0x0\n+\t.long\t0x2040811\n+\t.long\t0x4104105\n+\t.long\t0x624DD30\n+\t.long\t0x8421085\n+\t.long\t0xA6810A7\n+\t.long\t0xC9714FC\n+\t.long\t0xECF56BF\n+\t.long\t0x11111112\n+\t.long\t0x135C8114\n+\t.long\t0x15B1E5F8\n+\t.long\t0x18118119\n+\t.long\t0x1A7B9612\n+\t.long\t0x1CF06ADB\n+\t.long\t0x1F7047DD\n+\t.long\t0x21FB7813\n+\t.long\t0x24924925\n+\t.long\t0x27350B89\n+\t.long\t0x29E4129F\n+\t.long\t0x2C9FB4D9\n+\t.long\t0x2F684BDB\n+\t.long\t0x323E34A3\n+\t.long\t0x3521CFB3\n+\t.long\t0x38138139\n+\t.long\t0x3B13B13C\n+\t.long\t0x3E22CBCF\n+\t.long\t0x41414142\n+\t.long\t0x446F8657\n+\t.long\t0x47AE147B\n+\t.long\t0x4AFD6A06\n+\t.long\t0x4E5E0A73\n+\t.long\t0x51D07EAF\n+\t.long\t0x55555556\n+\t.long\t0x58ED2309\n+\t.long\t0x5C9882BA\n+\t.long\t0x60581606\n+\t.long\t0x642C8591\n+\t.long\t0x68168169\n+\t.long\t0x6C16C16D\n+\t.long\t0x702E05C1\n+\t.long\t0x745D1746\n+\t.long\t0x78A4C818\n+\t.long\t0x7D05F418\n+\t.long\t0x81818182\n+\t.long\t0x86186187\n+\t.long\t0x8ACB90F7\n+\t.long\t0x8F9C18FA\n+\t.long\t0x948B0FCE\n+\t.long\t0x9999999A\n+\t.long\t0x9EC8E952\n+\t.long\t0xA41A41A5\n+\t.long\t0xA98EF607\n+\t.long\t0xAF286BCB\n+\t.long\t0xB4E81B4F\n+\t.long\t0xBACF914D\n+\t.long\t0xC0E07039\n+\t.long\t0xC71C71C8\n+\t.long\t0xCD856891\n+\t.long\t0xD41D41D5\n+\t.long\t0xDAE6076C\n+\t.long\t0xE1E1E1E2\n+\t.long\t0xE9131AC0\n+\t.long\t0xF07C1F08\n+\t.long\t0xF81F81F9\n+\t.long\t0x0\n+\t.long\t0x4104105\n+\t.long\t0x8421085\n+\t.long\t0xC9714FC\n+\t.long\t0x11111112\n+\t.long\t0x15B1E5F8\n+\t.long\t0x1A7B9612\n+\t.long\t0x1F7047DD\n+\t.long\t0x24924925\n+\t.long\t0x29E4129F\n+\t.long\t0x2F684BDB\n+\t.long\t0x3521CFB3\n+\t.long\t0x3B13B13C\n+\t.long\t0x41414142\n+\t.long\t0x47AE147B\n+\t.long\t0x4E5E0A73\n+\t.long\t0x55555556\n+\t.long\t0x5C9882BA\n+\t.long\t0x642C8591\n+\t.long\t0x6C16C16D\n+\t.long\t0x745D1746\n+\t.long\t0x7D05F418\n+\t.long\t0x86186187\n+\t.long\t0x8F9C18FA\n+\t.long\t0x9999999A\n+\t.long\t0xA41A41A5\n+\t.long\t0xAF286BCB\n+\t.long\t0xBACF914D\n+\t.long\t0xC71C71C8\n+\t.long\t0xD41D41D5\n+\t.long\t0xE1E1E1E2\n+\t.long\t0xF07C1F08\n+\t.long\t0x0\n+\t.long\t0x8421085\n+\t.long\t0x11111112\n+\t.long\t0x1A7B9612\n+\t.long\t0x24924925\n+\t.long\t0x2F684BDB\n+\t.long\t0x3B13B13C\n+\t.long\t0x47AE147B\n+\t.long\t0x55555556\n+\t.long\t0x642C8591\n+\t.long\t0x745D1746\n+\t.long\t0x86186187\n+\t.long\t0x9999999A\n+\t.long\t0xAF286BCB\n+\t.long\t0xC71C71C8\n+\t.long\t0xE1E1E1E2\n+\t.long\t0x0\n+\t.long\t0x11111112\n+\t.long\t0x24924925\n+\t.long\t0x3B13B13C\n+\t.long\t0x55555556\n+\t.long\t0x745D1746\n+\t.long\t0x9999999A\n+\t.long\t0xC71C71C8\n+\t.long\t0x0\n+\t.long\t0x24924925\n+\t.long\t0x55555556\n+\t.long\t0x9999999A\n+\t.long\t0x0\n+\t.long\t0x55555556\n+\t.long\t0x0\n+\t.long\t0x0\n+LOCAL(div_table_inv):\n+\t.long\t0x0\n+\t.long\t0x0\n+\t.long\t0x0\n+\t.long\t0x55555556\n+\t.long\t0x0\n+\t.long\t0x9999999A\n+\t.long\t0x55555556\n+\t.long\t0x24924925\n+\t.long\t0x0\n+\t.long\t0xC71C71C8\n+\t.long\t0x9999999A\n+\t.long\t0x745D1746\n+\t.long\t0x55555556\n+\t.long\t0x3B13B13C\n+\t.long\t0x24924925\n+\t.long\t0x11111112\n+\t.long\t0x0\n+\t.long\t0xE1E1E1E2\n+\t.long\t0xC71C71C8\n+\t.long\t0xAF286BCB\n+\t.long\t0x9999999A\n+\t.long\t0x86186187\n+\t.long\t0x745D1746\n+\t.long\t0x642C8591\n+\t.long\t0x55555556\n+\t.long\t0x47AE147B\n+\t.long\t0x3B13B13C\n+\t.long\t0x2F684BDB\n+\t.long\t0x24924925\n+\t.long\t0x1A7B9612\n+\t.long\t0x11111112\n+\t.long\t0x8421085\n+\t.long\t0x0\n+\t.long\t0xF07C1F08\n+\t.long\t0xE1E1E1E2\n+\t.long\t0xD41D41D5\n+\t.long\t0xC71C71C8\n+\t.long\t0xBACF914D\n+\t.long\t0xAF286BCB\n+\t.long\t0xA41A41A5\n+\t.long\t0x9999999A\n+\t.long\t0x8F9C18FA\n+\t.long\t0x86186187\n+\t.long\t0x7D05F418\n+\t.long\t0x745D1746\n+\t.long\t0x6C16C16D\n+\t.long\t0x642C8591\n+\t.long\t0x5C9882BA\n+\t.long\t0x55555556\n+\t.long\t0x4E5E0A73\n+\t.long\t0x47AE147B\n+\t.long\t0x41414142\n+\t.long\t0x3B13B13C\n+\t.long\t0x3521CFB3\n+\t.long\t0x2F684BDB\n+\t.long\t0x29E4129F\n+\t.long\t0x24924925\n+\t.long\t0x1F7047DD\n+\t.long\t0x1A7B9612\n+\t.long\t0x15B1E5F8\n+\t.long\t0x11111112\n+\t.long\t0xC9714FC\n+\t.long\t0x8421085\n+\t.long\t0x4104105\n+\t.long\t0x0\n+\t.long\t0xF81F81F9\n+\t.long\t0xF07C1F08\n+\t.long\t0xE9131AC0\n+\t.long\t0xE1E1E1E2\n+\t.long\t0xDAE6076C\n+\t.long\t0xD41D41D5\n+\t.long\t0xCD856891\n+\t.long\t0xC71C71C8\n+\t.long\t0xC0E07039\n+\t.long\t0xBACF914D\n+\t.long\t0xB4E81B4F\n+\t.long\t0xAF286BCB\n+\t.long\t0xA98EF607\n+\t.long\t0xA41A41A5\n+\t.long\t0x9EC8E952\n+\t.long\t0x9999999A\n+\t.long\t0x948B0FCE\n+\t.long\t0x8F9C18FA\n+\t.long\t0x8ACB90F7\n+\t.long\t0x86186187\n+\t.long\t0x81818182\n+\t.long\t0x7D05F418\n+\t.long\t0x78A4C818\n+\t.long\t0x745D1746\n+\t.long\t0x702E05C1\n+\t.long\t0x6C16C16D\n+\t.long\t0x68168169\n+\t.long\t0x642C8591\n+\t.long\t0x60581606\n+\t.long\t0x5C9882BA\n+\t.long\t0x58ED2309\n+\t.long\t0x55555556\n+\t.long\t0x51D07EAF\n+\t.long\t0x4E5E0A73\n+\t.long\t0x4AFD6A06\n+\t.long\t0x47AE147B\n+\t.long\t0x446F8657\n+\t.long\t0x41414142\n+\t.long\t0x3E22CBCF\n+\t.long\t0x3B13B13C\n+\t.long\t0x38138139\n+\t.long\t0x3521CFB3\n+\t.long\t0x323E34A3\n+\t.long\t0x2F684BDB\n+\t.long\t0x2C9FB4D9\n+\t.long\t0x29E4129F\n+\t.long\t0x27350B89\n+\t.long\t0x24924925\n+\t.long\t0x21FB7813\n+\t.long\t0x1F7047DD\n+\t.long\t0x1CF06ADB\n+\t.long\t0x1A7B9612\n+\t.long\t0x18118119\n+\t.long\t0x15B1E5F8\n+\t.long\t0x135C8114\n+\t.long\t0x11111112\n+\t.long\t0xECF56BF\n+\t.long\t0xC9714FC\n+\t.long\t0xA6810A7\n+\t.long\t0x8421085\n+\t.long\t0x624DD30\n+\t.long\t0x4104105\n+\t.long\t0x2040811\n+\t/* maximum error: 0.987342 scaled: 0.921875*/\n+\n+#endif /* SH3 / SH4 */\n+\n+#endif /* L_div_table */"}, {"sha": "e142b1cee684a875735ce9f541373aeebf68824e", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for Renesas / SuperH SH.\n    Copyright (C) 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2003,\n-   2004, 2005\n+   2004, 2005, 2006\n    Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n@@ -69,6 +69,10 @@ extern void print_operand (FILE *, rtx, int);\n extern void output_pic_addr_const (FILE *, rtx);\n extern int expand_block_move (rtx *);\n extern int prepare_move_operands (rtx[], enum machine_mode mode);\n+extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n+\t\t\t\t\t       enum rtx_code comparison);\n+extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);\n+extern bool expand_cbranchdi4 (rtx *operands, enum rtx_code comparison);\n extern void from_compare (rtx *, int);\n extern int shift_insns_rtx (rtx);\n extern void gen_ashift (int, int, rtx);"}, {"sha": "9f733b852f1d9d12260f02d19bc8ff7370f0c19f", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 401, "deletions": 46, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -526,10 +526,15 @@ sh_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n     case OPT_m4:\n     case OPT_m4_100:\n     case OPT_m4_200:\n+    case OPT_m4_300:\n       target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4;\n       return true;\n \n     case OPT_m4_nofpu:\n+    case OPT_m4_100_nofpu:\n+    case OPT_m4_200_nofpu:\n+    case OPT_m4_300_nofpu:\n+    case OPT_m4_340:\n     case OPT_m4_400:\n     case OPT_m4_500:\n       target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_NOFPU;\n@@ -538,12 +543,14 @@ sh_handle_option (size_t code, const char *arg ATTRIBUTE_UNUSED,\n     case OPT_m4_single:\n     case OPT_m4_100_single:\n     case OPT_m4_200_single:\n+    case OPT_m4_300_single:\n       target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_SINGLE;\n       return true;\n \n     case OPT_m4_single_only:\n     case OPT_m4_100_single_only:\n     case OPT_m4_200_single_only:\n+    case OPT_m4_300_single_only:\n       target_flags = (target_flags & ~MASK_ARCH) | SELECT_SH4_SINGLE_ONLY;\n       return true;\n \n@@ -1341,6 +1348,288 @@ prepare_move_operands (rtx operands[], enum machine_mode mode)\n   return 0;\n }\n \n+enum rtx_code\n+prepare_cbranch_operands (rtx *operands, enum machine_mode mode,\n+\t\t\t  enum rtx_code comparison)\n+{\n+  rtx op1;\n+  rtx scratch = NULL_RTX;\n+\n+  if (comparison == CODE_FOR_nothing)\n+    comparison = GET_CODE (operands[0]);\n+  else\n+    scratch = operands[4];\n+  if (GET_CODE (operands[1]) == CONST_INT\n+      && GET_CODE (operands[2]) != CONST_INT)\n+    {\n+      rtx tmp = operands[1];\n+\n+      operands[1] = operands[2];\n+      operands[2] = tmp;\n+      comparison = swap_condition (comparison);\n+    }\n+  if (GET_CODE (operands[2]) == CONST_INT)\n+    {\n+      HOST_WIDE_INT val = INTVAL (operands[2]);\n+      if ((val == -1 || val == -0x81)\n+\t  && (comparison == GT || comparison == LE))\n+\t{\n+\t  comparison = (comparison == GT) ? GE : LT;\n+\t  operands[2] = gen_int_mode (val + 1, mode);\n+\t}\n+      else if ((val == 1 || val == 0x80)\n+\t       && (comparison == GE || comparison == LT))\n+\t{\n+\t  comparison = (comparison == GE) ? GT : LE;\n+\t  operands[2] = gen_int_mode (val - 1, mode);\n+\t}\n+      else if (val == 1 && (comparison == GEU || comparison == LTU))\n+\t{\n+\t  comparison = (comparison == GEU) ? NE : EQ;\n+\t  operands[2] = CONST0_RTX (mode);\n+\t}\n+      else if (val == 0x80 && (comparison == GEU || comparison == LTU))\n+\t{\n+\t  comparison = (comparison == GEU) ? GTU : LEU;\n+\t  operands[2] = gen_int_mode (val - 1, mode);\n+\t}\n+      else if (val == 0 && (comparison == GTU || comparison == LEU))\n+\tcomparison = (comparison == GTU) ? NE : EQ;\n+      else if (mode == SImode\n+\t       && ((val == 0x7fffffff\n+\t\t    && (comparison == GTU || comparison == LEU))\n+\t\t   || ((unsigned HOST_WIDE_INT) val\n+\t\t\t== (unsigned HOST_WIDE_INT) 0x7fffffff + 1\n+\t\t       && (comparison == GEU || comparison == LTU))))\n+\t{\n+\t  comparison = (comparison == GTU || comparison == GEU) ? LT : GE;\n+\t  operands[2] = CONST0_RTX (mode);\n+\t}\n+    }\n+  op1 = operands[1];\n+  if (!no_new_pseudos)\n+    operands[1] = force_reg (mode, op1);\n+  /* When we are handling DImode comparisons, we want to keep constants so\n+     that we can optimize the component comparisons; however, memory loads\n+     are better issued as a whole so that they can be scheduled well.\n+     SImode equality comparisons allow I08 constants, but only when they\n+     compare r0.  Hence, if operands[1] has to be loaded from somewhere else\n+     into a register, that register might as well be r0, and we allow the\n+     constant.  If it is already in a register, this is likely to be\n+     allocatated to a different hard register, thus we load the constant into\n+     a register unless it is zero.  */\n+  if (!REG_P (operands[2])\n+      && (GET_CODE (operands[2]) != CONST_INT\n+\t  || (mode == SImode && operands[2] != CONST0_RTX (SImode)\n+\t      && ((comparison != EQ && comparison != NE)\n+\t\t  || (REG_P (op1) && REGNO (op1) != R0_REG)\n+\t\t  || !CONST_OK_FOR_I08 (INTVAL (operands[2]))))))\n+    {\n+      if (scratch && GET_MODE (scratch) == mode)\n+\t{\n+\t  emit_move_insn (scratch, operands[2]);\n+\t  operands[2] = scratch;\n+\t}\n+      else if (!no_new_pseudos)\n+\toperands[2] = force_reg (mode, operands[2]);\n+    }\n+  return comparison;\n+}\n+\n+void\n+expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int probability)\n+{\n+  rtx (*branch_expander) (rtx) = gen_branch_true;\n+  rtx jump;\n+\n+  comparison = prepare_cbranch_operands (operands, SImode, comparison);\n+  switch (comparison)\n+    {\n+    case NE: case LT: case LE: case LTU: case LEU:\n+      comparison = reverse_condition (comparison);\n+      branch_expander = gen_branch_false;\n+    default: ;\n+    }\n+  emit_insn (gen_rtx_SET (VOIDmode, gen_rtx_REG (SImode, T_REG),\n+                          gen_rtx_fmt_ee (comparison, SImode,\n+                                          operands[1], operands[2])));\n+  jump = emit_jump_insn (branch_expander (operands[3]));\n+  if (probability >= 0)\n+    REG_NOTES (jump)\n+      = gen_rtx_EXPR_LIST (REG_BR_PROB, GEN_INT (probability),\n+                           REG_NOTES (jump));\n+\n+}\n+\n+/* ??? How should we distribute probabilities when more than one branch\n+   is generated.  So far we only have soem ad-hoc observations:\n+   - If the operands are random, they are likely to differ in both parts.\n+   - If comparing items in a hash chain, the operands are random or equal;\n+     operation should be EQ or NE.\n+   - If items are searched in an ordered tree from the root, we can expect\n+     the highpart to be unequal about half of the time; operation should be\n+     an unequality comparison, operands non-constant, and overall probability\n+     about 50%.  Likewise for quicksort.\n+   - Range checks will be often made against constants.  Even if we assume for\n+     simplicity an even distribution of the non-constant operand over a\n+     sub-range here, the same probability could be generated with differently\n+     wide sub-ranges - as long as the ratio of the part of the subrange that\n+     is before the threshold to the part that comes after the threshold stays\n+     the same.  Thus, we can't really tell anything here;\n+     assuming random distribution is at least simple.\n+ */\n+\n+bool\n+expand_cbranchdi4 (rtx *operands, enum rtx_code comparison)\n+{\n+  enum rtx_code msw_taken, msw_skip, lsw_taken;\n+  rtx skip_label;\n+  rtx op1h, op1l, op2h, op2l;\n+  int num_branches;\n+  int prob, rev_prob;\n+  int msw_taken_prob = -1, msw_skip_prob = -1, lsw_taken_prob = -1;\n+\n+  comparison = prepare_cbranch_operands (operands, DImode, comparison);\n+  op1h = gen_highpart_mode (SImode, DImode, operands[1]);\n+  op2h = gen_highpart_mode (SImode, DImode, operands[2]);\n+  op1l = gen_lowpart (SImode, operands[1]);\n+  op2l = gen_lowpart (SImode, operands[2]);\n+  msw_taken = msw_skip = lsw_taken = CODE_FOR_nothing;\n+  prob = split_branch_probability;\n+  rev_prob = REG_BR_PROB_BASE - prob;\n+  switch (comparison)\n+    {\n+    /* ??? Should we use the cmpeqdi_t pattern for equality comparisons?\n+       That costs 1 cycle more when the first branch can be predicted taken,\n+       but saves us mispredicts because only one branch needs prediction.\n+       It also enables generating the cmpeqdi_t-1 pattern.  */\n+    case EQ:\n+      if (TARGET_CMPEQDI_T)\n+\t{\n+\t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n+\t  emit_jump_insn (gen_branch_true (operands[3]));\n+\t  return true;\n+\t}\n+      msw_skip = NE;\n+      lsw_taken = EQ;\n+      if (prob >= 0)\n+\t{\n+\t  /* If we had more precision, we'd use rev_prob - (rev_prob >> 32) .\n+\t   */\n+\t  msw_skip_prob = rev_prob;\n+\t  if (REG_BR_PROB_BASE <= 65535)\n+\t    lsw_taken_prob = prob ? REG_BR_PROB_BASE : 0;\n+\t  else\n+\t    {\n+\t      gcc_assert (HOST_BITS_PER_WIDEST_INT >= 64);\n+\t      lsw_taken_prob\n+\t\t= (prob\n+\t\t   ? (REG_BR_PROB_BASE\n+\t\t      - ((HOST_WIDEST_INT) REG_BR_PROB_BASE * rev_prob\n+\t\t\t / ((HOST_WIDEST_INT) prob << 32)))\n+\t\t   : 0);\n+\t    }\n+\t}\n+      break;\n+    case NE:\n+      if (TARGET_CMPEQDI_T)\n+\t{\n+\t  emit_insn (gen_cmpeqdi_t (operands[1], operands[2]));\n+\t  emit_jump_insn (gen_branch_false (operands[3]));\n+\t  return true;\n+\t}\n+      msw_taken = NE;\n+      lsw_taken_prob = prob;\n+      lsw_taken = NE;\n+      lsw_taken_prob = 0;\n+      break;\n+    case GTU: case GT:\n+      msw_taken = comparison;\n+      if (GET_CODE (op2l) == CONST_INT && INTVAL (op2l) == -1)\n+\tbreak;\n+      if (comparison != GTU || op2h != CONST0_RTX (SImode))\n+\tmsw_skip = swap_condition (msw_taken);\n+      lsw_taken = GTU;\n+      break;\n+    case GEU: case GE:\n+      if (op2l == CONST0_RTX (SImode))\n+\tmsw_taken = comparison;\n+      else\n+\t{\n+\t  msw_taken = comparison == GE ? GT : GTU;\n+\t  msw_skip = swap_condition (msw_taken);\n+\t  lsw_taken = GEU;\n+\t}\n+      break;\n+    case LTU: case LT:\n+      msw_taken = comparison;\n+      if (op2l == CONST0_RTX (SImode))\n+\tbreak;\n+      msw_skip = swap_condition (msw_taken);\n+      lsw_taken = LTU;\n+      break;\n+    case LEU: case LE:\n+      if (GET_CODE (op2l) == CONST_INT && INTVAL (op2l) == -1)\n+\tmsw_taken = comparison;\n+      else\n+\t{\n+\t  lsw_taken = LEU;\n+\t  if (comparison == LE)\n+\t    msw_taken = LT;\n+\t  else if (op2h != CONST0_RTX (SImode))\n+\t    msw_taken = LTU;\n+\t  else\n+\t    break;\n+\t  msw_skip = swap_condition (msw_taken);\n+\t}\n+      break;\n+    default: return false;\n+    }\n+  num_branches = ((msw_taken != CODE_FOR_nothing)\n+\t\t  + (msw_skip != CODE_FOR_nothing)\n+\t\t  + (lsw_taken != CODE_FOR_nothing));\n+  if (comparison != EQ && comparison != NE && num_branches > 1)\n+    {\n+      if (!CONSTANT_P (operands[2])\n+\t  && prob >= (int) (REG_BR_PROB_BASE * 3 / 8U)\n+\t  && prob <= (int) (REG_BR_PROB_BASE * 5 / 8U))\n+\t{\n+\t  msw_taken_prob = prob / 2U;\n+\t  msw_skip_prob\n+\t    = REG_BR_PROB_BASE * rev_prob / (REG_BR_PROB_BASE + rev_prob);\n+\t  lsw_taken_prob = prob;\n+\t}\n+      else\n+\t{\n+\t  msw_taken_prob = prob;\n+\t  msw_skip_prob = REG_BR_PROB_BASE;\n+\t  /* ??? If we have a constant op2h, should we use that when\n+\t     calculating lsw_taken_prob?  */\n+\t  lsw_taken_prob = prob;\n+\t}\n+    }\n+  operands[1] = op1h;\n+  operands[2] = op2h;\n+  operands[4] = NULL_RTX;\n+  if (msw_taken != CODE_FOR_nothing)\n+    expand_cbranchsi4 (operands, msw_taken, msw_taken_prob);\n+  if (msw_skip != CODE_FOR_nothing)\n+    {\n+      rtx taken_label = operands[3];\n+\n+      operands[3] = skip_label = gen_label_rtx ();\n+      expand_cbranchsi4 (operands, msw_skip, msw_skip_prob);\n+      operands[3] = taken_label;\n+    }\n+  operands[1] = op1l;\n+  operands[2] = op2l;\n+  if (lsw_taken != CODE_FOR_nothing)\n+    expand_cbranchsi4 (operands, lsw_taken, lsw_taken_prob);\n+  if (msw_skip != CODE_FOR_nothing)\n+    emit_label (skip_label);\n+  return true;\n+}\n+\n /* Prepare the operands for an scc instruction; make sure that the\n    compare has been done.  */\n rtx\n@@ -1723,6 +2012,12 @@ output_branch (int logic, rtx insn, rtx *operands)\n     }\n }\n \n+/* Output a code sequence for INSN using TEMPLATE with OPERANDS; but before,\n+   fill in operands 9 as a label to the successor insn.\n+   We try to use jump threading where possible.\n+   IF CODE matches the comparison in the IF_THEN_ELSE of a following jump,\n+   we assume the jump is taken.  I.e. EQ means follow jmp and bf, NE means\n+   follow jmp and bt, if the address is in range.  */\n const char *\n output_branchy_insn (enum rtx_code code, const char *template,\n \t\t     rtx insn, rtx *operands)\n@@ -2117,6 +2412,15 @@ sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n       else if ((outer_code == AND || outer_code == IOR || outer_code == XOR)\n \t       && CONST_OK_FOR_K08 (INTVAL (x)))\n         *total = 1;\n+      /* prepare_cmp_insn will force costly constants int registers before\n+\t the cbrach[sd]i4 pattterns can see them, so preserve potentially\n+\t interesting ones not covered by I08 above.  */\n+      else if (outer_code == COMPARE\n+\t       && ((unsigned HOST_WIDE_INT) INTVAL (x)\n+\t\t    == (unsigned HOST_WIDE_INT) 0x7fffffff + 1\n+\t\t    || INTVAL (x) == 0x7fffffff\n+\t\t   || INTVAL (x) == 0x80 || INTVAL (x) == -0x81))\n+        *total = 1;\n       else\n         *total = 8;\n       return true;\n@@ -2135,6 +2439,11 @@ sh_rtx_costs (rtx x, int code, int outer_code, int *total)\n     case CONST_DOUBLE:\n       if (TARGET_SHMEDIA)\n         *total = COSTS_N_INSNS (4);\n+      /* prepare_cmp_insn will force costly constants int registers before\n+\t the cbrachdi4 patttern can see them, so preserve potentially\n+\t interesting ones.  */\n+      else if (outer_code == COMPARE && GET_MODE (x) == DImode)\n+        *total = 1;\n       else\n         *total = 10;\n       return true;\n@@ -8571,23 +8880,32 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n     }\n   else if (REG_NOTE_KIND (link) == 0)\n     {\n-      enum attr_type dep_type, type;\n+      enum attr_type type;\n+      rtx dep_set;\n \n       if (recog_memoized (insn) < 0\n \t  || recog_memoized (dep_insn) < 0)\n \treturn cost;\n \n-      dep_type = get_attr_type (dep_insn);\n-      if (dep_type == TYPE_FLOAD || dep_type == TYPE_PCFLOAD)\n-\tcost--;\n-      if ((dep_type == TYPE_LOAD_SI || dep_type == TYPE_PCLOAD_SI)\n-\t  && (type = get_attr_type (insn)) != TYPE_CALL\n-\t  && type != TYPE_SFUNC)\n-\tcost--;\n+      dep_set = single_set (dep_insn);\n \n+      /* The latency that we specify in the scheduling description refers\n+\t to the actual output, not to an auto-increment register; for that,\n+\t the latency is one.  */\n+      if (dep_set && MEM_P (SET_SRC (dep_set)) && cost > 1)\n+\t{\n+\t  rtx set = single_set (insn);\n+\n+\t  if (set\n+\t      && !reg_mentioned_p (SET_DEST (dep_set), SET_SRC (set))\n+\t      && (!MEM_P (SET_DEST (set))\n+\t\t  || !reg_mentioned_p (SET_DEST (dep_set),\n+\t\t\t\t       XEXP (SET_DEST (set), 0))))\n+\t    cost = 1;\n+\t}\n       /* The only input for a call that is timing-critical is the\n \t function's address.  */\n-      if (GET_CODE(insn) == CALL_INSN)\n+      if (GET_CODE (insn) == CALL_INSN)\n \t{\n \t  rtx call = PATTERN (insn);\n \n@@ -8599,63 +8917,100 @@ sh_adjust_cost (rtx insn, rtx link ATTRIBUTE_UNUSED, rtx dep_insn, int cost)\n \t\t  /* sibcalli_thunk uses a symbol_ref in an unspec.  */\n \t      && (GET_CODE (XEXP (XEXP (call, 0), 0)) == UNSPEC\n \t\t  || ! reg_set_p (XEXP (XEXP (call, 0), 0), dep_insn)))\n-\t    cost = 0;\n+\t    cost -= TARGET_SH4_300 ? 3 : 6;\n \t}\n       /* Likewise, the most timing critical input for an sfuncs call\n \t is the function address.  However, sfuncs typically start\n \t using their arguments pretty quickly.\n-\t Assume a four cycle delay before they are needed.  */\n+\t Assume a four cycle delay for SH4 before they are needed.\n+\t Cached ST40-300 calls are quicker, so assume only a one\n+\t cycle delay there.\n+\t ??? Maybe we should encode the delays till input registers\n+\t are needed by sfuncs into the sfunc call insn.  */\n       /* All sfunc calls are parallels with at least four components.\n \t Exploit this to avoid unnecessary calls to sfunc_uses_reg.  */\n       else if (GET_CODE (PATTERN (insn)) == PARALLEL\n \t       && XVECLEN (PATTERN (insn), 0) >= 4\n \t       && (reg = sfunc_uses_reg (insn)))\n \t{\n \t  if (! reg_set_p (reg, dep_insn))\n-\t    cost -= 4;\n-\t}\n-      /* When the preceding instruction loads the shift amount of\n-\t the following SHAD/SHLD, the latency of the load is increased\n-\t by 1 cycle.  */\n-      else if (TARGET_SH4\n-\t       && get_attr_type (insn) == TYPE_DYN_SHIFT\n-\t       && get_attr_any_int_load (dep_insn) == ANY_INT_LOAD_YES\n-\t       && reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\n-\t\t\t\t\t   XEXP (SET_SRC (single_set (insn)),\n-\t\t\t\t\t\t 1)))\n-\tcost++;\n-      /* When an LS group instruction with a latency of less than\n-\t 3 cycles is followed by a double-precision floating-point\n-\t instruction, FIPR, or FTRV, the latency of the first\n-\t instruction is increased to 3 cycles.  */\n-      else if (cost < 3\n-\t       && get_attr_insn_class (dep_insn) == INSN_CLASS_LS_GROUP\n-\t       && get_attr_dfp_comp (insn) == DFP_COMP_YES)\n-\tcost = 3;\n-      /* The lsw register of a double-precision computation is ready one\n-\t cycle earlier.  */\n-      else if (reload_completed\n-\t       && get_attr_dfp_comp (dep_insn) == DFP_COMP_YES\n-\t       && (use_pat = single_set (insn))\n-\t       && ! regno_use_in (REGNO (SET_DEST (single_set (dep_insn))),\n-\t\t\t\t  SET_SRC (use_pat)))\n-\tcost -= 1;\n-\n-      if (get_attr_any_fp_comp (dep_insn) == ANY_FP_COMP_YES\n-\t  && get_attr_late_fp_use (insn) == LATE_FP_USE_YES)\n-\tcost -= 1;\n+\t    cost -= TARGET_SH4_300 ? 1 : 4;\n+\t}\n+      if (TARGET_HARD_SH4 && !TARGET_SH4_300)\n+\t{\n+\t  enum attr_type dep_type = get_attr_type (dep_insn);\n+\n+\t  if (dep_type == TYPE_FLOAD || dep_type == TYPE_PCFLOAD)\n+\t    cost--;\n+\t  else if ((dep_type == TYPE_LOAD_SI || dep_type == TYPE_PCLOAD_SI)\n+\t\t   && (type = get_attr_type (insn)) != TYPE_CALL\n+\t\t   && type != TYPE_SFUNC)\n+\t    cost--;\n+\t  /* When the preceding instruction loads the shift amount of\n+\t     the following SHAD/SHLD, the latency of the load is increased\n+\t     by 1 cycle.  */\n+\t  if (get_attr_type (insn) == TYPE_DYN_SHIFT\n+\t      && get_attr_any_int_load (dep_insn) == ANY_INT_LOAD_YES\n+\t      && reg_overlap_mentioned_p (SET_DEST (PATTERN (dep_insn)),\n+\t\t\t\t\t  XEXP (SET_SRC (single_set (insn)),\n+\t\t\t\t\t\t1)))\n+\t    cost++;\n+\t  /* When an LS group instruction with a latency of less than\n+\t     3 cycles is followed by a double-precision floating-point\n+\t     instruction, FIPR, or FTRV, the latency of the first\n+\t     instruction is increased to 3 cycles.  */\n+\t  else if (cost < 3\n+\t\t   && get_attr_insn_class (dep_insn) == INSN_CLASS_LS_GROUP\n+\t\t   && get_attr_dfp_comp (insn) == DFP_COMP_YES)\n+\t    cost = 3;\n+\t  /* The lsw register of a double-precision computation is ready one\n+\t     cycle earlier.  */\n+\t  else if (reload_completed\n+\t\t   && get_attr_dfp_comp (dep_insn) == DFP_COMP_YES\n+\t\t   && (use_pat = single_set (insn))\n+\t\t   && ! regno_use_in (REGNO (SET_DEST (single_set (dep_insn))),\n+\t\t\t\t      SET_SRC (use_pat)))\n+\t    cost -= 1;\n+\n+\t  if (get_attr_any_fp_comp (dep_insn) == ANY_FP_COMP_YES\n+\t      && get_attr_late_fp_use (insn) == LATE_FP_USE_YES)\n+\t    cost -= 1;\n+\t}\n+      else if (TARGET_SH4_300)\n+\t{\n+\t  /* Stores need their input register two cycles later.  */\n+\t  if (dep_set && cost >= 1\n+\t      && ((type = get_attr_type (insn)) == TYPE_STORE\n+\t\t  || type == TYPE_PSTORE\n+\t\t  || type == TYPE_FSTORE || type == TYPE_MAC_MEM))\n+\t    {\n+\t      rtx set = single_set (insn);\n+\n+\t      if (!reg_mentioned_p (SET_SRC (set), XEXP (SET_DEST (set), 0))\n+\t\t  && rtx_equal_p (SET_SRC (set), SET_DEST (dep_set)))\n+\t\t{\n+\t\t  cost -= 2;\n+\t\t  /* But don't reduce the cost below 1 if the address depends\n+\t\t     on a side effect of dep_insn.  */\n+\t\t  if (cost < 1\n+\t\t      && modified_in_p (XEXP (SET_DEST (set), 0), dep_insn))\n+\t\t    cost = 1;\n+\t\t}\n+\t    }\n+\t}\n     }\n   /* An anti-dependence penalty of two applies if the first insn is a double\n      precision fadd / fsub / fmul.  */\n-  else if (REG_NOTE_KIND (link) == REG_DEP_ANTI\n+  else if (!TARGET_SH4_300\n+\t   && REG_NOTE_KIND (link) == REG_DEP_ANTI\n \t   && recog_memoized (dep_insn) >= 0\n-\t   && get_attr_type (dep_insn) == TYPE_DFP_ARITH\n+\t   && (get_attr_type (dep_insn) == TYPE_DFP_ARITH\n+\t       || get_attr_type (dep_insn) == TYPE_DFP_MUL)\n \t   /* A lot of alleged anti-flow dependences are fake,\n \t      so check this one is real.  */\n \t   && flow_dependent_p (dep_insn, insn))\n     cost = 2;\n \n-\n   return cost;\n }\n "}, {"sha": "1b659c751357358e41545effd13318d3011f5380", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -274,23 +274,25 @@ do { \\\n #endif\n #if SUPPORT_SH2\n #define SUPPORT_SH3 1\n+#define SUPPORT_SH2A_NOFPU 1\n #endif\n #if SUPPORT_SH3\n #define SUPPORT_SH4_NOFPU 1\n #endif\n #if SUPPORT_SH4_NOFPU\n #define SUPPORT_SH4A_NOFPU 1\n #define SUPPORT_SH4AL 1\n-#define SUPPORT_SH2A_NOFPU 1\n #endif\n \n #if SUPPORT_SH2E\n #define SUPPORT_SH3E 1\n+#define SUPPORT_SH2A_SINGLE_ONLY 1\n #endif\n #if SUPPORT_SH3E\n #define SUPPORT_SH4_SINGLE_ONLY 1\n+#endif\n+#if SUPPORT_SH4_SINGLE_ONLY\n #define SUPPORT_SH4A_SINGLE_ONLY 1\n-#define SUPPORT_SH2A_SINGLE_ONLY 1\n #endif\n \n #if SUPPORT_SH4\n@@ -469,6 +471,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n       target_flags |= MASK_SMALLCODE;\t\t\t\t\t\\\n       sh_div_str = SH_DIV_STR_FOR_SIZE ;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n+  else\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      TARGET_CBRANCHDI4 = 1;\t\t\t\t\t\t\\\n+      TARGET_EXPAND_CBRANCHDI4 = 1;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   /* We can't meaningfully test TARGET_SHMEDIA here, because -m options\t\\\n      haven't been parsed yet, hence we'd read only the default.\t\\\n      sh_target_reg_class will return NO_REGS if this is not SHMEDIA, so\t\\\n@@ -608,6 +615,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t      else\t\t\t\t\t\t\t\\\n \t\tsh_div_strategy = SH_DIV_INV;\t\t\t\t\\\n \t    }\t\t\t\t\t\t\t\t\\\n+\t  TARGET_CBRANCHDI4 = 0;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\t\t\\\n       /* -fprofile-arcs needs a working libgcov .  In unified tree\t\\\n \t configurations with newlib, this requires to configure with\t\\\n@@ -668,6 +676,9 @@ do {\t\t\t\t\t\t\t\t\t\\\n     sh_divsi3_libfunc = \"__sdivsi3_1\";\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\t\\\n     sh_divsi3_libfunc = \"__sdivsi3\";\t\t\t\t\t\\\n+  if (sh_branch_cost == -1)\t\t\t\t\t\t\\\n+    sh_branch_cost\t\t\t\t\t\t\t\\\n+      = TARGET_SH5 ? 1 : ! TARGET_SH2 || TARGET_HARD_SH4 ? 2 : 1;\t\\\n   if (TARGET_FMOVD)\t\t\t\t\t\t\t\\\n     reg_class_from_letter['e' - 'a'] = NO_REGS;\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n@@ -844,7 +855,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ((GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_INT \\\n     || GET_MODE_CLASS (TYPE_MODE (TYPE)) == MODE_COMPLEX_FLOAT) \\\n    ? (unsigned) MIN (BIGGEST_ALIGNMENT, GET_MODE_BITSIZE (TYPE_MODE (TYPE))) \\\n-   : (unsigned) ALIGN)\n+   : (unsigned) DATA_ALIGNMENT(TYPE, ALIGN))\n \n /* Make arrays of chars word-aligned for the same reasons.  */\n #define DATA_ALIGNMENT(TYPE, ALIGN)\t\t\\\n@@ -2288,6 +2299,7 @@ struct sh_args {\n #define CONSTANT_ADDRESS_P(X)\t(GET_CODE (X) == LABEL_REF)\n \n /* Nonzero if the constant value X is a legitimate general operand.  */\n+/* can_store_by_pieces constructs VOIDmode CONST_DOUBLEs.  */\n \n #define LEGITIMATE_CONSTANT_P(X) \\\n   (TARGET_SHMEDIA\t\t\t\t\t\t\t\\\n@@ -2298,7 +2310,7 @@ struct sh_args {\n       || TARGET_SHMEDIA64)\t\t\t\t\t\t\\\n    : (GET_CODE (X) != CONST_DOUBLE\t\t\t\t\t\\\n       || GET_MODE (X) == DFmode || GET_MODE (X) == SFmode\t\t\\\n-      || (TARGET_SH2E && (fp_zero_operand (X) || fp_one_operand (X)))))\n+      || GET_MODE (X) == DImode || GET_MODE (X) == VOIDmode))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class."}, {"sha": "a37c58308e3d580811d2d58d6d06c308a3d5dddf", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 148, "deletions": 64, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -204,7 +204,9 @@\n ;; load_si\tLikewise, SImode variant for general register.\n ;; fload\tLikewise, but load to fp register.\n ;; store\tto memory\n+;; fstore\tfloating point register to memory\n ;; move\t\tgeneral purpose register to register\n+;; movi8\t8 bit immediate to general purpose register\n ;; mt_group\tother sh4 mt instructions\n ;; fmove\tregister to register, floating point\n ;; smpy\t\tword precision integer multiply\n@@ -221,11 +223,15 @@\n ;; sfunc\tspecial function call with known used registers\n ;; call\t\tfunction call\n ;; fp\t\tfloating point\n+;; fpscr_toggle\ttoggle a bit in the fpscr\n ;; fdiv\t\tfloating point divide (or square root)\n ;; gp_fpul\tmove from general purpose register to fpul\n ;; fpul_gp\tmove from fpul to general purpose register\n ;; mac_gp\tmove from mac[lh] to general purpose register\n-;; dfp_arith, dfp_cmp,dfp_conv\n+;; gp_mac\tmove from general purpose register to mac[lh]\n+;; mac_mem\tmove from mac[lh] to memory\n+;; mem_mac\tmove from memory to mac[lh]\n+;; dfp_arith,dfp_mul, fp_cmp,dfp_cmp,dfp_conv\n ;; ftrc_s\tfix_truncsfsi2_i4\n ;; dfdiv\tdouble precision floating point divide (or square root)\n ;; cwb\t\tic_invalidate_line_i\n@@ -263,7 +269,7 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,movua,fsrra,fsca,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n+ \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,fstore,move,movi8,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fpscr_toggle,fdiv,ftrc_s,dfp_arith,dfp_mul,fp_cmp,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,gp_mac,mac_mem,mem_mac,mem_fpscr,gp_fpscr,cwb,movua,fsrra,fsca,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n@@ -279,12 +285,12 @@\n (define_attr \"insn_class\"\n   \"mt_group,ex_group,ls_group,br_group,fe_group,co_group,none\"\n   (cond [(eq_attr \"type\" \"move,mt_group\") (const_string \"mt_group\")\n-         (eq_attr \"type\" \"arith,dyn_shift\") (const_string \"ex_group\")\n-\t (eq_attr \"type\" \"fmove,load,pcload,load_si,pcload_si,fload,pcfload,store,gp_fpul,fpul_gp\") (const_string \"ls_group\")\n+         (eq_attr \"type\" \"movi8,arith,dyn_shift\") (const_string \"ex_group\")\n+\t (eq_attr \"type\" \"fmove,load,pcload,load_si,pcload_si,fload,pcfload,store,fstore,gp_fpul,fpul_gp\") (const_string \"ls_group\")\n \t (eq_attr \"type\" \"cbranch,jump\") (const_string \"br_group\")\n-\t (eq_attr \"type\" \"fp,fdiv,ftrc_s,dfp_arith,dfp_conv,dfdiv\")\n+\t (eq_attr \"type\" \"fp,fp_cmp,fdiv,ftrc_s,dfp_arith,dfp_mul,dfp_conv,dfdiv\")\n \t   (const_string \"fe_group\")\n-\t (eq_attr \"type\" \"jump_ind,smpy,dmpy,mac_gp,return,pload,prset,pstore,prget,rte,sfunc,call,dfp_cmp,mem_fpscr,gp_fpscr,cwb\") (const_string \"co_group\")]\n+\t (eq_attr \"type\" \"jump_ind,smpy,dmpy,mac_gp,return,pload,prset,pstore,prget,rte,sfunc,call,dfp_cmp,mem_fpscr,gp_fpscr,cwb,gp_mac,mac_mem,mem_mac\") (const_string \"co_group\")]\n \t(const_string \"none\")))\n ;; nil are zero instructions, and arith3 / arith3b are multiple instructions,\n ;; so these do not belong in an insn group, although they are modeled\n@@ -494,14 +500,14 @@\n ;; SH4 Double-precision computation with double-precision result -\n ;; the two halves are ready at different times.\n (define_attr \"dfp_comp\" \"yes,no\"\n-  (cond [(eq_attr \"type\" \"dfp_arith,dfp_conv,dfdiv\") (const_string \"yes\")]\n+  (cond [(eq_attr \"type\" \"dfp_arith,dfp_mul,dfp_conv,dfdiv\") (const_string \"yes\")]\n \t(const_string \"no\")))\n \n ;; Insns for which the latency of a preceding fp insn is decreased by one.\n (define_attr \"late_fp_use\" \"yes,no\" (const_string \"no\"))\n ;; And feeding insns for which this relevant.\n (define_attr \"any_fp_comp\" \"yes,no\"\n-  (cond [(eq_attr \"type\" \"fp,fdiv,ftrc_s,dfp_arith,dfp_conv,dfdiv\")\n+  (cond [(eq_attr \"type\" \"fp,fdiv,ftrc_s,dfp_arith,dfp_mul,dfp_conv,dfdiv\")\n \t (const_string \"yes\")]\n \t(const_string \"no\")))\n \n@@ -608,16 +614,38 @@\n \tcmp/pz\t%0\"\n    [(set_attr \"type\" \"mt_group\")])\n \n+;; -------------------------------------------------------------------------\n+;; SImode compare and branch\n+;; -------------------------------------------------------------------------\n+\n+(define_expand \"cbranchsi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:SI 1 \"arith_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"arith_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_CBRANCHDI4\"\n+  \"expand_cbranchsi4 (operands, CODE_FOR_nothing, -1); DONE;\")\n+\n ;; -------------------------------------------------------------------------\n ;; SImode unsigned integer comparisons\n ;; -------------------------------------------------------------------------\n \n-(define_insn \"cmpgeusi_t\"\n+(define_insn_and_split \"cmpgeusi_t\"\n   [(set (reg:SI T_REG)\n \t(geu:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\")\n-\t\t(match_operand:SI 1 \"arith_reg_operand\" \"r\")))]\n+\t\t(match_operand:SI 1 \"arith_reg_or_0_operand\" \"rN\")))]\n   \"TARGET_SH1\"\n   \"cmp/hs\t%1,%0\"\n+  \"&& operands[0] == CONST0_RTX (SImode)\"\n+  [(pc)]\n+  \"\n+{\n+  emit_insn (gen_sett ());\n+  DONE;\n+}\"\n    [(set_attr \"type\" \"mt_group\")])\n \n (define_insn \"cmpgtusi_t\"\n@@ -647,12 +675,64 @@\n }\")\n \f\n ;; -------------------------------------------------------------------------\n-;; DImode signed integer comparisons\n+;; DImode compare and branch\n ;; -------------------------------------------------------------------------\n \n-;; ??? Could get better scheduling by splitting the initial test from the\n-;; rest of the insn after reload.  However, the gain would hardly justify\n-;; the sh.md size increase necessary to do that.\n+\n+;; arith3 patterns don't work well with the sh4-300 branch prediction mechanism.\n+;; Therefore, we aim to have a set of three branches that go straight to the\n+;; destination, i.e. only one of them is taken at any one time.\n+;; This mechanism should also be slightly better for the sh4-200.\n+\n+(define_expand \"cbranchdi4\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:DI 1 \"arith_operand\" \"\")\n+\t\t\t (match_operand:DI 2 \"arith_operand\" \"\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_dup 4))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_CBRANCHDI4\"\n+  \"\n+{\n+  enum rtx_code comparison;\n+\n+  if (TARGET_EXPAND_CBRANCHDI4)\n+    {\n+      if (expand_cbranchdi4 (operands, CODE_FOR_nothing))\n+\tDONE;\n+    }\n+  comparison = prepare_cbranch_operands (operands, DImode, CODE_FOR_nothing);\n+  if (comparison != GET_CODE (operands[0]))\n+    operands[0]\n+      = gen_rtx_fmt_ee (VOIDmode, comparison, operands[1], operands[2]);\n+   operands[4] = gen_rtx_SCRATCH (SImode);\n+}\")\n+\n+(define_insn_and_split \"cbranchdi4_i\"\n+  [(set (pc)\n+\t(if_then_else (match_operator 0 \"comparison_operator\"\n+\t\t\t[(match_operand:DI 1 \"arith_operand\" \"r,r\")\n+\t\t\t (match_operand:DI 2 \"arith_operand\" \"rN,i\")])\n+\t\t      (label_ref (match_operand 3 \"\" \"\"))\n+\t\t      (pc)))\n+   (clobber (match_scratch:SI 4 \"=X,&r\"))\n+   (clobber (reg:SI T_REG))]\n+  \"TARGET_CBRANCHDI4\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(pc)]\n+  \"\n+{\n+  if (!expand_cbranchdi4 (operands, GET_CODE (operands[0])))\n+    FAIL;\n+  DONE;\n+}\")\n+\n+;; -------------------------------------------------------------------------\n+;; DImode signed integer comparisons\n+;; -------------------------------------------------------------------------\n \n (define_insn \"\"\n   [(set (reg:SI T_REG)\n@@ -4736,7 +4816,7 @@ label:\n   [(set (mem:SF (pre_dec:SI (reg:SI SP_REG))) (reg:SF FPUL_REG))]\n   \"TARGET_SH2E && ! TARGET_SH5\"\n   \"sts.l\tfpul,@-r15\"\n-  [(set_attr \"type\" \"store\")\n+  [(set_attr \"type\" \"fstore\")\n    (set_attr \"late_fp_use\" \"yes\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n@@ -4818,9 +4898,9 @@ label:\n ;; (made from (set (subreg:SI (reg:QI ###) 0) ) into T.\n (define_insn \"movsi_i\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n-\t    \"=r,r,t,r,r,r,r,m,<,<,x,l,x,l,r\")\n+\t    \"=r,r,r,t,r,r,r,r,m,<,<,x,l,x,l,r\")\n \t(match_operand:SI 1 \"general_movsrc_operand\"\n-\t \"Q,rI08,r,mr,x,l,t,r,x,l,r,r,>,>,i\"))]\n+\t \"Q,r,I08,r,mr,x,l,t,r,x,l,r,r,>,>,i\"))]\n   \"TARGET_SH1\n    && ! TARGET_SH2E\n    && ! TARGET_SH2A\n@@ -4829,6 +4909,7 @@ label:\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n+\tmov\t%1,%0\n \tcmp/pl\t%1\n \tmov.l\t%1,%0\n \tsts\t%1,%0\n@@ -4842,8 +4923,8 @@ label:\n \tlds.l\t%1,%0\n \tlds.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload_si,move,mt_group,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,pcload_si\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+  [(set_attr \"type\" \"pcload_si,move,movi8,mt_group,load_si,mac_gp,prget,arith,mac_mem,store,pstore,gp_mac,prset,mem_mac,pload,pcload_si\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; t/r must come after r/r, lest reload will try to reload stuff like\n ;; (subreg:SI (reg:SF FR14_REG) 0) into T (compiling stdlib/strtod.c -m3e -O2)\n@@ -4853,15 +4934,16 @@ label:\n ;; TARGET_FMOVD is in effect, and mode switching is done before reload.\n (define_insn \"movsi_ie\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\"\n-\t    \"=r,r,r,t,r,r,r,r,m,<,<,x,l,x,l,y,<,r,y,r,*f,y,*f,y\")\n+\t    \"=r,r,r,r,t,r,r,r,r,m,<,<,x,l,x,l,y,<,r,y,r,*f,y,*f,y\")\n \t(match_operand:SI 1 \"general_movsrc_operand\"\n-\t \"Q,rI08,I20,r,mr,x,l,t,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n+\t \"Q,r,I08,I20,r,mr,x,l,t,r,x,l,r,r,>,>,>,y,i,r,y,y,*f,*f,y\"))]\n   \"(TARGET_SH2E || TARGET_SH2A)\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n+\tmov\t%1,%0\n \tmovi20\t%1,%0\n \tcmp/pl\t%1\n \tmov.l\t%1,%0\n@@ -4884,26 +4966,27 @@ label:\n \tflds\t%1,fpul\n \tfmov\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"pcload_si,move,move,*,load_si,mac_gp,prget,move,store,store,pstore,move,prset,load,pload,load,store,pcload_si,gp_fpul,fpul_gp,fmove,fmove,fmove,nil\")\n-   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*,*,*,*\")\n-   (set_attr \"length\" \"*,*,4,*,4,*,*,*,4,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n+  [(set_attr \"type\" \"pcload_si,move,movi8,move,*,load_si,mac_gp,prget,arith,store,mac_mem,pstore,gp_mac,prset,mem_mac,pload,load,fstore,pcload_si,gp_fpul,fpul_gp,fmove,fmove,fmove,nil\")\n+   (set_attr \"late_fp_use\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,yes,*,*,yes,*,*,*,*\")\n+   (set_attr \"length\" \"*,*,*,4,*,4,*,*,*,4,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n \n (define_insn \"movsi_i_lowpart\"\n-  [(set (strict_low_part (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,m,r\"))\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI08,mr,x,l,t,r,i\"))]\n+  [(set (strict_low_part (match_operand:SI 0 \"general_movdst_operand\" \"+r,r,r,r,r,r,r,m,r\"))\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,r,I08,mr,x,l,t,r,i\"))]\n    \"TARGET_SH1\n     && (register_operand (operands[0], SImode)\n         || register_operand (operands[1], SImode))\"\n   \"@\n \tmov.l\t%1,%0\n \tmov\t%1,%0\n+\tmov\t%1,%0\n \tmov.l\t%1,%0\n \tsts\t%1,%0\n \tsts\t%1,%0\n \tmovt\t%0\n \tmov.l\t%1,%0\n \tfake\t%1,%0\"\n-  [(set_attr \"type\" \"pcload,move,load,move,prget,move,store,pcload\")])\n+  [(set_attr \"type\" \"pcload,move,arith,load,mac_gp,prget,arith,store,pcload\")])\n \n (define_insn_and_split \"load_ra\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"\")\n@@ -5155,19 +5238,20 @@ label:\n    (set_attr \"needs_delay_slot\" \"yes\")])\n \n (define_insn \"movqi_i\"\n-  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,r,l\")\n-\t(match_operand:QI 1 \"general_movsrc_operand\"  \"ri,m,r,t,l,r\"))]\n+  [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m,r,r,l\")\n+\t(match_operand:QI 1 \"general_movsrc_operand\"  \"r,i,m,r,t,l,r\"))]\n   \"TARGET_SH1\n    && (arith_reg_operand (operands[0], QImode)\n        || arith_reg_operand (operands[1], QImode))\"\n   \"@\n+\tmov\t%1,%0\n \tmov\t%1,%0\n \tmov.b\t%1,%0\n \tmov.b\t%1,%0\n \tmovt\t%0\n \tsts\t%1,%0\n \tlds\t%1,%0\"\n- [(set_attr \"type\" \"move,load,store,move,move,move\")])\n+ [(set_attr \"type\" \"move,movi8,load,store,arith,prget,prset\")])\n \n (define_insn \"*movqi_media\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,r,m\")\n@@ -5769,7 +5853,7 @@ label:\n       (if_then_else\n        (ne (symbol_ref \"TARGET_SHCOMPACT\") (const_int 0))\n        (const_int 10) (const_int 8))])\n-   (set_attr \"type\" \"fmove,move,pcfload,fload,store,pcload,load,store,load,fload\")\n+   (set_attr \"type\" \"fmove,move,pcfload,fload,fstore,pcload,load,store,load,fload\")\n    (set_attr \"late_fp_use\" \"*,*,*,*,yes,*,*,*,*,*\")\n    (set (attr \"fp_mode\") (if_then_else (eq_attr \"fmovd\" \"yes\")\n \t\t\t\t\t   (const_string \"double\")\n@@ -6486,7 +6570,7 @@ label:\n \tsts.l\t%1,%0\n \tlds.l\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcfload,fload,store,pcload,load,store,fmove,fmove,load,*,fpul_gp,gp_fpul,store,load,nil\")\n+  [(set_attr \"type\" \"fmove,move,fmove,fmove,pcfload,fload,fstore,pcload,load,store,fmove,fmove,load,*,fpul_gp,gp_fpul,fstore,load,nil\")\n    (set_attr \"late_fp_use\" \"*,*,*,*,*,*,yes,*,*,*,*,*,*,*,yes,*,yes,*,*\")\n    (set_attr \"length\" \"*,*,*,*,4,4,4,*,*,*,2,2,2,4,2,2,2,2,0\")\n    (set (attr \"fp_mode\") (if_then_else (eq_attr \"fmovd\" \"yes\")\n@@ -9929,7 +10013,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \tsts\tfpscr,%0\n \tsts.l\tfpscr,%0\"\n   [(set_attr \"length\" \"0,2,2,4,2,2,2,2,2\")\n-   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,mac_gp,store\")])\n+   (set_attr \"type\" \"nil,mem_fpscr,load,mem_fpscr,gp_fpscr,move,store,mac_gp,fstore\")])\n \n (define_peephole2\n   [(set (reg:PSI FPSCR_REG)\n@@ -9980,7 +10064,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(xor:PSI (reg:PSI FPSCR_REG) (const_int 1048576)))]\n   \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n   \"fschg\"\n-  [(set_attr \"type\" \"fp\") (set_attr \"fp_set\" \"unknown\")])\n+  [(set_attr \"type\" \"fpscr_toggle\") (set_attr \"fp_set\" \"unknown\")])\n \n ;; There's no way we can use it today, since optimize mode switching\n ;; doesn't enable us to know from which mode we're switching to the\n@@ -9992,7 +10076,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t(xor:PSI (reg:PSI FPSCR_REG) (const_int 524288)))]\n   \"TARGET_SH4A_FP && ! TARGET_FPU_SINGLE\"\n   \"fpchg\"\n-  [(set_attr \"type\" \"fp\")])\n+  [(set_attr \"type\" \"fpscr_toggle\")])\n \n (define_expand \"addsf3\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n@@ -10124,25 +10208,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n-;; Unfortunately, the combiner is unable to cope with the USE of the FPSCR\n-;; register in feeding fp instructions.  Thus, we cannot generate fmac for\n-;; mixed-precision SH4 targets.  To allow it to be still generated for the\n-;; SH3E, we use a separate insn for SH3E mulsf3.\n-\n (define_expand \"mulsf3\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"\")\n \t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"\")\n \t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"\")))]\n   \"TARGET_SH2E || TARGET_SHMEDIA_FPU\"\n-  \"\n-{\n-  if (TARGET_SH4 || TARGET_SH2A_SINGLE)\n-    expand_sf_binop (&gen_mulsf3_i4, operands);\n-  else if (TARGET_SH2E)\n-    emit_insn (gen_mulsf3_ie (operands[0], operands[1], operands[2]));\n-  if (! TARGET_SHMEDIA)\n-    DONE;\n-}\")\n+  \"\")\n \n (define_insn \"*mulsf3_media\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n@@ -10152,6 +10223,27 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   \"fmul.s\t%1, %2, %0\"\n   [(set_attr \"type\" \"fparith_media\")])\n \n+;; Unfortunately, the combiner is unable to cope with the USE of the FPSCR\n+;; register in feeding fp instructions.  Thus, in order to generate fmac,\n+;; we start out with a mulsf pattern that does not depend on fpscr.\n+;; This is split after combine to introduce the dependency, in order to\n+;; get mode switching and scheduling right.\n+(define_insn_and_split \"mulsf3_ie\"\n+  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\")))]\n+  \"TARGET_SH2E\"\n+  \"fmul\t%2,%0\"\n+  \"TARGET_SH4 || TARGET_SH2A_SINGLE\"\n+  [(const_int 0)]\n+  \"\n+{\n+  emit_insn (gen_mulsf3_i4 (operands[0], operands[1], operands[2],\n+\t     get_fpscr_rtx ()));\n+  DONE;\n+}\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"mulsf3_i4\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%0\")\n@@ -10162,20 +10254,12 @@ mov.l\\\\t1f,r0\\\\n\\\\\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n-(define_insn \"mulsf3_ie\"\n-  [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n-\t(mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH2E && ! (TARGET_SH4 || TARGET_SH2A_SINGLE)\"\n-  \"fmul\t%2,%0\"\n-  [(set_attr \"type\" \"fp\")])\n-\n (define_insn \"mac_media\"\n   [(set (match_operand:SF 0 \"fp_arith_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"fp_arith_reg_operand\" \"%f\")\n \t\t\t  (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"fp_arith_reg_operand\" \"0\")))]\n-  \"TARGET_SHMEDIA_FPU\"\n+  \"TARGET_SHMEDIA_FPU && TARGET_FMAC\"\n   \"fmac.s %1, %2, %0\"\n   [(set_attr \"type\" \"fparith_media\")])\n \n@@ -10185,7 +10269,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t\t\t  (match_operand:SF 2 \"fp_arith_reg_operand\" \"f\"))\n \t\t (match_operand:SF 3 \"arith_reg_operand\" \"0\")))\n    (use (match_operand:PSI 4 \"fpscr_operand\" \"c\"))]\n-  \"TARGET_SH2E && ! TARGET_SH4\"\n+  \"TARGET_SH2E && TARGET_FMAC\"\n   \"fmac\tfr0,%2,%0\"\n   [(set_attr \"type\" \"fp\")\n    (set_attr \"fp_mode\" \"single\")])\n@@ -10336,7 +10420,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t       (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n   \"TARGET_SH2E && ! (TARGET_SH4 || TARGET_SH2A_SINGLE)\"\n   \"fcmp/gt\t%1,%0\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fp_cmp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n (define_insn \"cmpeqsf_t\"\n@@ -10345,7 +10429,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n \t       (match_operand:SF 1 \"fp_arith_reg_operand\" \"f\")))]\n   \"TARGET_SH2E && ! (TARGET_SH4 || TARGET_SH2A_SINGLE)\"\n   \"fcmp/eq\t%1,%0\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fp_cmp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n (define_insn \"ieee_ccmpeqsf_t\"\n@@ -10365,7 +10449,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"(TARGET_SH4 || TARGET_SH2A_SINGLE)\"\n   \"fcmp/gt\t%1,%0\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fp_cmp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n (define_insn \"cmpeqsf_t_i4\"\n@@ -10375,7 +10459,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"(TARGET_SH4 || TARGET_SH2A_SINGLE)\"\n   \"fcmp/eq\t%1,%0\"\n-  [(set_attr \"type\" \"fp\")\n+  [(set_attr \"type\" \"fp_cmp\")\n    (set_attr \"fp_mode\" \"single\")])\n \n (define_insn \"*ieee_ccmpeqsf_t_4\"\n@@ -10724,7 +10808,7 @@ mov.l\\\\t1f,r0\\\\n\\\\\n    (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n   \"(TARGET_SH4 || TARGET_SH2A_DOUBLE)\"\n   \"fmul\t%2,%0\"\n-  [(set_attr \"type\" \"dfp_arith\")\n+  [(set_attr \"type\" \"dfp_mul\")\n    (set_attr \"fp_mode\" \"double\")])\n \n (define_expand \"divdf3\""}, {"sha": "161fdd8dcaff718802ad30a525d80d3a59906e09", "filename": "gcc/config/sh/sh.opt", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.opt?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -57,11 +57,11 @@ Target RejectNegative Condition(SUPPORT_SH2A_NOFPU)\n Generate SH2a FPU-less code\n \n m2a-single\n-Target RejectNegative Condition (SUPPORT_SH2A_SINGLE)\n+Target RejectNegative Condition(SUPPORT_SH2A_SINGLE)\n Generate default single-precision SH2a code\n \n m2a-single-only\n-Target RejectNegative Condition (SUPPORT_SH2A_SINGLE_ONLY)\n+Target RejectNegative Condition(SUPPORT_SH2A_SINGLE_ONLY)\n Generate only single-precision SH2a code\n \n m2e\n@@ -88,10 +88,33 @@ m4-200\n Target RejectNegative Condition(SUPPORT_SH4)\n Generate SH4-200 code\n \n+;; TARGET_SH4_300 indicates if we have the ST40-300 instruction set and\n+;; pipeline - irrespective of ABI.\n+m4-300\n+Target RejectNegative Condition(SUPPORT_SH4) Var(TARGET_SH4_300)\n+Generate SH4-300 code\n+\n m4-nofpu\n Target RejectNegative Condition(SUPPORT_SH4_NOFPU)\n Generate SH4 FPU-less code\n \n+m4-100-nofpu\n+Target RejectNegative Condition(SUPPORT_SH4_NOFPU)\n+Generate SH4-100 FPU-less code\n+\n+m4-200-nofpu\n+Target RejectNegative Condition(SUPPORT_SH4_NOFPU)\n+Generate SH4-200 FPU-less code\n+\n+m4-300-nofpu\n+Target RejectNegative Condition(SUPPORT_SH4_NOFPU) Var(TARGET_SH4_300) VarExists\n+Generate SH4-300 FPU-less code\n+\n+m4-340\n+Target RejectNegative Condition(SUPPORT_SH4_NOFPU) Var(TARGET_SH4_300) VarExists\n+Generate code for SH4 340 series (MMU/FPU-less)\n+;; passes -isa=sh4-nommu-nofpu to the assembler.\n+\n m4-400\n Target RejectNegative Condition(SUPPORT_SH4_NOFPU)\n Generate code for SH4 400 series (MMU/FPU-less)\n@@ -114,6 +137,10 @@ m4-200-single\n Target RejectNegative Condition(SUPPORT_SH4_SINGLE)\n Generate default single-precision SH4-200 code\n \n+m4-300-single\n+Target RejectNegative Condition(SUPPORT_SH4_SINGLE) Var(TARGET_SH4_300) VarExists\n+Generate default single-precision SH4-300 code\n+\n m4-single-only\n Target RejectNegative Condition(SUPPORT_SH4_SINGLE_ONLY)\n Generate only single-precision SH4 code\n@@ -126,6 +153,10 @@ m4-200-single-only\n Target RejectNegative Condition(SUPPORT_SH4_SINGLE_ONLY)\n Generate only single-precision SH4-200 code\n \n+m4-300-single-only\n+Target RejectNegative Condition(SUPPORT_SH4_SINGLE_ONLY) Var(TARGET_SH4_300) VarExists\n+Generate only single-precision SH4-300 code\n+\n m4a\n Target RejectNegative Mask(SH4A) Condition(SUPPORT_SH4A)\n Generate SH4a code\n@@ -182,6 +213,22 @@ mbigtable\n Target Report RejectNegative Mask(BIGTABLE)\n Generate 32-bit offsets in switch tables\n \n+mbranch-cost=\n+Target RejectNegative Joined UInteger Var(sh_branch_cost) Init(-1)\n+Cost to assume for a branch insn\n+\n+mcbranchdi\n+Target Var(TARGET_CBRANCHDI4)\n+Enable cbranchdi4 pattern\n+\n+mexpand-cbranchdi\n+Target Var(TARGET_EXPAND_CBRANCHDI4)\n+Expand cbranchdi4 pattern early into separate comparisons and branches.\n+\n+mcmpeqdi\n+Target Var(TARGET_CMPEQDI_T)\n+Emit cmpeqdi_t pattern even when -mcbranchdi and -mexpand-cbranchdi are in effect.\n+\n mcut2-workaround\n Target RejectNegative Var(TARGET_SH5_CUT2_WORKAROUND)\n Enable SH5 cut2 workaround\n@@ -192,7 +239,7 @@ Align doubles at 64-bit boundaries\n \n mdiv=\n Target RejectNegative Joined Var(sh_div_str) Init(\"\")\n-Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp call-div1 call-fp call-table\n+Division strategy, one of: call, call2, fp, inv, inv:minlat, inv20u, inv20l, inv:call, inv:call2, inv:fp, call-div1, call-fp, call-table\n \n mdivsi3_libfunc=\n Target RejectNegative Joined Var(sh_divsi3_libfunc) Init(\"\")\n@@ -201,6 +248,10 @@ Specify name for 32 bit signed division function\n mfmovd\n Target RejectNegative Mask(FMOVD) Undocumented\n \n+mfused-madd\n+Target Var(TARGET_FMAC)\n+Enable the use of the fused floating point multiply-accumulate operation\n+\n mgettrcost=\n Target RejectNegative Joined UInteger Var(sh_gettrcost) Init(-1)\n Cost to assume for gettr insn"}, {"sha": "1198fe737b9823e1c2c9b90fb82f125a9d5798b4", "filename": "gcc/config/sh/sh1.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh1.md?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,5 +1,5 @@\n ;; DFA scheduling description for Renesas / SuperH SH.\n-;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;; Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -45,7 +45,7 @@\n \n (define_insn_reservation \"sh1_load_store\" 2\n   (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"load,pcload,pload,store,pstore\"))\n+       (eq_attr \"type\" \"load,pcload,pload,mem_mac,store,fstore,pstore,mac_mem\"))\n   \"sh1memory*2\")\n \n (define_insn_reservation \"sh1_arith3\" 3\n@@ -76,7 +76,7 @@\n \n (define_insn_reservation \"sh1_fp\" 2\n   (and (eq_attr \"pipe_model\" \"sh1\")\n-       (eq_attr \"type\" \"fp,fmove\"))\n+       (eq_attr \"type\" \"fp,fpscr_toggle,fp_cmp,fmove\"))\n   \"sh1fp\")\n \n (define_insn_reservation \"sh1_fdiv\" 13"}, {"sha": "228782a67fcd4d6dae789b24755b64e9f69ee777", "filename": "gcc/config/sh/sh4-300.md", "status": "added", "additions": 288, "deletions": 0, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4-300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4-300.md?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -0,0 +1,288 @@\n+;; DFA scheduling description for ST40-300.\n+;; Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n+\n+;; This file is part of GCC.\n+\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+;; Boston, MA 02110-1301, USA.\n+\n+;; Load and store instructions save a cycle if they are aligned on a\n+;; four byte boundary.  Using a function unit for stores encourages\n+;; gcc to separate load and store instructions by one instruction,\n+;; which makes it more likely that the linker will be able to word\n+;; align them when relaxing.\n+\n+;; The following description models the ST40-300 pipeline using the DFA based\n+;; scheduler.\n+\n+;; Two automata are defined to reduce number of states\n+;; which a single large automaton will have. (Factoring)\n+\n+(define_automaton \"sh4_300_inst_pipeline,sh4_300_fpu_pipe\")\n+\n+;; This unit is basically the decode unit of the processor.\n+;; Since SH4 is a dual issue machine,it is as if there are two\n+;; units so that any insn can be processed by either one\n+;; of the decoding unit.\n+\n+(define_cpu_unit \"sh4_300_pipe_01,sh4_300_pipe_02\" \"sh4_300_inst_pipeline\")\n+\n+;; The floating point units.\n+\n+(define_cpu_unit \"sh4_300_fpt,sh4_300_fpu,sh4_300_fds\" \"sh4_300_fpu_pipe\")\n+\n+;; integer multiplier unit\n+\n+(define_cpu_unit \"sh4_300_mul\" \"sh4_300_inst_pipeline\")\n+\n+;; LS unit\n+\n+(define_cpu_unit \"sh4_300_ls\" \"sh4_300_inst_pipeline\")\n+\n+;; The address calculator used for branch instructions.\n+;; This will be reserved after \"issue\" of branch instructions\n+;; and this is to make sure that no two branch instructions\n+;; can be issued in parallel.\n+\n+(define_cpu_unit \"sh4_300_br\" \"sh4_300_inst_pipeline\")\n+\n+;; ----------------------------------------------------\n+;; This reservation is to simplify the dual issue description.\n+\n+(define_reservation  \"sh4_300_issue\"  \"sh4_300_pipe_01|sh4_300_pipe_02\")\n+\n+(define_reservation \"all\" \"sh4_300_pipe_01+sh4_300_pipe_02\")\n+\n+;;(define_insn_reservation \"nil\" 0 (eq_attr \"type\" \"nil\") \"nothing\")\n+\n+;; MOV RM,RN / MOV #imm8,RN / STS PR,RN\n+(define_insn_reservation \"sh4_300_mov\" 0\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"move,movi8,prget\"))\n+  \"sh4_300_issue\")\n+\n+;; Fixed STS from MACL / MACH\n+(define_insn_reservation \"sh4_300_mac_gp\" 0\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"mac_gp\"))\n+  \"sh4_300_issue+sh4_300_mul\")\n+\n+;; Fixed LDS to MACL / MACH\n+(define_insn_reservation \"sh4_300_gp_mac\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"gp_mac\"))\n+  \"sh4_300_issue+sh4_300_mul\")\n+\n+;; Instructions without specific resource requirements with latency 1.\n+\n+(define_insn_reservation \"sh4_300_simple_arith\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"mt_group,arith,dyn_shift,prset\"))\n+  \"sh4_300_issue\")\n+\n+;; Load and store instructions have no alignment peculiarities for the ST40-300,\n+;; but they use the load-store unit, which they share with the fmove type\n+;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n+;; Loads have a latency of three.\n+\n+;; Load Store instructions.\n+(define_insn_reservation \"sh4_300_load\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"load,pcload,load_si,pcload_si,pload\"))\n+  \"sh4_300_issue+sh4_300_ls\")\n+\n+(define_insn_reservation \"sh4_300_mac_load\" 3\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"mem_mac\"))\n+  \"sh4_300_issue+sh4_300_ls+sh4_300_mul\")\n+\n+(define_insn_reservation \"sh4_300_fload\" 4\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fload,pcfload\"))\n+  \"sh4_300_issue+sh4_300_ls+sh4_300_fpt\")\n+\n+;; sh_adjust_cost describes the reduced latency of the feeding insns of a store.\n+;; The latency of an auto-increment register is 1; the latency of the memory\n+;; output is not actually considered here anyway.\n+(define_insn_reservation \"sh4_300_store\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"store,pstore\"))\n+  \"sh4_300_issue+sh4_300_ls\")\n+\n+(define_insn_reservation \"sh4_300_fstore\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fstore\"))\n+  \"sh4_300_issue+sh4_300_ls+sh4_300_fpt\")\n+\n+;; Fixed STS.L from MACL / MACH\n+(define_insn_reservation \"sh4_300_mac_store\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"mac_mem\"))\n+  \"sh4_300_issue+sh4_300_mul+sh4_300_ls\")\n+\n+(define_insn_reservation \"sh4_300_gp_fpul\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"gp_fpul\"))\n+  \"sh4_300_issue+sh4_300_fpt\")\n+\n+(define_insn_reservation \"sh4_300_fpul_gp\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fpul_gp\"))\n+  \"sh4_300_issue+sh4_300_fpt\")\n+\n+;; Branch (BF,BF/S,BT,BT/S,BRA)\n+;; Branch Far (JMP,RTS,BRAF)\n+;; Group:\tBR\n+;; When displacement is 0 for BF / BT, we have effectively conditional\n+;; execution of one instruction, without pipeline disruption.\n+;; Otherwise, the latency depends on prediction success.\n+;; We can't really do much with the latency, even if we could express it,\n+;; but the pairing restrictions are useful to take into account.\n+;; ??? If the branch is likely, and not paired with a preceding insn,\n+;; or likely and likely not predicted, we might want to fill the delay slot.\n+;; However, there appears to be no machinery to make the compiler\n+;; recognize these scenarios.\n+\n+(define_insn_reservation \"sh4_300_branch\"  1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"cbranch,jump,return,jump_ind\"))\n+  \"sh4_300_issue+sh4_300_br\")\n+\n+;; RTE\n+(define_insn_reservation \"sh4_300_return_from_exp\" 9\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"rte\"))\n+  \"sh4_300_pipe_01+sh4_300_pipe_02*9\")\n+\n+;; OCBP, OCBWB\n+;; Group:\tCO\n+;; Latency: \t1-5\n+;; Issue Rate: \t1\n+\n+;; cwb is used for the sequence ocbwb @%0; extu.w %0,%2; or %1,%2; mov.l %0,@%2\n+;; This description is likely inexact, but this pattern should not actually\n+;; appear when compiling for sh4-300; we should use isbi instead.\n+;; If a -mtune option is added later, we should use the icache array\n+;; dispatch method instead.\n+(define_insn_reservation \"sh4_300_ocbwb\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"cwb\"))\n+  \"all*3\")\n+\n+;; JSR,BSR,BSRF\n+;; Calls have a mandatory delay slot, which we'd like to fill with an insn\n+;; that can be paired with the call itself.\n+;; Scheduling runs before reorg, so we approximate this by saying that we\n+;; want the call to be paired with a preceding insn.\n+;; In most cases, the insn that loads the address of the call should have\n+;; a non-zero latency (mov rn,rm doesn't make sense since we could use rn\n+;; for the address then).  Thus, a preceding insn that can be paired with\n+;; a call should be elegible for the delay slot.\n+;;\n+;; calls introduce a longisch delay that is likely to flush the pipelines\n+;; of the caller's instructions.  Ordinary functions tend to end with a\n+;; load to restore a register (in the delay slot of rts), while sfuncs\n+;; tend to end with an EX or MT insn.  But that is not actually relevant,\n+;; since there are no instructions that contend for memory access early.\n+;; We could, of course, provide exact scheduling information for specific\n+;; sfuncs, if that should prove useful.\n+\n+(define_insn_reservation \"sh4_300_call\" 16\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"call,sfunc\"))\n+  \"sh4_300_issue+sh4_300_br,all*15\")\n+\n+;; FMOV.S / FMOV.D\n+(define_insn_reservation \"sh4_300_fmov\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fmove\"))\n+  \"sh4_300_issue+sh4_300_fpt\")\n+\n+;; LDS to FPSCR\n+(define_insn_reservation \"sh4_300_fpscr_load\" 8\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"gp_fpscr\"))\n+  \"sh4_300_issue+sh4_300_fpu+sh4_300_fpt\")\n+\n+;; LDS.L to FPSCR\n+(define_insn_reservation \"sh4_300_fpscr_load_mem\" 8\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\"  \"mem_fpscr\"))\n+  \"sh4_300_issue+sh4_300_fpu+sh4_300_fpt+sh4_300_ls\")\n+\n+\f\n+;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n+(define_insn_reservation \"multi\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"smpy,dmpy\"))\n+  \"sh4_300_issue+sh4_300_mul\")\n+\n+;; FPCHG, FRCHG, FSCHG\n+(define_insn_reservation \"fpscr_toggle\"  1\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fpscr_toggle\"))\n+  \"sh4_300_issue+sh4_300_fpu+sh4_300_fpt\")\n+\n+;; FCMP/EQ, FCMP/GT\n+(define_insn_reservation \"fp_cmp\"  3\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fp_cmp,dfp_cmp\"))\n+  \"sh4_300_issue+sh4_300_fpu\")\n+\n+;; Single precision floating point (FADD,FLOAT,FMAC,FMUL,FSUB,FTRC)\n+;; Double-precision floating-point (FADD,FCNVDS,FCNVSD,FLOAT,FSUB,FTRC)\n+(define_insn_reservation \"fp_arith\"  6\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fp,ftrc_s,dfp_arith,dfp_conv\"))\n+  \"sh4_300_issue+sh4_300_fpu\")\n+\n+;; Single Precision FDIV/SQRT\n+(define_insn_reservation \"fp_div\" 19\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"fdiv\"))\n+  \"sh4_300_issue+sh4_300_fpu+sh4_300_fds,sh4_300_fds*15\")\n+\n+;; Double-precision floating-point FMUL\n+(define_insn_reservation \"dfp_mul\" 9\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"dfp_mul\"))\n+  \"sh4_300_issue+sh4_300_fpu,sh4_300_fpu*3\")\n+\n+;; Double precision FDIV/SQRT\n+(define_insn_reservation \"dp_div\" 35\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"dfdiv\"))\n+  \"sh4_300_issue+sh4_300_fpu+sh4_300_fds,sh4_300_fds*31\")\n+\n+\n+;; ??? We don't really want these for sh4-300.\n+;; this pattern itself is likely to finish in 3 cycles, but also\n+;; to disrupt branch prediction for taken branches for the following\n+;; condbranch.\n+(define_insn_reservation \"sh4_300_arith3\" 5\n+  (and (eq_attr \"pipe_model\" \"sh4_300\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"sh4_300_issue,all*4\")\n+\n+;; arith3b insns without brach redirection make use of the 0-offset 0-latency\n+;; branch feature, and thus schedule the same no matter if the branch is taken\n+;; or not.  If the branch is redirected, the taken branch might take longer,\n+;; but then, we don't have to take the next branch.\n+;; ??? should we suppress branch redirection for sh4-300 to improve branch\n+;; target hit rates?\n+(define_insn_reservation \"arith3b\" 2\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"arith3\"))\n+  \"issue,all\")"}, {"sha": "b390ab99d050a69ab4e73a853d954d61e72f2d5f", "filename": "gcc/config/sh/sh4.md", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4.md?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,5 +1,5 @@\n ;; DFA scheduling description for SH4.\n-;; Copyright (C) 2004 Free Software Foundation, Inc.\n+;; Copyright (C) 2004, 2006 Free Software Foundation, Inc.\n \n ;; This file is part of GCC.\n \n@@ -209,9 +209,14 @@\n \n (define_insn_reservation \"sh4_store\" 1\n   (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"store\"))\n+       (eq_attr \"type\" \"store,fstore\"))\n   \"issue+load_store,nothing,memory\")\n \n+(define_insn_reservation \"mac_mem\" 1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"mac_mem\"))\n+  \"d_lock,nothing,memory\")\n+\n ;; Load Store instructions.\n ;; Group:\tLS\n ;; Latency: \t1\n@@ -372,35 +377,42 @@\n ;; Fixed point multiplication (DMULS.L DMULU.L MUL.L MULS.W,MULU.W)\n ;; Group:\tCO\n ;; Latency: \t4 / 4\n-;; Issue Rate: \t1\n+;; Issue Rate: \t2\n \n (define_insn_reservation \"multi\" 4\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"smpy,dmpy\"))\n   \"d_lock,(d_lock+f1_1),(f1_1|f1_2)*3,F2\")\n \n-;; Fixed STS from MACL / MACH\n+;; Fixed STS from, and LDS to MACL / MACH\n ;; Group:\tCO\n ;; Latency: \t3\n ;; Issue Rate: \t1\n \n (define_insn_reservation \"sh4_mac_gp\" 3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"mac_gp\"))\n+       (eq_attr \"type\" \"mac_gp,gp_mac,mem_mac\"))\n   \"d_lock\")\n \n \n ;; Single precision floating point computation FCMP/EQ,\n-;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRVHG, FSCHG\n+;; FCMP/GT, FADD, FLOAT, FMAC, FMUL, FSUB, FTRC, FRCHG, FSCHG\n ;; Group:\tFE\n ;; Latency: \t3/4\n ;; Issue Rate: \t1\n \n (define_insn_reservation \"fp_arith\"  3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"type\" \"fp,fp_cmp\"))\n   \"issue,F01,F2\")\n \n+;; We don't model the resource usage of this exactly because that would\n+;; introduce a bogus latency.\n+(define_insn_reservation \"sh4_fpscr_toggle\"  1\n+  (and (eq_attr \"pipe_model\" \"sh4\")\n+       (eq_attr \"type\" \"fpscr_toggle\"))\n+  \"issue\")\n+\n (define_insn_reservation \"fp_arith_ftrc\"  3\n   (and (eq_attr \"pipe_model\" \"sh4\")\n        (eq_attr \"type\" \"ftrc_s\"))\n@@ -437,7 +449,7 @@\n \n (define_insn_reservation \"fp_double_arith\" 8\n   (and (eq_attr \"pipe_model\" \"sh4\")\n-       (eq_attr \"type\" \"dfp_arith\"))\n+       (eq_attr \"type\" \"dfp_arith,dfp_mul\"))\n   \"issue,F01,F1+F2,fpu*4,F2\")\n \n ;; Double-precision FCMP (FCMP/EQ,FCMP/GT)"}, {"sha": "602c6545ae9c1c2129f451b8d6414614bed99ffc", "filename": "gcc/config/sh/sh4a.md", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4a.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsh4a.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh4a.md?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,5 +1,5 @@\n ;; Scheduling description for Renesas SH4a\n-;; Copyright (C) 2003, 2004 Free Software Foundation, Inc.\n+;; Copyright (C) 2003, 2004, 2006 Free Software Foundation, Inc.\n ;;\n ;; This file is part of GCC.\n ;;\n@@ -98,17 +98,19 @@\n ;; MOV\n ;; Group: MT\n ;; Latency: 0\n+;; ??? not sure if movi8 belongs here, but that's where it was\n+;; effectively before.\n (define_insn_reservation \"sh4a_mov\" 0\n   (and (eq_attr \"cpu\" \"sh4a\")\n-       (eq_attr \"type\" \"move\"))\n+       (eq_attr \"type\" \"move,movi8,gp_mac\"))\n   \"ID_or\")\n \n ;; Load\n ;; Group: LS\n ;; Latency: 3\n (define_insn_reservation \"sh4a_load\" 3\n   (and (eq_attr \"cpu\" \"sh4a\")\n-       (eq_attr \"type\" \"load,pcload\"))\n+       (eq_attr \"type\" \"load,pcload,mem_mac\"))\n   \"sh4a_ls+sh4a_memory\")\n \n (define_insn_reservation \"sh4a_load_si\" 3\n@@ -121,7 +123,7 @@\n ;; Latency: 0\n (define_insn_reservation \"sh4a_store\" 0\n   (and (eq_attr \"cpu\" \"sh4a\")\n-       (eq_attr \"type\" \"store\"))\n+       (eq_attr \"type\" \"store,fstore,mac_mem\"))\n   \"sh4a_ls+sh4a_memory\")\n \n ;; CWB TYPE\n@@ -177,7 +179,7 @@\n ;; Latency: \t3\n (define_insn_reservation \"sh4a_fp_arith\"  3\n   (and (eq_attr \"cpu\" \"sh4a\")\n-       (eq_attr \"type\" \"fp\"))\n+       (eq_attr \"type\" \"fp,fp_cmp,fpscr_toggle\"))\n   \"ID_or,sh4a_fex\")\n \n (define_insn_reservation \"sh4a_fp_arith_ftrc\"  3\n@@ -207,7 +209,7 @@\n ;; Latency: \t5\n (define_insn_reservation \"sh4a_fp_double_arith\" 5\n   (and (eq_attr \"cpu\" \"sh4a\")\n-       (eq_attr \"type\" \"dfp_arith\"))\n+       (eq_attr \"type\" \"dfp_arith,dfp_mul\"))\n   \"ID_or,sh4a_fex*3\")\n \n ;; Double precision FDIV/SQRT"}, {"sha": "65154926e338fff8ad5c56abb5b776b594116b49", "filename": "gcc/config/sh/superh.h", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsuperh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Fsuperh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsuperh.h?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -75,17 +75,17 @@ Boston, MA 02110-1301, USA.  */\n    on newlib and provide the runtime support */\n #undef SUBTARGET_CPP_SPEC\n #define SUBTARGET_CPP_SPEC \\\n-\"-D__EMBEDDED_CROSS__ %{m4-100*:-D__SH4_100__} %{m4-200*:-D__SH4_200__} %{m4-400:-D__SH4_400__} %{m4-500:-D__SH4_500__} \\\n+\"-D__EMBEDDED_CROSS__ %{m4-100*:-D__SH4_100__} %{m4-200*:-D__SH4_200__} %{m4-300*:-D__SH4_300__} %{m4-340:-D__SH4_340__} %{m4-400:-D__SH4_400__} %{m4-500:-D__SH4_500__} \\\n %(cppruntime)\"\n \n /* Override the SUBTARGET_ASM_SPEC to add the runtime support */\n #undef SUBTARGET_ASM_SPEC\n-#define SUBTARGET_ASM_SPEC \"%{m4-100*|m4-200*:-isa=sh4} %{m4-400:-isa=sh4-nommu-nofpu} %{m4-500:-isa=sh4-nofpu} %(asruntime)\"\n+#define SUBTARGET_ASM_SPEC \"%{m4-100*|m4-200*:-isa=sh4} %{m4-400|m4-340:-isa=sh4-nommu-nofpu} %{m4-500:-isa=sh4-nofpu} %(asruntime)\"\n \n /* Override the SUBTARGET_ASM_RELAX_SPEC so it doesn't interfere with the\n    runtime support by adding -isa=sh4 in the wrong place.  */\n #undef SUBTARGET_ASM_RELAX_SPEC\n-#define SUBTARGET_ASM_RELAX_SPEC \"%{!m4-100*:%{!m4-200*:%{!m4-400:%{!m4-500:-isa=sh4}}}}\"\n+#define SUBTARGET_ASM_RELAX_SPEC \"%{!m4-100*:%{!m4-200*:%{!m4-300*:%{!m4-340:%{!m4-400:%{!m4-500:-isa=sh4}}}}}}\"\n \n /* Create the CC1_SPEC to add the runtime support */\n #undef CC1_SPEC\n@@ -102,7 +102,7 @@ Boston, MA 02110-1301, USA.  */\n /* Override STARTFILE_SPEC to add profiling and MMU support.  */\n #undef STARTFILE_SPEC\n #define STARTFILE_SPEC \\\n-  \"%{!shared: %{!m4-400*: %{pg:gcrt1-mmu.o%s}%{!pg:crt1-mmu.o%s}}} \\\n-   %{!shared: %{m4-400*: %{pg:gcrt1.o%s}%{!pg:crt1.o%s}}} \\\n+  \"%{!shared: %{!m4-400*:%{!m4-340*: %{pg:gcrt1-mmu.o%s}%{!pg:crt1-mmu.o%s}}}} \\\n+   %{!shared: %{m4-340*|m4-400*: %{pg:gcrt1.o%s}%{!pg:crt1.o%s}}} \\\n    crti.o%s \\\n    %{!shared:crtbegin.o%s} %{shared:crtbeginS.o%s}\""}, {"sha": "56b6ba1c55a0999ba2e54f9ac6a0426fba235ff4", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -38,11 +38,12 @@ MULTILIB_DIRNAMES=\n # is why sh2a and sh2a-single need their own multilibs.\n MULTILIB_MATCHES = $(shell \\\n   multilibs=\"$(MULTILIB_OPTIONS)\" ; \\\n-  for abi in m1,m2,m3,m4-nofpu,m4-400,m4-500,m4al,m4a-nofpu m1,m2,m2a-nofpu \\\n-             m2e,m3e,m4-single-only,m4-100-single-only,m4-200-single-only,m4a-single-only \\\n+  for abi in m1,m2,m3,m4-nofpu,m4-100-nofpu,m4-200-nofpu,m4-400,m4-500,m4-340,m4-300-nofpu,m4al,m4a-nofpu \\\n+             m1,m2,m2a-nofpu \\\n+             m2e,m3e,m4-single-only,m4-100-single-only,m4-200-single-only,m4-300-single-only,m4a-single-only \\\n              m2e,m2a-single-only \\\n-             m4-single,m4-100-single,m4-200-single,m4a-single \\\n-             m4,m4-100,m4-200,m4a \\\n+             m4-single,m4-100-single,m4-200-single,m4-300-single,m4a-single \\\n+             m4,m4-100,m4-200,m4-300,m4a \\\n              m5-32media,m5-compact,m5-32media \\\n              m5-32media-nofpu,m5-compact-nofpu,m5-32media-nofpu; do \\\n     subst= ; \\\n@@ -76,7 +77,7 @@ gt-sh.h : s-gtype ; @true\n \n IC_EXTRA_PARTS= libic_invalidate_array_4-100.a libic_invalidate_array_4-200.a \\\n libic_invalidate_array_4a.a\n-OPT_EXTRA_PARTS= libgcc-Os-4-200.a\n+OPT_EXTRA_PARTS= libgcc-Os-4-200.a libgcc-4-300.a\n EXTRA_MULTILIB_PARTS= $(IC_EXTRA_PARTS) $(OPT_EXTRA_PARTS)\n \n $(T)ic_invalidate_array_4-100.o: $(srcdir)/config/sh/lib1funcs.asm $(GCC_PASSES)\n@@ -104,6 +105,12 @@ OBJS_Os_4_200=$(T)sdivsi3_i4i-Os-4-200.o $(T)udivsi3_i4i-Os-4-200.o $(T)unwind-d\n $(T)libgcc-Os-4-200.a: $(OBJS_Os_4_200) $(GCC_PASSES)\n \t$(AR_CREATE_FOR_TARGET) $@ $(OBJS_Os_4_200)\n \n+$(T)div_table-4-300.o: $(srcdir)/config/sh/lib1funcs-4-300.asm $(GCC_PASSES)\n+\t$(GCC_FOR_TARGET) $(MULTILIB_CFLAGS) -c -o $@ -DL_div_table -x assembler-with-cpp $<\n+\n+$(T)libgcc-4-300.a: $(T)div_table-4-300.o $(GCC_PASSES)\n+\t$(AR_CREATE_FOR_TARGET) $@ $(T)div_table-4-300.o\n+\n # Local Variables:\n # mode: Makefile\n # End:"}, {"sha": "1949db13719ddce40a1aef83c3f00a077beb2eee", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -1,3 +1,8 @@\n+2006-11-03  J\"orn Rennecke  <joern.rennecke@st.com>\n+\n+\t* testsuite/gcc.c-torture/execute/arith-rand-ll.c:\n+\tAlso test for bogus rest sign.\n+\n 2006-11-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/27895"}, {"sha": "6c3cf1885babccf1f600a944058b09f01dcc163b", "filename": "gcc/testsuite/gcc.c-torture/execute/arith-rand-ll.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-rand-ll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78d310c2c138f824e912f84eb0f6718e335238eb/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-rand-ll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Farith-rand-ll.c?ref=78d310c2c138f824e912f84eb0f6718e335238eb", "patch": "@@ -79,7 +79,7 @@ main ()\n \t  continue;\n \tr1 = xx / yy;\n \tr2 = xx % yy;\n-\tif (ABS (r2) >= (unsigned int) ABS (yy) || (signed int) (r1 * yy + r2) != xx)\n+\tif (ABS (r2) >= (unsigned int) ABS (yy) || (signed int) (r1 * yy + r2) != xx || ((xx < 0) != (r2 < 0) && r2))\n \t  abort ();\n       }\n       { unsigned short xx = x, yy = y, r1, r2;"}]}