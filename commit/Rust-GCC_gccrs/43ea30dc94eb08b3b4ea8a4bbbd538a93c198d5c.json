{"sha": "43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDNlYTMwZGM5NGViMDhiM2I0ZWE4YTRiYmJkNTM4YTkzYzE5OGQ1Yw==", "commit": {"author": {"name": "Nathan Froyd", "email": "froydnj@codesourcery.com", "date": "2010-10-08T01:06:14Z"}, "committer": {"name": "Nathan Froyd", "email": "froydnj@gcc.gnu.org", "date": "2010-10-08T01:06:14Z"}, "message": "builtins.c (rewrite_call_expr): Move code to...\n\n\t* builtins.c (rewrite_call_expr): Move code to...\n\t(rewrite_call_expr_valist): ...here.  Call\n\tbuild_call_expr_loc_array.\n\t(rewrite_call_expr_array): New function.\n\t(fold_builtin_sprintf_chk_1): New function.\n\t(fold_builtin_sprintf_chk): Call it.\n\t(gimple_fold_builtin_sprintf_chk): Likewise.\n\t(fold_builtin_snprintf_chk_1): New function.\n\t(fold_builtin_snprintf_chk): Call it.\n\t(gimple_fold_builtin_snprintf_chk): Likewise.\n\t(gimple_rewrite_call_expr): Delete.\n\nFrom-SVN: r165146", "tree": {"sha": "bd8c7cf017284dd50a6782a57546837b06eab688", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd8c7cf017284dd50a6782a57546837b06eab688"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c/comments", "author": null, "committer": null, "parents": [{"sha": "937f7f69bc169cfa47c929911ddb396f76b349ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/937f7f69bc169cfa47c929911ddb396f76b349ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/937f7f69bc169cfa47c929911ddb396f76b349ac"}], "stats": {"total": 341, "additions": 121, "deletions": 220}, "files": [{"sha": "408f89c73a85d6dcf4afe19da4e0b08ebcf0ca67", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "patch": "@@ -1,3 +1,17 @@\n+2010-10-07  Nathan Froyd  <froydnj@codesourcery.com>\n+\n+\t* builtins.c (rewrite_call_expr): Move code to...\n+\t(rewrite_call_expr_valist): ...here.  Call\n+\tbuild_call_expr_loc_array.\n+\t(rewrite_call_expr_array): New function.\n+\t(fold_builtin_sprintf_chk_1): New function.\n+\t(fold_builtin_sprintf_chk): Call it.\n+\t(gimple_fold_builtin_sprintf_chk): Likewise.\n+\t(fold_builtin_snprintf_chk_1): New function.\n+\t(fold_builtin_snprintf_chk): Call it.\n+\t(gimple_fold_builtin_snprintf_chk): Likewise.\n+\t(gimple_rewrite_call_expr): Delete.\n+\n 2010-10-07  Dave Korn  <dave.korn.cygwin@gmail.com>\n \n \t* config.host: Update copyright year."}, {"sha": "0579f758cf50876e3b55bef7f0cbeae037ace995", "filename": "gcc/builtins.c", "status": "modified", "additions": 107, "deletions": 220, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=43ea30dc94eb08b3b4ea8a4bbbd538a93c198d5c", "patch": "@@ -10869,37 +10869,70 @@ fold_builtin_call_array (location_t loc, tree type,\n   return build_call_array_loc (loc, type, fn, n, argarray);\n }\n \n-/* Construct a new CALL_EXPR using the tail of the argument list of EXP\n-   along with N new arguments specified as the \"...\" parameters.  SKIP\n-   is the number of arguments in EXP to be omitted.  This function is used\n-   to do varargs-to-varargs transformations.  */\n+/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n+   list ARGS along with N new arguments in NEWARGS.  SKIP is the number\n+   of arguments in ARGS to be omitted.  OLDNARGS is the number of\n+   elements in ARGS.  */\n \n static tree\n-rewrite_call_expr (location_t loc, tree exp, int skip, tree fndecl, int n, ...)\n+rewrite_call_expr_valist (location_t loc, int oldnargs, tree *args,\n+\t\t\t  int skip, tree fndecl, int n, va_list newargs)\n {\n-  int oldnargs = call_expr_nargs (exp);\n   int nargs = oldnargs - skip + n;\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n   tree *buffer;\n \n   if (n > 0)\n     {\n       int i, j;\n-      va_list ap;\n \n       buffer = XALLOCAVEC (tree, nargs);\n-      va_start (ap, n);\n       for (i = 0; i < n; i++)\n-\tbuffer[i] = va_arg (ap, tree);\n-      va_end (ap);\n+\tbuffer[i] = va_arg (newargs, tree);\n       for (j = skip; j < oldnargs; j++, i++)\n-\tbuffer[i] = CALL_EXPR_ARG (exp, j);\n+\tbuffer[i] = args[j];\n     }\n   else\n-    buffer = CALL_EXPR_ARGP (exp) + skip;\n+    buffer = args + skip;\n \n-  return fold (build_call_array_loc (loc, TREE_TYPE (exp), fn, nargs, buffer));\n+  return build_call_expr_loc_array (loc, fndecl, nargs, buffer);\n+}\n+\n+/* Construct a new CALL_EXPR to FNDECL using the tail of the argument\n+   list ARGS along with N new arguments specified as the \"...\"\n+   parameters.  SKIP is the number of arguments in ARGS to be omitted.\n+   OLDNARGS is the number of elements in ARGS.  */\n+\n+static tree\n+rewrite_call_expr_array (location_t loc, int oldnargs, tree *args,\n+\t\t\t int skip, tree fndecl, int n, ...)\n+{\n+  va_list ap;\n+  tree t;\n+\n+  va_start (ap, n);\n+  t = rewrite_call_expr_valist (loc, oldnargs, args, skip, fndecl, n, ap);\n+  va_end (ap);\n+\n+  return t;\n+}\n+\n+/* Construct a new CALL_EXPR using the tail of the argument list of EXP\n+   along with N new arguments specified as the \"...\" parameters.  SKIP\n+   is the number of arguments in EXP to be omitted.  This function is used\n+   to do varargs-to-varargs transformations.  */\n+\n+static tree\n+rewrite_call_expr (location_t loc, tree exp, int skip, tree fndecl, int n, ...)\n+{\n+  va_list ap;\n+  tree t;\n+\n+  va_start (ap, n);\n+  t = rewrite_call_expr_valist (loc, call_expr_nargs (exp),\n+\t\t\t\tCALL_EXPR_ARGP (exp), skip, fndecl, n, ap);\n+  va_end (ap);\n+\n+  return t;\n }\n \n /* Validate a single argument ARG against a tree code CODE representing\n@@ -12460,31 +12493,31 @@ fold_builtin_strncat_chk (location_t loc, tree fndecl,\n   return build_call_expr_loc (loc, fn, 3, dest, src, len);\n }\n \n-/* Fold a call EXP to __{,v}sprintf_chk.  Return NULL_TREE if\n-   a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n+/* Fold a call EXP to __{,v}sprintf_chk having NARGS passed as ARGS.\n+   Return NULL_TREE if a normal call should be emitted rather than\n+   expanding the function inline.  FCODE is either BUILT_IN_SPRINTF_CHK\n+   or BUILT_IN_VSPRINTF_CHK.  */\n \n static tree\n-fold_builtin_sprintf_chk (location_t loc, tree exp,\n-\t\t\t  enum built_in_function fcode)\n+fold_builtin_sprintf_chk_1 (location_t loc, int nargs, tree *args,\n+\t\t\t    enum built_in_function fcode)\n {\n   tree dest, size, len, fn, fmt, flag;\n   const char *fmt_str;\n-  int nargs = call_expr_nargs (exp);\n \n   /* Verify the required arguments in the original call.  */\n   if (nargs < 4)\n     return NULL_TREE;\n-  dest = CALL_EXPR_ARG (exp, 0);\n+  dest = args[0];\n   if (!validate_arg (dest, POINTER_TYPE))\n     return NULL_TREE;\n-  flag = CALL_EXPR_ARG (exp, 1);\n+  flag = args[1];\n   if (!validate_arg (flag, INTEGER_TYPE))\n     return NULL_TREE;\n-  size = CALL_EXPR_ARG (exp, 2);\n+  size = args[2];\n   if (!validate_arg (size, INTEGER_TYPE))\n     return NULL_TREE;\n-  fmt = CALL_EXPR_ARG (exp, 3);\n+  fmt = args[3];\n   if (!validate_arg (fmt, POINTER_TYPE))\n     return NULL_TREE;\n \n@@ -12515,7 +12548,7 @@ fold_builtin_sprintf_chk (location_t loc, tree exp,\n \n \t  if (nargs == 5)\n \t    {\n-\t      arg = CALL_EXPR_ARG (exp, 4);\n+\t      arg = args[4];\n \t      if (validate_arg (arg, POINTER_TYPE))\n \t\t{\n \t\t  len = c_strlen (arg, 1);\n@@ -12549,38 +12582,50 @@ fold_builtin_sprintf_chk (location_t loc, tree exp,\n   if (!fn)\n     return NULL_TREE;\n \n-  return rewrite_call_expr (loc, exp, 4, fn, 2, dest, fmt);\n+  return rewrite_call_expr_array (loc, nargs, args, 4, fn, 2, dest, fmt);\n }\n \n-/* Fold a call EXP to {,v}snprintf.  Return NULL_TREE if\n+/* Fold a call EXP to __{,v}sprintf_chk.  Return NULL_TREE if\n    a normal call should be emitted rather than expanding the function\n-   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n+   inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n+\n+static tree\n+fold_builtin_sprintf_chk (location_t loc, tree exp,\n+\t\t\t  enum built_in_function fcode)\n+{\n+  return fold_builtin_sprintf_chk_1 (loc, call_expr_nargs (exp),\n+\t\t\t\t     CALL_EXPR_ARGP (exp), fcode);\n+}\n+\n+/* Fold a call EXP to {,v}snprintf having NARGS passed as ARGS.  Return\n+   NULL_TREE if a normal call should be emitted rather than expanding\n+   the function inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n    BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n    passed as second argument.  */\n \n-tree\n-fold_builtin_snprintf_chk (location_t loc, tree exp, tree maxlen,\n-\t\t\t   enum built_in_function fcode)\n+static tree\n+fold_builtin_snprintf_chk_1 (location_t loc, int nargs, tree *args,\n+\t\t\t     tree maxlen, enum built_in_function fcode)\n {\n   tree dest, size, len, fn, fmt, flag;\n   const char *fmt_str;\n \n   /* Verify the required arguments in the original call.  */\n-  if (call_expr_nargs (exp) < 5)\n+  if (nargs < 5)\n     return NULL_TREE;\n-  dest = CALL_EXPR_ARG (exp, 0);\n+  dest = args[0];\n   if (!validate_arg (dest, POINTER_TYPE))\n     return NULL_TREE;\n-  len = CALL_EXPR_ARG (exp, 1);\n+  len = args[1];\n   if (!validate_arg (len, INTEGER_TYPE))\n     return NULL_TREE;\n-  flag = CALL_EXPR_ARG (exp, 2);\n+  flag = args[2];\n   if (!validate_arg (flag, INTEGER_TYPE))\n     return NULL_TREE;\n-  size = CALL_EXPR_ARG (exp, 3);\n+  size = args[3];\n   if (!validate_arg (size, INTEGER_TYPE))\n     return NULL_TREE;\n-  fmt = CALL_EXPR_ARG (exp, 4);\n+  fmt = args[4];\n   if (!validate_arg (fmt, POINTER_TYPE))\n     return NULL_TREE;\n \n@@ -12626,7 +12671,21 @@ fold_builtin_snprintf_chk (location_t loc, tree exp, tree maxlen,\n   if (!fn)\n     return NULL_TREE;\n \n-  return rewrite_call_expr (loc, exp, 5, fn, 3, dest, len, fmt);\n+  return rewrite_call_expr_array (loc, nargs, args, 5, fn, 3, dest, len, fmt);\n+}\n+\n+/* Fold a call EXP to {,v}snprintf.  Return NULL_TREE if\n+   a normal call should be emitted rather than expanding the function\n+   inline.  FCODE is either BUILT_IN_SNPRINTF_CHK or\n+   BUILT_IN_VSNPRINTF_CHK.  If MAXLEN is not NULL, it is maximum length\n+   passed as second argument.  */\n+\n+tree\n+fold_builtin_snprintf_chk (location_t loc, tree exp, tree maxlen,\n+\t\t\t   enum built_in_function fcode)\n+{\n+  return fold_builtin_snprintf_chk_1 (loc, call_expr_nargs (exp),\n+\t\t\t\t      CALL_EXPR_ARGP (exp), maxlen, fcode);\n }\n \n /* Fold a call to the {,v}printf{,_unlocked} and __{,v}printf_chk builtins.\n@@ -13482,132 +13541,19 @@ do_mpc_arg2 (tree arg0, tree arg1, tree type, int do_nonfinite,\n   return result;\n }\n \n-/* FIXME tuples.\n-   The functions below provide an alternate interface for folding\n-   builtin function calls presented as GIMPLE_CALL statements rather\n-   than as CALL_EXPRs.  The folded result is still expressed as a\n-   tree.  There is too much code duplication in the handling of\n-   varargs functions, and a more intrusive re-factoring would permit\n-   better sharing of code between the tree and statement-based\n-   versions of these functions.  */\n-\n-/* Construct a new CALL_EXPR using the tail of the argument list of STMT\n-   along with N new arguments specified as the \"...\" parameters.  SKIP\n-   is the number of arguments in STMT to be omitted.  This function is used\n-   to do varargs-to-varargs transformations.  */\n-\n-static tree\n-gimple_rewrite_call_expr (gimple stmt, int skip, tree fndecl, int n, ...)\n-{\n-  int oldnargs = gimple_call_num_args (stmt);\n-  int nargs = oldnargs - skip + n;\n-  tree fntype = TREE_TYPE (fndecl);\n-  tree fn = build1 (ADDR_EXPR, build_pointer_type (fntype), fndecl);\n-  tree *buffer;\n-  int i, j;\n-  va_list ap;\n-  location_t loc = gimple_location (stmt);\n-\n-  buffer = XALLOCAVEC (tree, nargs);\n-  va_start (ap, n);\n-  for (i = 0; i < n; i++)\n-    buffer[i] = va_arg (ap, tree);\n-  va_end (ap);\n-  for (j = skip; j < oldnargs; j++, i++)\n-    buffer[i] = gimple_call_arg (stmt, j);\n-\n-  return fold (build_call_array_loc (loc, TREE_TYPE (fntype), fn, nargs, buffer));\n-}\n-\n /* Fold a call STMT to __{,v}sprintf_chk.  Return NULL_TREE if\n    a normal call should be emitted rather than expanding the function\n    inline.  FCODE is either BUILT_IN_SPRINTF_CHK or BUILT_IN_VSPRINTF_CHK.  */\n \n static tree\n gimple_fold_builtin_sprintf_chk (gimple stmt, enum built_in_function fcode)\n {\n-  tree dest, size, len, fn, fmt, flag;\n-  const char *fmt_str;\n   int nargs = gimple_call_num_args (stmt);\n \n-  /* Verify the required arguments in the original call.  */\n-  if (nargs < 4)\n-    return NULL_TREE;\n-  dest = gimple_call_arg (stmt, 0);\n-  if (!validate_arg (dest, POINTER_TYPE))\n-    return NULL_TREE;\n-  flag = gimple_call_arg (stmt, 1);\n-  if (!validate_arg (flag, INTEGER_TYPE))\n-    return NULL_TREE;\n-  size = gimple_call_arg (stmt, 2);\n-  if (!validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-  fmt = gimple_call_arg (stmt, 3);\n-  if (!validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! host_integerp (size, 1))\n-    return NULL_TREE;\n-\n-  len = NULL_TREE;\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  /* Check whether the format is a literal string constant.  */\n-  fmt_str = c_getstr (fmt);\n-  if (fmt_str != NULL)\n-    {\n-      /* If the format doesn't contain % args or %%, we know the size.  */\n-      if (strchr (fmt_str, target_percent) == 0)\n-\t{\n-\t  if (fcode != BUILT_IN_SPRINTF_CHK || nargs == 4)\n-\t    len = build_int_cstu (size_type_node, strlen (fmt_str));\n-\t}\n-      /* If the format is \"%s\" and first ... argument is a string literal,\n-\t we know the size too.  */\n-      else if (fcode == BUILT_IN_SPRINTF_CHK\n-\t       && strcmp (fmt_str, target_percent_s) == 0)\n-\t{\n-\t  tree arg;\n-\n-\t  if (nargs == 5)\n-\t    {\n-\t      arg = gimple_call_arg (stmt, 4);\n-\t      if (validate_arg (arg, POINTER_TYPE))\n-\t\t{\n-\t\t  len = c_strlen (arg, 1);\n-\t\t  if (! len || ! host_integerp (len, 1))\n-\t\t    len = NULL_TREE;\n-\t\t}\n-\t    }\n-\t}\n-    }\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! len || ! tree_int_cst_lt (len, size))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* Only convert __{,v}sprintf_chk to {,v}sprintf if flag is 0\n-     or if format doesn't contain % chars or is \"%s\".  */\n-  if (! integer_zerop (flag))\n-    {\n-      if (fmt_str == NULL)\n-\treturn NULL_TREE;\n-      if (strchr (fmt_str, target_percent) != NULL\n-\t  && strcmp (fmt_str, target_percent_s))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_{,v}sprintf_chk is used, assume {,v}sprintf is available.  */\n-  fn = built_in_decls[fcode == BUILT_IN_VSPRINTF_CHK\n-\t\t      ? BUILT_IN_VSPRINTF : BUILT_IN_SPRINTF];\n-  if (!fn)\n-    return NULL_TREE;\n-\n-  return gimple_rewrite_call_expr (stmt, 4, fn, 2, dest, fmt);\n+  return fold_builtin_sprintf_chk_1 (gimple_location (stmt), nargs,\n+\t\t\t\t     (nargs > 0\n+\t\t\t\t      ? gimple_call_arg_ptr (stmt, 0)\n+\t\t\t\t      : &error_mark_node), fcode);\n }\n \n /* Fold a call STMT to {,v}snprintf.  Return NULL_TREE if\n@@ -13620,71 +13566,12 @@ tree\n gimple_fold_builtin_snprintf_chk (gimple stmt, tree maxlen,\n                                   enum built_in_function fcode)\n {\n-  tree dest, size, len, fn, fmt, flag;\n-  const char *fmt_str;\n-\n-  /* Verify the required arguments in the original call.  */\n-  if (gimple_call_num_args (stmt) < 5)\n-    return NULL_TREE;\n-  dest = gimple_call_arg (stmt, 0);\n-  if (!validate_arg (dest, POINTER_TYPE))\n-    return NULL_TREE;\n-  len = gimple_call_arg (stmt, 1);\n-  if (!validate_arg (len, INTEGER_TYPE))\n-    return NULL_TREE;\n-  flag = gimple_call_arg (stmt, 2);\n-  if (!validate_arg (flag, INTEGER_TYPE))\n-    return NULL_TREE;\n-  size = gimple_call_arg (stmt, 3);\n-  if (!validate_arg (size, INTEGER_TYPE))\n-    return NULL_TREE;\n-  fmt = gimple_call_arg (stmt, 4);\n-  if (!validate_arg (fmt, POINTER_TYPE))\n-    return NULL_TREE;\n-\n-  if (! host_integerp (size, 1))\n-    return NULL_TREE;\n-\n-  if (! integer_all_onesp (size))\n-    {\n-      if (! host_integerp (len, 1))\n-\t{\n-\t  /* If LEN is not constant, try MAXLEN too.\n-\t     For MAXLEN only allow optimizing into non-_ocs function\n-\t     if SIZE is >= MAXLEN, never convert to __ocs_fail ().  */\n-\t  if (maxlen == NULL_TREE || ! host_integerp (maxlen, 1))\n-\t    return NULL_TREE;\n-\t}\n-      else\n-\tmaxlen = len;\n-\n-      if (tree_int_cst_lt (size, maxlen))\n-\treturn NULL_TREE;\n-    }\n-\n-  if (!init_target_chars ())\n-    return NULL_TREE;\n-\n-  /* Only convert __{,v}snprintf_chk to {,v}snprintf if flag is 0\n-     or if format doesn't contain % chars or is \"%s\".  */\n-  if (! integer_zerop (flag))\n-    {\n-      fmt_str = c_getstr (fmt);\n-      if (fmt_str == NULL)\n-\treturn NULL_TREE;\n-      if (strchr (fmt_str, target_percent) != NULL\n-\t  && strcmp (fmt_str, target_percent_s))\n-\treturn NULL_TREE;\n-    }\n-\n-  /* If __builtin_{,v}snprintf_chk is used, assume {,v}snprintf is\n-     available.  */\n-  fn = built_in_decls[fcode == BUILT_IN_VSNPRINTF_CHK\n-\t\t      ? BUILT_IN_VSNPRINTF : BUILT_IN_SNPRINTF];\n-  if (!fn)\n-    return NULL_TREE;\n+  int nargs = gimple_call_num_args (stmt);\n \n-  return gimple_rewrite_call_expr (stmt, 5, fn, 3, dest, len, fmt);\n+  return fold_builtin_snprintf_chk_1 (gimple_location (stmt), nargs,\n+\t\t\t\t      (nargs > 0\n+\t\t\t\t       ? gimple_call_arg_ptr (stmt, 0)\n+\t\t\t\t       : &error_mark_node), maxlen, fcode);\n }\n \n /* Builtins with folding operations that operate on \"...\" arguments"}]}