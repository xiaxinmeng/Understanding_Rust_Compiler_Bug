{"sha": "502ef838c9c03499ccc8f55e0ff86f19c0f66119", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTAyZWY4MzhjOWMwMzQ5OWNjYzhmNTVlMGZmODZmMTljMGY2NjExOQ==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gnu.org", "date": "2010-09-04T07:26:39Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2010-09-04T07:26:39Z"}, "message": "df.h (enum df_ref_class): Remove DF_REF_EXTRACT.\n\n2010-09-04  Paolo Bonzini  <bonzini@gnu.org>\n\n\t* df.h (enum df_ref_class): Remove DF_REF_EXTRACT.\n\t(struct df_extract_ref): Remove.\n\t(union df_ref_d): Remove extract_ref member.\n\t(df_ref_create): Remove last three arguments.\n\t(DF_REF_LOC): Remove DF_REF_EXTRACT case.\n\t* df-scan.c (df_ref_record): Remove last three arguments, do not\n\tpass them to df_ref_create_structure.\n\t(df_uses_record): Remove first and last three arguments.  Replace\n\tfirst argument with DF_REF_REGULAR, adjust calls to remove the\n\twidth, offset and mode.  Always call recursively on the second\n\tand third argument of ZERO_EXTRACT and SIGN_EXTRACT.\n\t(df_ref_create_structure): Remove first argument.\n\t(struct df_scan_problem_data): Remove ref_extract_pool.\n\t(df_scan_free_internal): Do not free it.\n\t(df_scan_alloc): Do not allocate it.\n\t(df_ref_create): Remove last three arguments, do not pass them to\n\tdf_ref_create_structure.\n\t(df_free_ref): Remove DF_REF_EXTRACT case.\n\t(df_notes_rescan): Adjust call to df_uses_record.\n\t(df_ref_equal_p, df_ref_compare, df_ref_create_structure):\n\tRemove DF_REF_EXTRACT case.\n\t(df_def_record_1): Do not special case class for a ZERO_EXTRACT lhs.\n\tAdjust calls to df_ref_record, using DF_REF_REGULAR for all REG\n\tand SUBREG definitions.\n\t(df_get_conditional_uses): Remove references to width/offset/mode,\n\tadjust call to df_ref_create_structure.\n\t(df_get_call_refs, df_insn_refs_collect, df_bb_refs_collect,\n\tdf_entry_block_defs_collect, df_exit_block_uses_collect): Adjust\n\tcalls to df_uses_record and df_ref_record.\n\t* fwprop.c (update_df): Remove references to width/offset/mode,\n\tadjust call to df_ref_create.\n\nFrom-SVN: r163854", "tree": {"sha": "a7671f002a287d6524319f97f4f6fceea0ed368b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a7671f002a287d6524319f97f4f6fceea0ed368b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/502ef838c9c03499ccc8f55e0ff86f19c0f66119", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502ef838c9c03499ccc8f55e0ff86f19c0f66119", "html_url": "https://github.com/Rust-GCC/gccrs/commit/502ef838c9c03499ccc8f55e0ff86f19c0f66119", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/502ef838c9c03499ccc8f55e0ff86f19c0f66119/comments", "author": {"login": "bonzini", "id": 42082, "node_id": "MDQ6VXNlcjQyMDgy", "avatar_url": "https://avatars.githubusercontent.com/u/42082?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bonzini", "html_url": "https://github.com/bonzini", "followers_url": "https://api.github.com/users/bonzini/followers", "following_url": "https://api.github.com/users/bonzini/following{/other_user}", "gists_url": "https://api.github.com/users/bonzini/gists{/gist_id}", "starred_url": "https://api.github.com/users/bonzini/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bonzini/subscriptions", "organizations_url": "https://api.github.com/users/bonzini/orgs", "repos_url": "https://api.github.com/users/bonzini/repos", "events_url": "https://api.github.com/users/bonzini/events{/privacy}", "received_events_url": "https://api.github.com/users/bonzini/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f37b4faa861a11d51332bde2dc3118d39f1e2051", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f37b4faa861a11d51332bde2dc3118d39f1e2051", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f37b4faa861a11d51332bde2dc3118d39f1e2051"}], "stats": {"total": 412, "additions": 137, "deletions": 275}, "files": [{"sha": "34ef13924aff2d5732be3846db96e2bfe23c91da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=502ef838c9c03499ccc8f55e0ff86f19c0f66119", "patch": "@@ -1,3 +1,37 @@\n+2010-09-04  Paolo Bonzini  <bonzini@gnu.org>\n+\n+\t* df.h (enum df_ref_class): Remove DF_REF_EXTRACT.\n+\t(struct df_extract_ref): Remove.\n+\t(union df_ref_d): Remove extract_ref member.\n+\t(df_ref_create): Remove last three arguments.\n+\t(DF_REF_LOC): Remove DF_REF_EXTRACT case.\n+\t* df-scan.c (df_ref_record): Remove last three arguments, do not\n+\tpass them to df_ref_create_structure.\n+\t(df_uses_record): Remove first and last three arguments.  Replace\n+\tfirst argument with DF_REF_REGULAR, adjust calls to remove the\n+\twidth, offset and mode.  Always call recursively on the second\n+\tand third argument of ZERO_EXTRACT and SIGN_EXTRACT.\n+\t(df_ref_create_structure): Remove first argument.\n+\t(struct df_scan_problem_data): Remove ref_extract_pool.\n+\t(df_scan_free_internal): Do not free it.\n+\t(df_scan_alloc): Do not allocate it.\n+\t(df_ref_create): Remove last three arguments, do not pass them to\n+\tdf_ref_create_structure.\n+\t(df_free_ref): Remove DF_REF_EXTRACT case.\n+\t(df_notes_rescan): Adjust call to df_uses_record.\n+\t(df_ref_equal_p, df_ref_compare, df_ref_create_structure):\n+\tRemove DF_REF_EXTRACT case.\n+\t(df_def_record_1): Do not special case class for a ZERO_EXTRACT lhs.\n+\tAdjust calls to df_ref_record, using DF_REF_REGULAR for all REG\n+\tand SUBREG definitions.\n+\t(df_get_conditional_uses): Remove references to width/offset/mode,\n+\tadjust call to df_ref_create_structure.\n+\t(df_get_call_refs, df_insn_refs_collect, df_bb_refs_collect,\n+\tdf_entry_block_defs_collect, df_exit_block_uses_collect): Adjust\n+\tcalls to df_uses_record and df_ref_record.\n+\t* fwprop.c (update_df): Remove references to width/offset/mode,\n+\tadjust call to df_ref_create.\n+\n 2010-09-03  Jan Hubicka  <jh@suse.cz>\n \n \t* ipa.c (build_cdtor): Take VECtor as argument; fix array walk."}, {"sha": "f98df02f4238c6947a8821a46730b52641a757e8", "filename": "gcc/df-scan.c", "status": "modified", "additions": 99, "deletions": 245, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=502ef838c9c03499ccc8f55e0ff86f19c0f66119", "patch": "@@ -110,26 +110,22 @@ static struct df_mw_hardreg * df_null_mw_rec[1];\n static void df_ref_record (enum df_ref_class, struct df_collection_rec *,\n \t\t\t   rtx, rtx *,\n \t\t\t   basic_block, struct df_insn_info *,\n-\t\t\t   enum df_ref_type, int ref_flags,\n-\t\t\t   int, int, enum machine_mode);\n+\t\t\t   enum df_ref_type, int ref_flags);\n static void df_def_record_1 (struct df_collection_rec *, rtx,\n \t\t\t     basic_block, struct df_insn_info *,\n \t\t\t     int ref_flags);\n static void df_defs_record (struct df_collection_rec *, rtx,\n \t\t\t    basic_block, struct df_insn_info *,\n \t\t\t    int ref_flags);\n-static void df_uses_record (enum df_ref_class, struct df_collection_rec *,\n+static void df_uses_record (struct df_collection_rec *,\n \t\t\t    rtx *, enum df_ref_type,\n \t\t\t    basic_block, struct df_insn_info *,\n-\t\t\t    int ref_flags,\n-\t\t\t    int, int, enum machine_mode);\n+\t\t\t    int ref_flags);\n \n static df_ref df_ref_create_structure (enum df_ref_class,\n \t\t\t\t       struct df_collection_rec *, rtx, rtx *,\n \t\t\t\t       basic_block, struct df_insn_info *,\n-\t\t\t\t       enum df_ref_type, int ref_flags,\n-\t\t\t\t       int, int, enum machine_mode);\n-\n+\t\t\t\t       enum df_ref_type, int ref_flags);\n static void df_insn_refs_collect (struct df_collection_rec*,\n \t\t\t\t  basic_block, struct df_insn_info *);\n static void df_canonize_collection_rec (struct df_collection_rec *);\n@@ -182,7 +178,6 @@ struct df_scan_problem_data\n   alloc_pool ref_base_pool;\n   alloc_pool ref_artificial_pool;\n   alloc_pool ref_regular_pool;\n-  alloc_pool ref_extract_pool;\n   alloc_pool insn_pool;\n   alloc_pool reg_pool;\n   alloc_pool mw_reg_pool;\n@@ -269,7 +264,6 @@ df_scan_free_internal (void)\n   free_alloc_pool (problem_data->ref_base_pool);\n   free_alloc_pool (problem_data->ref_artificial_pool);\n   free_alloc_pool (problem_data->ref_regular_pool);\n-  free_alloc_pool (problem_data->ref_extract_pool);\n   free_alloc_pool (problem_data->insn_pool);\n   free_alloc_pool (problem_data->reg_pool);\n   free_alloc_pool (problem_data->mw_reg_pool);\n@@ -344,9 +338,6 @@ df_scan_alloc (bitmap all_blocks ATTRIBUTE_UNUSED)\n   problem_data->ref_regular_pool\n     = create_alloc_pool (\"df_scan ref regular\",\n \t\t\t sizeof (struct df_regular_ref), block_size);\n-  problem_data->ref_extract_pool\n-    = create_alloc_pool (\"df_scan ref extract\",\n-\t\t\t sizeof (struct df_extract_ref), block_size);\n   problem_data->insn_pool\n     = create_alloc_pool (\"df_scan insn\",\n \t\t\t sizeof (struct df_insn_info), block_size);\n@@ -689,19 +680,13 @@ df_scan_blocks (void)\n \n \n /* Create a new ref of type DF_REF_TYPE for register REG at address\n-   LOC within INSN of BB.  This function is only used externally.\n-\n-   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n-   fields if they were constants.  Otherwise they should be -1 if\n-   those flags were set.  */\n+   LOC within INSN of BB.  This function is only used externally.  */\n \n df_ref\n df_ref_create (rtx reg, rtx *loc, rtx insn,\n \t       basic_block bb,\n \t       enum df_ref_type ref_type,\n-\t       int ref_flags,\n-\t       int width, int offset, enum machine_mode mode)\n+\t       int ref_flags)\n {\n   df_ref ref;\n   struct df_reg_info **reg_info;\n@@ -717,15 +702,12 @@ df_ref_create (rtx reg, rtx *loc, rtx insn,\n   /* You cannot hack artificial refs.  */\n   gcc_assert (insn);\n \n-  if (width != -1 || offset != -1)\n-    cl = DF_REF_EXTRACT;\n-  else if (loc)\n+  if (loc)\n     cl = DF_REF_REGULAR;\n   else\n     cl = DF_REF_BASE;\n   ref = df_ref_create_structure (cl, NULL, reg, loc, bb, DF_INSN_INFO_GET (insn),\n-                                 ref_type, ref_flags,\n-\t\t\t\t width, offset, mode);\n+                                 ref_type, ref_flags);\n \n   if (DF_REF_REG_DEF_P (ref))\n     {\n@@ -843,10 +825,6 @@ df_free_ref (df_ref ref)\n     case DF_REF_REGULAR:\n       pool_free (problem_data->ref_regular_pool, ref);\n       break;\n-\n-    case DF_REF_EXTRACT:\n-      pool_free (problem_data->ref_extract_pool, ref);\n-      break;\n     }\n }\n \n@@ -2011,7 +1989,7 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df,\n   while (the_ref)\n     {\n       if ((!DF_REF_IS_ARTIFICIAL (the_ref))\n-\t  && (DF_REF_LOC (the_ref))\n+\t  && DF_REF_LOC (the_ref)\n \t  && (*DF_REF_LOC (the_ref) == loc))\n \t{\n \t  df_ref next_ref = DF_REF_NEXT_REG (the_ref);\n@@ -2214,9 +2192,9 @@ df_notes_rescan (rtx insn)\n \t    {\n \t    case REG_EQUIV:\n \t    case REG_EQUAL:\n-\t      df_uses_record (DF_REF_REGULAR, &collection_rec,\n+\t      df_uses_record (&collection_rec,\n \t\t\t      &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t      bb, insn_info, DF_REF_IN_NOTE, -1, -1, VOIDmode);\n+\t\t\t      bb, insn_info, DF_REF_IN_NOTE);\n \t    default:\n \t      break;\n \t    }\n@@ -2310,13 +2288,6 @@ df_ref_equal_p (df_ref ref1, df_ref ref2)\n     case DF_REF_BASE:\n       return true;\n \n-    case DF_REF_EXTRACT:\n-      if ((DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n-\t  || (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n-\t  || (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2)))\n-\treturn false;\n-      /* fallthru.  */\n-\n     case DF_REF_REGULAR:\n       return DF_REF_LOC (ref1) == DF_REF_LOC (ref2);\n \n@@ -2371,17 +2342,6 @@ df_ref_compare (const void *r1, const void *r2)\n \treturn 1;\n     }\n \n-  /* The classes are the same at this point so it is safe to only look\n-     at ref1.  */\n-  if (DF_REF_CLASS (ref1) == DF_REF_EXTRACT)\n-    {\n-      if (DF_REF_EXTRACT_OFFSET (ref1) != DF_REF_EXTRACT_OFFSET (ref2))\n-\treturn DF_REF_EXTRACT_OFFSET (ref1) - DF_REF_EXTRACT_OFFSET (ref2);\n-      if (DF_REF_EXTRACT_WIDTH (ref1) != DF_REF_EXTRACT_WIDTH (ref2))\n-\treturn DF_REF_EXTRACT_WIDTH (ref1) - DF_REF_EXTRACT_WIDTH (ref2);\n-      if (DF_REF_EXTRACT_MODE (ref1) != DF_REF_EXTRACT_MODE (ref2))\n-\treturn DF_REF_EXTRACT_MODE (ref1) - DF_REF_EXTRACT_MODE (ref2);\n-    }\n   return (int)DF_REF_ORDER (ref1) - (int)DF_REF_ORDER (ref2);\n }\n \n@@ -2762,21 +2722,15 @@ df_refs_add_to_chains (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Allocate a ref and initialize its fields.\n-\n-   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the fields\n-   if they were constants.  Otherwise they should be -1 if those flags\n-   were set.  */\n+/* Allocate a ref and initialize its fields.  */\n \n static df_ref\n df_ref_create_structure (enum df_ref_class cl,\n \t\t\t struct df_collection_rec *collection_rec,\n \t\t\t rtx reg, rtx *loc,\n \t\t\t basic_block bb, struct df_insn_info *info,\n \t\t\t enum df_ref_type ref_type,\n-\t\t\t int ref_flags,\n-\t\t\t int width, int offset, enum machine_mode mode)\n+\t\t\t int ref_flags)\n {\n   df_ref this_ref = NULL;\n   int regno = REGNO (GET_CODE (reg) == SUBREG ? SUBREG_REG (reg) : reg);\n@@ -2801,15 +2755,6 @@ df_ref_create_structure (enum df_ref_class cl,\n       this_ref->regular_ref.loc = loc;\n       gcc_checking_assert (loc);\n       break;\n-\n-    case DF_REF_EXTRACT:\n-      this_ref = (df_ref) pool_alloc (problem_data->ref_extract_pool);\n-      DF_REF_EXTRACT_WIDTH (this_ref) = width;\n-      DF_REF_EXTRACT_OFFSET (this_ref) = offset;\n-      DF_REF_EXTRACT_MODE (this_ref) = mode;\n-      this_ref->regular_ref.loc = loc;\n-      gcc_checking_assert (loc);\n-      break;\n     }\n \n   DF_REF_CLASS (this_ref) = cl;\n@@ -2859,12 +2804,7 @@ df_ref_create_structure (enum df_ref_class cl,\n \n \n /* Create new references of type DF_REF_TYPE for each part of register REG\n-   at address LOC within INSN of BB.\n-\n-   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n-   fields if they were constants.  Otherwise they should be -1 if\n-   those flags were set.  */\n+   at address LOC within INSN of BB.  */\n \n \n static void\n@@ -2873,8 +2813,7 @@ df_ref_record (enum df_ref_class cl,\n                rtx reg, rtx *loc,\n \t       basic_block bb, struct df_insn_info *insn_info,\n \t       enum df_ref_type ref_type,\n-\t       int ref_flags,\n-\t       int width, int offset, enum machine_mode mode)\n+\t       int ref_flags)\n {\n   unsigned int regno;\n \n@@ -2924,16 +2863,15 @@ df_ref_record (enum df_ref_class cl,\n       for (i = regno; i < endregno; i++)\n \t{\n \t  ref = df_ref_create_structure (cl, collection_rec, regno_reg_rtx[i], loc,\n-\t\t\t\t\t bb, insn_info, ref_type, ref_flags,\n-\t\t\t\t\t width, offset, mode);\n+\t\t\t\t\t bb, insn_info, ref_type, ref_flags);\n \n           gcc_assert (ORIGINAL_REGNO (DF_REF_REG (ref)) == i);\n \t}\n     }\n   else\n     {\n       df_ref_create_structure (cl, collection_rec, reg, loc, bb, insn_info,\n-\t\t\t       ref_type, ref_flags, width, offset, mode);\n+\t\t\t       ref_type, ref_flags);\n     }\n }\n \n@@ -2967,10 +2905,6 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n {\n   rtx *loc;\n   rtx dst;\n-  int offset = -1;\n-  int width = -1;\n-  enum machine_mode mode = VOIDmode;\n-  enum df_ref_class cl = DF_REF_REGULAR;\n \n  /* We may recursively call ourselves on EXPR_LIST when dealing with PARALLEL\n      construct.  */\n@@ -3010,32 +2944,21 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n     {\n       flags |= DF_REF_READ_WRITE | DF_REF_PARTIAL | DF_REF_ZERO_EXTRACT;\n \n-      if (CONST_INT_P (XEXP (dst, 1))\n-\t  && CONST_INT_P (XEXP (dst, 2)))\n-\t{\n-\t  width = INTVAL (XEXP (dst, 1));\n-\t  offset = INTVAL (XEXP (dst, 2));\n-\t  mode = GET_MODE (dst);\n-\t  cl = DF_REF_EXTRACT;\n-\t}\n-\n       loc = &XEXP (dst, 0);\n       dst = *loc;\n     }\n \n   /* At this point if we do not have a reg or a subreg, just return.  */\n   if (REG_P (dst))\n     {\n-      df_ref_record (cl, collection_rec,\n-\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags,\n-\t\t     width, offset, mode);\n+      df_ref_record (DF_REF_REGULAR, collection_rec,\n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags);\n \n       /* We want to keep sp alive everywhere - by making all\n \t writes to sp also use of sp. */\n       if (REGNO (dst) == STACK_POINTER_REGNUM)\n \tdf_ref_record (DF_REF_BASE, collection_rec,\n-\t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags,\n-\t\t       width, offset, mode);\n+\t\t       dst, NULL, bb, insn_info, DF_REF_REG_USE, flags);\n     }\n   else if (GET_CODE (dst) == SUBREG && REG_P (SUBREG_REG (dst)))\n     {\n@@ -3044,9 +2967,8 @@ df_def_record_1 (struct df_collection_rec *collection_rec,\n \n       flags |= DF_REF_SUBREG;\n \n-      df_ref_record (cl, collection_rec,\n-\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags,\n-\t\t     width, offset, mode);\n+      df_ref_record (DF_REF_REGULAR, collection_rec,\n+\t\t     dst, loc, bb, insn_info, DF_REF_REG_DEF, flags);\n     }\n }\n \n@@ -3083,19 +3005,13 @@ df_defs_record (struct df_collection_rec *collection_rec,\n }\n \n \n-/* Process all the registers used in the rtx at address LOC.\n-\n-   If the REF_FLAGS field contain DF_REF_SIGN_EXTRACT or\n-   DF_REF_ZERO_EXTRACT.  WIDTH, OFFSET and MODE are used to access the\n-   fields if they were constants.  Otherwise they should be -1 if\n-   those flags were set.  */\n+/* Process all the registers used in the rtx at address LOC.  */\n \n static void\n-df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n+df_uses_record (struct df_collection_rec *collection_rec,\n                 rtx *loc, enum df_ref_type ref_type,\n \t\tbasic_block bb, struct df_insn_info *insn_info,\n-\t\tint flags,\n-\t\tint width, int offset, enum machine_mode mode)\n+\t\tint flags)\n {\n   RTX_CODE code;\n   rtx x;\n@@ -3124,20 +3040,19 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n       /* If we are clobbering a MEM, mark any registers inside the address\n \t as being used.  */\n       if (MEM_P (XEXP (x, 0)))\n-\tdf_uses_record (cl, collection_rec,\n+\tdf_uses_record (collection_rec,\n \t\t\t&XEXP (XEXP (x, 0), 0),\n \t\t\tDF_REF_REG_MEM_STORE,\n \t\t        bb, insn_info,\n-\t\t\tflags, width, offset, mode);\n+\t\t\tflags);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n     case MEM:\n-      df_uses_record (cl, collection_rec,\n+      df_uses_record (collection_rec,\n \t\t      &XEXP (x, 0), DF_REF_REG_MEM_LOAD,\n-\t\t      bb, insn_info, flags & DF_REF_IN_NOTE,\n-\t\t      width, offset, mode);\n+\t\t      bb, insn_info, flags & DF_REF_IN_NOTE);\n       return;\n \n     case SUBREG:\n@@ -3147,62 +3062,54 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n       if (!REG_P (SUBREG_REG (x)))\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (cl, collection_rec, loc, ref_type, bb, insn_info, flags,\n-\t\t\t  width, offset, mode);\n+\t  df_uses_record (collection_rec, loc, ref_type, bb, insn_info, flags);\n \t  return;\n \t}\n       /* ... Fall through ...  */\n \n     case REG:\n-      df_ref_record (cl, collection_rec,\n+      df_ref_record (DF_REF_REGULAR, collection_rec,\n \t\t     x, loc, bb, insn_info,\n-\t\t     ref_type, flags,\n-\t\t     width, offset, mode);\n+\t\t     ref_type, flags);\n       return;\n \n     case SIGN_EXTRACT:\n     case ZERO_EXTRACT:\n       {\n-\t/* If the parameters to the zero or sign extract are\n-\t   constants, strip them off and recurse, otherwise there is\n-\t   no information that we can gain from this operation.  */\n-\tif (CONST_INT_P (XEXP (x, 1))\n-\t    && CONST_INT_P (XEXP (x, 2)))\n-\t  {\n-\t    width = INTVAL (XEXP (x, 1));\n-\t    offset = INTVAL (XEXP (x, 2));\n-\t    mode = GET_MODE (x);\n-\n-\t    if (code == ZERO_EXTRACT)\n-\t      flags |= DF_REF_ZERO_EXTRACT;\n-\t    else\n-\t      flags |= DF_REF_SIGN_EXTRACT;\n-\n-\t    df_uses_record (DF_REF_EXTRACT, collection_rec,\n-\t\t\t    &XEXP (x, 0), ref_type, bb, insn_info, flags,\n-\t\t\t    width, offset, mode);\n-\t    return;\n-\t  }\n+        df_uses_record (collection_rec,\n+                        &XEXP (x, 1), ref_type, bb, insn_info, flags);\n+        df_uses_record (collection_rec,\n+                        &XEXP (x, 2), ref_type, bb, insn_info, flags);\n+\n+        /* If the parameters to the zero or sign extract are\n+           constants, strip them off and recurse, otherwise there is\n+           no information that we can gain from this operation.  */\n+        if (code == ZERO_EXTRACT)\n+          flags |= DF_REF_ZERO_EXTRACT;\n+        else\n+          flags |= DF_REF_SIGN_EXTRACT;\n+\n+        df_uses_record (collection_rec,\n+                        &XEXP (x, 0), ref_type, bb, insn_info, flags);\n+        return;\n       }\n       break;\n \n     case SET:\n       {\n \trtx dst = SET_DEST (x);\n \tgcc_assert (!(flags & DF_REF_IN_NOTE));\n-\tdf_uses_record (cl, collection_rec,\n-\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags,\n-\t\t\twidth, offset, mode);\n+\tdf_uses_record (collection_rec,\n+\t\t\t&SET_SRC (x), DF_REF_REG_USE, bb, insn_info, flags);\n \n \tswitch (GET_CODE (dst))\n \t  {\n \t    case SUBREG:\n \t      if (df_read_modify_subreg_p (dst))\n \t\t{\n-\t\t  df_uses_record (cl, collection_rec, &SUBREG_REG (dst),\n+\t\t  df_uses_record (collection_rec, &SUBREG_REG (dst),\n \t\t\t\t  DF_REF_REG_USE, bb, insn_info,\n-\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG,\n-\t\t\t\t  width, offset, mode);\n+\t\t\t\t  flags | DF_REF_READ_WRITE | DF_REF_SUBREG);\n \t\t  break;\n \t\t}\n \t      /* Fall through.  */\n@@ -3213,63 +3120,35 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t    case CC0:\n \t\tbreak;\n \t    case MEM:\n-\t      df_uses_record (cl, collection_rec, &XEXP (dst, 0),\n-\t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags,\n-\t\t\t      width, offset, mode);\n+\t      df_uses_record (collection_rec, &XEXP (dst, 0),\n+\t\t\t      DF_REF_REG_MEM_STORE, bb, insn_info, flags);\n \t      break;\n \t    case STRICT_LOW_PART:\n \t      {\n \t\trtx *temp = &XEXP (dst, 0);\n \t\t/* A strict_low_part uses the whole REG and not just the\n \t\t SUBREG.  */\n \t\tdst = XEXP (dst, 0);\n-\t\tdf_uses_record (cl, collection_rec,\n+\t\tdf_uses_record (collection_rec,\n \t\t\t\t(GET_CODE (dst) == SUBREG) ? &SUBREG_REG (dst) : temp,\n \t\t\t\tDF_REF_REG_USE, bb, insn_info,\n-\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART,\n-\t\t\t\twidth, offset, mode);\n+\t\t\t\tDF_REF_READ_WRITE | DF_REF_STRICT_LOW_PART);\n \t      }\n \t      break;\n \t    case ZERO_EXTRACT:\n \t      {\n-\t\tif (CONST_INT_P (XEXP (dst, 1))\n-\t\t    && CONST_INT_P (XEXP (dst, 2)))\n-\t\t  {\n-\t\t    width = INTVAL (XEXP (dst, 1));\n-\t\t    offset = INTVAL (XEXP (dst, 2));\n-\t\t    mode = GET_MODE (dst);\n-\t\t    if (GET_CODE (XEXP (dst,0)) == MEM)\n-\t\t      {\n-\t\t\t/* Handle the case of zero_extract(mem(...)) in the set dest.\n-\t\t\t   This special case is allowed only if the mem is a single byte and\n-\t\t\t   is useful to set a bitfield in memory.  */\n-\t\t\tdf_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (XEXP (dst,0), 0),\n-\t\t\t\t\tDF_REF_REG_MEM_STORE, bb, insn_info,\n-\t\t\t\t\tDF_REF_ZERO_EXTRACT,\n-\t\t\t\t\twidth, offset, mode);\n-\t\t      }\n-\t\t    else\n-\t\t      {\n-\t\t\tdf_uses_record (DF_REF_EXTRACT, collection_rec, &XEXP (dst, 0),\n-\t\t\t\t\tDF_REF_REG_USE, bb, insn_info,\n-\t\t\t\t\tDF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT,\n-\t\t\t\t\twidth, offset, mode);\n-\t\t      }\n-\t\t  }\n-\t\telse\n-\t\t  {\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 1),\n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags,\n-\t\t\t\t    width, offset, mode);\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 2),\n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info, flags,\n-\t\t\t\t    width, offset, mode);\n-\t\t    df_uses_record (cl, collection_rec, &XEXP (dst, 0),\n-\t\t\t\t    DF_REF_REG_USE, bb, insn_info,\n-\t\t\t\t    DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT,\n-\t\t\t\t    width, offset, mode);\n-\t\t  }\n-\n+\t\tdf_uses_record (collection_rec, &XEXP (dst, 1),\n+\t\t\t\tDF_REF_REG_USE, bb, insn_info, flags);\n+\t\tdf_uses_record (collection_rec, &XEXP (dst, 2),\n+\t\t\t\tDF_REF_REG_USE, bb, insn_info, flags);\n+                if (GET_CODE (XEXP (dst,0)) == MEM)\n+                  df_uses_record (collection_rec, &XEXP (dst, 0),\n+                                  DF_REF_REG_USE, bb, insn_info,\n+                                  flags);\n+                else\n+                  df_uses_record (collection_rec, &XEXP (dst, 0),\n+                                  DF_REF_REG_USE, bb, insn_info,\n+                                  DF_REF_READ_WRITE | DF_REF_ZERO_EXTRACT);\n \t      }\n \t      break;\n \n@@ -3318,19 +3197,17 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t    int j;\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n-\t      df_uses_record (cl, collection_rec, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn_info, flags,\n-\t\t\t      width, offset, mode);\n+\t      df_uses_record (collection_rec, &ASM_OPERANDS_INPUT (x, j),\n+\t\t\t      DF_REF_REG_USE, bb, insn_info, flags);\n \t    return;\n \t  }\n \tbreak;\n       }\n \n     case VAR_LOCATION:\n-      df_uses_record (cl, collection_rec,\n+      df_uses_record (collection_rec,\n \t\t      &PAT_VAR_LOCATION_LOC (x),\n-\t\t      DF_REF_REG_USE, bb, insn_info,\n-\t\t      flags, width, offset, mode);\n+\t\t      DF_REF_REG_USE, bb, insn_info, flags);\n       return;\n \n     case PRE_DEC:\n@@ -3341,11 +3218,10 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n     case POST_MODIFY:\n       gcc_assert (!DEBUG_INSN_P (insn_info->insn));\n       /* Catch the def of the register being modified.  */\n-      df_ref_record (cl, collection_rec, XEXP (x, 0), &XEXP (x, 0),\n+      df_ref_record (DF_REF_REGULAR, collection_rec, XEXP (x, 0), &XEXP (x, 0),\n \t\t     bb, insn_info,\n \t\t     DF_REF_REG_DEF,\n-                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY,\n-\t\t     width, offset, mode);\n+                     flags | DF_REF_READ_WRITE | DF_REF_PRE_POST_MODIFY);\n \n       /* ... Fall through to handle uses ...  */\n \n@@ -3368,18 +3244,16 @@ df_uses_record (enum df_ref_class cl, struct df_collection_rec *collection_rec,\n \t\tloc = &XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    df_uses_record (cl, collection_rec, &XEXP (x, i), ref_type,\n-\t\t\t    bb, insn_info, flags,\n-\t\t\t    width, offset, mode);\n+\t    df_uses_record (collection_rec, &XEXP (x, i), ref_type,\n+\t\t\t    bb, insn_info, flags);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n-\t      df_uses_record (cl, collection_rec,\n+\t      df_uses_record (collection_rec,\n \t\t\t      &XVECEXP (x, i, j), ref_type,\n-\t\t\t      bb, insn_info, flags,\n-\t\t\t      width, offset, mode);\n+\t\t\t      bb, insn_info, flags);\n \t  }\n       }\n   }\n@@ -3400,23 +3274,12 @@ df_get_conditional_uses (struct df_collection_rec *collection_rec)\n     {\n       if (DF_REF_FLAGS_IS_SET (ref, DF_REF_CONDITIONAL))\n         {\n-\t  int width = -1;\n-\t  int offset = -1;\n-\t  enum machine_mode mode = VOIDmode;\n           df_ref use;\n \n-\t  if (DF_REF_FLAGS_IS_SET (ref, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-\t    {\n-\t      width = DF_REF_EXTRACT_WIDTH (ref);\n-\t      offset = DF_REF_EXTRACT_OFFSET (ref);\n-\t      mode = DF_REF_EXTRACT_MODE (ref);\n-\t    }\n-\n           use = df_ref_create_structure (DF_REF_CLASS (ref), collection_rec, DF_REF_REG (ref),\n \t\t\t\t\t DF_REF_LOC (ref), DF_REF_BB (ref),\n \t\t\t\t\t DF_REF_INSN_INFO (ref), DF_REF_REG_USE,\n-\t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL,\n-\t\t\t\t\t width, offset, mode);\n+\t\t\t\t\t DF_REF_FLAGS (ref) & ~DF_REF_CONDITIONAL);\n           DF_REF_REGNO (use) = DF_REF_REGNO (ref);\n         }\n     }\n@@ -3453,9 +3316,8 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n        note = XEXP (note, 1))\n     {\n       if (GET_CODE (XEXP (note, 0)) == USE)\n-        df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (XEXP (note, 0), 0),\n-\t\t\tDF_REF_REG_USE, bb, insn_info, flags, -1, -1,\n-\t\t\tVOIDmode);\n+        df_uses_record (collection_rec, &XEXP (XEXP (note, 0), 0),\n+\t\t\tDF_REF_REG_USE, bb, insn_info, flags);\n       else if (GET_CODE (XEXP (note, 0)) == CLOBBER)\n \t{\n \t  if (REG_P (XEXP (XEXP (note, 0), 0)))\n@@ -3466,29 +3328,25 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t\t\t\tinsn_info, flags);\n \t    }\n \t  else\n-\t    df_uses_record (DF_REF_REGULAR, collection_rec, &XEXP (note, 0),\n-\t\t            DF_REF_REG_USE, bb, insn_info, flags, -1, -1,\n-\t\t\t    VOIDmode);\n+\t    df_uses_record (collection_rec, &XEXP (note, 0),\n+\t\t            DF_REF_REG_USE, bb, insn_info, flags);\n \t}\n     }\n \n   /* The stack ptr is used (honorarily) by a CALL insn.  */\n   df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[STACK_POINTER_REGNUM],\n \t\t NULL, bb, insn_info, DF_REF_REG_USE,\n-\t\t DF_REF_CALL_STACK_USAGE | flags,\n-\t\t -1, -1, VOIDmode);\n+\t\t DF_REF_CALL_STACK_USAGE | flags);\n \n   /* Calls may also reference any of the global registers,\n      so they are recorded as used.  */\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n     if (global_regs[i])\n       {\n \tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags, -1, -1,\n-\t\t       VOIDmode);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_USE, flags);\n \tdf_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[i],\n-\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags, -1, -1,\n-\t\t       VOIDmode);\n+\t\t       NULL, bb, insn_info, DF_REF_REG_DEF, flags);\n       }\n \n   is_sibling_call = SIBLING_CALL_P (insn_info->insn);\n@@ -3502,8 +3360,7 @@ df_get_call_refs (struct df_collection_rec * collection_rec,\n \t\t\t\t    crtl->return_rtx, NULL)))\n         df_ref_record (DF_REF_BASE, collection_rec, regno_reg_rtx[ui],\n \t\t       NULL, bb, insn_info, DF_REF_REG_DEF,\n-\t\t       DF_REF_MAY_CLOBBER | flags,\n-\t\t       -1, -1, VOIDmode);\n+\t\t       DF_REF_MAY_CLOBBER | flags);\n     }\n \n   bitmap_clear (&defs_generated);\n@@ -3539,21 +3396,21 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n         {\n         case REG_EQUIV:\n         case REG_EQUAL:\n-          df_uses_record (DF_REF_REGULAR, collection_rec,\n+          df_uses_record (collection_rec,\n                           &XEXP (note, 0), DF_REF_REG_USE,\n-                          bb, insn_info, DF_REF_IN_NOTE, -1, -1, VOIDmode);\n+                          bb, insn_info, DF_REF_IN_NOTE);\n           break;\n         case REG_NON_LOCAL_GOTO:\n           /* The frame ptr is used by a non-local goto.  */\n           df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n-                         DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n+                         DF_REF_REG_USE, 0);\n #if FRAME_POINTER_REGNUM != HARD_FRAME_POINTER_REGNUM\n           df_ref_record (DF_REF_BASE, collection_rec,\n                          regno_reg_rtx[HARD_FRAME_POINTER_REGNUM],\n                          NULL, bb, insn_info,\n-                         DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n+                         DF_REF_REG_USE, 0);\n #endif\n           break;\n         default:\n@@ -3566,9 +3423,8 @@ df_insn_refs_collect (struct df_collection_rec* collection_rec,\n \t\t      (is_cond_exec) ? DF_REF_CONDITIONAL : 0);\n \n   /* Record the register uses.  */\n-  df_uses_record (DF_REF_REGULAR, collection_rec,\n-\t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0,\n-\t\t  -1, -1, VOIDmode);\n+  df_uses_record (collection_rec,\n+\t\t  &PATTERN (insn_info->insn), DF_REF_REG_USE, bb, insn_info, 0);\n \n   /* DF_REF_CONDITIONAL needs corresponding USES. */\n   if (is_cond_exec)\n@@ -3639,8 +3495,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n \t  if (regno == INVALID_REGNUM)\n \t    break;\n \t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1,\n-\t\t\t VOIDmode);\n+\t\t\t bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP);\n \t}\n     }\n #endif\n@@ -3649,7 +3504,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n      non-local goto.  */\n   if (bb->flags & BB_NON_LOCAL_GOTO_TARGET)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, hard_frame_pointer_rtx, NULL,\n-\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP, -1, -1, VOIDmode);\n+\t\t   bb, NULL, DF_REF_REG_DEF, DF_REF_AT_TOP);\n \n   /* Add the artificial uses.  */\n   if (bb->index >= NUM_FIXED_BLOCKS)\n@@ -3663,7 +3518,7 @@ df_bb_refs_collect (struct df_collection_rec *collection_rec, basic_block bb)\n       EXECUTE_IF_SET_IN_BITMAP (au, 0, regno, bi)\n \t{\n \t  df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[regno], NULL,\n-\t\t\t bb, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n+\t\t\t bb, NULL, DF_REF_REG_USE, 0);\n \t}\n     }\n \n@@ -3939,8 +3794,7 @@ df_entry_block_defs_collect (struct df_collection_rec *collection_rec,\n   EXECUTE_IF_SET_IN_BITMAP (entry_block_defs, 0, i, bi)\n     {\n       df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n-\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0, -1, -1,\n-\t\t     VOIDmode);\n+\t\t     ENTRY_BLOCK_PTR, NULL, DF_REF_REG_DEF, 0);\n     }\n \n   df_canonize_collection_rec (collection_rec);\n@@ -4102,7 +3956,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n \n   EXECUTE_IF_SET_IN_BITMAP (exit_block_uses, 0, i, bi)\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[i], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n \n #if FRAME_POINTER_REGNUM != ARG_POINTER_REGNUM\n   /* It is deliberate that this is not put in the exit block uses but\n@@ -4112,7 +3966,7 @@ df_exit_block_uses_collect (struct df_collection_rec *collection_rec, bitmap exi\n       && bb_has_eh_pred (EXIT_BLOCK_PTR)\n       && fixed_regs[ARG_POINTER_REGNUM])\n     df_ref_record (DF_REF_ARTIFICIAL, collection_rec, regno_reg_rtx[ARG_POINTER_REGNUM], NULL,\n-\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0, -1, -1, VOIDmode);\n+\t\t   EXIT_BLOCK_PTR, NULL, DF_REF_REG_USE, 0);\n #endif\n \n   df_canonize_collection_rec (collection_rec);"}, {"sha": "e52cc0e734e5c73b3dd316f0f5e75f4a1b9614d9", "filename": "gcc/df.h", "status": "modified", "additions": 3, "deletions": 18, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=502ef838c9c03499ccc8f55e0ff86f19c0f66119", "patch": "@@ -67,7 +67,7 @@ enum df_flow_dir\n   };\n \n /* Descriminator for the various df_ref types.  */\n-enum df_ref_class {DF_REF_BASE, DF_REF_ARTIFICIAL, DF_REF_REGULAR, DF_REF_EXTRACT};\n+enum df_ref_class {DF_REF_BASE, DF_REF_ARTIFICIAL, DF_REF_REGULAR};\n \n /* The first of these us a set of a registers.  The remaining three\n    are all uses of a register (the mem_load and mem_store relate to\n@@ -402,26 +402,12 @@ struct df_regular_ref\n   rtx *loc;\n };\n \n-\n-/* A df_ref_extract is just a df_ref with a width and offset field at\n-   the end of it.  It is used to hold this information if the ref was\n-   wrapped by a SIGN_EXTRACT or a ZERO_EXTRACT and to pass this info\n-   to passes that wish to process partial regs precisely.  */\n-struct df_extract_ref\n-{\n-  struct df_regular_ref base;\n-  int width;\n-  int offset;\n-  enum machine_mode mode;\n-};\n-\n /* Union of the different kinds of defs/uses placeholders.  */\n union df_ref_d\n {\n   struct df_base_ref base;\n   struct df_regular_ref regular_ref;\n   struct df_artificial_ref artificial_ref;\n-  struct df_extract_ref extract_ref;\n };\n typedef union df_ref_d *df_ref;\n \n@@ -645,7 +631,7 @@ struct df_d\n #define DF_REF_REAL_LOC(REF) (GET_CODE (*((REF)->regular_ref.loc)) == SUBREG \\\n                                ? &SUBREG_REG (*((REF)->regular_ref.loc)) : ((REF)->regular_ref.loc))\n #define DF_REF_REG(REF) ((REF)->base.reg)\n-#define DF_REF_LOC(REF) ((DF_REF_CLASS(REF) == DF_REF_REGULAR || DF_REF_CLASS(REF) == DF_REF_EXTRACT) ? \\\n+#define DF_REF_LOC(REF) (DF_REF_CLASS(REF) == DF_REF_REGULAR ? \\\n \t\t\t (REF)->regular_ref.loc : NULL)\n #define DF_REF_BB(REF) (DF_REF_IS_ARTIFICIAL(REF) ? \\\n                         (REF)->artificial_ref.bb : BLOCK_FOR_INSN (DF_REF_INSN(REF)))\n@@ -994,8 +980,7 @@ extern void df_grow_reg_info (void);\n extern void df_grow_insn_info (void);\n extern void df_scan_blocks (void);\n extern df_ref df_ref_create (rtx, rtx *, rtx,basic_block,\n-\t\t\t\t     enum df_ref_type, int ref_flags,\n-\t\t\t\t     int, int, enum machine_mode);\n+\t\t\t     enum df_ref_type, int ref_flags);\n extern void df_ref_remove (df_ref);\n extern struct df_insn_info * df_insn_create_insn_record (rtx);\n extern void df_insn_delete (basic_block, unsigned int);"}, {"sha": "006dca3cda923009615531fbe1680bfcac9fc289", "filename": "gcc/fwprop.c", "status": "modified", "additions": 1, "deletions": 12, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/502ef838c9c03499ccc8f55e0ff86f19c0f66119/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=502ef838c9c03499ccc8f55e0ff86f19c0f66119", "patch": "@@ -908,28 +908,17 @@ update_df (rtx insn, rtx *loc, df_ref *use_rec, enum df_ref_type type,\n     {\n       df_ref use = *use_rec;\n       df_ref orig_use = use, new_use;\n-      int width = -1;\n-      int offset = -1;\n-      enum machine_mode mode = VOIDmode;\n       rtx *new_loc = find_occurrence (loc, DF_REF_REG (orig_use));\n       use_rec++;\n \n       if (!new_loc)\n \tcontinue;\n \n-      if (DF_REF_FLAGS_IS_SET (orig_use, DF_REF_SIGN_EXTRACT | DF_REF_ZERO_EXTRACT))\n-\t{\n-\t  width = DF_REF_EXTRACT_WIDTH (orig_use);\n-\t  offset = DF_REF_EXTRACT_OFFSET (orig_use);\n-\t  mode = DF_REF_EXTRACT_MODE (orig_use);\n-\t}\n-\n       /* Add a new insn use.  Use the original type, because it says if the\n          use was within a MEM.  */\n       new_use = df_ref_create (DF_REF_REG (orig_use), new_loc,\n \t\t\t       insn, BLOCK_FOR_INSN (insn),\n-\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags,\n-\t\t\t       width, offset, mode);\n+\t\t\t       type, DF_REF_FLAGS (orig_use) | new_flags);\n \n       /* Set up the use-def chain.  */\n       gcc_assert (DF_REF_ID (new_use) == (int) VEC_length (df_ref, use_def_ref));"}]}