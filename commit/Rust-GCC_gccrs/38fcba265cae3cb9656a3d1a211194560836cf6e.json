{"sha": "38fcba265cae3cb9656a3d1a211194560836cf6e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzhmY2JhMjY1Y2FlM2NiOTY1NmEzZDFhMjExMTk0NTYwODM2Y2Y2ZQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:28:14Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-09-02T12:28:14Z"}, "message": "Initial revision\n\nFrom-SVN: r22173", "tree": {"sha": "4ccc5ddb33a38d06639679070617c3f9892f0f2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4ccc5ddb33a38d06639679070617c3f9892f0f2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/38fcba265cae3cb9656a3d1a211194560836cf6e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fcba265cae3cb9656a3d1a211194560836cf6e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38fcba265cae3cb9656a3d1a211194560836cf6e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38fcba265cae3cb9656a3d1a211194560836cf6e/comments", "author": null, "committer": null, "parents": [{"sha": "70126bf6730b22f344059a0690fab2a788621132", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70126bf6730b22f344059a0690fab2a788621132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70126bf6730b22f344059a0690fab2a788621132"}], "stats": {"total": 404, "additions": 404, "deletions": 0}, "files": [{"sha": "b28cedcfb5183ac40b56b4cd96ddb7189690d4b8", "filename": "libstdc++/stl/limits", "status": "added", "additions": 404, "deletions": 0, "changes": 404, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/38fcba265cae3cb9656a3d1a211194560836cf6e/libstdc%2B%2B%2Fstl%2Flimits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/38fcba265cae3cb9656a3d1a211194560836cf6e/libstdc%2B%2B%2Fstl%2Flimits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B%2Fstl%2Flimits?ref=38fcba265cae3cb9656a3d1a211194560836cf6e", "patch": "@@ -0,0 +1,404 @@\n+/*\n+ * Copyright (c) 1997\n+ * Silicon Graphics Computer Systems, Inc.\n+ *\n+ * Permission to use, copy, modify, distribute and sell this software\n+ * and its documentation for any purpose is hereby granted without fee,\n+ * provided that the above copyright notice appear in all copies and\n+ * that both that copyright notice and this permission notice appear\n+ * in supporting documentation.  Silicon Graphics makes no\n+ * representations about the suitability of this software for any\n+ * purpose.  It is provided \"as is\" without express or implied warranty.\n+ */\n+\n+/* NOTE: This is not portable code.  Parts of numeric_limits<> are\n+ * inherently machine-dependent, and this file is written for the MIPS\n+ * architecture and the SGI MIPSpro C++ compiler.  Parts of it (in\n+ * particular, some of the characteristics of floating-point types)\n+ * are almost certainly incorrect for any other platform.\n+ */\n+\n+#ifndef __SGI_CPP_LIMITS\n+#define __SGI_CPP_LIMITS\n+\n+#include <limits.h>\n+#include <float.h>\n+#include <stl_config.h>\n+\n+__STL_BEGIN_NAMESPACE\n+\n+enum float_round_style {\n+  round_indeterminate       = -1,\n+  round_toward_zero         =  0,\n+  round_to_nearest          =  1,\n+  round_toward_infinity     =  2,\n+  round_toward_neg_infinity =  3\n+};\n+  \n+\n+// Base class for all specializations of numeric_limits.\n+\n+template <class Number>\n+class __numeric_limits_base {\n+public:\n+  static const bool is_specialized = false;\n+\n+  static Number min() __STL_NOTHROW { return Number(); }\n+  static Number max() __STL_NOTHROW { return Number(); }\n+\n+  static const int digits   = 0;\n+  static const int digits10 = 0;\n+\n+  static const bool is_signed  = false;\n+  static const bool is_integer = false;\n+  static const bool is_exact   = false;\n+\n+  static const int radix = 0;\n+\n+  static Number epsilon() __STL_NOTHROW     { return Number(); }\n+  static Number round_error() __STL_NOTHROW { return Number(); }\n+\n+  static const int min_exponent   = 0;\n+  static const int min_exponent10 = 0;\n+  static const int max_exponent   = 0;\n+  static const int max_exponent10 = 0;\n+\n+  static const bool has_infinity      = false;\n+  static const bool has_quiet_NaN     = false;\n+  static const bool has_signaling_NaN = false;\n+  static const bool has_denorm        = false;\n+  static const bool has_denorm_loss   = false;\n+\n+  static Number infinity() __STL_NOTHROW      { return Number(); }\n+  static Number quiet_NaN() __STL_NOTHROW     { return Number(); }\n+  static Number signaling_NaN() __STL_NOTHROW { return Number(); }\n+  static Number denorm_min() __STL_NOTHROW    { return Number(); }\n+\n+  static const bool is_iec559  = false;\n+  static const bool is_bounded = false;\n+  static const bool is_modulo  = false;\n+\n+  static const bool traps           = false;\n+  static const bool tinyness_before = false;\n+  static const float_round_style round_style = round_toward_zero;\n+};\n+\n+#define __declare_numeric_base_member(__type, __mem) \\\n+template <class Number> \\\n+  const __type __numeric_limits_base<Number>:: __mem\n+\n+__declare_numeric_base_member(bool, is_specialized);\n+__declare_numeric_base_member(int, digits);\n+__declare_numeric_base_member(int, digits10);\n+__declare_numeric_base_member(bool, is_signed);\n+__declare_numeric_base_member(bool, is_integer);\n+__declare_numeric_base_member(bool, is_exact);\n+__declare_numeric_base_member(int, radix);\n+__declare_numeric_base_member(int, min_exponent);\n+__declare_numeric_base_member(int, max_exponent);\n+__declare_numeric_base_member(int, min_exponent10);\n+__declare_numeric_base_member(int, max_exponent10);\n+__declare_numeric_base_member(bool, has_infinity);\n+__declare_numeric_base_member(bool, has_quiet_NaN);\n+__declare_numeric_base_member(bool, has_signaling_NaN);\n+__declare_numeric_base_member(bool, has_denorm);\n+__declare_numeric_base_member(bool, has_denorm_loss);\n+__declare_numeric_base_member(bool, is_iec559);\n+__declare_numeric_base_member(bool, is_bounded);\n+__declare_numeric_base_member(bool, is_modulo);\n+__declare_numeric_base_member(bool, traps);\n+__declare_numeric_base_member(bool, tinyness_before);\n+__declare_numeric_base_member(float_round_style, round_style);\n+\n+#undef __declare_numeric_base_member\n+\n+// Base class for integers.\n+\n+template <class __Int,\n+          __Int IMin,\n+          __Int IMax,\n+          int IDigits = -1>\n+class __integer_limits : public __numeric_limits_base<__Int> \n+{\n+public:\n+  static const bool is_specialized = true;\n+\n+  static __Int min() __STL_NOTHROW { return IMin; }\n+  static __Int max() __STL_NOTHROW { return IMax; }\n+\n+  static const int digits = \n+    (IDigits < 0) ? sizeof(__Int) * CHAR_BIT - (IMin == 0 ? 0 : 1) : IDigits;\n+  static const int digits10 = (digits * 301) / 1000; \n+                                // log 2 = 0.301029995664...\n+\n+  static const bool is_signed = IMin != 0;\n+  static const bool is_integer = true;\n+  static const bool is_exact = true;\n+  static const int radix = 2;\n+\n+\n+  static const bool is_bounded = true;\n+  static const bool is_modulo = true;\n+};\n+\n+#define __declare_integer_limits_member(__type, __mem) \\\n+template <class __Int, __Int IMin, __Int IMax, int IDigits> \\\n+  const __type __integer_limits<__Int, IMin, IMax, IDigits>:: __mem\n+\n+__declare_integer_limits_member(bool, is_specialized);\n+__declare_integer_limits_member(int, digits);\n+__declare_integer_limits_member(int, digits10);\n+__declare_integer_limits_member(bool, is_signed);\n+__declare_integer_limits_member(bool, is_integer);\n+__declare_integer_limits_member(bool, is_exact);\n+__declare_integer_limits_member(int, radix);\n+__declare_integer_limits_member(bool, is_bounded);\n+__declare_integer_limits_member(bool, is_modulo);\n+\n+#undef __declare_integer_limits_member\n+\n+// Base class for floating-point numbers.\n+template <class Number,\n+         int FDigits, int FDigits10,\n+         int FMinExp, int FMaxExp,\n+         int FMinExp10, int FMaxExp10,\n+         unsigned int FInfinityWord,\n+         unsigned int FQNaNWord, unsigned int FSNaNWord,\n+         bool FIsIEC559,\n+         float_round_style FRoundStyle>\n+class __floating_limits : public __numeric_limits_base<Number>\n+{\n+public:\n+  static const bool is_specialized = true;\n+\n+  static const int digits   = FDigits;\n+  static const int digits10 = FDigits10;\n+\n+  static const bool is_signed = true;\n+\n+  static const int radix = 2;\n+\n+  static const int min_exponent   = FMinExp;\n+  static const int max_exponent   = FMaxExp;\n+  static const int min_exponent10 = FMinExp10;\n+  static const int max_exponent10 = FMaxExp10;\n+\n+  static const bool has_infinity      = true;\n+  static const bool has_quiet_NaN     = true;\n+  static const bool has_signaling_NaN = true;\n+  static const bool has_denorm        = false;\n+  static const bool has_denorm_loss   = false;\n+\n+  static Number infinity() __STL_NOTHROW {\n+    static unsigned int inf[sizeof(Number) / sizeof(int)] = { FInfinityWord };\n+    return *reinterpret_cast<Number*>(&inf);\n+  }\n+  static Number quiet_NaN() __STL_NOTHROW {\n+    static unsigned int nan[sizeof(Number) / sizeof(int)] = { FQNaNWord };\n+    return *reinterpret_cast<Number*>(&nan);\n+  }\n+  static Number signaling_NaN() __STL_NOTHROW {\n+    static unsigned int nan[sizeof(Number) / sizeof(int)] = { FSNaNWord };\n+    return *reinterpret_cast<Number*>(&nan);\n+  }\n+\n+  static const bool is_iec559       = FIsIEC559;\n+  static const bool is_bounded      = true;\n+  static const bool traps           = true;\n+  static const bool tinyness_before = false;\n+\n+  static const float_round_style round_style = FRoundStyle;\n+};\n+\n+#define __declare_float_limits_member(__type, __mem) \\\n+template <class __Num, int __Dig, int __Dig10, \\\n+          int __MnX, int __MxX, int __MnX10, int __MxX10, \\\n+          unsigned int __Inf, unsigned int __QNaN, unsigned int __SNaN, \\\n+          bool __IsIEEE, float_round_style __Sty> \\\n+const __type __floating_limits<__Num, __Dig, __Dig10, \\\n+                               __MnX, __MxX, __MnX10, __MxX10, \\\n+                               __Inf, __QNaN, __SNaN,__IsIEEE, __Sty>:: __mem\n+\n+__declare_float_limits_member(bool, is_specialized);  \n+__declare_float_limits_member(int, digits);  \n+__declare_float_limits_member(int, digits10);  \n+__declare_float_limits_member(bool, is_signed);  \n+__declare_float_limits_member(int, radix);  \n+__declare_float_limits_member(int, min_exponent);  \n+__declare_float_limits_member(int, max_exponent);  \n+__declare_float_limits_member(int, min_exponent10);  \n+__declare_float_limits_member(int, max_exponent10);  \n+__declare_float_limits_member(bool, has_infinity);\n+__declare_float_limits_member(bool, has_quiet_NaN);\n+__declare_float_limits_member(bool, has_signaling_NaN);\n+__declare_float_limits_member(bool, has_denorm);\n+__declare_float_limits_member(bool, has_denorm_loss);\n+__declare_float_limits_member(bool, is_iec559);\n+__declare_float_limits_member(bool, is_bounded);\n+__declare_float_limits_member(bool, traps);\n+__declare_float_limits_member(bool, tinyness_before);\n+__declare_float_limits_member(float_round_style, round_style);\n+\n+#undef __declare_float_limits_member\n+\n+// Class numeric_limits\n+\n+// The unspecialized class.\n+\n+template<class T> \n+class numeric_limits : public __numeric_limits_base<T> {};\n+\n+// Specializations for all built-in integral types.\n+\n+#ifndef __STL_NEED_BOOL\n+\n+template<>\n+class numeric_limits<bool>\n+  : public __integer_limits<bool, false, true, 0>\n+{};\n+\n+#endif /* __STL_NEED_BOOL */\n+\n+template<>\n+class numeric_limits<char>\n+  : public __integer_limits<char, CHAR_MIN, CHAR_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<signed char>\n+  : public __integer_limits<signed char, SCHAR_MIN, SCHAR_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<unsigned char>\n+  : public __integer_limits<unsigned char, 0, UCHAR_MAX>\n+{};\n+\n+#ifdef _WCHAR_T_IS_KEYWORD\n+\n+template<>\n+class numeric_limits<wchar_t>\n+  : public __integer_limits<wchar_t, INT_MIN, INT_MAX>\n+{};\n+\n+#endif\n+\n+template<>\n+class numeric_limits<short>\n+  : public __integer_limits<short, SHRT_MIN, SHRT_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<unsigned short>\n+  : public __integer_limits<unsigned short, 0, USHRT_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<int>\n+  : public __integer_limits<int, INT_MIN, INT_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<unsigned int>\n+  : public __integer_limits<unsigned int, 0, UINT_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<long>\n+  : public __integer_limits<long, LONG_MIN, LONG_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<unsigned long>\n+  : public __integer_limits<unsigned long, 0, ULONG_MAX>\n+{};\n+\n+#if defined(_LONGLONG) && _SGIAPI\n+\n+template<>\n+class numeric_limits<long long>\n+  : public __integer_limits<long long, LONGLONG_MIN, LONGLONG_MAX>\n+{};\n+\n+template<>\n+class numeric_limits<unsigned long long>\n+  : public __integer_limits<unsigned long long, 0, ULONGLONG_MAX>\n+{};\n+\n+#endif /* _LONGLONG && _SGIAPI */\n+\n+// Specializations for all built-in floating-point type.\n+\n+template<> class numeric_limits<float>\n+  : public __floating_limits<float, \n+                             FLT_MANT_DIG,   // Binary digits of precision\n+                             FLT_DIG,        // Decimal digits of precision\n+                             FLT_MIN_EXP,    // Minimum exponent\n+                             FLT_MAX_EXP,    // Maximum exponent\n+                             FLT_MIN_10_EXP, // Minimum base 10 exponent\n+                             FLT_MAX_10_EXP, // Maximum base 10 exponent\n+                             0x7f800000u,    // First word of +infinity\n+                             0x7f810000u,    // First word of quiet NaN\n+                             0x7fc10000u,    // First word of signaling NaN\n+                             true,           // conforms to iec559\n+                             round_to_nearest>\n+{\n+public:\n+  static float min() __STL_NOTHROW { return FLT_MIN; }\n+  static float denorm_min() __STL_NOTHROW { return FLT_MIN; }\n+  static float max() __STL_NOTHROW { return FLT_MAX; }\n+  static float epsilon() __STL_NOTHROW { return FLT_EPSILON; }\n+  static float round_error() __STL_NOTHROW { return 0.5f; } // Units: ulps.\n+};\n+\n+template<> class numeric_limits<double>\n+  : public __floating_limits<double, \n+                             DBL_MANT_DIG,   // Binary digits of precision\n+                             DBL_DIG,        // Decimal digits of precision\n+                             DBL_MIN_EXP,    // Minimum exponent\n+                             DBL_MAX_EXP,    // Maximum exponent\n+                             DBL_MIN_10_EXP, // Minimum base 10 exponent\n+                             DBL_MAX_10_EXP, // Maximum base 10 exponent\n+                             0x7ff00000u,    // First word of +infinity\n+                             0x7ff10000u,    // First word of quiet NaN\n+                             0x7ff90000u,    // First word of signaling NaN\n+                             true,           // conforms to iec559\n+                             round_to_nearest>\n+{\n+public:\n+  static double min() __STL_NOTHROW { return DBL_MIN; }\n+  static double denorm_min() __STL_NOTHROW { return DBL_MIN; }\n+  static double max() __STL_NOTHROW { return DBL_MAX; }\n+  static double epsilon() __STL_NOTHROW { return DBL_EPSILON; }\n+  static double round_error() __STL_NOTHROW { return 0.5; } // Units: ulps.\n+};\n+\n+template<> class numeric_limits<long double>\n+  : public __floating_limits<long double, \n+                             LDBL_MANT_DIG,  // Binary digits of precision\n+                             LDBL_DIG,       // Decimal digits of precision\n+                             LDBL_MIN_EXP,   // Minimum exponent\n+                             LDBL_MAX_EXP,   // Maximum exponent\n+                             LDBL_MIN_10_EXP,// Minimum base 10 exponent\n+                             LDBL_MAX_10_EXP,// Maximum base 10 exponent\n+                             0x7ff00000u,    // First word of +infinity\n+                             0x7ff10000u,    // First word of quiet NaN\n+                             0x7ff90000u,    // First word of signaling NaN\n+                             false,          // Doesn't conform to iec559\n+                             round_to_nearest>\n+{\n+public:\n+  static long double min() __STL_NOTHROW { return LDBL_MIN; }\n+  static long double denorm_min() __STL_NOTHROW { return LDBL_MIN; }\n+  static long double max() __STL_NOTHROW { return LDBL_MAX; }\n+  static long double epsilon() __STL_NOTHROW { return LDBL_EPSILON; }\n+  static long double round_error() __STL_NOTHROW { return 4; } // Units: ulps.\n+};\n+\n+__STL_END_NAMESPACE\n+\n+#endif /* __SGI_CPP_LIMITS */\n+\n+// Local Variables:\n+// mode:C++\n+// End:"}]}