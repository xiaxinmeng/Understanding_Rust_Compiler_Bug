{"sha": "e1f998ad669d4b1244255742eab338eaf06508d5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFmOTk4YWQ2NjlkNGIxMjQ0MjU1NzQyZWFiMzM4ZWFmMDY1MDhkNQ==", "commit": {"author": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-11-12T13:37:42Z"}, "committer": {"name": "James Van Artsdalen", "email": "jrv@gnu.org", "date": "1992-11-12T13:37:42Z"}, "message": "(floatMN2 recognizers): Don't omit mode on a match_operand that might be reloaded.\n\n(floatMN2 recognizers): Don't omit mode on a match_operand that might\nbe reloaded.  Split into separate patterns for each mode.\n(zero_extract test): Disable for now.\n\nFrom-SVN: r2747", "tree": {"sha": "5c9b59753d0fd01a8df615f782bae81e2647e89b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5c9b59753d0fd01a8df615f782bae81e2647e89b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1f998ad669d4b1244255742eab338eaf06508d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f998ad669d4b1244255742eab338eaf06508d5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1f998ad669d4b1244255742eab338eaf06508d5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1f998ad669d4b1244255742eab338eaf06508d5/comments", "author": null, "committer": null, "parents": [{"sha": "8f2400848464baf07d6b970cef03d864102982a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8f2400848464baf07d6b970cef03d864102982a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8f2400848464baf07d6b970cef03d864102982a0"}], "stats": {"total": 55, "additions": 42, "deletions": 13}, "files": [{"sha": "dca7bb61464c455baaadaead84f0d689b15bc301", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 42, "deletions": 13, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1f998ad669d4b1244255742eab338eaf06508d5/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1f998ad669d4b1244255742eab338eaf06508d5/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=e1f998ad669d4b1244255742eab338eaf06508d5", "patch": "@@ -1305,11 +1305,9 @@\n ;; This will convert from SImode or DImode to MODE_FLOAT.\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"register_operand\" \"=f,f\")\n-\t(match_operator 2 \"float_op\"\n-\t\t\t[(match_operand:DI 1 \"general_operand\" \"m,!*r\")]))]\n-  \"TARGET_80387 && GET_MODE (operands[0]) == GET_MODE (operands[2])\n-   && GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_FLOAT\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(float:DF (match_operand:DI 1 \"general_operand\" \"m,!*r\")))]\n+  \"TARGET_80387\"\n   \"*\n {\n   if (NON_STACK_REG_P (operands[1]))\n@@ -1324,11 +1322,43 @@\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand 0 \"register_operand\" \"=f,f\")\n-\t(match_operator 2 \"float_op\"\n-\t\t\t[(match_operand:SI 1 \"general_operand\" \"m,!*r\")]))]\n-  \"TARGET_80387 && GET_MODE (operands[0]) == GET_MODE (operands[2])\n-   && GET_MODE_CLASS (GET_MODE (operands[0])) == MODE_FLOAT\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(float:SF (match_operand:DI 1 \"general_operand\" \"m,!*r\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fild%z0,%1));\n+      RET;\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    return AS1 (fild%z1,%1);\n+  else\n+    abort ();\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n+\t(float:DF (match_operand:SI 1 \"general_operand\" \"m,!*r\")))]\n+  \"TARGET_80387\"\n+  \"*\n+{\n+  if (NON_STACK_REG_P (operands[1]))\n+    {\n+      output_op_from_reg (operands[1], AS1 (fild%z0,%1));\n+      RET;\n+    }\n+  else if (GET_CODE (operands[1]) == MEM)\n+    return AS1 (fild%z1,%1);\n+  else\n+    abort ();\n+}\")\n+\n+(define_insn \"\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f,f\")\n+\t(float:SF (match_operand:SI 1 \"general_operand\" \"m,!*r\")))]\n+  \"TARGET_80387\"\n   \"*\n {\n   if (NON_STACK_REG_P (operands[1]))\n@@ -2939,6 +2969,7 @@\n \n ;; ??? All bets are off if operand 0 is a volatile MEM reference.\n \n+/*\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand 0 \"general_operand\" \"rm\")\n \t\t\t    (match_operand:SI 1 \"const_int_operand\" \"n\")\n@@ -2955,8 +2986,6 @@\n \n   if (! REG_P (operands[0]) || QI_REG_P (operands[0]))\n     {\n-      /* We may set the sign bit spuriously.  */\n-\n       if ((mask & ~0xff) == 0)\n         {\n \t  cc_status.flags |= CC_NOT_NEGATIVE;\n@@ -2999,7 +3028,7 @@\n \n   return AS2 (test%L1,%0,%1);\n }\")\n-\n+*/\n (define_insn \"\"\n   [(set (cc0) (zero_extract (match_operand:SI 0 \"register_operand\" \"r\")\n \t\t\t    (const_int 1)"}]}