{"sha": "9bc856ddbfbb72ad01f2350ded06d7713781f645", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJjODU2ZGRiZmJiNzJhZDAxZjIzNTBkZWQwNmQ3NzEzNzgxZjY0NQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-14T13:55:12Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2004-05-14T13:55:12Z"}, "message": "[multiple changes]\n\n2004-05-14  Robert Dewar  <dewar@gnat.com>\n\n\t* gnat_ugn.texi: Minor change to -gnatS documentation\n\n\t* sprint.adb: Remove some instances of Assert (False) and for this\n\tpurpose replace them by output of a ??? string.\n\n\t* checks.adb, exp_aggr.adb, sem_elim.adb: Remove useless pragma\n\tAssert (False).\n\n\t* lib-writ.adb, lib-load.adb, lib.ads, lib.adb: Remove Dependent_Unit\n\tflag processing. This was suppressing required dependencies in\n\tNo_Run_Time mode and is not needed since the binder does not generate\n\treferences for things in libgnat anyway.\n\n\t* sem_ch3.adb (Access_Type_Declaration): Reorganize code to avoid GCC\n\twarning.\n\n2004-05-14  Thomas Quinot  <quinot@act-europe.fr>\n\n\t* gnat_ugn.texi: Document AIX-specific issue with initialization of\n\tresolver library.\n\n\t* exp_ch4.adb (Insert_Dereference_Action): Do not generate dereference\n\taction for the case of an actual parameter in an init proc call.\n\n2004-05-14  Ed Schonberg  <schonberg@gnat.com>\n\n\t* sem_ch4.adb (Analyze_Selected_Component): If prefix is a protected\n\tsubtype, check visible entities in base type.\n\n\t* exp_ch7.adb (Clean_Simple_Protected_Objects): Do not generate cleanup\n\tactions if the object is a renaming.\n\n\t* sem_ch12.adb (Same_Instantiated_Entity): Predicate for\n\tCheck_Formal_Package_Instance, to determine more precisely when the\n\tformal and the actual denote the same entity.\n\n2004-05-14  Javier Miranda  <miranda@gnat.com>\n\n\t* par-ch10.adb (P_Context_Clause): Complete documentation on AI-262\n\n\t* sem_ch10.adb (Analyze_With_Clause): After analyzed, the entity\n\tcorresponding to a private_with must be removed from visibility; it\n\twill be made visible later, just before we analyze the private part of\n\tthe package.\n\t(Check_Private_Child_Unit): Allow private_with clauses in public\n\tsiblings.\n\t(Install_Siblings): Make visible the private entities of private-withed\n\tsiblings.\n\t(Install_Withed_Unit): Do not install the private withed unit if we\n\tare compiling a package declaration and the Private_With_OK flag was\n\tnot set by the caller. These declarations will be installed later,\n\tjust before we analyze the private part of the package.\n\n\t* sem_ch3.adb (Analyze_Object_Declaration): In case of errors detected\n\tduring the evaluation of the expression that initializes the object,\n\tdecorate it with the expected type to avoid cascade errors.\n\tCode cleanup.\n\n\t* sem_ch6.adb (Analyze_Subprogram_Body): If we are compiling a library\n\tsubprogram we have to install the private_with clauses after its\n\tspecification has been analyzed (as documented in AI-262.TXT).\n\n\t* sem_ch8.adb (Has_Private_With): New function. Determines if the\n\tcurrent compilation unit has a private with on a given entity.\n\t(Find_Direct_Name): Detect the Beaujolais problem described in\n\tAI-262.TXT\n\n\t* sem_utils.ads, sem_util.adb (Is_Ancestor_Package): New function. It\n\tprovides the functionality of the function Is_Ancestor that was\n\tpreviously available in sem_ch10. It has been renamed to avoid\n\toverloading.\n\n\t* sprint.adb (Sprint_Node_Actual): Print limited_with clauses\n\n2004-05-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n\n\t* utils.c (build_vms_descriptor): Use SImode pointers.\n\n2004-05-14  Vasiliy Fofanov  <fofanov@act-europe.fr>\n\n\t* gnat_ugn.texi: Revised chapter \"GNAT and Libraries\".\n\n2004-05-14  GNAT Script  <nobody@gnat.com>\n\n\t* Make-lang.in: Makefile automatically updated\n\nFrom-SVN: r81844", "tree": {"sha": "7ea3f2bdfdd5974ffdc5deb52be2420d071ccd8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7ea3f2bdfdd5974ffdc5deb52be2420d071ccd8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bc856ddbfbb72ad01f2350ded06d7713781f645", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc856ddbfbb72ad01f2350ded06d7713781f645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bc856ddbfbb72ad01f2350ded06d7713781f645", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bc856ddbfbb72ad01f2350ded06d7713781f645/comments", "author": null, "committer": null, "parents": [{"sha": "8765339d0b13e84a05d615392655a9b13a604b4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8765339d0b13e84a05d615392655a9b13a604b4a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8765339d0b13e84a05d615392655a9b13a604b4a"}], "stats": {"total": 1112, "additions": 743, "deletions": 369}, "files": [{"sha": "16d3d0a7225afa85a664183229f4f1bc630b3615", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -1,3 +1,91 @@\n+2004-05-14  Robert Dewar  <dewar@gnat.com>\n+\n+\t* gnat_ugn.texi: Minor change to -gnatS documentation\n+\n+\t* sprint.adb: Remove some instances of Assert (False) and for this\n+\tpurpose replace them by output of a ??? string.\n+\n+\t* checks.adb, exp_aggr.adb, sem_elim.adb: Remove useless pragma\n+\tAssert (False).\n+\n+\t* lib-writ.adb, lib-load.adb, lib.ads, lib.adb: Remove Dependent_Unit\n+\tflag processing. This was suppressing required dependencies in\n+\tNo_Run_Time mode and is not needed since the binder does not generate\n+\treferences for things in libgnat anyway.\n+\n+\t* sem_ch3.adb (Access_Type_Declaration): Reorganize code to avoid GCC\n+\twarning.\n+\n+2004-05-14  Thomas Quinot  <quinot@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Document AIX-specific issue with initialization of\n+\tresolver library.\n+\n+\t* exp_ch4.adb (Insert_Dereference_Action): Do not generate dereference\n+\taction for the case of an actual parameter in an init proc call.\n+\n+2004-05-14  Ed Schonberg  <schonberg@gnat.com>\n+\n+\t* sem_ch4.adb (Analyze_Selected_Component): If prefix is a protected\n+\tsubtype, check visible entities in base type.\n+\n+\t* exp_ch7.adb (Clean_Simple_Protected_Objects): Do not generate cleanup\n+\tactions if the object is a renaming.\n+\n+\t* sem_ch12.adb (Same_Instantiated_Entity): Predicate for\n+\tCheck_Formal_Package_Instance, to determine more precisely when the\n+\tformal and the actual denote the same entity.\n+\n+2004-05-14  Javier Miranda  <miranda@gnat.com>\n+\n+\t* par-ch10.adb (P_Context_Clause): Complete documentation on AI-262\n+\n+\t* sem_ch10.adb (Analyze_With_Clause): After analyzed, the entity\n+\tcorresponding to a private_with must be removed from visibility; it\n+\twill be made visible later, just before we analyze the private part of\n+\tthe package.\n+\t(Check_Private_Child_Unit): Allow private_with clauses in public\n+\tsiblings.\n+\t(Install_Siblings): Make visible the private entities of private-withed\n+\tsiblings.\n+\t(Install_Withed_Unit): Do not install the private withed unit if we\n+\tare compiling a package declaration and the Private_With_OK flag was\n+\tnot set by the caller. These declarations will be installed later,\n+\tjust before we analyze the private part of the package.\n+\n+\t* sem_ch3.adb (Analyze_Object_Declaration): In case of errors detected\n+\tduring the evaluation of the expression that initializes the object,\n+\tdecorate it with the expected type to avoid cascade errors.\n+\tCode cleanup.\n+\n+\t* sem_ch6.adb (Analyze_Subprogram_Body): If we are compiling a library\n+\tsubprogram we have to install the private_with clauses after its\n+\tspecification has been analyzed (as documented in AI-262.TXT).\n+\n+\t* sem_ch8.adb (Has_Private_With): New function. Determines if the\n+\tcurrent compilation unit has a private with on a given entity.\n+\t(Find_Direct_Name): Detect the Beaujolais problem described in\n+\tAI-262.TXT\n+\n+\t* sem_utils.ads, sem_util.adb (Is_Ancestor_Package): New function. It\n+\tprovides the functionality of the function Is_Ancestor that was\n+\tpreviously available in sem_ch10. It has been renamed to avoid\n+\toverloading.\n+\n+\t* sprint.adb (Sprint_Node_Actual): Print limited_with clauses\n+\n+2004-05-14  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* utils.c (build_vms_descriptor): Use SImode pointers.\n+\n+2004-05-14  Vasiliy Fofanov  <fofanov@act-europe.fr>\n+\n+\t* gnat_ugn.texi: Revised chapter \"GNAT and Libraries\".\n+\n+2004-05-14  GNAT Script  <nobody@gnat.com>\n+\n+\t* Make-lang.in: Makefile automatically updated\n+\n 2004-05-14  Arnaud Charlet  <charlet@act-europe.fr>\n \n \tRenaming of target specific files for clarity"}, {"sha": "1342a542da22ee9a80dc117e4c8357dd4d7b6b4b", "filename": "gcc/ada/Make-lang.in", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMake-lang.in?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -2328,10 +2328,10 @@ ada/lib-load.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/atree.ads \\\n    ada/s-htable.ads ada/s-imgenu.ads ada/s-memory.ads ada/s-rident.ads \\\n    ada/s-secsta.ads ada/s-soflin.ads ada/s-stache.ads ada/s-stalib.ads \\\n    ada/s-stoele.ads ada/s-stoele.adb ada/s-traent.ads ada/s-unstyp.ads \\\n-   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/targparm.ads \\\n-   ada/tbuild.ads ada/tbuild.adb ada/tree_io.ads ada/types.ads \\\n-   ada/uintp.ads ada/uintp.adb ada/uname.ads ada/unchconv.ads \\\n-   ada/unchdeal.ads ada/urealp.ads ada/widechar.ads \n+   ada/s-wchcon.ads ada/table.ads ada/table.adb ada/tbuild.ads \\\n+   ada/tbuild.adb ada/tree_io.ads ada/types.ads ada/uintp.ads \\\n+   ada/uintp.adb ada/uname.ads ada/unchconv.ads ada/unchdeal.ads \\\n+   ada/urealp.ads ada/widechar.ads \n \n ada/lib-util.o : ada/ada.ads ada/a-except.ads ada/alloc.ads ada/debug.ads \\\n    ada/gnat.ads ada/g-os_lib.ads ada/g-string.ads ada/gnatvsn.ads \\"}, {"sha": "713ea26306caef740cefb642a8fd778365309f17", "filename": "gcc/ada/checks.adb", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fchecks.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fchecks.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fchecks.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -2596,8 +2596,7 @@ package body Checks is\n             Check_Null_Not_Allowed (N);\n \n          when others =>\n-            pragma Assert (False);\n-            null;\n+            raise Program_Error;\n       end case;\n    end Null_Exclusion_Static_Checks;\n "}, {"sha": "966b848931c21c5ffbc291c577ee89c12a140b18", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -4122,8 +4122,7 @@ package body Exp_Aggr is\n \n                --  Ada 0Y (AI-287): This case has not been analyzed???\n \n-               pragma Assert (False);\n-               null;\n+               raise Program_Error;\n             end if;\n \n             --  Name in assignment is explicit dereference.\n@@ -4743,11 +4742,13 @@ package body Exp_Aggr is\n       Typ    : Entity_Id;\n       Target : Node_Id;\n       Flist  : Node_Id   := Empty;\n-      Obj    : Entity_Id := Empty) return List_Id is\n+      Obj    : Entity_Id := Empty) return List_Id\n+   is\n    begin\n       if Is_Record_Type (Etype (N)) then\n          return Build_Record_Aggr_Code (N, Typ, Target, Flist, Obj);\n-      elsif Is_Array_Type (Etype (N)) then\n+\n+      else pragma Assert (Is_Array_Type (Etype (N)));\n          return\n            Build_Array_Aggr_Code\n              (N           => N,\n@@ -4757,9 +4758,6 @@ package body Exp_Aggr is\n               Scalar_Comp => Is_Scalar_Type (Component_Type (Typ)),\n               Indices     => No_List,\n               Flist       => Flist);\n-      else\n-         pragma Assert (False);\n-         return New_List;\n       end if;\n    end Late_Expansion;\n "}, {"sha": "4ae959a992d64658bdffe79f7078a5ae04c42dde", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -6529,7 +6529,7 @@ package body Exp_Ch4 is\n       Loc  : constant Source_Ptr := Sloc (N);\n       Typ  : constant Entity_Id  := Etype (N);\n       Pool : constant Entity_Id  := Associated_Storage_Pool (Typ);\n-      Pnod : constant Node_Id    := Parent (N);\n+      Pnod : Node_Id             := Parent (N);\n \n       function Is_Checked_Storage_Pool (P : Entity_Id) return Boolean;\n       --  Return true if type of P is derived from Checked_Pool;\n@@ -6578,6 +6578,25 @@ package body Exp_Ch4 is\n          return;\n       end if;\n \n+      --  Do not generate a dereference check for the object passed\n+      --  to an init proc: such a check is not desired (we know for\n+      --  sure that a valid dereference is passed to init procs,\n+      --  and the calls to 'Size and 'Alignment containent in the\n+      --  dereference check would be erroneous anyway if the init proc\n+      --  has not been executed yet.)\n+\n+      while Present (Pnod) loop\n+         if Nkind (Pnod) = N_Procedure_Call_Statement\n+           and then Is_Entity_Name (Name (Pnod))\n+           and then Is_Init_Proc (Name (Pnod))\n+         then\n+            return;\n+         end if;\n+\n+         Pnod := Parent (Pnod);\n+         exit when Nkind (Pnod) not in N_Subexpr;\n+      end loop;\n+\n       Insert_Action (N,\n         Make_Procedure_Call_Statement (Loc,\n           Name => New_Reference_To ("}, {"sha": "426658564e2f8d8d818eeb070e60994a32e14684", "filename": "gcc/ada/exp_ch7.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_ch7.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fexp_ch7.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch7.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -706,6 +706,7 @@ package body Exp_Ch7 is\n               or else Ekind (E) = E_Constant)\n            and then Has_Simple_Protected_Object (Etype (E))\n            and then not Has_Task (Etype (E))\n+           and then Nkind (Parent (E)) /= N_Object_Renaming_Declaration\n          then\n             declare\n                Typ : constant Entity_Id := Etype (E);"}, {"sha": "1a30c465a5531d49d6e860688c5bc8cf433f1358", "filename": "gcc/ada/gnat_ugn.texi", "status": "modified", "additions": 299, "deletions": 148, "changes": 447, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fgnat_ugn.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fgnat_ugn.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_ugn.texi?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -450,10 +450,9 @@ Cleaning Up Using gnatclean\n \n GNAT and Libraries\n \n-* Creating an Ada Library::\n-* Installing an Ada Library::\n-* Using an Ada Library::\n-* Creating an Ada Library to be Used in a Non-Ada Context::\n+* Introduction to Libraries in GNAT::\n+* General Ada Libraries::\n+* Stand-alone Ada Libraries::\n * Rebuilding the GNAT Run-Time Library::\n \n Using the GNU make Utility\n@@ -580,6 +579,7 @@ Platform-Specific Information for the Run-Time Libraries\n * Solaris-Specific Considerations::\n * IRIX-Specific Considerations::\n * Linux-Specific Considerations::\n+* AIX-Specific Considerations::\n \n Example of Binder Output File\n \n@@ -6264,7 +6264,7 @@ The use of the switch @option{-gnatS} for an\n Ada compilation will cause the compiler to output a\n representation of package Standard in a form very\n close to standard Ada. It is not quite possible to\n-do this and remain entirely Standard (since new\n+do this entirely in standard Ada (since new\n numeric base types cannot be created in standard\n Ada), but the output is easily\n readable to any Ada programmer, and is useful to\n@@ -6628,7 +6628,7 @@ The content of the @file{ada_source_path} file which is part of the GNAT\n installation tree and is used to store standard libraries such as the\n GNAT Run Time Library (RTL) source files.\n @ifclear vms\n-@ref{Installing an Ada Library}\n+@ref{Installing the library}\n @end ifclear\n @end enumerate\n \n@@ -7552,7 +7552,7 @@ installation tree and is used to store standard libraries such as the\n GNAT Run Time Library (RTL) unless the switch @option{-nostdlib} is\n specified.\n @ifclear vms\n-@ref{Installing an Ada Library}\n+@ref{Installing the library}\n @end ifclear\n @end enumerate\n \n@@ -14403,8 +14403,8 @@ output source file\n @item\n @var{filename} is the name (including the extension) of the source file to\n reformat; ``wildcards'' or several file names on the same gnatpp command are\n-allowed.  The file name may contain path information; it does not have to follow\n-the GNAT file naming rules\n+allowed.  The file name may contain path information; it does not have to\n+follow the GNAT file naming rules\n @end itemize\n \n \n@@ -14640,8 +14640,9 @@ Compact layout\n Uncompact layout\n \n @item ^-notab^/NOTABS^\n-All the VT characters are removed from the comment text. All the HT characters are\n-expanded with the sequences of space characters to get to the next tab stops.\n+All the VT characters are removed from the comment text. All the HT characters\n+are expanded with the sequences of space characters to get to the next tab\n+stops.\n \n @end table\n \n@@ -16263,26 +16264,39 @@ where @code{gnatclean} was invoked.\n @ifclear vms\n @node GNAT and Libraries\n @chapter GNAT and Libraries\n-@cindex Library, building, installing\n+@cindex Library, building, installing, using\n \n @noindent\n-This chapter addresses some of the issues related to building and using\n-a library with GNAT. It also shows how the GNAT run-time library can be\n-recompiled.\n+This chapter addresses the issues related to building and using\n+libraries with GNAT. It also shows how the GNAT run-time library can be\n+recompiled. It is recommended that the user understands how to use the\n+@ref{GNAT Project Manager} facility before reading this chapter.\n \n @menu\n-* Creating an Ada Library::\n-* Installing an Ada Library::\n-* Using an Ada Library::\n-* Creating an Ada Library to be Used in a Non-Ada Context::\n+* Introduction to Libraries in GNAT::\n+* General Ada Libraries::\n+* Stand-alone Ada Libraries::\n * Rebuilding the GNAT Run-Time Library::\n @end menu\n \n-@node Creating an Ada Library\n-@section Creating an Ada Library\n+@node Introduction to Libraries in GNAT\n+@section Introduction to Libraries in GNAT\n \n @noindent\n-In the GNAT environment, a library has two components:\n+A library is, conceptually, a collection of objects which does not have its\n+own main thread of execution, but rather provides certain services to the\n+applications that use it. A library can be either statically linked with the\n+application, in which case its code is directly included in the application,\n+or, on platforms that support it, be dynamically linked, in which case\n+its code is shared by all applications making use of this library. GNAT\n+supports both types of libraries. In the static case, the compiled code can\n+be provided in different ways. The simplest way is to provide directly the\n+set of objects produced by the compiler during the compilation of the library.\n+It is also possible to group the objects into an archive using whatever\n+commands are provided by the operating system. For the later case, the objects\n+are grouped into a shared library.\n+\n+In the GNAT environment, a library has two types of components:\n @itemize @bullet\n @item\n Source files.\n@@ -16291,37 +16305,76 @@ Compiled code and Ali files. See @ref{The Ada Library Information Files}.\n @end itemize\n \n @noindent\n-In order to use other packages @ref{The GNAT Compilation Model}\n-requires a certain number of sources to be available to the compiler.\n-The minimal set of\n-sources required includes the specs of all the packages that make up the\n-visible part of the library as well as all the sources upon which they\n-depend. The bodies of all visible generic units must also be provided.\n-@noindent\n-Although it is not strictly mandatory, it is recommended that all sources\n-needed to recompile the library be provided, so that the user can make\n-full use of inter-unit inlining and source-level debugging. This can also\n-make the situation easier for users that need to upgrade their compilation\n-toolchain and thus need to recompile the library from sources.\n+GNAT libraries can either completely expose their source files to the\n+compilation context of the user's application, or alternatively only expose\n+a limited set of source files, called interface units, in which case they are\n+called @ref{Stand-alone Ada Libraries}. In addition, GNAT provides full support\n+for foreign libraries which are only available in the object format.\n+\n+Ada semantics requires that all compilation units comprising the application\n+are elaborated in the timely fashion. Where possible, GNAT provides facilities\n+to ensure that compilation units of a library are automatically elaborated;\n+however, there are cases where this must be responsibility of a user. This will\n+be addressed in greater detail further on.\n+\n+@node General Ada Libraries\n+@section General Ada Libraries\n+\n+@menu\n+* Building the library::\n+* Installing the library::\n+* Using the library::\n+@end menu\n+\n+@node Building the library\n+@subsection Building the library\n \n @noindent\n-The compiled code can be provided in different ways. The simplest way is\n-to provide directly the set of objects produced by the compiler during\n-the compilation of the library. It is also possible to group the objects\n-into an archive using whatever commands are provided by the operating\n-system. Finally, it is also possible to create a shared library (see\n-option -shared in the GCC manual).\n+The easiest way to build a library is to use the @ref{GNAT Project Manager},\n+which supports a special type of projects called @ref{Library Projects}.\n+\n+A project is considered a library project, when two project-level attributes\n+are defined in it: @code{Library_Name} and @code{Library_Dir}. In order to\n+control different aspects of library configuration, additional optional\n+project-level attributes can be specified:\n+@itemize\n+@item @code{Library_Kind}\n+This attribute controls whether the library is to be static or shared\n+@item @code{Library_Version}\n+This attribute specifies what is the library version; this value is used\n+during dynamic linking of shared libraries to determine if the currently\n+installed versions of the binaries are compatible.\n+@item @code{Library_Options}, @code{Library_GCC}\n+These attributes specify additional low-level options to be used during\n+library generation, and redefine the actual application used to generate\n+library.\n+@end itemize\n \n @noindent\n+GNAT Project Manager takes full care of the library maintenance task,\n+including recompilation of the source files for which objects do not exist\n+or are not up to date, assembly of the library archive, and installation of\n+the library, i.e. the copy of associated source, object and ALI files to the\n+specific location.\n+\n+It is not entirely trivial to correctly do all the steps required to\n+produce a library. We recommend that you use @ref{GNAT Project Manager}\n+for this task. In special cases where this is not desired, the necessary\n+steps are discussed below.\n+\n There are various possibilities for compiling the units that make up the\n library: for example with a Makefile @ref{Using the GNU make Utility},\n or with a conventional script.\n For simple libraries, it is also possible to create a\n dummy main program which depends upon all the packages that comprise the\n interface of the library. This dummy main program can then be given to\n-gnatmake, in order to build all the necessary objects. Here is an example\n-of such a dummy program and the generic commands used to build an\n-archive or a shared library.\n+gnatmake, which will ensure that all necessary objects are built.\n+\n+After this task is accomplished, the user should follow the standard procedure\n+of the underlying operating system to produce the static or shared library.\n+\n+Below is an example of such a dummy program and the generic commands used to\n+build an archive or a shared library.\n \n @smallexample @c ada\n @iftex\n@@ -16360,30 +16413,23 @@ $ chmod -w *.ali\n \n @end smallexample\n \n-@noindent\n-When the objects are grouped in an archive or a shared library, the user\n-needs to specify the desired library at link time, unless a pragma\n-linker_options has been used in one of the sources:\n-@smallexample @c ada\n-pragma Linker_Options (\"-lmy_lib\");\n-@end smallexample\n-\n @noindent\n Please note that the library must have a name of the form libxxx.a or\n libxxx.so in order to be accessed by the directive -lxxx at link\n time.\n \n-@node Installing an Ada Library\n-@section Installing an Ada Library\n+@node Installing the library\n+@subsection Installing the library\n \n @noindent\n In the GNAT model, installing a library consists in copying into a specific\n-location the files that make up this library. It is possible to install\n-the sources in a different directory from the other files (ALI, objects,\n-archives) since the source path and the object path can easily be\n-specified separately.\n+location the files that make up this library. When the library is built using\n+projects, it is automatically installed in the location specified in the\n+project by means of the attribute @code{Library_Dir}, otherwise it is\n+responsibility of the user. GNAT also supports installing the sources in a\n+different directory from the other files (ALI, objects, archives) since the\n+source path and the object path can be specified separately.\n \n-@noindent\n For general purpose libraries, it is possible for the system\n administrator to put those libraries in the default compiler paths. To\n achieve this, he must specify their location in the configuration files\n@@ -16403,7 +16449,6 @@ in their order of appearance in the file. The names can be either absolute\n or relative, in the latter case, they are relative to where theses files\n are located.\n \n-@noindent\n @file{ada_source_path} and @file{ada_object_path} might actually not be\n present in a\n GNAT installation, in which case, GNAT will look for its run-time library in\n@@ -16416,27 +16461,52 @@ be @file{adainclude}). In the same way, the @file{ada_object_path} file must\n contain the location for the GNAT run-time objects (which can simply\n be @file{adalib}).\n \n-@noindent\n You can also specify a new default path to the runtime library at compilation\n time with the switch @option{--RTS=rts-path}. You can easily choose and change\n the runtime you want your program to be compiled with. This switch is\n recognized by gcc, gnatmake, gnatbind, gnatls, gnatfind and gnatxref.\n \n-@noindent\n It is possible to install a library before or after the standard GNAT\n library, by reordering the lines in the configuration files. In general, a\n library must be installed before the GNAT library if it redefines\n any part of it.\n \n-@node Using an Ada Library\n-@section Using an Ada Library\n+\n+@node Using the library\n+@subsection Using the library\n+\n+@noindent\n+Once again, the project facility greatly simplifies the addition of libraries\n+to the compilation. If the project file for an application lists a library\n+project in its @code{with} clause, the project manager will ensure that the\n+library files are consistent, and are considered during compilation and\n+linking of the main application.\n+\n+Even if you have a third-party, non-Ada library, you can still use GNAT\n+Project facility to provide a wrapper for it. The following project for\n+example, when \"withed\" in your main project, will link with the third-party\n+library liba.a:\n+\n+@smallexample @c projectfile\n+@group\n+project Liba is\n+   for Source_Dirs use ();\n+   for Library_Dir use \"lib\";\n+   for Library_Name use \"a\";\n+   for Library_Kind use \"static\";\n+end Liba;\n+@end group\n+@end smallexample\n \n @noindent\n-In order to use a Ada library, you need to make sure that this\n+In order to use an Ada library manually, you need to make sure that this\n library is on both your source and object path\n @ref{Search Paths and the Run-Time Library (RTL)}\n-and @ref{Search Paths for gnatbind}. For\n-instance, you can use the library @file{mylib} installed in\n+and @ref{Search Paths for gnatbind}. Furthermore, when the objects are grouped\n+in an archive or a shared library, the user needs to specify the desired\n+library at link time.\n+\n+By means of example, you can use the library @file{mylib} installed in\n @file{/dir/my_lib_src} and @file{/dir/my_lib_obj} with the following commands:\n \n @smallexample\n@@ -16460,98 +16530,173 @@ variable @code{ADA_INCLUDE_PATH}, or by the administrator to the file\n variable @code{ADA_OBJECTS_PATH}, or by the administrator to the file\n @file{ada_object_path}\n @item\n-a pragma @code{Linker_Options}, as mentioned in @ref{Creating an Ada Library},\n-has been added to the sources.\n+a pragma @code{Linker_Options}, has been added to one of the sources.\n+For example:\n+\n+@smallexample @c ada\n+pragma Linker_Options (\"-lmy_lib\");\n+@end smallexample\n @end itemize\n-@noindent\n \n-@node Creating an Ada Library to be Used in a Non-Ada Context\n-@section Creating an Ada Library to be Used in a Non-Ada Context\n \n-@noindent\n-The previous sections detailed how to create and install a library that\n-was usable from an Ada main program. Using this library in a non-Ada\n-context is not possible, because the elaboration of the library is\n-automatically done as part of the main program elaboration.\n+@node Stand-alone Ada Libraries\n+@section Stand-alone Ada Libraries\n+@cindex Stand-alone library, building, using\n \n-GNAT also provides the ability to build libraries that can be used both\n-in an Ada and non-Ada context.  This section describes how to build such\n-a library, and then how to use it from a C program. The method for\n-interfacing with the library from other languages such as Fortran for\n-instance remains the same.\n+@menu\n+* Introduction to Stand-Alone Libraries::\n+* Building SAL::\n+* Creating SAL to be used in a non-Ada context::\n+* Restrictions in SALs::\n+@end menu\n \n-@subsection Creating the Library\n+@node Introduction to Stand-Alone Libraries\n+@subsection Introduction to Stand-Alone Libraries\n \n-@itemize @bullet\n-@item Identify the units representing the interface of the library.\n+@noindent\n+A Stand-alone Library (SAL) is a library that contains the necessary code to\n+elaborate the Ada units that are included in the library. Different from\n+ordinary libraries, which consist of all sources, objects and ALI files of the\n+library, the SAL creator can specify a restricted subset of compilation units\n+comprising SAL to serve as a library interface. In this case, the fully\n+self-sufficient set of files of such library will normally consist of objects\n+archive, sources of interface units specs, and ALI files of interface units.\n+Note that if interface specs contain generics or inlined subprograms, body\n+source must also be provided; if the units that must be provided in the source\n+form depend on other units, the source and ALIs of those must also be provided.\n \n-Here is an example of simple library interface:\n+The main purpose of SAL is to minimize the recompilation overhead of client\n+applications when the new version of the library is installed. Specifically,\n+if the interface sources have not changed, client applications do not need to\n+be recompiled. If, furthermore, SAL is provided in the shared form and its\n+version, controlled by @code{Library_Version} attribute, is not changed, the\n+clients don't need to be relinked, either.\n \n-@smallexample @c ada\n-package Interface is\n+SALs also allow the library providers to minimize amount of library source\n+text exposed to the clients, which might be necessary for different reasons.\n \n-   procedure Do_Something;\n+Stand-alone libraries are also well suited to be used in an executable which\n+main is not written in Ada.\n \n-   procedure Do_Something_Else;\n+@node Building SAL\n+@subsection Building SAL\n \n-end Interface;\n-@end smallexample\n+@noindent\n+GNAT Project facility provides a simple way of building and installing\n+stand-alone libraries, see @ref{Stand-alone Library Projects}.\n+To be a Stand-alone Library Project, in addition to the two attributes\n+that make a project a Library Project (@code{Library_Name} and\n+@code{Library_Dir}, see @ref{Library Projects}), the attribute\n+@code{Library_Interface} must be defined.\n \n-@item Use @code{pragma Export} or @code{pragma Convention} for the\n-exported entities.\n+@smallexample @c projectfile\n+@group\n+   for Library_Dir use \"lib_dir\";\n+   for Library_Name use \"dummy\";\n+   for Library_Interface use (\"int1\", \"int1.child\");\n+@end group\n+@end smallexample\n \n-Our package @code{Interface} is then updated as follow:\n-@smallexample @c ada\n-package Interface is\n+Attribute @code{Library_Interface} has a non empty string list value,\n+each string in the list designating a unit contained in an immediate source\n+of the project file.\n \n-   procedure Do_Something;\n-   pragma Export (C, Do_Something, \"do_something\");\n+When a Stand-alone Library is built, first the binder is invoked to build\n+a package whose name depends on the library name\n+(^b~dummy.ads/b^B$DUMMY.ADS/B^ in the example above).\n+This binder-generated package includes initialization and\n+finalization procedures whose\n+names depend on the library name (dummyinit and dummyfinal in the example\n+above). The object corresponding to this package is included in the library.\n \n-   procedure Do_Something_Else;\n-   pragma Export (C, Do_Something_Else, \"do_something_else\");\n+The user must ensure timely (e.g. prior to any use of interfaces in the SAL)\n+calling of these procedures if static SAL is built, or shared SAL is built\n+with project-level attribute @code{Library_Auto_Init} set to \"false\".\n \n-end Interface;\n-@end smallexample\n+For a Stand-Alone Library, only the @file{ALI} files of the Interface Units\n+(those that are listed in attribute @code{Library_Interface}) are copied to\n+the Library Directory. As a consequence, only the Interface Units may be\n+imported from Ada units outside of the library. If other units are imported,\n+the binding phase will fail.\n \n-@item Compile all the units composing the library.\n+The attribute @code{Library_Src_Dir}, may be specified for a\n+Stand-Alone Library. @code{Library_Src_Dir} is a simple attribute that has a\n+single string value. Its value must be the path (absolute or relative to the\n+project directory) of an existing directory. This directory cannot be the\n+object directory or one of the source directories, but it can be the same as\n+the library directory. The sources of the Interface\n+Units of the library, necessary to an Ada client of the library, will be\n+copied to the designated directory, called Interface Copy directory.\n+These sources includes the specs of the Interface Units, but they may also\n+include bodies and subunits, when pragmas @code{Inline} or @code{Inline_Always}\n+are used, or when there is a generic units in the spec. Before the sources\n+are copied to the Interface Copy directory, an attempt is made to delete all\n+files in the Interface Copy directory.\n \n-@item Bind the library objects.\n+Building stand-alone libraries by hand is difficult. Below are listed the steps\n+necessary to be done by the user:\n+@itemize @bullet\n+@item\n+compile all library sources\n+@item\n+invoke the binder with the switch -n (No Ada main program),\n+with all the ALI files of the interfaces, and\n+with the switch -L to give specific names to the init and final\n+procedure.\n+@smallexample\n+  gnatbind -n int1.ali int2.ali -Lsal1\n+@end smallexample\n+@item\n+compile the binder generated file\n+@smallexample\n+  gcc -c b~int2.adb\n+@end smallexample\n+@item\n+link the dynamic library with all the necessary object files,\n+indicating to the linker the names of the init (and possibly\n+final) procedures for automatic initialization (and finalization).\n+The built library should be put in a directory different from\n+the object directory.\n+@item\n+copy the ALI files of the interface to the library directory,\n+add in the copy the indication that it is an interface to a SAL\n+(i.e. add a word @option{SL} on the line in ALI file that starts\n+with letter P) and make the modified copy of the ALI file read-only.\n+@end itemize\n \n-This step is performed by invoking gnatbind with the @option{-L<prefix>}\n-switch. @code{gnatbind} will then generate the library elaboration\n-procedure (named @code{<prefix>init}) and the run-time finalization\n-procedure (named @code{<prefix>final}).\n+@noindent\n+Using SALs is not different from using other libraries\n+(see @ref{Using the library}).\n \n-@smallexample\n-# generate the binder file in Ada\n-$ gnatbind -Lmylib interface\n+@node Creating SAL to be used in a non-Ada context\n+@subsection Creating SAL to be used in a non-Ada context\n \n-# generate the binder file in C\n-$ gnatbind -C -Lmylib interface\n-@end smallexample\n+@noindent\n+It is easy to adapt SAL build procedure discussed above for use of SAL in\n+a non-Ada context.\n \n-@item Compile the files generated by the binder\n+The only extra step required is to ensure that library interface subprograms\n+are compatible with the main program, by means of @code{pragma Export}\n+or @code{pragma Convention}.\n \n-@smallexample\n-$ gcc -c b~interface.adb\n-@end smallexample\n+Here is an example of simple library interface for use with C main program:\n \n-@item Create the library;\n+@smallexample @c ada\n+package Interface is\n \n-The procedure is identical to the procedure explained in\n-@ref{Creating an Ada Library},\n-except that @file{b~interface.o} needs to be added to\n-the list of objects.\n+   procedure Do_Something;\n+   pragma Export (C, Do_Something, \"do_something\");\n \n-@smallexample\n-# create an archive file\n-$ ar cr libmylib.a b~interface.o <other object files>\n+   procedure Do_Something_Else;\n+   pragma Export (C, Do_Something_Else, \"do_something_else\");\n \n-# create a shared library\n-$ gcc -shared -o libmylib.so b~interface.o <other object files>\n+end Interface;\n @end smallexample\n \n-@item Provide a ``foreign'' view of the library interface;\n+@noindent\n+On the foreign language side, you must provide a ``foreign'' view of the\n+library interface; remeber that it should contain elaboration routines in\n+addition to interface subrporams.\n \n The example below shows the content of @code{mylib_interface.h} (note\n that there is no rule for the naming of this file, any name can be used)\n@@ -16566,9 +16711,6 @@ extern void mylibfinal (void);\n extern void do_something (void);\n extern void do_something_else (void);\n @end smallexample\n-@end itemize\n-\n-@subsection Using the Library\n \n @noindent\n Libraries built as explained above can be used from any program, provided\n@@ -16599,23 +16741,14 @@ main (void)\n @end smallexample\n \n @noindent\n-Note that this same library can be used from an equivalent Ada main\n-program. In addition, if the libraries are installed as detailed in\n-@ref{Installing an Ada Library}, it is not necessary to invoke the\n-library elaboration and finalization routines. The binder will ensure\n-that this is done as part of the main program elaboration and\n-finalization phases.\n-\n-@subsection The Finalization Phase\n-\n-@noindent\n-Invoking any library finalization procedure generated by @code{gnatbind}\n-shuts down the Ada run time permanently. Consequently, the finalization\n-of all Ada libraries must be performed at the end of the program. No\n-call to these libraries nor the Ada run time should be made past the\n+Note that invoking any library finalization procedure generated by\n+@code{gnatbind} shuts down the Ada run time permanently. Consequently, the\n+finalization of all Ada libraries must be performed at the end of the program.\n+No call to these libraries nor the Ada run time should be made past the\n finalization phase.\n \n-@subsection Restrictions in Libraries\n+@node Restrictions in SALs\n+@subsection Restrictions in SALs\n \n @noindent\n The pragmas listed below should be used with caution inside libraries,\n@@ -16647,11 +16780,12 @@ to be a consideration.\n \n @node  Rebuilding the GNAT Run-Time Library\n @section Rebuilding the GNAT Run-Time Library\n+@cindex GNAT Run-Time Library, rebuilding\n \n @noindent\n It may be useful to recompile the GNAT library in various contexts, the\n most important one being the use of partition-wide configuration pragmas\n-such as Normalize_Scalar. A special Makefile called\n+such as @code{Normalize_Scalars}. A special Makefile called\n @code{Makefile.adalib} is provided to that effect and can be found in\n the directory containing the GNAT library. The location of this\n directory depends on the way the GNAT environment has been installed and can\n@@ -16667,6 +16801,7 @@ gnat library. This Makefile contains its own documentation and in\n particular the set of instructions needed to rebuild a new library and\n to use it.\n \n+\n @node Using the GNU make Utility\n @chapter Using the GNU @code{make} Utility\n @findex make\n@@ -20694,6 +20829,7 @@ information about several specific platforms.\n * Solaris-Specific Considerations::\n * IRIX-Specific Considerations::\n * Linux-Specific Considerations::\n+* AIX-Specific Considerations::\n @end menu\n \n \n@@ -21106,7 +21242,22 @@ compared to other native thread libraries:\n   e.g. by using @code{killpg()}.\n @end itemize\n \n+@node AIX-Specific Considerations\n+@section AIX-Specific Considerations\n+@cindex AIX resolver library\n+\n+@noindent\n+On AIX, the resolver library initializes some internal structure on\n+the first call to @code{get*by*} functions, which are used to implement\n+@code{GNAT.Sockets.Get_Host_By_Name} and @code{GNAT.Sockets.Get_Host_By_Addrss}.\n+If such initialization occurs within an Ada task, and the stack size for\n+the task is the default size, a stack overflow may occur.\n \n+To avoid this overflow, the user should either ensure that the first call\n+to @code{GNAT.Sockets.Get_Host_By_Name} or @code{GNAT.Sockets.Get_Host_By_Addrss}\n+occurs in the environment task, or use @code{pragma Storage_Size} to\n+specify a sufficiently large size for the stack of the task that contains\n+this call.\n \n @c *******************************\n @node Example of Binder Output File"}, {"sha": "03dcfe8cd732c0d07fb2df2187225c00cafeeee4", "filename": "gcc/ada/lib-load.adb", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib-load.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib-load.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-load.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -43,7 +43,6 @@ with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Sinput.L; use Sinput.L;\n with Stand;    use Stand;\n-with Targparm; use Targparm;\n with Tbuild;   use Tbuild;\n with Uname;    use Uname;\n \n@@ -143,7 +142,6 @@ package body Lib.Load is\n         Cunit           => Cunit,\n         Cunit_Entity    => Cunit_Entity,\n         Dependency_Num  => 0,\n-        Dependent_Unit  => False,\n         Dynamic_Elab    => False,\n         Error_Location  => Sloc (With_Node),\n         Expected_Unit   => Spec_Name,\n@@ -215,7 +213,6 @@ package body Lib.Load is\n            Cunit           => Empty,\n            Cunit_Entity    => Empty,\n            Dependency_Num  => 0,\n-           Dependent_Unit  => True,\n            Dynamic_Elab    => False,\n            Error_Location  => No_Location,\n            Expected_Unit   => No_Name,\n@@ -253,39 +250,6 @@ package body Lib.Load is\n       Fname        : File_Name_Type;\n       Src_Ind      : Source_File_Index;\n \n-      procedure Set_Load_Unit_Dependency (U : Unit_Number_Type);\n-      --  Sets the Dependent_Unit flag unless we have a predefined unit\n-      --  being loaded in High_Integrity_Mode. In this case we do not want\n-      --  to create a dependency, since we have loaded the unit only\n-      --  to inline stuff from it. If this is not the case, an error\n-      --  message will be issued in Rtsfind in any case.\n-\n-      ------------------------------\n-      -- Set_Load_Unit_Dependency --\n-      ------------------------------\n-\n-      procedure Set_Load_Unit_Dependency (U : Unit_Number_Type) is\n-      begin\n-         --  Differentiate between pragma No_Run_Time mode (that can be\n-         --  used with a standard installation), and HI-E mode which comes\n-         --  with a special installation.\n-\n-         --  For Configurable_Run_Time_Mode set by a pragma, we do not want to\n-         --  create a dependency since the binder would generate references to\n-         --  these units. In the case of configurable run-time, we do want to\n-         --  establish this dependency.\n-\n-         if Configurable_Run_Time_Mode\n-           and then not Configurable_Run_Time_On_Target\n-           and then not Debug_Flag_YY\n-           and then Is_Internal_File_Name (Unit_File_Name (U))\n-         then\n-            null;\n-         else\n-            Units.Table (U).Dependent_Unit := True;\n-         end if;\n-      end Set_Load_Unit_Dependency;\n-\n    --  Start of processing for Load_Unit\n \n    begin\n@@ -547,7 +511,6 @@ package body Lib.Load is\n          end if;\n \n          Load_Stack.Decrement_Last;\n-         Set_Load_Unit_Dependency (Unum);\n          return Unum;\n \n       --  Unit is not already in table, so try to open the file\n@@ -574,7 +537,6 @@ package body Lib.Load is\n               Cunit           => Empty,\n               Cunit_Entity    => Empty,\n               Dependency_Num  => 0,\n-              Dependent_Unit  => False,\n               Dynamic_Elab    => False,\n               Error_Location  => Sloc (Error_Node),\n               Expected_Unit   => Uname_Actual,\n@@ -631,7 +593,6 @@ package body Lib.Load is\n             --  Remove load stack entry and return the entry in the file table\n \n             Load_Stack.Decrement_Last;\n-            Set_Load_Unit_Dependency (Unum);\n             return Unum;\n \n          --  Case of file not found"}, {"sha": "7168e69c9a220115ec9f7d342f192eae0a6cc835", "filename": "gcc/ada/lib-writ.adb", "status": "modified", "additions": 4, "deletions": 9, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib-writ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib-writ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib-writ.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -68,7 +68,6 @@ package body Lib.Writ is\n          Cunit           => Empty,\n          Cunit_Entity    => Empty,\n          Dependency_Num  => 0,\n-         Dependent_Unit  => True,\n          Dynamic_Elab    => False,\n          Fatal_Error     => False,\n          Generate_Code   => False,\n@@ -122,7 +121,6 @@ package body Lib.Writ is\n         Cunit           => Empty,\n         Cunit_Entity    => Empty,\n         Dependency_Num  => 0,\n-        Dependent_Unit  => True,\n         Dynamic_Elab    => False,\n         Fatal_Error     => False,\n         Generate_Code   => False,\n@@ -619,7 +617,6 @@ package body Lib.Writ is\n \n             if Unit_Name (J) /= No_Name\n               and then (With_Flags (J) or else Unit_Name (J) = Pname)\n-              and then Units.Table (J).Dependent_Unit\n             then\n                Num_Withs := Num_Withs + 1;\n                With_Table (Num_Withs) := J;\n@@ -1042,11 +1039,9 @@ package body Lib.Writ is\n             Write_Info_Initiate ('D');\n             Write_Info_Char (' ');\n \n-            --  Normal case of a dependent unit entry with a source index\n+            --  Normal case of a unit entry with a source index\n \n-            if Sind /= No_Source_File\n-              and then Units.Table (Unum).Dependent_Unit\n-            then\n+            if Sind /= No_Source_File then\n                Write_Info_Name (File_Name (Sind));\n                Write_Info_Tab (25);\n                Write_Info_Str (String (Time_Stamp (Sind)));\n@@ -1078,8 +1073,8 @@ package body Lib.Writ is\n                   Write_Info_Name (Reference_Name (Sind));\n                end if;\n \n-            --  Case where there is no source index (happens for missing files)\n-            --  Also come here for non-dependent units.\n+               --  Case where there is no source index (happens for missing\n+               --  files). In this case we write a dummy time stamp.\n \n             else\n                Write_Info_Name (Unit_File_Name (Unum));"}, {"sha": "d1e8781c9045246b38c7fcf4e2895862c52234e8", "filename": "gcc/ada/lib.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -83,11 +83,6 @@ package body Lib is\n       return Units.Table (U).Dependency_Num;\n    end Dependency_Num;\n \n-   function Dependent_Unit (U : Unit_Number_Type) return Boolean is\n-   begin\n-      return Units.Table (U).Dependent_Unit;\n-   end Dependent_Unit;\n-\n    function Dynamic_Elab (U : Unit_Number_Type) return Boolean is\n    begin\n       return Units.Table (U).Dynamic_Elab;"}, {"sha": "e48f22457757fdcf3d7b1e246ed48900ff7aeb72", "filename": "gcc/ada/lib.ads", "status": "modified", "additions": 0, "deletions": 11, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Flib.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flib.ads?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -361,14 +361,6 @@ package Lib is\n    --      then called to reflect the contributions of any unit on which this\n    --      unit is semantically dependent.\n \n-   --    Dependent_Unit\n-   --      This is a Boolean flag, which is set True to indicate that this\n-   --      entry is for a semantically dependent unit. This flag is nearly\n-   --      always set True, the only exception is for a unit that is loaded\n-   --      by an Rtsfind request in High_Integrity_Mode, where the entity that\n-   --      is obtained by Rtsfind.RTE is for an inlined subprogram or other\n-   --      entity for which a dependency need not be created.\n-\n    --  The units table is reset to empty at the start of the compilation of\n    --  each main unit by Lib.Initialize. Entries are then added by calls to\n    --  the Lib.Load procedure. The following subprograms are used to access\n@@ -381,7 +373,6 @@ package Lib is\n \n    function Cunit            (U : Unit_Number_Type) return Node_Id;\n    function Cunit_Entity     (U : Unit_Number_Type) return Entity_Id;\n-   function Dependent_Unit   (U : Unit_Number_Type) return Boolean;\n    function Dependency_Num   (U : Unit_Number_Type) return Nat;\n    function Dynamic_Elab     (U : Unit_Number_Type) return Boolean;\n    function Error_Location   (U : Unit_Number_Type) return Source_Ptr;\n@@ -621,7 +612,6 @@ private\n    pragma Inline (Cunit);\n    pragma Inline (Cunit_Entity);\n    pragma Inline (Dependency_Num);\n-   pragma Inline (Dependent_Unit);\n    pragma Inline (Fatal_Error);\n    pragma Inline (Generate_Code);\n    pragma Inline (Has_RACW);\n@@ -650,7 +640,6 @@ private\n       Cunit            : Node_Id;\n       Cunit_Entity     : Entity_Id;\n       Dependency_Num   : Int;\n-      Dependent_Unit   : Boolean;\n       Fatal_Error      : Boolean;\n       Generate_Code    : Boolean;\n       Has_RACW         : Boolean;"}, {"sha": "d776635a778717567a831bcff49a0d48989427cb", "filename": "gcc/ada/par-ch10.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fpar-ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fpar-ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar-ch10.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -799,8 +799,8 @@ package body Ch10 is\n \n          --  Processing for WITH clause\n \n-         --  Ada0Y (AI-50217): First check for LIMITED WITH, PRIVATE WITH,\n-         --  or both.\n+         --  Ada0Y (AI-50217, AI-262): First check for LIMITED WITH,\n+         --  PRIVATE WITH, or both.\n \n          if Token = Tok_Limited then\n             Has_Limited := True;"}, {"sha": "4283ae0beb22ac7d12e0fa73a750e559b9535592", "filename": "gcc/ada/sem_ch10.adb", "status": "modified", "additions": 50, "deletions": 49, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch10.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch10.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch10.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -1812,6 +1812,14 @@ package body Sem_Ch10 is\n \n          null;\n       end if;\n+\n+      --  Ada 0Y (AI-262): Remove from visibility the entity corresponding to\n+      --  private_with units; they will be made visible later (just before the\n+      --  private part is analyzed)\n+\n+      if Private_Present (N) then\n+         Set_Is_Immediately_Visible (E_Name, False);\n+      end if;\n    end Analyze_With_Clause;\n \n    ------------------------------\n@@ -2226,8 +2234,12 @@ package body Sem_Ch10 is\n       Item := First (Context_Items (N));\n       while Present (Item) loop\n \n+         --  Ada 0Y (AI-262): Allow private_with of a private child package in\n+         --  public siblings\n+\n          if Nkind (Item) = N_With_Clause\n             and then not Implicit_With (Item)\n+            and then not Private_Present (Item)\n             and then Is_Private_Descendant (Entity (Name (Item)))\n          then\n             Priv_Child := Entity (Name (Item));\n@@ -2422,7 +2434,7 @@ package body Sem_Ch10 is\n             Mark_Rewrite_Insertion (Withn);\n          end if;\n \n-      elsif Nkind (Nam) = N_Selected_Component then\n+      else pragma Assert (Nkind (Nam) = N_Selected_Component);\n          Withn :=\n            Make_With_Clause\n            (Loc,\n@@ -2453,10 +2465,6 @@ package body Sem_Ch10 is\n \n             Expand_Limited_With_Clause (Prefix (Nam), N);\n          end if;\n-\n-      else\n-         null;\n-         pragma Assert (False);\n       end if;\n \n       New_Nodes_OK := New_Nodes_OK - 1;\n@@ -3154,6 +3162,12 @@ package body Sem_Ch10 is\n       Clause : Node_Id;\n \n    begin\n+      if Debug_Flag_I then\n+         Write_Str (\"install private with clauses of \");\n+         Write_Name (Chars (P));\n+         Write_Eol;\n+      end if;\n+\n       if Nkind (Parent (Decl)) = N_Compilation_Unit then\n          Clause := First (Context_Items (Parent (Decl)));\n          while Present (Clause) loop\n@@ -3176,36 +3190,6 @@ package body Sem_Ch10 is\n       Item : Node_Id;\n       Id   : Entity_Id;\n       Prev : Entity_Id;\n-\n-      function Is_Ancestor (E : Entity_Id) return Boolean;\n-      --  Determine whether the scope of a child unit is an ancestor of\n-      --  the current unit.\n-      --  Shouldn't this be somewhere more general ???\n-\n-      -----------------\n-      -- Is_Ancestor --\n-      -----------------\n-\n-      function Is_Ancestor (E : Entity_Id) return Boolean is\n-         Par : Entity_Id;\n-\n-      begin\n-         Par := U_Name;\n-         while Present (Par)\n-           and then Par /= Standard_Standard\n-         loop\n-            if Par = E then\n-               return True;\n-            end if;\n-\n-            Par := Scope (Par);\n-         end loop;\n-\n-         return False;\n-      end Is_Ancestor;\n-\n-   --  Start of processing for Install_Siblings\n-\n    begin\n       --  Iterate over explicit with clauses, and check whether the\n       --  scope of each entity is an ancestor of the current unit.\n@@ -3219,14 +3203,22 @@ package body Sem_Ch10 is\n             Id := Entity (Name (Item));\n \n             if Is_Child_Unit (Id)\n-              and then Is_Ancestor (Scope (Id))\n+              and then Is_Ancestor_Package (Scope (Id), U_Name)\n             then\n                Set_Is_Immediately_Visible (Id);\n-               Prev := Current_Entity (Id);\n+\n+               --  Ada 0Y (AI-262): Make visible the private entities of\n+               --  private-withed siblings\n+\n+               if Private_Present (Item) then\n+                  Install_Private_Declarations (Id);\n+               end if;\n \n                --  Check for the presence of another unit in the context,\n                --  that may be inadvertently hidden by the child.\n \n+               Prev := Current_Entity (Id);\n+\n                if Present (Prev)\n                  and then Is_Immediately_Visible (Prev)\n                  and then not Is_Child_Unit (Prev)\n@@ -3257,7 +3249,7 @@ package body Sem_Ch10 is\n             --  the child immediately visible.\n \n             elsif Is_Child_Unit (Scope (Id))\n-              and then Is_Ancestor (Scope (Scope (Id)))\n+              and then Is_Ancestor_Package (Scope (Scope (Id)), U_Name)\n             then\n                Set_Is_Immediately_Visible (Scope (Id));\n             end if;\n@@ -3327,8 +3319,7 @@ package body Sem_Ch10 is\n             return;\n \n          when others =>\n-            pragma Assert (False);\n-            null;\n+            raise Program_Error;\n       end case;\n \n       P := Defining_Unit_Name (Specification (P_Unit));\n@@ -3472,9 +3463,25 @@ package body Sem_Ch10 is\n       P     : constant Entity_Id := Scope (Uname);\n \n    begin\n+      --  Ada 0Y (AI-262): Do not install the private withed unit if we are\n+      --  compiling a package declaration and the Private_With_OK flag was not\n+      --  set by the caller. These declarations will be installed later (before\n+      --  analyzing the private part of the package).\n+\n+      if Private_Present (With_Clause)\n+        and then Nkind (Cunit (Current_Sem_Unit)) = N_Package_Declaration\n+        and then not (Private_With_OK)\n+      then\n+         return;\n+      end if;\n \n       if Debug_Flag_I then\n-         Write_Str (\"install withed unit \");\n+         if Private_Present (With_Clause) then\n+            Write_Str (\"install private withed unit \");\n+         else\n+            Write_Str (\"install withed unit \");\n+         end if;\n+\n          Write_Name (Chars (Uname));\n          Write_Eol;\n       end if;\n@@ -3492,17 +3499,13 @@ package body Sem_Ch10 is\n       end if;\n \n       if P /= Standard_Standard then\n-         if Private_Present (With_Clause)\n-           and then not (Private_With_OK)\n-         then\n-            return;\n \n          --  If the unit is not analyzed after analysis of the with clause,\n          --  and it is an instantiation, then it awaits a body and is the main\n          --  unit. Its appearance in the context of some other unit indicates\n          --  a circular dependency (DEC suite perversity).\n \n-         elsif not Analyzed (Uname)\n+         if not Analyzed (Uname)\n            and then Nkind (Parent (Uname)) = N_Package_Instantiation\n          then\n             Error_Msg_N\n@@ -3520,7 +3523,6 @@ package body Sem_Ch10 is\n                Set_Is_Visible_Child_Unit\n                  (Related_Instance\n                    (Defining_Entity (Unit (Library_Unit (With_Clause)))));\n-               null;\n             end if;\n \n             --  The parent unit may have been installed already, and\n@@ -3909,8 +3911,7 @@ package body Sem_Ch10 is\n             return;\n \n          when others =>\n-            pragma Assert (False);\n-            null;\n+            raise Program_Error;\n       end case;\n \n       --  Check if the chain is already built"}, {"sha": "7684845103a598aa5c20d9fae34ad5a1952f9a66", "filename": "gcc/ada/sem_ch12.adb", "status": "modified", "additions": 61, "deletions": 6, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch12.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch12.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch12.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -3636,6 +3636,16 @@ package body Sem_Ch12 is\n       --  Common error routine for mismatch between the parameters of\n       --  the actual instance and those of the formal package.\n \n+      function Same_Instantiated_Entity (E1, E2 : Entity_Id) return Boolean;\n+      --  The formal may come from a nested formal package, and the actual\n+      --  may have been constant-folded. To determine whether the two denote\n+      --  the same entity we may have to traverse several definitions to\n+      --  recover the ultimate entity that they refer to.\n+\n+      --------------------\n+      -- Check_Mismatch --\n+      --------------------\n+\n       procedure Check_Mismatch (B : Boolean) is\n       begin\n          if B then\n@@ -3645,6 +3655,42 @@ package body Sem_Ch12 is\n          end if;\n       end Check_Mismatch;\n \n+      ------------------------------\n+      -- Same_Instantiated_Entity --\n+      ------------------------------\n+\n+      function Same_Instantiated_Entity (E1, E2 : Entity_Id) return Boolean is\n+         Ent : Entity_Id;\n+\n+      begin\n+         Ent := E2;\n+         while Present (Ent) loop\n+            if E1 = Ent then\n+               return True;\n+\n+            elsif Ekind (Ent) /= E_Constant then\n+               return False;\n+\n+            elsif Is_Entity_Name (Constant_Value (Ent)) then\n+               if  Entity (Constant_Value (Ent)) = E1 then\n+                  return True;\n+               else\n+                  Ent := Entity (Constant_Value (Ent));\n+               end if;\n+\n+            --  The actual may be a constant that has been folded. Recover\n+            --  original name.\n+\n+            elsif Is_Entity_Name (Original_Node (Constant_Value (Ent))) then\n+                  Ent := Entity (Original_Node (Constant_Value (Ent)));\n+            else\n+               return False;\n+            end if;\n+         end loop;\n+\n+         return False;\n+      end Same_Instantiated_Entity;\n+\n    --  Start of processing for Check_Formal_Package_Instance\n \n    begin\n@@ -3723,10 +3769,8 @@ package body Sem_Ch12 is\n                   if Entity (Expr1) = Entity (Expr2) then\n                      null;\n \n-                  elsif Ekind (Entity (Expr2)) = E_Constant\n-                     and then Is_Entity_Name (Constant_Value (Entity (Expr2)))\n-                     and then\n-                      Entity (Constant_Value (Entity (Expr2))) = Entity (Expr1)\n+                  elsif\n+                    Same_Instantiated_Entity (Entity (Expr1), Entity (Expr2))\n                   then\n                      null;\n                   else\n@@ -3736,6 +3780,14 @@ package body Sem_Ch12 is\n                   Check_Mismatch (True);\n                end if;\n \n+            elsif Is_Entity_Name (Original_Node (Expr1))\n+              and then Is_Entity_Name (Expr2)\n+            and then\n+              Same_Instantiated_Entity\n+                (Entity (Original_Node (Expr1)), Entity (Expr2))\n+            then\n+               null;\n+\n             elsif Nkind (Expr1) = N_Null then\n                Check_Mismatch (Nkind (Expr1) /= N_Null);\n \n@@ -6160,8 +6212,7 @@ package body Sem_Ch12 is\n                end loop;\n \n             when others =>\n-               null;\n-               pragma Assert (False);\n+               raise Program_Error;\n          end case;\n       end Find_Matching_Actual;\n \n@@ -8650,6 +8701,10 @@ package body Sem_Ch12 is\n                   Set_In_Private_Part (P);\n                end if;\n \n+            --  This looks incomplete: what about compilation units that\n+            --  were made visible by Install_Parent but should not remain\n+            --  visible??? Standard is on the scope stack.\n+\n             elsif not In_Open_Scopes (Scope (P)) then\n                Set_Is_Immediately_Visible (P, False);\n             end if;"}, {"sha": "88480d8332b5c82376ee76a29174110479bd4c17", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 31, "deletions": 62, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -840,37 +840,6 @@ package body Sem_Ch3 is\n \n       Set_Can_Never_Be_Null (T_Name, Null_Exclusion_Present (T_Def));\n \n-      --  -------------------------------------------------------------------\n-      --  I assume that the following statements should also be here.\n-      --  Need some tests to check it. Detected by comparison with the\n-      --  access_definition subprogram???\n-      --  -------------------------------------------------------------------\n-\n-      --  The anonymous access type is as public as the discriminated type or\n-      --  subprogram that defines it. It is imported (for back-end purposes)\n-      --  if the designated type is.\n-\n---      Set_Is_Public (T_Name, Is_Public (Scope (T_Name)));\n-\n-      --  Ada 0Y (AI-50217): Propagate the attribute that indicates that the\n-      --  designated type comes from the limited view (for back-end purposes).\n-\n---      Set_From_With_Type (T_Name, From_With_Type (Desig_Type));\n-\n-      --  The context is either a subprogram declaration or an access\n-      --  discriminant, in a private or a full type declaration. In\n-      --  the case of a subprogram, If the designated type is incomplete,\n-      --  the operation will be a primitive operation of the full type, to\n-      --  be updated subsequently.\n-\n---        if Ekind (Desig_Type) = E_Incomplete_Type\n---          and then Is_Overloadable (Current_Scope)\n---        then\n---           Append_Elmt (Current_Scope, Private_Dependents (Desig_Type));\n---           Set_Has_Delayed_Freeze (Current_Scope);\n---        end if;\n-      --  ---------------------------------------------------------------\n-\n       Check_Restriction (No_Access_Subprograms, T_Def);\n    end Access_Subprogram_Declaration;\n \n@@ -885,9 +854,6 @@ package body Sem_Ch3 is\n       Desig : Entity_Id;\n       --  Designated type\n \n-      N_Desig : Entity_Id;\n-      --  Non-limited view, when needed\n-\n    begin\n       --  Check for permissible use of incomplete type\n \n@@ -937,26 +903,28 @@ package body Sem_Ch3 is\n       --  available, use it as the designated type of the access type, so that\n       --  the back-end gets a usable entity.\n \n-      if From_With_Type (Desig) then\n-         Set_From_With_Type (T);\n+      declare\n+         N_Desig : Entity_Id;\n \n-         if Ekind (Desig) = E_Incomplete_Type then\n-            N_Desig := Non_Limited_View (Desig);\n+      begin\n+         if From_With_Type (Desig) then\n+            Set_From_With_Type (T);\n \n-         elsif Ekind (Desig) = E_Class_Wide_Type then\n-            if From_With_Type (Etype (Desig)) then\n-               N_Desig := Non_Limited_View (Etype (Desig));\n-            else\n-               N_Desig := Etype (Desig);\n+            if Ekind (Desig) = E_Incomplete_Type then\n+               N_Desig := Non_Limited_View (Desig);\n+\n+            else pragma Assert (Ekind (Desig) = E_Class_Wide_Type);\n+               if From_With_Type (Etype (Desig)) then\n+                  N_Desig := Non_Limited_View (Etype (Desig));\n+               else\n+                  N_Desig := Etype (Desig);\n+               end if;\n             end if;\n-         else\n-            null;\n-            pragma Assert (False);\n-         end if;\n \n-         pragma Assert (Present (N_Desig));\n-         Set_Directly_Designated_Type (T, N_Desig);\n-      end if;\n+            pragma Assert (Present (N_Desig));\n+            Set_Directly_Designated_Type (T, N_Desig);\n+         end if;\n+      end;\n \n       --  Note that Has_Task is always false, since the access type itself\n       --  is not a task type. See Einfo for more description on this point.\n@@ -991,7 +959,10 @@ package body Sem_Ch3 is\n \n       --  Ada 0Y (AI-230): Access Definition case\n \n-      elsif Present (Access_Definition (Component_Definition (N))) then\n+      else\n+         pragma Assert (Present\n+                          (Access_Definition (Component_Definition (N))));\n+\n          T := Access_Definition\n                 (Related_Nod => N,\n                  N => Access_Definition (Component_Definition (N)));\n@@ -1012,10 +983,6 @@ package body Sem_Ch3 is\n          then\n             T := Replace_Anonymous_Access_To_Protected_Subprogram (N, T);\n          end if;\n-\n-      else\n-         pragma Assert (False);\n-         null;\n       end if;\n \n       --  If the subtype is a constrained subtype of the enclosing record,\n@@ -1715,6 +1682,13 @@ package body Sem_Ch3 is\n       if Present (E) and then E /= Error then\n          Analyze (E);\n \n+         --  In case of errors detected in the analysis of the expression,\n+         --  decorate it with the expected type to avoid cascade errors\n+\n+         if not Present (Etype (E)) then\n+            Set_Etype (E, T);\n+         end if;\n+\n          --  If an initialization expression is present, then we set the\n          --  Is_True_Constant flag. It will be reset if this is a variable\n          --  and it is indeed modified.\n@@ -2997,7 +2971,7 @@ package body Sem_Ch3 is\n \n       --  Ada 0Y (AI-230): Access Definition case\n \n-      elsif Present (Access_Definition (Component_Def)) then\n+      else pragma Assert (Present (Access_Definition (Component_Def)));\n          Element_Type := Access_Definition\n                            (Related_Nod => Related_Id,\n                             N           => Access_Definition (Component_Def));\n@@ -3021,10 +2995,6 @@ package body Sem_Ch3 is\n                    (Def, Element_Type);\n             end if;\n          end;\n-\n-      else\n-         pragma Assert (False);\n-         null;\n       end if;\n \n       --  Constrained array case\n@@ -3205,8 +3175,7 @@ package body Sem_Ch3 is\n             Acc  := Parameter_Type (N);\n \n          when others =>\n-            null;\n-            pragma Assert (False);\n+            raise Program_Error;\n       end case;\n \n       Decl := Make_Full_Type_Declaration (Loc,"}, {"sha": "8722b77692df3c78ea1142c7062756dba62e0443", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -2768,7 +2768,8 @@ package body Sem_Ch4 is\n             <<Next_Comp>>\n                Next_Entity (Comp);\n                exit when not In_Scope\n-                 and then Comp = First_Private_Entity (Prefix_Type);\n+                 and then\n+                   Comp = First_Private_Entity (Base_Type (Prefix_Type));\n          end loop;\n \n          Set_Is_Overloaded (N, Is_Overloaded (Sel));"}, {"sha": "8e2cd6a8ea7d9492f20efdb2057c27612105acb9", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -48,6 +48,7 @@ with Sem_Ch3;  use Sem_Ch3;\n with Sem_Ch4;  use Sem_Ch4;\n with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch10; use Sem_Ch10;\n with Sem_Ch12; use Sem_Ch12;\n with Sem_Disp; use Sem_Disp;\n with Sem_Dist; use Sem_Dist;\n@@ -1149,6 +1150,15 @@ package body Sem_Ch6 is\n          Build_Body_To_Inline (N, Spec_Id);\n       end if;\n \n+      --  Ada 0Y (AI-262): In library subprogram bodies, after the analysis\n+      --  if its specification we have to install the private withed units.\n+\n+      if Is_Compilation_Unit (Body_Id)\n+        and then Scope (Body_Id) = Standard_Standard\n+      then\n+         Install_Private_With_Clauses (Body_Id);\n+      end if;\n+\n       --  Now we can go on to analyze the body\n \n       HSS := Handled_Statement_Sequence (N);"}, {"sha": "518179d85875901677bca4df161657eb3b0959b2", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 110, "deletions": 8, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -428,6 +428,10 @@ package body Sem_Ch8 is\n    --  Find a type derived from Character or Wide_Character in the prefix of N.\n    --  Used to resolved qualified names whose selector is a character literal.\n \n+   function Has_Private_With (E : Entity_Id) return Boolean;\n+   --  Ada 0Y (AI-262): Determines if the current compilation unit has a\n+   --  private with on E\n+\n    procedure Find_Expanded_Name (N : Node_Id);\n    --  Selected component is known to be expanded name. Verify legality\n    --  of selector given the scope denoted by prefix.\n@@ -685,8 +689,7 @@ package body Sem_Ch8 is\n \n       --  Ada 0Y (AI-230/AI-254): Access renaming\n \n-      elsif Present (Access_Definition (N)) then\n-\n+      else pragma Assert (Present (Access_Definition (N)));\n          T := Access_Definition\n                 (Related_Nod => N,\n                  N           => Access_Definition (N));\n@@ -706,9 +709,6 @@ package body Sem_Ch8 is\n             Error_Msg_N (\"(Ada 0Y): null-excluding attribute ignored \"\n                          & \"('R'M 8.5.1(6))?\", N);\n          end if;\n-      else\n-         pragma Assert (False);\n-         null;\n       end if;\n \n       --  An object renaming requires an exact match of the type;\n@@ -2406,6 +2406,11 @@ package body Sem_Ch8 is\n       --  user point of view to warrant an error message of \"not visible\"\n       --  rather than undefined.\n \n+      Nvis_Is_Private_Subprg : Boolean := False;\n+      --  Ada 0Y (AI-262): Set True to indicate that a form of Beaujolais\n+      --  effect concerning library subprograms has been detected. Used to\n+      --  generate the precise error message.\n+\n       function From_Actual_Package (E : Entity_Id) return Boolean;\n       --  Returns true if the entity is declared in a package that is\n       --  an actual for a formal package of the current instance. Such an\n@@ -2566,10 +2571,46 @@ package body Sem_Ch8 is\n       -------------------\n \n       procedure Nvis_Messages is\n-         Ent    : Entity_Id;\n-         Hidden : Boolean := False;\n+         Comp_Unit : Node_Id;\n+         Ent       : Entity_Id;\n+         Hidden    : Boolean := False;\n+         Item      : Node_Id;\n \n       begin\n+         --  Ada 0Y (AI-262): Generate a precise error concerning the\n+         --  Beaujolais effect that was previously detected\n+\n+         if Nvis_Is_Private_Subprg then\n+\n+            pragma Assert (Nkind (E2) = N_Defining_Identifier\n+                           and then Ekind (E2) = E_Function\n+                           and then Scope (E2) = Standard_Standard\n+                           and then Has_Private_With (E2));\n+\n+            --  Find the sloc corresponding to the private with'ed unit\n+\n+            Comp_Unit      := Cunit (Current_Sem_Unit);\n+            Item           := First (Context_Items (Comp_Unit));\n+            Error_Msg_Sloc := No_Location;\n+\n+            while Present (Item) loop\n+               if Nkind (Item) = N_With_Clause\n+                 and then Private_Present (Item)\n+                 and then Entity (Name (Item)) = E2\n+               then\n+                  Error_Msg_Sloc := Sloc (Item);\n+                  exit;\n+               end if;\n+\n+               Next (Item);\n+            end loop;\n+\n+            pragma Assert (Error_Msg_Sloc /= No_Location);\n+\n+            Error_Msg_N (\"(Ada 0Y): hidden by private with clause #\", N);\n+            return;\n+         end if;\n+\n          Undefined (Nvis => True);\n \n          if Msg then\n@@ -2949,6 +2990,29 @@ package body Sem_Ch8 is\n             elsif Is_Potentially_Use_Visible (E2) then\n                Only_One_Visible := False;\n                All_Overloadable := All_Overloadable and Is_Overloadable (E2);\n+\n+            --  Ada 0Y (AI-262): Protect against a form of Beujolais effect\n+            --  that can occurr in private_with clauses. Example:\n+\n+            --    with A;\n+            --    private with B;              package A is\n+            --    package C is                   function B return Integer;\n+            --      use A;                     end A;\n+            --      V1 : Integer := B;\n+            --    private                      function B return Integer;\n+            --      V2 : Integer := B;\n+            --    end C;\n+\n+            --  V1 resolves to A.B, but V2 resolves to library unit B.\n+\n+            elsif Ekind (E2) = E_Function\n+              and then Scope (E2) = Standard_Standard\n+              and then Has_Private_With (E2)\n+            then\n+               Only_One_Visible       := False;\n+               All_Overloadable       := False;\n+               Nvis_Is_Private_Subprg := True;\n+               exit;\n             end if;\n \n             E2 := Homonym (E2);\n@@ -4433,6 +4497,30 @@ package body Sem_Ch8 is\n       return Found;\n    end Has_Implicit_Character_Literal;\n \n+   ----------------------\n+   -- Has_Private_With --\n+   ----------------------\n+\n+   function Has_Private_With (E : Entity_Id) return Boolean is\n+      Comp_Unit : constant Node_Id := Cunit (Current_Sem_Unit);\n+      Item      : Node_Id;\n+\n+   begin\n+      Item := First (Context_Items (Comp_Unit));\n+      while Present (Item) loop\n+         if Nkind (Item) = N_With_Clause\n+           and then Private_Present (Item)\n+           and then Entity (Name (Item)) = E\n+         then\n+            return True;\n+         end if;\n+\n+         Next (Item);\n+      end loop;\n+\n+      return False;\n+   end Has_Private_With;\n+\n    ---------------------------\n    -- Has_Implicit_Operator --\n    ---------------------------\n@@ -5356,6 +5444,7 @@ package body Sem_Ch8 is\n       Prev             : Entity_Id;\n       Current_Instance : Entity_Id := Empty;\n       Real_P           : Entity_Id;\n+      Private_With_OK  : Boolean   := False;\n \n    begin\n       if Ekind (P) /= E_Package then\n@@ -5396,12 +5485,25 @@ package body Sem_Ch8 is\n          Real_P := P;\n       end if;\n \n+      --  Ada 0Y (AI-262): Check the use_clause of a private withed package\n+      --  found in the private part of a package specification\n+\n+      if In_Private_Part (Current_Scope)\n+        and then Has_Private_With (P)\n+        and then Is_Child_Unit (Current_Scope)\n+        and then Is_Child_Unit (P)\n+        and then Is_Ancestor_Package (Scope (Current_Scope), P)\n+      then\n+         Private_With_OK := True;\n+      end if;\n+\n       --  Loop through entities in one package making them potentially\n       --  use-visible.\n \n       Id := First_Entity (P);\n       while Present (Id)\n-        and then Id /= First_Private_Entity (P)\n+        and then (Id /= First_Private_Entity (P)\n+                    or else Private_With_OK) --  Ada 0Y (AI-262)\n       loop\n          Prev := Current_Entity (Id);\n "}, {"sha": "f5200ca540607bdb344b6277df7040dab85cc758", "filename": "gcc/ada/sem_elim.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_elim.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_elim.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elim.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -657,7 +657,7 @@ package body Sem_Elim is\n \n       --  Should never fall through, since entry should be in table\n \n-      pragma Assert (False);\n+      raise Program_Error;\n    end Eliminate_Error_Msg;\n \n    ----------------"}, {"sha": "9eb9af0b388a6492d4538e06e2950ce21498cea2", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -3152,6 +3152,31 @@ package body Sem_Util is\n       end if;\n    end Is_Aliased_View;\n \n+   -------------------------\n+   -- Is_Ancestor_Package --\n+   -------------------------\n+\n+   function Is_Ancestor_Package\n+     (E1  : Entity_Id;\n+      E2  : Entity_Id) return Boolean\n+   is\n+      Par : Entity_Id;\n+\n+   begin\n+      Par := E2;\n+      while Present (Par)\n+        and then Par /= Standard_Standard\n+      loop\n+         if Par = E1 then\n+            return True;\n+         end if;\n+\n+         Par := Scope (Par);\n+      end loop;\n+\n+      return False;\n+   end Is_Ancestor_Package;\n+\n    ----------------------\n    -- Is_Atomic_Object --\n    ----------------------"}, {"sha": "a32ddc092397b2be17475ad1e8ea8c3838e53381", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -424,6 +424,11 @@ package Sem_Util is\n    --  Determine if Obj is an aliased view, i.e. the name of an\n    --  object to which 'Access or 'Unchecked_Access can apply.\n \n+   function Is_Ancestor_Package\n+     (E1 : Entity_Id;\n+      E2 : Entity_Id) return Boolean;\n+   --  Determine whether package E1 is an ancestor of E2\n+\n    function Is_Atomic_Object (N : Node_Id) return Boolean;\n    --  Determines if the given node denotes an atomic object in the sense\n    --  of the legality checks described in RM C.6(12)."}, {"sha": "5fe9e1c550e6fad53448c66f997a0abab674d319", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -1014,9 +1014,9 @@ package body Sprint is\n                end if;\n \n                Sprint_Node (Subtype_Indication (Node));\n+\n             else\n-               pragma Assert (False);\n-               null;\n+               Write_Str (\" ??? \");\n             end if;\n \n          when N_Component_Declaration =>\n@@ -1782,8 +1782,7 @@ package body Sprint is\n                Sprint_Node (Subtype_Mark (Node));\n \n             else\n-               pragma Assert (False);\n-               null;\n+               Write_Str (\" ??? \");\n             end if;\n \n             Write_Str_With_Col_Check (\" renames \");\n@@ -2601,8 +2600,15 @@ package body Sprint is\n \n                   --  Ada 0Y (AI-50217): Print limited with_clauses\n \n-                  if Limited_Present (Node) then\n+                  if Private_Present (Node) and Limited_Present (Node) then\n+                     Write_Indent_Str (\"limited private with \");\n+\n+                  elsif Private_Present (Node) then\n+                     Write_Indent_Str (\"private with \");\n+\n+                  elsif Limited_Present (Node) then\n                      Write_Indent_Str (\"limited with \");\n+\n                   else\n                      Write_Indent_Str (\"with \");\n                   end if;"}, {"sha": "6022dbfe75889d6e60136a2f0007de3bb44a64b6", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bc856ddbfbb72ad01f2350ded06d7713781f645/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=9bc856ddbfbb72ad01f2350ded06d7713781f645", "patch": "@@ -2444,13 +2444,12 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n \n   field_list\n     = chainon (field_list,\n-\t       make_descriptor_field (\"POINTER\",\n-\t\t\t\t      build_pointer_type (type),\n-\t\t\t\t      record_type,\n-\t\t\t\t      build1 (ADDR_EXPR,\n-\t\t\t\t\t      build_pointer_type (type),\n-\t\t\t\t\t      build (PLACEHOLDER_EXPR,\n-\t\t\t\t\t\t     type))));\n+\t       make_descriptor_field\n+\t       (\"POINTER\",\n+\t\tbuild_pointer_type_for_mode (type, SImode, false), record_type,\n+\t\tbuild1 (ADDR_EXPR,\n+\t\t\tbuild_pointer_type_for_mode (type, SImode, false),\n+\t\t\tbuild (PLACEHOLDER_EXPR, type))));\n \n   switch (mech)\n     {\n@@ -2520,8 +2519,13 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       field_list\n \t= chainon (field_list,\n \t\t   make_descriptor_field\n-\t\t   (\"A0\", build_pointer_type (inner_type), record_type,\n-\t\t    build1 (ADDR_EXPR, build_pointer_type (inner_type), tem)));\n+\t\t   (\"A0\",\n+\t\t    build_pointer_type_for_mode (inner_type, SImode, false),\n+\t\t    record_type,\n+\t\t    build1 (ADDR_EXPR,\n+\t\t\t    build_pointer_type_for_mode (inner_type, SImode,\n+\t\t\t\t\t\t\t false),\n+\t\t\t    tem)));\n \n       /* Next come the addressing coefficients.  */\n       tem = size_int (1);"}]}