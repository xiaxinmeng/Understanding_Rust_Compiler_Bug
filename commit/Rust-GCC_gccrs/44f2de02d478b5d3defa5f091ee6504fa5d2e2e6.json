{"sha": "44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "node_id": "C_kwDOANBUbNoAKDQ0ZjJkZTAyZDQ3OGI1ZDNkZWZhNWYwOTFlZTY1MDRmYTVkMmUyZTY", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-06-14T18:44:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-06-14T18:44:26Z"}, "message": "Merge #1312\n\n1312: Refactor generic parameter parsing and report order errors r=CohenArthur a=CohenArthur\n\nCloses #1311\r\n\r\nThis allows us to parse lifetimes and types (and later const generics)\r\nin any order without necessarily erroring out for the wrong reason. It also simplifies the\r\ncode greatly and makes it easier to modify.\r\n\r\nThis also removes an unused duplicate `parse_generic_params` function\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>", "tree": {"sha": "70e5218f2506d14b681238d3d20cdcf3e69605cb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/70e5218f2506d14b681238d3d20cdcf3e69605cb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiqNcKCRBK7hj4Ov3rIwAAnmEIAJhVqBKo0enL3Qo4LDMM45Ik\nC5vmzej178Oqld4VuuIqhdyktbklRDr/tvjfrurRfHLZD5SYciYnOyVg9tR9LXQz\npkvN5yqynVglg5j2tGvQa9a6v1KT9SvgMkrvuEy3LdL2ueny3pTkc8tFiOcP8GuK\n1urWtjioplefAlaT5wHPqHBDvkVacmwYuqCr+rYObCsMOsD042iePKrzaJDp8cJq\n8zilXOIxsQmGn8EDdS7q9SP67IMAHBqkmkar3uAqMrQI8vvtMHTt7myqpJbsLNXj\nQrHhYPufXUZ8dFm3eGn+ppXBM3uGwXxC2vZXo+2Ic5okl2qB/qHfkxllQj8wilk=\n=8Jk4\n-----END PGP SIGNATURE-----\n", "payload": "tree 70e5218f2506d14b681238d3d20cdcf3e69605cb\nparent 61e95a9bf6d4e8cc4de7b2d2b4c1ac989fa76836\nparent 8e22742c9ad844d5e6dd348f6f7d8fa2ef064de4\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1655232266 +0000\ncommitter GitHub <noreply@github.com> 1655232266 +0000\n\nMerge #1312\n\n1312: Refactor generic parameter parsing and report order errors r=CohenArthur a=CohenArthur\n\nCloses #1311\r\n\r\nThis allows us to parse lifetimes and types (and later const generics)\r\nin any order without necessarily erroring out for the wrong reason. It also simplifies the\r\ncode greatly and makes it easier to modify.\r\n\r\nThis also removes an unused duplicate `parse_generic_params` function\n\nCo-authored-by: Arthur Cohen <arthur.cohen@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "61e95a9bf6d4e8cc4de7b2d2b4c1ac989fa76836", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61e95a9bf6d4e8cc4de7b2d2b4c1ac989fa76836", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61e95a9bf6d4e8cc4de7b2d2b4c1ac989fa76836"}, {"sha": "8e22742c9ad844d5e6dd348f6f7d8fa2ef064de4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e22742c9ad844d5e6dd348f6f7d8fa2ef064de4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e22742c9ad844d5e6dd348f6f7d8fa2ef064de4"}], "stats": {"total": 421, "additions": 106, "deletions": 315}, "files": [{"sha": "2d7d31a34b76775118d396edf7b392782548adc3", "filename": "gcc/rust/ast/rust-ast.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "patch": "@@ -1255,6 +1255,13 @@ class Lifetime : public TypeParamBound\n class GenericParam\n {\n public:\n+  enum class Kind\n+  {\n+    Lifetime,\n+    Type,\n+    Const,\n+  };\n+\n   virtual ~GenericParam () {}\n \n   // Unique pointer custom clone function\n@@ -1269,6 +1276,8 @@ class GenericParam\n \n   virtual Location get_locus () const = 0;\n \n+  virtual Kind get_kind () const = 0;\n+\n   NodeId get_node_id () { return node_id; }\n \n protected:\n@@ -1322,6 +1331,8 @@ class LifetimeParam : public GenericParam\n \n   Location get_locus () const override final { return locus; }\n \n+  Kind get_kind () const override final { return Kind::Lifetime; }\n+\n protected:\n   /* Use covariance to implement clone function as returning this object rather\n    * than base */"}, {"sha": "94ffffba6faeb2a47b9e84fae449e939bd401442", "filename": "gcc/rust/ast/rust-item.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "patch": "@@ -132,6 +132,8 @@ class TypeParam : public GenericParam\n \n   Location get_locus () const override final { return locus; }\n \n+  Kind get_kind () const override final { return Kind::Type; }\n+\n   void accept_vis (ASTVisitor &vis) override;\n \n   // TODO: is this better? Or is a \"vis_block\" better?"}, {"sha": "ce68c16ac7c057f3e80b040a7abfdac4023870a0", "filename": "gcc/rust/parse/rust-parse-impl.h", "status": "modified", "additions": 89, "deletions": 314, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fparse%2Frust-parse-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-impl.h?ref=44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "patch": "@@ -2793,197 +2793,87 @@ Parser<ManagedTokenSource>::parse_generic_params_in_angles ()\n   return generic_params;\n }\n \n-/* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n- * always parse_generic_params_in_angles is what is wanted. */\n template <typename ManagedTokenSource>\n-std::vector<std::unique_ptr<AST::GenericParam>>\n-Parser<ManagedTokenSource>::parse_generic_params ()\n+template <typename EndTokenPred>\n+std::unique_ptr<AST::GenericParam>\n+Parser<ManagedTokenSource>::parse_generic_param (EndTokenPred is_end_token)\n {\n-  std::vector<std::unique_ptr<AST::GenericParam>> generic_params;\n-\n-  // can't parse lifetime and type params separately due to lookahead issues\n-  // thus, parse them all here\n+  auto token = lexer.peek_token ();\n+  auto outer_attrs = parse_outer_attribute ();\n+  std::unique_ptr<AST::GenericParam> param;\n \n-  // DEBUG\n-  rust_debug (\"starting to parse generic params (inside angle brackets)\");\n-\n-  /* HACK: used to retain attribute data if a lifetime param is tentatively\n-   * parsed but it turns out to be type param */\n-  AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n-\n-  /* HACK: generic params always in angle brackets with current syntax, so have\n-   * that as end char */\n-  const_TokenPtr t = lexer.peek_token ();\n-  // parse lifetime params\n-  while (!is_right_angle_tok (t->get_id ()))\n-    {\n-      // HACK: reimpl of lifetime param parsing\n-      AST::Attribute outer_attr = parse_outer_attribute ();\n-\n-      // move attribute outward if type param\n-      if (lexer.peek_token ()->get_id () != LIFETIME)\n-\t{\n-\t  parsed_outer_attr = std::move (outer_attr);\n-\n-\t  // DEBUG\n-\t  rust_debug (\n-\t    \"broke from parsing lifetime params as next token isn't lifetime - \"\n-\t    \"saved attribute\");\n-\n-\t  break;\n-\t}\n-\n-      Location locus = lexer.peek_token ()->get_locus ();\n-      AST::Lifetime lifetime = parse_lifetime ();\n-\n-      // DEBUG\n-      rust_debug (\"parsed lifetime in lifetime params\");\n-\n-      // parse optional bounds\n-      std::vector<AST::Lifetime> lifetime_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\t  // parse required bounds\n-\t  lifetime_bounds = parse_lifetime_bounds (\n-\t    [] (TokenId id) { return is_right_angle_tok (id) || id == COMMA; });\n-\t}\n-\n-      std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime),\n-\t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr), locus));\n-      generic_params.push_back (std::move (param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      lexer.skip_token ();\n-\n-      t = lexer.peek_token ();\n-    }\n-\n-  // parse type params (reimpl required for first one but not others)\n-  if (!is_right_angle_tok (lexer.peek_token ()->get_id ())\n-      && !parsed_outer_attr.is_empty ())\n+  switch (token->get_id ())\n     {\n-      // DEBUG\n-      rust_debug (\"as parsed outer attr isn't empty, started parsing type \"\n-\t\t  \"param reimpl\");\n-\n-      // reimpl as type param definitely exists\n-      const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n-      if (ident_tok == nullptr)\n-\t{\n-\t  Error error (\n-\t    lexer.peek_token ()->get_locus (),\n-\t    \"failed to parse identifier in type param in generic params\");\n-\t  add_error (std::move (error));\n-\n-\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t}\n-      Identifier ident = ident_tok->get_str ();\n-\n-      // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse optional type param bounds\n-\t  type_param_bounds = parse_type_param_bounds ();\n-\t}\n-\n-      // parse optional type\n-      std::unique_ptr<AST::Type> type = nullptr;\n-      if (lexer.peek_token ()->get_id () == EQUAL)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse required type\n-\t  type = parse_type ();\n-\t  if (type == nullptr)\n-\t    {\n-\t      Error error (\n-\t\tlexer.peek_token ()->get_locus (),\n-\t\t\"failed to parse type in type param in generic params\");\n-\t      add_error (std::move (error));\n-\n-\t      return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t    }\n-\t}\n-\n-      std::unique_ptr<AST::TypeParam> param (\n-\tnew AST::TypeParam (std::move (ident), ident_tok->get_locus (),\n-\t\t\t    std::move (type_param_bounds), std::move (type),\n-\t\t\t    std::move (parsed_outer_attr)));\n-      generic_params.push_back (std::move (param));\n-\n-      // handle comma\n-      if (lexer.peek_token ()->get_id () == COMMA)\n-\t{\n-\t  lexer.skip_token ();\n-\t}\n-    }\n-\n-  // DEBUG\n-  rust_debug (\n-    \"about to start parsing normally-parsed type params in generic params\");\n+      case LIFETIME: {\n+\tauto lifetime = parse_lifetime ();\n+\tif (lifetime.is_error ())\n+\t  {\n+\t    rust_error_at (\n+\t      token->get_locus (),\n+\t      \"failed to parse lifetime in generic parameter list\");\n+\t    return nullptr;\n+\t  }\n \n-  // parse rest of type params - reimpl due to right angle tokens\n-  t = lexer.peek_token ();\n-  while (!is_right_angle_tok (t->get_id ()))\n-    {\n-      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n+\tstd::vector<AST::Lifetime> lifetime_bounds;\n+\tif (lexer.peek_token ()->get_id () == COLON)\n+\t  {\n+\t    lexer.skip_token ();\n+\t    // parse required bounds\n+\t    lifetime_bounds\n+\t      = parse_lifetime_bounds ([is_end_token] (TokenId id) {\n+\t\t  return is_end_token (id) || id == COMMA;\n+\t\t});\n+\t  }\n \n-      if (type_param == nullptr)\n-\t{\n-\t  Error error (lexer.peek_token ()->get_locus (),\n-\t\t       \"failed to parse type param in generic params\");\n-\t  add_error (std::move (error));\n+\tparam = std::unique_ptr<AST::LifetimeParam> (new AST::LifetimeParam (\n+\t  std::move (lifetime), std::move (lifetime_bounds),\n+\t  std::move (outer_attrs), token->get_locus ()));\n+\tbreak;\n+      }\n+      case IDENTIFIER: {\n+\tauto type_ident = token->get_str ();\n+\tlexer.skip_token ();\n \n-\t  return std::vector<std::unique_ptr<AST::GenericParam>> ();\n-\t}\n+\tstd::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n+\tif (lexer.peek_token ()->get_id () == COLON)\n+\t  {\n+\t    lexer.skip_token ();\n \n-      // DEBUG\n-      rust_debug (\"successfully parsed type param\");\n+\t    // parse optional type param bounds\n+\t    type_param_bounds = parse_type_param_bounds ();\n+\t  }\n \n-      generic_params.push_back (std::move (type_param));\n+\tstd::unique_ptr<AST::Type> type = nullptr;\n+\tif (lexer.peek_token ()->get_id () == EQUAL)\n+\t  {\n+\t    lexer.skip_token ();\n \n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\t{\n-\t  break;\n-\t}\n-      // skip commas, including trailing commas\n-      lexer.skip_token ();\n+\t    // parse required type\n+\t    type = parse_type ();\n+\t    if (!type)\n+\t      {\n+\t\trust_error_at (\n+\t\t  lexer.peek_token ()->get_locus (),\n+\t\t  \"failed to parse type in type param in generic params\");\n+\t\treturn nullptr;\n+\t      }\n+\t  }\n \n-      t = lexer.peek_token ();\n+\tparam = std::unique_ptr<AST::TypeParam> (\n+\t  new AST::TypeParam (std::move (type_ident), token->get_locus (),\n+\t\t\t      std::move (type_param_bounds), std::move (type),\n+\t\t\t      std::move (outer_attrs)));\n+\tbreak;\n+      }\n+    default:\n+      // FIXME: Can we clean this last call with a method call?\n+      rust_error_at (token->get_locus (),\n+\t\t     \"unexpected token when parsing generic parameters: %qs\",\n+\t\t     token->get_str ().c_str ());\n+      return nullptr;\n     }\n \n-  // old code\n-  /*\n-  // parse lifetime params (optional), allowed to end with a trailing comma\n-  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params\n-    = parse_lifetime_params();\n-  if (!lifetime_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(lifetime_params.begin()),\n-\tstd::make_move_iterator(lifetime_params.end()));\n-  }\n-\n-  // parse type params (optional)\n-  std::vector<std::unique_ptr<AST::TypeParam>> type_params =\n-  parse_type_params(); if (!type_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(type_params.begin()),\n-\tstd::make_move_iterator(type_params.end()));\n-  }*/\n-\n-  generic_params.shrink_to_fit ();\n-  return generic_params;\n+  return param;\n }\n \n /* Parse generic (lifetime or type) params NOT INSIDE ANGLE BRACKETS!!! Almost\n@@ -3002,149 +2892,34 @@ Parser<ManagedTokenSource>::parse_generic_params (EndTokenPred is_end_token)\n    * parsed but it turns out to be type param */\n   AST::Attribute parsed_outer_attr = AST::Attribute::create_empty ();\n \n-  const_TokenPtr t = lexer.peek_token ();\n-  // parse lifetime params\n-  while (!is_end_token (t->get_id ()))\n-    {\n-      // HACK: reimpl of lifetime param parsing\n-      AST::Attribute outer_attr = parse_outer_attribute ();\n-\n-      // move attribute outward if type param\n-      if (lexer.peek_token ()->get_id () != LIFETIME)\n-\t{\n-\t  parsed_outer_attr = std::move (outer_attr);\n-\t  break;\n-\t}\n-\n-      Location locus = lexer.peek_token ()->get_locus ();\n-      AST::Lifetime lifetime = parse_lifetime ();\n-\n-      // parse optional bounds\n-      std::vector<AST::Lifetime> lifetime_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\t  // parse required bounds\n-\t  lifetime_bounds = parse_lifetime_bounds ([is_end_token] (TokenId id) {\n-\t    return is_end_token (id) || id == COMMA;\n-\t  });\n-\t}\n-\n-      std::unique_ptr<AST::LifetimeParam> param (\n-\tnew AST::LifetimeParam (std::move (lifetime),\n-\t\t\t\tstd::move (lifetime_bounds),\n-\t\t\t\tstd::move (outer_attr), locus));\n-      generic_params.push_back (std::move (param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\tbreak;\n-\n-      lexer.skip_token ();\n-      t = lexer.peek_token ();\n-    }\n+  // Did we parse a generic type param yet\n+  auto type_seen = false;\n+  // Did the user write a lifetime parameter after a type one\n+  auto order_error = false;\n \n-  // parse type params (reimpl required for first one but not others)\n-  if (!is_end_token (lexer.peek_token ()->get_id ())\n-      && !parsed_outer_attr.is_empty ())\n-    {\n-      // reimpl as type param definitely exists\n-      const_TokenPtr ident_tok = expect_token (IDENTIFIER);\n-      if (ident_tok == nullptr)\n-\t{\n-\t  Error error (\n-\t    lexer.peek_token ()->get_locus (),\n-\t    \"failed to parse identifier in type param in generic params\");\n-\t  add_error (std::move (error));\n-\n-\t  return {};\n-\t}\n-      Identifier ident = ident_tok->get_str ();\n-\n-      // parse optional bounds\n-      std::vector<std::unique_ptr<AST::TypeParamBound>> type_param_bounds;\n-      if (lexer.peek_token ()->get_id () == COLON)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse optional type param bounds\n-\t  type_param_bounds = parse_type_param_bounds ();\n-\t}\n-\n-      // parse optional type\n-      std::unique_ptr<AST::Type> type = nullptr;\n-      if (lexer.peek_token ()->get_id () == EQUAL)\n-\t{\n-\t  lexer.skip_token ();\n-\n-\t  // parse required type\n-\t  type = parse_type ();\n-\t  if (type == nullptr)\n-\t    {\n-\t      Error error (\n-\t\tlexer.peek_token ()->get_locus (),\n-\t\t\"failed to parse type in type param in generic params\");\n-\t      add_error (std::move (error));\n-\n-\t      return {};\n-\t    }\n-\t}\n-\n-      std::unique_ptr<AST::TypeParam> param (\n-\tnew AST::TypeParam (std::move (ident), ident_tok->get_locus (),\n-\t\t\t    std::move (type_param_bounds), std::move (type),\n-\t\t\t    std::move (parsed_outer_attr)));\n-      generic_params.push_back (std::move (param));\n-\n-      // handle comma\n-      if (lexer.peek_token ()->get_id () == COMMA)\n-\tlexer.skip_token ();\n-    }\n-\n-  // parse rest of type params - reimpl due to right angle tokens\n-  t = lexer.peek_token ();\n-  while (!is_end_token (t->get_id ()))\n+  // parse lifetime params\n+  while (!is_end_token (lexer.peek_token ()->get_id ()))\n     {\n-      std::unique_ptr<AST::TypeParam> type_param = parse_type_param ();\n-\n-      if (type_param == nullptr)\n+      auto param = parse_generic_param (is_end_token);\n+      if (param)\n \t{\n-\t  Error error (lexer.peek_token ()->get_locus (),\n-\t\t       \"failed to parse type param in generic params\");\n-\t  add_error (std::move (error));\n+\t  // TODO: Handle `Const` here as well if necessary\n+\t  if (param->get_kind () == AST::GenericParam::Kind::Type)\n+\t    type_seen = true;\n+\t  else if (param->get_kind () == AST::GenericParam::Kind::Lifetime\n+\t\t   && type_seen)\n+\t    order_error = true;\n \n-\t  return {};\n+\t  generic_params.emplace_back (std::move (param));\n+\t  maybe_skip_token (COMMA);\n \t}\n-\n-      generic_params.push_back (std::move (type_param));\n-\n-      if (lexer.peek_token ()->get_id () != COMMA)\n-\tbreak;\n-\n-      // skip commas, including trailing commas\n-      lexer.skip_token ();\n-      t = lexer.peek_token ();\n     }\n \n-  // old code\n-  /*\n-  // parse lifetime params (optional), allowed to end with a trailing comma\n-  std::vector<std::unique_ptr<AST::LifetimeParam>> lifetime_params\n-    = parse_lifetime_params();\n-  if (!lifetime_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(lifetime_params.begin()),\n-\tstd::make_move_iterator(lifetime_params.end()));\n-  }\n-\n-  // parse type params (optional)\n-  std::vector<std::unique_ptr<AST::TypeParam>> type_params =\n-  parse_type_params(); if (!type_params.empty()) {\n-      // C++11 code:\n-      generic_params.insert(generic_params.end(),\n-\tstd::make_move_iterator(type_params.begin()),\n-\tstd::make_move_iterator(type_params.end()));\n-  }*/\n+  // FIXME: Add reordering hint\n+  if (order_error)\n+    rust_error_at (generic_params.front ()->get_locus (),\n+\t\t   \"invalid order for generic parameters: lifetimes should \"\n+\t\t   \"always come before types\");\n \n   generic_params.shrink_to_fit ();\n   return generic_params;"}, {"sha": "d19bc71d3105d02b4946ad2a7122685162680b14", "filename": "gcc/rust/parse/rust-parse.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "patch": "@@ -223,10 +223,12 @@ template <typename ManagedTokenSource> class Parser\n   AST::FunctionQualifiers parse_function_qualifiers ();\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params_in_angles ();\n-  std::vector<std::unique_ptr<AST::GenericParam> > parse_generic_params ();\n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::GenericParam> >\n   parse_generic_params (EndTokenPred is_end_token);\n+  template <typename EndTokenPred>\n+  std::unique_ptr<AST::GenericParam>\n+  parse_generic_param (EndTokenPred is_end_token);\n \n   template <typename EndTokenPred>\n   std::vector<std::unique_ptr<AST::LifetimeParam> >"}, {"sha": "05c75c5f63d74764f461a26dcca3710806874126", "filename": "gcc/testsuite/rust/compile/generics13.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics13.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/44f2de02d478b5d3defa5f091ee6504fa5d2e2e6/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics13.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Fgenerics13.rs?ref=44f2de02d478b5d3defa5f091ee6504fa5d2e2e6", "patch": "@@ -0,0 +1 @@\n+struct Foo<A, 'a>; // { dg-error \"invalid order for generic parameters: lifetimes should always come before types\" }"}]}