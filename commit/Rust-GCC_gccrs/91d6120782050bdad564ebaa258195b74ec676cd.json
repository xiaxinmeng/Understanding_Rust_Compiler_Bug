{"sha": "91d6120782050bdad564ebaa258195b74ec676cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTFkNjEyMDc4MjA1MGJkYWQ1NjRlYmFhMjU4MTk1Yjc0ZWM2NzZjZA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-13T19:49:13Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-10-13T19:49:13Z"}, "message": "(FLOAT_WORDS_BIG_ENDIAN): New macro.\n\n(HOST_FLOAT_WORDS_BIG_ENDIAN): Likewise, for host.\n(REAL_VALUE_TO_TARGET_DOUBLE (default version)): Use them.\n(efixi, efixui): Return HOST_WIDE_INT.\n(REAL_VALUE_FROM_INT): Cast inputs to HOST_WIDE_INT.\n\nFrom-SVN: r5775", "tree": {"sha": "983ca03d3ad9536bf4eed56a17948d3faf47c892", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/983ca03d3ad9536bf4eed56a17948d3faf47c892"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/91d6120782050bdad564ebaa258195b74ec676cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d6120782050bdad564ebaa258195b74ec676cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/91d6120782050bdad564ebaa258195b74ec676cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/91d6120782050bdad564ebaa258195b74ec676cd/comments", "author": null, "committer": null, "parents": [{"sha": "1f109a14e9505c5033834393594ca4d6a63c6ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1f109a14e9505c5033834393594ca4d6a63c6ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1f109a14e9505c5033834393594ca4d6a63c6ae7"}], "stats": {"total": 35, "additions": 29, "deletions": 6}, "files": [{"sha": "2090bb1575a3d1275298602904ae1883688ec9d6", "filename": "gcc/real.h", "status": "modified", "additions": 29, "deletions": 6, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/91d6120782050bdad564ebaa258195b74ec676cd/gcc%2Freal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/91d6120782050bdad564ebaa258195b74ec676cd/gcc%2Freal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freal.h?ref=91d6120782050bdad564ebaa258195b74ec676cd", "patch": "@@ -40,6 +40,24 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n #define REAL_INFINITY\n #endif\n \n+/* If FLOAT_WORDS_BIG_ENDIAN and HOST_FLOAT_WORDS_BIG_ENDIAN are not defined\n+   in the header files, then this implies the word-endianness is the same as\n+   for integers.  */\n+\n+/* This is defined 0 or 1, like WORDS_BIG_ENDIAN.  */\n+#ifndef FLOAT_WORDS_BIG_ENDIAN\n+#define FLOAT_WORDS_BIG_ENDIAN WORDS_BIG_ENDIAN\n+#endif\n+\n+/* This is defined 0 or 1, unlike HOST_WORDS_BIG_ENDIAN.  */\n+#ifndef HOST_FLOAT_WORDS_BIG_ENDIAN\n+#ifdef HOST_WORDS_BIG_ENDIAN\n+#define HOST_FLOAT_WORDS_BIG_ENDIAN 1\n+#else\n+#define HOST_FLOAT_WORDS_BIG_ENDIAN 0\n+#endif\n+#endif\n+\n /* Defining REAL_ARITHMETIC invokes a floating point emulator\n    that can produce a target machine format differing by more\n    than just endian-ness from the host's format.  The emulator\n@@ -108,8 +126,9 @@ typedef struct {\n /* Declare functions in real.c that are referenced here. */\n void earith (), ereal_from_uint (), ereal_from_int (), ereal_to_int ();\n void etarldouble (), etartdouble (), etardouble ();\n-long etarsingle (), efixi ();\n-unsigned long efixui ();\n+long etarsingle ();\n+HOST_WIDE_INT efixi ();\n+unsigned HOST_WIDE_INT efixui ();\n int ereal_cmp (), ereal_isneg ();\n unsigned int eroundui ();\n REAL_VALUE_TYPE etrunci (), etruncui (), ereal_ldexp (), ereal_atof ();\n@@ -127,7 +146,7 @@ REAL_VALUE_TYPE ereal_from_float (), ereal_from_double ();\n extern REAL_VALUE_TYPE real_value_truncate ();\n #define REAL_VALUE_TRUNCATE(mode, x)  real_value_truncate (mode, x)\n \n-/* These return int: */\n+/* These return HOST_WIDE_INT: */\n /* Convert a floating-point value to integer, rounding toward zero.  */\n #define REAL_VALUE_FIX(x) (efixi (x))\n /* Convert a floating-point value to unsigned integer, rounding\n@@ -141,8 +160,12 @@ extern REAL_VALUE_TYPE real_value_truncate ();\n  ((ereal_cmp (x, dconst0) == 0) && (ereal_isneg (x) != 0 ))\n \n #define REAL_VALUE_TO_INT ereal_to_int\n-#define REAL_VALUE_FROM_INT(d, i, j) (ereal_from_int (&d, i, j))\n-#define REAL_VALUE_FROM_UNSIGNED_INT(d, i, j) (ereal_from_uint (&d, i, j))\n+\n+/* Here the cast to HOST_WIDE_INT sign-extends arguments such as ~0.  */\n+#define REAL_VALUE_FROM_INT(d, lo, hi) \\\n+  ereal_from_int (&d, (HOST_WIDE_INT) (lo), (HOST_WIDE_INT) (hi))\n+\n+#define REAL_VALUE_FROM_UNSIGNED_INT(d, lo, hi) (ereal_from_uint (&d, lo, hi))\n \n /* IN is a REAL_VALUE_TYPE.  OUT is an array of longs. */\n #if LONG_DOUBLE_TYPE_SIZE == 96\n@@ -218,7 +241,7 @@ do { float f = (float) (IN);\t\t\t\t\t\t\\\n    values which is its bitwise equivalent, but put the two words into\n    proper word order for the target.  */\n #ifndef REAL_VALUE_TO_TARGET_DOUBLE\n-#if defined (HOST_WORDS_BIG_ENDIAN) == WORDS_BIG_ENDIAN\n+#if HOST_FLOAT_WORDS_BIG_ENDIAN == FLOAT_WORDS_BIG_ENDIAN\n #define REAL_VALUE_TO_TARGET_DOUBLE(IN, OUT)\t\t\t\t\\\n do { REAL_VALUE_TYPE in = (IN);  /* Make sure it's not in a register.  */\\\n      (OUT)[0] = ((long *) &in)[0];\t\t\t\t\t\\"}]}