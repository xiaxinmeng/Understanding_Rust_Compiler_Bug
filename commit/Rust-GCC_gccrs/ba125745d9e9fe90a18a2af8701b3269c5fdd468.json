{"sha": "ba125745d9e9fe90a18a2af8701b3269c5fdd468", "node_id": "C_kwDOANBUbNoAKGJhMTI1NzQ1ZDllOWZlOTBhMThhMmFmODcwMWIzMjY5YzVmZGQ0Njg", "commit": {"author": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-02-09T07:00:33Z"}, "committer": {"name": "Eugene Rozenfeld", "email": "erozen@microsoft.com", "date": "2022-02-10T07:33:10Z"}, "message": "AutoFDO: Don't try to promote indirect calls that result in recursive direct calls\n\nAutoFDO tries to promote and inline all indirect calls that were promoted\nand inlined in the original binary and that are still hot. In the included\ntest case, the promotion results in a direct call that is a recursive call.\ninline_call and optimize_inline_calls can't handle recursive calls at this stage.\nCurrently, inline_call fails with a segmentation fault.\n\nThis change leaves the indirect call alone if promotion will result in a recursive call.\n\nTested on x86_64-pc-linux-gnu.\n\ngcc/ChangeLog:\n\t* auto-profile.cc (afdo_indirect_call): Don't attempt to promote indirect calls\n\tthat will result in direct recursive calls.\n\ngcc/testsuite/ChangeLog:\n\t* g++.dg/tree-prof/indir-call-recursive-inlining.C : New test.", "tree": {"sha": "ec7c6b95fa344b78dc44cbccaeb7d02b4a6a6027", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec7c6b95fa344b78dc44cbccaeb7d02b4a6a6027"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba125745d9e9fe90a18a2af8701b3269c5fdd468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba125745d9e9fe90a18a2af8701b3269c5fdd468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba125745d9e9fe90a18a2af8701b3269c5fdd468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba125745d9e9fe90a18a2af8701b3269c5fdd468/comments", "author": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erozenfeld", "id": 10624223, "node_id": "MDQ6VXNlcjEwNjI0MjIz", "avatar_url": "https://avatars.githubusercontent.com/u/10624223?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erozenfeld", "html_url": "https://github.com/erozenfeld", "followers_url": "https://api.github.com/users/erozenfeld/followers", "following_url": "https://api.github.com/users/erozenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/erozenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/erozenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erozenfeld/subscriptions", "organizations_url": "https://api.github.com/users/erozenfeld/orgs", "repos_url": "https://api.github.com/users/erozenfeld/repos", "events_url": "https://api.github.com/users/erozenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/erozenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "41582f88ec01c5ce2f85ebc4ac2743eb426d6e33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41582f88ec01c5ce2f85ebc4ac2743eb426d6e33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41582f88ec01c5ce2f85ebc4ac2743eb426d6e33"}], "stats": {"total": 94, "additions": 78, "deletions": 16}, "files": [{"sha": "2b34b80b82d26ad2aa0f5f63d886b8f257c2fb8a", "filename": "gcc/auto-profile.cc", "status": "modified", "additions": 24, "deletions": 16, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba125745d9e9fe90a18a2af8701b3269c5fdd468/gcc%2Fauto-profile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba125745d9e9fe90a18a2af8701b3269c5fdd468/gcc%2Fauto-profile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.cc?ref=ba125745d9e9fe90a18a2af8701b3269c5fdd468", "patch": "@@ -975,20 +975,20 @@ read_profile (void)\n      * after annotation, we just need to mark, and let follow-up logic to\n        decide if it needs to promote and inline.  */\n \n-static void\n+static bool\n afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n                     bool transform)\n {\n   gimple *gs = gsi_stmt (*gsi);\n   tree callee;\n \n   if (map.size () == 0)\n-    return;\n+    return false;\n   gcall *stmt = dyn_cast <gcall *> (gs);\n   if (!stmt\n       || gimple_call_internal_p (stmt)\n       || gimple_call_fndecl (stmt) != NULL_TREE)\n-    return;\n+    return false;\n \n   gcov_type total = 0;\n   icall_target_map::const_iterator max_iter = map.end ();\n@@ -1003,7 +1003,7 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n   struct cgraph_node *direct_call = cgraph_node::get_for_asmname (\n       get_identifier (afdo_string_table->get_name (max_iter->first)));\n   if (direct_call == NULL || !direct_call->profile_id)\n-    return;\n+    return false;\n \n   callee = gimple_call_fn (stmt);\n \n@@ -1013,20 +1013,27 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n   hist->hvalue.counters = XNEWVEC (gcov_type, hist->n_counters);\n   gimple_add_histogram_value (cfun, stmt, hist);\n \n-  // Total counter\n+  /* Total counter */\n   hist->hvalue.counters[0] = total;\n-  // Number of value/counter pairs\n+  /* Number of value/counter pairs */\n   hist->hvalue.counters[1] = 1;\n-  // Value\n+  /* Value */\n   hist->hvalue.counters[2] = direct_call->profile_id;\n-  // Counter\n+  /* Counter */\n   hist->hvalue.counters[3] = max_iter->second;\n \n   if (!transform)\n-    return;\n+    return false;\n+\n+  cgraph_node* current_function_node = cgraph_node::get (current_function_decl);\n+\n+  /* If the direct call is a recursive call, don't promote it since\n+     we are not set up to inline recursive calls at this stage. */\n+  if (direct_call == current_function_node)\n+    return false;\n \n   struct cgraph_edge *indirect_edge\n-      = cgraph_node::get (current_function_decl)->get_edge (stmt);\n+      = current_function_node->get_edge (stmt);\n \n   if (dump_file)\n     {\n@@ -1040,13 +1047,13 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n     {\n       if (dump_file)\n         fprintf (dump_file, \" not transforming\\n\");\n-      return;\n+      return false;\n     }\n   if (DECL_STRUCT_FUNCTION (direct_call->decl) == NULL)\n     {\n       if (dump_file)\n         fprintf (dump_file, \" no declaration\\n\");\n-      return;\n+      return false;\n     }\n \n   if (dump_file)\n@@ -1063,16 +1070,17 @@ afdo_indirect_call (gimple_stmt_iterator *gsi, const icall_target_map &map,\n   cgraph_edge::redirect_call_stmt_to_callee (new_edge);\n   gimple_remove_histogram_value (cfun, stmt, hist);\n   inline_call (new_edge, true, NULL, NULL, false);\n+  return true;\n }\n \n /* From AutoFDO profiles, find values inside STMT for that we want to measure\n    histograms and adds them to list VALUES.  */\n \n-static void\n+static bool\n afdo_vpt (gimple_stmt_iterator *gsi, const icall_target_map &map,\n           bool transform)\n {\n-  afdo_indirect_call (gsi, map, transform);\n+  return afdo_indirect_call (gsi, map, transform);\n }\n \n typedef std::set<basic_block> bb_set;\n@@ -1498,8 +1506,8 @@ afdo_vpt_for_early_inline (stmt_set *promoted_stmts)\n           {\n             /* Promote the indirect call and update the promoted_stmts.  */\n             promoted_stmts->insert (stmt);\n-            afdo_vpt (&gsi, info.targets, true);\n-            has_vpt = true;\n+            if (afdo_vpt (&gsi, info.targets, true))\n+              has_vpt = true;\n           }\n       }\n   }"}, {"sha": "11f690063ef9ddd2922d4e82cc8cd1a396464c15", "filename": "gcc/testsuite/g++.dg/tree-prof/indir-call-recursive-inlining.C", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba125745d9e9fe90a18a2af8701b3269c5fdd468/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-recursive-inlining.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba125745d9e9fe90a18a2af8701b3269c5fdd468/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-recursive-inlining.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Findir-call-recursive-inlining.C?ref=ba125745d9e9fe90a18a2af8701b3269c5fdd468", "patch": "@@ -0,0 +1,54 @@\n+/* { dg-options \"-O2 \" } */\n+\n+class Parent\n+{\n+public:\n+  Parent *object;\n+\n+  Parent()\n+  {\n+       object = this;\n+  }\n+\n+  virtual void recurse (int t) = 0;\n+};\n+\n+class Child : public Parent\n+{\n+\n+  Parent *\n+  get_object ()\n+  {\n+     return this;\n+  }\n+\n+public:\n+  virtual void\n+  recurse (int t)\n+  {\n+    if (t != 10)\n+      for (int i = 0; i < 5; ++i)\n+        get_object()->recurse(t + 1);\n+  };\n+};\n+\n+Parent *\n+create_object ()\n+{\n+  Child *mod = new Child;\n+  return mod;\n+}\n+\n+int\n+main (int argc, char **argv)\n+{\n+  Parent *parent = create_object ();\n+\n+  for (int i = 0; i < 5; ++i)\n+    {\n+\t  parent->recurse (0);\n+    }\n+\n+  return 0;\n+}\n+"}]}