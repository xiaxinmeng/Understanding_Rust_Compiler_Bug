{"sha": "4ecad771dd276d6c518d679b3e13c58b45737b8c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGVjYWQ3NzFkZDI3NmQ2YzUxOGQ2NzliM2UxM2M1OGI0NTczN2I4Yw==", "commit": {"author": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-05-05T07:59:22Z"}, "committer": {"name": "Janne Blomqvist", "email": "jb@gcc.gnu.org", "date": "2012-05-05T07:59:22Z"}, "message": "PR 49010,24518 MOD/MODULO fixes.\n\ngcc/fortran:\n\n2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/49010\n\tPR fortran/24518\n\t* intrinsic.texi (MOD, MODULO): Mention sign and magnitude of result.\n\t* simplify.c (gfc_simplify_mod): Use mpfr_fmod.\n\t(gfc_simplify_modulo): Likewise, use copysign to fix the result if\n\tzero.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_mod): Remove fallback as\n\tbuiltin_fmod is always available. For modulo, call copysign to fix\n\tthe result when signed zeros are enabled.\n\n\ntestsuite:\n\n2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n\n\tPR fortran/49010\n\tPR fortran/24518\n\t* gfortran.dg/mod_sign0_1.f90: New test.\n\t* gfortran.dg/mod_large_1.f90: New test.\n\nFrom-SVN: r187191", "tree": {"sha": "8d0572d604c2f2a46fc172d68dceeb1635b87c47", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d0572d604c2f2a46fc172d68dceeb1635b87c47"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ecad771dd276d6c518d679b3e13c58b45737b8c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ecad771dd276d6c518d679b3e13c58b45737b8c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ecad771dd276d6c518d679b3e13c58b45737b8c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ecad771dd276d6c518d679b3e13c58b45737b8c/comments", "author": null, "committer": null, "parents": [{"sha": "68ee9c0807fd3c9a66c649aa7bd3bebacfb0dff0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68ee9c0807fd3c9a66c649aa7bd3bebacfb0dff0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68ee9c0807fd3c9a66c649aa7bd3bebacfb0dff0"}], "stats": {"total": 274, "additions": 187, "deletions": 87}, "files": [{"sha": "a9b4195499dc0f2999c324b2fa1c138f1c252602", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -1,3 +1,15 @@\n+2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/49010\n+\tPR fortran/24518\n+\t* intrinsic.texi (MOD, MODULO): Mention sign and magnitude of result.\n+\t* simplify.c (gfc_simplify_mod): Use mpfr_fmod.\n+\t(gfc_simplify_modulo): Likewise, use copysign to fix the result if\n+\tzero.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_mod): Remove fallback as\n+\tbuiltin_fmod is always available. For modulo, call copysign to fix\n+\tthe result when signed zeros are enabled.\n+\n 2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n \n         * gfortran.texi (GFORTRAN_TMPDIR): Rename to TMPDIR, explain"}, {"sha": "9bc36d7d4153f412dd65f795beee26e6411da6c0", "filename": "gcc/fortran/intrinsic.texi", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Fintrinsic.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Fintrinsic.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.texi?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -8991,8 +8991,7 @@ cases, the result is of the same type and kind as @var{ARRAY}.\n \n @table @asis\n @item @emph{Description}:\n-@code{MOD(A,P)} computes the remainder of the division of A by P@. It is\n-calculated as @code{A - (INT(A/P) * P)}.\n+@code{MOD(A,P)} computes the remainder of the division of A by P@. \n \n @item @emph{Standard}:\n Fortran 77 and later\n@@ -9005,14 +9004,16 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A} @tab Shall be a scalar of type @code{INTEGER} or @code{REAL}\n-@item @var{P} @tab Shall be a scalar of the same type as @var{A} and not\n-equal to zero\n+@item @var{A} @tab Shall be a scalar of type @code{INTEGER} or @code{REAL}.\n+@item @var{P} @tab Shall be a scalar of the same type and kind as @var{A} \n+and not equal to zero.\n @end multitable\n \n @item @emph{Return value}:\n-The kind of the return value is the result of cross-promoting\n-the kinds of the arguments.\n+The return value is the result of @code{A - (INT(A/P) * P)}. The type\n+and kind of the return value is the same as that of the arguments. The\n+returned value has the same sign as A and a magnitude less than the\n+magnitude of P.\n \n @item @emph{Example}:\n @smallexample\n@@ -9041,6 +9042,10 @@ end program test_mod\n @item @code{AMOD(A,P)} @tab @code{REAL(4) A,P} @tab @code{REAL(4)} @tab Fortran 95 and later\n @item @code{DMOD(A,P)} @tab @code{REAL(8) A,P} @tab @code{REAL(8)} @tab Fortran 95 and later\n @end multitable\n+\n+@item @emph{See also}:\n+@ref{MODULO}\n+\n @end table\n \n \n@@ -9066,8 +9071,9 @@ Elemental function\n \n @item @emph{Arguments}:\n @multitable @columnfractions .15 .70\n-@item @var{A} @tab Shall be a scalar of type @code{INTEGER} or @code{REAL}\n-@item @var{P} @tab Shall be a scalar of the same type and kind as @var{A}\n+@item @var{A} @tab Shall be a scalar of type @code{INTEGER} or @code{REAL}.\n+@item @var{P} @tab Shall be a scalar of the same type and kind as @var{A}. \n+It shall not be zero.\n @end multitable\n \n @item @emph{Return value}:\n@@ -9080,7 +9086,8 @@ The type and kind of the result are those of the arguments.\n @item If @var{A} and @var{P} are of type @code{REAL}:\n @code{MODULO(A,P)} has the value of @code{A - FLOOR (A / P) * P}.\n @end table\n-In all cases, if @var{P} is zero the result is processor-dependent.\n+The returned value has the same sign as P and a magnitude less than\n+the magnitude of P.\n \n @item @emph{Example}:\n @smallexample\n@@ -9096,6 +9103,9 @@ program test_modulo\n end program\n @end smallexample\n \n+@item @emph{See also}:\n+@ref{MOD}\n+\n @end table\n \n "}, {"sha": "1578db19b94866079bc2edc9aad26f23e00330b4", "filename": "gcc/fortran/simplify.c", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -4222,7 +4222,6 @@ gfc_expr *\n gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n-  mpfr_t tmp;\n   int kind;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n@@ -4254,12 +4253,8 @@ gfc_simplify_mod (gfc_expr *a, gfc_expr *p)\n \t  }\n \n \tgfc_set_model_kind (kind);\n-\tmpfr_init (tmp);\n-\tmpfr_div (tmp, a->value.real, p->value.real, GFC_RND_MODE);\n-\tmpfr_trunc (tmp, tmp);\n-\tmpfr_mul (tmp, tmp, p->value.real, GFC_RND_MODE);\n-\tmpfr_sub (result->value.real, a->value.real, tmp, GFC_RND_MODE);\n-\tmpfr_clear (tmp);\n+\tmpfr_fmod (result->value.real, a->value.real, p->value.real, \n+\t\t   GFC_RND_MODE);\n \tbreak;\n \n       default:\n@@ -4274,7 +4269,6 @@ gfc_expr *\n gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n {\n   gfc_expr *result;\n-  mpfr_t tmp;\n   int kind;\n \n   if (a->expr_type != EXPR_CONSTANT || p->expr_type != EXPR_CONSTANT)\n@@ -4308,12 +4302,17 @@ gfc_simplify_modulo (gfc_expr *a, gfc_expr *p)\n \t  }\n \n \tgfc_set_model_kind (kind);\n-\tmpfr_init (tmp);\n-\tmpfr_div (tmp, a->value.real, p->value.real, GFC_RND_MODE);\n-\tmpfr_floor (tmp, tmp);\n-\tmpfr_mul (tmp, tmp, p->value.real, GFC_RND_MODE);\n-\tmpfr_sub (result->value.real, a->value.real, tmp, GFC_RND_MODE);\n-\tmpfr_clear (tmp);\n+\tmpfr_fmod (result->value.real, a->value.real, p->value.real, \n+\t\t   GFC_RND_MODE);\n+\tif (mpfr_cmp_ui (result->value.real, 0) != 0)\n+\t  {\n+\t    if (mpfr_signbit (a->value.real) != mpfr_signbit (p->value.real))\n+\t      mpfr_add (result->value.real, result->value.real, p->value.real,\n+\t\t\tGFC_RND_MODE);\n+\t  }\n+\telse\n+\t  mpfr_copysign (result->value.real, result->value.real, \n+\t\t\t p->value.real, GFC_RND_MODE);\n \tbreak;\n \n       default:"}, {"sha": "bfbebf3269b6d8e0b5406c10c19a42f2ea92daa6", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 65, "deletions": 63, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -1719,21 +1719,24 @@ gfc_conv_intrinsic_cmplx (gfc_se * se, gfc_expr * expr, int both)\n   se->expr = fold_build2_loc (input_location, COMPLEX_EXPR, type, real, imag);\n }\n \n+\n /* Remainder function MOD(A, P) = A - INT(A / P) * P\n-                      MODULO(A, P) = A - FLOOR (A / P) * P  */\n-/* TODO: MOD(x, 0)  */\n+                      MODULO(A, P) = A - FLOOR (A / P) * P  \n+\n+   The obvious algorithms above are numerically instable for large\n+   arguments, hence these intrinsics are instead implemented via calls\n+   to the fmod family of functions.  It is the responsibility of the\n+   user to ensure that the second argument is non-zero.  */\n \n static void\n gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n {\n   tree type;\n-  tree itype;\n   tree tmp;\n   tree test;\n   tree test2;\n   tree fmod;\n-  mpfr_t huge;\n-  int n, ikind;\n+  tree zero;\n   tree args[2];\n \n   gfc_conv_intrinsic_function_args (se, expr, args, 2);\n@@ -1757,33 +1760,47 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n       /* Check if we have a builtin fmod.  */\n       fmod = gfc_builtin_decl_for_float_kind (BUILT_IN_FMOD, expr->ts.kind);\n \n-      /* Use it if it exists.  */\n-      if (fmod != NULL_TREE)\n-\t{\n-  \t  tmp = build_addr (fmod, current_function_decl);\n-\t  se->expr = build_call_array_loc (input_location,\n+      /* The builtin should always be available.  */\n+      gcc_assert (fmod != NULL_TREE);\n+\n+      tmp = build_addr (fmod, current_function_decl);\n+      se->expr = build_call_array_loc (input_location,\n \t\t\t\t       TREE_TYPE (TREE_TYPE (fmod)),\n                                        tmp, 2, args);\n-\t  if (modulo == 0)\n-\t    return;\n-\t}\n+      if (modulo == 0)\n+\treturn;\n \n       type = TREE_TYPE (args[0]);\n \n       args[0] = gfc_evaluate_now (args[0], &se->pre);\n       args[1] = gfc_evaluate_now (args[1], &se->pre);\n \n       /* Definition:\n-\t modulo = arg - floor (arg/arg2) * arg2, so\n-\t\t= test ? fmod (arg, arg2) : fmod (arg, arg2) + arg2, \n-\t where\n-\t  test  = (fmod (arg, arg2) != 0) && ((arg < 0) xor (arg2 < 0))\n-\t thereby avoiding another division and retaining the accuracy\n-\t of the builtin function.  */\n-      if (fmod != NULL_TREE && modulo)\n+\t modulo = arg - floor (arg/arg2) * arg2\n+\n+\t In order to calculate the result accurately, we use the fmod\n+\t function as follows.\n+\t \n+\t res = fmod (arg, arg2);\n+\t if (res)\n+\t   {\n+\t     if ((arg < 0) xor (arg2 < 0))\n+\t       res += arg2;\n+\t   }\n+\t else\n+\t   res = copysign (0., arg2);\n+\n+\t => As two nested ternary exprs:\n+\n+\t res = res ? (((arg < 0) xor (arg2 < 0)) ? res + arg2 : res) \n+\t       : copysign (0., arg2);\n+\n+      */\n+\n+      zero = gfc_build_const (type, integer_zero_node);\n+      tmp = gfc_evaluate_now (se->expr, &se->pre);\n+      if (!flag_signed_zeros)\n \t{\n-\t  tree zero = gfc_build_const (type, integer_zero_node);\n-\t  tmp = gfc_evaluate_now (se->expr, &se->pre);\n \t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n \t\t\t\t  args[0], zero);\n \t  test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n@@ -1796,50 +1813,35 @@ gfc_conv_intrinsic_mod (gfc_se * se, gfc_expr * expr, int modulo)\n \t\t\t\t  boolean_type_node, test, test2);\n \t  test = gfc_evaluate_now (test, &se->pre);\n \t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n-\t\t\t\t  fold_build2_loc (input_location, PLUS_EXPR,\n-\t\t\t\t\t\t   type, tmp, args[1]), tmp);\n-\t  return;\n+\t\t\t\t      fold_build2_loc (input_location, \n+\t\t\t\t\t\t       PLUS_EXPR,\n+\t\t\t\t\t\t       type, tmp, args[1]), \n+\t\t\t\t      tmp);\n \t}\n-\n-      /* If we do not have a built_in fmod, the calculation is going to\n-\t have to be done longhand.  */\n-      tmp = fold_build2_loc (input_location, RDIV_EXPR, type, args[0], args[1]);\n-\n-      /* Test if the value is too large to handle sensibly.  */\n-      gfc_set_model_kind (expr->ts.kind);\n-      mpfr_init (huge);\n-      n = gfc_validate_kind (BT_INTEGER, expr->ts.kind, true);\n-      ikind = expr->ts.kind;\n-      if (n < 0)\n+      else\n \t{\n-\t  n = gfc_validate_kind (BT_INTEGER, gfc_max_integer_kind, false);\n-\t  ikind = gfc_max_integer_kind;\n+\t  tree expr1, copysign, cscall;\n+\t  copysign = gfc_builtin_decl_for_float_kind (BUILT_IN_COPYSIGN, \n+\t\t\t\t\t\t      expr->ts.kind);\n+\t  test = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t  args[0], zero);\n+\t  test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n+\t\t\t\t   args[1], zero);\n+\t  test2 = fold_build2_loc (input_location, TRUTH_XOR_EXPR,\n+\t\t\t\t   boolean_type_node, test, test2);\n+\t  expr1 = fold_build3_loc (input_location, COND_EXPR, type, test2,\n+\t\t\t\t   fold_build2_loc (input_location, \n+\t\t\t\t\t\t    PLUS_EXPR,\n+\t\t\t\t\t\t    type, tmp, args[1]), \n+\t\t\t\t   tmp);\n+\t  test = fold_build2_loc (input_location, NE_EXPR, boolean_type_node,\n+\t\t\t\t  tmp, zero);\n+\t  cscall = build_call_expr_loc (input_location, copysign, 2, zero, \n+\t\t\t\t\targs[1]);\n+\t  se->expr = fold_build3_loc (input_location, COND_EXPR, type, test,\n+\t\t\t\t      expr1, cscall);\n \t}\n-      mpfr_set_z (huge, gfc_integer_kinds[n].huge, GFC_RND_MODE);\n-      test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind, 0);\n-      test2 = fold_build2_loc (input_location, LT_EXPR, boolean_type_node,\n-\t\t\t       tmp, test);\n-\n-      mpfr_neg (huge, huge, GFC_RND_MODE);\n-      test = gfc_conv_mpfr_to_tree (huge, expr->ts.kind, 0);\n-      test = fold_build2_loc (input_location, GT_EXPR, boolean_type_node, tmp,\n-\t\t\t      test);\n-      test2 = fold_build2_loc (input_location, TRUTH_AND_EXPR,\n-\t\t\t       boolean_type_node, test, test2);\n-\n-      itype = gfc_get_int_type (ikind);\n-      if (modulo)\n-       tmp = build_fix_expr (&se->pre, tmp, itype, RND_FLOOR);\n-      else\n-       tmp = build_fix_expr (&se->pre, tmp, itype, RND_TRUNC);\n-      tmp = convert (type, tmp);\n-      tmp = fold_build3_loc (input_location, COND_EXPR, type, test2, tmp,\n-\t\t\t     args[0]);\n-      tmp = fold_build2_loc (input_location, MULT_EXPR, type, tmp, args[1]);\n-      se->expr = fold_build2_loc (input_location, MINUS_EXPR, type, args[0],\n-\t\t\t\t  tmp);\n-      mpfr_clear (huge);\n-      break;\n+      return;\n \n     default:\n       gcc_unreachable ();"}, {"sha": "c954165f0fda141e746b82c0fd7f1329b62f9120", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -1,3 +1,10 @@\n+2012-05-05  Janne Blomqvist  <jb@gcc.gnu.org>\n+\n+\tPR fortran/49010\n+\tPR fortran/24518\n+\t* gfortran.dg/mod_sign0_1.f90: New test.\n+\t* gfortran.dg/mod_large_1.f90: New test.\n+\n 2012-05-04  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/53175"}, {"sha": "1047ad62e981d9eb5d5dfc37b3996fac5a033f63", "filename": "gcc/testsuite/gfortran.dg/mod_large_1.f90", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_large_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_large_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_large_1.f90?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -0,0 +1,16 @@\n+! { dg-do run }\n+! PR fortran/24518 \n+! MOD/MODULO of large arguments.\n+! The naive algorithm goes pear-shaped for large arguments, instead\n+! use fmod.\n+! Here we test only with constant arguments (evaluated with\n+! mpfr_fmod), as we don't want to cause failures on targets with a\n+! crappy libm.\n+program mod_large_1\n+  implicit none\n+  real :: r1\n+  r1 = mod (1e22, 1.7)\n+  if (abs(r1 - 0.995928764) > 1e-5) call abort\n+  r1 = modulo (1e22, -1.7)\n+  if (abs(r1 + 0.704071283) > 1e-5) call abort\n+end program mod_large_1"}, {"sha": "61ef5fd046c464a71a54383556cb263b3488a7bc", "filename": "gcc/testsuite/gfortran.dg/mod_sign0_1.f90", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_sign0_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ecad771dd276d6c518d679b3e13c58b45737b8c/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_sign0_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fmod_sign0_1.f90?ref=4ecad771dd276d6c518d679b3e13c58b45737b8c", "patch": "@@ -0,0 +1,54 @@\n+! { dg-do run }\n+! PR fortran/49010 \n+! MOD/MODULO sign of zero.\n+\n+! We wish to provide the following guarantees:\n+\n+! MOD(A, P): The result has the sign of A and a magnitude less than\n+! that of P.  \n+\n+! MODULO(A, P): The result has the sign of P and a magnitude less than\n+! that of P.\n+\n+! Here we test only with constant arguments (evaluated with\n+! mpfr_fmod), as we don't want to cause failures on targets with a\n+! crappy libm. But, a target where fmod follows C99 Annex F is\n+! fine. Also, targets where GCC inline expands fmod (such as x86(-64))\n+! are also fine.\n+program mod_sign0_1\n+  implicit none\n+  real :: r, t\n+\n+  r = mod (4., 2.)\n+  t = sign (1., r)\n+  if (t < 0.) call abort\n+\n+  r = modulo (4., 2.)\n+  t = sign (1., r)\n+  if (t < 0.) call abort\n+\n+  r = mod (-4., 2.)\n+  t = sign (1., r)\n+  if (t > 0.) call abort\n+\n+  r = modulo (-4., 2.)\n+  t = sign (1., r)\n+  if (t < 0.) call abort\n+\n+  r = mod (4., -2.)\n+  t = sign (1., r)\n+  if (t < 0.) call abort\n+\n+  r = modulo (4., -2.)\n+  t = sign (1., r)\n+  if (t > 0.) call abort\n+\n+  r = mod (-4., -2.)\n+  t = sign (1., r)\n+  if (t > 0.) call abort\n+\n+  r = modulo (-4., -2.)\n+  t = sign (1., r)\n+  if (t > 0.) call abort\n+\n+end program mod_sign0_1"}]}