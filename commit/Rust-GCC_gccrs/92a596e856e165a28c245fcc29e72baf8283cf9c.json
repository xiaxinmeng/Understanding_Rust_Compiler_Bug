{"sha": "92a596e856e165a28c245fcc29e72baf8283cf9c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJhNTk2ZTg1NmUxNjVhMjhjMjQ1ZmNjMjllNzJiYWY4MjgzY2Y5Yw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2014-12-17T20:41:12Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2014-12-17T20:41:12Z"}, "message": "* constexpr.c: Change \"addr\" parm names to \"lval\".\n\nFrom-SVN: r218831", "tree": {"sha": "9da30b5a0ad71cf6b7a38c9bbfb81ac0b7defc7a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9da30b5a0ad71cf6b7a38c9bbfb81ac0b7defc7a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92a596e856e165a28c245fcc29e72baf8283cf9c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a596e856e165a28c245fcc29e72baf8283cf9c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92a596e856e165a28c245fcc29e72baf8283cf9c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92a596e856e165a28c245fcc29e72baf8283cf9c/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "13f649f66cbd81ef7c508e6b6e2740ba7eb566c0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13f649f66cbd81ef7c508e6b6e2740ba7eb566c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13f649f66cbd81ef7c508e6b6e2740ba7eb566c0"}], "stats": {"total": 178, "additions": 90, "deletions": 88}, "files": [{"sha": "8adf2a12f04ced8640225dc6b61a657c3481a195", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a596e856e165a28c245fcc29e72baf8283cf9c/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a596e856e165a28c245fcc29e72baf8283cf9c/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=92a596e856e165a28c245fcc29e72baf8283cf9c", "patch": "@@ -1,5 +1,7 @@\n 2014-12-17  Jason Merrill  <jason@redhat.com>\n \n+\t* constexpr.c: Change \"addr\" parm names to \"lval\".\n+\n \t* constexpr.c: Tweak comments and formatting.\n \n 2014-12-16  Paolo Carlini  <paolo.carlini@oracle.com>"}, {"sha": "3ab80f7aba719e13e267a3ec3f3488dbce7948a7", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 88, "deletions": 88, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92a596e856e165a28c245fcc29e72baf8283cf9c/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92a596e856e165a28c245fcc29e72baf8283cf9c/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=92a596e856e165a28c245fcc29e72baf8283cf9c", "patch": "@@ -999,7 +999,7 @@ lookup_parameter_binding (const constexpr_call *call, tree t)\n \n static tree\n cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n-\t\t\t\tbool addr,\n+\t\t\t\tbool lval,\n \t\t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   const int nargs = call_expr_nargs (t);\n@@ -1009,7 +1009,7 @@ cxx_eval_builtin_function_call (const constexpr_ctx *ctx, tree t,\n   for (i = 0; i < nargs; ++i)\n     {\n       args[i] = cxx_eval_constant_expression (ctx, CALL_EXPR_ARG (t, i),\n-\t\t\t\t\t      addr,\n+\t\t\t\t\t      lval,\n \t\t\t\t\t      non_constant_p, overflow_p);\n       if (ctx->quiet && *non_constant_p)\n \treturn t;\n@@ -1071,7 +1071,7 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  x = ctx->object;\n \t  x = cp_build_addr_expr (x, tf_warning_or_error);\n \t}\n-      bool addr = false;\n+      bool lval = false;\n       if (parms && DECL_BY_REFERENCE (parms) && !use_new_call)\n \t{\n \t  /* cp_genericize made this a reference for argument passing, but\n@@ -1082,9 +1082,9 @@ cxx_bind_parameters_in_call (const constexpr_ctx *ctx, tree t,\n \t  gcc_assert (TREE_CODE (TREE_TYPE (x)) == REFERENCE_TYPE);\n \t  type = TREE_TYPE (type);\n \t  x = convert_from_reference (x);\n-\t  addr = true;\n+\t  lval = true;\n \t}\n-      arg = cxx_eval_constant_expression (ctx, x, addr,\n+      arg = cxx_eval_constant_expression (ctx, x, lval,\n \t\t\t\t\t  non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (*non_constant_p && ctx->quiet)\n@@ -1150,7 +1150,7 @@ cx_error_context (void)\n \n static tree\n cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool addr,\n+\t\t\t  bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   location_t loc = EXPR_LOC_OR_LOC (t, input_location);\n@@ -1178,7 +1178,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n     {\n       /* Might be a constexpr function pointer.  */\n       fun = cxx_eval_constant_expression (ctx, fun,\n-\t\t\t\t\t  /*addr*/false, non_constant_p,\n+\t\t\t\t\t  /*lval*/false, non_constant_p,\n \t\t\t\t\t  overflow_p);\n       STRIP_NOPS (fun);\n       if (TREE_CODE (fun) == ADDR_EXPR)\n@@ -1200,7 +1200,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \n   if (is_builtin_fn (fun))\n     return cxx_eval_builtin_function_call (ctx, t,\n-\t\t\t\t\t   addr, non_constant_p, overflow_p);\n+\t\t\t\t\t   lval, non_constant_p, overflow_p);\n   if (!DECL_DECLARED_CONSTEXPR_P (fun))\n     {\n       if (!ctx->quiet)\n@@ -1219,7 +1219,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t{\n \t  tree arg = convert_from_reference (get_nth_callarg (t, 1));\n \t  return cxx_eval_constant_expression (ctx, arg,\n-\t\t\t\t\t       addr, non_constant_p,\n+\t\t\t\t\t       lval, non_constant_p,\n \t\t\t\t\t       overflow_p);\n \t}\n       else if (TREE_CODE (t) == AGGR_INIT_EXPR\n@@ -1315,7 +1315,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t      new_ctx.call = &new_call;\n \t      result = (cxx_eval_constant_expression\n \t\t\t(&new_ctx, new_call.fundef->body,\n-\t\t\t addr,\n+\t\t\t lval,\n \t\t\t non_constant_p, overflow_p));\n \t    }\n \t  else\n@@ -1358,7 +1358,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \n \t      tree jump_target = NULL_TREE;\n \t      cxx_eval_constant_expression (ctx, body,\n-\t\t\t\t\t    addr, non_constant_p, overflow_p,\n+\t\t\t\t\t    lval, non_constant_p, overflow_p,\n \t\t\t\t\t    &jump_target);\n \n \t      if (DECL_CONSTRUCTOR_P (fun))\n@@ -1367,7 +1367,7 @@ cxx_eval_call_expression (const constexpr_ctx *ctx, tree t,\n \t\t   side-effects rather than the value.  We could get at the\n \t\t   value by evaluating *this, but we don't bother; there's\n \t\t   no need to put such a call in the hash table.  */\n-\t\tresult = addr ? ctx->object : ctx->ctor;\n+\t\tresult = lval ? ctx->object : ctx->ctor;\n \t      else\n \t\t{\n \t\t  result = *ctx->values->get (slot ? slot : res);\n@@ -1558,13 +1558,13 @@ cxx_eval_check_shift_p (location_t loc, const constexpr_ctx *ctx,\n \n static tree\n cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool addr,\n+\t\t\t   bool lval,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_arg = TREE_OPERAND (t, 0);\n   tree arg = cxx_eval_constant_expression (ctx, orig_arg,\n-\t\t\t\t\t   addr, non_constant_p, overflow_p);\n+\t\t\t\t\t   lval, non_constant_p, overflow_p);\n   VERIFY_CONSTANT (arg);\n   location_t loc = EXPR_LOCATION (t);\n   enum tree_code code = TREE_CODE (t);\n@@ -1586,19 +1586,19 @@ cxx_eval_unary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t    bool addr,\n+\t\t\t    bool lval,\n \t\t\t    bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree orig_lhs = TREE_OPERAND (t, 0);\n   tree orig_rhs = TREE_OPERAND (t, 1);\n   tree lhs, rhs;\n   lhs = cxx_eval_constant_expression (ctx, orig_lhs,\n-\t\t\t\t      addr,\n+\t\t\t\t      lval,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   rhs = cxx_eval_constant_expression (ctx, orig_rhs,\n-\t\t\t\t      addr,\n+\t\t\t\t      lval,\n \t\t\t\t      non_constant_p, overflow_p);\n   VERIFY_CONSTANT (rhs);\n \n@@ -1625,22 +1625,22 @@ cxx_eval_binary_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t\t bool addr,\n+\t\t\t\t bool lval,\n \t\t\t\t bool *non_constant_p, bool *overflow_p,\n \t\t\t\t tree *jump_target)\n {\n   tree val = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   addr,\n+\t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (val);\n   /* Don't VERIFY_CONSTANT the other operands.  */\n   if (integer_zerop (val))\n     return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 2),\n-\t\t\t\t\t addr,\n+\t\t\t\t\t lval,\n \t\t\t\t\t non_constant_p, overflow_p,\n \t\t\t\t\t jump_target);\n   return cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t       addr,\n+\t\t\t\t       lval,\n \t\t\t\t       non_constant_p, overflow_p,\n \t\t\t\t       jump_target);\n }\n@@ -1650,12 +1650,12 @@ cxx_eval_conditional_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t  bool addr,\n+\t\t\t  bool lval,\n \t\t\t  bool *non_constant_p, bool *overflow_p)\n {\n   tree oldary = TREE_OPERAND (t, 0);\n   tree ary = cxx_eval_constant_expression (ctx, oldary,\n-\t\t\t\t\t   addr,\n+\t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   tree index, oldidx;\n   HOST_WIDE_INT i;\n@@ -1668,9 +1668,9 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\tfalse,\n \t\t\t\t\tnon_constant_p, overflow_p);\n   VERIFY_CONSTANT (index);\n-  if (addr && ary == oldary && index == oldidx)\n+  if (lval && ary == oldary && index == oldidx)\n     return t;\n-  else if (addr)\n+  else if (lval)\n     return build4 (ARRAY_REF, TREE_TYPE (t), ary, index, NULL, NULL);\n   elem_type = TREE_TYPE (TREE_TYPE (ary));\n   if (TREE_CODE (ary) == CONSTRUCTOR)\n@@ -1696,7 +1696,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \t     initializer, it's value-initialized.  */\n \t  tree val = build_value_init (elem_type, tf_warning_or_error);\n \t  return cxx_eval_constant_expression (ctx, val,\n-\t\t\t\t\t       addr,\n+\t\t\t\t\t       lval,\n \t\t\t\t\t       non_constant_p, overflow_p);\n \t}\n \n@@ -1733,7 +1733,7 @@ cxx_eval_array_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool addr,\n+\t\t\t      bool lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   unsigned HOST_WIDE_INT i;\n@@ -1742,11 +1742,11 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   tree part = TREE_OPERAND (t, 1);\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n-\t\t\t\t\t     addr,\n+\t\t\t\t\t     lval,\n \t\t\t\t\t     non_constant_p, overflow_p);\n   if (whole == orig_whole)\n     return t;\n-  if (addr)\n+  if (lval)\n     return fold_build3 (COMPONENT_REF, TREE_TYPE (t),\n \t\t\twhole, part, NULL_TREE);\n   /* Don't VERIFY_CONSTANT here; we only want to check that we got a\n@@ -1801,7 +1801,7 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n   /* If there's no explicit init for this field, it's value-initialized.  */\n   value = build_value_init (TREE_TYPE (t), tf_warning_or_error);\n   return cxx_eval_constant_expression (ctx, value,\n-\t\t\t\t       addr,\n+\t\t\t\t       lval,\n \t\t\t\t       non_constant_p, overflow_p);\n }\n \n@@ -1811,15 +1811,15 @@ cxx_eval_component_reference (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n-\t\t\tbool addr,\n+\t\t\tbool lval,\n \t\t\tbool *non_constant_p, bool *overflow_p)\n {\n   tree orig_whole = TREE_OPERAND (t, 0);\n   tree retval, fldval, utype, mask;\n   bool fld_seen = false;\n   HOST_WIDE_INT istart, isize;\n   tree whole = cxx_eval_constant_expression (ctx, orig_whole,\n-\t\t\t\t\t     addr,\n+\t\t\t\t\t     lval,\n \t\t\t\t\t     non_constant_p, overflow_p);\n   tree start, field, value;\n   unsigned HOST_WIDE_INT i;\n@@ -1897,19 +1897,19 @@ cxx_eval_bit_field_ref (const constexpr_ctx *ctx, tree t,\n static tree\n cxx_eval_logical_expression (const constexpr_ctx *ctx, tree t,\n                              tree bailout_value, tree continue_value,\n-\t\t\t     bool addr,\n+\t\t\t     bool lval,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree r;\n   tree lhs = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\t   addr,\n+\t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p);\n   VERIFY_CONSTANT (lhs);\n   if (tree_int_cst_equal (lhs, bailout_value))\n     return lhs;\n   gcc_assert (tree_int_cst_equal (lhs, continue_value));\n   r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t    addr, non_constant_p,\n+\t\t\t\t    lval, non_constant_p,\n \t\t\t\t    overflow_p);\n   VERIFY_CONSTANT (r);\n   return r;\n@@ -2031,7 +2031,7 @@ verify_ctor_sanity (const constexpr_ctx *ctx, tree type)\n \n static tree\n cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n-\t\t\t bool addr,\n+\t\t\t bool lval,\n \t\t\t bool *non_constant_p, bool *overflow_p)\n {\n   vec<constructor_elt, va_gc> *v = CONSTRUCTOR_ELTS (t);\n@@ -2052,7 +2052,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \t   initializers can refer to it.  */\n \tCONSTRUCTOR_APPEND_ELT (*p, index, new_ctx.ctor);\n       tree elt = cxx_eval_constant_expression (&new_ctx, value,\n-\t\t\t\t\t       addr,\n+\t\t\t\t\t       lval,\n \t\t\t\t\t       non_constant_p, overflow_p);\n       /* Don't VERIFY_CONSTANT here.  */\n       if (ctx->quiet && *non_constant_p)\n@@ -2111,7 +2111,7 @@ cxx_eval_bare_aggregate (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n-\t\t     bool value_init, bool addr,\n+\t\t     bool value_init, bool lval,\n \t\t     bool *non_constant_p, bool *overflow_p)\n {\n   tree elttype = TREE_TYPE (atype);\n@@ -2162,7 +2162,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t    eltinit = cp_build_array_ref (input_location, init, idx,\n \t\t\t\t\t  tf_warning_or_error);\n \t  eltinit = cxx_eval_vec_init_1 (&new_ctx, elttype, eltinit, value_init,\n-\t\t\t\t\t addr,\n+\t\t\t\t\t lval,\n \t\t\t\t\t non_constant_p, overflow_p);\n \t}\n       else if (pre_init)\n@@ -2171,7 +2171,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t     we just pre-built above.  */\n \t  eltinit = (cxx_eval_constant_expression\n \t\t     (&new_ctx, init,\n-\t\t      addr, non_constant_p, overflow_p));\n+\t\t      lval, non_constant_p, overflow_p));\n \t}\n       else\n \t{\n@@ -2184,7 +2184,7 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \t    eltinit = move (eltinit);\n \t  eltinit = force_rvalue (eltinit, tf_warning_or_error);\n \t  eltinit = (cxx_eval_constant_expression\n-\t\t     (&new_ctx, eltinit, addr,\n+\t\t     (&new_ctx, eltinit, lval,\n \t\t      non_constant_p, overflow_p));\n \t}\n       if (*non_constant_p && !ctx->quiet)\n@@ -2209,14 +2209,14 @@ cxx_eval_vec_init_1 (const constexpr_ctx *ctx, tree atype, tree init,\n \n static tree\n cxx_eval_vec_init (const constexpr_ctx *ctx, tree t,\n-\t\t   bool addr,\n+\t\t   bool lval,\n \t\t   bool *non_constant_p, bool *overflow_p)\n {\n   tree atype = TREE_TYPE (t);\n   tree init = VEC_INIT_EXPR_INIT (t);\n   tree r = cxx_eval_vec_init_1 (ctx, atype, init,\n \t\t\t\tVEC_INIT_EXPR_VALUE_INIT (t),\n-\t\t\t\taddr, non_constant_p, overflow_p);\n+\t\t\t\tlval, non_constant_p, overflow_p);\n   if (*non_constant_p)\n     return t;\n   else\n@@ -2416,12 +2416,12 @@ cxx_fold_indirect_ref (location_t loc, tree type, tree op0, bool *empty_base)\n \n static tree\n cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n-\t\t       bool addr,\n+\t\t       bool lval,\n \t\t       bool *non_constant_p, bool *overflow_p)\n {\n   tree orig_op0 = TREE_OPERAND (t, 0);\n   tree op0 = cxx_eval_constant_expression (ctx, orig_op0,\n-\t\t\t\t\t   /*addr*/false, non_constant_p,\n+\t\t\t\t\t   /*lval*/false, non_constant_p,\n \t\t\t\t\t   overflow_p);\n   bool empty_base = false;\n   tree r;\n@@ -2435,7 +2435,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \n   if (r)\n     r = cxx_eval_constant_expression (ctx, r,\n-\t\t\t\t      addr, non_constant_p, overflow_p);\n+\t\t\t\t      lval, non_constant_p, overflow_p);\n   else\n     {\n       tree sub = op0;\n@@ -2459,7 +2459,7 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n   /* If we're pulling out the value of an empty base, make sure\n      that the whole object is constant and then return an empty\n      CONSTRUCTOR.  */\n-  if (empty_base && !addr)\n+  if (empty_base && !lval)\n     {\n       VERIFY_CONSTANT (r);\n       r = build_constructor (TREE_TYPE (t), NULL);\n@@ -2468,9 +2468,9 @@ cxx_eval_indirect_ref (const constexpr_ctx *ctx, tree t,\n \n   if (r == NULL_TREE)\n     {\n-      if (addr && op0 != orig_op0)\n+      if (lval && op0 != orig_op0)\n \treturn build1 (INDIRECT_REF, TREE_TYPE (t), op0);\n-      if (!addr)\n+      if (!lval)\n \tVERIFY_CONSTANT (t);\n       return t;\n     }\n@@ -2526,7 +2526,7 @@ non_const_var_error (tree r)\n \n static tree\n cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t     bool addr,\n+\t\t\t     bool lval,\n \t\t\t     bool *non_constant_p, bool *overflow_p)\n {\n   int i;\n@@ -2536,7 +2536,7 @@ cxx_eval_trinary_expression (const constexpr_ctx *ctx, tree t,\n   for (i = 0; i < 3; i++)\n     {\n       args[i] = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, i),\n-\t\t\t\t\t      addr,\n+\t\t\t\t\t      lval,\n \t\t\t\t\t      non_constant_p, overflow_p);\n       VERIFY_CONSTANT (args[i]);\n     }\n@@ -2561,7 +2561,7 @@ var_in_constexpr_fn (tree t)\n \n static tree\n cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t   bool addr,\n+\t\t\t   bool lval,\n \t\t\t   bool *non_constant_p, bool *overflow_p)\n {\n   constexpr_ctx new_ctx = *ctx;\n@@ -2658,7 +2658,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n   if (*non_constant_p)\n     return t;\n-  else if (addr)\n+  else if (lval)\n     return target;\n   else\n     return init;\n@@ -2668,7 +2668,7 @@ cxx_eval_store_expression (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool addr,\n+\t\t\t      bool lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p)\n {\n   enum tree_code code = TREE_CODE (t);\n@@ -2711,7 +2711,7 @@ cxx_eval_increment_expression (const constexpr_ctx *ctx, tree t,\n   if (code == PREINCREMENT_EXPR || code == PREDECREMENT_EXPR)\n     {\n       /* Prefix ops are lvalues.  */\n-      if (addr)\n+      if (lval)\n \treturn op;\n       else\n \t/* But we optimize when the caller wants an rvalue.  */\n@@ -2886,7 +2886,7 @@ cxx_eval_switch_expr (const constexpr_ctx *ctx, tree t,\n \n static tree\n cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n-\t\t\t      bool addr,\n+\t\t\t      bool lval,\n \t\t\t      bool *non_constant_p, bool *overflow_p,\n \t\t\t      tree *jump_target)\n {\n@@ -2913,15 +2913,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n   switch (TREE_CODE (t))\n     {\n     case RESULT_DECL:\n-      if (addr)\n+      if (lval)\n \treturn t;\n       /* We ask for an rvalue for the RESULT_DECL when indirecting\n \t through an invisible reference.  */\n       gcc_assert (DECL_BY_REFERENCE (t));\n       return (*ctx->values->get (t));\n \n     case VAR_DECL:\n-      if (addr)\n+      if (lval)\n \treturn t;\n       /* else fall through. */\n     case CONST_DECL:\n@@ -2954,11 +2954,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       if (!use_new_call && ctx\n \t  && ctx->call && DECL_CONTEXT (t) == ctx->call->fundef->decl)\n \tr = lookup_parameter_binding (ctx->call, t);\n-      else if (addr && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n+      else if (lval && TREE_CODE (TREE_TYPE (t)) != REFERENCE_TYPE)\n \t/* glvalue use.  */;\n       else if (tree *p = ctx->values->get (r))\n \tr = *p;\n-      else if (addr)\n+      else if (lval)\n \t/* Defer in case this is only used for its type.  */;\n       else if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n \t/* Defer, there's no lvalue->rvalue conversion.  */;\n@@ -2978,7 +2978,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case CALL_EXPR:\n     case AGGR_INIT_EXPR:\n-      r = cxx_eval_call_expression (ctx, t, addr,\n+      r = cxx_eval_call_expression (ctx, t, lval,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -3034,15 +3034,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  ctx->values->put (new_ctx.object, new_ctx.ctor);\n \t  ctx = &new_ctx;\n \t}\n-      /* Pass false for 'addr' because this indicates\n+      /* Pass false for 'lval' because this indicates\n \t initialization of a temporary.  */\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n \t\t\t\t\tfalse,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       if (!*non_constant_p)\n \t/* Adjust the type of the result to the type of the temporary.  */\n \tr = adjust_temp_type (TREE_TYPE (t), r);\n-      if (addr)\n+      if (lval)\n \t{\n \t  tree slot = TARGET_EXPR_SLOT (t);\n \t  ctx->values->put (slot, r);\n@@ -3062,19 +3062,19 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t}\n       /* else fall through */\n     case MODIFY_EXPR:\n-      r = cxx_eval_store_expression (ctx, t, addr,\n+      r = cxx_eval_store_expression (ctx, t, lval,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case SCOPE_REF:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 1),\n-\t\t\t\t\taddr,\n+\t\t\t\t\tlval,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case RETURN_EXPR:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\taddr,\n+\t\t\t\t\tlval,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       *jump_target = t;\n       break;\n@@ -3098,7 +3098,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case EXPR_STMT:\n     case EH_SPEC_BLOCK:\n       r = cxx_eval_constant_expression (ctx, TREE_OPERAND (t, 0),\n-\t\t\t\t\taddr,\n+\t\t\t\t\tlval,\n \t\t\t\t\tnon_constant_p, overflow_p,\n \t\t\t\t\tjump_target);\n       break;\n@@ -3107,15 +3107,15 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t check for a constant operand or result; an address can be\n \t constant without its operand being, and vice versa.  */\n     case INDIRECT_REF:\n-      r = cxx_eval_indirect_ref (ctx, t, addr,\n+      r = cxx_eval_indirect_ref (ctx, t, lval,\n \t\t\t\t non_constant_p, overflow_p);\n       break;\n \n     case ADDR_EXPR:\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n-\t\t\t\t\t\t/*addr*/true,\n+\t\t\t\t\t\t/*lval*/true,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n \t/* Don't VERIFY_CONSTANT here.  */\n \tif (*non_constant_p)\n@@ -3138,7 +3138,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case BIT_NOT_EXPR:\n     case TRUTH_NOT_EXPR:\n     case FIXED_CONVERT_EXPR:\n-      r = cxx_eval_unary_expression (ctx, t, addr,\n+      r = cxx_eval_unary_expression (ctx, t, lval,\n \t\t\t\t     non_constant_p, overflow_p);\n       break;\n \n@@ -3168,7 +3168,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \tif ((TREE_CODE (op0) == TARGET_EXPR && op1 == TARGET_EXPR_SLOT (op0))\n \t    || TREE_CODE (op1) == EMPTY_CLASS_EXPR)\n \t  r = cxx_eval_constant_expression (ctx, op0,\n-\t\t\t\t\t    addr, non_constant_p, overflow_p,\n+\t\t\t\t\t    lval, non_constant_p, overflow_p,\n \t\t\t\t\t    jump_target);\n \telse\n \t  {\n@@ -3178,7 +3178,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t\t\t\t\t  jump_target);\n \t    op1 = TREE_OPERAND (t, 1);\n \t    r = cxx_eval_constant_expression (ctx, op1,\n-\t\t\t\t\t      addr, non_constant_p, overflow_p,\n+\t\t\t\t\t      lval, non_constant_p, overflow_p,\n \t\t\t\t\t      jump_target);\n \t  }\n       }\n@@ -3223,7 +3223,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case LTGT_EXPR:\n     case RANGE_EXPR:\n     case COMPLEX_EXPR:\n-      r = cxx_eval_binary_expression (ctx, t, addr,\n+      r = cxx_eval_binary_expression (ctx, t, lval,\n \t\t\t\t      non_constant_p, overflow_p);\n       break;\n \n@@ -3233,20 +3233,20 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case TRUTH_ANDIF_EXPR:\n       r = cxx_eval_logical_expression (ctx, t, boolean_false_node,\n \t\t\t\t       boolean_true_node,\n-\t\t\t\t       addr,\n+\t\t\t\t       lval,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case TRUTH_OR_EXPR:\n     case TRUTH_ORIF_EXPR:\n       r = cxx_eval_logical_expression (ctx, t, boolean_true_node,\n \t\t\t\t       boolean_false_node,\n-\t\t\t\t       addr,\n+\t\t\t\t       lval,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n     case ARRAY_REF:\n-      r = cxx_eval_array_reference (ctx, t, addr,\n+      r = cxx_eval_array_reference (ctx, t, lval,\n \t\t\t\t    non_constant_p, overflow_p);\n       break;\n \n@@ -3261,24 +3261,24 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  *non_constant_p = true;\n \t  return t;\n \t}\n-      r = cxx_eval_component_reference (ctx, t, addr,\n+      r = cxx_eval_component_reference (ctx, t, lval,\n \t\t\t\t\tnon_constant_p, overflow_p);\n       break;\n \n     case BIT_FIELD_REF:\n-      r = cxx_eval_bit_field_ref (ctx, t, addr,\n+      r = cxx_eval_bit_field_ref (ctx, t, lval,\n \t\t\t\t  non_constant_p, overflow_p);\n       break;\n \n     case COND_EXPR:\n     case VEC_COND_EXPR:\n-      r = cxx_eval_conditional_expression (ctx, t, addr,\n+      r = cxx_eval_conditional_expression (ctx, t, lval,\n \t\t\t\t\t   non_constant_p, overflow_p,\n \t\t\t\t\t   jump_target);\n       break;\n \n     case CONSTRUCTOR:\n-      r = cxx_eval_bare_aggregate (ctx, t, addr,\n+      r = cxx_eval_bare_aggregate (ctx, t, lval,\n \t\t\t\t   non_constant_p, overflow_p);\n       break;\n \n@@ -3288,13 +3288,13 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t be NULL, meaning default-initialization, or it will be an lvalue\n \t or xvalue of the same type, meaning direct-initialization from the\n \t corresponding member.  */\n-      r = cxx_eval_vec_init (ctx, t, addr,\n+      r = cxx_eval_vec_init (ctx, t, lval,\n \t\t\t     non_constant_p, overflow_p);\n       break;\n \n     case FMA_EXPR:\n     case VEC_PERM_EXPR:\n-      r = cxx_eval_trinary_expression (ctx, t, addr,\n+      r = cxx_eval_trinary_expression (ctx, t, lval,\n \t\t\t\t       non_constant_p, overflow_p);\n       break;\n \n@@ -3304,7 +3304,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       {\n \ttree oldop = TREE_OPERAND (t, 0);\n \ttree op = cxx_eval_constant_expression (ctx, oldop,\n-\t\t\t\t\t\taddr,\n+\t\t\t\t\t\tlval,\n \t\t\t\t\t\tnon_constant_p, overflow_p);\n \tif (*non_constant_p)\n \t  return t;\n@@ -3344,7 +3344,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \n     case BIND_EXPR:\n       return cxx_eval_constant_expression (ctx, BIND_EXPR_BODY (t),\n-\t\t\t\t\t   addr,\n+\t\t\t\t\t   lval,\n \t\t\t\t\t   non_constant_p, overflow_p,\n \t\t\t\t\t   jump_target);\n \n@@ -3353,7 +3353,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n     case PREDECREMENT_EXPR:\n     case POSTDECREMENT_EXPR:\n       return cxx_eval_increment_expression (ctx, t,\n-\t\t\t\t\t    addr, non_constant_p, overflow_p);\n+\t\t\t\t\t    lval, non_constant_p, overflow_p);\n \n     case LAMBDA_EXPR:\n     case NEW_EXPR:\n@@ -3376,7 +3376,7 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n       break;\n \n     case PLACEHOLDER_EXPR:\n-      if (!ctx || !ctx->ctor || (addr && !ctx->object))\n+      if (!ctx || !ctx->ctor || (lval && !ctx->object))\n \t{\n \t  /* A placeholder without a referent.  We can get here when\n \t     checking whether NSDMIs are noexcept, or in massage_init_elt;\n@@ -3390,11 +3390,11 @@ cxx_eval_constant_expression (const constexpr_ctx *ctx, tree t,\n \t  /* Use of the value or address of the current object.  We could\n \t     use ctx->object unconditionally, but using ctx->ctor when we\n \t     can is a minor optimization.  */\n-\t  tree ctor = addr ? ctx->object : ctx->ctor;\n+\t  tree ctor = lval ? ctx->object : ctx->ctor;\n \t  gcc_assert (same_type_ignoring_top_level_qualifiers_p\n \t\t      (TREE_TYPE (t), TREE_TYPE (ctor)));\n \t  return cxx_eval_constant_expression\n-\t    (ctx, ctor, addr,\n+\t    (ctx, ctor, lval,\n \t     non_constant_p, overflow_p);\n \t}\n       break;"}]}