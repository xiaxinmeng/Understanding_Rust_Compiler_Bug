{"sha": "76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzY1NDBhYzNlMzljZDU4YjBiMDA4NGYxZjFiNGZkMGVhM2MxMjJiMQ==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-06-23T09:07:22Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-06-23T09:07:22Z"}, "message": "re PR fortran/64674 ([OOP] ICE in ASSOCIATE with class array)\n\ngcc/fortran/ChangeLog:\n\n2015-06-23  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/64674\n\t* parse.c (parse_associate): Figure the rank and as of a\n\tclass array in an associate early.\n\t* primary.c (gfc_match_varspec): Prevent setting the\n\tdimension attribute on the sym for classes.\n\t* resolve.c (resolve_variable): Correct the component\n\tref's type for associated variables.  Add a full array ref\n\twhen class array's are associated.\n\t(resolve_assoc_var): Correct the type of the symbol,\n\twhen in the associate the expression's rank becomes scalar.\n\t* trans-expr.c (gfc_conv_variable): Indirect ref needed for\n\tallocatable associated objects.\n\ngcc/testsuite/ChangeLog:\n\n2015-06-23  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/64674\n\t* gfortran.dg/associate_18.f08: New test.\n\nFrom-SVN: r224827", "tree": {"sha": "9c5390ba13cb036568b057572fb5b757c5d0bdb1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c5390ba13cb036568b057572fb5b757c5d0bdb1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bcd119b7a308c3e89af4fbdaa30d45a146194235", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcd119b7a308c3e89af4fbdaa30d45a146194235", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcd119b7a308c3e89af4fbdaa30d45a146194235"}], "stats": {"total": 342, "additions": 327, "deletions": 15}, "files": [{"sha": "808bf7e70a1a20f38ca2a7c91c365acb2605b3e0", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -1,3 +1,18 @@\n+2015-06-23  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/64674\n+\t* parse.c (parse_associate): Figure the rank and as of a\n+\tclass array in an associate early.\n+\t* primary.c (gfc_match_varspec): Prevent setting the\n+\tdimension attribute on the sym for classes.\n+\t* resolve.c (resolve_variable): Correct the component\n+\tref's type for associated variables.  Add a full array ref\n+\twhen class array's are associated.\n+\t(resolve_assoc_var): Correct the type of the symbol,\n+\twhen in the associate the expression's rank becomes scalar.\n+\t* trans-expr.c (gfc_conv_variable): Indirect ref needed for\n+\tallocatable associated objects.\n+\n 2015-06-19  Mikael Morin  <mikael@gcc.gnu.org>\n \n \tPR fortran/66549"}, {"sha": "c70714240d5baee968298ff07c982de9f13e37fc", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -3958,6 +3958,8 @@ parse_associate (void)\n   for (a = new_st.ext.block.assoc; a; a = a->next)\n     {\n       gfc_symbol* sym;\n+      gfc_ref *ref;\n+      gfc_array_ref *array_ref;\n \n       if (gfc_get_sym_tree (a->name, NULL, &a->st, false))\n \tgcc_unreachable ();\n@@ -3974,6 +3976,84 @@ parse_associate (void)\n \t for parsing component references on the associate-name\n \t in case of association to a derived-type.  */\n       sym->ts = a->target->ts;\n+\n+      /* Check if the target expression is array valued.  This can not always\n+\t be done by looking at target.rank, because that might not have been\n+\t set yet.  Therefore traverse the chain of refs, looking for the last\n+\t array ref and evaluate that.  */\n+      array_ref = NULL;\n+      for (ref = a->target->ref; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY)\n+\t  array_ref = &ref->u.ar;\n+      if (array_ref || a->target->rank)\n+\t{\n+\t  gfc_array_spec *as;\n+\t  int dim, rank = 0;\n+\t  if (array_ref)\n+\t    {\n+\t      /* Count the dimension, that have a non-scalar extend.  */\n+\t      for (dim = 0; dim < array_ref->dimen; ++dim)\n+\t\tif (array_ref->dimen_type[dim] != DIMEN_ELEMENT\n+\t\t    && !(array_ref->dimen_type[dim] == DIMEN_UNKNOWN\n+\t\t\t && array_ref->end[dim] == NULL\n+\t\t\t && array_ref->start[dim] != NULL))\n+\t\t  ++rank;\n+\t    }\n+\t  else\n+\t    rank = a->target->rank;\n+\t  /* When the rank is greater than zero then sym will be an array.  */\n+\t  if (sym->ts.type == BT_CLASS)\n+\t    {\n+\t      if ((!CLASS_DATA (sym)->as && rank != 0)\n+\t\t  || (CLASS_DATA (sym)->as\n+\t\t      && CLASS_DATA (sym)->as->rank != rank))\n+\t\t{\n+\t\t  /* Don't just (re-)set the attr and as in the sym.ts,\n+\t\t     because this modifies the target's attr and as.  Copy the\n+\t\t     data and do a build_class_symbol.  */\n+\t\t  symbol_attribute attr = CLASS_DATA (a->target)->attr;\n+\t\t  int corank = gfc_get_corank (a->target);\n+\t\t  gfc_typespec type;\n+\n+\t\t  if (rank || corank)\n+\t\t    {\n+\t\t      as = gfc_get_array_spec ();\n+\t\t      as->type = AS_DEFERRED;\n+\t\t      as->rank = rank;\n+\t\t      as->corank = corank;\n+\t\t      attr.dimension = rank ? 1 : 0;\n+\t\t      attr.codimension = corank ? 1 : 0;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      as = NULL;\n+\t\t      attr.dimension = attr.codimension = 0;\n+\t\t    }\n+\t\t  attr.class_ok = 0;\n+\t\t  type = CLASS_DATA (sym)->ts;\n+\t\t  if (!gfc_build_class_symbol (&type,\n+\t\t\t\t\t       &attr, &as))\n+\t\t    gcc_unreachable ();\n+\t\t  sym->ts = type;\n+\t\t  sym->ts.type = BT_CLASS;\n+\t\t  sym->attr.class_ok = 1;\n+\t\t}\n+\t      else\n+\t\tsym->attr.class_ok = 1;\n+\t    }\n+\t  else if ((!sym->as && rank != 0)\n+\t\t   || (sym->as && sym->as->rank != rank))\n+\t    {\n+\t      as = gfc_get_array_spec ();\n+\t      as->type = AS_DEFERRED;\n+\t      as->rank = rank;\n+\t      as->corank = gfc_get_corank (a->target);\n+\t      sym->as = as;\n+\t      sym->attr.dimension = 1;\n+\t      if (as->corank)\n+\t\tsym->attr.codimension = 1;\n+\t    }\n+\t}\n     }\n \n   accept_statement (ST_ASSOCIATE);"}, {"sha": "86639aac65afb6ad5be04fb42b93ce5c5745bbd3", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -1911,7 +1911,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   if (sym->assoc && gfc_peek_ascii_char () == '('\n       && !(sym->assoc->dangling && sym->assoc->st\n \t   && sym->assoc->st->n.sym\n-\t   && sym->assoc->st->n.sym->attr.dimension == 0))\n+\t   && sym->assoc->st->n.sym->attr.dimension == 0)\n+      && sym->ts.type != BT_CLASS)\n     sym->attr.dimension = 1;\n \n   if ((equiv_flag && gfc_peek_ascii_char () == '(')"}, {"sha": "ea235a71e85681400dbebf3704223b8eb409705f", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 143, "deletions": 13, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -4969,6 +4969,30 @@ resolve_variable (gfc_expr *e)\n       return false;\n     }\n \n+  /* For variables that are used in an associate (target => object) where\n+     the object's basetype is array valued while the target is scalar,\n+     the ts' type of the component refs is still array valued, which\n+     can't be translated that way.  */\n+  if (sym->assoc && e->rank == 0 && e->ref && sym->ts.type == BT_CLASS\n+      && sym->assoc->target->ts.type == BT_CLASS\n+      && CLASS_DATA (sym->assoc->target)->as)\n+    {\n+      gfc_ref *ref = e->ref;\n+      while (ref)\n+\t{\n+\t  switch (ref->type)\n+\t    {\n+\t    case REF_COMPONENT:\n+\t      ref->u.c.sym = sym->ts.u.derived;\n+\t      /* Stop the loop.  */\n+\t      ref = NULL;\n+\t      break;\n+\t    default:\n+\t      ref = ref->next;\n+\t      break;\n+\t    }\n+\t}\n+    }\n \n   /* If this is an associate-name, it may be parsed with an array reference\n      in error even though the target is scalar.  Fail directly in this case.\n@@ -4994,6 +5018,49 @@ resolve_variable (gfc_expr *e)\n       e->ref->u.ar.dimen = 0;\n     }\n \n+  /* Like above, but for class types, where the checking whether an array\n+     ref is present is more complicated.  Furthermore make sure not to add\n+     the full array ref to _vptr or _len refs.  */\n+  if (sym->assoc && sym->ts.type == BT_CLASS\n+      && CLASS_DATA (sym)->attr.dimension\n+      && (e->ts.type != BT_DERIVED || !e->ts.u.derived->attr.vtype))\n+    {\n+      gfc_ref *ref, *newref;\n+\n+      newref = gfc_get_ref ();\n+      newref->type = REF_ARRAY;\n+      newref->u.ar.type = AR_FULL;\n+      newref->u.ar.dimen = 0;\n+      /* Because this is an associate var and the first ref either is a ref to\n+\t the _data component or not, no traversal of the ref chain is\n+\t needed.  The array ref needs to be inserted after the _data ref,\n+\t or when that is not present, which may happend for polymorphic\n+\t types, then at the first position.  */\n+      ref = e->ref;\n+      if (!ref)\n+\te->ref = newref;\n+      else if (ref->type == REF_COMPONENT\n+\t       && strcmp (\"_data\", ref->u.c.component->name) == 0)\n+\t{\n+\t  if (!ref->next || ref->next->type != REF_ARRAY)\n+\t    {\n+\t      newref->next = ref->next;\n+\t      ref->next = newref;\n+\t    }\n+\t  else\n+\t    /* Array ref present already.  */\n+\t    gfc_free_ref_list (newref);\n+\t}\n+      else if (ref->type == REF_ARRAY)\n+\t/* Array ref present already.  */\n+\tgfc_free_ref_list (newref);\n+      else\n+\t{\n+\t  newref->next = ref;\n+\t  e->ref = newref;\n+\t}\n+    }\n+\n   if (e->ref && !resolve_ref (e))\n     return false;\n \n@@ -7960,6 +8027,9 @@ gfc_type_is_extensible (gfc_symbol *sym)\n }\n \n \n+static void\n+resolve_types (gfc_namespace *ns);\n+\n /* Resolve an associate-name:  Resolve target and ensure the type-spec is\n    correct as well as possibly the array-spec.  */\n \n@@ -8022,6 +8092,7 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       return;\n     }\n \n+\n   /* We cannot deal with class selectors that need temporaries.  */\n   if (target->ts.type == BT_CLASS\n \t&& gfc_ref_needs_temporary_p (target->ref))\n@@ -8031,22 +8102,81 @@ resolve_assoc_var (gfc_symbol* sym, bool resolve_target)\n       return;\n     }\n \n-  if (target->ts.type != BT_CLASS && target->rank > 0)\n-    sym->attr.dimension = 1;\n-  else if (target->ts.type == BT_CLASS)\n+  if (target->ts.type == BT_CLASS)\n     gfc_fix_class_refs (target);\n \n-  /* The associate-name will have a correct type by now. Make absolutely\n-     sure that it has not picked up a dimension attribute.  */\n-  if (sym->ts.type == BT_CLASS)\n-    sym->attr.dimension = 0;\n-\n-  if (sym->attr.dimension)\n+  if (target->rank != 0)\n     {\n-      sym->as = gfc_get_array_spec ();\n-      sym->as->rank = target->rank;\n-      sym->as->type = AS_DEFERRED;\n-      sym->as->corank = gfc_get_corank (target);\n+      gfc_array_spec *as;\n+      if (sym->ts.type != BT_CLASS && !sym->as)\n+\t{\n+\t  as = gfc_get_array_spec ();\n+\t  as->rank = target->rank;\n+\t  as->type = AS_DEFERRED;\n+\t  as->corank = gfc_get_corank (target);\n+\t  sym->attr.dimension = 1;\n+\t  if (as->corank != 0)\n+\t    sym->attr.codimension = 1;\n+\t  sym->as = as;\n+\t}\n+    }\n+  else\n+    {\n+      /* target's rank is 0, but the type of the sym is still array valued,\n+\t which has to be corrected.  */\n+      if (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->as)\n+\t{\n+\t  gfc_array_spec *as;\n+\t  symbol_attribute attr;\n+\t  /* The associated variable's type is still the array type\n+\t     correct this now.  */\n+\t  gfc_typespec *ts = &target->ts;\n+\t  gfc_ref *ref;\n+\t  gfc_component *c;\n+\t  for (ref = target->ref; ref != NULL; ref = ref->next)\n+\t    {\n+\t      switch (ref->type)\n+\t\t{\n+\t\tcase REF_COMPONENT:\n+\t\t  ts = &ref->u.c.component->ts;\n+\t\t  break;\n+\t\tcase REF_ARRAY:\n+\t\t  if (ts->type == BT_CLASS)\n+\t\t    ts = &ts->u.derived->components->ts;\n+\t\t  break;\n+\t\tdefault:\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t  /* Create a scalar instance of the current class type.  Because the\n+\t     rank of a class array goes into its name, the type has to be\n+\t     rebuild.  The alternative of (re-)setting just the attributes\n+\t     and as in the current type, destroys the type also in other\n+\t     places.  */\n+\t  as = NULL;\n+\t  sym->ts = *ts;\n+\t  sym->ts.type = BT_CLASS;\n+\t  attr = CLASS_DATA (sym)->attr;\n+\t  attr.class_ok = 0;\n+\t  attr.associate_var = 1;\n+\t  attr.dimension = attr.codimension = 0;\n+\t  attr.class_pointer = 1;\n+\t  if (!gfc_build_class_symbol (&sym->ts, &attr, &as))\n+\t    gcc_unreachable ();\n+\t  /* Make sure the _vptr is set.  */\n+\t  c = gfc_find_component (sym->ts.u.derived, \"_vptr\", true, true);\n+\t  if (c->ts.u.derived == NULL)\n+\t    c->ts.u.derived = gfc_find_derived_vtab (sym->ts.u.derived);\n+\t  CLASS_DATA (sym)->attr.pointer = 1;\n+\t  CLASS_DATA (sym)->attr.class_pointer = 1;\n+\t  gfc_set_sym_referenced (sym->ts.u.derived);\n+\t  gfc_commit_symbol (sym->ts.u.derived);\n+\t  /* _vptr now has the _vtab in it, change it to the _vtype.  */\n+\t  if (c->ts.u.derived->attr.vtab)\n+\t    c->ts.u.derived = c->ts.u.derived->ts.u.derived;\n+\t  c->ts.u.derived->ns->types_resolved = 0;\n+\t  resolve_types (c->ts.u.derived->ns);\n+\t}\n     }\n \n   /* Mark this as an associate variable.  */"}, {"sha": "7747a6793c99203cebf643351f1176c7874d5c51", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -2529,7 +2529,8 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t\t   && !sym->attr.result\n \t\t   && (CLASS_DATA (sym)->attr.dimension\n \t\t       || CLASS_DATA (sym)->attr.codimension)\n-\t\t   && !CLASS_DATA (sym)->attr.allocatable\n+\t\t   && (sym->assoc\n+\t\t       || !CLASS_DATA (sym)->attr.allocatable)\n \t\t   && !CLASS_DATA (sym)->attr.class_pointer)\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);"}, {"sha": "9b5d2dc84242f8c656d882ade577488deef88095", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -1,3 +1,8 @@\n+2015-06-23  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/64674\n+\t* gfortran.dg/associate_18.f08: New test.\n+\n 2015-06-23  Uros Bizjak  <ubizjak@gmail.com>\n \n \tPR target/66560"}, {"sha": "16168500191393a6bb174072d560a84cdd62163a", "filename": "gcc/testsuite/gfortran.dg/associate_18.f08", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_18.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_18.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassociate_18.f08?ref=76540ac3e39cd58b0b0084f1f1b4fd0ea3c122b1", "patch": "@@ -0,0 +1,80 @@\n+! { dg-do run }\n+!\n+! Contributed by Antony Lewis  <antony@cosmologist.info>\n+!                Andre Vehreschild  <vehre@gcc.gnu.org>\n+! Check that associating array-sections/scalars is working\n+! with class arrays.\n+!\n+\n+program associate_18\n+  Type T\n+    integer :: map = 1\n+  end Type T\n+\n+  class(T), allocatable :: av(:)\n+  class(T), allocatable :: am(:,:)\n+  class(T), pointer :: pv(:)\n+  class(T), pointer :: pm(:,:)\n+\n+  integer :: iv(5) = 17\n+  integer :: im(4,5) = 23\n+  integer :: expect(20) = 23\n+  integer :: c\n+\n+  allocate(av(2))\n+  associate(i => av(1))\n+    i%map = 2\n+  end associate\n+  if (any (av%map /= [2,1])) call abort()\n+  deallocate(av)\n+\n+  allocate(am(3,4))\n+  associate(pam => am(2:3, 2:3))\n+    pam%map = 7\n+    pam(1,2)%map = 8\n+  end associate\n+  if (any (reshape(am%map, [12]) /= [1,1,1, 1,7,7, 1,8,7, 1,1,1])) call abort()\n+  deallocate(am)\n+\n+  allocate(pv(2))\n+  associate(i => pv(1))\n+    i%map = 2\n+  end associate\n+  if (any (pv%map /= [2,1])) call abort()\n+  deallocate(pv)\n+\n+  allocate(pm(3,4))\n+  associate(ppm => pm(2:3, 2:3))\n+    ppm%map = 7\n+    ppm(1,2)%map = 8\n+  end associate\n+  if (any (reshape(pm%map, [12]) /= [1,1,1, 1,7,7, 1,8,7, 1,1,1])) call abort()\n+  deallocate(pm)\n+\n+  associate(i => iv(1))\n+    i = 7\n+  end associate\n+  if (any (iv /= [7, 17, 17, 17, 17])) call abort()\n+\n+  associate(pam => im(2:3, 2:3))\n+    pam = 9\n+    pam(1,2) = 10\n+    do c = 1, 2\n+        pam(2, c) = 0\n+    end do\n+  end associate\n+  if (any (reshape(im, [20]) /= [23,23,23,23, 23,9,0,23, &\n+        23,10,0,23, 23,23,23,23, 23,23,23,23])) call abort()\n+\n+  expect(2:3) = 9\n+  do c = 1, 5\n+    im = 23\n+    associate(pam => im(:, c))\n+      pam(2:3) = 9\n+    end associate\n+    if (any (reshape(im, [20]) /= expect)) call abort()\n+    ! Shift expect\n+    expect = [expect(17:), expect(:16)]\n+  end do\n+end program\n+"}]}