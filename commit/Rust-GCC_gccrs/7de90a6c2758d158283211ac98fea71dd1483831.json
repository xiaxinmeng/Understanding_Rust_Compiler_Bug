{"sha": "7de90a6c2758d158283211ac98fea71dd1483831", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2RlOTBhNmMyNzU4ZDE1ODI4MzIxMWFjOThmZWE3MWRkMTQ4MzgzMQ==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2014-04-23T19:06:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@gcc.gnu.org", "date": "2014-04-23T19:06:40Z"}, "message": "Change is-a.h to support typedefs of pointers\n\ngcc/\n\t* is-a.h: Update comments to reflect the following changes to the\n\t\"pointerness\" of the API, making the template parameter match the\n\treturn type, allowing use of is-a.h with typedefs of pointers.\n\t(is_a_helper::cast): Return a T rather then a pointer to a T, so\n\tthat the return type matches the parameter to the is_a_helper.\n\t(as_a): Likewise.\n\t(dyn_cast): Likewise.\n\n\t* cgraph.c (cgraph_node_for_asm): Update for removal of implicit\n\tpointer from the is-a.h API.\n\n\t* cgraph.h (is_a_helper <cgraph_node>::test): Convert to...\n\t(is_a_helper <cgraph_node *>::test): ...this, matching change to\n\tis-a.h API.\n\t(is_a_helper <varpool_node>::test): Likewise, convert to...\n\t(is_a_helper <varpool_node *>::test): ...this.\n\n\t(varpool_first_variable): Update for removal of implicit pointer\n\tfrom the is-a.h API.\n\t(varpool_next_variable): Likewise.\n\t(varpool_first_static_initializer): Likewise.\n\t(varpool_next_static_initializer): Likewise.\n\t(varpool_first_defined_variable): Likewise.\n\t(varpool_next_defined_variable): Likewise.\n\t(cgraph_first_defined_function): Likewise.\n\t(cgraph_next_defined_function): Likewise.\n\t(cgraph_first_function): Likewise.\n\t(cgraph_next_function): Likewise.\n\t(cgraph_first_function_with_gimple_body): Likewise.\n\t(cgraph_next_function_with_gimple_body): Likewise.\n\t(cgraph_alias_target): Likewise.\n\t(varpool_alias_target): Likewise.\n\t(cgraph_function_or_thunk_node): Likewise.\n\t(varpool_variable_node): Likewise.\n\t(symtab_real_symbol_p): Likewise.\n\t* cgraphunit.c (referred_to_p): Likewise.\n\t(analyze_functions): Likewise.\n\t(handle_alias_pairs): Likewise.\n\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n\t* gimple-ssa.h (gimple_vuse_op): Likewise.\n\t(gimple_vdef_op): Likewise.\n\t* gimple-streamer-in.c (input_gimple_stmt): Likewise.\n\t* gimple.c (gimple_build_asm_1): Likewise.\n\t(gimple_build_try): Likewise.\n\t(gimple_build_resx): Likewise.\n\t(gimple_build_eh_dispatch): Likewise.\n\t(gimple_build_omp_for): Likewise.\n\t(gimple_omp_for_set_clauses): Likewise.\n\n\t* gimple.h (is_a_helper <gimple_statement_asm>::test): Convert to...\n\t(is_a_helper <gimple_statement_asm *>::test): ...this.\n\t(is_a_helper <gimple_statement_bind>::test): Convert to...\n\t(is_a_helper <gimple_statement_bind *>::test): ...this.\n\t(is_a_helper <gimple_statement_call>::test): Convert to...\n\t(is_a_helper <gimple_statement_call *>::test): ...this.\n\t(is_a_helper <gimple_statement_catch>::test): Convert to...\n\t(is_a_helper <gimple_statement_catch *>::test): ...this.\n\t(is_a_helper <gimple_statement_resx>::test): Convert to...\n\t(is_a_helper <gimple_statement_resx *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_dispatch>::test): Convert to...\n\t(is_a_helper <gimple_statement_eh_dispatch *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_else>::test): Convert to...\n\t(is_a_helper <gimple_statement_eh_else *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_filter>::test): Convert to...\n\t(is_a_helper <gimple_statement_eh_filter *>::test): ...this.\n\t(is_a_helper <gimple_statement_eh_mnt>::test): Convert to...\n\t(is_a_helper <gimple_statement_eh_mnt *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_atomic_load>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_atomic_load *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_atomic_store>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_atomic_store *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_return>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_return *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_continue>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_continue *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_critical>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_critical *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_for>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_for *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_taskreg>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_taskreg *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_parallel>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_parallel *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_target>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_target *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_sections>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_sections *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_single>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_single *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_teams>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_teams *>::test): ...this.\n\t(is_a_helper <gimple_statement_omp_task>::test): Convert to...\n\t(is_a_helper <gimple_statement_omp_task *>::test): ...this.\n\t(is_a_helper <gimple_statement_phi>::test): Convert to...\n\t(is_a_helper <gimple_statement_phi *>::test): ...this.\n\t(is_a_helper <gimple_statement_transaction>::test): Convert to...\n\t(is_a_helper <gimple_statement_transaction *>::test): ...this.\n\t(is_a_helper <gimple_statement_try>::test): Convert to...\n\t(is_a_helper <gimple_statement_try *>::test): ...this.\n\t(is_a_helper <gimple_statement_wce>::test): Convert to...\n\t(is_a_helper <gimple_statement_wce *>::test): ...this.\n\t(is_a_helper <const gimple_statement_asm>::test): Convert to...\n\t(is_a_helper <const gimple_statement_asm *>::test): ...this.\n\t(is_a_helper <const gimple_statement_bind>::test): Convert to...\n\t(is_a_helper <const gimple_statement_bind *>::test): ...this.\n\t(is_a_helper <const gimple_statement_call>::test): Convert to...\n\t(is_a_helper <const gimple_statement_call *>::test): ...this.\n\t(is_a_helper <const gimple_statement_catch>::test): Convert to...\n\t(is_a_helper <const gimple_statement_catch *>::test): ...this.\n\t(is_a_helper <const gimple_statement_resx>::test): Convert to...\n\t(is_a_helper <const gimple_statement_resx *>::test): ...this.\n\t(is_a_helper <const gimple_statement_eh_dispatch>::test):\n\tConvert to...\n\t(is_a_helper <const gimple_statement_eh_dispatch *>::test):\n\t...this.\n\t(is_a_helper <const gimple_statement_eh_filter>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_eh_filter *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_atomic_load>::test):\n\tConvert to...\n\t(is_a_helper <const gimple_statement_omp_atomic_load *>::test):\n\t...this.\n\t(is_a_helper <const gimple_statement_omp_atomic_store>::test):\n\tConvert to...\n\t(is_a_helper <const gimple_statement_omp_atomic_store *>::test):\n\t...this.\n\t(is_a_helper <const gimple_statement_omp_return>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_return *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_continue>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_continue *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_critical>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_critical *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_for>::test): Convert to...\n\t(is_a_helper <const gimple_statement_omp_for *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_taskreg>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_taskreg *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_parallel>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_parallel *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_target>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_target *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_sections>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_sections *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_single>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_single *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_teams>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_teams *>::test): ...this.\n\t(is_a_helper <const gimple_statement_omp_task>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_omp_task *>::test): ...this.\n\t(is_a_helper <const gimple_statement_phi>::test): Convert to...\n\t(is_a_helper <const gimple_statement_phi *>::test): ...this.\n\t(is_a_helper <const gimple_statement_transaction>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_transaction *>::test): ...this.\n\t(is_a_helper <const gimple_statement_with_ops>::test): Convert\n\tto...\n\t(is_a_helper <const gimple_statement_with_ops *>::test): ...this.\n\t(is_a_helper <gimple_statement_with_ops>::test): Convert to...\n\t(is_a_helper <gimple_statement_with_ops *>::test): ...this.\n\t(is_a_helper <const gimple_statement_with_memory_ops>::test):\n\tConvert to...\n\t(is_a_helper <const gimple_statement_with_memory_ops *>::test):\n\t...this.\n\t(is_a_helper <gimple_statement_with_memory_ops>::test): Convert\n\tto...\n\t(is_a_helper <gimple_statement_with_memory_ops *>::test): ...this.\n\n\t(gimple_use_ops): Update for removal of implicit pointer from the\n\tis-a.h API.\n\t(gimple_set_use_ops): Likewise.\n\t(gimple_vuse): Likewise.\n\t(gimple_vdef): Likewise.\n\t(gimple_vuse_ptr): Likewise.\n\t(gimple_vdef_ptr): Likewise.\n\t(gimple_set_vuse): Likewise.\n\t(gimple_set_vdef): Likewise.\n\t(gimple_omp_return_set_lhs): Likewise.\n\t(gimple_omp_return_lhs): Likewise.\n\t(gimple_omp_return_lhs_ptr): Likewise.\n\t(gimple_call_fntype): Likewise.\n\t(gimple_call_set_fntype): Likewise.\n\t(gimple_call_set_internal_fn): Likewise.\n\t(gimple_call_use_set): Likewise.\n\t(gimple_call_clobber_set): Likewise.\n\t(gimple_bind_vars): Likewise.\n\t(gimple_bind_set_vars): Likewise.\n\t(gimple_bind_body_ptr): Likewise.\n\t(gimple_bind_set_body): Likewise.\n\t(gimple_bind_add_stmt): Likewise.\n\t(gimple_bind_block): Likewise.\n\t(gimple_bind_set_block): Likewise.\n\t(gimple_asm_ninputs): Likewise.\n\t(gimple_asm_noutputs): Likewise.\n\t(gimple_asm_nclobbers): Likewise.\n\t(gimple_asm_nlabels): Likewise.\n\t(gimple_asm_input_op): Likewise.\n\t(gimple_asm_input_op_ptr): Likewise.\n\t(gimple_asm_output_op): Likewise.\n\t(gimple_asm_output_op_ptr): Likewise.\n\t(gimple_asm_set_output_op): Likewise.\n\t(gimple_asm_clobber_op): Likewise.\n\t(gimple_asm_set_clobber_op): Likewise.\n\t(gimple_asm_label_op): Likewise.\n\t(gimple_asm_set_label_op): Likewise.\n\t(gimple_asm_string): Likewise.\n\t(gimple_catch_types): Likewise.\n\t(gimple_catch_types_ptr): Likewise.\n\t(gimple_catch_handler_ptr): Likewise.\n\t(gimple_catch_set_types): Likewise.\n\t(gimple_catch_set_handler): Likewise.\n\t(gimple_eh_filter_types): Likewise.\n\t(gimple_eh_filter_types_ptr): Likewise.\n\t(gimple_eh_filter_failure_ptr): Likewise.\n\t(gimple_eh_filter_set_types): Likewise.\n\t(gimple_eh_filter_set_failure): Likewise.\n\t(gimple_eh_must_not_throw_fndecl): Likewise.\n\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n\t(gimple_eh_else_n_body_ptr): Likewise.\n\t(gimple_eh_else_e_body_ptr): Likewise.\n\t(gimple_eh_else_set_n_body): Likewise.\n\t(gimple_eh_else_set_e_body): Likewise.\n\t(gimple_try_eval_ptr): Likewise.\n\t(gimple_try_cleanup_ptr): Likewise.\n\t(gimple_try_set_eval): Likewise.\n\t(gimple_try_set_cleanup): Likewise.\n\t(gimple_wce_cleanup_ptr): Likewise.\n\t(gimple_wce_set_cleanup): Likewise.\n\t(gimple_phi_capacity): Likewise.\n\t(gimple_phi_num_args): Likewise.\n\t(gimple_phi_result): Likewise.\n\t(gimple_phi_result_ptr): Likewise.\n\t(gimple_phi_set_result): Likewise.\n\t(gimple_phi_arg): Likewise.\n\t(gimple_phi_set_arg): Likewise.\n\t(gimple_resx_region): Likewise.\n\t(gimple_resx_set_region): Likewise.\n\t(gimple_eh_dispatch_region): Likewise.\n\t(gimple_eh_dispatch_set_region): Likewise.\n\t(gimple_omp_critical_name): Likewise.\n\t(gimple_omp_critical_name_ptr): Likewise.\n\t(gimple_omp_critical_set_name): Likewise.\n\t(gimple_omp_for_clauses): Likewise.\n\t(gimple_omp_for_clauses_ptr): Likewise.\n\t(gimple_omp_for_set_clauses): Likewise.\n\t(gimple_omp_for_collapse): Likewise.\n\t(gimple_omp_for_index): Likewise.\n\t(gimple_omp_for_index_ptr): Likewise.\n\t(gimple_omp_for_set_index): Likewise.\n\t(gimple_omp_for_initial): Likewise.\n\t(gimple_omp_for_initial_ptr): Likewise.\n\t(gimple_omp_for_set_initial): Likewise.\n\t(gimple_omp_for_final): Likewise.\n\t(gimple_omp_for_final_ptr): Likewise.\n\t(gimple_omp_for_set_final): Likewise.\n\t(gimple_omp_for_incr): Likewise.\n\t(gimple_omp_for_incr_ptr): Likewise.\n\t(gimple_omp_for_set_incr): Likewise.\n\t(gimple_omp_for_pre_body_ptr): Likewise.\n\t(gimple_omp_for_set_pre_body): Likewise.\n\t(gimple_omp_parallel_clauses): Likewise.\n\t(gimple_omp_parallel_clauses_ptr): Likewise.\n\t(gimple_omp_parallel_set_clauses): Likewise.\n\t(gimple_omp_parallel_child_fn): Likewise.\n\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n\t(gimple_omp_parallel_set_child_fn): Likewise.\n\t(gimple_omp_parallel_data_arg): Likewise.\n\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n\t(gimple_omp_parallel_set_data_arg): Likewise.\n\t(gimple_omp_task_clauses): Likewise.\n\t(gimple_omp_task_clauses_ptr): Likewise.\n\t(gimple_omp_task_set_clauses): Likewise.\n\t(gimple_omp_task_child_fn): Likewise.\n\t(gimple_omp_task_child_fn_ptr): Likewise.\n\t(gimple_omp_task_set_child_fn): Likewise.\n\t(gimple_omp_task_data_arg): Likewise.\n\t(gimple_omp_task_data_arg_ptr): Likewise.\n\t(gimple_omp_task_set_data_arg): Likewise.\n\t(gimple_omp_taskreg_clauses): Likewise.\n\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n\t(gimple_omp_taskreg_set_clauses): Likewise.\n\t(gimple_omp_taskreg_child_fn): Likewise.\n\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n\t(gimple_omp_taskreg_set_child_fn): Likewise.\n\t(gimple_omp_taskreg_data_arg): Likewise.\n\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n\t(gimple_omp_taskreg_set_data_arg): Likewise.\n\t(gimple_omp_task_copy_fn): Likewise.\n\t(gimple_omp_task_copy_fn_ptr): Likewise.\n\t(gimple_omp_task_set_copy_fn): Likewise.\n\t(gimple_omp_task_arg_size): Likewise.\n\t(gimple_omp_task_arg_size_ptr): Likewise.\n\t(gimple_omp_task_set_arg_size): Likewise.\n\t(gimple_omp_task_arg_align): Likewise.\n\t(gimple_omp_task_arg_align_ptr): Likewise.\n\t(gimple_omp_task_set_arg_align): Likewise.\n\t(gimple_omp_single_clauses): Likewise.\n\t(gimple_omp_single_clauses_ptr): Likewise.\n\t(gimple_omp_single_set_clauses): Likewise.\n\t(gimple_omp_target_clauses): Likewise.\n\t(gimple_omp_target_clauses_ptr): Likewise.\n\t(gimple_omp_target_set_clauses): Likewise.\n\t(gimple_omp_target_child_fn): Likewise.\n\t(gimple_omp_target_child_fn_ptr): Likewise.\n\t(gimple_omp_target_set_child_fn): Likewise.\n\t(gimple_omp_target_data_arg): Likewise.\n\t(gimple_omp_target_data_arg_ptr): Likewise.\n\t(gimple_omp_target_set_data_arg): Likewise.\n\t(gimple_omp_teams_clauses): Likewise.\n\t(gimple_omp_teams_clauses_ptr): Likewise.\n\t(gimple_omp_teams_set_clauses): Likewise.\n\t(gimple_omp_sections_clauses): Likewise.\n\t(gimple_omp_sections_clauses_ptr): Likewise.\n\t(gimple_omp_sections_set_clauses): Likewise.\n\t(gimple_omp_sections_control): Likewise.\n\t(gimple_omp_sections_control_ptr): Likewise.\n\t(gimple_omp_sections_set_control): Likewise.\n\t(gimple_omp_for_set_cond): Likewise.\n\t(gimple_omp_for_cond): Likewise.\n\t(gimple_omp_atomic_store_set_val): Likewise.\n\t(gimple_omp_atomic_store_val): Likewise.\n\t(gimple_omp_atomic_store_val_ptr): Likewise.\n\t(gimple_omp_atomic_load_set_lhs): Likewise.\n\t(gimple_omp_atomic_load_lhs): Likewise.\n\t(gimple_omp_atomic_load_lhs_ptr): Likewise.\n\t(gimple_omp_atomic_load_set_rhs): Likewise.\n\t(gimple_omp_atomic_load_rhs): Likewise.\n\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n\t(gimple_omp_continue_control_def): Likewise.\n\t(gimple_omp_continue_control_def_ptr): Likewise.\n\t(gimple_omp_continue_set_control_def): Likewise.\n\t(gimple_omp_continue_control_use): Likewise.\n\t(gimple_omp_continue_control_use_ptr): Likewise.\n\t(gimple_omp_continue_set_control_use): Likewise.\n\t(gimple_transaction_body_ptr): Likewise.\n\t(gimple_transaction_label): Likewise.\n\t(gimple_transaction_label_ptr): Likewise.\n\t(gimple_transaction_set_body): Likewise.\n\t(gimple_transaction_set_label): Likewise.\n\n\t* ipa-devirt.c (build_type_inheritance_graph): Likewise.\n\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n\t* ipa-ref.c (ipa_record_reference): Likewise.\n\t* ipa-reference.c (analyze_function): Likewise.\n\t(ipa_reference_write_optimization_summary): Likewise.\n\t* ipa.c (symtab_remove_unreachable_nodes): Likewise.\n\t(address_taken_from_non_vtable_p): Likewise.\n\t(comdat_can_be_unshared_p_1): Likewise.\n\t* lto-cgraph.c (lto_output_ref): Likewise.\n\t(add_references): Likewise.\n\t(compute_ltrans_boundary): Likewise.\n\t(output_symtab): Likewise.\n\t(input_ref): Likewise.\n\t(input_cgraph_1): Likewise.\n\t(output_cgraph_opt_summary): Likewise.\n\t* lto-streamer-out.c (lto_output): Likewise.\n\t(output_symbol_p): Likewise.\n\t* lto-streamer.h (lsei_next_function_in_partition): Likewise.\n\t(lsei_start_function_in_partition): Likewise.\n\t(lsei_next_variable_in_partition): Likewise.\n\t(lsei_start_variable_in_partition): Likewise.\n\t* symtab.c (insert_to_assembler_name_hash): Likewise.\n\t(unlink_from_assembler_name_hash): Likewise.\n\t(symtab_unregister_node): Likewise.\n\t(symtab_remove_node): Likewise.\n\t(dump_symtab_node): Likewise.\n\t(verify_symtab_base): Likewise.\n\t(verify_symtab_node): Likewise.\n\t(symtab_make_decl_local): Likewise.\n\t(symtab_alias_ultimate_target): Likewise.\n\t(symtab_resolve_alias): Likewise.\n\t(symtab_get_symbol_partitioning_class): Likewise.\n\t* tree-phinodes.c (allocate_phi_node): Likewise.\n\t(reserve_phi_args_for_new_edge): Likewise.\n\t(remove_phi_args): Likewise.\n\t* varpool.c (varpool_node_for_asm): Likewise.\n\t(varpool_remove_unreferenced_decls): Likewise.\n\ngcc/lto/\n\t* lto-partition.c (add_references_to_partition): Update for\n\tremoval of implicit pointer from the is-a.h API.\n\t(add_symbol_to_partition_1): Likewise.\n\t(contained_in_symbol): Likewise.\n\t(undo_partition): Likewise.\n\t(lto_balanced_map): Likewise.\n\t(promote_symbol): Likewise.\n\t* lto-symtab.c (lto_symtab_merge_symbols_1): Likewise.\n\t(lto_symtab_merge_symbols): Likewise.\n\t* lto.c (lto_wpa_write_files): Likewise.\n\nFrom-SVN: r209719", "tree": {"sha": "9265b153ec1a54d0f2ff0466c5e57a8ac51b577d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9265b153ec1a54d0f2ff0466c5e57a8ac51b577d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7de90a6c2758d158283211ac98fea71dd1483831", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de90a6c2758d158283211ac98fea71dd1483831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7de90a6c2758d158283211ac98fea71dd1483831", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7de90a6c2758d158283211ac98fea71dd1483831/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9219922e543dec72f15bc095f8a99d25d2a60d24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9219922e543dec72f15bc095f8a99d25d2a60d24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9219922e543dec72f15bc095f8a99d25d2a60d24"}], "stats": {"total": 1111, "additions": 756, "deletions": 355}, "files": [{"sha": "117cdd0f08eb81de478cd620e7d10093bc2a6118", "filename": "gcc/ChangeLog", "status": "modified", "additions": 388, "deletions": 0, "changes": 388, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -1,3 +1,391 @@\n+2014-04-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* is-a.h: Update comments to reflect the following changes to the\n+\t\"pointerness\" of the API, making the template parameter match the\n+\treturn type, allowing use of is-a.h with typedefs of pointers.\n+\t(is_a_helper::cast): Return a T rather then a pointer to a T, so\n+\tthat the return type matches the parameter to the is_a_helper.\n+\t(as_a): Likewise.\n+\t(dyn_cast): Likewise.\n+\n+\t* cgraph.c (cgraph_node_for_asm): Update for removal of implicit\n+\tpointer from the is-a.h API.\n+\n+\t* cgraph.h (is_a_helper <cgraph_node>::test): Convert to...\n+\t(is_a_helper <cgraph_node *>::test): ...this, matching change to\n+\tis-a.h API.\n+\t(is_a_helper <varpool_node>::test): Likewise, convert to...\n+\t(is_a_helper <varpool_node *>::test): ...this.\n+\n+\t(varpool_first_variable): Update for removal of implicit pointer\n+\tfrom the is-a.h API.\n+\t(varpool_next_variable): Likewise.\n+\t(varpool_first_static_initializer): Likewise.\n+\t(varpool_next_static_initializer): Likewise.\n+\t(varpool_first_defined_variable): Likewise.\n+\t(varpool_next_defined_variable): Likewise.\n+\t(cgraph_first_defined_function): Likewise.\n+\t(cgraph_next_defined_function): Likewise.\n+\t(cgraph_first_function): Likewise.\n+\t(cgraph_next_function): Likewise.\n+\t(cgraph_first_function_with_gimple_body): Likewise.\n+\t(cgraph_next_function_with_gimple_body): Likewise.\n+\t(cgraph_alias_target): Likewise.\n+\t(varpool_alias_target): Likewise.\n+\t(cgraph_function_or_thunk_node): Likewise.\n+\t(varpool_variable_node): Likewise.\n+\t(symtab_real_symbol_p): Likewise.\n+\t* cgraphunit.c (referred_to_p): Likewise.\n+\t(analyze_functions): Likewise.\n+\t(handle_alias_pairs): Likewise.\n+\t* gimple-fold.c (can_refer_decl_in_current_unit_p): Likewise.\n+\t* gimple-ssa.h (gimple_vuse_op): Likewise.\n+\t(gimple_vdef_op): Likewise.\n+\t* gimple-streamer-in.c (input_gimple_stmt): Likewise.\n+\t* gimple.c (gimple_build_asm_1): Likewise.\n+\t(gimple_build_try): Likewise.\n+\t(gimple_build_resx): Likewise.\n+\t(gimple_build_eh_dispatch): Likewise.\n+\t(gimple_build_omp_for): Likewise.\n+\t(gimple_omp_for_set_clauses): Likewise.\n+\n+\t* gimple.h (is_a_helper <gimple_statement_asm>::test): Convert to...\n+\t(is_a_helper <gimple_statement_asm *>::test): ...this.\n+\t(is_a_helper <gimple_statement_bind>::test): Convert to...\n+\t(is_a_helper <gimple_statement_bind *>::test): ...this.\n+\t(is_a_helper <gimple_statement_call>::test): Convert to...\n+\t(is_a_helper <gimple_statement_call *>::test): ...this.\n+\t(is_a_helper <gimple_statement_catch>::test): Convert to...\n+\t(is_a_helper <gimple_statement_catch *>::test): ...this.\n+\t(is_a_helper <gimple_statement_resx>::test): Convert to...\n+\t(is_a_helper <gimple_statement_resx *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_dispatch>::test): Convert to...\n+\t(is_a_helper <gimple_statement_eh_dispatch *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_else>::test): Convert to...\n+\t(is_a_helper <gimple_statement_eh_else *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_filter>::test): Convert to...\n+\t(is_a_helper <gimple_statement_eh_filter *>::test): ...this.\n+\t(is_a_helper <gimple_statement_eh_mnt>::test): Convert to...\n+\t(is_a_helper <gimple_statement_eh_mnt *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_atomic_load>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_atomic_load *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_atomic_store>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_atomic_store *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_return>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_return *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_continue>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_continue *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_critical>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_critical *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_for>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_for *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_taskreg>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_taskreg *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_parallel>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_parallel *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_target>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_target *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_sections>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_sections *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_single>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_single *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_teams>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_teams *>::test): ...this.\n+\t(is_a_helper <gimple_statement_omp_task>::test): Convert to...\n+\t(is_a_helper <gimple_statement_omp_task *>::test): ...this.\n+\t(is_a_helper <gimple_statement_phi>::test): Convert to...\n+\t(is_a_helper <gimple_statement_phi *>::test): ...this.\n+\t(is_a_helper <gimple_statement_transaction>::test): Convert to...\n+\t(is_a_helper <gimple_statement_transaction *>::test): ...this.\n+\t(is_a_helper <gimple_statement_try>::test): Convert to...\n+\t(is_a_helper <gimple_statement_try *>::test): ...this.\n+\t(is_a_helper <gimple_statement_wce>::test): Convert to...\n+\t(is_a_helper <gimple_statement_wce *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_asm>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_asm *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_bind>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_bind *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_call>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_call *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_catch>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_catch *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_resx>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_resx *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_eh_dispatch>::test):\n+\tConvert to...\n+\t(is_a_helper <const gimple_statement_eh_dispatch *>::test):\n+\t...this.\n+\t(is_a_helper <const gimple_statement_eh_filter>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_eh_filter *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_atomic_load>::test):\n+\tConvert to...\n+\t(is_a_helper <const gimple_statement_omp_atomic_load *>::test):\n+\t...this.\n+\t(is_a_helper <const gimple_statement_omp_atomic_store>::test):\n+\tConvert to...\n+\t(is_a_helper <const gimple_statement_omp_atomic_store *>::test):\n+\t...this.\n+\t(is_a_helper <const gimple_statement_omp_return>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_return *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_continue>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_continue *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_critical>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_critical *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_for>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_omp_for *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_taskreg>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_taskreg *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_parallel>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_parallel *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_target>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_target *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_sections>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_sections *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_single>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_single *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_teams>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_teams *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_omp_task>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_omp_task *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_phi>::test): Convert to...\n+\t(is_a_helper <const gimple_statement_phi *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_transaction>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_transaction *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_with_ops>::test): Convert\n+\tto...\n+\t(is_a_helper <const gimple_statement_with_ops *>::test): ...this.\n+\t(is_a_helper <gimple_statement_with_ops>::test): Convert to...\n+\t(is_a_helper <gimple_statement_with_ops *>::test): ...this.\n+\t(is_a_helper <const gimple_statement_with_memory_ops>::test):\n+\tConvert to...\n+\t(is_a_helper <const gimple_statement_with_memory_ops *>::test):\n+\t...this.\n+\t(is_a_helper <gimple_statement_with_memory_ops>::test): Convert\n+\tto...\n+\t(is_a_helper <gimple_statement_with_memory_ops *>::test): ...this.\n+\n+\t(gimple_use_ops): Update for removal of implicit pointer from the\n+\tis-a.h API.\n+\t(gimple_set_use_ops): Likewise.\n+\t(gimple_vuse): Likewise.\n+\t(gimple_vdef): Likewise.\n+\t(gimple_vuse_ptr): Likewise.\n+\t(gimple_vdef_ptr): Likewise.\n+\t(gimple_set_vuse): Likewise.\n+\t(gimple_set_vdef): Likewise.\n+\t(gimple_omp_return_set_lhs): Likewise.\n+\t(gimple_omp_return_lhs): Likewise.\n+\t(gimple_omp_return_lhs_ptr): Likewise.\n+\t(gimple_call_fntype): Likewise.\n+\t(gimple_call_set_fntype): Likewise.\n+\t(gimple_call_set_internal_fn): Likewise.\n+\t(gimple_call_use_set): Likewise.\n+\t(gimple_call_clobber_set): Likewise.\n+\t(gimple_bind_vars): Likewise.\n+\t(gimple_bind_set_vars): Likewise.\n+\t(gimple_bind_body_ptr): Likewise.\n+\t(gimple_bind_set_body): Likewise.\n+\t(gimple_bind_add_stmt): Likewise.\n+\t(gimple_bind_block): Likewise.\n+\t(gimple_bind_set_block): Likewise.\n+\t(gimple_asm_ninputs): Likewise.\n+\t(gimple_asm_noutputs): Likewise.\n+\t(gimple_asm_nclobbers): Likewise.\n+\t(gimple_asm_nlabels): Likewise.\n+\t(gimple_asm_input_op): Likewise.\n+\t(gimple_asm_input_op_ptr): Likewise.\n+\t(gimple_asm_output_op): Likewise.\n+\t(gimple_asm_output_op_ptr): Likewise.\n+\t(gimple_asm_set_output_op): Likewise.\n+\t(gimple_asm_clobber_op): Likewise.\n+\t(gimple_asm_set_clobber_op): Likewise.\n+\t(gimple_asm_label_op): Likewise.\n+\t(gimple_asm_set_label_op): Likewise.\n+\t(gimple_asm_string): Likewise.\n+\t(gimple_catch_types): Likewise.\n+\t(gimple_catch_types_ptr): Likewise.\n+\t(gimple_catch_handler_ptr): Likewise.\n+\t(gimple_catch_set_types): Likewise.\n+\t(gimple_catch_set_handler): Likewise.\n+\t(gimple_eh_filter_types): Likewise.\n+\t(gimple_eh_filter_types_ptr): Likewise.\n+\t(gimple_eh_filter_failure_ptr): Likewise.\n+\t(gimple_eh_filter_set_types): Likewise.\n+\t(gimple_eh_filter_set_failure): Likewise.\n+\t(gimple_eh_must_not_throw_fndecl): Likewise.\n+\t(gimple_eh_must_not_throw_set_fndecl): Likewise.\n+\t(gimple_eh_else_n_body_ptr): Likewise.\n+\t(gimple_eh_else_e_body_ptr): Likewise.\n+\t(gimple_eh_else_set_n_body): Likewise.\n+\t(gimple_eh_else_set_e_body): Likewise.\n+\t(gimple_try_eval_ptr): Likewise.\n+\t(gimple_try_cleanup_ptr): Likewise.\n+\t(gimple_try_set_eval): Likewise.\n+\t(gimple_try_set_cleanup): Likewise.\n+\t(gimple_wce_cleanup_ptr): Likewise.\n+\t(gimple_wce_set_cleanup): Likewise.\n+\t(gimple_phi_capacity): Likewise.\n+\t(gimple_phi_num_args): Likewise.\n+\t(gimple_phi_result): Likewise.\n+\t(gimple_phi_result_ptr): Likewise.\n+\t(gimple_phi_set_result): Likewise.\n+\t(gimple_phi_arg): Likewise.\n+\t(gimple_phi_set_arg): Likewise.\n+\t(gimple_resx_region): Likewise.\n+\t(gimple_resx_set_region): Likewise.\n+\t(gimple_eh_dispatch_region): Likewise.\n+\t(gimple_eh_dispatch_set_region): Likewise.\n+\t(gimple_omp_critical_name): Likewise.\n+\t(gimple_omp_critical_name_ptr): Likewise.\n+\t(gimple_omp_critical_set_name): Likewise.\n+\t(gimple_omp_for_clauses): Likewise.\n+\t(gimple_omp_for_clauses_ptr): Likewise.\n+\t(gimple_omp_for_set_clauses): Likewise.\n+\t(gimple_omp_for_collapse): Likewise.\n+\t(gimple_omp_for_index): Likewise.\n+\t(gimple_omp_for_index_ptr): Likewise.\n+\t(gimple_omp_for_set_index): Likewise.\n+\t(gimple_omp_for_initial): Likewise.\n+\t(gimple_omp_for_initial_ptr): Likewise.\n+\t(gimple_omp_for_set_initial): Likewise.\n+\t(gimple_omp_for_final): Likewise.\n+\t(gimple_omp_for_final_ptr): Likewise.\n+\t(gimple_omp_for_set_final): Likewise.\n+\t(gimple_omp_for_incr): Likewise.\n+\t(gimple_omp_for_incr_ptr): Likewise.\n+\t(gimple_omp_for_set_incr): Likewise.\n+\t(gimple_omp_for_pre_body_ptr): Likewise.\n+\t(gimple_omp_for_set_pre_body): Likewise.\n+\t(gimple_omp_parallel_clauses): Likewise.\n+\t(gimple_omp_parallel_clauses_ptr): Likewise.\n+\t(gimple_omp_parallel_set_clauses): Likewise.\n+\t(gimple_omp_parallel_child_fn): Likewise.\n+\t(gimple_omp_parallel_child_fn_ptr): Likewise.\n+\t(gimple_omp_parallel_set_child_fn): Likewise.\n+\t(gimple_omp_parallel_data_arg): Likewise.\n+\t(gimple_omp_parallel_data_arg_ptr): Likewise.\n+\t(gimple_omp_parallel_set_data_arg): Likewise.\n+\t(gimple_omp_task_clauses): Likewise.\n+\t(gimple_omp_task_clauses_ptr): Likewise.\n+\t(gimple_omp_task_set_clauses): Likewise.\n+\t(gimple_omp_task_child_fn): Likewise.\n+\t(gimple_omp_task_child_fn_ptr): Likewise.\n+\t(gimple_omp_task_set_child_fn): Likewise.\n+\t(gimple_omp_task_data_arg): Likewise.\n+\t(gimple_omp_task_data_arg_ptr): Likewise.\n+\t(gimple_omp_task_set_data_arg): Likewise.\n+\t(gimple_omp_taskreg_clauses): Likewise.\n+\t(gimple_omp_taskreg_clauses_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_clauses): Likewise.\n+\t(gimple_omp_taskreg_child_fn): Likewise.\n+\t(gimple_omp_taskreg_child_fn_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_child_fn): Likewise.\n+\t(gimple_omp_taskreg_data_arg): Likewise.\n+\t(gimple_omp_taskreg_data_arg_ptr): Likewise.\n+\t(gimple_omp_taskreg_set_data_arg): Likewise.\n+\t(gimple_omp_task_copy_fn): Likewise.\n+\t(gimple_omp_task_copy_fn_ptr): Likewise.\n+\t(gimple_omp_task_set_copy_fn): Likewise.\n+\t(gimple_omp_task_arg_size): Likewise.\n+\t(gimple_omp_task_arg_size_ptr): Likewise.\n+\t(gimple_omp_task_set_arg_size): Likewise.\n+\t(gimple_omp_task_arg_align): Likewise.\n+\t(gimple_omp_task_arg_align_ptr): Likewise.\n+\t(gimple_omp_task_set_arg_align): Likewise.\n+\t(gimple_omp_single_clauses): Likewise.\n+\t(gimple_omp_single_clauses_ptr): Likewise.\n+\t(gimple_omp_single_set_clauses): Likewise.\n+\t(gimple_omp_target_clauses): Likewise.\n+\t(gimple_omp_target_clauses_ptr): Likewise.\n+\t(gimple_omp_target_set_clauses): Likewise.\n+\t(gimple_omp_target_child_fn): Likewise.\n+\t(gimple_omp_target_child_fn_ptr): Likewise.\n+\t(gimple_omp_target_set_child_fn): Likewise.\n+\t(gimple_omp_target_data_arg): Likewise.\n+\t(gimple_omp_target_data_arg_ptr): Likewise.\n+\t(gimple_omp_target_set_data_arg): Likewise.\n+\t(gimple_omp_teams_clauses): Likewise.\n+\t(gimple_omp_teams_clauses_ptr): Likewise.\n+\t(gimple_omp_teams_set_clauses): Likewise.\n+\t(gimple_omp_sections_clauses): Likewise.\n+\t(gimple_omp_sections_clauses_ptr): Likewise.\n+\t(gimple_omp_sections_set_clauses): Likewise.\n+\t(gimple_omp_sections_control): Likewise.\n+\t(gimple_omp_sections_control_ptr): Likewise.\n+\t(gimple_omp_sections_set_control): Likewise.\n+\t(gimple_omp_for_set_cond): Likewise.\n+\t(gimple_omp_for_cond): Likewise.\n+\t(gimple_omp_atomic_store_set_val): Likewise.\n+\t(gimple_omp_atomic_store_val): Likewise.\n+\t(gimple_omp_atomic_store_val_ptr): Likewise.\n+\t(gimple_omp_atomic_load_set_lhs): Likewise.\n+\t(gimple_omp_atomic_load_lhs): Likewise.\n+\t(gimple_omp_atomic_load_lhs_ptr): Likewise.\n+\t(gimple_omp_atomic_load_set_rhs): Likewise.\n+\t(gimple_omp_atomic_load_rhs): Likewise.\n+\t(gimple_omp_atomic_load_rhs_ptr): Likewise.\n+\t(gimple_omp_continue_control_def): Likewise.\n+\t(gimple_omp_continue_control_def_ptr): Likewise.\n+\t(gimple_omp_continue_set_control_def): Likewise.\n+\t(gimple_omp_continue_control_use): Likewise.\n+\t(gimple_omp_continue_control_use_ptr): Likewise.\n+\t(gimple_omp_continue_set_control_use): Likewise.\n+\t(gimple_transaction_body_ptr): Likewise.\n+\t(gimple_transaction_label): Likewise.\n+\t(gimple_transaction_label_ptr): Likewise.\n+\t(gimple_transaction_set_body): Likewise.\n+\t(gimple_transaction_set_label): Likewise.\n+\n+\t* ipa-devirt.c (build_type_inheritance_graph): Likewise.\n+\t* ipa-inline-analysis.c (inline_write_summary): Likewise.\n+\t* ipa-ref.c (ipa_record_reference): Likewise.\n+\t* ipa-reference.c (analyze_function): Likewise.\n+\t(ipa_reference_write_optimization_summary): Likewise.\n+\t* ipa.c (symtab_remove_unreachable_nodes): Likewise.\n+\t(address_taken_from_non_vtable_p): Likewise.\n+\t(comdat_can_be_unshared_p_1): Likewise.\n+\t* lto-cgraph.c (lto_output_ref): Likewise.\n+\t(add_references): Likewise.\n+\t(compute_ltrans_boundary): Likewise.\n+\t(output_symtab): Likewise.\n+\t(input_ref): Likewise.\n+\t(input_cgraph_1): Likewise.\n+\t(output_cgraph_opt_summary): Likewise.\n+\t* lto-streamer-out.c (lto_output): Likewise.\n+\t(output_symbol_p): Likewise.\n+\t* lto-streamer.h (lsei_next_function_in_partition): Likewise.\n+\t(lsei_start_function_in_partition): Likewise.\n+\t(lsei_next_variable_in_partition): Likewise.\n+\t(lsei_start_variable_in_partition): Likewise.\n+\t* symtab.c (insert_to_assembler_name_hash): Likewise.\n+\t(unlink_from_assembler_name_hash): Likewise.\n+\t(symtab_unregister_node): Likewise.\n+\t(symtab_remove_node): Likewise.\n+\t(dump_symtab_node): Likewise.\n+\t(verify_symtab_base): Likewise.\n+\t(verify_symtab_node): Likewise.\n+\t(symtab_make_decl_local): Likewise.\n+\t(symtab_alias_ultimate_target): Likewise.\n+\t(symtab_resolve_alias): Likewise.\n+\t(symtab_get_symbol_partitioning_class): Likewise.\n+\t* tree-phinodes.c (allocate_phi_node): Likewise.\n+\t(reserve_phi_args_for_new_edge): Likewise.\n+\t(remove_phi_args): Likewise.\n+\t* varpool.c (varpool_node_for_asm): Likewise.\n+\t(varpool_remove_unreferenced_decls): Likewise.\n+\n 2014-04-23  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/60902"}, {"sha": "ee192ed754ffe76517071c4dc1d30b74aea4ebc3", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -674,7 +674,7 @@ cgraph_node_for_asm (tree asmname)\n        node;\n        node = node->next_sharing_asm_name)\n     {\n-      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n       if (cn && !cn->global.inlined_to)\n \treturn cn;\n     }"}, {"sha": "84fc1d90536dc82d57a2a9f45f3dced07203b4bd", "filename": "gcc/cgraph.h", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -661,7 +661,7 @@ struct GTY(()) asm_node {\n template <>\n template <>\n inline bool\n-is_a_helper <cgraph_node>::test (symtab_node *p)\n+is_a_helper <cgraph_node *>::test (symtab_node *p)\n {\n   return p->type == SYMTAB_FUNCTION;\n }\n@@ -671,7 +671,7 @@ is_a_helper <cgraph_node>::test (symtab_node *p)\n template <>\n template <>\n inline bool\n-is_a_helper <varpool_node>::test (symtab_node *p)\n+is_a_helper <varpool_node *>::test (symtab_node *p)\n {\n   return p->type == SYMTAB_VARIABLE;\n }\n@@ -1029,7 +1029,7 @@ varpool_first_variable (void)\n {\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n-    if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+    if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n       return vnode;\n   return NULL;\n }\n@@ -1040,7 +1040,7 @@ varpool_next_variable (varpool_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n-    if (varpool_node *vnode1 = dyn_cast <varpool_node> (node1))\n+    if (varpool_node *vnode1 = dyn_cast <varpool_node *> (node1))\n       return vnode1;\n   return NULL;\n }\n@@ -1057,7 +1057,7 @@ varpool_first_static_initializer (void)\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n-      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode && DECL_INITIAL (node->decl))\n \treturn vnode;\n     }\n@@ -1071,7 +1071,7 @@ varpool_next_static_initializer (varpool_node *node)\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n-      varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n+      varpool_node *vnode1 = dyn_cast <varpool_node *> (node1);\n       if (vnode1 && DECL_INITIAL (node1->decl))\n \treturn vnode1;\n     }\n@@ -1090,7 +1090,7 @@ varpool_first_defined_variable (void)\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n-      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode && vnode->definition)\n \treturn vnode;\n     }\n@@ -1104,7 +1104,7 @@ varpool_next_defined_variable (varpool_node *node)\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n-      varpool_node *vnode1 = dyn_cast <varpool_node> (node1);\n+      varpool_node *vnode1 = dyn_cast <varpool_node *> (node1);\n       if (vnode1 && vnode1->definition)\n \treturn vnode1;\n     }\n@@ -1122,7 +1122,7 @@ cgraph_first_defined_function (void)\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n-      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n       if (cn && cn->definition)\n \treturn cn;\n     }\n@@ -1136,7 +1136,7 @@ cgraph_next_defined_function (struct cgraph_node *node)\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n-      cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n+      cgraph_node *cn1 = dyn_cast <cgraph_node *> (node1);\n       if (cn1 && cn1->definition)\n \treturn cn1;\n     }\n@@ -1154,7 +1154,7 @@ cgraph_first_function (void)\n {\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n-    if (cgraph_node *cn = dyn_cast <cgraph_node> (node))\n+    if (cgraph_node *cn = dyn_cast <cgraph_node *> (node))\n       return cn;\n   return NULL;\n }\n@@ -1165,7 +1165,7 @@ cgraph_next_function (struct cgraph_node *node)\n {\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n-    if (cgraph_node *cn1 = dyn_cast <cgraph_node> (node1))\n+    if (cgraph_node *cn1 = dyn_cast <cgraph_node *> (node1))\n       return cn1;\n   return NULL;\n }\n@@ -1193,7 +1193,7 @@ cgraph_first_function_with_gimple_body (void)\n   symtab_node *node;\n   for (node = symtab_nodes; node; node = node->next)\n     {\n-      cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+      cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n       if (cn && cgraph_function_with_gimple_body_p (cn))\n \treturn cn;\n     }\n@@ -1207,7 +1207,7 @@ cgraph_next_function_with_gimple_body (struct cgraph_node *node)\n   symtab_node *node1 = node->next;\n   for (; node1; node1 = node1->next)\n     {\n-      cgraph_node *cn1 = dyn_cast <cgraph_node> (node1);\n+      cgraph_node *cn1 = dyn_cast <cgraph_node *> (node1);\n       if (cn1 && cgraph_function_with_gimple_body_p (cn1))\n \treturn cn1;\n     }\n@@ -1415,13 +1415,13 @@ symtab_alias_target (symtab_node *n)\n static inline struct cgraph_node *\n cgraph_alias_target (struct cgraph_node *n)\n {\n-  return dyn_cast <cgraph_node> (symtab_alias_target (n));\n+  return dyn_cast <cgraph_node *> (symtab_alias_target (n));\n }\n \n static inline varpool_node *\n varpool_alias_target (varpool_node *n)\n {\n-  return dyn_cast <varpool_node> (symtab_alias_target (n));\n+  return dyn_cast <varpool_node *> (symtab_alias_target (n));\n }\n \n /* Given NODE, walk the alias chain to return the function NODE is alias of.\n@@ -1434,8 +1434,8 @@ cgraph_function_or_thunk_node (struct cgraph_node *node,\n {\n   struct cgraph_node *n;\n \n-  n = dyn_cast <cgraph_node> (symtab_alias_ultimate_target (node,\n-\t\t\t\t\t\t\t    availability));\n+  n = dyn_cast <cgraph_node *> (symtab_alias_ultimate_target (node,\n+\t\t\t\t\t\t\t      availability));\n   if (!n && availability)\n     *availability = AVAIL_NOT_AVAILABLE;\n   return n;\n@@ -1451,8 +1451,8 @@ varpool_variable_node (varpool_node *node,\n   varpool_node *n;\n \n   if (node)\n-    n = dyn_cast <varpool_node> (symtab_alias_ultimate_target (node,\n-\t\t\t\t\t\t\t       availability));\n+    n = dyn_cast <varpool_node *> (symtab_alias_ultimate_target (node,\n+\t\t\t\t\t\t\t\t availability));\n   else\n     n = NULL;\n \n@@ -1502,7 +1502,7 @@ symtab_real_symbol_p (symtab_node *node)\n \n   if (DECL_ABSTRACT (node->decl))\n     return false;\n-  if (!is_a <cgraph_node> (node))\n+  if (!is_a <cgraph_node *> (node))\n     return true;\n   cnode = cgraph (node);\n   if (cnode->global.inlined_to)"}, {"sha": "7bf9a07cbb22437b219f7cad5b61cfef056bc2c7", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -406,7 +406,7 @@ referred_to_p (symtab_node *node)\n   if (ipa_ref_list_referring_iterate (&node->ref_list, 0, ref))\n     return true;\n   /* For functions check also calls.  */\n-  cgraph_node *cn = dyn_cast <cgraph_node> (node);\n+  cgraph_node *cn = dyn_cast <cgraph_node *> (node);\n   if (cn && cn->callers)\n     return true;\n   return false;\n@@ -994,7 +994,7 @@ analyze_functions (void)\n \t  changed = true;\n \t  node = queued_nodes;\n \t  queued_nodes = (symtab_node *)queued_nodes->aux;\n-\t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \t  if (cnode && cnode->definition)\n \t    {\n \t      struct cgraph_edge *edge;\n@@ -1045,7 +1045,7 @@ analyze_functions (void)\n \t    }\n \t  else\n \t    {\n-\t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+\t      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n \t      if (vnode && vnode->definition && !vnode->analyzed)\n \t\tvarpool_analyze_node (vnode);\n \t    }\n@@ -1089,7 +1089,7 @@ analyze_functions (void)\n \t  symtab_remove_node (node);\n \t  continue;\n \t}\n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \t{\n \t  tree decl = node->decl;\n \n@@ -1179,7 +1179,7 @@ handle_alias_pairs (void)\n \t}\n \n       if (TREE_CODE (p->decl) == FUNCTION_DECL\n-          && target_node && is_a <cgraph_node> (target_node))\n+          && target_node && is_a <cgraph_node *> (target_node))\n \t{\n \t  struct cgraph_node *src_node = cgraph_get_node (p->decl);\n \t  if (src_node && src_node->definition)\n@@ -1188,7 +1188,7 @@ handle_alias_pairs (void)\n \t  alias_pairs->unordered_remove (i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n-\t       && target_node && is_a <varpool_node> (target_node))\n+\t       && target_node && is_a <varpool_node *> (target_node))\n \t{\n \t  varpool_create_variable_alias (p->decl, target_node->decl);\n \t  alias_pairs->unordered_remove (i);"}, {"sha": "8b47f513652d633cff56d0b0f61b1b4c23d1815c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -96,7 +96,7 @@ can_refer_decl_in_current_unit_p (tree decl, tree from_decl)\n       snode = symtab_get_node (decl);\n       if (!snode)\n \treturn false;\n-      node = dyn_cast <cgraph_node> (snode);\n+      node = dyn_cast <cgraph_node *> (snode);\n       return !node || !node->global.inlined_to;\n     }\n "}, {"sha": "904f002d54e0ef30d69ab571bf0760c291390ef2", "filename": "gcc/gimple-ssa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-ssa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-ssa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa.h?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -109,7 +109,7 @@ gimple_vuse_op (const_gimple g)\n {\n   struct use_optype_d *ops;\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <const gimple_statement_with_memory_ops> (g);\n+     dyn_cast <const gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL_USE_OPERAND_P;\n   ops = mem_ops_stmt->use_ops;\n@@ -125,7 +125,7 @@ static inline def_operand_p\n gimple_vdef_op (gimple g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <gimple_statement_with_memory_ops> (g);\n+     dyn_cast <gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL_DEF_OPERAND_P;\n   if (mem_ops_stmt->vdef)"}, {"sha": "f7b5d0110a7e28b5f523c205d6e53ef37bedfc5b", "filename": "gcc/gimple-streamer-in.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-streamer-in.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -137,7 +137,7 @@ input_gimple_stmt (struct lto_input_block *ib, struct data_in *data_in,\n     case GIMPLE_ASM:\n       {\n \t/* FIXME lto.  Move most of this into a new gimple_asm_set_string().  */\n-\tgimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (stmt);\n+\tgimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (stmt);\n \ttree str;\n \tasm_stmt->ni = streamer_read_uhwi (ib);\n \tasm_stmt->no = streamer_read_uhwi (ib);"}, {"sha": "8552a17920a9391b12aa071c8faf5fa268706f41", "filename": "gcc/gimple.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -544,7 +544,7 @@ gimple_build_asm_1 (const char *string, unsigned ninputs, unsigned noutputs,\n      enforced by the front end.  */\n   gcc_assert (nlabels == 0 || noutputs == 0);\n \n-  p = as_a <gimple_statement_asm> (\n+  p = as_a <gimple_statement_asm *> (\n         gimple_build_with_ops (GIMPLE_ASM, ERROR_MARK,\n \t\t\t       ninputs + noutputs + nclobbers + nlabels));\n \n@@ -671,7 +671,7 @@ gimple_build_try (gimple_seq eval, gimple_seq cleanup,\n   gimple_statement_try *p;\n \n   gcc_assert (kind == GIMPLE_TRY_CATCH || kind == GIMPLE_TRY_FINALLY);\n-  p = as_a <gimple_statement_try> (gimple_alloc (GIMPLE_TRY, 0));\n+  p = as_a <gimple_statement_try *> (gimple_alloc (GIMPLE_TRY, 0));\n   gimple_set_subcode (p, kind);\n   if (eval)\n     gimple_try_set_eval (p, eval);\n@@ -702,7 +702,7 @@ gimple\n gimple_build_resx (int region)\n {\n   gimple_statement_resx *p =\n-    as_a <gimple_statement_resx> (\n+    as_a <gimple_statement_resx *> (\n       gimple_build_with_ops (GIMPLE_RESX, ERROR_MARK, 0));\n   p->region = region;\n   return p;\n@@ -752,7 +752,7 @@ gimple\n gimple_build_eh_dispatch (int region)\n {\n   gimple_statement_eh_dispatch *p =\n-    as_a <gimple_statement_eh_dispatch> (\n+    as_a <gimple_statement_eh_dispatch *> (\n       gimple_build_with_ops (GIMPLE_EH_DISPATCH, ERROR_MARK, 0));\n   p->region = region;\n   return p;\n@@ -829,7 +829,7 @@ gimple_build_omp_for (gimple_seq body, int kind, tree clauses, size_t collapse,\n \t\t      gimple_seq pre_body)\n {\n   gimple_statement_omp_for *p =\n-    as_a <gimple_statement_omp_for> (gimple_alloc (GIMPLE_OMP_FOR, 0));\n+    as_a <gimple_statement_omp_for *> (gimple_alloc (GIMPLE_OMP_FOR, 0));\n   if (body)\n     gimple_omp_set_body (p, body);\n   gimple_omp_for_set_clauses (p, clauses);\n@@ -1664,7 +1664,7 @@ gimple_copy (gimple stmt)\n \t  gimple_omp_for_set_clauses (copy, t);\n \t  {\n \t    gimple_statement_omp_for *omp_for_copy =\n-\t      as_a <gimple_statement_omp_for> (copy);\n+\t      as_a <gimple_statement_omp_for *> (copy);\n \t    omp_for_copy->iter =\n \t      static_cast <struct gimple_omp_for_iter *> (\n \t\t  ggc_internal_vec_alloc_stat (sizeof (struct gimple_omp_for_iter),"}, {"sha": "edb46351ea6a0c82e2328246778d44fa25e8c818", "filename": "gcc/gimple.h", "status": "modified", "additions": 225, "deletions": 225, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -767,383 +767,383 @@ enum gimple_statement_structure_enum {\n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_asm>::test (gimple gs)\n+is_a_helper <gimple_statement_asm *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_ASM;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_bind>::test (gimple gs)\n+is_a_helper <gimple_statement_bind *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_BIND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_call>::test (gimple gs)\n+is_a_helper <gimple_statement_call *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_CALL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_catch>::test (gimple gs)\n+is_a_helper <gimple_statement_catch *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_CATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_resx>::test (gimple gs)\n+is_a_helper <gimple_statement_resx *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_RESX;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_eh_dispatch>::test (gimple gs)\n+is_a_helper <gimple_statement_eh_dispatch *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_EH_DISPATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_eh_else>::test (gimple gs)\n+is_a_helper <gimple_statement_eh_else *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_EH_ELSE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_eh_filter>::test (gimple gs)\n+is_a_helper <gimple_statement_eh_filter *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_EH_FILTER;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_eh_mnt>::test (gimple gs)\n+is_a_helper <gimple_statement_eh_mnt *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_EH_MUST_NOT_THROW;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_atomic_load>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_atomic_load *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_LOAD;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_atomic_store>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_atomic_store *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_STORE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_return>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_return *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_continue>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_continue *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_CONTINUE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_critical>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_critical *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_for>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_for *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_FOR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_taskreg>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_taskreg *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_parallel>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_parallel *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_target>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_target *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TARGET;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_sections>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_sections *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_SECTIONS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_single>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_single *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_SINGLE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_teams>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_teams *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TEAMS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_omp_task>::test (gimple gs)\n+is_a_helper <gimple_statement_omp_task *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_phi>::test (gimple gs)\n+is_a_helper <gimple_statement_phi *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_PHI;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_transaction>::test (gimple gs)\n+is_a_helper <gimple_statement_transaction *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_TRANSACTION;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_try>::test (gimple gs)\n+is_a_helper <gimple_statement_try *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_TRY;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_wce>::test (gimple gs)\n+is_a_helper <gimple_statement_wce *>::test (gimple gs)\n {\n   return gs->code == GIMPLE_WITH_CLEANUP_EXPR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_asm>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_asm *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_ASM;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_bind>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_bind *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_BIND;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_call>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_call *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_CALL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_catch>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_catch *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_CATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_resx>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_resx *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_RESX;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_eh_dispatch>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_eh_dispatch *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_EH_DISPATCH;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_eh_filter>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_eh_filter *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_EH_FILTER;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_atomic_load>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_atomic_load *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_LOAD;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_atomic_store>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_atomic_store *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_ATOMIC_STORE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_return>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_return *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_RETURN;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_continue>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_continue *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_CONTINUE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_critical>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_critical *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_CRITICAL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_for>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_for *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_FOR;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_taskreg>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_taskreg *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL || gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_parallel>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_parallel *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_PARALLEL;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_target>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_target *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TARGET;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_sections>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_sections *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_SECTIONS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_single>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_single *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_SINGLE;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_teams>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_teams *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TEAMS;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_omp_task>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_omp_task *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_OMP_TASK;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_phi>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_phi *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_PHI;\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_transaction>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_transaction *>::test (const_gimple gs)\n {\n   return gs->code == GIMPLE_TRANSACTION;\n }\n@@ -1647,15 +1647,15 @@ gimple_has_ops (const_gimple g)\n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_with_ops>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_with_ops *>::test (const_gimple gs)\n {\n   return gimple_has_ops (gs);\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_with_ops>::test (gimple gs)\n+is_a_helper <gimple_statement_with_ops *>::test (gimple gs)\n {\n   return gimple_has_ops (gs);\n }\n@@ -1671,15 +1671,15 @@ gimple_has_mem_ops (const_gimple g)\n template <>\n template <>\n inline bool\n-is_a_helper <const gimple_statement_with_memory_ops>::test (const_gimple gs)\n+is_a_helper <const gimple_statement_with_memory_ops *>::test (const_gimple gs)\n {\n   return gimple_has_mem_ops (gs);\n }\n \n template <>\n template <>\n inline bool\n-is_a_helper <gimple_statement_with_memory_ops>::test (gimple gs)\n+is_a_helper <gimple_statement_with_memory_ops *>::test (gimple gs)\n {\n   return gimple_has_mem_ops (gs);\n }\n@@ -1690,7 +1690,7 @@ static inline struct use_optype_d *\n gimple_use_ops (const_gimple g)\n {\n   const gimple_statement_with_ops *ops_stmt =\n-    dyn_cast <const gimple_statement_with_ops> (g);\n+    dyn_cast <const gimple_statement_with_ops *> (g);\n   if (!ops_stmt)\n     return NULL;\n   return ops_stmt->use_ops;\n@@ -1703,7 +1703,7 @@ static inline void\n gimple_set_use_ops (gimple g, struct use_optype_d *use)\n {\n   gimple_statement_with_ops *ops_stmt =\n-    as_a <gimple_statement_with_ops> (g);\n+    as_a <gimple_statement_with_ops *> (g);\n   ops_stmt->use_ops = use;\n }\n \n@@ -1714,7 +1714,7 @@ static inline tree\n gimple_vuse (const_gimple g)\n {\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <const gimple_statement_with_memory_ops> (g);\n+     dyn_cast <const gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL_TREE;\n   return mem_ops_stmt->vuse;\n@@ -1726,7 +1726,7 @@ static inline tree\n gimple_vdef (const_gimple g)\n {\n   const gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <const gimple_statement_with_memory_ops> (g);\n+     dyn_cast <const gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL_TREE;\n   return mem_ops_stmt->vdef;\n@@ -1738,7 +1738,7 @@ static inline tree *\n gimple_vuse_ptr (gimple g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <gimple_statement_with_memory_ops> (g);\n+     dyn_cast <gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL;\n   return &mem_ops_stmt->vuse;\n@@ -1750,7 +1750,7 @@ static inline tree *\n gimple_vdef_ptr (gimple g)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n-     dyn_cast <gimple_statement_with_memory_ops> (g);\n+     dyn_cast <gimple_statement_with_memory_ops *> (g);\n   if (!mem_ops_stmt)\n     return NULL;\n   return &mem_ops_stmt->vdef;\n@@ -1762,7 +1762,7 @@ static inline void\n gimple_set_vuse (gimple g, tree vuse)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n-    as_a <gimple_statement_with_memory_ops> (g);\n+    as_a <gimple_statement_with_memory_ops *> (g);\n   mem_ops_stmt->vuse = vuse;\n }\n \n@@ -1772,7 +1772,7 @@ static inline void\n gimple_set_vdef (gimple g, tree vdef)\n {\n   gimple_statement_with_memory_ops *mem_ops_stmt =\n-    as_a <gimple_statement_with_memory_ops> (g);\n+    as_a <gimple_statement_with_memory_ops *> (g);\n   mem_ops_stmt->vdef = vdef;\n }\n \n@@ -1904,7 +1904,7 @@ static inline void\n gimple_omp_return_set_lhs (gimple g, tree lhs)\n {\n   gimple_statement_omp_return *omp_return_stmt =\n-    as_a <gimple_statement_omp_return> (g);\n+    as_a <gimple_statement_omp_return *> (g);\n   omp_return_stmt->val = lhs;\n }\n \n@@ -1915,7 +1915,7 @@ static inline tree\n gimple_omp_return_lhs (const_gimple g)\n {\n   const gimple_statement_omp_return *omp_return_stmt =\n-    as_a <const gimple_statement_omp_return> (g);\n+    as_a <const gimple_statement_omp_return *> (g);\n   return omp_return_stmt->val;\n }\n \n@@ -1926,7 +1926,7 @@ static inline tree *\n gimple_omp_return_lhs_ptr (gimple g)\n {\n   gimple_statement_omp_return *omp_return_stmt =\n-    as_a <gimple_statement_omp_return> (g);\n+    as_a <gimple_statement_omp_return *> (g);\n   return &omp_return_stmt->val;\n }\n \n@@ -2454,7 +2454,7 @@ static inline tree\n gimple_call_fntype (const_gimple gs)\n {\n   const gimple_statement_call *call_stmt =\n-    as_a <const gimple_statement_call> (gs);\n+    as_a <const gimple_statement_call *> (gs);\n   if (gimple_call_internal_p (gs))\n     return NULL_TREE;\n   return call_stmt->u.fntype;\n@@ -2465,7 +2465,7 @@ gimple_call_fntype (const_gimple gs)\n static inline void\n gimple_call_set_fntype (gimple gs, tree fntype)\n {\n-  gimple_statement_call *call_stmt = as_a <gimple_statement_call> (gs);\n+  gimple_statement_call *call_stmt = as_a <gimple_statement_call *> (gs);\n   gcc_gimple_checking_assert (!gimple_call_internal_p (gs));\n   call_stmt->u.fntype = fntype;\n }\n@@ -2519,7 +2519,7 @@ gimple_call_set_fndecl (gimple gs, tree decl)\n static inline void\n gimple_call_set_internal_fn (gimple gs, enum internal_fn fn)\n {\n-  gimple_statement_call *call_stmt = as_a <gimple_statement_call> (gs);\n+  gimple_statement_call *call_stmt = as_a <gimple_statement_call *> (gs);\n   gcc_gimple_checking_assert (gimple_call_internal_p (gs));\n   call_stmt->u.internal_fn = fn;\n }\n@@ -2797,7 +2797,7 @@ gimple_call_copy_flags (gimple dest_call, gimple orig_call)\n static inline struct pt_solution *\n gimple_call_use_set (gimple call)\n {\n-  gimple_statement_call *call_stmt = as_a <gimple_statement_call> (call);\n+  gimple_statement_call *call_stmt = as_a <gimple_statement_call *> (call);\n   return &call_stmt->call_used;\n }\n \n@@ -2808,7 +2808,7 @@ gimple_call_use_set (gimple call)\n static inline struct pt_solution *\n gimple_call_clobber_set (gimple call)\n {\n-  gimple_statement_call *call_stmt = as_a <gimple_statement_call> (call);\n+  gimple_statement_call *call_stmt = as_a <gimple_statement_call *> (call);\n   return &call_stmt->call_clobbered;\n }\n \n@@ -3078,7 +3078,7 @@ static inline tree\n gimple_bind_vars (const_gimple gs)\n {\n   const gimple_statement_bind *bind_stmt =\n-    as_a <const gimple_statement_bind> (gs);\n+    as_a <const gimple_statement_bind *> (gs);\n   return bind_stmt->vars;\n }\n \n@@ -3089,7 +3089,7 @@ gimple_bind_vars (const_gimple gs)\n static inline void\n gimple_bind_set_vars (gimple gs, tree vars)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   bind_stmt->vars = vars;\n }\n \n@@ -3100,15 +3100,15 @@ gimple_bind_set_vars (gimple gs, tree vars)\n static inline void\n gimple_bind_append_vars (gimple gs, tree vars)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   bind_stmt->vars = chainon (bind_stmt->vars, vars);\n }\n \n \n static inline gimple_seq *\n gimple_bind_body_ptr (gimple gs)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   return &bind_stmt->body;\n }\n \n@@ -3127,7 +3127,7 @@ gimple_bind_body (gimple gs)\n static inline void\n gimple_bind_set_body (gimple gs, gimple_seq seq)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   bind_stmt->body = seq;\n }\n \n@@ -3137,7 +3137,7 @@ gimple_bind_set_body (gimple gs, gimple_seq seq)\n static inline void\n gimple_bind_add_stmt (gimple gs, gimple stmt)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   gimple_seq_add_stmt (&bind_stmt->body, stmt);\n }\n \n@@ -3147,7 +3147,7 @@ gimple_bind_add_stmt (gimple gs, gimple stmt)\n static inline void\n gimple_bind_add_seq (gimple gs, gimple_seq seq)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   gimple_seq_add_seq (&bind_stmt->body, seq);\n }\n \n@@ -3159,7 +3159,7 @@ static inline tree\n gimple_bind_block (const_gimple gs)\n {\n   const gimple_statement_bind *bind_stmt =\n-    as_a <const gimple_statement_bind> (gs);\n+    as_a <const gimple_statement_bind *> (gs);\n   return bind_stmt->block;\n }\n \n@@ -3170,7 +3170,7 @@ gimple_bind_block (const_gimple gs)\n static inline void\n gimple_bind_set_block (gimple gs, tree block)\n {\n-  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind> (gs);\n+  gimple_statement_bind *bind_stmt = as_a <gimple_statement_bind *> (gs);\n   gcc_gimple_checking_assert (block == NULL_TREE\n \t\t\t      || TREE_CODE (block) == BLOCK);\n   bind_stmt->block = block;\n@@ -3183,7 +3183,7 @@ static inline unsigned\n gimple_asm_ninputs (const_gimple gs)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   return asm_stmt->ni;\n }\n \n@@ -3194,7 +3194,7 @@ static inline unsigned\n gimple_asm_noutputs (const_gimple gs)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   return asm_stmt->no;\n }\n \n@@ -3205,7 +3205,7 @@ static inline unsigned\n gimple_asm_nclobbers (const_gimple gs)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   return asm_stmt->nc;\n }\n \n@@ -3215,7 +3215,7 @@ static inline unsigned\n gimple_asm_nlabels (const_gimple gs)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   return asm_stmt->nl;\n }\n \n@@ -3225,7 +3225,7 @@ static inline tree\n gimple_asm_input_op (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->ni);\n   return gimple_op (gs, index + asm_stmt->no);\n }\n@@ -3236,7 +3236,7 @@ static inline tree *\n gimple_asm_input_op_ptr (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->ni);\n   return gimple_op_ptr (gs, index + asm_stmt->no);\n }\n@@ -3247,7 +3247,7 @@ gimple_asm_input_op_ptr (const_gimple gs, unsigned index)\n static inline void\n gimple_asm_set_input_op (gimple gs, unsigned index, tree in_op)\n {\n-  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (gs);\n+  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->ni\n \t\t\t      && TREE_CODE (in_op) == TREE_LIST);\n   gimple_set_op (gs, index + asm_stmt->no, in_op);\n@@ -3260,7 +3260,7 @@ static inline tree\n gimple_asm_output_op (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->no);\n   return gimple_op (gs, index);\n }\n@@ -3271,7 +3271,7 @@ static inline tree *\n gimple_asm_output_op_ptr (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->no);\n   return gimple_op_ptr (gs, index);\n }\n@@ -3282,7 +3282,7 @@ gimple_asm_output_op_ptr (const_gimple gs, unsigned index)\n static inline void\n gimple_asm_set_output_op (gimple gs, unsigned index, tree out_op)\n {\n-  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (gs);\n+  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->no\n \t\t\t      && TREE_CODE (out_op) == TREE_LIST);\n   gimple_set_op (gs, index, out_op);\n@@ -3295,7 +3295,7 @@ static inline tree\n gimple_asm_clobber_op (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->nc);\n   return gimple_op (gs, index + asm_stmt->ni + asm_stmt->no);\n }\n@@ -3306,7 +3306,7 @@ gimple_asm_clobber_op (const_gimple gs, unsigned index)\n static inline void\n gimple_asm_set_clobber_op (gimple gs, unsigned index, tree clobber_op)\n {\n-  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (gs);\n+  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->nc\n \t\t\t      && TREE_CODE (clobber_op) == TREE_LIST);\n   gimple_set_op (gs, index + asm_stmt->ni + asm_stmt->no, clobber_op);\n@@ -3318,7 +3318,7 @@ static inline tree\n gimple_asm_label_op (const_gimple gs, unsigned index)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->nl);\n   return gimple_op (gs, index + asm_stmt->ni + asm_stmt->nc);\n }\n@@ -3328,7 +3328,7 @@ gimple_asm_label_op (const_gimple gs, unsigned index)\n static inline void\n gimple_asm_set_label_op (gimple gs, unsigned index, tree label_op)\n {\n-  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm> (gs);\n+  gimple_statement_asm *asm_stmt = as_a <gimple_statement_asm *> (gs);\n   gcc_gimple_checking_assert (index < asm_stmt->nl\n \t\t\t      && TREE_CODE (label_op) == TREE_LIST);\n   gimple_set_op (gs, index + asm_stmt->ni + asm_stmt->nc, label_op);\n@@ -3341,7 +3341,7 @@ static inline const char *\n gimple_asm_string (const_gimple gs)\n {\n   const gimple_statement_asm *asm_stmt =\n-    as_a <const gimple_statement_asm> (gs);\n+    as_a <const gimple_statement_asm *> (gs);\n   return asm_stmt->string;\n }\n \n@@ -3398,7 +3398,7 @@ static inline tree\n gimple_catch_types (const_gimple gs)\n {\n   const gimple_statement_catch *catch_stmt =\n-    as_a <const gimple_statement_catch> (gs);\n+    as_a <const gimple_statement_catch *> (gs);\n   return catch_stmt->types;\n }\n \n@@ -3408,7 +3408,7 @@ gimple_catch_types (const_gimple gs)\n static inline tree *\n gimple_catch_types_ptr (gimple gs)\n {\n-  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch> (gs);\n+  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch *> (gs);\n   return &catch_stmt->types;\n }\n \n@@ -3419,7 +3419,7 @@ gimple_catch_types_ptr (gimple gs)\n static inline gimple_seq *\n gimple_catch_handler_ptr (gimple gs)\n {\n-  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch> (gs);\n+  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch *> (gs);\n   return &catch_stmt->handler;\n }\n \n@@ -3439,7 +3439,7 @@ gimple_catch_handler (gimple gs)\n static inline void\n gimple_catch_set_types (gimple gs, tree t)\n {\n-  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch> (gs);\n+  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch *> (gs);\n   catch_stmt->types = t;\n }\n \n@@ -3449,7 +3449,7 @@ gimple_catch_set_types (gimple gs, tree t)\n static inline void\n gimple_catch_set_handler (gimple gs, gimple_seq handler)\n {\n-  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch> (gs);\n+  gimple_statement_catch *catch_stmt = as_a <gimple_statement_catch *> (gs);\n   catch_stmt->handler = handler;\n }\n \n@@ -3460,7 +3460,7 @@ static inline tree\n gimple_eh_filter_types (const_gimple gs)\n {\n   const gimple_statement_eh_filter *eh_filter_stmt =\n-    as_a <const gimple_statement_eh_filter> (gs);\n+    as_a <const gimple_statement_eh_filter *> (gs);\n   return eh_filter_stmt->types;\n }\n \n@@ -3472,7 +3472,7 @@ static inline tree *\n gimple_eh_filter_types_ptr (gimple gs)\n {\n   gimple_statement_eh_filter *eh_filter_stmt =\n-    as_a <gimple_statement_eh_filter> (gs);\n+    as_a <gimple_statement_eh_filter *> (gs);\n   return &eh_filter_stmt->types;\n }\n \n@@ -3484,7 +3484,7 @@ static inline gimple_seq *\n gimple_eh_filter_failure_ptr (gimple gs)\n {\n   gimple_statement_eh_filter *eh_filter_stmt =\n-    as_a <gimple_statement_eh_filter> (gs);\n+    as_a <gimple_statement_eh_filter *> (gs);\n   return &eh_filter_stmt->failure;\n }\n \n@@ -3505,7 +3505,7 @@ static inline void\n gimple_eh_filter_set_types (gimple gs, tree types)\n {\n   gimple_statement_eh_filter *eh_filter_stmt =\n-    as_a <gimple_statement_eh_filter> (gs);\n+    as_a <gimple_statement_eh_filter *> (gs);\n   eh_filter_stmt->types = types;\n }\n \n@@ -3517,7 +3517,7 @@ static inline void\n gimple_eh_filter_set_failure (gimple gs, gimple_seq failure)\n {\n   gimple_statement_eh_filter *eh_filter_stmt =\n-    as_a <gimple_statement_eh_filter> (gs);\n+    as_a <gimple_statement_eh_filter *> (gs);\n   eh_filter_stmt->failure = failure;\n }\n \n@@ -3526,7 +3526,7 @@ gimple_eh_filter_set_failure (gimple gs, gimple_seq failure)\n static inline tree\n gimple_eh_must_not_throw_fndecl (gimple gs)\n {\n-  gimple_statement_eh_mnt *eh_mnt_stmt = as_a <gimple_statement_eh_mnt> (gs);\n+  gimple_statement_eh_mnt *eh_mnt_stmt = as_a <gimple_statement_eh_mnt *> (gs);\n   return eh_mnt_stmt->fndecl;\n }\n \n@@ -3535,7 +3535,7 @@ gimple_eh_must_not_throw_fndecl (gimple gs)\n static inline void\n gimple_eh_must_not_throw_set_fndecl (gimple gs, tree decl)\n {\n-  gimple_statement_eh_mnt *eh_mnt_stmt = as_a <gimple_statement_eh_mnt> (gs);\n+  gimple_statement_eh_mnt *eh_mnt_stmt = as_a <gimple_statement_eh_mnt *> (gs);\n   eh_mnt_stmt->fndecl = decl;\n }\n \n@@ -3545,7 +3545,7 @@ static inline gimple_seq *\n gimple_eh_else_n_body_ptr (gimple gs)\n {\n   gimple_statement_eh_else *eh_else_stmt =\n-    as_a <gimple_statement_eh_else> (gs);\n+    as_a <gimple_statement_eh_else *> (gs);\n   return &eh_else_stmt->n_body;\n }\n \n@@ -3559,7 +3559,7 @@ static inline gimple_seq *\n gimple_eh_else_e_body_ptr (gimple gs)\n {\n   gimple_statement_eh_else *eh_else_stmt =\n-    as_a <gimple_statement_eh_else> (gs);\n+    as_a <gimple_statement_eh_else *> (gs);\n   return &eh_else_stmt->e_body;\n }\n \n@@ -3573,15 +3573,15 @@ static inline void\n gimple_eh_else_set_n_body (gimple gs, gimple_seq seq)\n {\n   gimple_statement_eh_else *eh_else_stmt =\n-    as_a <gimple_statement_eh_else> (gs);\n+    as_a <gimple_statement_eh_else *> (gs);\n   eh_else_stmt->n_body = seq;\n }\n \n static inline void\n gimple_eh_else_set_e_body (gimple gs, gimple_seq seq)\n {\n   gimple_statement_eh_else *eh_else_stmt =\n-    as_a <gimple_statement_eh_else> (gs);\n+    as_a <gimple_statement_eh_else *> (gs);\n   eh_else_stmt->e_body = seq;\n }\n \n@@ -3627,7 +3627,7 @@ gimple_try_catch_is_cleanup (const_gimple gs)\n static inline gimple_seq *\n gimple_try_eval_ptr (gimple gs)\n {\n-  gimple_statement_try *try_stmt = as_a <gimple_statement_try> (gs);\n+  gimple_statement_try *try_stmt = as_a <gimple_statement_try *> (gs);\n   return &try_stmt->eval;\n }\n \n@@ -3647,7 +3647,7 @@ gimple_try_eval (gimple gs)\n static inline gimple_seq *\n gimple_try_cleanup_ptr (gimple gs)\n {\n-  gimple_statement_try *try_stmt = as_a <gimple_statement_try> (gs);\n+  gimple_statement_try *try_stmt = as_a <gimple_statement_try *> (gs);\n   return &try_stmt->cleanup;\n }\n \n@@ -3681,7 +3681,7 @@ gimple_try_set_catch_is_cleanup (gimple g, bool catch_is_cleanup)\n static inline void\n gimple_try_set_eval (gimple gs, gimple_seq eval)\n {\n-  gimple_statement_try *try_stmt = as_a <gimple_statement_try> (gs);\n+  gimple_statement_try *try_stmt = as_a <gimple_statement_try *> (gs);\n   try_stmt->eval = eval;\n }\n \n@@ -3692,7 +3692,7 @@ gimple_try_set_eval (gimple gs, gimple_seq eval)\n static inline void\n gimple_try_set_cleanup (gimple gs, gimple_seq cleanup)\n {\n-  gimple_statement_try *try_stmt = as_a <gimple_statement_try> (gs);\n+  gimple_statement_try *try_stmt = as_a <gimple_statement_try *> (gs);\n   try_stmt->cleanup = cleanup;\n }\n \n@@ -3702,7 +3702,7 @@ gimple_try_set_cleanup (gimple gs, gimple_seq cleanup)\n static inline gimple_seq *\n gimple_wce_cleanup_ptr (gimple gs)\n {\n-  gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce> (gs);\n+  gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce *> (gs);\n   return &wce_stmt->cleanup;\n }\n \n@@ -3721,7 +3721,7 @@ gimple_wce_cleanup (gimple gs)\n static inline void\n gimple_wce_set_cleanup (gimple gs, gimple_seq cleanup)\n {\n-  gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce> (gs);\n+  gimple_statement_wce *wce_stmt = as_a <gimple_statement_wce *> (gs);\n   wce_stmt->cleanup = cleanup;\n }\n \n@@ -3752,7 +3752,7 @@ static inline unsigned\n gimple_phi_capacity (const_gimple gs)\n {\n   const gimple_statement_phi *phi_stmt =\n-    as_a <const gimple_statement_phi> (gs);\n+    as_a <const gimple_statement_phi *> (gs);\n   return phi_stmt->capacity;\n }\n \n@@ -3765,7 +3765,7 @@ static inline unsigned\n gimple_phi_num_args (const_gimple gs)\n {\n   const gimple_statement_phi *phi_stmt =\n-    as_a <const gimple_statement_phi> (gs);\n+    as_a <const gimple_statement_phi *> (gs);\n   return phi_stmt->nargs;\n }\n \n@@ -3776,7 +3776,7 @@ static inline tree\n gimple_phi_result (const_gimple gs)\n {\n   const gimple_statement_phi *phi_stmt =\n-    as_a <const gimple_statement_phi> (gs);\n+    as_a <const gimple_statement_phi *> (gs);\n   return phi_stmt->result;\n }\n \n@@ -3785,7 +3785,7 @@ gimple_phi_result (const_gimple gs)\n static inline tree *\n gimple_phi_result_ptr (gimple gs)\n {\n-  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi> (gs);\n+  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi *> (gs);\n   return &phi_stmt->result;\n }\n \n@@ -3794,7 +3794,7 @@ gimple_phi_result_ptr (gimple gs)\n static inline void\n gimple_phi_set_result (gimple gs, tree result)\n {\n-  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi> (gs);\n+  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi *> (gs);\n   phi_stmt->result = result;\n   if (result && TREE_CODE (result) == SSA_NAME)\n     SSA_NAME_DEF_STMT (result) = gs;\n@@ -3807,7 +3807,7 @@ gimple_phi_set_result (gimple gs, tree result)\n static inline struct phi_arg_d *\n gimple_phi_arg (gimple gs, unsigned index)\n {\n-  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi> (gs);\n+  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi *> (gs);\n   gcc_gimple_checking_assert (index <= phi_stmt->capacity);\n   return &(phi_stmt->args[index]);\n }\n@@ -3818,7 +3818,7 @@ gimple_phi_arg (gimple gs, unsigned index)\n static inline void\n gimple_phi_set_arg (gimple gs, unsigned index, struct phi_arg_d * phiarg)\n {\n-  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi> (gs);\n+  gimple_statement_phi *phi_stmt = as_a <gimple_statement_phi *> (gs);\n   gcc_gimple_checking_assert (index <= phi_stmt->nargs);\n   phi_stmt->args[index] = *phiarg;\n }\n@@ -3906,7 +3906,7 @@ static inline int\n gimple_resx_region (const_gimple gs)\n {\n   const gimple_statement_resx *resx_stmt =\n-    as_a <const gimple_statement_resx> (gs);\n+    as_a <const gimple_statement_resx *> (gs);\n   return resx_stmt->region;\n }\n \n@@ -3915,7 +3915,7 @@ gimple_resx_region (const_gimple gs)\n static inline void\n gimple_resx_set_region (gimple gs, int region)\n {\n-  gimple_statement_resx *resx_stmt = as_a <gimple_statement_resx> (gs);\n+  gimple_statement_resx *resx_stmt = as_a <gimple_statement_resx *> (gs);\n   resx_stmt->region = region;\n }\n \n@@ -3925,7 +3925,7 @@ static inline int\n gimple_eh_dispatch_region (const_gimple gs)\n {\n   const gimple_statement_eh_dispatch *eh_dispatch_stmt =\n-    as_a <const gimple_statement_eh_dispatch> (gs);\n+    as_a <const gimple_statement_eh_dispatch *> (gs);\n   return eh_dispatch_stmt->region;\n }\n \n@@ -3935,7 +3935,7 @@ static inline void\n gimple_eh_dispatch_set_region (gimple gs, int region)\n {\n   gimple_statement_eh_dispatch *eh_dispatch_stmt =\n-    as_a <gimple_statement_eh_dispatch> (gs);\n+    as_a <gimple_statement_eh_dispatch *> (gs);\n   eh_dispatch_stmt->region = region;\n }\n \n@@ -4247,7 +4247,7 @@ static inline tree\n gimple_omp_critical_name (const_gimple gs)\n {\n   const gimple_statement_omp_critical *omp_critical_stmt =\n-    as_a <const gimple_statement_omp_critical> (gs);\n+    as_a <const gimple_statement_omp_critical *> (gs);\n   return omp_critical_stmt->name;\n }\n \n@@ -4258,7 +4258,7 @@ static inline tree *\n gimple_omp_critical_name_ptr (gimple gs)\n {\n   gimple_statement_omp_critical *omp_critical_stmt =\n-    as_a <gimple_statement_omp_critical> (gs);\n+    as_a <gimple_statement_omp_critical *> (gs);\n   return &omp_critical_stmt->name;\n }\n \n@@ -4269,7 +4269,7 @@ static inline void\n gimple_omp_critical_set_name (gimple gs, tree name)\n {\n   gimple_statement_omp_critical *omp_critical_stmt =\n-    as_a <gimple_statement_omp_critical> (gs);\n+    as_a <gimple_statement_omp_critical *> (gs);\n   omp_critical_stmt->name = name;\n }\n \n@@ -4351,7 +4351,7 @@ static inline tree\n gimple_omp_for_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   return omp_for_stmt->clauses;\n }\n \n@@ -4362,7 +4362,7 @@ static inline tree *\n gimple_omp_for_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   return &omp_for_stmt->clauses;\n }\n \n@@ -4373,7 +4373,7 @@ static inline void\n gimple_omp_for_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   omp_for_stmt->clauses = clauses;\n }\n \n@@ -4384,7 +4384,7 @@ static inline size_t\n gimple_omp_for_collapse (gimple gs)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   return omp_for_stmt->collapse;\n }\n \n@@ -4395,7 +4395,7 @@ static inline tree\n gimple_omp_for_index (const_gimple gs, size_t i)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return omp_for_stmt->iter[i].index;\n }\n@@ -4407,7 +4407,7 @@ static inline tree *\n gimple_omp_for_index_ptr (gimple gs, size_t i)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return &omp_for_stmt->iter[i].index;\n }\n@@ -4419,7 +4419,7 @@ static inline void\n gimple_omp_for_set_index (gimple gs, size_t i, tree index)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   omp_for_stmt->iter[i].index = index;\n }\n@@ -4431,7 +4431,7 @@ static inline tree\n gimple_omp_for_initial (const_gimple gs, size_t i)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return omp_for_stmt->iter[i].initial;\n }\n@@ -4443,7 +4443,7 @@ static inline tree *\n gimple_omp_for_initial_ptr (gimple gs, size_t i)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return &omp_for_stmt->iter[i].initial;\n }\n@@ -4455,7 +4455,7 @@ static inline void\n gimple_omp_for_set_initial (gimple gs, size_t i, tree initial)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   omp_for_stmt->iter[i].initial = initial;\n }\n@@ -4467,7 +4467,7 @@ static inline tree\n gimple_omp_for_final (const_gimple gs, size_t i)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return omp_for_stmt->iter[i].final;\n }\n@@ -4479,7 +4479,7 @@ static inline tree *\n gimple_omp_for_final_ptr (gimple gs, size_t i)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return &omp_for_stmt->iter[i].final;\n }\n@@ -4491,7 +4491,7 @@ static inline void\n gimple_omp_for_set_final (gimple gs, size_t i, tree final)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   omp_for_stmt->iter[i].final = final;\n }\n@@ -4503,7 +4503,7 @@ static inline tree\n gimple_omp_for_incr (const_gimple gs, size_t i)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return omp_for_stmt->iter[i].incr;\n }\n@@ -4515,7 +4515,7 @@ static inline tree *\n gimple_omp_for_incr_ptr (gimple gs, size_t i)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return &omp_for_stmt->iter[i].incr;\n }\n@@ -4527,7 +4527,7 @@ static inline void\n gimple_omp_for_set_incr (gimple gs, size_t i, tree incr)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   omp_for_stmt->iter[i].incr = incr;\n }\n@@ -4540,7 +4540,7 @@ static inline gimple_seq *\n gimple_omp_for_pre_body_ptr (gimple gs)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   return &omp_for_stmt->pre_body;\n }\n \n@@ -4562,7 +4562,7 @@ static inline void\n gimple_omp_for_set_pre_body (gimple gs, gimple_seq pre_body)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   omp_for_stmt->pre_body = pre_body;\n }\n \n@@ -4573,7 +4573,7 @@ static inline tree\n gimple_omp_parallel_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <const gimple_statement_omp_parallel> (gs);\n+    as_a <const gimple_statement_omp_parallel *> (gs);\n   return omp_parallel_stmt->clauses;\n }\n \n@@ -4584,7 +4584,7 @@ static inline tree *\n gimple_omp_parallel_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   return &omp_parallel_stmt->clauses;\n }\n \n@@ -4596,7 +4596,7 @@ static inline void\n gimple_omp_parallel_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   omp_parallel_stmt->clauses = clauses;\n }\n \n@@ -4607,7 +4607,7 @@ static inline tree\n gimple_omp_parallel_child_fn (const_gimple gs)\n {\n   const gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <const gimple_statement_omp_parallel> (gs);\n+    as_a <const gimple_statement_omp_parallel *> (gs);\n   return omp_parallel_stmt->child_fn;\n }\n \n@@ -4618,7 +4618,7 @@ static inline tree *\n gimple_omp_parallel_child_fn_ptr (gimple gs)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   return &omp_parallel_stmt->child_fn;\n }\n \n@@ -4629,7 +4629,7 @@ static inline void\n gimple_omp_parallel_set_child_fn (gimple gs, tree child_fn)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   omp_parallel_stmt->child_fn = child_fn;\n }\n \n@@ -4641,7 +4641,7 @@ static inline tree\n gimple_omp_parallel_data_arg (const_gimple gs)\n {\n   const gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <const gimple_statement_omp_parallel> (gs);\n+    as_a <const gimple_statement_omp_parallel *> (gs);\n   return omp_parallel_stmt->data_arg;\n }\n \n@@ -4652,7 +4652,7 @@ static inline tree *\n gimple_omp_parallel_data_arg_ptr (gimple gs)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   return &omp_parallel_stmt->data_arg;\n }\n \n@@ -4663,7 +4663,7 @@ static inline void\n gimple_omp_parallel_set_data_arg (gimple gs, tree data_arg)\n {\n   gimple_statement_omp_parallel *omp_parallel_stmt =\n-    as_a <gimple_statement_omp_parallel> (gs);\n+    as_a <gimple_statement_omp_parallel *> (gs);\n   omp_parallel_stmt->data_arg = data_arg;\n }\n \n@@ -4674,7 +4674,7 @@ static inline tree\n gimple_omp_task_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->clauses;\n }\n \n@@ -4685,7 +4685,7 @@ static inline tree *\n gimple_omp_task_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->clauses;\n }\n \n@@ -4697,7 +4697,7 @@ static inline void\n gimple_omp_task_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->clauses = clauses;\n }\n \n@@ -4708,7 +4708,7 @@ static inline tree\n gimple_omp_task_child_fn (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->child_fn;\n }\n \n@@ -4719,7 +4719,7 @@ static inline tree *\n gimple_omp_task_child_fn_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->child_fn;\n }\n \n@@ -4730,7 +4730,7 @@ static inline void\n gimple_omp_task_set_child_fn (gimple gs, tree child_fn)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->child_fn = child_fn;\n }\n \n@@ -4742,7 +4742,7 @@ static inline tree\n gimple_omp_task_data_arg (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->data_arg;\n }\n \n@@ -4753,7 +4753,7 @@ static inline tree *\n gimple_omp_task_data_arg_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->data_arg;\n }\n \n@@ -4764,7 +4764,7 @@ static inline void\n gimple_omp_task_set_data_arg (gimple gs, tree data_arg)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->data_arg = data_arg;\n }\n \n@@ -4775,7 +4775,7 @@ static inline tree\n gimple_omp_taskreg_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <const gimple_statement_omp_taskreg> (gs);\n+    as_a <const gimple_statement_omp_taskreg *> (gs);\n   return omp_taskreg_stmt->clauses;\n }\n \n@@ -4786,7 +4786,7 @@ static inline tree *\n gimple_omp_taskreg_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   return &omp_taskreg_stmt->clauses;\n }\n \n@@ -4798,7 +4798,7 @@ static inline void\n gimple_omp_taskreg_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   omp_taskreg_stmt->clauses = clauses;\n }\n \n@@ -4809,7 +4809,7 @@ static inline tree\n gimple_omp_taskreg_child_fn (const_gimple gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <const gimple_statement_omp_taskreg> (gs);\n+    as_a <const gimple_statement_omp_taskreg *> (gs);\n   return omp_taskreg_stmt->child_fn;\n }\n \n@@ -4820,7 +4820,7 @@ static inline tree *\n gimple_omp_taskreg_child_fn_ptr (gimple gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   return &omp_taskreg_stmt->child_fn;\n }\n \n@@ -4831,7 +4831,7 @@ static inline void\n gimple_omp_taskreg_set_child_fn (gimple gs, tree child_fn)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   omp_taskreg_stmt->child_fn = child_fn;\n }\n \n@@ -4843,7 +4843,7 @@ static inline tree\n gimple_omp_taskreg_data_arg (const_gimple gs)\n {\n   const gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <const gimple_statement_omp_taskreg> (gs);\n+    as_a <const gimple_statement_omp_taskreg *> (gs);\n   return omp_taskreg_stmt->data_arg;\n }\n \n@@ -4854,7 +4854,7 @@ static inline tree *\n gimple_omp_taskreg_data_arg_ptr (gimple gs)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   return &omp_taskreg_stmt->data_arg;\n }\n \n@@ -4865,7 +4865,7 @@ static inline void\n gimple_omp_taskreg_set_data_arg (gimple gs, tree data_arg)\n {\n   gimple_statement_omp_taskreg *omp_taskreg_stmt =\n-    as_a <gimple_statement_omp_taskreg> (gs);\n+    as_a <gimple_statement_omp_taskreg *> (gs);\n   omp_taskreg_stmt->data_arg = data_arg;\n }\n \n@@ -4876,7 +4876,7 @@ static inline tree\n gimple_omp_task_copy_fn (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->copy_fn;\n }\n \n@@ -4887,7 +4887,7 @@ static inline tree *\n gimple_omp_task_copy_fn_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->copy_fn;\n }\n \n@@ -4898,7 +4898,7 @@ static inline void\n gimple_omp_task_set_copy_fn (gimple gs, tree copy_fn)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->copy_fn = copy_fn;\n }\n \n@@ -4909,7 +4909,7 @@ static inline tree\n gimple_omp_task_arg_size (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->arg_size;\n }\n \n@@ -4920,7 +4920,7 @@ static inline tree *\n gimple_omp_task_arg_size_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->arg_size;\n }\n \n@@ -4931,7 +4931,7 @@ static inline void\n gimple_omp_task_set_arg_size (gimple gs, tree arg_size)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->arg_size = arg_size;\n }\n \n@@ -4942,7 +4942,7 @@ static inline tree\n gimple_omp_task_arg_align (const_gimple gs)\n {\n   const gimple_statement_omp_task *omp_task_stmt =\n-    as_a <const gimple_statement_omp_task> (gs);\n+    as_a <const gimple_statement_omp_task *> (gs);\n   return omp_task_stmt->arg_align;\n }\n \n@@ -4953,7 +4953,7 @@ static inline tree *\n gimple_omp_task_arg_align_ptr (gimple gs)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   return &omp_task_stmt->arg_align;\n }\n \n@@ -4964,7 +4964,7 @@ static inline void\n gimple_omp_task_set_arg_align (gimple gs, tree arg_align)\n {\n   gimple_statement_omp_task *omp_task_stmt =\n-    as_a <gimple_statement_omp_task> (gs);\n+    as_a <gimple_statement_omp_task *> (gs);\n   omp_task_stmt->arg_align = arg_align;\n }\n \n@@ -4975,7 +4975,7 @@ static inline tree\n gimple_omp_single_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_single *omp_single_stmt =\n-    as_a <const gimple_statement_omp_single> (gs);\n+    as_a <const gimple_statement_omp_single *> (gs);\n   return omp_single_stmt->clauses;\n }\n \n@@ -4986,7 +4986,7 @@ static inline tree *\n gimple_omp_single_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_single *omp_single_stmt =\n-    as_a <gimple_statement_omp_single> (gs);\n+    as_a <gimple_statement_omp_single *> (gs);\n   return &omp_single_stmt->clauses;\n }\n \n@@ -4997,7 +4997,7 @@ static inline void\n gimple_omp_single_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_single *omp_single_stmt =\n-    as_a <gimple_statement_omp_single> (gs);\n+    as_a <gimple_statement_omp_single *> (gs);\n   omp_single_stmt->clauses = clauses;\n }\n \n@@ -5008,7 +5008,7 @@ static inline tree\n gimple_omp_target_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_target *omp_target_stmt =\n-    as_a <const gimple_statement_omp_target> (gs);\n+    as_a <const gimple_statement_omp_target *> (gs);\n   return omp_target_stmt->clauses;\n }\n \n@@ -5019,7 +5019,7 @@ static inline tree *\n gimple_omp_target_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   return &omp_target_stmt->clauses;\n }\n \n@@ -5030,7 +5030,7 @@ static inline void\n gimple_omp_target_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   omp_target_stmt->clauses = clauses;\n }\n \n@@ -5062,7 +5062,7 @@ static inline tree\n gimple_omp_target_child_fn (const_gimple gs)\n {\n   const gimple_statement_omp_target *omp_target_stmt =\n-    as_a <const gimple_statement_omp_target> (gs);\n+    as_a <const gimple_statement_omp_target *> (gs);\n   return omp_target_stmt->child_fn;\n }\n \n@@ -5073,7 +5073,7 @@ static inline tree *\n gimple_omp_target_child_fn_ptr (gimple gs)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   return &omp_target_stmt->child_fn;\n }\n \n@@ -5084,7 +5084,7 @@ static inline void\n gimple_omp_target_set_child_fn (gimple gs, tree child_fn)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   omp_target_stmt->child_fn = child_fn;\n }\n \n@@ -5096,7 +5096,7 @@ static inline tree\n gimple_omp_target_data_arg (const_gimple gs)\n {\n   const gimple_statement_omp_target *omp_target_stmt =\n-    as_a <const gimple_statement_omp_target> (gs);\n+    as_a <const gimple_statement_omp_target *> (gs);\n   return omp_target_stmt->data_arg;\n }\n \n@@ -5107,7 +5107,7 @@ static inline tree *\n gimple_omp_target_data_arg_ptr (gimple gs)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   return &omp_target_stmt->data_arg;\n }\n \n@@ -5118,7 +5118,7 @@ static inline void\n gimple_omp_target_set_data_arg (gimple gs, tree data_arg)\n {\n   gimple_statement_omp_target *omp_target_stmt =\n-    as_a <gimple_statement_omp_target> (gs);\n+    as_a <gimple_statement_omp_target *> (gs);\n   omp_target_stmt->data_arg = data_arg;\n }\n \n@@ -5129,7 +5129,7 @@ static inline tree\n gimple_omp_teams_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_teams *omp_teams_stmt =\n-    as_a <const gimple_statement_omp_teams> (gs);\n+    as_a <const gimple_statement_omp_teams *> (gs);\n   return omp_teams_stmt->clauses;\n }\n \n@@ -5140,7 +5140,7 @@ static inline tree *\n gimple_omp_teams_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_teams *omp_teams_stmt =\n-    as_a <gimple_statement_omp_teams> (gs);\n+    as_a <gimple_statement_omp_teams *> (gs);\n   return &omp_teams_stmt->clauses;\n }\n \n@@ -5151,7 +5151,7 @@ static inline void\n gimple_omp_teams_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_teams *omp_teams_stmt =\n-    as_a <gimple_statement_omp_teams> (gs);\n+    as_a <gimple_statement_omp_teams *> (gs);\n   omp_teams_stmt->clauses = clauses;\n }\n \n@@ -5162,7 +5162,7 @@ static inline tree\n gimple_omp_sections_clauses (const_gimple gs)\n {\n   const gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <const gimple_statement_omp_sections> (gs);\n+    as_a <const gimple_statement_omp_sections *> (gs);\n   return omp_sections_stmt->clauses;\n }\n \n@@ -5173,7 +5173,7 @@ static inline tree *\n gimple_omp_sections_clauses_ptr (gimple gs)\n {\n   gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <gimple_statement_omp_sections> (gs);\n+    as_a <gimple_statement_omp_sections *> (gs);\n   return &omp_sections_stmt->clauses;\n }\n \n@@ -5185,7 +5185,7 @@ static inline void\n gimple_omp_sections_set_clauses (gimple gs, tree clauses)\n {\n   gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <gimple_statement_omp_sections> (gs);\n+    as_a <gimple_statement_omp_sections *> (gs);\n   omp_sections_stmt->clauses = clauses;\n }\n \n@@ -5197,7 +5197,7 @@ static inline tree\n gimple_omp_sections_control (const_gimple gs)\n {\n   const gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <const gimple_statement_omp_sections> (gs);\n+    as_a <const gimple_statement_omp_sections *> (gs);\n   return omp_sections_stmt->control;\n }\n \n@@ -5209,7 +5209,7 @@ static inline tree *\n gimple_omp_sections_control_ptr (gimple gs)\n {\n   gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <gimple_statement_omp_sections> (gs);\n+    as_a <gimple_statement_omp_sections *> (gs);\n   return &omp_sections_stmt->control;\n }\n \n@@ -5221,7 +5221,7 @@ static inline void\n gimple_omp_sections_set_control (gimple gs, tree control)\n {\n   gimple_statement_omp_sections *omp_sections_stmt =\n-    as_a <gimple_statement_omp_sections> (gs);\n+    as_a <gimple_statement_omp_sections *> (gs);\n   omp_sections_stmt->control = control;\n }\n \n@@ -5232,7 +5232,7 @@ static inline void\n gimple_omp_for_set_cond (gimple gs, size_t i, enum tree_code cond)\n {\n   gimple_statement_omp_for *omp_for_stmt =\n-    as_a <gimple_statement_omp_for> (gs);\n+    as_a <gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (TREE_CODE_CLASS (cond) == tcc_comparison\n \t\t\t      && i < omp_for_stmt->collapse);\n   omp_for_stmt->iter[i].cond = cond;\n@@ -5245,7 +5245,7 @@ static inline enum tree_code\n gimple_omp_for_cond (const_gimple gs, size_t i)\n {\n   const gimple_statement_omp_for *omp_for_stmt =\n-    as_a <const gimple_statement_omp_for> (gs);\n+    as_a <const gimple_statement_omp_for *> (gs);\n   gcc_gimple_checking_assert (i < omp_for_stmt->collapse);\n   return omp_for_stmt->iter[i].cond;\n }\n@@ -5257,7 +5257,7 @@ static inline void\n gimple_omp_atomic_store_set_val (gimple g, tree val)\n {\n   gimple_statement_omp_atomic_store *omp_atomic_store_stmt =\n-    as_a <gimple_statement_omp_atomic_store> (g);\n+    as_a <gimple_statement_omp_atomic_store *> (g);\n   omp_atomic_store_stmt->val = val;\n }\n \n@@ -5268,7 +5268,7 @@ static inline tree\n gimple_omp_atomic_store_val (const_gimple g)\n {\n   const gimple_statement_omp_atomic_store *omp_atomic_store_stmt =\n-    as_a <const gimple_statement_omp_atomic_store> (g);\n+    as_a <const gimple_statement_omp_atomic_store *> (g);\n   return omp_atomic_store_stmt->val;\n }\n \n@@ -5279,7 +5279,7 @@ static inline tree *\n gimple_omp_atomic_store_val_ptr (gimple g)\n {\n   gimple_statement_omp_atomic_store *omp_atomic_store_stmt =\n-    as_a <gimple_statement_omp_atomic_store> (g);\n+    as_a <gimple_statement_omp_atomic_store *> (g);\n   return &omp_atomic_store_stmt->val;\n }\n \n@@ -5290,7 +5290,7 @@ static inline void\n gimple_omp_atomic_load_set_lhs (gimple g, tree lhs)\n {\n   gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <gimple_statement_omp_atomic_load> (g);\n+    as_a <gimple_statement_omp_atomic_load *> (g);\n   omp_atomic_load_stmt->lhs = lhs;\n }\n \n@@ -5301,7 +5301,7 @@ static inline tree\n gimple_omp_atomic_load_lhs (const_gimple g)\n {\n   const gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <const gimple_statement_omp_atomic_load> (g);\n+    as_a <const gimple_statement_omp_atomic_load *> (g);\n   return omp_atomic_load_stmt->lhs;\n }\n \n@@ -5312,7 +5312,7 @@ static inline tree *\n gimple_omp_atomic_load_lhs_ptr (gimple g)\n {\n   gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <gimple_statement_omp_atomic_load> (g);\n+    as_a <gimple_statement_omp_atomic_load *> (g);\n   return &omp_atomic_load_stmt->lhs;\n }\n \n@@ -5323,7 +5323,7 @@ static inline void\n gimple_omp_atomic_load_set_rhs (gimple g, tree rhs)\n {\n   gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <gimple_statement_omp_atomic_load> (g);\n+    as_a <gimple_statement_omp_atomic_load *> (g);\n   omp_atomic_load_stmt->rhs = rhs;\n }\n \n@@ -5334,7 +5334,7 @@ static inline tree\n gimple_omp_atomic_load_rhs (const_gimple g)\n {\n   const gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <const gimple_statement_omp_atomic_load> (g);\n+    as_a <const gimple_statement_omp_atomic_load *> (g);\n   return omp_atomic_load_stmt->rhs;\n }\n \n@@ -5345,7 +5345,7 @@ static inline tree *\n gimple_omp_atomic_load_rhs_ptr (gimple g)\n {\n   gimple_statement_omp_atomic_load *omp_atomic_load_stmt =\n-    as_a <gimple_statement_omp_atomic_load> (g);\n+    as_a <gimple_statement_omp_atomic_load *> (g);\n   return &omp_atomic_load_stmt->rhs;\n }\n \n@@ -5356,7 +5356,7 @@ static inline tree\n gimple_omp_continue_control_def (const_gimple g)\n {\n   const gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <const gimple_statement_omp_continue> (g);\n+    as_a <const gimple_statement_omp_continue *> (g);\n   return omp_continue_stmt->control_def;\n }\n \n@@ -5366,7 +5366,7 @@ static inline tree *\n gimple_omp_continue_control_def_ptr (gimple g)\n {\n   gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <gimple_statement_omp_continue> (g);\n+    as_a <gimple_statement_omp_continue *> (g);\n   return &omp_continue_stmt->control_def;\n }\n \n@@ -5376,7 +5376,7 @@ static inline void\n gimple_omp_continue_set_control_def (gimple g, tree def)\n {\n   gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <gimple_statement_omp_continue> (g);\n+    as_a <gimple_statement_omp_continue *> (g);\n   omp_continue_stmt->control_def = def;\n }\n \n@@ -5387,7 +5387,7 @@ static inline tree\n gimple_omp_continue_control_use (const_gimple g)\n {\n   const gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <const gimple_statement_omp_continue> (g);\n+    as_a <const gimple_statement_omp_continue *> (g);\n   return omp_continue_stmt->control_use;\n }\n \n@@ -5398,7 +5398,7 @@ static inline tree *\n gimple_omp_continue_control_use_ptr (gimple g)\n {\n   gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <gimple_statement_omp_continue> (g);\n+    as_a <gimple_statement_omp_continue *> (g);\n   return &omp_continue_stmt->control_use;\n }\n \n@@ -5409,7 +5409,7 @@ static inline void\n gimple_omp_continue_set_control_use (gimple g, tree use)\n {\n   gimple_statement_omp_continue *omp_continue_stmt =\n-    as_a <gimple_statement_omp_continue> (g);\n+    as_a <gimple_statement_omp_continue *> (g);\n   omp_continue_stmt->control_use = use;\n }\n \n@@ -5419,7 +5419,7 @@ static inline gimple_seq *\n gimple_transaction_body_ptr (gimple gs)\n {\n   gimple_statement_transaction *transaction_stmt =\n-    as_a <gimple_statement_transaction> (gs);\n+    as_a <gimple_statement_transaction *> (gs);\n   return &transaction_stmt->body;\n }\n \n@@ -5437,15 +5437,15 @@ static inline tree\n gimple_transaction_label (const_gimple gs)\n {\n   const gimple_statement_transaction *transaction_stmt =\n-    as_a <const gimple_statement_transaction> (gs);\n+    as_a <const gimple_statement_transaction *> (gs);\n   return transaction_stmt->label;\n }\n \n static inline tree *\n gimple_transaction_label_ptr (gimple gs)\n {\n   gimple_statement_transaction *transaction_stmt =\n-    as_a <gimple_statement_transaction> (gs);\n+    as_a <gimple_statement_transaction *> (gs);\n   return &transaction_stmt->label;\n }\n \n@@ -5464,7 +5464,7 @@ static inline void\n gimple_transaction_set_body (gimple gs, gimple_seq body)\n {\n   gimple_statement_transaction *transaction_stmt =\n-    as_a <gimple_statement_transaction> (gs);\n+    as_a <gimple_statement_transaction *> (gs);\n   transaction_stmt->body = body;\n }\n \n@@ -5474,7 +5474,7 @@ static inline void\n gimple_transaction_set_label (gimple gs, tree label)\n {\n   gimple_statement_transaction *transaction_stmt =\n-    as_a <gimple_statement_transaction> (gs);\n+    as_a <gimple_statement_transaction *> (gs);\n   transaction_stmt->label = label;\n }\n "}, {"sha": "4ff31fc6638c8aae61fb8b4b97ab48d2c5b809a8", "filename": "gcc/ipa-devirt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-devirt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-devirt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-devirt.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -619,7 +619,7 @@ build_type_inheritance_graph (void)\n   /* We reconstruct the graph starting of types of all methods seen in the\n      the unit.  */\n   FOR_EACH_SYMBOL (n)\n-    if (is_a <cgraph_node> (n)\n+    if (is_a <cgraph_node *> (n)\n \t&& DECL_VIRTUAL_P (n->decl)\n \t&& symtab_real_symbol_p (n))\n       get_odr_type (method_class_type (TREE_TYPE (n->decl)), true);\n@@ -643,7 +643,7 @@ build_type_inheritance_graph (void)\n        assume it is called externally or C is in anonymous namespace and\n        thus we will see the vtable.  */\n \n-    else if (is_a <varpool_node> (n)\n+    else if (is_a <varpool_node *> (n)\n \t     && DECL_VIRTUAL_P (n->decl)\n \t     && TREE_CODE (DECL_CONTEXT (n->decl)) == RECORD_TYPE\n \t     && TYPE_BINFO (DECL_CONTEXT (n->decl))"}, {"sha": "2bb37597a4a3dba8e20b119b01e9cc88d7672375", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -4253,7 +4253,7 @@ inline_write_summary (void)\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-      cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && cnode->definition && !cnode->alias)\n \tcount++;\n     }\n@@ -4262,7 +4262,7 @@ inline_write_summary (void)\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-      cgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n       if (cnode && (node = cnode)->definition && !node->alias)\n \t{\n \t  struct inline_summary *info = inline_summary (node);"}, {"sha": "df84c9cc1af352118fc1ddbbeda611cc86a36d2f", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -42,7 +42,7 @@ ipa_record_reference (symtab_node *referring_node,\n   struct ipa_ref_list *list, *list2;\n   ipa_ref_t *old_references;\n \n-  gcc_checking_assert (!stmt || is_a <cgraph_node> (referring_node));\n+  gcc_checking_assert (!stmt || is_a <cgraph_node *> (referring_node));\n   gcc_checking_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n   list = &referring_node->ref_list;"}, {"sha": "ebff60cdfee5a9493e7573d1f1dc7fa1a64c7477", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -466,7 +466,7 @@ analyze_function (struct cgraph_node *fn)\n   local = init_function_info (fn);\n   for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n     {\n-      if (!is_a <varpool_node> (ref->referred))\n+      if (!is_a <varpool_node *> (ref->referred))\n \tcontinue;\n       var = ipa_ref_varpool_node (ref)->decl;\n       if (!is_proper_for_analysis (var))\n@@ -973,7 +973,7 @@ ipa_reference_write_optimization_summary (void)\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-      varpool_node *vnode = dyn_cast <varpool_node> (snode);\n+      varpool_node *vnode = dyn_cast <varpool_node *> (snode);\n       if (vnode\n \t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n \t  && referenced_from_this_partition_p (&vnode->ref_list, encoder))\n@@ -991,7 +991,7 @@ ipa_reference_write_optimization_summary (void)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n \tsymtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-\tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+\tcgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n \tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  count++;\n       }\n@@ -1006,7 +1006,7 @@ ipa_reference_write_optimization_summary (void)\n     for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n       {\n \tsymtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-\tcgraph_node *cnode = dyn_cast <cgraph_node> (snode);\n+\tcgraph_node *cnode = dyn_cast <cgraph_node *> (snode);\n \tif (cnode && write_node_summary_p (cnode, encoder, ltrans_statics))\n \t  {\n \t    ipa_reference_optimization_summary_t info;"}, {"sha": "a14f024182016a06b604f7046a81a7861be8d24f", "filename": "gcc/ipa.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -387,7 +387,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t\t      before_inlining_p, reachable);\n \t}\n \n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \t{\n \t  /* Mark the callees reachable unless they are direct calls to extern\n  \t     inline functions we decided to not inline.  */\n@@ -465,7 +465,7 @@ symtab_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       /* When we see constructor of external variable, keep referred nodes in the\n \tboundary.  This will also hold initializers of the external vars NODE\n \trefers to.  */\n-      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode\n \t  && DECL_EXTERNAL (node->decl)\n \t  && !vnode->alias\n@@ -694,7 +694,7 @@ address_taken_from_non_vtable_p (symtab_node *node)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tvarpool_node *node;\n-\tif (is_a <cgraph_node> (ref->referring))\n+\tif (is_a <cgraph_node *> (ref->referring))\n \t  return true;\n \tnode = ipa_ref_referring_varpool_node (ref);\n \tif (!DECL_VIRTUAL_P (node->decl))\n@@ -732,7 +732,7 @@ comdat_can_be_unshared_p_1 (symtab_node *node)\n     return false;\n \n   /* Non-readonly and volatile variables can not be duplicated.  */\n-  if (is_a <varpool_node> (node)\n+  if (is_a <varpool_node *> (node)\n       && (!TREE_READONLY (node->decl)\n \t  || TREE_THIS_VOLATILE (node->decl)))\n     return false;"}, {"sha": "a14e344761af51b6bf491b9753cc301ae1987df9", "filename": "gcc/is-a.h", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fis-a.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fis-a.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fis-a.h?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -34,21 +34,21 @@ bool is_a <TYPE> (pointer)\n     Suppose you have a symtab_node *ptr, AKA symtab_node *ptr.  You can test\n     whether it points to a 'derived' cgraph_node as follows.\n \n-      if (is_a <cgraph_node> (ptr))\n+      if (is_a <cgraph_node *> (ptr))\n         ....\n \n \n-TYPE *as_a <TYPE> (pointer)\n+TYPE as_a <TYPE> (pointer)\n \n-    Converts pointer to a TYPE*.\n+    Converts pointer to a TYPE.\n \n     You can just assume that it is such a node.\n \n-      do_something_with (as_a <cgraph_node> *ptr);\n+      do_something_with (as_a <cgraph_node *> *ptr);\n \n-TYPE *dyn_cast <TYPE> (pointer)\n+TYPE dyn_cast <TYPE> (pointer)\n \n-    Converts pointer to TYPE* if and only if \"is_a <TYPE> pointer\".  Otherwise,\n+    Converts pointer to TYPE if and only if \"is_a <TYPE> pointer\".  Otherwise,\n     returns NULL.  This function is essentially a checked down cast.\n \n     This functions reduce compile time and increase type safety when treating a\n@@ -57,7 +57,7 @@ TYPE *dyn_cast <TYPE> (pointer)\n     You can test and obtain a pointer to the 'derived' type in one indivisible\n     operation.\n \n-      if (cgraph_node *cptr = dyn_cast <cgraph_node> (ptr))\n+      if (cgraph_node *cptr = dyn_cast <cgraph_node *> (ptr))\n         ....\n \n     As an example, the code change is from\n@@ -70,7 +70,7 @@ TYPE *dyn_cast <TYPE> (pointer)\n \n     to\n \n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n         {\n           ....\n         }\n@@ -88,7 +88,7 @@ TYPE *dyn_cast <TYPE> (pointer)\n \n     becomes\n \n-      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n       if (vnode && vnode->finalized)\n         varpool_analyze_node (vnode);\n \n@@ -110,7 +110,7 @@ example,\n   template <>\n   template <>\n   inline bool\n-  is_a_helper <cgraph_node>::test (symtab_node *p)\n+  is_a_helper <cgraph_node *>::test (symtab_node *p)\n   {\n     return p->type == SYMTAB_FUNCTION;\n   }\n@@ -122,7 +122,7 @@ when needed may result in a crash.  For example,\n   template <>\n   template <>\n   inline bool\n-  is_a_helper <cgraph_node>::cast (symtab_node *p)\n+  is_a_helper <cgraph_node *>::cast (symtab_node *p)\n   {\n     return &p->x_function;\n   }\n@@ -140,7 +140,7 @@ struct is_a_helper\n   template <typename U>\n   static inline bool test (U *p);\n   template <typename U>\n-  static inline T *cast (U *p);\n+  static inline T cast (U *p);\n };\n \n /* Note that we deliberately do not define the 'test' member template.  Not\n@@ -154,10 +154,10 @@ struct is_a_helper\n \n template <typename T>\n template <typename U>\n-inline T *\n+inline T\n is_a_helper <T>::cast (U *p)\n {\n-  return reinterpret_cast <T *> (p);\n+  return reinterpret_cast <T> (p);\n }\n \n \n@@ -178,7 +178,7 @@ is_a (U *p)\n    discussion above for when to use this function.  */\n \n template <typename T, typename U>\n-inline T *\n+inline T\n as_a (U *p)\n {\n   gcc_checking_assert (is_a <T> (p));\n@@ -189,13 +189,13 @@ as_a (U *p)\n    the discussion above for when to use this function.  */\n \n template <typename T, typename U>\n-inline T *\n+inline T\n dyn_cast (U *p)\n {\n   if (is_a <T> (p))\n     return is_a_helper <T>::cast (p);\n   else\n-    return static_cast <T *> (0);\n+    return static_cast <T> (0);\n }\n \n #endif  /* GCC_IS_A_H  */"}, {"sha": "58084cd0148aaff5ca5195f49ec0ab2a44c04bde", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -619,7 +619,7 @@ lto_output_ref (struct lto_simple_output_block *ob, struct ipa_ref *ref,\n   gcc_assert (nref != LCC_NOT_FOUND);\n   streamer_write_hwi_stream (ob->main_stream, nref);\n   \n-  node = dyn_cast <cgraph_node> (ref->referring);\n+  node = dyn_cast <cgraph_node *> (ref->referring);\n   if (node)\n     {\n       if (ref->stmt)\n@@ -753,7 +753,7 @@ add_references (lto_symtab_encoder_t encoder,\n   int i;\n   struct ipa_ref *ref;\n   for (i = 0; ipa_ref_list_reference_iterate (list, i, ref); i++)\n-    if (is_a <cgraph_node> (ref->referred))\n+    if (is_a <cgraph_node *> (ref->referred))\n       add_node_to (encoder, ipa_ref_node (ref), false);\n     else\n       lto_symtab_encoder_encode (encoder, ref->referred);\n@@ -819,7 +819,7 @@ compute_ltrans_boundary (lto_symtab_encoder_t in_encoder)\n   for (i = 0; i < lto_symtab_encoder_size (encoder); i++)\n     {\n       symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n-      if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+      if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n \t{\n \t  if (!lto_symtab_encoder_encode_initializer_p (encoder,\n \t\t\t\t\t\t\tvnode)\n@@ -913,7 +913,7 @@ output_symtab (void)\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n         lto_output_node (ob, cnode, encoder);\n       else\n         lto_output_varpool_node (ob, varpool (node), encoder);\n@@ -1199,7 +1199,7 @@ input_ref (struct lto_input_block *ib,\n   node = nodes[streamer_read_hwi (ib)];\n   ref = ipa_record_reference (referring_node, node, use, NULL);\n   ref->speculative = speculative;\n-  if (is_a <cgraph_node> (referring_node))\n+  if (is_a <cgraph_node *> (referring_node))\n     ref->lto_stmt_uid = streamer_read_hwi (ib);\n }\n \n@@ -1316,12 +1316,12 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   /* AUX pointers should be all non-zero for function nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n   FOR_EACH_VEC_ELT (nodes, i, node)\n-    gcc_assert (node->aux || !is_a <cgraph_node> (node));\n+    gcc_assert (node->aux || !is_a <cgraph_node *> (node));\n #endif\n   FOR_EACH_VEC_ELT (nodes, i, node)\n     {\n       int ref;\n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \t{\n \t  ref = (int) (intptr_t) cnode->global.inlined_to;\n \n@@ -1346,7 +1346,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n \tnode->same_comdat_group = NULL;\n     }\n   FOR_EACH_VEC_ELT (nodes, i, node)\n-    node->aux = is_a <cgraph_node> (node) ? (void *)1 : NULL;\n+    node->aux = is_a <cgraph_node *> (node) ? (void *)1 : NULL;\n   return nodes;\n }\n \n@@ -1696,15 +1696,15 @@ output_cgraph_opt_summary (void)\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n-      cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n       if (cnode && output_cgraph_opt_summary_p (cnode))\n \tcount++;\n     }\n   streamer_write_uhwi (ob, count);\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node *node = lto_symtab_encoder_deref (encoder, i);\n-      cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+      cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n       if (cnode && output_cgraph_opt_summary_p (cnode))\n \t{\n \t  streamer_write_uhwi (ob, i);"}, {"sha": "a40fd19b464e571b00eb448ffd03b5b30f1406d7", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -2067,7 +2067,7 @@ lto_output (void)\n   for (i = 0; i < n_nodes; i++)\n     {\n       symtab_node *snode = lto_symtab_encoder_deref (encoder, i);\n-      if (cgraph_node *node = dyn_cast <cgraph_node> (snode))\n+      if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t{\n \t  if (lto_symtab_encoder_encode_body_p (encoder, node)\n \t      && !node->alias)\n@@ -2087,7 +2087,7 @@ lto_output (void)\n \t      lto_record_function_out_decl_state (node->decl, decl_state);\n \t    }\n \t}\n-      else if (varpool_node *node = dyn_cast <varpool_node> (snode))\n+      else if (varpool_node *node = dyn_cast <varpool_node *> (snode))\n \t{\n \t  /* Wrap symbol references inside the ctor in a type\n \t     preserving MEM_REF.  */\n@@ -2344,7 +2344,7 @@ output_symbol_p (symtab_node *node)\n   /* We keep external functions in symtab for sake of inlining\n      and devirtualization.  We do not want to see them in symbol table as\n      references unless they are really used.  */\n-  cnode = dyn_cast <cgraph_node> (node);\n+  cnode = dyn_cast <cgraph_node *> (node);\n   if (cnode && (!node->definition || DECL_EXTERNAL (cnode->decl))\n       && cnode->callers)\n     return true;\n@@ -2362,7 +2362,7 @@ output_symbol_p (symtab_node *node)\n \t{\n \t  if (ref->use == IPA_REF_ALIAS)\n \t    continue;\n-          if (is_a <cgraph_node> (ref->referring))\n+          if (is_a <cgraph_node *> (ref->referring))\n \t    return true;\n \t  if (!DECL_EXTERNAL (ref->referring->decl))\n \t    return true;"}, {"sha": "ca6646585895f9cd5bd3690deb9be4358dda47eb", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -1139,7 +1139,7 @@ lsei_next_function_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n   while (!lsei_end_p (*lsei)\n-\t && (!is_a <cgraph_node> (lsei_node (*lsei))\n+\t && (!is_a <cgraph_node *> (lsei_node (*lsei))\n \t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n     lsei_next (lsei);\n }\n@@ -1152,7 +1152,7 @@ lsei_start_function_in_partition (lto_symtab_encoder_t encoder)\n \n   if (lsei_end_p (lsei))\n     return lsei;\n-  if (!is_a <cgraph_node> (lsei_node (lsei))\n+  if (!is_a <cgraph_node *> (lsei_node (lsei))\n       || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n     lsei_next_function_in_partition (&lsei);\n \n@@ -1165,7 +1165,7 @@ lsei_next_variable_in_partition (lto_symtab_encoder_iterator *lsei)\n {\n   lsei_next (lsei);\n   while (!lsei_end_p (*lsei)\n-\t && (!is_a <varpool_node> (lsei_node (*lsei))\n+\t && (!is_a <varpool_node *> (lsei_node (*lsei))\n \t     || !lto_symtab_encoder_in_partition_p (lsei->encoder, lsei_node (*lsei))))\n     lsei_next (lsei);\n }\n@@ -1178,7 +1178,7 @@ lsei_start_variable_in_partition (lto_symtab_encoder_t encoder)\n \n   if (lsei_end_p (lsei))\n     return lsei;\n-  if (!is_a <varpool_node> (lsei_node (lsei))\n+  if (!is_a <varpool_node *> (lsei_node (lsei))\n       || !lto_symtab_encoder_in_partition_p (encoder, lsei_node (lsei)))\n     lsei_next_variable_in_partition (&lsei);\n "}, {"sha": "f1ecec9e02785aecbaae0de346d002bfac5f17f1", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -1,3 +1,16 @@\n+2014-04-23  David Malcolm  <dmalcolm@redhat.com>\n+\n+\t* lto-partition.c (add_references_to_partition): Update for\n+\tremoval of implicit pointer from the is-a.h API.\n+\t(add_symbol_to_partition_1): Likewise.\n+\t(contained_in_symbol): Likewise.\n+\t(undo_partition): Likewise.\n+\t(lto_balanced_map): Likewise.\n+\t(promote_symbol): Likewise.\n+\t* lto-symtab.c (lto_symtab_merge_symbols_1): Likewise.\n+\t(lto_symtab_merge_symbols): Likewise.\n+\t* lto.c (lto_wpa_write_files): Likewise.\n+\n 2014-04-15  Richard Biener  <rguenther@suse.de>\n \n \t* lto.c: Include params.h."}, {"sha": "5a8c843b77544f21288ef8b1a7ef2ed2acdd17c2", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -95,7 +95,7 @@ add_references_to_partition (ltrans_partition part, symtab_node *node)\n     /* References to a readonly variable may be constant foled into its value.\n        Recursively look into the initializers of the constant variable and add\n        references, too.  */\n-    else if (is_a <varpool_node> (ref->referred)\n+    else if (is_a <varpool_node *> (ref->referred)\n \t     && ctor_for_folding (ref->referred->decl) != error_mark_node\n \t     && !lto_symtab_encoder_in_partition_p (part->encoder, ref->referred))\n       {\n@@ -146,7 +146,7 @@ add_symbol_to_partition_1 (ltrans_partition part, symtab_node *node)\n     }\n   node->aux = (void *)((size_t)node->aux + 1);\n \n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     {\n       struct cgraph_edge *e;\n       if (!node->alias)\n@@ -194,14 +194,14 @@ contained_in_symbol (symtab_node *node)\n   /* Weakrefs are never contained in anything.  */\n   if (node->weakref)\n     return node;\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     {\n       cnode = cgraph_function_node (cnode, NULL);\n       if (cnode->global.inlined_to)\n \tcnode = cnode->global.inlined_to;\n       return cnode;\n     }\n-  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+  else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n     return varpool_variable_node (vnode, NULL);\n   return node;\n }\n@@ -252,7 +252,7 @@ undo_partition (ltrans_partition partition, unsigned int n_nodes)\n \tpointer_set_destroy (partition->initializers_visited);\n       partition->initializers_visited = NULL;\n \n-      if (!node->alias && (cnode = dyn_cast <cgraph_node> (node)))\n+      if (!node->alias && (cnode = dyn_cast <cgraph_node *> (node)))\n         partition->insns -= inline_summary (cnode)->self_size;\n       lto_symtab_encoder_delete_node (partition->encoder, node);\n       node->aux = (void *)((size_t)node->aux - 1);\n@@ -522,7 +522,7 @@ lto_balanced_map (int n_lto_partitions)\n \t  symtab_node *snode = lto_symtab_encoder_deref (partition->encoder,\n \t\t\t\t\t\t\tlast_visited_node);\n \n-\t  if (cgraph_node *node = dyn_cast <cgraph_node> (snode))\n+\t  if (cgraph_node *node = dyn_cast <cgraph_node *> (snode))\n \t    {\n \t      struct cgraph_edge *edge;\n \n@@ -577,7 +577,7 @@ lto_balanced_map (int n_lto_partitions)\n \t  /* Compute boundary cost of IPA REF edges and at the same time look into\n \t     variables referenced from current partition and try to add them.  */\n \t  for (j = 0; ipa_ref_list_reference_iterate (refs, j, ref); j++)\n-\t    if (is_a <varpool_node> (ref->referred))\n+\t    if (is_a <varpool_node *> (ref->referred))\n \t      {\n \t\tint index;\n \n@@ -611,7 +611,7 @@ lto_balanced_map (int n_lto_partitions)\n \t\t  cost++;\n \t      }\n \t  for (j = 0; ipa_ref_list_referring_iterate (refs, j, ref); j++)\n-\t    if (is_a <varpool_node> (ref->referring))\n+\t    if (is_a <varpool_node *> (ref->referring))\n \t      {\n \t\tint index;\n \n@@ -811,7 +811,7 @@ promote_symbol (symtab_node *node)\n static bool\n may_need_named_section_p (lto_symtab_encoder_t encoder, symtab_node *node)\n {\n-  struct cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+  struct cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n   if (!cnode)\n     return false;\n   if (symtab_real_symbol_p (node))"}, {"sha": "5486e737f763de2d2e729627eae48f7c7c9fd550", "filename": "gcc/lto/lto-symtab.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-symtab.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -560,10 +560,10 @@ lto_symtab_merge_symbols_1 (symtab_node *prevailing)\n \n       if (!lto_symtab_symbol_p (e))\n \tcontinue;\n-      cgraph_node *ce = dyn_cast <cgraph_node> (e);\n+      cgraph_node *ce = dyn_cast <cgraph_node *> (e);\n       if (ce && !DECL_BUILT_IN (e->decl))\n \tlto_cgraph_replace_node (ce, cgraph (prevailing));\n-      if (varpool_node *ve = dyn_cast <varpool_node> (e))\n+      if (varpool_node *ve = dyn_cast <varpool_node *> (e))\n \tlto_varpool_replace_node (ve, varpool (prevailing));\n     }\n \n@@ -609,7 +609,7 @@ lto_symtab_merge_symbols (void)\n \t    }\n \t  node->aux = NULL;\n \n-\t  if (!(cnode = dyn_cast <cgraph_node> (node))\n+\t  if (!(cnode = dyn_cast <cgraph_node *> (node))\n \t      || !cnode->clone_of\n \t      || cnode->clone_of->decl != cnode->decl)\n \t    {\n@@ -624,11 +624,11 @@ lto_symtab_merge_symbols (void)\n \t      /* The user defined assembler variables are also not unified by their\n \t\t symbol name (since it is irrelevant), but we need to unify symbol\n \t\t nodes if tree merging occured.  */\n-\t      if ((vnode = dyn_cast <varpool_node> (node))\n+\t      if ((vnode = dyn_cast <varpool_node *> (node))\n \t\t  && DECL_HARD_REGISTER (vnode->decl)\n \t\t  && (node2 = symtab_get_node (vnode->decl))\n \t\t  && node2 != node)\n-\t\tlto_varpool_replace_node (dyn_cast <varpool_node> (node2),\n+\t\tlto_varpool_replace_node (dyn_cast <varpool_node *> (node2),\n \t\t\t\t\t  vnode);\n \t  \n "}, {"sha": "5f4478a58a8a45c961a9d466a52633d0aedeb545", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -2625,13 +2625,13 @@ lto_wpa_write_files (void)\n \t      if (!lto_symtab_encoder_in_partition_p (part->encoder, node))\n \t\t{\n \t          fprintf (cgraph_dump_file, \"%s \", node->asm_name ());\n-\t\t  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+\t\t  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \t\t  if (cnode\n \t\t      && lto_symtab_encoder_encode_body_p (part->encoder, cnode))\n \t\t    fprintf (cgraph_dump_file, \"(body included)\");\n \t\t  else\n \t\t    {\n-\t\t      varpool_node *vnode = dyn_cast <varpool_node> (node);\n+\t\t      varpool_node *vnode = dyn_cast <varpool_node *> (node);\n \t\t      if (vnode\n \t\t\t  && lto_symtab_encoder_encode_initializer_p (part->encoder, vnode))\n \t\t\tfprintf (cgraph_dump_file, \"(initializer included)\");"}, {"sha": "f948e77425977d460f99365ee0af3323bed46e96", "filename": "gcc/symtab.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -192,7 +192,7 @@ eq_assembler_name (const void *p1, const void *p2)\n static void\n insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n {\n-  if (is_a <varpool_node> (node) && DECL_HARD_REGISTER (node->decl))\n+  if (is_a <varpool_node *> (node) && DECL_HARD_REGISTER (node->decl))\n     return;\n   gcc_checking_assert (!node->previous_sharing_asm_name\n \t\t       && !node->next_sharing_asm_name);\n@@ -214,7 +214,7 @@ insert_to_assembler_name_hash (symtab_node *node, bool with_clones)\n       *aslot = node;\n \n       /* Update also possible inline clones sharing a decl.  */\n-      cnode = dyn_cast <cgraph_node> (node);\n+      cnode = dyn_cast <cgraph_node *> (node);\n       if (cnode && cnode->clones && with_clones)\n \tfor (cnode = cnode->clones; cnode; cnode = cnode->next_sibling_clone)\n \t  if (cnode->decl == decl)\n@@ -258,7 +258,7 @@ unlink_from_assembler_name_hash (symtab_node *node, bool with_clones)\n       node->previous_sharing_asm_name = NULL;\n \n       /* Update also possible inline clones sharing a decl.  */\n-      cnode = dyn_cast <cgraph_node> (node);\n+      cnode = dyn_cast <cgraph_node *> (node);\n       if (cnode && cnode->clones && with_clones)\n \tfor (cnode = cnode->clones; cnode; cnode = cnode->next_sibling_clone)\n \t  if (cnode->decl == decl)\n@@ -364,14 +364,14 @@ symtab_unregister_node (symtab_node *node)\n   if (slot && *slot && *slot == node)\n     {\n       symtab_node *replacement_node = NULL;\n-      if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+      if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n \treplacement_node = cgraph_find_replacement_node (cnode);\n       if (!replacement_node)\n \thtab_clear_slot (symtab_hash, slot);\n       else\n \t*slot = replacement_node;\n     }\n-  if (!is_a <varpool_node> (node) || !DECL_HARD_REGISTER (node->decl))\n+  if (!is_a <varpool_node *> (node) || !DECL_HARD_REGISTER (node->decl))\n     unlink_from_assembler_name_hash (node, false);\n }\n \n@@ -411,9 +411,9 @@ symtab_get_node (const_tree decl)\n void\n symtab_remove_node (symtab_node *node)\n {\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     cgraph_remove_node (cnode);\n-  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+  else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n     varpool_remove_node (vnode);\n }\n \n@@ -690,9 +690,9 @@ dump_symtab_base (FILE *f, symtab_node *node)\n void\n dump_symtab_node (FILE *f, symtab_node *node)\n {\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     dump_cgraph_node (f, cnode);\n-  else if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+  else if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n     dump_varpool_node (f, vnode);\n }\n \n@@ -731,15 +731,15 @@ verify_symtab_base (symtab_node *node)\n   bool error_found = false;\n   symtab_node *hashed_node;\n \n-  if (is_a <cgraph_node> (node))\n+  if (is_a <cgraph_node *> (node))\n     {\n       if (TREE_CODE (node->decl) != FUNCTION_DECL)\n \t{\n           error (\"function symbol is not function\");\n           error_found = true;\n \t}\n     }\n-  else if (is_a <varpool_node> (node))\n+  else if (is_a <varpool_node *> (node))\n     {\n       if (TREE_CODE (node->decl) != VAR_DECL)\n \t{\n@@ -762,9 +762,9 @@ verify_symtab_base (symtab_node *node)\n \t  error_found = true;\n \t}\n       if (hashed_node != node\n-\t  && (!is_a <cgraph_node> (node)\n-\t      || !dyn_cast <cgraph_node> (node)->clone_of\n-\t      || dyn_cast <cgraph_node> (node)->clone_of->decl\n+\t  && (!is_a <cgraph_node *> (node)\n+\t      || !dyn_cast <cgraph_node *> (node)->clone_of\n+\t      || dyn_cast <cgraph_node *> (node)->clone_of->decl\n \t\t != node->decl))\n \t{\n \t  error (\"node differs from symtab decl hashtable\");\n@@ -786,7 +786,7 @@ verify_symtab_base (symtab_node *node)\n \t  hashed_node = hashed_node->next_sharing_asm_name;\n \t}\n       if (!hashed_node\n-          && !(is_a <varpool_node> (node)\n+          && !(is_a <varpool_node *> (node)\n \t       || DECL_HARD_REGISTER (node->decl)))\n \t{\n           error (\"node not found in symtab assembler name hash\");\n@@ -878,7 +878,7 @@ verify_symtab_node (symtab_node *node)\n     return;\n \n   timevar_push (TV_CGRAPH_VERIFY);\n-  if (cgraph_node *cnode = dyn_cast <cgraph_node> (node))\n+  if (cgraph_node *cnode = dyn_cast <cgraph_node *> (node))\n     verify_cgraph_node (cnode);\n   else\n     if (verify_symtab_base (node))\n@@ -973,7 +973,7 @@ symtab_make_decl_local (tree decl)\n enum availability\n symtab_node_availability (symtab_node *node)\n {\n-  if (is_a <cgraph_node> (node))\n+  if (is_a <cgraph_node *> (node))\n     return cgraph_function_body_availability (cgraph (node));\n   else\n     return cgraph_variable_initializer_availability (varpool (node));\n@@ -1061,7 +1061,7 @@ symtab_alias_ultimate_target (symtab_node *node, enum availability *availability\n void\n fixup_same_cpp_alias_visibility (symtab_node *node, symtab_node *target)\n {\n-  if (is_a <cgraph_node> (node))\n+  if (is_a <cgraph_node *> (node))\n     {\n       DECL_DECLARED_INLINE_P (node->decl)\n \t = DECL_DECLARED_INLINE_P (target->decl);\n@@ -1108,9 +1108,9 @@ symtab_resolve_alias (symtab_node *node, symtab_node *target)\n        n = n->analyzed ? symtab_alias_target (n) : NULL)\n     if (n == node)\n        {\n-\t if (is_a <cgraph_node> (node))\n+\t if (is_a <cgraph_node *> (node))\n            error (\"function %q+D part of alias cycle\", node->decl);\n-         else if (is_a <varpool_node> (node))\n+         else if (is_a <varpool_node *> (node))\n            error (\"variable %q+D part of alias cycle\", node->decl);\n \t else\n \t   gcc_unreachable ();\n@@ -1277,7 +1277,7 @@ symtab_get_symbol_partitioning_class (symtab_node *node)\n {\n   /* Inline clones are always duplicated.\n      This include external delcarations.   */\n-  cgraph_node *cnode = dyn_cast <cgraph_node> (node);\n+  cgraph_node *cnode = dyn_cast <cgraph_node *> (node);\n \n   if (DECL_ABSTRACT (node->decl))\n     return SYMBOL_EXTERNAL;\n@@ -1293,7 +1293,7 @@ symtab_get_symbol_partitioning_class (symtab_node *node)\n   if (DECL_EXTERNAL (node->decl))\n     return SYMBOL_EXTERNAL;\n \n-  if (varpool_node *vnode = dyn_cast <varpool_node> (node))\n+  if (varpool_node *vnode = dyn_cast <varpool_node *> (node))\n     {\n       /* Constant pool references use local symbol names that can not\n          be promoted global.  We should never put into a constant pool"}, {"sha": "0be431e60680c823721bf477546f59740dd749bb", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -115,7 +115,7 @@ allocate_phi_node (size_t len)\n       && gimple_phi_capacity ((*free_phinodes[bucket])[0]) >= len)\n     {\n       free_phinode_count--;\n-      phi = as_a <gimple_statement_phi> (free_phinodes[bucket]->pop ());\n+      phi = as_a <gimple_statement_phi *> (free_phinodes[bucket]->pop ());\n       if (free_phinodes[bucket]->is_empty ())\n \tvec_free (free_phinodes[bucket]);\n       if (GATHER_STATISTICS)\n@@ -297,7 +297,7 @@ reserve_phi_args_for_new_edge (basic_block bb)\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       gimple_statement_phi *stmt =\n-\tas_a <gimple_statement_phi> (gsi_stmt (gsi));\n+\tas_a <gimple_statement_phi *> (gsi_stmt (gsi));\n \n       if (len > gimple_phi_capacity (stmt))\n \t{\n@@ -436,7 +436,7 @@ remove_phi_args (edge e)\n   gimple_stmt_iterator gsi;\n \n   for (gsi = gsi_start_phis (e->dest); !gsi_end_p (gsi); gsi_next (&gsi))\n-    remove_phi_arg_num (as_a <gimple_statement_phi> (gsi_stmt (gsi)),\n+    remove_phi_arg_num (as_a <gimple_statement_phi *> (gsi_stmt (gsi)),\n \t\t\te->dest_idx);\n }\n "}, {"sha": "69172c69dbaea892b2ef8025e4fbc09666e97c2f", "filename": "gcc/varpool.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7de90a6c2758d158283211ac98fea71dd1483831/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=7de90a6c2758d158283211ac98fea71dd1483831", "patch": "@@ -238,7 +238,7 @@ varpool_node *\n varpool_node_for_asm (tree asmname)\n {\n   if (symtab_node *node = symtab_node_for_asm (asmname))\n-    return dyn_cast <varpool_node> (node);\n+    return dyn_cast <varpool_node *> (node);\n   else\n     return NULL;\n }\n@@ -521,14 +521,14 @@ varpool_remove_unreferenced_decls (void)\n \t       next != node;\n \t       next = next->same_comdat_group)\n \t    {\n-\t      varpool_node *vnext = dyn_cast <varpool_node> (next);\n+\t      varpool_node *vnext = dyn_cast <varpool_node *> (next);\n \t      if (vnext && vnext->analyzed && !symtab_comdat_local_p (next))\n \t\tenqueue_node (vnext, &first);\n \t    }\n \t}\n       for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n \t{\n-\t  varpool_node *vnode = dyn_cast <varpool_node> (ref->referred);\n+\t  varpool_node *vnode = dyn_cast <varpool_node *> (ref->referred);\n \t  if (vnode\n \t      && !vnode->in_other_partition\n \t      && (!DECL_EXTERNAL (ref->referred->decl)"}]}