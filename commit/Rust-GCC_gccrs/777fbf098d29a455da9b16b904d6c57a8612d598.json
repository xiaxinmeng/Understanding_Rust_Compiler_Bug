{"sha": "777fbf098d29a455da9b16b904d6c57a8612d598", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Nzc3ZmJmMDk4ZDI5YTQ1NWRhOWIxNmI5MDRkNmM1N2E4NjEyZDU5OA==", "commit": {"author": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-03-12T00:25:59Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "1997-03-12T00:25:59Z"}, "message": "mn10300.c (expand_prologue): Rework so that eliminating the frame pointer produces faster/smaller code.\n\n        * mn10300/mn10300.c (expand_prologue): Rework so that eliminating\n        the frame pointer produces faster/smaller code.\n        (expand_epilogue): Likewise.\n        (initial_offset): New function for argument pointer and frame pointer\n        elimination.\n        * mn10300/mn10300.h (FIRST_PSEUDO_REGISTER): Bump to 10.\n        (FIXED_REGISTERS): Add argument pointer register, it's a fake fixed\n        register.\n        (CALL_USED_REGISTERS, REG_ALLOC_ORDER): Corresponding changes.\n        (REGNO_REG_CLASS, REG_CLASS_CONTENTS): Likewise.\n        (REG_OK_FOR_BASE_P, REGISTER_NAMES): Likewise.\n        (reg_class, REG_CLASS_NAMES): Delete unwanted DATA_OR_SP_REGS class.\n        (PREFERRED_OUTPUT_RELOAD_CLASS): Define.\n        (FIRST_PARM_OFFSET): No longer include register save area in\n        computation.\n        (STACK_POINTER_REGNUM): Is now register 9.\n        (ARG_POINTER_REGNUM): Is now register 8.\n        (FRAME_POINTER_REQUIRED): Refine.\n        (ELIMINABLE_REGS, INITIAL_ELIMINATION_OFFSET): Define.\n        (CAN_DEUG_WITHOUT_FP): Define.\n        * mn10300/mn10300.md (return_internal): Break into two patterns.\n\n        * mn10300/mn10300.h (CONST_OK_FOR_LETTER_P): Handle 'M' too.\n        (REGISTER_MOVE_COST): Fix errors and refine.\n\n        * mn10300/mn10300.c (notice_update_cc): SET_ZN_C0 insns leave the\n        overflow bit in an unuseable state.  Rename CC_SET to CC_TST.\n        * mn10300/mn10300.md (cc attributes): \"set\" is gone, replaced by\n        \"tst\".  Update attributes on various insns.\n\n        * mn10300/mn10300.md: Improve sign and zero extension instructions.\n        (ashlsi3): Improve.  Handle address registers too.\n        (add peephole): Combine two consecutive adjustments of a register\n        into a single adjustment.\n\nFrom-SVN: r13700", "tree": {"sha": "3a87d29bb567cfe92d07c2b8ca567f507d8a4936", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3a87d29bb567cfe92d07c2b8ca567f507d8a4936"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/777fbf098d29a455da9b16b904d6c57a8612d598", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777fbf098d29a455da9b16b904d6c57a8612d598", "html_url": "https://github.com/Rust-GCC/gccrs/commit/777fbf098d29a455da9b16b904d6c57a8612d598", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/777fbf098d29a455da9b16b904d6c57a8612d598/comments", "author": null, "committer": null, "parents": [{"sha": "e9b1360b4952466ae1e4189b4002b131c95e649d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9b1360b4952466ae1e4189b4002b131c95e649d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9b1360b4952466ae1e4189b4002b131c95e649d"}], "stats": {"total": 272, "additions": 185, "deletions": 87}, "files": [{"sha": "13a9774567dafb95777b9b10ad091ee6db48b075", "filename": "gcc/config/mn10300/mn10300.c", "status": "modified", "additions": 61, "deletions": 25, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.c?ref=777fbf098d29a455da9b16b904d6c57a8612d598", "patch": "@@ -213,14 +213,18 @@ expand_prologue ()\n {\n   unsigned int size = get_frame_size ();\n \n-  /* For simplicity, we just movm all the callee saved registers to\n-     the stack with one instruction, then set up the frame pointer\n-     (if needed), and finally allocate the new stack.  */\n-  emit_insn (gen_store_movm ());\n-\n+  /* And now store all the registers onto the stack with a\n+     single two byte instruction.  */\n+  if (regs_ever_live[2] || regs_ever_live[3]\n+      || regs_ever_live[6] || regs_ever_live[7]\n+      || frame_pointer_needed)\n+    emit_insn (gen_store_movm ());\n+\n+  /* Now put the frame pointer into the frame pointer register.  */\n   if (frame_pointer_needed)\n     emit_move_insn (frame_pointer_rtx, stack_pointer_rtx);\n \n+  /* Allocate stack for this frame.  */\n   if (size)\n     emit_insn (gen_addsi3 (stack_pointer_rtx,\n \t\t\t   stack_pointer_rtx,\n@@ -246,8 +250,23 @@ expand_epilogue ()\n       size = 0;\n     }\n \n-  /* Deallocate remaining stack, restore registers and return.  And return.  */\n-  emit_jump_insn (gen_return_internal (GEN_INT (size)));\n+  /* For simplicity, we just movm all the callee saved registers to\n+     the stack with one instruction.\n+\n+     ?!? Only save registers which are actually used.  Reduces\n+     stack requireents and is faster.  */\n+  if (regs_ever_live[2] || regs_ever_live[3]\n+      || regs_ever_live[6] || regs_ever_live[7]\n+      || frame_pointer_needed)\n+    emit_jump_insn (gen_return_internal_regs (GEN_INT (size)));\n+  else\n+    {\n+      if (size)\n+\temit_insn (gen_addsi3 (stack_pointer_rtx,\n+\t\t\t       stack_pointer_rtx,\n+\t\t\t       GEN_INT (size)));\n+      emit_jump_insn (gen_return_internal ());\n+    }\n }\n \n /* Update the condition code from the insn.  */\n@@ -275,14 +294,13 @@ notice_update_cc (body, insn)\n \t V is always set to 0.  C may or may not be set to 0 but that's ok\n \t because alter_cond will change tests to use EQ/NE.  */\n       CC_STATUS_INIT;\n-      cc_status.flags |= CC_NO_OVERFLOW;\n+      cc_status.flags |= CC_NO_OVERFLOW | CC_OVERFLOW_UNUSABLE;\n       cc_status.value1 = recog_operand[0];\n       break;\n \n-    case CC_SET:\n+    case CC_TST:\n       /* The insn sets all the condition codes, except v is bogus.  */\n       CC_STATUS_INIT;\n-      cc_status.flags |= CC_OVERFLOW_UNUSABLE;\n       cc_status.value1 = recog_operand[0];\n       break;\n \n@@ -334,27 +352,45 @@ secondary_reload_class (class, mode, in)\n \n   /* We can't directly load sp + const_int into a data register;\n      we must use an address register as an intermediate.  */\n-  if (class == DATA_REGS\n+  if (class != SP_REGS\n+      && class != ADDRESS_REGS\n+      && class != SP_OR_ADDRESS_REGS\n       && (in == stack_pointer_rtx\n \t  || (GET_CODE (in) == PLUS\n- \t      && XEXP (in, 0) == stack_pointer_rtx)))\n+\t      && (XEXP (in, 0) == stack_pointer_rtx\n+\t\t  || XEXP (in, 1) == stack_pointer_rtx))))\n     return ADDRESS_REGS;\n \n-  /* Get the true register.  */\n-  if (GET_CODE (in) == REG)\n+  /* Otherwise assume no secondary reloads are needed.  */\n+  return NO_REGS;\n+}\n+\n+int\n+initial_offset (from, to)\n+     int from, to;\n+{\n+  if (from == ARG_POINTER_REGNUM && to == FRAME_POINTER_REGNUM)\n     {\n-      regno = REGNO (in);\n-      if (regno >= FIRST_PSEUDO_REGISTER)\n-        regno = true_regnum (in);\n+      if (regs_ever_live[2] || regs_ever_live[3]\n+\t  || regs_ever_live[6] || regs_ever_live[7]\n+\t  || frame_pointer_needed)\n+\treturn 20;\n+      else\n+\treturn 4;\n     }\n \n-  /* We can't copy directly from a data register into the stack\n-     pointer.  */\n-  if (class == SP_REGS\n-      && GET_CODE (in) == REG\n-      && regno < 4)\n-    return ADDRESS_REGS;\n+  if (from == ARG_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    {\n+      if (regs_ever_live[2] || regs_ever_live[3]\n+\t  || regs_ever_live[6] || regs_ever_live[7]\n+\t  || frame_pointer_needed)\n+\treturn get_frame_size () + 20;\n+      else\n+\treturn get_frame_size () + 4;\n+    }\n \n-  /* Otherwise assume no secondary reloads are needed.  */\n-  return NO_REGS;\n+  if (from == FRAME_POINTER_REGNUM && to == STACK_POINTER_REGNUM)\n+    return get_frame_size ();\n+\n+  abort ();\n }"}, {"sha": "2a49eb1f680938f8f144434ec87ac8485d074551", "filename": "gcc/config/mn10300/mn10300.h", "status": "modified", "additions": 63, "deletions": 34, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.h?ref=777fbf098d29a455da9b16b904d6c57a8612d598", "patch": "@@ -131,13 +131,13 @@ extern int target_flags;\n    All registers that the compiler knows about must be given numbers,\n    even those that are not normally considered general registers.  */\n \n-#define FIRST_PSEUDO_REGISTER 9\n+#define FIRST_PSEUDO_REGISTER 10\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n-  { 0, 0, 0, 0, 0, 0, 0, 0, 1}\n+  { 0, 0, 0, 0, 0, 0, 0, 0, 1, 1}\n \n /* 1 for registers not available across function calls.\n    These must include the FIXED_REGISTERS and also any\n@@ -148,10 +148,10 @@ extern int target_flags;\n    like.  */\n \n #define CALL_USED_REGISTERS \\\n-  { 1, 1, 0, 0, 1, 1, 0, 0, 1}\n+  { 1, 1, 0, 0, 1, 1, 0, 0, 1, 1}\n \n #define REG_ALLOC_ORDER \\\n-  { 0, 1, 4, 5, 2, 3, 6, 7, 8}\n+  { 0, 1, 4, 5, 2, 3, 6, 7, 8, 9}\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n@@ -202,7 +202,7 @@ extern int target_flags;\n    class that represents their union.  */\n    \n enum reg_class {\n-  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS, DATA_OR_ADDRESS_REGS, DATA_OR_SP_REGS, SP_OR_ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n+  NO_REGS, DATA_REGS, ADDRESS_REGS, SP_REGS, DATA_OR_ADDRESS_REGS, SP_OR_ADDRESS_REGS, GENERAL_REGS, ALL_REGS, LIM_REG_CLASSES\n };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n@@ -211,8 +211,8 @@ enum reg_class {\n \n #define REG_CLASS_NAMES \\\n { \"NO_REGS\", \"DATA_REGS\", \"ADDRESS_REGS\", \\\n-  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"DATA_OR_SP_REGS\", \\\n-  \"SP_OR_ADDRESS_REGS\",\t\"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n+  \"SP_REGS\", \"DATA_OR_ADDRESS_REGS\", \"SP_OR_ADDRESS_REGS\", \\\n+  \"GENERAL_REGS\", \"ALL_REGS\", \"LIM_REGS\" }\n \n /* Define which registers fit in which classes.\n    This is an initializer for a vector of HARD_REG_SET\n@@ -221,13 +221,12 @@ enum reg_class {\n #define REG_CLASS_CONTENTS  \t\t\t\\\n {      0,\t\t/* No regs      */\t\\\n    0x00f,\t\t/* DATA_REGS */\t\t\\\n-   0x0f0,\t\t/* ADDRESS_REGS */\t\\\n-   0x100,\t\t/* SP_REGS */\t\t\\\n-   0x0ff,\t\t/* DATA_OR_ADDRESS_REGS */\\\n-   0x00f,\t\t/* DATA_OR_SP_REGS */\t\\\n-   0x0f0,\t\t/* SP_OR_ADDRESS_REGS */\\\n-   0x0ff,\t\t/* GENERAL_REGS */    \t\\\n-   0x0ff,\t\t/* ALL_REGS \t*/\t\\\n+   0x1f0,\t\t/* ADDRESS_REGS */\t\\\n+   0x200,\t\t/* SP_REGS */\t\t\\\n+   0x1ff,\t\t/* DATA_OR_ADDRESS_REGS */\\\n+   0x1f0,\t\t/* SP_OR_ADDRESS_REGS */\\\n+   0x1ff,\t\t/* GENERAL_REGS */    \t\\\n+   0x3ff,\t\t/* ALL_REGS \t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -237,8 +236,8 @@ enum reg_class {\n \n #define REGNO_REG_CLASS(REGNO) \\\n   ((REGNO) < 4 ? DATA_REGS : \\\n-   (REGNO) < 8 ? ADDRESS_REGS : \\\n-    (REGNO) == 8 ? SP_REGS: 0)\n+   (REGNO) < 9 ? ADDRESS_REGS : \\\n+    (REGNO) == 9 ? SP_REGS: 0)\n \n /* The class value for index registers, and the one for base regs.  */\n \n@@ -277,6 +276,9 @@ enum reg_class {\n #define PREFERRED_RELOAD_CLASS(X,CLASS) \\\n   (X == stack_pointer_rtx && CLASS != SP_REGS ? ADDRESS_REGS : CLASS)\n \n+#define PREFERRED_OUTPUT_RELOAD_CLASS(X,CLASS) \\\n+  (X == stack_pointer_rtx && CLASS != SP_REGS ? ADDRESS_REGS : CLASS)\n+\n #define LIMIT_RELOAD_CLASS(MODE, CLASS) \\\n   ((MODE == QImode || MODE == HImode) ? DATA_REGS : CLASS)\n \n@@ -302,12 +304,14 @@ enum reg_class {\n #define CONST_OK_FOR_J(VALUE) ((VALUE) == 1)\n #define CONST_OK_FOR_K(VALUE) ((VALUE) == 2)\n #define CONST_OK_FOR_L(VALUE) ((VALUE) == 4)\n+#define CONST_OK_FOR_M(VALUE) ((VALUE) == 3)\n \n #define CONST_OK_FOR_LETTER_P(VALUE, C) \\\n   ((C) == 'I' ? CONST_OK_FOR_I (VALUE) : \\\n    (C) == 'J' ? CONST_OK_FOR_J (VALUE) : \\\n    (C) == 'K' ? CONST_OK_FOR_K (VALUE) : \\\n-   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : 0)\n+   (C) == 'L' ? CONST_OK_FOR_L (VALUE) : \\\n+   (C) == 'M' ? CONST_OK_FOR_M (VALUE) : 0)\n \n \n /* Similar, but for floating constants, and defining letters G and H.\n@@ -343,38 +347,62 @@ enum reg_class {\n /* Is equal to the size of the saved fp + pc, even if an fp isn't\n    saved since the value is used before we know.  */\n \n-#define FIRST_PARM_OFFSET(FNDECL) (-4 + 20)\n+#define FIRST_PARM_OFFSET(FNDECL) -4\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n \n /* Register to use for pushing function arguments.  */\n-#define STACK_POINTER_REGNUM 8\n+#define STACK_POINTER_REGNUM 9\n \n /* Base register for access to local variables of the function.  */\n #define FRAME_POINTER_REGNUM 7\n \n-/* Base register for access to arguments of the function.  */\n-#define ARG_POINTER_REGNUM 7\n+/* Base register for access to arguments of the function.  This\n+   is a fake register and will be eliminated into either the frame\n+   pointer or stack pointer.  */\n+#define ARG_POINTER_REGNUM 8\n \n /* Register in which static-chain is passed to a function.  */\n #define STATIC_CHAIN_REGNUM 5\n \n /* Value should be nonzero if functions must have frame pointers.\n    Zero means the frame pointer need not be set up (and parms\n    may be accessed via the stack pointer) in functions that seem suitable.\n-   This is computed in `reload', in reload1.c. \n+   This is computed in `reload', in reload1.c.\n+\n+   We allow frame pointers to be eliminated when not having one will\n+   not interfere with debugging.\n+\n+     * If this is a leaf function, then we can keep the stack pointer\n+     constant throughout the function, and therefore gdb can easily\n+     find the base of the current frame.\n+\n+     * If this function never allocates stack space for outgoing\n+     args (ie calls functions with either no args, or args only\n+     in registers), then the stack pointer will be constant and\n+     gdb can easily find the base of the current frame.\n+\n+     We'd really like to define ACCUMULATE_OUTGOING_ARGS and eliminate\n+     all frame pointer, but currently we can't.\n+\n+     We probably also want a -m option to eliminate frame pointer, even\n+     if the resulting executable can not be debugged.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+ { ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+#define CAN_ELIMINATE(FROM, TO) 1\n \n-   Currently we always need a frame pointer.  In the future we'd like\n-   to be able to eliminate it.  */\n-#define FRAME_POINTER_REQUIRED 1\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+  OFFSET = initial_offset (FROM, TO)\n \n-/* Store in the variable DEPTH the initial difference between the\n-   frame pointer reg contents and the stack pointer reg contents,\n-   as of the start of the function body.  This depends on the layout\n-   of the fixed parts of the stack frame and on how registers are saved.  */\n+#define FRAME_POINTER_REQUIRED \\\n+  !(leaf_function_p () || current_function_outgoing_args_size == 0)\n \n-#define INITIAL_FRAME_POINTER_OFFSET(DEPTH) (DEPTH) = 20\n+#define CAN_DEBUG_WITHOUT_FP\n \n /* A guess for the MN10300.  */\n #define PROMOTE_PROTOTYPES 1\n@@ -565,7 +593,7 @@ enum reg_class {\n /* Nonzero if X is a hard reg that can be used as a base reg\n    or if it is a pseudo reg.  */\n #define REG_OK_FOR_BASE_P(X) \\\n-  ((REGNO (X) >= 4 && REGNO(X) <= 8) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+  ((REGNO (X) >= 4 && REGNO(X) <= 9) || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n #else\n /* Nonzero if X is a hard reg that can be used as an index.  */\n #define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n@@ -609,7 +637,7 @@ enum reg_class {\n \t{\t\t\t\t\t\t\\\n \t  if (GET_CODE (index) == CONST_INT)\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n-\t  if (GET_CODE (index) == REG\t\t\t\\\n+\t  if (REG_P (index)\t\t\t\t\\\n \t      && REG_OK_FOR_INDEX_P (index))\t\t\\\n \t    goto ADDR;\t\t\t\t\t\\\n \t}\t\t\t\t\t\t\\\n@@ -666,7 +694,7 @@ enum reg_class {\n   default: { int _zxy= const_costs(RTX, CODE);\t\\\n \t     if(_zxy) return _zxy; break;}\n \n-#define REGISTER_MOVE_COST(CLASS1, CLASS2)  3\n+#define REGISTER_MOVE_COST(CLASS1, CLASS2)  (CLASS1 != CLASS2 ? 4 : 0)\n \n /* A crude cut at RTX_COSTS for the MN10300.  */\n \n@@ -808,7 +836,7 @@ do { char dstr[30];\t\t\t\t\t\\\n    This sequence is indexed by compiler's hard-register-number (see above).  */\n \n #define REGISTER_NAMES \\\n-{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"sp\" }\n+{ \"d0\", \"d1\", \"d2\", \"d3\", \"a0\", \"a1\", \"a2\", \"a3\", \"ap\", \"sp\" }\n \n /* Print an instruction operand X on file FILE.\n    look in mn10300.c for details */\n@@ -913,3 +941,4 @@ extern void expand_epilogue ();\n extern void notice_update_cc ();\n extern int call_address_operand ();\n extern enum reg_class secondary_reload_class ();\n+extern int initial_offset ();"}, {"sha": "3089e8a2a3ec229a8121bb1d28fc1cc5c99a2d33", "filename": "gcc/config/mn10300/mn10300.md", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/777fbf098d29a455da9b16b904d6c57a8612d598/gcc%2Fconfig%2Fmn10300%2Fmn10300.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmn10300%2Fmn10300.md?ref=777fbf098d29a455da9b16b904d6c57a8612d598", "patch": "@@ -36,7 +36,7 @@\n ;;\tbe known (if it isn't that's ok, we don't need it anyway).\n ;; compare - compare instruction\n ;; clobber - value of cc is unknown\n-(define_attr \"cc\" \"none,none_0hit,set,set_zn_c0,compare,clobber\"\n+(define_attr \"cc\" \"none,none_0hit,tst,set_zn_c0,compare,clobber\"\n   (const_string \"clobber\"))\n \f\n ;; ----------------------------------------------------------------------\n@@ -178,12 +178,12 @@\n   [(set (cc0) (match_operand:SI 0 \"register_operand\" \"da\"))]\n   \"\"\n   \"cmp 0,%0\"\n-  [(set_attr \"cc\" \"set_zn_c0\")])\n+  [(set_attr \"cc\" \"tst\")])\n \n (define_insn \"cmpsi\"\n   [(set (cc0)\n \t(compare:SI (match_operand:SI 0 \"register_operand\" \"da\")\n-\t\t    (match_operand:SI 1 \"nonmemory_operand\" \"dai\")))]\n+\t\t    (match_operand:SI 1 \"register_operand\" \"dai\")))]\n   \"\"\n   \"cmp %1,%0\"\n   [(set_attr \"cc\" \"compare\")])\n@@ -223,7 +223,7 @@\n   inc4 %0\n   add %2,%0\n   add %2,%0\"\n-  [(set_attr \"cc\" \"set,none_0hit,none_0hit,set,none_0hit\")])\n+  [(set_attr \"cc\" \"set_zn_c0,none_0hit,none_0hit,set_zn_c0,none_0hit\")])\n \n ;; ----------------------------------------------------------------------\n ;; SUBTRACT INSTRUCTIONS\n@@ -235,7 +235,7 @@\n \t\t  (match_operand:SI 2 \"register_operand\" \"dai\")))]\n   \"\"\n   \"sub %2,%0\"\n-  [(set_attr \"cc\" \"set\")])\n+  [(set_attr \"cc\" \"set_zn_c0\")])\n \n (define_expand \"negsi2\"\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n@@ -571,38 +571,48 @@\n ;; EXTEND INSTRUCTIONS\n ;; ----------------------------------------------------------------------\n \n-(define_insn \"zero_extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+(define_insn \"zero_extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n \t(zero_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"0\")))]\n+\t (match_operand:QI 1 \"general_operand\" \"0,d,m\")))]\n   \"\"\n-  \"exthu %0\"\n+  \"@\n+  extbu %0\n+  mov %1,%0\\;extbu %0\n+  movbu %1,%0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n-(define_insn \"zero_extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+(define_insn \"zero_extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d,d\")\n \t(zero_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"0\")))]\n+\t (match_operand:HI 1 \"general_operand\" \"0,d,m\")))]\n   \"\"\n-  \"extbu %0\"\n+  \"@\n+  exthu %0\n+  mov %1,%0\\;exthu %0\n+  movhu %1,%0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n ;;- sign extension instructions\n \n-(define_insn \"extendhisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+(define_insn \"extendqisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n \t(sign_extend:SI\n-\t (match_operand:HI 1 \"register_operand\" \"0\")))]\n+\t (match_operand:QI 1 \"general_operand\" \"0,d\")))]\n   \"\"\n-  \"exth %0\"\n+  \"@\n+  extb %0\n+  mov %1,%0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n-(define_insn \"extendqisi2\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n+(define_insn \"extendhisi2\"\n+  [(set (match_operand:SI 0 \"general_operand\" \"=d,d\")\n \t(sign_extend:SI\n-\t (match_operand:QI 1 \"register_operand\" \"0\")))]\n+\t (match_operand:HI 1 \"general_operand\" \"0,d\")))]\n   \"\"\n-  \"extb %0\"\n+  \"@\n+  exth %0\n+  mov %1,%0\"\n   [(set_attr \"cc\" \"none_0hit\")])\n \n \f\n@@ -611,13 +621,19 @@\n ;; ----------------------------------------------------------------------\n \n (define_insn \"ashlsi3\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d,d\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=da,d,a,d,a,d,a,d\")\n \t(ashift:SI\n-\t (match_operand:SI 1 \"register_operand\" \"0,0\")\n-\t (match_operand:QI 2 \"nonmemory_operand\" \"K,di\")))]\n+\t (match_operand:SI 1 \"register_operand\" \"0,0,0,0,0,0,0,0\")\n+\t (match_operand:QI 2 \"nonmemory_operand\" \"J,K,K,M,M,L,L,di\")))]\n   \"\"\n   \"@\n+  add %0,%0\n   asl2 %0\n+  add %0,%0\\;add %0,%0\n+  asl2 %0\\;add %0,%0\n+  add %0,%0\\;add %0,%0\\;add %0,%0\n+  asl2 %0\\;asl2 %0\n+  add %0,%0\\;add %0,%0\\;add %0,%0\\;add %0,%0\n   asl %2,%0\"\n   [(set_attr \"cc\" \"set_zn_c0\")])\n \n@@ -656,15 +672,15 @@\n   DONE;\n }\")\n \n-(define_insn \"return\"\n-  [(return)]\n-  \"0\"\n+(define_insn \"return_internal\"\n+  [(const_int 2)]\n+  \"\"\n   \"rets\"\n   [(set_attr \"cc\" \"clobber\")])\n \n ;; This insn restores the callee saved registers and does a return, it\n ;; can also deallocate stack space.\n-(define_insn \"return_internal\"\n+(define_insn \"return_internal_regs\"\n   [(const_int 0)\n    (match_operand:SI 0  \"const_int_operand\" \"i\")\n    (return)]\n@@ -677,3 +693,20 @@\n   \"\"\n   \"movm [d2,d3,a2,a3],(sp)\"\n   [(set_attr \"cc\" \"clobber\")])\n+\n+;; Try to combine consecutive updates of the stack pointer (or any\n+;; other register for that matter).\n+(define_peephole\n+  [(set (match_operand:SI 0 \"register_operand\" \"=dax\")\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand 1 \"const_int_operand\" \"\")))\n+   (set (match_dup 0)\n+\t(plus:SI (match_dup 0)\n+\t\t (match_operand 2 \"const_int_operand\" \"\")))]\n+  \"\"\n+  \"*\n+{\n+  operands[1] = GEN_INT (INTVAL (operands[2]) + INTVAL (operands[1]));\n+  return \\\"add %1,%0\\\";\n+}\"\n+  [(set_attr \"cc\" \"clobber\")])"}]}