{"sha": "1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWViN2IwNDkwNDcwYWQzNjkwZmIzMWVkNDc5OTAwOGViZGYxZTIxZg==", "commit": {"author": {"name": "Dirk Mueller", "email": "dmueller@suse.de", "date": "2007-01-21T16:12:10Z"}, "committer": {"name": "Dirk Mueller", "email": "mueller@gcc.gnu.org", "date": "2007-01-21T16:12:10Z"}, "message": "re PR bootstrap/30511 (False array bound check causes gcc failed to boostrap)\n\n2007-01-21  Dirk Mueller  <dmueller@suse.de>\n\n        PR bootstrap/30511\n        * tree-vrp.c (check_array_bounds): do not warn\n        about ADDR_EXPR's of ARRAY_REF's which are immediately\n        used in binary expressions.\n\nFrom-SVN: r121032", "tree": {"sha": "e98cb630de12d5eb716512e618033f5078e643d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e98cb630de12d5eb716512e618033f5078e643d0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1eb7b0490470ad3690fb31ed4799008ebdf1e21f/comments", "author": null, "committer": null, "parents": [{"sha": "e9e90c1f98233c09b734988f2a481a1476bd2266", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e9e90c1f98233c09b734988f2a481a1476bd2266", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e9e90c1f98233c09b734988f2a481a1476bd2266"}], "stats": {"total": 44, "additions": 34, "deletions": 10}, "files": [{"sha": "742e60fe45ac1b6fba4dd0da8ba738e2f1f63f42", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb7b0490470ad3690fb31ed4799008ebdf1e21f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb7b0490470ad3690fb31ed4799008ebdf1e21f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "patch": "@@ -1,3 +1,10 @@\n+2007-01-21  Dirk Mueller  <dmueller@suse.de>\n+\n+\tPR bootstrap/30511\n+\t* tree-vrp.c (check_array_bounds): do not warn\n+\tabout ADDR_EXPR's of ARRAY_REF's which are immediately\n+\tused in binary expressions.\n+\n 2007-01-21  Ira Rosen  <irar@il.ibm.com>\n \n \t* tree-vectorizer.h (struct _stmt_vec_info): Add new field "}, {"sha": "6fb2a7271ba09dad49163c2f42fd3d60adf1934e", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1eb7b0490470ad3690fb31ed4799008ebdf1e21f/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1eb7b0490470ad3690fb31ed4799008ebdf1e21f/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=1eb7b0490470ad3690fb31ed4799008ebdf1e21f", "patch": "@@ -3564,26 +3564,43 @@ static tree\n check_array_bounds (tree *tp, int *walk_subtree, void *data)\n {\n   tree t = *tp;\n-  location_t *location = EXPR_LOCUS ((tree) data);\n+  tree stmt = (tree)data;\n+  location_t *location = EXPR_LOCUS (stmt);\n \n   *walk_subtree = TRUE;\n \n   if (TREE_CODE (t) == ARRAY_REF)\n     check_array_ref (t, location, false /*ignore_off_by_one*/);\n   else if (TREE_CODE (t) == ADDR_EXPR)\n     {\n+       use_operand_p op;\n+       tree use_stmt;\n        t = TREE_OPERAND (t, 0);\n \n        /* Don't warn on statements like\n-          ssa_name = 500 + &array[-200] which are sometimes\n-          produced by various optimizing passes.  */\n-       if (TREE_CODE ((tree)data) == GIMPLE_MODIFY_STMT\n-           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND ((tree)data, 1)))\n-         {\n-           *walk_subtree = FALSE;\n-           return NULL_TREE;\n-         }\n-       while (handled_component_p (t))\n+\n+          ssa_name = 500 + &array[-200]\n+\n+          or\n+\n+          ssa_name = &array[-200]\n+          other_name = ssa_name + 300;\n+\n+          which are sometimes\n+          produced by other optimizing passes.  */\n+\n+       if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND (stmt, 1)))\n+         *walk_subtree = FALSE;\n+\n+       if (TREE_CODE (stmt) == GIMPLE_MODIFY_STMT\n+           && TREE_CODE (GIMPLE_STMT_OPERAND (stmt, 0)) == SSA_NAME\n+           && single_imm_use (GIMPLE_STMT_OPERAND (stmt, 0), &op, &use_stmt)\n+           && TREE_CODE (use_stmt) == GIMPLE_MODIFY_STMT\n+           && BINARY_CLASS_P (GIMPLE_STMT_OPERAND (use_stmt, 1)))\n+         *walk_subtree = FALSE;\n+\n+       while (*walk_subtree && handled_component_p (t))\n          {\n            if (TREE_CODE (t) == ARRAY_REF)\n              check_array_ref (t, location, true /*ignore_off_by_one*/);"}]}