{"sha": "e79d51963378b10ab90544a7d8eeb6266e9a57f6", "node_id": "C_kwDOANBUbNoAKGU3OWQ1MTk2MzM3OGIxMGFiOTA1NDRhN2Q4ZWViNjI2NmU5YTU3ZjY", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-15T23:50:16Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2022-12-15T23:50:16Z"}, "message": "c++: variadic using-decl with parm pack in terminal name [PR102104]\n\nThere's a curious corner case with variadic member using-decls: the\nterminal name can also contain a parameter pack, and only through naming\na conversion function, e.g.\n\n  using A<Ts>::operator Ts...;\n\nWe currently only handle parameter packs appearing in the qualifying\nscope of a variadic using-decl; this patch adds support for the above\ncase as well, representing such a using-decl via two pack expansions,\none for the qualifying scope and one for the terminal name (despite\nlogically there being just one).  Then at instantiation time we manually\nmerge them.\n\n\tPR c++/102104\n\tPR c++/108090\n\ngcc/cp/ChangeLog:\n\n\t* error.cc (dump_decl) <case USING_DECL>: Look through a\n\tpack expansion in the name as well.\n\t* parser.cc (cp_parser_using_declaration): Handle a parameter\n\tpack appearing in the terminal name of a variadic using-decl.\n\t* pt.cc (tsubst_decl) <case USING_DECL>: Likewise.  Combine the\n\thandling of variadic and non-variadic using-decls.\n\ngcc/testsuite/ChangeLog:\n\n\t* g++.dg/cpp1z/using-variadic1.C: New test.\n\t* g++.dg/cpp1z/using-variadic1a.C: New test.\n\t* g++.dg/cpp1z/using-variadic1b.C: New test.\n\t* g++.dg/cpp1z/using-variadic1c.C: New test.\n\t* g++.dg/cpp1z/using-variadic2.C: New test.\n\t* g++.dg/cpp1z/using-variadic3.C: New test.", "tree": {"sha": "268e1db420be13769feae29da9fe3a4dcbf2f7a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/268e1db420be13769feae29da9fe3a4dcbf2f7a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e79d51963378b10ab90544a7d8eeb6266e9a57f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79d51963378b10ab90544a7d8eeb6266e9a57f6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e79d51963378b10ab90544a7d8eeb6266e9a57f6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e79d51963378b10ab90544a7d8eeb6266e9a57f6/comments", "author": null, "committer": null, "parents": [{"sha": "57ab3714b6c436032ca440f9432c5837928de969", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57ab3714b6c436032ca440f9432c5837928de969", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57ab3714b6c436032ca440f9432c5837928de969"}], "stats": {"total": 295, "additions": 268, "deletions": 27}, "files": [{"sha": "e7f60335cc06f4f8161954af16f20d0b12d8fd64", "filename": "gcc/cp/error.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Ferror.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Ferror.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.cc?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -1477,11 +1477,20 @@ dump_decl (cxx_pretty_printer *pp, tree t, int flags)\n \tif (!(flags & TFF_UNQUALIFIED_NAME))\n \t  {\n \t    tree scope = USING_DECL_SCOPE (t);\n+\t    tree name = DECL_NAME (t);\n \t    if (PACK_EXPANSION_P (scope))\n \t      {\n \t\tscope = PACK_EXPANSION_PATTERN (scope);\n \t\tvariadic = true;\n \t      }\n+\t    if (identifier_p (name)\n+\t\t&& IDENTIFIER_CONV_OP_P (name)\n+\t\t&& PACK_EXPANSION_P (TREE_TYPE (name)))\n+\t      {\n+\t\tname = make_conv_op_name (PACK_EXPANSION_PATTERN\n+\t\t\t\t\t  (TREE_TYPE (name)));\n+\t\tvariadic = true;\n+\t      }\n \t    dump_type (pp, scope, flags);\n \t    pp_cxx_colon_colon (pp);\n \t  }"}, {"sha": "bfd8aeae39f69d0fd9e1e51a41991410799c5398", "filename": "gcc/cp/parser.cc", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Fparser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Fparser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.cc?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -21708,7 +21708,36 @@ cp_parser_using_declaration (cp_parser* parser,\n \tpedwarn (ell->location, OPT_Wc__17_extensions,\n \t\t \"pack expansion in using-declaration only available \"\n \t\t \"with %<-std=c++17%> or %<-std=gnu++17%>\");\n-      qscope = make_pack_expansion (qscope);\n+\n+      /* A parameter pack can appear in the qualifying scope, and/or in the\n+\t terminal name (if naming a conversion function).  Logically they're\n+\t part of a single pack expansion of the overall USING_DECL, but we\n+\t express them as separate pack expansions within the USING_DECL since\n+\t we can't create a pack expansion over a USING_DECL.  */\n+      bool saw_parm_pack = false;\n+      if (uses_parameter_packs (qscope))\n+\t{\n+\t  qscope = make_pack_expansion (qscope);\n+\t  saw_parm_pack = true;\n+\t}\n+      if (identifier_p (identifier)\n+\t  && IDENTIFIER_CONV_OP_P (identifier)\n+\t  && uses_parameter_packs (TREE_TYPE (identifier)))\n+\t{\n+\t  identifier = make_conv_op_name (make_pack_expansion\n+\t\t\t\t\t  (TREE_TYPE (identifier)));\n+\t  saw_parm_pack = true;\n+\t}\n+      if (!saw_parm_pack)\n+\t{\n+\t  /* Issue an error in terms using a SCOPE_REF that includes both\n+\t     components.  */\n+\t  tree name\n+\t    = build_qualified_name (NULL_TREE, qscope, identifier, false);\n+\t  make_pack_expansion (name);\n+\t  gcc_assert (seen_error ());\n+\t  qscope = identifier = error_mark_node;\n+\t}\n     }\n \n   /* The function we call to handle a using-declaration is different"}, {"sha": "bc566ab702b883dd0d949198270db57a08034e03", "filename": "gcc/cp/pt.cc", "status": "modified", "additions": 64, "deletions": 26, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Fpt.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Fcp%2Fpt.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.cc?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -14962,43 +14962,81 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n       if (DECL_DEPENDENT_P (t)\n \t  || uses_template_parms (USING_DECL_SCOPE (t)))\n \t{\n+\t  /* True iff this using-decl was written as a pack expansion\n+\t     (and a pack appeared in its scope or name).  If a pack\n+\t     appeared in both, we expand the packs separately and\n+\t     manually merge them.  */\n+\t  bool variadic_p = false;\n+\n \t  tree scope = USING_DECL_SCOPE (t);\n-\t  tree name = tsubst_copy (DECL_NAME (t), args, complain, in_decl);\n \t  if (PACK_EXPANSION_P (scope))\n \t    {\n-\t      tree vec = tsubst_pack_expansion (scope, args, complain, in_decl);\n-\t      int len = TREE_VEC_LENGTH (vec);\n-\t      r = make_tree_vec (len);\n-\t      for (int i = 0; i < len; ++i)\n+\t      scope = tsubst_pack_expansion (scope, args, complain, in_decl);\n+\t      variadic_p = true;\n+\t    }\n+\t  else\n+\t    scope = tsubst_copy (scope, args, complain, in_decl);\n+\n+\t  tree name = DECL_NAME (t);\n+\t  if (IDENTIFIER_CONV_OP_P (name)\n+\t      && PACK_EXPANSION_P (TREE_TYPE (name)))\n+\t    {\n+\t      name = tsubst_pack_expansion (TREE_TYPE (name), args,\n+\t\t\t\t\t    complain, in_decl);\n+\t      if (name == error_mark_node)\n \t\t{\n-\t\t  tree escope = TREE_VEC_ELT (vec, i);\n-\t\t  tree elt = do_class_using_decl (escope, name);\n-\t\t  if (!elt)\n-\t\t    {\n-\t\t      r = error_mark_node;\n-\t\t      break;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_PROTECTED (elt) = TREE_PROTECTED (t);\n-\t\t      TREE_PRIVATE (elt) = TREE_PRIVATE (t);\n-\t\t    }\n-\t\t  TREE_VEC_ELT (r, i) = elt;\n+\t\t  r = error_mark_node;\n+\t\t  break;\n \t\t}\n+\t      for (tree& elt : tree_vec_range (name))\n+\t\telt = make_conv_op_name (elt);\n+\t      variadic_p = true;\n \t    }\n \t  else\n+\t    name = tsubst_copy (name, args, complain, in_decl);\n+\n+\t  int len;\n+\t  if (!variadic_p)\n+\t    len = 1;\n+\t  else if (TREE_CODE (scope) == TREE_VEC\n+\t\t   && TREE_CODE (name) == TREE_VEC)\n \t    {\n-\t      tree inst_scope = tsubst_copy (USING_DECL_SCOPE (t), args,\n-\t\t\t\t\t     complain, in_decl);\n-\t      r = do_class_using_decl (inst_scope, name);\n-\t      if (!r)\n-\t\tr = error_mark_node;\n-\t      else\n+\t      if (TREE_VEC_LENGTH (scope) != TREE_VEC_LENGTH (name))\n \t\t{\n-\t\t  TREE_PROTECTED (r) = TREE_PROTECTED (t);\n-\t\t  TREE_PRIVATE (r) = TREE_PRIVATE (t);\n+\t\t  error (\"mismatched argument pack lengths (%d vs %d)\",\n+\t\t\t TREE_VEC_LENGTH (scope), TREE_VEC_LENGTH (name));\n+\t\t  r = error_mark_node;\n+\t\t  break;\n \t\t}\n+\t      len = TREE_VEC_LENGTH (scope);\n \t    }\n+\t  else if (TREE_CODE (scope) == TREE_VEC)\n+\t    len = TREE_VEC_LENGTH (scope);\n+\t  else /* TREE_CODE (name) == TREE_VEC  */\n+\t    len = TREE_VEC_LENGTH (name);\n+\n+\t  r = make_tree_vec (len);\n+\t  for (int i = 0; i < len; ++i)\n+\t    {\n+\t      tree escope = (TREE_CODE (scope) == TREE_VEC\n+\t\t\t     ? TREE_VEC_ELT (scope, i)\n+\t\t\t     : scope);\n+\t      tree ename = (TREE_CODE (name) == TREE_VEC\n+\t\t\t    ? TREE_VEC_ELT (name, i)\n+\t\t\t    : name);\n+\t      tree elt = do_class_using_decl (escope, ename);\n+\t      if (!elt)\n+\t\t{\n+\t\t  r = error_mark_node;\n+\t\t  break;\n+\t\t}\n+\t      TREE_PROTECTED (elt) = TREE_PROTECTED (t);\n+\t      TREE_PRIVATE (elt) = TREE_PRIVATE (t);\n+\t      TREE_VEC_ELT (r, i) = elt;\n+\t    }\n+\n+\t  if (!variadic_p && r != error_mark_node)\n+\t    r = TREE_VEC_ELT (r, 0);\n \t}\n       else\n \t{"}, {"sha": "7a8bcbbe37291a4a2f5f1c18675837abd5a3017e", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1.C", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,29 @@\n+// PR c++/102104\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls : private Bases... {\n+  using Bases::operator typename Bases::target_type...;\n+};\n+\n+cls<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<B> v2;\n+bool* a2 = v2; // { dg-error \"cannot convert\" }\n+long* b2 = v2;\n+\n+cls<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"cannot convert\" }"}, {"sha": "0393cab6ace1c566de73c6198c1531abe651ba01", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1a.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1a.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,34 @@\n+// PR c++/102104\n+// A version of using-variadic1.C where the qualifying scope and the\n+// terminal name of the using-declaration use different parameter packs.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Bases... {\n+    using Bases::operator typename Ts::target_type...;\n+  };\n+};\n+\n+cls<A, B>::nested<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<B>::nested<B> v2;\n+bool* a2 = v2; // { dg-error \"cannot convert\" }\n+long* b2 = v2;\n+\n+cls<A>::nested<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"cannot convert\" }"}, {"sha": "fd3a41718b6c9a0ae72769443a2bbce61b5034fa", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1b.C", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1b.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,37 @@\n+// PR c++/102104\n+// A version of using-variadic1.C where only the qualifying scope\n+// uses a parameter pack.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+};\n+\n+struct B {\n+  using target_type = long*;\n+};\n+\n+struct C {\n+  operator bool*();\n+  operator long*();\n+};\n+\n+template<typename Base>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Base {\n+    using Base::operator typename Ts::target_type...;\n+  };\n+};\n+\n+cls<C>::nested<A, B> v1;\n+bool* a1 = v1;\n+long* b1 = v1;\n+\n+cls<C>::nested<B> v2;\n+bool* a2 = v2; // { dg-error \"inaccessible|not an accessible\" }\n+long* b2 = v2;\n+\n+cls<C>::nested<A> v3;\n+bool* a3 = v3;\n+long* b3 = v3; // { dg-error \"inaccessible|not an accessible\" }"}, {"sha": "aa86b28fd2e02ea5c8cfd90e64695208fd09ae40", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic1c.C", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic1c.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,33 @@\n+// PR c++/102104\n+// A version of of using-variadic1.C where only the terminal name\n+// uses a parameter pack.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  operator bool*();\n+};\n+\n+struct B {\n+  operator bool*();\n+};\n+\n+struct C {\n+  using target_type = bool*;\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class T>\n+  struct nested : private Bases... {\n+    using Bases::operator typename T::target_type...;\n+  };\n+};\n+\n+cls<A, B>::nested<C> v1;\n+bool* a1 = v1; // { dg-error \"ambiguous\" }\n+\n+cls<A>::nested<C> v2;\n+bool* a2 = v2;\n+\n+cls<B>::nested<C> v3;\n+bool* a3 = v3;"}, {"sha": "1d68ceece8a5b35cd7cb97988a0272004dcd62f5", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic2.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic2.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,24 @@\n+// PR c++/102104\n+// A version of using-variadic1a.C where the argument packs have\n+// different lengths.\n+// { dg-do compile { target c++17 } }\n+\n+struct A {\n+  using target_type = bool*;\n+  operator bool*();\n+};\n+\n+struct B {\n+  using target_type = long*;\n+  operator long*();\n+};\n+\n+template<typename... Bases>\n+struct cls {\n+  template<class... Ts>\n+  struct nested : private Bases... {\n+    using Bases::operator typename Ts::target_type...; // { dg-error \"lengths\" }\n+  };\n+};\n+\n+cls<A>::nested<A, B> v1; // { dg-message \"required from here\" }"}, {"sha": "4e1d6894e5610c8a3fd3e59dceb6ed0eea6177db", "filename": "gcc/testsuite/g++.dg/cpp1z/using-variadic3.C", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e79d51963378b10ab90544a7d8eeb6266e9a57f6/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fusing-variadic3.C?ref=e79d51963378b10ab90544a7d8eeb6266e9a57f6", "patch": "@@ -0,0 +1,8 @@\n+// PR c++/108090\n+// { dg-do compile { target c++17 } }\n+\n+template<typename T> struct As { operator T(); };\n+template<typename ...T> struct AsAll : As<T>... {\n+  using As<T>::operator T...;\n+};\n+AsAll<int, float, char> x;"}]}