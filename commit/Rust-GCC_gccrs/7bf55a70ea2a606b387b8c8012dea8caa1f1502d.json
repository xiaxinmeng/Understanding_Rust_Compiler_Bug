{"sha": "7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2JmNTVhNzBlYTJhNjA2YjM4N2I4YzgwMTJkZWE4Y2FhMWYxNTAyZA==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.vnet.ibm.com", "date": "2013-05-07T14:11:21Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2013-05-07T14:11:21Z"}, "message": "gimple-ssa-strength-reduction.c (MAX_INCR_VEC_LEN): New constant.\n\n2013-05-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n\n\t* gimple-ssa-strength-reduction.c (MAX_INCR_VEC_LEN): New constant.\n\t(incr_vec_index): Return -1 if increment not found.\n\t(create_add_on_incoming_edge): Assert if increment not found.\n\t(record_increment): Limit number of increments recorded.\n\t(all_phi_incrs_profitable): Return false if an increment not found.\n\t(replace_profitable_candidates): Don't process increments that were\n\tnot recorded.\n\t(analyze_candidates_and_replace): Limit size of incr_vec.\n\nFrom-SVN: r198682", "tree": {"sha": "e23ee68c7be1be702c26f701e119cc174417b0ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e23ee68c7be1be702c26f701e119cc174417b0ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7bf55a70ea2a606b387b8c8012dea8caa1f1502d/comments", "author": {"login": "wschmidt-ibm", "id": 5520937, "node_id": "MDQ6VXNlcjU1MjA5Mzc=", "avatar_url": "https://avatars.githubusercontent.com/u/5520937?v=4", "gravatar_id": "", "url": "https://api.github.com/users/wschmidt-ibm", "html_url": "https://github.com/wschmidt-ibm", "followers_url": "https://api.github.com/users/wschmidt-ibm/followers", "following_url": "https://api.github.com/users/wschmidt-ibm/following{/other_user}", "gists_url": "https://api.github.com/users/wschmidt-ibm/gists{/gist_id}", "starred_url": "https://api.github.com/users/wschmidt-ibm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/wschmidt-ibm/subscriptions", "organizations_url": "https://api.github.com/users/wschmidt-ibm/orgs", "repos_url": "https://api.github.com/users/wschmidt-ibm/repos", "events_url": "https://api.github.com/users/wschmidt-ibm/events{/privacy}", "received_events_url": "https://api.github.com/users/wschmidt-ibm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3f8825c030327ba848489938822ce84659adb15c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f8825c030327ba848489938822ce84659adb15c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f8825c030327ba848489938822ce84659adb15c"}], "stats": {"total": 58, "additions": 42, "deletions": 16}, "files": [{"sha": "ab43501c3642133dd9c633de461d45c8d9e90ac5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf55a70ea2a606b387b8c8012dea8caa1f1502d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf55a70ea2a606b387b8c8012dea8caa1f1502d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "patch": "@@ -1,3 +1,14 @@\n+2013-05-07  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n+\n+\t* gimple-ssa-strength-reduction.c (MAX_INCR_VEC_LEN): New constant.\n+\t(incr_vec_index): Return -1 if increment not found.\n+\t(create_add_on_incoming_edge): Assert if increment not found.\n+\t(record_increment): Limit number of increments recorded.\n+\t(all_phi_incrs_profitable): Return false if an increment not found.\n+\t(replace_profitable_candidates): Don't process increments that were\n+\tnot recorded.\n+\t(analyze_candidates_and_replace): Limit size of incr_vec.\n+\n 2013-05-07  Richard Biener  <rguenther@suse.de>\n \n \t* calls.c (special_function_p): setjmp-like functions are leaf."}, {"sha": "2a2c6158df1e6f99f40a3944e98dd6a33026b90e", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 31, "deletions": 16, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7bf55a70ea2a606b387b8c8012dea8caa1f1502d/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7bf55a70ea2a606b387b8c8012dea8caa1f1502d/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=7bf55a70ea2a606b387b8c8012dea8caa1f1502d", "patch": "@@ -366,9 +366,11 @@ static struct obstack chain_obstack;\n \n /* An array INCR_VEC of incr_infos is used during analysis of related\n    candidates having an SSA name for a stride.  INCR_VEC_LEN describes\n-   its current length.  */\n+   its current length.  MAX_INCR_VEC_LEN is used to avoid costly\n+   pathological cases. */\n static incr_info_t incr_vec;\n static unsigned incr_vec_len;\n+const int MAX_INCR_VEC_LEN = 16;\n \n /* For a chain of candidates with unknown stride, indicates whether or not\n    we must generate pointer arithmetic when replacing statements.  */\n@@ -1960,18 +1962,22 @@ replace_unconditional_candidate (slsr_cand_t c)\n   replace_mult_candidate (c, gimple_assign_lhs (basis->cand_stmt), bump);\n }\n \f\n-/* Return the index in the increment vector of the given INCREMENT.  */\n+/* Return the index in the increment vector of the given INCREMENT,\n+   or -1 if not found.  The latter can occur if more than\n+   MAX_INCR_VEC_LEN increments have been found.  */\n \n-static inline unsigned\n+static inline int\n incr_vec_index (double_int increment)\n {\n   unsigned i;\n   \n   for (i = 0; i < incr_vec_len && increment != incr_vec[i].incr; i++)\n     ;\n \n-  gcc_assert (i < incr_vec_len);\n-  return i;\n+  if (i < incr_vec_len)\n+    return i;\n+  else\n+    return -1;\n }\n \n /* Create a new statement along edge E to add BASIS_NAME to the product\n@@ -2015,9 +2021,10 @@ create_add_on_incoming_edge (slsr_cand_t c, tree basis_name,\n     }\n   else\n     {\n-      unsigned i;\n+      int i;\n       bool negate_incr = (!address_arithmetic_p && increment.is_negative ());\n       i = incr_vec_index (negate_incr ? -increment : increment);\n+      gcc_assert (i >= 0);\n \n       if (incr_vec[i].initializer)\n \t{\n@@ -2323,7 +2330,7 @@ record_increment (slsr_cand_t c, double_int increment, bool is_phi_adjust)\n \t}\n     }\n \n-  if (!found)\n+  if (!found && incr_vec_len < MAX_INCR_VEC_LEN - 1)\n     {\n       /* The first time we see an increment, create the entry for it.\n \t If this is the root candidate which doesn't have a basis, set\n@@ -3025,7 +3032,7 @@ all_phi_incrs_profitable (slsr_cand_t c, gimple phi)\n \t    }\n \t  else\n \t    {\n-\t      unsigned j;\n+\t      int j;\n \t      slsr_cand_t arg_cand = base_cand_from_table (arg);\n \t      double_int increment = arg_cand->index - basis->index;\n \n@@ -3041,14 +3048,19 @@ all_phi_incrs_profitable (slsr_cand_t c, gimple phi)\n \t\t  print_gimple_stmt (dump_file, phi, 0, 0);\n \t\t  fputs (\"    increment: \", dump_file);\n \t\t  dump_double_int (dump_file, increment, false);\n-\t\t  fprintf (dump_file, \"\\n    cost: %d\\n\", incr_vec[j].cost);\n-\t\t  if (profitable_increment_p (j))\n-\t\t    fputs (\"  Replacing...\\n\", dump_file);\n-\t\t  else\n-\t\t    fputs (\"  Not replaced.\\n\", dump_file);\n+\t\t  if (j < 0)\n+\t\t    fprintf (dump_file,\n+\t\t\t     \"\\n  Not replaced; incr_vec overflow.\\n\");\n+\t\t  else {\n+\t\t    fprintf (dump_file, \"\\n    cost: %d\\n\", incr_vec[j].cost);\n+\t\t    if (profitable_increment_p (j))\n+\t\t      fputs (\"  Replacing...\\n\", dump_file);\n+\t\t    else\n+\t\t      fputs (\"  Not replaced.\\n\", dump_file);\n+\t\t  }\n \t\t}\n \n-\t      if (!profitable_increment_p (j))\n+\t      if (j < 0 || !profitable_increment_p (j))\n \t\treturn false;\n \t    }\n \t}\n@@ -3268,13 +3280,14 @@ replace_profitable_candidates (slsr_cand_t c)\n     {\n       double_int increment = cand_abs_increment (c);\n       enum tree_code orig_code = gimple_assign_rhs_code (c->cand_stmt);\n-      unsigned i;\n+      int i;\n \n       i = incr_vec_index (increment);\n \n       /* Only process profitable increments.  Nothing useful can be done\n \t to a cast or copy.  */\n-      if (profitable_increment_p (i) \n+      if (i >= 0\n+\t  && profitable_increment_p (i) \n \t  && orig_code != MODIFY_EXPR\n \t  && orig_code != NOP_EXPR)\n \t{\n@@ -3378,6 +3391,8 @@ analyze_candidates_and_replace (void)\n \t  length = count_candidates (c);\n \t  if (!length)\n \t    continue;\n+\t  if (length > MAX_INCR_VEC_LEN)\n+\t    length = MAX_INCR_VEC_LEN;\n \n \t  /* Construct an array of increments for this candidate chain.  */\n \t  incr_vec = XNEWVEC (incr_info, length);"}]}