{"sha": "4546f423ecff96f223adfbec4963d2ff17f27c7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDU0NmY0MjNlY2ZmOTZmMjIzYWRmYmVjNDk2M2QyZmYxN2YyN2M3Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-02T10:57:06Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2021-07-02T11:54:30Z"}, "message": "tree-optimization/101293 - further enhance LIMs ref canonicalization\n\nThis makes sure to handle MEM[p + 4] and MEM[p].j with j at offset 4\nas the same ref in store motion.  For hashing we need to be\nmore restrictive in what we handle since there's no poly-int\nhandlers for inchash.  For comparison we can compare poly_offsets directly.\n\n2021-07-02  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/101293\n\t* tree-ssa-loop-im.c (mem_ref_hasher::equal): Compare MEM_REF bases\n\twith combined offsets.\n\t(gather_mem_refs_stmt): Hash MEM_REFs as if their offset were\n\tcombined with the rest of the offset.\n\n\t* gcc.dg/tree-ssa/ssa-lim-15.c: New testcase.", "tree": {"sha": "8e730b452d7c751f146eb4dbe5c9fd8cc53a3e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8e730b452d7c751f146eb4dbe5c9fd8cc53a3e64"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4546f423ecff96f223adfbec4963d2ff17f27c7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4546f423ecff96f223adfbec4963d2ff17f27c7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4546f423ecff96f223adfbec4963d2ff17f27c7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4546f423ecff96f223adfbec4963d2ff17f27c7b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bc8f0ed7042280282035168428f6afc839997cf0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc8f0ed7042280282035168428f6afc839997cf0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc8f0ed7042280282035168428f6afc839997cf0"}], "stats": {"total": 45, "additions": 41, "deletions": 4}, "files": [{"sha": "5efb95627ee6b743d8f2a4dd07e7c260d2ee5cf8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-lim-15.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4546f423ecff96f223adfbec4963d2ff17f27c7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4546f423ecff96f223adfbec4963d2ff17f27c7b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-lim-15.c?ref=4546f423ecff96f223adfbec4963d2ff17f27c7b", "patch": "@@ -0,0 +1,18 @@\n+/* PR/101293 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-lim2-details\" } */\n+\n+struct X { int i; int j; };\n+\n+void foo(struct X *x, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      int *p = &x->j;\n+      int tem = *p;\n+      x->j += tem * i;\n+    }\n+}\n+\n+/* Make sure LIM can handle unifying MEM[x, 4] and MEM[x].j  */\n+/* { dg-final { scan-tree-dump \"Executing store motion\" \"lim2\" } } */"}, {"sha": "e7a3050ba9da71aecf6bce98078b5dd48639b497", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 23, "deletions": 4, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4546f423ecff96f223adfbec4963d2ff17f27c7b/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4546f423ecff96f223adfbec4963d2ff17f27c7b/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=4546f423ecff96f223adfbec4963d2ff17f27c7b", "patch": "@@ -194,8 +194,14 @@ mem_ref_hasher::equal (const im_mem_ref *mem1, const ao_ref *obj2)\n {\n   if (obj2->max_size_known_p ())\n     return (mem1->ref_decomposed\n-\t    && operand_equal_p (mem1->mem.base, obj2->base, 0)\n-\t    && known_eq (mem1->mem.offset, obj2->offset)\n+\t    && ((TREE_CODE (mem1->mem.base) == MEM_REF\n+\t\t && TREE_CODE (obj2->base) == MEM_REF\n+\t\t && operand_equal_p (TREE_OPERAND (mem1->mem.base, 0),\n+\t\t\t\t     TREE_OPERAND (obj2->base, 0), 0)\n+\t\t && known_eq (mem_ref_offset (mem1->mem.base) * BITS_PER_UNIT + mem1->mem.offset,\n+\t\t\t      mem_ref_offset (obj2->base) * BITS_PER_UNIT + obj2->offset))\n+\t\t|| (operand_equal_p (mem1->mem.base, obj2->base, 0)\n+\t\t    && known_eq (mem1->mem.offset, obj2->offset)))\n \t    && known_eq (mem1->mem.size, obj2->size)\n \t    && known_eq (mem1->mem.max_size, obj2->max_size)\n \t    && mem1->mem.volatile_p == obj2->volatile_p\n@@ -1500,8 +1506,21 @@ gather_mem_refs_stmt (class loop *loop, gimple *stmt)\n \t  && (mem_base = get_addr_base_and_unit_offset (aor.ref, &mem_off)))\n \t{\n \t  ref_decomposed = true;\n-\t  hash = iterative_hash_expr (ao_ref_base (&aor), 0);\n-\t  hash = iterative_hash_host_wide_int (offset, hash);\n+\t  tree base = ao_ref_base (&aor);\n+\t  poly_int64 moffset;\n+\t  HOST_WIDE_INT mcoffset;\n+\t  if (TREE_CODE (base) == MEM_REF\n+\t      && (mem_ref_offset (base) * BITS_PER_UNIT + offset).to_shwi (&moffset)\n+\t      && moffset.is_constant (&mcoffset))\n+\t    {\n+\t      hash = iterative_hash_expr (TREE_OPERAND (base, 0), 0);\n+\t      hash = iterative_hash_host_wide_int (mcoffset, hash);\n+\t    }\n+\t  else\n+\t    {\n+\t      hash = iterative_hash_expr (base, 0);\n+\t      hash = iterative_hash_host_wide_int (offset, hash);\n+\t    }\n \t  hash = iterative_hash_host_wide_int (size, hash);\n \t}\n       else"}]}