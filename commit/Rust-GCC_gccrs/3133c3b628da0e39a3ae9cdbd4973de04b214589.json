{"sha": "3133c3b628da0e39a3ae9cdbd4973de04b214589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzEzM2MzYjYyOGRhMGUzOWEzYWU5Y2RiZDQ5NzNkZTA0YjIxNDU4OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-01-03T21:47:11Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-01-03T21:47:11Z"}, "message": "Split rhs checking out of vectorizable_{,mask_load_}store\n\nThis patch splits out the rhs checking code that's common to both\nvectorizable_mask_load_store and vectorizable_store.\n\n2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* tree-vect-stmts.c (vect_check_store_rhs): New function,\n\tsplit out from...\n\t(vectorizable_mask_load_store): ...here.\n\t(vectorizable_store): ...and here.\n\nFrom-SVN: r256213", "tree": {"sha": "8d66cf57fd44dfbd34c07dda8a6236814461b96d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d66cf57fd44dfbd34c07dda8a6236814461b96d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3133c3b628da0e39a3ae9cdbd4973de04b214589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3133c3b628da0e39a3ae9cdbd4973de04b214589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3133c3b628da0e39a3ae9cdbd4973de04b214589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3133c3b628da0e39a3ae9cdbd4973de04b214589/comments", "author": null, "committer": null, "parents": [{"sha": "aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaeefd88f464de0a78fa66c8b5e2755babf0d47f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaeefd88f464de0a78fa66c8b5e2755babf0d47f"}], "stats": {"total": 87, "additions": 59, "deletions": 28}, "files": [{"sha": "6086e1550eded3838601a887b5a620b465f26545", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3133c3b628da0e39a3ae9cdbd4973de04b214589/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3133c3b628da0e39a3ae9cdbd4973de04b214589/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3133c3b628da0e39a3ae9cdbd4973de04b214589", "patch": "@@ -1,3 +1,10 @@\n+2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vect-stmts.c (vect_check_store_rhs): New function,\n+\tsplit out from...\n+\t(vectorizable_mask_load_store): ...here.\n+\t(vectorizable_store): ...and here.\n+\n 2018-01-03  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-stmts.c (vect_check_load_store_mask): New function,"}, {"sha": "0d6c824bb368e5453d7cae579fcb79e59e391e4b", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3133c3b628da0e39a3ae9cdbd4973de04b214589/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3133c3b628da0e39a3ae9cdbd4973de04b214589/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=3133c3b628da0e39a3ae9cdbd4973de04b214589", "patch": "@@ -2092,6 +2092,55 @@ vect_check_load_store_mask (gimple *stmt, tree mask, tree *mask_vectype_out)\n   return true;\n }\n \n+/* Return true if stored value RHS is suitable for vectorizing store\n+   statement STMT.  When returning true, store the type of the\n+   vectorized store value in *RHS_VECTYPE_OUT and the type of the\n+   store in *VLS_TYPE_OUT.  */\n+\n+static bool\n+vect_check_store_rhs (gimple *stmt, tree rhs, tree *rhs_vectype_out,\n+\t\t      vec_load_store_type *vls_type_out)\n+{\n+  /* In the case this is a store from a constant make sure\n+     native_encode_expr can handle it.  */\n+  if (CONSTANT_CLASS_P (rhs) && native_encode_expr (rhs, NULL, 64) == 0)\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"cannot encode constant as a byte sequence.\\n\");\n+      return false;\n+    }\n+\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  gimple *def_stmt;\n+  enum vect_def_type dt;\n+  tree rhs_vectype;\n+  if (!vect_is_simple_use (rhs, stmt_info->vinfo, &def_stmt, &dt,\n+\t\t\t   &rhs_vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"use not simple.\\n\");\n+      return false;\n+    }\n+\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  if (rhs_vectype && !useless_type_conversion_p (vectype, rhs_vectype))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"incompatible vector types.\\n\");\n+      return false;\n+    }\n+\n+  *rhs_vectype_out = rhs_vectype;\n+  if (dt == vect_constant_def || dt == vect_external_def)\n+    *vls_type_out = VLS_STORE_INVARIANT;\n+  else\n+    *vls_type_out = VLS_STORE;\n+  return true;\n+}\n+\n /* Function vectorizable_mask_load_store.\n \n    Check if STMT performs a conditional load or store that can be vectorized.\n@@ -2162,12 +2211,8 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   if (gimple_call_internal_fn (stmt) == IFN_MASK_STORE)\n     {\n       tree rhs = gimple_call_arg (stmt, 3);\n-      if (!vect_is_simple_use (rhs, loop_vinfo, &def_stmt, &dt, &rhs_vectype))\n+      if (!vect_check_store_rhs (stmt, rhs, &rhs_vectype, &vls_type))\n \treturn false;\n-      if (dt == vect_constant_def || dt == vect_external_def)\n-\tvls_type = VLS_STORE_INVARIANT;\n-      else\n-\tvls_type = VLS_STORE;\n     }\n   else\n     vls_type = VLS_LOAD;\n@@ -2201,9 +2246,7 @@ vectorizable_mask_load_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   else if (!VECTOR_MODE_P (TYPE_MODE (vectype))\n \t   || !can_vec_mask_load_store_p (TYPE_MODE (vectype),\n \t\t\t\t\t  TYPE_MODE (mask_vectype),\n-\t\t\t\t\t  vls_type == VLS_LOAD)\n-\t   || (rhs_vectype\n-\t       && !useless_type_conversion_p (vectype, rhs_vectype)))\n+\t\t\t\t\t  vls_type == VLS_LOAD))\n     return false;\n \n   if (!vec_stmt) /* transformation not required.  */\n@@ -5821,26 +5864,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi, gimple **vec_stmt,\n     }\n \n   op = gimple_assign_rhs1 (stmt);\n-\n-  /* In the case this is a store from a constant make sure\n-     native_encode_expr can handle it.  */\n-  if (CONSTANT_CLASS_P (op) && native_encode_expr (op, NULL, 64) == 0)\n-    return false;\n-\n-  if (!vect_is_simple_use (op, vinfo, &def_stmt, &dt, &rhs_vectype))\n-    {\n-      if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\\n\");\n-      return false;\n-    }\n-\n-  if (dt == vect_constant_def || dt == vect_external_def)\n-    vls_type = VLS_STORE_INVARIANT;\n-  else\n-    vls_type = VLS_STORE;\n-\n-  if (rhs_vectype && !useless_type_conversion_p (vectype, rhs_vectype))\n+  if (!vect_check_store_rhs (stmt, op, &rhs_vectype, &vls_type))\n     return false;\n \n   elem_type = TREE_TYPE (vectype);"}]}