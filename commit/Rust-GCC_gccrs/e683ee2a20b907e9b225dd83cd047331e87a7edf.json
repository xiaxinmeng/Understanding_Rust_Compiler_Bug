{"sha": "e683ee2a20b907e9b225dd83cd047331e87a7edf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY4M2VlMmEyMGI5MDdlOWIyMjVkZDgzY2QwNDczMzFlODdhN2VkZg==", "commit": {"author": {"name": "Johannes Singler", "email": "singler@ira.uka.de", "date": "2007-11-22T10:13:08Z"}, "committer": {"name": "Johannes Singler", "email": "singler@gcc.gnu.org", "date": "2007-11-22T10:13:08Z"}, "message": "re PR libstdc++/33893 ([parallel mode] Algorithms rely on omp_set_dynamic(false))\n\n2007-11-22  Johannes Singler  <singler@ira.uka.de>\n\n        PR libstdc++/33893\n        * include/parallel/multiway_merge.h: made omp_dynamic-safe\n        * include/parallel/workstealing.h: made omp_dynamic-safe\n        * include/parallel/base.h: infrastructure, cleanup\n        * include/parallel/par_loop.h: made omp_dynamic-safe\n        * include/parallel/features.h: activate loser tree variant\n        * include/parallel/quicksort.h: made omp_dynamic-safe\n        * include/parallel/compiletime_settings.h: settings overridable\n        * include/parallel/equally_split.h: made omp_dynamic-safe\n        * include/parallel/omp_loop_static.h: made omp_dynamic-safe\n        * include/parallel/random_shuffle.h: made omp_dynamic-safe\n        * include/parallel/balanced_quicksort.h: made omp_dynamic-safe\n        * include/parallel/set_operations.h: made omp_dynamic-safe\n        * include/parallel/unique_copy.h: made omp_dynamic-safe\n        * include/parallel/multiway_mergesort.h: made omp_dynamic-safe\n        * include/parallel/search.h: made omp_dynamic-safe\n        * include/parallel/partition.h: made omp_dynamic-safe\n        * include/parallel/partial_sum.h: made omp_dynamic-safe\n        * include/parallel/find.h: made omp_dynamic-safe\n        * include/parallel/omp_loop.h: made omp_dynamic-safe\n        * include/parallel/losertree.h: avoid default constructor\n\nFrom-SVN: r130347", "tree": {"sha": "c5838738b1b4d3a360f76e4418890226a450834a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5838738b1b4d3a360f76e4418890226a450834a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e683ee2a20b907e9b225dd83cd047331e87a7edf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e683ee2a20b907e9b225dd83cd047331e87a7edf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e683ee2a20b907e9b225dd83cd047331e87a7edf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e683ee2a20b907e9b225dd83cd047331e87a7edf/comments", "author": null, "committer": null, "parents": [{"sha": "7861a5ce14376a46409d83eeebef942be4030fe4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7861a5ce14376a46409d83eeebef942be4030fe4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7861a5ce14376a46409d83eeebef942be4030fe4"}], "stats": {"total": 7218, "additions": 3914, "deletions": 3304}, "files": [{"sha": "7415d5584b86b338a91672df1b8e68fee31f688c", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -1,3 +1,27 @@\n+2007-11-22  Johannes Singler  <singler@ira.uka.de>\n+\n+\tPR libstdc++/33893\n+        * include/parallel/multiway_merge.h: made omp_dynamic-safe\n+        * include/parallel/workstealing.h: made omp_dynamic-safe\n+        * include/parallel/base.h: infrastructure, cleanup\n+        * include/parallel/par_loop.h: made omp_dynamic-safe\n+        * include/parallel/features.h: activate loser tree variant\n+        * include/parallel/quicksort.h: made omp_dynamic-safe\n+        * include/parallel/compiletime_settings.h: settings overridable\n+        * include/parallel/equally_split.h: made omp_dynamic-safe\n+        * include/parallel/omp_loop_static.h: made omp_dynamic-safe\n+        * include/parallel/random_shuffle.h: made omp_dynamic-safe\n+        * include/parallel/balanced_quicksort.h: made omp_dynamic-safe\n+        * include/parallel/set_operations.h: made omp_dynamic-safe\n+        * include/parallel/unique_copy.h: made omp_dynamic-safe\n+        * include/parallel/multiway_mergesort.h: made omp_dynamic-safe\n+        * include/parallel/search.h: made omp_dynamic-safe\n+        * include/parallel/partition.h: made omp_dynamic-safe\n+        * include/parallel/partial_sum.h: made omp_dynamic-safe\n+        * include/parallel/find.h: made omp_dynamic-safe\n+        * include/parallel/omp_loop.h: made omp_dynamic-safe\n+        * include/parallel/losertree.h: avoid default constructor\n+\n 2007-11-21  Jonathan Wakely  <jwakely.gcc@gmail.com>\n \n \t* docs/html/17_intro/C++STYLE: Fix typos."}, {"sha": "0d845ce67c85ee855c3910fd55aacb62fe656716", "filename": "libstdc++-v3/include/parallel/balanced_quicksort.h", "status": "modified", "additions": 217, "deletions": 195, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbalanced_quicksort.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -63,15 +63,15 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Information local to one thread in the parallel quicksort run. */\n-  template<typename RandomAccessIterator>\n+/** @brief Information local to one thread in the parallel quicksort run. */\n+template<typename RandomAccessIterator>\n   struct QSBThreadLocal\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     /** @brief Continuous part of the sequence, described by an\n-\titerator pair. */\n+    iterator pair. */\n     typedef std::pair<RandomAccessIterator, RandomAccessIterator> Piece;\n \n     /** @brief Initial piece to work on. */\n@@ -94,59 +94,51 @@ namespace __gnu_parallel\n     QSBThreadLocal(int queue_size) : leftover_parts(queue_size) { }\n   };\n \n-  /** @brief Initialize the thread local storage.\n-   *  @param tls Array of thread-local storages.\n-   *  @param queue_size Size of the work-stealing queue. */\n-  template<typename RandomAccessIterator>\n-  inline void\n-  qsb_initialize(QSBThreadLocal<RandomAccessIterator>** tls, int queue_size)\n-  {\n-    int iam = omp_get_thread_num();\n-    tls[iam] = new QSBThreadLocal<RandomAccessIterator>(queue_size);\n-  }\n-\n-\n-  /** @brief Balanced quicksort divide step.\n-   *  @param begin Begin iterator of subsequence.\n-   *  @param end End iterator of subsequence.\n-   *  @param comp Comparator.\n-   *  @param num_threads Number of threads that are allowed to work on\n-   *  this part.\n-   *  @pre @c (end-begin)>=1 */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Balanced quicksort divide step.\n+  *  @param begin Begin iterator of subsequence.\n+  *  @param end End iterator of subsequence.\n+  *  @param comp Comparator.\n+  *  @param num_threads Number of threads that are allowed to work on\n+  *  this part.\n+  *  @pre @c (end-begin)>=1 */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n   qsb_divide(RandomAccessIterator begin, RandomAccessIterator end,\n-\t     Comparator comp, int num_threads)\n+             Comparator comp, thread_index_t num_threads)\n   {\n     _GLIBCXX_PARALLEL_ASSERT(num_threads > 0);\n \n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    RandomAccessIterator pivot_pos = median_of_three_iterators(begin, begin + (end - begin) / 2, end  - 1, comp);\n+    RandomAccessIterator pivot_pos = median_of_three_iterators(\n+        begin, begin + (end - begin) / 2, end  - 1, comp);\n \n #if defined(_GLIBCXX_ASSERTIONS)\n     // Must be in between somewhere.\n     difference_type n = end - begin;\n \n-    _GLIBCXX_PARALLEL_ASSERT((!comp(*pivot_pos, *begin) && !comp(*(begin + n / 2), *pivot_pos))\n-\t   || (!comp(*pivot_pos, *begin) && !comp(*end, *pivot_pos))\n-\t   || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*begin, *pivot_pos))\n-\t   || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*end, *pivot_pos))\n-\t   || (!comp(*pivot_pos, *end) && !comp(*begin, *pivot_pos))\n-\t   || (!comp(*pivot_pos, *end) && !comp(*(begin + n / 2), *pivot_pos)));\n+    _GLIBCXX_PARALLEL_ASSERT(\n+           (!comp(*pivot_pos, *begin) && !comp(*(begin + n / 2), *pivot_pos))\n+        || (!comp(*pivot_pos, *begin) && !comp(*end, *pivot_pos))\n+        || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*begin, *pivot_pos))\n+        || (!comp(*pivot_pos, *(begin + n / 2)) && !comp(*end, *pivot_pos))\n+        || (!comp(*pivot_pos, *end) && !comp(*begin, *pivot_pos))\n+        || (!comp(*pivot_pos, *end) && !comp(*(begin + n / 2), *pivot_pos)));\n #endif\n \n     // Swap pivot value to end.\n     if (pivot_pos != (end - 1))\n       std::swap(*pivot_pos, *(end - 1));\n     pivot_pos = end - 1;\n \n-    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n+        pred(comp, *pivot_pos);\n \n     // Divide, returning end - begin - 1 in the worst case.\n-    difference_type split_pos = parallel_partition(begin, end - 1, pred, num_threads);\n+    difference_type split_pos = parallel_partition(\n+        begin, end - 1, pred, num_threads);\n \n     // Swap back pivot to middle.\n     std::swap(*(begin + split_pos), *pivot_pos);\n@@ -163,33 +155,36 @@ namespace __gnu_parallel\n     return split_pos;\n   }\n \n-  /** @brief Quicksort conquer step.\n-   *  @param tls Array of thread-local storages.\n-   *  @param begin Begin iterator of subsequence.\n-   *  @param end End iterator of subsequence.\n-   *  @param comp Comparator.\n-   *  @param iam Number of the thread processing this function.\n-   *  @param num_threads Number of threads that are allowed to work on this part. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Quicksort conquer step.\n+  *  @param tls Array of thread-local storages.\n+  *  @param begin Begin iterator of subsequence.\n+  *  @param end End iterator of subsequence.\n+  *  @param comp Comparator.\n+  *  @param iam Number of the thread processing this function.\n+  *  @param num_threads\n+  *          Number of threads that are allowed to work on this part. */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline void\n   qsb_conquer(QSBThreadLocal<RandomAccessIterator>** tls,\n-\t      RandomAccessIterator begin, RandomAccessIterator end,\n-\t      Comparator comp, thread_index_t iam, thread_index_t num_threads)\n+              RandomAccessIterator begin, RandomAccessIterator end,\n+              Comparator comp,\n+              thread_index_t iam, thread_index_t num_threads,\n+              bool parent_wait)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     difference_type n = end - begin;\n \n-    if (num_threads <= 1 || n < 2)\n+    if (num_threads <= 1 || n <= 1)\n       {\n-\ttls[iam]->initial.first  = begin;\n-\ttls[iam]->initial.second = end;\n+        tls[iam]->initial.first  = begin;\n+        tls[iam]->initial.second = end;\n \n-\tqsb_local_sort_with_helping(tls, comp, iam);\n+        qsb_local_sort_with_helping(tls, comp, iam, parent_wait);\n \n-\treturn;\n+        return;\n       }\n \n     // Divide step.\n@@ -199,33 +194,55 @@ namespace __gnu_parallel\n     _GLIBCXX_PARALLEL_ASSERT(0 <= split_pos && split_pos < (end - begin));\n #endif\n \n-    thread_index_t num_threads_leftside = std::max<thread_index_t>(1, std::min<thread_index_t>(num_threads - 1, split_pos * num_threads / n));\n+    thread_index_t num_threads_leftside =\n+        std::max<thread_index_t>(1, std::min<thread_index_t>(\n+                          num_threads - 1, split_pos * num_threads / n));\n \n-#pragma omp atomic\n+#   pragma omp atomic\n     *tls[iam]->elements_leftover -= (difference_type)1;\n \n     // Conquer step.\n-#pragma omp parallel sections num_threads(2)\n+#   pragma omp parallel num_threads(2)\n     {\n-#pragma omp section\n-      qsb_conquer(tls, begin, begin + split_pos, comp, iam, num_threads_leftside);\n-      // The pivot_pos is left in place, to ensure termination.\n-#pragma omp section\n-      qsb_conquer(tls, begin + split_pos + 1, end, comp,\n-\t\t  iam + num_threads_leftside, num_threads - num_threads_leftside);\n+      bool wait;\n+      if(omp_get_num_threads() < 2)\n+        wait = false;\n+      else\n+        wait = parent_wait;\n+\n+#     pragma omp sections\n+        {\n+#         pragma omp section\n+            {\n+              qsb_conquer(tls, begin, begin + split_pos, comp,\n+                          iam,\n+                          num_threads_leftside,\n+                          wait);\n+              wait = parent_wait;\n+            }\n+          // The pivot_pos is left in place, to ensure termination.\n+#         pragma omp section\n+            {\n+              qsb_conquer(tls, begin + split_pos + 1, end, comp,\n+                          iam + num_threads_leftside,\n+                          num_threads - num_threads_leftside,\n+                          wait);\n+              wait = parent_wait;\n+            }\n+        }\n     }\n   }\n \n-  /** \n-   *  @brief Quicksort step doing load-balanced local sort.\n-   *  @param tls Array of thread-local storages.\n-   *  @param comp Comparator.\n-   *  @param iam Number of the thread processing this function. \n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/**\n+  *  @brief Quicksort step doing load-balanced local sort.\n+  *  @param tls Array of thread-local storages.\n+  *  @param comp Comparator.\n+  *  @param iam Number of the thread processing this function.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline void\n   qsb_local_sort_with_helping(QSBThreadLocal<RandomAccessIterator>** tls,\n-\t\t\t      Comparator& comp, int iam)\n+                              Comparator& comp, int iam, bool wait)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -251,151 +268,162 @@ namespace __gnu_parallel\n \n     for (;;)\n       {\n-\t// Invariant: current must be a valid (maybe empty) range.\n-\tRandomAccessIterator begin = current.first, end = current.second;\n-\tdifference_type n = end - begin;\n+        // Invariant: current must be a valid (maybe empty) range.\n+        RandomAccessIterator begin = current.first, end = current.second;\n+        difference_type n = end - begin;\n \n-\tif (n > base_case_n)\n-\t  {\n-\t    // Divide.\n-\t    RandomAccessIterator pivot_pos = begin +  rng(n);\n+        if (n > base_case_n)\n+          {\n+            // Divide.\n+            RandomAccessIterator pivot_pos = begin +  rng(n);\n \n-\t    // Swap pivot_pos value to end.\n-\t    if (pivot_pos != (end - 1))\n-\t      std::swap(*pivot_pos, *(end - 1));\n-\t    pivot_pos = end - 1;\n+            // Swap pivot_pos value to end.\n+            if (pivot_pos != (end - 1))\n+              std::swap(*pivot_pos, *(end - 1));\n+            pivot_pos = end - 1;\n \n-\t    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+            __gnu_parallel::binder2nd\n+                <Comparator, value_type, value_type, bool>\n+                pred(comp, *pivot_pos);\n \n-\t    // Divide, leave pivot unchanged in last place.\n-\t    RandomAccessIterator split_pos1, split_pos2;\n-\t    split_pos1 = __gnu_sequential::partition(begin, end - 1, pred);\n+            // Divide, leave pivot unchanged in last place.\n+            RandomAccessIterator split_pos1, split_pos2;\n+            split_pos1 = __gnu_sequential::partition(begin, end - 1, pred);\n \n-\t    // Left side: < pivot_pos; right side: >= pivot_pos.\n+            // Left side: < pivot_pos; right side: >= pivot_pos.\n #if _GLIBCXX_ASSERTIONS\n-\t    _GLIBCXX_PARALLEL_ASSERT(begin <= split_pos1 && split_pos1 < end);\n+            _GLIBCXX_PARALLEL_ASSERT(begin <= split_pos1 && split_pos1 < end);\n #endif\n-\t    // Swap pivot back to middle.\n-\t    if (split_pos1 != pivot_pos)\n-\t      std::swap(*split_pos1, *pivot_pos);\n-\t    pivot_pos = split_pos1;\n-\n-\t    // In case all elements are equal, split_pos1 == 0.\n-\t    if ((split_pos1 + 1 - begin) < (n >> 7)\n-\t\t|| (end - split_pos1) < (n >> 7))\n-\t      {\n-\t\t// Very unequal split, one part smaller than one 128th\n-\t\t// elements not strictly larger than the pivot.\n-\t\t__gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n-\n-\t\t// Find other end of pivot-equal range.\n-\t\tsplit_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n-\t      }\n-\t    else\n-\t      {\n-\t\t// Only skip the pivot.\n-\t\tsplit_pos2 = split_pos1 + 1;\n-\t      }\n-\n-\t    // Elements equal to pivot are done.\n-\t    elements_done += (split_pos2 - split_pos1);\n+            // Swap pivot back to middle.\n+            if (split_pos1 != pivot_pos)\n+              std::swap(*split_pos1, *pivot_pos);\n+            pivot_pos = split_pos1;\n+\n+            // In case all elements are equal, split_pos1 == 0.\n+            if ((split_pos1 + 1 - begin) < (n >> 7)\n+            || (end - split_pos1) < (n >> 7))\n+              {\n+                // Very unequal split, one part smaller than one 128th\n+                // elements not strictly larger than the pivot.\n+                __gnu_parallel::unary_negate<__gnu_parallel::binder1st\n+                    <Comparator, value_type, value_type, bool>, value_type>\n+                    pred(__gnu_parallel::binder1st\n+                        <Comparator, value_type, value_type, bool>(\n+                        comp, *pivot_pos));\n+\n+                // Find other end of pivot-equal range.\n+                split_pos2 = __gnu_sequential::partition(\n+                    split_pos1 + 1, end, pred);\n+              }\n+            else\n+              // Only skip the pivot.\n+              split_pos2 = split_pos1 + 1;\n+\n+            // Elements equal to pivot are done.\n+            elements_done += (split_pos2 - split_pos1);\n #if _GLIBCXX_ASSERTIONS\n-\t    total_elements_done += (split_pos2 - split_pos1);\n+            total_elements_done += (split_pos2 - split_pos1);\n #endif\n-\t    // Always push larger part onto stack.\n-\t    if (((split_pos1 + 1) - begin) < (end - (split_pos2)))\n-\t      {\n-\t\t// Right side larger.\n-\t\tif ((split_pos2) != end)\n-\t\t  tl.leftover_parts.push_front(std::make_pair(split_pos2, end));\n-\n-\t\t//current.first = begin;\t//already set anyway\n-\t\tcurrent.second = split_pos1;\n-\t\tcontinue;\n-\t      }\n-\t    else\n-\t      {\n-\t\t// Left side larger.\n-\t\tif (begin != split_pos1)\n-\t\t  tl.leftover_parts.push_front(std::make_pair(begin, split_pos1));\n-\n-\t\tcurrent.first = split_pos2;\n-\t\t//current.second = end;\t//already set anyway\n-\t\tcontinue;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    __gnu_sequential::sort(begin, end, comp);\n-\t    elements_done += n;\n+            // Always push larger part onto stack.\n+            if (((split_pos1 + 1) - begin) < (end - (split_pos2)))\n+              {\n+                // Right side larger.\n+                if ((split_pos2) != end)\n+                  tl.leftover_parts.push_front(std::make_pair(split_pos2, end));\n+\n+                //current.first = begin;\t//already set anyway\n+                current.second = split_pos1;\n+                continue;\n+              }\n+            else\n+              {\n+                // Left side larger.\n+                if (begin != split_pos1)\n+                  tl.leftover_parts.push_front(\n+                      std::make_pair(begin, split_pos1));\n+\n+                current.first = split_pos2;\n+                //current.second = end;\t//already set anyway\n+                continue;\n+              }\n+          }\n+        else\n+          {\n+            __gnu_sequential::sort(begin, end, comp);\n+            elements_done += n;\n #if _GLIBCXX_ASSERTIONS\n-\t    total_elements_done += n;\n+            total_elements_done += n;\n #endif\n \n-\t    // Prefer own stack, small pieces.\n-\t    if (tl.leftover_parts.pop_front(current))\n-\t      continue;\n+            // Prefer own stack, small pieces.\n+            if (tl.leftover_parts.pop_front(current))\n+              continue;\n \n-#pragma omp atomic\n-\t    *tl.elements_leftover -= elements_done;\n-\t    elements_done = 0;\n+#           pragma omp atomic\n+            *tl.elements_leftover -= elements_done;\n+\n+            elements_done = 0;\n \n #if _GLIBCXX_ASSERTIONS\n-\t    double search_start = omp_get_wtime();\n+            double search_start = omp_get_wtime();\n #endif\n \n-\t    // Look for new work.\n-\t    bool success = false;\n-\t    while (*tl.elements_leftover > 0 && !success\n+            // Look for new work.\n+            bool successfully_stolen = false;\n+            while (wait && *tl.elements_leftover > 0 && !successfully_stolen\n #if _GLIBCXX_ASSERTIONS\n-\t\t   // Possible dead-lock.\n-\t\t   && (omp_get_wtime() < (search_start + 1.0))\n+              // Possible dead-lock.\n+              && (omp_get_wtime() < (search_start + 1.0))\n #endif\n-\t\t   )\n-\t      {\n-\t\tthread_index_t victim;\n-\t\tvictim = rng(num_threads);\n-\n-\t\t// Large pieces.\n-\t\tsuccess = (victim != iam) && tls[victim]->leftover_parts.pop_back(current);\n-\t\tif (!success)\n-\t\t  yield();\n+              )\n+              {\n+                thread_index_t victim;\n+                victim = rng(num_threads);\n+\n+                // Large pieces.\n+                successfully_stolen = (victim != iam)\n+                    && tls[victim]->leftover_parts.pop_back(current);\n+                if (!successfully_stolen)\n+                  yield();\n #if !defined(__ICC) && !defined(__ECC)\n-#pragma omp flush\n+#               pragma omp flush\n #endif\n-\t      }\n+              }\n \n #if _GLIBCXX_ASSERTIONS\n-\t    if (omp_get_wtime() >= (search_start + 1.0))\n-\t      {\n-\t\tsleep(1);\n-\t\t_GLIBCXX_PARALLEL_ASSERT(omp_get_wtime() < (search_start + 1.0));\n-\t      }\n+            if (omp_get_wtime() >= (search_start + 1.0))\n+              {\n+                sleep(1);\n+                _GLIBCXX_PARALLEL_ASSERT(\n+                    omp_get_wtime() < (search_start + 1.0));\n+              }\n #endif\n-\t    if (!success)\n-\t      {\n+            if (!successfully_stolen)\n+              {\n #if _GLIBCXX_ASSERTIONS\n-\t\t_GLIBCXX_PARALLEL_ASSERT(*tl.elements_leftover == 0);\n+                _GLIBCXX_PARALLEL_ASSERT(*tl.elements_leftover == 0);\n #endif\n-\t\treturn;\n-\t      }\n-\t  }\n+                return;\n+              }\n+          }\n       }\n   }\n \n-  /** @brief Top-level quicksort routine.\n-   *  @param begin Begin iterator of sequence.\n-   *  @param end End iterator of sequence.\n-   *  @param comp Comparator.\n-   *  @param n Length of the sequence to sort.\n-   *  @param num_threads Number of threads that are allowed to work on\n-   *  this part.\n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Top-level quicksort routine.\n+  *  @param begin Begin iterator of sequence.\n+  *  @param end End iterator of sequence.\n+  *  @param comp Comparator.\n+  *  @param n Length of the sequence to sort.\n+  *  @param num_threads Number of threads that are allowed to work on\n+  *  this part.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline void\n   parallel_sort_qsb(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t    Comparator comp,\n-\t\t    typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads)\n+                    Comparator comp,\n+                    typename std::iterator_traits<RandomAccessIterator>\n+                        ::difference_type n,\n+                    thread_index_t num_threads)\n   {\n     _GLIBCXX_CALL(end - begin)\n \n@@ -413,11 +441,11 @@ namespace __gnu_parallel\n     if (num_threads > n)\n       num_threads = static_cast<thread_index_t>(n);\n \n+    // Initialize thread local storage\n     tls_type** tls = new tls_type*[num_threads];\n-\n-#pragma omp parallel num_threads(num_threads)\n-    // Initialize variables per processor.\n-    qsb_initialize(tls, num_threads * (thread_index_t)(log2(n) + 1));\n+    difference_type queue_size = num_threads * (thread_index_t)(log2(n) + 1);\n+    for (thread_index_t t = 0; t < num_threads; ++t)\n+      tls[t] = new QSBThreadLocal<RandomAccessIterator>(queue_size);\n \n     // There can never be more than ceil(log2(n)) ranges on the stack, because\n     // 1. Only one processor pushes onto the stack\n@@ -426,22 +454,16 @@ namespace __gnu_parallel\n     volatile difference_type elements_leftover = n;\n     for (int i = 0; i < num_threads; i++)\n       {\n-\ttls[i]->elements_leftover = &elements_leftover;\n-\ttls[i]->num_threads = num_threads;\n-\ttls[i]->global = std::make_pair(begin, end);\n+        tls[i]->elements_leftover = &elements_leftover;\n+        tls[i]->num_threads = num_threads;\n+        tls[i]->global = std::make_pair(begin, end);\n \n-\t// Just in case nothing is left to assign.\n-\ttls[i]->initial = std::make_pair(end, end);\n+        // Just in case nothing is left to assign.\n+        tls[i]->initial = std::make_pair(end, end);\n       }\n \n-    // Initial splitting, recursively.\n-    int old_nested = omp_get_nested();\n-    omp_set_nested(true);\n-\n     // Main recursion call.\n-    qsb_conquer(tls, begin, begin + n, comp, 0, num_threads);\n-\n-    omp_set_nested(old_nested);\n+    qsb_conquer(tls, begin, begin + n, comp, 0, num_threads, true);\n \n #if _GLIBCXX_ASSERTIONS\n     // All stack must be empty."}, {"sha": "5a756cd4be9b7e523323b4dbdb9eb5c7d6fe5463", "filename": "libstdc++-v3/include/parallel/base.h", "status": "modified", "additions": 256, "deletions": 227, "changes": 483, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fbase.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -49,54 +49,70 @@ namespace __gnu_parallel\n   // XXX remove std::duplicates from here if possible,\n   // XXX but keep minimal dependencies.\n \n-  /** @brief Calculates the rounded-down logarithm of @c n for base 2.\n-   *  @param n Argument.\n-   *  @return Returns 0 for argument 0.\n-   */\n-  template<typename Size> \n-    inline Size \n-    log2(Size n)\n+/** @brief Calculates the rounded-down logarithm of @c n for base 2.\n+  *  @param n Argument.\n+  *  @return Returns 0 for argument 0.\n+  */\n+template<typename Size>\n+  inline Size\n+  log2(Size n)\n     {\n       Size k;\n       for (k = 0; n != 1; n >>= 1)\n-\t++k;\n+        ++k;\n       return k;\n     }\n \n-  /** @brief Encode two integers into one __gnu_parallel::lcas_t.\n-   *  @param a First integer, to be encoded in the most-significant @c\n-   *  lcas_t_bits/2 bits.\n-   *  @param b Second integer, to be encoded in the least-significant\n-   *  @c lcas_t_bits/2 bits.\n-   *  @return __gnu_parallel::lcas_t value encoding @c a and @c b.\n-   *  @see decode2 \n-   */\n-  inline lcas_t\n-  encode2(int a, int b)\t//must all be non-negative, actually\n+/** @brief Encode two integers into one __gnu_parallel::lcas_t.\n+  *  @param a First integer, to be encoded in the most-significant @c\n+  *  lcas_t_bits/2 bits.\n+  *  @param b Second integer, to be encoded in the least-significant\n+  *  @c lcas_t_bits/2 bits.\n+  *  @return __gnu_parallel::lcas_t value encoding @c a and @c b.\n+  *  @see decode2\n+  */\n+inline lcas_t\n+encode2(int a, int b)\t//must all be non-negative, actually\n+{\n+  return (((lcas_t)a) << (lcas_t_bits / 2)) | (((lcas_t)b) << 0);\n+}\n+\n+/** @brief Decode two integers from one __gnu_parallel::lcas_t.\n+  *  @param x __gnu_parallel::lcas_t to decode integers from.\n+  *  @param a First integer, to be decoded from the most-significant\n+  *  @c lcas_t_bits/2 bits of @c x.\n+  *  @param b Second integer, to be encoded in the least-significant\n+  *  @c lcas_t_bits/2 bits of @c x.\n+  *  @see encode2\n+  */\n+inline void\n+decode2(lcas_t x, int& a, int& b)\n+{\n+  a = (int)((x >> (lcas_t_bits / 2)) & lcas_t_mask);\n+  b = (int)((x >>               0 ) & lcas_t_mask);\n+}\n+\n+/** @brief Equivalent to std::min. */\n+template<typename T>\n+  const T&\n+  min(const T& a, const T& b)\n   {\n-    return (((lcas_t)a) << (lcas_t_bits / 2)) | (((lcas_t)b) << 0);\n-  }\n+    return (a < b) ? a : b;\n+  };\n \n-  /** @brief Decode two integers from one __gnu_parallel::lcas_t.\n-   *  @param x __gnu_parallel::lcas_t to decode integers from.\n-   *  @param a First integer, to be decoded from the most-significant\n-   *  @c lcas_t_bits/2 bits of @c x.\n-   *  @param b Second integer, to be encoded in the least-significant\n-   *  @c lcas_t_bits/2 bits of @c x.\n-   *  @see encode2\n-   */\n-  inline void\n-  decode2(lcas_t x, int& a, int& b)\n+/** @brief Equivalent to std::max. */\n+template<typename T>\n+  const T&\n+  max(const T& a, const T& b)\n   {\n-    a = (int)((x >> (lcas_t_bits / 2)) & lcas_t_mask);\n-    b = (int)((x >>               0 ) & lcas_t_mask);\n-  }\n+    return (a > b) ? a : b;\n+  };\n \n-  /** @brief Constructs predicate for equality from strict weak\n-   *  ordering predicate\n-   */\n-  // XXX comparator at the end, as per others\n-  template<typename Comparator, typename T1, typename T2>\n+/** @brief Constructs predicate for equality from strict weak\n+  *  ordering predicate\n+  */\n+// XXX comparator at the end, as per others\n+template<typename Comparator, typename T1, typename T2>\n   class equal_from_less : public std::binary_function<T1, T2, bool>\n   {\n   private:\n@@ -112,162 +128,176 @@ namespace __gnu_parallel\n   };\n \n \n-  /** @brief Similar to std::binder1st, but giving the argument types explicitly. */\n-  template<typename _Predicate, typename argument_type>\n-    class unary_negate\n-    : public std::unary_function<argument_type, bool>\n-    {\n-    protected:\n-      _Predicate _M_pred;\n-\n-    public:\n-      explicit\n-      unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n-\n-      bool\n-      operator()(const argument_type& __x)\n-      { return !_M_pred(__x); }\n-    };\n-\n-  /** @brief Similar to std::binder1st, but giving the argument types explicitly. */\n-  template<typename _Operation, typename first_argument_type, typename second_argument_type, typename result_type>\n-    class binder1st\n-    : public std::unary_function<second_argument_type, result_type>\n-    {\n-    protected:\n-      _Operation op;\n-      first_argument_type value;\n-\n-    public:\n-      binder1st(const _Operation& __x,\n-\t\tconst first_argument_type& __y)\n-      : op(__x), value(__y) { }\n-\n-      result_type\n-      operator()(const second_argument_type& __x)\n-      { return op(value, __x); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 109.  Missing binders for non-const sequence elements\n-      result_type\n-      operator()(second_argument_type& __x) const\n-      { return op(value, __x); }\n-    };\n-\n-  /** \n-   *  @brief Similar to std::binder2nd, but giving the argument types\n-   *  explicitly. \n-   */\n-  template<typename _Operation, typename first_argument_type, typename second_argument_type, typename result_type>\n-    class binder2nd\n-    : public std::unary_function<first_argument_type, result_type>\n-    {\n-    protected:\n-      _Operation op;\n-      second_argument_type value;\n-\n-    public:\n-      binder2nd(const _Operation& __x,\n-\t\tconst second_argument_type& __y)\n-      : op(__x), value(__y) { }\n-\n-      result_type\n-      operator()(const first_argument_type& __x) const\n-      { return op(__x, value); }\n-\n-      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-      // 109.  Missing binders for non-const sequence elements\n-      result_type\n-      operator()(first_argument_type& __x)\n-      { return op(__x, value); }\n-    };\n-\n-  /** @brief Similar to std::equal_to, but allows two different types. */\n-  template<typename T1, typename T2>\n+/** @brief Similar to std::binder1st,\n+  *  but giving the argument types explicitly. */\n+template<typename _Predicate, typename argument_type>\n+  class unary_negate\n+  : public std::unary_function<argument_type, bool>\n+  {\n+  protected:\n+    _Predicate _M_pred;\n+\n+  public:\n+    explicit\n+    unary_negate(const _Predicate& __x) : _M_pred(__x) { }\n+\n+    bool\n+    operator()(const argument_type& __x)\n+    { return !_M_pred(__x); }\n+  };\n+\n+/** @brief Similar to std::binder1st,\n+  *  but giving the argument types explicitly. */\n+template<\n+    typename _Operation,\n+    typename first_argument_type,\n+    typename second_argument_type,\n+    typename result_type>\n+  class binder1st\n+  : public std::unary_function<second_argument_type, result_type>\n+  {\n+  protected:\n+    _Operation op;\n+    first_argument_type value;\n+\n+  public:\n+    binder1st(const _Operation& __x,\n+              const first_argument_type& __y)\n+    : op(__x), value(__y) { }\n+\n+    result_type\n+    operator()(const second_argument_type& __x)\n+    { return op(value, __x); }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 109.  Missing binders for non-const sequence elements\n+    result_type\n+    operator()(second_argument_type& __x) const\n+    { return op(value, __x); }\n+  };\n+\n+/**\n+  *  @brief Similar to std::binder2nd, but giving the argument types\n+  *  explicitly.\n+  */\n+template<\n+    typename _Operation,\n+    typename first_argument_type,\n+    typename second_argument_type,\n+    typename result_type>\n+  class binder2nd\n+  : public std::unary_function<first_argument_type, result_type>\n+  {\n+  protected:\n+    _Operation op;\n+    second_argument_type value;\n+\n+  public:\n+    binder2nd(const _Operation& __x,\n+              const second_argument_type& __y)\n+    : op(__x), value(__y) { }\n+\n+    result_type\n+    operator()(const first_argument_type& __x) const\n+    { return op(__x, value); }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 109.  Missing binders for non-const sequence elements\n+    result_type\n+    operator()(first_argument_type& __x)\n+    { return op(__x, value); }\n+  };\n+\n+/** @brief Similar to std::equal_to, but allows two different types. */\n+template<typename T1, typename T2>\n   struct equal_to : std::binary_function<T1, T2, bool>\n   {\n     bool operator()(const T1& t1, const T2& t2) const\n     { return t1 == t2; }\n   };\n \n-  /** @brief Similar to std::less, but allows two different types. */\n-  template<typename T1, typename T2>\n+/** @brief Similar to std::less, but allows two different types. */\n+template<typename T1, typename T2>\n   struct less : std::binary_function<T1, T2, bool>\n   {\n-    bool \n+    bool\n     operator()(const T1& t1, const T2& t2) const\n     { return t1 < t2; }\n \n-    bool \n+    bool\n     operator()(const T2& t2, const T1& t1) const\n     { return t2 < t1; }\n   };\n \n-  // Partial specialization for one type. Same as std::less.\n-  template<typename _Tp>\n-  struct less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n-    {\n-      bool\n-      operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x < __y; }\n-    };\n+// Partial specialization for one type. Same as std::less.\n+template<typename _Tp>\n+struct less<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, bool>\n+  {\n+    bool\n+    operator()(const _Tp& __x, const _Tp& __y) const\n+    { return __x < __y; }\n+  };\n \n \n-    /** @brief Similar to std::plus, but allows two different types. */\n-  template<typename _Tp1, typename _Tp2>\n-    struct plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n-    {\n-      typedef typeof(*static_cast<_Tp1*>(NULL) + *static_cast<_Tp2*>(NULL)) result;\n+  /** @brief Similar to std::plus, but allows two different types. */\n+template<typename _Tp1, typename _Tp2>\n+  struct plus : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+  {\n+    typedef typeof(*static_cast<_Tp1*>(NULL)\n+                    + *static_cast<_Tp2*>(NULL)) result;\n \n-      result\n-      operator()(const _Tp1& __x, const _Tp2& __y) const\n-      { return __x + __y; }\n-    };\n+    result\n+    operator()(const _Tp1& __x, const _Tp2& __y) const\n+    { return __x + __y; }\n+  };\n \n-  // Partial specialization for one type. Same as std::plus.\n-  template<typename _Tp>\n-    struct plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n-    {\n-      typedef typeof(*static_cast<_Tp*>(NULL) + *static_cast<_Tp*>(NULL)) result;\n+// Partial specialization for one type. Same as std::plus.\n+template<typename _Tp>\n+  struct plus<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+  {\n+    typedef typeof(*static_cast<_Tp*>(NULL)\n+                    + *static_cast<_Tp*>(NULL)) result;\n \n-      result\n-      operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x + __y; }\n-    };\n+    result\n+    operator()(const _Tp& __x, const _Tp& __y) const\n+    { return __x + __y; }\n+  };\n \n \n-  /** @brief Similar to std::multiplies, but allows two different types. */\n-  template<typename _Tp1, typename _Tp2>\n-    struct multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n-    {\n-      typedef typeof(*static_cast<_Tp1*>(NULL) * *static_cast<_Tp2*>(NULL)) result;\n+/** @brief Similar to std::multiplies, but allows two different types. */\n+template<typename _Tp1, typename _Tp2>\n+  struct multiplies : public std::binary_function<_Tp1, _Tp2, _Tp1>\n+  {\n+    typedef typeof(*static_cast<_Tp1*>(NULL)\n+                    * *static_cast<_Tp2*>(NULL)) result;\n \n-      result\n-      operator()(const _Tp1& __x, const _Tp2& __y) const\n-      { return __x * __y; }\n-    };\n+    result\n+    operator()(const _Tp1& __x, const _Tp2& __y) const\n+    { return __x * __y; }\n+  };\n \n-  // Partial specialization for one type. Same as std::multiplies.\n-  template<typename _Tp>\n-    struct multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n-    {\n-      typedef typeof(*static_cast<_Tp*>(NULL) * *static_cast<_Tp*>(NULL)) result;\n+// Partial specialization for one type. Same as std::multiplies.\n+template<typename _Tp>\n+  struct multiplies<_Tp, _Tp> : public std::binary_function<_Tp, _Tp, _Tp>\n+  {\n+    typedef typeof(*static_cast<_Tp*>(NULL)\n+                    * *static_cast<_Tp*>(NULL)) result;\n \n-      result\n-      operator()(const _Tp& __x, const _Tp& __y) const\n-      { return __x * __y; }\n-    };\n+    result\n+    operator()(const _Tp& __x, const _Tp& __y) const\n+    { return __x * __y; }\n+  };\n \n \n-  template<typename T, typename _DifferenceTp>\n+template<typename T, typename _DifferenceTp>\n   class pseudo_sequence;\n \n-  /** @brief Iterator associated with __gnu_parallel::pseudo_sequence.\n-   *  If features the usual random-access iterator functionality.\n-   *  @param T Sequence value type.\n-   *  @param difference_type Sequence difference type. \n-   */\n-  template<typename T, typename _DifferenceTp>\n+/** @brief Iterator associated with __gnu_parallel::pseudo_sequence.\n+  *  If features the usual random-access iterator functionality.\n+  *  @param T Sequence value type.\n+  *  @param difference_type Sequence difference type.\n+  */\n+template<typename T, typename _DifferenceTp>\n   class pseudo_sequence_iterator\n   {\n   public:\n@@ -296,34 +326,34 @@ namespace __gnu_parallel\n     operator++(int)\n     { return type(pos++); }\n \n-    const T& \n+    const T&\n     operator*() const\n     { return val; }\n \n-    const T& \n+    const T&\n     operator[](difference_type) const\n     { return val; }\n \n-    bool \n+    bool\n     operator==(const type& i2)\n     { return pos == i2.pos; }\n \n-    difference_type \n+    difference_type\n     operator!=(const type& i2)\n     { return pos != i2.pos; }\n \n-    difference_type \n+    difference_type\n     operator-(const type& i2)\n     { return pos - i2.pos; }\n   };\n \n-  /** @brief Sequence that conceptually consists of multiple copies of\n-      the same element.\n-   *  The copies are not stored explicitly, of course.\n-   *  @param T Sequence value type.\n-   *  @param difference_type Sequence difference type. \n-   */\n-  template<typename T, typename _DifferenceTp>\n+/** @brief Sequence that conceptually consists of multiple copies of\n+    the same element.\n+  *  The copies are not stored explicitly, of course.\n+  *  @param T Sequence value type.\n+  *  @param difference_type Sequence difference type.\n+  */\n+template<typename T, typename _DifferenceTp>\n   class pseudo_sequence\n   {\n     typedef pseudo_sequence<T, _DifferenceTp> type;\n@@ -335,10 +365,10 @@ namespace __gnu_parallel\n     typedef pseudo_sequence_iterator<T, uint64> iterator;\n \n     /** @brief Constructor.\n-     *  @param val Element of the sequence.\n-     *  @param count Number of (virtual) copies.\n-     */\n-    pseudo_sequence(const T& val, difference_type count) \n+      *  @param val Element of the sequence.\n+      *  @param count Number of (virtual) copies.\n+      */\n+    pseudo_sequence(const T& val, difference_type count)\n     : val(val), count(count)  { }\n \n     /** @brief Begin iterator. */\n@@ -356,67 +386,66 @@ namespace __gnu_parallel\n     difference_type count;\n   };\n \n-  /** @brief Functor that does nothing */\n-  template<typename _ValueTp>\n+/** @brief Functor that does nothing */\n+template<typename _ValueTp>\n   class void_functor\n   {\n-    inline void \n+    inline void\n     operator()(const _ValueTp& v) const { }\n   };\n \n-  /** @brief Compute the median of three referenced elements,\n-      according to @c comp.\n-   *  @param a First iterator.\n-   *  @param b Second iterator.\n-   *  @param c Third iterator.\n-   *  @param comp Comparator. \n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n-  RandomAccessIterator\n-  median_of_three_iterators(RandomAccessIterator a, RandomAccessIterator b, \n-\t\t\t    RandomAccessIterator c, Comparator& comp)\n+/** @brief Compute the median of three referenced elements,\n+    according to @c comp.\n+  *  @param a First iterator.\n+  *  @param b Second iterator.\n+  *  @param c Third iterator.\n+  *  @param comp Comparator.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n+RandomAccessIterator\n+  median_of_three_iterators(RandomAccessIterator a, RandomAccessIterator b,\n+                            RandomAccessIterator c, Comparator& comp)\n   {\n     if (comp(*a, *b))\n       if (comp(*b, *c))\n-\treturn b;\n+        return b;\n       else\n-\tif (comp(*a, *c))\n-\t  return c;\n-\telse\n-\t  return a;\n+        if (comp(*a, *c))\n+          return c;\n+        else\n+          return a;\n     else\n       {\n-\t// Just swap a and b.\n-\tif (comp(*a, *c))\n-\t  return a;\n-\telse\n-\t  if (comp(*b, *c))\n-\t    return c;\n-\t  else\n-\t    return b;\n+        // Just swap a and b.\n+        if (comp(*a, *c))\n+          return a;\n+        else\n+          if (comp(*b, *c))\n+            return c;\n+          else\n+            return b;\n       }\n   }\n \n-  // Avoid the use of assert, because we're trying to keep the <cassert>\n-  // include out of the mix. (Same as debug mode).\n-  inline void\n-  __replacement_assert(const char* __file, int __line, \n-\t\t       const char* __function, const char* __condition)\n-  {\n-    std::printf(\"%s:%d: %s: Assertion '%s' failed.\\n\", __file, __line,\n-\t\t__function, __condition);\n-    __builtin_abort();\n-  }\n-  \n+// Avoid the use of assert, because we're trying to keep the <cassert>\n+// include out of the mix. (Same as debug mode).\n+inline void\n+__replacement_assert(const char* __file, int __line,\n+                     const char* __function, const char* __condition)\n+{\n+  std::printf(\"%s:%d: %s: Assertion '%s' failed.\\n\", __file, __line,\n+              __function, __condition);\n+  __builtin_abort();\n+}\n+\n #define _GLIBCXX_PARALLEL_ASSERT(_Condition)                            \\\n-  do \t\t\t\t\t\t\t\t        \\\n-    {\t\t\t\t\t\t\t\t\t\\\n-      if (!(_Condition))\t\t\t\t\t\t\\\n-\t__gnu_parallel::__replacement_assert(__FILE__, __LINE__,\t\\\n-\t\t\t\t    __PRETTY_FUNCTION__, #_Condition);\t\\\n-    } while (false)\n-  \n+do \t\t\t\t\t\t\t\t        \\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    if (!(_Condition))\t\t\t\t\t\t\\\n+      __gnu_parallel::__replacement_assert(__FILE__, __LINE__,\t\\\n+                                  __PRETTY_FUNCTION__, #_Condition);\t\\\n+  } while (false)\n+\n } //namespace __gnu_parallel\n \n #endif\n-"}, {"sha": "edaea3856ad4f5dec7614eb4dd7057f1dad9e22d", "filename": "libstdc++-v3/include/parallel/compiletime_settings.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fcompiletime_settings.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -39,7 +39,7 @@\n #include <cstdio>\n \n /** @brief Determine verbosity level of the parallel mode.\n- *  Level 1 prints a message each time when entering a parallel-mode function. */\n+ *  Level 1 prints a message each time a parallel-mode function is entered. */\n #define _GLIBCXX_VERBOSE_LEVEL 0\n \n /** @def _GLIBCXX_CALL\n@@ -50,27 +50,40 @@\n #define _GLIBCXX_CALL(n)\n #endif\n #if (_GLIBCXX_VERBOSE_LEVEL == 1)\n-#define _GLIBCXX_CALL(n) printf(\"   %s:\\niam = %d, n = %ld, num_threads = %d\\n\", __PRETTY_FUNCTION__, omp_get_thread_num(), (n), get_max_threads());\n+#define _GLIBCXX_CALL(n) \\\n+  printf(\"   %s:\\niam = %d, n = %ld, num_threads = %d\\n\", \\\n+  __PRETTY_FUNCTION__, omp_get_thread_num(), (n), get_max_threads());\n #endif\n \n+#ifndef _GLIBCXX_SCALE_DOWN_FPU\n /** @brief Use floating-point scaling instead of modulo for mapping\n  *  random numbers to a range.  This can be faster on certain CPUs. */\n #define _GLIBCXX_SCALE_DOWN_FPU 0\n+#endif\n \n+#ifndef _GLIBCXX_ASSERTIONS\n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n  *  Should be switched on only locally. */\n #define _GLIBCXX_ASSERTIONS 0\n+#endif\n \n+#ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n- *  Consider the size of the L1 cache for __gnu_parallel::parallel_random_shuffle(). */\n+ *  Consider the size of the L1 cache for\n+ *  __gnu_parallel::parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1 0\n+#endif\n+#ifndef _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB \n /** @brief Switch on many _GLIBCXX_PARALLEL_ASSERTions in parallel code.\n- *  Consider the size of the TLB for __gnu_parallel::parallel_random_shuffle(). */\n+ *  Consider the size of the TLB for\n+ *  __gnu_parallel::parallel_random_shuffle(). */\n #define _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB 0\n+#endif\n \n+#ifndef _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n /** @brief First copy the data, sort it locally, and merge it back\n  * (0); or copy it back after everything is done (1).\n  *\n  *  Recommendation: 0 */\n #define _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST 0\n-\n+#endif"}, {"sha": "4c4167e3d251e31219b3d065483a6d35f01a606e", "filename": "libstdc++-v3/include/parallel/equally_split.h", "status": "modified", "additions": 45, "deletions": 17, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fequally_split.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -39,30 +39,58 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Function to split a sequence into parts of almost equal size.\n-   *\n-   *  The resulting sequence s of length p+1 contains the splitting\n-   *  positions when splitting the range [0,n) into parts of almost\n-   *  equal size (plus minus 1).  The first entry is 0, the last one\n-   *  n. There may result empty parts.\n-   *  @param n Number of elements\n-   *  @param p Number of parts\n-   *  @param s Splitters\n-   *  @returns End of splitter sequence, i. e. @c s+p+1 */\n-  template<typename _DifferenceTp, typename OutputIterator>\n+/** @brief Function to split a sequence into parts of almost equal size.\n+ *\n+ *  The resulting sequence s of length num_threads+1 contains the splitting\n+ *  positions when splitting the range [0,n) into parts of almost\n+ *  equal size (plus minus 1).  The first entry is 0, the last one\n+ *  n. There may result empty parts.\n+ *  @param n Number of elements\n+ *  @param num_threads Number of parts\n+ *  @param s Splitters\n+ *  @returns End of splitter sequence, i. e. @c s+num_threads+1 */\n+template<typename difference_type, typename OutputIterator>\n   OutputIterator\n-  equally_split(_DifferenceTp n, thread_index_t p, OutputIterator s)\n+  equally_split(difference_type n,\n+                thread_index_t num_threads,\n+                OutputIterator s)\n   {\n-    typedef _DifferenceTp difference_type;\n-    difference_type chunk_length = n / p, split = n % p, start = 0;\n-    for (int i = 0; i < p; i++)\n+    difference_type chunk_length = n / num_threads,\n+                    num_longer_chunks = n % num_threads,\n+                    pos = 0;\n+    for (thread_index_t i = 0; i < num_threads; ++i)\n       {\n-\t*s++ = start;\n-\tstart += (difference_type(i) < split) ? (chunk_length + 1) : chunk_length;\n+        *s++ = pos;\n+        pos += (i < num_longer_chunks) ? (chunk_length + 1) : chunk_length;\n       }\n     *s++ = n;\n     return s;\n   }\n+\n+\n+/** @brief Function to split a sequence into parts of almost equal size.\n+ *\n+ *  Returns the position of the splitting point between\n+ *  thread number thread_no (included) and\n+ *  thread number thread_no+1 (excluded).\n+ *  @param n Number of elements\n+ *  @param num_threads Number of parts\n+ *  @returns Splitting point */\n+template<typename difference_type>\n+  difference_type\n+  equally_split_point(difference_type n,\n+                      thread_index_t num_threads,\n+                      thread_index_t thread_no)\n+  {\n+    difference_type chunk_length = n / num_threads,\n+                    num_longer_chunks = n % num_threads;\n+\n+    if(thread_no < num_longer_chunks)\n+      return thread_no * (chunk_length + 1);\n+    else\n+      return num_longer_chunks * (chunk_length + 1)\n+          + (thread_no - num_longer_chunks) * chunk_length;\n+  }\n }\n \n #endif"}, {"sha": "a78c16b8886c1a03ed9b1cd89882c09a1cf8e3b5", "filename": "libstdc++-v3/include/parallel/features.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffeatures.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -66,7 +66,7 @@\n  *  @brief Include guarded (sequences may run empty) loser tree,\n  *  moving objects.\n  *  @see __gnu_parallel::Settings multiway_merge_algorithm */\n-#define _GLIBCXX_LOSER_TREE 0\n+#define _GLIBCXX_LOSER_TREE 1\n #endif\n \n #ifndef _GLIBCXX_LOSER_TREE_EXPLICIT"}, {"sha": "2a5b22c629f39191e8cbaff0690df7ec7633507e", "filename": "libstdc++-v3/include/parallel/find.h", "status": "modified", "additions": 253, "deletions": 205, "changes": 458, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Ffind.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -10,7 +10,7 @@\n \n // This library is distributed in the hope that it will be useful, but\n // WITHOUT ANY WARRANTY; without even the implied warranty of\n-// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURstartE.  See the GNU\n // General Public License for more details.\n \n // You should have received a copy of the GNU General Public License\n@@ -48,50 +48,66 @@\n \n namespace __gnu_parallel\n {\n-  /** \n-   *  @brief Parallel std::find, switch for different algorithms.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence. Must have same\n-   *  length as first sequence.\n-   *  @param pred Find predicate.\n-   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n-   *  @return Place of finding in both sequences. \n-   */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+/**\n+ *  @brief Parallel std::find, switch for different algorithms.\n+ *  @param begin1 Begin iterator of first sequence.\n+ *  @param end1 End iterator of first sequence.\n+ *  @param begin2 Begin iterator of second sequence. Must have same\n+ *  length as first sequence.\n+ *  @param pred Find predicate.\n+ *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @return Place of finding in both sequences.\n+ */\n+template<\n+    typename RandomAccessIterator1,\n+    typename RandomAccessIterator2,\n+    typename Pred,\n+    typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector)\n+                RandomAccessIterator2 begin2, Pred pred, Selector selector)\n   {\n     switch (Settings::find_distribution)\n       {\n       case Settings::GROWING_BLOCKS:\n-\treturn find_template(begin1, end1, begin2, pred, selector, growing_blocks_tag());\n+        return find_template(begin1, end1, begin2, pred, selector,\n+                            growing_blocks_tag());\n       case Settings::CONSTANT_SIZE_BLOCKS:\n-\treturn find_template(begin1, end1, begin2, pred, selector, constant_size_blocks_tag());\n+        return find_template(begin1, end1, begin2, pred, selector,\n+                            constant_size_blocks_tag());\n       case Settings::EQUAL_SPLIT:\n-\treturn find_template(begin1, end1, begin2, pred, selector, equal_split_tag());\n+        return find_template(begin1, end1, begin2, pred, selector,\n+                            equal_split_tag());\n       default:\n-\t_GLIBCXX_PARALLEL_ASSERT(false);\n-\treturn std::make_pair(begin1, begin2);\n+        _GLIBCXX_PARALLEL_ASSERT(false);\n+        return std::make_pair(begin1, begin2);\n       }\n   }\n \n #if _GLIBCXX_FIND_EQUAL_SPLIT\n \n-  /** \n-   *  @brief Parallel std::find, equal splitting variant.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence. Second sequence\n-   *  must have same length as first sequence.\n-   *  @param pred Find predicate.\n-   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n-   *  @return Place of finding in both sequences. \n-   */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+/**\n+ *  @brief Parallel std::find, equal splitting variant.\n+ *  @param begin1 Begin iterator of first sequence.\n+ *  @param end1 End iterator of first sequence.\n+ *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  must have same length as first sequence.\n+ *  @param pred Find predicate.\n+ *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @return Place of finding in both sequences.\n+ */\n+template<\n+    typename RandomAccessIterator1,\n+    typename RandomAccessIterator2,\n+    typename Pred,\n+    typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n-  find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1, RandomAccessIterator2 begin2, Pred pred, Selector selector, equal_split_tag)\n+  find_template(RandomAccessIterator1 begin1,\n+                RandomAccessIterator1 end1,\n+                RandomAccessIterator2 begin2,\n+                Pred pred,\n+                Selector selector,\n+                equal_split_tag)\n   {\n     _GLIBCXX_CALL(end1 - begin1)\n \n@@ -100,79 +116,89 @@ namespace __gnu_parallel\n     typedef typename traits_type::value_type value_type;\n \n     difference_type length = end1 - begin1;\n-\n     difference_type result = length;\n+    difference_type* borders;\n \n-    const thread_index_t num_threads = get_max_threads();\n     omp_lock_t result_lock;\n     omp_init_lock(&result_lock);\n \n-    difference_type* borders = static_cast<difference_type*>(__builtin_alloca(sizeof(difference_type) * (num_threads + 1)));\n-\n-    equally_split(length, num_threads, borders);\n-\n-#pragma omp parallel shared(result) num_threads(num_threads)\n-    {\n-      int iam = omp_get_thread_num();\n-      difference_type pos = borders[iam], limit = borders[iam + 1];\n-\n-      RandomAccessIterator1 i1 = begin1 + pos;\n-      RandomAccessIterator2 i2 = begin2 + pos;\n-      for (; pos < limit; pos++)\n-\t{\n-#pragma omp flush(result)\n-          // Result has been set to something lower.\n-          if (result < pos)\n-            break;\n-\n-          if (selector(i1, i2, pred))\n-            {\n-              omp_set_lock(&result_lock);\n-              if (result > pos)\n-                result = pos;\n-              omp_unset_lock(&result_lock);\n+    thread_index_t num_threads = get_max_threads();\n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            borders = new difference_type[num_threads + 1];\n+            equally_split(length, num_threads, borders);\n+          } //single\n+\n+        thread_index_t iam = omp_get_thread_num();\n+        difference_type start = borders[iam], stop = borders[iam + 1];\n+\n+        RandomAccessIterator1 i1 = begin1 + start;\n+        RandomAccessIterator2 i2 = begin2 + start;\n+        for (difference_type pos = start; pos < stop; ++pos)\n+          {\n+            #pragma omp flush(result)\n+            // Result has been set to something lower.\n+            if (result < pos)\n               break;\n-            }\n-          i1++;\n-          i2++;\n-        }\n-    }\n+\n+            if (selector(i1, i2, pred))\n+              {\n+                omp_set_lock(&result_lock);\n+                if (pos < result)\n+                  result = pos;\n+                omp_unset_lock(&result_lock);\n+                break;\n+              }\n+            ++i1;\n+            ++i2;\n+          }\n+      } //parallel\n \n     omp_destroy_lock(&result_lock);\n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+    delete[] borders;\n+\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n+        begin1 + result, begin2 + result);\n   }\n \n #endif\n \n #if _GLIBCXX_FIND_GROWING_BLOCKS\n \n-  /** \n-   *  @brief Parallel std::find, growing block size variant.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence. Second sequence\n-   *  must have same length as first sequence.\n-   *  @param pred Find predicate.\n-   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n-   *  @return Place of finding in both sequences.\n-   *  @see __gnu_parallel::Settings::find_sequential_search_size\n-   *  @see __gnu_parallel::Settings::find_initial_block_size\n-   *  @see __gnu_parallel::Settings::find_maximum_block_size\n-   *  @see __gnu_parallel::Settings::find_increasing_factor\n-   *\n-   *  There are two main differences between the growing blocks and\n-   *  the constant-size blocks variants.\n-   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n-\n-   *  2. For GB, the blocks are allocated dynamically;\n-   *     for CSB, the blocks are allocated in a predetermined manner,\n-   *     namely spacial round-robin.\n-   */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+/**\n+ *  @brief Parallel std::find, growing block size variant.\n+ *  @param begin1 Begin iterator of first sequence.\n+ *  @param end1 End iterator of first sequence.\n+ *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  must have same length as first sequence.\n+ *  @param pred Find predicate.\n+ *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @return Place of finding in both sequences.\n+ *  @see __gnu_parallel::Settings::find_sequential_search_size\n+ *  @see __gnu_parallel::Settings::find_initial_block_size\n+ *  @see __gnu_parallel::Settings::find_maximum_block_size\n+ *  @see __gnu_parallel::Settings::find_increasing_factor\n+ *\n+ *  There are two main differences between the growing blocks and\n+ *  the constant-size blocks variants.\n+ *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+\n+ *  2. For GB, the blocks are allocated dynamically;\n+ *     for CSB, the blocks are allocated in a predetermined manner,\n+ *     namely spacial round-robin.\n+ */\n+template<\n+    typename RandomAccessIterator1,\n+    typename RandomAccessIterator2,\n+    typename Pred,\n+    typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector,\n-\t\tgrowing_blocks_tag)\n+                RandomAccessIterator2 begin2, Pred pred, Selector selector,\n+                growing_blocks_tag)\n   {\n     _GLIBCXX_CALL(end1 - begin1)\n \n@@ -182,101 +208,118 @@ namespace __gnu_parallel\n \n     difference_type length = end1 - begin1;\n \n-    difference_type sequential_search_size = std::min<difference_type>(length, Settings::find_sequential_search_size);\n+    difference_type sequential_search_size = std::min<difference_type>(\n+        length, Settings::find_sequential_search_size);\n \n     // Try it sequentially first.\n     std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n-      selector.sequential_algorithm(begin1, begin1 + sequential_search_size, begin2, pred);\n+      selector.sequential_algorithm(\n+          begin1, begin1 + sequential_search_size, begin2, pred);\n \n     if (find_seq_result.first != (begin1 + sequential_search_size))\n       return find_seq_result;\n \n     // Index of beginning of next free block (after sequential find).\n-    difference_type next_block_pos = sequential_search_size;\n+    difference_type next_block_start = sequential_search_size;\n     difference_type result = length;\n-    const thread_index_t num_threads = get_max_threads();\n \n     omp_lock_t result_lock;\n     omp_init_lock(&result_lock);\n \n-#pragma omp parallel shared(result) num_threads(num_threads)\n-    {\n-      // Not within first k elements -> start parallel.\n-      thread_index_t iam = omp_get_thread_num();\n-\n-      difference_type block_size = Settings::find_initial_block_size;\n-      difference_type start = fetch_and_add<difference_type>(&next_block_pos, block_size);\n-\n-      // Get new block, update pointer to next block.\n-      difference_type stop = std::min<difference_type>(length, start + block_size);\n-\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n-\n-      while (start < length)\n-\t{\n-#pragma omp flush(result)\n-\t  // Get new value of result.\n-\t  if (result < start)\n-\t    {\n-\t      // No chance to find first element.\n-\t      break;\n-\t    }\n-\n-\t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n-\t  if (local_result.first != (begin1 + stop))\n-\t    {\n-              omp_set_lock(&result_lock);\n-\t      if ((local_result.first - begin1) < result)\n-\t\t{\n-\t\t  result = local_result.first - begin1;\n-\n-\t\t  // Result cannot be in future blocks, stop algorithm.\n-\t\t  fetch_and_add<difference_type>(&next_block_pos, length);\n-\t\t}\n-              omp_unset_lock(&result_lock);\n-\t    }\n-\n-\t  block_size = std::min<difference_type>(block_size * Settings::find_increasing_factor, Settings::find_maximum_block_size);\n-\n-\t  // Get new block, update pointer to next block.\n-\t  start = fetch_and_add<difference_type>(&next_block_pos, block_size);\n-\t  stop = (length < (start + block_size)) ? length : (start + block_size);\n-\t}\n-    }\n+    thread_index_t num_threads = get_max_threads();\n+#   pragma omp parallel shared(result) num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          num_threads = omp_get_num_threads();\n+\n+        // Not within first k elements -> start parallel.\n+        thread_index_t iam = omp_get_thread_num();\n+\n+        difference_type block_size = Settings::find_initial_block_size;\n+        difference_type start =\n+            fetch_and_add<difference_type>(&next_block_start, block_size);\n+\n+        // Get new block, update pointer to next block.\n+        difference_type stop =\n+            std::min<difference_type>(length, start + block_size);\n+\n+        std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+\n+        while (start < length)\n+          {\n+#           pragma omp flush(result)\n+            // Get new value of result.\n+            if (result < start)\n+              {\n+                // No chance to find first element.\n+                break;\n+              }\n+\n+            local_result = selector.sequential_algorithm(\n+                begin1 + start, begin1 + stop, begin2 + start, pred);\n+            if (local_result.first != (begin1 + stop))\n+              {\n+                omp_set_lock(&result_lock);\n+                if ((local_result.first - begin1) < result)\n+                  {\n+                    result = local_result.first - begin1;\n+\n+                    // Result cannot be in future blocks, stop algorithm.\n+                    fetch_and_add<difference_type>(&next_block_start, length);\n+                  }\n+                  omp_unset_lock(&result_lock);\n+              }\n+\n+            block_size = std::min<difference_type>(\n+                block_size * Settings::find_increasing_factor,\n+                Settings::find_maximum_block_size);\n+\n+            // Get new block, update pointer to next block.\n+            start =\n+                fetch_and_add<difference_type>(&next_block_start, block_size);\n+            stop = (length < (start + block_size)) ?\n+                        length : (start + block_size);\n+          }\n+      } //parallel\n \n     omp_destroy_lock(&result_lock);\n \n     // Return iterator on found element.\n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n+        begin1 + result, begin2 + result);\n   }\n \n #endif\n \n #if _GLIBCXX_FIND_CONSTANT_SIZE_BLOCKS\n \n-  /** \n-   *   @brief Parallel std::find, constant block size variant.\n-   *  @param begin1 Begin iterator of first sequence.\n-   *  @param end1 End iterator of first sequence.\n-   *  @param begin2 Begin iterator of second sequence. Second sequence\n-   *  must have same length as first sequence.\n-   *  @param pred Find predicate.\n-   *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n-   *  @return Place of finding in both sequences.\n-   *  @see __gnu_parallel::Settings::find_sequential_search_size\n-   *  @see __gnu_parallel::Settings::find_block_size\n-   *  There are two main differences between the growing blocks and the\n-   *  constant-size blocks variants.\n-   *  1. For GB, the block size grows; for CSB, the block size is fixed.\n-   *  2. For GB, the blocks are allocated dynamically; for CSB, the\n-   *  blocks are allocated in a predetermined manner, namely spacial\n-   *  round-robin.\n-   */\n-  template<typename RandomAccessIterator1, typename RandomAccessIterator2, typename Pred, typename Selector>\n+/**\n+ *   @brief Parallel std::find, constant block size variant.\n+ *  @param begin1 Begin iterator of first sequence.\n+ *  @param end1 End iterator of first sequence.\n+ *  @param begin2 Begin iterator of second sequence. Second sequence\n+ *  must have same length as first sequence.\n+ *  @param pred Find predicate.\n+ *  @param selector Functionality (e. g. std::find_if (), std::equal(),...)\n+ *  @return Place of finding in both sequences.\n+ *  @see __gnu_parallel::Settings::find_sequential_search_size\n+ *  @see __gnu_parallel::Settings::find_block_size\n+ *  There are two main differences between the growing blocks and the\n+ *  constant-size blocks variants.\n+ *  1. For GB, the block size grows; for CSB, the block size is fixed.\n+ *  2. For GB, the blocks are allocated dynamically; for CSB, the\n+ *  blocks are allocated in a predetermined manner, namely spacial\n+ *  round-robin.\n+ */\n+template<\n+    typename RandomAccessIterator1,\n+    typename RandomAccessIterator2,\n+    typename Pred,\n+    typename Selector>\n   std::pair<RandomAccessIterator1, RandomAccessIterator2>\n   find_template(RandomAccessIterator1 begin1, RandomAccessIterator1 end1,\n-\t\tRandomAccessIterator2 begin2, Pred pred, Selector selector,\n-\t\tconstant_size_blocks_tag)\n+                RandomAccessIterator2 begin2, Pred pred, Selector selector,\n+                constant_size_blocks_tag)\n   {\n     _GLIBCXX_CALL(end1 - begin1)\n     typedef std::iterator_traits<RandomAccessIterator1> traits_type;\n@@ -285,72 +328,77 @@ namespace __gnu_parallel\n \n     difference_type length = end1 - begin1;\n \n-    difference_type sequential_search_size = std::min<difference_type>(length, Settings::find_sequential_search_size);\n+    difference_type sequential_search_size = std::min<difference_type>(\n+        length, Settings::find_sequential_search_size);\n \n     // Try it sequentially first.\n     std::pair<RandomAccessIterator1, RandomAccessIterator2> find_seq_result =\n-      selector.sequential_algorithm(begin1, begin1 + sequential_search_size, begin2, pred);\n+      selector.sequential_algorithm(begin1, begin1 + sequential_search_size,\n+                                    begin2, pred);\n \n     if (find_seq_result.first != (begin1 + sequential_search_size))\n       return find_seq_result;\n \n     difference_type result = length;\n-    const thread_index_t num_threads = get_max_threads();\n-\n     omp_lock_t result_lock;\n     omp_init_lock(&result_lock);\n \n     // Not within first sequential_search_size elements -> start parallel.\n-#pragma omp parallel shared(result) num_threads(num_threads)\n-    {\n-      thread_index_t iam = omp_get_thread_num();\n-      difference_type block_size = Settings::find_initial_block_size;\n-\n-      difference_type start, stop;\n-\n-      // First element of thread's current iteration.\n-      difference_type iteration_start = sequential_search_size;\n-\n-      // Where to work (initialization).\n-      start = iteration_start + iam * block_size;\n-      stop = std::min<difference_type>(length, start + block_size);\n-\n-      std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n-\n-      while (start < length)\n-\t{\n-\t  // Get new value of result.\n-#pragma omp flush(result)\n-\t  // No chance to find first element.\n-\t  if (result < start)\n-\t    break;\n-\n-\t  local_result = selector.sequential_algorithm(begin1 + start, begin1 + stop, begin2 + start, pred);\n-\t  if (local_result.first != (begin1 + stop))\n-\t    {\n-\t      omp_set_lock(&result_lock);\n-\t      if ((local_result.first - begin1) < result)\n-\t\tresult = local_result.first - begin1;\n-              omp_unset_lock(&result_lock);\n-\t      // Will not find better value in its interval.\n-\t      break;\n-\t    }\n-\n-\t  iteration_start += num_threads * block_size;\n-\n-\t  // Where to work.\n-\t  start = iteration_start + iam * block_size;\n-\t  stop = std::min<difference_type>(length, start + block_size);\n-\t}\n-    }\n+\n+    thread_index_t num_threads = get_max_threads();\n+#   pragma omp parallel shared(result) num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          num_threads = omp_get_num_threads();\n+\n+        thread_index_t iam = omp_get_thread_num();\n+        difference_type block_size = Settings::find_initial_block_size;\n+\n+        // First element of thread's current iteration.\n+        difference_type iteration_start = sequential_search_size;\n+\n+        // Where to work (initialization).\n+        difference_type start = iteration_start + iam * block_size;\n+        difference_type stop =\n+            std::min<difference_type>(length, start + block_size);\n+\n+        std::pair<RandomAccessIterator1, RandomAccessIterator2> local_result;\n+\n+        while (start < length)\n+          {\n+            // Get new value of result.\n+#           pragma omp flush(result)\n+            // No chance to find first element.\n+            if (result < start)\n+              break;\n+            local_result = selector.sequential_algorithm(\n+                begin1 + start, begin1 + stop,\n+                begin2 + start, pred);\n+            if (local_result.first != (begin1 + stop))\n+              {\n+                omp_set_lock(&result_lock);\n+                if ((local_result.first - begin1) < result)\n+                  result = local_result.first - begin1;\n+                omp_unset_lock(&result_lock);\n+                // Will not find better value in its interval.\n+                break;\n+              }\n+\n+            iteration_start += num_threads * block_size;\n+\n+            // Where to work.\n+            start = iteration_start + iam * block_size;\n+            stop = std::min<difference_type>(length, start + block_size);\n+          }\n+      } //parallel\n \n     omp_destroy_lock(&result_lock);\n \n     // Return iterator on found element.\n-    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(begin1 + result, begin2 + result);\n+    return std::pair<RandomAccessIterator1, RandomAccessIterator2>(\n+        begin1 + result, begin2 + result);\n   }\n #endif\n } // end namespace\n \n #endif\n-"}, {"sha": "7b8b654baa16e2e70421ade061f27195979725b7", "filename": "libstdc++-v3/include/parallel/losertree.h", "status": "modified", "additions": 415, "deletions": 434, "changes": 849, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Flosertree.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -29,9 +29,9 @@\n // Public License.\n \n /** @file parallel/losertree.h\n- *  @brief Many generic loser tree variants.\n- *  This file is a GNU parallel extension to the Standard C++ Library.\n- */\n+*  @brief Many generic loser tree variants.\n+*  This file is a GNU parallel extension to the Standard C++ Library.\n+*/\n \n // Written by Johannes Singler.\n \n@@ -49,13 +49,13 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_LOSER_TREE_EXPLICIT\n \n-  /** @brief Guarded loser tree, copying the whole element into the\n-   * tree structure.\n-   *\n-   *  Guarding is done explicitly through two flags per element, inf\n-   *  and sup This is a quite slow variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Guarded loser tree, copying the whole element into the\n+* tree structure.\n+*\n+*  Guarding is done explicitly through two flags per element, inf\n+*  and sup This is a quite slow variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTreeExplicit\n   {\n   private:\n@@ -76,26 +76,25 @@ namespace __gnu_parallel\n     Comparator comp;\n \n   public:\n-    inline LoserTreeExplicit(unsigned int _size, Comparator _comp = std::less<T>()) : comp(_comp)\n+    inline\n+    LoserTreeExplicit(unsigned int _size, Comparator _comp = std::less<T>())\n+      : comp(_comp)\n     {\n       size = _size;\n       offset = size;\n       losers = new Loser[size];\n       for (unsigned int l = 0; l < size; l++)\n-\t{\n-\t  //losers[l].key = ... \tstays unset\n-\t  losers[l].inf = true;\n-\t  losers[l].sup = false;\n-\t  //losers[l].source = -1;\t//sentinel\n-\t}\n+        {\n+          //losers[l].key = ... \tstays unset\n+          losers[l].inf = true;\n+          losers[l].sup = false;\n+          //losers[l].source = -1;\t//sentinel\n+        }\n     }\n \n     inline ~LoserTreeExplicit()\n     { delete[] losers; }\n \n-    inline void\n-    print() { }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -105,16 +104,17 @@ namespace __gnu_parallel\n     {\n       bool inf = false;\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup && comp(losers[pos].key, key)) || losers[pos].inf || sup)\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].key, key);\n-\t      std::swap(losers[pos].inf, inf);\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t    }\n-\t}\n+        {\n+          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n+               && comp(losers[pos].key, key)) || losers[pos].inf || sup)\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].key, key);\n+              std::swap(losers[pos].inf, inf);\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+            }\n+        }\n \n       losers[0].key = key;\n       losers[0].inf = inf;\n@@ -131,19 +131,19 @@ namespace __gnu_parallel\n       bool inf = false;\n       int source = losers[0].source;\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup \n-\t       && comp(losers[pos].key, key))\n-\t      || losers[pos].inf || sup)\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].key, key);\n-\t      std::swap(losers[pos].inf, inf);\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted.\n+          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n+              && comp(losers[pos].key, key))\n+              || losers[pos].inf || sup)\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].key, key);\n+              std::swap(losers[pos].inf, inf);\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+            }\n+        }\n \n       losers[0].key = key;\n       losers[0].inf = inf;\n@@ -156,19 +156,19 @@ namespace __gnu_parallel\n     {\n       bool inf = false;\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup &&\n-\t       ((comp(losers[pos].key, key)) ||\n-\t\t(!comp(key, losers[pos].key) && losers[pos].source < source)))\n-\t      || losers[pos].inf || sup)\n-\t    {\n-\t      // Take next key.\n-\t      std::swap(losers[pos].key, key);\n-\t      std::swap(losers[pos].inf, inf);\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t    }\n-\t}\n+        {\n+          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup &&\n+              ((comp(losers[pos].key, key)) ||\n+                (!comp(key, losers[pos].key) && losers[pos].source < source)))\n+              || losers[pos].inf || sup)\n+            {\n+              // Take next key.\n+              std::swap(losers[pos].key, key);\n+              std::swap(losers[pos].inf, inf);\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+            }\n+        }\n \n       losers[0].key = key;\n       losers[0].inf = inf;\n@@ -185,18 +185,18 @@ namespace __gnu_parallel\n       bool inf = false;\n       int source = losers[0].source;\n       for (unsigned int pos = (offset + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n-\t       && ((comp(losers[pos].key, key)) ||\n-\t\t(!comp(key, losers[pos].key) && losers[pos].source < source)))\n-\t      || losers[pos].inf || sup)\n-\t    {\n-\t      std::swap(losers[pos].key, key);\n-\t      std::swap(losers[pos].inf, inf);\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t    }\n-\t}\n+        {\n+          if ((!inf && !losers[pos].inf && !sup && !losers[pos].sup\n+              && ((comp(losers[pos].key, key)) ||\n+                (!comp(key, losers[pos].key) && losers[pos].source < source)))\n+              || losers[pos].inf || sup)\n+            {\n+              std::swap(losers[pos].key, key);\n+              std::swap(losers[pos].inf, inf);\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+            }\n+        }\n \n       losers[0].key = key;\n       losers[0].inf = inf;\n@@ -209,14 +209,14 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_LOSER_TREE\n \n-  /** @brief Guarded loser tree, either copying the whole element into\n-   * the tree structure, or looking up the element via the index.\n-   *\n-   *  Guarding is done explicitly through one flag sup per element,\n-   *  inf is not needed due to a better initialization routine.  This\n-   *  is a well-performing variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Guarded loser tree, either copying the whole element into\n+* the tree structure, or looking up the element via the index.\n+*\n+*  Guarding is done explicitly through one flag sup per element,\n+*  inf is not needed due to a better initialization routine.  This\n+*  is a well-performing variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTree\n   {\n   private:\n@@ -240,22 +240,14 @@ namespace __gnu_parallel\n       // Next greater power of 2.\n       k = 1 << (log2(ik - 1) + 1);\n       offset = k;\n-      losers = new Loser[k * 2];\n+      losers = static_cast<Loser*>(::operator new(k * 2 * sizeof(Loser)));\n       for (unsigned int i = ik - 1; i < k; i++)\n-\tlosers[i + k].sup = true;\n+        losers[i + k].sup = true;\n     }\n \n     inline ~LoserTree()\n     { delete[] losers; }\n \n-    void\n-    print()\n-    {\n-      for (unsigned int i = 0; i < (k * 2); i++)\n-\tprintf(\"%d    %d from %d,  %d\\n\", i, losers[i].key, \n-\t       losers[i].source, losers[i].sup);\n-    }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -267,33 +259,34 @@ namespace __gnu_parallel\n \n       losers[pos].sup = sup;\n       losers[pos].source = source;\n-      losers[pos].key = key;\n+      new(&(losers[pos].key)) T(key);\n     }\n \n     unsigned int\n     init_winner (unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (losers[right].sup ||\n-\t      (!losers[left].sup && !comp(losers[right].key, losers[left].key)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\t// Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (losers[right].sup ||\n+              (!losers[left].sup\n+                && !comp(losers[right].key, losers[left].key)))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\t// Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -306,16 +299,16 @@ namespace __gnu_parallel\n     {\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].key, key);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted.\n+          if (sup || (!losers[pos].sup && comp(losers[pos].key, key)))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].key, key);\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -330,27 +323,28 @@ namespace __gnu_parallel\n     init_winner_stable (unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (\tlosers[right].sup ||\n-\t\t(!losers[left].sup && !comp(losers[right].key, losers[left].key)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (losers[right].sup\n+              || (!losers[left].sup\n+                && !comp(losers[right].key, losers[left].key)))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -363,19 +357,20 @@ namespace __gnu_parallel\n     {\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by source.\n-\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-\t\t(!sup && !losers[pos].sup &&\n-\t\t ((comp(losers[pos].key, key)) ||\n-\t\t  (!comp(key, losers[pos].key) && losers[pos].source < source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].key, key);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted, ties are broken by source.\n+          if (\t(sup && (!losers[pos].sup || losers[pos].source < source))\n+                || (!sup && !losers[pos].sup\n+                  && ((comp(losers[pos].key, key))\n+                    || (!comp(key, losers[pos].key)\n+                      && losers[pos].source < source))))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].key, key);\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -387,14 +382,14 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_LOSER_TREE_REFERENCE\n \n-  /** @brief Guarded loser tree, either copying the whole element into\n-   * the tree structure, or looking up the element via the index.\n-   *\n-   *  Guarding is done explicitly through one flag sup per element,\n-   *  inf is not needed due to a better initialization routine.  This\n-   *  is a well-performing variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Guarded loser tree, either copying the whole element into\n+* the tree structure, or looking up the element via the index.\n+*\n+*  Guarding is done explicitly through one flag sup per element,\n+*  inf is not needed due to a better initialization routine.  This\n+*  is a well-performing variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTreeReference\n   {\n #undef COPY\n@@ -423,7 +418,9 @@ namespace __gnu_parallel\n     Comparator comp;\n \n   public:\n-    inline LoserTreeReference(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    inline\n+    LoserTreeReference(unsigned int _k, Comparator _comp = std::less<T>())\n+      : comp(_comp)\n     {\n       ik = _k;\n \n@@ -435,7 +432,7 @@ namespace __gnu_parallel\n       keys = new T[ik];\n #endif\n       for (unsigned int i = ik - 1; i < k; i++)\n-\tlosers[i + k].sup = true;\n+        losers[i + k].sup = true;\n     }\n \n     inline ~LoserTreeReference()\n@@ -446,13 +443,6 @@ namespace __gnu_parallel\n #endif\n     }\n \n-    void\n-    print()\n-    {\n-      for (unsigned int i = 0; i < (k * 2); i++)\n-\tprintf(\"%d    %d from %d,  %d\\n\", i, KEY(i), losers[i].source, losers[i].sup);\n-    }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -471,27 +461,27 @@ namespace __gnu_parallel\n     init_winner(unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (\tlosers[right].sup ||\n-\t\t(!losers[left].sup && !comp(KEY(right), KEY(left))))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (\tlosers[right].sup ||\n+                (!losers[left].sup && !comp(KEY(right), KEY(left))))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -505,18 +495,18 @@ namespace __gnu_parallel\n     {\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (sup || (!losers[pos].sup && comp(KEY(pos), KEY_SOURCE(source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n+        {\n+          // The smaller one gets promoted.\n+          if (sup || (!losers[pos].sup && comp(KEY(pos), KEY_SOURCE(source))))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n #ifdef COPY\n-\t      std::swap(KEY(pos), KEY_SOURCE(source));\n+              std::swap(KEY(pos), KEY_SOURCE(source));\n #endif\n-\t    }\n-\t}\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -533,27 +523,27 @@ namespace __gnu_parallel\n     init_winner_stable(unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (losers[right].sup\n-\t      || (!losers[left].sup && !comp(KEY(right), KEY(left))))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (losers[right].sup\n+              || (!losers[left].sup && !comp(KEY(right), KEY(left))))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -565,21 +555,22 @@ namespace __gnu_parallel\n     {\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by source.\n-\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-\t\t(!sup && !losers[pos].sup &&\n-\t\t ((comp(KEY(pos), KEY_SOURCE(source))) ||\n-\t\t  (!comp(KEY_SOURCE(source), KEY(pos)) && losers[pos].source < source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n+        {\n+          // The smaller one gets promoted, ties are broken by source.\n+          if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+                (!sup && !losers[pos].sup &&\n+                ((comp(KEY(pos), KEY_SOURCE(source))) ||\n+                  (!comp(KEY_SOURCE(source), KEY(pos))\n+                    && losers[pos].source < source))))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n #ifdef COPY\n-\t      std::swap(KEY(pos), KEY_SOURCE(source));\n+              std::swap(KEY(pos), KEY_SOURCE(source));\n #endif\n-\t    }\n-\t}\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -595,13 +586,13 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_LOSER_TREE_POINTER\n \n-  /** @brief Guarded loser tree, either copying the whole element into\n-      the tree structure, or looking up the element via the index.\n-   *  Guarding is done explicitly through one flag sup per element,\n-   *  inf is not needed due to a better initialization routine.\n-   *  This is a well-performing variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Guarded loser tree, either copying the whole element into\n+    the tree structure, or looking up the element via the index.\n+*  Guarding is done explicitly through one flag sup per element,\n+*  inf is not needed due to a better initialization routine.\n+*  This is a well-performing variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTreePointer\n   {\n   private:\n@@ -617,7 +608,9 @@ namespace __gnu_parallel\n     Comparator comp;\n \n   public:\n-    inline LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    inline\n+    LoserTreePointer(unsigned int _k, Comparator _comp = std::less<T>())\n+      : comp(_comp)\n     {\n       ik = _k;\n \n@@ -626,19 +619,12 @@ namespace __gnu_parallel\n       offset = k;\n       losers = new Loser[k * 2];\n       for (unsigned int i = ik - 1; i < k; i++)\n-\tlosers[i + k].sup = true;\n+        losers[i + k].sup = true;\n     }\n \n     inline ~LoserTreePointer()\n     { delete[] losers; }\n \n-    void\n-    print()\n-    {\n-      for (unsigned int i = 0; i < (k * 2); i++)\n-\tprintf(\"%d    %d from %d,  %d\\n\", i, losers[i].keyp, losers[i].source, losers[i].sup);\n-    }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -657,49 +643,50 @@ namespace __gnu_parallel\n     init_winner(unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (\tlosers[right].sup ||\n-\t\t(!losers[left].sup && !comp(*losers[right].keyp, *losers[left].keyp)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (losers[right].sup\n+                || (!losers[left].sup\n+                  && !comp(*losers[right].keyp, *losers[left].keyp)))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n     init()\n     { losers[0] = losers[init_winner(1)]; }\n \n-    inline void \n+    inline void\n     delete_min_insert(const T& key, bool sup)\n     {\n       const T* keyp = &key;\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].keyp, keyp);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted.\n+          if (sup || (!losers[pos].sup && comp(*losers[pos].keyp, *keyp)))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].keyp, keyp);\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -714,28 +701,28 @@ namespace __gnu_parallel\n     init_winner_stable(unsigned int root)\n     {\n       if (root >= k)\n-\t{\n-\t  return root;\n-\t}\n+        {\n+          return root;\n+        }\n       else\n-\t{\n-\t  unsigned int left = init_winner (2 * root);\n-\t  unsigned int right = init_winner (2 * root + 1);\n-\t  if (losers[right].sup\n-\t      || (!losers[left].sup && !comp(*losers[right].keyp, \n-\t\t\t\t\t     *losers[left].keyp)))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          unsigned int left = init_winner (2 * root);\n+          unsigned int right = init_winner (2 * root + 1);\n+          if (losers[right].sup\n+              || (!losers[left].sup && !comp(*losers[right].keyp,\n+                                            *losers[left].keyp)))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -748,20 +735,20 @@ namespace __gnu_parallel\n       const T* keyp = &key;\n       int source = losers[0].source;\n       for (unsigned int pos = (k + source) / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by source.\n-\t  if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n-\t\t(!sup && !losers[pos].sup &&\n-\t\t ((comp(*losers[pos].keyp, *keyp)) ||\n-\t\t  (!comp(*keyp, *losers[pos].keyp) \n-\t\t   && losers[pos].source < source))))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].sup, sup);\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].keyp, keyp);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted, ties are broken by source.\n+          if (\t(sup && (!losers[pos].sup || losers[pos].source < source)) ||\n+                (!sup && !losers[pos].sup &&\n+                ((comp(*losers[pos].keyp, *keyp)) ||\n+                  (!comp(*keyp, *losers[pos].keyp)\n+                  && losers[pos].source < source))))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].sup, sup);\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].keyp, keyp);\n+            }\n+        }\n \n       losers[0].sup = sup;\n       losers[0].source = source;\n@@ -773,13 +760,13 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_LOSER_TREE_UNGUARDED\n \n-  /** @brief Unguarded loser tree, copying the whole element into the\n-   * tree structure.\n-   *\n-   *  No guarding is done, therefore not a single input sequence must\n-   *  run empty.  This is a very fast variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Unguarded loser tree, copying the whole element into the\n+* tree structure.\n+*\n+*  No guarding is done, therefore not a single input sequence must\n+*  run empty.  This is a very fast variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTreeUnguarded\n   {\n   private:\n@@ -798,18 +785,20 @@ namespace __gnu_parallel\n     map(unsigned int root, unsigned int begin, unsigned int end)\n     {\n       if (begin + 1 == end)\n-\tmapping[begin] = root;\n+        mapping[begin] = root;\n       else\n-\t{\n-\t  // Next greater or equal power of 2.\n-\t  unsigned int left = 1 << (log2(end - begin - 1));\n-\t  map(root * 2, begin, begin + left);\n-\t  map(root * 2 + 1, begin + left, end);\n-\t}\n+        {\n+          // Next greater or equal power of 2.\n+          unsigned int left = 1 << (log2(end - begin - 1));\n+          map(root * 2, begin, begin + left);\n+          map(root * 2 + 1, begin + left, end);\n+        }\n     }\n \n   public:\n-    inline LoserTreeUnguarded(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    inline\n+    LoserTreeUnguarded(unsigned int _k, Comparator _comp = std::less<T>())\n+      : comp(_comp)\n     {\n       ik = _k;\n       // Next greater or equal power of 2.\n@@ -826,13 +815,6 @@ namespace __gnu_parallel\n       delete[] mapping;\n     }\n \n-    void\n-    print()\n-    {\n-      for (unsigned int i = 0; i < k + ik; i++)\n-\tprintf(\"%d    %d from %d\\n\", i, losers[i].key, losers[i].source);\n-    }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -849,26 +831,27 @@ namespace __gnu_parallel\n     init_winner(unsigned int root, unsigned int begin, unsigned int end)\n     {\n       if (begin + 1 == end)\n-\treturn mapping[begin];\n+        return mapping[begin];\n       else\n-\t{\n-\t  // Next greater or equal power of 2.\n-\t  unsigned int division = 1 << (log2(end - begin - 1));\n-\t  unsigned int left = init_winner(2 * root, begin, begin + division);\n-\t  unsigned int right = init_winner(2 * root + 1, begin + division, end);\n-\t  if (!comp(losers[right].key, losers[left].key))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          // Next greater or equal power of 2.\n+          unsigned int division = 1 << (log2(end - begin - 1));\n+          unsigned int left = init_winner(2 * root, begin, begin + division);\n+          unsigned int right =\n+                          init_winner(2 * root + 1, begin + division, end);\n+          if (!comp(losers[right].key, losers[left].key))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -883,15 +866,15 @@ namespace __gnu_parallel\n       T& keyr = losers[0].key;\n       int& source = losers[0].source;\n       for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (comp(losers[pos].key, keyr))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].key, keyr);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted.\n+          if (comp(losers[pos].key, keyr))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].key, keyr);\n+            }\n+        }\n     }\n \n     inline void\n@@ -909,30 +892,31 @@ namespace __gnu_parallel\n       T& keyr = losers[0].key;\n       int& source = losers[0].source;\n       for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by source.\n-\t  if (comp(losers[pos].key, keyr)\n-\t      || (!comp(keyr, losers[pos].key) && losers[pos].source < source))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].key, keyr);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted, ties are broken by source.\n+          if (comp(losers[pos].key, keyr)\n+              || (!comp(keyr, losers[pos].key)\n+                && losers[pos].source < source))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].key, keyr);\n+            }\n+        }\n     }\n   };\n \n #endif\n \n #if _GLIBCXX_LOSER_TREE_POINTER_UNGUARDED\n \n-  /** @brief Unguarded loser tree, keeping only pointers to the\n-   * elements in the tree structure.\n-   *\n-   *  No guarding is done, therefore not a single input sequence must\n-   *  run empty.  This is a very fast variant.\n-   */\n-  template<typename T, typename Comparator = std::less<T> >\n+/** @brief Unguarded loser tree, keeping only pointers to the\n+* elements in the tree structure.\n+*\n+*  No guarding is done, therefore not a single input sequence must\n+*  run empty.  This is a very fast variant.\n+*/\n+template<typename T, typename Comparator = std::less<T> >\n   class LoserTreePointerUnguarded\n   {\n   private:\n@@ -950,18 +934,21 @@ namespace __gnu_parallel\n     void map(unsigned int root, unsigned int begin, unsigned int end)\n     {\n       if (begin + 1 == end)\n-\tmapping[begin] = root;\n+        mapping[begin] = root;\n       else\n-\t{\n-\t  // Next greater or equal power of 2.\n-\t  unsigned int left = 1 << (log2(end - begin - 1));\n-\t  map(root * 2, begin, begin + left);\n-\t  map(root * 2 + 1, begin + left, end);\n-\t}\n+        {\n+          // Next greater or equal power of 2.\n+          unsigned int left = 1 << (log2(end - begin - 1));\n+          map(root * 2, begin, begin + left);\n+          map(root * 2 + 1, begin + left, end);\n+        }\n     }\n \n   public:\n-    inline LoserTreePointerUnguarded(unsigned int _k, Comparator _comp = std::less<T>()) : comp(_comp)\n+    inline\n+    LoserTreePointerUnguarded(unsigned int _k,\n+                              Comparator _comp = std::less<T>())\n+      : comp(_comp)\n     {\n       ik = _k;\n \n@@ -979,13 +966,6 @@ namespace __gnu_parallel\n       delete[] mapping;\n     }\n \n-    void\n-    print()\n-    {\n-      for (unsigned int i = 0; i < k + ik; i++)\n-\tprintf(\"%d    %d from %d\\n\", i, *losers[i].keyp, losers[i].source);\n-    }\n-\n     inline int\n     get_min_source()\n     { return losers[0].source; }\n@@ -1002,26 +982,27 @@ namespace __gnu_parallel\n     init_winner(unsigned int root, unsigned int begin, unsigned int end)\n     {\n       if (begin + 1 == end)\n-\treturn mapping[begin];\n+        return mapping[begin];\n       else\n-\t{\n-\t  // Next greater or equal power of 2.\n-\t  unsigned int division = 1 << (log2(end - begin - 1));\n-\t  unsigned int left = init_winner(2 * root, begin, begin + division);\n-\t  unsigned int right = init_winner(2 * root + 1, begin + division, end);\n-\t  if (!comp(*losers[right].keyp, *losers[left].keyp))\n-\t    {\n-\t      // Left one is less or equal.\n-\t      losers[root] = losers[right];\n-\t      return left;\n-\t    }\n-\t  else\n-\t    {\n-\t      // Right one is less.\n-\t      losers[root] = losers[left];\n-\t      return right;\n-\t    }\n-\t}\n+        {\n+          // Next greater or equal power of 2.\n+          unsigned int division = 1 << (log2(end - begin - 1));\n+          unsigned int left = init_winner(2 * root, begin, begin + division);\n+          unsigned int right\n+                          = init_winner(2 * root + 1, begin + division, end);\n+          if (!comp(*losers[right].keyp, *losers[left].keyp))\n+            {\n+              // Left one is less or equal.\n+              losers[root] = losers[right];\n+              return left;\n+            }\n+          else\n+            {\n+              // Right one is less.\n+              losers[root] = losers[left];\n+              return right;\n+            }\n+        }\n     }\n \n     inline void\n@@ -1036,15 +1017,15 @@ namespace __gnu_parallel\n       const T* keyp = &key;\n       int& source = losers[0].source;\n       for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted.\n-\t  if (comp(*losers[pos].keyp, *keyp))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].keyp, keyp);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted.\n+          if (comp(*losers[pos].keyp, *keyp))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].keyp, keyp);\n+            }\n+        }\n \n       losers[0].keyp = keyp;\n     }\n@@ -1063,23 +1044,23 @@ namespace __gnu_parallel\n       int& source = losers[0].source;\n       const T* keyp = &key;\n       for (int pos = mapping[source] / 2; pos > 0; pos /= 2)\n-\t{\n-\t  // The smaller one gets promoted, ties are broken by source.\n-\t  if (comp(*losers[pos].keyp, *keyp)\n-\t      || (!comp(*keyp, *losers[pos].keyp) \n-\t\t  && losers[pos].source < source))\n-\t    {\n-\t      // The other one is smaller.\n-\t      std::swap(losers[pos].source, source);\n-\t      std::swap(losers[pos].keyp, keyp);\n-\t    }\n-\t}\n+        {\n+          // The smaller one gets promoted, ties are broken by source.\n+          if (comp(*losers[pos].keyp, *keyp)\n+              || (!comp(*keyp, *losers[pos].keyp)\n+                  && losers[pos].source < source))\n+            {\n+              // The other one is smaller.\n+              std::swap(losers[pos].source, source);\n+              std::swap(losers[pos].keyp, keyp);\n+            }\n+        }\n       losers[0].keyp = keyp;\n     }\n   };\n #endif\n \n-  template<typename _ValueTp, class Comparator>\n+template<typename _ValueTp, class Comparator>\n   struct loser_tree_traits\n   {\n #if _GLIBCXX_LOSER_TREE\n@@ -1093,7 +1074,7 @@ namespace __gnu_parallel\n #endif\n   };\n \n-  template<typename _ValueTp, class Comparator>\n+template<typename _ValueTp, class Comparator>\n   struct loser_tree_unguarded_traits\n   {\n #if _GLIBCXX_LOSER_TREE_UNGUARDED"}, {"sha": "67f2f8cb1dac3fe3ea515c67dc8abdf8de869578", "filename": "libstdc++-v3/include/parallel/multiway_merge.h", "status": "modified", "additions": 1024, "deletions": 773, "changes": 1797, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_merge.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -29,16 +29,16 @@\n // Public License.\n \n /** @file parallel/multiway_merge.h\n- *  @brief Implementation of sequential and parallel multiway merge.\n- *\n- *  Explanations on the high-speed merging routines in the appendix of\n- *\n- *  P. Sanders.\n- *  Fast priority queues for cached memory.\n- *  ACM Journal of Experimental Algorithmics, 5, 2000.\n- *\n- *  This file is a GNU parallel extension to the Standard C++ Library.\n- */\n+*  @brief Implementation of sequential and parallel multiway merge.\n+*\n+*  Explanations on the high-speed merging routines in the appendix of\n+*\n+*  P. Sanders.\n+*  Fast priority queues for cached memory.\n+*  ACM Journal of Experimental Algorithmics, 5, 2000.\n+*\n+*  This file is a GNU parallel extension to the Standard C++ Library.\n+*/\n \n // Written by Johannes Singler.\n \n@@ -62,25 +62,25 @@\n // XXX need iterator typedefs\n namespace __gnu_parallel\n {\n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   class guarded_iterator;\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t    guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+            guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+            guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n   /** @brief Iterator wrapper supporting an implicit supremum at the end\n       of the sequence, dominating all comparisons.\n       *  Deriving from RandomAccessIterator is not possible since\n       *  RandomAccessIterator need not be a class.\n       */\n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   class guarded_iterator\n   {\n   private:\n@@ -95,17 +95,17 @@ namespace __gnu_parallel\n \n   public:\n     /** @brief Constructor. Sets iterator to beginning of sequence.\n-     *  @param begin Begin iterator of sequence.\n-     *  @param end End iterator of sequence.\n-     *  @param comp Comparator provided for associated overloaded\n-     *  compare operators. */\n-    inline guarded_iterator(RandomAccessIterator begin, \n-\t\t\t    RandomAccessIterator end, Comparator& comp) \n+    *  @param begin Begin iterator of sequence.\n+    *  @param end End iterator of sequence.\n+    *  @param comp Comparator provided for associated overloaded\n+    *  compare operators. */\n+    inline guarded_iterator(RandomAccessIterator begin,\n+                            RandomAccessIterator end, Comparator& comp)\n     : current(begin), end(end), comp(comp)\n     { }\n \n     /** @brief Pre-increment operator.\n-     *  @return This. */\n+    *  @return This. */\n     inline guarded_iterator<RandomAccessIterator, Comparator>&\n     operator++()\n     {\n@@ -114,31 +114,35 @@ namespace __gnu_parallel\n     }\n \n     /** @brief Dereference operator.\n-     *  @return Referenced element. */\n+    *  @return Referenced element. */\n     inline typename std::iterator_traits<RandomAccessIterator>::value_type\n     operator*()\n     { return *current; }\n \n     /** @brief Convert to wrapped iterator.\n-     *  @return Wrapped iterator. */\n+    *  @return Wrapped iterator. */\n     inline operator RandomAccessIterator()\n     { return current; }\n \n     friend bool\n-    operator< <RandomAccessIterator, Comparator>(guarded_iterator<RandomAccessIterator, Comparator>& bi1, guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+    operator< <RandomAccessIterator, Comparator>(\n+        guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+        guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n     friend bool\n-    operator<= <RandomAccessIterator, Comparator>(guarded_iterator<RandomAccessIterator, Comparator>& bi1, guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+    operator<= <RandomAccessIterator, Comparator>(\n+        guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+        guarded_iterator<RandomAccessIterator, Comparator>& bi2);\n   };\n \n-  /** @brief Compare two elements referenced by guarded iterators.\n-   *  @param bi1 First iterator.\n-   *  @param bi2 Second iterator.\n-   *  @return @c True if less. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Compare two elements referenced by guarded iterators.\n+ *  @param bi1 First iterator.\n+ *  @param bi2 Second iterator.\n+ *  @return @c True if less. */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t    guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+            guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     if (bi1.current == bi1.end)\t//bi1 is sup\n       return bi2.current == bi2.end;\t//bi2 is not sup\n@@ -147,14 +151,14 @@ namespace __gnu_parallel\n     return (bi1.comp)(*bi1, *bi2);\t//normal compare\n   }\n \n-  /** @brief Compare two elements referenced by guarded iterators.\n-   *  @param bi1 First iterator.\n-   *  @param bi2 Second iterator.\n-   *  @return @c True if less equal. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Compare two elements referenced by guarded iterators.\n+ *  @param bi1 First iterator.\n+ *  @param bi2 Second iterator.\n+ *  @return @c True if less equal. */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(guarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+            guarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     if (bi2.current == bi2.end)\t//bi1 is sup\n       return bi1.current != bi1.end;\t//bi2 is not sup\n@@ -163,20 +167,20 @@ namespace __gnu_parallel\n     return !(bi1.comp)(*bi2, *bi1);\t//normal compare\n   }\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   class unguarded_iterator;\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t    unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+            unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+             unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n-  template<typename RandomAccessIterator, typename Comparator>\n+template<typename RandomAccessIterator, typename Comparator>\n   class unguarded_iterator\n   {\n   private:\n@@ -187,16 +191,16 @@ namespace __gnu_parallel\n \n   public:\n     /** @brief Constructor. Sets iterator to beginning of sequence.\n-     *  @param begin Begin iterator of sequence.\n-     *  @param end Unused, only for compatibility.\n-     *  @param comp Unused, only for compatibility. */\n-    inline unguarded_iterator(RandomAccessIterator begin, \n-\t\t\t      RandomAccessIterator end, Comparator& comp) \n+    *  @param begin Begin iterator of sequence.\n+    *  @param end Unused, only for compatibility.\n+    *  @param comp Unused, only for compatibility. */\n+    inline unguarded_iterator(RandomAccessIterator begin,\n+                              RandomAccessIterator end, Comparator& comp)\n     : current(begin), comp(comp)\n     { }\n \n     /** @brief Pre-increment operator.\n-     *  @return This. */\n+    *  @return This. */\n     inline  unguarded_iterator<RandomAccessIterator, Comparator>&\n     operator++()\n     {\n@@ -205,192 +209,215 @@ namespace __gnu_parallel\n     }\n \n     /** @brief Dereference operator.\n-     *  @return Referenced element. */\n-    inline typename std::iterator_traits<RandomAccessIterator>::value_type \n+    *  @return Referenced element. */\n+    inline typename std::iterator_traits<RandomAccessIterator>::value_type\n     operator*()\n     { return *current; }\n \n     /** @brief Convert to wrapped iterator.\n-     *  @return Wrapped iterator. */\n+    *  @return Wrapped iterator. */\n     inline\n     operator RandomAccessIterator()\n     { return current; }\n \n     friend bool\n-    operator< <RandomAccessIterator, Comparator>(unguarded_iterator<RandomAccessIterator, Comparator>& bi1, unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+    operator< <RandomAccessIterator, Comparator>(\n+        unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+        unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n \n     friend bool\n-    operator<= <RandomAccessIterator, Comparator>(unguarded_iterator<RandomAccessIterator, Comparator>& bi1, unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n+    operator<= <RandomAccessIterator, Comparator>(\n+        unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n+        unguarded_iterator<RandomAccessIterator, Comparator>& bi2);\n   };\n \n-  /** @brief Compare two elements referenced by unguarded iterators.\n-   *  @param bi1 First iterator.\n-   *  @param bi2 Second iterator.\n-   *  @return @c True if less. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Compare two elements referenced by unguarded iterators.\n+ *  @param bi1 First iterator.\n+ *  @param bi2 Second iterator.\n+ *  @return @c True if less. */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t    unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+            unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     // Normal compare.\n     return (bi1.comp)(*bi1, *bi2);\n   }\n \n-  /** @brief Compare two elements referenced by unguarded iterators.\n-   *  @param bi1 First iterator.\n-   *  @param bi2 Second iterator.\n-   *  @return @c True if less equal. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Compare two elements referenced by unguarded iterators.\n+ *  @param bi1 First iterator.\n+ *  @param bi2 Second iterator.\n+ *  @return @c True if less equal. */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline bool\n   operator<=(unguarded_iterator<RandomAccessIterator, Comparator>& bi1,\n-\t     unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n+            unguarded_iterator<RandomAccessIterator, Comparator>& bi2)\n   {\n     // Normal compare.\n     return !(bi1.comp)(*bi2, *bi1);\n   }\n \n-  /** Prepare a set of sequences to be merged without a (end) guard\n-   *  @param seqs_begin\n-   *  @param seqs_end\n-   *  @param comp\n-   *  @param min_sequence\n-   *  @param stable\n-   *  @pre (seqs_end - seqs_begin > 0) */\n-  template<typename RandomAccessIteratorIterator, typename Comparator>\n-  typename std::iterator_traits<typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n+/** Prepare a set of sequences to be merged without a (end) guard\n+ *  @param seqs_begin\n+ *  @param seqs_end\n+ *  @param comp\n+ *  @param min_sequence\n+ *  @param stable\n+ *  @pre (seqs_end - seqs_begin > 0) */\n+template<typename RandomAccessIteratorIterator, typename Comparator>\n+  typename std::iterator_traits<\n+      typename std::iterator_traits<RandomAccessIteratorIterator>::value_type\n+      ::first_type>::difference_type\n   prepare_unguarded(RandomAccessIteratorIterator seqs_begin,\n-\t\t    RandomAccessIteratorIterator seqs_end, Comparator comp,\n-\t\t    int& min_sequence, bool stable)\n+                    RandomAccessIteratorIterator seqs_end, Comparator comp,\n+                    int& min_sequence, bool stable)\n   {\n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+        ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n+    typedef typename std::iterator_traits<RandomAccessIterator1>\n+      ::difference_type\n       difference_type;\n \n     if ((*seqs_begin).first == (*seqs_begin).second)\n       {\n-\t// Empty sequence found, it's the first one.\n-\tmin_sequence = 0;\n-\treturn -1;\n+        // Empty sequence found, it's the first one.\n+        min_sequence = 0;\n+        return -1;\n       }\n \n     // Last element in sequence.\n     value_type min = *((*seqs_begin).second - 1);\n     min_sequence = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin + 1; s != seqs_end; s++)\n       {\n-\tif ((*s).first == (*s).second)\n-\t  {\n-\t    // Empty sequence found.\n-\t    min_sequence = static_cast<int>(s - seqs_begin);\n-\t    return -1;\n-\t  }\n-\n-\t// Last element in sequence.\n-\tconst value_type& v = *((*s).second - 1);\n-\tif (comp(v, min))\t//strictly smaller\n-\t  {\n-\t    min = v;\n-\t    min_sequence = static_cast<int>(s - seqs_begin);\n-\t  }\n+        if ((*s).first == (*s).second)\n+          {\n+            // Empty sequence found.\n+            min_sequence = static_cast<int>(s - seqs_begin);\n+            return -1;\n+          }\n+\n+        // Last element in sequence.\n+        const value_type& v = *((*s).second - 1);\n+        if (comp(v, min))\t//strictly smaller\n+          {\n+            min = v;\n+            min_sequence = static_cast<int>(s - seqs_begin);\n+          }\n       }\n \n     difference_type overhang_size = 0;\n \n     int s = 0;\n     for (s = 0; s <= min_sequence; s++)\n       {\n-\tRandomAccessIterator1 split;\n-\tif (stable)\n-\t  split = std::upper_bound(seqs_begin[s].first, seqs_begin[s].second,\n-\t\t\t\t   min, comp);\n-\telse\n-\t  split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second,\n-\t\t\t\t   min, comp);\n-\n-\toverhang_size += seqs_begin[s].second - split;\n+        RandomAccessIterator1 split;\n+        if (stable)\n+          split = std::upper_bound(seqs_begin[s].first, seqs_begin[s].second,\n+                                  min, comp);\n+        else\n+          split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second,\n+                                  min, comp);\n+\n+        overhang_size += seqs_begin[s].second - split;\n       }\n \n     for (; s < (seqs_end - seqs_begin); s++)\n       {\n-\tRandomAccessIterator1 split = std::lower_bound(seqs_begin[s].first, seqs_begin[s].second, min, comp);\n-\toverhang_size += seqs_begin[s].second - split;\n+        RandomAccessIterator1 split = std::lower_bound(\n+            seqs_begin[s].first, seqs_begin[s].second, min, comp);\n+        overhang_size += seqs_begin[s].second - split;\n       }\n \n     // So many elements will be left over afterwards.\n     return overhang_size;\n   }\n \n-  /** Prepare a set of sequences to be merged with a (end) guard (sentinel)\n-   *  @param seqs_begin\n-   *  @param seqs_end\n-   *  @param comp */\n-  template<typename RandomAccessIteratorIterator, typename Comparator>\n-  typename std::iterator_traits<typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n+/** Prepare a set of sequences to be merged with a (end) guard (sentinel)\n+ *  @param seqs_begin\n+ *  @param seqs_end\n+ *  @param comp */\n+template<typename RandomAccessIteratorIterator, typename Comparator>\n+  typename std::iterator_traits<typename std::iterator_traits<\n+      RandomAccessIteratorIterator>::value_type::first_type>::difference_type\n   prepare_unguarded_sentinel(RandomAccessIteratorIterator seqs_begin,\n-\t\t\t     RandomAccessIteratorIterator seqs_end,\n-\t\t\t     Comparator comp)\n+                            RandomAccessIteratorIterator seqs_end,\n+                            Comparator comp)\n   {\n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+    typedef typename std::iterator_traits<RandomAccessIterator1>\n+      ::value_type\n       value_type;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::difference_type\n+    typedef typename std::iterator_traits<RandomAccessIterator1>\n+      ::difference_type\n       difference_type;\n \n     // Last element in sequence.\n     value_type* max = NULL;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n       {\n-\tif ((*s).first == (*s).second)\n-\t  continue;\n+        if ((*s).first == (*s).second)\n+          continue;\n \n-\t// Last element in sequence.\n-\tvalue_type& v = *((*s).second - 1);\n+        // Last element in sequence.\n+        value_type& v = *((*s).second - 1);\n \n-\t// Strictly greater.\n-\tif (!max || comp(*max, v))\n-\t  max = &v;\n+        // Strictly greater.\n+        if (!max || comp(*max, v))\n+          max = &v;\n       }\n \n     difference_type overhang_size = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n       {\n-\tRandomAccessIterator1 split = std::lower_bound((*s).first, (*s).second,\n-\t\t\t\t\t\t       *max, comp);\n-\toverhang_size += (*s).second - split;\n+        RandomAccessIterator1 split =\n+            std::lower_bound((*s).first, (*s).second, *max, comp);\n+        overhang_size += (*s).second - split;\n \n-\t// Set sentinel.\n-\t*((*s).second) = *max;\n+        // Set sentinel.\n+        *((*s).second) = *max;\n       }\n \n     // So many elements will be left over afterwards.\n     return overhang_size;\n   }\n \n-  /** @brief Highly efficient 3-way merging procedure.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Unused, stable anyway.\n-   *  @return End iterator of output sequence. */\n-  template<template<typename RAI, typename C> class iterator, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Highly efficient 3-way merging procedure.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Unused, stable anyway.\n+ *  @return End iterator of output sequence. */\n+template<\n+    template<typename RAI, typename C> class iterator,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_3_variant(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_3_variant(\n+      RandomAccessIteratorIterator seqs_begin,\n+      RandomAccessIteratorIterator seqs_end,\n+      RandomAccessIterator3 target,\n+      Comparator comp, _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length);\n-    \n+\n     typedef _DifferenceTp difference_type;\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -405,25 +432,25 @@ namespace __gnu_parallel\n \n     if (seq0 <= seq1)\n       {\n-\tif (seq1 <= seq2)\n-\t  goto s012;\n-\telse\n-\t  if (seq2 <  seq0)\n-\t    goto s201;\n-\t  else\n-\t    goto s021;\n+        if (seq1 <= seq2)\n+          goto s012;\n+        else\n+          if (seq2 <  seq0)\n+            goto s201;\n+          else\n+            goto s021;\n       }\n     else\n       {\n-\tif (seq1 <= seq2)\n-\t  {\n-\t    if (seq0 <= seq2)\n-\t      goto s102;\n-\t    else\n-\t      goto s120;\n-\t  }\n-\telse\n-\t  goto s210;\n+        if (seq1 <= seq2)\n+          {\n+            if (seq0 <= seq2)\n+              goto s102;\n+            else\n+              goto s120;\n+          }\n+        else\n+          goto s210;\n       }\n \n #define Merge3Case(a,b,c,c0,c1)\t\t\t\t\\\n@@ -456,14 +483,23 @@ namespace __gnu_parallel\n     return target;\n   }\n \n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_3_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_3_combined(RandomAccessIteratorIterator seqs_begin,\n+                            RandomAccessIteratorIterator seqs_end,\n+                            RandomAccessIterator3 target,\n+                            Comparator comp,\n+                            _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length);\n-    \n+\n     typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -472,24 +508,26 @@ namespace __gnu_parallel\n     RandomAccessIterator3 target_end;\n \n     // Stable anyway.\n-    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n+    difference_type overhang =\n+        prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       total_length += LENGTH(*s);\n \n     if (overhang != -1)\n       {\n-\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n-\ttarget_end = multiway_merge_3_variant<unguarded_iterator>\n-\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-\toverhang = length - unguarded_length;\n+        difference_type unguarded_length =\n+            std::min(length, total_length - overhang);\n+        target_end = multiway_merge_3_variant<unguarded_iterator>\n+          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+        overhang = length - unguarded_length;\n       }\n     else\n       {\n-\t// Empty sequence found.\n-\toverhang = length;\n-\ttarget_end = target;\n+        // Empty sequence found.\n+        overhang = length;\n+        target_end = target;\n       }\n \n #if _GLIBCXX_ASSERTIONS\n@@ -500,23 +538,23 @@ namespace __gnu_parallel\n     switch (min_seq)\n       {\n       case 0:\n-\t// Iterators will be advanced accordingly.\n-\ttarget_end = merge_advance(seqs_begin[1].first, seqs_begin[1].second,\n-\t\t\t\t   seqs_begin[2].first, seqs_begin[2].second,\n-\t\t\t\t   target_end, overhang, comp);\n-\tbreak;\n+        // Iterators will be advanced accordingly.\n+        target_end = merge_advance(seqs_begin[1].first, seqs_begin[1].second,\n+                                  seqs_begin[2].first, seqs_begin[2].second,\n+                                  target_end, overhang, comp);\n+        break;\n       case 1:\n-\ttarget_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n-\t\t\t\t   seqs_begin[2].first, seqs_begin[2].second,\n-\t\t\t\t   target_end, overhang, comp);\n-\tbreak;\n+        target_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n+                                  seqs_begin[2].first, seqs_begin[2].second,\n+                                  target_end, overhang, comp);\n+        break;\n       case 2:\n-\ttarget_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n-\t\t\t\t   seqs_begin[1].first, seqs_begin[1].second,\n-\t\t\t\t   target_end, overhang, comp);\n-\tbreak;\n+        target_end = merge_advance(seqs_begin[0].first, seqs_begin[0].second,\n+                                  seqs_begin[1].first, seqs_begin[1].second,\n+                                  target_end, overhang, comp);\n+        break;\n       default:\n-\t_GLIBCXX_PARALLEL_ASSERT(false);\n+        _GLIBCXX_PARALLEL_ASSERT(false);\n       }\n \n #if _GLIBCXX_ASSERTIONS\n@@ -527,22 +565,31 @@ namespace __gnu_parallel\n     return target_end;\n   }\n \n-  /** @brief Highly efficient 4-way merging procedure.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Unused, stable anyway.\n-   *  @return End iterator of output sequence. */\n-  template<template<typename RAI, typename C> class iterator, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Highly efficient 4-way merging procedure.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Unused, stable anyway.\n+ *  @return End iterator of output sequence. */\n+template<\n+    template<typename RAI, typename C> class iterator,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_4_variant(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_4_variant(RandomAccessIteratorIterator seqs_begin,\n+                           RandomAccessIteratorIterator seqs_end,\n+                           RandomAccessIterator3 target,\n+                           Comparator comp, _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length);\n     typedef _DifferenceTp difference_type;\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -561,26 +608,26 @@ namespace __gnu_parallel\n \n     if (seq0 <= seq1)\n       {\n-\tif (seq1 <= seq2)\n-\t  Decision(0,1,2,3)\n-\t  else\n-\t    if (seq2 < seq0)\n-\t      Decision(2,0,1,3)\n-\t      else\n-\t\tDecision(0,2,1,3)\n-\t\t  }\n+        if (seq1 <= seq2)\n+          Decision(0,1,2,3)\n+          else\n+            if (seq2 < seq0)\n+              Decision(2,0,1,3)\n+              else\n+                Decision(0,2,1,3)\n+                  }\n     else\n       {\n-\tif (seq1 <= seq2)\n-\t  {\n-\t    if (seq0 <= seq2)\n-\t      Decision(1,0,2,3)\n-\t      else\n-\t\tDecision(1,2,0,3)\n-\t\t  }\n-\telse\n-\t  Decision(2,1,0,3)\n-\t    }\n+        if (seq1 <= seq2)\n+          {\n+            if (seq0 <= seq2)\n+              Decision(1,0,2,3)\n+              else\n+                Decision(1,2,0,3)\n+                  }\n+        else\n+          Decision(2,1,0,3)\n+            }\n \n #define Merge4Case(a,b,c,d,c0,c1,c2)\t\t\t\t\\\n     s ## a ## b ## c ## d:\t\t\t\t\t\\\n@@ -633,14 +680,23 @@ namespace __gnu_parallel\n     return target;\n   }\n \n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_4_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_4_combined(RandomAccessIteratorIterator seqs_begin,\n+                            RandomAccessIteratorIterator seqs_end,\n+                            RandomAccessIterator3 target,\n+                            Comparator comp,\n+                            _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length);\n     typedef _DifferenceTp difference_type;\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -649,35 +705,40 @@ namespace __gnu_parallel\n     RandomAccessIterator3 target_end;\n \n     // Stable anyway.\n-    difference_type overhang = prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n+    difference_type overhang =\n+        prepare_unguarded(seqs_begin, seqs_end, comp, min_seq, true);\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; ++s)\n       total_length += LENGTH(*s);\n \n     if (overhang != -1)\n       {\n-\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n-\ttarget_end = multiway_merge_4_variant<unguarded_iterator>\n-\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-\toverhang = length - unguarded_length;\n+        difference_type unguarded_length =\n+            std::min(length, total_length - overhang);\n+        target_end = multiway_merge_4_variant<unguarded_iterator>\n+          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+        overhang = length - unguarded_length;\n       }\n     else\n       {\n-\t// Empty sequence found.\n-\toverhang = length;\n-\ttarget_end = target;\n+        // Empty sequence found.\n+        overhang = length;\n+        target_end = target;\n       }\n \n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(target_end == target + length - overhang);\n     _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target_end, comp));\n #endif\n \n-    std::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> > one_missing(seqs_begin, seqs_end);\n+    std::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> >\n+        one_missing(seqs_begin, seqs_end);\n     one_missing.erase(one_missing.begin() + min_seq);\t//remove\n \n-    target_end = multiway_merge_3_variant<guarded_iterator>(one_missing.begin(), one_missing.end(), target_end, comp, overhang, stable);\n+    target_end = multiway_merge_3_variant<guarded_iterator>(\n+        one_missing.begin(), one_missing.end(),\n+        target_end, comp, overhang, stable);\n \n     // Insert back again.\n     one_missing.insert(one_missing.begin() + min_seq, seqs_begin[min_seq]);\n@@ -692,34 +753,43 @@ namespace __gnu_parallel\n     return target_end;\n   }\n \n-  /** @brief Basic multi-way merging procedure.\n-   *\n-   *  The head elements are kept in a sorted array, new heads are\n-   *  inserted linearly.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @return End iterator of output sequence. \n-   */\n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Basic multi-way merging procedure.\n+ *\n+ *  The head elements are kept in a sorted array, new heads are\n+ *  inserted linearly.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @return End iterator of output sequence.\n+ */\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_bubble(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_bubble(RandomAccessIteratorIterator seqs_begin,\n+                        RandomAccessIteratorIterator seqs_end,\n+                        RandomAccessIterator3 target,\n+                        Comparator comp, _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n \n     typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n     // Num remaining pieces.\n     int k = static_cast<int>(seqs_end - seqs_begin), nrp;\n \n-    value_type* pl = static_cast<value_type*>(::operator new(sizeof(value_type) * k));\n+    value_type* pl = static_cast<value_type*>(\n+      ::operator new(sizeof(value_type) * k));\n     int* source = new int[k];\n     difference_type total_length = 0;\n \n@@ -730,137 +800,138 @@ namespace __gnu_parallel\n     nrp = 0;\n     for (int pi = 0; pi < k; pi++)\n       {\n-\tif (STOPS(pi) != POS(pi))\n-\t  {\n-\t    pl[nrp] = *(POS(pi));\n-\t    source[nrp] = pi;\n-\t    nrp++;\n-\t    total_length += LENGTH(seqs_begin[pi]);\n-\t  }\n+        if (STOPS(pi) != POS(pi))\n+          {\n+            pl[nrp] = *(POS(pi));\n+            source[nrp] = pi;\n+            nrp++;\n+            total_length += LENGTH(seqs_begin[pi]);\n+          }\n       }\n \n     if (stable)\n       {\n-\tfor (int k = 0; k < nrp - 1; k++)\n-\t  for (int pi = nrp - 1; pi > k; pi--)\n-\t    if (comp(pl[pi], pl[pi - 1]) ||\n-\t\t(!comp(pl[pi - 1], pl[pi]) && source[pi] < source[pi - 1]))\n-\t      {\n-\t\tstd::swap(pl[pi - 1], pl[pi]);\n-\t\tstd::swap(source[pi - 1], source[pi]);\n-\t      }\n+        for (int k = 0; k < nrp - 1; k++)\n+          for (int pi = nrp - 1; pi > k; pi--)\n+            if (comp(pl[pi], pl[pi - 1]) ||\n+                (!comp(pl[pi - 1], pl[pi]) && source[pi] < source[pi - 1]))\n+              {\n+                std::swap(pl[pi - 1], pl[pi]);\n+                std::swap(source[pi - 1], source[pi]);\n+              }\n       }\n     else\n       {\n-\tfor (int k = 0; k < nrp - 1; k++)\n-\t  for (int pi = nrp - 1; pi > k; pi--)\n-\t    if (comp(pl[pi], pl[pi-1]))\n-\t      {\n-\t\tstd::swap(pl[pi-1], pl[pi]);\n-\t\tstd::swap(source[pi-1], source[pi]);\n-\t      }\n+        for (int k = 0; k < nrp - 1; k++)\n+          for (int pi = nrp - 1; pi > k; pi--)\n+            if (comp(pl[pi], pl[pi-1]))\n+              {\n+                std::swap(pl[pi-1], pl[pi]);\n+                std::swap(source[pi-1], source[pi]);\n+              }\n       }\n \n     // Iterate.\n     if (stable)\n       {\n-\tint j;\n-\twhile (nrp > 0 && length > 0)\n-\t  {\n-\t    if (source[0] < source[1])\n-\t      {\n-\t\t// pl[0] <= pl[1]\n-\t\twhile ((nrp == 1 || !(comp(pl[1], pl[0]))) && length > 0)\n-\t\t  {\n-\t\t    *target = pl[0];\n-\t\t    ++target;\n-\t\t    ++POS(source[0]);\n-\t\t    length--;\n-\t\t    if (POS(source[0]) == STOPS(source[0]))\n-\t\t      {\n-\t\t\t// Move everything to the left.\n-\t\t\tfor (int s = 0; s < nrp - 1; s++)\n-\t\t\t  {\n-\t\t\t    pl[s] = pl[s + 1];\n-\t\t\t    source[s] = source[s + 1];\n-\t\t\t  }\n-\t\t\tnrp--;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    else\n-\t\t      pl[0] = *(POS(source[0]));\n-\t\t  }\n-\t      }\n-\t    else\n-\t      {\n-\t\t// pl[0] < pl[1]\n-\t\twhile ((nrp == 1 || comp(pl[0], pl[1])) && length > 0)\n-\t\t  {\n-\t\t    *target = pl[0];\n-\t\t    ++target;\n-\t\t    ++POS(source[0]);\n-\t\t    length--;\n-\t\t    if (POS(source[0]) == STOPS(source[0]))\n-\t\t      {\n-\t\t\tfor (int s = 0; s < nrp - 1; s++)\n-\t\t\t  {\n-\t\t\t    pl[s] = pl[s + 1];\n-\t\t\t    source[s] = source[s + 1];\n-\t\t\t  }\n-\t\t\tnrp--;\n-\t\t\tbreak;\n-\t\t      }\n-\t\t    else\n-\t\t      pl[0] = *(POS(source[0]));\n-\t\t  }\n-\t      }\n-\n-\t    // Sink down.\n-\t    j = 1;\n-\t    while ((j < nrp) && (comp(pl[j], pl[j - 1]) ||\n-\t\t\t\t (!comp(pl[j - 1], pl[j]) && (source[j] < source[j - 1]))))\n-\t      {\n-\t\tstd::swap(pl[j - 1], pl[j]);\n-\t\tstd::swap(source[j - 1], source[j]);\n-\t\tj++;\n-\t      }\n-\t  }\n+        int j;\n+        while (nrp > 0 && length > 0)\n+          {\n+            if (source[0] < source[1])\n+              {\n+                // pl[0] <= pl[1]\n+                while ((nrp == 1 || !(comp(pl[1], pl[0]))) && length > 0)\n+                  {\n+                    *target = pl[0];\n+                    ++target;\n+                    ++POS(source[0]);\n+                    length--;\n+                    if (POS(source[0]) == STOPS(source[0]))\n+                      {\n+                        // Move everything to the left.\n+                        for (int s = 0; s < nrp - 1; s++)\n+                          {\n+                            pl[s] = pl[s + 1];\n+                            source[s] = source[s + 1];\n+                          }\n+                        nrp--;\n+                        break;\n+                      }\n+                    else\n+                      pl[0] = *(POS(source[0]));\n+                  }\n+              }\n+            else\n+              {\n+                // pl[0] < pl[1]\n+                while ((nrp == 1 || comp(pl[0], pl[1])) && length > 0)\n+                  {\n+                    *target = pl[0];\n+                    ++target;\n+                    ++POS(source[0]);\n+                    length--;\n+                    if (POS(source[0]) == STOPS(source[0]))\n+                      {\n+                        for (int s = 0; s < nrp - 1; s++)\n+                          {\n+                            pl[s] = pl[s + 1];\n+                            source[s] = source[s + 1];\n+                          }\n+                        nrp--;\n+                        break;\n+                      }\n+                    else\n+                      pl[0] = *(POS(source[0]));\n+                  }\n+              }\n+\n+            // Sink down.\n+            j = 1;\n+            while ((j < nrp) && (comp(pl[j], pl[j - 1]) ||\n+                                (!comp(pl[j - 1], pl[j])\n+                                    && (source[j] < source[j - 1]))))\n+              {\n+                std::swap(pl[j - 1], pl[j]);\n+                std::swap(source[j - 1], source[j]);\n+                j++;\n+              }\n+          }\n       }\n     else\n       {\n-\tint j;\n-\twhile (nrp > 0 && length > 0)\n-\t  {\n-\t    // pl[0] <= pl[1]\n-\t    while (nrp == 1 || (!comp(pl[1], pl[0])) && length > 0)\n-\t      {\n-\t\t*target = pl[0];\n-\t\t++target;\n-\t\t++POS(source[0]);\n-\t\tlength--;\n-\t\tif (POS(source[0]) == STOPS(source[0]))\n-\t\t  {\n-\t\t    for (int s = 0; s < (nrp - 1); s++)\n-\t\t      {\n-\t\t\tpl[s] = pl[s + 1];\n-\t\t\tsource[s] = source[s + 1];\n-\t\t      }\n-\t\t    nrp--;\n-\t\t    break;\n-\t\t  }\n-\t\telse\n-\t\t  pl[0] = *(POS(source[0]));\n-\t      }\n-\n-\t    // Sink down.\n-\t    j = 1;\n-\t    while ((j < nrp) && comp(pl[j], pl[j - 1]))\n-\t      {\n-\t\tstd::swap(pl[j - 1], pl[j]);\n-\t\tstd::swap(source[j - 1], source[j]);\n-\t\tj++;\n-\t      }\n-\t  }\n+        int j;\n+        while (nrp > 0 && length > 0)\n+          {\n+            // pl[0] <= pl[1]\n+            while (nrp == 1 || (!comp(pl[1], pl[0])) && length > 0)\n+              {\n+                *target = pl[0];\n+                ++target;\n+                ++POS(source[0]);\n+                length--;\n+                if (POS(source[0]) == STOPS(source[0]))\n+                  {\n+                    for (int s = 0; s < (nrp - 1); s++)\n+                      {\n+                        pl[s] = pl[s + 1];\n+                        source[s] = source[s + 1];\n+                      }\n+                    nrp--;\n+                    break;\n+                  }\n+                else\n+                  pl[0] = *(POS(source[0]));\n+              }\n+\n+            // Sink down.\n+            j = 1;\n+            while ((j < nrp) && comp(pl[j], pl[j - 1]))\n+              {\n+                std::swap(pl[j - 1], pl[j]);\n+                std::swap(source[j - 1], source[j]);\n+                j++;\n+              }\n+          }\n       }\n \n     delete[] pl;\n@@ -869,26 +940,36 @@ namespace __gnu_parallel\n     return target;\n   }\n \n-  /** @brief Multi-way merging procedure for a high branching factor,\n-   * guarded case.\n-   *\n-   *  The head elements are kept in a loser tree.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @return End iterator of output sequence. \n-   */\n-  template<typename LT, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Multi-way merging procedure for a high branching factor,\n+ * guarded case.\n+ *\n+ *  The head elements are kept in a loser tree.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *   @param stable Stable merging incurs a performance penalty.\n+ *  @return End iterator of output sequence.\n+ */\n+template<\n+    typename LT,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree(RandomAccessIteratorIterator seqs_begin,\n+                            RandomAccessIteratorIterator seqs_end,\n+                            RandomAccessIterator3 target,\n+                            Comparator comp,\n+                            _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n \n     typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -941,64 +1022,73 @@ namespace __gnu_parallel\n \n     if (stable)\n       {\n-\tfor (difference_type i = 0; i < total_length; i++)\n-\t  {\n-\t    // Take out.\n-\t    source = lt.get_min_source();\n+        for (difference_type i = 0; i < total_length; i++)\n+          {\n+            // Take out.\n+            source = lt.get_min_source();\n \n-\t    *(target++) = *(seqs_begin[source].first++);\n+            *(target++) = *(seqs_begin[source].first++);\n \n-\t    // Feed.\n-\t    if (seqs_begin[source].first == seqs_begin[source].second)\n-\t      lt.delete_min_insert_stable(*arbitrary_element, true);\n-\t    else\n-\t      // Replace from same source.\n-\t      lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n+            // Feed.\n+            if (seqs_begin[source].first == seqs_begin[source].second)\n+              lt.delete_min_insert_stable(*arbitrary_element, true);\n+            else\n+              // Replace from same source.\n+              lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n \n-\t  }\n+          }\n       }\n     else\n       {\n-\tfor (difference_type i = 0; i < total_length; i++)\n-\t  {\n-\t    //take out\n-\t    source = lt.get_min_source();\n-\n-\t    *(target++) = *(seqs_begin[source].first++);\n-\n-\t    // Feed.\n-\t    if (seqs_begin[source].first == seqs_begin[source].second)\n-\t      lt.delete_min_insert(*arbitrary_element, true);\n-\t    else\n-\t      // Replace from same source.\n-\t      lt.delete_min_insert(*seqs_begin[source].first, false);\n-\t  }\n+        for (difference_type i = 0; i < total_length; i++)\n+          {\n+            //take out\n+            source = lt.get_min_source();\n+\n+            *(target++) = *(seqs_begin[source].first++);\n+\n+            // Feed.\n+            if (seqs_begin[source].first == seqs_begin[source].second)\n+              lt.delete_min_insert(*arbitrary_element, true);\n+            else\n+              // Replace from same source.\n+              lt.delete_min_insert(*seqs_begin[source].first, false);\n+          }\n       }\n \n     return target;\n   }\n \n-  /** @brief Multi-way merging procedure for a high branching factor,\n-   * unguarded case.\n-   *\n-   *  The head elements are kept in a loser tree.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @return End iterator of output sequence.\n-   *  @pre No input will run out of elements during the merge. \n-   */\n-  template<typename LT, typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Multi-way merging procedure for a high branching factor,\n+ * unguarded case.\n+ *\n+ *  The head elements are kept in a loser tree.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @return End iterator of output sequence.\n+ *  @pre No input will run out of elements during the merge.\n+ */\n+template<\n+    typename LT,\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp, typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree_unguarded(RandomAccessIteratorIterator seqs_begin,\n+                                      RandomAccessIteratorIterator seqs_end,\n+                                      RandomAccessIterator3 target,\n+                                      Comparator comp,\n+                                      _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n     typedef _DifferenceTp difference_type;\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -1012,14 +1102,14 @@ namespace __gnu_parallel\n     for (int t = 0; t < k; t++)\n       {\n #if _GLIBCXX_ASSERTIONS\n-\t_GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n+        _GLIBCXX_PARALLEL_ASSERT(seqs_begin[t].first != seqs_begin[t].second);\n #endif\n-\tif (stable)\n-\t  lt.insert_start_stable(*seqs_begin[t].first, t, false);\n-\telse\n-\t  lt.insert_start(*seqs_begin[t].first, t, false);\n+        if (stable)\n+          lt.insert_start_stable(*seqs_begin[t].first, t, false);\n+        else\n+          lt.insert_start(*seqs_begin[t].first, t, false);\n \n-\ttotal_length += LENGTH(seqs_begin[t]);\n+        total_length += LENGTH(seqs_begin[t]);\n       }\n \n     if (stable)\n@@ -1038,94 +1128,111 @@ namespace __gnu_parallel\n \n     if (stable)\n       {\n-\tRandomAccessIterator3 target_end = target + length;\n-\twhile (target < target_end)\n-\t  {\n-\t    // Take out.\n-\t    source = lt.get_min_source();\n+        RandomAccessIterator3 target_end = target + length;\n+        while (target < target_end)\n+          {\n+            // Take out.\n+            source = lt.get_min_source();\n \n #if _GLIBCXX_ASSERTIONS\n-\t    _GLIBCXX_PARALLEL_ASSERT(i == 0 || !comp(*(seqs_begin[source].first), *(target - 1)));\n+            _GLIBCXX_PARALLEL_ASSERT(i == 0\n+                || !comp(*(seqs_begin[source].first), *(target - 1)));\n #endif\n \n-\t    *(target++) = *(seqs_begin[source].first++);\n+            *(target++) = *(seqs_begin[source].first++);\n \n #if _GLIBCXX_ASSERTIONS\n-\t    _GLIBCXX_PARALLEL_ASSERT((seqs_begin[source].first != seqs_begin[source].second) || (i == length - 1));\n-\t    i++;\n+            _GLIBCXX_PARALLEL_ASSERT(\n+                (seqs_begin[source].first != seqs_begin[source].second)\n+                || (i == length - 1));\n+            i++;\n #endif\n-\t    // Feed.\n-\t    // Replace from same source.\n-\t    lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n+            // Feed.\n+            // Replace from same source.\n+            lt.delete_min_insert_stable(*seqs_begin[source].first, false);\n \n-\t  }\n+          }\n       }\n     else\n       {\n-\tRandomAccessIterator3 target_end = target + length;\n-\twhile (target < target_end)\n-\t  {\n-\t    // Take out.\n-\t    source = lt.get_min_source();\n+        RandomAccessIterator3 target_end = target + length;\n+        while (target < target_end)\n+          {\n+            // Take out.\n+            source = lt.get_min_source();\n \n #if _GLIBCXX_ASSERTIONS\n-\t    if (i > 0 && comp(*(seqs_begin[source].first), *(target - 1)))\n-\t      printf(\"         %i %i %i\\n\", length, i, source);\n-\t    _GLIBCXX_PARALLEL_ASSERT(i == 0 || !comp(*(seqs_begin[source].first), *(target - 1)));\n+            if (i > 0 && comp(*(seqs_begin[source].first), *(target - 1)))\n+              printf(\"         %i %i %i\\n\", length, i, source);\n+            _GLIBCXX_PARALLEL_ASSERT(i == 0\n+                || !comp(*(seqs_begin[source].first), *(target - 1)));\n #endif\n \n-\t    *(target++) = *(seqs_begin[source].first++);\n+            *(target++) = *(seqs_begin[source].first++);\n \n #if _GLIBCXX_ASSERTIONS\n-\t    if (!((seqs_begin[source].first != seqs_begin[source].second) || (i >= length - 1)))\n-\t      printf(\"         %i %i %i\\n\", length, i, source);\n-\t    _GLIBCXX_PARALLEL_ASSERT((seqs_begin[source].first != seqs_begin[source].second) || (i >= length - 1));\n-\t    i++;\n+            if (!((seqs_begin[source].first != seqs_begin[source].second)\n+                || (i >= length - 1)))\n+              printf(\"         %i %i %i\\n\", length, i, source);\n+            _GLIBCXX_PARALLEL_ASSERT(\n+                (seqs_begin[source].first != seqs_begin[source].second)\n+                || (i >= length - 1));\n+            i++;\n #endif\n-\t    // Feed.\n-\t    // Replace from same source.\n-\t    lt.delete_min_insert(*seqs_begin[source].first, false);\n-\t  }\n+            // Feed.\n+            // Replace from same source.\n+            lt.delete_min_insert(*seqs_begin[source].first, false);\n+          }\n       }\n \n     return target;\n   }\n \n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_loser_tree_combined(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree_combined(RandomAccessIteratorIterator seqs_begin,\n+                                     RandomAccessIteratorIterator seqs_end,\n+                                     RandomAccessIterator3 target,\n+                                     Comparator comp,\n+                                     _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n \n     typedef _DifferenceTp difference_type;\n \n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n \n     int min_seq;\n     RandomAccessIterator3 target_end;\n     difference_type overhang = prepare_unguarded(seqs_begin, seqs_end,\n-\t\t\t\t\t  comp, min_seq, stable);\n+                                          comp, min_seq, stable);\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n       total_length += LENGTH(*s);\n \n     if (overhang != -1)\n       {\n-\tdifference_type unguarded_length = std::min(length, total_length - overhang);\n-\ttarget_end = multiway_merge_loser_tree_unguarded\n-\t  <typename loser_tree_unguarded_traits<value_type, Comparator>::LT>\n-\t  (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n-\toverhang = length - unguarded_length;\n+        difference_type unguarded_length =\n+            std::min(length, total_length - overhang);\n+        target_end = multiway_merge_loser_tree_unguarded\n+          <typename loser_tree_unguarded_traits<value_type, Comparator>::LT>\n+          (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n+        overhang = length - unguarded_length;\n       }\n     else\n       {\n-\t// Empty sequence found.\n-\toverhang = length;\n-\ttarget_end = target;\n+        // Empty sequence found.\n+        overhang = length;\n+        target_end = target;\n       }\n \n #if _GLIBCXX_ASSERTIONS\n@@ -1145,34 +1252,43 @@ namespace __gnu_parallel\n     return target_end;\n   }\n \n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable)\n+  multiway_merge_loser_tree_sentinel(RandomAccessIteratorIterator seqs_begin,\n+                                     RandomAccessIteratorIterator seqs_end,\n+                                      RandomAccessIterator3 target,\n+                                      Comparator comp,\n+                                      _DifferenceTp length, bool stable)\n   {\n     _GLIBCXX_CALL(length)\n \n     typedef _DifferenceTp difference_type;\n     typedef std::iterator_traits<RandomAccessIteratorIterator> traits_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n-      RandomAccessIterator1;\n \n     RandomAccessIterator3 target_end;\n-    difference_type overhang = prepare_unguarded_sentinel(seqs_begin, seqs_end, comp);\n+    difference_type overhang =\n+        prepare_unguarded_sentinel(seqs_begin, seqs_end, comp);\n \n     difference_type total_length = 0;\n     for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end; s++)\n       {\n-\ttotal_length += LENGTH(*s);\n+        total_length += LENGTH(*s);\n \n-\t// Sentinel spot.\n-\t(*s).second++;\n+        // Sentinel spot.\n+        (*s).second++;\n       }\n \n-    difference_type unguarded_length = std::min(length, total_length - overhang);\n+    difference_type unguarded_length =\n+        std::min(length, total_length - overhang);\n     target_end = multiway_merge_loser_tree_unguarded\n       <typename loser_tree_unguarded_traits<value_type, Comparator>::LT>\n       (seqs_begin, seqs_end, target, comp, unguarded_length, stable);\n@@ -1184,14 +1300,17 @@ namespace __gnu_parallel\n #endif\n \n     // Copy rest stable.\n-    for (RandomAccessIteratorIterator s = seqs_begin; s != seqs_end && overhang > 0; s++)\n+    for (RandomAccessIteratorIterator s = seqs_begin;\n+         s != seqs_end && overhang > 0; s++)\n       {\n-\t// Restore.\n-\t(*s).second--;\n-\tdifference_type local_length = std::min((difference_type)overhang, (difference_type)LENGTH(*s));\n-\ttarget_end = std::copy((*s).first, (*s).first + local_length, target_end);\n-\t(*s).first += local_length;\n-\toverhang -= local_length;\n+        // Restore.\n+        (*s).second--;\n+        difference_type local_length =\n+            std::min<difference_type>(overhang, LENGTH(*s));\n+        target_end = std::copy((*s).first, (*s).first + local_length,\n+                               target_end);\n+        (*s).first += local_length;\n+        overhang -= local_length;\n       }\n \n #if _GLIBCXX_ASSERTIONS\n@@ -1203,25 +1322,35 @@ namespace __gnu_parallel\n     return target_end;\n   }\n \n-  /** @brief Sequential multi-way merging switch.\n-   *\n-   *  The decision if based on the branching factor and runtime settings.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @param sentinel The sequences have a sentinel element.\n-   *  @return End iterator of output sequence. */\n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Sequential multi-way merging switch.\n+ *\n+ *  The decision if based on the branching factor and runtime settings.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @param sentinel The sequences have a sentinel element.\n+ *  @return End iterator of output sequence. */\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  multiway_merge(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable, bool sentinel, sequential_tag)\n+  multiway_merge(RandomAccessIteratorIterator seqs_begin,\n+                 RandomAccessIteratorIterator seqs_end,\n+                 RandomAccessIterator3 target,\n+                 Comparator comp, _DifferenceTp length,\n+                 bool stable, bool sentinel,\n+                 sequential_tag)\n   {\n     _GLIBCXX_CALL(length)\n \n     typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n+    typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+      ::value_type::first_type\n       RandomAccessIterator1;\n     typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n       value_type;\n@@ -1234,83 +1363,135 @@ namespace __gnu_parallel\n     RandomAccessIterator3 return_target = target;\n     int k = static_cast<int>(seqs_end - seqs_begin);\n \n-    Settings::MultiwayMergeAlgorithm mwma = Settings::multiway_merge_algorithm;\n+    Settings::MultiwayMergeAlgorithm mwma =\n+        Settings::multiway_merge_algorithm;\n \n     if (!sentinel && mwma == Settings::LOSER_TREE_SENTINEL)\n       mwma = Settings::LOSER_TREE_COMBINED;\n \n     switch (k)\n       {\n       case 0:\n-\tbreak;\n+        break;\n       case 1:\n-\treturn_target = std::copy(seqs_begin[0].first, seqs_begin[0].first + length, target);\n-\tseqs_begin[0].first += length;\n-\tbreak;\n+        return_target = std::copy(seqs_begin[0].first,\n+                                  seqs_begin[0].first + length,\n+                                  target);\n+        seqs_begin[0].first += length;\n+        break;\n       case 2:\n-\treturn_target = merge_advance(seqs_begin[0].first, seqs_begin[0].second, seqs_begin[1].first, seqs_begin[1].second, target, length, comp);\n-\tbreak;\n+        return_target = merge_advance(seqs_begin[0].first,\n+                                      seqs_begin[0].second,\n+                                      seqs_begin[1].first,\n+                                      seqs_begin[1].second,\n+                                      target, length, comp);\n+        break;\n       case 3:\n-\tswitch (mwma)\n-\t  {\n-\t  case Settings::LOSER_TREE_COMBINED:\n-\t    return_target = multiway_merge_3_combined(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  case Settings::LOSER_TREE_SENTINEL:\n-\t    return_target = multiway_merge_3_variant<unguarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  default:\n-\t    return_target = multiway_merge_3_variant<guarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  }\n-\tbreak;\n+        switch (mwma)\n+          {\n+          case Settings::LOSER_TREE_COMBINED:\n+            return_target = multiway_merge_3_combined(seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          case Settings::LOSER_TREE_SENTINEL:\n+            return_target = multiway_merge_3_variant<unguarded_iterator>(\n+                seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          default:\n+            return_target = multiway_merge_3_variant<guarded_iterator>(\n+                seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          }\n+        break;\n       case 4:\n-\tswitch (mwma)\n-\t  {\n-\t  case Settings::LOSER_TREE_COMBINED:\n-\t    return_target = multiway_merge_4_combined(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  case Settings::LOSER_TREE_SENTINEL:\n-\t    return_target = multiway_merge_4_variant<unguarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  default:\n-\t    return_target = multiway_merge_4_variant<guarded_iterator>(seqs_begin, seqs_end, target, comp, length, stable);\n-\t    break;\n-\t  }\n-\tbreak;\n+        switch (mwma)\n+          {\n+          case Settings::LOSER_TREE_COMBINED:\n+            return_target = multiway_merge_4_combined(\n+                seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          case Settings::LOSER_TREE_SENTINEL:\n+            return_target = multiway_merge_4_variant<unguarded_iterator>(\n+                seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          default:\n+            return_target = multiway_merge_4_variant<guarded_iterator>(\n+                seqs_begin,\n+                seqs_end,\n+                target,\n+                comp, length, stable);\n+            break;\n+          }\n+        break;\n       default:\n-\t{\n-\t  switch (mwma)\n-\t    {\n-\t    case Settings::BUBBLE:\n-\t      return_target = multiway_merge_bubble(seqs_begin, seqs_end, target, comp, length, stable);\n-\t      break;\n+        {\n+          switch (mwma)\n+            {\n+            case Settings::BUBBLE:\n+              return_target = multiway_merge_bubble(\n+                  seqs_begin,\n+                  seqs_end,\n+                  target,\n+                  comp, length, stable);\n+              break;\n #if _GLIBCXX_LOSER_TREE_EXPLICIT\n-\t    case Settings::LOSER_TREE_EXPLICIT:\n-\t      return_target = multiway_merge_loser_tree<LoserTreeExplicit<value_type, Comparator> >(seqs_begin, seqs_end, target, comp, length, stable);\n-\t      break;\n+            case Settings::LOSER_TREE_EXPLICIT:\n+              return_target = multiway_merge_loser_tree<\n+                    LoserTreeExplicit<value_type, Comparator> >(\n+                  seqs_begin,\n+                  seqs_end,\n+                  target,\n+                  comp, length, stable);\n+              break;\n #endif\n #if _GLIBCXX_LOSER_TREE\n-\t    case Settings::LOSER_TREE:\n-\t      return_target = multiway_merge_loser_tree<LoserTree<value_type, Comparator> >(seqs_begin, seqs_end, target, comp, length, stable);\n-\t      break;\n+            case Settings::LOSER_TREE:\n+              return_target = multiway_merge_loser_tree<\n+                    LoserTree<value_type, Comparator> >(\n+                  seqs_begin,\n+                  seqs_end,\n+                  target,\n+                  comp, length, stable);\n+              break;\n #endif\n #if _GLIBCXX_LOSER_TREE_COMBINED\n-\t    case Settings::LOSER_TREE_COMBINED:\n-\t      return_target = multiway_merge_loser_tree_combined(seqs_begin, seqs_end, target, comp, length, stable);\n-\t      break;\n+            case Settings::LOSER_TREE_COMBINED:\n+              return_target = multiway_merge_loser_tree_combined(\n+                  seqs_begin,\n+                  seqs_end,\n+                  target,\n+                  comp, length, stable);\n+              break;\n #endif\n #if _GLIBCXX_LOSER_TREE_SENTINEL\n-\t    case Settings::LOSER_TREE_SENTINEL:\n-\t      return_target = multiway_merge_loser_tree_sentinel(seqs_begin, seqs_end, target, comp, length, stable);\n-\t      break;\n+            case Settings::LOSER_TREE_SENTINEL:\n+              return_target = multiway_merge_loser_tree_sentinel(\n+                  seqs_begin,\n+                  seqs_end,\n+                  target,\n+                  comp, length, stable);\n+              break;\n #endif\n-\t    default:\n-\t      // multiway_merge algorithm not implemented.\n-\t      _GLIBCXX_PARALLEL_ASSERT(0);\n-\t      break;\n-\t    }\n-\t}\n+            default:\n+              // multiway_merge algorithm not implemented.\n+              _GLIBCXX_PARALLEL_ASSERT(0);\n+              break;\n+            }\n+        }\n       }\n #if _GLIBCXX_ASSERTIONS\n     _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n@@ -1319,214 +1500,268 @@ namespace __gnu_parallel\n     return return_target;\n   }\n \n-  /** @brief Parallel multi-way merge routine.\n-   *\n-   *  The decision if based on the branching factor and runtime settings.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @param sentinel Ignored.\n-   *  @return End iterator of output sequence. \n-   */\n-  template<typename RandomAccessIteratorIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Parallel multi-way merge routine.\n+ *\n+ *  The decision if based on the branching factor and runtime settings.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @param sentinel Ignored.\n+ *  @return End iterator of output sequence.\n+ */\n+template<\n+    typename RandomAccessIteratorIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n-  parallel_multiway_merge(RandomAccessIteratorIterator seqs_begin, RandomAccessIteratorIterator seqs_end, RandomAccessIterator3 target, Comparator comp, _DifferenceTp length, bool stable, bool sentinel)\n-  {\n-    _GLIBCXX_CALL(length)\n-\n-    typedef _DifferenceTp difference_type;\n-    typedef typename std::iterator_traits<RandomAccessIteratorIterator>::value_type::first_type\n-      RandomAccessIterator1;\n-    typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n-      value_type;\n-\n-#if _GLIBCXX_ASSERTIONS\n-    for (RandomAccessIteratorIterator rii = seqs_begin; rii != seqs_end; rii++)\n-      _GLIBCXX_PARALLEL_ASSERT(is_sorted((*rii).first, (*rii).second, comp));\n-#endif\n-\n-    // k sequences.\n-    int k = static_cast<int>(seqs_end - seqs_begin);\n-\n-    difference_type total_length = 0;\n-    for (RandomAccessIteratorIterator raii = seqs_begin; raii != seqs_end; raii++)\n-      total_length += LENGTH(*raii);\n-\n-    _GLIBCXX_CALL(total_length)\n-\n-    if (total_length == 0 || k == 0)\n-      return target;\n-\n-    thread_index_t num_threads = static_cast<thread_index_t>(std::min(static_cast<difference_type>(get_max_threads()), total_length));\n-\n-    bool tight = (total_length == length);\n-\n-    // Thread t will have to merge pieces[iam][0..k - 1]\n-    std::vector<std::pair<difference_type, difference_type> >* pieces = new std::vector<std::pair<difference_type, difference_type> >[num_threads];\n-    for (int s = 0; s < num_threads; s++)\n-      pieces[s].resize(k);\n-\n-    difference_type num_samples = Settings::merge_oversampling * num_threads;\n-\n-    if (Settings::multiway_merge_splitting == Settings::SAMPLING)\n-      {\n-\tvalue_type* samples = static_cast<value_type*>(::operator new(sizeof(value_type) * k * num_samples));\n-\t// Sample.\n-\tfor (int s = 0; s < k; s++)\n-\t  for (int i = 0; (difference_type)i < num_samples; i++)\n-\t    {\n-\t      difference_type sample_index = static_cast<difference_type>(LENGTH(seqs_begin[s]) * (double(i + 1) / (num_samples + 1)) * (double(length) / total_length));\n-\t      samples[s * num_samples + i] = seqs_begin[s].first[sample_index];\n-\t    }\n-\n-\tif (stable)\n-\t  __gnu_sequential::stable_sort(samples, samples + (num_samples * k), comp);\n-\telse\n-\t  __gnu_sequential::sort(samples, samples + (num_samples * k), comp);\n-\n-\tfor (int slab = 0; slab < num_threads; slab++)\n-\t  // For each slab / processor.\n-\t  for (int seq = 0; seq < k; seq++)\n-\t    {\n-\t      // For each sequence.\n-\t      if (slab > 0)\n-\t\tpieces[slab][seq].first = std::upper_bound(seqs_begin[seq].first, seqs_begin[seq].second, samples[num_samples * k * slab / num_threads], comp) - seqs_begin[seq].first;\n-\t      else\n-\t\t{\n-\t\t  // Absolute beginning.\n-\t\t  pieces[slab][seq].first = 0;\n-\t\t}\n-\t      if ((slab + 1) < num_threads)\n-\t\tpieces[slab][seq].second = std::upper_bound(seqs_begin[seq].first, seqs_begin[seq].second, samples[num_samples * k * (slab + 1) / num_threads], comp) - seqs_begin[seq].first;\n-\t      else\n-\t\tpieces[slab][seq].second = LENGTH(seqs_begin[seq]);\t//absolute ending\n-\t    }\n-\tdelete[] samples;\n-      }\n-    else\n-      {\n-\t// (Settings::multiway_merge_splitting == Settings::EXACT).\n-\tstd::vector<RandomAccessIterator1>* offsets = new std::vector<RandomAccessIterator1>[num_threads];\n-\tstd::vector<std::pair<RandomAccessIterator1, RandomAccessIterator1> > se(k);\n-\n-\tcopy(seqs_begin, seqs_end, se.begin());\n-\n-\tdifference_type* borders = static_cast<difference_type*>(__builtin_alloca(sizeof(difference_type) * (num_threads + 1)));\n-\tequally_split(length, num_threads, borders);\n-\n-\tfor (int s = 0; s < (num_threads - 1); s++)\n-\t  {\n-\t    offsets[s].resize(k);\n-\t    multiseq_partition(se.begin(), se.end(), borders[s + 1],\n-\t\t\t       offsets[s].begin(), comp);\n-\n-\t    // Last one also needed and available.\n-\t    if (!tight)\n-\t      {\n-\t\toffsets[num_threads - 1].resize(k);\n-\t\tmultiseq_partition(se.begin(), se.end(), \n-\t\t\t\t   difference_type(length), \n-\t\t\t\t   offsets[num_threads - 1].begin(),  comp);\n-\t      }\n-\t  }\n-\n-\n-\tfor (int slab = 0; slab < num_threads; slab++)\n-\t  {\n-\t    // For each slab / processor.\n-\t    for (int seq = 0; seq < k; seq++)\n-\t      {\n-\t\t// For each sequence.\n-\t\tif (slab == 0)\n-\t\t  {\n-\t\t    // Absolute beginning.\n-\t\t    pieces[slab][seq].first = 0;\n-\t\t  }\n-\t\telse\n-\t\t  pieces[slab][seq].first = pieces[slab - 1][seq].second;\n-\t\tif (!tight || slab < (num_threads - 1))\n-\t\t  pieces[slab][seq].second = offsets[slab][seq] - seqs_begin[seq].first;\n-\t\telse\n-\t\t  {\n-\t\t    // slab == num_threads - 1\n-\t\t    pieces[slab][seq].second = LENGTH(seqs_begin[seq]);\n-\t\t  }\n-\t      }\n-\t  }\n-\tdelete[] offsets;\n-      }\n-\n-#\tpragma omp parallel num_threads(num_threads)\n+  parallel_multiway_merge(RandomAccessIteratorIterator seqs_begin,\n+                          RandomAccessIteratorIterator seqs_end,\n+                           RandomAccessIterator3 target,\n+                           Comparator comp,\n+                           _DifferenceTp length, bool stable, bool sentinel)\n     {\n-      thread_index_t iam = omp_get_thread_num();\n-\n-      difference_type target_position = 0;\n-\n-      for (int c = 0; c < k; c++)\n-\ttarget_position += pieces[iam][c].first;\n-\n-      if (k > 2)\n-\t{\n-\t  std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks = new std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n-\n-\t  difference_type local_length = 0;\n-\t  for (int s = 0; s < k; s++)\n-\t    {\n-\t      chunks[s] = std::make_pair(seqs_begin[s].first + pieces[iam][s].first, seqs_begin[s].first + pieces[iam][s].second);\n-\t      local_length += LENGTH(chunks[s]);\n-\t    }\n-\n-\t  multiway_merge(chunks, chunks + k, target + target_position, comp,\n-\t\t\t std::min(local_length, length - target_position),\n-\t\t\t stable, false, sequential_tag());\n-\n-\t  delete[] chunks;\n-\t}\n-      else if (k == 2)\n-\t{\n-\t  RandomAccessIterator1 begin0 = seqs_begin[0].first + pieces[iam][0].first, begin1 = seqs_begin[1].first + pieces[iam][1].first;\n-\t  merge_advance(begin0,\n-\t\t\tseqs_begin[0].first + pieces[iam][0].second,\n-\t\t\tbegin1,\n-\t\t\tseqs_begin[1].first + pieces[iam][1].second,\n-\t\t\ttarget + target_position,\n-\t\t\t(pieces[iam][0].second - pieces[iam][0].first) + (pieces[iam][1].second - pieces[iam][1].first),\n-\t\t\tcomp);\n-\t}\n-    }\n+      _GLIBCXX_CALL(length)\n+\n+      typedef _DifferenceTp difference_type;\n+      typedef typename std::iterator_traits<RandomAccessIteratorIterator>\n+        ::value_type::first_type\n+        RandomAccessIterator1;\n+      typedef typename std::iterator_traits<RandomAccessIterator1>::value_type\n+        value_type;\n+\n+      // k sequences.\n+      int k = static_cast<int>(seqs_end - seqs_begin);\n+\n+      difference_type total_length = 0;\n+      for (RandomAccessIteratorIterator raii = seqs_begin;\n+           raii != seqs_end; raii++)\n+        total_length += LENGTH(*raii);\n+\n+      _GLIBCXX_CALL(total_length)\n+\n+      if (total_length == 0 || k == 0)\n+        return target;\n+\n+      bool tight = (total_length == length);\n+\n+      std::vector<std::pair<difference_type, difference_type> >* pieces;\n+\n+      thread_index_t num_threads = static_cast<thread_index_t>(\n+          std::min<difference_type>(get_max_threads(), total_length));\n+\n+#     pragma omp parallel num_threads (num_threads)\n+        {\n+#         pragma omp single\n+            {\n+              num_threads = omp_get_num_threads();\n+              // Thread t will have to merge pieces[iam][0..k - 1]\n+              pieces = new std::vector<\n+                  std::pair<difference_type, difference_type> >[num_threads];\n+              for (int s = 0; s < num_threads; s++)\n+                pieces[s].resize(k);\n+\n+              difference_type num_samples =\n+                  Settings::merge_oversampling * num_threads;\n+\n+              if (Settings::multiway_merge_splitting == Settings::SAMPLING)\n+                {\n+                  value_type* samples = static_cast<value_type*>(\n+                    ::operator new(sizeof(value_type) * k * num_samples));\n+                  // Sample.\n+                  for (int s = 0; s < k; s++)\n+                    for (int i = 0; (difference_type)i < num_samples; i++)\n+                      {\n+                        difference_type sample_index =\n+                            static_cast<difference_type>(\n+                                LENGTH(seqs_begin[s]) * (double(i + 1) /\n+                                (num_samples + 1)) * (double(length)\n+                                / total_length));\n+                        samples[s * num_samples + i] =\n+                            seqs_begin[s].first[sample_index];\n+                      }\n+\n+                  if (stable)\n+                    __gnu_sequential::stable_sort(\n+                      samples, samples + (num_samples * k), comp);\n+                  else\n+                    __gnu_sequential::sort(\n+                      samples, samples + (num_samples * k), comp);\n+\n+                  for (int slab = 0; slab < num_threads; slab++)\n+                    // For each slab / processor.\n+                    for (int seq = 0; seq < k; seq++)\n+                      {\n+                        // For each sequence.\n+                        if (slab > 0)\n+                          pieces[slab][seq].first =\n+                              std::upper_bound(\n+                                seqs_begin[seq].first,\n+                                seqs_begin[seq].second,\n+                                samples[num_samples * k * slab / num_threads],\n+                                  comp)\n+                              - seqs_begin[seq].first;\n+                        else\n+                          {\n+                            // Absolute beginning.\n+                            pieces[slab][seq].first = 0;\n+                          }\n+                        if ((slab + 1) < num_threads)\n+                          pieces[slab][seq].second =\n+                              std::upper_bound(\n+                                  seqs_begin[seq].first,\n+                                  seqs_begin[seq].second,\n+                                  samples[num_samples * k * (slab + 1) /\n+                                      num_threads], comp)\n+                              - seqs_begin[seq].first;\n+                        else\n+                        pieces[slab][seq].second = LENGTH(seqs_begin[seq]);\n+                      }\n+                    delete[] samples;\n+                }\n+              else\n+                {\n+                  // (Settings::multiway_merge_splitting == Settings::EXACT).\n+                  std::vector<RandomAccessIterator1>* offsets =\n+                      new std::vector<RandomAccessIterator1>[num_threads];\n+                  std::vector<\n+                      std::pair<RandomAccessIterator1, RandomAccessIterator1>\n+                      > se(k);\n+\n+                  copy(seqs_begin, seqs_end, se.begin());\n+\n+                  difference_type* borders =\n+                      new difference_type[num_threads + 1];\n+                  equally_split(length, num_threads, borders);\n+\n+                  for (int s = 0; s < (num_threads - 1); s++)\n+                    {\n+                      offsets[s].resize(k);\n+                      multiseq_partition(\n+                          se.begin(), se.end(), borders[s + 1],\n+                          offsets[s].begin(), comp);\n+\n+                      // Last one also needed and available.\n+                      if (!tight)\n+                        {\n+                          offsets[num_threads - 1].resize(k);\n+                          multiseq_partition(se.begin(), se.end(),\n+                                difference_type(length),\n+                                offsets[num_threads - 1].begin(),  comp);\n+                        }\n+                    }\n+\n+\n+                  for (int slab = 0; slab < num_threads; slab++)\n+                    {\n+                      // For each slab / processor.\n+                      for (int seq = 0; seq < k; seq++)\n+                        {\n+                          // For each sequence.\n+                          if (slab == 0)\n+                            {\n+                              // Absolute beginning.\n+                              pieces[slab][seq].first = 0;\n+                            }\n+                          else\n+                            pieces[slab][seq].first =\n+                                pieces[slab - 1][seq].second;\n+                          if (!tight || slab < (num_threads - 1))\n+                            pieces[slab][seq].second =\n+                                offsets[slab][seq] - seqs_begin[seq].first;\n+                          else\n+                            {\n+                              // slab == num_threads - 1\n+                              pieces[slab][seq].second =\n+                                  LENGTH(seqs_begin[seq]);\n+                            }\n+                        }\n+                    }\n+                  delete[] offsets;\n+                }\n+            } //single\n+\n+          thread_index_t iam = omp_get_thread_num();\n+\n+          difference_type target_position = 0;\n+\n+          for (int c = 0; c < k; c++)\n+            target_position += pieces[iam][c].first;\n+\n+          if (k > 2)\n+            {\n+              std::pair<RandomAccessIterator1, RandomAccessIterator1>* chunks\n+                = new\n+                  std::pair<RandomAccessIterator1, RandomAccessIterator1>[k];\n+\n+              difference_type local_length = 0;\n+              for (int s = 0; s < k; s++)\n+                {\n+                  chunks[s] = std::make_pair(\n+                      seqs_begin[s].first + pieces[iam][s].first,\n+                      seqs_begin[s].first + pieces[iam][s].second);\n+                  local_length += LENGTH(chunks[s]);\n+                }\n+\n+              multiway_merge(\n+                    chunks, chunks + k, target + target_position, comp,\n+                    std::min(local_length, length - target_position),\n+                    stable, false, sequential_tag());\n+\n+              delete[] chunks;\n+            }\n+          else if (k == 2)\n+            {\n+              RandomAccessIterator1\n+                  begin0 = seqs_begin[0].first + pieces[iam][0].first,\n+                  begin1 = seqs_begin[1].first + pieces[iam][1].first;\n+              merge_advance(begin0,\n+                    seqs_begin[0].first + pieces[iam][0].second,\n+                    begin1,\n+                    seqs_begin[1].first + pieces[iam][1].second,\n+                    target + target_position,\n+                    (pieces[iam][0].second - pieces[iam][0].first) +\n+                        (pieces[iam][1].second - pieces[iam][1].first),\n+                    comp);\n+            }\n+        } //parallel\n \n #if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n+      _GLIBCXX_PARALLEL_ASSERT(is_sorted(target, target + length, comp));\n #endif\n \n-    // Update ends of sequences.\n-    for (int s = 0; s < k; s++)\n-      seqs_begin[s].first += pieces[num_threads - 1][s].second;\n+      // Update ends of sequences.\n+      for (int s = 0; s < k; s++)\n+        seqs_begin[s].first += pieces[num_threads - 1][s].second;\n \n-    delete[] pieces;\n+      delete[] pieces;\n \n-    return target + length;\n-  }\n+      return target + length;\n+    }\n \n-  /** \n-   *  @brief Multi-way merging front-end.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @return End iterator of output sequence. \n-   */\n-  template<typename RandomAccessIteratorPairIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/**\n+ *  @brief Multi-way merging front-end.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @return End iterator of output sequence.\n+ */\n+template<\n+    typename RandomAccessIteratorPairIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n   multiway_merge(RandomAccessIteratorPairIterator seqs_begin,\n-\t\t RandomAccessIteratorPairIterator seqs_end,\n-\t\t RandomAccessIterator3 target, Comparator comp,\n-\t\t _DifferenceTp length, bool stable)\n+                RandomAccessIteratorPairIterator seqs_end,\n+                RandomAccessIterator3 target, Comparator comp,\n+                _DifferenceTp length, bool stable)\n   {\n     typedef _DifferenceTp difference_type;\n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n@@ -1535,33 +1770,43 @@ namespace __gnu_parallel\n       return target;\n \n     RandomAccessIterator3 target_end;\n-    if (_GLIBCXX_PARALLEL_CONDITION(((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k) && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n-      target_end = parallel_multiway_merge(seqs_begin, seqs_end, target, comp, (difference_type)length, stable, false);\n+    if (_GLIBCXX_PARALLEL_CONDITION(\n+        ((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k)\n+        && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n+      target_end = parallel_multiway_merge(\n+          seqs_begin, seqs_end,\n+          target, comp, static_cast<difference_type>(length), stable, false);\n     else\n-      target_end = multiway_merge(seqs_begin, seqs_end, target, comp, length, stable, false, sequential_tag());\n+      target_end = multiway_merge(\n+          seqs_begin, seqs_end,\n+          target, comp, length, stable, false, sequential_tag());\n \n     return target_end;\n   }\n \n-  /** @brief Multi-way merging front-end.\n-   *  @param seqs_begin Begin iterator of iterator pair input sequence.\n-   *  @param seqs_end End iterator of iterator pair input sequence.\n-   *  @param target Begin iterator out output sequence.\n-   *  @param comp Comparator.\n-   *  @param length Maximum length to merge.\n-   *  @param stable Stable merging incurs a performance penalty.\n-   *  @return End iterator of output sequence.\n-   *  @pre For each @c i, @c seqs_begin[i].second must be the end\n-   *  marker of the sequence, but also reference the one more sentinel\n-   *  element. */\n-  template<typename RandomAccessIteratorPairIterator, typename RandomAccessIterator3, typename _DifferenceTp, typename Comparator>\n+/** @brief Multi-way merging front-end.\n+ *  @param seqs_begin Begin iterator of iterator pair input sequence.\n+ *  @param seqs_end End iterator of iterator pair input sequence.\n+ *  @param target Begin iterator out output sequence.\n+ *  @param comp Comparator.\n+ *  @param length Maximum length to merge.\n+ *  @param stable Stable merging incurs a performance penalty.\n+ *  @return End iterator of output sequence.\n+ *  @pre For each @c i, @c seqs_begin[i].second must be the end\n+ *  marker of the sequence, but also reference the one more sentinel\n+ *  element. */\n+template<\n+    typename RandomAccessIteratorPairIterator,\n+    typename RandomAccessIterator3,\n+    typename _DifferenceTp,\n+    typename Comparator>\n   RandomAccessIterator3\n   multiway_merge_sentinel(RandomAccessIteratorPairIterator seqs_begin,\n-\t\t\t  RandomAccessIteratorPairIterator seqs_end,\n-\t\t\t  RandomAccessIterator3 target,\n-\t\t\t  Comparator comp,\n-\t\t\t  _DifferenceTp length,\n-\t\t\t  bool stable)\n+                          RandomAccessIteratorPairIterator seqs_end,\n+                          RandomAccessIterator3 target,\n+                          Comparator comp,\n+                          _DifferenceTp length,\n+                          bool stable)\n   {\n     typedef _DifferenceTp difference_type;\n \n@@ -1570,10 +1815,16 @@ namespace __gnu_parallel\n \n     _GLIBCXX_CALL(seqs_end - seqs_begin)\n \n-    if (_GLIBCXX_PARALLEL_CONDITION(((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k) && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n-      return parallel_multiway_merge(seqs_begin, seqs_end, target, comp, (typename std::iterator_traits<RandomAccessIterator3>::difference_type)length, stable, true);\n+    if (_GLIBCXX_PARALLEL_CONDITION(\n+        ((seqs_end - seqs_begin) >= Settings::multiway_merge_minimal_k)\n+        && ((sequence_index_t)length >= Settings::multiway_merge_minimal_n)))\n+      return parallel_multiway_merge(\n+          seqs_begin, seqs_end,\n+          target, comp, static_cast<difference_type>(length), stable, true);\n     else\n-      return multiway_merge(seqs_begin, seqs_end, target, comp, length, stable, true, sequential_tag());\n+      return multiway_merge(\n+          seqs_begin, seqs_end,\n+          target, comp, length, stable, true, sequential_tag());\n   }\n }\n "}, {"sha": "5dedd0035c4afe97f17e670193c38dc4ea18b50f", "filename": "libstdc++-v3/include/parallel/multiway_mergesort.h", "status": "modified", "additions": 203, "deletions": 200, "changes": 403, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fmultiway_mergesort.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -48,8 +48,8 @@\n namespace __gnu_parallel\n {\n \n-  /** @brief Subsequence description. */\n-  template<typename _DifferenceTp>\n+/** @brief Subsequence description. */\n+template<typename _DifferenceTp>\n   struct Piece\n   {\n     typedef _DifferenceTp difference_type;\n@@ -61,16 +61,19 @@ namespace __gnu_parallel\n     difference_type end;\n   };\n \n-  /** @brief Data accessed by all threads.\n-   *\n-   *  PMWMS = parallel multiway mergesort */\n-  template<typename RandomAccessIterator>\n+/** @brief Data accessed by all threads.\n+  *\n+  *  PMWMS = parallel multiway mergesort */\n+template<typename RandomAccessIterator>\n   struct PMWMSSortingData\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n+    /** @brief Number of threads involved. */\n+    thread_index_t num_threads;\n+\n     /** @brief Input begin. */\n     RandomAccessIterator source;\n \n@@ -105,62 +108,55 @@ namespace __gnu_parallel\n \n     /** @brief Pieces of data to merge @c [thread][sequence] */\n     std::vector<Piece<difference_type> >* pieces;\n-  };\n \n-  /** @brief Thread local data for PMWMS. */\n-  template<typename RandomAccessIterator>\n-  struct PMWMSSorterPU\n-  {\n-    /** @brief Total number of thread involved. */\n-    thread_index_t num_threads;\n-    /** @brief Number of owning thread. */\n-    thread_index_t iam;\n     /** @brief Stable sorting desired. */\n     bool stable;\n-    /** @brief Pointer to global data. */\n-    PMWMSSortingData<RandomAccessIterator>* sd;\n-  };\n-\n-  /** \n-   *  @brief Select samples from a sequence.\n-   *  @param d Pointer to thread-local data. Result will be placed in\n-   *  @c d->ds->samples.\n-   *  @param num_samples Number of samples to select. \n-   */\n-  template<typename RandomAccessIterator, typename _DifferenceTp>\n+};\n+\n+/**\n+  *  @brief Select samples from a sequence.\n+  *  @param sd Pointer to algorithm data. Result will be placed in\n+  *  @c sd->samples.\n+  *  @param num_samples Number of samples to select.\n+  */\n+template<typename RandomAccessIterator, typename _DifferenceTp>\n   inline void \n-  determine_samples(PMWMSSorterPU<RandomAccessIterator>* d, \n-\t\t    _DifferenceTp& num_samples)\n+  determine_samples(PMWMSSortingData<RandomAccessIterator>* sd,\n+                    _DifferenceTp& num_samples)\n   {\n     typedef _DifferenceTp difference_type;\n \n-    PMWMSSortingData<RandomAccessIterator>* sd = d->sd;\n+    thread_index_t iam = omp_get_thread_num();\n \n-    num_samples = Settings::sort_mwms_oversampling * d->num_threads - 1;\n+    num_samples =\n+        Settings::sort_mwms_oversampling * sd->num_threads - 1;\n \n-    difference_type* es = static_cast<difference_type*>(__builtin_alloca(sizeof(difference_type) * (num_samples + 2)));\n+    difference_type* es = new difference_type[num_samples + 2];\n \n-    equally_split(sd->starts[d->iam + 1] - sd->starts[d->iam], num_samples + 1, es);\n+    equally_split(sd->starts[iam + 1] - sd->starts[iam], \n+                  num_samples + 1, es);\n \n     for (difference_type i = 0; i < num_samples; i++)\n-      sd->samples[d->iam * num_samples + i] = sd->source[sd->starts[d->iam] + es[i + 1]];\n+      sd->samples[iam * num_samples + i] =\n+          sd->source[sd->starts[iam] + es[i + 1]];\n+\n+    delete[] es;\n   }\n \n-  /** @brief PMWMS code executed by each thread.\n-   *  @param d Pointer to thread-local data.\n-   *  @param comp Comparator. \n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief PMWMS code executed by each thread.\n+  *  @param sd Pointer to algorithm data.\n+  *  @param comp Comparator.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline void \n-  parallel_sort_mwms_pu(PMWMSSorterPU<RandomAccessIterator>* d, \n-\t\t\tComparator& comp)\n+  parallel_sort_mwms_pu(PMWMSSortingData<RandomAccessIterator>* sd,\n+                        Comparator& comp)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    PMWMSSortingData<RandomAccessIterator>* sd = d->sd;\n-    thread_index_t iam = d->iam;\n+    thread_index_t iam = omp_get_thread_num();\n \n     // Length of this thread's chunk, before merging.\n     difference_type length_local = sd->starts[iam + 1] - sd->starts[iam];\n@@ -174,237 +170,244 @@ namespace __gnu_parallel\n     typedef value_type* SortingPlacesIterator;\n \n     // Sort in temporary storage, leave space for sentinel.\n-    sd->sorting_places[iam] = sd->temporaries[iam] = static_cast<value_type*>(::operator new(sizeof(value_type) * (length_local + 1)));\n+    sd->sorting_places[iam] = sd->temporaries[iam] = \n+        static_cast<value_type*>(\n+        ::operator new(sizeof(value_type) * (length_local + 1)));\n \n     // Copy there.\n-    std::uninitialized_copy(sd->source + sd->starts[iam], sd->source + sd->starts[iam] + length_local, sd->sorting_places[iam]);\n+    std::uninitialized_copy(sd->source + sd->starts[iam],\n+                            sd->source + sd->starts[iam] + length_local,\n+                            sd->sorting_places[iam]);\n #endif\n \n     // Sort locally.\n-    if (d->stable)\n-      __gnu_sequential::stable_sort(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp);\n+    if (sd->stable)\n+      __gnu_sequential::stable_sort(sd->sorting_places[iam],\n+                                    sd->sorting_places[iam] + length_local,\n+                                    comp);\n     else\n-      __gnu_sequential::sort(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp);\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(sd->sorting_places[iam], sd->sorting_places[iam] + length_local, comp));\n-#endif\n+      __gnu_sequential::sort(sd->sorting_places[iam],\n+                             sd->sorting_places[iam] + length_local,\n+                             comp);\n \n     // Invariant: locally sorted subsequence in sd->sorting_places[iam],\n     // sd->sorting_places[iam] + length_local.\n \n     if (Settings::sort_splitting == Settings::SAMPLING)\n       {\n-\tdifference_type num_samples;\n-\tdetermine_samples(d, num_samples);\n-\n-#pragma omp barrier\n-\n-#pragma omp single\n-\t__gnu_sequential::sort(sd->samples, \n-\t\t\t       sd->samples + (num_samples * d->num_threads), \n-\t\t\t       comp);\n-\n-#pragma omp barrier\n-\n-\tfor (int s = 0; s < d->num_threads; s++)\n-\t  {\n-\t    // For each sequence.\n-\t    if (num_samples * iam > 0)\n-\t      sd->pieces[iam][s].begin = std::lower_bound(sd->sorting_places[s],\n-\t\t\t\t sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n-\t\t\t\t sd->samples[num_samples * iam],\n-\t\t\t\t comp)\n-\t\t- sd->sorting_places[s];\n-\t    else\n-\t      // Absolute beginning.\n-\t      sd->pieces[iam][s].begin = 0;\n-\n-\t    if ((num_samples * (iam + 1)) < (num_samples * d->num_threads))\n-\t      sd->pieces[iam][s].end = std::lower_bound(sd->sorting_places[s],\n-\t\t\t\t\t\t\tsd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s], sd->samples[num_samples * (iam + 1)], comp)\n-\t\t- sd->sorting_places[s];\n-\t    else\n-\t      // Absolute end.\n-\t      sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n-\t  }\n-\n+        difference_type num_samples;\n+        determine_samples(sd, num_samples);\n+\n+#       pragma omp barrier\n+\n+#       pragma omp single\n+        __gnu_sequential::sort(sd->samples,\n+                               sd->samples + (num_samples * sd->num_threads),\n+                               comp);\n+\n+#       pragma omp barrier\n+\n+        for (int s = 0; s < sd->num_threads; s++)\n+          {\n+            // For each sequence.\n+              if (num_samples * iam > 0)\n+                sd->pieces[iam][s].begin = \n+                    std::lower_bound(sd->sorting_places[s],\n+                        sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n+                        sd->samples[num_samples * iam],\n+                        comp)\n+                    - sd->sorting_places[s];\n+            else\n+              // Absolute beginning.\n+              sd->pieces[iam][s].begin = 0;\n+\n+            if ((num_samples * (iam + 1)) < (num_samples * sd->num_threads))\n+              sd->pieces[iam][s].end =\n+                  std::lower_bound(sd->sorting_places[s],\n+                                   sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s],\n+                                   sd->samples[num_samples * (iam + 1)], comp)\n+                  - sd->sorting_places[s];\n+            else\n+              // Absolute end.\n+              sd->pieces[iam][s].end = sd->starts[s + 1] - sd->starts[s];\n+            }\n       }\n     else if (Settings::sort_splitting == Settings::EXACT)\n       {\n-#pragma omp barrier\n-\n-\tstd::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> > seqs(d->num_threads);\n-\tfor (int s = 0; s < d->num_threads; s++)\n-\t  seqs[s] = std::make_pair(sd->sorting_places[s], sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s]);\n-\n-\tstd::vector<SortingPlacesIterator> offsets(d->num_threads);\n-\n-\t// If not last thread.\n-\tif (iam < d->num_threads - 1)\n-\t  multiseq_partition(seqs.begin(), seqs.end(), sd->starts[iam + 1], offsets.begin(), comp);\n-\n-\tfor (int seq = 0; seq < d->num_threads; seq++)\n-\t  {\n-\t    // For each sequence.\n-\t    if (iam < (d->num_threads - 1))\n-\t      sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n-\t    else\n-\t      // Absolute end of this sequence.\n-\t      sd->pieces[iam][seq].end = sd->starts[seq + 1] - sd->starts[seq];\n-\t  }\n-\n-#pragma omp barrier\n-\n-\tfor (int seq = 0; seq < d->num_threads; seq++)\n-\t  {\n-\t    // For each sequence.\n-\t    if (iam > 0)\n-\t      sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n-\t    else\n-\t      // Absolute beginning.\n-\t      sd->pieces[iam][seq].begin = 0;\n-\t  }\n+#       pragma omp barrier\n+\n+        std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n+            seqs(sd->num_threads);\n+        for (int s = 0; s < sd->num_threads; s++)\n+          seqs[s] = std::make_pair(sd->sorting_places[s],\n+                                   sd->sorting_places[s] + sd->starts[s + 1] - sd->starts[s]);\n+\n+        std::vector<SortingPlacesIterator> offsets(sd->num_threads);\n+\n+        // if not last thread\n+        if (iam < sd->num_threads - 1)\n+          multiseq_partition(seqs.begin(), seqs.end(),\n+                             sd->starts[iam + 1], offsets.begin(), comp);\n+\n+        for (int seq = 0; seq < sd->num_threads; seq++)\n+          {\n+            // for each sequence\n+            if (iam < (sd->num_threads - 1))\n+              sd->pieces[iam][seq].end = offsets[seq] - seqs[seq].first;\n+            else\n+              // very end of this sequence\n+              sd->pieces[iam][seq].end = sd->starts[seq + 1] - sd->starts[seq];\n+          }\n+\n+#       pragma omp barrier\n+\n+        for (int seq = 0; seq < sd->num_threads; seq++)\n+          {\n+            // For each sequence.\n+            if (iam > 0)\n+              sd->pieces[iam][seq].begin = sd->pieces[iam - 1][seq].end;\n+            else\n+              // Absolute beginning.\n+              sd->pieces[iam][seq].begin = 0;\n+          }\n       }\n \n     // Offset from target begin, length after merging.\n     difference_type offset = 0, length_am = 0;\n-    for (int s = 0; s < d->num_threads; s++)\n+    for (int s = 0; s < sd->num_threads; s++)\n       {\n-\tlength_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n-\toffset += sd->pieces[iam][s].begin;\n+        length_am += sd->pieces[iam][s].end - sd->pieces[iam][s].begin;\n+        offset += sd->pieces[iam][s].begin;\n       }\n \n #if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n     // Merge to temporary storage, uninitialized creation not possible\n     // since there is no multiway_merge calling the placement new\n     // instead of the assignment operator.\n-    sd->merging_places[iam] = sd->temporaries[iam] = static_cast<value_type*>(::operator new(sizeof(value_type) * length_am));\n+    sd->merging_places[iam] = sd->temporaries[iam] =\n+        static_cast<value_type*>(\n+        ::operator new(sizeof(value_type) * length_am));\n #else\n     // Merge directly to target.\n     sd->merging_places[iam] = sd->source + offset;\n #endif\n-    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> > seqs(d->num_threads);\n+    std::vector<std::pair<SortingPlacesIterator, SortingPlacesIterator> >\n+        seqs(sd->num_threads);\n \n-    for (int s = 0; s < d->num_threads; s++)\n+    for (int s = 0; s < sd->num_threads; s++)\n       {\n-\tseqs[s] = std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin, sd->sorting_places[s] + sd->pieces[iam][s].end);\n-\n-#if _GLIBCXX_ASSERTIONS\n-\t_GLIBCXX_PARALLEL_ASSERT(is_sorted(seqs[s].first, seqs[s].second, comp));\n-#endif\n+        seqs[s] = std::make_pair(sd->sorting_places[s] + sd->pieces[iam][s].begin,\n+                                 sd->sorting_places[s] + sd->pieces[iam][s].end);\n       }\n \n-    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp, length_am, d->stable, false, sequential_tag());\n-\n-#if _GLIBCXX_ASSERTIONS\n-    _GLIBCXX_PARALLEL_ASSERT(is_sorted(sd->merging_places[iam], sd->merging_places[iam] + length_am, comp));\n-#endif\n+    multiway_merge(seqs.begin(), seqs.end(), sd->merging_places[iam], comp, length_am, sd->stable, false, sequential_tag());\n \n-#\tpragma omp barrier\n+#   pragma omp barrier\n \n #if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n     // Write back.\n-    std::copy(sd->merging_places[iam], sd->merging_places[iam] + length_am, \n-\t      sd->source + offset);\n+    std::copy(sd->merging_places[iam],\n+              sd->merging_places[iam] + length_am,\n+              sd->source + offset);\n #endif\n \n     delete[] sd->temporaries[iam];\n   }\n \n-  /** @brief PMWMS main call.\n-   *  @param begin Begin iterator of sequence.\n-   *  @param end End iterator of sequence.\n-   *  @param comp Comparator.\n-   *  @param n Length of sequence.\n-   *  @param num_threads Number of threads to use.\n-   *  @param stable Stable sorting.\n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief PMWMS main call.\n+  *  @param begin Begin iterator of sequence.\n+  *  @param end End iterator of sequence.\n+  *  @param comp Comparator.\n+  *  @param n Length of sequence.\n+  *  @param num_threads Number of threads to use.\n+  *  @param stable Stable sorting.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end, \n-\t\t     Comparator comp, \n-       typename std::iterator_traits<RandomAccessIterator>::difference_type n, \n-\t\t     int num_threads, bool stable)\n+  parallel_sort_mwms(RandomAccessIterator begin, RandomAccessIterator end,\n+                     Comparator comp, \n+                     typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n+                     int num_threads,\n+                     bool stable)\n   {\n     _GLIBCXX_CALL(n)\n-      \n+\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     if (n <= 1)\n       return;\n \n-    // At least one element per thread.\n+    // at least one element per thread\n     if (num_threads > n)\n       num_threads = static_cast<thread_index_t>(n);\n \n+    // shared variables\n     PMWMSSortingData<RandomAccessIterator> sd;\n+    difference_type* starts;\n \n-    sd.source = begin;\n-    sd.temporaries = new value_type*[num_threads];\n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+        num_threads = omp_get_num_threads();  //no more threads than requested\n+\n+#       pragma omp single\n+          {\n+            sd.num_threads = num_threads;\n+            sd.source = begin;\n+            sd.temporaries = new value_type*[num_threads];\n \n #if _GLIBCXX_MULTIWAY_MERGESORT_COPY_LAST\n-    sd.sorting_places = new RandomAccessIterator[num_threads];\n-    sd.merging_places = new value_type*[num_threads];\n+            sd.sorting_places = new RandomAccessIterator[num_threads];\n+            sd.merging_places = new value_type*[num_threads];\n #else\n-    sd.sorting_places = new value_type*[num_threads];\n-    sd.merging_places = new RandomAccessIterator[num_threads];\n+            sd.sorting_places = new value_type*[num_threads];\n+            sd.merging_places = new RandomAccessIterator[num_threads];\n #endif\n \n-    if (Settings::sort_splitting == Settings::SAMPLING)\n-      {\n-\tunsigned int sz = Settings::sort_mwms_oversampling * num_threads - 1;\n-\tsz *= num_threads;\n-\t\n-\t// Equivalent to value_type[sz], without need of default construction.\n-\tsz *= sizeof(value_type);\n-\tsd.samples = static_cast<value_type*>(::operator new(sz));\n-      }\n-    else\n-      sd.samples = NULL;\n-\n-    sd.offsets = new difference_type[num_threads - 1];\n-    sd.pieces = new std::vector<Piece<difference_type> >[num_threads];\n-    for (int s = 0; s < num_threads; s++)\n-      sd.pieces[s].resize(num_threads);\n-    PMWMSSorterPU<RandomAccessIterator>* pus = new PMWMSSorterPU<RandomAccessIterator>[num_threads];\n-    difference_type* starts = sd.starts = new difference_type[num_threads + 1];\n-\n-    difference_type chunk_length = n / num_threads;\n-    difference_type split = n % num_threads;\n-    difference_type start = 0;\n-    for (int i = 0; i < num_threads; i++)\n-      {\n-\tstarts[i] = start;\n-\tstart += (i < split) ? (chunk_length + 1) : chunk_length;\n-\tpus[i].num_threads = num_threads;\n-\tpus[i].iam = i;\n-\tpus[i].sd = &sd;\n-\tpus[i].stable = stable;\n-      }\n-    starts[num_threads] = start;\n-\n-    // Now sort in parallel.\n-#pragma omp parallel num_threads(num_threads)\n-    parallel_sort_mwms_pu(&(pus[omp_get_thread_num()]), comp);\n+            if (Settings::sort_splitting == Settings::SAMPLING)\n+              {\n+                unsigned int size = \n+                    (Settings::sort_mwms_oversampling * num_threads - 1) * num_threads;\n+                sd.samples = static_cast<value_type*>(\n+                    ::operator new(size * sizeof(value_type)));\n+              }\n+            else\n+              sd.samples = NULL;\n+\n+            sd.offsets = new difference_type[num_threads - 1];\n+            sd.pieces = new std::vector<Piece<difference_type> >[num_threads];\n+            for (int s = 0; s < num_threads; s++)\n+              sd.pieces[s].resize(num_threads);\n+            starts = sd.starts = new difference_type[num_threads + 1];\n+            sd.stable = stable;\n+\n+            difference_type chunk_length = n / num_threads;\n+            difference_type split = n % num_threads;\n+            difference_type pos = 0;\n+            for (int i = 0; i < num_threads; i++)\n+              {\n+                starts[i] = pos;\n+                pos += (i < split) ? (chunk_length + 1) : chunk_length;\n+              }\n+            starts[num_threads] = pos;\n+          }\n+\n+        // Now sort in parallel.\n+        parallel_sort_mwms_pu(&sd, comp);\n+      } //parallel\n \n-    // XXX sd as RAII\n     delete[] starts;\n     delete[] sd.temporaries;\n     delete[] sd.sorting_places;\n     delete[] sd.merging_places;\n \n     if (Settings::sort_splitting == Settings::SAMPLING)\n-      delete[] sd.samples;\n+        delete[] sd.samples;\n \n     delete[] sd.offsets;\n     delete[] sd.pieces;\n-\n-    delete[] pus;\n   }\n-\n-}\n+} //namespace __gnu_parallel\n \n #endif"}, {"sha": "0a992b063def6c9e4c6faa3de001227d7560d360", "filename": "libstdc++-v3/include/parallel/omp_loop.h", "status": "modified", "additions": 55, "deletions": 37, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -43,54 +43,71 @@\n \n #include <parallel/settings.h>\n #include <parallel/basic_iterator.h>\n+#include <parallel/base.h>\n \n namespace __gnu_parallel\n {\n-  /** @brief Embarrassingly parallel algorithm for random access\n-   * iterators, using an OpenMP for loop.\n-   *\n-   *  @param begin Begin iterator of element sequence.\n-   *  @param end End iterator of element sequence.\n-   *  @param o User-supplied functor (comparator, predicate, adding\n-   *  functor, etc.).\n-   *  @param f Functor to \"process\" an element with op (depends on\n-   *  desired functionality, e. g. for std::for_each(), ...).\n-   *  @param r Functor to \"add\" a single result to the already\n-   *  processed elements (depends on functionality).\n-   *  @param base Base value for reduction.\n-   *  @param output Pointer to position where final result is written to\n-   *  @param bound Maximum number of elements processed (e. g. for\n-   *  std::count_n()).\n-   *  @return User-supplied functor (that may contain a part of the result).\n-   */\n-  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+/** @brief Embarrassingly parallel algorithm for random access\n+  * iterators, using an OpenMP for loop.\n+  *\n+  *  @param begin Begin iterator of element sequence.\n+  *  @param end End iterator of element sequence.\n+  *  @param o User-supplied functor (comparator, predicate, adding\n+  *  functor, etc.).\n+  *  @param f Functor to \"process\" an element with op (depends on\n+  *  desired functionality, e. g. for std::for_each(), ...).\n+  *  @param r Functor to \"add\" a single result to the already\n+  *  processed elements (depends on functionality).\n+  *  @param base Base value for reduction.\n+  *  @param output Pointer to position where final result is written to\n+  *  @param bound Maximum number of elements processed (e. g. for\n+  *  std::count_n()).\n+  *  @return User-supplied functor (that may contain a part of the result).\n+  */\n+template<typename RandomAccessIterator,\n+            typename Op,\n+            typename Fu,\n+            typename Red,\n+            typename Result>\n   Op\n-  for_each_template_random_access_omp_loop(RandomAccessIterator begin, RandomAccessIterator end, Op o, Fu& f, Red r, Result base, Result& output, typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  for_each_template_random_access_omp_loop(\n+             RandomAccessIterator begin,\n+             RandomAccessIterator end,\n+             Op o, Fu& f, Red r, Result base, Result& output,\n+             typename std::iterator_traits<RandomAccessIterator>::\n+                 difference_type bound)\n   {\n-    typedef typename std::iterator_traits<RandomAccessIterator>::difference_type difference_type;\n+    typedef typename\n+        std::iterator_traits<RandomAccessIterator>::difference_type\n+        difference_type;\n \n-    thread_index_t num_threads = (get_max_threads() < (end - begin)) ? get_max_threads() : static_cast<thread_index_t>((end - begin));\n-    Result *thread_results = new Result[num_threads];\n     difference_type length = end - begin;\n+    thread_index_t num_threads =\n+        __gnu_parallel::min<difference_type>(get_max_threads(), length);\n \n-    for (thread_index_t i = 0; i < num_threads; i++)\n+    Result *thread_results;\n+\n+#   pragma omp parallel num_threads(num_threads)\n       {\n-\tthread_results[i] = r(thread_results[i], f(o, begin+i));\n-      }\n-\n-#pragma omp parallel num_threads(num_threads)\n-    {\n-#pragma omp for schedule(dynamic, Settings::workstealing_chunk_size)\n-      for (difference_type pos = 0; pos < length; pos++)\n-\t{\n-\t  thread_results[omp_get_thread_num()] = r(thread_results[omp_get_thread_num()], f(o, begin+pos));\n-\t}\n-    }\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            thread_results = new Result[num_threads];\n+\n+            for (thread_index_t i = 0; i < num_threads; i++)\n+              thread_results[i] = Result();\n+          }\n+\n+        thread_index_t iam = omp_get_thread_num();\n+\n+#       pragma omp for schedule(dynamic, Settings::workstealing_chunk_size)\n+        for (difference_type pos = 0; pos < length; pos++)\n+          thread_results[iam] =\n+              r(thread_results[iam], f(o, begin+pos));\n+      } //parallel\n \n     for (thread_index_t i = 0; i < num_threads; i++)\n-      {\n-\toutput = r(output, thread_results[i]);\n-      }\n+        output = r(output, thread_results[i]);\n \n     delete [] thread_results;\n \n@@ -100,6 +117,7 @@ namespace __gnu_parallel\n \n     return o;\n   }\n+\n } // end namespace\n \n #endif"}, {"sha": "df2c3b5e6a723a82daea8e1cec04792185819ae0", "filename": "libstdc++-v3/include/parallel/omp_loop_static.h", "status": "modified", "additions": 37, "deletions": 25, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fomp_loop_static.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -64,39 +64,50 @@ namespace __gnu_parallel\n    *  std::count_n()).\n    *  @return User-supplied functor (that may contain a part of the result).\n    */\n-  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+template<typename RandomAccessIterator,\n+          typename Op,\n+          typename Fu,\n+          typename Red,\n+          typename Result>\n   Op\n-  for_each_template_random_access_omp_loop_static(RandomAccessIterator begin,\n-\t\t\t\t\t\t  RandomAccessIterator end,\n-\t\t\t\t\t\t  Op o, Fu& f, Red r,\n-\t\t\t\t\t\t  Result base, Result& output,\n-\t\t\t\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  for_each_template_random_access_omp_loop_static(\n+              RandomAccessIterator begin,\n+              RandomAccessIterator end,\n+              Op o, Fu& f, Red r, Result base, Result& output,\n+              typename std::iterator_traits<RandomAccessIterator>::\n+                  difference_type bound)\n   {\n-    typedef std::iterator_traits<RandomAccessIterator> traits_type;\n-    typedef typename traits_type::difference_type difference_type;\n+    typedef typename\n+        std::iterator_traits<RandomAccessIterator>::difference_type\n+        difference_type;\n \n-    thread_index_t num_threads = (get_max_threads() < (end - begin)) ? get_max_threads() : (end - begin);\n-    Result *thread_results = new Result[num_threads];\n     difference_type length = end - begin;\n+    thread_index_t num_threads =\n+        std::min<difference_type>(get_max_threads(), length);\n \n-    for (thread_index_t i = 0; i < num_threads; i++)\n+    Result *thread_results;\n+\n+#   pragma omp parallel num_threads(num_threads)\n       {\n-\tthread_results[i] = r(thread_results[i], f(o, begin+i));\n-      }\n-\n-#pragma omp parallel num_threads(num_threads)\n-    {\n-#pragma omp for schedule(static, Settings::workstealing_chunk_size)\n-      for (difference_type pos = 0; pos < length; pos++)\n-\t{\n-\t  thread_results[omp_get_thread_num()] = r(thread_results[omp_get_thread_num()], f(o, begin+pos));\n-\t}\n-    }\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            thread_results = new Result[num_threads];\n+\n+            for (thread_index_t i = 0; i < num_threads; i++)\n+              thread_results[i] = Result();\n+          }\n+\n+        thread_index_t iam = omp_get_thread_num();\n+\n+#       pragma omp for schedule(static, Settings::workstealing_chunk_size)\n+        for (difference_type pos = 0; pos < length; pos++)\n+          thread_results[iam] =\n+              r(thread_results[iam], f(o, begin+pos));\n+      } //parallel\n \n     for (thread_index_t i = 0; i < num_threads; i++)\n-      {\n-\toutput = r(output, thread_results[i]);\n-      }\n+        output = r(output, thread_results[i]);\n \n     delete [] thread_results;\n \n@@ -106,6 +117,7 @@ namespace __gnu_parallel\n \n     return o;\n   }\n+\n } // end namespace\n \n #endif"}, {"sha": "6954e74507684f603750b27a9acdf36a213ecaba", "filename": "libstdc++-v3/include/parallel/par_loop.h", "status": "modified", "additions": 56, "deletions": 45, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpar_loop.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -41,69 +41,80 @@\n \n #include <omp.h>\n #include <parallel/settings.h>\n+#include <parallel/base.h>\n \n namespace __gnu_parallel\n {\n \n-  /** @brief Embarrassingly parallel algorithm for random access\n-   * iterators, using hand-crafted parallelization by equal splitting\n-   * the work.\n-   *\n-   *  @param begin Begin iterator of element sequence.\n-   *  @param end End iterator of element sequence.\n-   *  @param o User-supplied functor (comparator, predicate, adding\n-   *  functor, ...)\n-   *  @param f Functor to \"process\" an element with op (depends on\n-   *  desired functionality, e. g. for std::for_each(), ...).\n-   *  @param r Functor to \"add\" a single result to the already\n-   *  processed elements (depends on functionality).\n-   *  @param base Base value for reduction.\n-   *  @param output Pointer to position where final result is written to\n-   *  @param bound Maximum number of elements processed (e. g. for\n-   *  std::count_n()).\n-   *  @return User-supplied functor (that may contain a part of the result).\n-   */\n-  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+/** @brief Embarrassingly parallel algorithm for random access\n+  * iterators, using hand-crafted parallelization by equal splitting\n+  * the work.\n+  *\n+  *  @param begin Begin iterator of element sequence.\n+  *  @param end End iterator of element sequence.\n+  *  @param o User-supplied functor (comparator, predicate, adding\n+  *  functor, ...)\n+  *  @param f Functor to \"process\" an element with op (depends on\n+  *  desired functionality, e. g. for std::for_each(), ...).\n+  *  @param r Functor to \"add\" a single result to the already\n+  *  processed elements (depends on functionality).\n+  *  @param base Base value for reduction.\n+  *  @param output Pointer to position where final result is written to\n+  *  @param bound Maximum number of elements processed (e. g. for\n+  *  std::count_n()).\n+  *  @return User-supplied functor (that may contain a part of the result).\n+  */\n+template<\n+    typename RandomAccessIterator,\n+    typename Op,\n+    typename Fu,\n+    typename Red,\n+    typename Result>\n   Op\n-  for_each_template_random_access_ed(RandomAccessIterator begin,\n-\t\t\t\t     RandomAccessIterator end, Op o, Fu& f,\n-\t\t\t\t     Red r, Result base, Result& output,\n-\t\t\t\t     typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  for_each_template_random_access_ed(\n+              RandomAccessIterator begin,\n+              RandomAccessIterator end,\n+              Op o, Fu& f, Red r, Result base, Result& output,\n+              typename std::iterator_traits<RandomAccessIterator>::\n+                  difference_type bound)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     const difference_type length = end - begin;\n-    const difference_type settings_threads = static_cast<difference_type>(get_max_threads());\n-    const difference_type dmin = settings_threads < length ? settings_threads : length;\n-    const difference_type dmax = dmin > 1 ? dmin : 1;\n+    Result *thread_results;\n \n-    thread_index_t num_threads = static_cast<thread_index_t>(dmax);\n+    thread_index_t num_threads =\n+        __gnu_parallel::min<difference_type>(get_max_threads(), length);\n \n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            thread_results = new Result[num_threads];\n+          }\n \n-    Result *thread_results = new Result[num_threads];\n+        thread_index_t iam = omp_get_thread_num();\n \n-#pragma omp parallel num_threads(num_threads)\n-    {\n-      // Neutral element.\n-      Result reduct = Result();\n+        // Neutral element.\n+        Result reduct = Result();\n \n-      thread_index_t p = num_threads;\n-      thread_index_t iam = omp_get_thread_num();\n-      difference_type start = iam * length / p;\n-      difference_type limit = (iam == p - 1) ? length : (iam + 1) * length / p;\n+        difference_type\n+            start = equally_split_point(length, num_threads, iam),\n+            stop = equally_split_point(length, num_threads, iam + 1);\n \n-      if (start < limit)\n-\t{\n-\t  reduct = f(o, begin + start);\n-\t  start++;\n-\t}\n+        if (start < stop)\n+          {\n+            reduct = f(o, begin + start);\n+            ++start;\n+          }\n \n-      for (; start < limit; start++)\n-\treduct = r(reduct, f(o, begin + start));\n+        for (; start < stop; ++start)\n+          reduct = r(reduct, f(o, begin + start));\n \n-      thread_results[iam] = reduct;\n-    }\n+        thread_results[iam] = reduct;\n+      } //parallel\n \n     for (thread_index_t i = 0; i < num_threads; i++)\n       output = r(output, thread_results[i]);"}, {"sha": "3dfce86e018835afbdbf716623788abc3e4754b3", "filename": "libstdc++-v3/include/parallel/partial_sum.h", "status": "modified", "additions": 125, "deletions": 102, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartial_sum.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -48,149 +48,172 @@ namespace __gnu_parallel\n {\n   // Problem: there is no 0-element given.\n \n-  /** @brief Base case prefix sum routine.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param result Begin iterator of output sequence.\n-   *  @param bin_op Associative binary function.\n-   *  @param value Start value. Must be passed since the neutral\n-   *  element is unknown in general.\n-   *  @return End iterator of output sequence. */\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+/** @brief Base case prefix sum routine.\n+  *  @param begin Begin iterator of input sequence.\n+  *  @param end End iterator of input sequence.\n+  *  @param result Begin iterator of output sequence.\n+  *  @param bin_op Associative binary function.\n+  *  @param value Start value. Must be passed since the neutral\n+  *  element is unknown in general.\n+  *  @return End iterator of output sequence. */\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename BinaryOperation>\n   inline OutputIterator\n-  parallel_partial_sum_basecase(InputIterator begin, InputIterator end,\n-\t\t\t\tOutputIterator result, BinaryOperation bin_op,\n-\t\t\t\ttypename std::iterator_traits<InputIterator>::value_type value)\n+  parallel_partial_sum_basecase(\n+            InputIterator begin, InputIterator end,\n+            OutputIterator result, BinaryOperation bin_op,\n+            typename std::iterator_traits<InputIterator>::value_type value)\n   {\n     if (begin == end)\n       return result;\n \n     while (begin != end)\n       {\n-\tvalue = bin_op(value, *begin);\n-\t*result = value;\n-\tresult++;\n-\tbegin++;\n+        value = bin_op(value, *begin);\n+        *result = value;\n+        result++;\n+        begin++;\n       }\n     return result;\n   }\n \n-  /** @brief Parallel partial sum implementation, two-phase approach,\n-      no recursion.\n-      *  @param begin Begin iterator of input sequence.\n-      *  @param end End iterator of input sequence.\n-      *  @param result Begin iterator of output sequence.\n-      *  @param bin_op Associative binary function.\n-      *  @param n Length of sequence.\n-      *  @param num_threads Number of threads to use.\n-      *  @return End iterator of output sequence.\n-      */\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+/** @brief Parallel partial sum implementation, two-phase approach,\n+    no recursion.\n+    *  @param begin Begin iterator of input sequence.\n+    *  @param end End iterator of input sequence.\n+    *  @param result Begin iterator of output sequence.\n+    *  @param bin_op Associative binary function.\n+    *  @param n Length of sequence.\n+    *  @param num_threads Number of threads to use.\n+    *  @return End iterator of output sequence.\n+    */\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename BinaryOperation>\n   OutputIterator\n-  parallel_partial_sum_linear(InputIterator begin, InputIterator end,\n-\t\t\t      OutputIterator result, BinaryOperation bin_op,\n-\t\t\t      typename std::iterator_traits<InputIterator>::difference_type n, int num_threads)\n+  parallel_partial_sum_linear(\n+            InputIterator begin, InputIterator end,\n+            OutputIterator result, BinaryOperation bin_op,\n+            typename std::iterator_traits<InputIterator>::difference_type n)\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    if (num_threads > (n - 1))\n-      num_threads = static_cast<thread_index_t>(n - 1);\n+    thread_index_t num_threads =\n+        std::min<difference_type>(get_max_threads(), n - 1);\n+\n     if (num_threads < 2)\n       {\n-\t*result = *begin;\n-\treturn parallel_partial_sum_basecase(begin + 1, end, result + 1, bin_op, *begin);\n+        *result = *begin;\n+        return parallel_partial_sum_basecase(\n+            begin + 1, end, result + 1, bin_op, *begin);\n       }\n \n-    difference_type* borders = static_cast<difference_type*>(__builtin_alloca(sizeof(difference_type) * (num_threads + 2)));\n+    difference_type* borders;\n+    value_type* sums;\n \n-    if (Settings::partial_sum_dilatation == 1.0f)\n-      equally_split(n, num_threads + 1, borders);\n-    else\n+#   pragma omp parallel num_threads(num_threads)\n       {\n-\tdifference_type chunk_length = (int)((double)n / ((double)num_threads + Settings::partial_sum_dilatation)), borderstart = n - num_threads * chunk_length;\n-\tborders[0] = 0;\n-\tfor (int i = 1; i < (num_threads + 1); i++)\n-\t  {\n-\t    borders[i] = borderstart;\n-\t    borderstart += chunk_length;\n-\t  }\n-\tborders[num_threads + 1] = n;\n-      }\n-\n-    value_type* sums = static_cast<value_type*>(::operator new(sizeof(value_type) * num_threads));\n-    OutputIterator target_end;\n-\n-#pragma omp parallel num_threads(num_threads)\n-    {\n-      int id = omp_get_thread_num();\n-      if (id == 0)\n-\t{\n-\t  *result = *begin;\n-\t  parallel_partial_sum_basecase(begin + 1, begin + borders[1], \n-\t\t\t\t\tresult + 1, bin_op, *begin);\n-\t  sums[0] = *(result + borders[1] - 1);\n-\t}\n-      else\n-\t{\n-\t  sums[id] = std::accumulate(begin + borders[id] + 1, \n-\t\t\t\t     begin + borders[id + 1], \n-\t\t\t\t     *(begin + borders[id]), \n-\t\t\t\t     bin_op, __gnu_parallel::sequential_tag());\n-\t}\n-\n-#pragma omp barrier\n-\n-#pragma omp single\n-      parallel_partial_sum_basecase(sums + 1, sums + num_threads, sums + 1, \n-\t\t\t\t    bin_op, sums[0]);\n-\n-#pragma omp barrier\n-\n-      // Still same team.\n-      parallel_partial_sum_basecase(begin + borders[id + 1], \n-\t\t\t\t    begin + borders[id + 2], \n-\t\t\t\t    result + borders[id + 1], bin_op, \n-\t\t\t\t    sums[id]);\n-    }\n-\n-    delete [] sums;\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+\n+            borders = new difference_type[num_threads + 2];\n+\n+            if (Settings::partial_sum_dilatation == 1.0f)\n+              equally_split(n, num_threads + 1, borders);\n+            else\n+              {\n+                difference_type chunk_length =\n+                    ((double)n /\n+                    ((double)num_threads + Settings::partial_sum_dilatation)),\n+                    borderstart = n - num_threads * chunk_length;\n+                borders[0] = 0;\n+                for (int i = 1; i < (num_threads + 1); i++)\n+                  {\n+                    borders[i] = borderstart;\n+                    borderstart += chunk_length;\n+                  }\n+                borders[num_threads + 1] = n;\n+              }\n+\n+            sums = static_cast<value_type*>(\n+                ::operator new(sizeof(value_type) * num_threads));\n+            OutputIterator target_end;\n+          } //single\n+\n+        int iam = omp_get_thread_num();\n+        if (iam == 0)\n+          {\n+            *result = *begin;\n+            parallel_partial_sum_basecase(begin + 1, begin + borders[1],\n+                          result + 1, bin_op, *begin);\n+            sums[0] = *(result + borders[1] - 1);\n+          }\n+        else\n+          {\n+            sums[iam] = std::accumulate(begin + borders[iam] + 1,\n+                            begin + borders[iam + 1],\n+                            *(begin + borders[iam]),\n+                            bin_op, __gnu_parallel::sequential_tag());\n+          }\n+\n+#       pragma omp barrier\n+\n+#       pragma omp single\n+          parallel_partial_sum_basecase(\n+              sums + 1, sums + num_threads, sums + 1, bin_op, sums[0]);\n+\n+#       pragma omp barrier\n+\n+        // Still same team.\n+        parallel_partial_sum_basecase(begin + borders[iam + 1],\n+                      begin + borders[iam + 2],\n+                      result + borders[iam + 1], bin_op,\n+                      sums[iam]);\n+      } //parallel\n+\n+    delete[] sums;\n+    delete[] borders;\n \n     return result + n;\n   }\n \n-  /** @brief Parallel partial sum front-end.\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param end End iterator of input sequence.\n-   *  @param result Begin iterator of output sequence.\n-   *  @param bin_op Associative binary function.\n-   *  @return End iterator of output sequence. */\n-  template<typename InputIterator, typename OutputIterator, typename BinaryOperation>\n+/** @brief Parallel partial sum front-end.\n+  *  @param begin Begin iterator of input sequence.\n+  *  @param end End iterator of input sequence.\n+  *  @param result Begin iterator of output sequence.\n+  *  @param bin_op Associative binary function.\n+  *  @return End iterator of output sequence. */\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename BinaryOperation>\n   OutputIterator\n   parallel_partial_sum(InputIterator begin, InputIterator end,\n-\t\t       OutputIterator result, BinaryOperation bin_op)\n+                       OutputIterator result, BinaryOperation bin_op)\n   {\n-    _GLIBCXX_CALL(begin - end);\n+    _GLIBCXX_CALL(begin - end)\n \n     typedef std::iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     difference_type n = end - begin;\n \n-    int num_threads = get_max_threads();\n-\n     switch (Settings::partial_sum_algorithm)\n       {\n       case Settings::LINEAR:\n-\t// Need an initial offset.\n-\treturn parallel_partial_sum_linear(begin, end, result, bin_op,\n-\t\t\t\t\t   n, num_threads);\n+        // Need an initial offset.\n+        return parallel_partial_sum_linear(begin, end, result, bin_op, n);\n       default:\n-\t// Partial_sum algorithm not implemented.\n-\t_GLIBCXX_PARALLEL_ASSERT(0);\n-\treturn result + n;\n+    // Partial_sum algorithm not implemented.\n+        _GLIBCXX_PARALLEL_ASSERT(0);\n+        return result + n;\n       }\n   }\n }"}, {"sha": "d6dac37d7c8633e70166a474f6ae81e21e9d6838", "filename": "libstdc++-v3/include/parallel/partition.h", "status": "modified", "additions": 273, "deletions": 247, "changes": 520, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fpartition.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -45,21 +45,21 @@\n #include <bits/stl_algo.h>\n #include <parallel/parallel.h>\n \n-/** @brief Decide whether to declare certain variable volatile in this file. */\n+/** @brief Decide whether to declare certain variables volatile. */\n #define _GLIBCXX_VOLATILE volatile\n \n namespace __gnu_parallel\n {\n-  /** @brief Parallel implementation of std::partition.\n-   *  @param begin Begin iterator of input sequence to split.\n-   *  @param end End iterator of input sequence to split.\n-   *  @param pred Partition predicate, possibly including some kind of pivot.\n-   *  @param max_num_threads Maximum number of threads to use for this task.\n-   *  @return Number of elements not fulfilling the predicate. */\n-  template<typename RandomAccessIterator, typename Predicate>\n-  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n+/** @brief Parallel implementation of std::partition.\n+  *  @param begin Begin iterator of input sequence to split.\n+  *  @param end End iterator of input sequence to split.\n+  *  @param pred Partition predicate, possibly including some kind of pivot.\n+  *  @param num_threads Maximum number of threads to use for this task.\n+  *  @return Number of elements not fulfilling the predicate. */\n+template<typename RandomAccessIterator, typename Predicate>\n+  typename std::iterator_traits<RandomAccessIterator>::difference_type\n   parallel_partition(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t     Predicate pred, thread_index_t max_num_threads)\n+                     Predicate pred, thread_index_t num_threads)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -74,212 +74,238 @@ namespace __gnu_parallel\n     _GLIBCXX_VOLATILE difference_type leftover_left, leftover_right;\n     _GLIBCXX_VOLATILE difference_type leftnew, rightnew;\n \n-    bool* reserved_left, * reserved_right;\n-\n-    reserved_left = new bool[max_num_threads];\n-    reserved_right = new bool[max_num_threads];\n+    bool* reserved_left = NULL, * reserved_right = NULL;\n \n     difference_type chunk_size;\n-    if (Settings::partition_chunk_share > 0.0)\n-      chunk_size = std::max((difference_type)Settings::partition_chunk_size, (difference_type)((double)n * Settings::partition_chunk_share / (double)max_num_threads));\n-    else\n-      chunk_size = Settings::partition_chunk_size;\n \n     omp_lock_t result_lock;\n     omp_init_lock(&result_lock);\n \n-    // At least good for two processors.\n-    while (right - left + 1 >= 2 * max_num_threads * chunk_size)\n+    //at least two chunks per thread\n+    if(right - left + 1 >= 2 * num_threads * chunk_size)\n+#   pragma omp parallel num_threads(num_threads)\n       {\n-\tdifference_type num_chunks = (right - left + 1) / chunk_size;\n-\tthread_index_t num_threads = (int)std::min((difference_type)max_num_threads, num_chunks / 2);\n-\n-\tfor (int r = 0; r < num_threads; r++)\n-\t  {\n-\t    reserved_left[r] = false;\n-\t    reserved_right[r] = false;\n-\t  }\n-\tleftover_left = 0;\n-\tleftover_right = 0;\n-\n-#pragma omp parallel num_threads(num_threads)\n-\t{\n-\t  // Private.\n-\t  difference_type thread_left, thread_left_border, thread_right, thread_right_border;\n-\t  thread_left = left + 1;\n-\n-\t  // Just to satisfy the condition below.\n-\t  thread_left_border = thread_left - 1;\n-\t  thread_right = n - 1;\n-\t  thread_right_border = thread_right + 1;\n-\n-\t  bool iam_finished = false;\n-\t  while (!iam_finished)\n-\t    {\n-\t      if (thread_left > thread_left_border)\n-\t\t{\n-                  omp_set_lock(&result_lock);\n-\t\t  if (left + (chunk_size - 1) > right)\n-\t\t    iam_finished = true;\n-\t\t  else\n-\t\t    {\n-\t\t      thread_left = left;\n-\t\t      thread_left_border = left + (chunk_size - 1);\n-\t\t      left += chunk_size;\n-\t\t    }\n-                  omp_unset_lock(&result_lock);\n-\t\t}\n-\n-\t      if (thread_right < thread_right_border)\n-\t\t{\n-                  omp_set_lock(&result_lock);\n-\t\t  if (left > right - (chunk_size - 1))\n-\t\t    iam_finished = true;\n-\t\t  else\n-\t\t    {\n-\t\t      thread_right = right;\n-\t\t      thread_right_border = right - (chunk_size - 1);\n-\t\t      right -= chunk_size;\n-\t\t    }\n-                  omp_unset_lock(&result_lock);\n-\t\t}\n-\n-\t      if (iam_finished)\n-\t\tbreak;\n-\n-\t      // Swap as usual.\n-\t      while (thread_left < thread_right)\n-\t\t{\n-\t\t  while (pred(begin[thread_left]) && thread_left <= thread_left_border)\n-\t\t    thread_left++;\n-\t\t  while (!pred(begin[thread_right]) && thread_right >= thread_right_border)\n-\t\t    thread_right--;\n-\n-\t\t  if (thread_left > thread_left_border || thread_right < thread_right_border)\n-\t\t    // Fetch new chunk(s).\n-\t\t    break;\n-\n-\t\t  std::swap(begin[thread_left], begin[thread_right]);\n-\t\t  thread_left++;\n-\t\t  thread_right--;\n-\t\t}\n-\t    }\n-\n-\t  // Now swap the leftover chunks to the right places.\n-\t  if (thread_left <= thread_left_border)\n-#pragma omp atomic\n-\t    leftover_left++;\n-\t  if (thread_right >= thread_right_border)\n-#pragma omp atomic\n-\t    leftover_right++;\n-\n-#pragma omp barrier\n-\n-#pragma omp single\n-\t  {\n-\t    leftnew = left - leftover_left * chunk_size;\n-\t    rightnew = right + leftover_right * chunk_size;\n-\t  }\n-\n-#pragma omp barrier\n-\n-\t  // <=> thread_left_border + (chunk_size - 1) >= leftnew\n-\t  if (thread_left <= thread_left_border\n-\t      && thread_left_border >= leftnew)\n-\t    {\n-\t      // Chunk already in place, reserve spot.\n-\t      reserved_left[(left - (thread_left_border + 1)) / chunk_size] = true;\n-\t    }\n-\n-\t  // <=> thread_right_border - (chunk_size - 1) <= rightnew\n-\t  if (thread_right >= thread_right_border\n-\t      && thread_right_border <= rightnew)\n-\t    {\n-\t      // Chunk already in place, reserve spot.\n-\t      reserved_right[((thread_right_border - 1) - right) / chunk_size] = true;\n-\t    }\n-\n-#pragma omp barrier\n-\n-\t  if (thread_left <= thread_left_border && thread_left_border < leftnew)\n-\t    {\n-\t      // Find spot and swap.\n-\t      difference_type swapstart = -1;\n-              omp_set_lock(&result_lock);\n-\t      for (int r = 0; r < leftover_left; r++)\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            reserved_left = new bool[num_threads];\n+            reserved_right = new bool[num_threads];\n+\n+            if (Settings::partition_chunk_share > 0.0)\n+              chunk_size = std::max<difference_type>(\n+                  Settings::partition_chunk_size,\n+                  (double)n * Settings::partition_chunk_share /\n+                        (double)num_threads);\n+            else\n+              chunk_size = Settings::partition_chunk_size;\n+          }\n+\n+        while (right - left + 1 >= 2 * num_threads * chunk_size)\n+          {\n+#           pragma omp single\n+              {\n+                difference_type num_chunks = (right - left + 1) / chunk_size;\n+\n+                for (int r = 0; r < num_threads; r++)\n+                  {\n+                    reserved_left[r] = false;\n+                    reserved_right[r] = false;\n+                  }\n+                leftover_left = 0;\n+                leftover_right = 0;\n+              } //implicit barrier\n+\n+            // Private.\n+            difference_type thread_left, thread_left_border,\n+                            thread_right, thread_right_border;\n+            thread_left = left + 1;\n+\n+            // Just to satisfy the condition below.\n+            thread_left_border = thread_left - 1;\n+            thread_right = n - 1;\n+            thread_right_border = thread_right + 1;\n+\n+            bool iam_finished = false;\n+            while (!iam_finished)\n+              {\n+                if (thread_left > thread_left_border)\n+                  {\n+                    omp_set_lock(&result_lock);\n+                    if (left + (chunk_size - 1) > right)\n+                      iam_finished = true;\n+                    else\n+                      {\n+                        thread_left = left;\n+                        thread_left_border = left + (chunk_size - 1);\n+                        left += chunk_size;\n+                      }\n+                    omp_unset_lock(&result_lock);\n+                  }\n+\n+                if (thread_right < thread_right_border)\n+                  {\n+                    omp_set_lock(&result_lock);\n+                    if (left > right - (chunk_size - 1))\n+                      iam_finished = true;\n+                    else\n+                      {\n+                        thread_right = right;\n+                        thread_right_border = right - (chunk_size - 1);\n+                        right -= chunk_size;\n+                      }\n+                    omp_unset_lock(&result_lock);\n+                  }\n+\n+                if (iam_finished)\n+                  break;\n+\n+                // Swap as usual.\n+                while (thread_left < thread_right)\n+                  {\n+                    while (pred(begin[thread_left])\n+                            && thread_left <= thread_left_border)\n+                      thread_left++;\n+                    while (!pred(begin[thread_right])\n+                            && thread_right >= thread_right_border)\n+                      thread_right--;\n+\n+                    if (thread_left > thread_left_border\n+                        || thread_right < thread_right_border)\n+                      // Fetch new chunk(s).\n+                      break;\n+\n+                    std::swap(begin[thread_left], begin[thread_right]);\n+                    thread_left++;\n+                    thread_right--;\n+                  }\n+              }\n+\n+            // Now swap the leftover chunks to the right places.\n+            if (thread_left <= thread_left_border)\n+#             pragma omp atomic\n+              leftover_left++;\n+            if (thread_right >= thread_right_border)\n+#             pragma omp atomic\n+              leftover_right++;\n+\n+#           pragma omp barrier\n+\n+#           pragma omp single\n+              {\n+                leftnew = left - leftover_left * chunk_size;\n+                rightnew = right + leftover_right * chunk_size;\n+              }\n+\n+#           pragma omp barrier\n+\n+            // <=> thread_left_border + (chunk_size - 1) >= leftnew\n+            if (thread_left <= thread_left_border\n+                && thread_left_border >= leftnew)\n+              {\n+                // Chunk already in place, reserve spot.\n+                reserved_left[(left - (thread_left_border + 1)) / chunk_size]\n+                    = true;\n+              }\n+\n+            // <=> thread_right_border - (chunk_size - 1) <= rightnew\n+            if (thread_right >= thread_right_border\n+                && thread_right_border <= rightnew)\n+              {\n+                // Chunk already in place, reserve spot.\n+                reserved_right\n+                    [((thread_right_border - 1) - right) / chunk_size]\n+                    = true;\n+              }\n+\n+#           pragma omp barrier\n+\n+            if (thread_left <= thread_left_border\n+                && thread_left_border < leftnew)\n+              {\n+                // Find spot and swap.\n+                difference_type swapstart = -1;\n+                omp_set_lock(&result_lock);\n+                for (int r = 0; r < leftover_left; r++)\n                   if (!reserved_left[r])\n                     {\n                       reserved_left[r] = true;\n                       swapstart = left - (r + 1) * chunk_size;\n                       break;\n                     }\n-              omp_unset_lock(&result_lock);\n+                omp_unset_lock(&result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-\t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+                _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n #endif\n \n-\t      std::swap_ranges(begin + thread_left_border - (chunk_size - 1), begin + thread_left_border + 1, begin + swapstart);\n-\t    }\n-\n-\t  if (thread_right >= thread_right_border\n-\t      && thread_right_border > rightnew)\n-\t    {\n-\t      // Find spot and swap\n-\t      difference_type swapstart = -1;\n-              omp_set_lock(&result_lock);\n-\t      for (int r = 0; r < leftover_right; r++)\n-\t\t  if (!reserved_right[r])\n-\t\t    {\n-\t\t      reserved_right[r] = true;\n-\t\t      swapstart = right + r * chunk_size + 1;\n-\t\t      break;\n-\t\t    }\n-              omp_unset_lock(&result_lock);\n+                std::swap_ranges(\n+                    begin + thread_left_border - (chunk_size - 1),\n+                    begin + thread_left_border + 1,\n+                    begin + swapstart);\n+              }\n+\n+            if (thread_right >= thread_right_border\n+                && thread_right_border > rightnew)\n+              {\n+                // Find spot and swap\n+                difference_type swapstart = -1;\n+                omp_set_lock(&result_lock);\n+                for (int r = 0; r < leftover_right; r++)\n+                  if (!reserved_right[r])\n+                    {\n+                      reserved_right[r] = true;\n+                      swapstart = right + r * chunk_size + 1;\n+                      break;\n+                    }\n+                omp_unset_lock(&result_lock);\n \n #if _GLIBCXX_ASSERTIONS\n-\t      _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n+                _GLIBCXX_PARALLEL_ASSERT(swapstart != -1);\n #endif\n \n-\t      std::swap_ranges(begin + thread_right_border, begin + thread_right_border + chunk_size, begin + swapstart);\n-\t    }\n+                std::swap_ranges(begin + thread_right_border,\n+                                begin + thread_right_border + chunk_size,\n+                                begin + swapstart);\n+              }\n #if _GLIBCXX_ASSERTIONS\n-#pragma omp barrier\n+#             pragma omp barrier\n \n-#pragma omp single\n-\t  {\n-\t    for (int r = 0; r < leftover_left; r++)\n-\t      _GLIBCXX_PARALLEL_ASSERT(reserved_left[r]);\n-\t    for (int r = 0; r < leftover_right; r++)\n-\t      _GLIBCXX_PARALLEL_ASSERT(reserved_right[r]);\n-\t  }\n+#             pragma omp single\n+                {\n+                  for (int r = 0; r < leftover_left; r++)\n+                    _GLIBCXX_PARALLEL_ASSERT(reserved_left[r]);\n+                  for (int r = 0; r < leftover_right; r++)\n+                    _GLIBCXX_PARALLEL_ASSERT(reserved_right[r]);\n+                }\n \n-#pragma omp barrier\n+#             pragma omp barrier\n #endif\n \n-#pragma omp barrier\n-\t  left = leftnew;\n-\t  right = rightnew;\n-\t}\n-      }\t// end \"recursion\"\n+#             pragma omp barrier\n+\n+              left = leftnew;\n+              right = rightnew;\n+          }\n+#         pragma omp flush(left, right)\n+      } // end \"recursion\" //parallel\n \n     difference_type final_left = left, final_right = right;\n \n     while (final_left < final_right)\n       {\n-\t// Go right until key is geq than pivot.\n-\twhile (pred(begin[final_left]) && final_left < final_right)\n-\t  final_left++;\n-\n-\t// Go left until key is less than pivot.\n-\twhile (!pred(begin[final_right]) && final_left < final_right)\n-\t  final_right--;\n-\n-\tif (final_left == final_right)\n-\t  break;\n-\tstd::swap(begin[final_left], begin[final_right]);\n-\tfinal_left++;\n-\tfinal_right--;\n+        // Go right until key is geq than pivot.\n+        while (pred(begin[final_left]) && final_left < final_right)\n+          final_left++;\n+\n+        // Go left until key is less than pivot.\n+        while (!pred(begin[final_right]) && final_left < final_right)\n+          final_right--;\n+\n+        if (final_left == final_right)\n+          break;\n+        std::swap(begin[final_left], begin[final_right]);\n+        final_left++;\n+        final_right--;\n       }\n \n     // All elements on the left side are < piv, all elements on the\n@@ -298,14 +324,14 @@ namespace __gnu_parallel\n       return final_left + 1;\n   }\n \n-  /** \n-   *  @brief Parallel implementation of std::nth_element().\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param nth Iterator of element that must be in position afterwards.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator. \n-   */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/**\n+  *  @brief Parallel implementation of std::nth_element().\n+  *  @param begin Begin iterator of input sequence.\n+  *  @param nth Iterator of element that must be in position afterwards.\n+  *  @param end End iterator of input sequence.\n+  *  @param comp Comparator.\n+  */\n+template<typename RandomAccessIterator, typename Comparator>\n   void \n   parallel_nth_element(RandomAccessIterator begin, RandomAccessIterator nth, \n \t\t       RandomAccessIterator end, Comparator comp)\n@@ -324,73 +350,73 @@ namespace __gnu_parallel\n     // Break if input range to small.\n     while (static_cast<sequence_index_t>(end - begin) >= minimum_length)\n       {\n-\tdifference_type n = end - begin;\n-\n-\tRandomAccessIterator pivot_pos = begin +  rng(n);\n-\n-\t// Swap pivot_pos value to end.\n-\tif (pivot_pos != (end - 1))\n-\t  std::swap(*pivot_pos, *(end - 1));\n-\tpivot_pos = end - 1;\n-\n-\t// XXX Comparator must have first_value_type, second_value_type, result_type\n-\t// Comparator == __gnu_parallel::lexicographic<S, int, __gnu_parallel::less<S, S> > \n-\t// pivot_pos == std::pair<S, int>*\n-\t// XXX binder2nd only for RandomAccessIterators??\n-\t__gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n-\n-\t// Divide, leave pivot unchanged in last place.\n-\tRandomAccessIterator split_pos1, split_pos2;\n-\tsplit_pos1 = begin + parallel_partition(begin, end - 1, pred, get_max_threads());\n-\n-\t// Left side: < pivot_pos; right side: >= pivot_pos\n-\n-\t// Swap pivot back to middle.\n-\tif (split_pos1 != pivot_pos)\n-\t  std::swap(*split_pos1, *pivot_pos);\n-\tpivot_pos = split_pos1;\n-\n-\t// In case all elements are equal, split_pos1 == 0\n-\tif ((split_pos1 + 1 - begin) < (n >> 7) || (end - split_pos1) < (n >> 7))\n-\t  {\n-\t    // Very unequal split, one part smaller than one 128th\n-\t    // elements not stricly larger than the pivot.\n-\t    __gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n-\n-\t    // Find other end of pivot-equal range.\n-\t    split_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n-\t  }\n-\telse\n-\t  // Only skip the pivot.\n-\t  split_pos2 = split_pos1 + 1;\n-\n-\t// Compare iterators.\n-\tif (split_pos2 <= nth)\n-\t  begin = split_pos2;\n-\telse if (nth < split_pos1)\n-\t  end = split_pos1;\n-\telse\n-\t  break;\n+        difference_type n = end - begin;\n+\n+        RandomAccessIterator pivot_pos = begin +  rng(n);\n+\n+        // Swap pivot_pos value to end.\n+        if (pivot_pos != (end - 1))\n+          std::swap(*pivot_pos, *(end - 1));\n+        pivot_pos = end - 1;\n+\n+        // XXX Comparator must have first_value_type, second_value_type, result_type\n+        // Comparator == __gnu_parallel::lexicographic<S, int, __gnu_parallel::less<S, S> >\n+        // pivot_pos == std::pair<S, int>*\n+        // XXX binder2nd only for RandomAccessIterators??\n+        __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, *pivot_pos);\n+\n+        // Divide, leave pivot unchanged in last place.\n+        RandomAccessIterator split_pos1, split_pos2;\n+        split_pos1 = begin + parallel_partition(begin, end - 1, pred, get_max_threads());\n+\n+        // Left side: < pivot_pos; right side: >= pivot_pos\n+\n+        // Swap pivot back to middle.\n+        if (split_pos1 != pivot_pos)\n+          std::swap(*split_pos1, *pivot_pos);\n+        pivot_pos = split_pos1;\n+\n+        // In case all elements are equal, split_pos1 == 0\n+        if ((split_pos1 + 1 - begin) < (n >> 7) || (end - split_pos1) < (n >> 7))\n+          {\n+            // Very unequal split, one part smaller than one 128th\n+            // elements not stricly larger than the pivot.\n+            __gnu_parallel::unary_negate<__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>, value_type> pred(__gnu_parallel::binder1st<Comparator, value_type, value_type, bool>(comp, *pivot_pos));\n+\n+            // Find other end of pivot-equal range.\n+            split_pos2 = __gnu_sequential::partition(split_pos1 + 1, end, pred);\n+          }\n+        else\n+          // Only skip the pivot.\n+          split_pos2 = split_pos1 + 1;\n+\n+        // Compare iterators.\n+        if (split_pos2 <= nth)\n+          begin = split_pos2;\n+        else if (nth < split_pos1)\n+          end = split_pos1;\n+        else\n+          break;\n       }\n \n     // Only at most Settings::partition_minimal_n elements left.\n     __gnu_sequential::sort(begin, end, comp);\n   }\n \n-  /** @brief Parallel implementation of std::partial_sort().\n-   *  @param begin Begin iterator of input sequence.\n-   *  @param middle Sort until this position.\n-   *  @param end End iterator of input sequence.\n-   *  @param comp Comparator. */\n-  template<typename RandomAccessIterator, typename Comparator>\n+/** @brief Parallel implementation of std::partial_sort().\n+*  @param begin Begin iterator of input sequence.\n+*  @param middle Sort until this position.\n+*  @param end End iterator of input sequence.\n+*  @param comp Comparator. */\n+template<typename RandomAccessIterator, typename Comparator>\n   void\n   parallel_partial_sort(RandomAccessIterator begin, RandomAccessIterator middle, RandomAccessIterator end, Comparator comp)\n   {\n     parallel_nth_element(begin, middle, end, comp);\n     std::sort(begin, middle, comp);\n   }\n \n-}\t//namespace __gnu_parallel\n+} //namespace __gnu_parallel\n \n #undef _GLIBCXX_VOLATILE\n "}, {"sha": "4eb357818cfb71f467dcb60a690a102a9d35ba4f", "filename": "libstdc++-v3/include/parallel/quicksort.h", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fquicksort.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -53,32 +53,42 @@ namespace __gnu_parallel\n    *  this part.\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n-  inline typename std::iterator_traits<RandomAccessIterator>::difference_type\n-  parallel_sort_qs_divide(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t\t  Comparator comp,\n-\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type pivot_rank,\n-\t\t\t  typename std::iterator_traits<RandomAccessIterator>::difference_type num_samples, thread_index_t num_threads)\n+  inline\n+  typename std::iterator_traits<RandomAccessIterator>::difference_type\n+  parallel_sort_qs_divide(\n+      RandomAccessIterator begin,\n+      RandomAccessIterator end,\n+      Comparator comp,\n+      typename std::iterator_traits<RandomAccessIterator>::difference_type\n+          pivot_rank,\n+      typename std::iterator_traits<RandomAccessIterator>::difference_type\n+          num_samples,\n+      thread_index_t num_threads)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     difference_type n = end - begin;\n     num_samples = std::min(num_samples, n);\n-    value_type* samples = static_cast<value_type*>(__builtin_alloca(sizeof(value_type) * num_samples));\n+\n+    // Allocate uninitialized, to avoid default constructor.\n+    value_type* samples = static_cast<value_type*>(\n+        operator new(num_samples * sizeof(value_type)));\n \n     for (difference_type s = 0; s < num_samples; s++)\n       {\n-\tconst unsigned long long index = static_cast<unsigned long long>(s) \n-\t  \t\t\t\t * n / num_samples;\n-\tsamples[s] = begin[index];\n+        const unsigned long long index = static_cast<unsigned long long>(s)\n+                        * n / num_samples;\n+        new(samples + s) value_type(begin[index]);\n       }\n \n     __gnu_sequential::sort(samples, samples + num_samples, comp);\n \n     value_type& pivot = samples[pivot_rank * num_samples / n];\n \n-    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool> pred(comp, pivot);\n+    __gnu_parallel::binder2nd<Comparator, value_type, value_type, bool>\n+        pred(comp, pivot);\n     difference_type split = parallel_partition(begin, end, pred, num_threads);\n \n     return split;\n@@ -93,41 +103,47 @@ namespace __gnu_parallel\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  parallel_sort_qs_conquer(RandomAccessIterator begin, RandomAccessIterator end, Comparator comp, int num_threads)\n+  parallel_sort_qs_conquer(RandomAccessIterator begin,\n+                           RandomAccessIterator end,\n+                           Comparator comp,\n+                           thread_index_t num_threads)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n     if (num_threads <= 1)\n       {\n-\t__gnu_sequential::sort(begin, end, comp);\n-\treturn;\n+        __gnu_sequential::sort(begin, end, comp);\n+        return;\n       }\n \n     difference_type n = end - begin, pivot_rank;\n \n     if (n <= 1)\n       return;\n \n-    thread_index_t num_processors_left;\n+    thread_index_t num_threads_left;\n \n     if ((num_threads % 2) == 1)\n-      num_processors_left = num_threads / 2 + 1;\n+      num_threads_left = num_threads / 2 + 1;\n     else\n-      num_processors_left = num_threads / 2;\n+      num_threads_left = num_threads / 2;\n \n-    pivot_rank = n * num_processors_left / num_threads;\n+    pivot_rank = n * num_threads_left / num_threads;\n \n-    difference_type split = parallel_sort_qs_divide(begin, end, comp, pivot_rank,\n-Settings::sort_qs_num_samples_preset, num_threads);\n+    difference_type split = parallel_sort_qs_divide(\n+        begin, end, comp, pivot_rank,\n+        Settings::sort_qs_num_samples_preset, num_threads);\n \n #pragma omp parallel sections\n     {\n #pragma omp section\n-      parallel_sort_qs_conquer(begin, begin + split, comp, num_processors_left);\n+      parallel_sort_qs_conquer(begin, begin + split,\n+                               comp, num_threads_left);\n #pragma omp section\n-      parallel_sort_qs_conquer(begin + split, end, comp, num_threads - num_processors_left);\n+      parallel_sort_qs_conquer(begin + split, end,\n+                               comp, num_threads - num_threads_left);\n     }\n   }\n \n@@ -143,9 +159,12 @@ Settings::sort_qs_num_samples_preset, num_threads);\n    */\n   template<typename RandomAccessIterator, typename Comparator>\n   inline void\n-  parallel_sort_qs(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t   Comparator comp,\n-\t\t   typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads)\n+  parallel_sort_qs(\n+      RandomAccessIterator begin,\n+      RandomAccessIterator end,\n+      Comparator comp,\n+      typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n+      int num_threads)\n   {\n     _GLIBCXX_CALL(n)\n \n@@ -165,12 +184,9 @@ Settings::sort_qs_num_samples_preset, num_threads);\n     // Hard to avoid.\n     omp_set_num_threads(num_threads);\n \n-    bool old_nested = (omp_get_nested() != 0);\n-    omp_set_nested(true);\n     parallel_sort_qs_conquer(begin, begin + n, comp, num_threads);\n-    omp_set_nested(old_nested);\n   }\n \n-}\t//namespace __gnu_parallel\n+} //namespace __gnu_parallel\n \n #endif"}, {"sha": "d7a82fbc59e818229913cff1c9b92d64218949c5", "filename": "libstdc++-v3/include/parallel/random_shuffle.h", "status": "modified", "additions": 211, "deletions": 182, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Frandom_shuffle.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -45,16 +45,16 @@\n \n namespace __gnu_parallel\n {\n-  /** @brief Type to hold the index of a bin.\n-   *\n-   *  Since many variables of this type are allocated, it should be\n-   *  chosen as small as possible.\n-   */\n-  typedef unsigned short bin_index;\n-\n-  /** @brief Data known to every thread participating in\n-      __gnu_parallel::parallel_random_shuffle(). */\n-  template<typename RandomAccessIterator>\n+/** @brief Type to hold the index of a bin.\n+  *\n+  *  Since many variables of this type are allocated, it should be\n+  *  chosen as small as possible.\n+  */\n+typedef unsigned short bin_index;\n+\n+/** @brief Data known to every thread participating in\n+    __gnu_parallel::parallel_random_shuffle(). */\n+template<typename RandomAccessIterator>\n   struct DRandomShufflingGlobalData\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n@@ -90,18 +90,15 @@ namespace __gnu_parallel\n     : source(_source) { }\n   };\n \n-  /** @brief Local data for a thread participating in\n-      __gnu_parallel::parallel_random_shuffle().\n-   */\n-  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+/** @brief Local data for a thread participating in\n+    __gnu_parallel::parallel_random_shuffle().\n+  */\n+template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   struct DRSSorterPU\n   {\n     /** @brief Number of threads participating in total. */\n     int num_threads;\n \n-    /** @brief Number of owning thread. */\n-    int iam;\n-\n     /** @brief Begin index for bins taken care of by this thread. */\n     bin_index bins_begin;\n \n@@ -115,29 +112,29 @@ namespace __gnu_parallel\n     DRandomShufflingGlobalData<RandomAccessIterator>* sd;\n   };\n \n-  /** @brief Generate a random number in @c [0,2^logp).\n-   *  @param logp Logarithm (basis 2) of the upper range bound.\n-   *  @param rng Random number generator to use.\n-   */\n-  template<typename RandomNumberGenerator>\n+/** @brief Generate a random number in @c [0,2^logp).\n+  *  @param logp Logarithm (basis 2) of the upper range bound.\n+  *  @param rng Random number generator to use.\n+  */\n+template<typename RandomNumberGenerator>\n   inline int\n   random_number_pow2(int logp, RandomNumberGenerator& rng)\n   { return rng.genrand_bits(logp); }\n \n-  /** @brief Random shuffle code executed by each thread.\n-   *  @param pus Array of thread-local data records. */\n-  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+/** @brief Random shuffle code executed by each thread.\n+  *  @param pus Array of thread-local data records. */\n+template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void \n-  parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator, \n-\t\t\t\t RandomNumberGenerator>* pus)\n+  parallel_random_shuffle_drs_pu(DRSSorterPU<RandomAccessIterator,\n+                                 RandomNumberGenerator>* pus)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n     typedef typename traits_type::difference_type difference_type;\n \n-    DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* d = &pus[omp_get_thread_num()];\n+    thread_index_t iam = omp_get_thread_num();\n+    DRSSorterPU<RandomAccessIterator, RandomNumberGenerator>* d = &pus[iam];\n     DRandomShufflingGlobalData<RandomAccessIterator>* sd = d->sd;\n-    thread_index_t iam = d->iam;\n \n     // Indexing: dist[bin][processor]\n     difference_type length = sd->starts[iam + 1] - sd->starts[iam];\n@@ -156,35 +153,35 @@ namespace __gnu_parallel\n     // First main loop.\n     for (difference_type i = 0; i < length; i++)\n       {\n-\tbin_index oracle = random_number_pow2(num_bits, rng);\n-\toracles[i] = oracle;\n+        bin_index oracle = random_number_pow2(num_bits, rng);\n+        oracles[i] = oracle;\n \n-\t// To allow prefix (partial) sum.\n-\tdist[oracle + 1]++;\n+        // To allow prefix (partial) sum.\n+        dist[oracle + 1]++;\n       }\n \n     for (bin_index b = 0; b < sd->num_bins + 1; b++)\n       sd->dist[b][iam + 1] = dist[b];\n \n-#pragma omp barrier\n+#   pragma omp barrier\n \n-#pragma omp single\n+#   pragma omp single\n     {\n       // Sum up bins, sd->dist[s + 1][d->num_threads] now contains the\n       // total number of items in bin s\n       for (bin_index s = 0; s < sd->num_bins; s++)\n-\t__gnu_sequential::partial_sum(sd->dist[s + 1],\n-\t\t\t\t      sd->dist[s + 1] + d->num_threads + 1,\n-\t\t\t\t      sd->dist[s + 1]);\n+        __gnu_sequential::partial_sum(sd->dist[s + 1],\n+                                      sd->dist[s + 1] + d->num_threads + 1,\n+                                      sd->dist[s + 1]);\n     }\n \n-#pragma omp barrier\n+#   pragma omp barrier\n \n     sequence_index_t offset = 0, global_offset = 0;\n     for (bin_index s = 0; s < d->bins_begin; s++)\n       global_offset += sd->dist[s + 1][d->num_threads];\n \n-#pragma omp barrier\n+#   pragma omp barrier\n \n     for (bin_index s = d->bins_begin; s < d->bins_end; s++)\n       {\n@@ -193,9 +190,10 @@ namespace __gnu_parallel\n \toffset = sd->dist[s + 1][d->num_threads];\n       }\n \n-    sd->temporaries[iam] = static_cast<value_type*>(::operator new(sizeof(value_type) * offset));\n+    sd->temporaries[iam] = static_cast<value_type*>(\n+      ::operator new(sizeof(value_type) * offset));\n \n-#pragma omp barrier\n+#   pragma omp barrier\n \n     // Draw local copies to avoid false sharing.\n     for (bin_index b = 0; b < sd->num_bins + 1; b++)\n@@ -211,35 +209,39 @@ namespace __gnu_parallel\n     // Distribute according to oracles, second main loop.\n     for (difference_type i = 0; i < length; i++)\n       {\n-\tbin_index target_bin = oracles[i];\n-\tthread_index_t target_p = bin_proc[target_bin];\n+        bin_index target_bin = oracles[i];\n+        thread_index_t target_p = bin_proc[target_bin];\n \n-\t// Last column [d->num_threads] stays unchanged.\n-\ttemporaries[target_p][dist[target_bin + 1]++] = *(source + i + start);\n+        // Last column [d->num_threads] stays unchanged.\n+        temporaries[target_p][dist[target_bin + 1]++] = *(source + i + start);\n       }\n \n     delete[] oracles;\n     delete[] dist;\n     delete[] bin_proc;\n     delete[] temporaries;\n \n-#pragma omp barrier\n+#   pragma omp barrier\n \n     // Shuffle bins internally.\n     for (bin_index b = d->bins_begin; b < d->bins_end; b++)\n       {\n-\tvalue_type* begin = sd->temporaries[iam] + ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]),\n-\t  * end = sd->temporaries[iam] + sd->dist[b + 1][d->num_threads];\n-\tsequential_random_shuffle(begin, end, rng);\n-\tstd::copy(begin, end, sd->source + global_offset + ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]));\n+        value_type* begin =\n+                    sd->temporaries[iam] +\n+                    ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]),\n+                  * end =\n+                    sd->temporaries[iam] + sd->dist[b + 1][d->num_threads];\n+        sequential_random_shuffle(begin, end, rng);\n+        std::copy(begin, end, sd->source + global_offset +\n+            ((b == d->bins_begin) ? 0 : sd->dist[b][d->num_threads]));\n       }\n \n     delete[] sd->temporaries[iam];\n   }\n \n-  /** @brief Round up to the next greater power of 2.\n-   *  @param x Integer to round up */\n-  template<typename T>\n+/** @brief Round up to the next greater power of 2.\n+  *  @param x Integer to round up */\n+template<typename T>\n   T \n   round_up_to_pow2(T x)\n   {\n@@ -249,16 +251,21 @@ namespace __gnu_parallel\n       return (T)1 << (log2(x - 1) + 1);\n   }\n \n-  /** @brief Main parallel random shuffle step.\n-   *  @param begin Begin iterator of sequence.\n-   *  @param end End iterator of sequence.\n-   *  @param n Length of sequence.\n-   *  @param num_threads Number of threads to use.\n-   *  @param rng Random number generator to use.\n-   */\n-  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+/** @brief Main parallel random shuffle step.\n+  *  @param begin Begin iterator of sequence.\n+  *  @param end End iterator of sequence.\n+  *  @param n Length of sequence.\n+  *  @param num_threads Number of threads to use.\n+  *  @param rng Random number generator to use.\n+  */\n+template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n-  parallel_random_shuffle_drs(RandomAccessIterator begin, RandomAccessIterator end, typename std::iterator_traits<RandomAccessIterator>::difference_type n, int num_threads, RandomNumberGenerator& rng)\n+  parallel_random_shuffle_drs(\n+      RandomAccessIterator begin,\n+      RandomAccessIterator end,\n+      typename std::iterator_traits<RandomAccessIterator>::difference_type n,\n+      thread_index_t num_threads,\n+      RandomNumberGenerator& rng)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -275,87 +282,99 @@ namespace __gnu_parallel\n     // Try the L1 cache first.\n \n     // Must fit into L1.\n-    num_bins_cache = std::max((difference_type)1, (difference_type)(n / (Settings::L1_cache_size_lb / sizeof(value_type))));\n+    num_bins_cache = std::max<difference_type>(\n+        1, n / (Settings::L1_cache_size_lb / sizeof(value_type)));\n     num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n     // Power of 2 and at least one element per bin, at most the TLB size.\n-    num_bins = std::min(n, (difference_type)num_bins_cache);\n+    num_bins = std::min<difference_type>(n, num_bins_cache);\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n     // 2 TLB entries needed per bin.\n-    num_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+    num_bins = std::min<difference_type>(Settings::TLB_size / 2, num_bins);\n #endif\n     num_bins = round_up_to_pow2(num_bins);\n \n     if (num_bins < num_bins_cache)\n       {\n #endif\n-\t// Now try the L2 cache\n-\t// Must fit into L2\n-\tnum_bins_cache = static_cast<bin_index>(std::max((difference_type)1, (difference_type)(n / (Settings::L2_cache_size / sizeof(value_type)))));\n-\tnum_bins_cache = round_up_to_pow2(num_bins_cache);\n-\n-\t// No more buckets than TLB entries, power of 2.\n-\tnum_bins = static_cast<bin_index>(std::min(n, (difference_type)num_bins_cache));\n-\t// Power of 2 and at least one element per bin, at most the TLB size.\n+        // Now try the L2 cache\n+        // Must fit into L2\n+        num_bins_cache = static_cast<bin_index>(std::max<difference_type>(\n+            1, n / (Settings::L2_cache_size / sizeof(value_type))));\n+        num_bins_cache = round_up_to_pow2(num_bins_cache);\n+\n+        // No more buckets than TLB entries, power of 2.\n+        num_bins = static_cast<bin_index>(\n+            std::min(n, static_cast<difference_type>(num_bins_cache)));\n+        // Power of 2 and at least one element per bin, at most the TLB size.\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-\t// 2 TLB entries needed per bin.\n-\tnum_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+        // 2 TLB entries needed per bin.\n+        num_bins = std::min(\n+            static_cast<difference_type>(Settings::TLB_size / 2), num_bins);\n #endif\n-\tnum_bins = round_up_to_pow2(num_bins);\n+          num_bins = round_up_to_pow2(num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n       }\n #endif\n \n-    num_threads = std::min((bin_index)num_threads, (bin_index)num_bins);\n+    num_threads = std::min<bin_index>(num_threads, num_bins);\n \n     if (num_threads <= 1)\n       return sequential_random_shuffle(begin, end, rng);\n \n     DRandomShufflingGlobalData<RandomAccessIterator> sd(begin);\n+    DRSSorterPU<RandomAccessIterator, random_number >* pus;\n+    difference_type* starts;\n \n-    DRSSorterPU<RandomAccessIterator, random_number >* pus = new DRSSorterPU<RandomAccessIterator, random_number >[num_threads];\n-\n-    sd.temporaries = new value_type*[num_threads];\n-    //sd.oracles = new bin_index[n];\n-    sd.dist = new difference_type*[num_bins + 1];\n-    sd.bin_proc = new thread_index_t[num_bins];\n-    for (bin_index b = 0; b < num_bins + 1; b++)\n-      sd.dist[b] = new difference_type[num_threads + 1];\n-    for (bin_index b = 0; b < (num_bins + 1); b++)\n+#   pragma omp parallel num_threads(num_threads)\n       {\n-\tsd.dist[0][0] = 0;\n-\tsd.dist[b][0] = 0;\n-      }\n-    difference_type* starts = sd.starts = new difference_type[num_threads + 1];\n-    int bin_cursor = 0;\n-    sd.num_bins = num_bins;\n-    sd.num_bits = log2(num_bins);\n-\n-    difference_type chunk_length = n / num_threads, split = n % num_threads, start = 0;\n-    int bin_chunk_length = num_bins / num_threads, bin_split = num_bins % num_threads;\n-    for (int i = 0; i < num_threads; i++)\n-      {\n-\tstarts[i] = start;\n-\tstart += (i < split) ? (chunk_length + 1) : chunk_length;\n-\tint j = pus[i].bins_begin = bin_cursor;\n-\n-\t// Range of bins for this processor.\n-\tbin_cursor += (i < bin_split) ? (bin_chunk_length + 1) : bin_chunk_length;\n-\tpus[i].bins_end = bin_cursor;\n-\tfor (; j < bin_cursor; j++)\n-\t  sd.bin_proc[j] = i;\n-\tpus[i].num_threads = num_threads;\n-\tpus[i].iam = i;\n-\tpus[i].seed = rng(std::numeric_limits<uint32>::max());\n-\tpus[i].sd = &sd;\n-      }\n-    starts[num_threads] = start;\n-\n-    // Now shuffle in parallel.\n-#pragma omp parallel num_threads(num_threads)\n-    parallel_random_shuffle_drs_pu(pus);\n+#       pragma omp single\n+          {\n+            pus = new DRSSorterPU<RandomAccessIterator, random_number>\n+                [num_threads];\n+\n+            sd.temporaries = new value_type*[num_threads];\n+            sd.dist = new difference_type*[num_bins + 1];\n+            sd.bin_proc = new thread_index_t[num_bins];\n+            for (bin_index b = 0; b < num_bins + 1; b++)\n+              sd.dist[b] = new difference_type[num_threads + 1];\n+            for (bin_index b = 0; b < (num_bins + 1); b++)\n+              {\n+                sd.dist[0][0] = 0;\n+                sd.dist[b][0] = 0;\n+              }\n+            starts = sd.starts = new difference_type[num_threads + 1];\n+            int bin_cursor = 0;\n+            sd.num_bins = num_bins;\n+            sd.num_bits = log2(num_bins);\n+\n+            difference_type chunk_length = n / num_threads,\n+                            split = n % num_threads, start = 0;\n+            difference_type bin_chunk_length = num_bins / num_threads,\n+                            bin_split = num_bins % num_threads;\n+            for (thread_index_t i = 0; i < num_threads; i++)\n+              {\n+                starts[i] = start;\n+                start += (i < split) ? (chunk_length + 1) : chunk_length;\n+                int j = pus[i].bins_begin = bin_cursor;\n+\n+                // Range of bins for this processor.\n+                bin_cursor += (i < bin_split) ?\n+                    (bin_chunk_length + 1) : bin_chunk_length;\n+                pus[i].bins_end = bin_cursor;\n+                for (; j < bin_cursor; j++)\n+                  sd.bin_proc[j] = i;\n+                pus[i].num_threads = num_threads;\n+                pus[i].seed = rng(std::numeric_limits<uint32>::max());\n+                pus[i].sd = &sd;\n+              }\n+            starts[num_threads] = start;\n+          } //single\n+      // Now shuffle in parallel.\n+      parallel_random_shuffle_drs_pu(pus);\n+    }\n \n     delete[] starts;\n     delete[] sd.bin_proc;\n@@ -367,16 +386,16 @@ namespace __gnu_parallel\n     delete[] pus;\n   }\n \n-  /** @brief Sequential cache-efficient random shuffle.\n-   *  @param begin Begin iterator of sequence.\n-   *  @param end End iterator of sequence.\n-   *  @param rng Random number generator to use.\n-   */\n-  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+/** @brief Sequential cache-efficient random shuffle.\n+ *  @param begin Begin iterator of sequence.\n+ *  @param end End iterator of sequence.\n+ *  @param rng Random number generator to use.\n+ */\n+template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n   sequential_random_shuffle(RandomAccessIterator begin, \n-\t\t\t    RandomAccessIterator end, \n-\t\t\t    RandomNumberGenerator& rng)\n+                            RandomAccessIterator end,\n+                            RandomNumberGenerator& rng)\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n@@ -388,7 +407,9 @@ namespace __gnu_parallel\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n     // Try the L1 cache first, must fit into L1.\n-    num_bins_cache = std::max((difference_type)1, (difference_type)(n / (Settings::L1_cache_size_lb / sizeof(value_type))));\n+    num_bins_cache =\n+        std::max<difference_type>\n+            (1, n / (Settings::L1_cache_size_lb / sizeof(value_type)));\n     num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n     // No more buckets than TLB entries, power of 2\n@@ -403,19 +424,23 @@ namespace __gnu_parallel\n     if (num_bins < num_bins_cache)\n       {\n #endif\n-\t// Now try the L2 cache, must fit into L2.\n-\tnum_bins_cache = static_cast<bin_index>(std::max((difference_type)1, (difference_type)(n / (Settings::L2_cache_size / sizeof(value_type)))));\n-\tnum_bins_cache = round_up_to_pow2(num_bins_cache);\n+        // Now try the L2 cache, must fit into L2.\n+        num_bins_cache =\n+            static_cast<bin_index>(std::max<difference_type>(\n+                1, n / (Settings::L2_cache_size / sizeof(value_type))));\n+        num_bins_cache = round_up_to_pow2(num_bins_cache);\n \n-\t// No more buckets than TLB entries, power of 2\n-\t// Power of 2 and at least one element per bin, at most the TLB size.\n-\tnum_bins = static_cast<bin_index>(std::min(n, (difference_type)num_bins_cache));\n+        // No more buckets than TLB entries, power of 2\n+        // Power of 2 and at least one element per bin, at most the TLB size.\n+        num_bins = static_cast<bin_index>\n+            (std::min(n, static_cast<difference_type>(num_bins_cache)));\n \n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_TLB\n-\t// 2 TLB entries needed per bin\n-\tnum_bins = std::min((difference_type)Settings::TLB_size / 2, num_bins);\n+        // 2 TLB entries needed per bin\n+        num_bins =\n+            std::min<difference_type>(Settings::TLB_size / 2, num_bins);\n #endif\n-\tnum_bins = round_up_to_pow2(num_bins);\n+        num_bins = round_up_to_pow2(num_bins);\n #if _GLIBCXX_RANDOM_SHUFFLE_CONSIDER_L1\n       }\n #endif\n@@ -424,58 +449,62 @@ namespace __gnu_parallel\n \n     if (num_bins > 1)\n       {\n-\tvalue_type* target = static_cast<value_type*>(::operator new(sizeof(value_type) * n));\n-\tbin_index* oracles = new bin_index[n];\n-\tdifference_type* dist0 = new difference_type[num_bins + 1], * dist1 = new difference_type[num_bins + 1];\n-\n-\tfor (int b = 0; b < num_bins + 1; b++)\n-\t  dist0[b] = 0;\n-\n-\trandom_number bitrng(rng(0xFFFFFFFF));\n-\n-\tfor (difference_type i = 0; i < n; i++)\n-\t  {\n-\t    bin_index oracle = random_number_pow2(num_bits, bitrng);\n-\t    oracles[i] = oracle;\n-\n-\t    // To allow prefix (partial) sum.\n-\t    dist0[oracle + 1]++;\n-\t  }\n-\n-\t// Sum up bins.\n-\t__gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n-\n-\tfor (int b = 0; b < num_bins + 1; b++)\n-\t  dist1[b] = dist0[b];\n-\n-\t// Distribute according to oracles.\n-\tfor (difference_type i = 0; i < n; i++)\n-\t  target[(dist0[oracles[i]])++] = *(begin + i);\n-\n-\tfor (int b = 0; b < num_bins; b++)\n-\t  {\n-\t    sequential_random_shuffle(target + dist1[b], target + dist1[b + 1],\n-\t\t\t\t      rng);\n-\t  }\n-\n-\tdelete[] dist0;\n-\tdelete[] dist1;\n-\tdelete[] oracles;\n-\tdelete[] target;\n+        value_type* target = static_cast<value_type*>(\n+          ::operator new(sizeof(value_type) * n));\n+        bin_index* oracles = new bin_index[n];\n+        difference_type* dist0 = new difference_type[num_bins + 1],\n+                       * dist1 = new difference_type[num_bins + 1];\n+\n+        for (int b = 0; b < num_bins + 1; b++)\n+          dist0[b] = 0;\n+\n+        random_number bitrng(rng(0xFFFFFFFF));\n+\n+        for (difference_type i = 0; i < n; i++)\n+          {\n+            bin_index oracle = random_number_pow2(num_bits, bitrng);\n+            oracles[i] = oracle;\n+\n+            // To allow prefix (partial) sum.\n+            dist0[oracle + 1]++;\n+          }\n+\n+        // Sum up bins.\n+        __gnu_sequential::partial_sum(dist0, dist0 + num_bins + 1, dist0);\n+\n+        for (int b = 0; b < num_bins + 1; b++)\n+          dist1[b] = dist0[b];\n+\n+        // Distribute according to oracles.\n+        for (difference_type i = 0; i < n; i++)\n+          target[(dist0[oracles[i]])++] = *(begin + i);\n+\n+        for (int b = 0; b < num_bins; b++)\n+          {\n+            sequential_random_shuffle(target + dist1[b],\n+                                      target + dist1[b + 1],\n+                                      rng);\n+          }\n+\n+        delete[] dist0;\n+        delete[] dist1;\n+        delete[] oracles;\n+        delete[] target;\n       }\n     else\n       __gnu_sequential::random_shuffle(begin, end, rng);\n   }\n \n-  /** @brief Parallel random public call.\n-   *  @param begin Begin iterator of sequence.\n-   *  @param end End iterator of sequence.\n-   *  @param rng Random number generator to use.\n-   */\n-  template<typename RandomAccessIterator, typename RandomNumberGenerator>\n+/** @brief Parallel random public call.\n+ *  @param begin Begin iterator of sequence.\n+ *  @param end End iterator of sequence.\n+ *  @param rng Random number generator to use.\n+ */\n+template<typename RandomAccessIterator, typename RandomNumberGenerator>\n   inline void\n-  parallel_random_shuffle(RandomAccessIterator begin, RandomAccessIterator end,\n-\t\t\t  RandomNumberGenerator rng = random_number())\n+  parallel_random_shuffle(RandomAccessIterator begin,\n+                          RandomAccessIterator end,\n+                          RandomNumberGenerator rng = random_number())\n   {\n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;"}, {"sha": "d917b12693a34da2bec474cd2884180867f91d89", "filename": "libstdc++-v3/include/parallel/search.h", "status": "modified", "additions": 61, "deletions": 47, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fsearch.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -53,10 +53,10 @@ namespace __gnu_parallel\n    *  @param length Length of sequence to search for.\n    *  @param advances Returned offsets. \n    */\n-  template<typename RandomAccessIterator, typename _DifferenceTp>\n+template<typename RandomAccessIterator, typename _DifferenceTp>\n   void\n   calc_borders(RandomAccessIterator elements, _DifferenceTp length, \n-\t       _DifferenceTp* off)\n+              _DifferenceTp* off)\n   {\n     typedef _DifferenceTp difference_type;\n \n@@ -66,9 +66,9 @@ namespace __gnu_parallel\n     difference_type k = 0;\n     for (difference_type j = 2; j <= length; j++)\n       {\n-\twhile ((k >= 0) && !(elements[k] == elements[j-1]))\n-\t  k = off[k];\n-\toff[j] = ++k;\n+        while ((k >= 0) && !(elements[k] == elements[j-1]))\n+          k = off[k];\n+        off[j] = ++k;\n       }\n   }\n \n@@ -81,11 +81,14 @@ namespace __gnu_parallel\n    *  @param end2 End iterator of second sequence.\n    *  @param pred Find predicate.\n    *  @return Place of finding in first sequences. */\n-  template<typename _RandomAccessIterator1, typename _RandomAccessIterator2, typename Pred>\n+template<\n+    typename _RandomAccessIterator1,\n+    typename _RandomAccessIterator2,\n+    typename Pred>\n   _RandomAccessIterator1\n   search_template(_RandomAccessIterator1 begin1, _RandomAccessIterator1 end1,\n-\t\t  _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2,\n-\t\t  Pred pred)\n+                  _RandomAccessIterator2 begin2, _RandomAccessIterator2 end2,\n+                  Pred pred)\n   {\n     typedef std::iterator_traits<_RandomAccessIterator1> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n@@ -103,60 +106,71 @@ namespace __gnu_parallel\n \n     // Where is first occurrence of pattern? defaults to end.\n     difference_type result = (end1 - begin1);\n+    difference_type *splitters;\n \n     // Pattern too long.\n     if (input_length < 0)\n       return end1;\n \n-    thread_index_t num_threads = std::max<difference_type>(1, std::min<difference_type>(input_length, __gnu_parallel::get_max_threads()));\n-\n     omp_lock_t result_lock;\n     omp_init_lock(&result_lock);\n \n-    difference_type borders[num_threads + 1];\n-    __gnu_parallel::equally_split(input_length, num_threads, borders);\n+    thread_index_t num_threads =\n+        std::max<difference_type>(1,\n+            std::min<difference_type>(input_length, get_max_threads()));\n \n     difference_type advances[pattern_length];\n     calc_borders(begin2, pattern_length, advances);\n \n-#pragma omp parallel num_threads(num_threads)\n-    {\n-      thread_index_t iam = omp_get_thread_num();\n-\n-      difference_type start = borders[iam], stop = borders[iam + 1];\n-\n-      difference_type pos_in_pattern = 0;\n-      bool found_pattern = false;\n-\n-      while (start <= stop && !found_pattern)\n-\t{\n-\t  // Get new value of result.\n-#pragma omp flush(result)\n-\t  // No chance for this thread to find first occurrence.\n-\t  if (result < start)\n-\t    break;\n-\t  while (pred(begin1[start + pos_in_pattern], begin2[pos_in_pattern]))\n-\t    {\n-\t      ++pos_in_pattern;\n-\t      if (pos_in_pattern == pattern_length)\n-\t\t{\n-\t\t  // Found new candidate for result.\n-                  omp_set_lock(&result_lock);\n-\t\t  result = std::min(result, start);\n-                  omp_unset_lock(&result_lock);\n-\n-\t\t  found_pattern = true;\n-\t\t  break;\n-\t\t}\n-\t    }\n-\t  // Make safe jump.\n-\t  start += (pos_in_pattern - advances[pos_in_pattern]);\n-\t  pos_in_pattern = (advances[pos_in_pattern] < 0) ? 0 : advances[pos_in_pattern];\n-\t}\n-    }\n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+            splitters = new difference_type[num_threads + 1];\n+            equally_split(input_length, num_threads, splitters);\n+          }\n+\n+        thread_index_t iam = omp_get_thread_num();\n+\n+        difference_type start = splitters[iam], stop = splitters[iam + 1];\n+\n+        difference_type pos_in_pattern = 0;\n+        bool found_pattern = false;\n+\n+        while (start <= stop && !found_pattern)\n+          {\n+            // Get new value of result.\n+            #pragma omp flush(result)\n+            // No chance for this thread to find first occurrence.\n+            if (result < start)\n+              break;\n+            while (pred(begin1[start + pos_in_pattern],\n+                         begin2[pos_in_pattern]))\n+              {\n+                ++pos_in_pattern;\n+                if (pos_in_pattern == pattern_length)\n+                  {\n+                    // Found new candidate for result.\n+                            omp_set_lock(&result_lock);\n+                    result = std::min(result, start);\n+                            omp_unset_lock(&result_lock);\n+\n+                    found_pattern = true;\n+                    break;\n+                  }\n+              }\n+            // Make safe jump.\n+            start += (pos_in_pattern - advances[pos_in_pattern]);\n+            pos_in_pattern =\n+                (advances[pos_in_pattern] < 0) ? 0 : advances[pos_in_pattern];\n+          }\n+      } //parallel\n \n     omp_destroy_lock(&result_lock);\n \n+    delete[] splitters;\n+\n     // Return iterator on found element.\n     return (begin1 + result);\n   }"}, {"sha": "7be31277077dc54ee26227089ddcc9808e174cf1", "filename": "libstdc++-v3/include/parallel/set_operations.h", "status": "modified", "additions": 291, "deletions": 254, "changes": 545, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fset_operations.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -47,28 +47,31 @@\n \n namespace __gnu_parallel\n {\n-  template<typename InputIterator, typename OutputIterator>\n+template<typename InputIterator, typename OutputIterator>\n   inline OutputIterator\n   copy_tail(std::pair<InputIterator, InputIterator> b,\n-\t    std::pair<InputIterator, InputIterator> e, OutputIterator r)\n+            std::pair<InputIterator, InputIterator> e, OutputIterator r)\n   {\n     if (b.first != e.first)\n       {\n-\tdo\n-\t  {\n-\t    *r++ = *b.first++;\n-\t  }\n-\twhile (b.first != e.first);\n+        do\n+          {\n+            *r++ = *b.first++;\n+          }\n+        while (b.first != e.first);\n       }\n     else\n       {\n-\twhile (b.second != e.second)\n-\t  *r++ = *b.second++;\n+        while (b.second != e.second)\n+          *r++ = *b.second++;\n       }\n     return r;\n   }\n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   struct symmetric_difference_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -80,55 +83,56 @@ namespace __gnu_parallel\n     Comparator comp;\n \n     inline OutputIterator invoke(InputIterator a, InputIterator b,\n-\t\t\t\t InputIterator c, InputIterator d,\n-\t\t\t\t OutputIterator r) const\n+                                  InputIterator c, InputIterator d,\n+                                  OutputIterator r) const\n     {\n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    {\n-\t      *r = *a;\n-\t      ++a;\n-\t      ++r;\n-\t    }\n-\t  else if (comp(*c, *a))\n-\t    {\n-\t      *r = *c;\n-\t      ++c;\n-\t      ++r;\n-\t    }\n-\t  else\n-\t    {\n-\t      ++a;\n-\t      ++c;\n-\t    }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            {\n+              *r = *a;\n+              ++a;\n+              ++r;\n+            }\n+          else if (comp(*c, *a))\n+            {\n+              *r = *c;\n+              ++c;\n+              ++r;\n+            }\n+          else\n+            {\n+              ++a;\n+              ++c;\n+            }\n+        }\n       return std::copy(c, d, std::copy(a, b, r));\n     }\n \n     inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n+        const\n     {\n       difference_type counter = 0;\n \n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    {\n-\t      ++a;\n-\t      ++counter;\n-\t    }\n-\t  else if (comp(*c, *a))\n-\t    {\n-\t      ++c;\n-\t      ++counter;\n-\t    }\n-\t  else\n-\t    {\n-\t      ++a;\n-\t      ++c;\n-\t    }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            {\n+              ++a;\n+              ++counter;\n+            }\n+          else if (comp(*c, *a))\n+            {\n+              ++c;\n+              ++counter;\n+            }\n+          else\n+            {\n+              ++a;\n+              ++c;\n+            }\n+        }\n \n       return counter + (b - a) + (d - c);\n     }\n@@ -144,7 +148,10 @@ namespace __gnu_parallel\n   };\n \n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   struct difference_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -157,44 +164,45 @@ namespace __gnu_parallel\n \n     inline OutputIterator\n     invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n-\t   OutputIterator r) const\n+          OutputIterator r) const\n     {\n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    {\n-\t      *r = *a;\n-\t      ++a;\n-\t      ++r;\n-\t    }\n-\t  else if (comp(*c, *a))\n-\t    { ++c; }\n-\t  else\n-\t    {\n-\t      ++a;\n-\t      ++c;\n-\t    }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            {\n+              *r = *a;\n+              ++a;\n+              ++r;\n+            }\n+          else if (comp(*c, *a))\n+            { ++c; }\n+          else\n+            {\n+              ++a;\n+              ++c;\n+            }\n+        }\n       return std::copy(a, b, r);\n     }\n \n     inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n+        const\n     {\n       difference_type counter = 0;\n \n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    {\n-\t      ++a;\n-\t      ++counter;\n-\t    }\n-\t  else if (comp(*c, *a))\n-\t    { ++c; }\n-\t  else\n-\t    { ++a; ++c; }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            {\n+              ++a;\n+              ++counter;\n+            }\n+          else if (comp(*c, *a))\n+            { ++c; }\n+          else\n+            { ++a; ++c; }\n+        }\n \n       return counter + (b - a);\n     }\n@@ -209,7 +217,10 @@ namespace __gnu_parallel\n   };\n \n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   struct intersection_func\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n@@ -222,44 +233,45 @@ namespace __gnu_parallel\n \n     inline OutputIterator\n     invoke(InputIterator a, InputIterator b, InputIterator c, InputIterator d,\n-\t   OutputIterator r) const\n+          OutputIterator r) const\n     {\n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    { ++a; }\n-\t  else if (comp(*c, *a))\n-\t    { ++c; }\n-\t  else\n-\t    {\n-\t      *r = *a;\n-\t      ++a;\n-\t      ++c;\n-\t      ++r;\n-\t    }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            { ++a; }\n+          else if (comp(*c, *a))\n+            { ++c; }\n+          else\n+            {\n+              *r = *a;\n+              ++a;\n+              ++c;\n+              ++r;\n+            }\n+        }\n \n       return r;\n     }\n \n     inline difference_type\n-    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d) const\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n+        const\n     {\n       difference_type counter = 0;\n \n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    { ++a; }\n-\t  else if (comp(*c, *a))\n-\t    { ++c; }\n-\t  else\n-\t    {\n-\t      ++a;\n-\t      ++c;\n-\t      ++counter;\n-\t    }\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            { ++a; }\n+          else if (comp(*c, *a))\n+            { ++c; }\n+          else\n+            {\n+              ++a;\n+              ++c;\n+              ++counter;\n+            }\n+        }\n \n       return counter;\n     }\n@@ -273,61 +285,62 @@ namespace __gnu_parallel\n     { return out; }\n   };\n \n-  template<class InputIterator, class OutputIterator, class Comparator>\n+template<class InputIterator, class OutputIterator, class Comparator>\n   struct union_func\n   {\n-    typedef typename std::iterator_traits<InputIterator>::difference_type difference_type;\n+    typedef typename std::iterator_traits<InputIterator>::difference_type\n+        difference_type;\n \n     union_func(Comparator c) : comp(c) {}\n \n     Comparator comp;\n \n     inline OutputIterator\n     invoke(InputIterator a, const InputIterator b, InputIterator c,\n-\t   const InputIterator d, OutputIterator r) const\n+          const InputIterator d, OutputIterator r) const\n     {\n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    {\n-\t      *r = *a;\n-\t      ++a;\n-\t    }\n-\t  else if (comp(*c, *a))\n-\t    {\n-\t      *r = *c;\n-\t      ++c;\n-\t    }\n-\t  else\n-\t    {\n-\t      *r = *a;\n-\t      ++a;\n-\t      ++c;\n-\t    }\n-\t  ++r;\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            {\n+              *r = *a;\n+              ++a;\n+            }\n+          else if (comp(*c, *a))\n+            {\n+              *r = *c;\n+              ++c;\n+            }\n+          else\n+            {\n+              *r = *a;\n+              ++a;\n+              ++c;\n+            }\n+          ++r;\n+        }\n       return std::copy(c, d, std::copy(a, b, r));\n     }\n \n     inline difference_type\n-    count(InputIterator a, const InputIterator b, InputIterator c,\n-\t  const InputIterator d) const\n+    count(InputIterator a, InputIterator b, InputIterator c, InputIterator d)\n+        const\n     {\n       difference_type counter = 0;\n \n       while (a != b && c != d)\n-\t{\n-\t  if (comp(*a, *c))\n-\t    { ++a; }\n-\t  else if (comp(*c, *a))\n-\t    { ++c; }\n-\t  else\n-\t    {\n-\t      ++a;\n-\t      ++c;\n-\t    }\n-\t  ++counter;\n-\t}\n+        {\n+          if (comp(*a, *c))\n+            { ++a; }\n+          else if (comp(*c, *a))\n+            { ++c; }\n+          else\n+            {\n+              ++a;\n+              ++c;\n+            }\n+          ++counter;\n+        }\n \n       counter += (b - a);\n       counter += (d - c);\n@@ -343,19 +356,21 @@ namespace __gnu_parallel\n     { return std::copy(a, b, out); }\n   };\n \n-  template<typename InputIterator, typename OutputIterator, typename Operation>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Operation>\n   OutputIterator\n   parallel_set_operation(InputIterator begin1, InputIterator end1,\n-\t\t\t InputIterator begin2, InputIterator end2,\n-\t\t\t OutputIterator result, Operation op)\n+                         InputIterator begin2, InputIterator end2,\n+                         OutputIterator result, Operation op)\n   {\n     _GLIBCXX_CALL((end1 - begin1) + (end2 - begin2))\n \n     typedef std::iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n     typedef typename std::pair<InputIterator, InputIterator> iterator_pair;\n \n-\n     if (begin1 == end1)\n       return op.first_empty(begin2, end2, result);\n \n@@ -364,152 +379,174 @@ namespace __gnu_parallel\n \n     const difference_type size = (end1 - begin1) + (end2 - begin2);\n \n-    thread_index_t num_threads = std::min<difference_type>(std::min(end1 - begin1, end2 - begin2), get_max_threads());\n-\n-    difference_type borders[num_threads + 2];\n-    equally_split(size, num_threads + 1, borders);\n-\n-    const iterator_pair sequence[ 2 ] = { std::make_pair(begin1, end1), std::make_pair(begin2, end2) } ;\n-\n-    iterator_pair block_begins[num_threads + 1];\n-\n-    // Very start.\n-    block_begins[0] = std::make_pair(begin1, begin2);\n-    difference_type length[num_threads];\n-\n+    const iterator_pair sequence[ 2 ] =\n+        { std::make_pair(begin1, end1), std::make_pair(begin2, end2) } ;\n     OutputIterator return_value = result;\n+    difference_type *borders;\n+    iterator_pair *block_begins;\n+    difference_type* lengths;\n \n-#pragma omp parallel num_threads(num_threads)\n-    {\n-      // Result from multiseq_partition.\n-      InputIterator offset[2];\n-      const int iam = omp_get_thread_num();\n-\n-      const difference_type rank = borders[iam + 1];\n-\n-      multiseq_partition(sequence, sequence + 2, rank, offset, op.comp);\n-\n-      // allowed to read?\n-      // together\n-      // *(offset[ 0 ] - 1) == *offset[ 1 ]\n-      if (offset[ 0 ] != begin1 && offset[ 1 ] != end2\n-\t   && !op.comp(*(offset[ 0 ] - 1), *offset[ 1 ])\n-\t   && !op.comp(*offset[ 1 ], *(offset[ 0 ] - 1)))\n-\t{\n-\t  // Avoid split between globally equal elements: move one to\n-\t  // front in first sequence.\n-\t  --offset[ 0 ];\n-\t}\n-\n-      iterator_pair block_end = block_begins[ iam + 1 ] = iterator_pair(offset[ 0 ], offset[ 1 ]);\n-\n-      // Make sure all threads have their block_begin result written out.\n-#pragma omp barrier\n-\n-      iterator_pair block_begin = block_begins[ iam ];\n-\n-      // Begin working for the first block, while the others except\n-      // the last start to count.\n-      if (iam == 0)\n-\t{\n-\t  // The first thread can copy already.\n-\t  length[ iam ] = op.invoke(block_begin.first, block_end.first, block_begin.second, block_end.second, result) - result;\n-\t}\n-      else\n-\t{\n-\t  length[ iam ] = op.count(block_begin.first, block_end.first,\n-\t\t\t\t   block_begin.second, block_end.second);\n-\t}\n-\n-      // Make sure everyone wrote their lengths.\n-#pragma omp barrier\n-\n-      OutputIterator r = result;\n-\n-      if (iam == 0)\n-\t{\n-\t  // Do the last block.\n-\t  for (int i = 0; i < num_threads; ++i)\n-\t    r += length[i];\n-\n-\t  block_begin = block_begins[num_threads];\n-\n-\t  // Return the result iterator of the last block.\n-\t  return_value = op.invoke(block_begin.first, end1, block_begin.second, end2, r);\n-\n-\t}\n-      else\n-\t{\n-\t  for (int i = 0; i < iam; ++i)\n-\t    r += length[ i ];\n-\n-\t  // Reset begins for copy pass.\n-\t  op.invoke(block_begin.first, block_end.first,\n-\t\t    block_begin.second, block_end.second, r);\n-\t}\n-    }\n+    thread_index_t num_threads =\n+        std::min<difference_type>(get_max_threads(),\n+            std::min(end1 - begin1, end2 - begin2));\n+\n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+\n+            borders = new difference_type[num_threads + 2];\n+            equally_split(size, num_threads + 1, borders);\n+            block_begins = new iterator_pair[num_threads + 1];\n+            // Very start.\n+            block_begins[0] = std::make_pair(begin1, begin2);\n+            lengths = new difference_type[num_threads];\n+          } //single\n+\n+        thread_index_t iam = omp_get_thread_num();\n+\n+        // Result from multiseq_partition.\n+        InputIterator offset[2];\n+        const difference_type rank = borders[iam + 1];\n+\n+        multiseq_partition(sequence, sequence + 2, rank, offset, op.comp);\n+\n+        // allowed to read?\n+        // together\n+        // *(offset[ 0 ] - 1) == *offset[ 1 ]\n+        if (offset[ 0 ] != begin1 && offset[ 1 ] != end2\n+            && !op.comp(*(offset[ 0 ] - 1), *offset[ 1 ])\n+            && !op.comp(*offset[ 1 ], *(offset[ 0 ] - 1)))\n+          {\n+            // Avoid split between globally equal elements: move one to\n+            // front in first sequence.\n+            --offset[ 0 ];\n+          }\n+\n+        iterator_pair block_end = block_begins[ iam + 1 ] =\n+            iterator_pair(offset[ 0 ], offset[ 1 ]);\n+\n+        // Make sure all threads have their block_begin result written out.\n+#       pragma omp barrier\n+\n+        iterator_pair block_begin = block_begins[ iam ];\n+\n+        // Begin working for the first block, while the others except\n+        // the last start to count.\n+        if (iam == 0)\n+          {\n+            // The first thread can copy already.\n+            lengths[ iam ] = op.invoke(block_begin.first, block_end.first,\n+                                       block_begin.second, block_end.second,\n+                                       result)\n+                              - result;\n+          }\n+        else\n+          {\n+            lengths[ iam ] = op.count(block_begin.first, block_end.first,\n+                        block_begin.second, block_end.second);\n+          }\n+\n+        // Make sure everyone wrote their lengths.\n+#       pragma omp barrier\n+\n+        OutputIterator r = result;\n+\n+        if (iam == 0)\n+          {\n+            // Do the last block.\n+            for (int i = 0; i < num_threads; ++i)\n+              r += lengths[i];\n+\n+            block_begin = block_begins[num_threads];\n+\n+            // Return the result iterator of the last block.\n+            return_value = op.invoke(\n+                block_begin.first, end1, block_begin.second, end2, r);\n+\n+          }\n+        else\n+          {\n+            for (int i = 0; i < iam; ++i)\n+              r += lengths[ i ];\n+\n+            // Reset begins for copy pass.\n+            op.invoke(block_begin.first, block_end.first,\n+                  block_begin.second, block_end.second, r);\n+          }\n+      }\n     return return_value;\n   }\n \n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   OutputIterator\n   parallel_set_union(InputIterator begin1, InputIterator end1,\n-\t\t     InputIterator begin2, InputIterator end2,\n-\t\t     OutputIterator result, Comparator comp)\n+                     InputIterator begin2, InputIterator end2,\n+                     OutputIterator result, Comparator comp)\n   {\n     return parallel_set_operation(begin1, end1, begin2, end2, result,\n-\t\t\t\t  union_func< InputIterator, OutputIterator, Comparator>(comp));\n+        union_func< InputIterator, OutputIterator, Comparator>(comp));\n   }\n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   OutputIterator\n   parallel_set_intersection(InputIterator begin1, InputIterator end1,\n-\t\t\t    InputIterator begin2, InputIterator end2,\n-\t\t\t    OutputIterator result, Comparator comp)\n+                            InputIterator begin2, InputIterator end2,\n+                            OutputIterator result, Comparator comp)\n   {\n     return parallel_set_operation(begin1, end1, begin2, end2, result,\n-\t\t\t\t  intersection_func<InputIterator, OutputIterator, Comparator>(comp));\n+        intersection_func<InputIterator, OutputIterator, Comparator>(comp));\n   }\n \n \n-  template<typename InputIterator, typename OutputIterator>\n+template<typename InputIterator, typename OutputIterator>\n   OutputIterator\n-  set_intersection(InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result)\n+  set_intersection(InputIterator begin1, InputIterator end1,\n+                   InputIterator begin2, InputIterator end2,\n+                   OutputIterator result)\n   {\n     typedef std::iterator_traits<InputIterator> traits_type;\n     typedef typename traits_type::value_type value_type;\n \n     return set_intersection(begin1, end1, begin2, end2, result,\n-\t\t\t    std::less<value_type>());\n+                  std::less<value_type>());\n   }\n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   OutputIterator\n   parallel_set_difference(InputIterator begin1, InputIterator end1,\n-\t\t\t  InputIterator begin2, InputIterator end2,\n-\t\t\t  OutputIterator result, Comparator comp)\n+                          InputIterator begin2, InputIterator end2,\n+                          OutputIterator result, Comparator comp)\n   {\n     return parallel_set_operation(begin1, end1, begin2, end2, result,\n-\t\t\t\t  difference_func<InputIterator, OutputIterator, Comparator>(comp));\n+        difference_func<InputIterator, OutputIterator, Comparator>(comp));\n   }\n \n-  template<typename InputIterator, typename OutputIterator, typename Comparator>\n+template<\n+    typename InputIterator,\n+    typename OutputIterator,\n+    typename Comparator>\n   OutputIterator\n-  parallel_set_symmetric_difference(InputIterator begin1, InputIterator end1, InputIterator begin2, InputIterator end2, OutputIterator result, Comparator comp)\n+  parallel_set_symmetric_difference(InputIterator begin1, InputIterator end1,\n+                                    InputIterator begin2, InputIterator end2,\n+                                    OutputIterator result, Comparator comp)\n   {\n     return parallel_set_operation(begin1, end1, begin2, end2, result,\n-\t\t\t\t  symmetric_difference_func<InputIterator, OutputIterator, Comparator>(comp));\n+        symmetric_difference_func<InputIterator, OutputIterator, Comparator>\n+            (comp));\n   }\n \n }\n \n #endif // _GLIBCXX_SET_ALGORITHM_\n-\n-\n-\n-\n-\n-\n-\n-"}, {"sha": "bf305031ed34385f41393656797fbcd6f02f4eeb", "filename": "libstdc++-v3/include/parallel/unique_copy.h", "status": "modified", "additions": 106, "deletions": 93, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Funique_copy.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -44,16 +44,19 @@\n namespace __gnu_parallel\n {\n \n-  /** @brief Parallel std::unique_copy(), without explicit equality predicate.\n-   *  @param first Begin iterator of input sequence.\n-   *  @param last End iterator of input sequence.\n-   *  @param result Begin iterator of result sequence.\n-   *  @param binary_pred Equality predicate.\n-   *  @return End iterator of result sequence. */\n-  template<typename InputIterator, class OutputIterator, class BinaryPredicate>\n+/** @brief Parallel std::unique_copy(), w/o explicit equality predicate.\n+  *  @param first Begin iterator of input sequence.\n+  *  @param last End iterator of input sequence.\n+  *  @param result Begin iterator of result sequence.\n+  *  @param binary_pred Equality predicate.\n+  *  @return End iterator of result sequence. */\n+template<\n+    typename InputIterator,\n+    class OutputIterator,\n+    class BinaryPredicate>\n   inline OutputIterator\n   parallel_unique_copy(InputIterator first, InputIterator last,\n-\t\t       OutputIterator result, BinaryPredicate binary_pred)\n+                       OutputIterator result, BinaryPredicate binary_pred)\n   {\n     _GLIBCXX_CALL(last - first)\n \n@@ -62,126 +65,136 @@ namespace __gnu_parallel\n     typedef typename traits_type::difference_type difference_type;\n \n     difference_type size = last - first;\n-    int num_threads = __gnu_parallel::get_max_threads();\n-    difference_type counter[num_threads + 1];\n \n     if (size == 0)\n       return result;\n \n     // Let the first thread process two parts.\n-    difference_type borders[num_threads + 2];\n-    __gnu_parallel::equally_split(size, num_threads + 1, borders);\n+    difference_type *counter;\n+    difference_type *borders;\n \n+    thread_index_t num_threads = get_max_threads();\n     // First part contains at least one element.\n-#pragma omp parallel num_threads(num_threads)\n-    {\n-      int iam = omp_get_thread_num();\n-\n-      difference_type begin, end;\n-\n-      // Check for length without duplicates\n-      // Needed for position in output\n-      difference_type i = 0;\n-      OutputIterator out = result;\n-      if (iam == 0)\n-\t{\n-\t  begin = borders[0] + 1;\t// == 1\n-\t  end = borders[iam + 1];\n-\n-\t  i++;\n-\t  new (static_cast<void *>(&*out)) value_type(*first);\n-\t  out++;\n-\n-\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n-\t    {\n-\t      if (!binary_pred(*iter, *(iter-1)))\n-\t\t{\n-\t\t  i++;\n-\t\t  new (static_cast<void *>(&*out)) value_type(*iter);\n-\t\t  out++;\n-\t\t}\n-\t    }\n-\t}\n+#   pragma omp parallel num_threads(num_threads)\n+      {\n+#       pragma omp single\n+          {\n+                num_threads = omp_get_num_threads();\n+                borders = new difference_type[num_threads + 2];\n+                equally_split(size, num_threads + 1, borders);\n+                counter = new difference_type[num_threads + 1];\n+          }\n+\n+        thread_index_t iam = omp_get_thread_num();\n+\n+        difference_type begin, end;\n+\n+        // Check for length without duplicates\n+        // Needed for position in output\n+        difference_type i = 0;\n+        OutputIterator out = result;\n+\n+        if (iam == 0)\n+        {\n+          begin = borders[0] + 1;\t// == 1\n+          end = borders[iam + 1];\n+\n+          i++;\n+          new (static_cast<void *>(&*out)) value_type(*first);\n+          out++;\n+\n+          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+            {\n+              if (!binary_pred(*iter, *(iter-1)))\n+                {\n+                  i++;\n+                  new (static_cast<void *>(&*out)) value_type(*iter);\n+                  out++;\n+                }\n+            }\n+        }\n       else\n-\t{\n-\t  begin = borders[iam]; //one part\n-\t  end = borders[iam + 1];\n-\n-\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n-\t    {\n-\t      if (!binary_pred(*iter, *(iter-1)))\n-\t\t{\n-\t\t  i++;\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          begin = borders[iam]; //one part\n+          end = borders[iam + 1];\n+\n+          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+            {\n+              if (!binary_pred(*iter, *(iter-1)))\n+                {\n+                  i++;\n+                }\n+            }\n+        }\n       counter[iam] = i;\n \n       // Last part still untouched.\n       difference_type begin_output;\n \n-#pragma omp barrier\n+#     pragma omp barrier\n \n       // Store result in output on calculated positions.\n       begin_output = 0;\n \n       if (iam == 0)\n-\t{\n-\t  for (int t = 0; t < num_threads; t++)\n-\t    begin_output += counter[t];\n+        {\n+          for (int t = 0; t < num_threads; t++)\n+            begin_output += counter[t];\n \n-\t  i = 0;\n+          i = 0;\n \n-\t  OutputIterator iter_out = result + begin_output;\n+          OutputIterator iter_out = result + begin_output;\n \n-\t  begin = borders[num_threads];\n-\t  end = size;\n+          begin = borders[num_threads];\n+          end = size;\n \n-\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n-\t    {\n-\t      if (iter == first || !binary_pred(*iter, *(iter-1)))\n-\t\t{\n-\t\t  i++;\n-\t\t  new (static_cast<void *>(&*iter_out)) value_type(*iter);\n-\t\t  iter_out++;\n-\t\t}\n-\t    }\n+          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+            {\n+              if (iter == first || !binary_pred(*iter, *(iter-1)))\n+                {\n+                  i++;\n+                  new (static_cast<void *>(&*iter_out)) value_type(*iter);\n+                  iter_out++;\n+                }\n+            }\n \n-\t  counter[num_threads] = i;\n-\t}\n+          counter[num_threads] = i;\n+        }\n       else\n-\t{\n-\t  for (int t = 0; t < iam; t++)\n-\t    begin_output += counter[t];\n-\n-\t  OutputIterator iter_out = result + begin_output;\n-\t  for (InputIterator iter = first + begin; iter < first + end; ++iter)\n-\t    {\n-\t      if (!binary_pred(*iter, *(iter-1)))\n-\t\t{\n-\t\t  new (static_cast<void *> (&*iter_out)) value_type(*iter);\n-\t\t  iter_out++;\n-\t\t}\n-\t    }\n-\t}\n+        {\n+          for (int t = 0; t < iam; t++)\n+            begin_output += counter[t];\n+\n+          OutputIterator iter_out = result + begin_output;\n+          for (InputIterator iter = first + begin; iter < first + end; ++iter)\n+            {\n+              if (!binary_pred(*iter, *(iter-1)))\n+                {\n+                  new (static_cast<void *> (&*iter_out)) value_type(*iter);\n+                  iter_out++;\n+                }\n+            }\n+        }\n     }\n \n     difference_type end_output = 0;\n     for (int t = 0; t < num_threads + 1; t++)\n       end_output += counter[t];\n \n+    delete[] borders;\n+\n     return result + end_output;\n   }\n \n-  /** @brief Parallel std::unique_copy(), without explicit equality predicate\n-   *  @param first Begin iterator of input sequence.\n-   *  @param last End iterator of input sequence.\n-   *  @param result Begin iterator of result sequence.\n-   *  @return End iterator of result sequence. */\n-  template<typename InputIterator, class OutputIterator>\n+/** @brief Parallel std::unique_copy(), without explicit equality predicate\n+  *  @param first Begin iterator of input sequence.\n+  *  @param last End iterator of input sequence.\n+  *  @param result Begin iterator of result sequence.\n+  *  @return End iterator of result sequence. */\n+template<typename InputIterator, class OutputIterator>\n   inline OutputIterator\n   parallel_unique_copy(InputIterator first, InputIterator last,\n-\t\t       OutputIterator result)\n+                       OutputIterator result)\n   {\n     typedef typename std::iterator_traits<InputIterator>::value_type value_type;\n "}, {"sha": "60c873951e100e867749c8ad9c6126c97f59493d", "filename": "libstdc++-v3/include/parallel/workstealing.h", "status": "modified", "additions": 199, "deletions": 187, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e683ee2a20b907e9b225dd83cd047331e87a7edf/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fparallel%2Fworkstealing.h?ref=e683ee2a20b907e9b225dd83cd047331e87a7edf", "patch": "@@ -55,8 +55,8 @@ namespace __gnu_parallel\n \n #define _GLIBCXX_JOB_VOLATILE volatile\n \n-  /** @brief One job for a certain thread. */\n-  template<typename _DifferenceTp>\n+/** @brief One job for a certain thread. */\n+template<typename _DifferenceTp>\n   struct Job\n   {\n     typedef _DifferenceTp difference_type;\n@@ -78,214 +78,226 @@ namespace __gnu_parallel\n     _GLIBCXX_JOB_VOLATILE difference_type load;\n   };\n \n-  /** @brief Work stealing algorithm for random access iterators.\n-   *\n-   *  Uses O(1) additional memory. Synchronization at job lists is\n-   *  done with atomic operations.\n-   *  @param begin Begin iterator of element sequence.\n-   *  @param end End iterator of element sequence.\n-   *  @param op User-supplied functor (comparator, predicate, adding\n-   *  functor, ...).\n-   *  @param f Functor to \"process\" an element with op (depends on\n-   *  desired functionality, e. g. for std::for_each(), ...).\n-   *  @param r Functor to \"add\" a single result to the already\n-   *  processed elements (depends on functionality).\n-   *  @param base Base value for reduction.\n-   *  @param output Pointer to position where final result is written to\n-   *  @param bound Maximum number of elements processed (e. g. for\n-   *  std::count_n()).\n-   *  @return User-supplied functor (that may contain a part of the result).\n-   */\n-  template<typename RandomAccessIterator, typename Op, typename Fu, typename Red, typename Result>\n+/** @brief Work stealing algorithm for random access iterators.\n+  *\n+  *  Uses O(1) additional memory. Synchronization at job lists is\n+  *  done with atomic operations.\n+  *  @param begin Begin iterator of element sequence.\n+  *  @param end End iterator of element sequence.\n+  *  @param op User-supplied functor (comparator, predicate, adding\n+  *  functor, ...).\n+  *  @param f Functor to \"process\" an element with op (depends on\n+  *  desired functionality, e. g. for std::for_each(), ...).\n+  *  @param r Functor to \"add\" a single result to the already\n+  *  processed elements (depends on functionality).\n+  *  @param base Base value for reduction.\n+  *  @param output Pointer to position where final result is written to\n+  *  @param bound Maximum number of elements processed (e. g. for\n+  *  std::count_n()).\n+  *  @return User-supplied functor (that may contain a part of the result).\n+  */\n+template<\n+    typename RandomAccessIterator,\n+    typename Op,\n+    typename Fu,\n+    typename Red,\n+    typename Result>\n   Op\n-  for_each_template_random_access_workstealing(RandomAccessIterator begin,\n-\t\t\t\t\t       RandomAccessIterator end,\n-\t\t\t\t\t       Op op, Fu& f, Red r,\n-\t\t\t\t\t       Result base, Result& output,\n-\t\t\t\t\t       typename std::iterator_traits<RandomAccessIterator>::difference_type bound)\n+  for_each_template_random_access_workstealing(\n+      RandomAccessIterator begin,\n+      RandomAccessIterator end,\n+      Op op, Fu& f, Red r,\n+      Result base, Result& output,\n+      typename std::iterator_traits<RandomAccessIterator>::difference_type\n+          bound)\n   {\n     _GLIBCXX_CALL(end - begin)\n \n     typedef std::iterator_traits<RandomAccessIterator> traits_type;\n     typedef typename traits_type::difference_type difference_type;\n \n \n-    difference_type chunk_size = static_cast<difference_type>(Settings::workstealing_chunk_size);\n+    difference_type chunk_size =\n+        static_cast<difference_type>(Settings::workstealing_chunk_size);\n \n     // How many jobs?\n     difference_type length = (bound < 0) ? (end - begin) : bound;\n \n     // To avoid false sharing in a cache line.\n-    const int stride = Settings::cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n+    const int stride =\n+        Settings::cache_line_size * 10 / sizeof(Job<difference_type>) + 1;\n \n     // Total number of threads currently working.\n     thread_index_t busy = 0;\n-    thread_index_t num_threads = get_max_threads();\n-    difference_type num_threads_min = num_threads < end - begin ? num_threads : end - begin;\n+\n+    Job<difference_type> *job;\n \n     omp_lock_t output_lock;\n     omp_init_lock(&output_lock);\n \n-    // No more threads than jobs, at least one thread.\n-    difference_type num_threads_max = num_threads_min > 1 ? num_threads_min : 1;\n-    num_threads = static_cast<thread_index_t>(num_threads_max);\n-\n-    // Create job description array.\n-    Job<difference_type> *job = new Job<difference_type>[num_threads * stride];\n-\n     // Write base value to output.\n     output = base;\n \n-#pragma omp parallel shared(busy) num_threads(num_threads)\n-    {\n-      // Initialization phase.\n-\n-      // Flags for every thread if it is doing productive work.\n-      bool iam_working = false;\n-\n-      // Thread id.\n-      thread_index_t iam = omp_get_thread_num();\n-\n-      // This job.\n-      Job<difference_type>& my_job = job[iam * stride];\n-\n-      // Random number (for work stealing).\n-      thread_index_t victim;\n-\n-      // Local value for reduction.\n-      Result result = Result();\n-\n-      // Number of elements to steal in one attempt.\n-      difference_type steal;\n-\n-      // Every thread has its own random number generator (modulo num_threads).\n-      random_number rand_gen(iam, num_threads);\n-\n-#pragma omp atomic\n-      // This thread is currently working.\n-      busy++;\n-\n-      iam_working = true;\n-\n-      // How many jobs per thread? last thread gets the rest.\n-      my_job.first = static_cast<difference_type>(iam * (length / num_threads));\n-\n-      my_job.last = (iam == (num_threads - 1)) ? (length - 1) : ((iam + 1) * (length / num_threads) - 1);\n-      my_job.load = my_job.last - my_job.first + 1;\n-\n-      // Init result with first value (to have a base value for reduction).\n-      if (my_job.first <= my_job.last)\n-\t{\n-\t  // Cannot use volatile variable directly.\n-\t  difference_type my_first = my_job.first;\n-\t  result = f(op, begin + my_first);\n-\t  my_job.first++;\n-\t  my_job.load--;\n-\t}\n-\n-      RandomAccessIterator current;\n-\n-#pragma omp barrier\n-\n-      // Actual work phase\n-      // Work on own or stolen start\n-      while (busy > 0)\n-\t{\n-\t  // Work until no productive thread left.\n-#pragma omp flush(busy)\n-\n-\t  // Thread has own work to do\n-\t  while (my_job.first <= my_job.last)\n-\t    {\n-\t      // fetch-and-add call\n-\t      // Reserve current job block (size chunk_size) in my queue.\n-\t      difference_type current_job = fetch_and_add<difference_type>(&(my_job.first), chunk_size);\n-\n-\t      // Update load, to make the three values consistent,\n-\t      // first might have been changed in the meantime\n-\t      my_job.load = my_job.last - my_job.first + 1;\n-\t      for (difference_type job_counter = 0; job_counter < chunk_size && current_job <= my_job.last; job_counter++)\n-\t\t{\n-\t\t  // Yes: process it!\n-\t\t  current = begin + current_job;\n-\t\t  current_job++;\n-\n-\t\t  // Do actual work.\n-\t\t  result = r(result, f(op, current));\n-\t\t}\n-\n-#pragma omp flush(busy)\n-\n-\t    }\n-\n-\t  // After reaching this point, a thread's job list is empty.\n-\t  if (iam_working)\n-\t    {\n-#pragma omp atomic\n-\t      // This thread no longer has work.\n-\t      busy--;\n-\n-\t      iam_working = false;\n-\t    }\n-\n-\t  difference_type supposed_first, supposed_last, supposed_load;\n-\t  do\n-\t    {\n-\t      // Find random nonempty deque (not own) and do consistency check.\n-\t      yield();\n-#pragma omp flush(busy)\n-\t      victim = rand_gen();\n-\t      supposed_first = job[victim * stride].first;\n-\t      supposed_last = job[victim * stride].last;\n-\t      supposed_load = job[victim * stride].load;\n-\t    }\n-\t  while (busy > 0\n-\t\t && ((supposed_load <= 0) || ((supposed_first + supposed_load - 1) != supposed_last)));\n-\n-\t  if (busy == 0)\n-\t    break;\n-\n-\t  if (supposed_load > 0)\n-\t    {\n-\t      // Has work and work to do.\n-\t      // Number of elements to steal (at least one).\n-\t      steal = (supposed_load < 2) ? 1 : supposed_load / 2;\n-\n-\t      // Protects against stealing threads\n-\t      // omp_set_lock(&(job[victim * stride].lock));\n-\n-\t      // Push victim's start forward.\n-\t      difference_type stolen_first = fetch_and_add<difference_type>(&(job[victim * stride].first), steal);\n-\t      difference_type stolen_try = stolen_first + steal - difference_type(1);\n-\n-\t      // Protects against working thread\n-\t      // omp_unset_lock(&(job[victim * stride].lock));\n-\n-\t      my_job.first = stolen_first;\n-\t      \n-\t      // Avoid std::min dependencies.\n-\t      my_job.last = stolen_try < supposed_last ? stolen_try : supposed_last;\n-\n-\t      my_job.load = my_job.last - my_job.first + 1;\n-\n-\t      //omp_unset_lock(&(my_job.lock));\n-\n-#pragma omp atomic\n-\t      // Has potential work again.\n-\t      busy++;\n-\t      iam_working = true;\n-\n-#pragma omp flush(busy)\n-\t    }\n-#pragma omp flush(busy)\n-\t} // end while busy > 0\n-      // Add accumulated result to output.\n-      omp_set_lock(&output_lock);\n-      output = r(output, result);\n-      omp_unset_lock(&output_lock);\n-\n-      //omp_destroy_lock(&(my_job.lock));\n-    }\n+    // No more threads than jobs, at least one thread.\n+    thread_index_t num_threads =\n+        __gnu_parallel::max<thread_index_t>(1,\n+            __gnu_parallel::min<difference_type>(length, get_max_threads()));\n+\n+#   pragma omp parallel shared(busy) num_threads(num_threads)\n+      {\n+\n+#       pragma omp single\n+          {\n+            num_threads = omp_get_num_threads();\n+\n+            // Create job description array.\n+            job = new Job<difference_type>[num_threads * stride];\n+          }\n+\n+        // Initialization phase.\n+\n+        // Flags for every thread if it is doing productive work.\n+        bool iam_working = false;\n+\n+        // Thread id.\n+        thread_index_t iam = omp_get_thread_num();\n+\n+        // This job.\n+        Job<difference_type>& my_job = job[iam * stride];\n+\n+        // Random number (for work stealing).\n+        thread_index_t victim;\n+\n+        // Local value for reduction.\n+        Result result = Result();\n+\n+        // Number of elements to steal in one attempt.\n+        difference_type steal;\n+\n+        // Every thread has its own random number generator\n+        // (modulo num_threads).\n+        random_number rand_gen(iam, num_threads);\n+\n+        // This thread is currently working.\n+#       pragma omp atomic\n+          busy++;\n+\n+        iam_working = true;\n+\n+        // How many jobs per thread? last thread gets the rest.\n+        my_job.first =\n+            static_cast<difference_type>(iam * (length / num_threads));\n+\n+        my_job.last = (iam == (num_threads - 1)) ?\n+            (length - 1) : ((iam + 1) * (length / num_threads) - 1);\n+        my_job.load = my_job.last - my_job.first + 1;\n+\n+        // Init result with first value (to have a base value for reduction).\n+        if (my_job.first <= my_job.last)\n+          {\n+            // Cannot use volatile variable directly.\n+            difference_type my_first = my_job.first;\n+            result = f(op, begin + my_first);\n+            my_job.first++;\n+            my_job.load--;\n+          }\n+\n+        RandomAccessIterator current;\n+\n+#       pragma omp barrier\n+\n+        // Actual work phase\n+        // Work on own or stolen start\n+        while (busy > 0)\n+          {\n+            // Work until no productive thread left.\n+#           pragma omp flush(busy)\n+\n+            // Thread has own work to do\n+            while (my_job.first <= my_job.last)\n+              {\n+                // fetch-and-add call\n+                // Reserve current job block (size chunk_size) in my queue.\n+                difference_type current_job =\n+                  fetch_and_add<difference_type>(&(my_job.first), chunk_size);\n+\n+                // Update load, to make the three values consistent,\n+                // first might have been changed in the meantime\n+                my_job.load = my_job.last - my_job.first + 1;\n+                for (difference_type job_counter = 0;\n+                     job_counter < chunk_size && current_job <= my_job.last;\n+                     job_counter++)\n+                  {\n+                    // Yes: process it!\n+                    current = begin + current_job;\n+                    current_job++;\n+\n+                    // Do actual work.\n+                    result = r(result, f(op, current));\n+                  }\n+\n+#               pragma omp flush(busy)\n+              }\n+\n+            // After reaching this point, a thread's job list is empty.\n+            if (iam_working)\n+              {\n+                // This thread no longer has work.\n+#               pragma omp atomic\n+                busy--;\n+\n+                iam_working = false;\n+              }\n+\n+            difference_type supposed_first, supposed_last, supposed_load;\n+            do\n+              {\n+                // Find random nonempty deque (not own), do consistency check.\n+                yield();\n+#               pragma omp flush(busy)\n+                victim = rand_gen();\n+                supposed_first = job[victim * stride].first;\n+                supposed_last = job[victim * stride].last;\n+                supposed_load = job[victim * stride].load;\n+              }\n+            while (busy > 0\n+              && ((supposed_load <= 0)\n+                || ((supposed_first + supposed_load - 1) != supposed_last)));\n+\n+            if (busy == 0)\n+              break;\n+\n+            if (supposed_load > 0)\n+              {\n+                // Has work and work to do.\n+                // Number of elements to steal (at least one).\n+                steal = (supposed_load < 2) ? 1 : supposed_load / 2;\n+\n+                // Push victim's start forward.\n+                difference_type stolen_first =\n+                    fetch_and_add<difference_type>(\n+                        &(job[victim * stride].first), steal);\n+                difference_type stolen_try =\n+                    stolen_first + steal - difference_type(1);\n+\n+                my_job.first = stolen_first;\n+                my_job.last = __gnu_parallel::min(stolen_try, supposed_last);\n+                my_job.load = my_job.last - my_job.first + 1;\n+\n+                // Has potential work again.\n+#               pragma omp atomic\n+                  busy++;\n+                iam_working = true;\n+\n+#               pragma omp flush(busy)\n+              }\n+#           pragma omp flush(busy)\n+          } // end while busy > 0\n+            // Add accumulated result to output.\n+        omp_set_lock(&output_lock);\n+        output = r(output, result);\n+        omp_unset_lock(&output_lock);\n+      }\n \n     delete[] job;\n "}]}