{"sha": "31f1f73b3e6e89784f0639957d1cf6ea44575468", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzFmMWY3M2IzZTZlODk3ODRmMDYzOTk1N2QxY2Y2ZWE0NDU3NTQ2OA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2013-09-01T12:00:35Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2013-09-01T12:00:35Z"}, "message": "lto.c (tree_with_vars): Turn into vector.\n\n\n\t* lto.c (tree_with_vars): Turn into vector.\n\t(MAYBE_REMEMBER_WITH_VARS): Change to...\n\t(CHECK_VAR): ... this one.\n\t(CHECK_NO_VAR): New macro.\n\t(maybe_remember_with_vars_typed): Turn to ...\n\t(mentions_vars_p_typed): ... this one.\n\t(maybe_remember_with_vars_common): Turn to ...\n\t(mentions_vars_p_comon): ... this one.\n\t(maybe_remember_with_vars_decl_minimal): Turn to ...\n\t(mentions_vars_p_decl_minmal): ... this one.\n\t(maybe_remember_with_vars_decl_common): Turn to ...\n\t(mentions_vars_p_decl_common): ... this one.\n\t(maybe_remember_with_vars_decl_with_vis): Turn to ...\n\t(mentions_vars_p_decl_with_vis): ... this one.\n\t(maybe_remember_with_vars_decl_non_common): Turn to ...\n\t(mentions_vars_p_decl_non_common): ... this one.\n\t(maybe_remember_with_vars_function): Turn to ...\n\t(mentions_vars_p_function): ... this one.\n\t(maybe_remember_with_vars_field_decl): Turn to ...\n\t(mentions_vars_p_field_decl): ... this one.\n\t(maybe_remember_with_vars_type): Turn to ...\n\t(mentions_vars_p_type): ... this one.\n\t(maybe_remember_with_vars_binfo): Turn to ...\n\t(mentions_vars_p_binfo): ... this one.\n\t(maybe_remember_with_vars_constructor): Turn to ...\n\t(mentions_vars_p_constructor): ... this one.\n\t(maybe_remember_with_vars_expr): Turn to ...\n\t(mentions_vars_p_expr): ... this one.\n\t(maybe_remember_with_vars): Turn to ...\n\t(mentions_vars_p): ... this one.\n\t(lto_read_decls): Update.\n\t(LTO_SET_PREVAIL): Do not call function for internal decls.\n\t(lto_fixup_prevailing_decls): Update to match mentions_vars_p;\n\tcheck that something was updated.\n\t(lto_fixup_state): Do not care about internal decls.\n\t(lto_fixup_decls): Update.\n\t(read_cgraph_and_symbols): Update.\n\nFrom-SVN: r202143", "tree": {"sha": "1a0693e5ff7603ab135b03a52dd4e3e3d388d19a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a0693e5ff7603ab135b03a52dd4e3e3d388d19a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/31f1f73b3e6e89784f0639957d1cf6ea44575468", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f1f73b3e6e89784f0639957d1cf6ea44575468", "html_url": "https://github.com/Rust-GCC/gccrs/commit/31f1f73b3e6e89784f0639957d1cf6ea44575468", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/31f1f73b3e6e89784f0639957d1cf6ea44575468/comments", "author": null, "committer": null, "parents": [{"sha": "63bf9a906c4c8fa5952fd494e8b7d45753b887bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63bf9a906c4c8fa5952fd494e8b7d45753b887bb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63bf9a906c4c8fa5952fd494e8b7d45753b887bb"}], "stats": {"total": 350, "additions": 210, "deletions": 140}, "files": [{"sha": "cf31c21e177dce1ec881e63e8d9a73cd68b4ef73", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f1f73b3e6e89784f0639957d1cf6ea44575468/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f1f73b3e6e89784f0639957d1cf6ea44575468/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=31f1f73b3e6e89784f0639957d1cf6ea44575468", "patch": "@@ -1,3 +1,43 @@\n+2013-08-31  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c (tree_with_vars): Turn into vector.\n+\t(MAYBE_REMEMBER_WITH_VARS): Change to...\n+\t(CHECK_VAR): ... this one.\n+\t(CHECK_NO_VAR): New macro.\n+\t(maybe_remember_with_vars_typed): Turn to ...\n+\t(mentions_vars_p_typed): ... this one.\n+\t(maybe_remember_with_vars_common): Turn to ...\n+\t(mentions_vars_p_comon): ... this one.\n+\t(maybe_remember_with_vars_decl_minimal): Turn to ...\n+\t(mentions_vars_p_decl_minmal): ... this one.\n+\t(maybe_remember_with_vars_decl_common): Turn to ...\n+\t(mentions_vars_p_decl_common): ... this one.\n+\t(maybe_remember_with_vars_decl_with_vis): Turn to ...\n+\t(mentions_vars_p_decl_with_vis): ... this one.\n+\t(maybe_remember_with_vars_decl_non_common): Turn to ...\n+\t(mentions_vars_p_decl_non_common): ... this one.\n+\t(maybe_remember_with_vars_function): Turn to ...\n+\t(mentions_vars_p_function): ... this one.\n+\t(maybe_remember_with_vars_field_decl): Turn to ...\n+\t(mentions_vars_p_field_decl): ... this one.\n+\t(maybe_remember_with_vars_type): Turn to ...\n+\t(mentions_vars_p_type): ... this one.\n+\t(maybe_remember_with_vars_binfo): Turn to ...\n+\t(mentions_vars_p_binfo): ... this one.\n+\t(maybe_remember_with_vars_constructor): Turn to ...\n+\t(mentions_vars_p_constructor): ... this one.\n+\t(maybe_remember_with_vars_expr): Turn to ...\n+\t(mentions_vars_p_expr): ... this one.\n+\t(maybe_remember_with_vars): Turn to ...\n+\t(mentions_vars_p): ... this one.\n+\t(lto_read_decls): Update.\n+\t(LTO_SET_PREVAIL): Do not call function for internal decls.\n+\t(lto_fixup_prevailing_decls): Update to match mentions_vars_p;\n+\tcheck that something was updated.\n+\t(lto_fixup_state): Do not care about internal decls.\n+\t(lto_fixup_decls): Update.\n+\t(read_cgraph_and_symbols): Update.\n+\n 2013-08-29  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c (read_cgraph_and_symbols): Free decl states."}, {"sha": "1d1350be3240c6aca9371ec5aff06d76cbbd308a", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 170, "deletions": 140, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/31f1f73b3e6e89784f0639957d1cf6ea44575468/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/31f1f73b3e6e89784f0639957d1cf6ea44575468/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=31f1f73b3e6e89784f0639957d1cf6ea44575468", "patch": "@@ -1283,238 +1283,249 @@ gimple_register_type (tree t)\n \n /* End of old merging code.  */\n \n+/* Remember trees that contains references to declarations.  */\n+static GTY(()) vec <tree, va_gc> *tree_with_vars;\n \n-\n-/* A hashtable of trees that potentially refer to variables or functions\n-   that must be replaced with their prevailing variant.  */\n-static GTY((if_marked (\"ggc_marked_p\"), param_is (union tree_node))) htab_t\n-  tree_with_vars;\n-\n-/* Remember that T is a tree that (potentially) refers to a variable\n-   or function decl that may be replaced with its prevailing variant.  */\n-static void\n-remember_with_vars (tree t)\n-{\n-  *(tree *) htab_find_slot (tree_with_vars, t, INSERT) = t;\n-}\n-\n-#define MAYBE_REMEMBER_WITH_VARS(tt) \\\n+#define CHECK_VAR(tt) \\\n   do \\\n     { \\\n-      if (tt) \\\n-\t{ \\\n-\t  if (VAR_OR_FUNCTION_DECL_P (tt) && TREE_PUBLIC (tt)) \\\n-\t    remember_with_vars (t); \\\n-\t} \\\n+      if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n+\t  && (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n+\treturn true; \\\n     } while (0)\n \n-/* Fix up fields of a tree_typed T.  */\n+#define CHECK_NO_VAR(tt) \\\n+  gcc_checking_assert (!(tt) || !VAR_OR_FUNCTION_DECL_P (tt))\n \n-static void\n-maybe_remember_with_vars_typed (tree t)\n+/* Check presence of pointers to decls in fields of a tree_typed T.  */\n+\n+static inline bool\n+mentions_vars_p_typed (tree t)\n {\n-  MAYBE_REMEMBER_WITH_VARS (TREE_TYPE (t));\n+  CHECK_NO_VAR (TREE_TYPE (t));\n+  return false;\n }\n \n-/* Fix up fields of a tree_common T.  */\n+/* Check presence of pointers to decls in fields of a tree_common T.  */\n \n-static void\n-maybe_remember_with_vars_common (tree t)\n+static inline bool\n+mentions_vars_p_common (tree t)\n {\n-  maybe_remember_with_vars_typed (t);\n-  MAYBE_REMEMBER_WITH_VARS (TREE_CHAIN (t));\n+  if (mentions_vars_p_typed (t))\n+    return true;\n+  CHECK_NO_VAR (TREE_CHAIN (t));\n+  return false;\n }\n \n-/* Fix up fields of a decl_minimal T.  */\n+/* Check presence of pointers to decls in fields of a decl_minimal T.  */\n \n-static void\n-maybe_remember_with_vars_decl_minimal (tree t)\n+static inline bool\n+mentions_vars_p_decl_minimal (tree t)\n {\n-  maybe_remember_with_vars_common (t);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_NAME (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_CONTEXT (t));\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_NAME (t));\n+  CHECK_VAR (DECL_CONTEXT (t));\n+  return false;\n }\n \n-/* Fix up fields of a decl_common T.  */\n+/* Check presence of pointers to decls in fields of a decl_common T.  */\n \n-static void\n-maybe_remember_with_vars_decl_common (tree t)\n+static inline bool\n+mentions_vars_p_decl_common (tree t)\n {\n-  maybe_remember_with_vars_decl_minimal (t);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_SIZE (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_SIZE_UNIT (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_INITIAL (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_ATTRIBUTES (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_ABSTRACT_ORIGIN (t));\n+  if (mentions_vars_p_decl_minimal (t))\n+    return true;\n+  CHECK_VAR (DECL_SIZE (t));\n+  CHECK_VAR (DECL_SIZE_UNIT (t));\n+  CHECK_VAR (DECL_INITIAL (t));\n+  CHECK_NO_VAR (DECL_ATTRIBUTES (t));\n+  CHECK_VAR (DECL_ABSTRACT_ORIGIN (t));\n+  return false;\n }\n \n-/* Fix up fields of a decl_with_vis T.  */\n+/* Check presence of pointers to decls in fields of a decl_with_vis T.  */\n \n-static void\n-maybe_remember_with_vars_decl_with_vis (tree t)\n+static inline bool\n+mentions_vars_p_decl_with_vis (tree t)\n {\n-  maybe_remember_with_vars_decl_common (t);\n+  if (mentions_vars_p_decl_common (t))\n+    return true;\n \n   /* Accessor macro has side-effects, use field-name here. */\n-  MAYBE_REMEMBER_WITH_VARS (t->decl_with_vis.assembler_name);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_SECTION_NAME (t));\n+  CHECK_NO_VAR (t->decl_with_vis.assembler_name);\n+  CHECK_NO_VAR (DECL_SECTION_NAME (t));\n+  return false;\n }\n \n-/* Fix up fields of a decl_non_common T.  */\n+/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n \n-static void\n-maybe_remember_with_vars_decl_non_common (tree t)\n+static inline bool\n+mentions_vars_p_decl_non_common (tree t)\n {\n-  maybe_remember_with_vars_decl_with_vis (t);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_ARGUMENT_FLD (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_RESULT_FLD (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_VINDEX (t));\n+  if (mentions_vars_p_decl_with_vis (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_ARGUMENT_FLD (t));\n+  CHECK_NO_VAR (DECL_RESULT_FLD (t));\n+  CHECK_NO_VAR (DECL_VINDEX (t));\n+  return false;\n }\n \n-/* Fix up fields of a decl_non_common T.  */\n+/* Check presence of pointers to decls in fields of a decl_non_common T.  */\n \n-static void\n-maybe_remember_with_vars_function (tree t)\n+static bool\n+mentions_vars_p_function (tree t)\n {\n-  maybe_remember_with_vars_decl_non_common (t);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_FUNCTION_PERSONALITY (t));\n+  if (mentions_vars_p_decl_non_common (t))\n+    return true;\n+  CHECK_VAR (DECL_FUNCTION_PERSONALITY (t));\n+  return false;\n }\n \n-/* Fix up fields of a field_decl T.  */\n+/* Check presence of pointers to decls in fields of a field_decl T.  */\n \n-static void\n-maybe_remember_with_vars_field_decl (tree t)\n+static bool\n+mentions_vars_p_field_decl (tree t)\n {\n-  maybe_remember_with_vars_decl_common (t);\n-  MAYBE_REMEMBER_WITH_VARS (DECL_FIELD_OFFSET (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_BIT_FIELD_TYPE (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_QUALIFIER (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_FIELD_BIT_OFFSET (t));\n-  MAYBE_REMEMBER_WITH_VARS (DECL_FCONTEXT (t));\n+  if (mentions_vars_p_decl_common (t))\n+    return true;\n+  CHECK_NO_VAR (DECL_FIELD_OFFSET (t));\n+  CHECK_NO_VAR (DECL_BIT_FIELD_TYPE (t));\n+  CHECK_NO_VAR (DECL_QUALIFIER (t));\n+  CHECK_NO_VAR (DECL_FIELD_BIT_OFFSET (t));\n+  CHECK_NO_VAR (DECL_FCONTEXT (t));\n+  return false;\n }\n \n-/* Fix up fields of a type T.  */\n+/* Check presence of pointers to decls in fields of a type T.  */\n \n-static void\n-maybe_remember_with_vars_type (tree t)\n+static bool\n+mentions_vars_p_type (tree t)\n {\n-  maybe_remember_with_vars_common (t);\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_CACHED_VALUES (t));\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_SIZE (t));\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_SIZE_UNIT (t));\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_ATTRIBUTES (t));\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_NAME (t));\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_NO_VAR (TYPE_CACHED_VALUES (t));\n+  CHECK_VAR (TYPE_SIZE (t));\n+  CHECK_VAR (TYPE_SIZE_UNIT (t));\n+  CHECK_NO_VAR (TYPE_ATTRIBUTES (t));\n+  CHECK_NO_VAR (TYPE_NAME (t));\n \n-  /* Accessors are for derived node types only. */\n-  if (!POINTER_TYPE_P (t))\n-    MAYBE_REMEMBER_WITH_VARS (TYPE_MINVAL (t));\n-  MAYBE_REMEMBER_WITH_VARS (TYPE_MAXVAL (t));\n+  CHECK_VAR (TYPE_MINVAL (t));\n+  CHECK_VAR (TYPE_MAXVAL (t));\n \n   /* Accessor is for derived node types only. */\n-  MAYBE_REMEMBER_WITH_VARS (t->type_non_common.binfo);\n+  CHECK_NO_VAR (t->type_non_common.binfo);\n \n-  MAYBE_REMEMBER_WITH_VARS (TYPE_CONTEXT (t));\n+  CHECK_VAR (TYPE_CONTEXT (t));\n+  CHECK_NO_VAR (TYPE_CANONICAL (t));\n+  CHECK_NO_VAR (TYPE_MAIN_VARIANT (t));\n+  CHECK_NO_VAR (TYPE_NEXT_VARIANT (t));\n+  return false;\n }\n \n-/* Fix up fields of a BINFO T.  */\n+/* Check presence of pointers to decls in fields of a BINFO T.  */\n \n-static void\n-maybe_remember_with_vars_binfo (tree t)\n+static bool\n+mentions_vars_p_binfo (tree t)\n {\n   unsigned HOST_WIDE_INT i, n;\n \n-  maybe_remember_with_vars_common (t);\n-  MAYBE_REMEMBER_WITH_VARS (BINFO_VTABLE (t));\n-  MAYBE_REMEMBER_WITH_VARS (BINFO_OFFSET (t));\n-  MAYBE_REMEMBER_WITH_VARS (BINFO_VIRTUALS (t));\n-  MAYBE_REMEMBER_WITH_VARS (BINFO_VPTR_FIELD (t));\n+  if (mentions_vars_p_common (t))\n+    return true;\n+  CHECK_VAR (BINFO_VTABLE (t));\n+  CHECK_NO_VAR (BINFO_OFFSET (t));\n+  CHECK_NO_VAR (BINFO_VIRTUALS (t));\n+  CHECK_NO_VAR (BINFO_VPTR_FIELD (t));\n   n = vec_safe_length (BINFO_BASE_ACCESSES (t));\n   for (i = 0; i < n; i++)\n-    MAYBE_REMEMBER_WITH_VARS (BINFO_BASE_ACCESS (t, i));\n+    CHECK_NO_VAR (BINFO_BASE_ACCESS (t, i));\n   /* Do not walk BINFO_INHERITANCE_CHAIN, BINFO_SUBVTT_INDEX\n      and BINFO_VPTR_INDEX; these are used by C++ FE only.  */\n   n = BINFO_N_BASE_BINFOS (t);\n   for (i = 0; i < n; i++)\n-    MAYBE_REMEMBER_WITH_VARS (BINFO_BASE_BINFO (t, i));\n+    CHECK_NO_VAR (BINFO_BASE_BINFO (t, i));\n+  return false;\n }\n \n-/* Fix up fields of a CONSTRUCTOR T.  */\n+/* Check presence of pointers to decls in fields of a CONSTRUCTOR T.  */\n \n-static void\n-maybe_remember_with_vars_constructor (tree t)\n+static bool\n+mentions_vars_p_constructor (tree t)\n {\n   unsigned HOST_WIDE_INT idx;\n   constructor_elt *ce;\n \n-  maybe_remember_with_vars_typed (t);\n+  if (mentions_vars_p_typed (t))\n+    return true;\n \n   for (idx = 0; vec_safe_iterate (CONSTRUCTOR_ELTS (t), idx, &ce); idx++)\n     {\n-      MAYBE_REMEMBER_WITH_VARS (ce->index);\n-      MAYBE_REMEMBER_WITH_VARS (ce->value);\n+      CHECK_NO_VAR (ce->index);\n+      CHECK_VAR (ce->value);\n     }\n+  return false;\n }\n \n-/* Fix up fields of an expression tree T.  */\n+/* Check presence of pointers to decls in fields of an expression tree T.  */\n \n-static void\n-maybe_remember_with_vars_expr (tree t)\n+static bool\n+mentions_vars_p_expr (tree t)\n {\n   int i;\n-  maybe_remember_with_vars_typed (t);\n+  if (mentions_vars_p_typed (t))\n+    return true;\n   for (i = TREE_OPERAND_LENGTH (t) - 1; i >= 0; --i)\n-    MAYBE_REMEMBER_WITH_VARS (TREE_OPERAND (t, i));\n+    CHECK_VAR (TREE_OPERAND (t, i));\n+  return false;\n }\n \n-/* Given a tree T fixup fields of T by replacing types with their merged\n-   variant and other entities by an equal entity from an earlier compilation\n-   unit, or an entity being canonical in a different way.  This includes\n-   for instance integer or string constants.  */\n+/* Check presence of pointers to decls that needs later fixup in T.  */\n \n-static void\n-maybe_remember_with_vars (tree t)\n+static bool\n+mentions_vars_p (tree t)\n {\n   switch (TREE_CODE (t))\n     {\n     case IDENTIFIER_NODE:\n       break;\n \n     case TREE_LIST:\n-      MAYBE_REMEMBER_WITH_VARS (TREE_VALUE (t));\n-      MAYBE_REMEMBER_WITH_VARS (TREE_PURPOSE (t));\n-      MAYBE_REMEMBER_WITH_VARS (TREE_CHAIN (t));\n+      CHECK_VAR (TREE_VALUE (t));\n+      CHECK_VAR (TREE_PURPOSE (t));\n+      CHECK_NO_VAR (TREE_CHAIN (t));\n       break;\n \n     case FIELD_DECL:\n-      maybe_remember_with_vars_field_decl (t);\n+      return mentions_vars_p_field_decl (t);\n       break;\n \n     case LABEL_DECL:\n     case CONST_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n     case IMPORTED_DECL:\n-      maybe_remember_with_vars_decl_common (t);\n+    case NAMESPACE_DECL:\n+      return mentions_vars_p_decl_common (t);\n       break;\n \n     case VAR_DECL:\n-      maybe_remember_with_vars_decl_with_vis (t);\n+      return mentions_vars_p_decl_with_vis (t);\n       break;\n \n     case TYPE_DECL:\n-      maybe_remember_with_vars_decl_non_common (t);\n+      return mentions_vars_p_decl_non_common (t);\n       break;\n \n     case FUNCTION_DECL:\n-      maybe_remember_with_vars_function (t);\n+      return mentions_vars_p_function (t);\n       break;\n \n     case TREE_BINFO:\n-      maybe_remember_with_vars_binfo (t);\n+      return mentions_vars_p_binfo (t);\n       break;\n \n     case PLACEHOLDER_EXPR:\n-      maybe_remember_with_vars_common (t);\n+      return mentions_vars_p_common (t);\n       break;\n \n     case BLOCK:\n@@ -1524,19 +1535,26 @@ maybe_remember_with_vars (tree t)\n       break;\n \n     case CONSTRUCTOR:\n-      maybe_remember_with_vars_constructor (t);\n+      return mentions_vars_p_constructor (t);\n       break;\n \n     default:\n       if (TYPE_P (t))\n-\tmaybe_remember_with_vars_type (t);\n-      else if (CONSTANT_CLASS_P (t))\n-\tMAYBE_REMEMBER_WITH_VARS (TREE_TYPE (t));\n+\t{\n+\t  if (mentions_vars_p_type (t))\n+\t    return true;\n+\t}\n       else if (EXPR_P (t))\n-\tmaybe_remember_with_vars_expr (t);\n+\t{\n+\t  if (mentions_vars_p_expr (t))\n+\t    return true;\n+\t}\n+      else if (CONSTANT_CLASS_P (t))\n+\tCHECK_NO_VAR (TREE_TYPE (t));\n       else\n-\tremember_with_vars (t);\n+\tgcc_unreachable ();\n     }\n+  return false;\n }\n \n \n@@ -2492,7 +2510,8 @@ lto_read_decls (struct lto_file_decl_data *decl_data, const void *data,\n \t\t    lto_register_function_decl_in_symtab (data_in, t, from + i);\n \t\t  /* Scan the tree for references to global functions or\n \t\t     variables and record those for later fixup.  */\n-\t\t  maybe_remember_with_vars (t);\n+\t\t  if (mentions_vars_p (t))\n+\t\t    vec_safe_push (tree_with_vars, t);\n \t\t}\n \t    }\n \t  if (not_merged_type_same_scc)\n@@ -3137,8 +3156,12 @@ lto_wpa_write_files (void)\n    prevailing variant.  */\n #define LTO_SET_PREVAIL(tt) \\\n   do {\\\n-    if ((tt) && VAR_OR_FUNCTION_DECL_P (tt)) \\\n-      tt = lto_symtab_prevailing_decl (tt); \\\n+    if ((tt) && VAR_OR_FUNCTION_DECL_P (tt) \\\n+\t&& (TREE_PUBLIC (tt) || DECL_EXTERNAL (tt))) \\\n+      { \\\n+        tt = lto_symtab_prevailing_decl (tt); \\\n+\tfixed = true; \\\n+      } \\\n   } while (0)\n \n /* Ensure that TT isn't a replacable var of function decl.  */\n@@ -3151,6 +3174,9 @@ static void\n lto_fixup_prevailing_decls (tree t)\n {\n   enum tree_code code = TREE_CODE (t);\n+  bool fixed = false;\n+\n+  gcc_checking_assert (code != CONSTRUCTOR && code != TREE_BINFO);\n   LTO_NO_PREVAIL (TREE_TYPE (t));\n   if (CODE_CONTAINS_STRUCT (code, TS_COMMON))\n     LTO_NO_PREVAIL (TREE_CHAIN (t));\n@@ -3198,7 +3224,7 @@ lto_fixup_prevailing_decls (tree t)\n \n       LTO_SET_PREVAIL (TYPE_MINVAL (t));\n       LTO_SET_PREVAIL (TYPE_MAXVAL (t));\n-      LTO_SET_PREVAIL (t->type_non_common.binfo);\n+      LTO_NO_PREVAIL (t->type_non_common.binfo);\n \n       LTO_SET_PREVAIL (TYPE_CONTEXT (t));\n \n@@ -3219,11 +3245,15 @@ lto_fixup_prevailing_decls (tree t)\n \tcase TREE_LIST:\n \t  LTO_SET_PREVAIL (TREE_VALUE (t));\n \t  LTO_SET_PREVAIL (TREE_PURPOSE (t));\n+\t  LTO_NO_PREVAIL (TREE_PURPOSE (t));\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n     }\n+  /* If we fixed nothing, then we missed something seen by\n+     mentions_vars_p.  */\n+  gcc_checking_assert (fixed);\n }\n #undef LTO_SET_PREVAIL\n #undef LTO_NO_PREVAIL\n@@ -3246,7 +3276,8 @@ lto_fixup_state (struct lto_in_decl_state *state)\n       for (i = 0; i < table->size; i++)\n \t{\n \t  tree *tp = table->trees + i;\n-\t  if (VAR_OR_FUNCTION_DECL_P (*tp))\n+\t  if (VAR_OR_FUNCTION_DECL_P (*tp)\n+\t      && (TREE_PUBLIC (*tp) || DECL_EXTERNAL (*tp)))\n \t    *tp = lto_symtab_prevailing_decl (*tp);\n \t}\n     }\n@@ -3270,11 +3301,11 @@ static void\n lto_fixup_decls (struct lto_file_decl_data **files)\n {\n   unsigned int i;\n-  htab_iterator hi;\n   tree t;\n \n-  FOR_EACH_HTAB_ELEMENT (tree_with_vars, t, tree, hi)\n-    lto_fixup_prevailing_decls (t);\n+  if (tree_with_vars)\n+    FOR_EACH_VEC_ELT ((*tree_with_vars), i, t)\n+      lto_fixup_prevailing_decls (t);\n \n   for (i = 0; files[i]; i++)\n     {\n@@ -3364,8 +3395,6 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n     }\n   cgraph_state = CGRAPH_LTO_STREAMING;\n \n-  tree_with_vars = htab_create_ggc (101, htab_hash_pointer, htab_eq_pointer,\n-\t\t\t\t    NULL);\n   type_hash_cache = htab_create_ggc (512, tree_int_map_hash,\n \t\t\t\t     tree_int_map_eq, NULL);\n   type_pair_cache = XCNEWVEC (struct type_pair_d, GIMPLE_TYPE_PAIR_SIZE);\n@@ -3481,7 +3510,8 @@ read_cgraph_and_symbols (unsigned nfiles, const char **fnames)\n       /* Fixup all decls.  */\n       lto_fixup_decls (all_file_decl_data);\n     }\n-  htab_delete (tree_with_vars);\n+  if (tree_with_vars)\n+    ggc_free (tree_with_vars);\n   tree_with_vars = NULL;\n   ggc_collect ();\n "}]}