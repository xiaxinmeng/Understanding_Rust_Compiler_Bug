{"sha": "a1c9f779f75283427316b5c670c1e01ff8ce9ced", "node_id": "C_kwDOANBUbNoAKGExYzlmNzc5Zjc1MjgzNDI3MzE2YjVjNjcwYzFlMDFmZjhjZTljZWQ", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-11-22T12:54:20Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-05-25T08:37:13Z"}, "message": "Add GIMPLE switch support to loop unswitching\n\nThis patch adds support to unswitch loops with switch statements\nbased on invariant index.  It furthermore reworks the cost model\nto allow an overall budget of statements to be created per original\nloop by all unswitching opportunities in the loop.  Compared to\nthe original all unswitching opportunities in a loop are\npre-evaluated before the first transform which will allow future\nchanges to select the most profitable candidates first.\n\nTo efficiently support switch statements the pass now uses\nranger to simplify switch statements and conditions in loop\ncopies based on ranges extracted from the recorded set of\npredicates unswitched.\n\ngcc/ChangeLog:\n\n\t* dbgcnt.def (DEBUG_COUNTER): Add loop_unswitch counter.\n\t* params.opt (max-unswitch-level): Remove.\n\t* doc/invoke.texi (max-unswitch-level): Likewise.\n\t* tree-cfg.cc (gimple_lv_add_condition_to_bb): Support not\n\tgimplified expressions.\n\t* tree-ssa-loop-unswitch.cc (struct unswitch_predicate): New.\n\t(tree_may_unswitch_on): Rename to ...\n\t(find_unswitching_predicates_for_bb): ... this and handle\n\tswitch statements.\n\t(get_predicates_for_bb): Likewise.\n\t(set_predicates_for_bb): Likewise.\n\t(init_loop_unswitch_info): Likewise.\n\t(tree_ssa_unswitch_loops): Prepare stuff before calling\n\ttree_unswitch_single_loop.\n\t(tree_unswitch_single_loop): Rework the function using\n\tpre-computed predicates and with a per original loop cost model.\n\t(merge_last): New.\n\t(add_predicate_to_path): Likewise.\n\t(find_range_for_lhs): Likewise.\n\t(simplify_using_entry_checks): Rename to ...\n\t(evaluate_control_stmt_using_entry_checks): ... this, handle\n\tswitch statements and improve simplifications using ranger.\n\t(simplify_loop_version): Rework using\n\tevaluate_control_stmt_using_entry_checks.\n\t(evaluate_bbs): New.\n\t(evaluate_loop_insns_for_predicate): Likewise.\n\t(tree_unswitch_loop): Adjust to allow switch statements and\n\tpass in the edge to unswitch.\n\t(clean_up_after_unswitching): New.\n\t(pass_tree_unswitch::execute): Pass down fun.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.dg/loop-unswitch-7.c: New test.\n\t* gcc.dg/loop-unswitch-8.c: New test.\n\t* gcc.dg/loop-unswitch-9.c: New test.\n\t* gcc.dg/loop-unswitch-10.c: New test.\n\t* gcc.dg/loop-unswitch-11.c: New test.\n\t* gcc.dg/loop-unswitch-12.c: New test.\n\t* gcc.dg/loop-unswitch-13.c: New test.\n\t* gcc.dg/loop-unswitch-14.c: New test.\n\t* gcc.dg/loop-unswitch-15.c: New test.\n\t* gcc.dg/loop-unswitch-16.c: New test.\n\t* gcc.dg/loop-unswitch-17.c: New test.\n\t* gcc.dg/torture/20220518-1.c: New test.\n\t* gcc.dg/torture/20220518-2.c: New test.\n\t* gcc.dg/torture/20220525-1.c: New test.\n\t* gcc.dg/alias-10.c: Adjust.\n\t* gcc.dg/tree-ssa/loop-6.c: Likewise.\n\t* gcc.dg/loop-unswitch-1.c: Likewise.\n\nCo-authored-by: Richard Biener  <rguenther@suse.de>", "tree": {"sha": "3b23452070d3fa5c671287b3796721451c71356e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b23452070d3fa5c671287b3796721451c71356e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a1c9f779f75283427316b5c670c1e01ff8ce9ced", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c9f779f75283427316b5c670c1e01ff8ce9ced", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1c9f779f75283427316b5c670c1e01ff8ce9ced", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1c9f779f75283427316b5c670c1e01ff8ce9ced/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0d344b557604e966dc7f91739881f03e1f221efd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d344b557604e966dc7f91739881f03e1f221efd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d344b557604e966dc7f91739881f03e1f221efd"}], "stats": {"total": 1540, "additions": 1288, "deletions": 252}, "files": [{"sha": "365d5cbc6b85e79ace250aed312f2c88d3a01df5", "filename": "gcc/dbgcnt.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fdbgcnt.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fdbgcnt.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbgcnt.def?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -187,6 +187,7 @@ DEBUG_COUNTER (ira_move)\n DEBUG_COUNTER (ivopts_loop)\n DEBUG_COUNTER (lim)\n DEBUG_COUNTER (local_alloc_for_sched)\n+DEBUG_COUNTER (loop_unswitch)\n DEBUG_COUNTER (match)\n DEBUG_COUNTER (merged_ipa_icf)\n DEBUG_COUNTER (phiopt_edge_range)"}, {"sha": "12f834ff01d0e190819110432f778bdb375f324f", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -14204,9 +14204,6 @@ The maximum depth of a loop nest suitable for complete peeling.\n @item max-unswitch-insns\n The maximum number of insns of an unswitched loop.\n \n-@item max-unswitch-level\n-The maximum number of branches unswitched in a single loop.\n-\n @item lim-expensive\n The minimum cost of an expensive expression in the loop invariant motion.\n "}, {"sha": "bcf1423671ae3234dbd15d5439da119628acc567", "filename": "gcc/params.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fparams.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Fparams.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.opt?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -745,10 +745,6 @@ The maximum number of instructions to consider to unroll in a loop.\n Common Joined UInteger Var(param_max_unswitch_insns) Init(50) Param Optimization\n The maximum number of insns of an unswitched loop.\n \n--param=max-unswitch-level=\n-Common Joined UInteger Var(param_max_unswitch_level) Init(3) Param Optimization\n-The maximum number of unswitchings in a single loop.\n-\n -param=max-variable-expansions-in-unroller=\n Common Joined UInteger Var(param_max_variable_expansions) Init(1) Param Optimization\n If -fvariable-expansion-in-unroller is used, the maximum number of times that an individual variable will be expanded during loop unrolling."}, {"sha": "8472d30a6ae5fb3ae960fa2e7342667d198bdc9a", "filename": "gcc/testsuite/gcc.dg/alias-10.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Falias-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Falias-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Falias-10.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -28,4 +28,4 @@ void foo (bitmap head, bitmap_element *elt)\n }\n \n \n-/* { dg-final { scan-tree-dump-times \"Unswitching\" 1 \"unswitch\"} } */\n+/* { dg-final { scan-tree-dump-times \"unswitching\" 1 \"unswitch\"} } */"}, {"sha": "196cb64735e7c3f0e4b393ceb2a69bc1b08fd5c9", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-1.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -33,4 +33,4 @@ parse_tag: ;\n }\n \n /* Test that we actually unswitched something.  */\n-/* { dg-final { scan-tree-dump \"Unswitching loop\" \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump \"unswitching loop\" \"unswitch\" } } */"}, {"sha": "5e4f16e2935fd225101e322e013fafdbadae7a25", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-10.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-10.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,56 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+__attribute__((noipa))\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp, tmp2;\n+\n+    switch(order)\n+    {\n+      case 0:\n+        tmp = -8 * a[i];\n+        tmp2 = 2 * b[i];\n+        break;\n+      case 1: \n+        tmp = 3 * a[i] -  2 * b[i];\n+        tmp2 = 5 * b[i] - 2 * c[i];\n+        break;\n+      case 2:\n+        tmp = 9 * a[i] +  2 * b[i] + c[i];\n+        tmp2 = 4 * b[i] + 2 * c[i] + 8 * d[i];\n+        break;\n+      case 3:\n+        tmp = 3 * a[i] +  2 * b[i] - c[i];\n+        tmp2 = b[i] - 2 * c[i] + 8 * d[i];\n+        break;\n+      defaut:\n+        __builtin_unreachable ();\n+    }\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+    double y = 3.4f * tmp + d[i] + tmp2;\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+#define N 16 * 1024\n+double aa[N], bb[N], cc[N], dd[N], rr[N];\n+\n+int main()\n+{\n+  for (int i = 0; i < 100 * 1000; i++)\n+    foo (aa, bb, cc, dd, rr, N, i % 4);\n+}\n+\n+\n+/* Test that we actually unswitched something.  */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 0\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 1\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 2\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 3\" 1 \"unswitch\" } } */"}, {"sha": "04da28c076263b72c8ad7c6a4b7448297aafdd2c", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-11.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-11.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp, tmp2;\n+\n+    switch(order)\n+    {\n+      case 5 ... 6:\n+      case 9:\n+        tmp = -8 * a[i];\n+        tmp2 = 2 * b[i];\n+        break;\n+      case 11: \n+        tmp = 3 * a[i] -  2 * b[i];\n+        tmp2 = 5 * b[i] - 2 * c[i];\n+        break;\n+      case 22:\n+        tmp = 9 * a[i] +  2 * b[i] + c[i];\n+        tmp2 = 4 * b[i] + 2 * c[i] + 8 * d[i];\n+        break;\n+      case 33:\n+        tmp = 3 * a[i] +  2 * b[i] - c[i];\n+        tmp2 = b[i] - 2 * c[i] + 8 * d[i];\n+        break;\n+      defaut:\n+        __builtin_unreachable ();\n+    }\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+    double y = 3.4f * tmp + d[i] + tmp2;\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* \\\\+ 4294967291.*order.* == 9\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 1\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 2\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 3\" 1 \"unswitch\" } } */"}, {"sha": "052c456846c3abc3f6b0f6db5d67ebe49b775439", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-12.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-12.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp;\n+\n+    if (order == 1)\n+      tmp = -8 * a[i];\n+    else\n+      tmp = -4 * b[i];\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+\n+    if (order == 1)\n+      x += 2;\n+\n+    double y = 3.4f * tmp + d[i];\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .if. with condition: order.* == 1\" 1 \"unswitch\" } } */"}, {"sha": "d09c4aabc4ed7a4d1dc8a0403e05d075146bbed4", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-13.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-13.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fno-thread-jumps -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, unsigned order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp;\n+\n+    switch (order)\n+      {\n+      case 0 ... 4:\n+\ttmp = -8 * a[i];\n+\tbreak;\n+      default:\n+\ttmp = -4 * b[i];\n+\tbreak;\n+      }\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+\n+    /* This and the case 0 ... 4 condition should only be unswitched once\n+       since they are mutually excluded.  */\n+    if (order >= 5)\n+      x += 2;\n+\n+    double y = 3.4f * tmp + d[i];\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .\\[^\\n\\r\\]*. with condition\" 1 \"unswitch\" } } */"}, {"sha": "129805eb91801636f5c324dc0f7a938a1bc22442", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-14.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-14.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized --param=max-unswitch-insns=1000\" } */\n+\n+int\n+__attribute__((noipa))\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp, tmp2;\n+\n+    if (order <= 0)\n+      tmp = 123;\n+\n+    switch(order)\n+    {\n+      case 0:\n+        tmp += -8 * a[i];\n+        tmp2 = 2 * b[i];\n+        break;\n+      case 1: \n+        tmp = 3 * a[i] -  2 * b[i];\n+        tmp2 = 5 * b[i] - 2 * c[i];\n+        break;\n+      case 2:\n+        tmp = 9 * a[i] +  2 * b[i] + c[i];\n+        tmp2 = 4 * b[i] + 2 * c[i] + 8 * d[i];\n+        break;\n+      case 3:\n+        tmp = 3 * a[i] +  2 * b[i] - c[i];\n+        tmp2 = b[i] - 2 * c[i] + 8 * d[i];\n+        break;\n+      defaut:\n+        __builtin_unreachable ();\n+    }\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+    double y = 3.4f * tmp + d[i] + tmp2;\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+#define N 16 * 1024\n+double aa[N], bb[N], cc[N], dd[N], rr[N];\n+\n+int main()\n+{\n+  for (int i = 0; i < 100 * 1000; i++)\n+    foo (aa, bb, cc, dd, rr, N, i % 4);\n+}\n+\n+\n+/* Test that we actually unswitched something.  */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* <= 0\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 0\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 1\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 2\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .switch. with condition: order.* == 3\" 1 \"unswitch\" } } */"}, {"sha": "87139bb333439208a870afc8c5bbbfbaacd4685b", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-15.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-15.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+void bar();\n+void baz();\n+void foo (int a, int b, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    if (a < b)\n+      bar ();\n+    else\n+      baz ();\n+}\n+\n+/* { dg-final { scan-tree-dump \"unswitching loop . on .if. with condition:\" \"unswitch\" } } */"}, {"sha": "4b0b40015ace4e57d86b740daa1b5e6c04efbdc7", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-16.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-16.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized --param max-unswitch-insns=100\" } */\n+\n+void bar (int);\n+void foo (int a, int b, int c, int n)\n+{\n+  for (int i = 0; i < n; ++i)\n+    {\n+      if (a > 5)\n+        bar (1);\n+      if (b < 10)\n+        bar (2);\n+      if (c != 5)\n+        bar (3);\n+    }\n+}\n+\n+/* Verify we can unswitch all permutations of the predicates.  */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .if. with condition\" 7 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump \"unswitching loop . on .if. with condition: a\" \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump \"unswitching loop . on .if. with condition: b\" \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump \"unswitching loop . on .if. with condition: c\" \"unswitch\" } } */"}, {"sha": "8655e09a51c2f8cb86e2f240fc28985b674f129d", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-17.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-17.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int foo (int a)\n+{\n+  do\n+    {\n+      if (a == 1)\n+        return 0;\n+      switch (a)\n+        {\n+        case 1:\n+          return 5;\n+        case 2:\n+          return 7;\n+        case 3:\n+          return 11;\n+        default:;\n+        }\n+    }\n+  while (1);\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop\" 3 \"unswitch\" } } */"}, {"sha": "db2f93096cb3bea82935f0f02dcde516ea954f13", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-7.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-7.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fno-thread-jumps -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, float order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp;\n+\n+    if (order == 1.f)\n+      tmp = -8 * a[i];\n+    else\n+      tmp = -4 * b[i];\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+\n+    if (order == 1.f)\n+      x += 2;\n+\n+    double y = 3.4f * tmp + d[i];\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .if. with condition: order.* == 1.0e\" 1 \"unswitch\" } } */"}, {"sha": "32796e9b7f808e83d50824138691a35086d8fe14", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-8.c", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-8.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,31 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp;\n+\n+    if (order < 3)\n+      tmp = -8 * a[i];\n+    else\n+      tmp = -4 * b[i];\n+\n+    double x = 3 * tmp + d[i] + tmp;\n+\n+    if (5 > order)\n+      x += 2;\n+\n+    if (order == 12345)\n+      x *= 5;\n+\n+    double y = 3.4f * tmp + d[i];\n+    r[i] = x + y;\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .if. with condition: order\" 3 \"unswitch\" } } */"}, {"sha": "5e50b078bba180d5c950ae62a53495bc1c348e4f", "filename": "gcc/testsuite/gcc.dg/loop-unswitch-9.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Floop-unswitch-9.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -funswitch-loops -fdump-tree-unswitch-optimized\" } */\n+\n+int\n+foo(double *a, double *b, double *c, double *d, double *r, int size, int order)\n+{\n+  for (int i = 0; i < size; i++)\n+  {\n+    double tmp;\n+\n+    if (order == 1)\n+      tmp = -8 * a[i];\n+    else\n+      {\n+\tif (order == 2)\n+\t  tmp = -4 * b[i];\n+\telse\n+\t  tmp = a[i];\n+      }\n+\n+    r[i] = 3.4f * tmp + d[i];\n+  }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"unswitching loop . on .if. with condition: order\" 2 \"unswitch\" } } */"}, {"sha": "1822aee61519837baca11904b25a42ff93b70312", "filename": "gcc/testsuite/gcc.dg/torture/20220518-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-1.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-funswitch-loops\" } */\n+\n+enum {\n+  MOD_WVG_MASK_TEX_USE_INT,\n+  MOD_WVG_MASK_TEX_USE_RED,\n+  MOD_WVG_MASK_TEX_USE_BLUE,\n+  MOD_WVG_MASK_TEX_USE_SAT,\n+  MOD_WVG_MASK_TEX_USE_VAL,\n+  MOD_WVG_MASK_TEX_USE_ALPHA\n+} foo_num;\n+float *foo_org_w;\n+int *foo_new_w;\n+float foo_fact;\n+int foo_tex_use_channel, foo_i, foo_texres_0;\n+void foo()\n+{\n+  for (; foo_num;)\n+    switch (foo_tex_use_channel) {\n+    case MOD_WVG_MASK_TEX_USE_INT:\n+      foo_org_w[foo_i] = foo_new_w[foo_i] * foo_texres_0;\n+      break;\n+    case MOD_WVG_MASK_TEX_USE_RED:\n+      foo_org_w[foo_i] = 0;\n+    case MOD_WVG_MASK_TEX_USE_BLUE:\n+      foo_org_w[foo_i] = foo_fact + foo_org_w[foo_i];\n+      break;\n+    case MOD_WVG_MASK_TEX_USE_SAT:\n+      foo_org_w[foo_i] = foo_fact;\n+      break;\n+    case MOD_WVG_MASK_TEX_USE_VAL:\n+      foo_org_w[foo_i] = 0;\n+    case MOD_WVG_MASK_TEX_USE_ALPHA:\n+      foo_org_w[foo_i] = foo_fact + foo_org_w[foo_i];\n+      break;\n+    default:\n+      foo_org_w[foo_i] = foo_new_w[foo_i] * foo_texres_0;\n+    }\n+}"}, {"sha": "af70d7f66344a6e02cd423ea24c266e045710bb2", "filename": "gcc/testsuite/gcc.dg/torture/20220518-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220518-2.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-funswitch-loops\" } */\n+\n+int Get_Spline_Val_sp_0, Get_Spline_Val_k;\n+double Get_Spline_Val_p, Get_Spline_Val_se_0_0_0;\n+double *Get_Spline_Val_v;\n+void Get_Spline_Val() {\n+  int i;\n+  for (;;)\n+    if (i > Get_Spline_Val_sp_0)\n+      Get_Spline_Val_k = Get_Spline_Val_se_0_0_0;\n+    else if (Get_Spline_Val_sp_0 == 1)\n+      Get_Spline_Val_v[Get_Spline_Val_k] = Get_Spline_Val_p;\n+}"}, {"sha": "55dad3140f7a0fafe6a34a54b715efa5aa6a0d0b", "filename": "gcc/testsuite/gcc.dg/torture/20220525-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220525-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220525-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2F20220525-1.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-funswitch-loops\" } */\n+\n+int LIST_1, mb_pred_b_d4x4spatial_dec_picture_l0_rFrame,\n+    mb_pred_b_d4x4spatial_dec_picture_l1_rFrame;\n+typedef struct {\n+    char ref_idx[2];\n+} PicMotionParams;\n+PicMotionParams mb_pred_b_d4x4spatial_dec_picture_mv_info;\n+int get_colocated_info_4x4___trans_tmp_1, get_colocated_info_4x4_list1_0;\n+int get_colocated_info_4x4()\n+{\n+  int moving =\n+      get_colocated_info_4x4_list1_0 && get_colocated_info_4x4___trans_tmp_1;\n+  return moving;\n+}\n+void mb_pred_b_d4x4spatial_dec_picture()\n+{\n+  char k;\n+  for (;;)\n+    {\n+      k = 0;\n+      for (; k < 4; k++)\n+        if (mb_pred_b_d4x4spatial_dec_picture_l0_rFrame\n+            || mb_pred_b_d4x4spatial_dec_picture_l1_rFrame == 0)\n+          {\n+            int is_not_moving = get_colocated_info_4x4();\n+            if (mb_pred_b_d4x4spatial_dec_picture_l1_rFrame)\n+              if (is_not_moving)\n+                mb_pred_b_d4x4spatial_dec_picture_mv_info.ref_idx[LIST_1] = 1;\n+          }\n+    }\n+}"}, {"sha": "f9eb5c65ebe4263cb137d51c40af78b56924c9b4", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-6.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -19,7 +19,7 @@ void xxx(void)\n \n /* Loop should be unswitched.  */\n \n-/* { dg-final { scan-tree-dump-times \"Unswitching loop\" 1 \"unswitch\" } } */\n+/* { dg-final { scan-tree-dump-times \"unswitching loop\" 1 \"unswitch\" } } */\n \n /* In effect there should be exactly three conditional jumps in the final program.  */\n "}, {"sha": "8de1b144a426776bf464765477c71ee8f2e52b81", "filename": "gcc/tree-cfg.cc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftree-cfg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftree-cfg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.cc?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -9028,11 +9028,16 @@ gimple_lv_add_condition_to_bb (basic_block first_head ATTRIBUTE_UNUSED,\n   edge e0;\n \n   /* Build new conditional expr */\n+  gsi = gsi_last_bb (cond_bb);\n+\n+  cond_expr = force_gimple_operand_gsi_1 (&gsi, cond_expr,\n+\t\t\t\t\t  is_gimple_condexpr_for_cond,\n+\t\t\t\t\t  NULL_TREE, false,\n+\t\t\t\t\t  GSI_CONTINUE_LINKING);\n   new_cond_expr = gimple_build_cond_from_tree (cond_expr,\n \t\t\t\t\t       NULL_TREE, NULL_TREE);\n \n   /* Add new cond in cond_bb.  */\n-  gsi = gsi_last_bb (cond_bb);\n   gsi_insert_after (&gsi, new_cond_expr, GSI_NEW_STMT);\n \n   /* Adjust edges appropriately to connect new head with first head"}, {"sha": "f32f1a78f00f741f8c019d4be53f41e3916e359d", "filename": "gcc/tree-ssa-loop-unswitch.cc", "status": "modified", "additions": 821, "deletions": 241, "changes": 1062, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftree-ssa-loop-unswitch.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a1c9f779f75283427316b5c670c1e01ff8ce9ced/gcc%2Ftree-ssa-loop-unswitch.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.cc?ref=a1c9f779f75283427316b5c670c1e01ff8ce9ced", "patch": "@@ -38,6 +38,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfghooks.h\"\n #include \"tree-ssa-loop-manip.h\"\n #include \"tree-vectorizer.h\"\n+#include \"tree-pretty-print.h\"\n+#include \"gimple-range.h\"\n+#include \"dbgcnt.h\"\n+#include \"cfganal.h\"\n \n /* This file implements the loop unswitching, i.e. transformation of loops like\n \n@@ -75,9 +79,137 @@ along with GCC; see the file COPYING3.  If not see\n    tree-ssa-loop-im.cc ensures that all the suitable conditions are in this\n    shape.  */\n \n-static class loop *tree_unswitch_loop (class loop *, basic_block, tree);\n-static bool tree_unswitch_single_loop (class loop *, int);\n-static tree tree_may_unswitch_on (basic_block, class loop *);\n+/* Loop unswitching algorithm for innermost loops works in the following steps:\n+\n+   1) Number of instructions is estimated for each BB that belongs to a loop.\n+   2) Unswitching candidates are found for gcond and gswitch statements\n+      (note that an unswitching predicate for a gswitch actually corresponds\n+       to a non-default edge so it can contain multiple cases).\n+   3) The so called unswitch predicates are stored in a cache where the\n+      gimple_uid of the last stmt in a basic-block is an index to the cache.\n+   4) We consider one by one the unswitching candidates and calculate BBs that\n+      will be reachable in the unswitch version.\n+   5) A selected predicate is chosen and we simplify the CFG (dead edges) in\n+      both versions of the loop.  We utilize both Ranger for condition\n+      simplification and also symbol equivalence.  The folded if conditions\n+      are replaced with true/false values, while for gswitch we mark the\n+      corresponding edges with a pass-defined unreachable flag.\n+   6) Every time we unswitch a loop, we save unswitch_predicate to a vector\n+      together with information if true or false edge was taken.  Doing that\n+      we have a so called PREDICATE_PATH that is utilized for simplification\n+      of the cloned loop.\n+   7) The process is repeated until we reach a growth threshold or all\n+      unswitching opportunities are taken.  */\n+\n+/* A tuple that holds a GENERIC condition and value range for an unswitching\n+   predicate.  */\n+\n+struct unswitch_predicate\n+{\n+  /* CTOR for a switch edge predicate.  */\n+  unswitch_predicate (tree cond, tree lhs_, int edge_index_, edge e,\n+\t\t      const int_range_max& edge_range)\n+    : condition (cond), lhs (lhs_),\n+      true_range (edge_range), edge_index (edge_index_), switch_p (true)\n+  {\n+    gcc_assert (!(e->flags & (EDGE_TRUE_VALUE|EDGE_FALSE_VALUE))\n+\t\t&& irange::supports_type_p (TREE_TYPE (lhs)));\n+    false_range = true_range;\n+    if (!false_range.varying_p ()\n+\t&& !false_range.undefined_p ())\n+      false_range.invert ();\n+    num = predicates->length ();\n+    predicates->safe_push (this);\n+  }\n+\n+  /* CTOR for a GIMPLE condition statement.  */\n+  unswitch_predicate (gcond *stmt)\n+    : switch_p (false)\n+  {\n+    if (EDGE_SUCC (gimple_bb (stmt), 0)->flags & EDGE_TRUE_VALUE)\n+      edge_index = 0;\n+    else\n+      edge_index = 1;\n+    lhs = gimple_cond_lhs (stmt);\n+    tree rhs = gimple_cond_rhs (stmt);\n+    enum tree_code code = gimple_cond_code (stmt);\n+    condition = build2 (code, boolean_type_node, lhs, rhs);\n+    if (irange::supports_type_p (TREE_TYPE (lhs)))\n+      {\n+\tauto range_op = range_op_handler (code, TREE_TYPE (lhs));\n+\tint_range<2> rhs_range (TREE_TYPE (rhs));\n+\tif (CONSTANT_CLASS_P (rhs))\n+\t  rhs_range.set (rhs);\n+\tif (!range_op->op1_range (true_range, TREE_TYPE (lhs),\n+\t\t\t\t  int_range<2> (boolean_true_node,\n+\t\t\t\t\t\tboolean_true_node), rhs_range)\n+\t    || !range_op->op1_range (false_range, TREE_TYPE (lhs),\n+\t\t\t\t     int_range<2> (boolean_false_node,\n+\t\t\t\t\t\t   boolean_false_node),\n+\t\t\t\t     rhs_range))\n+\t  {\n+\t    true_range.set_varying (TREE_TYPE (lhs));\n+\t    false_range.set_varying (TREE_TYPE (lhs));\n+\t  }\n+      }\n+    num = predicates->length ();\n+    predicates->safe_push (this);\n+  }\n+\n+  /* Copy ranges for purpose of usage in predicate path.  */\n+\n+  inline void\n+  copy_merged_ranges ()\n+  {\n+    merged_true_range = true_range;\n+    merged_false_range = false_range;\n+  }\n+\n+  /* GENERIC unswitching expression testing LHS against CONSTANT.  */\n+  tree condition;\n+\n+  /* LHS of the expression.  */\n+  tree lhs;\n+\n+  /* Initial ranges (when the expression is true/false) for the expression.  */\n+  int_range_max true_range = {}, false_range = {};\n+\n+  /* Modified range that is part of a predicate path.  */\n+  int_range_max merged_true_range = {}, merged_false_range = {};\n+\n+  /* Index of the edge the predicate belongs to in the successor vector.  */\n+  int edge_index;\n+\n+  /* Whether the predicate was created from a switch statement.  */\n+  bool switch_p;\n+\n+  /* The number of the predicate in the predicates vector below.  */\n+  unsigned num;\n+\n+  /* Vector of all used predicates, used for assigning a unique id that\n+     can be used for bitmap operations.  */\n+  static vec<unswitch_predicate *> *predicates;\n+};\n+\n+vec<unswitch_predicate *> *unswitch_predicate::predicates;\n+\n+/* Ranger instance used in the pass.  */\n+static gimple_ranger *ranger = NULL;\n+\n+/* Cache storage for unswitch_predicate belonging to a basic block.  */\n+static vec<vec<unswitch_predicate *>> *bb_predicates;\n+\n+/* The type represents a predicate path leading to a basic block.  */\n+typedef vec<std::pair<unswitch_predicate *, bool>> predicate_vector;\n+\n+static class loop *tree_unswitch_loop (class loop *, edge, tree);\n+static bool tree_unswitch_single_loop (class loop *, dump_user_location_t,\n+\t\t\t\t       predicate_vector &predicate_path,\n+\t\t\t\t       unsigned loop_size, unsigned &budget,\n+\t\t\t\t       int ignored_edge_flag, bitmap);\n+static void\n+find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n+\t\t\t\t    vec<unswitch_predicate *> &candidates);\n static bool tree_unswitch_outer_loop (class loop *);\n static edge find_loop_guard (class loop *, vec<gimple *>&);\n static bool empty_bb_without_guard_p (class loop *, basic_block,\n@@ -86,26 +218,154 @@ static bool used_outside_loop_p (class loop *, tree, vec<gimple *>&);\n static void hoist_guard (class loop *, edge);\n static bool check_exit_phi (class loop *);\n static tree get_vop_from_header (class loop *);\n+static void clean_up_after_unswitching (int);\n+\n+/* Return vector of predicates that belong to a basic block.  */\n+\n+static vec<unswitch_predicate *> &\n+get_predicates_for_bb (basic_block bb)\n+{\n+  gimple *last = last_stmt (bb);\n+  return (*bb_predicates)[last == NULL ? 0 : gimple_uid (last)];\n+}\n+\n+/* Save predicates that belong to a basic block.  */\n+\n+static void\n+set_predicates_for_bb (basic_block bb, vec<unswitch_predicate *> predicates)\n+{\n+  gimple_set_uid (last_stmt (bb), bb_predicates->length ());\n+  bb_predicates->safe_push (predicates);\n+}\n+\n+/* Initialize LOOP information reused during the unswitching pass.\n+   Return total number of instructions in the loop.  */\n+\n+static unsigned\n+init_loop_unswitch_info (class loop *loop)\n+{\n+  unsigned total_insns = 0;\n+\n+  /* Calculate instruction count.  */\n+  basic_block *bbs = get_loop_body (loop);\n+  for (unsigned i = 0; i < loop->num_nodes; i++)\n+    {\n+      unsigned insns = 0;\n+      for (gimple_stmt_iterator gsi = gsi_start_bb (bbs[i]); !gsi_end_p (gsi);\n+\t   gsi_next (&gsi))\n+\tinsns += estimate_num_insns (gsi_stmt (gsi), &eni_size_weights);\n+\n+      bbs[i]->aux = (void *)(uintptr_t)insns;\n+      total_insns += insns;\n+    }\n+\n+  /* Find all unswitching candidates.  */\n+  for (unsigned i = 0; i != loop->num_nodes; i++)\n+    {\n+      /* Find a bb to unswitch on.  */\n+      vec<unswitch_predicate *> candidates;\n+      candidates.create (1);\n+      find_unswitching_predicates_for_bb (bbs[i], loop, candidates);\n+      if (!candidates.is_empty ())\n+\tset_predicates_for_bb (bbs[i], candidates);\n+      else\n+\t{\n+\t  candidates.release ();\n+\t  gimple *last = last_stmt (bbs[i]);\n+\t  if (last != NULL)\n+\t    gimple_set_uid (last, 0);\n+\t}\n+    }\n+\n+  free (bbs);\n+\n+  return total_insns;\n+}\n \n /* Main entry point.  Perform loop unswitching on all suitable loops.  */\n \n unsigned int\n-tree_ssa_unswitch_loops (void)\n+tree_ssa_unswitch_loops (function *fun)\n {\n-  bool changed = false;\n+  bool changed_unswitch = false;\n+  bool changed_hoist = false;\n+  auto_edge_flag ignored_edge_flag (fun);\n+\n+  ranger = enable_ranger (fun);\n \n   /* Go through all loops starting from innermost.  */\n-  for (auto loop : loops_list (cfun, LI_FROM_INNERMOST))\n+  for (auto loop : loops_list (fun, LI_FROM_INNERMOST))\n     {\n       if (!loop->inner)\n-\t/* Unswitch innermost loop.  */\n-\tchanged |= tree_unswitch_single_loop (loop, 0);\n+\t{\n+\t  /* Perform initial tests if unswitch is eligible.  */\n+\t  dump_user_location_t loc = find_loop_location (loop);\n+\n+\t  /* Do not unswitch in cold regions. */\n+\t  if (optimize_loop_for_size_p (loop))\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, loc,\n+\t\t\t\t \"Not unswitching cold loops\\n\");\n+\t      continue;\n+\t    }\n+\n+\t  /* If the loop is not expected to iterate, there is no need\n+\t     for unswitching.  */\n+\t  HOST_WIDE_INT iterations = estimated_loop_iterations_int (loop);\n+\t  if (iterations < 0)\n+\t    iterations = likely_max_loop_iterations_int (loop);\n+\t  if (iterations >= 0 && iterations <= 1)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_NOTE, loc,\n+\t\t\t\t \"Not unswitching, loop is not expected\"\n+\t\t\t\t \" to iterate\\n\");\n+\t      continue;\n+\t    }\n+\n+\t  bb_predicates = new vec<vec<unswitch_predicate *>> ();\n+\t  bb_predicates->safe_push (vec<unswitch_predicate *> ());\n+\t  unswitch_predicate::predicates = new vec<unswitch_predicate *> ();\n+\n+\t  /* Unswitch innermost loop.  */\n+\t  unsigned int loop_size = init_loop_unswitch_info (loop);\n+\t  unsigned int budget = loop_size + param_max_unswitch_insns;\n+\n+\t  predicate_vector predicate_path;\n+\t  predicate_path.create (8);\n+\t  auto_bitmap handled;\n+\t  changed_unswitch\n+\t    |= tree_unswitch_single_loop (loop, loc, predicate_path,\n+\t\t\t\t\t  loop_size, budget,\n+\t\t\t\t\t  ignored_edge_flag, handled);\n+\t  predicate_path.release ();\n+\n+\t  for (auto predlist : bb_predicates)\n+\t    predlist.release ();\n+\t  bb_predicates->release ();\n+\t  delete bb_predicates;\n+\t  bb_predicates = NULL;\n+\n+\t  for (auto pred : unswitch_predicate::predicates)\n+\t    delete pred;\n+\t  unswitch_predicate::predicates->release ();\n+\t  delete unswitch_predicate::predicates;\n+\t  unswitch_predicate::predicates = NULL;\n+\t}\n       else\n-\tchanged |= tree_unswitch_outer_loop (loop);\n+\tchanged_hoist |= tree_unswitch_outer_loop (loop);\n     }\n \n-  if (changed)\n+  disable_ranger (fun);\n+  clear_aux_for_blocks ();\n+\n+  if (changed_unswitch)\n+    clean_up_after_unswitching (ignored_edge_flag);\n+\n+  if (changed_unswitch || changed_hoist)\n     return TODO_cleanup_cfg;\n+\n   return 0;\n }\n \n@@ -184,319 +444,588 @@ is_maybe_undefined (const tree name, gimple *stmt, class loop *loop)\n }\n \n /* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n-   basic blocks (for what it means see comments below).  */\n+   basic blocks (for what it means see comments below).\n+   All candidates all filled to the provided vector CANDIDATES.  */\n \n-static tree\n-tree_may_unswitch_on (basic_block bb, class loop *loop)\n+static void\n+find_unswitching_predicates_for_bb (basic_block bb, class loop *loop,\n+\t\t\t\t    vec<unswitch_predicate *> &candidates)\n {\n   gimple *last, *def;\n-  gcond *stmt;\n-  tree cond, use;\n+  tree use;\n   basic_block def_bb;\n   ssa_op_iter iter;\n \n   /* BB must end in a simple conditional jump.  */\n   last = last_stmt (bb);\n-  if (!last || gimple_code (last) != GIMPLE_COND)\n-    return NULL_TREE;\n-  stmt = as_a <gcond *> (last);\n-\n-  /* To keep the things simple, we do not directly remove the conditions,\n-     but just replace tests with 0 != 0 resp. 1 != 0.  Prevent the infinite\n-     loop where we would unswitch again on such a condition.  */\n-  if (gimple_cond_true_p (stmt) || gimple_cond_false_p (stmt))\n-    return NULL_TREE;\n-\n-  /* Condition must be invariant.  */\n-  FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+  if (!last)\n+    return;\n+\n+  if (gcond *stmt = safe_dyn_cast <gcond *> (last))\n     {\n-      def = SSA_NAME_DEF_STMT (use);\n+      /* To keep the things simple, we do not directly remove the conditions,\n+\t but just replace tests with 0 != 0 resp. 1 != 0.  Prevent the infinite\n+\t loop where we would unswitch again on such a condition.  */\n+      if (gimple_cond_true_p (stmt) || gimple_cond_false_p (stmt))\n+\treturn;\n+\n+      /* At least the LHS needs to be symbolic.  */\n+      if (TREE_CODE (gimple_cond_lhs (stmt)) != SSA_NAME)\n+\treturn;\n+\n+      /* Condition must be invariant.  */\n+      FOR_EACH_SSA_TREE_OPERAND (use, stmt, iter, SSA_OP_USE)\n+\t{\n+\t  def = SSA_NAME_DEF_STMT (use);\n+\t  def_bb = gimple_bb (def);\n+\t  if (def_bb\n+\t      && flow_bb_inside_loop_p (loop, def_bb))\n+\t    return;\n+\t  /* Unswitching on undefined values would introduce undefined\n+\t     behavior that the original program might never exercise.  */\n+\t  if (is_maybe_undefined (use, stmt, loop))\n+\t    return;\n+\t}\n+\n+      unswitch_predicate *predicate = new unswitch_predicate (stmt);\n+      candidates.safe_push (predicate);\n+    }\n+  else if (gswitch *stmt = safe_dyn_cast <gswitch *> (last))\n+    {\n+      unsigned nlabels = gimple_switch_num_labels (stmt);\n+      tree idx = gimple_switch_index (stmt);\n+      if (TREE_CODE (idx) != SSA_NAME\n+\t  || nlabels < 1)\n+\treturn;\n+      /* Index must be invariant.  */\n+      def = SSA_NAME_DEF_STMT (idx);\n       def_bb = gimple_bb (def);\n       if (def_bb\n \t  && flow_bb_inside_loop_p (loop, def_bb))\n-\treturn NULL_TREE;\n+\treturn;\n       /* Unswitching on undefined values would introduce undefined\n \t behavior that the original program might never exercise.  */\n-      if (is_maybe_undefined (use, stmt, loop))\n-\treturn NULL_TREE;\n-    }\n+      if (is_maybe_undefined (idx, stmt, loop))\n+\treturn;\n+\n+      /* Build compound expression for all outgoing edges of the switch.  */\n+      auto_vec<tree, 16> preds;\n+      auto_vec<int_range_max> edge_range;\n+      preds.safe_grow_cleared (EDGE_COUNT (gimple_bb (stmt)->succs), true);\n+      edge_range.safe_grow_cleared (EDGE_COUNT (gimple_bb (stmt)->succs), true);\n+      edge e;\n+      edge_iterator ei;\n+      unsigned edge_index = 0;\n+      FOR_EACH_EDGE (e, ei, gimple_bb (stmt)->succs)\n+\te->aux = (void *)(uintptr_t)edge_index++;\n+      for (unsigned i = 1; i < gimple_switch_num_labels (stmt); ++i)\n+\t{\n+\t  tree lab = gimple_switch_label (stmt, i);\n+\t  tree cmp;\n+\t  int_range<2> lab_range;\n+\t  if (CASE_HIGH (lab) != NULL_TREE)\n+\t    {\n+\t      tree cmp1 = fold_build2 (GE_EXPR, boolean_type_node, idx,\n+\t\t\t\t       CASE_LOW (lab));\n+\t      tree cmp2 = fold_build2 (LE_EXPR, boolean_type_node, idx,\n+\t\t\t\t       CASE_HIGH (lab));\n+\t      cmp = fold_build2 (BIT_AND_EXPR, boolean_type_node, cmp1, cmp2);\n+\t      lab_range.set (CASE_LOW (lab), CASE_HIGH (lab));\n+\t    }\n+\t  else\n+\t    {\n+\t      cmp = fold_build2 (EQ_EXPR, boolean_type_node, idx,\n+\t\t\t\t CASE_LOW (lab));\n+\t      lab_range.set (CASE_LOW (lab));\n+\t    }\n \n-  cond = build2 (gimple_cond_code (stmt), boolean_type_node,\n-\t\t gimple_cond_lhs (stmt), gimple_cond_rhs (stmt));\n+\t  /* Combine the expression with the existing one.  */\n+\t  basic_block dest = label_to_block (cfun, CASE_LABEL (lab));\n+\t  e = find_edge (gimple_bb (stmt), dest);\n+\t  tree &expr = preds[(uintptr_t)e->aux];\n+\t  if (expr == NULL_TREE)\n+\t    expr = cmp;\n+\t  else\n+\t    expr = fold_build2 (BIT_IOR_EXPR, boolean_type_node, expr, cmp);\n+\t  edge_range[(uintptr_t)e->aux].union_ (lab_range);\n+\t}\n \n-  return cond;\n+      /* Now register the predicates.  */\n+      for (edge_index = 0; edge_index < preds.length (); ++edge_index)\n+\t{\n+\t  edge e = EDGE_SUCC (gimple_bb (stmt), edge_index);\n+\t  e->aux = NULL;\n+\t  if (preds[edge_index] != NULL_TREE)\n+\t    {\n+\t      unswitch_predicate *predicate\n+\t\t= new unswitch_predicate (preds[edge_index], idx,\n+\t\t\t\t\t  edge_index, e,\n+\t\t\t\t\t  edge_range[edge_index]);\n+\t      candidates.safe_push (predicate);\n+\t    }\n+\t}\n+    }\n }\n \n-/* Simplifies COND using checks in front of the entry of the LOOP.  Just very\n-   simplish (sufficient to prevent us from duplicating loop in unswitching\n-   unnecessarily).  */\n+/* Merge ranges for the last item of PREDICATE_PATH with a predicate\n+   that shared the same LHS.  */\n \n-static tree\n-simplify_using_entry_checks (class loop *loop, tree cond)\n+static void\n+merge_last (predicate_vector &predicate_path)\n {\n-  edge e = loop_preheader_edge (loop);\n-  gimple *stmt;\n+  unswitch_predicate *last_predicate = predicate_path.last ().first;\n \n-  while (1)\n+  for (int i = predicate_path.length () - 2; i >= 0; i--)\n     {\n-      stmt = last_stmt (e->src);\n-      if (stmt\n-\t  && gimple_code (stmt) == GIMPLE_COND\n-\t  && gimple_cond_code (stmt) == TREE_CODE (cond)\n-\t  && operand_equal_p (gimple_cond_lhs (stmt),\n-\t\t\t      TREE_OPERAND (cond, 0), 0)\n-\t  && operand_equal_p (gimple_cond_rhs (stmt),\n-\t\t\t      TREE_OPERAND (cond, 1), 0))\n-\treturn (e->flags & EDGE_TRUE_VALUE\n-\t\t? boolean_true_node\n-\t\t: boolean_false_node);\n-\n-      if (!single_pred_p (e->src))\n-\treturn cond;\n-\n-      e = single_pred_edge (e->src);\n-      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\treturn cond;\n+      unswitch_predicate *predicate = predicate_path[i].first;\n+      bool true_edge = predicate_path[i].second;\n+\n+      if (operand_equal_p (predicate->lhs, last_predicate->lhs, 0))\n+\t{\n+\t  irange &other = (true_edge ? predicate->merged_true_range\n+\t\t\t   : predicate->merged_false_range);\n+\t  last_predicate->merged_true_range.intersect (other);\n+\t  last_predicate->merged_false_range.intersect (other);\n+\t  return;\n+\t}\n     }\n }\n \n-/* Unswitch single LOOP.  NUM is number of unswitchings done; we do not allow\n-   it to grow too much, it is too easy to create example on that the code would\n-   grow exponentially.  */\n+/* Add PREDICATE to PREDICATE_PATH on TRUE_EDGE.  */\n \n-static bool\n-tree_unswitch_single_loop (class loop *loop, int num)\n+static void\n+add_predicate_to_path (predicate_vector &predicate_path,\n+\t\t       unswitch_predicate *predicate, bool true_edge)\n {\n-  basic_block *bbs;\n-  class loop *nloop;\n-  unsigned i, found;\n-  tree cond = NULL_TREE;\n-  gimple *stmt;\n-  bool changed = false;\n-  HOST_WIDE_INT iterations;\n-\n-  dump_user_location_t loc = find_loop_location (loop);\n+  predicate->copy_merged_ranges ();\n+  predicate_path.safe_push (std::make_pair (predicate, true_edge));\n+  merge_last (predicate_path);\n+}\n \n-  /* Perform initial tests if unswitch is eligible.  */\n-  if (num == 0)\n+static bool\n+find_range_for_lhs (predicate_vector &predicate_path, tree lhs,\n+\t\t    int_range_max &range)\n+{\n+  for (int i = predicate_path.length () - 1; i >= 0; i--)\n     {\n-      /* Do not unswitch in cold regions. */\n-      if (optimize_loop_for_size_p (loop))\n-\t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, loc,\n-\t\t\t     \"Not unswitching cold loops\\n\");\n-\t  return false;\n-\t}\n+      unswitch_predicate *predicate = predicate_path[i].first;\n+      bool true_edge = predicate_path[i].second;\n \n-      /* The loop should not be too large, to limit code growth. */\n-      if (tree_num_loop_insns (loop, &eni_size_weights)\n-\t  > (unsigned) param_max_unswitch_insns)\n+      if (operand_equal_p (predicate->lhs, lhs, 0))\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, loc,\n-\t\t\t     \"Not unswitching, loop too big\\n\");\n-\t  return false;\n+\t  range = (true_edge ? predicate->merged_true_range\n+\t\t   : predicate->merged_false_range);\n+\t  return !range.undefined_p ();\n \t}\n+    }\n \n-      /* If the loop is not expected to iterate, there is no need\n-\t for unswitching.  */\n-      iterations = estimated_loop_iterations_int (loop);\n-      if (iterations < 0)\n-        iterations = likely_max_loop_iterations_int (loop);\n-      if (iterations >= 0 && iterations <= 1)\n+  return false;\n+}\n+\n+/* Simplifies STMT using the predicate we unswitched on which is the last\n+   in PREDICATE_PATH.  For switch statements add newly unreachable edges\n+   to IGNORED_EDGES (but do not set IGNORED_EDGE_FLAG on them).  */\n+\n+static tree\n+evaluate_control_stmt_using_entry_checks (gimple *stmt,\n+\t\t\t\t\t  predicate_vector &predicate_path,\n+\t\t\t\t\t  int ignored_edge_flag,\n+\t\t\t\t\t  hash_set<edge> *ignored_edges)\n+{\n+  unswitch_predicate *last_predicate = predicate_path.last ().first;\n+  bool true_edge = predicate_path.last ().second;\n+\n+  if (gcond *cond = dyn_cast<gcond *> (stmt))\n+    {\n+      tree lhs = gimple_cond_lhs (cond);\n+      if (!operand_equal_p (lhs, last_predicate->lhs))\n+\treturn NULL_TREE;\n+      /* Try a symbolic match which works for floating point and fully\n+\t symbolic conditions.  */\n+      if (gimple_cond_code (cond) == TREE_CODE (last_predicate->condition)\n+\t  && operand_equal_p (gimple_cond_rhs (cond),\n+\t\t\t      TREE_OPERAND (last_predicate->condition, 1)))\n+\treturn true_edge ? boolean_true_node : boolean_false_node;\n+      /* Else try ranger if it supports LHS.  */\n+      else if (irange::supports_type_p (TREE_TYPE (lhs)))\n \t{\n-\t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, loc,\n-\t\t\t     \"Not unswitching, loop is not expected\"\n-\t\t\t     \" to iterate\\n\");\n-\t  return false;\n+\t  int_range<2> r;\n+\t  int_range_max path_range;\n+\n+\t  if (find_range_for_lhs (predicate_path, lhs, path_range)\n+\t      && fold_range (r, cond, path_range)\n+\t      && r.singleton_p ())\n+\t    return r.zero_p () ? boolean_false_node : boolean_true_node;\n \t}\n     }\n+  else if (gswitch *swtch = dyn_cast<gswitch *> (stmt))\n+    {\n+      unsigned nlabels = gimple_switch_num_labels (swtch);\n \n-  i = 0;\n-  bbs = get_loop_body (loop);\n-  found = loop->num_nodes;\n+      tree idx = gimple_switch_index (swtch);\n \n-  while (1)\n-    {\n-      /* Find a bb to unswitch on.  */\n-      for (; i < loop->num_nodes; i++)\n-\tif ((cond = tree_may_unswitch_on (bbs[i], loop)))\n-\t  break;\n+      /* Already folded switch.  */\n+      if (TREE_CONSTANT (idx))\n+\treturn NULL_TREE;\n \n-      if (i == loop->num_nodes)\n+      int_range_max path_range;\n+      if (!find_range_for_lhs (predicate_path, idx, path_range))\n+\treturn NULL_TREE;\n+\n+      tree result = NULL_TREE;\n+      edge single_edge = NULL;\n+      for (unsigned i = 0; i < nlabels; ++i)\n \t{\n-\t  if (dump_enabled_p ()\n-\t      && num > param_max_unswitch_level)\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, loc,\n-\t\t\t     \"Not unswitching anymore, hit max level\\n\");\n+\t  tree lab = gimple_switch_label (swtch, i);\n+\t  basic_block dest = label_to_block (cfun, CASE_LABEL (lab));\n+\t  edge e = find_edge (gimple_bb (stmt), dest);\n+\t  if (e->flags & ignored_edge_flag)\n+\t    continue;\n \n-\t  if (found == loop->num_nodes)\n+\t  int_range_max r;\n+\t  if (!ranger->gori ().outgoing_edge_range_p (r, e, idx,\n+\t\t\t\t\t\t      *get_global_range_query ()))\n+\t    continue;\n+\t  r.intersect (path_range);\n+\t  if (r.undefined_p ())\n+\t    ignored_edges->add (e);\n+\t  else\n \t    {\n-\t      free (bbs);\n-\t      return changed;\n+\t      if (!single_edge)\n+\t\t{\n+\t\t  single_edge = e;\n+\t\t  result = CASE_LOW (lab);\n+\t\t}\n+\t      else if (single_edge != e)\n+\t\tresult = NULL;\n \t    }\n-\t  break;\n \t}\n \n-      cond = simplify_using_entry_checks (loop, cond);\n-      stmt = last_stmt (bbs[i]);\n-      if (integer_nonzerop (cond))\n-\t{\n-\t  /* Remove false path.  */\n-\t  gimple_cond_set_condition_from_tree (as_a <gcond *> (stmt),\n-\t\t\t\t\t       boolean_true_node);\n-\t  changed = true;\n-\t}\n-      else if (integer_zerop (cond))\n+      /* Only one edge from the switch is alive.  */\n+      if (single_edge && result)\n+\treturn result;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Simplify LOOP based on PREDICATE_PATH where dead edges are properly\n+   marked.  */\n+\n+static bool\n+simplify_loop_version (class loop *loop, predicate_vector &predicate_path,\n+\t\t       int ignored_edge_flag, bitmap handled)\n+{\n+  bool changed = false;\n+  basic_block *bbs = get_loop_body (loop);\n+\n+  hash_set<edge> ignored_edges;\n+  for (unsigned i = 0; i != loop->num_nodes; i++)\n+    {\n+      vec<unswitch_predicate *> &predicates = get_predicates_for_bb (bbs[i]);\n+      if (predicates.is_empty ())\n+\tcontinue;\n+\n+      gimple *stmt = last_stmt (bbs[i]);\n+      tree folded = evaluate_control_stmt_using_entry_checks (stmt,\n+\t\t\t\t\t\t\t      predicate_path,\n+\t\t\t\t\t\t\t      ignored_edge_flag,\n+\t\t\t\t\t\t\t      &ignored_edges);\n+\n+      if (gcond *cond = dyn_cast<gcond *> (stmt))\n \t{\n-\t  /* Remove true path.  */\n-\t  gimple_cond_set_condition_from_tree (as_a <gcond *> (stmt),\n-\t\t\t\t\t       boolean_false_node);\n-\t  changed = true;\n+\t  if (folded)\n+\t    {\n+\t      /* Remove path.  */\n+\t      if (integer_nonzerop (folded))\n+\t\tgimple_cond_set_condition_from_tree (cond, boolean_true_node);\n+\t      else\n+\t\tgimple_cond_set_condition_from_tree (cond, boolean_false_node);\n+\n+\t      gcc_assert (predicates.length () == 1);\n+\t      bitmap_set_bit (handled, predicates[0]->num);\n+\n+\t      update_stmt (cond);\n+\t      changed = true;\n+\t    }\n \t}\n-      /* Do not unswitch too much.  */\n-      else if (num > param_max_unswitch_level)\n+      else if (gswitch *swtch = dyn_cast<gswitch *> (stmt))\n \t{\n-\t  i++;\n-\t  continue;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\t  FOR_EACH_EDGE (e, ei, bbs[i]->succs)\n+\t    if (ignored_edges.contains (e))\n+\t      e->flags |= ignored_edge_flag;\n+\n+\t  for (unsigned j = 0; j < predicates.length (); j++)\n+\t    {\n+\t      edge e = EDGE_SUCC (bbs[i], predicates[j]->edge_index);\n+\t      if (ignored_edges.contains (e))\n+\t\tbitmap_set_bit (handled, predicates[j]->num);\n+\t    }\n+\n+\t  if (folded)\n+\t    {\n+\t      gimple_switch_set_index (swtch, folded);\n+\t      update_stmt (swtch);\n+\t      changed = true;\n+\t    }\n \t}\n-      /* In nested tree_unswitch_single_loop first optimize all conditions\n-\t using entry checks, then discover still reachable blocks in the\n-\t loop and find the condition only among those still reachable bbs.  */\n-      else if (num != 0)\n+    }\n+\n+  free (bbs);\n+  return changed;\n+}\n+\n+/* Evaluate reachable blocks in LOOP and call VISIT on them, aborting the\n+   DFS walk if VISIT returns true.  When PREDICATE_PATH is specified then\n+   take into account that when computing reachability, otherwise just\n+   look at the simplified state and IGNORED_EDGE_FLAG.  */\n+\n+template <typename VisitOp>\n+static void\n+evaluate_bbs (class loop *loop, predicate_vector *predicate_path,\n+\t      int ignored_edge_flag, VisitOp visit)\n+{\n+  auto_bb_flag reachable_flag (cfun);\n+  auto_vec<basic_block, 10> worklist (loop->num_nodes);\n+  auto_vec<basic_block, 10> reachable (loop->num_nodes);\n+  hash_set<edge> ignored_edges;\n+\n+  loop->header->flags |= reachable_flag;\n+  worklist.quick_push (loop->header);\n+  reachable.safe_push (loop->header);\n+\n+  while (!worklist.is_empty ())\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      int flags = ignored_edge_flag;\n+      basic_block bb = worklist.pop ();\n+\n+      if (visit (bb))\n+\tbreak;\n+\n+      gimple *last = last_stmt (bb);\n+      if (gcond *cond = safe_dyn_cast <gcond *> (last))\n \t{\n-\t  if (found == loop->num_nodes)\n-\t    found = i;\n-\t  i++;\n-\t  continue;\n+\t  if (gimple_cond_true_p (cond))\n+\t    flags = EDGE_FALSE_VALUE;\n+\t  else if (gimple_cond_false_p (cond))\n+\t    flags = EDGE_TRUE_VALUE;\n+\t  else if (predicate_path)\n+\t    {\n+\t      tree res;\n+\t      if (!get_predicates_for_bb (bb).is_empty ()\n+\t\t  && (res = evaluate_control_stmt_using_entry_checks\n+\t\t\t      (cond, *predicate_path, ignored_edge_flag,\n+\t\t\t       &ignored_edges)))\n+\t\tflags = (integer_nonzerop (res)\n+\t\t\t ? EDGE_FALSE_VALUE : EDGE_TRUE_VALUE);\n+\t    }\n \t}\n-      else\n+      else if (gswitch *swtch = safe_dyn_cast<gswitch *> (last))\n+\tif (predicate_path\n+\t    && !get_predicates_for_bb (bb).is_empty ())\n+\t  evaluate_control_stmt_using_entry_checks (swtch, *predicate_path,\n+\t\t\t\t\t\t    ignored_edge_flag,\n+\t\t\t\t\t\t    &ignored_edges);\n+\n+      /* Note that for the moment we do not account reachable conditions\n+\t which are simplified to take a known edge as zero size nor\n+\t are we accounting for the required addition of the versioning\n+\t condition.  Those should cancel out conservatively.  */\n+\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n \t{\n-\t  found = i;\n-\t  break;\n-\t}\n+\t  basic_block dest = e->dest;\n \n-      update_stmt (stmt);\n-      i++;\n+\t  if (dest->loop_father == loop\n+\t      && !(dest->flags & reachable_flag)\n+\t      && !(e->flags & flags)\n+\t      && !ignored_edges.contains (e))\n+\t    {\n+\t      dest->flags |= reachable_flag;\n+\t      worklist.safe_push (dest);\n+\t      reachable.safe_push (dest);\n+\t    }\n+\t}\n     }\n \n-  if (num != 0)\n-    {\n-      basic_block *tos, *worklist;\n+  /* Clear the flag from basic blocks.  */\n+  while (!reachable.is_empty ())\n+    reachable.pop ()->flags &= ~reachable_flag;\n+}\n \n-      /* When called recursively, first do a quick discovery\n-\t of reachable bbs after the above changes and only\n-\t consider conditions in still reachable bbs.  */\n-      tos = worklist = XNEWVEC (basic_block, loop->num_nodes);\n+/* Evaluate how many instruction will we have if we unswitch LOOP (with BBS)\n+   based on PREDICATE predicate (using PREDICATE_PATH).  Store the\n+   result in TRUE_SIZE and FALSE_SIZE.  */\n \n-      for (i = 0; i < loop->num_nodes; i++)\n-\tbbs[i]->flags &= ~BB_REACHABLE;\n+static void\n+evaluate_loop_insns_for_predicate (class loop *loop,\n+\t\t\t\t   predicate_vector &predicate_path,\n+\t\t\t\t   unswitch_predicate *predicate,\n+\t\t\t\t   int ignored_edge_flag,\n+\t\t\t\t   unsigned *true_size, unsigned *false_size)\n+{\n+  unsigned size = 0;\n+  auto sum_size = [&](basic_block bb) -> bool\n+    { size += (uintptr_t)bb->aux; return false; };\n+\n+  add_predicate_to_path (predicate_path, predicate, true);\n+  evaluate_bbs (loop, &predicate_path, ignored_edge_flag, sum_size);\n+  predicate_path.pop ();\n+  unsigned true_loop_cost = size;\n+\n+  size = 0;\n+  add_predicate_to_path (predicate_path, predicate, false);\n+  evaluate_bbs (loop, &predicate_path, ignored_edge_flag, sum_size);\n+  predicate_path.pop ();\n+  unsigned false_loop_cost = size;\n+\n+  *true_size = true_loop_cost;\n+  *false_size = false_loop_cost;\n+}\n \n-      /* Start with marking header.  */\n-      *tos++ = bbs[0];\n-      bbs[0]->flags |= BB_REACHABLE;\n+/* Unswitch single LOOP.  PREDICATE_PATH contains so far used predicates\n+   for unswitching.  BUDGET is number of instruction for which we can increase\n+   the loop and is updated when unswitching occurs.  */\n \n-      /* Iterate: find everything reachable from what we've already seen\n-\t within the same innermost loop.  Don't look through false edges\n-\t if condition is always true or true edges if condition is\n-\t always false.  */\n-      while (tos != worklist)\n+static bool\n+tree_unswitch_single_loop (class loop *loop, dump_user_location_t loc,\n+\t\t\t   predicate_vector &predicate_path,\n+\t\t\t   unsigned loop_size, unsigned &budget,\n+\t\t\t   int ignored_edge_flag, bitmap handled)\n+{\n+  class loop *nloop;\n+  bool changed = false;\n+  unswitch_predicate *predicate = NULL;\n+  basic_block predicate_bb = NULL;\n+  unsigned true_size = 0, false_size = 0;\n+\n+  auto check_predicates = [&](basic_block bb) -> bool\n+    {\n+      for (auto pred : get_predicates_for_bb (bb))\n \t{\n-\t  basic_block b = *--tos;\n-\t  edge e;\n-\t  edge_iterator ei;\n-\t  int flags = 0;\n+\t  if (bitmap_bit_p (handled, pred->num))\n+\t    continue;\n \n-\t  if (EDGE_COUNT (b->succs) == 2)\n-\t    {\n-\t      gimple *stmt = last_stmt (b);\n-\t      if (stmt\n-\t\t  && gimple_code (stmt) == GIMPLE_COND)\n-\t\t{\n-\t\t  gcond *cond_stmt = as_a <gcond *> (stmt);\n-\t\t  if (gimple_cond_true_p (cond_stmt))\n-\t\t    flags = EDGE_FALSE_VALUE;\n-\t\t  else if (gimple_cond_false_p (cond_stmt))\n-\t\t    flags = EDGE_TRUE_VALUE;\n-\t\t}\n-\t    }\n+\t  evaluate_loop_insns_for_predicate (loop, predicate_path,\n+\t\t\t\t\t     pred, ignored_edge_flag,\n+\t\t\t\t\t     &true_size, &false_size);\n \n-\t  FOR_EACH_EDGE (e, ei, b->succs)\n+\t  /* We'll get LOOP replaced with a simplified version according\n+\t     to PRED estimated to TRUE_SIZE and a copy simplified\n+\t     according to the inverted PRED estimated to FALSE_SIZE.  */\n+\t  if (true_size + false_size < budget + loop_size)\n \t    {\n-\t      basic_block dest = e->dest;\n-\n-\t      if (dest->loop_father == loop\n-\t\t  && !(dest->flags & BB_REACHABLE)\n-\t\t  && !(e->flags & flags))\n-\t\t{\n-\t\t  *tos++ = dest;\n-\t\t  dest->flags |= BB_REACHABLE;\n-\t\t}\n+\t      predicate = pred;\n+\t      predicate_bb = bb;\n+\n+\t      /* There are cases where true_size and false_size add up to\n+\t\t less than the original loop_size.  We do not want to\n+\t\t grow the remaining budget because of that.  */\n+\t      if (true_size + false_size > loop_size)\n+\t\tbudget -= (true_size + false_size - loop_size);\n+\n+\t      /* FIXME: right now we select first candidate, but we can\n+\t\t choose the cheapest or hottest one.  */\n+\t      return true;\n \t    }\n+\t  else if (dump_enabled_p ())\n+\t    dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t     \"not unswitching condition, cost too big \"\n+\t\t\t     \"(%u insns copied to %u and %u)\\n\", loop_size,\n+\t\t\t     true_size, false_size);\n \t}\n+      return false;\n+    };\n+  /* Check predicates of reachable blocks.  */\n+  evaluate_bbs (loop, NULL, ignored_edge_flag, check_predicates);\n \n-      free (worklist);\n+  if (predicate != NULL)\n+    {\n+      if (!dbg_cnt (loop_unswitch))\n+\tgoto exit;\n \n-      /* Find a bb to unswitch on.  */\n-      for (; found < loop->num_nodes; found++)\n-\tif ((bbs[found]->flags & BB_REACHABLE)\n-\t    && (cond = tree_may_unswitch_on (bbs[found], loop)))\n-\t  break;\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n+\t\t\t   \"unswitching loop %d on %qs with condition: %T\\n\",\n+\t\t\t   loop->num, predicate->switch_p ? \"switch\" : \"if\",\n+\t\t\t   predicate->condition);\n+\t  dump_printf_loc (MSG_NOTE, loc,\n+\t\t\t   \"optimized sizes estimated to %u (true) \"\n+\t\t\t   \"and %u (false) from original size %u\\n\",\n+\t\t\t   true_size, false_size, loop_size);\n+\t}\n \n-      if (found == loop->num_nodes)\n+      bitmap_set_bit (handled, predicate->num);\n+      initialize_original_copy_tables ();\n+      /* Unswitch the loop on this condition.  */\n+      nloop = tree_unswitch_loop (loop, EDGE_SUCC (predicate_bb,\n+\t\t\t\t\t\t   predicate->edge_index),\n+\t\t\t\t  predicate->condition);\n+      if (!nloop)\n \t{\n-\t  free (bbs);\n-\t  return changed;\n+\t  free_original_copy_tables ();\n+\t  goto exit;\n \t}\n-    }\n \n-  if (dump_enabled_p ())\n-    dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, loc,\n-\t\t     \"Unswitching loop on condition: %G\\n\",\n-\t\t     last_stmt (bbs[found]));\n+      /* Copy BB costs.  */\n+      basic_block *bbs2 = get_loop_body (nloop);\n+      for (unsigned i = 0; i < nloop->num_nodes; i++)\n+\tbbs2[i]->aux = get_bb_original (bbs2[i])->aux;\n+      free (bbs2);\n \n-  initialize_original_copy_tables ();\n-  /* Unswitch the loop on this condition.  */\n-  nloop = tree_unswitch_loop (loop, bbs[found], cond);\n-  if (!nloop)\n-    {\n       free_original_copy_tables ();\n-      free (bbs);\n-      return changed;\n-    }\n \n-  /* Update the SSA form after unswitching.  */\n-  update_ssa (TODO_update_ssa);\n-  free_original_copy_tables ();\n+      /* Update the SSA form after unswitching.  */\n+      update_ssa (TODO_update_ssa);\n+\n+      /* Invoke itself on modified loops.  */\n+      bitmap handled_copy = BITMAP_ALLOC (NULL);\n+      bitmap_copy (handled_copy, handled);\n+      add_predicate_to_path (predicate_path, predicate, false);\n+      changed |= simplify_loop_version (nloop, predicate_path,\n+\t\t\t\t\tignored_edge_flag, handled_copy);\n+      tree_unswitch_single_loop (nloop, loc, predicate_path,\n+\t\t\t\t false_size, budget,\n+\t\t\t\t ignored_edge_flag, handled_copy);\n+      predicate_path.pop ();\n+      BITMAP_FREE (handled_copy);\n+\n+      /* FIXME: After unwinding above we have to reset all ->handled\n+\t flags as otherwise we fail to realize unswitching opportunities\n+\t in the below recursion.  See gcc.dg/loop-unswitch-16.c  */\n+      add_predicate_to_path (predicate_path, predicate, true);\n+      changed |= simplify_loop_version (loop, predicate_path,\n+\t\t\t\t\tignored_edge_flag, handled);\n+      tree_unswitch_single_loop (loop, loc, predicate_path,\n+\t\t\t\t true_size, budget,\n+\t\t\t\t ignored_edge_flag, handled);\n+      predicate_path.pop ();\n+      changed = true;\n+    }\n \n-  /* Invoke itself on modified loops.  */\n-  tree_unswitch_single_loop (nloop, num + 1);\n-  tree_unswitch_single_loop (loop, num + 1);\n-  free (bbs);\n-  return true;\n+exit:\n+  return changed;\n }\n \n-/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support\n-   unswitching of innermost loops.  COND is the condition determining which\n-   loop is entered -- the new loop is entered if COND is true.  Returns NULL\n-   if impossible, new loop otherwise.  */\n+/* Unswitch a LOOP w.r. to given EDGE_TRUE.  We only support unswitching of\n+   innermost loops.  COND is the condition determining which loop is entered;\n+   the new loop is entered if COND is true.  Returns NULL if impossible, new\n+   loop otherwise.  */\n \n static class loop *\n-tree_unswitch_loop (class loop *loop,\n-\t\t    basic_block unswitch_on, tree cond)\n+tree_unswitch_loop (class loop *loop, edge edge_true, tree cond)\n {\n-  profile_probability prob_true;\n-  edge edge_true, edge_false;\n-\n   /* Some sanity checking.  */\n-  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n-  gcc_assert (EDGE_COUNT (unswitch_on->succs) == 2);\n+  gcc_assert (flow_bb_inside_loop_p (loop, edge_true->src));\n+  gcc_assert (EDGE_COUNT (edge_true->src->succs) >= 2);\n   gcc_assert (loop->inner == NULL);\n \n-  extract_true_false_edges_from_block (unswitch_on, &edge_true, &edge_false);\n-  prob_true = edge_true->probability;\n+  profile_probability prob_true = edge_true->probability;\n   return loop_version (loop, unshare_expr (cond),\n \t\t       NULL, prob_true,\n \t\t       prob_true.invert (),\n@@ -1010,6 +1539,57 @@ check_exit_phi (class loop *loop)\n   return true;\n }\n \n+/* Remove all dead cases from switches that are unswitched.  */\n+\n+static void\n+clean_up_after_unswitching (int ignored_edge_flag)\n+{\n+  basic_block bb;\n+  edge e;\n+  edge_iterator ei;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    {\n+      gswitch *stmt= safe_dyn_cast <gswitch *> (last_stmt (bb));\n+      if (stmt && !CONSTANT_CLASS_P (gimple_switch_index (stmt)))\n+\t{\n+\t  unsigned nlabels = gimple_switch_num_labels (stmt);\n+\t  unsigned index = 1;\n+\t  tree lab = gimple_switch_default_label (stmt);\n+\t  edge default_e = find_edge (gimple_bb (stmt),\n+\t\t\t\t      label_to_block (cfun, CASE_LABEL (lab)));\n+\t  for (unsigned i = 1; i < nlabels; ++i)\n+\t    {\n+\t      tree lab = gimple_switch_label (stmt, i);\n+\t      basic_block dest = label_to_block (cfun, CASE_LABEL (lab));\n+\t      edge e = find_edge (gimple_bb (stmt), dest);\n+\t      if (e == NULL)\n+\t\t; /* The edge is already removed.  */\n+\t      else if (e->flags & ignored_edge_flag)\n+\t\t{\n+\t\t  /* We may not remove the default label so we also have\n+\t\t     to preserve its edge.  But we can remove the\n+\t\t     non-default CASE sharing the edge.  */\n+\t\t  if (e != default_e)\n+\t\t    remove_edge (e);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  gimple_switch_set_label (stmt, index, lab);\n+\t\t  ++index;\n+\t\t}\n+\t    }\n+\n+\t  if (index != nlabels)\n+\t    gimple_switch_set_num_labels (stmt, index);\n+\t}\n+\n+      /* Clean up the ignored_edge_flag from edges.  */\n+      FOR_EACH_EDGE (e, ei, bb->succs)\n+\te->flags &= ~ignored_edge_flag;\n+    }\n+}\n+\n /* Loop unswitching pass.  */\n \n namespace {\n@@ -1046,7 +1626,7 @@ pass_tree_unswitch::execute (function *fun)\n   if (number_of_loops (fun) <= 1)\n     return 0;\n \n-  return tree_ssa_unswitch_loops ();\n+  return tree_ssa_unswitch_loops (fun);\n }\n \n } // anon namespace"}]}