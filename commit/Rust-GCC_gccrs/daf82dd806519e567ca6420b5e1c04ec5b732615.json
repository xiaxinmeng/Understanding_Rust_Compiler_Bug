{"sha": "daf82dd806519e567ca6420b5e1c04ec5b732615", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGFmODJkZDgwNjUxOWU1NjdjYTY0MjBiNWUxYzA0ZWM1YjczMjYxNQ==", "commit": {"author": {"name": "Hristian Kirtchev", "email": "kirtchev@adacore.com", "date": "2017-11-08T14:07:31Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-11-08T14:07:31Z"}, "message": "exp_ch3.adb (Expand_N_Object_Declaration): Save and restore relevant SPARK-related flags.\n\n2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch3.adb (Expand_N_Object_Declaration): Save and restore relevant\n\tSPARK-related flags.  Add ??? comment.\n\t* exp_util.adb (Insert_Actions): Add an entry for node\n\tN_Variable_Reference_Marker.\n\t* sem.adb (Analyze): Add an entry for node N_Variable_Reference_Marker.\n\t* sem_ch8.adb (Find_Direct_Name): Add constant Is_Assignment_LHS. Build\n\tand record a variable reference marker for the current name.\n\t(Find_Expanded_Name): Add constant Is_Assignment_LHS. Build and record\n\ta variable reference marker for the current name.\n\t* sem_elab.adb (Build_Variable_Reference_Marker): New routine.\n\t(Extract_Variable_Reference_Attributes): Reimplemented.\n\t(Info_Scenario): Add output for variable references and remove output\n\tfor variable reads.\n\t(Info_Variable_Read): Removed.\n\t(Info_Variable_Reference): New routine.\n\t(Is_Suitable_Scenario): Variable references are now suitable scenarios\n\twhile variable reads are not.\n\t(Output_Active_Scenarios): Add output for variable references and\n\tremove output for variable reads.\n\t(Output_Variable_Read): Removed.\n\t(Output_Variable_Reference): New routine.\n\t(Process_Variable_Read): Removed.\n\t(Process_Variable_Reference): New routine.\n\t(Process_Variable_Reference_Read): New routine.\n\t* sem_elab.ads (Build_Variable_Reference_Marker): New routine.\n\t* sem_res.adb (Resolve_Actuals): Build and record a variable reference\n\tmarker for the current actual.\n\t* sem_spark.adb (Check_Node): Add an entry for node\n\tN_Variable_Reference_Marker.\n\t* sem_util.adb (Within_Subprogram_Call): Moved to the library level.\n\t* sem_util.ads (Within_Subprogram_Call): Moved to the library level.\n\t* sinfo.adb (Is_Read): New routine.\n\t(Is_Write): New routine.\n\t(Target): Updated to handle variable reference markers.\n\t(Set_Is_Read): New routine.\n\t(Set_Is_Write): New routine.\n\t(Set_Target): Updated to handle variable reference markers.\n\t* sinfo.ads: Add new attributes Is_Read and Is_Write along with\n\toccurrences in nodes. Update attribute Target. Add new node\n\tkind N_Variable_Reference_Marker.\n\t(Is_Read): New routine along with pragma Inline.\n\t(Is_Write): New routine along with pragma Inline.\n\t(Set_Is_Read): New routine along with pragma Inline.\n\t(Set_Is_Write): New routine along with pragma Inline.\n\t* sprint.adb (Sprint_Node_Actual): Add an entry for node\n\tN_Variable_Reference_Marker.\n\nFrom-SVN: r254531", "tree": {"sha": "6d2a5589a44e34dc401f2506ce59561013a2617e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6d2a5589a44e34dc401f2506ce59561013a2617e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/daf82dd806519e567ca6420b5e1c04ec5b732615", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf82dd806519e567ca6420b5e1c04ec5b732615", "html_url": "https://github.com/Rust-GCC/gccrs/commit/daf82dd806519e567ca6420b5e1c04ec5b732615", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/daf82dd806519e567ca6420b5e1c04ec5b732615/comments", "author": {"login": "kirtchev-adacore", "id": 60669983, "node_id": "MDQ6VXNlcjYwNjY5OTgz", "avatar_url": "https://avatars.githubusercontent.com/u/60669983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kirtchev-adacore", "html_url": "https://github.com/kirtchev-adacore", "followers_url": "https://api.github.com/users/kirtchev-adacore/followers", "following_url": "https://api.github.com/users/kirtchev-adacore/following{/other_user}", "gists_url": "https://api.github.com/users/kirtchev-adacore/gists{/gist_id}", "starred_url": "https://api.github.com/users/kirtchev-adacore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kirtchev-adacore/subscriptions", "organizations_url": "https://api.github.com/users/kirtchev-adacore/orgs", "repos_url": "https://api.github.com/users/kirtchev-adacore/repos", "events_url": "https://api.github.com/users/kirtchev-adacore/events{/privacy}", "received_events_url": "https://api.github.com/users/kirtchev-adacore/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "428dab52e965f90ce26925d3a89c2f3c6982b460", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428dab52e965f90ce26925d3a89c2f3c6982b460", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428dab52e965f90ce26925d3a89c2f3c6982b460"}], "stats": {"total": 864, "additions": 570, "deletions": 294}, "files": [{"sha": "10ab49eacc8791a8f9f23d5d428dfc05288b3154", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1,3 +1,52 @@\n+2017-11-08  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch3.adb (Expand_N_Object_Declaration): Save and restore relevant\n+\tSPARK-related flags.  Add ??? comment.\n+\t* exp_util.adb (Insert_Actions): Add an entry for node\n+\tN_Variable_Reference_Marker.\n+\t* sem.adb (Analyze): Add an entry for node N_Variable_Reference_Marker.\n+\t* sem_ch8.adb (Find_Direct_Name): Add constant Is_Assignment_LHS. Build\n+\tand record a variable reference marker for the current name.\n+\t(Find_Expanded_Name): Add constant Is_Assignment_LHS. Build and record\n+\ta variable reference marker for the current name.\n+\t* sem_elab.adb (Build_Variable_Reference_Marker): New routine.\n+\t(Extract_Variable_Reference_Attributes): Reimplemented.\n+\t(Info_Scenario): Add output for variable references and remove output\n+\tfor variable reads.\n+\t(Info_Variable_Read): Removed.\n+\t(Info_Variable_Reference): New routine.\n+\t(Is_Suitable_Scenario): Variable references are now suitable scenarios\n+\twhile variable reads are not.\n+\t(Output_Active_Scenarios): Add output for variable references and\n+\tremove output for variable reads.\n+\t(Output_Variable_Read): Removed.\n+\t(Output_Variable_Reference): New routine.\n+\t(Process_Variable_Read): Removed.\n+\t(Process_Variable_Reference): New routine.\n+\t(Process_Variable_Reference_Read): New routine.\n+\t* sem_elab.ads (Build_Variable_Reference_Marker): New routine.\n+\t* sem_res.adb (Resolve_Actuals): Build and record a variable reference\n+\tmarker for the current actual.\n+\t* sem_spark.adb (Check_Node): Add an entry for node\n+\tN_Variable_Reference_Marker.\n+\t* sem_util.adb (Within_Subprogram_Call): Moved to the library level.\n+\t* sem_util.ads (Within_Subprogram_Call): Moved to the library level.\n+\t* sinfo.adb (Is_Read): New routine.\n+\t(Is_Write): New routine.\n+\t(Target): Updated to handle variable reference markers.\n+\t(Set_Is_Read): New routine.\n+\t(Set_Is_Write): New routine.\n+\t(Set_Target): Updated to handle variable reference markers.\n+\t* sinfo.ads: Add new attributes Is_Read and Is_Write along with\n+\toccurrences in nodes. Update attribute Target. Add new node\n+\tkind N_Variable_Reference_Marker.\n+\t(Is_Read): New routine along with pragma Inline.\n+\t(Is_Write): New routine along with pragma Inline.\n+\t(Set_Is_Read): New routine along with pragma Inline.\n+\t(Set_Is_Write): New routine along with pragma Inline.\n+\t* sprint.adb (Sprint_Node_Actual): Add an entry for node\n+\tN_Variable_Reference_Marker.\n+\n 2017-11-08  Arnaud Charlet  <charlet@adacore.com>\n \n \t* sem_util.adb (Subprogram_Name): Append suffix for overloaded"}, {"sha": "435ff07b4383a9fd06ced1c40aa110b342953cf4", "filename": "gcc/ada/exp_ch3.adb", "status": "modified", "additions": 17, "deletions": 2, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fexp_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fexp_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch3.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -6727,8 +6727,11 @@ package body Exp_Ch3 is\n                   declare\n                      New_Id    : constant Entity_Id := Defining_Identifier (N);\n                      Next_Temp : constant Entity_Id := Next_Entity (New_Id);\n-                     S_Flag    : constant Boolean   :=\n+                     Save_CFS  : constant Boolean   :=\n                                    Comes_From_Source (Def_Id);\n+                     Save_SP   : constant Node_Id   := SPARK_Pragma (Def_Id);\n+                     Save_SPI  : constant Boolean   :=\n+                                   SPARK_Pragma_Inherited (Def_Id);\n \n                   begin\n                      Set_Next_Entity (New_Id, Next_Entity (Def_Id));\n@@ -6740,8 +6743,20 @@ package body Exp_Ch3 is\n                      Set_Sloc    (Defining_Identifier (N), Sloc    (Def_Id));\n \n                      Set_Comes_From_Source (Def_Id, False);\n+\n+                     --  ??? This is extremely dangerous!!! Exchanging entities\n+                     --  is very low level, and as a result it resets flags and\n+                     --  fields which belong to the original Def_Id. Several of\n+                     --  these attributes are saved and restored, but there may\n+                     --  be many more that need to be preserverd.\n+\n                      Exchange_Entities (Defining_Identifier (N), Def_Id);\n-                     Set_Comes_From_Source (Def_Id, S_Flag);\n+\n+                     --  Restore clobbered attributes\n+\n+                     Set_Comes_From_Source      (Def_Id, Save_CFS);\n+                     Set_SPARK_Pragma           (Def_Id, Save_SP);\n+                     Set_SPARK_Pragma_Inherited (Def_Id, Save_SPI);\n                   end;\n                end;\n             end if;"}, {"sha": "e9522e44e0de51e3b31edb470feb1508e471d0f6", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -7255,9 +7255,11 @@ package body Exp_Util is\n                   null;\n                end if;\n \n-            --  Special case: a call marker\n+            --  Special case: a marker\n \n-            when N_Call_Marker =>\n+            when N_Call_Marker\n+               | N_Variable_Reference_Marker\n+            =>\n                if Is_List_Member (P) then\n                   Insert_List_Before_And_Analyze (P, Ins_Actions);\n                   return;"}, {"sha": "02c8fa244edf8a7609c1b392f4c5d45bd25a7598", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -612,10 +612,12 @@ package body Sem is\n          when N_With_Clause =>\n             Analyze_With_Clause (N);\n \n-         --  A call to analyze a call marker is ignored because the node does\n-         --  not have any static and run-time semantics.\n+         --  A call to analyze a marker is ignored because the node does not\n+         --  have any static and run-time semantics.\n \n-         when N_Call_Marker =>\n+         when N_Call_Marker\n+            | N_Variable_Reference_Marker\n+         =>\n             null;\n \n          --  A call to analyze the Empty node is an error, but most likely it"}, {"sha": "86ceb52bf60f41e7e40221eac41afdfa28b7e3e2", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -5358,6 +5358,8 @@ package body Sem_Ch8 is\n \n       --  Local variables\n \n+      Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+\n       Nested_Inst : Entity_Id := Empty;\n       --  The entity of a nested instance which appears within Inst (if any)\n \n@@ -5895,9 +5897,20 @@ package body Sem_Ch8 is\n    <<Done>>\n       Check_Restriction_No_Use_Of_Entity (N);\n \n-      --  Save the scenario for later examination by the ABE Processing phase\n+      --  Annotate the tree by creating a variable reference marker in case the\n+      --  original variable reference is folded or optimized away. The variable\n+      --  reference marker is automatically saved for later examination by the\n+      --  ABE Processing phase. Variable references which act as actuals in a\n+      --  call require special processing and are left to Resolve_Actuals. The\n+      --  reference is a write when it appears on the left hand side of an\n+      --  assignment.\n \n-      Record_Elaboration_Scenario (N);\n+      if not Within_Subprogram_Call (N) then\n+         Build_Variable_Reference_Marker\n+           (N     => N,\n+            Read  => not Is_Assignment_LHS,\n+            Write => Is_Assignment_LHS);\n+      end if;\n    end Find_Direct_Name;\n \n    ------------------------\n@@ -5969,8 +5982,10 @@ package body Sem_Ch8 is\n \n       --  Local variables\n \n-      Selector  : constant Node_Id := Selector_Name (N);\n-      Candidate : Entity_Id        := Empty;\n+      Is_Assignment_LHS : constant Boolean := Is_LHS (N) = Yes;\n+      Selector          : constant Node_Id := Selector_Name (N);\n+\n+      Candidate : Entity_Id := Empty;\n       P_Name    : Entity_Id;\n       Id        : Entity_Id;\n \n@@ -6529,9 +6544,20 @@ package body Sem_Ch8 is\n \n       Check_Restriction_No_Use_Of_Entity (N);\n \n-      --  Save the scenario for later examination by the ABE Processing phase\n+      --  Annotate the tree by creating a variable reference marker in case the\n+      --  original variable reference is folded or optimized away. The variable\n+      --  reference marker is automatically saved for later examination by the\n+      --  ABE Processing phase. Variable references which act as actuals in a\n+      --  call require special processing and are left to Resolve_Actuals. The\n+      --  reference is a write when it appears on the left hand side of an\n+      --  assignment.\n \n-      Record_Elaboration_Scenario (N);\n+      if not Within_Subprogram_Call (N) then\n+         Build_Variable_Reference_Marker\n+           (N     => N,\n+            Read  => not Is_Assignment_LHS,\n+            Write => Is_Assignment_LHS);\n+      end if;\n    end Find_Expanded_Name;\n \n    --------------------"}, {"sha": "fb0d825ad05469d88057232f92bf8794de8d2eb3", "filename": "gcc/ada/sem_elab.adb", "status": "modified", "additions": 283, "deletions": 243, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_elab.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_elab.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -293,7 +293,7 @@ package body Sem_Elab is\n    --  |       |                                                            |\n    --  |       +--> Process_Variable_Assignment                             |\n    --  |       |                                                            |\n-   --  |       +--> Process_Variable_Read                                   |\n+   --  |       +--> Process_Variable_Reference                              |\n    --  |                                                                    |\n    --  +------------------------- Processing phase -------------------------+\n \n@@ -683,10 +683,6 @@ package body Sem_Elab is\n    --  variable.\n \n    type Variable_Attributes is record\n-      SPARK_Mode_On : Boolean;\n-      --  This flag is set when the variable appears in a region subject to\n-      --  pragma SPARK_Mode with value On, or starts one such region.\n-\n       Unit_Id : Entity_Id;\n       --  This attribute denotes the entity of the compilation unit where the\n       --  variable resides.\n@@ -965,16 +961,16 @@ package body Sem_Elab is\n    --  information message, otherwise it emits an error. If flag In_SPARK\n    --  is set, then string \" in SPARK\" is added to the end of the message.\n \n-   procedure Info_Variable_Read\n+   procedure Info_Variable_Reference\n      (Ref      : Node_Id;\n       Var_Id   : Entity_Id;\n       Info_Msg : Boolean;\n       In_SPARK : Boolean);\n-   pragma Inline (Info_Variable_Read);\n-   --  Output information concerning reference Ref which reads variable Var_Id.\n-   --  If flag Info_Msg is set, the routine emits an information message,\n-   --  otherwise it emits an error. If flag In_SPARK is set, then string \" in\n-   --  SPARK\" is added to the end of the message.\n+   pragma Inline (Info_Variable_Reference);\n+   --  Output information concerning reference Ref which mentions variable\n+   --  Var_Id. If flag Info_Msg is set, the routine emits an information\n+   --  message, otherwise it emits an error. If flag In_SPARK is set, then\n+   --  string \" in SPARK\" is added to the end of the message.\n \n    function Insertion_Node (N : Node_Id; Ins_Nod : Node_Id) return Node_Id;\n    pragma Inline (Insertion_Node);\n@@ -1166,10 +1162,10 @@ package body Sem_Elab is\n    --  Determine whether arbitrary node N denotes a suitable assignment for ABE\n    --  processing.\n \n-   function Is_Suitable_Variable_Read (N : Node_Id) return Boolean;\n-   pragma Inline (Is_Suitable_Variable_Read);\n-   --  Determine whether arbitrary node N is a suitable variable read for ABE\n-   --  processing.\n+   function Is_Suitable_Variable_Reference (N : Node_Id) return Boolean;\n+   pragma Inline (Is_Suitable_Variable_Reference);\n+   --  Determine whether arbitrary node N is a suitable variable reference for\n+   --  ABE processing.\n \n    function Is_Task_Entry (Id : Entity_Id) return Boolean;\n    pragma Inline (Is_Task_Entry);\n@@ -1418,9 +1414,16 @@ package body Sem_Elab is\n    --  Perform ABE checks and diagnostics for assignment statement Asmt that\n    --  updates the value of variable Var_Id using the SPARK rules.\n \n-   procedure Process_Variable_Read (Ref : Node_Id);\n-   --  Perform ABE checks and diagnostics for reference Ref that reads a\n-   --  variable.\n+   procedure Process_Variable_Reference (Ref : Node_Id);\n+   --  Top level dispatcher for processing of variable references. Perform ABE\n+   --  checks and diagnostics for variable reference Ref.\n+\n+   procedure Process_Variable_Reference_Read\n+     (Ref    : Node_Id;\n+      Var_Id : Entity_Id;\n+      Attrs  : Variable_Attributes);\n+   --  Perform ABE checks and diagnostics for reference Ref described by its\n+   --  attributes Attrs, that reads variable Var_Id.\n \n    procedure Push_Active_Scenario (N : Node_Id);\n    pragma Inline (Push_Active_Scenario);\n@@ -1647,6 +1650,12 @@ package body Sem_Elab is\n       if ASIS_Mode then\n          return;\n \n+      --  Nothing to do when the call is being preanalyzed as the marker will\n+      --  be inserted in the wrong place.\n+\n+      elsif Preanalysis_Active then\n+         return;\n+\n       --  Nothing to do when the input does not denote a call or a requeue\n \n       elsif not Nkind_In (N, N_Entry_Call_Statement,\n@@ -1656,12 +1665,6 @@ package body Sem_Elab is\n       then\n          return;\n \n-      --  Nothing to do when the call is being preanalyzed as the marker will\n-      --  be inserted in the wrong place.\n-\n-      elsif Preanalysis_Active then\n-         return;\n-\n       --  Nothing to do when the call is analyzed/resolved too early within an\n       --  intermediate context.\n \n@@ -1808,6 +1811,146 @@ package body Sem_Elab is\n       Record_Elaboration_Scenario (Marker);\n    end Build_Call_Marker;\n \n+   -------------------------------------\n+   -- Build_Variable_Reference_Marker --\n+   -------------------------------------\n+\n+   procedure Build_Variable_Reference_Marker\n+     (N     : Node_Id;\n+      Read  : Boolean;\n+      Write : Boolean)\n+   is\n+      function In_Pragma (Nod : Node_Id) return Boolean;\n+      --  Determine whether arbitrary node Nod appears within a pragma\n+\n+      ---------------\n+      -- In_Pragma --\n+      ---------------\n+\n+      function In_Pragma (Nod : Node_Id) return Boolean is\n+         Par : Node_Id;\n+\n+      begin\n+         Par := Nod;\n+         while Present (Par) loop\n+            if Nkind (Par) = N_Pragma then\n+               return True;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Is_Body_Or_Package_Declaration (Par) then\n+               exit;\n+            end if;\n+\n+            Par := Parent (Par);\n+         end loop;\n+\n+         return False;\n+      end In_Pragma;\n+\n+      --  Local variables\n+\n+      Marker    : Node_Id;\n+      Prag      : Node_Id;\n+      Var_Attrs : Variable_Attributes;\n+      Var_Id    : Entity_Id;\n+\n+   --  Start of processing for Build_Variable_Reference_Marker\n+\n+   begin\n+      --  Nothing to do for ASIS. As a result, ABE checks and diagnostics are\n+      --  not performed in this mode.\n+\n+      if ASIS_Mode then\n+         return;\n+\n+      --  Nothing to do when the reference is being preanalyzed as the marker\n+      --  will be inserted in the wrong place.\n+\n+      elsif Preanalysis_Active then\n+         return;\n+\n+      --  Nothing to do when the input does not denote a reference\n+\n+      elsif not Nkind_In (N, N_Expanded_Name, N_Identifier) then\n+         return;\n+\n+      --  Nothing to do for internally-generated references\n+\n+      elsif not Comes_From_Source (N) then\n+         return;\n+\n+      --  Nothing to do when the reference is erroneous, left in a bad state,\n+      --  or does not denote a variable.\n+\n+      elsif not (Present (Entity (N))\n+                  and then Ekind (Entity (N)) = E_Variable\n+                  and then Entity (N) /= Any_Id)\n+      then\n+         return;\n+      end if;\n+\n+      Extract_Variable_Reference_Attributes\n+        (Ref    => N,\n+         Var_Id => Var_Id,\n+         Attrs  => Var_Attrs);\n+\n+      Prag := SPARK_Pragma (Var_Id);\n+\n+      if Comes_From_Source (Var_Id)\n+\n+         --  Both the variable and the reference must appear in SPARK_Mode On\n+         --  regions because this scenario falls under the SPARK rules.\n+\n+         and then Present (Prag)\n+         and then Get_SPARK_Mode_From_Annotation (Prag) = On\n+         and then Is_SPARK_Mode_On_Node (N)\n+\n+         --  The reference must not be considered when it appears in a pragma.\n+         --  If the pragma has run-time semantics, then the reference will be\n+         --  reconsidered once the pragma is expanded.\n+\n+         --  Performance note: parent traversal\n+\n+         and then not In_Pragma (N)\n+      then\n+         null;\n+\n+      --  Otherwise the reference is not suitable for ABE processing. This\n+      --  prevents the generation of variable markers which will never play\n+      --  a role in ABE diagnostics.\n+\n+      else\n+         return;\n+      end if;\n+\n+      --  At this point it is known that the variable reference will play some\n+      --  role in ABE checks and diagnostics. Create a corresponding variable\n+      --  marker in case the original variable reference is folded or optimized\n+      --  away.\n+\n+      Marker := Make_Variable_Reference_Marker (Sloc (N));\n+\n+      --  Inherit the attributes of the original variable reference\n+\n+      Set_Target   (Marker, Var_Id);\n+      Set_Is_Read  (Marker, Read);\n+      Set_Is_Write (Marker, Write);\n+\n+      --  The marker is inserted prior to the original variable reference. The\n+      --  insertion must take place even when the reference does not occur in\n+      --  the main unit to keep the tree symmetric. This ensures that internal\n+      --  name serialization is consistent in case the variable marker causes\n+      --  the tree to transform in some way.\n+\n+      Insert_Action (N, Marker);\n+\n+      --  The marker becomes the \"corresponding\" scenario for the reference.\n+      --  Save the marker for later processing for the ABE phase.\n+\n+      Record_Elaboration_Scenario (Marker);\n+   end Build_Variable_Reference_Marker;\n+\n    ---------------------------------\n    -- Check_Elaboration_Scenarios --\n    ---------------------------------\n@@ -2990,14 +3133,45 @@ package body Sem_Elab is\n       Var_Id : out Entity_Id;\n       Attrs  : out Variable_Attributes)\n    is\n+      function Get_Renamed_Variable (Id : Entity_Id) return Entity_Id;\n+      --  Obtain the ultimate renamed variable of variable Id\n+\n+      --------------------------\n+      -- Get_Renamed_Variable --\n+      --------------------------\n+\n+      function Get_Renamed_Variable (Id : Entity_Id) return Entity_Id is\n+         Ren_Id : Entity_Id;\n+\n+      begin\n+         Ren_Id := Id;\n+         while Present (Renamed_Entity (Ren_Id))\n+           and then Nkind (Renamed_Entity (Ren_Id)) in N_Entity\n+         loop\n+            Ren_Id := Renamed_Entity (Ren_Id);\n+         end loop;\n+\n+         return Ren_Id;\n+      end Get_Renamed_Variable;\n+\n+   --  Start of processing for Extract_Variable_Reference_Attributes\n+\n    begin\n-      --  Traverse a possible chain of renamings to obtain the original\n-      --  variable being referenced.\n+      --  Extraction for variable reference markers\n+\n+      if Nkind (Ref) = N_Variable_Reference_Marker then\n+         Var_Id := Target (Ref);\n \n-      Var_Id := Get_Renamed_Entity (Entity (Ref));\n+      --  Extraction for expanded names and identifiers\n \n-      Attrs.SPARK_Mode_On := Is_SPARK_Mode_On_Node (Ref);\n-      Attrs.Unit_Id       := Find_Top_Unit (Var_Id);\n+      else\n+         Var_Id := Entity (Ref);\n+      end if;\n+\n+      --  Obtain the original variable which the reference mentions\n+\n+      Var_Id        := Get_Renamed_Variable (Var_Id);\n+      Attrs.Unit_Id := Find_Top_Unit (Var_Id);\n \n       --  At this point certain attributes should always be available\n \n@@ -4284,24 +4458,26 @@ package body Sem_Elab is\n          In_SPARK => In_SPARK);\n    end Info_Instantiation;\n \n-   ------------------------\n-   -- Info_Variable_Read --\n-   ------------------------\n+   -----------------------------\n+   -- Info_Variable_Reference --\n+   -----------------------------\n \n-   procedure Info_Variable_Read\n+   procedure Info_Variable_Reference\n      (Ref      : Node_Id;\n       Var_Id   : Entity_Id;\n       Info_Msg : Boolean;\n       In_SPARK : Boolean)\n    is\n    begin\n-      Elab_Msg_NE\n-        (Msg      => \"read of variable & during elaboration\",\n-         N        => Ref,\n-         Id       => Var_Id,\n-         Info_Msg => Info_Msg,\n-         In_SPARK => In_SPARK);\n-   end Info_Variable_Read;\n+      if Is_Read (Ref) then\n+         Elab_Msg_NE\n+           (Msg      => \"read of variable & during elaboration\",\n+            N        => Ref,\n+            Id       => Var_Id,\n+            Info_Msg => Info_Msg,\n+            In_SPARK => In_SPARK);\n+      end if;\n+   end Info_Variable_Reference;\n \n    --------------------\n    -- Insertion_Node --\n@@ -5258,7 +5434,7 @@ package body Sem_Elab is\n           or else Is_Suitable_Call (N)\n           or else Is_Suitable_Instantiation (N)\n           or else Is_Suitable_Variable_Assignment (N)\n-          or else Is_Suitable_Variable_Read (N);\n+          or else Is_Suitable_Variable_Reference (N);\n    end Is_Suitable_Scenario;\n \n    -------------------------------------\n@@ -5355,187 +5531,19 @@ package body Sem_Elab is\n           and then Corresponding_Body (Var_Unit) = N_Unit_Id;\n    end Is_Suitable_Variable_Assignment;\n \n-   -------------------------------\n-   -- Is_Suitable_Variable_Read --\n-   -------------------------------\n-\n-   function Is_Suitable_Variable_Read (N : Node_Id) return Boolean is\n-      function In_Pragma (Nod : Node_Id) return Boolean;\n-      --  Determine whether arbitrary node Nod appears within a pragma\n-\n-      function Is_Variable_Read (Ref : Node_Id) return Boolean;\n-      --  Determine whether variable reference Ref constitutes a read\n-\n-      ---------------\n-      -- In_Pragma --\n-      ---------------\n-\n-      function In_Pragma (Nod : Node_Id) return Boolean is\n-         Par : Node_Id;\n-\n-      begin\n-         Par := Nod;\n-         while Present (Par) loop\n-            if Nkind (Par) = N_Pragma then\n-               return True;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return False;\n-      end In_Pragma;\n-\n-      ----------------------\n-      -- Is_Variable_Read --\n-      ----------------------\n-\n-      function Is_Variable_Read (Ref : Node_Id) return Boolean is\n-         function Is_Out_Actual (Call : Node_Id) return Boolean;\n-         --  Determine whether the corresponding formal of actual Ref which\n-         --  appears in call Call has mode OUT.\n-\n-         -------------------\n-         -- Is_Out_Actual --\n-         -------------------\n-\n-         function Is_Out_Actual (Call : Node_Id) return Boolean is\n-            Actual     : Node_Id;\n-            Call_Attrs : Call_Attributes;\n-            Formal     : Entity_Id;\n-            Target_Id  : Entity_Id;\n-\n-         begin\n-            Extract_Call_Attributes\n-              (Call      => Call,\n-               Target_Id => Target_Id,\n-               Attrs     => Call_Attrs);\n-\n-            --  Inspect the actual and formal parameters, trying to find the\n-            --  corresponding formal for Ref.\n-\n-            Actual := First_Actual (Call);\n-            Formal := First_Formal (Target_Id);\n-            while Present (Actual) and then Present (Formal) loop\n-               if Actual = Ref then\n-                  return Ekind (Formal) = E_Out_Parameter;\n-               end if;\n-\n-               Next_Actual (Actual);\n-               Next_Formal (Formal);\n-            end loop;\n-\n-            return False;\n-         end Is_Out_Actual;\n-\n-         --  Local variables\n-\n-         Context : constant Node_Id := Parent (Ref);\n-\n-      --  Start of processing for Is_Variable_Read\n-\n-      begin\n-         --  The majority of variable references are reads, and they can appear\n-         --  in a great number of contexts. To determine whether a reference is\n-         --  a read, it is more practical to find out whether it is a write.\n-\n-         --  A reference is a write when it appears immediately on the left-\n-         --  hand side of an assignment.\n-\n-         if Nkind (Context) = N_Assignment_Statement\n-           and then Name (Context) = Ref\n-         then\n-            return False;\n-\n-         --  A reference is a write when it acts as an actual in a subprogram\n-         --  call and the corresponding formal has mode OUT.\n-\n-         elsif Nkind_In (Context, N_Function_Call,\n-                                  N_Procedure_Call_Statement)\n-           and then Is_Out_Actual (Context)\n-         then\n-            return False;\n-         end if;\n-\n-         --  Any other reference is a read\n-\n-         return True;\n-      end Is_Variable_Read;\n-\n-      --  Local variables\n-\n-      Prag   : Node_Id;\n-      Var_Id : Entity_Id;\n-\n-   --  Start of processing for Is_Suitable_Variable_Read\n+   ------------------------------------\n+   -- Is_Suitable_Variable_Reference --\n+   ------------------------------------\n \n+   function Is_Suitable_Variable_Reference (N : Node_Id) return Boolean is\n    begin\n-      --  This scenario is relevant only when the static model is in effect\n-      --  because it is graph-dependent and does not involve any run-time\n-      --  checks. Allowing it in the dynamic model would create confusing\n-      --  noise.\n-\n-      if not Static_Elaboration_Checks then\n-         return False;\n-\n-      --  Attributes and operator sumbols are not considered to be suitable\n-      --  references even though they are part of predicate Is_Entity_Name.\n-\n-      elsif not Nkind_In (N, N_Expanded_Name, N_Identifier) then\n-         return False;\n-\n-      --  Nothing to do for internally-generated references because they are\n-      --  assumed to be ABE safe.\n-\n-      elsif not Comes_From_Source (N) then\n-         return False;\n-      end if;\n-\n-      --  Sanitize the reference\n-\n-      Var_Id := Entity (N);\n-\n-      if No (Var_Id) then\n-         return False;\n+      --  Expanded names and identifiers are intentionally ignored because they\n+      --  be folded, optimized away, etc. Variable references markers play the\n+      --  role of variable references and provide a uniform foundation for ABE\n+      --  processing.\n \n-      elsif Var_Id = Any_Id then\n-         return False;\n-\n-      elsif Ekind (Var_Id) /= E_Variable then\n-         return False;\n-      end if;\n-\n-      Prag := SPARK_Pragma (Var_Id);\n-\n-      --  To qualify, the reference must meet the following prerequisites:\n-\n-      return\n-        Comes_From_Source (Var_Id)\n-\n-          --  Both the variable and the reference must appear in SPARK_Mode On\n-          --  regions because this scenario falls under the SPARK rules.\n-\n-          and then Present (Prag)\n-          and then Get_SPARK_Mode_From_Annotation (Prag) = On\n-          and then Is_SPARK_Mode_On_Node (N)\n-\n-          --  The reference must denote a variable read\n-\n-          and then Is_Variable_Read (N)\n-\n-          --  The reference must not be considered when it appears in a pragma.\n-          --  If the pragma has run-time semantics, then the reference will be\n-          --  reconsidered once the pragma is expanded.\n-\n-          --  Performance note: parent traversal\n-\n-          and then not In_Pragma (N);\n-   end Is_Suitable_Variable_Read;\n+      return Nkind (N) = N_Variable_Reference_Marker;\n+   end Is_Suitable_Variable_Reference;\n \n    -------------------\n    -- Is_Task_Entry --\n@@ -5710,8 +5718,8 @@ package body Sem_Elab is\n                Info_Msg => False,\n                In_SPARK => True);\n \n-         elsif Is_Suitable_Variable_Read (N) then\n-            Info_Variable_Read\n+         elsif Is_Suitable_Variable_Reference (N) then\n+            Info_Variable_Reference\n               (Ref      => N,\n                Var_Id   => Target_Id,\n                Info_Msg => False,\n@@ -5875,8 +5883,8 @@ package body Sem_Elab is\n       procedure Output_Variable_Assignment (N : Node_Id);\n       --  Emit a specific diagnostic message for assignment statement N\n \n-      procedure Output_Variable_Read (N : Node_Id);\n-      --  Emit a specific diagnostic message for reference N which reads a\n+      procedure Output_Variable_Reference (N : Node_Id);\n+      --  Emit a specific diagnostic message for reference N which mentions a\n       --  variable.\n \n       -------------------\n@@ -6206,11 +6214,11 @@ package body Sem_Elab is\n          Error_Msg_NE (\"\\\\  variable & assigned #\", Error_Nod, Var_Id);\n       end Output_Variable_Assignment;\n \n-      --------------------------\n-      -- Output_Variable_Read --\n-      --------------------------\n+      -------------------------------\n+      -- Output_Variable_Reference --\n+      -------------------------------\n \n-      procedure Output_Variable_Read (N : Node_Id) is\n+      procedure Output_Variable_Reference (N : Node_Id) is\n          Dummy  : Variable_Attributes;\n          Var_Id : Entity_Id;\n \n@@ -6221,8 +6229,11 @@ package body Sem_Elab is\n             Attrs  => Dummy);\n \n          Error_Msg_Sloc := Sloc (N);\n-         Error_Msg_NE (\"\\\\  variable & read #\", Error_Nod, Var_Id);\n-      end Output_Variable_Read;\n+\n+         if Is_Read (N) then\n+            Error_Msg_NE (\"\\\\  variable & read #\", Error_Nod, Var_Id);\n+         end if;\n+      end Output_Variable_Reference;\n \n       --  Local variables\n \n@@ -6283,10 +6294,10 @@ package body Sem_Elab is\n          elsif Nkind (N) = N_Assignment_Statement then\n             Output_Variable_Assignment (N);\n \n-         --  Variable read\n+         --  Variable references\n \n-         elsif Is_Suitable_Variable_Read (N) then\n-            Output_Variable_Read (N);\n+         elsif Is_Suitable_Variable_Reference (N) then\n+            Output_Variable_Reference (N);\n \n          else\n             pragma Assert (False);\n@@ -8140,11 +8151,11 @@ package body Sem_Elab is\n       end if;\n    end Process_Variable_Assignment_SPARK;\n \n-   ---------------------------\n-   -- Process_Variable_Read --\n-   ---------------------------\n+   --------------------------------\n+   -- Process_Variable_Reference --\n+   --------------------------------\n \n-   procedure Process_Variable_Read (Ref : Node_Id) is\n+   procedure Process_Variable_Reference (Ref : Node_Id) is\n       Var_Attrs : Variable_Attributes;\n       Var_Id    : Entity_Id;\n \n@@ -8154,6 +8165,24 @@ package body Sem_Elab is\n          Var_Id => Var_Id,\n          Attrs  => Var_Attrs);\n \n+      if Is_Read (Ref) then\n+         Process_Variable_Reference_Read\n+           (Ref    => Ref,\n+            Var_Id => Var_Id,\n+            Attrs  => Var_Attrs);\n+      end if;\n+   end Process_Variable_Reference;\n+\n+   -------------------------------------\n+   -- Process_Variable_Reference_Read --\n+   -------------------------------------\n+\n+   procedure Process_Variable_Reference_Read\n+     (Ref    : Node_Id;\n+      Var_Id : Entity_Id;\n+      Attrs  : Variable_Attributes)\n+   is\n+   begin\n       --  Output relevant information when switch -gnatel (info messages on\n       --  implicit Elaborate[_All] pragmas) is in effect.\n \n@@ -8169,7 +8198,7 @@ package body Sem_Elab is\n       --  Nothing to do when the variable appears within the main unit because\n       --  diagnostics on reads are relevant only for external variables.\n \n-      if Is_Same_Unit (Var_Attrs.Unit_Id, Cunit_Entity (Main_Unit)) then\n+      if Is_Same_Unit (Attrs.Unit_Id, Cunit_Entity (Main_Unit)) then\n          null;\n \n       --  Nothing to do when the variable is already initialized. Note that the\n@@ -8181,7 +8210,7 @@ package body Sem_Elab is\n       --  Nothing to do when the external unit guarantees the initialization of\n       --  the variable by means of pragma Elaborate_Body.\n \n-      elsif Has_Pragma_Elaborate_Body (Var_Attrs.Unit_Id) then\n+      elsif Has_Pragma_Elaborate_Body (Attrs.Unit_Id) then\n          null;\n \n       --  A variable read imposes an Elaborate requirement on the context of\n@@ -8194,7 +8223,7 @@ package body Sem_Elab is\n             Target_Id => Var_Id,\n             Req_Nam   => Name_Elaborate);\n       end if;\n-   end Process_Variable_Read;\n+   end Process_Variable_Reference_Read;\n \n    --------------------------\n    -- Push_Active_Scenario --\n@@ -8271,10 +8300,21 @@ package body Sem_Elab is\n       elsif Is_Suitable_Variable_Assignment (N) then\n          Process_Variable_Assignment (N);\n \n-      --  Variable read\n+      --  Variable references\n \n-      elsif Is_Suitable_Variable_Read (N) then\n-         Process_Variable_Read (N);\n+      elsif Is_Suitable_Variable_Reference (N) then\n+\n+         --  In general, only variable references found within the main unit\n+         --  are processed because the ALI information supplied to binde is for\n+         --  the main unit only. However, to preserve the consistency of the\n+         --  tree and ensure proper serialization of internal names, external\n+         --  variable references also receive corresponding variable reference\n+         --  markers (see Build_Varaible_Reference_Marker). Regardless of the\n+         --  reason, external variable references must not be processed.\n+\n+         if In_Main_Context (N) then\n+            Process_Variable_Reference (N);\n+         end if;\n       end if;\n \n       --  Remove the current scenario from the stack of active scenarios once\n@@ -8365,7 +8405,7 @@ package body Sem_Elab is\n          Possible_Local_Raise (N, Standard_Program_Error);\n \n       elsif Is_Suitable_Variable_Assignment (N)\n-        or else Is_Suitable_Variable_Read (N)\n+        or else Is_Suitable_Variable_Reference (N)\n       then\n          null;\n "}, {"sha": "69d65d8cd698331fcb05cfb3b0f27788840f99c4", "filename": "gcc/ada/sem_elab.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_elab.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_elab.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_elab.ads?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -34,6 +34,15 @@ package Sem_Elab is\n    --  Create a call marker for call or requeue statement N and record it for\n    --  later processing by the ABE mechanism.\n \n+   procedure Build_Variable_Reference_Marker\n+     (N     : Node_Id;\n+      Read  : Boolean;\n+      Write : Boolean);\n+   --  Create a variable reference marker for arbitrary node N if it mentions a\n+   --  variable, and record it for later processing by the ABE mechanism. Flag\n+   --  Read should be set when the reference denotes a read. Flag Write should\n+   --  be set when the reference denotes a write.\n+\n    procedure Check_Elaboration_Scenarios;\n    --  Examine each scenario recorded during analysis/resolution and apply the\n    --  Ada or SPARK elaboration rules taking into account the model in effect."}, {"sha": "07e4ba83f6631a1b7c251c95554e00838d73f2d6", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -3744,6 +3744,21 @@ package body Sem_Res is\n            and then Is_Entity_Name (A)\n            and then Comes_From_Source (A)\n          then\n+            --  Annotate the tree by creating a variable reference marker when\n+            --  the actual denotes a variable reference, in case the reference\n+            --  is folded or optimized away. The variable reference marker is\n+            --  automatically saved for later examination by the ABE Processing\n+            --  phase. The status of the reference is set as follows:\n+\n+            --    status   mode\n+            --    read     IN, IN OUT\n+            --    write    IN OUT, OUT\n+\n+            Build_Variable_Reference_Marker\n+              (N     => A,\n+               Read  => Ekind (F) /= E_Out_Parameter,\n+               Write => Ekind (F) /= E_In_Parameter);\n+\n             Orig_A := Entity (A);\n \n             if Present (Orig_A) then"}, {"sha": "42517ea0829be760bdf4ead98bb89cd4052eafad", "filename": "gcc/ada/sem_spark.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_spark.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -2349,6 +2349,7 @@ package body Sem_SPARK is\n             | N_With_Clause\n             | N_Use_Type_Clause\n             | N_Validate_Unchecked_Conversion\n+            | N_Variable_Reference_Marker\n          =>\n             null;\n "}, {"sha": "429310cd80d7ae8e512d119dd9049b9cfed23ad3", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 30, "deletions": 34, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -14865,10 +14865,6 @@ package body Sem_Util is\n       function Within_Check (Nod : Node_Id) return Boolean;\n       --  Determine whether an arbitrary node appears in a check node\n \n-      function Within_Subprogram_Call (Nod : Node_Id) return Boolean;\n-      --  Determine whether an arbitrary node appears in an entry, function, or\n-      --  procedure call.\n-\n       function Within_Volatile_Function (Id : Entity_Id) return Boolean;\n       --  Determine whether an arbitrary entity appears in a volatile function\n \n@@ -14931,36 +14927,6 @@ package body Sem_Util is\n          return False;\n       end Within_Check;\n \n-      ----------------------------\n-      -- Within_Subprogram_Call --\n-      ----------------------------\n-\n-      function Within_Subprogram_Call (Nod : Node_Id) return Boolean is\n-         Par : Node_Id;\n-\n-      begin\n-         --  Climb the parent chain looking for a function or procedure call\n-\n-         Par := Nod;\n-         while Present (Par) loop\n-            if Nkind_In (Par, N_Entry_Call_Statement,\n-                              N_Function_Call,\n-                              N_Procedure_Call_Statement)\n-            then\n-               return True;\n-\n-            --  Prevent the search from going too far\n-\n-            elsif Is_Body_Or_Package_Declaration (Par) then\n-               exit;\n-            end if;\n-\n-            Par := Parent (Par);\n-         end loop;\n-\n-         return False;\n-      end Within_Subprogram_Call;\n-\n       ------------------------------\n       -- Within_Volatile_Function --\n       ------------------------------\n@@ -24241,6 +24207,36 @@ package body Sem_Util is\n       return Scope_Within_Or_Same (Scope (E), S);\n    end Within_Scope;\n \n+   ----------------------------\n+   -- Within_Subprogram_Call --\n+   ----------------------------\n+\n+   function Within_Subprogram_Call (N : Node_Id) return Boolean is\n+      Par : Node_Id;\n+\n+   begin\n+      --  Climb the parent chain looking for a function or procedure call\n+\n+      Par := N;\n+      while Present (Par) loop\n+         if Nkind_In (Par, N_Entry_Call_Statement,\n+                           N_Function_Call,\n+                           N_Procedure_Call_Statement)\n+         then\n+            return True;\n+\n+         --  Prevent the search from going too far\n+\n+         elsif Is_Body_Or_Package_Declaration (Par) then\n+            exit;\n+         end if;\n+\n+         Par := Parent (Par);\n+      end loop;\n+\n+      return False;\n+   end Within_Subprogram_Call;\n+\n    ----------------\n    -- Wrong_Type --\n    ----------------"}, {"sha": "f0e06e4a4e6a3083213bdb738dbb607ebfd51a0c", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -2735,6 +2735,10 @@ package Sem_Util is\n    function Within_Scope (E : Entity_Id; S : Entity_Id) return Boolean;\n    --  Returns True if entity E is declared within scope S\n \n+   function Within_Subprogram_Call (N : Node_Id) return Boolean;\n+   --  Determine whether arbitrary node N appears in an entry, function, or\n+   --  procedure call.\n+\n    procedure Wrong_Type (Expr : Node_Id; Expected_Type : Entity_Id);\n    --  Output error message for incorrectly typed expression. Expr is the node\n    --  for the incorrectly typed construct (Etype (Expr) is the type found),"}, {"sha": "5514291bb348c5606e8a4a9a87dc1f3f7e34d6a6", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -2090,6 +2090,14 @@ package body Sinfo is\n       return Flag4 (N);\n    end Is_Qualified_Universal_Literal;\n \n+   function Is_Read\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n+      return Flag1 (N);\n+   end Is_Read;\n+\n    function Is_Recorded_Scenario\n       (N : Node_Id) return Boolean is\n    begin\n@@ -2179,6 +2187,14 @@ package body Sinfo is\n       return Flag5 (N);\n    end Is_Task_Master;\n \n+   function Is_Write\n+      (N : Node_Id) return Boolean is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n+      return Flag2 (N);\n+   end Is_Write;\n+\n    function Iteration_Scheme\n       (N : Node_Id) return Node_Id is\n    begin\n@@ -3277,7 +3293,8 @@ package body Sinfo is\n       (N : Node_Id) return Entity_Id is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Call_Marker);\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       return Node1 (N);\n    end Target;\n \n@@ -5512,6 +5529,14 @@ package body Sinfo is\n       Set_Flag4 (N, Val);\n    end Set_Is_Qualified_Universal_Literal;\n \n+   procedure Set_Is_Read\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n+      Set_Flag1 (N, Val);\n+   end Set_Is_Read;\n+\n    procedure Set_Is_Recorded_Scenario\n       (N : Node_Id; Val : Boolean := True) is\n    begin\n@@ -5601,6 +5626,14 @@ package body Sinfo is\n       Set_Flag5 (N, Val);\n    end Set_Is_Task_Master;\n \n+   procedure Set_Is_Write\n+      (N : Node_Id; Val : Boolean := True) is\n+   begin\n+      pragma Assert (False\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n+      Set_Flag2 (N, Val);\n+   end Set_Is_Write;\n+\n    procedure Set_Iteration_Scheme\n       (N : Node_Id; Val : Node_Id) is\n    begin\n@@ -6699,7 +6732,8 @@ package body Sinfo is\n       (N : Node_Id; Val : Entity_Id) is\n    begin\n       pragma Assert (False\n-        or else NT (N).Nkind = N_Call_Marker);\n+        or else NT (N).Nkind = N_Call_Marker\n+        or else NT (N).Nkind = N_Variable_Reference_Marker);\n       Set_Node1 (N, Val); -- semantic field, no parent set\n    end Set_Target;\n "}, {"sha": "21e7bb96909a578055de9e89f553039634ac0877", "filename": "gcc/ada/sinfo.ads", "status": "modified", "additions": 66, "deletions": 2, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.ads?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -1863,6 +1863,10 @@ package Sinfo is\n    --    the resolution of accidental overloading of binary or unary operators\n    --    which may occur in instances.\n \n+   --  Is_Read (Flag1-Sem)\n+   --    Present in variable reference markers. Set when the original variable\n+   --    reference constitues a read of the variable.\n+\n    --  Is_Recorded_Scenario (Flag6-Sem)\n    --    Present in call marker and instantiation nodes. Set when the scenario\n    --    was saved by the ABE Recording phase. This flag aids the ABE machinery\n@@ -1916,6 +1920,10 @@ package Sinfo is\n    --    indicate that the construct is a task master (i.e. has declared tasks\n    --    or declares an access to a task type).\n \n+   --  Is_Write (Flag2-Sem)\n+   --    Present in variable reference markers. Set when the original variable\n+   --    reference constitues a write of the variable.\n+\n    --  Itype (Node1-Sem)\n    --    Used in N_Itype_Reference node to reference an itype for which it is\n    --    important to ensure that it is defined. See description of this node\n@@ -2318,8 +2326,9 @@ package Sinfo is\n    --    only execute if invalid values are present).\n \n    --  Target (Node1-Sem)\n-   --    Present in call marker nodes. References the entity of the entry,\n-   --    operator, or subprogram invoked by the related call or requeue.\n+   --    Present in call and variable reference marker nodes. References the\n+   --    entity of the original entity, operator, or subprogram being invoked,\n+   --    or the original variable being read or written.\n \n    --  Target_Type (Node2-Sem)\n    --    Used in an N_Validate_Unchecked_Conversion node to point to the target\n@@ -8455,6 +8464,37 @@ package Sinfo is\n       --  Note: in the case where a debug source file is generated, the Sloc\n       --  for this node points to the VALIDATE keyword in the file output.\n \n+      -------------------------------\n+      -- Variable_Reference_Marker --\n+      -------------------------------\n+\n+      --  This node is created during the analysis of direct or expanded names,\n+      --  and the resolution of entry and subprogram calls. It performs several\n+      --  functions:\n+\n+      --    * Variable reference markers provide a uniform model for handling\n+      --      variable references by the ABE mechanism, regardless of whether\n+      --      expansion took place.\n+\n+      --    * The variable reference marker captures the entity of the variable\n+      --      being read or written.\n+\n+      --    * The variable reference markers aid the ABE Processing phase by\n+      --      signaling the presence of a call in case the original variable\n+      --      reference was transformed by expansion.\n+\n+      --  Sprint syntax:  r#target#  --  for a read\n+      --                 rw#target#  --  for a read/write\n+      --                  w#target#  --  for a write\n+\n+      --  The Sprint syntax shown above is not enabled by default\n+\n+      --  N_Variable_Reference_Marker\n+      --  Sloc points to Sloc of original variable reference\n+      --  Target (Node1-Sem)\n+      --  Is_Read (Flag1-Sem)\n+      --  Is_Write (Flag2-Sem)\n+\n    -----------\n    -- Empty --\n    -----------\n@@ -8877,6 +8917,7 @@ package Sinfo is\n       N_Triggering_Alternative,\n       N_Use_Type_Clause,\n       N_Validate_Unchecked_Conversion,\n+      N_Variable_Reference_Marker,\n       N_Variant,\n       N_Variant_Part,\n       N_With_Clause,\n@@ -9733,6 +9774,9 @@ package Sinfo is\n    function Is_Qualified_Universal_Literal\n      (N : Node_Id) return Boolean;    -- Flag4\n \n+   function Is_Read\n+     (N : Node_Id) return Boolean;    -- Flag1\n+\n    function Is_Recorded_Scenario\n      (N : Node_Id) return Boolean;    -- Flag6\n \n@@ -9760,6 +9804,9 @@ package Sinfo is\n    function Is_Task_Master\n      (N : Node_Id) return Boolean;    -- Flag5\n \n+   function Is_Write\n+     (N : Node_Id) return Boolean;    -- Flag2\n+\n    function Iteration_Scheme\n      (N : Node_Id) return Node_Id;    -- Node2\n \n@@ -10822,6 +10869,9 @@ package Sinfo is\n    procedure Set_Is_Qualified_Universal_Literal\n      (N : Node_Id; Val : Boolean := True);    -- Flag4\n \n+   procedure Set_Is_Read\n+     (N : Node_Id; Val : Boolean := True);    -- Flag1\n+\n    procedure Set_Is_Recorded_Scenario\n      (N : Node_Id; Val : Boolean := True);    -- Flag6\n \n@@ -10849,6 +10899,9 @@ package Sinfo is\n    procedure Set_Is_Task_Master\n      (N : Node_Id; Val : Boolean := True);    -- Flag5\n \n+   procedure Set_Is_Write\n+     (N : Node_Id; Val : Boolean := True);    -- Flag2\n+\n    procedure Set_Iteration_Scheme\n      (N : Node_Id; Val : Node_Id);            -- Node2\n \n@@ -13023,6 +13076,13 @@ package Sinfo is\n         4 => False,   --  unused\n         5 => False),  --  unused\n \n+     N_Variable_Reference_Marker =>\n+       (1 => False,   --  Target (Node1-Sem)\n+        2 => False,   --  unused\n+        3 => False,   --  unused\n+        4 => False,   --  unused\n+        5 => False),  --  unused\n+\n    --  Entries for Empty, Error and Unused. Even thought these have a Chars\n    --  field for debugging purposes, they are not really syntactic fields, so\n    --  we mark all fields as unused.\n@@ -13276,6 +13336,7 @@ package Sinfo is\n    pragma Inline (Is_Prefixed_Call);\n    pragma Inline (Is_Protected_Subprogram_Body);\n    pragma Inline (Is_Qualified_Universal_Literal);\n+   pragma Inline (Is_Read);\n    pragma Inline (Is_Recorded_Scenario);\n    pragma Inline (Is_Source_Call);\n    pragma Inline (Is_SPARK_Mode_On_Node);\n@@ -13285,6 +13346,7 @@ package Sinfo is\n    pragma Inline (Is_Task_Allocation_Block);\n    pragma Inline (Is_Task_Body_Procedure);\n    pragma Inline (Is_Task_Master);\n+   pragma Inline (Is_Write);\n    pragma Inline (Iteration_Scheme);\n    pragma Inline (Itype);\n    pragma Inline (Kill_Range_Check);\n@@ -13634,6 +13696,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Prefixed_Call);\n    pragma Inline (Set_Is_Protected_Subprogram_Body);\n    pragma Inline (Set_Is_Qualified_Universal_Literal);\n+   pragma Inline (Set_Is_Read);\n    pragma Inline (Set_Is_Recorded_Scenario);\n    pragma Inline (Set_Is_Source_Call);\n    pragma Inline (Set_Is_SPARK_Mode_On_Node);\n@@ -13643,6 +13706,7 @@ package Sinfo is\n    pragma Inline (Set_Is_Task_Allocation_Block);\n    pragma Inline (Set_Is_Task_Body_Procedure);\n    pragma Inline (Set_Is_Task_Master);\n+   pragma Inline (Set_Is_Write);\n    pragma Inline (Set_Iteration_Scheme);\n    pragma Inline (Set_Iterator_Specification);\n    pragma Inline (Set_Itype);"}, {"sha": "428e91a73cd6c059afed419fb7c731578430fb00", "filename": "gcc/ada/sprint.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsprint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/daf82dd806519e567ca6420b5e1c04ec5b732615/gcc%2Fada%2Fsprint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsprint.adb?ref=daf82dd806519e567ca6420b5e1c04ec5b732615", "patch": "@@ -3459,6 +3459,25 @@ package body Sprint is\n             Sprint_Node (Target_Type (Node));\n             Write_Str (\");\");\n \n+         when N_Variable_Reference_Marker =>\n+            null;\n+\n+            --  Enable the following code for debugging purposes only\n+\n+            --  if Is_Read (Node) and then Is_Write (Node) then\n+            --     Write_Indent_Str (\"rw#\");\n+\n+            --  elsif Is_Read (Node) then\n+            --     Write_Indent_Str (\"r#\");\n+\n+            --  else\n+            --     pragma Assert (Is_Write (Node));\n+            --     Write_Indent_Str (\"w#\");\n+            --  end if;\n+\n+            --  Write_Id (Target (Node));\n+            --  Write_Char ('#');\n+\n          when N_Variant =>\n             Write_Indent_Str_Sloc (\"when \");\n             Sprint_Bar_List (Discrete_Choices (Node));"}]}