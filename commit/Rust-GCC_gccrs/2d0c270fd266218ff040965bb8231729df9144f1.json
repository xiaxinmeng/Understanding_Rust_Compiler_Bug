{"sha": "2d0c270fd266218ff040965bb8231729df9144f1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmQwYzI3MGZkMjY2MjE4ZmYwNDA5NjViYjgyMzE3MjlkZjkxNDRmMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@codesourcery.com", "date": "2011-07-06T14:21:03Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2011-07-06T14:21:03Z"}, "message": "cse.c (find_comparison_args): Use val_mode_signbit_set_p.\n\n\t* cse.c (find_comparison_args): Use val_mode_signbit_set_p.\n\t* simplify-rtx.c (mode_signbit_p): Use GET_MODE_PRECISION.\n\t(val_mode_signbit_p, val_mode_signbit_set_p): New functions.\n\t(simplify_const_unary_operation, simplify_binary_operation_1,\n\tsimplify_const_binary_operation,\n\tsimplify_const_relational_operation): Use them.  Use\n\tGET_MODE_MASK for masking and sign-extensions.\n\t* combine.c (set_nonzero_bits_and_sign_copies, simplify_set,\n\tcombine_simplify_rtx, force_to_mode, reg_nonzero_bits_for_combine,\n\tsimplify_shift_const_1, simplify_comparison): Likewise.\n\t* expr.c (convert_modes): Likewise.\n\t* rtlanal.c (nonzero_bits1, canonicalize_condition): Likewise.\n\t* expmed.c (emit_cstore, emit_store_flag_1, emit_store_flag):\n\tLikewise.\n\t* rtl.h (val_mode_signbit_p, val_mode_signbit_set_p): Declare.\n\nFrom-SVN: r175917", "tree": {"sha": "2a2d891d415bcfdd26b794dc666ecd03b7565eee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a2d891d415bcfdd26b794dc666ecd03b7565eee"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2d0c270fd266218ff040965bb8231729df9144f1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d0c270fd266218ff040965bb8231729df9144f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d0c270fd266218ff040965bb8231729df9144f1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d0c270fd266218ff040965bb8231729df9144f1/comments", "author": null, "committer": null, "parents": [{"sha": "6d6c952527c53637280297b2e6a48d6b21606294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6d6c952527c53637280297b2e6a48d6b21606294", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6d6c952527c53637280297b2e6a48d6b21606294"}], "stats": {"total": 281, "additions": 147, "deletions": 134}, "files": [{"sha": "e06f36996e9fc398f6239be7852cf31a95a38a80", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -1,3 +1,21 @@\n+2011-07-06  Bernd Schmidt  <bernds@codesourcery.com>\n+\n+\t* cse.c (find_comparison_args): Use val_mode_signbit_set_p.\n+\t* simplify-rtx.c (mode_signbit_p): Use GET_MODE_PRECISION.\n+\t(val_mode_signbit_p, val_mode_signbit_set_p): New functions.\n+\t(simplify_const_unary_operation, simplify_binary_operation_1,\n+\tsimplify_const_binary_operation,\n+\tsimplify_const_relational_operation): Use them.  Use\n+\tGET_MODE_MASK for masking and sign-extensions.\n+\t* combine.c (set_nonzero_bits_and_sign_copies, simplify_set,\n+\tcombine_simplify_rtx, force_to_mode, reg_nonzero_bits_for_combine,\n+\tsimplify_shift_const_1, simplify_comparison): Likewise.\n+\t* expr.c (convert_modes): Likewise.\n+\t* rtlanal.c (nonzero_bits1, canonicalize_condition): Likewise.\n+\t* expmed.c (emit_cstore, emit_store_flag_1, emit_store_flag):\n+\tLikewise.\n+\t* rtl.h (val_mode_signbit_p, val_mode_signbit_set_p): Declare.\n+\n 2011-07-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49645"}, {"sha": "7ac4613955c1f14dfc9899cf869fbb2cbd895fcd", "filename": "gcc/combine.c", "status": "modified", "additions": 15, "deletions": 37, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -1627,15 +1627,11 @@ set_nonzero_bits_and_sign_copies (rtx x, const_rtx set, void *data)\n \t     ??? For 2.5, try to tighten up the MD files in this regard\n \t     instead of this kludge.  */\n \n-\t  if (GET_MODE_BITSIZE (GET_MODE (x)) < BITS_PER_WORD\n+\t  if (GET_MODE_PRECISION (GET_MODE (x)) < BITS_PER_WORD\n \t      && CONST_INT_P (src)\n \t      && INTVAL (src) > 0\n-\t      && 0 != (UINTVAL (src)\n-\t\t       & ((unsigned HOST_WIDE_INT) 1\n-\t\t\t  << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n-\t    src = GEN_INT (UINTVAL (src)\n-\t\t\t   | ((unsigned HOST_WIDE_INT) (-1)\n-\t\t\t      << GET_MODE_BITSIZE (GET_MODE (x))));\n+\t      && val_signbit_known_set_p (GET_MODE (x), INTVAL (src)))\n+\t    src = GEN_INT (INTVAL (src) | ~GET_MODE_MASK (GET_MODE (x)));\n #endif\n \n \t  /* Don't call nonzero_bits if it cannot change anything.  */\n@@ -5887,8 +5883,7 @@ combine_simplify_rtx (rtx x, enum machine_mode op0_mode, int in_dest,\n \t     going to test the sign bit.  */\n \t  if (new_code == NE && GET_MODE_CLASS (mode) == MODE_INT\n \t      && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t  == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n+\t      && val_signbit_p (mode, STORE_FLAG_VALUE)\n \t      && op1 == const0_rtx\n \t      && mode == GET_MODE (op0)\n \t      && (i = exact_log2 (nonzero_bits (op0, mode))) >= 0)\n@@ -6551,10 +6546,8 @@ simplify_set (rtx x)\n       enum machine_mode inner_mode = GET_MODE (inner);\n \n       /* Here we make sure that we don't have a sign bit on.  */\n-      if (GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && (nonzero_bits (inner, inner_mode)\n-\t      < ((unsigned HOST_WIDE_INT) 1\n-\t\t << (GET_MODE_BITSIZE (GET_MODE (src)) - 1))))\n+      if (val_signbit_known_clear_p (GET_MODE (src),\n+\t\t\t\t     nonzero_bits (inner, inner_mode)))\n \t{\n \t  SUBST (SET_SRC (x), inner);\n \t  src = SET_SRC (x);\n@@ -8445,9 +8438,7 @@ force_to_mode (rtx x, enum machine_mode mode, unsigned HOST_WIDE_INT mask,\n     case ASHIFTRT:\n       /* If we are just looking for the sign bit, we don't need this shift at\n \t all, even if it has a variable count.  */\n-      if (GET_MODE_BITSIZE (GET_MODE (x)) <= HOST_BITS_PER_WIDE_INT\n-\t  && (mask == ((unsigned HOST_WIDE_INT) 1\n-\t\t       << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n+      if (val_signbit_p (GET_MODE (x), mask))\n \treturn force_to_mode (XEXP (x, 0), mode, mask, next_select);\n \n       /* If this is a shift by a constant, get a mask that contains those bits\n@@ -9589,15 +9580,11 @@ reg_nonzero_bits_for_combine (const_rtx x, enum machine_mode mode,\n \t ??? For 2.5, try to tighten up the MD files in this regard\n \t instead of this kludge.  */\n \n-      if (GET_MODE_BITSIZE (GET_MODE (x)) < GET_MODE_BITSIZE (mode)\n+      if (GET_MODE_PRECISION (GET_MODE (x)) < GET_MODE_PRECISION (mode)\n \t  && CONST_INT_P (tem)\n \t  && INTVAL (tem) > 0\n-\t  && 0 != (UINTVAL (tem)\n-\t\t   & ((unsigned HOST_WIDE_INT) 1\n-\t\t      << (GET_MODE_BITSIZE (GET_MODE (x)) - 1))))\n-\ttem = GEN_INT (UINTVAL (tem)\n-\t\t       | ((unsigned HOST_WIDE_INT) (-1)\n-\t\t\t  << GET_MODE_BITSIZE (GET_MODE (x))));\n+\t  && val_signbit_known_set_p (GET_MODE (x), INTVAL (tem)))\n+\ttem = GEN_INT (INTVAL (tem) | ~GET_MODE_MASK (GET_MODE (x)));\n #endif\n       return tem;\n     }\n@@ -9987,11 +9974,9 @@ simplify_shift_const_1 (enum rtx_code code, enum machine_mode result_mode,\n \t ASHIFTRT to LSHIFTRT if we know the sign bit is clear.\n \t `make_compound_operation' will convert it to an ASHIFTRT for\n \t those machines (such as VAX) that don't have an LSHIFTRT.  */\n-      if (GET_MODE_BITSIZE (shift_mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && code == ASHIFTRT\n-\t  && ((nonzero_bits (varop, shift_mode)\n-\t       & ((unsigned HOST_WIDE_INT) 1\n-\t\t  << (GET_MODE_BITSIZE (shift_mode) - 1))) == 0))\n+      if (code == ASHIFTRT\n+\t  && val_signbit_known_clear_p (shift_mode,\n+\t\t\t\t\tnonzero_bits (varop, shift_mode)))\n \tcode = LSHIFTRT;\n \n       if (((code == LSHIFTRT\n@@ -11424,10 +11409,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  mode = GET_MODE (XEXP (op0, 0));\n \t  if (mode != VOIDmode && GET_MODE_CLASS (mode) == MODE_INT\n \t      && ! unsigned_comparison_p\n-\t      && (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n-\t      && ((unsigned HOST_WIDE_INT) const_op\n-\t\t  < (((unsigned HOST_WIDE_INT) 1\n-\t\t      << (GET_MODE_BITSIZE (mode) - 1))))\n+\t      && val_signbit_known_clear_p (mode, const_op)\n \t      && have_insn_for (COMPARE, mode))\n \t    {\n \t      op0 = XEXP (op0, 0);\n@@ -11614,11 +11596,7 @@ simplify_comparison (enum rtx_code code, rtx *pop0, rtx *pop1)\n \t  /* Check for the cases where we simply want the result of the\n \t     earlier test or the opposite of that result.  */\n \t  if (code == NE || code == EQ\n-\t      || (GET_MODE_BITSIZE (GET_MODE (op0)) <= HOST_BITS_PER_WIDE_INT\n-\t\t  && GET_MODE_CLASS (GET_MODE (op0)) == MODE_INT\n-\t\t  && (STORE_FLAG_VALUE\n-\t\t      & (((unsigned HOST_WIDE_INT) 1\n-\t\t\t  << (GET_MODE_BITSIZE (GET_MODE (op0)) - 1))))\n+\t      || (val_signbit_known_set_p (GET_MODE (op0), STORE_FLAG_VALUE)\n \t\t  && (code == LT || code == GE)))\n \t    {\n \t      enum rtx_code new_code;"}, {"sha": "9dc27c383e88e8251aa1367e614241d901f7fa70", "filename": "gcc/cse.c", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -3063,12 +3063,8 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t\t for STORE_FLAG_VALUE, also look at LT and GE operations.  */\n \t      || ((code == NE\n \t\t   || (code == LT\n-\t\t       && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t       && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t   <= HOST_BITS_PER_WIDE_INT)\n-\t\t       && (STORE_FLAG_VALUE\n-\t\t\t   & ((HOST_WIDE_INT) 1\n-\t\t\t      << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t       && val_signbit_known_set_p (inner_mode,\n+\t\t\t\t\t\t   STORE_FLAG_VALUE))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t   || (code == LT\n \t\t       && SCALAR_FLOAT_MODE_P (inner_mode)\n@@ -3083,12 +3079,8 @@ find_comparison_args (enum rtx_code code, rtx *parg1, rtx *parg2,\n \t    }\n \t  else if ((code == EQ\n \t\t    || (code == GE\n-\t\t\t&& GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t&& (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t    <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t&& (STORE_FLAG_VALUE\n-\t\t\t    & ((HOST_WIDE_INT) 1\n-\t\t\t       << (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t&& val_signbit_known_set_p (inner_mode,\n+\t\t\t\t\t\t    STORE_FLAG_VALUE))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t    || (code == GE\n \t\t\t&& SCALAR_FLOAT_MODE_P (inner_mode)"}, {"sha": "e9b6016cf8be53480cdb55e9399beb1ef5572c3e", "filename": "gcc/expmed.c", "status": "modified", "additions": 8, "deletions": 17, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -5039,10 +5039,8 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n   if (GET_MODE_SIZE (target_mode) > GET_MODE_SIZE (result_mode))\n     {\n       convert_move (target, subtarget,\n-\t\t    (GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT)\n-\t\t    && 0 == (STORE_FLAG_VALUE\n-\t\t\t     & ((HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (result_mode) -1))));\n+\t\t    val_signbit_known_clear_p (result_mode,\n+\t\t\t\t\t       STORE_FLAG_VALUE));\n       op0 = target;\n       result_mode = target_mode;\n     }\n@@ -5066,9 +5064,7 @@ emit_cstore (rtx target, enum insn_code icode, enum rtx_code code,\n   /* We don't want to use STORE_FLAG_VALUE < 0 below since this makes\n      it hard to use a value of just the sign bit due to ANSI integer\n      constant typing rules.  */\n-  else if (GET_MODE_BITSIZE (result_mode) <= HOST_BITS_PER_WIDE_INT\n-\t   && (STORE_FLAG_VALUE\n-\t       & ((HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (result_mode) - 1))))\n+  else if (val_signbit_known_set_p (result_mode, STORE_FLAG_VALUE))\n     op0 = expand_shift (RSHIFT_EXPR, result_mode, op0,\n \t\t\tGET_MODE_BITSIZE (result_mode) - 1, subtarget,\n \t\t\tnormalizep == 1);\n@@ -5206,9 +5202,9 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n \t    target = gen_reg_rtx (target_mode);\n \n \t  convert_move (target, tem,\n-\t\t\t0 == ((normalizep ? normalizep : STORE_FLAG_VALUE)\n-\t\t\t      & ((HOST_WIDE_INT) 1\n-\t\t\t\t << (GET_MODE_BITSIZE (word_mode) -1))));\n+\t\t\t!val_signbit_known_set_p (word_mode,\n+\t\t\t\t\t\t  (normalizep ? normalizep\n+\t\t\t\t\t\t   : STORE_FLAG_VALUE)));\n \t  return target;\n \t}\n     }\n@@ -5218,10 +5214,7 @@ emit_store_flag_1 (rtx target, enum rtx_code code, rtx op0, rtx op1,\n   if (op1 == const0_rtx && (code == LT || code == GE)\n       && GET_MODE_CLASS (mode) == MODE_INT\n       && (normalizep || STORE_FLAG_VALUE == 1\n-\t  || (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t      && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t  == ((unsigned HOST_WIDE_INT) 1\n-\t\t      << (GET_MODE_BITSIZE (mode) - 1))))))\n+\t  || val_signbit_p (mode, STORE_FLAG_VALUE)))\n     {\n       subtarget = target;\n \n@@ -5330,9 +5323,7 @@ emit_store_flag (rtx target, enum rtx_code code, rtx op0, rtx op1,\n       if (STORE_FLAG_VALUE == 1 || STORE_FLAG_VALUE == -1)\n \tnormalizep = STORE_FLAG_VALUE;\n \n-      else if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t       && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t\t   == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1)))\n+      else if (val_signbit_p (mode, STORE_FLAG_VALUE))\n \t;\n       else\n \treturn 0;"}, {"sha": "e225d245a044f21574731fd98f8cc4a80caa6dff", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -764,14 +764,13 @@ convert_modes (enum machine_mode mode, enum machine_mode oldmode, rtx x, int uns\n \t  && GET_MODE_SIZE (mode) > GET_MODE_SIZE (oldmode))\n \t{\n \t  HOST_WIDE_INT val = INTVAL (x);\n-\t  int width = GET_MODE_BITSIZE (oldmode);\n \n \t  /* We must sign or zero-extend in this case.  Start by\n \t     zero-extending, then sign extend if we need to.  */\n-\t  val &= ((HOST_WIDE_INT) 1 << width) - 1;\n+\t  val &= GET_MODE_MASK (oldmode);\n \t  if (! unsignedp\n-\t      && (val & ((HOST_WIDE_INT) 1 << (width - 1))))\n-\t    val |= (HOST_WIDE_INT) (-1) << width;\n+\t      && val_signbit_known_set_p (oldmode, val))\n+\t    val |= ~GET_MODE_MASK (oldmode);\n \n \t  return gen_int_mode (val, mode);\n \t}"}, {"sha": "2f2aaca7b426d21ac8687d0518eccb20faaaa1f6", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -1816,6 +1816,11 @@ extern rtx simplify_rtx (const_rtx);\n extern rtx avoid_constant_pool_reference (rtx);\n extern rtx delegitimize_mem_from_attrs (rtx);\n extern bool mode_signbit_p (enum machine_mode, const_rtx);\n+extern bool val_signbit_p (enum machine_mode, unsigned HOST_WIDE_INT);\n+extern bool val_signbit_known_set_p (enum machine_mode,\n+\t\t\t\t     unsigned HOST_WIDE_INT);\n+extern bool val_signbit_known_clear_p (enum machine_mode,\n+\t\t\t\t       unsigned HOST_WIDE_INT);\n \n /* In reginfo.c  */\n extern enum machine_mode choose_hard_reg_mode (unsigned int, unsigned int,"}, {"sha": "9ac347ed0fa5b6768e84a592c5bc7fb2917bbf5c", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 14, "deletions": 26, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -3849,6 +3849,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n   unsigned HOST_WIDE_INT nonzero = GET_MODE_MASK (mode);\n   unsigned HOST_WIDE_INT inner_nz;\n   enum rtx_code code;\n+  enum machine_mode inner_mode;\n   unsigned int mode_width = GET_MODE_BITSIZE (mode);\n \n   /* For floating-point and vector values, assume all bits are needed.  */\n@@ -4028,9 +4029,7 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n       if (GET_MODE (XEXP (x, 0)) != VOIDmode)\n \t{\n \t  inner_nz &= GET_MODE_MASK (GET_MODE (XEXP (x, 0)));\n-\t  if (inner_nz\n-\t      & (((unsigned HOST_WIDE_INT) 1\n-\t\t  << (GET_MODE_BITSIZE (GET_MODE (XEXP (x, 0))) - 1))))\n+\t  if (val_signbit_known_set_p (GET_MODE (XEXP (x, 0)), inner_nz))\n \t    inner_nz |= (GET_MODE_MASK (mode)\n \t\t\t & ~GET_MODE_MASK (GET_MODE (XEXP (x, 0))));\n \t}\n@@ -4153,35 +4152,32 @@ nonzero_bits1 (const_rtx x, enum machine_mode mode, const_rtx known_x,\n \t\t  & cached_nonzero_bits (SUBREG_REG (x), GET_MODE (x),\n \t\t\t\t\t known_x, known_mode, known_ret);\n \n+      inner_mode = GET_MODE (SUBREG_REG (x));\n       /* If the inner mode is a single word for both the host and target\n \t machines, we can compute this from which bits of the inner\n \t object might be nonzero.  */\n-      if (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) <= BITS_PER_WORD\n-\t  && (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x)))\n-\t      <= HOST_BITS_PER_WIDE_INT))\n+      if (GET_MODE_BITSIZE (inner_mode) <= BITS_PER_WORD\n+\t  && (GET_MODE_BITSIZE (inner_mode) <= HOST_BITS_PER_WIDE_INT))\n \t{\n \t  nonzero &= cached_nonzero_bits (SUBREG_REG (x), mode,\n \t\t\t\t\t  known_x, known_mode, known_ret);\n \n #if defined (WORD_REGISTER_OPERATIONS) && defined (LOAD_EXTEND_OP)\n \t  /* If this is a typical RISC machine, we only have to worry\n \t     about the way loads are extended.  */\n-\t  if ((LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) == SIGN_EXTEND\n-\t       ? (((nonzero\n-\t\t    & (((unsigned HOST_WIDE_INT) 1\n-\t\t\t<< (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (x))) - 1))))\n-\t\t   != 0))\n-\t       : LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (x))) != ZERO_EXTEND)\n+\t  if ((LOAD_EXTEND_OP (inner_mode) == SIGN_EXTEND\n+\t       ? val_signbit_known_set_p (inner_mode, nonzero)\n+\t       : LOAD_EXTEND_OP (inner_mode) != ZERO_EXTEND)\n \t      || !MEM_P (SUBREG_REG (x)))\n #endif\n \t    {\n \t      /* On many CISC machines, accessing an object in a wider mode\n \t\t causes the high-order bits to become undefined.  So they are\n \t\t not known to be zero.  */\n \t      if (GET_MODE_SIZE (GET_MODE (x))\n-\t\t  > GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))))\n+\t\t  > GET_MODE_SIZE (inner_mode))\n \t\tnonzero |= (GET_MODE_MASK (GET_MODE (x))\n-\t\t\t    & ~GET_MODE_MASK (GET_MODE (SUBREG_REG (x))));\n+\t\t\t    & ~GET_MODE_MASK (inner_mode));\n \t    }\n \t}\n       break;\n@@ -4921,12 +4917,8 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t  if ((GET_CODE (SET_SRC (set)) == COMPARE\n \t       || (((code == NE\n \t\t     || (code == LT\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((unsigned HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t && val_signbit_known_set_p (inner_mode,\n+\t\t\t\t\t\t     STORE_FLAG_VALUE))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == LT\n \t\t\t && SCALAR_FLOAT_MODE_P (inner_mode)\n@@ -4941,12 +4933,8 @@ canonicalize_condition (rtx insn, rtx cond, int reverse, rtx *earliest,\n \t    x = SET_SRC (set);\n \t  else if (((code == EQ\n \t\t     || (code == GE\n-\t\t\t && (GET_MODE_BITSIZE (inner_mode)\n-\t\t\t     <= HOST_BITS_PER_WIDE_INT)\n-\t\t\t && GET_MODE_CLASS (inner_mode) == MODE_INT\n-\t\t\t && (STORE_FLAG_VALUE\n-\t\t\t     & ((unsigned HOST_WIDE_INT) 1\n-\t\t\t\t<< (GET_MODE_BITSIZE (inner_mode) - 1))))\n+\t\t\t && val_signbit_known_set_p (inner_mode,\n+\t\t\t\t\t\t     STORE_FLAG_VALUE))\n #ifdef FLOAT_STORE_FLAG_VALUE\n \t\t     || (code == GE\n \t\t\t && SCALAR_FLOAT_MODE_P (inner_mode)"}, {"sha": "6a5ec1a1bfa8d4ca9f608423d8c93e1fb10535b5", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 80, "deletions": 38, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2d0c270fd266218ff040965bb8231729df9144f1/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=2d0c270fd266218ff040965bb8231729df9144f1", "patch": "@@ -82,7 +82,7 @@ mode_signbit_p (enum machine_mode mode, const_rtx x)\n   if (GET_MODE_CLASS (mode) != MODE_INT)\n     return false;\n \n-  width = GET_MODE_BITSIZE (mode);\n+  width = GET_MODE_PRECISION (mode);\n   if (width == 0)\n     return false;\n \n@@ -103,6 +103,62 @@ mode_signbit_p (enum machine_mode mode, const_rtx x)\n     val &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n   return val == ((unsigned HOST_WIDE_INT) 1 << (width - 1));\n }\n+\n+/* Test whether VAL is equal to the most significant bit of mode MODE\n+   (after masking with the mode mask of MODE).  Returns false if the\n+   precision of MODE is too large to handle.  */\n+\n+bool\n+val_signbit_p (enum machine_mode mode, unsigned HOST_WIDE_INT val)\n+{\n+  unsigned int width;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return false;\n+\n+  width = GET_MODE_PRECISION (mode);\n+  if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n+    return false;\n+\n+  val &= GET_MODE_MASK (mode);\n+  return val == ((unsigned HOST_WIDE_INT) 1 << (width - 1));\n+}\n+\n+/* Test whether the most significant bit of mode MODE is set in VAL.\n+   Returns false if the precision of MODE is too large to handle.  */\n+bool\n+val_signbit_known_set_p (enum machine_mode mode, unsigned HOST_WIDE_INT val)\n+{\n+  unsigned int width;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return false;\n+\n+  width = GET_MODE_PRECISION (mode);\n+  if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n+    return false;\n+\n+  val &= (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+  return val != 0;\n+}\n+\n+/* Test whether the most significant bit of mode MODE is clear in VAL.\n+   Returns false if the precision of MODE is too large to handle.  */\n+bool\n+val_signbit_known_clear_p (enum machine_mode mode, unsigned HOST_WIDE_INT val)\n+{\n+  unsigned int width;\n+\n+  if (GET_MODE_CLASS (mode) != MODE_INT)\n+    return false;\n+\n+  width = GET_MODE_PRECISION (mode);\n+  if (width == 0 || width > HOST_BITS_PER_WIDE_INT)\n+    return false;\n+\n+  val &= (unsigned HOST_WIDE_INT) 1 << (width - 1);\n+  return val == 0;\n+}\n \f\n /* Make a binary operation by properly ordering the operands and\n    seeing if the expression folds.  */\n@@ -908,12 +964,8 @@ simplify_unary_operation_1 (enum rtx_code code, enum machine_mode mode, rtx op)\n \n       /* If operand is something known to be positive, ignore the ABS.  */\n       if (GET_CODE (op) == FFS || GET_CODE (op) == ABS\n-\t  || ((GET_MODE_BITSIZE (GET_MODE (op))\n-\t       <= HOST_BITS_PER_WIDE_INT)\n-\t      && ((nonzero_bits (op, GET_MODE (op))\n-\t\t   & ((unsigned HOST_WIDE_INT) 1\n-\t\t      << (GET_MODE_BITSIZE (GET_MODE (op)) - 1)))\n-\t\t  == 0)))\n+\t  || val_signbit_known_clear_p (GET_MODE (op),\n+\t\t\t\t\tnonzero_bits (op, GET_MODE (op))))\n \treturn op;\n \n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n@@ -1425,8 +1477,7 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t      val = arg0;\n \t    }\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n-\t    val = arg0 & ~((unsigned HOST_WIDE_INT) (-1)\n-\t\t\t   << GET_MODE_BITSIZE (op_mode));\n+\t    val = arg0 & GET_MODE_MASK (op_mode);\n \t  else\n \t    return 0;\n \t  break;\n@@ -1444,13 +1495,9 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t    }\n \t  else if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      val\n-\t\t= arg0 & ~((unsigned HOST_WIDE_INT) (-1)\n-\t\t\t   << GET_MODE_BITSIZE (op_mode));\n-\t      if (val & ((unsigned HOST_WIDE_INT) 1\n-\t\t\t << (GET_MODE_BITSIZE (op_mode) - 1)))\n-\t\tval\n-\t\t  -= (unsigned HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n+\t      val = arg0 & GET_MODE_MASK (op_mode);\n+\t      if (val_signbit_known_set_p (op_mode, val))\n+\t\tval |= ~GET_MODE_MASK (op_mode);\n \t    }\n \t  else\n \t    return 0;\n@@ -1602,10 +1649,8 @@ simplify_const_unary_operation (enum rtx_code code, enum machine_mode mode,\n \t  else\n \t    {\n \t      lv = l1 & GET_MODE_MASK (op_mode);\n-\t      if (GET_MODE_BITSIZE (op_mode) < HOST_BITS_PER_WIDE_INT\n-\t\t  && (lv & ((unsigned HOST_WIDE_INT) 1\n-\t\t\t    << (GET_MODE_BITSIZE (op_mode) - 1))) != 0)\n-\t\tlv -= (unsigned HOST_WIDE_INT) 1 << GET_MODE_BITSIZE (op_mode);\n+\t      if (val_signbit_known_set_p (op_mode, lv))\n+\t\tlv |= ~GET_MODE_MASK (op_mode);\n \n \t      hv = HWI_SIGN_EXTEND (lv);\n \t    }\n@@ -2663,9 +2708,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n-      if (GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT\n-\t  && ((STORE_FLAG_VALUE & GET_MODE_MASK (mode))\n-\t      == (unsigned HOST_WIDE_INT) 1 << (GET_MODE_BITSIZE (mode) - 1))\n+      if (val_signbit_p (mode, STORE_FLAG_VALUE)\n \t  && trueop1 == const_true_rtx\n \t  && COMPARISON_P (op0)\n \t  && (reversed = reversed_comparison (op0, mode)))\n@@ -3028,8 +3071,7 @@ simplify_binary_operation_1 (enum rtx_code code, enum machine_mode mode,\n \n     case SMIN:\n       if (width <= HOST_BITS_PER_WIDE_INT\n-\t  && CONST_INT_P (trueop1)\n-\t  && UINTVAL (trueop1) == (unsigned HOST_WIDE_INT) 1 << (width -1)\n+\t  && mode_signbit_p (mode, trueop1)\n \t  && ! side_effects_p (op0))\n \treturn op1;\n       if (rtx_equal_p (trueop0, trueop1) && ! side_effects_p (op0))\n@@ -3634,16 +3676,16 @@ simplify_const_binary_operation (enum rtx_code code, enum machine_mode mode,\n \n       if (width < HOST_BITS_PER_WIDE_INT)\n         {\n-          arg0 &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n-          arg1 &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+          arg0 &= GET_MODE_MASK (mode);\n+          arg1 &= GET_MODE_MASK (mode);\n \n           arg0s = arg0;\n-          if (arg0s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n-\t    arg0s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n+\t  if (val_signbit_known_set_p (mode, arg0s))\n+\t    arg0s |= ~GET_MODE_MASK (mode);\n \n-\t  arg1s = arg1;\n-\t  if (arg1s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n-\t    arg1s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n+          arg1s = arg1;\n+\t  if (val_signbit_known_set_p (mode, arg1s))\n+\t    arg1s |= ~GET_MODE_MASK (mode);\n \t}\n       else\n \t{\n@@ -4616,14 +4658,14 @@ simplify_const_relational_operation (enum rtx_code code,\n \t we have to sign or zero-extend the values.  */\n       if (width != 0 && width < HOST_BITS_PER_WIDE_INT)\n \t{\n-\t  l0u &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n-\t  l1u &= ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+\t  l0u &= GET_MODE_MASK (mode);\n+\t  l1u &= GET_MODE_MASK (mode);\n \n-\t  if (l0s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n-\t    l0s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n+\t  if (val_signbit_known_set_p (mode, l0s))\n+\t    l0s |= ~GET_MODE_MASK (mode);\n \n-\t  if (l1s & ((unsigned HOST_WIDE_INT) 1 << (width - 1)))\n-\t    l1s |= ((unsigned HOST_WIDE_INT) (-1) << width);\n+\t  if (val_signbit_known_set_p (mode, l1s))\n+\t    l1s |= ~GET_MODE_MASK (mode);\n \t}\n       if (width != 0 && width <= HOST_BITS_PER_WIDE_INT)\n \th0u = h1u = 0, h0s = HWI_SIGN_EXTEND (l0s), h1s = HWI_SIGN_EXTEND (l1s);"}]}