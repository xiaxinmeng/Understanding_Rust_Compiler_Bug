{"sha": "9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTk1MjkwOGE0YjZjZjczZThkZTExYWY2MWUxZDJjNGQ2N2UxYjUzMA==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2016-09-13T19:20:38Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2016-09-13T19:20:38Z"}, "message": "Implement P0028R4, C++17 using attribute namespaces without repetition\n\n\tImplement P0028R4, C++17 using attribute namespaces without repetition\n\t* parser.c (cp_parser_std_attribute): Add ATTR_NS argument.  Diagnose\n\tnon-NULL ATTR_NS with scoped attribute token.  Handle non-NULL\n\tATTR_NS with non-scoped attribute tokens.  Allow named ops in\n\tidentifier after ::.\n\t(cp_parser_std_attribute_list): Add ATTR_NS argument, pass it down\n\tto cp_parser_std_attribute calls.\n\t(cp_parser_std_attribute_spec): Parse optional C++17\n\tattribute-using-prefix, adjust grammar in function comment.\n\n\t* g++.dg/cpp0x/gen-attrs-61.C: New test.\n\t* g++.dg/cpp1z/gen-attrs1.C: New test.\n\nFrom-SVN: r240121", "tree": {"sha": "74f623c862618a148b54782ef57d24472a7727cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/74f623c862618a148b54782ef57d24472a7727cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "63cdb7a08d7f80b32ba7704b72136fff7ae9f995", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63cdb7a08d7f80b32ba7704b72136fff7ae9f995", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63cdb7a08d7f80b32ba7704b72136fff7ae9f995"}], "stats": {"total": 120, "additions": 113, "deletions": 7}, "files": [{"sha": "97e9cda97ceca701406184abec4780a581582cf1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "patch": "@@ -1,5 +1,15 @@\n 2016-09-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\tImplement P0028R4, C++17 using attribute namespaces without repetition\n+\t* parser.c (cp_parser_std_attribute): Add ATTR_NS argument.  Diagnose\n+\tnon-NULL ATTR_NS with scoped attribute token.  Handle non-NULL\n+\tATTR_NS with non-scoped attribute tokens.  Allow named ops in\n+\tidentifier after ::.\n+\t(cp_parser_std_attribute_list): Add ATTR_NS argument, pass it down\n+\tto cp_parser_std_attribute calls.\n+\t(cp_parser_std_attribute_spec): Parse optional C++17\n+\tattribute-using-prefix, adjust grammar in function comment.\n+\n \tPR c++/77553\n \t* constexpr.c (cxx_fold_pointer_plus_expression): New function.\n \t(cxx_eval_binary_expression): Use it for POINTER_PLUS_EXPR."}, {"sha": "d704593e6aa283819290e82c0f14e2266dfbd112", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 47, "deletions": 7, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "patch": "@@ -2392,7 +2392,7 @@ static tree cp_parser_gnu_attributes_opt\n static tree cp_parser_gnu_attribute_list\n   (cp_parser *);\n static tree cp_parser_std_attribute\n-  (cp_parser *);\n+  (cp_parser *, tree);\n static tree cp_parser_std_attribute_spec\n   (cp_parser *);\n static tree cp_parser_std_attribute_spec_seq\n@@ -24056,9 +24056,9 @@ cp_parser_gnu_attribute_list (cp_parser* parser)\n       { balanced-token-seq }.  */\n \n static tree\n-cp_parser_std_attribute (cp_parser *parser)\n+cp_parser_std_attribute (cp_parser *parser, tree attr_ns)\n {\n-  tree attribute, attr_ns = NULL_TREE, attr_id = NULL_TREE, arguments;\n+  tree attribute, attr_id = NULL_TREE, arguments;\n   cp_token *token;\n \n   /* First, parse name of the attribute, a.k.a attribute-token.  */\n@@ -24082,13 +24082,18 @@ cp_parser_std_attribute (cp_parser *parser)\n       /* We are seeing a scoped attribute token.  */\n \n       cp_lexer_consume_token (parser->lexer);\n+      if (attr_ns)\n+\terror_at (token->location, \"attribute using prefix used together \"\n+\t\t\t\t   \"with scoped attribute token\");\n       attr_ns = attr_id;\n \n       token = cp_lexer_consume_token (parser->lexer);\n       if (token->type == CPP_NAME)\n \tattr_id = token->u.value;\n       else if (token->type == CPP_KEYWORD)\n \tattr_id = ridpointers[(int) token->keyword];\n+      else if (token->flags & NAMED_OP)\n+\tattr_id = get_identifier (cpp_type2name (token->type, token->flags));\n       else\n \t{\n \t  error_at (token->location,\n@@ -24099,6 +24104,9 @@ cp_parser_std_attribute (cp_parser *parser)\n \t\t\t\t   NULL_TREE);\n       token = cp_lexer_peek_token (parser->lexer);\n     }\n+  else if (attr_ns)\n+    attribute = build_tree_list (build_tree_list (attr_ns, attr_id),\n+\t\t\t\t NULL_TREE);\n   else\n     {\n       attribute = build_tree_list (build_tree_list (NULL_TREE, attr_id),\n@@ -24192,14 +24200,14 @@ cp_parser_check_std_attribute (tree attributes, tree attribute)\n */\n \n static tree\n-cp_parser_std_attribute_list (cp_parser *parser)\n+cp_parser_std_attribute_list (cp_parser *parser, tree attr_ns)\n {\n   tree attributes = NULL_TREE, attribute = NULL_TREE;\n   cp_token *token = NULL;\n \n   while (true)\n     {\n-      attribute = cp_parser_std_attribute (parser);\n+      attribute = cp_parser_std_attribute (parser, attr_ns);\n       if (attribute == error_mark_node)\n \tbreak;\n       if (attribute != NULL_TREE)\n@@ -24227,9 +24235,12 @@ cp_parser_std_attribute_list (cp_parser *parser)\n /* Parse a standard C++-11 attribute specifier.\n \n    attribute-specifier:\n-     [ [ attribute-list ] ]\n+     [ [ attribute-using-prefix [opt] attribute-list ] ]\n      alignment-specifier\n \n+   attribute-using-prefix:\n+     using attribute-namespace :\n+\n    alignment-specifier:\n      alignas ( type-id ... [opt] )\n      alignas ( alignment-expression ... [opt] ).  */\n@@ -24243,10 +24254,39 @@ cp_parser_std_attribute_spec (cp_parser *parser)\n   if (token->type == CPP_OPEN_SQUARE\n       && cp_lexer_peek_nth_token (parser->lexer, 2)->type == CPP_OPEN_SQUARE)\n     {\n+      tree attr_ns = NULL_TREE;\n+\n       cp_lexer_consume_token (parser->lexer);\n       cp_lexer_consume_token (parser->lexer);\n \n-      attributes = cp_parser_std_attribute_list (parser);\n+      if (cp_lexer_next_token_is_keyword (parser->lexer, RID_USING))\n+\t{\n+\t  token = cp_lexer_peek_nth_token (parser->lexer, 2);\n+\t  if (token->type == CPP_NAME)\n+\t    attr_ns = token->u.value;\n+\t  else if (token->type == CPP_KEYWORD)\n+\t    attr_ns = ridpointers[(int) token->keyword];\n+\t  else if (token->flags & NAMED_OP)\n+\t    attr_ns = get_identifier (cpp_type2name (token->type,\n+\t\t\t\t\t\t     token->flags));\n+\t  if (attr_ns\n+\t      && cp_lexer_nth_token_is (parser->lexer, 3, CPP_COLON))\n+\t    {\n+\t      if (cxx_dialect < cxx1z\n+\t\t  && !in_system_header_at (input_location))\n+\t\tpedwarn (input_location, 0,\n+\t\t\t \"attribute using prefix only available \"\n+\t\t\t \"with -std=c++1z or -std=gnu++1z\");\n+\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t      cp_lexer_consume_token (parser->lexer);\n+\t    }\n+\t  else\n+\t    attr_ns = NULL_TREE;\n+\t}\n+\n+      attributes = cp_parser_std_attribute_list (parser, attr_ns);\n \n       if (!cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE)\n \t  || !cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))"}, {"sha": "779145a05fd7472f3a5ae3a7f7e243695c88c569", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "patch": "@@ -1,5 +1,8 @@\n 2016-09-13  Jakub Jelinek  <jakub@redhat.com>\n \n+\t* g++.dg/cpp0x/gen-attrs-61.C: New test.\n+\t* g++.dg/cpp1z/gen-attrs1.C: New test.\n+\n \tPR tree-optimization/77454\n \t* gcc.dg/pr77454.c: New test.\n "}, {"sha": "fd7f4437dbb023efe5be453d97036161b7e42162", "filename": "gcc/testsuite/g++.dg/cpp0x/gen-attrs-61.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-61.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-61.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fgen-attrs-61.C?ref=9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "patch": "@@ -0,0 +1,10 @@\n+// { dg-do compile { target c++11 } }\n+int\n+foo ()\n+{\n+  int i [[and::bitor, bar::xor_eq, compl::baz(1), bitand::xor_eq(2, 3)]]; // { dg-warning \"ignored\" }\n+  int j [[using, using::baz, bar::using, using::using (2)]];\t\t  // { dg-warning \"ignored\" }\n+  i = 0;\n+  j = 0;\n+  return i + j;\n+}"}, {"sha": "fe1ebb29a1d1a232b6844a2a04ff3613e2d90056", "filename": "gcc/testsuite/g++.dg/cpp1z/gen-attrs1.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fgen-attrs1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9952908a4b6cf73e8de11af61e1d2c4d67e1b530/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fgen-attrs1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp1z%2Fgen-attrs1.C?ref=9952908a4b6cf73e8de11af61e1d2c4d67e1b530", "patch": "@@ -0,0 +1,43 @@\n+// { dg-do compile { target c++11 } }\n+// { dg-options \"\" }\n+\n+int\n+foo ()\n+{\n+  static int a [[using gnu: unused, used]];\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } }\n+  int b [[ using foo : bar (2), baz ]];\t\t// { dg-warning \"'foo::bar' scoped attribute directive ignored\" }\n+\t\t\t\t\t\t// { dg-warning \"'foo::baz' scoped attribute directive ignored\" \"\" { target *-*-* } 8 }\n+\t\t\t\t\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } 8 }\n+  int c [[ using foo : using (\"foo\")]];\t\t// { dg-warning \"'foo::using' scoped attribute directive ignored\" }\n+\t\t\t\t\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } 11 }\n+  b = 0;\n+  c = 0;\n+  return b + c;\n+}\n+\n+int\n+bar ()\n+{\n+  int a [[ using BAR: foo::bar]];\t\t// { dg-error \"attribute using prefix used together with scoped attribute token\" }\n+\t\t\t\t\t\t// { dg-warning \"ignored\" \"\" { target *-*-* } 21 }\n+\t\t\t\t\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } 21 }\n+  int b [[ using BAZ: bar(2), bar::bar(3, 4) ]];// { dg-error \"attribute using prefix used together with scoped attribute token\" }\n+\t\t\t\t\t\t// { dg-warning \"ignored\" \"\" { target *-*-* } 24 }\n+\t\t\t\t\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } 24 }\n+  a = 0;\n+  b = 0;\n+  return a + b;\n+}\n+\n+int\n+baz ()\n+{\n+  int a [[ using using: using]];\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } }\n+\t\t\t\t\t\t// { dg-warning \"'using::using' scoped attribute directive ignored\" \"\" { target *-*-* } 35 }\n+  int b [[ using bitand: bitor, xor]];\t\t// { dg-warning \"attribute using prefix only available\" \"\" { target c++14_down } }\n+\t\t\t\t\t\t// { dg-warning \"'bitand::bitor' scoped attribute directive ignored\" \"\" { target *-*-* } 37 }\n+\t\t\t\t\t\t// { dg-warning \"'bitand::xor' scoped attribute directive ignored\" \"\" { target *-*-* } 37 }\n+  a = 0;\n+  b = 0;\n+  return a + b;\n+}"}]}