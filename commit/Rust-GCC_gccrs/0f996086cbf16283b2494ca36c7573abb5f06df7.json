{"sha": "0f996086cbf16283b2494ca36c7573abb5f06df7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY5OTYwODZjYmYxNjI4M2IyNDk0Y2EzNmM3NTczYWJiNWYwNmRmNw==", "commit": {"author": {"name": "Chao-ying Fu", "email": "fu@mips.com", "date": "2007-09-07T01:24:09Z"}, "committer": {"name": "Chao-ying Fu", "email": "chaoyingfu@gcc.gnu.org", "date": "2007-09-07T01:24:09Z"}, "message": "stdfix.h: New file.\n\n\t* ginclude/stdfix.h: New file.\n\t* Makefile.in (USER_H): Add $(srcdir)/ginclude/stdfix.h.\n\t(convert.o): Add dependence on fixed-value.h.\n\t* c-convert.c (convert): Support FIXED_POINT_TYPE.\n\t* c-cppbuiltin.c (builtin_define_fixed_point_constants): New function\n\tto define fixed-point constants.\n\t(c_cpp_builtins): Define fixed-point constants.\n\t* convert.c (fixed-value.h): New include.\n\t(convert_to_real): Update comment to include fixed-point.\n\tSupport FIXED_POINT_TYPE.\n\t(convert_to_integer): Update comment to include fixed-point.\n\tSupport FIXED_POINT_TYPE.\n\t(convert_to_complex): Support FIXED_POINT_TYPE.\n\t(convert_to_fixed): New function.\n\t* convert.h (convert_to_fixed): Declare.\n\t* genopinit.c: Add comment about $Q for only fixed-point modes.\n\t(optabs): Add fract_optab, fractuns_optab, satfract_optab,\n\tsatfractuns_optab, add_optab, ssadd_optab, usadd_optab, sub_optab,\n\tsssub_optab, ussub_optab, smul_optab, ssmul_optab, usmul_optab,\n\tssmadd_widen_optab, usmadd_widen_optab, ssdiv_optab, udiv_optab,\n\tusdiv_optab, ssashl_optab, usashl_optab, neg_optab, ssneg_optab,\n\tusneg_optab for fixed-point modes.\n\t(gen_insn): Add force_fixed to track the $Q format for all fixed-point\n\tmodes.\n\t* optabs.c (optab_for_tree_code): For *DIV_EXPR, LSHIFT_EXPR,\n\tPLUS_EXPR, MINUS_EXPR, MULT_EXPR, NEGATE_EXPR, return signed or\n\tunsigned saturation optabs, when type is saturating.\n\t(shift_optab_p): Return true for SS_ASHIFT or US_ASHIFT.\n\t(expand_fixed_convert): New function.\n\t(gen_fixed_libfunc, gen_signed_fixed_libfunc,\n\tgen_unsigned_fixed_libfunc, gen_int_fp_fixed_libfunc,\n\tgen_int_fp_signed_fixed_libfunc, gen_int_fixed_libfunc,\n\tgen_int_signed_fixed_libfunc, gen_int_unsigned_fixed_libfunc,\n\tgen_fract_conv_libfunc, gen_fractuns_conv_libfunc,\n\tgen_satfract_conv_libfunc, gen_satfractuns_conv_libfunc): New\n\tfunctions.\n\t(init_optabs): Initialize ssadd_optab, usadd_optab, sssub_optab,\n\tussub_optab, ssmul_optab, usmul_optab, ssmadd_widen_optab,\n\tusmadd_widen_optab, ssmsub_widen_optab, usmsub_widen_optab,\n\tssdiv_optab, usdiv_optab, ssashl_optab, usashl_optab, ssneg_optab,\n\tusneg_optab, fract_optab, fractuns_optab, satfract_optab,\n\tsatfractuns_optab.\n\tInitialize fixed-point libraries, including add, ssadd, usadd, sub,\n\tsssub, ussub, mul, ssmul, usmul, div, ssdiv, udiv, usdiv, ashl,\n\tssashl, usashl, ashr, lshr, neg, ssneg, usneg, cmp, fract, satfract,\n\tfractuns, satfractuns.\n\t* optabs.h (enum optab_index): Add OTI_ssadd, OTI_usadd, OTI_sssub,\n\tOTI_ussub, OTI_ssmul, OTI_usmul, OTI_ssdiv, OTI_usdiv, OTI_ssneg,\n\tOTI_usneg, OTI_ssashl, OTI_usashl, OTI_ssmadd_widen, OTI_usmadd_widen,\n\tOTI_ssmsub_widen,  OTI_usmsub_widen.\n\t(ssadd_optab, usadd_optab, sssub_optab, ussub_optab, ssmul_optab,\n\tusmul_optab, ssdiv_optab, usdiv_optab, ssneg_optab, usneg_optab,\n\tssashl_optab, usashl_optab, ssmadd_widen_optab, usmadd_widen_optab,\n\tumsub_widen_optab, usmsub_widen_optab): Define.\n\t(enum convert_optab_index): Add COI_fract, COI_fractuns, COI_satfract,\n\tCOI_satfractuns.\n\t(fract_optab, fractuns_optab, satfract_optab, satfractuns_optab):\n\tDefine.\n\t(expand_fixed_convert): Declare.\n\t* expr.c (convert_move): Support the move of fixed-point modes.\n\t(emit_move_insn_1): Handle fixed-point mode to move via integer.\n\t(categorize_ctor_elements_1): Handle FIXED_CST.\n\t(count_type_elements): Handle FIXED_POINT_TYPE.\n\t(expand_expr_real_1): For VECTOR_CST, check MODE_VECTOR_FRACT,\n\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\tSupport FIXED_CST.\n\tFor PLUS_EXPR and MINUS_EXPR, support saturating and non-saturating\n\tmultiply and add/subtract for fixed-point types.\n\tFor MULT_EXPR, *DIV_EXPR, *SHIFT_EXPR, if the mode if a fixed-point\n\tmode, we jump to binop directly.\n\tSupport FIXED_CONVERT_EXPR.\n\t(do_store_flag): Check FIXED_CST to put a constant second.\n\t(vector_mode_valid_p): Handle MODE_VECTOR_FRACT,\n\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n\t(const_vector_from_tree): Support FIXED_CST.\n\t* doc/extend.texi (Fixed-Point): New node.\n\t* doc/md.texi (ssadd, usadd, sssub, ussub, ssmul, usmul, ssdiv, usdiv,\n\tssmadd, usmadd, ssmsub, usmsub, ssashl, usashl, ssneg, usneg, fract,\n\tsatfract, fractuns, satfractuns): Document them.\n\nFrom-SVN: r128218", "tree": {"sha": "efee8ca8b1b0b17d1b3afab3a5bc101a5bfb2b1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/efee8ca8b1b0b17d1b3afab3a5bc101a5bfb2b1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f996086cbf16283b2494ca36c7573abb5f06df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f996086cbf16283b2494ca36c7573abb5f06df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f996086cbf16283b2494ca36c7573abb5f06df7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f996086cbf16283b2494ca36c7573abb5f06df7/comments", "author": null, "committer": null, "parents": [{"sha": "58cfe6985ba4e4050a48ebc29dd7835260d5c58e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58cfe6985ba4e4050a48ebc29dd7835260d5c58e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58cfe6985ba4e4050a48ebc29dd7835260d5c58e"}], "stats": {"total": 1213, "additions": 1178, "deletions": 35}, "files": [{"sha": "b93723adf6ac804bbf63e830b36f4f5bb587eed9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -1,3 +1,85 @@\n+2007-09-06  Chao-ying Fu  <fu@mips.com>\n+\n+\t* ginclude/stdfix.h: New file.\n+\t* Makefile.in (USER_H): Add $(srcdir)/ginclude/stdfix.h.\n+\t(convert.o): Add dependence on fixed-value.h.\n+\t* c-convert.c (convert): Support FIXED_POINT_TYPE.\n+\t* c-cppbuiltin.c (builtin_define_fixed_point_constants): New function\n+\tto define fixed-point constants.\n+\t(c_cpp_builtins): Define fixed-point constants.\n+\t* convert.c (fixed-value.h): New include.\n+\t(convert_to_real): Update comment to include fixed-point.\n+\tSupport FIXED_POINT_TYPE.\n+\t(convert_to_integer): Update comment to include fixed-point.\n+\tSupport FIXED_POINT_TYPE.\n+\t(convert_to_complex): Support FIXED_POINT_TYPE.\n+\t(convert_to_fixed): New function.\n+\t* convert.h (convert_to_fixed): Declare.\n+\t* genopinit.c: Add comment about $Q for only fixed-point modes.\n+\t(optabs): Add fract_optab, fractuns_optab, satfract_optab,\n+\tsatfractuns_optab, add_optab, ssadd_optab, usadd_optab, sub_optab,\n+\tsssub_optab, ussub_optab, smul_optab, ssmul_optab, usmul_optab,\n+\tssmadd_widen_optab, usmadd_widen_optab, ssdiv_optab, udiv_optab,\n+\tusdiv_optab, ssashl_optab, usashl_optab, neg_optab, ssneg_optab,\n+\tusneg_optab for fixed-point modes.\n+\t(gen_insn): Add force_fixed to track the $Q format for all fixed-point\n+\tmodes.\n+\t* optabs.c (optab_for_tree_code): For *DIV_EXPR, LSHIFT_EXPR,\n+\tPLUS_EXPR, MINUS_EXPR, MULT_EXPR, NEGATE_EXPR, return signed or\n+\tunsigned saturation optabs, when type is saturating.\n+\t(shift_optab_p): Return true for SS_ASHIFT or US_ASHIFT.\n+\t(expand_fixed_convert): New function.\n+\t(gen_fixed_libfunc, gen_signed_fixed_libfunc,\n+\tgen_unsigned_fixed_libfunc, gen_int_fp_fixed_libfunc,\n+\tgen_int_fp_signed_fixed_libfunc, gen_int_fixed_libfunc,\n+\tgen_int_signed_fixed_libfunc, gen_int_unsigned_fixed_libfunc,\n+\tgen_fract_conv_libfunc, gen_fractuns_conv_libfunc,\n+\tgen_satfract_conv_libfunc, gen_satfractuns_conv_libfunc): New\n+\tfunctions.\n+\t(init_optabs): Initialize ssadd_optab, usadd_optab, sssub_optab,\n+\tussub_optab, ssmul_optab, usmul_optab, ssmadd_widen_optab,\n+\tusmadd_widen_optab, ssmsub_widen_optab, usmsub_widen_optab,\n+\tssdiv_optab, usdiv_optab, ssashl_optab, usashl_optab, ssneg_optab,\n+\tusneg_optab, fract_optab, fractuns_optab, satfract_optab,\n+\tsatfractuns_optab.\n+\tInitialize fixed-point libraries, including add, ssadd, usadd, sub,\n+\tsssub, ussub, mul, ssmul, usmul, div, ssdiv, udiv, usdiv, ashl,\n+\tssashl, usashl, ashr, lshr, neg, ssneg, usneg, cmp, fract, satfract,\n+\tfractuns, satfractuns.\n+\t* optabs.h (enum optab_index): Add OTI_ssadd, OTI_usadd, OTI_sssub,\n+\tOTI_ussub, OTI_ssmul, OTI_usmul, OTI_ssdiv, OTI_usdiv, OTI_ssneg,\n+\tOTI_usneg, OTI_ssashl, OTI_usashl, OTI_ssmadd_widen, OTI_usmadd_widen,\n+\tOTI_ssmsub_widen,  OTI_usmsub_widen.\n+\t(ssadd_optab, usadd_optab, sssub_optab, ussub_optab, ssmul_optab,\n+\tusmul_optab, ssdiv_optab, usdiv_optab, ssneg_optab, usneg_optab,\n+\tssashl_optab, usashl_optab, ssmadd_widen_optab, usmadd_widen_optab,\n+\tumsub_widen_optab, usmsub_widen_optab): Define.\n+\t(enum convert_optab_index): Add COI_fract, COI_fractuns, COI_satfract,\n+\tCOI_satfractuns.\n+\t(fract_optab, fractuns_optab, satfract_optab, satfractuns_optab):\n+\tDefine.\n+\t(expand_fixed_convert): Declare.\n+\t* expr.c (convert_move): Support the move of fixed-point modes.\n+\t(emit_move_insn_1): Handle fixed-point mode to move via integer.\n+\t(categorize_ctor_elements_1): Handle FIXED_CST.\n+\t(count_type_elements): Handle FIXED_POINT_TYPE.\n+\t(expand_expr_real_1): For VECTOR_CST, check MODE_VECTOR_FRACT,\n+\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\tSupport FIXED_CST.\n+\tFor PLUS_EXPR and MINUS_EXPR, support saturating and non-saturating\n+\tmultiply and add/subtract for fixed-point types.\n+\tFor MULT_EXPR, *DIV_EXPR, *SHIFT_EXPR, if the mode if a fixed-point\n+\tmode, we jump to binop directly.\n+\tSupport FIXED_CONVERT_EXPR.\n+\t(do_store_flag): Check FIXED_CST to put a constant second.\n+\t(vector_mode_valid_p): Handle MODE_VECTOR_FRACT,\n+\tMODE_VECTOR_UFRACT, MODE_VECTOR_ACCUM, MODE_VECTOR_UACCUM.\n+\t(const_vector_from_tree): Support FIXED_CST.\n+\t* doc/extend.texi (Fixed-Point): New node.\n+\t* doc/md.texi (ssadd, usadd, sssub, ussub, ssmul, usmul, ssdiv, usdiv,\n+\tssmadd, usmadd, ssmsub, usmsub, ssashl, usashl, ssneg, usneg, fract,\n+\tsatfract, fractuns, satfractuns): Document them.\n+\n 2007-09-07  Bernd Schmidt  <bernd.schmidt@analog.com>\n \n \t* config/bfin/bfin.h (PREFERRED_RELOAD_CLASS): Don't reload autoinc"}, {"sha": "1030d8eb1e10ac98448f69f3db743f2ce3ab7403", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -302,6 +302,7 @@ USER_H = $(srcdir)/ginclude/float.h \\\n \t $(srcdir)/ginclude/stdbool.h \\\n \t $(srcdir)/ginclude/stddef.h \\\n \t $(srcdir)/ginclude/varargs.h \\\n+\t $(srcdir)/ginclude/stdfix.h \\\n \t $(EXTRA_HEADERS)\n \n UNWIND_H = $(srcdir)/unwind-generic.h\n@@ -1942,7 +1943,7 @@ prefix.o: prefix.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) prefix.h \\\n \t  -c $(srcdir)/prefix.c $(OUTPUT_OPTION)\n \n convert.o: convert.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-   $(FLAGS_H) convert.h toplev.h langhooks.h $(REAL_H)\n+   $(FLAGS_H) convert.h toplev.h langhooks.h $(REAL_H) fixed-value.h\n \n double-int.o: double-int.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n "}, {"sha": "8fa68a190b6032161d09e2a7ded9847a8e23e885", "filename": "gcc/c-convert.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -105,6 +105,8 @@ convert (tree type, tree expr)\n     return fold (convert_to_pointer (type, e));\n   if (code == REAL_TYPE)\n     return fold (convert_to_real (type, e));\n+  if (code == FIXED_POINT_TYPE)\n+    return fold (convert_to_fixed (type, e));\n   if (code == COMPLEX_TYPE)\n     return fold (convert_to_complex (type, e));\n   if (code == VECTOR_TYPE)"}, {"sha": "e201b058f5f2d7f6eee794c360b237c9c727d163", "filename": "gcc/c-cppbuiltin.c", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fc-cppbuiltin.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fc-cppbuiltin.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-cppbuiltin.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -317,6 +317,60 @@ builtin_define_decimal_float_constants (const char *name_prefix,\n   builtin_define_with_value (name, buf, 0);\n }\n \n+/* Define fixed-point constants for TYPE using NAME_PREFIX and SUFFIX.  */\n+\n+static void\n+builtin_define_fixed_point_constants (const char *name_prefix,\n+\t\t\t\t      const char *suffix,\n+\t\t\t\t      tree type)\n+{\n+  char name[64], buf[256], *new_buf;\n+  int i, mod;\n+\n+  sprintf (name, \"__%s_FBIT__\", name_prefix);\n+  builtin_define_with_int_value (name, TYPE_FBIT (type));\n+\n+  sprintf (name, \"__%s_IBIT__\", name_prefix);\n+  builtin_define_with_int_value (name, TYPE_IBIT (type));\n+\n+  /* If there is no suffix, defines are for fixed-point modes.\n+     We just return.  */\n+  if (strcmp (suffix, \"\") == 0)\n+    return;\n+\n+  if (TYPE_UNSIGNED (type))\n+    {\n+      sprintf (name, \"__%s_MIN__\", name_prefix);\n+      sprintf (buf, \"0.0%s\", suffix);\n+      builtin_define_with_value (name, buf, 0);\n+    }\n+  else\n+    {\n+      sprintf (name, \"__%s_MIN__\", name_prefix);\n+      if (ALL_ACCUM_MODE_P (TYPE_MODE (type)))\n+\tsprintf (buf, \"(-0X1P%d%s-0X1P%d%s)\", TYPE_IBIT (type) - 1, suffix,\n+\t\t TYPE_IBIT (type) - 1, suffix);\n+      else\n+\tsprintf (buf, \"(-0.5%s-0.5%s)\", suffix, suffix);\n+      builtin_define_with_value (name, buf, 0);\n+    }\n+\n+  sprintf (name, \"__%s_MAX__\", name_prefix);\n+  sprintf (buf, \"0X\");\n+  new_buf = buf + 2;\n+  mod = (TYPE_FBIT (type) + TYPE_IBIT (type)) % 4;\n+  if (mod)\n+    sprintf (new_buf++, \"%x\", (1 << mod) - 1);\n+  for (i = 0; i < (TYPE_FBIT (type) + TYPE_IBIT (type)) / 4; i++)\n+    sprintf (new_buf++, \"F\");\n+  sprintf (new_buf, \"P-%d%s\", TYPE_FBIT (type), suffix);\n+  builtin_define_with_value (name, buf, 0);\n+\n+  sprintf (name, \"__%s_EPSILON__\", name_prefix);\n+  sprintf (buf, \"0x1P-%d%s\", TYPE_FBIT (type), suffix);\n+  builtin_define_with_value (name, buf, 0);\n+}\n+\n /* Define __GNUC__, __GNUC_MINOR__ and __GNUC_PATCHLEVEL__.  */\n static void\n define__GNUC__ (void)\n@@ -465,6 +519,62 @@ c_cpp_builtins (cpp_reader *pfile)\n   builtin_define_decimal_float_constants (\"DEC64\", \"DD\", dfloat64_type_node);\n   builtin_define_decimal_float_constants (\"DEC128\", \"DL\", dfloat128_type_node);\n \n+  /* For fixed-point fibt, ibit, max, min, and epsilon.  */\n+  if (targetm.fixed_point_supported_p ())\n+    {\n+      builtin_define_fixed_point_constants (\"SFRACT\", \"HR\",\n+\t\t\t\t\t    short_fract_type_node);\n+      builtin_define_fixed_point_constants (\"USFRACT\", \"UHR\",\n+\t\t\t\t\t    unsigned_short_fract_type_node);\n+      builtin_define_fixed_point_constants (\"FRACT\", \"R\",\n+\t\t\t\t\t    fract_type_node);\n+      builtin_define_fixed_point_constants (\"UFRACT\", \"UR\",\n+\t\t\t\t\t    unsigned_fract_type_node);\n+      builtin_define_fixed_point_constants (\"LFRACT\", \"LR\",\n+\t\t\t\t\t    long_fract_type_node);\n+      builtin_define_fixed_point_constants (\"ULFRACT\", \"ULR\",\n+\t\t\t\t\t    unsigned_long_fract_type_node);\n+      builtin_define_fixed_point_constants (\"LLFRACT\", \"LLR\",\n+\t\t\t\t\t    long_long_fract_type_node);\n+      builtin_define_fixed_point_constants (\"ULLFRACT\", \"ULLR\",\n+\t\t\t\t\t    unsigned_long_long_fract_type_node);\n+      builtin_define_fixed_point_constants (\"SACCUM\", \"HK\",\n+\t\t\t\t\t    short_accum_type_node);\n+      builtin_define_fixed_point_constants (\"USACCUM\", \"UHK\",\n+\t\t\t\t\t    unsigned_short_accum_type_node);\n+      builtin_define_fixed_point_constants (\"ACCUM\", \"K\",\n+\t\t\t\t\t    accum_type_node);\n+      builtin_define_fixed_point_constants (\"UACCUM\", \"UK\",\n+\t\t\t\t\t    unsigned_accum_type_node);\n+      builtin_define_fixed_point_constants (\"LACCUM\", \"LK\",\n+\t\t\t\t\t    long_accum_type_node);\n+      builtin_define_fixed_point_constants (\"ULACCUM\", \"ULK\",\n+\t\t\t\t\t    unsigned_long_accum_type_node);\n+      builtin_define_fixed_point_constants (\"LLACCUM\", \"LLK\",\n+\t\t\t\t\t    long_long_accum_type_node);\n+      builtin_define_fixed_point_constants (\"ULLACCUM\", \"ULLK\",\n+\t\t\t\t\t    unsigned_long_long_accum_type_node);\n+\n+      builtin_define_fixed_point_constants (\"QQ\", \"\", qq_type_node);\n+      builtin_define_fixed_point_constants (\"HQ\", \"\", hq_type_node);\n+      builtin_define_fixed_point_constants (\"SQ\", \"\", sq_type_node);\n+      builtin_define_fixed_point_constants (\"DQ\", \"\", dq_type_node);\n+      builtin_define_fixed_point_constants (\"TQ\", \"\", tq_type_node);\n+      builtin_define_fixed_point_constants (\"UQQ\", \"\", uqq_type_node);\n+      builtin_define_fixed_point_constants (\"UHQ\", \"\", uhq_type_node);\n+      builtin_define_fixed_point_constants (\"USQ\", \"\", usq_type_node);\n+      builtin_define_fixed_point_constants (\"UDQ\", \"\", udq_type_node);\n+      builtin_define_fixed_point_constants (\"UTQ\", \"\", utq_type_node);\n+      builtin_define_fixed_point_constants (\"HA\", \"\", ha_type_node);\n+      builtin_define_fixed_point_constants (\"SA\", \"\", sa_type_node);\n+      builtin_define_fixed_point_constants (\"DA\", \"\", da_type_node);\n+      builtin_define_fixed_point_constants (\"TA\", \"\", ta_type_node);\n+      builtin_define_fixed_point_constants (\"UHA\", \"\", uha_type_node);\n+      builtin_define_fixed_point_constants (\"USA\", \"\", usa_type_node);\n+      builtin_define_fixed_point_constants (\"UDA\", \"\", uda_type_node);\n+      builtin_define_fixed_point_constants (\"UTA\", \"\", uta_type_node);\n+    }\n+\n   /* For use in assembly language.  */\n   builtin_define_with_value (\"__REGISTER_PREFIX__\", REGISTER_PREFIX, 0);\n   builtin_define_with_value (\"__USER_LABEL_PREFIX__\", user_label_prefix, 0);"}, {"sha": "f82604e775a5bd1338b341deecdbd84227697e08", "filename": "gcc/convert.c", "status": "modified", "additions": 50, "deletions": 3, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -33,6 +33,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"langhooks.h\"\n #include \"real.h\"\n+#include \"fixed-value.h\"\n \n /* Convert EXPR to some pointer or reference type TYPE.\n    EXPR must be pointer, reference, integer, enumeral, or literal zero;\n@@ -117,7 +118,7 @@ strip_float_extensions (tree exp)\n \n /* Convert EXPR to some floating-point type TYPE.\n \n-   EXPR must be float, integer, or enumeral;\n+   EXPR must be float, fixed-point, integer, or enumeral;\n    in other cases error is called.  */\n \n tree\n@@ -319,6 +320,9 @@ convert_to_real (tree type, tree expr)\n     case BOOLEAN_TYPE:\n       return build1 (FLOAT_EXPR, type, expr);\n \n+    case FIXED_POINT_TYPE:\n+      return build1 (FIXED_CONVERT_EXPR, type, expr);\n+\n     case COMPLEX_TYPE:\n       return convert (type,\n \t\t      fold_build1 (REALPART_EXPR,\n@@ -337,8 +341,8 @@ convert_to_real (tree type, tree expr)\n \n /* Convert EXPR to some integer (or enum) type TYPE.\n \n-   EXPR must be pointer, integer, discrete (enum, char, or bool), float, or\n-   vector; in other cases error is called.\n+   EXPR must be pointer, integer, discrete (enum, char, or bool), float,\n+   fixed-point or vector; in other cases error is called.\n \n    The result of this is always supposed to be a newly created tree node\n    not in use in any existing structure.  */\n@@ -713,6 +717,9 @@ convert_to_integer (tree type, tree expr)\n     case REAL_TYPE:\n       return build1 (FIX_TRUNC_EXPR, type, expr);\n \n+    case FIXED_POINT_TYPE:\n+      return build1 (FIXED_CONVERT_EXPR, type, expr);\n+\n     case COMPLEX_TYPE:\n       return convert (type,\n \t\t      fold_build1 (REALPART_EXPR,\n@@ -742,6 +749,7 @@ convert_to_complex (tree type, tree expr)\n   switch (TREE_CODE (TREE_TYPE (expr)))\n     {\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case INTEGER_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n@@ -806,3 +814,42 @@ convert_to_vector (tree type, tree expr)\n       return error_mark_node;\n     }\n }\n+\n+/* Convert EXPR to some fixed-point type TYPE.\n+\n+   EXPR must be fixed-point, float, integer, or enumeral;\n+   in other cases error is called.  */\n+\n+tree\n+convert_to_fixed (tree type, tree expr)\n+{\n+  if (integer_zerop (expr))\n+    {\n+      tree fixed_zero_node = build_fixed (type, FCONST0 (TYPE_MODE (type)));\n+      return fixed_zero_node;\n+    }\n+  else if (integer_onep (expr) && ALL_SCALAR_ACCUM_MODE_P (TYPE_MODE (type)))\n+    {\n+      tree fixed_one_node = build_fixed (type, FCONST1 (TYPE_MODE (type)));\n+      return fixed_one_node;\n+    }\n+\n+  switch (TREE_CODE (TREE_TYPE (expr)))\n+    {\n+    case FIXED_POINT_TYPE:\n+    case INTEGER_TYPE:\n+    case ENUMERAL_TYPE:\n+    case BOOLEAN_TYPE:\n+    case REAL_TYPE:\n+      return build1 (FIXED_CONVERT_EXPR, type, expr);\n+\n+    case COMPLEX_TYPE:\n+      return convert (type,\n+\t\t      fold_build1 (REALPART_EXPR,\n+\t\t\t\t   TREE_TYPE (TREE_TYPE (expr)), expr));\n+\n+    default:\n+      error (\"aggregate value used where a fixed-point was expected\");\n+      return error_mark_node;\n+    }\n+}"}, {"sha": "fad3882e47336635863d55a7e8e8a08b2d1e2b7e", "filename": "gcc/convert.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fconvert.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fconvert.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconvert.h?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -23,6 +23,7 @@ along with GCC; see the file COPYING3.  If not see\n extern tree convert_to_integer (tree, tree);\n extern tree convert_to_pointer (tree, tree);\n extern tree convert_to_real (tree, tree);\n+extern tree convert_to_fixed (tree, tree);\n extern tree convert_to_complex (tree, tree);\n extern tree convert_to_vector (tree, tree);\n "}, {"sha": "730940a49ddb2d01b5c3a725a29f58dd8003c60f", "filename": "gcc/doc/extend.texi", "status": "modified", "additions": 129, "deletions": 0, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fdoc%2Fextend.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fdoc%2Fextend.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fextend.texi?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -36,6 +36,7 @@ extensions, accepted by GCC in C89 mode and in C++.\n * Floating Types::      Additional Floating Types.\n * Decimal Float::       Decimal Floating Types. \n * Hex Floats::          Hexadecimal floating-point constants.\n+* Fixed-Point::         Fixed-Point Types.\n * Zero Length::         Zero-length arrays.\n * Variable Length::     Arrays whose length is computed at run time.\n * Empty Structures::    Structures with no members.\n@@ -949,6 +950,134 @@ would not be able to resolve the ambiguity of, e.g., @code{0x1.f}.  This\n could mean @code{1.0f} or @code{1.9375} since @samp{f} is also the\n extension for floating-point constants of type @code{float}.\n \n+@node Fixed-Point\n+@section Fixed-Point Types\n+@cindex fixed-point types\n+@cindex @code{_Fract} data type\n+@cindex @code{_Accum} data type\n+@cindex @code{_Sat} data type\n+@cindex @code{hr} fixed-suffix\n+@cindex @code{r} fixed-suffix\n+@cindex @code{lr} fixed-suffix\n+@cindex @code{llr} fixed-suffix\n+@cindex @code{uhr} fixed-suffix\n+@cindex @code{ur} fixed-suffix\n+@cindex @code{ulr} fixed-suffix\n+@cindex @code{ullr} fixed-suffix\n+@cindex @code{hk} fixed-suffix\n+@cindex @code{k} fixed-suffix\n+@cindex @code{lk} fixed-suffix\n+@cindex @code{llk} fixed-suffix\n+@cindex @code{uhk} fixed-suffix\n+@cindex @code{uk} fixed-suffix\n+@cindex @code{ulk} fixed-suffix\n+@cindex @code{ullk} fixed-suffix\n+@cindex @code{HR} fixed-suffix\n+@cindex @code{R} fixed-suffix\n+@cindex @code{LR} fixed-suffix\n+@cindex @code{LLR} fixed-suffix\n+@cindex @code{UHR} fixed-suffix\n+@cindex @code{UR} fixed-suffix\n+@cindex @code{ULR} fixed-suffix\n+@cindex @code{ULLR} fixed-suffix\n+@cindex @code{HK} fixed-suffix\n+@cindex @code{K} fixed-suffix\n+@cindex @code{LK} fixed-suffix\n+@cindex @code{LLK} fixed-suffix\n+@cindex @code{UHK} fixed-suffix\n+@cindex @code{UK} fixed-suffix\n+@cindex @code{ULK} fixed-suffix\n+@cindex @code{ULLK} fixed-suffix\n+\n+As an extension, the GNU C compiler supports fixed-point types as\n+defined in the N1169 draft of ISO/IEC DTR 18037.  Support for fixed-point\n+types in GCC will evolve as the draft technical report changes.\n+Calling conventions for any target might also change.  Not all targets\n+support fixed-point types.\n+\n+The fixed-point types are\n+@code{short _Fract},\n+@code{_Fract},\n+@code{long _Fract},\n+@code{long long _Fract},\n+@code{unsigned short _Fract},\n+@code{unsigned _Fract},\n+@code{unsigned long _Fract},\n+@code{unsigned long long _Fract},\n+@code{_Sat short _Fract},\n+@code{_Sat _Fract},\n+@code{_Sat long _Fract},\n+@code{_Sat long long _Fract},\n+@code{_Sat unsigned short _Fract},\n+@code{_Sat unsigned _Fract},\n+@code{_Sat unsigned long _Fract},\n+@code{_Sat unsigned long long _Fract},\n+@code{short _Accum},\n+@code{_Accum},\n+@code{long _Accum},\n+@code{long long _Accum},\n+@code{unsigned short _Accum},\n+@code{unsigned _Accum},\n+@code{unsigned long _Accum},\n+@code{unsigned long long _Accum},\n+@code{_Sat short _Accum},\n+@code{_Sat _Accum},\n+@code{_Sat long _Accum},\n+@code{_Sat long long _Accum},\n+@code{_Sat unsigned short _Accum},\n+@code{_Sat unsigned _Accum},\n+@code{_Sat unsigned long _Accum},\n+@code{_Sat unsigned long long _Accum}.\n+Fixed-point data values contain fractional and optional integral parts.\n+The format of fixed-point data varies and depends on the target machine.\n+\n+Support for fixed-point types includes prefix and postfix increment\n+and decrement operators (@code{++}, @code{--}); unary arithmetic operators\n+(@code{+}, @code{-}, @code{!}); binary arithmetic operators (@code{+},\n+@code{-}, @code{*}, @code{/}); binary shift operators (@code{<<}, @code{>>});\n+relational operators (@code{<}, @code{<=}, @code{>=}, @code{>});\n+equality operators (@code{==}, @code{!=}); assignment operators\n+(@code{+=}, @code{-=}, @code{*=}, @code{/=}, @code{<<=}, @code{>>=});\n+and conversions to and from integer, floating-point, or fixed-point types.\n+\n+Use a suffix @samp{hr} or @samp{HR} in a literal constant of type\n+@code{short _Fract} and @code{_Sat short _Fract},\n+@samp{r} or @samp{R} for @code{_Fract} and @code{_Sat _Fract},\n+@samp{lr} or @samp{LR} for @code{long _Fract} and @code{_Sat long _Fract},\n+@samp{llr} or @samp{LLR} for @code{long long _Fract} and\n+@code{_Sat long long _Fract},\n+@samp{uhr} or @samp{UHR} for @code{unsigned short _Fract} and\n+@code{_Sat unsigned short _Fract},\n+@samp{ur} or @samp{UR} for @code{unsigned _Fract} and\n+@code{_Sat unsigned _Fract},\n+@samp{ulr} or @samp{ULR} for @code{unsigned long _Fract} and\n+@code{_Sat unsigned long _Fract},\n+@samp{ullr} or @samp{ULLR} for @code{unsigned long long _Fract}\n+and @code{_Sat unsigned long long _Fract},\n+@samp{hk} or @samp{HK} for @code{short _Accum} and @code{_Sat short _Accum},\n+@samp{k} or @samp{K} for @code{_Accum} and @code{_Sat _Accum},\n+@samp{lk} or @samp{LK} for @code{long _Accum} and @code{_Sat long _Accum},\n+@samp{llk} or @samp{LLK} for @code{long long _Accum} and\n+@code{_Sat long long _Accum},\n+@samp{uhk} or @samp{UHK} for @code{unsigned short _Accum} and\n+@code{_Sat unsigned short _Accum},\n+@samp{uk} or @samp{UK} for @code{unsigned _Accum} and\n+@code{_Sat unsigned _Accum},\n+@samp{ulk} or @samp{ULK} for @code{unsigned long _Accum} and\n+@code{_Sat unsigned long _Accum},\n+and @samp{ullk} or @samp{ULLK} for @code{unsigned long long _Accum}\n+and @code{_Sat unsigned long long _Accum}.\n+\n+GCC support of fixed-point types as specified by the draft technical report\n+is incomplete:\n+\n+@itemize @bullet\n+@item\n+Pragmas to control overflow and rounding behaviors are not implemented.\n+@end itemize\n+\n+Fixed-point types are supported by the DWARF2 debug information format.\n+\n @node Zero Length\n @section Arrays of Length Zero\n @cindex arrays of length zero"}, {"sha": "1b0d766f73631741c7c676edc2e7a86854cc64e3", "filename": "gcc/doc/md.texi", "status": "modified", "additions": 74, "deletions": 6, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fdoc%2Fmd.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fdoc%2Fmd.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fmd.texi?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -3587,19 +3587,30 @@ Add operand 2 and operand 1, storing the result in operand 0.  All operands\n must have mode @var{m}.  This can be used even on two-address machines, by\n means of constraints requiring operands 1 and 0 to be the same location.\n \n+@cindex @code{ssadd@var{m}3} instruction pattern\n+@cindex @code{usadd@var{m}3} instruction pattern\n @cindex @code{sub@var{m}3} instruction pattern\n+@cindex @code{sssub@var{m}3} instruction pattern\n+@cindex @code{ussub@var{m}3} instruction pattern\n @cindex @code{mul@var{m}3} instruction pattern\n+@cindex @code{ssmul@var{m}3} instruction pattern\n+@cindex @code{usmul@var{m}3} instruction pattern\n @cindex @code{div@var{m}3} instruction pattern\n+@cindex @code{ssdiv@var{m}3} instruction pattern\n @cindex @code{udiv@var{m}3} instruction pattern\n+@cindex @code{usdiv@var{m}3} instruction pattern\n @cindex @code{mod@var{m}3} instruction pattern\n @cindex @code{umod@var{m}3} instruction pattern\n @cindex @code{umin@var{m}3} instruction pattern\n @cindex @code{umax@var{m}3} instruction pattern\n @cindex @code{and@var{m}3} instruction pattern\n @cindex @code{ior@var{m}3} instruction pattern\n @cindex @code{xor@var{m}3} instruction pattern\n-@item @samp{sub@var{m}3}, @samp{mul@var{m}3}\n-@itemx @samp{div@var{m}3}, @samp{udiv@var{m}3}\n+@item @samp{ssadd@var{m}3}, @samp{usadd@var{m}3}\n+@item @samp{sub@var{m}3}, @samp{sssub@var{m}3}, @samp{ussub@var{m}3}\n+@item @samp{mul@var{m}3}, @samp{ssmul@var{m}3}, @samp{usmul@var{m}3}\n+@itemx @samp{div@var{m}3}, @samp{ssdiv@var{m}3}\n+@itemx @samp{udiv@var{m}3}, @samp{usdiv@var{m}3}\n @itemx @samp{mod@var{m}3}, @samp{umod@var{m}3}\n @itemx @samp{umin@var{m}3}, @samp{umax@var{m}3}\n @itemx @samp{and@var{m}3}, @samp{ior@var{m}3}, @samp{xor@var{m}3}\n@@ -3772,7 +3783,7 @@ Similar, but the multiplication is unsigned.\n Multiply operands 1 and 2, sign-extend them to mode @var{n}, add\n operand 3, and store the result in operand 0.  Operands 1 and 2\n have mode @var{m} and operands 0 and 3 have mode @var{n}.\n-Both modes must be integer modes and @var{n} must be twice\n+Both modes must be integer or fixed-point modes and @var{n} must be twice\n the size of @var{m}.\n \n In other words, @code{madd@var{m}@var{n}4} is like\n@@ -3785,12 +3796,22 @@ These instructions are not allowed to @code{FAIL}.\n Like @code{madd@var{m}@var{n}4}, but zero-extend the multiplication\n operands instead of sign-extending them.\n \n+@cindex @code{ssmadd@var{m}@var{n}4} instruction pattern\n+@item @samp{ssmadd@var{m}@var{n}4}\n+Like @code{madd@var{m}@var{n}4}, but all involved operations must be\n+signed-saturating.\n+\n+@cindex @code{usmadd@var{m}@var{n}4} instruction pattern\n+@item @samp{usmadd@var{m}@var{n}4}\n+Like @code{umadd@var{m}@var{n}4}, but all involved operations must be\n+unsigned-saturating.\n+\n @cindex @code{msub@var{m}@var{n}4} instruction pattern\n @item @samp{msub@var{m}@var{n}4}\n Multiply operands 1 and 2, sign-extend them to mode @var{n}, subtract the\n result from operand 3, and store the result in operand 0.  Operands 1 and 2\n have mode @var{m} and operands 0 and 3 have mode @var{n}.\n-Both modes must be integer modes and @var{n} must be twice\n+Both modes must be integer or fixed-point modes and @var{n} must be twice\n the size of @var{m}.\n \n In other words, @code{msub@var{m}@var{n}4} is like\n@@ -3804,6 +3825,16 @@ These instructions are not allowed to @code{FAIL}.\n Like @code{msub@var{m}@var{n}4}, but zero-extend the multiplication\n operands instead of sign-extending them.\n \n+@cindex @code{ssmsub@var{m}@var{n}4} instruction pattern\n+@item @samp{ssmsub@var{m}@var{n}4}\n+Like @code{msub@var{m}@var{n}4}, but all involved operations must be\n+signed-saturating.\n+\n+@cindex @code{usmsub@var{m}@var{n}4} instruction pattern\n+@item @samp{usmsub@var{m}@var{n}4}\n+Like @code{umsub@var{m}@var{n}4}, but all involved operations must be\n+unsigned-saturating.\n+\n @cindex @code{divmod@var{m}4} instruction pattern\n @item @samp{divmod@var{m}4}\n Signed division that produces both a quotient and a remainder.\n@@ -3828,7 +3859,9 @@ Similar, but does unsigned division.\n \n @anchor{shift patterns}\n @cindex @code{ashl@var{m}3} instruction pattern\n-@item @samp{ashl@var{m}3}\n+@cindex @code{ssashl@var{m}3} instruction pattern\n+@cindex @code{usashl@var{m}3} instruction pattern\n+@item @samp{ashl@var{m}3}, @samp{ssashl@var{m}3}, @samp{usashl@var{m}3}\n Arithmetic-shift operand 1 left by a number of bits specified by operand\n 2, and store the result in operand 0.  Here @var{m} is the mode of\n operand 0 and operand 1; operand 2's mode is specified by the\n@@ -3846,7 +3879,9 @@ Other shift and rotate instructions, analogous to the\n @code{ashl@var{m}3} instructions.\n \n @cindex @code{neg@var{m}2} instruction pattern\n-@item @samp{neg@var{m}2}\n+@cindex @code{ssneg@var{m}2} instruction pattern\n+@cindex @code{usneg@var{m}2} instruction pattern\n+@item @samp{neg@var{m}2}, @samp{ssneg@var{m}2}, @samp{usneg@var{m}2}\n Negate operand 1 and store the result in operand 0.\n \n @cindex @code{abs@var{m}2} instruction pattern\n@@ -4274,6 +4309,39 @@ Zero-extend operand 1 (valid for mode @var{m}) to mode @var{n} and\n store in operand 0 (which has mode @var{n}).  Both modes must be fixed\n point.\n \n+@cindex @code{fract@var{mn}2} instruction pattern\n+@item @samp{fract@var{m}@var{n}2}\n+Convert operand 1 of mode @var{m} to mode @var{n} and store in\n+operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}\n+could be fixed-point to fixed-point, signed integer to fixed-point,\n+fixed-point to signed integer, floating-point to fixed-point,\n+or fixed-point to floating-point.\n+When overflows or underflows happen, the results are undefined.\n+\n+@cindex @code{satfract@var{mn}2} instruction pattern\n+@item @samp{satfract@var{m}@var{n}2}\n+Convert operand 1 of mode @var{m} to mode @var{n} and store in\n+operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}\n+could be fixed-point to fixed-point, signed integer to fixed-point,\n+or floating-point to fixed-point.\n+When overflows or underflows happen, the instruction saturates the\n+results to the maximum or the minimum.\n+\n+@cindex @code{fractuns@var{mn}2} instruction pattern\n+@item @samp{fractuns@var{m}@var{n}2}\n+Convert operand 1 of mode @var{m} to mode @var{n} and store in\n+operand 0 (which has mode @var{n}).  Mode @var{m} and mode @var{n}\n+could be unsigned integer to fixed-point, or\n+fixed-point to unsigned integer.\n+When overflows or underflows happen, the results are undefined.\n+\n+@cindex @code{satfractuns@var{mn}2} instruction pattern\n+@item @samp{satfractuns@var{m}@var{n}2}\n+Convert unsigned integer operand 1 of mode @var{m} to fixed-point mode\n+@var{n} and store in operand 0 (which has mode @var{n}).\n+When overflows or underflows happen, the instruction saturates the\n+results to the maximum or the minimum.\n+\n @cindex @code{extv} instruction pattern\n @item @samp{extv}\n Extract a bit-field from operand 1 (a register or memory operand), where"}, {"sha": "554d72a38a9fafb69a5eb0987b69fb5b6eb20fb4", "filename": "gcc/expr.c", "status": "modified", "additions": 96, "deletions": 13, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -347,7 +347,8 @@ init_expr (void)\n }\n \f\n /* Copy data from FROM to TO, where the machine modes are not the same.\n-   Both modes may be integer, or both may be floating.\n+   Both modes may be integer, or both may be floating, or both may be\n+   fixed-point.\n    UNSIGNEDP should be nonzero if FROM is an unsigned type.\n    This causes zero-extension instead of sign-extension.  */\n \n@@ -502,6 +503,22 @@ convert_move (rtx to, rtx from, int unsignedp)\n       from = new_from;\n     }\n \n+   /* Make sure both are fixed-point modes or both are not.  */\n+   gcc_assert (ALL_SCALAR_FIXED_POINT_MODE_P (from_mode) ==\n+\t       ALL_SCALAR_FIXED_POINT_MODE_P (to_mode));\n+   if (ALL_SCALAR_FIXED_POINT_MODE_P (from_mode))\n+    {\n+      /* If we widen from_mode to to_mode and they are in the same class,\n+\t we won't saturate the result.\n+\t Otherwise, always saturate the result to play safe.  */\n+      if (GET_MODE_CLASS (from_mode) == GET_MODE_CLASS (to_mode)\n+\t  && GET_MODE_SIZE (from_mode) < GET_MODE_SIZE (to_mode))\n+\texpand_fixed_convert (to, from, 0, 0);\n+      else\n+\texpand_fixed_convert (to, from, 0, 1);\n+      return;\n+    }\n+\n   /* Now both modes are integers.  */\n \n   /* Handle expanding beyond a word.  */\n@@ -3284,7 +3301,8 @@ emit_move_insn_1 (rtx x, rtx y)\n   if (COMPLEX_MODE_P (mode))\n     return emit_move_complex (mode, x, y);\n \n-  if (GET_MODE_CLASS (mode) == MODE_DECIMAL_FLOAT)\n+  if (GET_MODE_CLASS (mode) == MODE_DECIMAL_FLOAT\n+      || ALL_FIXED_POINT_MODE_P (mode))\n     {\n       rtx result = emit_move_via_integer (mode, x, y, true);\n \n@@ -4763,6 +4781,7 @@ categorize_ctor_elements_1 (const_tree ctor, HOST_WIDE_INT *p_nz_elts,\n \n \tcase INTEGER_CST:\n \tcase REAL_CST:\n+\tcase FIXED_CST:\n \t  if (!initializer_zerop (value))\n \t    nz_elts += mult;\n \t  elt_count += mult;\n@@ -4945,6 +4964,7 @@ count_type_elements (const_tree type, bool allow_flexarr)\n \n     case INTEGER_TYPE:\n     case REAL_TYPE:\n+    case FIXED_POINT_TYPE:\n     case ENUMERAL_TYPE:\n     case BOOLEAN_TYPE:\n     case POINTER_TYPE:\n@@ -7231,7 +7251,11 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       {\n \ttree tmp = NULL_TREE;\n \tif (GET_MODE_CLASS (mode) == MODE_VECTOR_INT\n-\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT)\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FLOAT\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_FRACT\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_UFRACT\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_ACCUM\n+\t    || GET_MODE_CLASS (mode) == MODE_VECTOR_UACCUM)\n \t  return const_vector_from_tree (exp);\n \tif (GET_MODE_CLASS (mode) == MODE_INT)\n \t  {\n@@ -7263,6 +7287,10 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       return CONST_DOUBLE_FROM_REAL_VALUE (TREE_REAL_CST (exp),\n \t\t\t\t\t   TYPE_MODE (TREE_TYPE (exp)));\n \n+    case FIXED_CST:\n+      return CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (exp),\n+\t\t\t\t\t   TYPE_MODE (TREE_TYPE (exp)));\n+\n     case COMPLEX_CST:\n       /* Handle evaluating a complex constant in a CONCAT target.  */\n       if (original_target && GET_CODE (original_target) == CONCAT)\n@@ -8152,18 +8180,21 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case PLUS_EXPR:\n \n       /* Check if this is a case for multiplication and addition.  */\n-      if (TREE_CODE (type) == INTEGER_TYPE\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n \t  && TREE_CODE (TREE_OPERAND (exp, 0)) == MULT_EXPR)\n \t{\n \t  tree subsubexp0, subsubexp1;\n-\t  enum tree_code code0, code1;\n+\t  enum tree_code code0, code1, this_code;\n \n \t  subexp0 = TREE_OPERAND (exp, 0);\n \t  subsubexp0 = TREE_OPERAND (subexp0, 0);\n \t  subsubexp1 = TREE_OPERAND (subexp0, 1);\n \t  code0 = TREE_CODE (subsubexp0);\n \t  code1 = TREE_CODE (subsubexp1);\n-\t  if (code0 == NOP_EXPR && code1 == NOP_EXPR\n+\t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n+\t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n+\t  if (code0 == this_code && code1 == this_code\n \t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n \t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n \t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n@@ -8174,7 +8205,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      tree op0type = TREE_TYPE (TREE_OPERAND (subsubexp0, 0));\n \t      enum machine_mode innermode = TYPE_MODE (op0type);\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n-\t      this_optab = zextend_p ? umadd_widen_optab : smadd_widen_optab;\n+\t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n+\t      if (sat_p == 0)\n+\t\tthis_optab = zextend_p ? umadd_widen_optab : smadd_widen_optab;\n+\t      else\n+\t\tthis_optab = zextend_p ? usmadd_widen_optab\n+\t\t\t\t       : ssmadd_widen_optab;\n \t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n \t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n@@ -8307,18 +8343,21 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \n     case MINUS_EXPR:\n       /* Check if this is a case for multiplication and subtraction.  */\n-      if (TREE_CODE (type) == INTEGER_TYPE\n+      if ((TREE_CODE (type) == INTEGER_TYPE\n+\t   || TREE_CODE (type) == FIXED_POINT_TYPE)\n \t  && TREE_CODE (TREE_OPERAND (exp, 1)) == MULT_EXPR)\n \t{\n \t  tree subsubexp0, subsubexp1;\n-\t  enum tree_code code0, code1;\n+\t  enum tree_code code0, code1, this_code;\n \n \t  subexp1 = TREE_OPERAND (exp, 1);\n \t  subsubexp0 = TREE_OPERAND (subexp1, 0);\n \t  subsubexp1 = TREE_OPERAND (subexp1, 1);\n \t  code0 = TREE_CODE (subsubexp0);\n \t  code1 = TREE_CODE (subsubexp1);\n-\t  if (code0 == NOP_EXPR && code1 == NOP_EXPR\n+\t  this_code = TREE_CODE (type) == INTEGER_TYPE ? NOP_EXPR\n+\t\t\t\t\t\t       : FIXED_CONVERT_EXPR;\n+\t  if (code0 == this_code && code1 == this_code\n \t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n \t\t  < TYPE_PRECISION (TREE_TYPE (subsubexp0)))\n \t      && (TYPE_PRECISION (TREE_TYPE (TREE_OPERAND (subsubexp0, 0)))\n@@ -8329,7 +8368,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t      tree op0type = TREE_TYPE (TREE_OPERAND (subsubexp0, 0));\n \t      enum machine_mode innermode = TYPE_MODE (op0type);\n \t      bool zextend_p = TYPE_UNSIGNED (op0type);\n-\t      this_optab = zextend_p ? umsub_widen_optab : smsub_widen_optab;\n+\t      bool sat_p = TYPE_SATURATING (TREE_TYPE (subsubexp0));\n+\t      if (sat_p == 0)\n+\t\tthis_optab = zextend_p ? umsub_widen_optab : smsub_widen_optab;\n+\t      else\n+\t\tthis_optab = zextend_p ? usmsub_widen_optab\n+\t\t\t\t       : ssmsub_widen_optab;\n \t      if (mode == GET_MODE_2XWIDER_MODE (innermode)\n \t\t  && (optab_handler (this_optab, mode)->insn_code\n \t\t      != CODE_FOR_nothing))\n@@ -8388,6 +8432,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       goto binop2;\n \n     case MULT_EXPR:\n+      /* If this is a fixed-point operation, then we cannot use the code\n+\t below because \"expand_mult\" doesn't support sat/no-sat fixed-point\n+         multiplications.   */\n+      if (ALL_FIXED_POINT_MODE_P (mode))\n+\tgoto binop;\n+\n       /* If first operand is constant, swap them.\n \t Thus the following special case checks need only\n \t check the second operand.  */\n@@ -8540,6 +8590,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case CEIL_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n+      /* If this is a fixed-point operation, then we cannot use the code\n+\t below because \"expand_divmod\" doesn't support sat/no-sat fixed-point\n+         divisions.   */\n+      if (ALL_FIXED_POINT_MODE_P (mode))\n+\tgoto binop;\n+\n       if (modifier == EXPAND_STACK_PARM)\n \ttarget = 0;\n       /* Possible optimization: compute the dividend with EXPAND_SUM\n@@ -8562,6 +8618,19 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n \t\t       subtarget, &op0, &op1, 0);\n       return expand_divmod (1, code, mode, op0, op1, target, unsignedp);\n \n+    case FIXED_CONVERT_EXPR:\n+      op0 = expand_normal (TREE_OPERAND (exp, 0));\n+      if (target == 0 || modifier == EXPAND_STACK_PARM)\n+\ttarget = gen_reg_rtx (mode);\n+\n+      if ((TREE_CODE (TREE_TYPE (TREE_OPERAND (exp, 0))) == INTEGER_TYPE\n+\t   && TYPE_UNSIGNED (TREE_TYPE (TREE_OPERAND (exp, 0))))\n+          || (TREE_CODE (type) == INTEGER_TYPE && TYPE_UNSIGNED (type)))\n+\texpand_fixed_convert (target, op0, 1, TYPE_SATURATING (type));\n+      else\n+\texpand_fixed_convert (target, op0, 0, TYPE_SATURATING (type));\n+      return target;\n+\n     case FIX_TRUNC_EXPR:\n       op0 = expand_normal (TREE_OPERAND (exp, 0));\n       if (target == 0 || modifier == EXPAND_STACK_PARM)\n@@ -8767,6 +8836,12 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n     case RSHIFT_EXPR:\n     case LROTATE_EXPR:\n     case RROTATE_EXPR:\n+      /* If this is a fixed-point operation, then we cannot use the code\n+\t below because \"expand_shift\" doesn't support sat/no-sat fixed-point\n+         shifts.   */\n+      if (ALL_FIXED_POINT_MODE_P (mode))\n+\tgoto binop;\n+\n       if (! safe_from_p (subtarget, TREE_OPERAND (exp, 1), 1))\n \tsubtarget = 0;\n       if (modifier == EXPAND_STACK_PARM)\n@@ -9583,7 +9658,8 @@ do_store_flag (tree exp, rtx target, enum machine_mode mode, int only_cheap)\n     }\n \n   /* Put a constant second.  */\n-  if (TREE_CODE (arg0) == REAL_CST || TREE_CODE (arg0) == INTEGER_CST)\n+  if (TREE_CODE (arg0) == REAL_CST || TREE_CODE (arg0) == INTEGER_CST\n+      || TREE_CODE (arg0) == FIXED_CST)\n     {\n       tem = arg0; arg0 = arg1; arg1 = tem;\n       code = swap_condition (code);\n@@ -9887,7 +9963,11 @@ vector_mode_valid_p (enum machine_mode mode)\n \n   /* Doh!  What's going on?  */\n   if (class != MODE_VECTOR_INT\n-      && class != MODE_VECTOR_FLOAT)\n+      && class != MODE_VECTOR_FLOAT\n+      && class != MODE_VECTOR_FRACT\n+      && class != MODE_VECTOR_UFRACT\n+      && class != MODE_VECTOR_ACCUM\n+      && class != MODE_VECTOR_UACCUM)\n     return 0;\n \n   /* Hardware support.  Woo hoo!  */\n@@ -9931,6 +10011,9 @@ const_vector_from_tree (tree exp)\n       if (TREE_CODE (elt) == REAL_CST)\n \tRTVEC_ELT (v, i) = CONST_DOUBLE_FROM_REAL_VALUE (TREE_REAL_CST (elt),\n \t\t\t\t\t\t\t inner);\n+      else if (TREE_CODE (elt) == FIXED_CST)\n+\tRTVEC_ELT (v, i) = CONST_FIXED_FROM_FIXED_VALUE (TREE_FIXED_CST (elt),\n+\t\t\t\t\t\t\t inner);\n       else\n \tRTVEC_ELT (v, i) = immed_double_const (TREE_INT_CST_LOW (elt),\n \t\t\t\t\t       TREE_INT_CST_HIGH (elt),"}, {"sha": "c5d0df2fd94c6537a87a801c12503218c1e77b37", "filename": "gcc/genopinit.c", "status": "modified", "additions": 42, "deletions": 2, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -50,6 +50,7 @@ along with GCC; see the file COPYING3.  If not see\n    only full integer modes should be considered for the next mode, and $F\n    means that only float modes should be considered.\n    $P means that both full and partial integer modes should be considered.\n+   $Q means that only fixed-point modes should be considered.\n \n    $V means to emit 'v' if the first mode is a MODE_FLOAT mode.\n \n@@ -67,14 +68,28 @@ static const char * const optabs[] =\n   \"convert_optab_handler (sfloat_optab, $B, $A)->insn_code = CODE_FOR_$(float$I$a$F$b2$)\",\n   \"convert_optab_handler (ufloat_optab, $B, $A)->insn_code = CODE_FOR_$(floatuns$I$a$F$b2$)\",\n   \"convert_optab_handler (trunc_optab, $B, $A)->insn_code = CODE_FOR_$(trunc$a$b2$)\",\n+  \"convert_optab_handler (fract_optab, $B, $A)->insn_code = CODE_FOR_$(fract$a$b2$)\",\n+  \"convert_optab_handler (fractuns_optab, $B, $A)->insn_code = CODE_FOR_$(fractuns$I$a$Q$b2$)\",\n+  \"convert_optab_handler (fractuns_optab, $B, $A)->insn_code = CODE_FOR_$(fractuns$Q$a$I$b2$)\",\n+  \"convert_optab_handler (satfract_optab, $B, $A)->insn_code = CODE_FOR_$(satfract$a$Q$b2$)\",\n+  \"convert_optab_handler (satfractuns_optab, $B, $A)->insn_code = CODE_FOR_$(satfractuns$I$a$Q$b2$)\",\n   \"optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$P$a3$)\",\n   \"optab_handler (addv_optab, $A)->insn_code =\\n\\\n     optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$F$a3$)\",\n   \"optab_handler (addv_optab, $A)->insn_code = CODE_FOR_$(addv$I$a3$)\",\n+  \"optab_handler (add_optab, $A)->insn_code = CODE_FOR_$(add$Q$a3$)\",\n+  \"optab_handler (ssadd_optab, $A)->insn_code = CODE_FOR_$(ssadd$Q$a3$)\",\n+  \"optab_handler (usadd_optab, $A)->insn_code = CODE_FOR_$(usadd$Q$a3$)\",\n   \"optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$P$a3$)\",\n   \"optab_handler (subv_optab, $A)->insn_code =\\n\\\n     optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$F$a3$)\",\n   \"optab_handler (subv_optab, $A)->insn_code = CODE_FOR_$(subv$I$a3$)\",\n+  \"optab_handler (sub_optab, $A)->insn_code = CODE_FOR_$(sub$Q$a3$)\",\n+  \"optab_handler (sssub_optab, $A)->insn_code = CODE_FOR_$(sssub$Q$a3$)\",\n+  \"optab_handler (ussub_optab, $A)->insn_code = CODE_FOR_$(ussub$Q$a3$)\",\n+  \"optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$Q$a3$)\",\n+  \"optab_handler (ssmul_optab, $A)->insn_code = CODE_FOR_$(ssmul$Q$a3$)\",\n+  \"optab_handler (usmul_optab, $A)->insn_code = CODE_FOR_$(usmul$Q$a3$)\",\n   \"optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$P$a3$)\",\n   \"optab_handler (smulv_optab, $A)->insn_code =\\n\\\n     optab_handler (smul_optab, $A)->insn_code = CODE_FOR_$(mul$F$a3$)\",\n@@ -86,11 +101,18 @@ static const char * const optabs[] =\n   \"optab_handler (usmul_widen_optab, $B)->insn_code = CODE_FOR_$(usmul$a$b3$)$N\",\n   \"optab_handler (smadd_widen_optab, $B)->insn_code = CODE_FOR_$(madd$a$b4$)$N\",\n   \"optab_handler (umadd_widen_optab, $B)->insn_code = CODE_FOR_$(umadd$a$b4$)$N\",\n+  \"optab_handler (ssmadd_widen_optab, $B)->insn_code = CODE_FOR_$(ssmadd$a$b4$)$N\",\n+  \"optab_handler (usmadd_widen_optab, $B)->insn_code = CODE_FOR_$(usmadd$a$b4$)$N\",\n   \"optab_handler (smsub_widen_optab, $B)->insn_code = CODE_FOR_$(msub$a$b4$)$N\",\n   \"optab_handler (umsub_widen_optab, $B)->insn_code = CODE_FOR_$(umsub$a$b4$)$N\",\n+  \"optab_handler (ssmsub_widen_optab, $B)->insn_code = CODE_FOR_$(ssmsub$a$b4$)$N\",\n+  \"optab_handler (usmsub_widen_optab, $B)->insn_code = CODE_FOR_$(usmsub$a$b4$)$N\",\n   \"optab_handler (sdiv_optab, $A)->insn_code = CODE_FOR_$(div$a3$)\",\n+  \"optab_handler (ssdiv_optab, $A)->insn_code = CODE_FOR_$(ssdiv$Q$a3$)\",\n   \"optab_handler (sdivv_optab, $A)->insn_code = CODE_FOR_$(div$V$I$a3$)\",\n   \"optab_handler (udiv_optab, $A)->insn_code = CODE_FOR_$(udiv$I$a3$)\",\n+  \"optab_handler (udiv_optab, $A)->insn_code = CODE_FOR_$(udiv$Q$a3$)\",\n+  \"optab_handler (usdiv_optab, $A)->insn_code = CODE_FOR_$(usdiv$Q$a3$)\",\n   \"optab_handler (sdivmod_optab, $A)->insn_code = CODE_FOR_$(divmod$a4$)\",\n   \"optab_handler (udivmod_optab, $A)->insn_code = CODE_FOR_$(udivmod$a4$)\",\n   \"optab_handler (smod_optab, $A)->insn_code = CODE_FOR_$(mod$a3$)\",\n@@ -102,6 +124,8 @@ static const char * const optabs[] =\n   \"optab_handler (ior_optab, $A)->insn_code = CODE_FOR_$(ior$a3$)\",\n   \"optab_handler (xor_optab, $A)->insn_code = CODE_FOR_$(xor$a3$)\",\n   \"optab_handler (ashl_optab, $A)->insn_code = CODE_FOR_$(ashl$a3$)\",\n+  \"optab_handler (ssashl_optab, $A)->insn_code = CODE_FOR_$(ssashl$Q$a3$)\",\n+  \"optab_handler (usashl_optab, $A)->insn_code = CODE_FOR_$(usashl$Q$a3$)\",\n   \"optab_handler (ashr_optab, $A)->insn_code = CODE_FOR_$(ashr$a3$)\",\n   \"optab_handler (lshr_optab, $A)->insn_code = CODE_FOR_$(lshr$a3$)\",\n   \"optab_handler (rotl_optab, $A)->insn_code = CODE_FOR_$(rotl$a3$)\",\n@@ -116,6 +140,9 @@ static const char * const optabs[] =\n   \"optab_handler (negv_optab, $A)->insn_code =\\n\\\n     optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$F$a2$)\",\n   \"optab_handler (negv_optab, $A)->insn_code = CODE_FOR_$(negv$I$a2$)\",\n+  \"optab_handler (neg_optab, $A)->insn_code = CODE_FOR_$(neg$Q$a2$)\",\n+  \"optab_handler (ssneg_optab, $A)->insn_code = CODE_FOR_$(ssneg$Q$a2$)\",\n+  \"optab_handler (usneg_optab, $A)->insn_code = CODE_FOR_$(usneg$Q$a2$)\",\n   \"optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$P$a2$)\",\n   \"optab_handler (absv_optab, $A)->insn_code =\\n\\\n     optab_handler (abs_optab, $A)->insn_code = CODE_FOR_$(abs$F$a2$)\",\n@@ -267,6 +294,7 @@ gen_insn (rtx insn)\n   for (pindex = 0; pindex < ARRAY_SIZE (optabs); pindex++)\n     {\n       int force_float = 0, force_int = 0, force_partial_int = 0;\n+      int force_fixed = 0;\n       int force_consec = 0;\n       int matches = 1;\n \n@@ -296,6 +324,9 @@ gen_insn (rtx insn)\n \t      case 'F':\n \t\tforce_float = 1;\n \t\tbreak;\n+\t      case 'Q':\n+\t\tforce_fixed = 1;\n+\t\tbreak;\n \t      case 'V':\n                 break;\n \t      case 'c':\n@@ -342,7 +373,16 @@ gen_insn (rtx insn)\n \t\t\t    || mode_class[i] == MODE_FLOAT \n \t\t\t    || mode_class[i] == MODE_DECIMAL_FLOAT\n \t\t\t    || mode_class[i] == MODE_COMPLEX_FLOAT\n-\t\t\t    || mode_class[i] == MODE_VECTOR_FLOAT))\n+\t\t\t    || mode_class[i] == MODE_VECTOR_FLOAT)\n+\t\t\t&& (! force_fixed\n+\t\t\t    || mode_class[i] == MODE_FRACT\n+\t\t\t    || mode_class[i] == MODE_UFRACT\n+\t\t\t    || mode_class[i] == MODE_ACCUM\n+\t\t\t    || mode_class[i] == MODE_UACCUM\n+\t\t\t    || mode_class[i] == MODE_VECTOR_FRACT\n+\t\t\t    || mode_class[i] == MODE_VECTOR_UFRACT\n+\t\t\t    || mode_class[i] == MODE_VECTOR_ACCUM\n+\t\t\t    || mode_class[i] == MODE_VECTOR_UACCUM))\n \t\t      break;\n \t\t  }\n \n@@ -353,7 +393,7 @@ gen_insn (rtx insn)\n \t\telse\n \t\t  m2 = i, np += strlen (GET_MODE_NAME(i));\n \n-\t\tforce_int = force_partial_int = force_float = 0;\n+\t\tforce_int = force_partial_int = force_float = force_fixed = 0;\n \t\tbreak;\n \n \t      default:"}, {"sha": "5e7cb2eed8ab86b3880e7f756d03d339a001e5e4", "filename": "gcc/ginclude/stdfix.h", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fginclude%2Fstdfix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Fginclude%2Fstdfix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdfix.h?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -0,0 +1,207 @@\n+/* Copyright (C) 2007 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 51 Franklin Street, Fifth Floor,\n+Boston, MA 02110-1301, USA.  */\n+\n+/* As a special exception, if you include this header file into source\n+   files compiled by GCC, this header file does not by itself cause\n+   the resulting executable to be covered by the GNU General Public\n+   License.  This exception does not however invalidate any other\n+   reasons why the executable file might be covered by the GNU General\n+   Public License.  */\n+\n+/* ISO/IEC JTC1 SC22 WG14 N1169\n+ * Date: 2006-04-04\n+ * ISO/IEC TR 18037\n+ * Programming languages - C - Extensions to support embedded processors\n+ */\n+\n+#ifndef _STDFIX_H\n+#define _STDFIX_H\n+\n+/* 7.18a.1 Introduction.  */\n+\n+#undef fract\n+#undef accum\n+#undef sat\n+#define fract\t\t_Fract\n+#define accum\t\t_Accum\n+#define sat\t\t_Sat\n+\n+/* 7.18a.3 Precision macros.  */\n+\n+#undef SFRACT_FBIT\n+#undef SFRACT_MIN\n+#undef SFRACT_MAX\n+#undef SFRACT_EPSILON\n+#define SFRACT_FBIT\t__SFRACT_FBIT__\n+#define SFRACT_MIN\t__SFRACT_MIN__\n+#define SFRACT_MAX\t__SFRACT_MAX__\n+#define SFRACT_EPSILON\t__SFRACT_EPSILON__\n+\n+#undef USFRACT_FBIT\n+#undef USFRACT_MIN\n+#undef USFRACT_MAX\n+#undef USFRACT_EPSILON\n+#define USFRACT_FBIT\t__USFRACT_FBIT__\n+#define USFRACT_MIN\t__USFRACT_MIN__\t\t/* GCC extension.  */\n+#define USFRACT_MAX\t__USFRACT_MAX__\n+#define USFRACT_EPSILON\t__USFRACT_EPSILON__\n+\n+#undef FRACT_FBIT\n+#undef FRACT_MIN\n+#undef FRACT_MAX\n+#undef FRACT_EPSILON\n+#define FRACT_FBIT\t__FRACT_FBIT__\n+#define FRACT_MIN\t__FRACT_MIN__\n+#define FRACT_MAX\t__FRACT_MAX__\n+#define FRACT_EPSILON\t__FRACT_EPSILON__\n+\n+#undef UFRACT_FBIT\n+#undef UFRACT_MIN\n+#undef UFRACT_MAX\n+#undef UFRACT_EPSILON\n+#define UFRACT_FBIT\t__UFRACT_FBIT__\n+#define UFRACT_MIN\t__UFRACT_MIN__\t\t/* GCC extension.  */\n+#define UFRACT_MAX\t__UFRACT_MAX__\n+#define UFRACT_EPSILON\t__UFRACT_EPSILON__\n+\n+#undef LFRACT_FBIT\n+#undef LFRACT_MIN\n+#undef LFRACT_MAX\n+#undef LFRACT_EPSILON\n+#define LFRACT_FBIT\t__LFRACT_FBIT__\n+#define LFRACT_MIN\t__LFRACT_MIN__\n+#define LFRACT_MAX\t__LFRACT_MAX__\n+#define LFRACT_EPSILON\t__LFRACT_EPSILON__\n+\n+#undef ULFRACT_FBIT\n+#undef ULFRACT_MIN\n+#undef ULFRACT_MAX\n+#undef ULFRACT_EPSILON\n+#define ULFRACT_FBIT\t__ULFRACT_FBIT__\n+#define ULFRACT_MIN\t__ULFRACT_MIN__\t\t/* GCC extension.  */\n+#define ULFRACT_MAX\t__ULFRACT_MAX__\n+#define ULFRACT_EPSILON\t__ULFRACT_EPSILON__\n+\n+#undef LLFRACT_FBIT\n+#undef LLFRACT_MIN\n+#undef LLFRACT_MAX\n+#undef LLFRACT_EPSILON\n+#define LLFRACT_FBIT\t__LLFRACT_FBIT__\t/* GCC extension.  */\n+#define LLFRACT_MIN\t__LLFRACT_MIN__\t\t/* GCC extension.  */\n+#define LLFRACT_MAX\t__LLFRACT_MAX__\t\t/* GCC extension.  */\n+#define LLFRACT_EPSILON\t__LLFRACT_EPSILON__\t/* GCC extension.  */\n+\n+#undef ULLFRACT_FBIT\n+#undef ULLFRACT_MIN\n+#undef ULLFRACT_MAX\n+#undef ULLFRACT_EPSILON\n+#define ULLFRACT_FBIT\t__ULLFRACT_FBIT__\t/* GCC extension.  */\n+#define ULLFRACT_MIN\t__ULLFRACT_MIN__\t/* GCC extension.  */\n+#define ULLFRACT_MAX\t__ULLFRACT_MAX__\t/* GCC extension.  */\n+#define ULLFRACT_EPSILON\t__ULLFRACT_EPSILON__\t/* GCC extension.  */\n+\n+#undef SACCUM_FBIT\n+#undef SACCUM_IBIT\n+#undef SACCUM_MIN\n+#undef SACCUM_MAX\n+#undef SACCUM_EPSILON\n+#define SACCUM_FBIT\t__SACCUM_FBIT__\n+#define SACCUM_IBIT\t__SACCUM_IBIT__\n+#define SACCUM_MIN\t__SACCUM_MIN__\n+#define SACCUM_MAX\t__SACCUM_MAX__\n+#define SACCUM_EPSILON\t__SACCUM_EPSILON__\n+\n+#undef USACCUM_FBIT\n+#undef USACCUM_IBIT\n+#undef USACCUM_MIN\n+#undef USACCUM_MAX\n+#undef USACCUM_EPSILON\n+#define USACCUM_FBIT\t__USACCUM_FBIT__\n+#define USACCUM_IBIT\t__USACCUM_IBIT__\n+#define USACCUM_MIN\t__USACCUM_MIN__\t\t/* GCC extension.  */\n+#define USACCUM_MAX\t__USACCUM_MAX__\n+#define USACCUM_EPSILON\t__USACCUM_EPSILON__\n+\n+#undef ACCUM_FBIT\n+#undef ACCUM_IBIT\n+#undef ACCUM_MIN\n+#undef ACCUM_MAX\n+#undef ACCUM_EPSILON\n+#define ACCUM_FBIT\t__ACCUM_FBIT__\n+#define ACCUM_IBIT\t__ACCUM_IBIT__\n+#define ACCUM_MIN\t__ACCUM_MIN__\n+#define ACCUM_MAX\t__ACCUM_MAX__\n+#define ACCUM_EPSILON\t__ACCUM_EPSILON__\n+\n+#undef UACCUM_FBIT\n+#undef UACCUM_IBIT\n+#undef UACCUM_MIN\n+#undef UACCUM_MAX\n+#undef UACCUM_EPSILON\n+#define UACCUM_FBIT\t__UACCUM_FBIT__\n+#define UACCUM_IBIT\t__UACCUM_IBIT__\n+#define UACCUM_MIN\t__UACCUM_MIN__\t\t/* GCC extension.  */\n+#define UACCUM_MAX\t__UACCUM_MAX__\n+#define UACCUM_EPSILON\t__UACCUM_EPSILON__\n+\n+#undef LACCUM_FBIT\n+#undef LACCUM_IBIT\n+#undef LACCUM_MIN\n+#undef LACCUM_MAX\n+#undef LACCUM_EPSILON\n+#define LACCUM_FBIT\t__LACCUM_FBIT__\n+#define LACCUM_IBIT\t__LACCUM_IBIT__\n+#define LACCUM_MIN\t__LACCUM_MIN__\n+#define LACCUM_MAX\t__LACCUM_MAX__\n+#define LACCUM_EPSILON\t__LACCUM_EPSILON__\n+\n+#undef ULACCUM_FBIT\n+#undef ULACCUM_IBIT\n+#undef ULACCUM_MIN\n+#undef ULACCUM_MAX\n+#undef ULACCUM_EPSILON\n+#define ULACCUM_FBIT\t__ULACCUM_FBIT__\n+#define ULACCUM_IBIT\t__ULACCUM_IBIT__\n+#define ULACCUM_MIN\t__ULACCUM_MIN__\t\t/* GCC extension.  */\n+#define ULACCUM_MAX\t__ULACCUM_MAX__\n+#define ULACCUM_EPSILON\t__ULACCUM_EPSILON__\n+\n+#undef LLACCUM_FBIT\n+#undef LLACCUM_IBIT\n+#undef LLACCUM_MIN\n+#undef LLACCUM_MAX\n+#undef LLACCUM_EPSILON\n+#define LLACCUM_FBIT\t__LLACCUM_FBIT__\t/* GCC extension.  */\n+#define LLACCUM_IBIT\t__LLACCUM_IBIT__\t/* GCC extension.  */\n+#define LLACCUM_MIN\t__LLACCUM_MIN__\t\t/* GCC extension.  */\n+#define LLACCUM_MAX\t__LLACCUM_MAX__\t\t/* GCC extension.  */\n+#define LLACCUM_EPSILON\t__LLACCUM_EPSILON__\t/* GCC extension.  */\n+\n+#undef ULLACCUM_FBIT\n+#undef ULLACCUM_IBIT\n+#undef ULLACCUM_MIN\n+#undef ULLACCUM_MAX\n+#undef ULLACCUM_EPSILON\n+#define ULLACCUM_FBIT\t__ULLACCUM_FBIT__\t/* GCC extension.  */\n+#define ULLACCUM_IBIT\t__ULLACCUM_IBIT__\t/* GCC extension.  */\n+#define ULLACCUM_MIN\t__ULLACCUM_MIN__\t/* GCC extension.  */\n+#define ULLACCUM_MAX\t__ULLACCUM_MAX__\t/* GCC extension.  */\n+#define ULLACCUM_EPSILON\t__ULLACCUM_EPSILON__\t/* GCC extension.  */\n+\n+#endif /* _STDFIX_H */"}, {"sha": "b1b32efb441b5d37389214f9a6ccc240e1ff6bad", "filename": "gcc/optabs.c", "status": "modified", "additions": 324, "deletions": 10, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -358,9 +358,13 @@ optab_for_tree_code (enum tree_code code, const_tree type)\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? usdiv_optab : ssdiv_optab;\n       return TYPE_UNSIGNED (type) ? udiv_optab : sdiv_optab;\n \n     case LSHIFT_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? usashl_optab : ssashl_optab;\n       return ashl_optab;\n \n     case RSHIFT_EXPR:\n@@ -448,15 +452,23 @@ optab_for_tree_code (enum tree_code code, const_tree type)\n     {\n     case POINTER_PLUS_EXPR:\n     case PLUS_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? usadd_optab : ssadd_optab;\n       return trapv ? addv_optab : add_optab;\n \n     case MINUS_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? ussub_optab : sssub_optab;\n       return trapv ? subv_optab : sub_optab;\n \n     case MULT_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? usmul_optab : ssmul_optab;\n       return trapv ? smulv_optab : smul_optab;\n \n     case NEGATE_EXPR:\n+      if (TYPE_SATURATING(type))\n+\treturn TYPE_UNSIGNED(type) ? usneg_optab : ssneg_optab;\n       return trapv ? negv_optab : neg_optab;\n \n     case ABS_EXPR:\n@@ -1327,6 +1339,8 @@ shift_optab_p (optab binoptab)\n   switch (binoptab->code)\n     {\n     case ASHIFT:\n+    case SS_ASHIFT:\n+    case US_ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATE:\n@@ -5442,6 +5456,57 @@ expand_fix (rtx to, rtx from, int unsignedp)\n     }\n }\n \n+/* Generate code to convert FROM or TO a fixed-point.\n+   If UINTP is true, either TO or FROM is an unsigned integer.\n+   If SATP is true, we need to saturate the result.  */\n+\n+void\n+expand_fixed_convert (rtx to, rtx from, int uintp, int satp)\n+{\n+  enum machine_mode to_mode = GET_MODE (to);\n+  enum machine_mode from_mode = GET_MODE (from);\n+  convert_optab tab;\n+  enum rtx_code this_code;\n+  enum insn_code code;\n+  rtx insns, value;\n+  rtx libfunc;\n+\n+  if (to_mode == from_mode)\n+    {\n+      emit_move_insn (to, from);\n+      return;\n+    }\n+\n+  if (uintp)\n+    {\n+      tab = satp ? satfractuns_optab : fractuns_optab;\n+      this_code = satp ? UNSIGNED_SAT_FRACT : UNSIGNED_FRACT_CONVERT;\n+    }\n+  else\n+    {\n+      tab = satp ? satfract_optab : fract_optab;\n+      this_code = satp ? SAT_FRACT : FRACT_CONVERT;\n+    }\n+  code = tab->handlers[to_mode][from_mode].insn_code;\n+  if (code != CODE_FOR_nothing)\n+    {\n+      emit_unop_insn (code, to, from, this_code);\n+      return;\n+    }\n+\n+  libfunc = convert_optab_libfunc (tab, to_mode, from_mode);\n+  gcc_assert (libfunc);\n+\n+  start_sequence ();\n+  value = emit_library_call_value (libfunc, NULL_RTX, LCT_CONST, to_mode,\n+\t\t\t\t   1, from, from_mode);\n+  insns = get_insns ();\n+  end_sequence ();\n+\n+  emit_libcall_block (insns, to, value,\n+\t\t      gen_rtx_fmt_e (tab->code, to_mode, from));\n+}\n+\n /* Generate code to convert FROM to fixed point and store in TO.  FROM\n    must be floating point, TO must be signed.  Use the conversion optab\n    TAB to do the conversion.  */\n@@ -5625,6 +5690,41 @@ gen_fp_libfunc (optab optable, const char *opname, char suffix,\n     }\n }\n \n+/* Like gen_libfunc, but verify that fixed-point operation is involved.  */\n+\n+static void\n+gen_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t   enum machine_mode mode)\n+{\n+  if (!ALL_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that signed fixed-point operation is\n+   involved.  */\n+\n+static void\n+gen_signed_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t\t  enum machine_mode mode)\n+{\n+  if (!SIGNED_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that unsigned fixed-point operation is\n+   involved.  */\n+\n+static void\n+gen_unsigned_fixed_libfunc (optab optable, const char *opname, char suffix,\n+\t\t\t    enum machine_mode mode)\n+{\n+  if (!UNSIGNED_FIXED_POINT_MODE_P (mode))\n+    return;\n+  gen_libfunc (optable, opname, suffix, mode);\n+}\n+\n /* Like gen_libfunc, but verify that FP or INT operation is involved.  */\n \n static void\n@@ -5657,6 +5757,75 @@ gen_intv_fp_libfunc (optab optable, const char *name, char suffix,\n     }\n }\n \n+/* Like gen_libfunc, but verify that FP or INT or FIXED operation is\n+   involved.  */\n+\n+static void\n+gen_int_fp_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t  enum machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (ALL_FIXED_POINT_MODE_P (mode))\n+    gen_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that FP or INT or signed FIXED operation is\n+   involved.  */\n+\n+static void\n+gen_int_fp_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t\t enum machine_mode mode)\n+{\n+  if (DECIMAL_FLOAT_MODE_P (mode) || GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    gen_fp_libfunc (optable, name, suffix, mode);\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (SIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or FIXED operation is\n+   involved.  */\n+\n+static void\n+gen_int_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t       enum machine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (ALL_FIXED_POINT_MODE_P (mode))\n+    gen_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or signed FIXED operation is\n+   involved.  */\n+\n+static void\n+gen_int_signed_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t      enum machine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (SIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_signed_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n+/* Like gen_libfunc, but verify that INT or unsigned FIXED operation is\n+   involved.  */\n+\n+static void\n+gen_int_unsigned_fixed_libfunc (optab optable, const char *name, char suffix,\n+\t\t\t\tenum machine_mode mode)\n+{\n+  if (INTEGRAL_MODE_P (mode))\n+    gen_int_libfunc (optable, name, suffix, mode);\n+  if (UNSIGNED_FIXED_POINT_MODE_P (mode))\n+    gen_unsigned_fixed_libfunc (optable, name, suffix, mode);\n+}\n+\n /* Initialize the libfunc fields of an entire group of entries of an\n    inter-mode-class conversion optab.  The string formation rules are\n    similar to the ones for init_libfuncs, above, but instead of having\n@@ -5907,6 +6076,84 @@ gen_extend_conv_libfunc (convert_optab tab,\n     gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n }\n \n+/* Pick proper libcall for fract_optab.  We need to chose if we do\n+   interclass or intraclass.  */\n+\n+static void\n+gen_fract_conv_libfunc (convert_optab tab,\n+\t\t\tconst char *opname,\n+\t\t\tenum machine_mode tmode,\n+\t\t\tenum machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  if (!(ALL_FIXED_POINT_MODE_P (tmode) || ALL_FIXED_POINT_MODE_P (fmode)))\n+    return;\n+\n+  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+  else\n+    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for fractuns_optab.  */\n+\n+static void\n+gen_fractuns_conv_libfunc (convert_optab tab,\n+\t\t\t   const char *opname,\n+\t\t\t   enum machine_mode tmode,\n+\t\t\t   enum machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* One mode must be a fixed-point mode, and the other must be an integer\n+     mode. */\n+  if (!((ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT)\n+\t|| (ALL_FIXED_POINT_MODE_P (fmode)\n+\t    && GET_MODE_CLASS (tmode) == MODE_INT)))\n+    return;\n+\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for satfract_optab.  We need to chose if we do\n+   interclass or intraclass.  */\n+\n+static void\n+gen_satfract_conv_libfunc (convert_optab tab,\n+\t\t\t   const char *opname,\n+\t\t\t   enum machine_mode tmode,\n+\t\t\t   enum machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* TMODE must be a fixed-point mode.  */\n+  if (!ALL_FIXED_POINT_MODE_P (tmode))\n+    return;\n+\n+  if (GET_MODE_CLASS (tmode) == GET_MODE_CLASS (fmode))\n+    gen_intraclass_conv_libfunc (tab, opname, tmode, fmode);\n+  else\n+    gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n+/* Pick proper libcall for satfractuns_optab.  */\n+\n+static void\n+gen_satfractuns_conv_libfunc (convert_optab tab,\n+\t\t\t      const char *opname,\n+\t\t\t      enum machine_mode tmode,\n+\t\t\t      enum machine_mode fmode)\n+{\n+  if (tmode == fmode)\n+    return;\n+  /* TMODE must be a fixed-point mode, and FMODE must be an integer mode. */\n+  if (!(ALL_FIXED_POINT_MODE_P (tmode) && GET_MODE_CLASS (fmode) == MODE_INT))\n+    return;\n+\n+  gen_interclass_conv_libfunc (tab, opname, tmode, fmode);\n+}\n+\n rtx\n init_one_libfunc (const char *name)\n {\n@@ -6013,7 +6260,13 @@ init_optabs (void)\n   addv_optab = init_optabv (PLUS);\n   sub_optab = init_optab (MINUS);\n   subv_optab = init_optabv (MINUS);\n+  ssadd_optab = init_optab (SS_PLUS);\n+  usadd_optab = init_optab (US_PLUS);\n+  sssub_optab = init_optab (SS_MINUS);\n+  ussub_optab = init_optab (US_MINUS);\n   smul_optab = init_optab (MULT);\n+  ssmul_optab = init_optab (SS_MULT);\n+  usmul_optab = init_optab (US_MULT);\n   smulv_optab = init_optabv (MULT);\n   smul_highpart_optab = init_optab (UNKNOWN);\n   umul_highpart_optab = init_optab (UNKNOWN);\n@@ -6022,9 +6275,15 @@ init_optabs (void)\n   usmul_widen_optab = init_optab (UNKNOWN);\n   smadd_widen_optab = init_optab (UNKNOWN);\n   umadd_widen_optab = init_optab (UNKNOWN);\n+  ssmadd_widen_optab = init_optab (UNKNOWN);\n+  usmadd_widen_optab = init_optab (UNKNOWN);\n   smsub_widen_optab = init_optab (UNKNOWN);\n   umsub_widen_optab = init_optab (UNKNOWN);\n+  ssmsub_widen_optab = init_optab (UNKNOWN);\n+  usmsub_widen_optab = init_optab (UNKNOWN);\n   sdiv_optab = init_optab (DIV);\n+  ssdiv_optab = init_optab (SS_DIV);\n+  usdiv_optab = init_optab (US_DIV);\n   sdivv_optab = init_optabv (DIV);\n   sdivmod_optab = init_optab (UNKNOWN);\n   udiv_optab = init_optab (UDIV);\n@@ -6038,6 +6297,8 @@ init_optabs (void)\n   ior_optab = init_optab (IOR);\n   xor_optab = init_optab (XOR);\n   ashl_optab = init_optab (ASHIFT);\n+  ssashl_optab = init_optab (SS_ASHIFT);\n+  usashl_optab = init_optab (US_ASHIFT);\n   ashr_optab = init_optab (ASHIFTRT);\n   lshr_optab = init_optab (LSHIFTRT);\n   rotl_optab = init_optab (ROTATE);\n@@ -6069,6 +6330,8 @@ init_optabs (void)\n   unord_optab = init_optab (UNORDERED);\n \n   neg_optab = init_optab (NEG);\n+  ssneg_optab = init_optab (SS_NEG);\n+  usneg_optab = init_optab (US_NEG);\n   negv_optab = init_optabv (NEG);\n   abs_optab = init_optab (ABS);\n   absv_optab = init_optabv (ABS);\n@@ -6175,6 +6438,11 @@ init_optabs (void)\n   lfloor_optab = init_convert_optab (UNKNOWN);\n   lceil_optab = init_convert_optab (UNKNOWN);\n \n+  fract_optab = init_convert_optab (FRACT_CONVERT);\n+  fractuns_optab = init_convert_optab (UNSIGNED_FRACT_CONVERT);\n+  satfract_optab = init_convert_optab (SAT_FRACT);\n+  satfractuns_optab = init_convert_optab (UNSIGNED_SAT_FRACT);\n+\n   for (i = 0; i < NUM_MACHINE_MODES; i++)\n     {\n       movmem_optab[i] = CODE_FOR_nothing;\n@@ -6215,31 +6483,55 @@ init_optabs (void)\n   /* Initialize the optabs with the names of the library functions.  */\n   add_optab->libcall_basename = \"add\";\n   add_optab->libcall_suffix = '3';\n-  add_optab->libcall_gen = gen_int_fp_libfunc;\n+  add_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n   addv_optab->libcall_basename = \"add\";\n   addv_optab->libcall_suffix = '3';\n   addv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  ssadd_optab->libcall_basename = \"ssadd\";\n+  ssadd_optab->libcall_suffix = '3';\n+  ssadd_optab->libcall_gen = gen_signed_fixed_libfunc;\n+  usadd_optab->libcall_basename = \"usadd\";\n+  usadd_optab->libcall_suffix = '3';\n+  usadd_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   sub_optab->libcall_basename = \"sub\";\n   sub_optab->libcall_suffix = '3';\n-  sub_optab->libcall_gen = gen_int_fp_libfunc;\n+  sub_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n   subv_optab->libcall_basename = \"sub\";\n   subv_optab->libcall_suffix = '3';\n   subv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  sssub_optab->libcall_basename = \"sssub\";\n+  sssub_optab->libcall_suffix = '3';\n+  sssub_optab->libcall_gen = gen_signed_fixed_libfunc;\n+  ussub_optab->libcall_basename = \"ussub\";\n+  ussub_optab->libcall_suffix = '3';\n+  ussub_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   smul_optab->libcall_basename = \"mul\";\n   smul_optab->libcall_suffix = '3';\n-  smul_optab->libcall_gen = gen_int_fp_libfunc;\n+  smul_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n   smulv_optab->libcall_basename = \"mul\";\n   smulv_optab->libcall_suffix = '3';\n   smulv_optab->libcall_gen = gen_intv_fp_libfunc;\n+  ssmul_optab->libcall_basename = \"ssmul\";\n+  ssmul_optab->libcall_suffix = '3';\n+  ssmul_optab->libcall_gen = gen_signed_fixed_libfunc;\n+  usmul_optab->libcall_basename = \"usmul\";\n+  usmul_optab->libcall_suffix = '3';\n+  usmul_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   sdiv_optab->libcall_basename = \"div\";\n   sdiv_optab->libcall_suffix = '3';\n-  sdiv_optab->libcall_gen = gen_int_fp_libfunc;\n+  sdiv_optab->libcall_gen = gen_int_fp_signed_fixed_libfunc;\n   sdivv_optab->libcall_basename = \"divv\";\n   sdivv_optab->libcall_suffix = '3';\n   sdivv_optab->libcall_gen = gen_int_libfunc;\n+  ssdiv_optab->libcall_basename = \"ssdiv\";\n+  ssdiv_optab->libcall_suffix = '3';\n+  ssdiv_optab->libcall_gen = gen_signed_fixed_libfunc;\n   udiv_optab->libcall_basename = \"udiv\";\n   udiv_optab->libcall_suffix = '3';\n-  udiv_optab->libcall_gen = gen_int_libfunc;\n+  udiv_optab->libcall_gen = gen_int_unsigned_fixed_libfunc;\n+  usdiv_optab->libcall_basename = \"usdiv\";\n+  usdiv_optab->libcall_suffix = '3';\n+  usdiv_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   sdivmod_optab->libcall_basename = \"divmod\";\n   sdivmod_optab->libcall_suffix = '4';\n   sdivmod_optab->libcall_gen = gen_int_libfunc;\n@@ -6266,13 +6558,19 @@ init_optabs (void)\n   xor_optab->libcall_gen = gen_int_libfunc;\n   ashl_optab->libcall_basename = \"ashl\";\n   ashl_optab->libcall_suffix = '3';\n-  ashl_optab->libcall_gen = gen_int_libfunc;\n+  ashl_optab->libcall_gen = gen_int_fixed_libfunc;\n+  ssashl_optab->libcall_basename = \"ssashl\";\n+  ssashl_optab->libcall_suffix = '3';\n+  ssashl_optab->libcall_gen = gen_signed_fixed_libfunc;\n+  usashl_optab->libcall_basename = \"usashl\";\n+  usashl_optab->libcall_suffix = '3';\n+  usashl_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   ashr_optab->libcall_basename = \"ashr\";\n   ashr_optab->libcall_suffix = '3';\n-  ashr_optab->libcall_gen = gen_int_libfunc;\n+  ashr_optab->libcall_gen = gen_int_signed_fixed_libfunc;\n   lshr_optab->libcall_basename = \"lshr\";\n   lshr_optab->libcall_suffix = '3';\n-  lshr_optab->libcall_gen = gen_int_libfunc;\n+  lshr_optab->libcall_gen = gen_int_unsigned_fixed_libfunc;\n   smin_optab->libcall_basename = \"min\";\n   smin_optab->libcall_suffix = '3';\n   smin_optab->libcall_gen = gen_int_fp_libfunc;\n@@ -6287,7 +6585,13 @@ init_optabs (void)\n   umax_optab->libcall_gen = gen_int_libfunc;\n   neg_optab->libcall_basename = \"neg\";\n   neg_optab->libcall_suffix = '2';\n-  neg_optab->libcall_gen = gen_int_fp_libfunc;\n+  neg_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n+  ssneg_optab->libcall_basename = \"ssneg\";\n+  ssneg_optab->libcall_suffix = '2';\n+  ssneg_optab->libcall_gen = gen_signed_fixed_libfunc;\n+  usneg_optab->libcall_basename = \"usneg\";\n+  usneg_optab->libcall_suffix = '2';\n+  usneg_optab->libcall_gen = gen_unsigned_fixed_libfunc;\n   negv_optab->libcall_basename = \"neg\";\n   negv_optab->libcall_suffix = '2';\n   negv_optab->libcall_gen = gen_intv_fp_libfunc;\n@@ -6314,7 +6618,7 @@ init_optabs (void)\n      signed/unsigned.  */\n   cmp_optab->libcall_basename = \"cmp\";\n   cmp_optab->libcall_suffix = '2';\n-  cmp_optab->libcall_gen = gen_int_fp_libfunc;\n+  cmp_optab->libcall_gen = gen_int_fp_fixed_libfunc;\n   ucmp_optab->libcall_basename = \"ucmp\";\n   ucmp_optab->libcall_suffix = '2';\n   ucmp_optab->libcall_gen = gen_int_libfunc;\n@@ -6369,6 +6673,16 @@ init_optabs (void)\n   trunc_optab->libcall_basename = \"trunc\";\n   trunc_optab->libcall_gen = gen_trunc_conv_libfunc;\n \n+  /* Conversions for fixed-point modes and other modes.  */\n+  fract_optab->libcall_basename = \"fract\";\n+  fract_optab->libcall_gen = gen_fract_conv_libfunc;\n+  satfract_optab->libcall_basename = \"satfract\";\n+  satfract_optab->libcall_gen = gen_satfract_conv_libfunc;\n+  fractuns_optab->libcall_basename = \"fractuns\";\n+  fractuns_optab->libcall_gen = gen_fractuns_conv_libfunc;\n+  satfractuns_optab->libcall_basename = \"satfractuns\";\n+  satfractuns_optab->libcall_gen = gen_satfractuns_conv_libfunc;\n+\n   /* The ffs function operates on `int'.  Fall back on it if we do not\n      have a libgcc2 function for that width.  */\n   if (INT_TYPE_SIZE < BITS_PER_WORD)"}, {"sha": "9dd98134a0b5effec96b966d46955f3d305647e7", "filename": "gcc/optabs.h", "status": "modified", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f996086cbf16283b2494ca36c7573abb5f06df7/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=0f996086cbf16283b2494ca36c7573abb5f06df7", "patch": "@@ -75,6 +75,20 @@ typedef struct convert_optab *convert_optab;\n /* Enumeration of valid indexes into optab_table.  */\n enum optab_index\n {\n+  /* Fixed-point operators with signed/unsigned saturation */\n+  OTI_ssadd,\n+  OTI_usadd,\n+  OTI_sssub,\n+  OTI_ussub,\n+  OTI_ssmul,\n+  OTI_usmul,\n+  OTI_ssdiv,\n+  OTI_usdiv,\n+  OTI_ssneg,\n+  OTI_usneg,\n+  OTI_ssashl,\n+  OTI_usashl,\n+\n   OTI_add,\n   OTI_addv,\n   OTI_sub,\n@@ -97,12 +111,28 @@ enum optab_index\n   /* Unsigned multiply and add with the result and addend one machine mode\n      wider than the multiplicand and multiplier.  */\n   OTI_umadd_widen,\n+  /* Signed multiply and add with the result and addend one machine mode\n+     wider than the multiplicand and multiplier.\n+     All involved operations are saturating.  */\n+  OTI_ssmadd_widen,\n+  /* Unigned multiply and add with the result and addend one machine mode\n+     wider than the multiplicand and multiplier.\n+     All involved operations are saturating.  */\n+  OTI_usmadd_widen,\n   /* Signed multiply and subtract the result and minuend one machine mode\n      wider than the multiplicand and multiplier.  */\n   OTI_smsub_widen,\n   /* Unsigned multiply and subtract the result and minuend one machine mode\n      wider than the multiplicand and multiplier.  */\n   OTI_umsub_widen,\n+  /* Signed multiply and subtract the result and minuend one machine mode\n+     wider than the multiplicand and multiplier.\n+     All involved operations are saturating.  */\n+  OTI_ssmsub_widen,\n+  /* Unigned multiply and subtract the result and minuend one machine mode\n+     wider than the multiplicand and multiplier.\n+     All involved operations are saturating.  */\n+  OTI_usmsub_widen,\n \n   /* Signed divide */\n   OTI_sdiv,\n@@ -332,6 +362,19 @@ enum optab_index\n \n extern optab optab_table[OTI_MAX];\n \n+#define ssadd_optab (optab_table[OTI_ssadd])\n+#define usadd_optab (optab_table[OTI_usadd])\n+#define sssub_optab (optab_table[OTI_sssub])\n+#define ussub_optab (optab_table[OTI_ussub])\n+#define ssmul_optab (optab_table[OTI_ssmul])\n+#define usmul_optab (optab_table[OTI_usmul])\n+#define ssdiv_optab (optab_table[OTI_ssdiv])\n+#define usdiv_optab (optab_table[OTI_usdiv])\n+#define ssneg_optab (optab_table[OTI_ssneg])\n+#define usneg_optab (optab_table[OTI_usneg])\n+#define ssashl_optab (optab_table[OTI_ssashl])\n+#define usashl_optab (optab_table[OTI_usashl])\n+\n #define add_optab (optab_table[OTI_add])\n #define sub_optab (optab_table[OTI_sub])\n #define smul_optab (optab_table[OTI_smul])\n@@ -344,8 +387,12 @@ extern optab optab_table[OTI_MAX];\n #define usmul_widen_optab (optab_table[OTI_usmul_widen])\n #define smadd_widen_optab (optab_table[OTI_smadd_widen])\n #define umadd_widen_optab (optab_table[OTI_umadd_widen])\n+#define ssmadd_widen_optab (optab_table[OTI_ssmadd_widen])\n+#define usmadd_widen_optab (optab_table[OTI_usmadd_widen])\n #define smsub_widen_optab (optab_table[OTI_smsub_widen])\n #define umsub_widen_optab (optab_table[OTI_umsub_widen])\n+#define ssmsub_widen_optab (optab_table[OTI_ssmsub_widen])\n+#define usmsub_widen_optab (optab_table[OTI_usmsub_widen])\n #define sdiv_optab (optab_table[OTI_sdiv])\n #define smulv_optab (optab_table[OTI_smulv])\n #define sdivv_optab (optab_table[OTI_sdivv])\n@@ -501,6 +548,11 @@ enum convert_optab_index\n   COI_lfloor,\n   COI_lceil,\n \n+  COI_fract,\n+  COI_fractuns,\n+  COI_satfract,\n+  COI_satfractuns,\n+\n   COI_MAX\n };\n \n@@ -519,6 +571,10 @@ extern convert_optab convert_optab_table[COI_MAX];\n #define lround_optab (convert_optab_table[COI_lround])\n #define lfloor_optab (convert_optab_table[COI_lfloor])\n #define lceil_optab (convert_optab_table[COI_lceil])\n+#define fract_optab (convert_optab_table[COI_fract])\n+#define fractuns_optab (convert_optab_table[COI_fractuns])\n+#define satfract_optab (convert_optab_table[COI_satfract])\n+#define satfractuns_optab (convert_optab_table[COI_satfractuns])\n \n /* These arrays record the insn_code of insns that may be needed to\n    perform input and output reloads of special objects.  They provide a\n@@ -693,6 +749,9 @@ extern void set_optab_libfunc (optab, enum machine_mode, const char *);\n extern void set_conv_libfunc (convert_optab, enum machine_mode,\n \t\t\t      enum machine_mode, const char *);\n \n+/* Generate code for a FIXED_CONVERT_EXPR.  */\n+extern void expand_fixed_convert (rtx, rtx, int, int);\n+\n /* Generate code for a FLOAT_EXPR.  */\n extern void expand_float (rtx, rtx, int);\n "}]}