{"sha": "d6b4ea8592e338addbd24be14708f66eaa4ac63e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDZiNGVhODU5MmUzMzhhZGRiZDI0YmUxNDcwOGY2NmVhYTRhYzYzZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2003-07-04T05:05:19Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2003-07-04T05:05:19Z"}, "message": "call.c (build_addr_func): Handle bound pointers-to-members.\n\n\t* call.c (build_addr_func): Handle bound pointers-to-members.\n\t(build_method_call): Do not call resolve_offset_ref.\n\t(implicit_conversion): Likewise.\n\t(resolve_scoped_fn_name): Use finish_non_static_data_member, not\n\tresolve_offset_ref.\n\t(resolve_args): Do not call resolve_offset_ref.\n\t(build_conditional_expr): Likewise.\n\t(build_new_method_call): Likewise.\n\t* cp-tree.def (OFFSET_REF): Update documentation.\n\t(cp_convert_to_pointer): Update handling of conversions from\n\tpointers to members to pointers.\n\t(ocp_convert): Do not call resolve_offset_ref.\n\t(convert_to_void): Likewise.\n\t(build_expr_type_conversion): Likewise.\n\t(delete_sanity): Likewise.\n\t(resolve_offset_ref): Simplify greatly.\n\t(build_vec_delete): Do not call resolve_offset_ref.\n\t* parser.c (cp_parser_postfix_expression): Call resolve_offset_ref\n\tif appropriate.\n\t(cp_parser_unary_expression): Use\n\tcp_parser_simple_cast_expression.\n\t(cp_parser_delete_expression): Likewise.\n\t(cp_parser_cast_expression): Likewise.\n\t(cp_parser_pm_expression): Use cp_parser_binary_op.\n\t(cp_parser_simple_cast_expression): New function.\n\t* rtti.c (build_dynamic_cast_1): Do not call resolve_offset_ref.\n\t* semantics.c (finish_increment_expr): Likewise.\n\t(finish_typeof): Likewise.\n\t* tree.c (lvalue_p_1): Do not handle OFFSET_REF.\n\t* typeck.c (require_complete_type): Do not handle OFFSET_REFs.\n\t(decay_conversion): Do not call resolve_offset_ref.\n\t(finish_class_member_access_expr): Likewise.\n\t(convert_arguments): Likewise.\n\t(build_x_binary_op): Handle DOTSTAR_EXPR.\n\t(condition_conversion): Do not call resolve_offset_ref.\n\t(unary_complex_lvalue): Likewise.\n\t(build_static_cast): Likewise.\n\t(build_reinterpret_cast): Likewise.\n\t(build_const_cast): Likewise.\n\t(build_c_cast): Likewise.\n\t(build_modify_expr): Likewise.\n\t(convert_for_assignment): Likewise.\n\t(convert_for_initialization): Likewise.\n\t* typeck2.c (build_x_arrow): Likewise.\n\t(build_m_component_ref): Simplify.\n\n\t* g++.old-deja/g++.jason/typeid1.C: Add dg-error marker.\n\t* g++.old-deja/g++.mike/net36.C: Tweak error messages.\n\nFrom-SVN: r68911", "tree": {"sha": "613039e905b0fbc1fe50e07889b99fdc172e8d14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/613039e905b0fbc1fe50e07889b99fdc172e8d14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d6b4ea8592e338addbd24be14708f66eaa4ac63e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b4ea8592e338addbd24be14708f66eaa4ac63e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d6b4ea8592e338addbd24be14708f66eaa4ac63e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d6b4ea8592e338addbd24be14708f66eaa4ac63e/comments", "author": null, "committer": null, "parents": [{"sha": "5f1989e65d23624efdbf26bde56f375e3caa6a22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f1989e65d23624efdbf26bde56f375e3caa6a22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f1989e65d23624efdbf26bde56f375e3caa6a22"}], "stats": {"total": 553, "additions": 192, "deletions": 361}, "files": [{"sha": "076dcbd300e06693b64a8e2fcd193adad93c0321", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -6,6 +6,52 @@\n \n 2003-07-03  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* call.c (build_addr_func): Handle bound pointers-to-members.\n+\t(build_method_call): Do not call resolve_offset_ref.\n+\t(implicit_conversion): Likewise.\n+\t(resolve_scoped_fn_name): Use finish_non_static_data_member, not\n+\tresolve_offset_ref.\n+\t(resolve_args): Do not call resolve_offset_ref.\n+\t(build_conditional_expr): Likewise.\n+\t(build_new_method_call): Likewise.\n+\t* cp-tree.def (OFFSET_REF): Update documentation.\n+\t(cp_convert_to_pointer): Update handling of conversions from\n+\tpointers to members to pointers.\n+\t(ocp_convert): Do not call resolve_offset_ref.\n+\t(convert_to_void): Likewise.\n+\t(build_expr_type_conversion): Likewise.\n+\t(delete_sanity): Likewise.\n+\t(resolve_offset_ref): Simplify greatly.\n+\t(build_vec_delete): Do not call resolve_offset_ref.\n+\t* parser.c (cp_parser_postfix_expression): Call resolve_offset_ref\n+\tif appropriate.\n+\t(cp_parser_unary_expression): Use\n+\tcp_parser_simple_cast_expression.\n+\t(cp_parser_delete_expression): Likewise.\n+\t(cp_parser_cast_expression): Likewise.\n+\t(cp_parser_pm_expression): Use cp_parser_binary_op.\n+\t(cp_parser_simple_cast_expression): New function.\n+\t* rtti.c (build_dynamic_cast_1): Do not call resolve_offset_ref.\n+\t* semantics.c (finish_increment_expr): Likewise.\n+\t(finish_typeof): Likewise.\n+\t* tree.c (lvalue_p_1): Do not handle OFFSET_REF.\n+\t* typeck.c (require_complete_type): Do not handle OFFSET_REFs.\n+\t(decay_conversion): Do not call resolve_offset_ref.\n+\t(finish_class_member_access_expr): Likewise.\n+\t(convert_arguments): Likewise.\n+\t(build_x_binary_op): Handle DOTSTAR_EXPR.\n+\t(condition_conversion): Do not call resolve_offset_ref.\n+\t(unary_complex_lvalue): Likewise.\n+\t(build_static_cast): Likewise.\n+\t(build_reinterpret_cast): Likewise.\n+\t(build_const_cast): Likewise.\n+\t(build_c_cast): Likewise.\n+\t(build_modify_expr): Likewise.\n+\t(convert_for_assignment): Likewise.\n+\t(convert_for_initialization): Likewise.\n+\t* typeck2.c (build_x_arrow): Likewise.\n+\t(build_m_component_ref): Simplify.\n+\t\n \t* call.c (build_scoped_method_call): Use convert_to_void.\n \t(build_method_call): Likewise.\n \t* class.c (check_field_decls): Remove dead code."}, {"sha": "e8a54dc0113e90eef5ed0d4ed95a4c75593855fa", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 32, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -317,21 +317,13 @@ build_addr_func (tree function)\n      functions.  */\n   if (TREE_CODE (type) == METHOD_TYPE)\n     {\n-      tree addr;\n-\n-      type = build_pointer_type (type);\n-\n-      if (!cxx_mark_addressable (function))\n-\treturn error_mark_node;\n-\n-      addr = build1 (ADDR_EXPR, type, function);\n-\n-      /* Address of a static or external variable or function counts\n-\t as a constant */\n-      if (staticp (function))\n-\tTREE_CONSTANT (addr) = 1;\n-\n-      function = addr;\n+      if (TREE_CODE (function) == OFFSET_REF)\n+\t{\n+\t  tree object = build_address (TREE_OPERAND (function, 0));\n+\t  return get_member_function_from_ptrfunc (&object,\n+\t\t\t\t\t\t   TREE_OPERAND (function, 1));\n+\t}\n+      function = build_address (function);\n     }\n   else\n     function = default_conversion (function);\n@@ -477,8 +469,6 @@ build_method_call (tree instance, tree name, tree parms,\n   if (processing_template_decl)\n     return build_min_nt (METHOD_CALL_EXPR, name, instance, parms, NULL_TREE);\n \n-  if (TREE_CODE (instance) == OFFSET_REF)\n-    instance = resolve_offset_ref (instance);\n   if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n     instance = convert_from_reference (instance);\n   object_type = TREE_TYPE (instance);\n@@ -1295,14 +1285,6 @@ implicit_conversion (tree to, tree from, tree expr, int flags)\n {\n   tree conv;\n \n-  /* Resolve expressions like `A::p' that we thought might become\n-     pointers-to-members.  */\n-  if (expr && TREE_CODE (expr) == OFFSET_REF)\n-    {\n-      expr = resolve_offset_ref (expr);\n-      from = TREE_TYPE (expr);\n-    }\n-\n   if (from == error_mark_node || to == error_mark_node\n       || expr == error_mark_node)\n     return NULL_TREE;\n@@ -2790,7 +2772,7 @@ resolve_scoped_fn_name (tree scope, tree name)\n \n       /* It might be the name of a function pointer member.  */\n       if (fn && TREE_CODE (fn) == FIELD_DECL)\n-\tfn = resolve_offset_ref (build_offset_ref (scope, fn));\n+\tfn = finish_non_static_data_member (fn, scope);\n     }\n   \n   if (!fn)\n@@ -2831,8 +2813,6 @@ resolve_args (tree args)\n \t  error (\"invalid use of void expression\");\n \t  return error_mark_node;\n \t}\n-      else if (TREE_CODE (arg) == OFFSET_REF)\n-\targ = resolve_offset_ref (arg);\n       arg = convert_from_reference (arg);\n       TREE_VALUE (t) = arg;\n     }\n@@ -3565,8 +3545,6 @@ prep_operand (tree operand)\n {\n   if (operand)\n     {\n-      if (TREE_CODE (operand) == OFFSET_REF)\n-\toperand = resolve_offset_ref (operand);\n       operand = convert_from_reference (operand);\n       if (CLASS_TYPE_P (TREE_TYPE (operand))\n \t  && CLASSTYPE_TEMPLATE_INSTANTIATION (TREE_TYPE (operand)))\n@@ -5025,8 +5003,6 @@ build_new_method_call (tree instance, tree fns, tree args,\n   if (args == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (instance) == OFFSET_REF)\n-    instance = resolve_offset_ref (instance);\n   if (TREE_CODE (TREE_TYPE (instance)) == REFERENCE_TYPE)\n     instance = convert_from_reference (instance);\n   basetype = TYPE_MAIN_VARIANT (TREE_TYPE (instance));"}, {"sha": "e988a4e25f98595b77aeff37f27e4b8a8e0a037e", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -26,22 +26,22 @@ Boston, MA 02111-1307, USA.  */\n /* An OFFSET_REF is used in two situations:\n \n    1. An expression of the form `A::m' where `A' is a class and `m' is\n-      a non-static data member.  In this case, operand 0 will be a\n-      TYPE (corresponding to `A') and operand 1 will be a FIELD_DECL\n-      (corresponding to `m'.\n+      a non-static member.  In this case, operand 0 will be a TYPE\n+      (corresponding to `A') and operand 1 will be a FIELD_DECL,\n+      BASELINK, or TEMPLATE_ID_EXPR (corresponding to `m').\n \n       The expression is a pointer-to-member if its address is taken,\n       but simply denotes a member of the object if its address isnot\n       taken.  In the latter case, resolve_offset_ref is used to\n       convert it to a representation of the member referred to by the\n       OFFSET_REF.\n+      \n+      This form is only used during the parsing phase; once semantic\n+      analysis has taken place they are eliminated.\n \n    2. An expression of the form `x.*p'.  In this case, operand 0 will\n       be an expression corresponding to `x' and operand 1 will be an\n-      expression with pointer-to-member type.\n-\n-   OFFSET_REFs are only used during the parsing phase; once semantic\n-   analysis has taken place they are eliminated.  */\n+      expression with pointer-to-member type.  */\n DEFTREECODE (OFFSET_REF, \"offset_ref\", 'r', 2)\n \n /* A pointer-to-member constant.  For a pointer-to-member constant"}, {"sha": "24a3416d42c88302491ad8d041896b7c0c086d6b", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -109,24 +109,26 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n \t functions.  */\n       if (TYPE_PTRMEMFUNC_P (intype))\n \t{\n-\t  tree fntype = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (intype));\n-\t  tree decl = maybe_dummy_object (TYPE_METHOD_BASETYPE (fntype), 0);\n-\t  expr = build (OFFSET_REF, fntype, decl, expr);\n+\t  if (pedantic || warn_pmf2ptr)\n+\t    pedwarn (\"converting from `%T' to `%T'\", intype, type);\n+\t  if (TREE_CODE (expr) == PTRMEM_CST)\n+\t    expr = build_address (PTRMEM_CST_MEMBER (expr));\n+\t  else\n+\t    {\n+\t      tree decl = maybe_dummy_object (TYPE_PTRMEM_CLASS_TYPE (intype), \n+\t\t\t\t\t      0);\n+\t      decl = build_address (decl);\n+\t      expr = get_member_function_from_ptrfunc (&decl, expr);\n+\t    }\n \t}\n-\n-      if (TREE_CODE (expr) == OFFSET_REF\n-\t  && TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n-\texpr = resolve_offset_ref (expr);\n-      if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n-\texpr = build_addr_func (expr);\n-      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+      else if (TREE_CODE (TREE_TYPE (expr)) == METHOD_TYPE)\n \t{\n-\t  if (TREE_CODE (TREE_TYPE (TREE_TYPE (expr))) == METHOD_TYPE)\n-\t    if (pedantic || warn_pmf2ptr)\n-\t      pedwarn (\"converting from `%T' to `%T'\", TREE_TYPE (expr),\n-\t\t\t  type);\n-\t  return build1 (NOP_EXPR, type, expr);\n+\t  if (pedantic || warn_pmf2ptr)\n+\t    pedwarn (\"converting from `%T' to `%T'\", intype, type);\n+\t  expr = build_addr_func (expr);\n \t}\n+      if (TREE_CODE (TREE_TYPE (expr)) == POINTER_TYPE)\n+\treturn build_nop (type, expr);\n       intype = TREE_TYPE (expr);\n     }\n \n@@ -233,6 +235,19 @@ cp_convert_to_pointer (tree type, tree expr, bool force)\n     return build_ptrmemfunc (TYPE_PTRMEMFUNC_FN_TYPE (type), expr, 0);\n   else if (TYPE_PTRMEMFUNC_P (intype))\n     {\n+      if (!warn_pmf2ptr)\n+\t{\n+\t  if (TREE_CODE (expr) == PTRMEM_CST)\n+\t    return cp_convert_to_pointer (type,\n+\t\t\t\t\t  PTRMEM_CST_MEMBER (expr),\n+\t\t\t\t\t  force);\n+\t  else if (TREE_CODE (expr) == OFFSET_REF)\n+\t    {\n+\t      tree object = TREE_OPERAND (expr, 0);\n+\t      return get_member_function_from_ptrfunc (&object,\n+\t\t\t\t\t\t       TREE_OPERAND (expr, 1));\n+\t    }\n+\t}\n       error (\"cannot convert `%E' from type `%T' to type `%T'\",\n \t\texpr, intype, type);\n       return error_mark_node;\n@@ -663,9 +678,6 @@ ocp_convert (tree type, tree expr, int convtype, int flags)\n       code = TREE_CODE (type);\n     }\n \n-  if (TREE_CODE (e) == OFFSET_REF)\n-    e = resolve_offset_ref (e);\n-\n   if (INTEGRAL_CODE_P (code))\n     {\n       tree intype = TREE_TYPE (e);\n@@ -879,10 +891,6 @@ convert_to_void (tree expr, const char *implicit)\n         break;\n       }\n \n-    case OFFSET_REF:\n-      expr = resolve_offset_ref (expr);\n-      break;\n-\n     default:;\n     }\n   {\n@@ -1023,8 +1031,6 @@ build_expr_type_conversion (int desires, tree expr, bool complain)\n       && !(desires & WANT_NULL))\n     warning (\"converting NULL to non-pointer type\");\n     \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n   expr = convert_from_reference (expr);\n   basetype = TREE_TYPE (expr);\n "}, {"sha": "78e84ca0056ec965b75f593f3ab3813b76d84672", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -481,8 +481,6 @@ delete_sanity (tree exp, tree size, int doing_vec, int use_global_delete)\n       return t;\n     }\n \n-  if (TREE_CODE (exp) == OFFSET_REF)\n-    exp = resolve_offset_ref (exp);\n   exp = convert_from_reference (exp);\n   t = build_expr_type_conversion (WANT_POINTER, exp, true);\n "}, {"sha": "e1a19b1aedc413656f45f54eadfc1ac050bdfd6b", "filename": "gcc/cp/init.c", "status": "modified", "additions": 26, "deletions": 105, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -1689,121 +1689,45 @@ build_offset_ref (tree type, tree name)\n tree\n resolve_offset_ref (tree exp)\n {\n-  tree type = TREE_TYPE (exp);\n-  tree base = NULL_TREE;\n   tree member;\n-  tree basetype, addr;\n-\n-  if (TREE_CODE (exp) == OFFSET_REF)\n-    {\n-      member = TREE_OPERAND (exp, 1);\n-      base = TREE_OPERAND (exp, 0);\n-    }\n-  else\n-    {\n-      my_friendly_assert (TREE_CODE (type) == OFFSET_TYPE, 214);\n-      if (TYPE_OFFSET_BASETYPE (type) != current_class_type)\n-\t{\n-\t  error (\"object missing in use of pointer-to-member construct\");\n-\t  return error_mark_node;\n-\t}\n-      member = exp;\n-      type = TREE_TYPE (type);\n-      base = current_class_ref;\n-    }\n-\n-  if (BASELINK_P (member) || TREE_CODE (member) == TEMPLATE_ID_EXPR)\n-    return build_unary_op (ADDR_EXPR, exp, 0);\n-  \n-  if (TREE_CODE (TREE_TYPE (member)) == METHOD_TYPE)\n-    {\n-      if (!flag_ms_extensions)\n-        /* A single non-static member, make sure we don't allow a\n-           pointer-to-member.  */\n-        exp = ovl_cons (member, NULL_TREE);\n-      \n-      return build_unary_op (ADDR_EXPR, exp, 0);\n-    }\n-  \n-  if ((TREE_CODE (member) == VAR_DECL\n-       && ! TYPE_PTRMEMFUNC_P (TREE_TYPE (member))\n-       && ! TYPE_PTRMEM_P (TREE_TYPE (member)))\n-      || TREE_CODE (TREE_TYPE (member)) == FUNCTION_TYPE)\n-    {\n-      /* These were static members.  */\n-      if (!cxx_mark_addressable (member))\n-\treturn error_mark_node;\n-      return member;\n-    }\n \n-  if (TREE_CODE (TREE_TYPE (member)) == POINTER_TYPE\n-      && TREE_CODE (TREE_TYPE (TREE_TYPE (member))) == METHOD_TYPE)\n-    return member;\n+  my_friendly_assert (TREE_CODE (exp) == OFFSET_REF, 20030703);\n \n-  /* Syntax error can cause a member which should\n-     have been seen as static to be grok'd as non-static.  */\n-  if (TREE_CODE (member) == FIELD_DECL && current_class_ref == NULL_TREE)\n-    {\n-      cp_error_at (\"member `%D' is non-static but referenced as a static member\",\n-\t\t   member);\n-      error (\"at this point in file\");\n-      return error_mark_node;\n-    }\n+  member = TREE_OPERAND (exp, 1);\n \n-  /* The first case is really just a reference to a member of `this'.  */\n-  if (TREE_CODE (member) == FIELD_DECL\n-      && (base == current_class_ref || is_dummy_object (base)))\n-    {\n-      tree binfo = NULL_TREE;\n+  /* If MEMBER is non-static, then the program has fallen afoul of\n+     [expr.prim]:\n \n-      /* Try to get to basetype from 'this'; if that doesn't work,\n-         nothing will.  */\n-      base = current_class_ref;\n+       An id-expression that denotes a nonstatic data member or\n+       nonstatic member function of a class can only be used:\n \n-      /* First convert to the intermediate base specified, if appropriate.  */\n-      if (TREE_CODE (exp) == OFFSET_REF && TREE_CODE (type) == OFFSET_TYPE)\n-\tbase = build_scoped_ref (base, TYPE_OFFSET_BASETYPE (type), &binfo);\n+       -- as part of a class member access (_expr.ref_) in which the\n+       object-expression refers to the member's class or a class\n+       derived from that class, or\n \n-      return build_class_member_access_expr (base, member,\n-\t\t\t\t\t     /*access_path=*/NULL_TREE,\n-\t\t\t\t\t     /*preserve_reference=*/false);\n-    }\n+       -- to form a pointer to member (_expr.unary.op_), or\n \n-  /* Ensure that we have an object.  */\n-  if (is_dummy_object (base))\n-    addr = error_mark_node;\n-  else\n-    /* If this is a reference to a member function, then return the\n-       address of the member function (which may involve going\n-       through the object's vtable), otherwise, return an expression\n-       for the dereferenced pointer-to-member construct.  */\n-    addr = build_unary_op (ADDR_EXPR, base, 0);\n+       -- in the body of a nonstatic member function of that class or\n+       of a class derived from that class (_class.mfct.nonstatic_), or\n \n-  if (TYPE_PTRMEM_P (TREE_TYPE (member)))\n+       -- in a mem-initializer for a constructor for that class or for\n+       a class derived from that class (_class.base.init_).  */\n+  if (DECL_NONSTATIC_MEMBER_FUNCTION_P (member))\n     {\n-      if (addr == error_mark_node)\n-\t{\n-\t  error (\"object missing in `%E'\", exp);\n-\t  return error_mark_node;\n-\t}\n-\n-      basetype = TYPE_OFFSET_BASETYPE (TREE_TYPE (TREE_TYPE (member)));\n-      basetype = lookup_base (TREE_TYPE (TREE_TYPE (addr)),\n-\t\t\t      basetype, ba_check, NULL);\n-      addr = build_base_path (PLUS_EXPR, addr, basetype, 1);\n-      \n-      member = cp_convert (ptrdiff_type_node, member);\n-\n-      addr = build (PLUS_EXPR, build_pointer_type (type), addr, member);\n-      return build_indirect_ref (addr, 0);\n+      /* In Microsoft mode, treat a non-static member function as if\n+\t it were a pointer-to-member.  */\n+      if (flag_ms_extensions)\n+\treturn build_unary_op (ADDR_EXPR, exp, 0);\n+      error (\"invalid use of non-static member function `%D'\", member);\n+      return error_mark_node;\n     }\n-  else if (TYPE_PTRMEMFUNC_P (TREE_TYPE (member)))\n+  else if (TREE_CODE (member) == FIELD_DECL)\n     {\n-      return get_member_function_from_ptrfunc (&addr, member);\n+      error (\"invalid use of non-static data member `%D'\", member);\n+      return error_mark_node;\n     }\n-  abort ();\n-  /* NOTREACHED */\n-  return NULL_TREE;\n+\n+  return member;\n }\n \n /* If DECL is a `const' declaration, and its value is a known\n@@ -3300,9 +3224,6 @@ build_vec_delete (tree base, tree maxindex,\n   tree rval;\n   tree base_init = NULL_TREE;\n \n-  if (TREE_CODE (base) == OFFSET_REF)\n-    base = resolve_offset_ref (base);\n-\n   type = TREE_TYPE (base);\n \n   if (TREE_CODE (type) == POINTER_TYPE)"}, {"sha": "d19e40383e596206a6617a33f00c80e421750742", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 30, "deletions": 42, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -1667,6 +1667,8 @@ static bool cp_parser_check_declarator_template_parameters\n   (cp_parser *, tree);\n static bool cp_parser_check_template_parameters\n   (cp_parser *, unsigned);\n+static tree cp_parser_simple_cast_expression\n+  (cp_parser *);\n static tree cp_parser_binary_expression\n   (cp_parser *, const cp_parser_token_tree_map, cp_parser_expression_fn);\n static tree cp_parser_global_scope_opt\n@@ -3846,8 +3848,15 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t  BASELINK_ACCESS_BINFO (postfix_expression),\n \t\t  /*preserve_reference=*/false));\n \t  else if (done)\n-\t    return build_offset_ref (qualifying_class,\n-\t\t\t\t     postfix_expression);\n+\t    {\n+\t      /* The expression is a qualified name whose address is not\n+\t\t being taken.  */\n+\t      postfix_expression = build_offset_ref (qualifying_class,\n+\t\t\t\t\t\t     postfix_expression);\n+\t      if (TREE_CODE (postfix_expression) == OFFSET_REF)\n+\t\tpostfix_expression = resolve_offset_ref (postfix_expression);\n+\t      return postfix_expression;\n+\t    }\n \t}\n     }\n \n@@ -4379,7 +4388,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t    /* Save away the PEDANTIC flag.  */\n \t    cp_parser_extension_opt (parser, &saved_pedantic);\n \t    /* Parse the cast-expression.  */\n-\t    expr = cp_parser_cast_expression (parser, /*address_p=*/false);\n+\t    expr = cp_parser_simple_cast_expression (parser);\n \t    /* Restore the PEDANTIC flag.  */\n \t    pedantic = saved_pedantic;\n \n@@ -4394,8 +4403,7 @@ cp_parser_unary_expression (cp_parser *parser, bool address_p)\n \t    /* Consume the `__real__' or `__imag__' token.  */\n \t    cp_lexer_consume_token (parser->lexer);\n \t    /* Parse the cast-expression.  */\n-\t    expression = cp_parser_cast_expression (parser,\n-\t\t\t\t\t\t    /*address_p=*/false);\n+\t    expression = cp_parser_simple_cast_expression (parser);\n \t    /* Create the complete representation.  */\n \t    return build_x_unary_op ((keyword == RID_REALPART\n \t\t\t\t      ? REALPART_EXPR : IMAGPART_EXPR),\n@@ -4817,7 +4825,7 @@ cp_parser_delete_expression (cp_parser* parser)\n     array_p = false;\n \n   /* Parse the cast-expression.  */\n-  expression = cp_parser_cast_expression (parser, /*address_p=*/false);\n+  expression = cp_parser_simple_cast_expression (parser);\n \n   return delete_sanity (expression, NULL_TREE, array_p, global_scope_p);\n }\n@@ -4897,7 +4905,7 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n          ctor of T, but looks like a cast to function returning T\n          without a dependent expression.  */\n       if (!cp_parser_error_occurred (parser))\n-\texpr = cp_parser_cast_expression (parser, /*address_p=*/false);\n+\texpr = cp_parser_simple_cast_expression (parser);\n \n       if (cp_parser_parse_definitely (parser))\n \t{\n@@ -4943,42 +4951,14 @@ cp_parser_cast_expression (cp_parser *parser, bool address_p)\n static tree\n cp_parser_pm_expression (cp_parser* parser)\n {\n-  tree cast_expr;\n-  tree pm_expr;\n-\n-  /* Parse the cast-expresion.  */\n-  cast_expr = cp_parser_cast_expression (parser, /*address_p=*/false);\n-  pm_expr = cast_expr;\n-  /* Now look for pointer-to-member operators.  */\n-  while (true)\n-    {\n-      cp_token *token;\n-      enum cpp_ttype token_type;\n-\n-      /* Peek at the next token.  */\n-      token = cp_lexer_peek_token (parser->lexer);\n-      token_type = token->type;\n-      /* If it's not `.*' or `->*' there's no pointer-to-member\n-\t operation.  */\n-      if (token_type != CPP_DOT_STAR \n-\t  && token_type != CPP_DEREF_STAR)\n-\tbreak;\n-\n-      /* Consume the token.  */\n-      cp_lexer_consume_token (parser->lexer);\n-\n-      /* Parse another cast-expression.  */\n-      cast_expr = cp_parser_cast_expression (parser, /*address_p=*/false);\n-\n-      /* Build the representation of the pointer-to-member \n-\t operation.  */\n-      if (token_type == CPP_DEREF_STAR)\n-\tpm_expr = build_x_binary_op (MEMBER_REF, pm_expr, cast_expr);\n-      else\n-\tpm_expr = build_m_component_ref (pm_expr, cast_expr);\n-    }\n+  static const cp_parser_token_tree_map map = {\n+    { CPP_DEREF_STAR, MEMBER_REF },\n+    { CPP_DOT_STAR, DOTSTAR_EXPR },\n+    { CPP_EOF, ERROR_MARK }\n+  };\n \n-  return pm_expr;\n+  return cp_parser_binary_expression (parser, map, \n+\t\t\t\t      cp_parser_simple_cast_expression);\n }\n \n /* Parse a multiplicative-expression.\n@@ -14025,6 +14005,14 @@ cp_parser_single_declaration (cp_parser* parser,\n   return decl;\n }\n \n+/* Parse a cast-expression that is not the operand of a unary \"&\".  */\n+\n+static tree\n+cp_parser_simple_cast_expression (cp_parser *parser)\n+{\n+  return cp_parser_cast_expression (parser, /*address_p=*/false);\n+}\n+\n /* Parse a functional cast to TYPE.  Returns an expression\n    representing the cast.  */\n "}, {"sha": "af494e39848deb320e75503d2a1eb316438acaa0", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -473,12 +473,6 @@ build_dynamic_cast_1 (tree type, tree expr)\n       goto fail;\n     }\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    {\n-      expr = resolve_offset_ref (expr);\n-      exprtype = TREE_TYPE (expr);\n-    }\n-\n   if (tc == POINTER_TYPE)\n     expr = convert_from_reference (expr);\n   else if (TREE_CODE (exprtype) != REFERENCE_TYPE)"}, {"sha": "3664590319633c03ebcd410993f375d9a09a13ef", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -1476,13 +1476,6 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual)\n tree \n finish_increment_expr (tree expr, enum tree_code code)\n {\n-  /* If we get an OFFSET_REF, turn it into what it really means (e.g.,\n-     a COMPONENT_REF).  This way if we've got, say, a reference to a\n-     static member that's being operated on, we don't end up trying to\n-     find a member operator for the class it's in.  */\n-\n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n   return build_x_unary_op (code, expr);  \n }\n \n@@ -2083,9 +2076,6 @@ finish_typeof (tree expr)\n       return type;\n     }\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n-\n   type = TREE_TYPE (expr);\n \n   if (!type || type == unknown_type_node)"}, {"sha": "9f8a119a181c75afab8351deb8a51fcd06b29351", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -133,10 +133,6 @@ lvalue_p_1 (tree ref,\n       /* A currently unresolved scope ref.  */\n     case SCOPE_REF:\n       abort ();\n-    case OFFSET_REF:\n-      if (TREE_CODE (TREE_OPERAND (ref, 1)) == FUNCTION_DECL)\n-\treturn clk_ordinary;\n-      /* Fall through.  */\n     case MAX_EXPR:\n     case MIN_EXPR:\n       op1_lvalue_kind = lvalue_p_1 (TREE_OPERAND (ref, 0),"}, {"sha": "96b74fa43acd8c78d2fbbec26a53bfa1419b4349", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 65, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -105,17 +105,6 @@ require_complete_type (tree value)\n   if (COMPLETE_TYPE_P (type))\n     return value;\n \n-  /* If we see X::Y, we build an OFFSET_TYPE which has\n-     not been laid out.  Try to avoid an error by interpreting\n-     it as this->X::Y, if reasonable.  */\n-  if (TREE_CODE (value) == OFFSET_REF\n-      && current_class_ref != 0\n-      && TREE_OPERAND (value, 0) == current_class_ref)\n-    {\n-      value = resolve_offset_ref (value);\n-      return require_complete_type (value);\n-    }\n-\n   if (complete_type_or_else (type, value))\n     return value;\n   else\n@@ -1486,11 +1475,6 @@ expr_sizeof (tree e)\n       cxx_incomplete_type_error (e, TREE_TYPE (e));\n       return c_sizeof (char_type_node);\n     }\n-  /* It's invalid to say `sizeof (X::i)' for `i' a non-static data\n-     member unless you're in a non-static member of X.  So hand off to\n-     resolve_offset_ref.  [expr.prim]  */\n-  else if (TREE_CODE (e) == OFFSET_REF)\n-    e = resolve_offset_ref (e);\n \n   if (e == error_mark_node)\n     return e;\n@@ -1511,9 +1495,6 @@ decay_conversion (tree exp)\n   register tree type;\n   register enum tree_code code;\n \n-  if (TREE_CODE (exp) == OFFSET_REF)\n-    exp = resolve_offset_ref (exp);\n-\n   type = TREE_TYPE (exp);\n   code = TREE_CODE (type);\n \n@@ -1555,7 +1536,10 @@ decay_conversion (tree exp)\n       return error_mark_node;\n     }\n   if (code == METHOD_TYPE)\n-    abort ();\n+    {\n+      error (\"invalid use of non-static member function\");\n+      return error_mark_node;\n+    }\n   if (code == FUNCTION_TYPE || is_overloaded_fn (exp))\n     return build_unary_op (ADDR_EXPR, exp, 0);\n   if (code == ARRAY_TYPE)\n@@ -2047,9 +2031,6 @@ finish_class_member_access_expr (tree object, tree name)\n   if (processing_template_decl)\n     return build_min_nt (COMPONENT_REF, object, name);\n   \n-  if (TREE_CODE (object) == OFFSET_REF)\n-    object = resolve_offset_ref (object);\n-\n   object_type = TREE_TYPE (object);\n   if (TREE_CODE (object_type) == REFERENCE_TYPE)\n     {\n@@ -2749,9 +2730,6 @@ convert_arguments (typelist, values, fndecl, flags)\n \t  break;\n \t}\n \n-      if (TREE_CODE (val) == OFFSET_REF)\n-\tval = resolve_offset_ref (val);\n-\n       /* build_c_cast puts on a NOP_EXPR to make the result not an lvalue.\n \t Strip such NOP_EXPRs, since VAL is used in non-lvalue context.  */\n       if (TREE_CODE (val) == NOP_EXPR\n@@ -2865,6 +2843,9 @@ build_x_binary_op (code, arg1, arg2)\n   if (processing_template_decl)\n     return build_min_nt (code, arg1, arg2);\n \n+  if (code == DOTSTAR_EXPR)\n+    return build_m_component_ref (arg1, arg2);\n+\n   return build_new_op (code, LOOKUP_NORMAL, arg1, arg2, NULL_TREE);\n }\n \n@@ -3973,8 +3954,6 @@ condition_conversion (expr)\n   tree t;\n   if (processing_template_decl)\n     return expr;\n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n   t = perform_implicit_conversion (boolean_type_node, expr);\n   t = fold (build1 (CLEANUP_POINT_EXPR, boolean_type_node, t));\n   return t;\n@@ -4560,15 +4539,7 @@ unary_complex_lvalue (enum tree_code code, tree arg)\n \t      return error_mark_node;\n \t    }\n \t  if (!PTRMEM_OK_P (arg))\n-\t    {\n-\t      /* This cannot form a pointer to method, so we must\n-\t         resolve the offset ref, and take the address of the\n-\t\t result.  For instance,\n-\t\t \t&(C::m)\t      */\n-\t      arg = resolve_offset_ref (arg);\n-\n-\t      return build_unary_op (code, arg, 0);\n-\t    }\n+\t    return build_unary_op (code, arg, 0);\n \t  \n \t  if (TREE_CODE (TREE_TYPE (t)) == REFERENCE_TYPE)\n \t    {\n@@ -4792,9 +4763,6 @@ build_static_cast (tree type, tree expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n-\n   if (processing_template_decl)\n     {\n       tree t = build_min (STATIC_CAST_EXPR, type, expr); \n@@ -4965,9 +4933,6 @@ build_reinterpret_cast (tree type, tree expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n-\n   if (processing_template_decl)\n     {\n       tree t = build_min (REINTERPRET_CAST_EXPR, type, expr);\n@@ -5055,9 +5020,6 @@ build_const_cast (tree type, tree expr)\n   if (type == error_mark_node || expr == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (expr) == OFFSET_REF)\n-    expr = resolve_offset_ref (expr);\n-\n   if (processing_template_decl)\n     {\n       tree t = build_min (CONST_CAST_EXPR, type, expr);\n@@ -5139,9 +5101,6 @@ build_c_cast (tree type, tree expr)\n       && TREE_TYPE (value) == TREE_TYPE (TREE_OPERAND (value, 0)))\n     value = TREE_OPERAND (value, 0);\n \n-  if (TREE_CODE (value) == OFFSET_REF)\n-    value = resolve_offset_ref (value);\n-\n   if (TREE_CODE (type) == ARRAY_TYPE)\n     {\n       /* Allow casting from T1* to T2[] because Cfront allows it.\n@@ -5361,12 +5320,6 @@ build_modify_expr (tree lhs, enum tree_code modifycode, tree rhs)\n \treturn build (COMPOUND_EXPR, TREE_TYPE (lhs), preeval, cond);\n       }\n       \n-    case OFFSET_REF:\n-      lhs = resolve_offset_ref (lhs);\n-      if (lhs == error_mark_node)\n-\treturn error_mark_node;\n-      olhstype = lhstype = TREE_TYPE (lhs);\n-    \n     default:\n       break;\n     }\n@@ -6008,9 +5961,6 @@ convert_for_assignment (tree type, tree rhs,\n   if (codel == OFFSET_TYPE)\n     abort ();\n \n-  if (TREE_CODE (rhs) == OFFSET_REF)\n-    rhs = resolve_offset_ref (rhs);\n-\n   /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n   if (TREE_CODE (rhs) == NON_LVALUE_EXPR)\n     rhs = TREE_OPERAND (rhs, 0);\n@@ -6117,13 +6067,6 @@ convert_for_initialization (tree exp, tree type, tree rhs, int flags,\n       || (TREE_CODE (rhs) == TREE_LIST && TREE_VALUE (rhs) == error_mark_node))\n     return error_mark_node;\n \n-  if (TREE_CODE (rhs) == OFFSET_REF)\n-    {\n-      rhs = resolve_offset_ref (rhs);\n-      if (rhs == error_mark_node)\n-\treturn error_mark_node;\n-    }\n-\n   if (TREE_CODE (TREE_TYPE (rhs)) == REFERENCE_TYPE)\n     rhs = convert_from_reference (rhs);\n "}, {"sha": "9d9ade150451a933fb14eac76191dad7817ac514", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 30, "deletions": 62, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -993,12 +993,6 @@ build_x_arrow (tree datum)\n   if (processing_template_decl)\n     return build_min_nt (ARROW_EXPR, rval);\n \n-  if (TREE_CODE (rval) == OFFSET_REF)\n-    {\n-      rval = resolve_offset_ref (datum);\n-      type = TREE_TYPE (rval);\n-    }\n-\n   if (TREE_CODE (type) == REFERENCE_TYPE)\n     {\n       rval = convert_from_reference (rval);\n@@ -1048,94 +1042,68 @@ build_x_arrow (tree datum)\n   return error_mark_node;\n }\n \n-/* Make an expression to refer to the COMPONENT field of\n-   structure or union value DATUM.  COMPONENT is an arbitrary\n-   expression.  DATUM has not already been checked out to be of\n-   aggregate type.\n-\n-   For C++, COMPONENT may be a TREE_LIST.  This happens when we must\n-   return an object of member type to a method of the current class,\n-   but there is not yet enough typing information to know which one.\n-   As a special case, if there is only one method by that name,\n-   it is returned.  Otherwise we return an expression which other\n-   routines will have to know how to deal with later.  */\n+/* Return an expression for \"DATUM .* COMPONENT\".  DATUM has not\n+   already been checked out to be of aggregate type.  */\n \n tree\n build_m_component_ref (tree datum, tree component)\n {\n-  tree type;\n+  tree ptrmem_type;\n   tree objtype;\n-  tree field_type;\n-  int type_quals;\n+  tree type;\n   tree binfo;\n \n-  if (processing_template_decl)\n-    return build_min_nt (DOTSTAR_EXPR, datum, component);\n-\n   datum = decay_conversion (datum);\n \n   if (datum == error_mark_node || component == error_mark_node)\n     return error_mark_node;\n \n-  objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));  \n-\n-  if (TYPE_PTRMEMFUNC_P (TREE_TYPE (component)))\n-    {\n-      type = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (TREE_TYPE (component)));\n-      field_type = type;\n-    }\n-  else if (TYPE_PTRMEM_P (TREE_TYPE (component)))\n-    {\n-      type = TREE_TYPE (TREE_TYPE (component));\n-      field_type = TREE_TYPE (type);\n-      \n-      /* Compute the type of the field, as described in [expr.ref].  */\n-      type_quals = TYPE_UNQUALIFIED;\n-      if (TREE_CODE (field_type) == REFERENCE_TYPE)\n-\t/* The standard says that the type of the result should be the\n-       \t   type referred to by the reference.  But for now, at least,\n-       \t   we do the conversion from reference type later.  */\n-\t;\n-      else\n-\t{\n-\t  type_quals = (cp_type_quals (field_type)  \n-\t\t\t| cp_type_quals (TREE_TYPE (datum)));\n-\n-\t  /* There's no such thing as a mutable pointer-to-member, so\n-\t     things are not as complex as they are for references to\n-\t     non-static data members.  */\n-\t  field_type = cp_build_qualified_type (field_type, type_quals);\n-\t}\n-    }\n-  else\n+  ptrmem_type = TREE_TYPE (component);\n+  if (!TYPE_PTRMEM_P (ptrmem_type) \n+      && !TYPE_PTRMEMFUNC_P (ptrmem_type))\n     {\n       error (\"`%E' cannot be used as a member pointer, since it is of type `%T'\", \n-\t\tcomponent, TREE_TYPE (component));\n+\t     component, ptrmem_type);\n       return error_mark_node;\n     }\n-\n+    \n+  objtype = TYPE_MAIN_VARIANT (TREE_TYPE (datum));  \n   if (! IS_AGGR_TYPE (objtype))\n     {\n       error (\"cannot apply member pointer `%E' to `%E', which is of non-aggregate type `%T'\",\n \t\tcomponent, datum, objtype);\n       return error_mark_node;\n     }\n \n-  binfo = lookup_base (objtype, TYPE_METHOD_BASETYPE (type),\n+  type = TYPE_PTRMEM_POINTED_TO_TYPE (ptrmem_type);\n+  binfo = lookup_base (objtype, TYPE_PTRMEM_CLASS_TYPE (ptrmem_type),\n \t\t       ba_check, NULL);\n   if (!binfo)\n     {\n       error (\"member type `%T::' incompatible with object type `%T'\",\n-\t\tTYPE_METHOD_BASETYPE (type), objtype);\n+\t     type, objtype);\n       return error_mark_node;\n     }\n   else if (binfo == error_mark_node)\n     return error_mark_node;\n \n-  component = build (OFFSET_REF, field_type, datum, component);\n-  if (TREE_CODE (type) == OFFSET_TYPE)\n-    component = resolve_offset_ref (component);\n-  return component;\n+  if (TYPE_PTRMEM_P (ptrmem_type))\n+    {\n+      /* Compute the type of the field, as described in [expr.ref].\n+\t There's no such thing as a mutable pointer-to-member, so\n+\t things are not as complex as they are for references to\n+\t non-static data members.  */\n+      type = cp_build_qualified_type (type,\n+\t\t\t\t      (cp_type_quals (type)  \n+\t\t\t\t       | cp_type_quals (TREE_TYPE (datum))));\n+\n+      datum = build_base_path (PLUS_EXPR, build_address (datum), binfo, 1);\n+      component = cp_convert (ptrdiff_type_node, component);\n+      datum = build (PLUS_EXPR, build_pointer_type (type), datum, component);\n+      return build_indirect_ref (datum, 0);\n+    }\n+  else\n+    return build (OFFSET_REF, type, datum, component);\n }\n \n /* Return a tree node for the expression TYPENAME '(' PARMS ')'.  */"}, {"sha": "344cb3976e8eb0f5e7db08fd73b5cb02140f2d08", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -1,3 +1,8 @@\n+2003-07-03  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.old-deja/g++.jason/typeid1.C: Add dg-error marker.\n+\t* g++.old-deja/g++.mike/net36.C: Tweak error messages.\n+\n 2003-07-03  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.dg/builtins-25.c: New testcase."}, {"sha": "678ab5fcdd556f97274c1d0ac4f99a3078813c28", "filename": "gcc/testsuite/g++.old-deja/g++.jason/typeid1.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ftypeid1.C?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -8,5 +8,5 @@ int main() {\n   double f (int);\n   const std::type_info &r = typeid (f);\n   std::cout << typeid(f).name() << std::endl;\n-  std::cout << typeid(foo::f).name() << std::endl;\n+  std::cout << typeid(foo::f).name() << std::endl; /* { dg-error \"\" } */\n }"}, {"sha": "3ffa60e37a28dc3da61059678208399af8fa0779", "filename": "gcc/testsuite/g++.old-deja/g++.mike/net36.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet36.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d6b4ea8592e338addbd24be14708f66eaa4ac63e/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet36.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet36.C?ref=d6b4ea8592e338addbd24be14708f66eaa4ac63e", "patch": "@@ -11,7 +11,7 @@ typedef void (A::*handler) (X*);\n \n class B {\n public:\n-  void setHandler(handler); // { dg-error \"\" } candidate\n+  void setHandler(handler);\n };\n \n void f(B* b) {"}]}