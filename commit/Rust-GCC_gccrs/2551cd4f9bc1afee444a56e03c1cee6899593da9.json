{"sha": "2551cd4f9bc1afee444a56e03c1cee6899593da9", "node_id": "C_kwDOANBUbNoAKDI1NTFjZDRmOWJjMWFmZWU0NDRhNTZlMDNjMWNlZTY4OTk1OTNkYTk", "commit": {"author": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2021-11-15T10:07:36Z"}, "committer": {"name": "Prathamesh Kulkarni", "email": "prathamesh.kulkarni@linaro.org", "date": "2021-11-15T10:07:36Z"}, "message": "[tree-vectorizer.c] Merge pass_vectorize::execute with vectorize_loops and replace occurences of cfun with function param.\n\ngcc/ChangeLog:\n\t* tree-ssa-loop.c (pass_vectorize): Move to tree-vectorizer.c.\n\t(pass_data_vectorize): Likewise.\n\t(make_pass_vectorize): Likewise.\n\t* tree-vectorizer.c (vectorize_loops): Merge with\n\tpass_vectorize::execute and replace cfun occurences with fun param.\n\t(adjust_simduid_builtins): Add fun param, replace cfun occurences with\n\tfun, and adjust callers approrpiately.\n\t(note_simd_array_uses): Likewise.\n\t(vect_loop_dist_alias_call): Likewise.\n\t(set_uid_loop_bbs): Likewise.\n\t(vect_transform_loops): Likewise.\n\t(try_vectorize_loop_1): Likewise.\n\t(try_vectorize_loop): Likewise.", "tree": {"sha": "19d9192cc6660bf32a652d4d965899302c952f4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/19d9192cc6660bf32a652d4d965899302c952f4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2551cd4f9bc1afee444a56e03c1cee6899593da9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2551cd4f9bc1afee444a56e03c1cee6899593da9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2551cd4f9bc1afee444a56e03c1cee6899593da9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2551cd4f9bc1afee444a56e03c1cee6899593da9/comments", "author": null, "committer": null, "parents": [{"sha": "a91f844ef449d0dd1cf2e0e47b0ade0d8a6304e1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a91f844ef449d0dd1cf2e0e47b0ade0d8a6304e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a91f844ef449d0dd1cf2e0e47b0ade0d8a6304e1"}], "stats": {"total": 172, "additions": 83, "deletions": 89}, "files": [{"sha": "6b54e2bccfca0a6efc50caec993bda5a54cd09aa", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2551cd4f9bc1afee444a56e03c1cee6899593da9/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2551cd4f9bc1afee444a56e03c1cee6899593da9/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=2551cd4f9bc1afee444a56e03c1cee6899593da9", "patch": "@@ -370,57 +370,6 @@ make_pass_tree_loop_init (gcc::context *ctxt)\n   return new pass_tree_loop_init (ctxt);\n }\n \n-/* Loop autovectorization.  */\n-\n-namespace {\n-\n-const pass_data pass_data_vectorize =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"vect\", /* name */\n-  OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */\n-  TV_TREE_VECTORIZATION, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0, /* todo_flags_finish */\n-};\n-\n-class pass_vectorize : public gimple_opt_pass\n-{\n-public:\n-  pass_vectorize (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_vectorize, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  virtual bool gate (function *fun)\n-    {\n-      return flag_tree_loop_vectorize || fun->has_force_vectorize_loops;\n-    }\n-\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_vectorize\n-\n-unsigned int\n-pass_vectorize::execute (function *fun)\n-{\n-  if (number_of_loops (fun) <= 1)\n-    return 0;\n-\n-  return vectorize_loops ();\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_vectorize (gcc::context *ctxt)\n-{\n-  return new pass_vectorize (ctxt);\n-}\n-\n /* Propagation of constants using scev.  */\n \n namespace {"}, {"sha": "0e1cee99baede7c525faa9b13d9c55175e11d1c7", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 83, "deletions": 38, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2551cd4f9bc1afee444a56e03c1cee6899593da9/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2551cd4f9bc1afee444a56e03c1cee6899593da9/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=2551cd4f9bc1afee444a56e03c1cee6899593da9", "patch": "@@ -251,11 +251,11 @@ simd_array_to_simduid::equal (const simd_array_to_simduid *p1,\n    IFN_GOMP_SIMD_ORDERED_{START,END}.  */\n \n static void\n-adjust_simduid_builtins (hash_table<simduid_to_vf> *htab)\n+adjust_simduid_builtins (hash_table<simduid_to_vf> *htab, function *fun)\n {\n   basic_block bb;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator i;\n \n@@ -383,7 +383,7 @@ note_simd_array_uses_cb (tree *tp, int *walk_subtrees, void *data)\n    simduid.  */\n \n static void\n-note_simd_array_uses (hash_table<simd_array_to_simduid> **htab)\n+note_simd_array_uses (hash_table<simd_array_to_simduid> **htab, function *fun)\n {\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n@@ -394,7 +394,7 @@ note_simd_array_uses (hash_table<simd_array_to_simduid> **htab)\n   wi.info = &ns;\n   ns.htab = htab;\n \n-  FOR_EACH_BB_FN (bb, cfun)\n+  FOR_EACH_BB_FN (bb, fun)\n     for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n       {\n \tgimple *stmt = gsi_stmt (gsi);\n@@ -879,7 +879,7 @@ vect_loop_vectorized_call (class loop *loop, gcond **cond)\n    internal call.  */\n \n static gimple *\n-vect_loop_dist_alias_call (class loop *loop)\n+vect_loop_dist_alias_call (class loop *loop, function *fun)\n {\n   basic_block bb;\n   basic_block entry;\n@@ -890,7 +890,7 @@ vect_loop_dist_alias_call (class loop *loop)\n   if (loop->orig_loop_num == 0)\n     return NULL;\n \n-  orig = get_loop (cfun, loop->orig_loop_num);\n+  orig = get_loop (fun, loop->orig_loop_num);\n   if (orig == NULL)\n     {\n       /* The original loop is somehow destroyed.  Clear the information.  */\n@@ -904,7 +904,7 @@ vect_loop_dist_alias_call (class loop *loop)\n     bb = loop_preheader_edge (loop)->src;\n \n   outer = bb->loop_father;\n-  entry = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n+  entry = ENTRY_BLOCK_PTR_FOR_FN (fun);\n \n   /* Look upward in dominance tree.  */\n   for (; bb != entry && flow_bb_inside_loop_p (outer, bb);\n@@ -933,12 +933,13 @@ vect_loop_dist_alias_call (class loop *loop)\n    represented by LOOP_VINFO. LOOP_VECTORIZED_CALL is the internal\n    call guarding the loop which has been if converted.  */\n static void\n-set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n+set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call,\n+\t\t  function *fun)\n {\n   tree arg = gimple_call_arg (loop_vectorized_call, 1);\n   basic_block *bbs;\n   unsigned int i;\n-  class loop *scalar_loop = get_loop (cfun, tree_to_shwi (arg));\n+  class loop *scalar_loop = get_loop (fun, tree_to_shwi (arg));\n \n   LOOP_VINFO_SCALAR_LOOP (loop_vinfo) = scalar_loop;\n   gcc_checking_assert (vect_loop_vectorized_call (scalar_loop)\n@@ -953,7 +954,7 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n       if (g)\n \t{\n \t  arg = gimple_call_arg (g, 0);\n-\t  get_loop (cfun, tree_to_shwi (arg))->dont_vectorize = true;\n+\t  get_loop (fun, tree_to_shwi (arg))->dont_vectorize = true;\n \t  fold_loop_internal_call (g, boolean_false_node);\n \t}\n     }\n@@ -980,12 +981,13 @@ set_uid_loop_bbs (loop_vec_info loop_vinfo, gimple *loop_vectorized_call)\n \n static void\n vect_transform_loops (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n-\t\t      loop_p loop, gimple *loop_vectorized_call)\n+\t\t      loop_p loop, gimple *loop_vectorized_call,\n+\t\t      function *fun)\n {\n   loop_vec_info loop_vinfo = loop_vec_info_for_loop (loop);\n \n   if (loop_vectorized_call)\n-    set_uid_loop_bbs (loop_vinfo, loop_vectorized_call);\n+    set_uid_loop_bbs (loop_vinfo, loop_vectorized_call, fun);\n \n   unsigned HOST_WIDE_INT bytes;\n   if (dump_enabled_p ())\n@@ -1017,7 +1019,7 @@ vect_transform_loops (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \n   /* Epilogue of vectorized loop must be vectorized too.  */\n   if (new_loop)\n-    vect_transform_loops (simduid_to_vf_htab, new_loop, NULL);\n+    vect_transform_loops (simduid_to_vf_htab, new_loop, NULL, fun);\n }\n \n /* Try to vectorize LOOP.  */\n@@ -1026,7 +1028,8 @@ static unsigned\n try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \t\t      unsigned *num_vectorized_loops, loop_p loop,\n \t\t      gimple *loop_vectorized_call,\n-\t\t      gimple *loop_dist_alias_call)\n+\t\t      gimple *loop_dist_alias_call,\n+\t\t      function *fun)\n {\n   unsigned ret = 0;\n   vec_info_shared shared;\n@@ -1097,7 +1100,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \t  if (!require_loop_vectorize)\n \t    {\n \t      tree arg = gimple_call_arg (loop_vectorized_call, 1);\n-\t      class loop *scalar_loop = get_loop (cfun, tree_to_shwi (arg));\n+\t      class loop *scalar_loop = get_loop (fun, tree_to_shwi (arg));\n \t      if (vect_slp_if_converted_bb (bb, scalar_loop))\n \t\t{\n \t\t  fold_loop_internal_call (loop_vectorized_call,\n@@ -1127,7 +1130,7 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \n   (*num_vectorized_loops)++;\n   /* Transform LOOP and its epilogues.  */\n-  vect_transform_loops (simduid_to_vf_htab, loop, loop_vectorized_call);\n+  vect_transform_loops (simduid_to_vf_htab, loop, loop_vectorized_call, fun);\n \n   if (loop_vectorized_call)\n     {\n@@ -1148,7 +1151,8 @@ try_vectorize_loop_1 (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \n static unsigned\n try_vectorize_loop (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n-\t\t    unsigned *num_vectorized_loops, loop_p loop)\n+\t\t    unsigned *num_vectorized_loops, loop_p loop,\n+\t\t    function *fun)\n {\n   if (!((flag_tree_loop_vectorize\n \t && optimize_loop_nest_for_speed_p (loop))\n@@ -1157,16 +1161,50 @@ try_vectorize_loop (hash_table<simduid_to_vf> *&simduid_to_vf_htab,\n \n   return try_vectorize_loop_1 (simduid_to_vf_htab, num_vectorized_loops, loop,\n \t\t\t       vect_loop_vectorized_call (loop),\n-\t\t\t       vect_loop_dist_alias_call (loop));\n+\t\t\t       vect_loop_dist_alias_call (loop, fun), fun);\n }\n \n \n+/* Loop autovectorization.  */\n+\n+namespace {\n+\n+const pass_data pass_data_vectorize =\n+{\n+  GIMPLE_PASS, /* type */\n+  \"vect\", /* name */\n+  OPTGROUP_LOOP | OPTGROUP_VEC, /* optinfo_flags */\n+  TV_TREE_VECTORIZATION, /* tv_id */\n+  ( PROP_cfg | PROP_ssa ), /* properties_required */\n+  0, /* properties_provided */\n+  0, /* properties_destroyed */\n+  0, /* todo_flags_start */\n+  0, /* todo_flags_finish */\n+};\n+\n+class pass_vectorize : public gimple_opt_pass\n+{\n+public:\n+  pass_vectorize (gcc::context *ctxt)\n+    : gimple_opt_pass (pass_data_vectorize, ctxt)\n+  {}\n+\n+  /* opt_pass methods: */\n+  virtual bool gate (function *fun)\n+    {\n+      return flag_tree_loop_vectorize || fun->has_force_vectorize_loops;\n+    }\n+\n+  virtual unsigned int execute (function *);\n+\n+}; // class pass_vectorize\n+\n /* Function vectorize_loops.\n \n    Entry point to loop vectorization phase.  */\n \n unsigned\n-vectorize_loops (void)\n+pass_vectorize::execute (function *fun)\n {\n   unsigned int i;\n   unsigned int num_vectorized_loops = 0;\n@@ -1177,23 +1215,23 @@ vectorize_loops (void)\n   bool any_ifcvt_loops = false;\n   unsigned ret = 0;\n \n-  vect_loops_num = number_of_loops (cfun);\n+  vect_loops_num = number_of_loops (fun);\n \n   /* Bail out if there are no loops.  */\n   if (vect_loops_num <= 1)\n     return 0;\n \n   vect_slp_init ();\n \n-  if (cfun->has_simduid_loops)\n-    note_simd_array_uses (&simd_array_to_simduid_htab);\n+  if (fun->has_simduid_loops)\n+    note_simd_array_uses (&simd_array_to_simduid_htab, fun);\n \n   /*  ----------- Analyze loops. -----------  */\n \n   /* If some loop was duplicated, it gets bigger number\n      than all previously defined loops.  This fact allows us to run\n      only over initial loops skipping newly generated ones.  */\n-  for (auto loop : loops_list (cfun, 0))\n+  for (auto loop : loops_list (fun, 0))\n     if (loop->dont_vectorize)\n       {\n \tany_ifcvt_loops = true;\n@@ -1225,25 +1263,25 @@ vectorize_loops (void)\n \t      {\n \t\ttree arg = gimple_call_arg (loop_vectorized_call, 0);\n \t\tclass loop *vector_loop\n-\t\t  = get_loop (cfun, tree_to_shwi (arg));\n+\t\t  = get_loop (fun, tree_to_shwi (arg));\n \t\tif (vector_loop && vector_loop != loop)\n \t\t  {\n \t\t    /* Make sure we don't vectorize it twice.  */\n \t\t    vector_loop->dont_vectorize = true;\n \t\t    ret |= try_vectorize_loop (simduid_to_vf_htab,\n \t\t\t\t\t       &num_vectorized_loops,\n-\t\t\t\t\t       vector_loop);\n+\t\t\t\t\t       vector_loop, fun);\n \t\t  }\n \t      }\n \t  }\n       }\n     else\n       ret |= try_vectorize_loop (simduid_to_vf_htab, &num_vectorized_loops,\n-\t\t\t\t loop);\n+\t\t\t\t loop, fun);\n \n   vect_location = dump_user_location_t ();\n \n-  statistics_counter_event (cfun, \"Vectorized loops\", num_vectorized_loops);\n+  statistics_counter_event (fun, \"Vectorized loops\", num_vectorized_loops);\n   if (dump_enabled_p ()\n       || (num_vectorized_loops > 0 && dump_enabled_p ()))\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -1253,9 +1291,9 @@ vectorize_loops (void)\n   /*  ----------- Finalize. -----------  */\n \n   if (any_ifcvt_loops)\n-    for (i = 1; i < number_of_loops (cfun); i++)\n+    for (i = 1; i < number_of_loops (fun); i++)\n       {\n-\tloop = get_loop (cfun, i);\n+\tloop = get_loop (fun, i);\n \tif (loop && loop->dont_vectorize)\n \t  {\n \t    gimple *g = vect_loop_vectorized_call (loop);\n@@ -1266,7 +1304,7 @@ vectorize_loops (void)\n \t\tg = NULL;\n \t      }\n \t    else\n-\t      g = vect_loop_dist_alias_call (loop);\n+\t      g = vect_loop_dist_alias_call (loop, fun);\n \n \t    if (g)\n \t      {\n@@ -1277,9 +1315,9 @@ vectorize_loops (void)\n       }\n \n   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */\n-  if (cfun->has_simduid_loops)\n+  if (fun->has_simduid_loops)\n     {\n-      adjust_simduid_builtins (simduid_to_vf_htab);\n+      adjust_simduid_builtins (simduid_to_vf_htab, fun);\n       /* Avoid stale SCEV cache entries for the SIMD_LANE defs.  */\n       scev_reset ();\n     }\n@@ -1288,7 +1326,7 @@ vectorize_loops (void)\n   if (simd_array_to_simduid_htab)\n     shrink_simd_arrays (simd_array_to_simduid_htab, simduid_to_vf_htab);\n   delete simduid_to_vf_htab;\n-  cfun->has_simduid_loops = false;\n+  fun->has_simduid_loops = false;\n \n   if (num_vectorized_loops > 0)\n     {\n@@ -1299,12 +1337,12 @@ vectorize_loops (void)\n       ret |= TODO_cleanup_cfg;\n     }\n \n-  for (i = 1; i < number_of_loops (cfun); i++)\n+  for (i = 1; i < number_of_loops (fun); i++)\n     {\n       loop_vec_info loop_vinfo;\n       bool has_mask_store;\n \n-      loop = get_loop (cfun, i);\n+      loop = get_loop (fun, i);\n       if (!loop || !loop->aux)\n \tcontinue;\n       loop_vinfo = (loop_vec_info) loop->aux;\n@@ -1322,7 +1360,7 @@ vectorize_loops (void)\n       bitmap_set_bit (exit_bbs, single_exit (loop)->dest->index);\n \n       edge entry = EDGE_PRED (loop_preheader_edge (loop)->src, 0);\n-      do_rpo_vn (cfun, entry, exit_bbs);\n+      do_rpo_vn (fun, entry, exit_bbs);\n \n       loop->aux = NULL;\n     }\n@@ -1332,6 +1370,13 @@ vectorize_loops (void)\n   return ret;\n }\n \n+} // anon namespace\n+\n+gimple_opt_pass *\n+make_pass_vectorize (gcc::context *ctxt)\n+{\n+  return new pass_vectorize (ctxt);\n+}\n \n /* Entry point to the simduid cleanup pass.  */\n \n@@ -1369,10 +1414,10 @@ pass_simduid_cleanup::execute (function *fun)\n {\n   hash_table<simd_array_to_simduid> *simd_array_to_simduid_htab = NULL;\n \n-  note_simd_array_uses (&simd_array_to_simduid_htab);\n+  note_simd_array_uses (&simd_array_to_simduid_htab, fun);\n \n   /* Fold IFN_GOMP_SIMD_{VF,LANE,LAST_LANE,ORDERED_{START,END}} builtins.  */\n-  adjust_simduid_builtins (NULL);\n+  adjust_simduid_builtins (NULL, fun);\n \n   /* Shrink any \"omp array simd\" temporary arrays to the\n      actual vectorization factors.  */"}]}