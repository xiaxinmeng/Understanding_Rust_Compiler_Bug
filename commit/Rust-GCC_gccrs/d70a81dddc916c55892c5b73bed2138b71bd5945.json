{"sha": "d70a81dddc916c55892c5b73bed2138b71bd5945", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDcwYTgxZGRkYzkxNmM1NTg5MmM1YjczYmVkMjEzOGI3MWJkNTk0NQ==", "commit": {"author": {"name": "Shiva Chen", "email": "shiva0217@gmail.com", "date": "2013-04-23T17:38:59Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-04-23T17:38:59Z"}, "message": "lra-assigns.c (find_hard_regno_for): Use lra_reg_val_equal_p to check the register content is equal or not.\n\n2013-04-23  Shiva Chen  <shiva0217@gmail.com>\n\n        * lra-assigns.c (find_hard_regno_for): Use lra_reg_val_equal_p\n        to check the register content is equal or not.\n        * lra-constraints.c (match_reload): Use lra_assign_reg_val\n        to assign register content record.\n        * lra-eliminations.c (update_reg_eliminate): Use\n\tlra_update_reg_val_offset to update register content offset.\n        * lra-int.h (struct lra_reg): Add offset member.\n        (lra_reg_val_equal_p): New static inline function.\n        (lra_update_reg_val_offset): New static inline function.\n        (lra_assign_reg_val): New static inline function.\n        * lra.c (lra_create_new_reg): Use lra_assign_reg_val\n        to assign register content record.\n        (initialize_lra_reg_info_element): Initial offset to zero.\n\nFrom-SVN: r198204", "tree": {"sha": "17afa8226cdc7da00b678c19aa87047ca1ddfd18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17afa8226cdc7da00b678c19aa87047ca1ddfd18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d70a81dddc916c55892c5b73bed2138b71bd5945", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70a81dddc916c55892c5b73bed2138b71bd5945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d70a81dddc916c55892c5b73bed2138b71bd5945", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d70a81dddc916c55892c5b73bed2138b71bd5945/comments", "author": {"login": "ShivaChen", "id": 32083954, "node_id": "MDQ6VXNlcjMyMDgzOTU0", "avatar_url": "https://avatars.githubusercontent.com/u/32083954?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ShivaChen", "html_url": "https://github.com/ShivaChen", "followers_url": "https://api.github.com/users/ShivaChen/followers", "following_url": "https://api.github.com/users/ShivaChen/following{/other_user}", "gists_url": "https://api.github.com/users/ShivaChen/gists{/gist_id}", "starred_url": "https://api.github.com/users/ShivaChen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ShivaChen/subscriptions", "organizations_url": "https://api.github.com/users/ShivaChen/orgs", "repos_url": "https://api.github.com/users/ShivaChen/repos", "events_url": "https://api.github.com/users/ShivaChen/events{/privacy}", "received_events_url": "https://api.github.com/users/ShivaChen/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b894a1f3464f4f56ce2318c019ec3855794f7118", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b894a1f3464f4f56ce2318c019ec3855794f7118", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b894a1f3464f4f56ce2318c019ec3855794f7118"}], "stats": {"total": 80, "additions": 69, "deletions": 11}, "files": [{"sha": "f55df95ed8af844245635d218665eee7fdf033af", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -1,3 +1,19 @@\n+2013-04-23  Shiva Chen  <shiva0217@gmail.com>\n+\n+        * lra-assigns.c (find_hard_regno_for): Use lra_reg_val_equal_p\n+        to check the register content is equal or not.\n+        * lra-constraints.c (match_reload): Use lra_assign_reg_val\n+        to assign register content record.\n+        * lra-eliminations.c (update_reg_eliminate): Use\n+\tlra_update_reg_val_offset to update register content offset.\n+        * lra-int.h (struct lra_reg): Add offset member.\n+        (lra_reg_val_equal_p): New static inline function.\n+        (lra_update_reg_val_offset): New static inline function.\n+        (lra_assign_reg_val): New static inline function.\n+        * lra.c (lra_create_new_reg): Use lra_assign_reg_val\n+        to assign register content record.\n+        (initialize_lra_reg_info_element): Initial offset to zero.\n+\n 2013-04-23  Catherine Moore  <clm@codesourcery.com>\n \n \t* config/mips/mips.md (*movhi_internal, *movqi_internal): New"}, {"sha": "3f8a899c7fae8649f8e7a391fd2542b706f15204", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -448,7 +448,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n   int hr, conflict_hr, nregs;\n   enum machine_mode biggest_mode;\n   unsigned int k, conflict_regno;\n-  int val, biggest_nregs, nregs_diff;\n+  int offset, val, biggest_nregs, nregs_diff;\n   enum reg_class rclass;\n   bitmap_iterator bi;\n   bool *rclass_intersect_p;\n@@ -508,9 +508,10 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n #endif\n   sparseset_clear_bit (conflict_reload_and_inheritance_pseudos, regno);\n   val = lra_reg_info[regno].val;\n+  offset = lra_reg_info[regno].offset;\n   CLEAR_HARD_REG_SET (impossible_start_hard_regs);\n   EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)\n-    if (val == lra_reg_info[conflict_regno].val)\n+    if (lra_reg_val_equal_p (conflict_regno, val, offset))\n       {\n \tconflict_hr = live_pseudos_reg_renumber[conflict_regno];\n \tnregs = (hard_regno_nregs[conflict_hr]\n@@ -538,7 +539,7 @@ find_hard_regno_for (int regno, int *cost, int try_only_hard_regno)\n       }\n   EXECUTE_IF_SET_IN_SPARSESET (conflict_reload_and_inheritance_pseudos,\n \t\t\t       conflict_regno)\n-    if (val != lra_reg_info[conflict_regno].val)\n+    if (!lra_reg_val_equal_p (conflict_regno, val, offset))\n       {\n \tlra_assert (live_pseudos_reg_renumber[conflict_regno] < 0);\n \tif ((hard_regno\n@@ -1007,7 +1008,7 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n {\n   int p, i, j, n, regno, hard_regno;\n   unsigned int k, conflict_regno;\n-  int val;\n+  int val, offset;\n   HARD_REG_SET conflict_set;\n   enum machine_mode mode;\n   lra_live_range_t r;\n@@ -1050,8 +1051,9 @@ setup_live_pseudos_and_spill_after_risky_transforms (bitmap\n       COPY_HARD_REG_SET (conflict_set, lra_no_alloc_regs);\n       IOR_HARD_REG_SET (conflict_set, lra_reg_info[regno].conflict_hard_regs);\n       val = lra_reg_info[regno].val;\n+      offset = lra_reg_info[regno].offset;\n       EXECUTE_IF_SET_IN_SPARSESET (live_range_hard_reg_pseudos, conflict_regno)\n-\tif (val != lra_reg_info[conflict_regno].val\n+\tif (!lra_reg_val_equal_p (conflict_regno, val, offset)\n \t    /* If it is multi-register pseudos they should start on\n \t       the same hard register.\t*/\n \t    || hard_regno != reg_renumber[conflict_regno])"}, {"sha": "7cc7081f02e3f3092afa5a2a2fcbcc27f9f8c5a5", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -704,7 +704,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t     pseudos still live where reload pseudos dies.  */\n \t  if (REG_P (in_rtx) && (int) REGNO (in_rtx) < lra_new_regno_start\n \t      && find_regno_note (curr_insn, REG_DEAD, REGNO (in_rtx)))\n-\t    lra_reg_info[REGNO (reg)].val = lra_reg_info[REGNO (in_rtx)].val;\n+\t    lra_assign_reg_val (REGNO (in_rtx), REGNO (reg));\n \t}\n       else\n \t{\n@@ -733,8 +733,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t\t  && GET_MODE (subreg_reg) == outmode\n \t\t  && SUBREG_BYTE (in_rtx) == SUBREG_BYTE (new_in_reg)\n \t\t  && find_regno_note (curr_insn, REG_DEAD, REGNO (subreg_reg)))\n-\t\tlra_reg_info[REGNO (reg)].val\n-\t\t  = lra_reg_info[REGNO (subreg_reg)].val;\n+\t\tlra_assign_reg_val (REGNO (subreg_reg), REGNO (reg));\n \t    }\n \t}\n     }"}, {"sha": "5aa0cb82ba2109e303d5b1a8ea7e726deb2123df", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -1124,8 +1124,15 @@ update_reg_eliminate (bitmap insns_with_changed_offsets)\n   setup_elimination_map ();\n   for (ep = reg_eliminate; ep < &reg_eliminate[NUM_ELIMINABLE_REGS]; ep++)\n     if (elimination_map[ep->from] == ep && ep->previous_offset != ep->offset)\n-      bitmap_ior_into (insns_with_changed_offsets,\n-\t\t       &lra_reg_info[ep->from].insn_bitmap);\n+      {\n+\tbitmap_ior_into (insns_with_changed_offsets,\n+\t\t\t &lra_reg_info[ep->from].insn_bitmap);\n+\n+\t/* Update offset when the eliminate offset have been\n+\t   changed.  */\n+\tlra_update_reg_val_offset (lra_reg_info[ep->from].val,\n+\t\t\t\t   ep->offset - ep->previous_offset);\n+      }\n }\n \n /* Initialize the table of hard registers to eliminate."}, {"sha": "3d7ecb35e093908ad7731acffa76999ca687e3ea", "filename": "gcc/lra-int.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-int.h?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -118,6 +118,8 @@ struct lra_reg\n   /* Value holding by register.\t If the pseudos have the same value\n      they do not conflict.  */\n   int val;\n+  /* Offset from relative eliminate register to pesudo reg.  */\n+  int offset;\n   /* These members are set up in lra-lives.c and updated in\n      lra-coalesce.c.  */\n   /* The biggest size mode in which each pseudo reg is referred in\n@@ -443,6 +445,37 @@ lra_get_insn_recog_data (rtx insn)\n   return lra_set_insn_recog_data (insn);\n }\n \n+/* Update offset from pseudos with VAL by INCR.  */\n+static inline void\n+lra_update_reg_val_offset (int val, int incr)\n+{\n+  int i;\n+\n+  for (i = FIRST_PSEUDO_REGISTER; i < max_reg_num (); i++)\n+    {\n+      if (lra_reg_info[i].val == val)\n+        lra_reg_info[i].offset += incr;\n+    }\n+}\n+\n+/* Return true if register content is equal to VAL with OFFSET.  */\n+static inline bool\n+lra_reg_val_equal_p (int regno, int val, int offset)\n+{\n+  if (lra_reg_info[regno].val == val\n+      && lra_reg_info[regno].offset == offset)\n+    return true;\n+\n+  return false;\n+}\n+\n+/* Assign value of register FROM to TO.  */\n+static inline void\n+lra_assign_reg_val (int from, int to)\n+{\n+  lra_reg_info[to].val = lra_reg_info[from].val;\n+  lra_reg_info[to].offset = lra_reg_info[from].offset;\n+}\n \f\n \n struct target_lra_int"}, {"sha": "a4da0a05a7bb5b1c93f6c7897f00c5c397c2cd2c", "filename": "gcc/lra.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d70a81dddc916c55892c5b73bed2138b71bd5945/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=d70a81dddc916c55892c5b73bed2138b71bd5945", "patch": "@@ -194,7 +194,7 @@ lra_create_new_reg (enum machine_mode md_mode, rtx original,\n   new_reg\n     = lra_create_new_reg_with_unique_value (md_mode, original, rclass, title);\n   if (original != NULL_RTX && REG_P (original))\n-    lra_reg_info[REGNO (new_reg)].val = lra_reg_info[REGNO (original)].val;\n+    lra_assign_reg_val (REGNO (original), REGNO (new_reg));\n   return new_reg;\n }\n \n@@ -1392,6 +1392,7 @@ initialize_lra_reg_info_element (int i)\n   lra_reg_info[i].last_reload = 0;\n   lra_reg_info[i].restore_regno = -1;\n   lra_reg_info[i].val = get_new_reg_value ();\n+  lra_reg_info[i].offset = 0;\n   lra_reg_info[i].copies = NULL;\n }\n "}]}