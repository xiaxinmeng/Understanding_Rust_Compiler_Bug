{"sha": "d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDI3NjNhYjVmMTgwYTRlMjJjYzdkMDVjODRhMzcyOGU4OWNlZDJiMQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2005-05-27T15:01:45Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2005-05-27T15:01:45Z"}, "message": "re PR libstdc++/20534 (Erroneous #include of <cassert>)\n\n\n2005-05-27  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tPR libstdc++/20534\n\t* include/debug/debug.h: Forwarding header, that pulls in details\n\tonly if in debug mode.\n\t* include/debug/macros.h: ...transfer all the internal macros here.\n\t* include/debug/functions.h: ...transfer all the functions here.\n\t* include/debug/safe_iterator.h: Add functions.h, macros.h includes.\n\t* include/debug/safe_sequence.h: Same.\n\t* include/debug/vector: Tweak.\n\t* include/Makefile.am (debug_headers): Add new includes.\n\t* include/Makefile.in: Regenerate.\n\t* testsuite/17_intro/no_assert_neg.cc: Add.\n\n\t* include/ext/hash_set: Add debug mode include.\n\t* include/ext/hash_map: Same.\n\t* include/debug/hash_map: Fix included files to match actual files.\n\t* include/debug/hash_set: Same.\n\nFrom-SVN: r100255", "tree": {"sha": "f104b42ef68aa4e8b7f0571c3575ad5042722b26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f104b42ef68aa4e8b7f0571c3575ad5042722b26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/comments", "author": null, "committer": null, "parents": [{"sha": "2d63754709c889b1087e692b6124e0ed9fc00a8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d63754709c889b1087e692b6124e0ed9fc00a8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d63754709c889b1087e692b6124e0ed9fc00a8b"}], "stats": {"total": 1116, "additions": 657, "deletions": 459}, "files": [{"sha": "826030217342de1090323c6a5f57ace4c2c781d9", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,3 +1,22 @@\n+2005-05-27  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tPR libstdc++/20534 \n+\t* include/debug/debug.h: Forwarding header, that pulls in details\n+\tonly if in debug mode.\n+\t* include/debug/macros.h: ...transfer all the internal macros here.\n+\t* include/debug/functions.h: ...transfer all the functions here.\n+\t* include/debug/safe_iterator.h: Add functions.h, macros.h includes.\n+\t* include/debug/safe_sequence.h: Same.\n+\t* include/debug/vector: Tweak.\n+\t* include/Makefile.am (debug_headers): Add new includes.\n+\t* include/Makefile.in: Regenerate.\n+\t* testsuite/17_intro/no_assert_neg.cc: Add.\n+\n+\t* include/ext/hash_set: Add debug mode include.\n+\t* include/ext/hash_map: Same.\n+\t* include/debug/hash_map: Fix included files to match actual files.\n+\t* include/debug/hash_set: Same.\n+\t\t\n 2005-05-26  Paolo Carlini  <pcarlini@suse.de>\n \n \tPR libstdc++/13943"}, {"sha": "797afb619c8282c62c34cfed586048c3377785f2", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -321,6 +321,7 @@ debug_headers = \\\n \t${debug_srcdir}/debug.h \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/functions.h \\\n \t${debug_srcdir}/hash_map \\\n \t${debug_srcdir}/hash_map.h \\\n \t${debug_srcdir}/hash_multimap.h \\\n@@ -329,6 +330,7 @@ debug_headers = \\\n \t${debug_srcdir}/hash_set.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\\n+\t${debug_srcdir}/macros.h \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\"}, {"sha": "253c898a1919145de3a181e3ce35a5e233ec6a2a", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -538,6 +538,7 @@ debug_headers = \\\n \t${debug_srcdir}/debug.h \\\n \t${debug_srcdir}/deque \\\n \t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/functions.h \\\n \t${debug_srcdir}/hash_map \\\n \t${debug_srcdir}/hash_map.h \\\n \t${debug_srcdir}/hash_multimap.h \\\n@@ -546,6 +547,7 @@ debug_headers = \\\n \t${debug_srcdir}/hash_set.h \\\n \t${debug_srcdir}/list \\\n \t${debug_srcdir}/map \\\n+\t${debug_srcdir}/macros.h \\\n \t${debug_srcdir}/map.h \\\n \t${debug_srcdir}/multimap.h \\\n \t${debug_srcdir}/multiset.h \\"}, {"sha": "b4ffb6f62a84cd97e24f9d346a73a0026893cc2a", "filename": "libstdc++-v3/include/debug/debug.h", "status": "modified", "additions": 10, "deletions": 444, "changes": 454, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -31,199 +31,21 @@\n #ifndef _GLIBCXX_DEBUG_DEBUG_H\n #define _GLIBCXX_DEBUG_DEBUG_H 1\n \n-/**\n- * Macros used by the implementation to verify certain\n- * properties. These macros may only be used directly by the debug\n- * wrappers. Note that these are macros (instead of the more obviously\n- * \"correct\" choice of making them functions) because we need line and\n- * file information at the call site, to minimize the distance between\n- * the user error and where the error is reported.\n- *\n- */\n-#define _GLIBCXX_DEBUG_VERIFY(_Condition,_ErrorMessage)\t\t\\\n-  do {\t\t\t\t\t\t\t\t\t\\\n-    if (! (_Condition))\t\t\t\t\t\t\t\\\n-      ::__gnu_debug::_Error_formatter::_M_at(__FILE__, __LINE__)\t\\\n-\t  ._ErrorMessage._M_error();\t\t\t\t\t\\\n-  } while (false)\n-\n-// Verify that [_First, _Last) forms a valid iterator range.\n-#define __glibcxx_check_valid_range(_First,_Last)\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__valid_range(_First, _Last),\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_valid_range)\t\\\n-\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last))\n-\n-/** Verify that we can insert into *this with the iterator _Position.\n- *  Insertion into a container at a specific position requires that\n- *  the iterator be nonsingular (i.e., either dereferenceable or\n- *  past-the-end) and that it reference the sequence we are inserting\n- *  into. Note that this macro is only valid when the container is a\n- *  _Safe_sequence and the iterator is a _Safe_iterator.\n-*/\n-#define __glibcxx_check_insert(_Position)\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n-\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n-\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position))\n-\n-/** Verify that we can insert the values in the iterator range\n- *  [_First, _Last) into *this with the iterator _Position.  Insertion\n- *  into a container at a specific position requires that the iterator\n- *  be nonsingular (i.e., either dereferenceable or past-the-end),\n- *  that it reference the sequence we are inserting into, and that the\n- *  iterator range [_First, Last) is a valid (possibly empty)\n- *  range. Note that this macro is only valid when the container is a\n- *  _Safe_sequence and the iterator is a _Safe_iterator.\n- *\n- *  @tbd We would like to be able to check for noninterference of\n- *  _Position and the range [_First, _Last), but that can't (in\n- *  general) be done.\n-*/\n-#define __glibcxx_check_insert_range(_Position,_First,_Last)\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n-                      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n-\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position))\n-\n-/** Verify that we can erase the element referenced by the iterator\n- * _Position. We can erase the element if the _Position iterator is\n- * dereferenceable and references this sequence.\n-*/\n-#define __glibcxx_check_erase(_Position)\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_Position._M_dereferenceable(),\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_erase_bad)\t\\\n-                      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n-\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_Position, #_Position))\n-\n-/** Verify that we can erase the elements in the iterator range\n- *  [_First, _Last). We can erase the elements if [_First, _Last) is a\n- *  valid iterator range within this sequence.\n-*/\n-#define __glibcxx_check_erase_range(_First,_Last)\t\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n-                      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last))\n-\n-// Verify that the subscript _N is less than the container's size.\n-#define __glibcxx_check_subscript(_N)\t\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(_N < this->size(),\t\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_subscript_oob) \\\n-                      ._M_sequence(*this, \"this\")\t\t\t\\\n-\t\t      ._M_integer(_N, #_N)\t\t\t\t\\\n-\t\t      ._M_integer(this->size(), \"size\"))\n-\n-// Verify that the container is nonempty\n-#define __glibcxx_check_nonempty()\t\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(! this->empty(),\t\t\t\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_empty)\t\\\n-                      ._M_sequence(*this, \"this\"))\n-\n-// Verify that the < operator for elements in the sequence is a\n-// StrictWeakOrdering by checking that it is irreflexive.\n-#define __glibcxx_check_strict_weak_ordering(_First,_Last)\t\\\n-_GLIBCXX_DEBUG_ASSERT(_First == _Last || !(*_First < *_First))\n-\n-// Verify that the predicate is StrictWeakOrdering by checking that it\n-// is irreflexive.\n-#define __glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred)\t\\\n-_GLIBCXX_DEBUG_ASSERT(_First == _Last || !_Pred(*_First, *_First))\n-\n-\n-// Verify that the iterator range [_First, _Last) is sorted\n-#define __glibcxx_check_sorted(_First,_Last)\t\t\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-__glibcxx_check_strict_weak_ordering(_First,_Last);\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last),\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_unsorted)\t\\\n-                      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last))\n-\n-/** Verify that the iterator range [_First, _Last) is sorted by the\n-    predicate _Pred. */\n-#define __glibcxx_check_sorted_pred(_First,_Last,_Pred)\t\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-__glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred);\t        \\\n-_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last, _Pred), \\\n-\t\t      _M_message(::__gnu_debug::__msg_unsorted_pred) \\\n-                      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n-\t\t      ._M_string(#_Pred))\n-\n-/** Verify that the iterator range [_First, _Last) is partitioned\n-    w.r.t. the value _Value. */\n-#define __glibcxx_check_partitioned(_First,_Last,_Value)\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n-\t\t\t\t\t\t\t _Value),\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_unpartitioned) \\\n-\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n-\t\t      ._M_string(#_Value))\n-\n-/** Verify that the iterator range [_First, _Last) is partitioned\n-    w.r.t. the value _Value and predicate _Pred. */\n-#define __glibcxx_check_partitioned_pred(_First,_Last,_Value,_Pred)\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n-\t\t\t\t\t\t\t _Value, _Pred), \\\n-\t\t      _M_message(::__gnu_debug::__msg_unpartitioned_pred) \\\n-\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n-\t\t      ._M_string(#_Pred)\t\t\t\t\\\n-                      ._M_string(#_Value))\n-\n-// Verify that the iterator range [_First, _Last) is a heap\n-#define __glibcxx_check_heap(_First,_Last)\t\t\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last),\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_not_heap)\t\\\n-\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last))\n-\n-/** Verify that the iterator range [_First, _Last) is a heap\n-    w.r.t. the predicate _Pred. */\n-#define __glibcxx_check_heap_pred(_First,_Last,_Pred)\t\t\t\\\n-__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n-_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last, _Pred),\t\t\\\n-\t\t      _M_message(::__gnu_debug::__msg_not_heap_pred) \\\n-                      ._M_iterator(_First, #_First)\t\t\t\\\n-\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n-\t\t      ._M_string(#_Pred))\n-\n-#ifdef _GLIBCXX_DEBUG_PEDANTIC\n-#  define __glibcxx_check_string(_String) _GLIBCXX_DEBUG_ASSERT(_String != 0)\n-#  define __glibcxx_check_string_len(_String,_Len) \\\n-       _GLIBCXX_DEBUG_ASSERT(_String != 0 || _Len == 0)\n-#else\n-#  define __glibcxx_check_string(_String)\n-#  define __glibcxx_check_string_len(_String,_Len)\n-#endif\n-\n /** Macros used by the implementation outside of debug wrappers to\n  *  verify certain properties. The __glibcxx_requires_xxx macros are\n  *  merely wrappers around the __glibcxx_check_xxx wrappers when we\n  *  are compiling with debug mode, but disappear when we are in\n  *  release mode so that there is no checking performed in, e.g., the\n  *  standard library algorithms.\n */\n+\n #ifdef _GLIBCXX_DEBUG\n+#  include <debug/macros.h>\n+\n+// The debug mode requires assert functionality, but keep this include\n+// conditionalized, so that non-debug use doesn't mandate exposure to the\n+// assert macro.\n+#  include <cassert> \n #  define _GLIBCXX_DEBUG_ASSERT(_Condition) assert(_Condition)\n \n #  ifdef _GLIBCXX_DEBUG_PEDANTIC\n@@ -252,6 +74,9 @@ _GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last, _Pred),\t\t\\\n #  define __glibcxx_requires_string_len(_String,_Len)\t\\\n      __glibcxx_check_string_len(_String,_Len)\n #  define __glibcxx_requires_subscript(_N) __glibcxx_check_subscript(_N)\n+\n+#  include <debug/functions.h>\n+#  include <debug/formatter.h>\n #else\n #  define _GLIBCXX_DEBUG_ASSERT(_Condition)\n #  define _GLIBCXX_DEBUG_PEDASSERT(_Condition)\n@@ -269,263 +94,4 @@ _GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last, _Pred),\t\t\\\n #  define __glibcxx_requires_subscript(_N)\n #endif\n \n-#include <cassert> // TBD: temporary\n-\n-#include <stddef.h>                       // for ptrdiff_t\n-#include <bits/stl_iterator_base_types.h> // for iterator_traits, categories\n-#include <bits/cpp_type_traits.h>         // for __is_integer\n-\n-namespace __gnu_debug\n-{\n-  template<typename _Iterator, typename _Sequence>\n-    class _Safe_iterator;\n-\n-  // An arbitrary iterator pointer is not singular.\n-  inline bool\n-  __check_singular_aux(const void*) { return false; }\n-\n-  // We may have an iterator that derives from _Safe_iterator_base but isn't\n-  // a _Safe_iterator.\n-  template<typename _Iterator>\n-    inline bool\n-    __check_singular(_Iterator& __x)\n-    { return __gnu_debug::__check_singular_aux(&__x); }\n-\n-  /** Non-NULL pointers are nonsingular. */\n-  template<typename _Tp>\n-    inline bool\n-    __check_singular(const _Tp* __ptr)\n-    { return __ptr == 0; }\n-\n-  /** Safe iterators know if they are singular. */\n-  template<typename _Iterator, typename _Sequence>\n-    inline bool\n-    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)\n-    { return __x._M_singular(); }\n-\n-  /** Assume that some arbitrary iterator is dereferenceable, because we\n-      can't prove that it isn't. */\n-  template<typename _Iterator>\n-    inline bool\n-    __check_dereferenceable(_Iterator&)\n-    { return true; }\n-\n-  /** Non-NULL pointers are dereferenceable. */\n-  template<typename _Tp>\n-    inline bool\n-    __check_dereferenceable(const _Tp* __ptr)\n-    { return __ptr; }\n-\n-  /** Safe iterators know if they are singular. */\n-  template<typename _Iterator, typename _Sequence>\n-    inline bool\n-    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)\n-    { return __x._M_dereferenceable(); }\n-\n-  /** If the distance between two random access iterators is\n-   *  nonnegative, assume the range is valid.\n-  */\n-  template<typename _RandomAccessIterator>\n-    inline bool\n-    __valid_range_aux2(const _RandomAccessIterator& __first,\n-\t\t       const _RandomAccessIterator& __last,\n-\t\t       std::random_access_iterator_tag)\n-    { return __last - __first >= 0; }\n-\n-  /** Can't test for a valid range with input iterators, because\n-   *  iteration may be destructive. So we just assume that the range\n-   *  is valid.\n-  */\n-  template<typename _InputIterator>\n-    inline bool\n-    __valid_range_aux2(const _InputIterator&, const _InputIterator&,\n-\t\t       std::input_iterator_tag)\n-    { return true; }\n-\n-  /** We say that integral types for a valid range, and defer to other\n-   *  routines to realize what to do with integral types instead of\n-   *  iterators.\n-  */\n-  template<typename _Integral>\n-    inline bool\n-    __valid_range_aux(const _Integral&, const _Integral&, __true_type)\n-    { return true; }\n-\n-  /** We have iterators, so figure out what kind of iterators that are\n-   *  to see if we can check the range ahead of time.\n-  */\n-  template<typename _InputIterator>\n-    inline bool\n-    __valid_range_aux(const _InputIterator& __first,\n-\t\t      const _InputIterator& __last, __false_type)\n-  {\n-    typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-      _Category;\n-    return __gnu_debug::__valid_range_aux2(__first, __last, _Category());\n-  }\n-\n-  /** Don't know what these iterators are, or if they are even\n-   *  iterators (we may get an integral type for InputIterator), so\n-   *  see if they are integral and pass them on to the next phase\n-   *  otherwise.\n-  */\n-  template<typename _InputIterator>\n-    inline bool\n-    __valid_range(const _InputIterator& __first, const _InputIterator& __last)\n-    {\n-      typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n-      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());\n-    }\n-\n-  /** Safe iterators know how to check if they form a valid range. */\n-  template<typename _Iterator, typename _Sequence>\n-    inline bool\n-    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,\n-\t\t  const _Safe_iterator<_Iterator, _Sequence>& __last)\n-    { return __first._M_valid_range(__last); }\n-\n-  /* Checks that [first, last) is a valid range, and then returns\n-   * __first. This routine is useful when we can't use a separate\n-   * assertion statement because, e.g., we are in a constructor.\n-  */\n-  template<typename _InputIterator>\n-    inline _InputIterator\n-    __check_valid_range(const _InputIterator& __first,\n-\t\t\tconst _InputIterator& __last)\n-    {\n-      _GLIBCXX_DEBUG_ASSERT(__gnu_debug::__valid_range(__first, __last));\n-      return __first;\n-    }\n-\n-  /** Checks that __s is non-NULL or __n == 0, and then returns __s. */\n-  template<typename _CharT, typename _Integer>\n-    inline const _CharT*\n-    __check_string(const _CharT* __s, const _Integer& __n)\n-    {\n-#ifdef _GLIBCXX_DEBUG_PEDANTIC\n-      _GLIBCXX_DEBUG_ASSERT(__s != 0 || __n == 0);\n-#endif\n-      return __s;\n-    }\n-\n-  /** Checks that __s is non-NULL and then returns __s. */\n-  template<typename _CharT>\n-    inline const _CharT*\n-    __check_string(const _CharT* __s)\n-    {\n-#ifdef _GLIBCXX_DEBUG_PEDANTIC\n-      _GLIBCXX_DEBUG_ASSERT(__s != 0);\n-#endif\n-      return __s;\n-    }\n-\n-  // Can't check if an input iterator sequence is sorted, because we\n-  // can't step through the sequence.\n-  template<typename _InputIterator>\n-    inline bool\n-    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n-                       std::input_iterator_tag)\n-    { return true; }\n-\n-  // Can verify if a forward iterator sequence is in fact sorted using\n-  // std::__is_sorted\n-  template<typename _ForwardIterator>\n-    inline bool\n-    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                       std::forward_iterator_tag)\n-    {\n-      if (__first == __last)\n-        return true;\n-\n-      _ForwardIterator __next = __first;\n-      for (++__next; __next != __last; __first = __next, ++__next) {\n-        if (*__next < *__first)\n-          return false;\n-      }\n-\n-      return true;\n-    }\n-\n-  // Can't check if an input iterator sequence is sorted, because we can't step\n-  // through the sequence.\n-  template<typename _InputIterator, typename _Predicate>\n-    inline bool\n-    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n-                       _Predicate, std::input_iterator_tag)\n-    { return true; }\n-\n-  // Can verify if a forward iterator sequence is in fact sorted using\n-  // std::__is_sorted\n-  template<typename _ForwardIterator, typename _Predicate>\n-    inline bool\n-    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,\n-                       _Predicate __pred, std::forward_iterator_tag)\n-    {\n-      if (__first == __last)\n-        return true;\n-\n-      _ForwardIterator __next = __first;\n-      for (++__next; __next != __last; __first = __next, ++__next) {\n-        if (__pred(*__next, *__first))\n-          return false;\n-      }\n-\n-      return true;\n-    }\n-\n-  // Determine if a sequence is sorted.\n-  template<typename _InputIterator>\n-    inline bool\n-    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)\n-    {\n-      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-        _Category;\n-      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());\n-    }\n-\n-  template<typename _InputIterator, typename _Predicate>\n-    inline bool\n-    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,\n-                   _Predicate __pred)\n-    {\n-      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n-        _Category;\n-      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,\n-\t\t\t\t\t     _Category());\n-    }\n-\n-  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n-  // 270. Binary search requirements overly strict\n-  // Determine if a sequence is partitioned w.r.t. this element.\n-  template<typename _ForwardIterator, typename _Tp>\n-    inline bool\n-    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t\tconst _Tp& __value)\n-    {\n-      while (__first != __last && *__first < __value)\n-\t++__first;\n-      while (__first != __last && !(*__first < __value))\n-\t++__first;\n-      return __first == __last;\n-    }\n-\n-  // Determine if a sequence is partitioned w.r.t. this element.\n-  template<typename _ForwardIterator, typename _Tp, typename _Pred>\n-    inline bool\n-    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n-\t\t\tconst _Tp& __value, _Pred __pred)\n-    {\n-      while (__first != __last && __pred(*__first, __value))\n-\t++__first;\n-      while (__first != __last && !__pred(*__first, __value))\n-\t++__first;\n-      return __first == __last;\n-    }\n-} // namespace __gnu_debug\n-\n-#ifdef _GLIBCXX_DEBUG\n-// We need the error formatter\n-#  include <debug/formatter.h>\n-#endif\n-\n #endif"}, {"sha": "28834d4786ef0182ff3fc98503bdc724cb2927e1", "filename": "libstdc++-v3/include/debug/functions.h", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Ffunctions.h?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -0,0 +1,286 @@\n+// Debugging support implementation -*- C++ -*-\n+\n+// Copyright (C) 2003, 2005\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_FUNCTIONS_H\n+#define _GLIBCXX_DEBUG_FUNCTIONS_H 1\n+\n+#include <stddef.h>                       // for ptrdiff_t\n+#include <bits/stl_iterator_base_types.h> // for iterator_traits, categories\n+#include <bits/cpp_type_traits.h>         // for __is_integer\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Iterator, typename _Sequence>\n+    class _Safe_iterator;\n+\n+  // An arbitrary iterator pointer is not singular.\n+  inline bool\n+  __check_singular_aux(const void*) { return false; }\n+\n+  // We may have an iterator that derives from _Safe_iterator_base but isn't\n+  // a _Safe_iterator.\n+  template<typename _Iterator>\n+    inline bool\n+    __check_singular(_Iterator& __x)\n+    { return __gnu_debug::__check_singular_aux(&__x); }\n+\n+  /** Non-NULL pointers are nonsingular. */\n+  template<typename _Tp>\n+    inline bool\n+    __check_singular(const _Tp* __ptr)\n+    { return __ptr == 0; }\n+\n+  /** Safe iterators know if they are singular. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)\n+    { return __x._M_singular(); }\n+\n+  /** Assume that some arbitrary iterator is dereferenceable, because we\n+      can't prove that it isn't. */\n+  template<typename _Iterator>\n+    inline bool\n+    __check_dereferenceable(_Iterator&)\n+    { return true; }\n+\n+  /** Non-NULL pointers are dereferenceable. */\n+  template<typename _Tp>\n+    inline bool\n+    __check_dereferenceable(const _Tp* __ptr)\n+    { return __ptr; }\n+\n+  /** Safe iterators know if they are singular. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)\n+    { return __x._M_dereferenceable(); }\n+\n+  /** If the distance between two random access iterators is\n+   *  nonnegative, assume the range is valid.\n+  */\n+  template<typename _RandomAccessIterator>\n+    inline bool\n+    __valid_range_aux2(const _RandomAccessIterator& __first,\n+\t\t       const _RandomAccessIterator& __last,\n+\t\t       std::random_access_iterator_tag)\n+    { return __last - __first >= 0; }\n+\n+  /** Can't test for a valid range with input iterators, because\n+   *  iteration may be destructive. So we just assume that the range\n+   *  is valid.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range_aux2(const _InputIterator&, const _InputIterator&,\n+\t\t       std::input_iterator_tag)\n+    { return true; }\n+\n+  /** We say that integral types for a valid range, and defer to other\n+   *  routines to realize what to do with integral types instead of\n+   *  iterators.\n+  */\n+  template<typename _Integral>\n+    inline bool\n+    __valid_range_aux(const _Integral&, const _Integral&, __true_type)\n+    { return true; }\n+\n+  /** We have iterators, so figure out what kind of iterators that are\n+   *  to see if we can check the range ahead of time.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range_aux(const _InputIterator& __first,\n+\t\t      const _InputIterator& __last, __false_type)\n+  {\n+    typedef typename std::iterator_traits<_InputIterator>::iterator_category\n+      _Category;\n+    return __gnu_debug::__valid_range_aux2(__first, __last, _Category());\n+  }\n+\n+  /** Don't know what these iterators are, or if they are even\n+   *  iterators (we may get an integral type for InputIterator), so\n+   *  see if they are integral and pass them on to the next phase\n+   *  otherwise.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range(const _InputIterator& __first, const _InputIterator& __last)\n+    {\n+      typedef typename std::__is_integer<_InputIterator>::__type _Integral;\n+      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());\n+    }\n+\n+  /** Safe iterators know how to check if they form a valid range. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t  const _Safe_iterator<_Iterator, _Sequence>& __last)\n+    { return __first._M_valid_range(__last); }\n+\n+  /* Checks that [first, last) is a valid range, and then returns\n+   * __first. This routine is useful when we can't use a separate\n+   * assertion statement because, e.g., we are in a constructor.\n+  */\n+  template<typename _InputIterator>\n+    inline _InputIterator\n+    __check_valid_range(const _InputIterator& __first,\n+\t\t\tconst _InputIterator& __last)\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(__gnu_debug::__valid_range(__first, __last));\n+      return __first;\n+    }\n+\n+  /** Checks that __s is non-NULL or __n == 0, and then returns __s. */\n+  template<typename _CharT, typename _Integer>\n+    inline const _CharT*\n+    __check_string(const _CharT* __s, const _Integer& __n)\n+    {\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+      _GLIBCXX_DEBUG_ASSERT(__s != 0 || __n == 0);\n+#endif\n+      return __s;\n+    }\n+\n+  /** Checks that __s is non-NULL and then returns __s. */\n+  template<typename _CharT>\n+    inline const _CharT*\n+    __check_string(const _CharT* __s)\n+    {\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+      _GLIBCXX_DEBUG_ASSERT(__s != 0);\n+#endif\n+      return __s;\n+    }\n+\n+  // Can't check if an input iterator sequence is sorted, because we\n+  // can't step through the sequence.\n+  template<typename _InputIterator>\n+    inline bool\n+    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n+                       std::input_iterator_tag)\n+    { return true; }\n+\n+  // Can verify if a forward iterator sequence is in fact sorted using\n+  // std::__is_sorted\n+  template<typename _ForwardIterator>\n+    inline bool\n+    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                       std::forward_iterator_tag)\n+    {\n+      if (__first == __last)\n+        return true;\n+\n+      _ForwardIterator __next = __first;\n+      for (++__next; __next != __last; __first = __next, ++__next) {\n+        if (*__next < *__first)\n+          return false;\n+      }\n+\n+      return true;\n+    }\n+\n+  // Can't check if an input iterator sequence is sorted, because we can't step\n+  // through the sequence.\n+  template<typename _InputIterator, typename _Predicate>\n+    inline bool\n+    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n+                       _Predicate, std::input_iterator_tag)\n+    { return true; }\n+\n+  // Can verify if a forward iterator sequence is in fact sorted using\n+  // std::__is_sorted\n+  template<typename _ForwardIterator, typename _Predicate>\n+    inline bool\n+    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                       _Predicate __pred, std::forward_iterator_tag)\n+    {\n+      if (__first == __last)\n+        return true;\n+\n+      _ForwardIterator __next = __first;\n+      for (++__next; __next != __last; __first = __next, ++__next) {\n+        if (__pred(*__next, *__first))\n+          return false;\n+      }\n+\n+      return true;\n+    }\n+\n+  // Determine if a sequence is sorted.\n+  template<typename _InputIterator>\n+    inline bool\n+    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)\n+    {\n+      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n+        _Category;\n+      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());\n+    }\n+\n+  template<typename _InputIterator, typename _Predicate>\n+    inline bool\n+    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,\n+                   _Predicate __pred)\n+    {\n+      typedef typename std::iterator_traits<_InputIterator>::iterator_category\n+        _Category;\n+      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,\n+\t\t\t\t\t     _Category());\n+    }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 270. Binary search requirements overly strict\n+  // Determine if a sequence is partitioned w.r.t. this element.\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline bool\n+    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\tconst _Tp& __value)\n+    {\n+      while (__first != __last && *__first < __value)\n+\t++__first;\n+      while (__first != __last && !(*__first < __value))\n+\t++__first;\n+      return __first == __last;\n+    }\n+\n+  // Determine if a sequence is partitioned w.r.t. this element.\n+  template<typename _ForwardIterator, typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\tconst _Tp& __value, _Pred __pred)\n+    {\n+      while (__first != __last && __pred(*__first, __value))\n+\t++__first;\n+      while (__first != __last && !__pred(*__first, __value))\n+\t++__first;\n+      return __first == __last;\n+    }\n+} // namespace __gnu_debug\n+\n+#endif"}, {"sha": "d4d149756cd40c4e2011cd4495b6394b01533b78", "filename": "libstdc++-v3/include/debug/hash_map", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Debugging hash_map/hash_multimap implementation -*- C++ -*-\n \n-// Copyright (C) 2003\n+// Copyright (C) 2003, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -31,8 +31,8 @@\n #ifndef _GLIBCXX_DEBUG_HASH_MAP\n #define _GLIBCXX_DEBUG_HASH_MAP 1\n \n-#include <hash_map>\n-#include <debug/dbg_hash_map.h>\n-#include <debug/dbg_hash_multimap.h>\n+#include <ext/hash_map>\n+#include <debug/hash_map.h>\n+#include <debug/hash_multimap.h>\n \n #endif"}, {"sha": "c600f07c160a781d63a47e69f4ba26fdaf60554f", "filename": "libstdc++-v3/include/debug/hash_set", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Debugging hash_set/hash_multiset implementation -*- C++ -*-\n \n-// Copyright (C) 2003\n+// Copyright (C) 2003, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -31,8 +31,8 @@\n #ifndef _GLIBCXX_DEBUG_HASH_SET\n #define _GLIBCXX_DEBUG_HASH_SET 1\n \n-#include <hash_set>\n-#include <debug/dbg_hash_set.h>\n-#include <debug/dbg_hash_multiset.h>\n+#include <ext/hash_set>\n+#include <debug/hash_set.h>\n+#include <debug/hash_multiset.h>\n \n #endif"}, {"sha": "c89ff9e84e467338a883c394ea99646eeb08a8f3", "filename": "libstdc++-v3/include/debug/macros.h", "status": "added", "additions": 219, "deletions": 0, "changes": 219, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmacros.h?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -0,0 +1,219 @@\n+// Debugging support implementation -*- C++ -*-\n+\n+// Copyright (C) 2003, 2005\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_MACROS_H\n+#define _GLIBCXX_DEBUG_MACROS_H 1\n+\n+/**\n+ * Macros used by the implementation to verify certain\n+ * properties. These macros may only be used directly by the debug\n+ * wrappers. Note that these are macros (instead of the more obviously\n+ * \"correct\" choice of making them functions) because we need line and\n+ * file information at the call site, to minimize the distance between\n+ * the user error and where the error is reported.\n+ *\n+ */\n+#define _GLIBCXX_DEBUG_VERIFY(_Condition,_ErrorMessage)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (! (_Condition))\t\t\t\t\t\t\t\\\n+      ::__gnu_debug::_Error_formatter::_M_at(__FILE__, __LINE__)\t\\\n+\t  ._ErrorMessage._M_error();\t\t\t\t\t\\\n+  } while (false)\n+\n+// Verify that [_First, _Last) forms a valid iterator range.\n+#define __glibcxx_check_valid_range(_First,_Last)\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__valid_range(_First, _Last),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_valid_range)\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that we can insert into *this with the iterator _Position.\n+ *  Insertion into a container at a specific position requires that\n+ *  the iterator be nonsingular (i.e., either dereferenceable or\n+ *  past-the-end) and that it reference the sequence we are inserting\n+ *  into. Note that this macro is only valid when the container is a\n+ *  _Safe_sequence and the iterator is a _Safe_iterator.\n+*/\n+#define __glibcxx_check_insert(_Position)\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can insert the values in the iterator range\n+ *  [_First, _Last) into *this with the iterator _Position.  Insertion\n+ *  into a container at a specific position requires that the iterator\n+ *  be nonsingular (i.e., either dereferenceable or past-the-end),\n+ *  that it reference the sequence we are inserting into, and that the\n+ *  iterator range [_First, Last) is a valid (possibly empty)\n+ *  range. Note that this macro is only valid when the container is a\n+ *  _Safe_sequence and the iterator is a _Safe_iterator.\n+ *\n+ *  @tbd We would like to be able to check for noninterference of\n+ *  _Position and the range [_First, _Last), but that can't (in\n+ *  general) be done.\n+*/\n+#define __glibcxx_check_insert_range(_Position,_First,_Last)\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can erase the element referenced by the iterator\n+ * _Position. We can erase the element if the _Position iterator is\n+ * dereferenceable and references this sequence.\n+*/\n+#define __glibcxx_check_erase(_Position)\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_dereferenceable(),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_bad)\t\\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can erase the elements in the iterator range\n+ *  [_First, _Last). We can erase the elements if [_First, _Last) is a\n+ *  valid iterator range within this sequence.\n+*/\n+#define __glibcxx_check_erase_range(_First,_Last)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+// Verify that the subscript _N is less than the container's size.\n+#define __glibcxx_check_subscript(_N)\t\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_N < this->size(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_subscript_oob) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_integer(_N, #_N)\t\t\t\t\\\n+\t\t      ._M_integer(this->size(), \"size\"))\n+\n+// Verify that the container is nonempty\n+#define __glibcxx_check_nonempty()\t\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(! this->empty(),\t\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_empty)\t\\\n+                      ._M_sequence(*this, \"this\"))\n+\n+// Verify that the < operator for elements in the sequence is a\n+// StrictWeakOrdering by checking that it is irreflexive.\n+#define __glibcxx_check_strict_weak_ordering(_First,_Last)\t\\\n+_GLIBCXX_DEBUG_ASSERT(_First == _Last || !(*_First < *_First))\n+\n+// Verify that the predicate is StrictWeakOrdering by checking that it\n+// is irreflexive.\n+#define __glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred)\t\\\n+_GLIBCXX_DEBUG_ASSERT(_First == _Last || !_Pred(*_First, *_First))\n+\n+\n+// Verify that the iterator range [_First, _Last) is sorted\n+#define __glibcxx_check_sorted(_First,_Last)\t\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+__glibcxx_check_strict_weak_ordering(_First,_Last);\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_unsorted)\t\\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that the iterator range [_First, _Last) is sorted by the\n+    predicate _Pred. */\n+#define __glibcxx_check_sorted_pred(_First,_Last,_Pred)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+__glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred);\t        \\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last, _Pred), \\\n+\t\t      _M_message(::__gnu_debug::__msg_unsorted_pred) \\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Pred))\n+\n+/** Verify that the iterator range [_First, _Last) is partitioned\n+    w.r.t. the value _Value. */\n+#define __glibcxx_check_partitioned(_First,_Last,_Value)\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n+\t\t\t\t\t\t\t _Value),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_unpartitioned) \\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Value))\n+\n+/** Verify that the iterator range [_First, _Last) is partitioned\n+    w.r.t. the value _Value and predicate _Pred. */\n+#define __glibcxx_check_partitioned_pred(_First,_Last,_Value,_Pred)\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n+\t\t\t\t\t\t\t _Value, _Pred), \\\n+\t\t      _M_message(::__gnu_debug::__msg_unpartitioned_pred) \\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Pred)\t\t\t\t\\\n+                      ._M_string(#_Value))\n+\n+// Verify that the iterator range [_First, _Last) is a heap\n+#define __glibcxx_check_heap(_First,_Last)\t\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last),\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_not_heap)\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that the iterator range [_First, _Last) is a heap\n+    w.r.t. the predicate _Pred. */\n+#define __glibcxx_check_heap_pred(_First,_Last,_Pred)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last, _Pred),\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_not_heap_pred) \\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Pred))\n+\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+#  define __glibcxx_check_string(_String) _GLIBCXX_DEBUG_ASSERT(_String != 0)\n+#  define __glibcxx_check_string_len(_String,_Len) \\\n+       _GLIBCXX_DEBUG_ASSERT(_String != 0 || _Len == 0)\n+#else\n+#  define __glibcxx_check_string(_String)\n+#  define __glibcxx_check_string_len(_String,_Len)\n+#endif\n+\n+#endif"}, {"sha": "8d96f397c85e32c065c47d4c347706cc1ed8583a", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -31,10 +31,12 @@\n #ifndef _GLIBCXX_DEBUG_SAFE_ITERATOR_H\n #define _GLIBCXX_DEBUG_SAFE_ITERATOR_H 1\n \n-#include <bits/stl_pair.h>\n #include <debug/debug.h>\n+#include <debug/macros.h>\n+#include <debug/functions.h>\n #include <debug/formatter.h>\n #include <debug/safe_base.h>\n+#include <bits/stl_pair.h>\n #include <bits/cpp_type_traits.h>\n \n namespace __gnu_debug\n@@ -46,7 +48,8 @@ namespace __gnu_debug\n    *  _Safe_iterators can be determined singular or non-singular via\n    *  _Safe_iterator_base.\n    */\n-  inline bool __check_singular_aux(const _Safe_iterator_base* __x)\n+  inline bool \n+  __check_singular_aux(const _Safe_iterator_base* __x)\n   { return __x->_M_singular(); }\n \n   /** \\brief Safe iterator wrapper."}, {"sha": "a1577b4b4ee8eb71cf3b64c6b310728f1c5d4fe4", "filename": "libstdc++-v3/include/debug/safe_sequence.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Safe sequence implementation  -*- C++ -*-\n \n-// Copyright (C) 2003, 2004\n+// Copyright (C) 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -32,6 +32,8 @@\n #define _GLIBCXX_DEBUG_SAFE_SEQUENCE_H 1\n \n #include <debug/debug.h>\n+#include <debug/macros.h>\n+#include <debug/functions.h>\n #include <debug/safe_base.h>\n \n namespace __gnu_debug"}, {"sha": "45a423d2d89f5d8bbe390af4c08bcc64c667f224", "filename": "libstdc++-v3/include/debug/vector", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Debugging vector implementation -*- C++ -*-\n \n-// Copyright (C) 2003, 2004\n+// Copyright (C) 2003, 2004, 2005\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -32,9 +32,9 @@\n #define _GLIBCXX_DEBUG_VECTOR 1\n \n #include <vector>\n+#include <utility>\n #include <debug/safe_sequence.h>\n #include <debug/safe_iterator.h>\n-#include <utility>\n \n namespace __gnu_debug_def\n {"}, {"sha": "20eebeb29a2cd7f5009769c64b9a6d5d30c11304", "filename": "libstdc++-v3/include/ext/hash_map", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_map?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Hashing map implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -617,4 +617,9 @@ namespace std\n       { return *this; }\n     };\n } // namespace std\n+\n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/hash_map>\n+#endif\n+\n #endif"}, {"sha": "120bfc5ae4be83e7762639b95f7d25c4f906b546", "filename": "libstdc++-v3/include/ext/hash_set", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fhash_set?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -1,6 +1,6 @@\n // Hashing set implementation -*- C++ -*-\n \n-// Copyright (C) 2001, 2002, 2004 Free Software Foundation, Inc.\n+// Copyright (C) 2001, 2002, 2004, 2005 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -583,4 +583,9 @@ namespace std\n       operator++(int) { return *this; }\n     };\n } // namespace std\n+\n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/hash_set>\n+#endif\n+\n #endif"}, {"sha": "f3ffa4a48e0adc76f99a30e00955961edc4cd5f0", "filename": "libstdc++-v3/testsuite/17_intro/no_assert_neg.cc", "status": "added", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fno_assert_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d2763ab5f180a4e22cc7d05c84a3728e89ced2b1/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fno_assert_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F17_intro%2Fno_assert_neg.cc?ref=d2763ab5f180a4e22cc7d05c84a3728e89ced2b1", "patch": "@@ -0,0 +1,89 @@\n+// { dg-do compile }\n+// { dg-options \"-D__GLIBCXX__=99999999\" }\n+// NB: This is done to force any generated and possibly included PCH\n+// to be invalid.\n+\n+// 2005-05-24 bkoz\n+\n+// Copyright (C) 2005 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 17.4.1.2 Headers\n+\n+// This file tests that assert is not included in any of the standard\n+// includes by accident.\n+\n+// C++ headers\n+#include <algorithm>\n+#include <bitset>\n+#include <complex>\n+#include <deque>\n+#include <exception>\n+#include <fstream>\n+#include <functional>\n+#include <iomanip>\n+#include <ios>\n+#include <iosfwd>\n+#include <iostream>\n+#include <istream>\n+#include <iterator>\n+#include <limits>\n+#include <list>\n+#include <locale>\n+#include <map>\n+#include <memory>\n+#include <new>\n+#include <numeric>\n+#include <ostream>\n+#include <queue>\n+#include <set>\n+#include <sstream>\n+#include <stack>\n+#include <stdexcept>\n+#include <streambuf>\n+#include <string>\n+#include <typeinfo>\n+#include <utility>\n+#include <valarray>\n+#include <vector>\n+\n+// C headers\n+#include <cctype>\n+#include <cerrno>\n+#include <cfloat>\n+#include <ciso646>\n+#include <climits>\n+#include <clocale>\n+#include <cmath>\n+#include <csetjmp>\n+#include <csignal>\n+#include <cstdarg>\n+#include <cstddef>\n+#include <cstdio>\n+#include <cstdlib>\n+#include <cstring>\n+#include <ctime>\n+\n+void foo()\n+{\n+ assert(true);  \n+}\n+\n+// { dg-error \"not declared\" \"\" { target *-*-* } 84 } \n+\n+"}]}