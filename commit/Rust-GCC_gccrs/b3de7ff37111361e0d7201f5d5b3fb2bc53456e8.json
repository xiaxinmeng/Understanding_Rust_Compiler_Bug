{"sha": "b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjNkZTdmZjM3MTExMzYxZTBkNzIwMWY1ZDViM2ZiMmJjNTM0NTZlOA==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2002-01-30T22:20:23Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2002-01-30T22:20:23Z"}, "message": "verify.cc (handle_ret_insn): Check for subroutine merge here...\n\n\t* verify.cc (handle_ret_insn): Check for subroutine merge here...\n\t(state::merge): ... not here.\n\t(subr_entry_info): New structure.\n\t(entry_points): New field.\n\t(~_Jv_BytecodeVerifier): Correctly free jsr_ptrs.  Free\n\tentry_points.\n\nFrom-SVN: r49344", "tree": {"sha": "77e4e1dfca3d77c1258e7f065d0e01ea2179435b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77e4e1dfca3d77c1258e7f065d0e01ea2179435b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8/comments", "author": null, "committer": null, "parents": [{"sha": "f2e7381d8e6ae8401be24fdc3b132ee59d66dbff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f2e7381d8e6ae8401be24fdc3b132ee59d66dbff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f2e7381d8e6ae8401be24fdc3b132ee59d66dbff"}], "stats": {"total": 90, "additions": 81, "deletions": 9}, "files": [{"sha": "044f72442ba52782b1cc93ce21029e840b76f18e", "filename": "libjava/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "patch": "@@ -1,3 +1,12 @@\n+2002-01-30  Tom Tromey  <tromey@redhat.com>\n+\n+\t* verify.cc (handle_ret_insn): Check for subroutine merge here...\n+\t(state::merge): ... not here.\n+\t(subr_entry_info): New structure.\n+\t(entry_points): New field.\n+\t(~_Jv_BytecodeVerifier): Correctly free jsr_ptrs.  Free\n+\tentry_points.\n+\n 2002-01-29  Tom Tromey  <tromey@redhat.com>\n \n \t* java/awt/List.java (addNotify): Correctly check to see if peer"}, {"sha": "1035cdaf4c8474b0877fb6ec6d0dc8eb99df6f82", "filename": "libjava/verify.cc", "status": "modified", "additions": 72, "deletions": 9, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8/libjava%2Fverify.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b3de7ff37111361e0d7201f5d5b3fb2bc53456e8/libjava%2Fverify.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fverify.cc?ref=b3de7ff37111361e0d7201f5d5b3fb2bc53456e8", "patch": "@@ -56,6 +56,7 @@ class _Jv_BytecodeVerifier\n   struct state;\n   struct type;\n   struct subr_info;\n+  struct subr_entry_info;\n   struct linked_utf8;\n \n   // The current PC.\n@@ -84,6 +85,11 @@ class _Jv_BytecodeVerifier\n   // of all calling `jsr's at at each jsr target.\n   subr_info **jsr_ptrs;\n \n+  // We keep a linked list of entries which map each `ret' instruction\n+  // to its unique subroutine entry point.  We expect that there won't\n+  // be many `ret' instructions, so a linked list is ok.\n+  subr_entry_info *entry_points;\n+\n   // The current top of the stack, in terms of slots.\n   int stacktop;\n   // The current depth of the stack.  This will be larger than\n@@ -273,6 +279,18 @@ class _Jv_BytecodeVerifier\n     subr_info *next;\n   };\n \n+  // This is used to keep track of which subroutine entry point\n+  // corresponds to which `ret' instruction.\n+  struct subr_entry_info\n+  {\n+    // PC of the subroutine entry point.\n+    int pc;\n+    // PC of the `ret' instruction.\n+    int ret_pc;\n+    // Link.\n+    subr_entry_info *next;\n+  };\n+\n   // The `type' class is used to represent a single type in the\n   // verifier.\n   struct type\n@@ -886,9 +904,9 @@ class _Jv_BytecodeVerifier\n       if (this_type.isinitialized ())\n \tthis_type = state_old->this_type;\n \n-      // Merge subroutine states.  *THIS and *STATE_OLD must be in the\n-      // same subroutine.  Also, recursive subroutine calls must be\n-      // avoided.\n+      // Merge subroutine states.  Here we just keep track of what\n+      // subroutine we think we're in.  We only check for a merge\n+      // (which is invalid) when we see a `ret'.\n       if (subroutine == state_old->subroutine)\n \t{\n \t  // Nothing.\n@@ -898,11 +916,13 @@ class _Jv_BytecodeVerifier\n \t  subroutine = state_old->subroutine;\n \t  changed = true;\n \t}\n-      // If we're handling the result of an unmerged `ret', then we\n-      // can't trust that it has the correct PC setting.  So in this\n-      // case we ignore what might otherwise look like a merge error.\n-      else if (! state_old->is_unmerged_ret_state (max_locals))\n-\tverifier->verify_fail (\"subroutines merged\");\n+      else\n+\t{\n+\t  // If the subroutines differ, indicate that the state\n+\t  // changed.  This is needed to detect when subroutines have\n+\t  // merged.\n+\t  changed = true;\n+\t}\n \n       // Merge stacks.\n       if (state_old->stacktop != stacktop)\n@@ -1329,6 +1349,24 @@ class _Jv_BytecodeVerifier\n     if (csub == 0)\n       verify_fail (\"no subroutine\");\n \n+    // Check to see if we've merged subroutines.\n+    subr_entry_info *entry;\n+    for (entry = entry_points; entry != NULL; entry = entry->next)\n+      {\n+\tif (entry->ret_pc == start_PC)\n+\t  break;\n+      }\n+    if (entry == NULL)\n+      {\n+\tentry = (subr_entry_info *) _Jv_Malloc (sizeof (subr_entry_info));\n+\tentry->pc = csub;\n+\tentry->ret_pc = start_PC;\n+\tentry->next = entry_points;\n+\tentry_points = entry;\n+      }\n+    else if (entry->pc != csub)\n+      verify_fail (\"subroutines merged\");\n+\n     for (subr_info *subr = jsr_ptrs[csub]; subr != NULL; subr = subr->next)\n       {\n \t// Temporarily modify the current state so it looks like we're\n@@ -2893,6 +2931,7 @@ class _Jv_BytecodeVerifier\n     flags = NULL;\n     jsr_ptrs = NULL;\n     utf8_list = NULL;\n+    entry_points = NULL;\n   }\n \n   ~_Jv_BytecodeVerifier ()\n@@ -2901,15 +2940,39 @@ class _Jv_BytecodeVerifier\n       _Jv_Free (states);\n     if (flags)\n       _Jv_Free (flags);\n+\n     if (jsr_ptrs)\n-      _Jv_Free (jsr_ptrs);\n+      {\n+\tfor (int i = 0; i < current_method->code_length; ++i)\n+\t  {\n+\t    if (jsr_ptrs[i] != NULL)\n+\t      {\n+\t\tsubr_info *info = jsr_ptrs[i];\n+\t\twhile (info != NULL)\n+\t\t  {\n+\t\t    subr_info *next = info->next;\n+\t\t    _Jv_Free (info);\n+\t\t    info = next;\n+\t\t  }\n+\t      }\n+\t  }\n+\t_Jv_Free (jsr_ptrs);\n+      }\n+\n     while (utf8_list != NULL)\n       {\n \tlinked_utf8 *n = utf8_list->next;\n \t_Jv_Free (utf8_list->val);\n \t_Jv_Free (utf8_list);\n \tutf8_list = n;\n       }\n+\n+    while (entry_points != NULL)\n+      {\n+\tsubr_entry_info *next = entry_points->next;\n+\t_Jv_Free (entry_points);\n+\tentry_points = next;\n+      }\n   }\n };\n "}]}