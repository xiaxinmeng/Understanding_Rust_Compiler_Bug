{"sha": "f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "node_id": "C_kwDOANBUbNoAKGYxNWFkMWUzZjk0ODhhMzFhYmYxYzEyMmJkMTg2YzFhM2QyYTVkYmM", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-11-05T11:07:42Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-11-10T08:57:43Z"}, "message": "[Ada] Minor cleanup in translation of calls to subprograms\n\ngcc/ada/\n\n\t* gcc-interface/ada-tree.h (DECL_STUBBED_P): Delete.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity): Do not set it.\n\t* gcc-interface/trans.c (Call_to_gnu): Use GNAT_NAME local variable\n\tand adjust accordingly.  Replace test on DECL_STUBBED_P with direct\n\ttest on Convention and move it down in the processing.", "tree": {"sha": "6cc7846b7b66b2075f8fbca8c23db98267918a6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cc7846b7b66b2075f8fbca8c23db98267918a6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e988162f6e9cbb9bea998b4f1febda199769692", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0e988162f6e9cbb9bea998b4f1febda199769692", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0e988162f6e9cbb9bea998b4f1febda199769692"}], "stats": {"total": 125, "additions": 60, "deletions": 65}, "files": [{"sha": "0ec81bc541c2dafd2fe8db4cb38004bd99c6b6c2", "filename": "gcc/ada/gcc-interface/ada-tree.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Fada-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fada-tree.h?ref=f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "patch": "@@ -410,10 +410,6 @@ do {\t\t\t\t\t\t   \\\n \n /* Flags added to decl nodes.  */\n \n-/* Nonzero in a FUNCTION_DECL that represents a stubbed function\n-   discriminant.  */\n-#define DECL_STUBBED_P(NODE) DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n-\n /* Nonzero in a VAR_DECL if it is guaranteed to be constant after having\n    been elaborated and TREE_READONLY is not set on it.  */\n #define DECL_READONLY_ONCE_ELAB(NODE) DECL_LANG_FLAG_0 (VAR_DECL_CHECK (NODE))"}, {"sha": "449463e799ec5a2291653b711fac6ee8e0ffeb49", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "patch": "@@ -4095,19 +4095,14 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, bool definition)\n \t    else if (extern_flag && gnu_ext_name == DECL_NAME (realloc_decl))\n \t      gnu_decl = realloc_decl;\n \t    else\n-\t      {\n-\t\tgnu_decl\n-\t\t  = create_subprog_decl (gnu_entity_name, gnu_ext_name,\n-\t\t\t\t\t gnu_type, gnu_param_list,\n-\t\t\t\t\t inline_status, public_flag,\n-\t\t\t\t\t extern_flag, artificial_p,\n-\t\t\t\t\t debug_info_p,\n-\t\t\t\t\t definition && imported_p, attr_list,\n-\t\t\t\t\t gnat_entity);\n-\n-\t\tDECL_STUBBED_P (gnu_decl)\n-\t\t  = (Convention (gnat_entity) == Convention_Stubbed);\n-\t      }\n+\t      gnu_decl\n+\t\t= create_subprog_decl (gnu_entity_name, gnu_ext_name,\n+\t\t\t\t       gnu_type, gnu_param_list,\n+\t\t\t\t       inline_status, public_flag,\n+\t\t\t\t       extern_flag, artificial_p,\n+\t\t\t\t       debug_info_p,\n+\t\t\t\t       definition && imported_p, attr_list,\n+\t\t\t\t       gnat_entity);\n \t  }\n       }\n       break;"}, {"sha": "a932ca24ce04fbeeda8fda218cd11a75816c1861", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 52, "deletions": 48, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=f15ad1e3f9488a31abf1c122bd186c1a3d2a5dbc", "patch": "@@ -4453,13 +4453,14 @@ static tree\n Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t     atomic_acces_t atomic_access, bool atomic_sync)\n {\n+  const Node_Id gnat_name = Name (gnat_node);\n   const bool function_call = (Nkind (gnat_node) == N_Function_Call);\n   const bool returning_value = (function_call && !gnu_target);\n   /* The GCC node corresponding to the GNAT subprogram name.  This can either\n      be a FUNCTION_DECL node if we are dealing with a standard subprogram call,\n      or an indirect reference expression (an INDIRECT_REF node) pointing to a\n      subprogram.  */\n-  tree gnu_subprog = gnat_to_gnu (Name (gnat_node));\n+  tree gnu_subprog = gnat_to_gnu (gnat_name);\n   /* The FUNCTION_TYPE node giving the GCC type of the subprogram.  */\n   tree gnu_subprog_type = TREE_TYPE (gnu_subprog);\n   /* The return type of the FUNCTION_TYPE.  */\n@@ -4482,50 +4483,16 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   atomic_acces_t aa_type;\n   bool aa_sync;\n \n-  gcc_assert (FUNC_OR_METHOD_TYPE_P (gnu_subprog_type));\n-\n-  /* If we are calling a stubbed function, raise Program_Error, but Elaborate\n-     all our args first.  */\n-  if (TREE_CODE (gnu_subprog) == FUNCTION_DECL && DECL_STUBBED_P (gnu_subprog))\n-    {\n-      tree call_expr = build_call_raise (PE_Stubbed_Subprogram_Called,\n-\t\t\t\t\t gnat_node, N_Raise_Program_Error);\n-\n-      for (gnat_actual = First_Actual (gnat_node);\n-\t   Present (gnat_actual);\n-\t   gnat_actual = Next_Actual (gnat_actual))\n-\tadd_stmt (gnat_to_gnu (gnat_actual));\n-\n-      if (returning_value)\n-\t{\n-\t  *gnu_result_type_p = gnu_result_type;\n-\t  return build1 (NULL_EXPR, gnu_result_type, call_expr);\n-\t}\n-\n-      return call_expr;\n-    }\n-\n-  if (TREE_CODE (gnu_subprog) == FUNCTION_DECL)\n-    {\n-      /* For a call to a nested function, check the inlining status.  */\n-      if (decl_function_context (gnu_subprog))\n-\tcheck_inlining_for_nested_subprog (gnu_subprog);\n-\n-      /* For a recursive call, avoid explosion due to recursive inlining.  */\n-      if (gnu_subprog == current_function_decl)\n-\tDECL_DISREGARD_INLINE_LIMITS (gnu_subprog) = 0;\n-    }\n-\n-  /* The only way we can be making a call via an access type is if Name is an\n+  /* The only way we can make a call via an access type is if GNAT_NAME is an\n      explicit dereference.  In that case, get the list of formal args from the\n      type the access type is pointing to.  Otherwise, get the formals from the\n      entity being called.  */\n-  if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n+  if (Nkind (gnat_name) == N_Explicit_Dereference)\n     {\n       const Entity_Id gnat_prefix_type\n-\t= Underlying_Type (Etype (Prefix (Name (gnat_node))));\n+\t= Underlying_Type (Etype (Prefix (gnat_name)));\n \n-      gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n+      gnat_formal = First_Formal_With_Extras (Etype (gnat_name));\n       variadic = IN (Convention (gnat_prefix_type), Convention_C_Variadic);\n \n       /* If the access type doesn't require foreign-compatible representation,\n@@ -4534,19 +4501,56 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t= targetm.calls.custom_function_descriptors > 0\n \t  && Can_Use_Internal_Rep (gnat_prefix_type);\n     }\n-  else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)\n+\n+  else if (Nkind (gnat_name) == N_Attribute_Reference)\n     {\n       /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n       gnat_formal = Empty;\n       variadic = false;\n       by_descriptor = false;\n     }\n+\n   else\n     {\n-      gnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n-      variadic\n-\t= IN (Convention (Entity (Name (gnat_node))), Convention_C_Variadic);\n+      gcc_checking_assert (Is_Entity_Name (gnat_name));\n+\n+      gnat_formal = First_Formal_With_Extras (Entity (gnat_name));\n+      variadic = IN (Convention (Entity (gnat_name)), Convention_C_Variadic);\n       by_descriptor = false;\n+\n+      /* If we are calling a stubbed function, then raise Program_Error, but\n+\t elaborate all our args first.  */\n+      if (Convention (Entity (gnat_name)) == Convention_Stubbed)\n+\t{\n+\t  tree call_expr = build_call_raise (PE_Stubbed_Subprogram_Called,\n+\t\t\t\t\t     gnat_node, N_Raise_Program_Error);\n+\n+\t  for (gnat_actual = First_Actual (gnat_node);\n+\t       Present (gnat_actual);\n+\t       gnat_actual = Next_Actual (gnat_actual))\n+\t    add_stmt (gnat_to_gnu (gnat_actual));\n+\n+\t  if (returning_value)\n+\t    {\n+\t      *gnu_result_type_p = gnu_result_type;\n+\t      return build1 (NULL_EXPR, gnu_result_type, call_expr);\n+\t    }\n+\n+\t  return call_expr;\n+\t}\n+    }\n+\n+  gcc_assert (FUNC_OR_METHOD_TYPE_P (gnu_subprog_type));\n+\n+  if (TREE_CODE (gnu_subprog) == FUNCTION_DECL)\n+    {\n+      /* For a call to a nested function, check the inlining status.  */\n+      if (decl_function_context (gnu_subprog))\n+\tcheck_inlining_for_nested_subprog (gnu_subprog);\n+\n+      /* For a recursive call, avoid explosion due to recursive inlining.  */\n+      if (gnu_subprog == current_function_decl)\n+\tDECL_DISREGARD_INLINE_LIMITS (gnu_subprog) = 0;\n     }\n \n   /* The lifetime of the temporaries created for the call ends right after the\n@@ -4765,8 +4769,8 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t  /* Do not initialize it for the _Init parameter of an initialization\n \t     procedure since no data is meant to be passed in.  */\n \t  if (Ekind (gnat_formal) == E_Out_Parameter\n-\t      && Is_Entity_Name (Name (gnat_node))\n-\t      && Is_Init_Proc (Entity (Name (gnat_node))))\n+\t      && Is_Entity_Name (gnat_name)\n+\t      && Is_Init_Proc (Entity (gnat_name)))\n \t    gnu_name = gnu_temp = create_temporary (\"A\", TREE_TYPE (gnu_name));\n \n \t  /* Initialize it on the fly like for an implicit temporary in the\n@@ -5097,10 +5101,10 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n       if (function_call)\n \tgnu_cico_list = TREE_CHAIN (gnu_cico_list);\n \n-      if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n-\tgnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n+      if (Nkind (gnat_name) == N_Explicit_Dereference)\n+\tgnat_formal = First_Formal_With_Extras (Etype (gnat_name));\n       else\n-\tgnat_formal = First_Formal_With_Extras (Entity (Name (gnat_node)));\n+\tgnat_formal = First_Formal_With_Extras (Entity (gnat_name));\n \n       for (gnat_actual = First_Actual (gnat_node);\n \t   Present (gnat_actual);"}]}