{"sha": "b20097c65d2e74b1901fba1c55c77f0407e542d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjIwMDk3YzY1ZDJlNzRiMTkwMWZiYTFjNTVjNzdmMDQwN2U1NDJkMg==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-05T21:46:41Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-07-13T10:21:20Z"}, "message": "openacc: Don't strip TO_PSET/POINTER for enter/exit data\n\nOpenACC 2.6 specifies that the array descriptor (when present) must be\ncopied to the target before attaching pointers in Fortran. This patch\nreverses the stripping of GOMP_MAP_TO_PSET and GOMP_MAP_POINTER that\nwas introduced by the \"OpenACC reference count overhaul\" patch.\n\n2020-07-10  Julian Brown  <julian@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\ngcc/\n\t* gimplify.c (gimplify_scan_omp_clauses): Do not strip\n\tGOMP_MAP_TO_PSET/GOMP_MAP_POINTER for OpenACC enter/exit data\n\tdirectives (see also PR92929).\n\ngcc/testsuite/\n\t* gfortran.dg/goacc/finalize-1.f: Update expected dump output.\n\nlibgomp/\n\t* testsuite/libgomp.oacc-fortran/dynamic-pointer-1.f90: New test.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "954defb734e68a90c47c5147f0392ef7aecb61ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/954defb734e68a90c47c5147f0392ef7aecb61ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b20097c65d2e74b1901fba1c55c77f0407e542d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20097c65d2e74b1901fba1c55c77f0407e542d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b20097c65d2e74b1901fba1c55c77f0407e542d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b20097c65d2e74b1901fba1c55c77f0407e542d2/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a4770f0394751860ee54520b23007938907ac33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a4770f0394751860ee54520b23007938907ac33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a4770f0394751860ee54520b23007938907ac33"}], "stats": {"total": 122, "additions": 110, "deletions": 12}, "files": [{"sha": "15dfee903ab298f6a02e45d1affcc2260f3c911d", "filename": "gcc/gimplify.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20097c65d2e74b1901fba1c55c77f0407e542d2/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20097c65d2e74b1901fba1c55c77f0407e542d2/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=b20097c65d2e74b1901fba1c55c77f0407e542d2", "patch": "@@ -8768,6 +8768,8 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t    case OMP_TARGET_DATA:\n \t    case OMP_TARGET_ENTER_DATA:\n \t    case OMP_TARGET_EXIT_DATA:\n+\t    case OACC_ENTER_DATA:\n+\t    case OACC_EXIT_DATA:\n \t    case OACC_HOST_DATA:\n \t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n \t\t  || (OMP_CLAUSE_MAP_KIND (c)\n@@ -8776,15 +8778,6 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t\t   mapped, but not the pointer to it.  */\n \t\tremove = true;\n \t      break;\n-\t    case OACC_ENTER_DATA:\n-\t    case OACC_EXIT_DATA:\n-\t      if (OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_POINTER\n-\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_TO_PSET\n-\t\t  || OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_FIRSTPRIVATE_POINTER\n-\t\t  || (OMP_CLAUSE_MAP_KIND (c)\n-\t\t      == GOMP_MAP_FIRSTPRIVATE_REFERENCE))\n-\t\tremove = true;\n-\t      break;\n \t    default:\n \t      break;\n \t    }\n@@ -8794,7 +8787,15 @@ gimplify_scan_omp_clauses (tree *list_p, gimple_seq *pre_p,\n \t     does not make sense.  Likewise, for 'update' only transferring the\n \t     data itself is needed as the rest has been handled in previous\n \t     directives.  However, for 'exit data', the array descriptor needs\n-\t     to be delete; hence, we turn the MAP_TO_PSET into a MAP_DELETE.  */\n+\t     to be delete; hence, we turn the MAP_TO_PSET into a MAP_DELETE.\n+\n+\t     NOTE: Generally, it is not safe to perform \"enter data\" operations\n+\t     on arrays where the data *or the descriptor* may go out of scope\n+\t     before a corresponding \"exit data\" operation -- and such a\n+\t     descriptor may be synthesized temporarily, e.g. to pass an\n+\t     explicit-shape array to a function expecting an assumed-shape\n+\t     argument.  Performing \"enter data\" inside the called function\n+\t     would thus be problematic.  */\n \t  if (code == OMP_TARGET_EXIT_DATA\n \t      && OMP_CLAUSE_MAP_KIND (c) == GOMP_MAP_TO_PSET)\n \t    OMP_CLAUSE_SET_MAP_KIND (c, OMP_CLAUSE_MAP_KIND (*prev_list_p)"}, {"sha": "ca642156e9fdef6b8e78bdd61d9a8807bb0dcfa0", "filename": "gcc/testsuite/gfortran.dg/goacc/finalize-1.f", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20097c65d2e74b1901fba1c55c77f0407e542d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20097c65d2e74b1901fba1c55c77f0407e542d2/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgoacc%2Ffinalize-1.f?ref=b20097c65d2e74b1901fba1c55c77f0407e542d2", "patch": "@@ -21,7 +21,7 @@ SUBROUTINE f\n \n !$ACC EXIT DATA FINALIZE DELETE (del_f_p(2:5))\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(release:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.0\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:del_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) del_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(sizetype\\\\) parm\\\\.0\\\\.data - \\\\(sizetype\\\\) del_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(delete:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(delete:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:del_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:del_f_p\\\\.data \\\\\\[pointer assign, bias: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n \n !$ACC EXIT DATA COPYOUT (cpo_r)\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(from:cpo_r\\\\);$\" 1 \"original\" } }\n@@ -33,5 +33,5 @@ SUBROUTINE f\n \n !$ACC EXIT DATA COPYOUT (cpo_f_p(4:10)) FINALIZE\n ! { dg-final { scan-tree-dump-times \"(?n)#pragma acc exit data map\\\\(from:\\\\*\\\\(c_char \\\\*\\\\) parm\\\\.1\\\\.data \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:cpo_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:\\\\(integer\\\\(kind=1\\\\)\\\\\\[0:\\\\\\] \\\\* restrict\\\\) cpo_f_p\\\\.data \\\\\\[pointer assign, bias: \\\\(sizetype\\\\) parm\\\\.1\\\\.data - \\\\(sizetype\\\\) cpo_f_p\\\\.data\\\\\\]\\\\) finalize;$\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(force_from:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n+! { dg-final { scan-tree-dump-times \"(?n)#pragma omp target oacc_enter_exit_data map\\\\(force_from:MEM\\\\\\[\\\\(c_char \\\\*\\\\)\\[^\\\\\\]\\]+\\\\\\] \\\\\\[len: \\[^\\\\\\]\\]+\\\\\\]\\\\) map\\\\(to:cpo_f_p \\\\\\[pointer set, len: \\[0-9\\]+\\\\\\]\\\\) map\\\\(alloc:cpo_f_p\\\\.data \\\\\\[pointer assign, bias: \\[^\\\\\\]\\]+\\\\\\]\\\\) finalize$\" 1 \"gimple\" } }\n       END SUBROUTINE f"}, {"sha": "4f38902ebc0c4c04e80975bff1bbb8a90d38fe88", "filename": "libgomp/testsuite/libgomp.oacc-fortran/dynamic-pointer-1.f90", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b20097c65d2e74b1901fba1c55c77f0407e542d2/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-pointer-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b20097c65d2e74b1901fba1c55c77f0407e542d2/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-pointer-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdynamic-pointer-1.f90?ref=b20097c65d2e74b1901fba1c55c77f0407e542d2", "patch": "@@ -0,0 +1,97 @@\n+! Verify that a 'enter data'ed 'pointer' object creates a persistent, visible device copy\n+\n+! { dg-do run }\n+! { dg-skip-if \"\" { *-*-* } { \"*\" } { \"-DACC_MEM_SHARED=0\" } }\n+\n+module m\n+  implicit none\n+contains\n+\n+  subroutine verify_a (a_ref, a)\n+    implicit none\n+    integer, dimension (:, :, :), allocatable :: a_ref\n+    integer, dimension (:, :, :), pointer :: a\n+\n+    !$acc routine seq\n+\n+    if (any (lbound (a) /= lbound (a_ref))) stop 101\n+    if (any (ubound (a) /= ubound (a_ref))) stop 102\n+    if (size (a) /= size (a_ref)) stop 103\n+  end subroutine verify_a\n+\n+end module m\n+\n+program main\n+  use m\n+  use openacc\n+  implicit none\n+  integer, parameter :: n = 30\n+  integer, dimension (:, :, :), allocatable, target :: a1, a2\n+  integer, dimension (:, :, :), pointer :: p\n+\n+  allocate (a1(1:n, 0:n-1, 10:n/2))\n+  !$acc enter data create(a1)\n+  allocate (a2(3:n/3, 10:n, n-10:n+10))\n+  !$acc enter data create(a2)\n+\n+  p => a1\n+  call verify_a(a1, p)\n+\n+  ! 'p' object isn't present on the device.\n+  !$acc parallel ! Implicit 'copy(p)'; creates 'p' object...\n+  call verify_a(a1, p)\n+  !$acc end parallel ! ..., and deletes it again.\n+\n+  p => a2\n+  call verify_a(a2, p)\n+\n+  ! 'p' object isn't present on the device.\n+  !$acc parallel ! Implicit 'copy(p)'; creates 'p' object...\n+  call verify_a(a2, p)\n+  !$acc end parallel ! ..., and deletes it again.\n+\n+  p => a1\n+\n+  !$acc enter data create(p)\n+  ! 'p' object is now present on the device (visible device copy).\n+  !TODO PR96080 if (.not. acc_is_present (p)) stop 1\n+\n+  !$acc parallel\n+  ! On the device, got created as 'p => a1'.\n+  call verify_a(a1, p)\n+  !$acc end parallel\n+  call verify_a(a1, p)\n+\n+  !$acc parallel\n+  p => a2\n+  ! On the device, 'p => a2' is now set.\n+  call verify_a(a2, p)\n+  !$acc end parallel\n+  ! On the host, 'p => a1' persists.\n+  call verify_a(a1, p)\n+\n+  !$acc parallel\n+  ! On the device, 'p => a2' persists.\n+  call verify_a(a2, p)\n+  !$acc end parallel\n+  ! On the host, 'p => a1' still persists.\n+  call verify_a(a1, p)\n+\n+  p => a2\n+\n+  !$acc parallel\n+  p => a1\n+  ! On the device, 'p => a1' is now set.\n+  call verify_a(a1, p)\n+  !$acc end parallel\n+  ! On the host, 'p => a2' persists.\n+  call verify_a(a2, p)\n+\n+  !$acc parallel\n+  ! On the device, 'p => a1' persists.\n+  call verify_a(a1, p)\n+  !$acc end parallel\n+  ! On the host, 'p => a2' still persists.\n+  call verify_a(a2, p)\n+\n+end program main"}]}