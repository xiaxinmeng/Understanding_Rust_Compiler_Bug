{"sha": "e645e94288a253da5ba9f14c599378a96348e4ea", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTY0NWU5NDI4OGEyNTNkYTViYTlmMTRjNTk5Mzc4YTk2MzQ4ZTRlYQ==", "commit": {"author": {"name": "Teresa Johnson", "email": "tejohnson@google.com", "date": "2013-09-16T13:40:02Z"}, "committer": {"name": "Teresa Johnson", "email": "tejohnson@gcc.gnu.org", "date": "2013-09-16T13:40:02Z"}, "message": "dumpfile.c (dump_loc): Remove newline emission.\n\n2013-09-16  Teresa Johnson  <tejohnson@google.com>\n\n\t* dumpfile.c (dump_loc): Remove newline emission.\n\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Add newline\n\temission to dump_printf_loc calls where missing.\n\t(vect_mark_for_runtime_alias_test): Ditto.\n\t(vect_analyze_data_ref_dependence): Ditto.\n\t(vect_analyze_data_ref_dependences): Ditto.\n\t(vect_slp_analyze_data_ref_dependence): Ditto.\n\t(vect_slp_analyze_data_ref_dependences): Ditto.\n\t(vect_compute_data_ref_alignment): Ditto.\n\t(vect_update_misalignment_for_peel): Ditto.\n\t(vect_verify_datarefs_alignment): Ditto.\n\t(vector_alignment_reachable_p): Ditto.\n\t(vect_get_data_access_cost): Ditto.\n\t(vect_enhance_data_refs_alignment): Ditto.\n\t(vect_find_same_alignment_drs): Ditto.\n\t(vect_analyze_data_refs_alignment): Ditto.\n\t(vect_analyze_group_access): Ditto.\n\t(vect_analyze_data_ref_access): Ditto.\n\t(vect_analyze_data_ref_accesses): Ditto.\n\t(vect_prune_runtime_alias_test_list): Ditto.\n\t(vect_analyze_data_refs): Ditto.\n\t(vect_create_addr_base_for_vector_ref): Ditto.\n\t(vect_create_data_ref_ptr): Ditto.\n\t(vect_grouped_store_supported): Ditto.\n\t(vect_grouped_load_supported): Ditto.\n\t* value-prof.c (check_counter): Ditto.\n\t(check_ic_target): Ditto.\n\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Ditto.\n\t(vect_recog_widen_mult_pattern): Ditto.\n\t(vect_recog_widen_sum_pattern): Ditto.\n\t(vect_recog_over_widening_pattern): Ditto.\n\t(vect_recog_widen_shift_pattern): Ditto.\n\t(vect_recog_rotate_pattern): Ditto.\n\t(vect_recog_vector_vector_shift_pattern): Ditto.\n\t(vect_recog_divmod_pattern): Ditto.\n\t(vect_recog_mixed_size_cond_pattern): Ditto.\n\t(vect_recog_bool_pattern): Ditto.\n\t(vect_pattern_recog_1): Ditto.\n\t(vect_pattern_recog): Ditto.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor): Ditto.\n\t(vect_is_simple_iv_evolution): Ditto.\n\t(vect_analyze_scalar_cycles_1): Ditto.\n\t(vect_get_loop_niters): Ditto.\n\t(vect_analyze_loop_1): Ditto.\n\t(vect_analyze_loop_form): Ditto.\n\t(vect_analyze_loop_operations): Ditto.\n\t(vect_analyze_loop_2): Ditto.\n\t(vect_analyze_loop): Ditto.\n\t(report_vect_op): Ditto.\n\t(vect_is_slp_reduction): Ditto.\n\t(vect_is_simple_reduction_1): Ditto.\n\t(vect_get_known_peeling_cost): Ditto.\n\t(vect_estimate_min_profitable_iters): Ditto.\n\t(vect_model_reduction_cost): Ditto.\n\t(vect_model_induction_cost): Ditto.\n\t(get_initial_def_for_induction): Ditto.\n\t(vect_create_epilog_for_reduction): Ditto.\n\t(vectorizable_reduction): Ditto.\n\t(vectorizable_induction): Ditto.\n\t(vectorizable_live_operation): Ditto.\n\t(vect_loop_kill_debug_uses): Ditto.\n\t(vect_transform_loop): Ditto.\n\t* tree-vect-stmts.c (vect_mark_relevant): Ditto.\n\t(vect_stmt_relevant_p): Ditto.\n\t(process_use): Ditto.\n\t(vect_mark_stmts_to_be_vectorized): Ditto.\n\t(vect_model_simple_cost): Ditto.\n\t(vect_model_promotion_demotion_cost): Ditto.\n\t(vect_model_store_cost): Ditto.\n\t(vect_get_store_cost): Ditto.\n\t(vect_model_load_cost): Ditto.\n\t(vect_get_load_cost): Ditto.\n\t(vect_init_vector_1): Ditto.\n\t(vect_get_vec_def_for_operand): Ditto.\n\t(vect_finish_stmt_generation): Ditto.\n\t(vectorizable_call): Ditto.\n\t(vectorizable_conversion): Ditto.\n\t(vectorizable_assignment): Ditto.\n\t(vectorizable_shift): Ditto.\n\t(vectorizable_operation): Ditto.\n\t(vectorizable_store): Ditto.\n\t(vectorizable_load): Ditto.\n\t(vectorizable_condition): Ditto.\n\t(vect_analyze_stmt): Ditto.\n\t(vect_transform_stmt): Ditto.\n\t(vect_is_simple_use): Ditto.\n\t* tree-vect-loop-manip.c (slpeel_make_loop_iterate_ntimes): Ditto.\n\t(vect_can_advance_ivs_p): Ditto.\n\t(vect_update_ivs_after_vectorizer): Ditto.\n\t(vect_do_peeling_for_loop_bound): Ditto.\n\t(vect_gen_niters_for_prolog_loop): Ditto.\n\t(vect_update_inits_of_drs): Ditto.\n\t(vect_create_cond_for_alias_checks): Ditto.\n\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Ditto.\n\t(vect_build_slp_tree_1): Ditto.\n\t(vect_supported_load_permutation_p): Ditto.\n\t(vect_analyze_slp_instance): Ditto.\n\t(vect_analyze_slp): Ditto.\n\t(vect_make_slp_decision): Ditto.\n\t(vect_detect_hybrid_slp): Ditto.\n\t(vect_bb_vectorization_profitable_p): Ditto.\n\t(vect_slp_analyze_bb_1): Ditto.\n\t(vect_update_slp_costs_according_to_vf): Ditto.\n\t(vect_get_mask_element): Ditto.\n\t(vect_transform_slp_perm_load): Ditto.\n\t(vect_schedule_slp_instance): Ditto.\n\t(vect_schedule_slp): Ditto.\n\t(vect_slp_transform_bb): Ditto.\n\t* profile.c (read_profile_edge_counts): Ditto.\n\t(compute_branch_probabilities): Ditto.\n\t* coverage.c (get_coverage_counts): Ditto.\n\nFrom-SVN: r202628", "tree": {"sha": "d0b34aefca8799f106a9ab8fac724b1ac684375f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0b34aefca8799f106a9ab8fac724b1ac684375f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e645e94288a253da5ba9f14c599378a96348e4ea", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e645e94288a253da5ba9f14c599378a96348e4ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e645e94288a253da5ba9f14c599378a96348e4ea", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e645e94288a253da5ba9f14c599378a96348e4ea/comments", "author": {"login": "teresajohnson", "id": 20446403, "node_id": "MDQ6VXNlcjIwNDQ2NDAz", "avatar_url": "https://avatars.githubusercontent.com/u/20446403?v=4", "gravatar_id": "", "url": "https://api.github.com/users/teresajohnson", "html_url": "https://github.com/teresajohnson", "followers_url": "https://api.github.com/users/teresajohnson/followers", "following_url": "https://api.github.com/users/teresajohnson/following{/other_user}", "gists_url": "https://api.github.com/users/teresajohnson/gists{/gist_id}", "starred_url": "https://api.github.com/users/teresajohnson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/teresajohnson/subscriptions", "organizations_url": "https://api.github.com/users/teresajohnson/orgs", "repos_url": "https://api.github.com/users/teresajohnson/repos", "events_url": "https://api.github.com/users/teresajohnson/events{/privacy}", "received_events_url": "https://api.github.com/users/teresajohnson/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "46f851f38d9b62da2be628c031969e63842caf72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46f851f38d9b62da2be628c031969e63842caf72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46f851f38d9b62da2be628c031969e63842caf72"}], "stats": {"total": 1058, "additions": 667, "deletions": 391}, "files": [{"sha": "38cdaf0b34c5efe6611f45aaac23a22bcd9410f1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -1,3 +1,117 @@\n+2013-09-16  Teresa Johnson  <tejohnson@google.com>\n+\n+\t* dumpfile.c (dump_loc): Remove newline emission.\n+\t* tree-vect-data-refs.c (vect_lanes_optab_supported_p): Add newline\n+\temission to dump_printf_loc calls where missing.\n+\t(vect_mark_for_runtime_alias_test): Ditto.\n+\t(vect_analyze_data_ref_dependence): Ditto.\n+\t(vect_analyze_data_ref_dependences): Ditto.\n+\t(vect_slp_analyze_data_ref_dependence): Ditto.\n+\t(vect_slp_analyze_data_ref_dependences): Ditto.\n+\t(vect_compute_data_ref_alignment): Ditto.\n+\t(vect_update_misalignment_for_peel): Ditto.\n+\t(vect_verify_datarefs_alignment): Ditto.\n+\t(vector_alignment_reachable_p): Ditto.\n+\t(vect_get_data_access_cost): Ditto.\n+\t(vect_enhance_data_refs_alignment): Ditto.\n+\t(vect_find_same_alignment_drs): Ditto.\n+\t(vect_analyze_data_refs_alignment): Ditto.\n+\t(vect_analyze_group_access): Ditto.\n+\t(vect_analyze_data_ref_access): Ditto.\n+\t(vect_analyze_data_ref_accesses): Ditto.\n+\t(vect_prune_runtime_alias_test_list): Ditto.\n+\t(vect_analyze_data_refs): Ditto.\n+\t(vect_create_addr_base_for_vector_ref): Ditto.\n+\t(vect_create_data_ref_ptr): Ditto.\n+\t(vect_grouped_store_supported): Ditto.\n+\t(vect_grouped_load_supported): Ditto.\n+\t* value-prof.c (check_counter): Ditto.\n+\t(check_ic_target): Ditto.\n+\t* tree-vect-patterns.c (vect_recog_dot_prod_pattern): Ditto.\n+\t(vect_recog_widen_mult_pattern): Ditto.\n+\t(vect_recog_widen_sum_pattern): Ditto.\n+\t(vect_recog_over_widening_pattern): Ditto.\n+\t(vect_recog_widen_shift_pattern): Ditto.\n+\t(vect_recog_rotate_pattern): Ditto.\n+\t(vect_recog_vector_vector_shift_pattern): Ditto.\n+\t(vect_recog_divmod_pattern): Ditto.\n+\t(vect_recog_mixed_size_cond_pattern): Ditto.\n+\t(vect_recog_bool_pattern): Ditto.\n+\t(vect_pattern_recog_1): Ditto.\n+\t(vect_pattern_recog): Ditto.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor): Ditto.\n+\t(vect_is_simple_iv_evolution): Ditto.\n+\t(vect_analyze_scalar_cycles_1): Ditto.\n+\t(vect_get_loop_niters): Ditto.\n+\t(vect_analyze_loop_1): Ditto.\n+\t(vect_analyze_loop_form): Ditto.\n+\t(vect_analyze_loop_operations): Ditto.\n+\t(vect_analyze_loop_2): Ditto.\n+\t(vect_analyze_loop): Ditto.\n+\t(report_vect_op): Ditto.\n+\t(vect_is_slp_reduction): Ditto.\n+\t(vect_is_simple_reduction_1): Ditto.\n+\t(vect_get_known_peeling_cost): Ditto.\n+\t(vect_estimate_min_profitable_iters): Ditto.\n+\t(vect_model_reduction_cost): Ditto.\n+\t(vect_model_induction_cost): Ditto.\n+\t(get_initial_def_for_induction): Ditto.\n+\t(vect_create_epilog_for_reduction): Ditto.\n+\t(vectorizable_reduction): Ditto.\n+\t(vectorizable_induction): Ditto.\n+\t(vectorizable_live_operation): Ditto.\n+\t(vect_loop_kill_debug_uses): Ditto.\n+\t(vect_transform_loop): Ditto.\n+\t* tree-vect-stmts.c (vect_mark_relevant): Ditto.\n+\t(vect_stmt_relevant_p): Ditto.\n+\t(process_use): Ditto.\n+\t(vect_mark_stmts_to_be_vectorized): Ditto.\n+\t(vect_model_simple_cost): Ditto.\n+\t(vect_model_promotion_demotion_cost): Ditto.\n+\t(vect_model_store_cost): Ditto.\n+\t(vect_get_store_cost): Ditto.\n+\t(vect_model_load_cost): Ditto.\n+\t(vect_get_load_cost): Ditto.\n+\t(vect_init_vector_1): Ditto.\n+\t(vect_get_vec_def_for_operand): Ditto.\n+\t(vect_finish_stmt_generation): Ditto.\n+\t(vectorizable_call): Ditto.\n+\t(vectorizable_conversion): Ditto.\n+\t(vectorizable_assignment): Ditto.\n+\t(vectorizable_shift): Ditto.\n+\t(vectorizable_operation): Ditto.\n+\t(vectorizable_store): Ditto.\n+\t(vectorizable_load): Ditto.\n+\t(vectorizable_condition): Ditto.\n+\t(vect_analyze_stmt): Ditto.\n+\t(vect_transform_stmt): Ditto.\n+\t(vect_is_simple_use): Ditto.\n+\t* tree-vect-loop-manip.c (slpeel_make_loop_iterate_ntimes): Ditto.\n+\t(vect_can_advance_ivs_p): Ditto.\n+\t(vect_update_ivs_after_vectorizer): Ditto.\n+\t(vect_do_peeling_for_loop_bound): Ditto.\n+\t(vect_gen_niters_for_prolog_loop): Ditto.\n+\t(vect_update_inits_of_drs): Ditto.\n+\t(vect_create_cond_for_alias_checks): Ditto.\n+\t* tree-vect-slp.c (vect_get_and_check_slp_defs): Ditto.\n+\t(vect_build_slp_tree_1): Ditto.\n+\t(vect_supported_load_permutation_p): Ditto.\n+\t(vect_analyze_slp_instance): Ditto.\n+\t(vect_analyze_slp): Ditto.\n+\t(vect_make_slp_decision): Ditto.\n+\t(vect_detect_hybrid_slp): Ditto.\n+\t(vect_bb_vectorization_profitable_p): Ditto.\n+\t(vect_slp_analyze_bb_1): Ditto.\n+\t(vect_update_slp_costs_according_to_vf): Ditto.\n+\t(vect_get_mask_element): Ditto.\n+\t(vect_transform_slp_perm_load): Ditto.\n+\t(vect_schedule_slp_instance): Ditto.\n+\t(vect_schedule_slp): Ditto.\n+\t(vect_slp_transform_bb): Ditto.\n+\t* profile.c (read_profile_edge_counts): Ditto.\n+\t(compute_branch_probabilities): Ditto.\n+\t* coverage.c (get_coverage_counts): Ditto.\n+\n 2013-09-16  Diego Novillo  <dnovillo@google.com>\n \n \t* tree-core.h: Add missing comment lines from refactoring"}, {"sha": "e25c9425707ddf2e8b7113fc67f0146ba3089a0d", "filename": "gcc/coverage.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -349,7 +349,7 @@ get_coverage_counts (unsigned counter, unsigned expected,\n                          (flag_guess_branch_prob\n                           ? \"file %s not found, execution counts estimated\"\n                           : \"file %s not found, execution counts assumed to \"\n-                            \"be zero\"),\n+                            \"be zero\\n\"),\n                          da_file_name);\n       return NULL;\n     }\n@@ -379,20 +379,20 @@ get_coverage_counts (unsigned counter, unsigned expected,\n           dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n                            \"use -Wno-error=coverage-mismatch to tolerate \"\n                            \"the mismatch but performance may drop if the \"\n-                           \"function is hot\");\n+                           \"function is hot\\n\");\n \t  \n \t  if (!seen_error ()\n \t      && !warned++)\n \t    {\n \t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n-                               \"coverage mismatch ignored\");\n-\t      dump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n-                               flag_guess_branch_prob\n-                               ? G_(\"execution counts estimated\")\n-                               : G_(\"execution counts assumed to be zero\"));\n+                               \"coverage mismatch ignored\\n\");\n+\t      dump_printf (MSG_OPTIMIZED_LOCATIONS,\n+                           flag_guess_branch_prob\n+                           ? G_(\"execution counts estimated\\n\")\n+                           : G_(\"execution counts assumed to be zero\\n\"));\n \t      if (!flag_guess_branch_prob)\n-\t\tdump_printf_loc (MSG_OPTIMIZED_LOCATIONS, input_location,\n-                                 \"this can result in poorly optimized code\");\n+\t\tdump_printf (MSG_OPTIMIZED_LOCATIONS,\n+                             \"this can result in poorly optimized code\\n\");\n \t    }\n \t}\n "}, {"sha": "dc87ab35e8c87e575db08eb1788e53eac85bd99d", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -262,10 +262,10 @@ dump_loc (int dump_kind, FILE *dfile, source_location loc)\n   if (dump_kind)\n     {\n       if (LOCATION_LOCUS (loc) > BUILTINS_LOCATION)\n-        fprintf (dfile, \"\\n%s:%d:%d: note: \", LOCATION_FILE (loc),\n+        fprintf (dfile, \"%s:%d:%d: note: \", LOCATION_FILE (loc),\n                  LOCATION_LINE (loc), LOCATION_COLUMN (loc));\n       else if (current_function_decl)\n-        fprintf (dfile, \"\\n%s:%d:%d: note: \",\n+        fprintf (dfile, \"%s:%d:%d: note: \",\n                  DECL_SOURCE_FILE (current_function_decl),\n                  DECL_SOURCE_LINE (current_function_decl),\n                  DECL_SOURCE_COLUMN (current_function_decl));"}, {"sha": "94a3f07c6f35bc0a6c6db9cfdd2faff5e24af0ee", "filename": "gcc/profile.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -434,7 +434,8 @@ read_profile_edge_counts (gcov_type *exec_counts)\n \t\t\tstatic bool informed = 0;\n \t\t\tif (dump_enabled_p () && !informed)\n \t\t          dump_printf_loc (MSG_NOTE, input_location,\n-\t\t\t          \"corrupted profile info: edge count exceeds maximal count\");\n+                                           \"corrupted profile info: edge count\"\n+                                           \" exceeds maximal count\\n\");\n \t\t\tinformed = 1;\n \t\t      }\n \t\t    else\n@@ -696,7 +697,7 @@ compute_branch_probabilities (unsigned cfg_checksum, unsigned lineno_checksum)\n            {\n              informed = 1;\n              dump_printf_loc (MSG_NOTE, input_location,\n-                              \"correcting inconsistent profile data\");\n+                              \"correcting inconsistent profile data\\n\");\n            }\n          correct_negative_edge_counts ();\n          /* Set bb counts to the sum of the outgoing edge counts */"}, {"sha": "63dd36ad7eaaf46ee4518212901a3fc1d49376a5", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 154, "deletions": 112, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -59,8 +59,8 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n   if (array_mode == BLKmode)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\",\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"no array mode for %s[\" HOST_WIDE_INT_PRINT_DEC \"]\\n\",\n                          GET_MODE_NAME (mode), count);\n       return false;\n     }\n@@ -69,14 +69,14 @@ vect_lanes_optab_supported_p (const char *name, convert_optab optab,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"cannot use %s<%s><%s>\", name,\n+                         \"cannot use %s<%s><%s>\\n\", name,\n                          GET_MODE_NAME (array_mode), GET_MODE_NAME (mode));\n       return false;\n     }\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"can use %s<%s><%s>\", name, GET_MODE_NAME (array_mode),\n+                     \"can use %s<%s><%s>\\n\", name, GET_MODE_NAME (array_mode),\n                      GET_MODE_NAME (mode));\n \n   return true;\n@@ -182,22 +182,24 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr)));\n       dump_printf (MSG_NOTE,  \" and \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr)));\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   if (optimize_loop_nest_for_size_p (loop))\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"versioning not supported when optimizing for size.\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"versioning not supported when optimizing\"\n+                         \" for size.\\n\");\n       return false;\n     }\n \n   /* FORNOW: We don't support versioning with outer-loop vectorization.  */\n   if (loop->inner)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"versioning not yet supported for outer-loops.\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                         \"versioning not yet supported for outer-loops.\\n\");\n       return false;\n     }\n \n@@ -207,9 +209,9 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n       || TREE_CODE (DR_STEP (DDR_B (ddr))) != INTEGER_CST)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"versioning not yet supported for non-constant \"\n-                         \"step\");\n+                         \"step\\n\");\n       return false;\n     }\n \n@@ -276,6 +278,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n \t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t DR_REF (drb));\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \t  return true;\n \t}\n@@ -290,6 +293,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t     DR_REF (drb));\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n \n       /* Add to list of ddrs that need to be tested at run-time.  */\n@@ -321,18 +325,20 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n \t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t DR_REF (drb));\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \t  return true;\n \t}\n \n       if (dump_enabled_p ())\n         {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"versioning for alias required: \"\n                            \"bad dist vector for \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n           dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n       /* Add to list of ddrs that need to be tested at run-time.  */\n       return !vect_mark_for_runtime_alias_test (ddr, loop_vinfo);\n@@ -345,17 +351,18 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"dependence distance  = %d.\", dist);\n+                         \"dependence distance  = %d.\\n\", dist);\n \n       if (dist == 0)\n \t{\n \t  if (dump_enabled_p ())\n \t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \n-                               \"dependence distance == 0 between \");\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t                       \"dependence distance == 0 between \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n \t      dump_printf (MSG_NOTE, \" and \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n \t  /* When we perform grouped accesses and perform implicit CSE\n@@ -383,7 +390,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t     \"READ_WRITE dependence in interleaving.\");\n+\t\t\t\t     \"READ_WRITE dependence in interleaving.\"\n+\t\t\t\t     \"\\n\");\n \t\t  return true;\n \t\t}\n \t    }\n@@ -398,7 +406,7 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t     distance is negative.  */\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"dependence distance negative.\");\n+\t                     \"dependence distance negative.\\n\");\n \t  continue;\n \t}\n \n@@ -410,8 +418,8 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t  *max_vf = abs (dist);\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"adjusting maximal vectorization factor to %i\",\n-                             *max_vf);\n+\t                     \"adjusting maximal vectorization factor to %i\\n\",\n+\t                     *max_vf);\n \t}\n \n       if (abs (dist) >= *max_vf)\n@@ -420,18 +428,19 @@ vect_analyze_data_ref_dependence (struct data_dependence_relation *ddr,\n \t     vectorization is concerned, in this case.  */\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"dependence distance >= VF.\");\n+\t                     \"dependence distance >= VF.\\n\");\n \t  continue;\n \t}\n \n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                       \"not vectorized, possible dependence \"\n-                       \"between data-refs \");\n+\t               \"not vectorized, possible dependence \"\n+\t               \"between data-refs \");\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n \t  dump_printf (MSG_NOTE,  \" and \");\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+\t  dump_printf (MSG_NOTE,  \"\\n\");\n \t}\n \n       return true;\n@@ -454,7 +463,7 @@ vect_analyze_data_ref_dependences (loop_vec_info loop_vinfo, int *max_vf)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_ref_dependences ===\");\n+                     \"=== vect_analyze_data_ref_dependences ===\\n\");\n \n   if (!compute_all_dependences (LOOP_VINFO_DATAREFS (loop_vinfo),\n \t\t\t\t&LOOP_VINFO_DDRS (loop_vinfo),\n@@ -515,6 +524,7 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dra));\n           dump_printf (MSG_MISSED_OPTIMIZATION,  \" and \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (drb));\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION,  \"\\n\");\n         }\n \n       /* We do not vectorize basic blocks with write-write dependencies.  */\n@@ -536,6 +546,7 @@ vect_slp_analyze_data_ref_dependence (struct data_dependence_relation *ddr)\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n       dump_printf (MSG_NOTE, \" and \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+      dump_printf (MSG_NOTE,  \"\\n\");\n     }\n \n   /* Do not vectorize basic blocks with write-write dependences.  */\n@@ -600,7 +611,7 @@ vect_slp_analyze_data_ref_dependences (bb_vec_info bb_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_slp_analyze_data_ref_dependences ===\");\n+                     \"=== vect_slp_analyze_data_ref_dependences ===\\n\");\n \n   if (!compute_all_dependences (BB_VINFO_DATAREFS (bb_vinfo),\n \t\t\t\t&BB_VINFO_DDRS (bb_vinfo),\n@@ -643,7 +654,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_compute_data_ref_alignment:\");\n+                     \"vect_compute_data_ref_alignment:\\n\");\n \n   if (loop_vinfo)\n     loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -676,7 +687,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n         {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"inner step divides the vector-size.\");\n+                             \"inner step divides the vector-size.\\n\");\n \t  misalign = STMT_VINFO_DR_INIT (stmt_info);\n \t  aligned_to = STMT_VINFO_DR_ALIGNED_TO (stmt_info);\n \t  base_addr = STMT_VINFO_DR_BASE_ADDRESS (stmt_info);\n@@ -685,7 +696,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"inner step doesn't divide the vector-size.\");\n+\t                     \"inner step doesn't divide the vector-size.\\n\");\n \t  misalign = NULL_TREE;\n \t}\n     }\n@@ -703,8 +714,8 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       if (dr_step % GET_MODE_SIZE (TYPE_MODE (vectype)) != 0)\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                             \"SLP: step doesn't divide the vector-size.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                     \"SLP: step doesn't divide the vector-size.\\n\");\n \t  misalign = NULL_TREE;\n \t}\n     }\n@@ -718,8 +729,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       if (dump_enabled_p ())\n \t{\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"Unknown alignment for access: \");\n+\t                   \"Unknown alignment for access: \");\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, base);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n       return true;\n     }\n@@ -748,8 +760,9 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"can't force alignment of ref: \");\n+\t                       \"can't force alignment of ref: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t  return true;\n \t}\n@@ -761,6 +774,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"force alignment of \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, ref);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       ((dataref_aux *)dr->aux)->base_decl = base;\n@@ -788,7 +802,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       /* Negative or overflowed misalignment value.  */\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"unexpected misalign value\");\n+\t                 \"unexpected misalign value\\n\");\n       return false;\n     }\n \n@@ -799,6 +813,7 @@ vect_compute_data_ref_alignment (struct data_reference *dr)\n       dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                        \"misalign = %d bytes of ref \", DR_MISALIGNMENT (dr));\n       dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, ref);\n+      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n     }\n \n   return true;\n@@ -895,7 +910,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n     }\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"Setting misalignment to -1.\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"Setting misalignment to -1.\\n\");\n   SET_DR_MISALIGNMENT (dr, -1);\n }\n \n@@ -953,12 +968,13 @@ vect_verify_datarefs_alignment (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                  DR_REF (dr));\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n           return false;\n         }\n       if (supportable_dr_alignment != dr_aligned && dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"Vectorizing an unaligned access.\");\n+                         \"Vectorizing an unaligned access.\\n\");\n     }\n   return true;\n }\n@@ -1015,16 +1031,16 @@ vector_alignment_reachable_p (struct data_reference *dr)\n \t\tint_cst_value (TYPE_SIZE_UNIT (TREE_TYPE (vectype)));\n       if (dump_enabled_p ())\n \t{\n-\t  dump_printf_loc (MSG_NOTE, vect_location, \n-                           \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n-\t  dump_printf (MSG_NOTE, \n-                       \". misalignment = %d. \", DR_MISALIGNMENT (dr));\n+\t  dump_printf_loc (MSG_NOTE, vect_location,\n+\t                   \"data size =\" HOST_WIDE_INT_PRINT_DEC, elmsize);\n+\t  dump_printf (MSG_NOTE,\n+\t               \". misalignment = %d.\\n\", DR_MISALIGNMENT (dr));\n \t}\n       if (DR_MISALIGNMENT (dr) % elmsize)\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                             \"data size does not divide the misalignment.\\n\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                     \"data size does not divide the misalignment.\\n\");\n \t  return false;\n \t}\n     }\n@@ -1034,8 +1050,8 @@ vector_alignment_reachable_p (struct data_reference *dr)\n       tree type = TREE_TYPE (DR_REF (dr));\n       bool is_packed = not_size_aligned (DR_REF (dr));\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"Unknown misalignment, is_packed = %d\",is_packed);\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                 \"Unknown misalignment, is_packed = %d\\n\",is_packed);\n       if ((TYPE_USER_ALIGN (type) && !is_packed)\n \t  || targetm.vectorize.vector_alignment_reachable (type, is_packed))\n \treturn true;\n@@ -1071,7 +1087,7 @@ vect_get_data_access_cost (struct data_reference *dr,\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_get_data_access_cost: inside_cost = %d, \"\n-                     \"outside_cost = %d.\", *inside_cost, *outside_cost);\n+                     \"outside_cost = %d.\\n\", *inside_cost, *outside_cost);\n }\n \n \n@@ -1346,7 +1362,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_enhance_data_refs_alignment ===\");\n+                     \"=== vect_enhance_data_refs_alignment ===\\n\");\n \n   /* While cost model enhancements are expected in the future, the high level\n      view of the code at this time is as follows:\n@@ -1515,8 +1531,8 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           if (!aligned_access_p (dr))\n             {\n               if (dump_enabled_p ())\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                 \"vector alignment may not be reachable\");\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"vector alignment may not be reachable\\n\");\n               break;\n             }\n         }\n@@ -1652,7 +1668,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"Try peeling by %d\", npeel);\n+                             \"Try peeling by %d\\n\", npeel);\n         }\n \n       /* Ensure that all data refs can be vectorized after the peel.  */\n@@ -1725,9 +1741,9 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \t  if (dump_enabled_p ())\n             {\n               dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"Alignment of access forced using peeling.\");\n+                               \"Alignment of access forced using peeling.\\n\");\n               dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"Peeling for alignment will be applied.\");\n+                               \"Peeling for alignment will be applied.\\n\");\n             }\n \t  /* We've delayed passing the inside-loop peeling costs to the\n \t     target cost model until we were sure peeling would happen.\n@@ -1847,13 +1863,13 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n           dr = STMT_VINFO_DATA_REF (stmt_info);\n \t  SET_DR_MISALIGNMENT (dr, 0);\n \t  if (dump_enabled_p ())\n-            dump_printf_loc (MSG_NOTE, vect_location, \n-                             \"Alignment of access forced using versioning.\");\n+            dump_printf_loc (MSG_NOTE, vect_location,\n+                             \"Alignment of access forced using versioning.\\n\");\n         }\n \n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \n-                         \"Versioning for alignment will be applied.\");\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"Versioning for alignment will be applied.\\n\");\n \n       /* Peeling and versioning can't be done together at this time.  */\n       gcc_assert (! (do_peeling && do_versioning));\n@@ -1919,7 +1935,7 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n \n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"dependence distance  = %d.\", dist);\n+\t                 \"dependence distance  = %d.\\n\", dist);\n \n       /* Same loop iteration.  */\n       if (dist == 0\n@@ -1930,13 +1946,14 @@ vect_find_same_alignment_drs (struct data_dependence_relation *ddr,\n \t  STMT_VINFO_SAME_ALIGN_REFS (stmtinfo_b).safe_push (dra);\n \t  if (dump_enabled_p ())\n \t    {\n-              dump_printf_loc (MSG_NOTE, vect_location,\n-                               \"accesses have the same alignment.\");\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t                       \"accesses have the same alignment.\\n\");\n \t      dump_printf (MSG_NOTE,\n-                           \"dependence distance modulo vf == 0 between \");\n+\t                   \"dependence distance modulo vf == 0 between \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n \t      dump_printf (MSG_NOTE,  \" and \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t}\n     }\n@@ -1954,7 +1971,7 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n {\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_refs_alignment ===\");\n+                     \"=== vect_analyze_data_refs_alignment ===\\n\");\n \n   /* Mark groups of data references with same alignment using\n      data dependence information.  */\n@@ -1971,9 +1988,9 @@ vect_analyze_data_refs_alignment (loop_vec_info loop_vinfo,\n   if (!vect_compute_data_refs_alignment (loop_vinfo, bb_vinfo))\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"not vectorized: can't calculate alignment \"\n-                         \"for data ref.\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                 \"not vectorized: can't calculate alignment \"\n+\t                 \"for data ref.\\n\");\n       return false;\n     }\n \n@@ -2025,25 +2042,26 @@ vect_analyze_group_access (struct data_reference *dr)\n \t  GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n \t  if (dump_enabled_p ())\n \t    {\n-\t      dump_printf_loc (MSG_NOTE, vect_location, \n-                               \"Detected single element interleaving \");\n+\t      dump_printf_loc (MSG_NOTE, vect_location,\n+\t                       \"Detected single element interleaving \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr));\n \t      dump_printf (MSG_NOTE, \" step \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, step);\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  if (loop_vinfo)\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n-                                 \"Data access with gaps requires scalar \"\n-                                 \"epilogue loop\");\n+\t\t                 \"Data access with gaps requires scalar \"\n+\t\t                 \"epilogue loop\\n\");\n               if (loop->inner)\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                      \"Peeling for outer loop is not\"\n-                                     \" supported\");\n+                                     \" supported\\n\");\n                   return false;\n                 }\n \n@@ -2056,8 +2074,9 @@ vect_analyze_group_access (struct data_reference *dr)\n       if (dump_enabled_p ())\n         {\n  \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"not consecutive access \");\n-          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t                   \"not consecutive access \");\n+\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       if (bb_vinfo)\n@@ -2094,8 +2113,8 @@ vect_analyze_group_access (struct data_reference *dr)\n               if (DR_IS_WRITE (data_ref))\n                 {\n                   if (dump_enabled_p ())\n-                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                     \"Two store stmts share the same dr.\");\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                     \"Two store stmts share the same dr.\\n\");\n                   return false;\n                 }\n \n@@ -2124,8 +2143,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \t      if (DR_IS_WRITE (data_ref))\n \t\t{\n                   if (dump_enabled_p ())\n-                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                     \"interleaved store with gaps\");\n+                    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                     \"interleaved store with gaps\\n\");\n \t\t  return false;\n \t\t}\n \n@@ -2155,9 +2174,11 @@ vect_analyze_group_access (struct data_reference *dr)\n         {\n           if (dump_enabled_p ())\n             {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"interleaving size is greater than step for \");\n-              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, DR_REF (dr));\n+              dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+                                 DR_REF (dr));\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n           return false;\n         }\n@@ -2178,8 +2199,8 @@ vect_analyze_group_access (struct data_reference *dr)\n           else\n             {\n               if (dump_enabled_p ())\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                 \"interleaved store with gaps\");\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"interleaved store with gaps\\n\");\n               return false;\n             }\n         }\n@@ -2196,6 +2217,7 @@ vect_analyze_group_access (struct data_reference *dr)\n               dump_printf (MSG_MISSED_OPTIMIZATION, \" size \");\n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                  TYPE_SIZE_UNIT (scalar_type));\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n           return false;\n         }\n@@ -2205,8 +2227,8 @@ vect_analyze_group_access (struct data_reference *dr)\n \n       GROUP_SIZE (vinfo_for_stmt (stmt)) = groupsize;\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \n-                         \"Detected interleaving of size %d\", (int)groupsize);\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"Detected interleaving of size %d\\n\", (int)groupsize);\n \n       /* SLP: create an SLP data structure for every interleaving group of\n \t stores for further analysis in vect_analyse_slp.  */\n@@ -2223,13 +2245,13 @@ vect_analyze_group_access (struct data_reference *dr)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"Data access with gaps requires scalar \"\n-                             \"epilogue loop\");\n+\t                     \"Data access with gaps requires scalar \"\n+\t                     \"epilogue loop\\n\");\n           if (loop->inner)\n             {\n               if (dump_enabled_p ())\n-                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                                 \"Peeling for outer loop is not supported\");\n+                dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+                                 \"Peeling for outer loop is not supported\\n\");\n               return false;\n             }\n \n@@ -2261,8 +2283,8 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n   if (loop_vinfo && !step)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                         \"bad data-ref access in loop\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                 \"bad data-ref access in loop\\n\");\n       return false;\n     }\n \n@@ -2274,7 +2296,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"zero step in inner loop of nest\");\n+\t\t\t     \"zero step in inner loop of nest\\n\");\n \t  return false;\n \t}\n       return DR_IS_READ (dr);\n@@ -2292,7 +2314,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"zero step in outer loop.\");\n+\t                     \"zero step in outer loop.\\n\");\n \t  if (DR_IS_READ (dr))\n   \t    return true;\n \t  else\n@@ -2318,7 +2340,7 @@ vect_analyze_data_ref_access (struct data_reference *dr)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"grouped access in outer loop.\");\n+\t                 \"grouped access in outer loop.\\n\");\n       return false;\n     }\n \n@@ -2482,7 +2504,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_data_ref_accesses ===\");\n+                     \"=== vect_analyze_data_ref_accesses ===\\n\");\n \n   if (loop_vinfo)\n     datarefs = LOOP_VINFO_DATAREFS (loop_vinfo);\n@@ -2567,6 +2589,7 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dra));\n \t      dump_printf (MSG_NOTE,  \" and \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (drb));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  /* Link the found element into the group list.  */\n@@ -2586,8 +2609,8 @@ vect_analyze_data_ref_accesses (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n         && !vect_analyze_data_ref_access (dr))\n       {\n \tif (dump_enabled_p ())\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                           \"not vectorized: complicated access pattern.\");\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                   \"not vectorized: complicated access pattern.\\n\");\n \n         if (bb_vinfo)\n           {\n@@ -2617,7 +2640,7 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_prune_runtime_alias_test_list ===\");\n+                     \"=== vect_prune_runtime_alias_test_list ===\\n\");\n \n   for (i = 0; i < ddrs.length (); )\n     {\n@@ -2636,14 +2659,19 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n-                                   \"found equal ranges \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr_i)));\n+\t\t                   \"found equal ranges \");\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t                     DR_REF (DDR_A (ddr_i)));\n \t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr_i)));\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t                     DR_REF (DDR_B (ddr_i)));\n \t\t  dump_printf (MSG_NOTE,  \" and \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_A (ddr_j)));\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t                     DR_REF (DDR_A (ddr_j)));\n \t\t  dump_printf (MSG_NOTE,  \", \");\n-\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (DDR_B (ddr_j)));\n+\t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM,\n+\t\t                     DR_REF (DDR_B (ddr_j)));\n+\t\t  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \t      found = true;\n \t      break;\n@@ -2663,9 +2691,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \t{\n-\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location, \n-                           \"disable versioning for alias - max number of \"\n-                           \"generated checks exceeded.\");\n+\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n+\t                   \"disable versioning for alias - max number of \"\n+\t                   \"generated checks exceeded.\\n\");\n \t}\n \n       LOOP_VINFO_MAY_ALIAS_DDRS (loop_vinfo).truncate (0);\n@@ -2908,9 +2936,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t       (loop, &LOOP_VINFO_DATAREFS (loop_vinfo)))\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-                             \"not vectorized: loop contains function calls\"\n-                             \" or data references that cannot be analyzed\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t                     \"not vectorized: loop contains function calls\"\n+\t                     \" or data references that cannot be analyzed\\n\");\n \t  return false;\n \t}\n \n@@ -2957,7 +2985,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"not vectorized: unhandled data-ref \");\n+\t                     \"not vectorized: unhandled data-ref\\n\");\n           return false;\n         }\n \n@@ -3060,10 +3088,11 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t    {\n \t      if (dump_enabled_p ())\n \t\t{\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: data ref analysis \"\n                                    \"failed \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \n \t      if (bb_vinfo)\n@@ -3078,7 +3107,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"not vectorized: base addr of dr is a \"\n-                             \"constant\");\n+                             \"constant\\n\");\n \n           if (bb_vinfo)\n \t    break;\n@@ -3095,6 +3124,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: volatile type \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           if (bb_vinfo)\n@@ -3111,6 +3141,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                \"not vectorized: statement can throw an \"\n                                \"exception \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           if (bb_vinfo)\n@@ -3130,6 +3161,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                \"not vectorized: statement is bitfield \"\n                                \"access \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           if (bb_vinfo)\n@@ -3149,8 +3181,9 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION,  vect_location,\n-                               \"not vectorized: dr in a call \");\n+\t                       \"not vectorized: dr in a call \");\n \t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n \t  if (bb_vinfo)\n@@ -3190,6 +3223,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"analyze in outer-loop: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, inner_base);\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  outer_base = get_inner_reference (inner_base, &pbitsize, &pbitpos,\n@@ -3209,7 +3243,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                           &base_iv, false))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                  \"failed: evolution of base is not affine.\\n\");\n \t      return false;\n \t    }\n@@ -3232,7 +3266,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                &offset_iv, false))\n \t    {\n \t      if (dump_enabled_p ())\n-\t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                  \"evolution of offset is not affine.\\n\");\n \t      return false;\n \t    }\n@@ -3275,6 +3309,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      dump_printf (MSG_NOTE, \"\\n\\touter aligned to: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n                                  STMT_VINFO_DR_ALIGNED_TO (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t}\n \n@@ -3286,6 +3321,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                \"not vectorized: more than one data ref \"\n                                \"in stmt: \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           if (bb_vinfo)\n@@ -3311,12 +3347,13 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n         {\n           if (dump_enabled_p ())\n             {\n-              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+              dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                \"not vectorized: no vectype for stmt: \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n               dump_printf (MSG_MISSED_OPTIMIZATION, \" scalar_type: \");\n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_DETAILS,\n                                  scalar_type);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           if (bb_vinfo)\n@@ -3338,6 +3375,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM,\n \t\t\t\t STMT_VINFO_VECTYPE (stmt_info));\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t}\n \n@@ -3365,6 +3403,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                    \"not vectorized: not suitable for gather \"\n                                    \"load \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n@@ -3384,6 +3423,7 @@ vect_analyze_data_refs (loop_vec_info loop_vinfo,\n                                    \"not vectorized: not suitable for strided \"\n                                    \"load \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n@@ -3569,6 +3609,7 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"created \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, addr_base);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   return addr_base;\n@@ -3700,6 +3741,7 @@ vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n       else\n         dump_printf (MSG_NOTE, \"  vectorizing a pointer ref: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_BASE_OBJECT (dr));\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* (1) Create the new aggregate-pointer variable.\n@@ -4005,7 +4047,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"the size of the group of accesses\"\n-                         \" is not a power of 2\");\n+                         \" is not a power of 2\\n\");\n       return false;\n     }\n \n@@ -4030,7 +4072,7 @@ vect_grouped_store_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \n   if (dump_enabled_p ())\n     dump_printf (MSG_MISSED_OPTIMIZATION,\n-                 \"interleave op not supported by target.\");\n+                 \"interleave op not supported by target.\\n\");\n   return false;\n }\n \n@@ -4452,7 +4494,7 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"the size of the group of accesses\"\n-                         \" is not a power of 2\");\n+                         \" is not a power of 2\\n\");\n       return false;\n     }\n \n@@ -4475,7 +4517,7 @@ vect_grouped_load_supported (tree vectype, unsigned HOST_WIDE_INT count)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                     \"extract even/odd not supported by target\");\n+                     \"extract even/odd not supported by target\\n\");\n   return false;\n }\n "}, {"sha": "bd77473e9a30c8064edae78434223fc7b84b6395", "filename": "gcc/tree-vect-loop-manip.c", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop-manip.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -683,6 +683,7 @@ slpeel_make_loop_iterate_ntimes (struct loop *loop, tree niters)\n \tdump_printf (MSG_NOTE, \"\\nloop at %s:%d: \", LOC_FILE (loop_loc),\n \t\t     LOC_LINE (loop_loc));\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, cond_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n   loop->nb_iterations = niters;\n }\n@@ -1552,7 +1553,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n   /* Analyze phi functions of the loop header.  */\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"vect_can_advance_ivs_p:\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"vect_can_advance_ivs_p:\\n\");\n   for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n     {\n       tree evolution_part;\n@@ -1562,6 +1563,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Skip virtual phi's. The data dependences that are associated with\n@@ -1571,7 +1573,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"virtual phi. skip.\");\n+                             \"virtual phi. skip.\\n\");\n \t  continue;\n \t}\n \n@@ -1581,7 +1583,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n         {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"reduc phi. skip.\");\n+                             \"reduc phi. skip.\\n\");\n           continue;\n         }\n \n@@ -1593,7 +1595,7 @@ vect_can_advance_ivs_p (loop_vec_info loop_vinfo)\n         {\n \t  if (dump_enabled_p ())\n \t    dump_printf (MSG_MISSED_OPTIMIZATION,\n-\t\t\t \"No access function or evolution.\");\n+\t\t\t \"No access function or evolution.\\n\");\n \t  return false;\n         }\n \n@@ -1682,14 +1684,15 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_update_ivs_after_vectorizer: phi: \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       /* Skip virtual phi's.  */\n       if (virtual_operand_p (PHI_RESULT (phi)))\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"virtual phi. skip.\");\n+                             \"virtual phi. skip.\\n\");\n \t  continue;\n \t}\n \n@@ -1699,7 +1702,7 @@ vect_update_ivs_after_vectorizer (loop_vec_info loop_vinfo, tree niters,\n         {\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"reduc phi. skip.\");\n+                             \"reduc phi. skip.\\n\");\n           continue;\n         }\n \n@@ -1762,7 +1765,7 @@ vect_do_peeling_for_loop_bound (loop_vec_info loop_vinfo, tree *ratio,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_do_peeling_for_loop_bound ===\");\n+                     \"=== vect_do_peeling_for_loop_bound ===\\n\");\n \n   initialize_original_copy_tables ();\n \n@@ -1881,7 +1884,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"known peeling = %d.\", npeel);\n+                         \"known peeling = %d.\\n\", npeel);\n \n       iters = build_int_cst (niters_type, npeel);\n       *bound = LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo);\n@@ -1938,6 +1941,7 @@ vect_gen_niters_for_prolog_loop (loop_vec_info loop_vinfo, tree loop_niters, int\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"niters for prolog loop: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, iters);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   var = create_tmp_var (niters_type, \"prolog_loop_niters\");\n@@ -1993,7 +1997,7 @@ vect_update_inits_of_drs (loop_vec_info loop_vinfo, tree niters)\n  \n  if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_update_inits_of_dr ===\");\n+                     \"=== vect_update_inits_of_dr ===\\n\");\n \n   FOR_EACH_VEC_ELT (datarefs, i, dr)\n     vect_update_init_of_dr (dr, niters);\n@@ -2338,6 +2342,7 @@ vect_create_cond_for_alias_checks (loop_vec_info loop_vinfo, tree * cond_expr)\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_a));\n \t  dump_printf (MSG_NOTE, \" and \");\n \t  dump_generic_expr (MSG_NOTE, TDF_SLIM, DR_REF (dr_b));\n+          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       seg_a_min = addr_base_a;"}, {"sha": "2871ba1ce751501f37f577acc46aad16a4ebcbb0", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 171, "deletions": 124, "changes": 295, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -188,7 +188,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_determine_vectorization_factor ===\");\n+                     \"=== vect_determine_vectorization_factor ===\\n\");\n \n   for (i = 0; i < nbbs; i++)\n     {\n@@ -202,6 +202,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"==> examining phi: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+\t      dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  gcc_assert (stmt_info);\n@@ -216,6 +217,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"get vectype for scalar type:  \");\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n@@ -228,6 +230,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                                        \"data-type \");\n \t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                          scalar_type);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t    }\n \t\t  return false;\n \t\t}\n@@ -237,11 +240,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n \t      nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\\n\",\n+                                 nunits);\n \n \t      if (!vectorization_factor\n \t\t  || (nunits > vectorization_factor))\n@@ -265,6 +270,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"==> examining statement: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  gcc_assert (stmt_info);\n@@ -286,12 +292,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                       dump_printf_loc (MSG_NOTE, vect_location,\n                                        \"==> examining pattern statement: \");\n                       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+                      dump_printf (MSG_NOTE, \"\\n\");\n                     }\n                 }\n               else\n \t        {\n \t          if (dump_enabled_p ())\n-\t            dump_printf_loc (MSG_NOTE, vect_location, \"skip.\");\n+\t            dump_printf_loc (MSG_NOTE, vect_location, \"skip.\\n\");\n                   gsi_next (&si);\n \t          continue;\n                 }\n@@ -336,6 +343,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                                            \"==> examining pattern def stmt: \");\n \t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n                                             pattern_def_stmt, 0);\n+                          dump_printf (MSG_NOTE, \"\\n\");\n \t\t\t}\n \n \t\t      stmt = pattern_def_stmt;\n@@ -359,6 +367,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                                    \"not vectorized: irregular stmt.\");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n                                     0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n@@ -370,6 +379,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                    \"not vectorized: vector stmt in loop:\");\n \t          dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t        }\n \t      return false;\n \t    }\n@@ -394,6 +404,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"get vectype for scalar type:  \");\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \t      vectype = get_vectype_for_scalar_type (scalar_type);\n \t      if (!vectype)\n@@ -405,6 +416,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                                        \"data-type \");\n \t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                          scalar_type);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t    }\n \t\t  return false;\n \t\t}\n@@ -415,6 +427,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n \t\t  dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n             }\n \n@@ -428,6 +441,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"get vectype for scalar type:  \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t  vf_vectype = get_vectype_for_scalar_type (scalar_type);\n \t  if (!vf_vectype)\n@@ -438,6 +452,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n                                    \"not vectorized: unsupported data-type \");\n \t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                      scalar_type);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n@@ -455,6 +470,7 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n \t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                      vf_vectype);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      return false;\n \t    }\n@@ -463,11 +479,12 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"vectype: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, vf_vectype);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  nunits = TYPE_VECTOR_SUBPARTS (vf_vectype);\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\", nunits);\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"nunits = %d\\n\", nunits);\n \t  if (!vectorization_factor\n \t      || (nunits > vectorization_factor))\n \t    vectorization_factor = nunits;\n@@ -482,13 +499,13 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \n   /* TODO: Analyze cost. Decide if worth while to vectorize.  */\n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = %d\",\n+    dump_printf_loc (MSG_NOTE, vect_location, \"vectorization factor = %d\\n\",\n                      vectorization_factor);\n   if (vectorization_factor <= 1)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: unsupported data-type\");\n+                         \"not vectorized: unsupported data-type\\n\");\n       return false;\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n@@ -530,6 +547,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, step_expr);\n       dump_printf (MSG_NOTE, \",  init: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, init_expr);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   *init = init_expr;\n@@ -547,7 +565,7 @@ vect_is_simple_iv_evolution (unsigned loop_nb, tree access_fn, tree * init,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"step unknown.\");\n+                         \"step unknown.\\n\");\n       return false;\n     }\n \n@@ -573,7 +591,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_analyze_scalar_cycles ===\");\n+                     \"=== vect_analyze_scalar_cycles ===\\n\");\n \n   /* First - identify all inductions.  Reduction detection assumes that all the\n      inductions have been identified, therefore, this order must not be\n@@ -589,6 +607,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Skip virtual phi's.  The data dependences that are associated with\n@@ -608,6 +627,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"Access function of PHI: \");\n \t      dump_generic_expr (MSG_NOTE, TDF_SLIM, access_fn);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t  STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo)\n \t    = evolution_part_in_loop_num (access_fn, loop->num);\n@@ -625,7 +645,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       gcc_assert (STMT_VINFO_LOOP_PHI_EVOLUTION_PART (stmt_vinfo) != NULL_TREE);\n \n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"Detected induction.\");\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"Detected induction.\\n\");\n       STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_induction_def;\n     }\n \n@@ -643,6 +663,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"Analyze phi: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       gcc_assert (!virtual_operand_p (def)\n@@ -657,7 +678,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n             {\n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t \"Detected double reduction.\");\n+\t\t\t\t \"Detected double reduction.\\n\");\n \n               STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_double_reduction_def;\n               STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n@@ -669,7 +690,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"Detected vectorizable nested cycle.\");\n+\t\t\t\t     \"Detected vectorizable nested cycle.\\n\");\n \n                   STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_nested_cycle;\n                   STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n@@ -679,7 +700,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"Detected reduction.\");\n+\t\t\t\t     \"Detected reduction.\\n\");\n \n                   STMT_VINFO_DEF_TYPE (stmt_vinfo) = vect_reduction_def;\n                   STMT_VINFO_DEF_TYPE (vinfo_for_stmt (reduc_stmt)) =\n@@ -693,7 +714,7 @@ vect_analyze_scalar_cycles_1 (loop_vec_info loop_vinfo, struct loop *loop)\n       else\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t   \"Unknown def-use cycle pattern.\");\n+\t\t\t   \"Unknown def-use cycle pattern.\\n\");\n     }\n \n   worklist.release ();\n@@ -755,7 +776,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== get_loop_niters ===\");\n+\t\t     \"=== get_loop_niters ===\\n\");\n   niters = number_of_exit_cond_executions (loop);\n \n   if (niters != NULL_TREE\n@@ -767,6 +788,7 @@ vect_get_loop_niters (struct loop *loop, tree *number_of_iterations)\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"==> get_loop_niters:\");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, *number_of_iterations);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n \n@@ -996,7 +1018,7 @@ vect_analyze_loop_1 (struct loop *loop)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"===== analyze_loop_nest_1 =====\");\n+\t\t     \"===== analyze_loop_nest_1 =====\\n\");\n \n   /* Check the CFG characteristics of the loop (nesting, entry/exit, etc.  */\n \n@@ -1005,7 +1027,7 @@ vect_analyze_loop_1 (struct loop *loop)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad inner-loop form.\");\n+\t\t\t \"bad inner-loop form.\\n\");\n       return NULL;\n     }\n \n@@ -1031,7 +1053,7 @@ vect_analyze_loop_form (struct loop *loop)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_loop_form ===\");\n+\t\t     \"=== vect_analyze_loop_form ===\\n\");\n \n   /* Different restrictions apply when we are considering an inner-most loop,\n      vs. an outer (nested) loop.\n@@ -1055,15 +1077,15 @@ vect_analyze_loop_form (struct loop *loop)\n         {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: control flow in loop.\");\n+\t\t\t     \"not vectorized: control flow in loop.\\n\");\n           return NULL;\n         }\n \n       if (empty_block_p (loop->header))\n     {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: empty loop.\");\n+\t\t\t     \"not vectorized: empty loop.\\n\");\n       return NULL;\n     }\n     }\n@@ -1093,7 +1115,7 @@ vect_analyze_loop_form (struct loop *loop)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: multiple nested loops.\");\n+\t\t\t     \"not vectorized: multiple nested loops.\\n\");\n \t  return NULL;\n \t}\n \n@@ -1103,16 +1125,17 @@ vect_analyze_loop_form (struct loop *loop)\n \t{\n \t  if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: Bad inner loop.\");\n+\t\t\t     \"not vectorized: Bad inner loop.\\n\");\n \t  return NULL;\n \t}\n \n       if (!expr_invariant_in_loop_p (loop,\n \t\t\t\t\tLOOP_VINFO_NITERS (inner_loop_vinfo)))\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: inner-loop count not invariant.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: inner-loop count not\"\n+                             \" invariant.\\n\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n@@ -1121,7 +1144,7 @@ vect_analyze_loop_form (struct loop *loop)\n         {\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: control flow in loop.\");\n+\t\t\t     \"not vectorized: control flow in loop.\\n\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n         }\n@@ -1136,15 +1159,15 @@ vect_analyze_loop_form (struct loop *loop)\n \t  || single_exit (innerloop)->dest !=  EDGE_PRED (loop->latch, 0)->src)\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: unsupported outerloop form.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: unsupported outerloop form.\\n\");\n \t  destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n \t}\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Considering outer-loop vectorization.\");\n+\t\t\t \"Considering outer-loop vectorization.\\n\");\n     }\n \n   if (!single_exit (loop)\n@@ -1154,10 +1177,10 @@ vect_analyze_loop_form (struct loop *loop)\n         {\n           if (!single_exit (loop))\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not vectorized: multiple exits.\");\n+\t\t\t     \"not vectorized: multiple exits.\\n\");\n           else if (EDGE_COUNT (loop->header->preds) != 2)\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: too many incoming edges.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: too many incoming edges.\\n\");\n         }\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n@@ -1173,7 +1196,7 @@ vect_analyze_loop_form (struct loop *loop)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: latch block not empty.\");\n+\t\t\t \"not vectorized: latch block not empty.\\n\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1187,13 +1210,13 @@ vect_analyze_loop_form (struct loop *loop)\n \t{\n \t  split_loop_exit_edge (e);\n \t  if (dump_enabled_p ())\n-\t    dump_printf (MSG_NOTE, \"split exit edge.\");\n+\t    dump_printf (MSG_NOTE, \"split exit edge.\\n\");\n \t}\n       else\n \t{\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: abnormal loop exit edge.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: abnormal loop exit edge.\\n\");\n \t  if (inner_loop_vinfo)\n \t    destroy_loop_vec_info (inner_loop_vinfo, true);\n \t  return NULL;\n@@ -1204,8 +1227,8 @@ vect_analyze_loop_form (struct loop *loop)\n   if (!loop_cond)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t \"not vectorized: complicated exit condition.\");\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"not vectorized: complicated exit condition.\\n\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1214,9 +1237,9 @@ vect_analyze_loop_form (struct loop *loop)\n   if (!number_of_iterations)\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: number of iterations cannot be \"\n-\t\t\t \"computed.\");\n+\t\t\t \"computed.\\n\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1226,7 +1249,7 @@ vect_analyze_loop_form (struct loop *loop)\n     {\n       if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"Infinite number of iterations.\");\n+\t\t\t     \"Infinite number of iterations.\\n\");\n       if (inner_loop_vinfo)\n \tdestroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1239,13 +1262,14 @@ vect_analyze_loop_form (struct loop *loop)\n           dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t   \"Symbolic number of iterations is \");\n \t  dump_generic_expr (MSG_NOTE, TDF_DETAILS, number_of_iterations);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n   else if (TREE_INT_CST_LOW (number_of_iterations) == 0)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: number of iterations = 0.\");\n+\t\t\t \"not vectorized: number of iterations = 0.\\n\");\n       if (inner_loop_vinfo)\n         destroy_loop_vec_info (inner_loop_vinfo, true);\n       return NULL;\n@@ -1293,7 +1317,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_analyze_loop_operations ===\");\n+\t\t     \"=== vect_analyze_loop_operations ===\\n\");\n \n   gcc_assert (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   vectorization_factor = LOOP_VINFO_VECT_FACTOR (loop_vinfo);\n@@ -1329,7 +1353,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Updating vectorization factor to %d \",\n+\t\t\t \"Updating vectorization factor to %d\\n\",\n \t\t\t vectorization_factor);\n     }\n \n@@ -1347,6 +1371,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n             {\n               dump_printf_loc (MSG_NOTE, vect_location, \"examining phi: \");\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n             }\n \n           /* Inner-loop loop-closed exit phi in outer-loop vectorization\n@@ -1363,9 +1388,9 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n                      != vect_double_reduction_def)\n                 {\n                   if (dump_enabled_p ())\n-\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t     \"Unsupported loop-closed phi in \"\n-\t\t\t\t     \"outer-loop.\");\n+\t\t\t\t     \"outer-loop.\\n\");\n                   return false;\n                 }\n \n@@ -1406,7 +1431,7 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n               /* FORNOW: not yet supported.  */\n               if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"not vectorized: value used after loop.\");\n+\t\t\t\t \"not vectorized: value used after loop.\\n\");\n               return false;\n             }\n \n@@ -1415,8 +1440,8 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n             {\n               /* A scalar-dependence cycle that we don't support.  */\n               if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t\t \"not vectorized: scalar dependence cycle.\");\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: scalar dependence cycle.\\n\");\n               return false;\n             }\n \n@@ -1431,10 +1456,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n             {\n               if (dump_enabled_p ())\n                 {\n-\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"not vectorized: relevant phi not \"\n \t\t\t\t   \"supported: \");\n                   dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, phi, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                 }\n \t      return false;\n             }\n@@ -1458,18 +1484,18 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"All the computation can be taken out of the loop.\");\n+\t\t\t \"All the computation can be taken out of the loop.\\n\");\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: redundant loop. no profit to \"\n-\t\t\t \"vectorize.\");\n+\t\t\t \"vectorize.\\n\");\n       return false;\n     }\n \n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo) && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"vectorization_factor = %d, niters = \"\n-\t\t     HOST_WIDE_INT_PRINT_DEC, vectorization_factor,\n+\t\t     HOST_WIDE_INT_PRINT_DEC \"\\n\", vectorization_factor,\n \t\t     LOOP_VINFO_INT_NITERS (loop_vinfo));\n \n   if ((LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo)\n@@ -1479,11 +1505,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: iteration count too small.\");\n+\t\t\t \"not vectorized: iteration count too small.\\n\");\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: iteration count smaller than \"\n-\t\t\t \"vectorization factor.\");\n+\t\t\t \"vectorization factor.\\n\");\n       return false;\n     }\n \n@@ -1501,11 +1527,11 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\");\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: vector version will never be \"\n-\t\t\t \"profitable.\");\n+\t\t\t \"profitable.\\n\");\n       return false;\n     }\n \n@@ -1527,12 +1553,12 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"not vectorized: vectorization not profitable.\");\n+\t\t\t \"not vectorized: vectorization not profitable.\\n\");\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"not vectorized: iteration count smaller than user \"\n \t\t\t \"specified loop bound parameter or minimum profitable \"\n-\t\t\t \"iterations (whichever is more conservative).\");\n+\t\t\t \"iterations (whichever is more conservative).\\n\");\n       return false;\n     }\n \n@@ -1543,13 +1569,13 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: estimated iteration count too \"\n-                         \"small.\");\n+                         \"small.\\n\");\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"not vectorized: estimated iteration count smaller \"\n                          \"than specified loop bound parameter or minimum \"\n                          \"profitable iterations (whichever is more \"\n-                         \"conservative).\");\n+                         \"conservative).\\n\");\n       return false;\n     }\n \n@@ -1558,19 +1584,19 @@ vect_analyze_loop_operations (loop_vec_info loop_vinfo, bool slp)\n       || LOOP_PEELING_FOR_ALIGNMENT (loop_vinfo))\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required.\");\n+        dump_printf_loc (MSG_NOTE, vect_location, \"epilog loop required.\\n\");\n       if (!vect_can_advance_ivs_p (loop_vinfo))\n         {\n           if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: can't create epilog loop 1.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: can't create epilog loop 1.\\n\");\n           return false;\n         }\n       if (!slpeel_can_duplicate_loop_p (loop, single_exit (loop)))\n         {\n           if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n-\t\t\t     \"not vectorized: can't create epilog loop 2.\");\n+\t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t     \"not vectorized: can't create epilog loop 2.\\n\");\n           return false;\n         }\n     }\n@@ -1603,7 +1629,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data references.\");\n+\t\t\t \"bad data references.\\n\");\n       return false;\n     }\n \n@@ -1615,7 +1641,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data access.\");\n+\t\t\t \"bad data access.\\n\");\n       return false;\n     }\n \n@@ -1633,7 +1659,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"unexpected pattern.\");\n+\t\t\t \"unexpected pattern.\\n\");\n       return false;\n     }\n \n@@ -1648,7 +1674,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"bad data dependence.\");\n+\t\t\t     \"bad data dependence.\\n\");\n       return false;\n     }\n \n@@ -1657,14 +1683,14 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"can't determine vectorization factor.\");\n+\t\t\t \"can't determine vectorization factor.\\n\");\n       return false;\n     }\n   if (max_vf < LOOP_VINFO_VECT_FACTOR (loop_vinfo))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data dependence.\");\n+\t\t\t \"bad data dependence.\\n\");\n       return false;\n     }\n \n@@ -1676,7 +1702,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data alignment.\");\n+\t\t\t \"bad data alignment.\\n\");\n       return false;\n     }\n \n@@ -1689,7 +1715,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"too long list of versioning for alias \"\n-\t\t\t \"run-time tests.\");\n+\t\t\t \"run-time tests.\\n\");\n       return false;\n     }\n \n@@ -1701,7 +1727,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad data alignment.\");\n+\t\t\t \"bad data alignment.\\n\");\n       return false;\n     }\n \n@@ -1726,7 +1752,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"bad operation or unsupported loop bound.\");\n+\t\t\t \"bad operation or unsupported loop bound.\\n\");\n       return false;\n     }\n \n@@ -1750,15 +1776,15 @@ vect_analyze_loop (struct loop *loop)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"===== analyze_loop_nest =====\");\n+\t\t     \"===== analyze_loop_nest =====\\n\");\n \n   if (loop_outer (loop)\n       && loop_vec_info_for_loop (loop_outer (loop))\n       && LOOP_VINFO_VECTORIZABLE_P (loop_vec_info_for_loop (loop_outer (loop))))\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"outer-loop already vectorized.\");\n+\t\t\t \"outer-loop already vectorized.\\n\");\n       return NULL;\n     }\n \n@@ -1770,7 +1796,7 @@ vect_analyze_loop (struct loop *loop)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"bad loop form.\");\n+\t\t\t     \"bad loop form.\\n\");\n \t  return NULL;\n \t}\n \n@@ -1851,6 +1877,7 @@ report_vect_op (int msg_type, gimple stmt, const char *msg)\n {\n   dump_printf_loc (msg_type, vect_location, \"%s\", msg);\n   dump_gimple_stmt (msg_type, TDF_SLIM, stmt, 0);\n+  dump_printf (msg_type, \"\\n\");\n }\n \n \n@@ -2026,6 +2053,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple phi, gimple first_stmt)\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location, \"swapping oprnds: \");\n \t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, next_stmt, 0);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n \t      swap_tree_operands (next_stmt,\n@@ -2126,7 +2154,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"intermediate value used outside loop.\");\n+\t\t\t     \"intermediate value used outside loop.\\n\");\n \n           return NULL;\n         }\n@@ -2138,7 +2166,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduction used in loop.\");\n+\t\t\t     \"reduction used in loop.\\n\");\n           return NULL;\n         }\n     }\n@@ -2150,6 +2178,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"reduction: not ssa_name: \");\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, loop_arg);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n       return NULL;\n     }\n@@ -2159,14 +2188,17 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"reduction: no def_stmt.\");\n+\t\t\t \"reduction: no def_stmt.\\n\");\n       return NULL;\n     }\n \n   if (!is_gimple_assign (def_stmt) && gimple_code (def_stmt) != GIMPLE_PHI)\n     {\n       if (dump_enabled_p ())\n-        dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n+        {\n+          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n+        }\n       return NULL;\n     }\n \n@@ -2195,7 +2227,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduction used in loop.\");\n+\t\t\t     \"reduction used in loop.\\n\");\n \t  return NULL;\n \t}\n     }\n@@ -2211,7 +2243,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported phi node definition.\");\n+\t\t\t     \"unsupported phi node definition.\\n\");\n \n           return NULL;\n         }\n@@ -2334,6 +2366,7 @@ vect_is_simple_reduction_1 (loop_vec_info loop_info, gimple phi,\n               dump_generic_expr (MSG_NOTE, TDF_SLIM,\n \t\t\t\t TREE_TYPE (op4));\n             }\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       return NULL;\n@@ -2591,7 +2624,7 @@ vect_get_known_peeling_cost (loop_vec_info loop_vinfo, int peel_iters_prologue,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"cost model: epilogue peel iters set to vf/2 \"\n-\t\t\t \"because loop iterations are unknown .\");\n+\t\t\t \"because loop iterations are unknown .\\n\");\n \n       /* If peeled iterations are known but number of scalar loop\n          iterations are unknown, count a taken branch per peeled loop.  */\n@@ -2649,7 +2682,7 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n   /* Cost model disabled.  */\n   if (!flag_vect_cost_model)\n     {\n-      dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\");\n+      dump_printf_loc (MSG_NOTE, vect_location, \"cost model disabled.\\n\");\n       *ret_min_profitable_niters = 0;\n       *ret_min_profitable_estimate = 0;\n       return;\n@@ -2707,14 +2740,14 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n     {\n       peel_iters_prologue = vf/2;\n       dump_printf (MSG_NOTE, \"cost model: \"\n-                   \"prologue peel iters set to vf/2.\");\n+                   \"prologue peel iters set to vf/2.\\n\");\n \n       /* If peeling for alignment is unknown, loop bound of main loop becomes\n          unknown.  */\n       peel_iters_epilogue = vf/2;\n       dump_printf (MSG_NOTE, \"cost model: \"\n                    \"epilogue peel iters set to vf/2 because \"\n-                   \"peeling for alignment is unknown.\");\n+                   \"peeling for alignment is unknown.\\n\");\n \n       /* If peeled iterations are unknown, count a taken branch and a not taken\n          branch per peeled loop. Even if scalar loop iterations are known,\n@@ -2884,7 +2917,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"cost model: the vector iteration cost = %d \"\n \t\t\t \"divided by the scalar iteration cost = %d \"\n-\t\t\t \"is greater or equal to the vectorization factor = %d.\",\n+\t\t\t \"is greater or equal to the vectorization factor = %d\"\n+                         \".\\n\",\n \t\t\t vec_inside_cost, scalar_single_iter_cost, vf);\n       *ret_min_profitable_niters = -1;\n       *ret_min_profitable_estimate = -1;\n@@ -2910,9 +2944,10 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n                    peel_iters_prologue);\n       dump_printf (MSG_NOTE, \"  epilogue iterations: %d\\n\",\n                    peel_iters_epilogue);\n-      dump_printf (MSG_NOTE, \n+      dump_printf (MSG_NOTE,\n                    \"  Calculated minimum iters for profitability: %d\\n\",\n                    min_profitable_iters);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   min_profitable_iters =\n@@ -2925,7 +2960,8 @@ vect_estimate_min_profitable_iters (loop_vec_info loop_vinfo,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"  Runtime profitability threshold = %d\\n\", min_profitable_iters);\n+                     \"  Runtime profitability threshold = %d\\n\",\n+                     min_profitable_iters);\n \n   *ret_min_profitable_niters = min_profitable_iters;\n \n@@ -3014,6 +3050,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n \t\t\t   \"unsupported data-type \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t     TREE_TYPE (reduction_op));\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n       return false;\n    }\n@@ -3082,7 +3119,7 @@ vect_model_reduction_cost (stmt_vec_info stmt_info, enum tree_code reduc_code,\n   if (dump_enabled_p ())\n     dump_printf (MSG_NOTE, \n                  \"vect_model_reduction_cost: inside_cost = %d, \"\n-                 \"prologue_cost = %d, epilogue_cost = %d .\", inside_cost,\n+                 \"prologue_cost = %d, epilogue_cost = %d .\\n\", inside_cost,\n                  prologue_cost, epilogue_cost);\n \n   return true;\n@@ -3111,7 +3148,7 @@ vect_model_induction_cost (stmt_vec_info stmt_info, int ncopies)\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_induction_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n \n@@ -3258,6 +3295,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t   \"created new init_stmt: \");\n \t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, init_stmt, 0);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \t      constant_p = false;\n \t    }\n@@ -3426,6 +3464,7 @@ get_initial_def_for_induction (gimple iv_phi)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"vector of inductions after inner-loop:\");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t}\n     }\n@@ -3439,6 +3478,7 @@ get_initial_def_for_induction (gimple iv_phi)\n       dump_printf (MSG_NOTE, \"\\n\");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n \t\t\tSSA_NAME_DEF_STMT (vec_def), 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   STMT_VINFO_VEC_STMT (phi_info) = induction_phi;\n@@ -3846,6 +3886,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n               dump_printf (MSG_NOTE, \"\\n\");\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, SSA_NAME_DEF_STMT (def), 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n             }\n \n           phi = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (phi));\n@@ -4042,7 +4083,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Reduce using direct vector reduction.\");\n+\t\t\t \"Reduce using direct vector reduction.\\n\");\n \n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n       tmp = build1 (reduc_code, vectype, new_phi_result);\n@@ -4093,7 +4134,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"Reduce using vector shifts\");\n+\t\t\t     \"Reduce using vector shifts\\n\");\n \n           vec_dest = vect_create_destination_var (scalar_dest, vectype);\n           new_temp = new_phi_result;\n@@ -4134,7 +4175,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"Reduce using scalar code. \");\n+\t\t\t     \"Reduce using scalar code.\\n\");\n \n           vec_size_in_bits = tree_low_cst (TYPE_SIZE (vectype), 1);\n           FOR_EACH_VEC_ELT (new_phis, i, new_phi)\n@@ -4225,7 +4266,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"extract scalar result\");\n+\t\t\t \"extract scalar result\\n\");\n \n       if (BYTES_BIG_ENDIAN)\n         bitpos = size_binop (MULT_EXPR,\n@@ -4464,6 +4505,7 @@ vect_create_epilog_for_reduction (vec<tree> vect_defs, gimple stmt,\n                       dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t\t       \"created double reduction phi node: \");\n                       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vect_phi, 0);\n+                      dump_printf (MSG_NOTE, \"\\n\");\n                     }\n \n                   vect_phi_res = PHI_RESULT (vect_phi);\n@@ -4819,7 +4861,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported condition in reduction\");\n+\t\t\t     \"unsupported condition in reduction\\n\");\n \n             return false;\n         }\n@@ -4835,7 +4877,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n \t     not vectorizable_reduction.  */\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"unsupported shift or rotation.\");\n+\t\t\t     \"unsupported shift or rotation.\\n\");\n \t  return false;\n \t}\n \n@@ -4845,23 +4887,23 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no optab.\");\n+\t\t\t     \"no optab.\\n\");\n \n           return false;\n         }\n \n       if (optab_handler (optab, vec_mode) == CODE_FOR_nothing)\n         {\n           if (dump_enabled_p ())\n-            dump_printf (MSG_NOTE, \"op not supported by target.\");\n+            dump_printf (MSG_NOTE, \"op not supported by target.\\n\");\n \n           if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n               || LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n \t          < vect_min_worthwhile_factor (code))\n             return false;\n \n           if (dump_enabled_p ())\n-  \t    dump_printf (MSG_NOTE, \"proceeding using word mode.\");\n+  \t    dump_printf (MSG_NOTE, \"proceeding using word mode.\\n\");\n         }\n \n       /* Worthwhile without SIMD support?  */\n@@ -4871,7 +4913,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"not worthwhile without SIMD support.\");\n+\t\t\t     \"not worthwhile without SIMD support.\\n\");\n \n           return false;\n         }\n@@ -4952,7 +4994,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no optab for reduction.\");\n+\t\t\t     \"no optab for reduction.\\n\");\n \n           epilog_reduc_code = ERROR_MARK;\n         }\n@@ -4962,7 +5004,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"reduc op not supported by target.\");\n+\t\t\t     \"reduc op not supported by target.\\n\");\n \n           epilog_reduc_code = ERROR_MARK;\n         }\n@@ -4973,7 +5015,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"no reduc code for scalar code.\");\n+\t\t\t     \"no reduc code for scalar code.\\n\");\n \n           return false;\n         }\n@@ -4983,7 +5025,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"multiple types in double reduction\");\n+\t\t\t \"multiple types in double reduction\\n\");\n \n       return false;\n     }\n@@ -5002,7 +5044,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"invalid types in dot-prod\");\n+\t\t\t     \"invalid types in dot-prod\\n\");\n \n           return false;\n         }\n@@ -5019,7 +5061,7 @@ vectorizable_reduction (gimple stmt, gimple_stmt_iterator *gsi,\n   /** Transform.  **/\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"transform reduction.\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform reduction.\\n\");\n \n   /* FORNOW: Multiple types are not supported for condition.  */\n   if (code == COND_EXPR)\n@@ -5306,7 +5348,7 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"multiple types in nested loop.\");\n+\t\t\t     \"multiple types in nested loop.\\n\");\n \t  return false;\n \t}\n \n@@ -5329,9 +5371,9 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n \t\t&& !STMT_VINFO_LIVE_P (exit_phi_vinfo)))\n \t    {\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"inner-loop induction only used outside \"\n-\t\t\t\t \"of the outer vectorized loop.\");\n+\t\t\t\t \"of the outer vectorized loop.\\n\");\n \t      return false;\n \t    }\n \t}\n@@ -5354,15 +5396,15 @@ vectorizable_induction (gimple phi, gimple_stmt_iterator *gsi ATTRIBUTE_UNUSED,\n       STMT_VINFO_TYPE (stmt_info) = induc_vec_info_type;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_induction ===\");\n+                         \"=== vectorizable_induction ===\\n\");\n       vect_model_induction_cost (stmt_info, ncopies);\n       return true;\n     }\n \n   /** Transform.  **/\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform induction phi.\\n\");\n \n   vec_def = get_initial_def_for_induction (phi);\n   *vec_stmt = SSA_NAME_DEF_STMT (vec_def);\n@@ -5462,7 +5504,7 @@ vectorizable_live_operation (gimple stmt,\n         {\n           if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"use not simple.\");\n+\t\t\t     \"use not simple.\\n\");\n           return false;\n         }\n \n@@ -5501,7 +5543,7 @@ vect_loop_kill_debug_uses (struct loop *loop, gimple stmt)\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-                                     \"killing debug use\");\n+                                     \"killing debug use\\n\");\n \n \t\t  gimple_debug_bind_reset_value (ustmt);\n \t\t  update_stmt (ustmt);\n@@ -5542,7 +5584,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n   gcov_type expected_iterations = expected_loop_iterations_unbounded (loop);\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vec_transform_loop ===\\n\");\n \n   /* If profile is inprecise, we have chance to fix it up.  */\n   if (LOOP_VINFO_NITERS_KNOWN_P (loop_vinfo))\n@@ -5561,7 +5603,8 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t \"Profitability threshold is %d loop iterations.\", th);\n+\t\t\t \"Profitability threshold is %d loop iterations.\\n\",\n+                         th);\n       check_profitability = true;\n     }\n \n@@ -5628,6 +5671,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n                                \"------>vectorizing phi: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \t  stmt_info = vinfo_for_stmt (phi);\n \t  if (!stmt_info)\n@@ -5643,12 +5687,12 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t  if ((TYPE_VECTOR_SUBPARTS (STMT_VINFO_VECTYPE (stmt_info))\n \t        != (unsigned HOST_WIDE_INT) vectorization_factor)\n \t      && dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\");\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"multiple-types.\\n\");\n \n \t  if (STMT_VINFO_DEF_TYPE (stmt_info) == vect_induction_def)\n \t    {\n \t      if (dump_enabled_p ())\n-\t\tdump_printf_loc (MSG_NOTE, vect_location, \"transform phi.\");\n+\t\tdump_printf_loc (MSG_NOTE, vect_location, \"transform phi.\\n\");\n \t      vect_transform_stmt (phi, NULL, NULL, NULL, NULL);\n \t    }\n \t}\n@@ -5678,6 +5722,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t       \"------>vectorizing statement: \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  stmt_info = vinfo_for_stmt (stmt);\n@@ -5752,6 +5797,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t\t\t\t\t   \"stmt: \");\n \t\t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM,\n \t\t\t\t\t    pattern_def_stmt, 0);\n+                          dump_printf (MSG_NOTE, \"\\n\");\n \t\t\t}\n \n \t\t      stmt = pattern_def_stmt;\n@@ -5776,7 +5822,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \t    /* For SLP VF is set according to unrolling factor, and not to\n \t       vector size, hence for SLP this print is not valid.  */\n             dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t     \"multiple-types.\");\n+\t\t\t     \"multiple-types.\\n\");\n \n \t  /* SLP. Schedule all the SLP instances when the first SLP stmt is\n \t     reached.  */\n@@ -5788,7 +5834,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t\t  if (dump_enabled_p ())\n \t\t    dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t\t\t     \"=== scheduling SLP instances ===\");\n+\t\t\t\t     \"=== scheduling SLP instances ===\\n\");\n \n \t\t  vect_schedule_slp (loop_vinfo, NULL);\n \t\t}\n@@ -5807,7 +5853,7 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n \n \t  /* -------- vectorize statement ------------ */\n \t  if (dump_enabled_p ())\n-\t    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\");\n+\t    dump_printf_loc (MSG_NOTE, vect_location, \"transform statement.\\n\");\n \n \t  grouped_store = false;\n \t  is_store = vect_transform_stmt (stmt, &si, &grouped_store, NULL, NULL);\n@@ -5870,5 +5916,6 @@ vect_transform_loop (loop_vec_info loop_vinfo)\n       if (loop->inner)\n \tdump_printf_loc (MSG_NOTE, vect_location,\n \t\t\t \"OUTER LOOP VECTORIZED\\n\");\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n }"}, {"sha": "30372522832d85e7ca5f73713db2b45c2b919299", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -422,6 +422,7 @@ vect_recog_dot_prod_pattern (vec<gimple> *stmts, tree *type_in,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_recog_dot_prod_pattern: detected: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* We don't allow changing the order of the computation in the inner-loop\n@@ -682,7 +683,7 @@ vect_recog_widen_mult_pattern (vec<gimple> *stmts,\n   /* Pattern detected.  */\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_recog_widen_mult_pattern: detected: \");\n+                     \"vect_recog_widen_mult_pattern: detected:\\n\");\n \n   /* Check target support  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n@@ -921,6 +922,7 @@ vect_recog_widen_sum_pattern (vec<gimple> *stmts, tree *type_in,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_recog_widen_sum_pattern: detected: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* We don't allow changing the order of the computation in the inner-loop\n@@ -1226,6 +1228,7 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"created pattern stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       type = gimple_expr_type (stmt);\n@@ -1294,6 +1297,7 @@ vect_recog_over_widening_pattern (vec<gimple> *stmts,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_recog_over_widening_pattern: detected: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   return pattern_stmt;\n@@ -1427,7 +1431,7 @@ vect_recog_widen_shift_pattern (vec<gimple> *stmts,\n   /* Pattern detected.  */\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_recog_widen_shift_pattern: detected: \");\n+                     \"vect_recog_widen_shift_pattern: detected:\\n\");\n \n   /* Check target support.  */\n   vectype = get_vectype_for_scalar_type (half_type0);\n@@ -1694,7 +1698,7 @@ vect_recog_rotate_pattern (vec<gimple> *stmts, tree *type_in, tree *type_out)\n   /* Pattern detected.  */\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"vect_recog_rotate_pattern: detected: \");\n+\t\t     \"vect_recog_rotate_pattern: detected:\\n\");\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (type, NULL);\n@@ -1824,7 +1828,7 @@ vect_recog_vector_vector_shift_pattern (vec<gimple> *stmts,\n   /* Pattern detected.  */\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_recog_vector_vector_shift_pattern: detected: \");\n+                     \"vect_recog_vector_vector_shift_pattern: detected:\\n\");\n \n   /* Pattern supported.  Create a stmt to be used to replace the pattern.  */\n   var = vect_recog_temp_ssa_var (TREE_TYPE (oprnd0), NULL);\n@@ -1942,7 +1946,7 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n       /* Pattern detected.  */\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vect_recog_divmod_pattern: detected: \");\n+                         \"vect_recog_divmod_pattern: detected:\\n\");\n \n       cond = build2 (LT_EXPR, boolean_type_node, oprnd0,\n \t\t     build_int_cst (itype, 0));\n@@ -2291,6 +2295,7 @@ vect_recog_divmod_pattern (vec<gimple> *stmts,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_recog_divmod_pattern: detected: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   stmts->safe_push (last_stmt);\n@@ -2456,7 +2461,7 @@ vect_recog_mixed_size_cond_pattern (vec<gimple> *stmts, tree *type_in,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"vect_recog_mixed_size_cond_pattern: detected: \");\n+                     \"vect_recog_mixed_size_cond_pattern: detected:\\n\");\n \n   return pattern_stmt;\n }\n@@ -2849,7 +2854,7 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,\n       stmts->safe_push (last_stmt);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vect_recog_bool_pattern: detected: \");\n+                         \"vect_recog_bool_pattern: detected:\\n\");\n \n       return pattern_stmt;\n     }\n@@ -2895,7 +2900,7 @@ vect_recog_bool_pattern (vec<gimple> *stmts, tree *type_in,\n       stmts->safe_push (last_stmt);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vect_recog_bool_pattern: detected: \");\n+                         \"vect_recog_bool_pattern: detected:\\n\");\n       return pattern_stmt;\n     }\n   else\n@@ -3048,6 +3053,7 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"pattern recognized: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* Mark the stmts that are involved in the pattern. */\n@@ -3074,6 +3080,7 @@ vect_pattern_recog_1 (vect_recog_func_ptr vect_recog_func,\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"additional pattern stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       vect_mark_pattern_stmts (stmt, pattern_stmt, NULL_TREE);\n@@ -3173,7 +3180,7 @@ vect_pattern_recog (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_pattern_recog ===\");\n+                     \"=== vect_pattern_recog ===\\n\");\n \n   if (loop_vinfo)\n     {"}, {"sha": "8ed0fc58c59341280850f52bb4284da9e46ead64", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 50, "deletions": 20, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -257,6 +257,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: can't find def for \");\n \t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n \t  return false;\n@@ -283,6 +284,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: some of the stmts\"\n \t\t\t\t   \" are in a pattern, and others are not \");\n \t\t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, oprnd);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \n \t      return false;\n@@ -295,7 +297,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             {\n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Unsupported pattern.\");\n+\t\t\t\t \"Unsupported pattern.\\n\");\n               return false;\n             }\n \n@@ -312,7 +314,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               default:\n                 if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t   \"unsupported defining stmt: \");\n+\t\t\t\t   \"unsupported defining stmt:\\n\");\n                 return false;\n             }\n         }\n@@ -342,7 +344,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"Build SLP failed: different types \");\n+\t\t\t\t \"Build SLP failed: different types\\n\");\n \n \t      return false;\n \t    }\n@@ -367,6 +369,7 @@ vect_get_and_check_slp_defs (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: illegal type of def \");\n \t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, def);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \n \t  return false;\n@@ -415,6 +418,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t{\n \t  dump_printf_loc (MSG_NOTE, vect_location, \"Build SLP for \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Fail to vectorize statements marked as unvectorizable.  */\n@@ -425,6 +429,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n               dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t       \"Build SLP failed: unvectorizable statement \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n@@ -440,6 +445,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"Build SLP failed: not GIMPLE_ASSIGN nor \"\n \t\t\t       \"GIMPLE_CALL \");\n \t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t    }\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n@@ -457,6 +463,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"Build SLP failed: condition is not \"\n \t\t\t       \"comparison \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n@@ -473,6 +480,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t       \"Build SLP failed: unsupported data-type \");\n               dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t scalar_type);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \t  /* Fatal mismatch.  */\n \t  matches[0] = false;\n@@ -501,6 +509,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: unsupported call type \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n@@ -538,7 +547,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t    {\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t\t \"Build SLP failed: no optab.\");\n+\t\t\t\t\t \"Build SLP failed: no optab.\\n\");\n \t\t      /* Fatal mismatch.  */\n \t\t      matches[0] = false;\n \t\t      return false;\n@@ -549,7 +558,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t      if (dump_enabled_p ())\n \t\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t\t \"Build SLP failed: \"\n-\t\t\t\t\t \"op not supported by target.\");\n+\t\t\t\t\t \"op not supported by target.\\n\");\n \t\t      /* Fatal mismatch.  */\n \t\t      matches[0] = false;\n \t\t      return false;\n@@ -588,6 +597,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: different operation \"\n \t\t\t\t   \"in stmt \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      /* Mismatch.  */\n \t      continue;\n@@ -602,6 +612,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: different shift \"\n \t\t\t\t   \"arguments in \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      /* Mismatch.  */\n \t      continue;\n@@ -622,6 +633,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t       \"Build SLP failed: different calls in \");\n \t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t    }\n \t\t  /* Mismatch.  */\n \t\t  continue;\n@@ -661,6 +673,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t       \"loads have gaps \");\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                     }\n \t\t  /* Fatal mismatch.  */\n \t\t  matches[0] = false;\n@@ -685,6 +698,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t       \"the SLP group size \");\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                     }\n \t\t  /* Fatal mismatch.  */\n \t\t  matches[0] = false;\n@@ -707,6 +721,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t   \"interleaving chains in one node \");\n                           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\t    stmt, 0);\n+                          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                         }\n \t\t      /* Mismatch.  */\n \t\t      continue;\n@@ -731,6 +746,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t\t   \"unaligned load \");\n                           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\t    stmt, 0);\n+                          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                         }\n \t\t      /* Fatal mismatch.  */\n \t\t      matches[0] = false;\n@@ -749,6 +765,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n \t\t\t\t   \"Build SLP failed: not grouped load \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \n \t      /* FORNOW: Not grouped loads are not supported.  */\n@@ -769,6 +786,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t   \"Build SLP failed: operation\");\n \t\t  dump_printf (MSG_MISSED_OPTIMIZATION, \" unsupported \");\n \t\t  dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t}\n \t      /* Fatal mismatch.  */\n \t      matches[0] = false;\n@@ -790,6 +808,7 @@ vect_build_slp_tree_1 (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n \t\t\t\t       \" operation\");\n                       dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tstmt, 0);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                     }\n \t\t  /* Mismatch.  */\n \t\t  continue;\n@@ -1076,6 +1095,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \telse\n \t  for (i = 0; i < group_size; ++i)\n \t    dump_printf (MSG_NOTE, \"%d \", i);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* In case of reduction every load permutation is allowed, since the order\n@@ -1187,6 +1207,7 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t\t\t\t       \"unsupported unaligned load \");\n \t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n \t\t\t\t\tfirst_load, 0);\n+                      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t\t    }\n \t\t  return false;\n \t\t}\n@@ -1449,6 +1470,7 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"Build SLP failed: unsupported data-type \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, scalar_type);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -1465,9 +1487,9 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n   if (unrolling_factor != 1 && !loop_vinfo)\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"Build SLP failed: unrolling required in basic\"\n-\t\t\t \" block SLP\");\n+\t\t\t \" block SLP\\n\");\n \n       return false;\n     }\n@@ -1514,9 +1536,9 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n       if (unrolling_factor != 1 && !loop_vinfo)\n         {\n           if (dump_enabled_p ())\n-            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t     \"Build SLP failed: unrolling required in basic\"\n-\t\t\t     \" block SLP\");\n+\t\t\t     \" block SLP\\n\");\n \t  vect_free_slp_tree (node);\n \t  loads.release ();\n           return false;\n@@ -1567,10 +1589,11 @@ vect_analyze_slp_instance (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo,\n             {\n               if (dump_enabled_p ())\n                 {\n-                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+                  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t   \"Build SLP failed: unsupported load \"\n \t\t\t\t   \"permutation \");\n                   dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+                  dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n                 }\n               vect_free_slp_instance (new_instance);\n               return false;\n@@ -1618,7 +1641,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n   bool ok = false;\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_analyze_slp ===\\n\");\n \n   if (loop_vinfo)\n     {\n@@ -1638,7 +1661,7 @@ vect_analyze_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t \"Failed to SLP the basic block.\");\n+\t\t\t \"Failed to SLP the basic block.\\n\");\n \n       return false;\n     }\n@@ -1680,7 +1703,8 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n   int decided_to_slp = 0;\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_make_slp_decision ===\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_make_slp_decision ===\"\n+                     \"\\n\");\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n@@ -1699,7 +1723,7 @@ vect_make_slp_decision (loop_vec_info loop_vinfo)\n \n   if (decided_to_slp && dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"Decided to SLP %d instances. Unrolling factor %d\",\n+\t\t     \"Decided to SLP %d instances. Unrolling factor %d\\n\",\n \t\t     decided_to_slp, unrolling_factor);\n \n   return (decided_to_slp > 0);\n@@ -1763,7 +1787,8 @@ vect_detect_hybrid_slp (loop_vec_info loop_vinfo)\n   slp_instance instance;\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"=== vect_detect_hybrid_slp ===\"\n+                     \"\\n\");\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     vect_detect_hybrid_slp_stmts (SLP_INSTANCE_TREE (instance));\n@@ -2016,7 +2041,7 @@ vect_bb_vectorization_profitable_p (bb_vec_info bb_vinfo)\n \t\t   vec_inside_cost);\n       dump_printf (MSG_NOTE, \"  Vector prologue cost: %d\\n\", vec_prologue_cost);\n       dump_printf (MSG_NOTE, \"  Vector epilogue cost: %d\\n\", vec_epilogue_cost);\n-      dump_printf (MSG_NOTE, \"  Scalar cost of basic block: %d\", scalar_cost);\n+      dump_printf (MSG_NOTE, \"  Scalar cost of basic block: %d\\n\", scalar_cost);\n     }\n \n   /* Vectorization is profitable if its cost is less than the cost of scalar\n@@ -2135,7 +2160,7 @@ vect_slp_analyze_bb_1 (basic_block bb)\n   if (!vect_slp_analyze_operations (bb_vinfo))\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+        dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t \"not vectorized: bad operation in basic block.\\n\");\n \n       destroy_bb_vec_info (bb_vinfo);\n@@ -2239,7 +2264,7 @@ vect_update_slp_costs_according_to_vf (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t     \"=== vect_update_slp_costs_according_to_vf ===\");\n+\t\t     \"=== vect_update_slp_costs_according_to_vf ===\\n\");\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n     {\n@@ -2739,9 +2764,10 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n     {\n       if (dump_enabled_p ())\n         {\n-          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location, \n+          dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"permutation requires at least two vectors \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -2761,6 +2787,7 @@ vect_get_mask_element (gimple stmt, int first_mask_element, int m,\n \t\t\t       \"permutation requires at \"\n \t\t\t       \"least three vectors \");\n               dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n \n           return false;\n@@ -2828,6 +2855,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t   \"no vect permute for \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n       return false;\n     }\n@@ -2998,6 +3026,7 @@ vect_schedule_slp_instance (slp_tree node, slp_instance instance,\n       dump_printf_loc (MSG_NOTE,vect_location,\n \t\t       \"------>vectorizing SLP node starting from: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* Loads should be inserted before the first load.  */\n@@ -3104,7 +3133,7 @@ vect_schedule_slp (loop_vec_info loop_vinfo, bb_vec_info bb_vinfo)\n                                              instance, vf);\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vectorizing stmts using SLP.\");\n+                         \"vectorizing stmts using SLP.\\n\");\n     }\n \n   FOR_EACH_VEC_ELT (slp_instances, i, instance)\n@@ -3168,6 +3197,7 @@ vect_slp_transform_bb (basic_block bb)\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"------>SLPing statement: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       stmt_info = vinfo_for_stmt (stmt);"}, {"sha": "135eb300ef10e47b9e324d14f426b3cea52f68ad", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 132, "deletions": 102, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -191,7 +191,7 @@ vect_mark_relevant (vec<gimple> *worklist, gimple stmt,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"mark relevant %d, live %d.\", relevant, live_p);\n+                     \"mark relevant %d, live %d.\\n\", relevant, live_p);\n \n   /* If this stmt is an original stmt in a pattern, we might need to mark its\n      related pattern stmt instead of the original stmt.  However, such stmts\n@@ -248,7 +248,7 @@ vect_mark_relevant (vec<gimple> *worklist, gimple stmt,\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n                              \"last stmt in pattern. don't mark\"\n-                             \" relevant/live.\");\n+                             \" relevant/live.\\n\");\n           stmt_info = vinfo_for_stmt (pattern_stmt);\n           gcc_assert (STMT_VINFO_RELATED_STMT (stmt_info) == stmt);\n           save_relevant = STMT_VINFO_RELEVANT (stmt_info);\n@@ -266,7 +266,7 @@ vect_mark_relevant (vec<gimple> *worklist, gimple stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"already marked relevant/live.\");\n+                         \"already marked relevant/live.\\n\");\n       return;\n     }\n \n@@ -311,7 +311,7 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n       {\n \tif (dump_enabled_p ())\n \t  dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"vec_stmt_relevant_p: stmt has vdefs.\");\n+                           \"vec_stmt_relevant_p: stmt has vdefs.\\n\");\n \t*relevant = vect_used_in_scope;\n       }\n \n@@ -325,7 +325,7 @@ vect_stmt_relevant_p (gimple stmt, loop_vec_info loop_vinfo,\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_NOTE, vect_location,\n-                                 \"vec_stmt_relevant_p: used out of loop.\");\n+                                 \"vec_stmt_relevant_p: used out of loop.\\n\");\n \n \t      if (is_gimple_debug (USE_STMT (use_p)))\n \t\tcontinue;\n@@ -438,7 +438,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: unsupported use in stmt.\");\n+                         \"not vectorized: unsupported use in stmt.\\n\");\n       return false;\n     }\n \n@@ -449,7 +449,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n   if (!flow_bb_inside_loop_p (loop, def_bb))\n     {\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"def_stmt is out of loop.\");\n+\tdump_printf_loc (MSG_NOTE, vect_location, \"def_stmt is out of loop.\\n\");\n       return true;\n     }\n \n@@ -468,7 +468,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"reduc-stmt defining reduc-phi in the same nest.\");\n+                         \"reduc-stmt defining reduc-phi in the same nest.\\n\");\n       if (STMT_VINFO_IN_PATTERN_P (dstmt_vinfo))\n \tdstmt_vinfo = vinfo_for_stmt (STMT_VINFO_RELATED_STMT (dstmt_vinfo));\n       gcc_assert (STMT_VINFO_RELEVANT (dstmt_vinfo) < vect_used_by_reduction);\n@@ -488,7 +488,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"outer-loop def-stmt defining inner-loop stmt.\");\n+                         \"outer-loop def-stmt defining inner-loop stmt.\\n\");\n \n       switch (relevant)\n \t{\n@@ -526,7 +526,7 @@ process_use (gimple stmt, tree use, loop_vec_info loop_vinfo, bool live_p,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"inner-loop def-stmt defining outer-loop stmt.\");\n+                         \"inner-loop def-stmt defining outer-loop stmt.\\n\");\n \n       switch (relevant)\n         {\n@@ -590,7 +590,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"=== vect_mark_stmts_to_be_vectorized ===\");\n+                     \"=== vect_mark_stmts_to_be_vectorized ===\\n\");\n \n   worklist.create (64);\n \n@@ -605,6 +605,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: phi relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, phi, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  if (vect_stmt_relevant_p (phi, loop_vinfo, &relevant, &live_p))\n@@ -617,6 +618,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location, \"init: stmt relevant? \");\n \t      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n \t    }\n \n \t  if (vect_stmt_relevant_p (stmt, loop_vinfo, &relevant, &live_p))\n@@ -635,6 +637,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t{\n           dump_printf_loc (MSG_NOTE, vect_location, \"worklist: examine stmt: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n \t}\n \n       /* Examine the USEs of STMT. For each USE, mark the stmt that defines it\n@@ -678,7 +681,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n \t        default:\n \t          if (dump_enabled_p ())\n \t            dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                     \"unsupported use of reduction.\");\n+                                     \"unsupported use of reduction.\\n\");\n   \t          worklist.release ();\n \t          return false;\n \t      }\n@@ -693,7 +696,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               {\n                 if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"unsupported use of nested cycle.\");\n+                                   \"unsupported use of nested cycle.\\n\");\n \n                 worklist.release ();\n                 return false;\n@@ -708,7 +711,7 @@ vect_mark_stmts_to_be_vectorized (loop_vec_info loop_vinfo)\n               {\n                 if (dump_enabled_p ())\n                   dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                   \"unsupported use of double reduction.\");\n+                                   \"unsupported use of double reduction.\\n\");\n \n                 worklist.release ();\n                 return false;\n@@ -832,7 +835,7 @@ vect_model_simple_cost (stmt_vec_info stmt_info, int ncopies,\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_simple_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n \n@@ -878,7 +881,7 @@ vect_model_promotion_demotion_cost (stmt_vec_info stmt_info,\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_promotion_demotion_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n /* Function vect_cost_group_size\n@@ -961,7 +964,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vect_model_store_cost: strided group_size = %d .\",\n+                         \"vect_model_store_cost: strided group_size = %d .\\n\",\n                          group_size);\n     }\n \n@@ -971,7 +974,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_store_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n \n@@ -995,7 +998,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"vect_model_store_cost: aligned.\");\n+                           \"vect_model_store_cost: aligned.\\n\");\n         break;\n       }\n \n@@ -1008,7 +1011,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_store_cost: unaligned supported by \"\n-                           \"hardware.\");\n+                           \"hardware.\\n\");\n         break;\n       }\n \n@@ -1018,7 +1021,7 @@ vect_get_store_cost (struct data_reference *dr, int ncopies,\n \n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"vect_model_store_cost: unsupported access.\");\n+                           \"vect_model_store_cost: unsupported access.\\n\");\n         break;\n       }\n \n@@ -1076,8 +1079,8 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t\t\t       stmt_info, 0, vect_body);\n \n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \n-                         \"vect_model_load_cost: strided group_size = %d .\",\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"vect_model_load_cost: strided group_size = %d .\\n\",\n                          group_size);\n     }\n \n@@ -1102,7 +1105,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, int ncopies,\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n                      \"vect_model_load_cost: inside_cost = %d, \"\n-                     \"prologue_cost = %d .\", inside_cost, prologue_cost);\n+                     \"prologue_cost = %d .\\n\", inside_cost, prologue_cost);\n }\n \n \n@@ -1128,7 +1131,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"vect_model_load_cost: aligned.\");\n+                           \"vect_model_load_cost: aligned.\\n\");\n \n         break;\n       }\n@@ -1142,7 +1145,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_load_cost: unaligned supported by \"\n-                           \"hardware.\");\n+                           \"hardware.\\n\");\n \n         break;\n       }\n@@ -1161,17 +1164,17 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \t\t\t\t\t    stmt_info, 0, vect_body);\n \n         if (dump_enabled_p ())\n-          dump_printf_loc (MSG_NOTE, vect_location, \n-                           \"vect_model_load_cost: explicit realign\");\n+          dump_printf_loc (MSG_NOTE, vect_location,\n+                           \"vect_model_load_cost: explicit realign\\n\");\n \n         break;\n       }\n     case dr_explicit_realign_optimized:\n       {\n         if (dump_enabled_p ())\n-          dump_printf_loc (MSG_NOTE, vect_location, \n+          dump_printf_loc (MSG_NOTE, vect_location,\n                            \"vect_model_load_cost: unaligned software \"\n-                           \"pipelined.\");\n+                           \"pipelined.\\n\");\n \n         /* Unaligned software pipeline has a load of an address, an initial\n            load, and possibly a mask operation to \"prime\" the loop.  However,\n@@ -1198,7 +1201,8 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"vect_model_load_cost: explicit realign optimized\");\n+                           \"vect_model_load_cost: explicit realign optimized\"\n+                           \"\\n\");\n \n         break;\n       }\n@@ -1209,7 +1213,7 @@ vect_get_load_cost (struct data_reference *dr, int ncopies,\n \n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                           \"vect_model_load_cost: unsupported access.\");\n+                           \"vect_model_load_cost: unsupported access.\\n\");\n         break;\n       }\n \n@@ -1262,6 +1266,7 @@ vect_init_vector_1 (gimple stmt, gimple new_stmt, gimple_stmt_iterator *gsi)\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"created new init_stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, new_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n }\n \n@@ -1344,6 +1349,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_get_vec_def_for_operand: \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, op);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   is_simple_use = vect_is_simple_use (op, stmt, loop_vinfo, NULL,\n@@ -1357,6 +1363,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n           dump_printf_loc (MSG_NOTE, vect_location, \"def =  \");\n           loc_printed = 1;\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, def);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n       if (def_stmt)\n         {\n@@ -1365,6 +1372,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n           else\n             dump_printf_loc (MSG_NOTE, vect_location, \"  def_stmt =  \");\n \t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, def_stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n     }\n \n@@ -1383,7 +1391,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n         /* Create 'vect_cst_ = {cst,cst,...,cst}'  */\n         if (dump_enabled_p ())\n           dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"Create vector_cst. nunits = %d\", nunits);\n+                           \"Create vector_cst. nunits = %d\\n\", nunits);\n \n         return vect_init_vector (stmt, op, vector_type, NULL);\n       }\n@@ -1399,7 +1407,7 @@ vect_get_vec_def_for_operand (tree op, gimple stmt, tree *scalar_def)\n \n         /* Create 'vec_inv = {inv,inv,..,inv}'  */\n         if (dump_enabled_p ())\n-          dump_printf_loc (MSG_NOTE, vect_location, \"Create vector_inv.\");\n+          dump_printf_loc (MSG_NOTE, vect_location, \"Create vector_inv.\\n\");\n \n         return vect_init_vector (stmt, def, vector_type, NULL);\n       }\n@@ -1666,6 +1674,7 @@ vect_finish_stmt_generation (gimple stmt, gimple vec_stmt,\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"add new stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, vec_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   gimple_set_location (vec_stmt, gimple_location (stmt));\n@@ -1775,7 +1784,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"argument types differ.\");\n+                             \"argument types differ.\\n\");\n \t  return false;\n \t}\n       if (!rhs_type)\n@@ -1786,7 +1795,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"use not simple.\");\n+                             \"use not simple.\\n\");\n \t  return false;\n \t}\n \n@@ -1797,7 +1806,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"argument vector types differ.\");\n+                             \"argument vector types differ.\\n\");\n \t  return false;\n \t}\n     }\n@@ -1814,6 +1823,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n           dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"no vectype for scalar type \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -1855,7 +1865,7 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t     \"function is not vectorizable.\");\n+\t\t\t     \"function is not vectorizable.\\n\");\n \t  return false;\n \t}\n     }\n@@ -1877,15 +1887,16 @@ vectorizable_call (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       STMT_VINFO_TYPE (stmt_info) = call_vec_info_type;\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\");\n+        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_call ===\"\n+                         \"\\n\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"transform call.\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform call.\\n\");\n \n   /* Handle def.  */\n   scalar_dest = gimple_call_lhs (stmt);\n@@ -2408,7 +2419,8 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"type conversion to/from bit-precision unsupported.\");\n+                         \"type conversion to/from bit-precision unsupported.\"\n+                         \"\\n\");\n       return false;\n     }\n \n@@ -2418,7 +2430,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n   if (op_type == binary_op)\n@@ -2440,7 +2452,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"use not simple.\");\n+                             \"use not simple.\\n\");\n \t  return false;\n \t}\n     }\n@@ -2458,6 +2470,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n \t  dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                            \"no vectype for scalar type \");\n \t  dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM, rhs_type);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n \t}\n \n       return false;\n@@ -2499,7 +2512,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     unsupported:\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"conversion not supported by target.\");\n+                         \"conversion not supported by target.\\n\");\n       return false;\n \n     case WIDEN:\n@@ -2598,7 +2611,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_conversion ===\");\n+                         \"=== vectorizable_conversion ===\\n\");\n       if (code == FIX_TRUNC_EXPR || code == FLOAT_EXPR)\n         {\n \t  STMT_VINFO_TYPE (stmt_info) = type_conversion_vec_info_type;\n@@ -2621,7 +2634,7 @@ vectorizable_conversion (gimple stmt, gimple_stmt_iterator *gsi,\n   /** Transform.  **/\n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"transform conversion. ncopies = %d.\", ncopies);\n+                     \"transform conversion. ncopies = %d.\\n\", ncopies);\n \n   if (op_type == binary_op)\n     {\n@@ -2967,7 +2980,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n \n@@ -2997,7 +3010,7 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                          \"type conversion to/from bit-precision \"\n-                         \"unsupported.\");\n+                         \"unsupported.\\n\");\n       return false;\n     }\n \n@@ -3006,14 +3019,14 @@ vectorizable_assignment (gimple stmt, gimple_stmt_iterator *gsi,\n       STMT_VINFO_TYPE (stmt_info) = assignment_vec_info_type;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_assignment ===\");\n+                         \"=== vectorizable_assignment ===\\n\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n \n   /** Transform.  **/\n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"transform assignment.\");\n+    dump_printf_loc (MSG_NOTE, vect_location, \"transform assignment.\\n\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3162,7 +3175,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"bit-precision shifts not supported.\");\n+                         \"bit-precision shifts not supported.\\n\");\n       return false;\n     }\n \n@@ -3172,7 +3185,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n   /* If op0 is an external or constant def use a vector type with\n@@ -3185,7 +3198,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"no vectype for scalar type \");\n+                         \"no vectype for scalar type\\n\");\n       return false;\n     }\n \n@@ -3200,7 +3213,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n \n@@ -3245,7 +3258,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"operand mode requires invariant argument.\");\n+                         \"operand mode requires invariant argument.\\n\");\n       return false;\n     }\n \n@@ -3255,7 +3268,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n       optab = optab_for_tree_code (code, vectype, optab_vector);\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"vector/vector shift/rotate found.\");\n+                         \"vector/vector shift/rotate found.\\n\");\n \n       if (!op1_vectype)\n \top1_vectype = get_same_sized_vectype (TREE_TYPE (op1), vectype_out);\n@@ -3265,7 +3278,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                              \"unusable type for last operand in\"\n-                             \" vector/vector shift/rotate.\");\n+                             \" vector/vector shift/rotate.\\n\");\n \t  return false;\n \t}\n     }\n@@ -3279,7 +3292,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n         {\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_NOTE, vect_location,\n-                             \"vector/scalar shift/rotate found.\");\n+                             \"vector/scalar shift/rotate found.\\n\");\n         }\n       else\n         {\n@@ -3292,7 +3305,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_NOTE, vect_location,\n-                                 \"vector/vector shift/rotate found.\");\n+                                 \"vector/vector shift/rotate found.\\n\");\n \n               /* Unlike the other binary operators, shifts/rotates have\n                  the rhs being int, instead of the same type as the lhs,\n@@ -3310,7 +3323,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n                       if (dump_enabled_p ())\n                         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n                                          \"unusable type for last operand in\"\n-                                         \" vector/vector shift/rotate.\");\n+                                         \" vector/vector shift/rotate.\\n\");\n \t\t\treturn false;\n \t\t    }\n \t\t  if (vec_stmt && !slp_node)\n@@ -3329,7 +3342,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"no optab.\");\n+                         \"no optab.\\n\");\n       return false;\n     }\n   vec_mode = TYPE_MODE (vectype);\n@@ -3338,14 +3351,15 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"op not supported by target.\");\n+                         \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n           || (vf < vect_min_worthwhile_factor (code)\n               && !vec_stmt))\n         return false;\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"proceeding using word mode.\\n\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n@@ -3355,15 +3369,16 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not worthwhile without SIMD support.\");\n+                         \"not worthwhile without SIMD support.\\n\");\n       return false;\n     }\n \n   if (!vec_stmt) /* transformation not required.  */\n     {\n       STMT_VINFO_TYPE (stmt_info) = shift_vec_info_type;\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"=== vectorizable_shift ===\");\n+        dump_printf_loc (MSG_NOTE, vect_location,\n+                         \"=== vectorizable_shift ===\\n\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n@@ -3372,7 +3387,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"transform binary/unary operation.\");\n+                     \"transform binary/unary operation.\\n\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3394,7 +3409,7 @@ vectorizable_shift (gimple stmt, gimple_stmt_iterator *gsi,\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_NOTE, vect_location,\n-                                     \"operand 1 using scalar mode.\");\n+                                     \"operand 1 using scalar mode.\\n\");\n                   vec_oprnd1 = op1;\n                   vec_oprnds1.create (slp_node ? slp_node->vec_stmts_size : 1);\n                   vec_oprnds1.quick_push (vec_oprnd1);\n@@ -3525,7 +3540,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"num. args = %d (not unary/binary/ternary op).\",\n+                         \"num. args = %d (not unary/binary/ternary op).\\n\",\n                          op_type);\n       return false;\n     }\n@@ -3544,7 +3559,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"bit-precision arithmetic not supported.\");\n+                         \"bit-precision arithmetic not supported.\\n\");\n       return false;\n     }\n \n@@ -3554,7 +3569,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n   /* If op0 is an external or constant def use a vector type with\n@@ -3571,6 +3586,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n                            \"no vectype for scalar type \");\n           dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                              TREE_TYPE (op0));\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -3589,7 +3605,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"use not simple.\");\n+                             \"use not simple.\\n\");\n \t  return false;\n \t}\n     }\n@@ -3601,7 +3617,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"use not simple.\");\n+                             \"use not simple.\\n\");\n \t  return false;\n \t}\n     }\n@@ -3643,7 +3659,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n           if (dump_enabled_p ())\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"no optab.\");\n+                             \"no optab.\\n\");\n \t  return false;\n \t}\n       icode = (int) optab_handler (optab, vec_mode);\n@@ -3653,13 +3669,14 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n \tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"op not supported by target.\");\n+                         \"op not supported by target.\\n\");\n       /* Check only during analysis.  */\n       if (GET_MODE_SIZE (vec_mode) != UNITS_PER_WORD\n \t  || (!vec_stmt && vf < vect_min_worthwhile_factor (code)))\n         return false;\n       if (dump_enabled_p ())\n-\tdump_printf_loc (MSG_NOTE, vect_location, \"proceeding using word mode.\");\n+\tdump_printf_loc (MSG_NOTE, vect_location,\n+                         \"proceeding using word mode.\\n\");\n     }\n \n   /* Worthwhile without SIMD support?  Check only during analysis.  */\n@@ -3669,7 +3686,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not worthwhile without SIMD support.\");\n+                         \"not worthwhile without SIMD support.\\n\");\n       return false;\n     }\n \n@@ -3678,7 +3695,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n       STMT_VINFO_TYPE (stmt_info) = op_vec_info_type;\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"=== vectorizable_operation ===\");\n+                         \"=== vectorizable_operation ===\\n\");\n       vect_model_simple_cost (stmt_info, ncopies, dt, NULL, NULL);\n       return true;\n     }\n@@ -3687,7 +3704,7 @@ vectorizable_operation (gimple stmt, gimple_stmt_iterator *gsi,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"transform binary/unary operation.\");\n+                     \"transform binary/unary operation.\\n\");\n \n   /* Handle def.  */\n   vec_dest = vect_create_destination_var (scalar_dest, vectype);\n@@ -3897,7 +3914,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"multiple types in nested loop.\");\n+                         \"multiple types in nested loop.\\n\");\n       return false;\n     }\n \n@@ -3932,7 +3949,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"use not simple.\");\n+                         \"use not simple.\\n\");\n       return false;\n     }\n \n@@ -3953,7 +3970,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"negative step for store.\");\n+                         \"negative step for store.\\n\");\n       return false;\n     }\n \n@@ -3984,7 +4001,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n                 {\n                   if (dump_enabled_p ())\n                     dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                     \"use not simple.\");\n+                                     \"use not simple.\\n\");\n                   return false;\n                 }\n               next_stmt = GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n@@ -4048,7 +4065,7 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"transform store. ncopies = %d\", ncopies);\n+                     \"transform store. ncopies = %d\\n\", ncopies);\n \n   dr_chain.create (group_size);\n   oprnds.create (group_size);\n@@ -4459,7 +4476,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"multiple types in nested loop.\");\n+                         \"multiple types in nested loop.\\n\");\n       return false;\n     }\n \n@@ -4500,7 +4517,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"Aligned load, but unsupported type.\");\n+                         \"Aligned load, but unsupported type.\\n\");\n       return false;\n     }\n \n@@ -4536,7 +4553,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"gather index use not simple.\");\n+                             \"gather index use not simple.\\n\");\n \t  return false;\n \t}\n     }\n@@ -4552,7 +4569,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"multiple types with negative step.\");\n+                             \"multiple types with negative step.\\n\");\n \t  return false;\n \t}\n \n@@ -4562,7 +4579,8 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    {\n \t      if (dump_enabled_p ())\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-\t\t\t\t \"negative step for group load not supported\");\n+\t\t\t\t \"negative step for group load not supported\"\n+                                 \"\\n\");\n \t      return false;\n \t    }\n \t  alignment_support_scheme = vect_supportable_dr_alignment (dr, false);\n@@ -4571,14 +4589,15 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t    {\n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"negative step but alignment required.\");\n+                                 \"negative step but alignment required.\\n\");\n \t      return false;\n \t    }\n \t  if (!perm_mask_for_reverse (vectype))\n \t    {\n               if (dump_enabled_p ())\n                 dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                                 \"negative step and reversing not supported.\");\n+                                 \"negative step and reversing not supported.\"\n+                                 \"\\n\");\n \t      return false;\n \t    }\n \t}\n@@ -4593,7 +4612,7 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n-                     \"transform load. ncopies = %d\", ncopies);\n+                     \"transform load. ncopies = %d\\n\", ncopies);\n \n   /** Transform.  **/\n \n@@ -5444,7 +5463,7 @@ vectorizable_condition (gimple stmt, gimple_stmt_iterator *gsi,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"value used after loop.\");\n+                         \"value used after loop.\\n\");\n       return false;\n     }\n \n@@ -5654,13 +5673,14 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"==> examining statement: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   if (gimple_has_volatile_ops (stmt))\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not vectorized: stmt has volatile operands\");\n+                         \"not vectorized: stmt has volatile operands\\n\");\n \n       return false;\n     }\n@@ -5696,12 +5716,13 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n               dump_printf_loc (MSG_NOTE, vect_location,\n                                \"==> examining pattern statement: \");\n               dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+              dump_printf (MSG_NOTE, \"\\n\");\n             }\n         }\n       else\n         {\n           if (dump_enabled_p ())\n-            dump_printf_loc (MSG_NOTE, vect_location, \"irrelevant.\");\n+            dump_printf_loc (MSG_NOTE, vect_location, \"irrelevant.\\n\");\n \n           return true;\n         }\n@@ -5718,6 +5739,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"==> examining pattern statement: \");\n           dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       if (!vect_analyze_stmt (pattern_stmt, need_to_vectorize, node))\n@@ -5742,6 +5764,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n                                    \"==> examining pattern def statement: \");\n \t\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_def_stmt, 0);\n+                  dump_printf (MSG_NOTE, \"\\n\");\n \t\t}\n \n \t      if (!vect_analyze_stmt (pattern_def_stmt,\n@@ -5781,6 +5804,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n           dump_printf_loc (MSG_NOTE, vect_location,\n                            \"get vectype for scalar type:  \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, scalar_type);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       vectype = get_vectype_for_scalar_type (scalar_type);\n@@ -5792,6 +5816,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                                 \"not SLPed: unsupported data-type \");\n                dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n                                   scalar_type);\n+              dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n             }\n           return false;\n         }\n@@ -5800,6 +5825,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n         {\n           dump_printf_loc (MSG_NOTE, vect_location, \"vectype:  \");\n           dump_generic_expr (MSG_NOTE, TDF_SLIM, vectype);\n+          dump_printf (MSG_NOTE, \"\\n\");\n         }\n \n       STMT_VINFO_VECTYPE (stmt_info) = vectype;\n@@ -5846,6 +5872,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                            \"not vectorized: relevant stmt not \");\n           dump_printf (MSG_MISSED_OPTIMIZATION, \"supported: \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n       return false;\n@@ -5868,6 +5895,7 @@ vect_analyze_stmt (gimple stmt, bool *need_to_vectorize, slp_tree node)\n                            \"not vectorized: live stmt not \");\n           dump_printf (MSG_MISSED_OPTIMIZATION,  \"supported: \");\n           dump_gimple_stmt (MSG_MISSED_OPTIMIZATION, TDF_SLIM, stmt, 0);\n+          dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n         }\n \n        return false;\n@@ -5964,7 +5992,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                             \"stmt not supported.\");\n+                             \"stmt not supported.\\n\");\n \t  gcc_unreachable ();\n \t}\n     }\n@@ -5989,7 +6017,7 @@ vect_transform_stmt (gimple stmt, gimple_stmt_iterator *gsi,\n \n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_NOTE, vect_location,\n-                         \"Record the vdef for outer-loop vectorization.\");\n+                         \"Record the vdef for outer-loop vectorization.\\n\");\n \n       /* Find the relevant loop-exit phi-node, and reord the vec_stmt there\n         (to be used when vectorizing outer-loop stmts that use the DEF of\n@@ -6303,6 +6331,7 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n       dump_printf_loc (MSG_NOTE, vect_location,\n                        \"vect_is_simple_use: operand \");\n       dump_generic_expr (MSG_NOTE, TDF_SLIM, operand);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   if (CONSTANT_CLASS_P (operand))\n@@ -6321,15 +6350,15 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n   if (TREE_CODE (operand) == PAREN_EXPR)\n     {\n       if (dump_enabled_p ())\n-        dump_printf_loc (MSG_NOTE, vect_location, \"non-associatable copy.\");\n+        dump_printf_loc (MSG_NOTE, vect_location, \"non-associatable copy.\\n\");\n       operand = TREE_OPERAND (operand, 0);\n     }\n \n   if (TREE_CODE (operand) != SSA_NAME)\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"not ssa-name.\");\n+                         \"not ssa-name.\\n\");\n       return false;\n     }\n \n@@ -6338,14 +6367,15 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"no def_stmt.\");\n+                         \"no def_stmt.\\n\");\n       return false;\n     }\n \n   if (dump_enabled_p ())\n     {\n       dump_printf_loc (MSG_NOTE, vect_location, \"def_stmt: \");\n       dump_gimple_stmt (MSG_NOTE, TDF_SLIM, *def_stmt, 0);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n   /* Empty stmt is expected only in case of a function argument.\n@@ -6376,12 +6406,12 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n     {\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"Unsupported pattern.\");\n+                         \"Unsupported pattern.\\n\");\n       return false;\n     }\n \n   if (dump_enabled_p ())\n-    dump_printf_loc (MSG_NOTE, vect_location, \"type of def: %d.\", *dt);\n+    dump_printf_loc (MSG_NOTE, vect_location, \"type of def: %d.\\n\", *dt);\n \n   switch (gimple_code (*def_stmt))\n     {\n@@ -6401,7 +6431,7 @@ vect_is_simple_use (tree operand, gimple stmt, loop_vec_info loop_vinfo,\n     default:\n       if (dump_enabled_p ())\n         dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n-                         \"unsupported defining stmt: \");\n+                         \"unsupported defining stmt:\\n\");\n       return false;\n     }\n "}, {"sha": "160a416d4d3e992343a86ea24a3210e675835da5", "filename": "gcc/value-prof.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e645e94288a253da5ba9f14c599378a96348e4ea/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=e645e94288a253da5ba9f14c599378a96348e4ea", "patch": "@@ -589,7 +589,7 @@ check_counter (gimple stmt, const char * name,\n             dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,\n                              \"correcting inconsistent value profile: %s \"\n                              \"profiler overall count (%d) does not match BB \"\n-                             \"count (%d)\", name, (int)*all, (int)bb_count);\n+                             \"count (%d)\\n\", name, (int)*all, (int)bb_count);\n \t  *all = bb_count;\n \t  if (*count > *all)\n             *count = *all;\n@@ -1275,7 +1275,7 @@ check_ic_target (gimple call_stmt, struct cgraph_node *target)\n    locus =  gimple_location (call_stmt);\n    if (dump_enabled_p ())\n      dump_printf_loc (MSG_MISSED_OPTIMIZATION, locus,\n-                      \"Skipping target %s with mismatching types for icall \",\n+                      \"Skipping target %s with mismatching types for icall\\n\",\n                       cgraph_node_name (target));\n    return false;\n }"}]}