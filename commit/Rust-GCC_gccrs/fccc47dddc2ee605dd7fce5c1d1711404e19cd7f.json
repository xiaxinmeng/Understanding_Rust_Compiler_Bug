{"sha": "fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmNjYzQ3ZGRkYzJlZTYwNWRkN2ZjZTVjMWQxNzExNDA0ZTE5Y2Q3Zg==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T08:21:59Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2021-04-28T08:21:59Z"}, "message": "Avoid creating useless local bounds around calls\n\nThis prevents the compiler from creating useless local bounds around calls\nthat take a parameter of an unconstrained array type when the bounds already\nexist somewhere else for the actual parameter.\n\ngcc/ada/\n\t* gcc-interface/decl.c (gnat_to_gnu_subprog_type): Do not demote a\n\tconst or pure function because of a parameter whose type is pointer\n\tto function.\n\t* gcc-interface/trans.c (Call_to_gnu): Do not put back a conversion\n\tbetween an actual and a formal that are unconstrained array types.\n\t(gnat_gimplify_expr) <CALL_EXPR>: New case.\n\t* gcc-interface/utils2.c (build_binary_op): Do not use |= operator.\n\t(gnat_stabilize_reference_1): Likewise.\n\t(gnat_rewrite_reference): Likewise.\n\t(build_unary_op): Do not clear existing TREE_CONSTANT on the result.\n\t(gnat_build_constructor): Also accept the address of a constant\n\tCONSTRUCTOR as constant element.", "tree": {"sha": "763c35580310792004c439ac5fbc0ed7f665beff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/763c35580310792004c439ac5fbc0ed7f665beff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/comments", "author": null, "committer": null, "parents": [{"sha": "b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b81e2d5e76a6bcc71f45b122e8b5538ddb7ebf4c"}], "stats": {"total": 85, "additions": 64, "deletions": 21}, "files": [{"sha": "6fd5c2c055f89f5a728232bb6ae93ccdaef59b09", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "patch": "@@ -6059,12 +6059,13 @@ gnat_to_gnu_subprog_type (Entity_Id gnat_subprog, bool definition,\n \n \t  /* A pure function in the Ada sense which takes an access parameter\n \t     may modify memory through it and thus need be considered neither\n-\t     const nor pure in the GCC sense.  Likewise it if takes a by-ref\n-\t     In Out or Out parameter.  But if it takes a by-ref In parameter,\n-\t     then it may only read memory through it and can be considered\n-\t     pure in the GCC sense.  */\n+\t     const nor pure in the GCC sense, unless it's access-to-function.\n+\t     Likewise it if takes a by-ref In Out or Out parameter.  But if it\n+\t     takes a by-ref In parameter, then it may only read memory through\n+\t     it and can be considered pure in the GCC sense.  */\n \t  if ((const_flag || pure_flag)\n-\t      && (POINTER_TYPE_P (gnu_param_type)\n+\t      && ((POINTER_TYPE_P (gnu_param_type)\n+\t\t   && TREE_CODE (TREE_TYPE (gnu_param_type)) != FUNCTION_TYPE)\n \t\t  || TYPE_IS_FAT_POINTER_P (gnu_param_type)))\n \t    {\n \t      const_flag = false;"}, {"sha": "246125985737dabf17cdf54a5adf0b3d71d45a6c", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 33, "deletions": 1, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "patch": "@@ -4816,14 +4816,21 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \t may have suppressed a conversion to the Etype of the actual earlier,\n \t since the parent is a procedure call, so put it back here.  Note that\n \t we might have a dummy type here if the actual is the dereference of a\n-\t pointer to it, but that's OK if the formal is passed by reference.  */\n+\t pointer to it, but that's OK when the formal is passed by reference.\n+\t We also do not put back a conversion between an actual and a formal\n+\t that are unconstrained array types to avoid creating local bounds.  */\n       tree gnu_actual_type = get_unpadded_type (Etype (gnat_actual));\n       if (TYPE_IS_DUMMY_P (gnu_actual_type))\n \tgcc_assert (is_true_formal_parm && DECL_BY_REF_P (gnu_formal));\n       else if (suppress_type_conversion\n \t       && Nkind (gnat_actual) == N_Unchecked_Type_Conversion)\n \tgnu_actual = unchecked_convert (gnu_actual_type, gnu_actual,\n \t\t\t\t        No_Truncation (gnat_actual));\n+      else if ((TREE_CODE (TREE_TYPE (gnu_actual)) == UNCONSTRAINED_ARRAY_TYPE\n+\t\t|| (TREE_CODE (TREE_TYPE (gnu_actual)) == RECORD_TYPE\n+\t\t    && TYPE_CONTAINS_TEMPLATE_P (TREE_TYPE (gnu_actual))))\n+\t       && TREE_CODE (gnu_formal_type) == UNCONSTRAINED_ARRAY_TYPE)\n+\t;\n       else\n \tgnu_actual = convert (gnu_actual_type, gnu_actual);\n \n@@ -8835,6 +8842,31 @@ gnat_gimplify_expr (tree *expr_p, gimple_seq *pre_p,\n \n       return GS_UNHANDLED;\n \n+    case CALL_EXPR:\n+      /* If we are passing a constant fat pointer CONSTRUCTOR, make sure it is\n+\t put into static memory; this performs a restricted version of constant\n+\t propagation on fat pointers in calls.  But do not do it for strings to\n+\t avoid blocking concatenation in the caller when it is inlined.  */\n+      for (int i = 0; i < call_expr_nargs (expr); i++)\n+\t{\n+\t  tree arg = *(CALL_EXPR_ARGP (expr) + i);\n+\n+\t  if (TREE_CODE (arg) == CONSTRUCTOR\n+\t      && TREE_CONSTANT (arg)\n+\t      && TYPE_IS_FAT_POINTER_P (TREE_TYPE (arg)))\n+\t    {\n+\t      tree t = CONSTRUCTOR_ELT (arg, 0)->value;\n+\t      if (TREE_CODE (t) == NOP_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) == ADDR_EXPR)\n+\t\tt = TREE_OPERAND (t, 0);\n+\t      if (TREE_CODE (t) != STRING_CST)\n+\t\t*(CALL_EXPR_ARGP (expr) + i) = tree_output_constant_def (arg);\n+\t    }\n+\t}\n+\n+      return GS_UNHANDLED;\n+\n     case VIEW_CONVERT_EXPR:\n       op = TREE_OPERAND (expr, 0);\n "}, {"sha": "3bf0e1546946d3893003c1fbf59ed05f68b407e3", "filename": "gcc/ada/gcc-interface/utils2.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fccc47dddc2ee605dd7fce5c1d1711404e19cd7f/gcc%2Fada%2Fgcc-interface%2Futils2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils2.c?ref=fccc47dddc2ee605dd7fce5c1d1711404e19cd7f", "patch": "@@ -1301,11 +1301,11 @@ build_binary_op (enum tree_code op_code, tree result_type,\n       if (TYPE_VOLATILE (operation_type))\n \tTREE_THIS_VOLATILE (result) = 1;\n     }\n-  else\n-    TREE_CONSTANT (result)\n-      |= (TREE_CONSTANT (left_operand) && TREE_CONSTANT (right_operand));\n+  else if (TREE_CONSTANT (left_operand) && TREE_CONSTANT (right_operand))\n+    TREE_CONSTANT (result) = 1;\n \n-  TREE_SIDE_EFFECTS (result) |= has_side_effects;\n+  if (has_side_effects)\n+    TREE_SIDE_EFFECTS (result) = 1;\n \n   /* If we are working with modular types, perform the MOD operation\n      if something above hasn't eliminated the need for it.  */\n@@ -1528,7 +1528,9 @@ build_unary_op (enum tree_code op_code, tree result_type, tree operand)\n \t  result = build_fold_addr_expr (operand);\n \t}\n \n-      TREE_CONSTANT (result) = staticp (operand) || TREE_CONSTANT (operand);\n+      if (TREE_CONSTANT (operand) || staticp (operand))\n+\tTREE_CONSTANT (result) = 1;\n+\n       break;\n \n     case INDIRECT_REF:\n@@ -1957,14 +1959,19 @@ gnat_build_constructor (tree type, vec<constructor_elt, va_gc> *v)\n      the elements along the way for possible sorting purposes below.  */\n   FOR_EACH_CONSTRUCTOR_ELT (v, n_elmts, obj, val)\n     {\n-      /* The predicate must be in keeping with output_constructor.  */\n+      /* The predicate must be in keeping with output_constructor and, unlike\n+\t initializer_constant_valid_p, we accept \"&{...}\" because we'll put\n+\t the CONSTRUCTOR into the constant pool during gimplification.  */\n       if ((!TREE_CONSTANT (val) && !TREE_STATIC (val))\n \t  || (TREE_CODE (type) == RECORD_TYPE\n \t      && CONSTRUCTOR_BITFIELD_P (obj)\n \t      && !initializer_constant_valid_for_bitfield_p (val))\n-\t  || !initializer_constant_valid_p (val,\n-\t\t\t\t\t    TREE_TYPE (val),\n-\t\t\t\t\t    TYPE_REVERSE_STORAGE_ORDER (type)))\n+\t  || (!initializer_constant_valid_p (val,\n+\t\t\t\t\t     TREE_TYPE (val),\n+\t\t\t\t\t     TYPE_REVERSE_STORAGE_ORDER (type))\n+\t      && !(TREE_CODE (val) == ADDR_EXPR\n+\t\t   && TREE_CODE (TREE_OPERAND (val, 0)) == CONSTRUCTOR\n+\t\t   && TREE_CONSTANT (TREE_OPERAND (val, 0)))))\n \tallconstant = false;\n \n       if (!TREE_READONLY (val))\n@@ -2676,10 +2683,13 @@ gnat_stabilize_reference_1 (tree e, void *data)\n       gcc_unreachable ();\n     }\n \n+  /* See gnat_rewrite_reference below for the rationale.  */\n   TREE_READONLY (result) = TREE_READONLY (e);\n-  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (e);\n   TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (e);\n \n+  if (TREE_SIDE_EFFECTS (e))\n+    TREE_SIDE_EFFECTS (result) = 1;\n+\n   return result;\n }\n \n@@ -2796,18 +2806,18 @@ gnat_rewrite_reference (tree ref, rewrite_fn func, void *data, tree *init)\n       gcc_unreachable ();\n     }\n \n-  /* TREE_THIS_VOLATILE and TREE_SIDE_EFFECTS set on the initial expression\n-     may not be sustained across some paths, such as the way via build1 for\n-     INDIRECT_REF.  We reset those flags here in the general case, which is\n-     consistent with the GCC version of this routine.\n+  /* TREE_READONLY and TREE_THIS_VOLATILE set on the initial expression may\n+     not be sustained across some paths, such as the one for INDIRECT_REF.\n \n      Special care should be taken regarding TREE_SIDE_EFFECTS, because some\n      paths introduce side-effects where there was none initially (e.g. if a\n      SAVE_EXPR is built) and we also want to keep track of that.  */\n   TREE_READONLY (result) = TREE_READONLY (ref);\n-  TREE_SIDE_EFFECTS (result) |= TREE_SIDE_EFFECTS (ref);\n   TREE_THIS_VOLATILE (result) = TREE_THIS_VOLATILE (ref);\n \n+  if (TREE_SIDE_EFFECTS (ref))\n+    TREE_SIDE_EFFECTS (result) = 1;\n+\n   if (code == INDIRECT_REF\n       || code == UNCONSTRAINED_ARRAY_REF\n       || code == ARRAY_REF"}]}