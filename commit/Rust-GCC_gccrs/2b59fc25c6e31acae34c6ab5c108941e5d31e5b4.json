{"sha": "2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI1OWZjMjVjNmUzMWFjYWUzNGM2YWI1YzEwODk0MWU1ZDMxZTViNA==", "commit": {"author": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@users.sourceforge.net", "date": "2003-01-08T14:42:39Z"}, "committer": {"name": "Kriang Lerdsuwanakij", "email": "lerdsuwa@gcc.gnu.org", "date": "2003-01-08T14:42:39Z"}, "message": "re PR c++/9030 (Template friends and access to local classes)\n\n\tPR c++/9030\n\t* decl.c (make_typename_type): Check access only when tf_error.\n\t(make_unbound_class_template): Likewise.\n\t* pt.c (saved_access_scope): New variable.\n\t(push_access_scope_real): New function.\n\t(push_access_scope): Likewise.\n\t(pop_access_scope): Likewise.\n\t(tsubst_default_argument): Use them.\n\t(instantiate_template): Likewise.\n\t(regenerate_decl_from_template): Likewise.\n\t(instantiate_decl): Likewise.\n\t(get_mostly_instantiated_function_type): Likewise.\n\n\t* g++.dg/template/friend12.C: New test.\n\t* g++.dg/template/friend13.C: Likewise.\n\t* g++.old-deja/g++.eh/spec6.C: Add missing error message.\n\nFrom-SVN: r61046", "tree": {"sha": "b20f75bc20fe6a1ea780fb19af201a2a9529519e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b20f75bc20fe6a1ea780fb19af201a2a9529519e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/comments", "author": null, "committer": null, "parents": [{"sha": "c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c5e7ce43a58f9ed299a496f3c3487a7ce7b32de3"}], "stats": {"total": 229, "additions": 187, "deletions": 42}, "files": [{"sha": "26207b7a3736ce8f1933c9976efae612ba5b2c4e", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -1,3 +1,18 @@\n+2003-01-08  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9030\n+\t* decl.c (make_typename_type): Check access only when tf_error.\n+\t(make_unbound_class_template): Likewise.\n+\t* pt.c (saved_access_scope): New variable.\n+\t(push_access_scope_real): New function.\n+\t(push_access_scope): Likewise.\n+\t(pop_access_scope): Likewise.\n+\t(tsubst_default_argument): Use them.\n+\t(instantiate_template): Likewise.\n+\t(regenerate_decl_from_template): Likewise.\n+\t(instantiate_decl): Likewise.\n+\t(get_mostly_instantiated_function_type): Likewise.\n+\n 2003-01-07  Nathanael Nerode <neroden@gcc.gnu.org>\n \n \t* tree.c: Delete bogus #if 0 code."}, {"sha": "538519ed0437bc2d5ddab01a285170d3b9cb1e9a", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 21, "deletions": 12, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -5671,10 +5671,13 @@ make_typename_type (context, name, complain)\n \t      return error_mark_node;\n \t    }\n \n-\t  if (complain & tf_parsing)\n-\t    type_access_control (context, tmpl);\n-\t  else\n-\t    enforce_access (context, tmpl);\n+\t  if (complain & tf_error)\n+\t    {\n+\t      if (complain & tf_parsing)\n+\t\ttype_access_control (context, tmpl);\n+\t      else\n+\t\tenforce_access (context, tmpl);\n+\t    }\n \n \t  return lookup_template_class (tmpl,\n \t\t\t\t\tTREE_OPERAND (fullname, 1),\n@@ -5703,10 +5706,13 @@ make_typename_type (context, name, complain)\n \t\t  return error_mark_node;\n \t\t}\n \n-\t      if (complain & tf_parsing)\n-\t\ttype_access_control (context, t);\n-\t      else\n-\t\tenforce_access (context, t);\n+\t      if (complain & tf_error)\n+\t\t{\n+\t      \t  if (complain & tf_parsing)\n+\t\t    type_access_control (context, t);\n+\t\t  else\n+\t\t    enforce_access (context, t);\n+\t\t}\n \n \t      if (DECL_ARTIFICIAL (t) || !(complain & tf_keep_type_decl))\n \t\tt = TREE_TYPE (t);\n@@ -5774,10 +5780,13 @@ make_unbound_class_template (context, name, complain)\n \t  return error_mark_node;\n \t}\n       \n-      if (complain & tf_parsing)\n-\ttype_access_control (context, tmpl);\n-      else\n-\tenforce_access (context, tmpl);\n+      if (complain & tf_error)\n+\t{\n+\t  if (complain & tf_parsing)\n+\t    type_access_control (context, tmpl);\n+\t  else\n+\t    enforce_access (context, tmpl);\n+\t}\n \n       return tmpl;\n     }"}, {"sha": "b63443b174bb62dbeb3c8e907face8c3c06f3937", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 98, "deletions": 29, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -67,6 +67,8 @@ static size_t inline_parm_levels_used;\n \n static GTY(()) tree current_tinst_level;\n \n+static GTY(()) tree saved_access_scope;\n+\n /* A map from local variable declarations in the body of the template\n    presently being instantiated to the corresponding instantiated\n    local variables.  */\n@@ -88,6 +90,9 @@ static htab_t local_specializations;\n #define GTB_IGNORE_TYPE 2 /* We don't need to try to unify the current\n \t\t\t     type with the desired type.  */\n \n+static void push_access_scope_real PARAMS ((tree, tree, tree));\n+static void push_access_scope PARAMS ((tree));\n+static void pop_access_scope PARAMS ((tree));\n static int resolve_overloaded_unification PARAMS ((tree, tree, tree, tree,\n \t\t\t\t\t\t   unification_kind_t, int));\n static int try_one_overload PARAMS ((tree, tree, tree, tree, tree,\n@@ -168,6 +173,80 @@ static int invalid_nontype_parm_type_p PARAMS ((tree, tsubst_flags_t));\n static int eq_local_specializations (const void *, const void *);\n static tree template_for_substitution (tree);\n \n+/* Make the current scope suitable for access checking when we are\n+   processing T.  T can be FUNCTION_DECL for instantiated function\n+   template, TEMPLATE_DECL for uninstantiated one, or VAR_DECL for\n+   static member variable (need by instantiate_decl).  ARGS is the \n+   template argument for TEMPLATE_DECL.  If CONTEXT is not NULL_TREE, \n+   this is used instead of the context of T.  */\n+\n+void\n+push_access_scope_real (t, args, context)\n+  tree t, args, context;\n+{\n+  if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n+    {\n+      /* When we are processing specialization `foo<Outer>' for code like\n+\n+\t   template <class U> typename U::Inner foo ();\n+\t   class Outer {\n+\t     struct Inner {};\n+\t     friend Outer::Inner foo<Outer> ();\n+\t   };\n+\n+\t `T' is a TEMPLATE_DECL, but `Outer' is only a friend of one of\n+\t its specialization.  We can get the FUNCTION_DECL with the right\n+\t information because this specialization has already been\n+\t registered by the friend declaration above.  */\n+\n+      if (DECL_FUNCTION_TEMPLATE_P (t) && args)\n+\t{\n+\t  tree full_args = tsubst_template_arg_vector\n+\t    (DECL_TI_ARGS (DECL_TEMPLATE_RESULT (t)), args, tf_none);\n+\t  tree spec = NULL_TREE;\n+\t  if (full_args != error_mark_node)\n+\t    spec = retrieve_specialization (t, full_args);\n+\t  if (spec)\n+\t    t = spec;\n+\t}\n+\n+      saved_access_scope = tree_cons\n+\t(NULL_TREE, current_function_decl, saved_access_scope);\n+      current_function_decl = t;\n+    }\n+\n+  if (!context)\n+    context = DECL_CONTEXT (t);\n+  if (context && TYPE_P (context))\n+    push_nested_class (context, 2);\n+}\n+\n+/* Like push_access_scope_real, but always uses DECL_CONTEXT.  */\n+\n+void\n+push_access_scope (t)\n+  tree t;\n+{\n+  push_access_scope_real (t, NULL_TREE, NULL_TREE);\n+}\n+\n+/* Restore the scope set up by push_access_scope.  T is the node we\n+   are processing.  */\n+\n+void\n+pop_access_scope (t)\n+  tree t;\n+{\n+  if (DECL_CLASS_SCOPE_P (t))\n+    pop_nested_class ();\n+\n+  if (TREE_CODE (t) == FUNCTION_DECL || DECL_FUNCTION_TEMPLATE_P (t))\n+    {\n+      current_function_decl = TREE_VALUE (saved_access_scope);\n+      saved_access_scope = TREE_CHAIN (saved_access_scope);\n+    }\n+}\n+\n /* Do any processing required when DECL (a member template\n    declaration) is finished.  Returns the TEMPLATE_DECL corresponding\n    to DECL, unless it is a specialization, in which case the DECL\n@@ -5733,14 +5812,14 @@ tsubst_default_argument (fn, type, arg)\n      ??? current_class_type affects a lot more than name lookup.  This is\n      very fragile.  Fortunately, it will go away when we do 2-phase name\n      binding properly.  */\n-  if (DECL_CLASS_SCOPE_P (fn))\n-    pushclass (DECL_CONTEXT (fn), 2);\n+\n+  /* FN is already the desired FUNCTION_DECL.  */\n+  push_access_scope (fn);\n \n   arg = tsubst_expr (arg, DECL_TI_ARGS (fn),\n \t\t     tf_error | tf_warning, NULL_TREE);\n   \n-  if (DECL_CLASS_SCOPE_P (fn))\n-    popclass ();\n+  pop_access_scope (fn);\n \n   /* Make sure the default argument is reasonable.  */\n   arg = check_default_argument (type, arg);\n@@ -7873,17 +7952,17 @@ instantiate_template (tmpl, targ_ptr)\n     }\n \n   /* Make sure that we can see identifiers, and compute access\n-     correctly.  */\n-  if (DECL_CLASS_SCOPE_P (gen_tmpl))\n-    pushclass (tsubst (DECL_CONTEXT (gen_tmpl), targ_ptr, tf_error,\n-\t\t       gen_tmpl), 1);\n+     correctly.  The desired FUNCTION_DECL for FNDECL may or may not be\n+     created earlier.  Let push_access_scope_real figure that out.  */\n+  push_access_scope_real\n+    (gen_tmpl, targ_ptr, tsubst (DECL_CONTEXT (gen_tmpl), targ_ptr, \n+\t\t\t\t tf_error, gen_tmpl));\n \n   /* substitute template parameters */\n   fndecl = tsubst (DECL_TEMPLATE_RESULT (gen_tmpl),\n \t\t   targ_ptr, tf_error, gen_tmpl);\n \n-  if (DECL_CLASS_SCOPE_P (gen_tmpl))\n-    popclass ();\n+  pop_access_scope (gen_tmpl);\n \n   /* The DECL_TI_TEMPLATE should always be the immediate parent\n      template, not the most general template.  */\n@@ -7955,7 +8034,7 @@ fn_type_unification (fn, explicit_targs, targs, args, return_type,\n   int result;\n \n   my_friendly_assert (TREE_CODE (fn) == TEMPLATE_DECL, 0);\n-  \n+\n   fntype = TREE_TYPE (fn);\n   if (explicit_targs)\n     {\n@@ -9977,19 +10056,14 @@ regenerate_decl_from_template (decl, tmpl)\n      instantiation of a specialization, which it isn't: it's a full\n      instantiation.  */\n   gen_tmpl = most_general_template (tmpl);\n+  push_access_scope_real (gen_tmpl, args, DECL_CONTEXT (decl));\n   unregistered = unregister_specialization (decl, gen_tmpl);\n \n   /* If the DECL was not unregistered then something peculiar is\n      happening: we created a specialization but did not call\n      register_specialization for it.  */\n   my_friendly_assert (unregistered, 0);\n \n-  if (DECL_CLASS_SCOPE_P (decl))\n-    /* Make sure that we can see identifiers, and compute access\n-       correctly, for the class members used in the declaration of\n-       this static variable or function.  */\n-    push_nested_class (DECL_CONTEXT (decl), 2);\n-\n   /* Do the substitution to get the new declaration.  */\n   new_decl = tsubst (code_pattern, args, tf_error, NULL_TREE);\n \n@@ -10010,9 +10084,7 @@ regenerate_decl_from_template (decl, tmpl)\n       DECL_INITIAL (decl) = NULL_TREE;\n     }\n \n-  /* Pop the class context we pushed above.  */\n-  if (DECL_CLASS_SCOPE_P (decl))\n-    pop_nested_class ();\n+  pop_access_scope (decl);\n \n   /* The immediate parent of the new template is still whatever it was\n      before, even though tsubst sets DECL_TI_TEMPLATE up as the most\n@@ -10218,9 +10290,9 @@ instantiate_decl (d, defer_ok)\n       tree type = TREE_TYPE (gen);\n \n       /* Make sure that we can see identifiers, and compute access\n-\t correctly.  */\n-      if (DECL_CLASS_SCOPE_P (d))\n-\tpushclass (DECL_CONTEXT (d), 1);\n+\t correctly.  D is already the target FUNCTION_DECL with the\n+\t right context.  */\n+      push_access_scope (d);\n \n       if (TREE_CODE (gen) == FUNCTION_DECL)\n \t{\n@@ -10235,8 +10307,7 @@ instantiate_decl (d, defer_ok)\n \t}\n       tsubst (type, gen_args, tf_error | tf_warning, d);\n \n-      if (DECL_CLASS_SCOPE_P (d))\n-\tpopclass ();\n+      pop_access_scope (d);\n     }\n   \n   if (TREE_CODE (d) == VAR_DECL && DECL_INITIALIZED_IN_CLASS_P (d)\n@@ -10597,8 +10668,7 @@ get_mostly_instantiated_function_type (decl)\n \t partial substitution here.  It depends only on outer template\n \t parameters, regardless of whether the innermost level is\n \t specialized or not.  */\n-      if (DECL_CLASS_SCOPE_P (decl))\n-\tpushclass (DECL_CONTEXT (decl), 1);\n+      push_access_scope (decl);\n \n       /* Now, do the (partial) substitution to figure out the\n \t appropriate function type.  */\n@@ -10611,8 +10681,7 @@ get_mostly_instantiated_function_type (decl)\n       TREE_VEC_LENGTH (partial_args)--;\n       tparms = tsubst_template_parms (tparms, partial_args, tf_error);\n \n-      if (DECL_CLASS_SCOPE_P (decl))\n-\tpopclass ();\n+      pop_access_scope (decl);\n     }\n \n   return fn_type;"}, {"sha": "848423d59d3a28b8ca5913ab88c4b7f124fe1efb", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -1,3 +1,10 @@\n+2003-01-08  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n+\n+\tPR c++/9030\n+\t* g++.dg/template/friend12.C: New test.\n+\t* g++.dg/template/friend13.C: Likewise.\n+\t* g++.old-deja/g++.eh/spec6.C: Add missing error message.\n+\n Wed Jan  8 11:41:47 CET 2003  Jan Hubicka  <jh@suse.cz>\n \n \t* gcc.dg/i386-cadd.c: New test."}, {"sha": "0cd561b5a2a205269c6922212b65dbd49a9d0d17", "filename": "gcc/testsuite/g++.dg/template/friend12.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend12.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend12.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend12.C?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do compile }\n+\n+// Origin: Wolfgang Bangerth <bangerth@ticam.utexas.edu>\n+\n+// PR 9030.  Perform access checking to parameter and return type of \n+// function template correctly when the template is friend.\n+\n+template <class T> class Outer {\n+  private:\n+    struct Inner {};\n+\n+    template <class T_>\n+    friend typename Outer<T_>::Inner foo ();\n+};\n+\n+template <class T>\n+typename Outer<T>::Inner\n+foo () {\n+  return typename Outer<T>::Inner();\n+}\n+\n+void f() {\n+  foo<int>();\n+}"}, {"sha": "6eebf6b951f4942009c04019531133c8d885b12d", "filename": "gcc/testsuite/g++.dg/template/friend13.C", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend13.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend13.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Ffriend13.C?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -0,0 +1,21 @@\n+// { dg-do compile }\n+\n+// Perform access checking to parameter and return type of \n+// function template correctly when only specialization is friend.\n+\n+template <class T>\n+typename T::Inner\n+foo () {\n+  return typename T::Inner();\n+}\n+\n+class Outer {\n+  private:\n+    struct Inner {};\n+\n+    friend Outer::Inner foo<Outer> ();\n+};\n+\n+void f() {\n+  foo<Outer>();\n+}"}, {"sha": "d9d4edf1f48d58466be5c4f496c9af25038ae88e", "filename": "gcc/testsuite/g++.old-deja/g++.eh/spec6.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b59fc25c6e31acae34c6ab5c108941e5d31e5b4/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.eh%2Fspec6.C?ref=2b59fc25c6e31acae34c6ab5c108941e5d31e5b4", "patch": "@@ -25,7 +25,7 @@ template<class T> void fnx(T *) throw(T){}  // ERROR - invalid use of void expre\n void fx()\n {\n   fnx((int *)0);\n-  fnx((void *)0);\n+  fnx((void *)0);\t\t// ERROR - instantiated from here\n }\n \n // [except.spec] 2, exception specifiers must be the same set of types (but"}]}