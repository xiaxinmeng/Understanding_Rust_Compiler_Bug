{"sha": "428b1317a5a94d5a99bdc617bac908cf8a10af25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDI4YjEzMTdhNWE5NGQ1YTk5YmRjNjE3YmFjOTA4Y2Y4YTEwYWYyNQ==", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2020-10-06T10:12:28Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-24T10:16:05Z"}, "message": "[Ada] Replace chained if-then-elsif with case stmt for attribute ids\n\ngcc/ada/\n\n\t* exp_spark.adb (Expand_SPARK_N_Attribute_Reference): Rewrite\n\twith a CASE statement.", "tree": {"sha": "42e0e4cb9550b629806bea18c063a3fe74b81b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42e0e4cb9550b629806bea18c063a3fe74b81b8e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/428b1317a5a94d5a99bdc617bac908cf8a10af25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428b1317a5a94d5a99bdc617bac908cf8a10af25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/428b1317a5a94d5a99bdc617bac908cf8a10af25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/428b1317a5a94d5a99bdc617bac908cf8a10af25/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3a6fa9a81bdbd5491204e68b2ad5a5d8516d56a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a6fa9a81bdbd5491204e68b2ad5a5d8516d56a1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a6fa9a81bdbd5491204e68b2ad5a5d8516d56a1"}], "stats": {"total": 170, "additions": 87, "deletions": 83}, "files": [{"sha": "7909944f61b83e5c8d7463e4ee2c020ebc26427a", "filename": "gcc/ada/exp_spark.adb", "status": "modified", "additions": 87, "deletions": 83, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/428b1317a5a94d5a99bdc617bac908cf8a10af25/gcc%2Fada%2Fexp_spark.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/428b1317a5a94d5a99bdc617bac908cf8a10af25/gcc%2Fada%2Fexp_spark.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_spark.adb?ref=428b1317a5a94d5a99bdc617bac908cf8a10af25", "patch": "@@ -374,101 +374,105 @@ package body Exp_SPARK is\n       Expr    : Node_Id;\n \n    begin\n-      if Attr_Id = Attribute_To_Address then\n+      case Attr_Id is\n+         when Attribute_To_Address =>\n \n-         --  Extract and convert argument to expected type for call\n+            --  Extract and convert argument to expected type for call\n \n-         Expr :=\n-           Make_Type_Conversion (Loc,\n-             Subtype_Mark =>\n-               New_Occurrence_Of (RTE (RE_Integer_Address), Loc),\n-             Expression   => Relocate_Node (First (Expressions (N))));\n+            Expr :=\n+              Make_Type_Conversion (Loc,\n+                Subtype_Mark =>\n+                  New_Occurrence_Of (RTE (RE_Integer_Address), Loc),\n+                Expression   => Relocate_Node (First (Expressions (N))));\n \n-         --  Replace attribute reference with call\n+            --  Replace attribute reference with call\n \n-         Rewrite (N,\n-           Make_Function_Call (Loc,\n-             Name                   =>\n-               New_Occurrence_Of (RTE (RE_To_Address), Loc),\n-             Parameter_Associations => New_List (Expr)));\n-         Analyze_And_Resolve (N, Typ);\n-\n-      elsif Attr_Id = Attribute_Object_Size\n-        or else Attr_Id = Attribute_Size\n-        or else Attr_Id = Attribute_Value_Size\n-        or else Attr_Id = Attribute_VADS_Size\n-      then\n-         Exp_Attr.Expand_Size_Attribute (N);\n-\n-      --  For attributes which return Universal_Integer, introduce a conversion\n-      --  to the expected type with the appropriate check flags set.\n-\n-      elsif Attr_Id = Attribute_Alignment\n-        or else Attr_Id = Attribute_Bit\n-        or else Attr_Id = Attribute_Bit_Position\n-        or else Attr_Id = Attribute_Descriptor_Size\n-        or else Attr_Id = Attribute_First_Bit\n-        or else Attr_Id = Attribute_Last_Bit\n-        or else Attr_Id = Attribute_Length\n-        or else Attr_Id = Attribute_Max_Size_In_Storage_Elements\n-        or else Attr_Id = Attribute_Pos\n-        or else Attr_Id = Attribute_Position\n-        or else Attr_Id = Attribute_Range_Length\n-        or else Attr_Id = Attribute_Aft\n-        or else Attr_Id = Attribute_Max_Alignment_For_Allocation\n-      then\n-         --  If the expected type is Long_Long_Integer, there will be no check\n-         --  flag as the compiler assumes attributes always fit in this type.\n-         --  Since in SPARK_Mode we do not take Storage_Error into account, we\n-         --  cannot make this assumption and need to produce a check.\n-         --  ??? It should be enough to add this check for attributes\n-         --  'Length, 'Range_Length and 'Pos when the type is as big\n-         --  as Long_Long_Integer.\n-\n-         declare\n-            Typ : Entity_Id;\n-         begin\n-            if Attr_Id = Attribute_Range_Length\n-              or else Attr_Id = Attribute_Pos\n-            then\n-               Typ := Etype (Prefix (N));\n+            Rewrite\n+              (N,\n+               Make_Function_Call (Loc,\n+                 Name                   =>\n+                   New_Occurrence_Of (RTE (RE_To_Address), Loc),\n+                 Parameter_Associations => New_List (Expr)));\n+            Analyze_And_Resolve (N, Typ);\n \n-            elsif Attr_Id = Attribute_Length then\n-               Typ := Get_Index_Subtype (N);\n+         when Attribute_Object_Size\n+            | Attribute_Size\n+            | Attribute_Value_Size\n+            | Attribute_VADS_Size\n+         =>\n+            Exp_Attr.Expand_Size_Attribute (N);\n+\n+         --  For attributes which return Universal_Integer, introduce a\n+         --  conversion to the expected type with the appropriate check flags\n+         --  set.\n+\n+         when Attribute_Aft\n+            | Attribute_Alignment\n+            | Attribute_Bit\n+            | Attribute_Bit_Position\n+            | Attribute_Descriptor_Size\n+            | Attribute_First_Bit\n+            | Attribute_Last_Bit\n+            | Attribute_Length\n+            | Attribute_Max_Alignment_For_Allocation\n+            | Attribute_Max_Size_In_Storage_Elements\n+            | Attribute_Pos\n+            | Attribute_Position\n+            | Attribute_Range_Length\n+         =>\n+            --  If the expected type is Long_Long_Integer, there will be no\n+            --  check flag as the compiler assumes attributes always fit in\n+            --  this type. Since in SPARK_Mode we do not take Storage_Error\n+            --  into account, we cannot make this assumption and need to\n+            --  produce a check. ??? It should be enough to add this check for\n+            --  attributes 'Length, 'Range_Length and 'Pos when the type is as\n+            --  big as Long_Long_Integer.\n+\n+            declare\n+               Typ : Entity_Id;\n+            begin\n+               if Attr_Id in Attribute_Pos | Attribute_Range_Length then\n+                  Typ := Etype (Prefix (N));\n+\n+               elsif Attr_Id = Attribute_Length then\n+                  Typ := Get_Index_Subtype (N);\n+\n+               else\n+                  Typ := Empty;\n+               end if;\n \n-            else\n-               Typ := Empty;\n-            end if;\n+               Apply_Universal_Integer_Attribute_Checks (N);\n \n-            Apply_Universal_Integer_Attribute_Checks (N);\n+               if Present (Typ)\n+                 and then RM_Size (Typ) = RM_Size (Standard_Long_Long_Integer)\n+               then\n+                  --  ??? This should rather be a range check, but this would\n+                  --  crash GNATprove which somehow recovers the proper kind\n+                  --  of check anyway.\n+                  Set_Do_Overflow_Check (N);\n+               end if;\n+            end;\n \n-            if Present (Typ)\n-              and then RM_Size (Typ) = RM_Size (Standard_Long_Long_Integer)\n-            then\n-               --  ??? This should rather be a range check, but this would\n-               --  crash GNATprove which somehow recovers the proper kind\n-               --  of check anyway.\n-               Set_Do_Overflow_Check (N);\n-            end if;\n-         end;\n+         when Attribute_Constrained =>\n \n-      elsif Attr_Id = Attribute_Constrained then\n+            --  If the prefix is an access to object, the attribute applies to\n+            --  the designated object, so rewrite with an explicit dereference.\n \n-         --  If the prefix is an access to object, the attribute applies to\n-         --  the designated object, so rewrite with an explicit dereference.\n+            if Is_Access_Type (Etype (Pref))\n+              and then\n+              (not Is_Entity_Name (Pref) or else Is_Object (Entity (Pref)))\n+            then\n+               Rewrite (Pref,\n+                        Make_Explicit_Dereference (Loc, Relocate_Node (Pref)));\n+               Analyze_And_Resolve (N, Standard_Boolean);\n+            end if;\n \n-         if Is_Access_Type (Etype (Pref))\n-           and then\n-             (not Is_Entity_Name (Pref) or else Is_Object (Entity (Pref)))\n-         then\n-            Rewrite (Pref,\n-                     Make_Explicit_Dereference (Loc, Relocate_Node (Pref)));\n-            Analyze_And_Resolve (N, Standard_Boolean);\n-         end if;\n+         when Attribute_Update =>\n+            Expand_SPARK_Delta_Or_Update (Typ, First (Expressions (N)));\n \n-      elsif Attr_Id = Attribute_Update then\n-         Expand_SPARK_Delta_Or_Update (Typ, First (Expressions (N)));\n-      end if;\n+         when others =>\n+            null;\n+      end case;\n    end Expand_SPARK_N_Attribute_Reference;\n \n    ------------------------------------"}]}