{"sha": "42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJmZDgxOThiNGFkYWJlM2FhNzRlOWJiOTg1MThhMWQxMzdjM2FmZg==", "commit": {"author": {"name": "Ilya Enkovich", "email": "enkovich.gnu@gmail.com", "date": "2015-11-10T11:57:34Z"}, "committer": {"name": "Ilya Enkovich", "email": "ienkovich@gcc.gnu.org", "date": "2015-11-10T11:57:34Z"}, "message": "expr.c (do_store_flag): Use expand_vec_cmp_expr for mask results.\n\ngcc/\n\n\t* expr.c (do_store_flag): Use expand_vec_cmp_expr for mask results.\n\t(const_vector_mask_from_tree): New.\n\t(const_vector_from_tree): Use const_vector_mask_from_tree\n\tfor boolean vectors.\n\t* optabs-query.h (get_vec_cmp_icode): New.\n\t* optabs-tree.c (expand_vec_cmp_expr_p): New.\n\t* optabs-tree.h (expand_vec_cmp_expr_p): New.\n\t* optabs.c (vector_compare_rtx): Add OPNO arg.\n\t(expand_vec_cond_expr): Adjust to vector_compare_rtx change.\n\t(expand_vec_cmp_expr): New.\n\t* optabs.def (vec_cmp_optab): New.\n\t(vec_cmpu_optab): New.\n\t* optabs.h (expand_vec_cmp_expr): New.\n\t* tree-vect-generic.c (expand_vector_comparison): Add vector\n\tcomparison optabs check.\n\t* tree-vect-loop.c (vect_determine_vectorization_factor):  Ignore mask\n\toperations for VF.  Add mask type computation.\n\t* tree-vect-stmts.c (get_mask_type_for_scalar_type): New.\n\t(vectorizable_comparison): New.\n\t(vect_analyze_stmt): Add vectorizable_comparison.\n\t(vect_transform_stmt): Likewise.\n\t(vect_init_vector): Support boolean vector invariants.\n\t(vect_get_vec_def_for_operand): Add VECTYPE arg.\n\t(vectorizable_condition): Directly provide vectype for invariants\n\tused in comparison.\n\t* tree-vectorizer.h (get_mask_type_for_scalar_type): New.\n\t(enum vect_var_kind): Add vect_mask_var.\n\t(enum stmt_vec_info_type): Add comparison_vec_info_type.\n\t(vectorizable_comparison): New.\n\t(vect_get_vec_def_for_operand): Add VECTYPE arg.\n\t* tree-vect-data-refs.c (vect_get_new_vect_var): Support vect_mask_var.\n\t(vect_create_destination_var): Likewise.\n\t* tree-vect-patterns.c (check_bool_pattern): Check fails\n\tif we can vectorize comparison directly.\n\t(search_type_for_mask): New.\n\t(vect_recog_bool_pattern): Support cases when bool pattern\n\tcheck fails.\n\t* tree-vect-slp.c (vect_build_slp_tree_1): Allow\n\tcomparison statements.\n\t(vect_get_constant_vectors): Support boolean vector\n\tconstants.\n\t* config/i386/i386-protos.h (ix86_expand_mask_vec_cmp): New.\n\t(ix86_expand_int_vec_cmp): New.\n\t(ix86_expand_fp_vec_cmp): New.\n\t* config/i386/i386.c (ix86_expand_sse_cmp): Allow NULL for\n\top_true and op_false.\n\t(ix86_int_cmp_code_to_pcmp_immediate): New.\n\t(ix86_fp_cmp_code_to_pcmp_immediate): New.\n\t(ix86_cmp_code_to_pcmp_immediate): New.\n\t(ix86_expand_mask_vec_cmp): New.\n\t(ix86_expand_fp_vec_cmp): New.\n\t(ix86_expand_int_sse_cmp): New.\n\t(ix86_expand_int_vcond): Use ix86_expand_int_sse_cmp.\n\t(ix86_expand_int_vec_cmp): New.\n\t(ix86_get_mask_mode): New.\n\t(TARGET_VECTORIZE_GET_MASK_MODE): New.\n\t* config/i386/sse.md (avx512fmaskmodelower): New.\n\t(vec_cmp<mode><avx512fmaskmodelower>): New.\n\t(vec_cmp<mode><sseintvecmodelower>): New.\n\t(vec_cmpv2div2di): New.\n\t(vec_cmpu<mode><avx512fmaskmodelower>): New.\n\t(vec_cmpu<mode><sseintvecmodelower>): New.\n\t(vec_cmpuv2div2di): New.\n\ngcc/testsuite/\n\n\t* gcc.dg/vect/slp-cond-5.c: New test.\n\nFrom-SVN: r230098", "tree": {"sha": "5b2a30146ccd97f4ba3781bec197d5f88c9ed198", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5b2a30146ccd97f4ba3781bec197d5f88c9ed198"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/comments", "author": null, "committer": null, "parents": [{"sha": "fb9333352b384e007d9b05f674d4fb452d3d7019", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fb9333352b384e007d9b05f674d4fb452d3d7019", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fb9333352b384e007d9b05f674d4fb452d3d7019"}], "stats": {"total": 1411, "additions": 1280, "deletions": 131}, "files": [{"sha": "0141553d30799ac5e3fda72ab8b716f794eda3f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -1,3 +1,69 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* expr.c (do_store_flag): Use expand_vec_cmp_expr for mask results.\n+\t(const_vector_mask_from_tree): New.\n+\t(const_vector_from_tree): Use const_vector_mask_from_tree\n+\tfor boolean vectors.\n+\t* optabs-query.h (get_vec_cmp_icode): New.\n+\t* optabs-tree.c (expand_vec_cmp_expr_p): New.\n+\t* optabs-tree.h (expand_vec_cmp_expr_p): New.\n+\t* optabs.c (vector_compare_rtx): Add OPNO arg.\n+\t(expand_vec_cond_expr): Adjust to vector_compare_rtx change.\n+\t(expand_vec_cmp_expr): New.\n+\t* optabs.def (vec_cmp_optab): New.\n+\t(vec_cmpu_optab): New.\n+\t* optabs.h (expand_vec_cmp_expr): New.\n+\t* tree-vect-generic.c (expand_vector_comparison): Add vector\n+\tcomparison optabs check.\n+\t* tree-vect-loop.c (vect_determine_vectorization_factor):  Ignore mask\n+\toperations for VF.  Add mask type computation.\n+\t* tree-vect-stmts.c (get_mask_type_for_scalar_type): New.\n+\t(vectorizable_comparison): New.\n+\t(vect_analyze_stmt): Add vectorizable_comparison.\n+\t(vect_transform_stmt): Likewise.\n+\t(vect_init_vector): Support boolean vector invariants.\n+\t(vect_get_vec_def_for_operand): Add VECTYPE arg.\n+\t(vectorizable_condition): Directly provide vectype for invariants\n+\tused in comparison.\n+\t* tree-vectorizer.h (get_mask_type_for_scalar_type): New.\n+\t(enum vect_var_kind): Add vect_mask_var.\n+\t(enum stmt_vec_info_type): Add comparison_vec_info_type.\n+\t(vectorizable_comparison): New.\n+\t(vect_get_vec_def_for_operand): Add VECTYPE arg.\n+\t* tree-vect-data-refs.c (vect_get_new_vect_var): Support vect_mask_var.\n+\t(vect_create_destination_var): Likewise.\n+\t* tree-vect-patterns.c (check_bool_pattern): Check fails\n+\tif we can vectorize comparison directly.\n+\t(search_type_for_mask): New.\n+\t(vect_recog_bool_pattern): Support cases when bool pattern\n+\tcheck fails.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1): Allow\n+\tcomparison statements.\n+\t(vect_get_constant_vectors): Support boolean vector\n+\tconstants.\n+\t* config/i386/i386-protos.h (ix86_expand_mask_vec_cmp): New.\n+\t(ix86_expand_int_vec_cmp): New.\n+\t(ix86_expand_fp_vec_cmp): New.\n+\t* config/i386/i386.c (ix86_expand_sse_cmp): Allow NULL for\n+\top_true and op_false.\n+\t(ix86_int_cmp_code_to_pcmp_immediate): New.\n+\t(ix86_fp_cmp_code_to_pcmp_immediate): New.\n+\t(ix86_cmp_code_to_pcmp_immediate): New.\n+\t(ix86_expand_mask_vec_cmp): New.\n+\t(ix86_expand_fp_vec_cmp): New.\n+\t(ix86_expand_int_sse_cmp): New.\n+\t(ix86_expand_int_vcond): Use ix86_expand_int_sse_cmp.\n+\t(ix86_expand_int_vec_cmp): New.\n+\t(ix86_get_mask_mode): New.\n+\t(TARGET_VECTORIZE_GET_MASK_MODE): New.\n+\t* config/i386/sse.md (avx512fmaskmodelower): New.\n+\t(vec_cmp<mode><avx512fmaskmodelower>): New.\n+\t(vec_cmp<mode><sseintvecmodelower>): New.\n+\t(vec_cmpv2div2di): New.\n+\t(vec_cmpu<mode><avx512fmaskmodelower>): New.\n+\t(vec_cmpu<mode><sseintvecmodelower>): New.\n+\t(vec_cmpuv2div2di): New.\n+\n 2015-11-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68240"}, {"sha": "9e20714099d8b1ef9cb4b1115894438e7b732d35", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -129,6 +129,9 @@ extern bool ix86_expand_fp_vcond (rtx[]);\n extern bool ix86_expand_int_vcond (rtx[]);\n extern void ix86_expand_vec_perm (rtx[]);\n extern bool ix86_expand_vec_perm_const (rtx[]);\n+extern bool ix86_expand_mask_vec_cmp (rtx[]);\n+extern bool ix86_expand_int_vec_cmp (rtx[]);\n+extern bool ix86_expand_fp_vec_cmp (rtx[]);\n extern void ix86_expand_sse_unpack (rtx, rtx, bool, bool);\n extern bool ix86_expand_int_addcc (rtx[]);\n extern rtx ix86_expand_call (rtx, rtx, rtx, rtx, rtx, bool);"}, {"sha": "f6c17dfd405924cdcadbb6066cf82c9725413d3f", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 303, "deletions": 83, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -22582,8 +22582,8 @@ ix86_expand_sse_cmp (rtx dest, enum rtx_code code, rtx cmp_op0, rtx cmp_op1,\n     cmp_op1 = force_reg (cmp_ops_mode, cmp_op1);\n \n   if (optimize\n-      || reg_overlap_mentioned_p (dest, op_true)\n-      || reg_overlap_mentioned_p (dest, op_false))\n+      || (op_true && reg_overlap_mentioned_p (dest, op_true))\n+      || (op_false && reg_overlap_mentioned_p (dest, op_false)))\n     dest = gen_reg_rtx (maskcmp ? cmp_mode : mode);\n \n   /* Compare patterns for int modes are unspec in AVX512F only.  */\n@@ -22644,6 +22644,14 @@ ix86_expand_sse_movcc (rtx dest, rtx cmp, rtx op_true, rtx op_false)\n \n   rtx t2, t3, x;\n \n+  /* If we have an integer mask and FP value then we need\n+     to cast mask to FP mode.  */\n+  if (mode != cmpmode && VECTOR_MODE_P (cmpmode))\n+    {\n+      cmp = force_reg (cmpmode, cmp);\n+      cmp = gen_rtx_SUBREG (mode, cmp, 0);\n+    }\n+\n   if (vector_all_ones_operand (op_true, mode)\n       && rtx_equal_p (op_false, CONST0_RTX (mode))\n       && !maskcmp)\n@@ -22855,107 +22863,154 @@ ix86_expand_fp_movcc (rtx operands[])\n   return true;\n }\n \n-/* Expand a floating-point vector conditional move; a vcond operation\n-   rather than a movcc operation.  */\n+/* Helper for ix86_cmp_code_to_pcmp_immediate for int modes.  */\n+\n+static int\n+ix86_int_cmp_code_to_pcmp_immediate (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return 0;\n+    case LT:\n+    case LTU:\n+      return 1;\n+    case LE:\n+    case LEU:\n+      return 2;\n+    case NE:\n+      return 4;\n+    case GE:\n+    case GEU:\n+      return 5;\n+    case GT:\n+    case GTU:\n+      return 6;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Helper for ix86_cmp_code_to_pcmp_immediate for fp modes.  */\n+\n+static int\n+ix86_fp_cmp_code_to_pcmp_immediate (enum rtx_code code)\n+{\n+  switch (code)\n+    {\n+    case EQ:\n+      return 0x08;\n+    case NE:\n+      return 0x04;\n+    case GT:\n+      return 0x16;\n+    case LE:\n+      return 0x1a;\n+    case GE:\n+      return 0x15;\n+    case LT:\n+      return 0x19;\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Return immediate value to be used in UNSPEC_PCMP\n+   for comparison CODE in MODE.  */\n+\n+static int\n+ix86_cmp_code_to_pcmp_immediate (enum rtx_code code, machine_mode mode)\n+{\n+  if (FLOAT_MODE_P (mode))\n+    return ix86_fp_cmp_code_to_pcmp_immediate (code);\n+  return ix86_int_cmp_code_to_pcmp_immediate (code);\n+}\n+\n+/* Expand AVX-512 vector comparison.  */\n \n bool\n-ix86_expand_fp_vcond (rtx operands[])\n+ix86_expand_mask_vec_cmp (rtx operands[])\n {\n-  enum rtx_code code = GET_CODE (operands[3]);\n+  machine_mode mask_mode = GET_MODE (operands[0]);\n+  machine_mode cmp_mode = GET_MODE (operands[2]);\n+  enum rtx_code code = GET_CODE (operands[1]);\n+  rtx imm = GEN_INT (ix86_cmp_code_to_pcmp_immediate (code, cmp_mode));\n+  int unspec_code;\n+  rtx unspec;\n+\n+  switch (code)\n+    {\n+    case LEU:\n+    case GTU:\n+    case GEU:\n+    case LTU:\n+      unspec_code = UNSPEC_UNSIGNED_PCMP;\n+    default:\n+      unspec_code = UNSPEC_PCMP;\n+    }\n+\n+  unspec = gen_rtx_UNSPEC (mask_mode, gen_rtvec (3, operands[2],\n+\t\t\t\t\t\t operands[3], imm),\n+\t\t\t   unspec_code);\n+  emit_insn (gen_rtx_SET (operands[0], unspec));\n+\n+  return true;\n+}\n+\n+/* Expand fp vector comparison.  */\n+\n+bool\n+ix86_expand_fp_vec_cmp (rtx operands[])\n+{\n+  enum rtx_code code = GET_CODE (operands[1]);\n   rtx cmp;\n \n   code = ix86_prepare_sse_fp_compare_args (operands[0], code,\n-\t\t\t\t\t   &operands[4], &operands[5]);\n+\t\t\t\t\t   &operands[2], &operands[3]);\n   if (code == UNKNOWN)\n     {\n       rtx temp;\n-      switch (GET_CODE (operands[3]))\n+      switch (GET_CODE (operands[1]))\n \t{\n \tcase LTGT:\n-\t  temp = ix86_expand_sse_cmp (operands[0], ORDERED, operands[4],\n-\t\t\t\t      operands[5], operands[0], operands[0]);\n-\t  cmp = ix86_expand_sse_cmp (operands[0], NE, operands[4],\n-\t\t\t\t     operands[5], operands[1], operands[2]);\n+\t  temp = ix86_expand_sse_cmp (operands[0], ORDERED, operands[2],\n+\t\t\t\t      operands[3], NULL, NULL);\n+\t  cmp = ix86_expand_sse_cmp (operands[0], NE, operands[2],\n+\t\t\t\t     operands[3], NULL, NULL);\n \t  code = AND;\n \t  break;\n \tcase UNEQ:\n-\t  temp = ix86_expand_sse_cmp (operands[0], UNORDERED, operands[4],\n-\t\t\t\t      operands[5], operands[0], operands[0]);\n-\t  cmp = ix86_expand_sse_cmp (operands[0], EQ, operands[4],\n-\t\t\t\t     operands[5], operands[1], operands[2]);\n+\t  temp = ix86_expand_sse_cmp (operands[0], UNORDERED, operands[2],\n+\t\t\t\t      operands[3], NULL, NULL);\n+\t  cmp = ix86_expand_sse_cmp (operands[0], EQ, operands[2],\n+\t\t\t\t     operands[3], NULL, NULL);\n \t  code = IOR;\n \t  break;\n \tdefault:\n \t  gcc_unreachable ();\n \t}\n       cmp = expand_simple_binop (GET_MODE (cmp), code, temp, cmp, cmp, 1,\n \t\t\t\t OPTAB_DIRECT);\n-      ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n-      return true;\n     }\n+  else\n+    cmp = ix86_expand_sse_cmp (operands[0], code, operands[2], operands[3],\n+\t\t\t       operands[1], operands[2]);\n \n-  if (ix86_expand_sse_fp_minmax (operands[0], code, operands[4],\n-\t\t\t\t operands[5], operands[1], operands[2]))\n-    return true;\n+  if (operands[0] != cmp)\n+    emit_move_insn (operands[0], cmp);\n \n-  cmp = ix86_expand_sse_cmp (operands[0], code, operands[4], operands[5],\n-\t\t\t     operands[1], operands[2]);\n-  ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n   return true;\n }\n \n-/* Expand a signed/unsigned integral vector conditional move.  */\n-\n-bool\n-ix86_expand_int_vcond (rtx operands[])\n+static rtx\n+ix86_expand_int_sse_cmp (rtx dest, enum rtx_code code, rtx cop0, rtx cop1,\n+\t\t\t rtx op_true, rtx op_false, bool *negate)\n {\n-  machine_mode data_mode = GET_MODE (operands[0]);\n-  machine_mode mode = GET_MODE (operands[4]);\n-  enum rtx_code code = GET_CODE (operands[3]);\n-  bool negate = false;\n-  rtx x, cop0, cop1;\n+  machine_mode data_mode = GET_MODE (dest);\n+  machine_mode mode = GET_MODE (cop0);\n+  rtx x;\n \n-  cop0 = operands[4];\n-  cop1 = operands[5];\n-\n-  /* Try to optimize x < 0 ? -1 : 0 into (signed) x >> 31\n-     and x < 0 ? 1 : 0 into (unsigned) x >> 31.  */\n-  if ((code == LT || code == GE)\n-      && data_mode == mode\n-      && cop1 == CONST0_RTX (mode)\n-      && operands[1 + (code == LT)] == CONST0_RTX (data_mode)\n-      && GET_MODE_UNIT_SIZE (data_mode) > 1\n-      && GET_MODE_UNIT_SIZE (data_mode) <= 8\n-      && (GET_MODE_SIZE (data_mode) == 16\n-\t  || (TARGET_AVX2 && GET_MODE_SIZE (data_mode) == 32)))\n-    {\n-      rtx negop = operands[2 - (code == LT)];\n-      int shift = GET_MODE_UNIT_BITSIZE (data_mode) - 1;\n-      if (negop == CONST1_RTX (data_mode))\n-\t{\n-\t  rtx res = expand_simple_binop (mode, LSHIFTRT, cop0, GEN_INT (shift),\n-\t\t\t\t\t operands[0], 1, OPTAB_DIRECT);\n-\t  if (res != operands[0])\n-\t    emit_move_insn (operands[0], res);\n-\t  return true;\n-\t}\n-      else if (GET_MODE_INNER (data_mode) != DImode\n-\t       && vector_all_ones_operand (negop, data_mode))\n-\t{\n-\t  rtx res = expand_simple_binop (mode, ASHIFTRT, cop0, GEN_INT (shift),\n-\t\t\t\t\t operands[0], 0, OPTAB_DIRECT);\n-\t  if (res != operands[0])\n-\t    emit_move_insn (operands[0], res);\n-\t  return true;\n-\t}\n-    }\n-\n-  if (!nonimmediate_operand (cop1, mode))\n-    cop1 = force_reg (mode, cop1);\n-  if (!general_operand (operands[1], data_mode))\n-    operands[1] = force_reg (data_mode, operands[1]);\n-  if (!general_operand (operands[2], data_mode))\n-    operands[2] = force_reg (data_mode, operands[2]);\n+  *negate = false;\n \n   /* XOP supports all of the comparisons on all 128-bit vector int types.  */\n   if (TARGET_XOP\n@@ -22976,13 +23031,13 @@ ix86_expand_int_vcond (rtx operands[])\n \tcase LE:\n \tcase LEU:\n \t  code = reverse_condition (code);\n-\t  negate = true;\n+\t  *negate = true;\n \t  break;\n \n \tcase GE:\n \tcase GEU:\n \t  code = reverse_condition (code);\n-\t  negate = true;\n+\t  *negate = true;\n \t  /* FALLTHRU */\n \n \tcase LT:\n@@ -23003,14 +23058,14 @@ ix86_expand_int_vcond (rtx operands[])\n \t    case EQ:\n \t      /* SSE4.1 supports EQ.  */\n \t      if (!TARGET_SSE4_1)\n-\t\treturn false;\n+\t\treturn NULL;\n \t      break;\n \n \t    case GT:\n \t    case GTU:\n \t      /* SSE4.2 supports GT/GTU.  */\n \t      if (!TARGET_SSE4_2)\n-\t\treturn false;\n+\t\treturn NULL;\n \t      break;\n \n \t    default:\n@@ -23071,12 +23126,13 @@ ix86_expand_int_vcond (rtx operands[])\n \t    case V8HImode:\n \t      /* Perform a parallel unsigned saturating subtraction.  */\n \t      x = gen_reg_rtx (mode);\n-\t      emit_insn (gen_rtx_SET (x, gen_rtx_US_MINUS (mode, cop0, cop1)));\n+\t      emit_insn (gen_rtx_SET (x, gen_rtx_US_MINUS (mode, cop0,\n+\t\t\t\t\t\t\t   cop1)));\n \n \t      cop0 = x;\n \t      cop1 = CONST0_RTX (mode);\n \t      code = EQ;\n-\t      negate = !negate;\n+\t      *negate = !*negate;\n \t      break;\n \n \t    default:\n@@ -23085,22 +23141,162 @@ ix86_expand_int_vcond (rtx operands[])\n \t}\n     }\n \n+  if (*negate)\n+    std::swap (op_true, op_false);\n+\n   /* Allow the comparison to be done in one mode, but the movcc to\n      happen in another mode.  */\n   if (data_mode == mode)\n     {\n-      x = ix86_expand_sse_cmp (operands[0], code, cop0, cop1,\n-\t\t\t       operands[1+negate], operands[2-negate]);\n+      x = ix86_expand_sse_cmp (dest, code, cop0, cop1,\n+\t\t\t       op_true, op_false);\n     }\n   else\n     {\n       gcc_assert (GET_MODE_SIZE (data_mode) == GET_MODE_SIZE (mode));\n       x = ix86_expand_sse_cmp (gen_reg_rtx (mode), code, cop0, cop1,\n-\t\t\t       operands[1+negate], operands[2-negate]);\n+\t\t\t       op_true, op_false);\n       if (GET_MODE (x) == mode)\n \tx = gen_lowpart (data_mode, x);\n     }\n \n+  return x;\n+}\n+\n+/* Expand integer vector comparison.  */\n+\n+bool\n+ix86_expand_int_vec_cmp (rtx operands[])\n+{\n+  rtx_code code = GET_CODE (operands[1]);\n+  bool negate = false;\n+  rtx cmp = ix86_expand_int_sse_cmp (operands[0], code, operands[2],\n+\t\t\t\t     operands[3], NULL, NULL, &negate);\n+\n+  if (!cmp)\n+    return false;\n+\n+  if (negate)\n+    cmp = ix86_expand_int_sse_cmp (operands[0], EQ, cmp,\n+\t\t\t\t   CONST0_RTX (GET_MODE (cmp)),\n+\t\t\t\t   NULL, NULL, &negate);\n+\n+  gcc_assert (!negate);\n+\n+  if (operands[0] != cmp)\n+    emit_move_insn (operands[0], cmp);\n+\n+  return true;\n+}\n+\n+/* Expand a floating-point vector conditional move; a vcond operation\n+   rather than a movcc operation.  */\n+\n+bool\n+ix86_expand_fp_vcond (rtx operands[])\n+{\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  rtx cmp;\n+\n+  code = ix86_prepare_sse_fp_compare_args (operands[0], code,\n+\t\t\t\t\t   &operands[4], &operands[5]);\n+  if (code == UNKNOWN)\n+    {\n+      rtx temp;\n+      switch (GET_CODE (operands[3]))\n+\t{\n+\tcase LTGT:\n+\t  temp = ix86_expand_sse_cmp (operands[0], ORDERED, operands[4],\n+\t\t\t\t      operands[5], operands[0], operands[0]);\n+\t  cmp = ix86_expand_sse_cmp (operands[0], NE, operands[4],\n+\t\t\t\t     operands[5], operands[1], operands[2]);\n+\t  code = AND;\n+\t  break;\n+\tcase UNEQ:\n+\t  temp = ix86_expand_sse_cmp (operands[0], UNORDERED, operands[4],\n+\t\t\t\t      operands[5], operands[0], operands[0]);\n+\t  cmp = ix86_expand_sse_cmp (operands[0], EQ, operands[4],\n+\t\t\t\t     operands[5], operands[1], operands[2]);\n+\t  code = IOR;\n+\t  break;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n+      cmp = expand_simple_binop (GET_MODE (cmp), code, temp, cmp, cmp, 1,\n+\t\t\t\t OPTAB_DIRECT);\n+      ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n+      return true;\n+    }\n+\n+  if (ix86_expand_sse_fp_minmax (operands[0], code, operands[4],\n+\t\t\t\t operands[5], operands[1], operands[2]))\n+    return true;\n+\n+  cmp = ix86_expand_sse_cmp (operands[0], code, operands[4], operands[5],\n+\t\t\t     operands[1], operands[2]);\n+  ix86_expand_sse_movcc (operands[0], cmp, operands[1], operands[2]);\n+  return true;\n+}\n+\n+/* Expand a signed/unsigned integral vector conditional move.  */\n+\n+bool\n+ix86_expand_int_vcond (rtx operands[])\n+{\n+  machine_mode data_mode = GET_MODE (operands[0]);\n+  machine_mode mode = GET_MODE (operands[4]);\n+  enum rtx_code code = GET_CODE (operands[3]);\n+  bool negate = false;\n+  rtx x, cop0, cop1;\n+\n+  cop0 = operands[4];\n+  cop1 = operands[5];\n+\n+  /* Try to optimize x < 0 ? -1 : 0 into (signed) x >> 31\n+     and x < 0 ? 1 : 0 into (unsigned) x >> 31.  */\n+  if ((code == LT || code == GE)\n+      && data_mode == mode\n+      && cop1 == CONST0_RTX (mode)\n+      && operands[1 + (code == LT)] == CONST0_RTX (data_mode)\n+      && GET_MODE_UNIT_SIZE (data_mode) > 1\n+      && GET_MODE_UNIT_SIZE (data_mode) <= 8\n+      && (GET_MODE_SIZE (data_mode) == 16\n+\t  || (TARGET_AVX2 && GET_MODE_SIZE (data_mode) == 32)))\n+    {\n+      rtx negop = operands[2 - (code == LT)];\n+      int shift = GET_MODE_UNIT_BITSIZE (data_mode) - 1;\n+      if (negop == CONST1_RTX (data_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (mode, LSHIFTRT, cop0, GEN_INT (shift),\n+\t\t\t\t\t operands[0], 1, OPTAB_DIRECT);\n+\t  if (res != operands[0])\n+\t    emit_move_insn (operands[0], res);\n+\t  return true;\n+\t}\n+      else if (GET_MODE_INNER (data_mode) != DImode\n+\t       && vector_all_ones_operand (negop, data_mode))\n+\t{\n+\t  rtx res = expand_simple_binop (mode, ASHIFTRT, cop0, GEN_INT (shift),\n+\t\t\t\t\t operands[0], 0, OPTAB_DIRECT);\n+\t  if (res != operands[0])\n+\t    emit_move_insn (operands[0], res);\n+\t  return true;\n+\t}\n+    }\n+\n+  if (!nonimmediate_operand (cop1, mode))\n+    cop1 = force_reg (mode, cop1);\n+  if (!general_operand (operands[1], data_mode))\n+    operands[1] = force_reg (data_mode, operands[1]);\n+  if (!general_operand (operands[2], data_mode))\n+    operands[2] = force_reg (data_mode, operands[2]);\n+\n+  x = ix86_expand_int_sse_cmp (operands[0], code, cop0, cop1,\n+\t\t\t       operands[1], operands[2], &negate);\n+\n+  if (!x)\n+    return false;\n+\n   ix86_expand_sse_movcc (operands[0], x, operands[1+negate],\n \t\t\t operands[2-negate]);\n   return true;\n@@ -53085,6 +53281,28 @@ ix86_autovectorize_vector_sizes (void)\n     (TARGET_AVX && !TARGET_PREFER_AVX128) ? 32 | 16 : 0;\n }\n \n+/* Implemenation of targetm.vectorize.get_mask_mode.  */\n+\n+static machine_mode\n+ix86_get_mask_mode (unsigned nunits, unsigned vector_size)\n+{\n+  unsigned elem_size = vector_size / nunits;\n+\n+  /* Scalar mask case.  */\n+  if (TARGET_AVX512F && vector_size == 64)\n+    {\n+      if (elem_size == 4 || elem_size == 8 || TARGET_AVX512BW)\n+\treturn smallest_mode_for_size (nunits, MODE_INT);\n+    }\n+\n+  machine_mode elem_mode\n+    = smallest_mode_for_size (elem_size * BITS_PER_UNIT, MODE_INT);\n+\n+  gcc_assert (elem_size * nunits == vector_size);\n+\n+  return mode_for_vector (elem_mode, nunits);\n+}\n+\n \f\n \n /* Return class of registers which could be used for pseudo of MODE\n@@ -54096,6 +54314,8 @@ ix86_addr_space_zero_address_valid (addr_space_t as)\n #undef TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES\n #define TARGET_VECTORIZE_AUTOVECTORIZE_VECTOR_SIZES \\\n   ix86_autovectorize_vector_sizes\n+#undef TARGET_VECTORIZE_GET_MASK_MODE\n+#define TARGET_VECTORIZE_GET_MASK_MODE ix86_get_mask_mode\n #undef TARGET_VECTORIZE_INIT_COST\n #define TARGET_VECTORIZE_INIT_COST ix86_init_cost\n #undef TARGET_VECTORIZE_ADD_STMT_COST"}, {"sha": "57feb27798bc84db1870a5d981be7647412b8bd4", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -613,6 +613,15 @@\n    (V16SF \"HI\") (V8SF  \"QI\") (V4SF  \"QI\")\n    (V8DF  \"QI\") (V4DF  \"QI\") (V2DF  \"QI\")])\n \n+;; Mapping of vector modes to corresponding mask size\n+(define_mode_attr avx512fmaskmodelower\n+  [(V64QI \"di\") (V32QI \"si\") (V16QI \"hi\")\n+   (V32HI \"si\") (V16HI \"hi\") (V8HI  \"qi\") (V4HI \"qi\")\n+   (V16SI \"hi\") (V8SI  \"qi\") (V4SI  \"qi\")\n+   (V8DI  \"qi\") (V4DI  \"qi\") (V2DI  \"qi\")\n+   (V16SF \"hi\") (V8SF  \"qi\") (V4SF  \"qi\")\n+   (V8DF  \"qi\") (V4DF  \"qi\") (V2DF  \"qi\")])\n+\n ;; Mapping of vector float modes to an integer mode of the same size\n (define_mode_attr sseintvecmode\n   [(V16SF \"V16SI\") (V8DF  \"V8DI\")\n@@ -2811,6 +2820,150 @@\n \t\t      (const_string \"0\")))\n    (set_attr \"mode\" \"<MODE>\")])\n \n+(define_expand \"vec_cmp<mode><avx512fmaskmodelower>\"\n+  [(set (match_operand:<avx512fmaskmode> 0 \"register_operand\")\n+\t(match_operator:<avx512fmaskmode> 1 \"\"\n+\t  [(match_operand:V48_AVX512VL 2 \"register_operand\")\n+\t   (match_operand:V48_AVX512VL 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX512F\"\n+{\n+  bool ok = ix86_expand_mask_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmp<mode><avx512fmaskmodelower>\"\n+  [(set (match_operand:<avx512fmaskmode> 0 \"register_operand\")\n+\t(match_operator:<avx512fmaskmode> 1 \"\"\n+\t  [(match_operand:VI12_AVX512VL 2 \"register_operand\")\n+\t   (match_operand:VI12_AVX512VL 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX512BW\"\n+{\n+  bool ok = ix86_expand_mask_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmp<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VI_256 2 \"register_operand\")\n+\t   (match_operand:VI_256 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmp<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VI124_128 2 \"register_operand\")\n+\t   (match_operand:VI124_128 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_SSE2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpv2div2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\")\n+\t(match_operator:V2DI 1 \"\"\n+\t  [(match_operand:V2DI 2 \"register_operand\")\n+\t   (match_operand:V2DI 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_SSE4_2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmp<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VF_256 2 \"register_operand\")\n+\t   (match_operand:VF_256 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX\"\n+{\n+  bool ok = ix86_expand_fp_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmp<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VF_128 2 \"register_operand\")\n+\t   (match_operand:VF_128 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_SSE\"\n+{\n+  bool ok = ix86_expand_fp_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><avx512fmaskmodelower>\"\n+  [(set (match_operand:<avx512fmaskmode> 0 \"register_operand\")\n+\t(match_operator:<avx512fmaskmode> 1 \"\"\n+\t  [(match_operand:VI48_AVX512VL 2 \"register_operand\")\n+\t   (match_operand:VI48_AVX512VL 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX512F\"\n+{\n+  bool ok = ix86_expand_mask_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><avx512fmaskmodelower>\"\n+  [(set (match_operand:<avx512fmaskmode> 0 \"register_operand\")\n+\t(match_operator:<avx512fmaskmode> 1 \"\"\n+\t  [(match_operand:VI12_AVX512VL 2 \"register_operand\")\n+\t   (match_operand:VI12_AVX512VL 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX512BW\"\n+{\n+  bool ok = ix86_expand_mask_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VI_256 2 \"register_operand\")\n+\t   (match_operand:VI_256 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_AVX2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpu<mode><sseintvecmodelower>\"\n+  [(set (match_operand:<sseintvecmode> 0 \"register_operand\")\n+\t(match_operator:<sseintvecmode> 1 \"\"\n+\t  [(match_operand:VI124_128 2 \"register_operand\")\n+\t   (match_operand:VI124_128 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_SSE2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n+(define_expand \"vec_cmpuv2div2di\"\n+  [(set (match_operand:V2DI 0 \"register_operand\")\n+\t(match_operator:V2DI 1 \"\"\n+\t  [(match_operand:V2DI 2 \"register_operand\")\n+\t   (match_operand:V2DI 3 \"nonimmediate_operand\")]))]\n+  \"TARGET_SSE4_2\"\n+{\n+  bool ok = ix86_expand_int_vec_cmp (operands);\n+  gcc_assert (ok);\n+  DONE;\n+})\n+\n (define_expand \"vcond<V_512:mode><VF_512:mode>\"\n   [(set (match_operand:V_512 0 \"register_operand\")\n \t(if_then_else:V_512"}, {"sha": "03936ee3ddb3d087fbde02c4d7a12dd8b69e6188", "filename": "gcc/expr.c", "status": "modified", "additions": 46, "deletions": 3, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -11128,9 +11128,15 @@ do_store_flag (sepops ops, rtx target, machine_mode mode)\n   if (TREE_CODE (ops->type) == VECTOR_TYPE)\n     {\n       tree ifexp = build2 (ops->code, ops->type, arg0, arg1);\n-      tree if_true = constant_boolean_node (true, ops->type);\n-      tree if_false = constant_boolean_node (false, ops->type);\n-      return expand_vec_cond_expr (ops->type, ifexp, if_true, if_false, target);\n+      if (VECTOR_BOOLEAN_TYPE_P (ops->type))\n+\treturn expand_vec_cmp_expr (ops->type, ifexp, target);\n+      else\n+\t{\n+\t  tree if_true = constant_boolean_node (true, ops->type);\n+\t  tree if_false = constant_boolean_node (false, ops->type);\n+\t  return expand_vec_cond_expr (ops->type, ifexp, if_true,\n+\t\t\t\t       if_false, target);\n+\t}\n     }\n \n   /* Get the rtx comparison code to use.  We know that EXP is a comparison\n@@ -11417,6 +11423,40 @@ try_tablejump (tree index_type, tree index_expr, tree minval, tree range,\n   return 1;\n }\n \n+/* Return a CONST_VECTOR rtx representing vector mask for\n+   a VECTOR_CST of booleans.  */\n+static rtx\n+const_vector_mask_from_tree (tree exp)\n+{\n+  rtvec v;\n+  unsigned i;\n+  int units;\n+  tree elt;\n+  machine_mode inner, mode;\n+\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+  units = GET_MODE_NUNITS (mode);\n+  inner = GET_MODE_INNER (mode);\n+\n+  v = rtvec_alloc (units);\n+\n+  for (i = 0; i < VECTOR_CST_NELTS (exp); ++i)\n+    {\n+      elt = VECTOR_CST_ELT (exp, i);\n+\n+      gcc_assert (TREE_CODE (elt) == INTEGER_CST);\n+      if (integer_zerop (elt))\n+\tRTVEC_ELT (v, i) = CONST0_RTX (inner);\n+      else if (integer_onep (elt)\n+\t       || integer_minus_onep (elt))\n+\tRTVEC_ELT (v, i) = CONSTM1_RTX (inner);\n+      else\n+\tgcc_unreachable ();\n+    }\n+\n+  return gen_rtx_CONST_VECTOR (mode, v);\n+}\n+\n /* Return a CONST_VECTOR rtx for a VECTOR_CST tree.  */\n static rtx\n const_vector_from_tree (tree exp)\n@@ -11432,6 +11472,9 @@ const_vector_from_tree (tree exp)\n   if (initializer_zerop (exp))\n     return CONST0_RTX (mode);\n \n+  if (VECTOR_BOOLEAN_TYPE_P (TREE_TYPE (exp)))\n+    return const_vector_mask_from_tree (exp);\n+\n   units = GET_MODE_NUNITS (mode);\n   inner = GET_MODE_INNER (mode);\n "}, {"sha": "81ac3627c512f7c933a0269d8fe7bc502cff6386", "filename": "gcc/optabs-query.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-query.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-query.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-query.h?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -74,6 +74,16 @@ trapv_binoptab_p (optab binoptab)\n \t  || binoptab == smulv_optab);\n }\n \n+/* Return insn code for a comparison operator with VMODE\n+   resultin MASK_MODE, unsigned if UNS is true.  */\n+\n+static inline enum insn_code\n+get_vec_cmp_icode (machine_mode vmode, machine_mode mask_mode, bool uns)\n+{\n+  optab tab = uns ? vec_cmpu_optab : vec_cmp_optab;\n+  return convert_optab_handler (tab, vmode, mask_mode);\n+}\n+\n /* Return insn code for a conditional operator with a comparison in\n    mode CMODE, unsigned if UNS is true, resulting in a value of mode VMODE.  */\n "}, {"sha": "aa863cfb94105c733fd9082558c77e3ab413da75", "filename": "gcc/optabs-tree.c", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -320,6 +320,19 @@ supportable_convert_operation (enum tree_code code,\n   return false;\n }\n \n+/* Return TRUE if appropriate vector insn is available\n+   for vector comparison expr with vector type VALUE_TYPE\n+   and resulting mask with MASK_TYPE.  */\n+\n+bool\n+expand_vec_cmp_expr_p (tree value_type, tree mask_type)\n+{\n+  enum insn_code icode = get_vec_cmp_icode (TYPE_MODE (value_type),\n+\t\t\t\t\t    TYPE_MODE (mask_type),\n+\t\t\t\t\t    TYPE_UNSIGNED (value_type));\n+  return (icode != CODE_FOR_nothing);\n+}\n+\n /* Return TRUE iff, appropriate vector insns are available\n    for vector cond expr with vector type VALUE_TYPE and a comparison\n    with operand vector types in CMP_OP_TYPE.  */"}, {"sha": "5b966ca92b8d2ed91f26d94cc92393d5b14b3427", "filename": "gcc/optabs-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs-tree.h?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -39,6 +39,7 @@ optab optab_for_tree_code (enum tree_code, const_tree, enum optab_subtype);\n optab scalar_reduc_to_vector (optab, const_tree);\n bool supportable_convert_operation (enum tree_code, tree, tree, tree *,\n \t\t\t\t    enum tree_code *);\n+bool expand_vec_cmp_expr_p (tree, tree);\n bool expand_vec_cond_expr_p (tree, tree);\n void init_tree_optimization_optabs (tree);\n "}, {"sha": "f9fbfde967d0deeb72b7c65cc6689febc82a5e4b", "filename": "gcc/optabs.c", "status": "modified", "additions": 40, "deletions": 4, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -5180,11 +5180,13 @@ get_rtx_code (enum tree_code tcode, bool unsignedp)\n }\n \n /* Return comparison rtx for COND. Use UNSIGNEDP to select signed or\n-   unsigned operators. Do not generate compare instruction.  */\n+   unsigned operators.  OPNO holds an index of the first comparison\n+   operand in insn with code ICODE.  Do not generate compare instruction.  */\n \n static rtx\n vector_compare_rtx (enum tree_code tcode, tree t_op0, tree t_op1,\n-\t\t    bool unsignedp, enum insn_code icode)\n+\t\t    bool unsignedp, enum insn_code icode,\n+\t\t    unsigned int opno)\n {\n   struct expand_operand ops[2];\n   rtx rtx_op0, rtx_op1;\n@@ -5210,7 +5212,7 @@ vector_compare_rtx (enum tree_code tcode, tree t_op0, tree t_op1,\n \n   create_input_operand (&ops[0], rtx_op0, m0);\n   create_input_operand (&ops[1], rtx_op1, m1);\n-  if (!maybe_legitimize_operands (icode, 4, 2, ops))\n+  if (!maybe_legitimize_operands (icode, opno, 2, ops))\n     gcc_unreachable ();\n   return gen_rtx_fmt_ee (rcode, VOIDmode, ops[0].value, ops[1].value);\n }\n@@ -5465,7 +5467,7 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n   if (icode == CODE_FOR_nothing)\n     return 0;\n \n-  comparison = vector_compare_rtx (tcode, op0a, op0b, unsignedp, icode);\n+  comparison = vector_compare_rtx (tcode, op0a, op0b, unsignedp, icode, 4);\n   rtx_op1 = expand_normal (op1);\n   rtx_op2 = expand_normal (op2);\n \n@@ -5479,6 +5481,40 @@ expand_vec_cond_expr (tree vec_cond_type, tree op0, tree op1, tree op2,\n   return ops[0].value;\n }\n \n+/* Generate insns for a vector comparison into a mask.  */\n+\n+rtx\n+expand_vec_cmp_expr (tree type, tree exp, rtx target)\n+{\n+  struct expand_operand ops[4];\n+  enum insn_code icode;\n+  rtx comparison;\n+  machine_mode mask_mode = TYPE_MODE (type);\n+  machine_mode vmode;\n+  bool unsignedp;\n+  tree op0a, op0b;\n+  enum tree_code tcode;\n+\n+  op0a = TREE_OPERAND (exp, 0);\n+  op0b = TREE_OPERAND (exp, 1);\n+  tcode = TREE_CODE (exp);\n+\n+  unsignedp = TYPE_UNSIGNED (TREE_TYPE (op0a));\n+  vmode = TYPE_MODE (TREE_TYPE (op0a));\n+\n+  icode = get_vec_cmp_icode (vmode, mask_mode, unsignedp);\n+  if (icode == CODE_FOR_nothing)\n+    return 0;\n+\n+  comparison = vector_compare_rtx (tcode, op0a, op0b, unsignedp, icode, 2);\n+  create_output_operand (&ops[0], target, mask_mode);\n+  create_fixed_operand (&ops[1], comparison);\n+  create_fixed_operand (&ops[2], XEXP (comparison, 0));\n+  create_fixed_operand (&ops[3], XEXP (comparison, 1));\n+  expand_insn (icode, 4, ops);\n+  return ops[0].value;\n+}\n+\n /* Expand a highpart multiply.  */\n \n rtx"}, {"sha": "c057186c07abd19b7b09d891712bd1878b18cfa5", "filename": "gcc/optabs.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.def?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -61,6 +61,8 @@ OPTAB_CD(vec_load_lanes_optab, \"vec_load_lanes$a$b\")\n OPTAB_CD(vec_store_lanes_optab, \"vec_store_lanes$a$b\")\n OPTAB_CD(vcond_optab, \"vcond$a$b\")\n OPTAB_CD(vcondu_optab, \"vcondu$a$b\")\n+OPTAB_CD(vec_cmp_optab, \"vec_cmp$a$b\")\n+OPTAB_CD(vec_cmpu_optab, \"vec_cmpu$a$b\")\n \n OPTAB_NL(add_optab, \"add$P$a3\", PLUS, \"add\", '3', gen_int_fp_fixed_libfunc)\n OPTAB_NX(add_optab, \"add$F$a3\")"}, {"sha": "78666f63b45f54ed84382566fe313aa6aed3fdb1", "filename": "gcc/optabs.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -304,6 +304,9 @@ extern rtx_insn *gen_cond_trap (enum rtx_code, rtx, rtx, rtx);\n /* Generate code for VEC_PERM_EXPR.  */\n extern rtx expand_vec_perm (machine_mode, rtx, rtx, rtx, rtx);\n \n+/* Generate code for vector comparison.  */\n+extern rtx expand_vec_cmp_expr (tree, tree, rtx);\n+\n /* Generate code for VEC_COND_EXPR.  */\n extern rtx expand_vec_cond_expr (tree, tree, tree, tree, rtx);\n "}, {"sha": "cc81cc409f8b0ff97f7fbb342063186f7d8e9193", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -1,3 +1,7 @@\n+2015-11-10  Ilya Enkovich  <enkovich.gnu@gmail.com>\n+\n+\t* gcc.dg/vect/slp-cond-5.c: New test.\n+\n 2015-11-10  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68240"}, {"sha": "5ade7d1fbad9eee7861d1b0d12ac98e42d453422", "filename": "gcc/testsuite/gcc.dg/vect/slp-cond-5.c", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fslp-cond-5.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -0,0 +1,81 @@\n+/* { dg-require-effective-target vect_condition } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 128\n+\n+static inline int\n+foo (int x, int y, int a, int b)\n+{\n+  if (x >= y && a > b)\n+    return a;\n+  else\n+    return b;\n+}\n+\n+__attribute__((noinline, noclone)) void\n+bar (int * __restrict__ a, int * __restrict__ b,\n+     int * __restrict__ c, int * __restrict__ d,\n+     int * __restrict__ e, int w)\n+{\n+  int i;\n+  for (i = 0; i < N/16; i++, a += 16, b += 16, c += 16, d += 16, e += 16)\n+    {\n+      e[0] = foo (c[0], d[0], a[0] * w, b[0] * w);\n+      e[1] = foo (c[1], d[1], a[1] * w, b[1] * w);\n+      e[2] = foo (c[2], d[2], a[2] * w, b[2] * w);\n+      e[3] = foo (c[3], d[3], a[3] * w, b[3] * w);\n+      e[4] = foo (c[4], d[4], a[4] * w, b[4] * w);\n+      e[5] = foo (c[5], d[5], a[5] * w, b[5] * w);\n+      e[6] = foo (c[6], d[6], a[6] * w, b[6] * w);\n+      e[7] = foo (c[7], d[7], a[7] * w, b[7] * w);\n+      e[8] = foo (c[8], d[8], a[8] * w, b[8] * w);\n+      e[9] = foo (c[9], d[9], a[9] * w, b[9] * w);\n+      e[10] = foo (c[10], d[10], a[10] * w, b[10] * w);\n+      e[11] = foo (c[11], d[11], a[11] * w, b[11] * w);\n+      e[12] = foo (c[12], d[12], a[12] * w, b[12] * w);\n+      e[13] = foo (c[13], d[13], a[13] * w, b[13] * w);\n+      e[14] = foo (c[14], d[14], a[14] * w, b[14] * w);\n+      e[15] = foo (c[15], d[15], a[15] * w, b[15] * w);\n+    }\n+}\n+\n+\n+int a[N], b[N], c[N], d[N], e[N];\n+\n+int main ()\n+{\n+  int i;\n+\n+  check_vect ();\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      a[i] = i;\n+      b[i] = 5;\n+      e[i] = 0;\n+\n+      switch (i % 9)\n+        {\n+        case 0: asm (\"\"); c[i] = i; d[i] = i + 1; break;\n+        case 1: c[i] = 0; d[i] = 0; break;\n+        case 2: c[i] = i + 1; d[i] = i - 1; break;\n+        case 3: c[i] = i; d[i] = i + 7; break;\n+        case 4: c[i] = i; d[i] = i; break;\n+        case 5: c[i] = i + 16; d[i] = i + 3; break;\n+        case 6: c[i] = i - 5; d[i] = i; break;\n+        case 7: c[i] = i; d[i] = i; break;\n+        case 8: c[i] = i; d[i] = i - 7; break;\n+        }\n+    }\n+\n+  bar (a, b, c, d, e, 2);\n+  for (i = 0; i < N; i++)\n+    if (e[i] != ((i % 3) == 0 || i <= 5 ? 10 : 2 * i))\n+      abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"vectorizing stmts using SLP\" 1 \"vect\" { target { i?86-*-* x86_64-*-* } } } } */\n+"}, {"sha": "87936ddee1d0c0aab0936267c90426c0a9f26eec", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -3863,6 +3863,9 @@ vect_get_new_vect_var (tree type, enum vect_var_kind var_kind, const char *name)\n   case vect_scalar_var:\n     prefix = \"stmp\";\n     break;\n+  case vect_mask_var:\n+    prefix = \"mask\";\n+    break;\n   case vect_pointer_var:\n     prefix = \"vectp\";\n     break;\n@@ -4452,7 +4455,11 @@ vect_create_destination_var (tree scalar_dest, tree vectype)\n   tree type;\n   enum vect_var_kind kind;\n \n-  kind = vectype ? vect_simple_var : vect_scalar_var;\n+  kind = vectype\n+    ? VECTOR_BOOLEAN_TYPE_P (vectype)\n+    ? vect_mask_var\n+    : vect_simple_var\n+    : vect_scalar_var;\n   type = vectype ? vectype : TREE_TYPE (scalar_dest);\n \n   gcc_assert (TREE_CODE (scalar_dest) == SSA_NAME);"}, {"sha": "5883db8abd6c30418a4a8f5c4125e269c6c6fae8", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -346,7 +346,8 @@ expand_vector_comparison (gimple_stmt_iterator *gsi, tree type, tree op0,\n                           tree op1, enum tree_code code)\n {\n   tree t;\n-  if (! expand_vec_cond_expr_p (type, TREE_TYPE (op0)))\n+  if (!expand_vec_cmp_expr_p (TREE_TYPE (op0), type)\n+      && !expand_vec_cond_expr_p (type, TREE_TYPE (op0)))\n     t = expand_vector_piecewise (gsi, do_compare, type,\n \t\t\t\t TREE_TYPE (TREE_TYPE (op0)), op0, op1, code);\n   else"}, {"sha": "cbf0073ffcfaed307fc3934e16fc21bc298ac734", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 130, "deletions": 5, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -178,19 +178,21 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n {\n   struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n   basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n-  int nbbs = loop->num_nodes;\n+  unsigned nbbs = loop->num_nodes;\n   unsigned int vectorization_factor = 0;\n   tree scalar_type;\n   gphi *phi;\n   tree vectype;\n   unsigned int nunits;\n   stmt_vec_info stmt_info;\n-  int i;\n+  unsigned i;\n   HOST_WIDE_INT dummy;\n   gimple *stmt, *pattern_stmt = NULL;\n   gimple_seq pattern_def_seq = NULL;\n   gimple_stmt_iterator pattern_def_si = gsi_none ();\n   bool analyze_pattern_stmt = false;\n+  bool bool_result;\n+  auto_vec<stmt_vec_info> mask_producers;\n \n   if (dump_enabled_p ())\n     dump_printf_loc (MSG_NOTE, vect_location,\n@@ -409,6 +411,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t      return false;\n \t    }\n \n+\t  bool_result = false;\n+\n \t  if (STMT_VINFO_VECTYPE (stmt_info))\n \t    {\n \t      /* The only case when a vectype had been already set is for stmts\n@@ -429,6 +433,32 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\tscalar_type = TREE_TYPE (gimple_call_arg (stmt, 3));\n \t      else\n \t\tscalar_type = TREE_TYPE (gimple_get_lhs (stmt));\n+\n+\t      /* Bool ops don't participate in vectorization factor\n+\t\t computation.  For comparison use compared types to\n+\t\t compute a factor.  */\n+\t      if (TREE_CODE (scalar_type) == BOOLEAN_TYPE)\n+\t\t{\n+\t\t  mask_producers.safe_push (stmt_info);\n+\t\t  bool_result = true;\n+\n+\t\t  if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t\t      && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt))\n+\t\t\t == tcc_comparison\n+\t\t      && TREE_CODE (TREE_TYPE (gimple_assign_rhs1 (stmt)))\n+\t\t\t != BOOLEAN_TYPE)\n+\t\t    scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t\t  else\n+\t\t    {\n+\t\t      if (!analyze_pattern_stmt && gsi_end_p (pattern_def_si))\n+\t\t\t{\n+\t\t\t  pattern_def_seq = NULL;\n+\t\t\t  gsi_next (&si);\n+\t\t\t}\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n \t      if (dump_enabled_p ())\n \t\t{\n \t\t  dump_printf_loc (MSG_NOTE, vect_location,\n@@ -451,7 +481,8 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t\t  return false;\n \t\t}\n \n-\t      STMT_VINFO_VECTYPE (stmt_info) = vectype;\n+\t      if (!bool_result)\n+\t\tSTMT_VINFO_VECTYPE (stmt_info) = vectype;\n \n \t      if (dump_enabled_p ())\n \t\t{\n@@ -464,8 +495,9 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n \t  /* The vectorization factor is according to the smallest\n \t     scalar type (or the largest vector size, but we only\n \t     support one vector size per loop).  */\n-\t  scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n-\t\t\t\t\t\t       &dummy);\n+\t  if (!bool_result)\n+\t    scalar_type = vect_get_smallest_scalar_type (stmt, &dummy,\n+\t\t\t\t\t\t\t &dummy);\n \t  if (dump_enabled_p ())\n \t    {\n \t      dump_printf_loc (MSG_NOTE, vect_location,\n@@ -540,6 +572,99 @@ vect_determine_vectorization_factor (loop_vec_info loop_vinfo)\n     }\n   LOOP_VINFO_VECT_FACTOR (loop_vinfo) = vectorization_factor;\n \n+  for (i = 0; i < mask_producers.length (); i++)\n+    {\n+      tree mask_type = NULL;\n+\n+      stmt = STMT_VINFO_STMT (mask_producers[i]);\n+\n+      if (gimple_code (stmt) == GIMPLE_ASSIGN\n+\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison\n+\t  && TREE_CODE (TREE_TYPE (gimple_assign_rhs1 (stmt))) != BOOLEAN_TYPE)\n+\t{\n+\t  scalar_type = TREE_TYPE (gimple_assign_rhs1 (stmt));\n+\t  mask_type = get_mask_type_for_scalar_type (scalar_type);\n+\n+\t  if (!mask_type)\n+\t    {\n+\t      if (dump_enabled_p ())\n+\t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t \"not vectorized: unsupported mask\\n\");\n+\t      return false;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  tree rhs;\n+\t  ssa_op_iter iter;\n+\t  gimple *def_stmt;\n+\t  enum vect_def_type dt;\n+\n+\t  FOR_EACH_SSA_TREE_OPERAND (rhs, stmt, iter, SSA_OP_USE)\n+\t    {\n+\t      if (!vect_is_simple_use (rhs, mask_producers[i]->vinfo,\n+\t\t\t\t       &def_stmt, &dt, &vectype))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t       \"not vectorized: can't compute mask type \"\n+\t\t\t\t       \"for statement, \");\n+\t\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n+\t\t\t\t\t0);\n+\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\n+\t      /* No vectype probably means external definition.\n+\t\t Allow it in case there is another operand which\n+\t\t allows to determine mask type.  */\n+\t      if (!vectype)\n+\t\tcontinue;\n+\n+\t      if (!mask_type)\n+\t\tmask_type = vectype;\n+\t      else if (TYPE_VECTOR_SUBPARTS (mask_type)\n+\t\t       != TYPE_VECTOR_SUBPARTS (vectype))\n+\t\t{\n+\t\t  if (dump_enabled_p ())\n+\t\t    {\n+\t\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t\t       \"not vectorized: different sized masks \"\n+\t\t\t\t       \"types in statement, \");\n+\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\t mask_type);\n+\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \" and \");\n+\t\t      dump_generic_expr (MSG_MISSED_OPTIMIZATION, TDF_SLIM,\n+\t\t\t\t\t vectype);\n+\t\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t\t    }\n+\t\t  return false;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* No mask_type should mean loop invariant predicate.\n+\t This is probably a subject for optimization in\n+\t if-conversion.  */\n+      if (!mask_type)\n+\t{\n+\t  if (dump_enabled_p ())\n+\t    {\n+\t      dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t       \"not vectorized: can't compute mask type \"\n+\t\t\t       \"for statement, \");\n+\t      dump_gimple_stmt (MSG_MISSED_OPTIMIZATION,  TDF_SLIM, stmt,\n+\t\t\t\t0);\n+\t      dump_printf (MSG_MISSED_OPTIMIZATION, \"\\n\");\n+\t    }\n+\t  return false;\n+\t}\n+\n+      STMT_VINFO_VECTYPE (mask_producers[i]) = mask_type;\n+    }\n+\n   return true;\n }\n "}, {"sha": "e91c6e008a025a37ced6ae6c0926721f0ff21560", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 163, "deletions": 21, "changes": 184, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -2849,7 +2849,9 @@ vect_recog_mixed_size_cond_pattern (vec<gimple *> *stmts, tree *type_in,\n \n \n /* Helper function of vect_recog_bool_pattern.  Called recursively, return\n-   true if bool VAR can be optimized that way.  */\n+   true if bool VAR can and should be optimized that way.  Assume it shouldn't\n+   in case it's a result of a comparison which can be directly vectorized into\n+   a vector comparison.  */\n \n static bool\n check_bool_pattern (tree var, vec_info *vinfo)\n@@ -2898,7 +2900,7 @@ check_bool_pattern (tree var, vec_info *vinfo)\n     default:\n       if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n \t{\n-\t  tree vecitype, comp_vectype;\n+\t  tree vecitype, comp_vectype, mask_type;\n \n \t  /* If the comparison can throw, then is_gimple_condexpr will be\n \t     false and we can't make a COND_EXPR/VEC_COND_EXPR out of it.  */\n@@ -2909,6 +2911,11 @@ check_bool_pattern (tree var, vec_info *vinfo)\n \t  if (comp_vectype == NULL_TREE)\n \t    return false;\n \n+\t  mask_type = get_mask_type_for_scalar_type (TREE_TYPE (rhs1));\n+\t  if (mask_type\n+\t      && expand_vec_cmp_expr_p (comp_vectype, mask_type))\n+\t    return false;\n+\n \t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE)\n \t    {\n \t      machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n@@ -3133,6 +3140,73 @@ adjust_bool_pattern (tree var, tree out_type, tree trueval,\n }\n \n \n+/* Return the proper type for converting bool VAR into\n+   an integer value or NULL_TREE if no such type exists.\n+   The type is chosen so that converted value has the\n+   same number of elements as VAR's vector type.  */\n+\n+static tree\n+search_type_for_mask (tree var, vec_info *vinfo)\n+{\n+  gimple *def_stmt;\n+  enum vect_def_type dt;\n+  tree rhs1;\n+  enum tree_code rhs_code;\n+  tree res = NULL_TREE;\n+\n+  if (TREE_CODE (var) != SSA_NAME)\n+    return NULL_TREE;\n+\n+  if ((TYPE_PRECISION (TREE_TYPE (var)) != 1\n+       || !TYPE_UNSIGNED (TREE_TYPE (var)))\n+      && TREE_CODE (TREE_TYPE (var)) != BOOLEAN_TYPE)\n+    return NULL_TREE;\n+\n+  if (!vect_is_simple_use (var, vinfo, &def_stmt, &dt))\n+    return NULL_TREE;\n+\n+  if (dt != vect_internal_def)\n+    return NULL_TREE;\n+\n+  if (!is_gimple_assign (def_stmt))\n+    return NULL_TREE;\n+\n+  rhs_code = gimple_assign_rhs_code (def_stmt);\n+  rhs1 = gimple_assign_rhs1 (def_stmt);\n+\n+  switch (rhs_code)\n+    {\n+    case SSA_NAME:\n+    case BIT_NOT_EXPR:\n+    CASE_CONVERT:\n+      res = search_type_for_mask (rhs1, vinfo);\n+      break;\n+\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+      if (!(res = search_type_for_mask (rhs1, vinfo)))\n+\tres = search_type_for_mask (gimple_assign_rhs2 (def_stmt), vinfo);\n+      break;\n+\n+    default:\n+      if (TREE_CODE_CLASS (rhs_code) == tcc_comparison)\n+\t{\n+\t  if (TREE_CODE (TREE_TYPE (rhs1)) != INTEGER_TYPE\n+\t      || !TYPE_UNSIGNED (TREE_TYPE (rhs1)))\n+\t    {\n+\t      machine_mode mode = TYPE_MODE (TREE_TYPE (rhs1));\n+\t      res = build_nonstandard_integer_type (GET_MODE_BITSIZE (mode), 1);\n+\t    }\n+\t  else\n+\t    res = TREE_TYPE (rhs1);\n+\t}\n+    }\n+\n+  return res;\n+}\n+\n+\n /* Function vect_recog_bool_pattern\n \n    Try to find pattern like following:\n@@ -3190,6 +3264,7 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n   enum tree_code rhs_code;\n   tree var, lhs, rhs, vectype;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (last_stmt);\n+  stmt_vec_info new_stmt_info;\n   vec_info *vinfo = stmt_vinfo->vinfo;\n   gimple *pattern_stmt;\n \n@@ -3214,16 +3289,52 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (vectype == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, vinfo))\n-\treturn NULL;\n-\n-      rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n-      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n-      if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-\tpattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n+      if (check_bool_pattern (var, vinfo))\n+\t{\n+\t  rhs = adjust_bool_pattern (var, TREE_TYPE (lhs), NULL_TREE, stmts);\n+\t  lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+\t  if (useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+\t    pattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);\n+\t  else\n+\t    pattern_stmt\n+\t      = gimple_build_assign (lhs, NOP_EXPR, rhs);\n+\t}\n       else\n-\tpattern_stmt\n-\t  = gimple_build_assign (lhs, NOP_EXPR, rhs);\n+\t{\n+\t  tree type = search_type_for_mask (var, vinfo);\n+\t  tree cst0, cst1, cmp, tmp;\n+\n+\t  if (!type)\n+\t    return NULL;\n+\n+\t  /* We may directly use cond with narrowed type to avoid\n+\t     multiple cond exprs with following result packing and\n+\t     perform single cond with packed mask instead.  In case\n+\t     of widening we better make cond first and then extract\n+\t     results.  */\n+\t  if (TYPE_MODE (type) == TYPE_MODE (TREE_TYPE (lhs)))\n+\t    type = TREE_TYPE (lhs);\n+\n+\t  cst0 = build_int_cst (type, 0);\n+\t  cst1 = build_int_cst (type, 1);\n+\t  tmp = vect_recog_temp_ssa_var (type, NULL);\n+\t  cmp = build2 (NE_EXPR, boolean_type_node,\n+\t\t\tvar, build_int_cst (TREE_TYPE (var), 0));\n+\t  pattern_stmt = gimple_build_assign (tmp, COND_EXPR, cmp, cst1, cst0);\n+\n+\t  if (!useless_type_conversion_p (type, TREE_TYPE (lhs)))\n+\t    {\n+\t      tree new_vectype = get_vectype_for_scalar_type (type);\n+\t      new_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n+\t      set_vinfo_for_stmt (pattern_stmt, new_stmt_info);\n+\t      STMT_VINFO_VECTYPE (new_stmt_info) = new_vectype;\n+\t      new_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\n+\t      lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n+\t      pattern_stmt = gimple_build_assign (lhs, CONVERT_EXPR, tmp);\n+\t    }\n+\t}\n+\n       *type_out = vectype;\n       *type_in = vectype;\n       stmts->safe_push (last_stmt);\n@@ -3252,15 +3363,19 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       if (get_vectype_for_scalar_type (type) == NULL_TREE)\n \treturn NULL;\n \n-      if (!check_bool_pattern (var, vinfo))\n-\treturn NULL;\n+      if (check_bool_pattern (var, vinfo))\n+\t{\n+\t  rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n+\t  rhs = build2 (NE_EXPR, boolean_type_node,\n+\t\t\trhs, build_int_cst (type, 0));\n+\t}\n+      else\n+\trhs = build2 (NE_EXPR, boolean_type_node,\n+\t\t      var, build_int_cst (TREE_TYPE (var), 0)),\n \n-      rhs = adjust_bool_pattern (var, type, NULL_TREE, stmts);\n       lhs = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n       pattern_stmt \n-\t  = gimple_build_assign (lhs, COND_EXPR,\n-\t\t\t\t build2 (NE_EXPR, boolean_type_node,\n-\t\t\t\t\t rhs, build_int_cst (type, 0)),\n+\t  = gimple_build_assign (lhs, COND_EXPR, rhs,\n \t\t\t\t gimple_assign_rhs2 (last_stmt),\n \t\t\t\t gimple_assign_rhs3 (last_stmt));\n       *type_out = vectype;\n@@ -3280,16 +3395,43 @@ vect_recog_bool_pattern (vec<gimple *> *stmts, tree *type_in,\n       gcc_assert (vectype != NULL_TREE);\n       if (!VECTOR_MODE_P (TYPE_MODE (vectype)))\n \treturn NULL;\n-      if (!check_bool_pattern (var, vinfo))\n-\treturn NULL;\n \n-      rhs = adjust_bool_pattern (var, TREE_TYPE (vectype), NULL_TREE, stmts);\n+      if (check_bool_pattern (var, vinfo))\n+\trhs = adjust_bool_pattern (var, TREE_TYPE (vectype),\n+\t\t\t\t   NULL_TREE, stmts);\n+      else\n+\t{\n+\t  tree type = search_type_for_mask (var, vinfo);\n+\t  tree cst0, cst1, cmp, new_vectype;\n+\n+\t  if (!type)\n+\t    return NULL;\n+\n+\t  if (TYPE_MODE (type) == TYPE_MODE (TREE_TYPE (vectype)))\n+\t    type = TREE_TYPE (vectype);\n+\n+\t  cst0 = build_int_cst (type, 0);\n+\t  cst1 = build_int_cst (type, 1);\n+\t  new_vectype = get_vectype_for_scalar_type (type);\n+\n+\t  rhs = vect_recog_temp_ssa_var (type, NULL);\n+\t  cmp = build2 (NE_EXPR, boolean_type_node,\n+\t\t\tvar, build_int_cst (TREE_TYPE (var), 0));\n+\t  pattern_stmt = gimple_build_assign (rhs, COND_EXPR,\n+\t\t\t\t\t      cmp, cst1, cst0);\n+\n+\t  pattern_stmt_info = new_stmt_vec_info (pattern_stmt, vinfo);\n+\t  set_vinfo_for_stmt (pattern_stmt, pattern_stmt_info);\n+\t  STMT_VINFO_VECTYPE (pattern_stmt_info) = new_vectype;\n+\t  append_pattern_def_seq (stmt_vinfo, pattern_stmt);\n+\t}\n+\n       lhs = build1 (VIEW_CONVERT_EXPR, TREE_TYPE (vectype), lhs);\n       if (!useless_type_conversion_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n \t{\n \t  tree rhs2 = vect_recog_temp_ssa_var (TREE_TYPE (lhs), NULL);\n \t  gimple *cast_stmt = gimple_build_assign (rhs2, NOP_EXPR, rhs);\n-\t  new_pattern_def_seq (stmt_vinfo, cast_stmt);\n+\t  append_pattern_def_seq (stmt_vinfo, cast_stmt);\n \t  rhs = rhs2;\n \t}\n       pattern_stmt = gimple_build_assign (lhs, SSA_NAME, rhs);"}, {"sha": "fe83828277764760468d3d099a5cf924a024f551", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -792,6 +792,7 @@ vect_build_slp_tree_1 (vec_info *vinfo,\n \t  if (TREE_CODE_CLASS (rhs_code) != tcc_binary\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_unary\n \t      && TREE_CODE_CLASS (rhs_code) != tcc_expression\n+\t      && TREE_CODE_CLASS (rhs_code) != tcc_comparison\n \t      && rhs_code != CALL_EXPR)\n \t    {\n \t      if (dump_enabled_p ())\n@@ -2640,7 +2641,14 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n   struct loop *loop;\n   gimple_seq ctor_seq = NULL;\n \n-  vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+  /* Check if vector type is a boolean vector.  */\n+  if (TREE_CODE (TREE_TYPE (op)) == BOOLEAN_TYPE\n+      && (VECTOR_BOOLEAN_TYPE_P (STMT_VINFO_VECTYPE (stmt_vinfo))\n+\t  || (code == COND_EXPR && op_num < 2)))\n+    vector_type\n+      = build_same_sized_truth_vector_type (STMT_VINFO_VECTYPE (stmt_vinfo));\n+  else\n+    vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n   nunits = TYPE_VECTOR_SUBPARTS (vector_type);\n \n   if (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n@@ -2812,8 +2820,21 @@ vect_get_constant_vectors (tree op, slp_tree slp_node,\n \t    {\n \t      if (CONSTANT_CLASS_P (op))\n \t\t{\n-\t\t  op = fold_unary (VIEW_CONVERT_EXPR,\n-\t\t\t\t   TREE_TYPE (vector_type), op);\n+\t\t  if (VECTOR_BOOLEAN_TYPE_P (vector_type))\n+\t\t    {\n+\t\t      /* Can't use VIEW_CONVERT_EXPR for booleans because\n+\t\t\t of possibly different sizes of scalar value and\n+\t\t\t vector element.  */\n+\t\t      if (integer_zerop (op))\n+\t\t\top = build_int_cst (TREE_TYPE (vector_type), 0);\n+\t\t      else if (integer_onep (op))\n+\t\t\top = build_int_cst (TREE_TYPE (vector_type), 1);\n+\t\t      else\n+\t\t\tgcc_unreachable ();\n+\t\t    }\n+\t\t  else\n+\t\t    op = fold_unary (VIEW_CONVERT_EXPR,\n+\t\t\t\t     TREE_TYPE (vector_type), op);\n \t\t  gcc_assert (op && CONSTANT_CLASS_P (op));\n \t\t}\n \t      else"}, {"sha": "af203ab438ceb7abfa6d6a6ed5a9ff5f9683faec", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 221, "deletions": 8, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -1300,7 +1300,7 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n       if (!types_compatible_p (TREE_TYPE (type), TREE_TYPE (val)))\n \t{\n \t  if (CONSTANT_CLASS_P (val))\n-\t    val = fold_unary (VIEW_CONVERT_EXPR, TREE_TYPE (type), val);\n+\t    val = fold_convert (TREE_TYPE (type), val);\n \t  else\n \t    {\n \t      new_temp = make_ssa_name (TREE_TYPE (type));\n@@ -1328,16 +1328,18 @@ vect_init_vector (gimple *stmt, tree val, tree type, gimple_stmt_iterator *gsi)\n    STMT_VINFO_VEC_STMT of the defining stmt holds the relevant def.\n \n    In case OP is an invariant or constant, a new stmt that creates a vector def\n-   needs to be introduced.  */\n+   needs to be introduced.  VECTYPE may be used to specify a required type for\n+   vector invariant.  */\n \n tree\n-vect_get_vec_def_for_operand (tree op, gimple *stmt)\n+vect_get_vec_def_for_operand (tree op, gimple *stmt, tree vectype)\n {\n   tree vec_oprnd;\n   gimple *vec_stmt;\n   gimple *def_stmt;\n   stmt_vec_info def_stmt_info = NULL;\n   stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt);\n+  tree stmt_vectype = STMT_VINFO_VECTYPE (stmt_vinfo);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_vinfo);\n   enum vect_def_type dt;\n   bool is_simple_use;\n@@ -1372,7 +1374,14 @@ vect_get_vec_def_for_operand (tree op, gimple *stmt)\n     case vect_constant_def:\n     case vect_external_def:\n       {\n-\tvector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\tif (vectype)\n+\t  vector_type = vectype;\n+\telse if (TREE_CODE (TREE_TYPE (op)) == BOOLEAN_TYPE\n+\t\t && VECTOR_BOOLEAN_TYPE_P (stmt_vectype))\n+\t  vector_type = build_same_sized_truth_vector_type (stmt_vectype);\n+\telse\n+\t  vector_type = get_vectype_for_scalar_type (TREE_TYPE (op));\n+\n \tgcc_assert (vector_type);\n         return vect_init_vector (stmt, op, vector_type, NULL);\n       }\n@@ -7329,13 +7338,14 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n             {\n \t      gimple *gtemp;\n \t      vec_cond_lhs =\n-\t      vect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0), stmt);\n+\t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 0),\n+\t\t\t\t\t      stmt, comp_vectype);\n \t      vect_is_simple_use (TREE_OPERAND (cond_expr, 0),\n \t\t\t\t  loop_vinfo, &gtemp, &dts[0]);\n \n \t      vec_cond_rhs =\n \t\tvect_get_vec_def_for_operand (TREE_OPERAND (cond_expr, 1),\n-\t\t\t\t\t      stmt);\n+\t\t\t\t\t      stmt, comp_vectype);\n \t      vect_is_simple_use (TREE_OPERAND (cond_expr, 1),\n \t\t\t\t  loop_vinfo, &gtemp, &dts[1]);\n \t      if (reduc_index == 1)\n@@ -7416,6 +7426,185 @@ vectorizable_condition (gimple *stmt, gimple_stmt_iterator *gsi,\n   return true;\n }\n \n+/* vectorizable_comparison.\n+\n+   Check if STMT is comparison expression that can be vectorized.\n+   If VEC_STMT is also passed, vectorize the STMT: create a vectorized\n+   comparison, put it in VEC_STMT, and insert it at GSI.\n+\n+   Return FALSE if not a vectorizable STMT, TRUE otherwise.  */\n+\n+bool\n+vectorizable_comparison (gimple *stmt, gimple_stmt_iterator *gsi,\n+\t\t\t gimple **vec_stmt, tree reduc_def,\n+\t\t\t slp_tree slp_node)\n+{\n+  tree lhs, rhs1, rhs2;\n+  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+  tree vectype1 = NULL_TREE, vectype2 = NULL_TREE;\n+  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n+  tree vec_rhs1 = NULL_TREE, vec_rhs2 = NULL_TREE;\n+  tree new_temp;\n+  loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n+  enum vect_def_type dts[2] = {vect_unknown_def_type, vect_unknown_def_type};\n+  unsigned nunits;\n+  int ncopies;\n+  enum tree_code code;\n+  stmt_vec_info prev_stmt_info = NULL;\n+  int i, j;\n+  bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n+  vec<tree> vec_oprnds0 = vNULL;\n+  vec<tree> vec_oprnds1 = vNULL;\n+  gimple *def_stmt;\n+  tree mask_type;\n+  tree mask;\n+\n+  if (!VECTOR_BOOLEAN_TYPE_P (vectype))\n+    return false;\n+\n+  mask_type = vectype;\n+  nunits = TYPE_VECTOR_SUBPARTS (vectype);\n+\n+  if (slp_node || PURE_SLP_STMT (stmt_info))\n+    ncopies = 1;\n+  else\n+    ncopies = LOOP_VINFO_VECT_FACTOR (loop_vinfo) / nunits;\n+\n+  gcc_assert (ncopies >= 1);\n+  if (!STMT_VINFO_RELEVANT_P (stmt_info) && !bb_vinfo)\n+    return false;\n+\n+  if (STMT_VINFO_DEF_TYPE (stmt_info) != vect_internal_def\n+      && !(STMT_VINFO_DEF_TYPE (stmt_info) == vect_nested_cycle\n+\t   && reduc_def))\n+    return false;\n+\n+  if (STMT_VINFO_LIVE_P (stmt_info))\n+    {\n+      if (dump_enabled_p ())\n+\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n+\t\t\t \"value used after loop.\\n\");\n+      return false;\n+    }\n+\n+  if (!is_gimple_assign (stmt))\n+    return false;\n+\n+  code = gimple_assign_rhs_code (stmt);\n+\n+  if (TREE_CODE_CLASS (code) != tcc_comparison)\n+    return false;\n+\n+  rhs1 = gimple_assign_rhs1 (stmt);\n+  rhs2 = gimple_assign_rhs2 (stmt);\n+\n+  if (!vect_is_simple_use (rhs1, stmt_info->vinfo, &def_stmt,\n+\t\t\t   &dts[0], &vectype1))\n+    return false;\n+\n+  if (!vect_is_simple_use (rhs2, stmt_info->vinfo, &def_stmt,\n+\t\t\t   &dts[1], &vectype2))\n+    return false;\n+\n+  if (vectype1 && vectype2\n+      && TYPE_VECTOR_SUBPARTS (vectype1) != TYPE_VECTOR_SUBPARTS (vectype2))\n+    return false;\n+\n+  vectype = vectype1 ? vectype1 : vectype2;\n+\n+  /* Invariant comparison.  */\n+  if (!vectype)\n+    {\n+      vectype = build_vector_type (TREE_TYPE (rhs1), nunits);\n+      if (tree_to_shwi (TYPE_SIZE_UNIT (vectype)) != current_vector_size)\n+\treturn false;\n+    }\n+  else if (nunits != TYPE_VECTOR_SUBPARTS (vectype))\n+    return false;\n+\n+  if (!vec_stmt)\n+    {\n+      STMT_VINFO_TYPE (stmt_info) = comparison_vec_info_type;\n+      vect_model_simple_cost (stmt_info, ncopies, dts, NULL, NULL);\n+      return expand_vec_cmp_expr_p (vectype, mask_type);\n+    }\n+\n+  /* Transform.  */\n+  if (!slp_node)\n+    {\n+      vec_oprnds0.create (1);\n+      vec_oprnds1.create (1);\n+    }\n+\n+  /* Handle def.  */\n+  lhs = gimple_assign_lhs (stmt);\n+  mask = vect_create_destination_var (lhs, mask_type);\n+\n+  /* Handle cmp expr.  */\n+  for (j = 0; j < ncopies; j++)\n+    {\n+      gassign *new_stmt = NULL;\n+      if (j == 0)\n+\t{\n+\t  if (slp_node)\n+\t    {\n+\t      auto_vec<tree, 2> ops;\n+\t      auto_vec<vec<tree>, 2> vec_defs;\n+\n+\t      ops.safe_push (rhs1);\n+\t      ops.safe_push (rhs2);\n+\t      vect_get_slp_defs (ops, slp_node, &vec_defs, -1);\n+\t      vec_oprnds1 = vec_defs.pop ();\n+\t      vec_oprnds0 = vec_defs.pop ();\n+\t    }\n+\t  else\n+\t    {\n+\t      vec_rhs1 = vect_get_vec_def_for_operand (rhs1, stmt, NULL);\n+\t      vec_rhs2 = vect_get_vec_def_for_operand (rhs2, stmt, NULL);\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  vec_rhs1 = vect_get_vec_def_for_stmt_copy (dts[0],\n+\t\t\t\t\t\t     vec_oprnds0.pop ());\n+\t  vec_rhs2 = vect_get_vec_def_for_stmt_copy (dts[1],\n+\t\t\t\t\t\t     vec_oprnds1.pop ());\n+\t}\n+\n+      if (!slp_node)\n+\t{\n+\t  vec_oprnds0.quick_push (vec_rhs1);\n+\t  vec_oprnds1.quick_push (vec_rhs2);\n+\t}\n+\n+      /* Arguments are ready.  Create the new vector stmt.  */\n+      FOR_EACH_VEC_ELT (vec_oprnds0, i, vec_rhs1)\n+\t{\n+\t  vec_rhs2 = vec_oprnds1[i];\n+\n+\t  new_temp = make_ssa_name (mask);\n+\t  new_stmt = gimple_build_assign (new_temp, code, vec_rhs1, vec_rhs2);\n+\t  vect_finish_stmt_generation (stmt, new_stmt, gsi);\n+\t  if (slp_node)\n+\t    SLP_TREE_VEC_STMTS (slp_node).quick_push (new_stmt);\n+\t}\n+\n+      if (slp_node)\n+\tcontinue;\n+\n+      if (j == 0)\n+\tSTMT_VINFO_VEC_STMT (stmt_info) = *vec_stmt = new_stmt;\n+      else\n+\tSTMT_VINFO_RELATED_STMT (prev_stmt_info) = new_stmt;\n+\n+      prev_stmt_info = vinfo_for_stmt (new_stmt);\n+    }\n+\n+  vec_oprnds0.release ();\n+  vec_oprnds1.release ();\n+\n+  return true;\n+}\n \n /* Make sure the statement is vectorizable.  */\n \n@@ -7619,7 +7808,8 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t  || vectorizable_call (stmt, NULL, NULL, node)\n \t  || vectorizable_store (stmt, NULL, NULL, node)\n \t  || vectorizable_reduction (stmt, NULL, NULL, node)\n-\t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node));\n+\t  || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n+\t  || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n   else\n     {\n       if (bb_vinfo)\n@@ -7631,7 +7821,8 @@ vect_analyze_stmt (gimple *stmt, bool *need_to_vectorize, slp_tree node)\n \t      || vectorizable_load (stmt, NULL, NULL, node, NULL)\n \t      || vectorizable_call (stmt, NULL, NULL, node)\n \t      || vectorizable_store (stmt, NULL, NULL, node)\n-\t      || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node));\n+\t      || vectorizable_condition (stmt, NULL, NULL, NULL, 0, node)\n+\t      || vectorizable_comparison (stmt, NULL, NULL, NULL, node));\n     }\n \n   if (!ok)\n@@ -7747,6 +7938,11 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n       gcc_assert (done);\n       break;\n \n+    case comparison_vec_info_type:\n+      done = vectorizable_comparison (stmt, gsi, &vec_stmt, NULL, slp_node);\n+      gcc_assert (done);\n+      break;\n+\n     case call_vec_info_type:\n       done = vectorizable_call (stmt, gsi, &vec_stmt, slp_node);\n       stmt = gsi_stmt (*gsi);\n@@ -8080,6 +8276,23 @@ get_vectype_for_scalar_type (tree scalar_type)\n   return vectype;\n }\n \n+/* Function get_mask_type_for_scalar_type.\n+\n+   Returns the mask type corresponding to a result of comparison\n+   of vectors of specified SCALAR_TYPE as supported by target.  */\n+\n+tree\n+get_mask_type_for_scalar_type (tree scalar_type)\n+{\n+  tree vectype = get_vectype_for_scalar_type (scalar_type);\n+\n+  if (!vectype)\n+    return NULL;\n+\n+  return build_truth_vector_type (TYPE_VECTOR_SUBPARTS (vectype),\n+\t\t\t\t  current_vector_size);\n+}\n+\n /* Function get_same_sized_vectype\n \n    Returns a vector type corresponding to SCALAR_TYPE of size"}, {"sha": "d890eb11d48b4be51a3df0620dbc8bd36e13ca93", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42fd8198b4adabe3aa74e9bb98518a1d137c3aff/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=42fd8198b4adabe3aa74e9bb98518a1d137c3aff", "patch": "@@ -28,7 +28,8 @@ along with GCC; see the file COPYING3.  If not see\n enum vect_var_kind {\n   vect_simple_var,\n   vect_pointer_var,\n-  vect_scalar_var\n+  vect_scalar_var,\n+  vect_mask_var\n };\n \n /* Defines type of operation.  */\n@@ -420,6 +421,7 @@ enum stmt_vec_info_type {\n   call_simd_clone_vec_info_type,\n   assignment_vec_info_type,\n   condition_vec_info_type,\n+  comparison_vec_info_type,\n   reduc_vec_info_type,\n   induc_vec_info_type,\n   type_promotion_vec_info_type,\n@@ -944,6 +946,7 @@ extern bool vect_can_advance_ivs_p (loop_vec_info);\n /* In tree-vect-stmts.c.  */\n extern unsigned int current_vector_size;\n extern tree get_vectype_for_scalar_type (tree);\n+extern tree get_mask_type_for_scalar_type (tree);\n extern tree get_same_sized_vectype (tree, tree);\n extern bool vect_is_simple_use (tree, vec_info *, gimple **,\n                                 enum vect_def_type *);\n@@ -975,7 +978,7 @@ extern unsigned record_stmt_cost (stmt_vector_for_cost *, int,\n extern void vect_finish_stmt_generation (gimple *, gimple *,\n                                          gimple_stmt_iterator *);\n extern bool vect_mark_stmts_to_be_vectorized (loop_vec_info);\n-extern tree vect_get_vec_def_for_operand (tree, gimple *);\n+extern tree vect_get_vec_def_for_operand (tree, gimple *, tree = NULL);\n extern tree vect_init_vector (gimple *, tree, tree,\n                               gimple_stmt_iterator *);\n extern tree vect_get_vec_def_for_stmt_copy (enum vect_def_type, tree);\n@@ -985,6 +988,8 @@ extern void vect_remove_stores (gimple *);\n extern bool vect_analyze_stmt (gimple *, bool *, slp_tree);\n extern bool vectorizable_condition (gimple *, gimple_stmt_iterator *,\n \t\t\t\t    gimple **, tree, int, slp_tree);\n+extern bool vectorizable_comparison (gimple *, gimple_stmt_iterator *,\n+\t\t\t\t     gimple **, tree, int, slp_tree);\n extern void vect_get_load_cost (struct data_reference *, int, bool,\n \t\t\t\tunsigned int *, unsigned int *,\n \t\t\t\tstmt_vector_for_cost *,"}]}