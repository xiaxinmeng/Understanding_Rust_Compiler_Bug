{"sha": "60564289186303fb1368800ed9dd466668300e8f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjA1NjQyODkxODYzMDNmYjEzNjg4MDBlZDlkZDQ2NjY2ODMwMGU4Zg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2008-07-15T17:51:00Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2008-07-15T17:51:00Z"}, "message": "df-problems.c (df_set_note): Avoid C++ keywords.\n\n\t* df-problems.c (df_set_note): Avoid C++ keywords.\n\t* df-scan.c (df_ref_change_reg_with_loc_1): Likewise.\n\t* dse.c (record_store, remove_useless_values): Likewise.\n\t* emit-rtl.c (gen_reg_rtx, update_reg_offset, gen_rtx_REG_offset,\n\tgen_reg_rtx_offset, operand_subword, change_address_1,\n\tchange_address, adjust_address_1, offset_address,\n\twiden_memory_access, emit_copy_of_insn_after): Likewise.\n\t* explow.c (round_push, allocate_dynamic_stack_space): Likewise.\n\t* fwprop.c (should_replace_address, propagate_rtx_1,\n\tpropagate_rtx, try_fwprop_subst, forward_propagate_and_simplify):\n\tLikewise.\n\t* gcse.c (cprop_jump, find_implicit_sets, bypass_block,\n\tgcse_emit_move_after, update_ld_motion_stores): Likewise.\n\t* lcm.c (compute_insert_delete, pre_edge_lcm,\n\tcompute_rev_insert_delete, pre_edge_rev_lcm): Likewise.\n\t* lower-subreg.c (resolve_reg_notes): Likewise.\n\t* mode-switching.c (optimize_mode_switching): Likewise.\n\nFrom-SVN: r137848", "tree": {"sha": "8310b0ac98d869d58834bfe965b85a9dd035a0a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8310b0ac98d869d58834bfe965b85a9dd035a0a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/60564289186303fb1368800ed9dd466668300e8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60564289186303fb1368800ed9dd466668300e8f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/60564289186303fb1368800ed9dd466668300e8f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/60564289186303fb1368800ed9dd466668300e8f/comments", "author": null, "committer": null, "parents": [{"sha": "32e9fa4804d726e0479c6f562f39c32ebd63eb16", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/32e9fa4804d726e0479c6f562f39c32ebd63eb16", "html_url": "https://github.com/Rust-GCC/gccrs/commit/32e9fa4804d726e0479c6f562f39c32ebd63eb16"}], "stats": {"total": 400, "additions": 210, "deletions": 190}, "files": [{"sha": "8689a24b63a3a6313e36d0a5d4adf2925d0cb13f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -1,3 +1,23 @@\n+2008-07-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* df-problems.c (df_set_note): Avoid C++ keywords.\n+\t* df-scan.c (df_ref_change_reg_with_loc_1): Likewise.\n+\t* dse.c (record_store, remove_useless_values): Likewise.\n+\t* emit-rtl.c (gen_reg_rtx, update_reg_offset, gen_rtx_REG_offset,\n+\tgen_reg_rtx_offset, operand_subword, change_address_1,\n+\tchange_address, adjust_address_1, offset_address,\n+\twiden_memory_access, emit_copy_of_insn_after): Likewise.\n+\t* explow.c (round_push, allocate_dynamic_stack_space): Likewise.\n+\t* fwprop.c (should_replace_address, propagate_rtx_1,\n+\tpropagate_rtx, try_fwprop_subst, forward_propagate_and_simplify):\n+\tLikewise.\n+\t* gcse.c (cprop_jump, find_implicit_sets, bypass_block,\n+\tgcse_emit_move_after, update_ld_motion_stores): Likewise.\n+\t* lcm.c (compute_insert_delete, pre_edge_lcm,\n+\tcompute_rev_insert_delete, pre_edge_rev_lcm): Likewise.\n+\t* lower-subreg.c (resolve_reg_notes): Likewise.\n+\t* mode-switching.c (optimize_mode_switching): Likewise.\n+\n 2008-07-15  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* bt-load.c (add_btr_def, migrate_btr_def,"}, {"sha": "abb34d0596a0428b6bf75687e4cc5f8fae910bcc", "filename": "gcc/df-problems.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -3170,24 +3170,24 @@ df_kill_notes (rtx insn, rtx *old_dead_notes, rtx *old_unused_notes)\n static inline rtx\n df_set_note (enum reg_note note_type, rtx insn, rtx old, rtx reg)\n {\n-  rtx this = old;\n+  rtx curr = old;\n   rtx prev = NULL;\n \n-  while (this)\n-    if (XEXP (this, 0) == reg)\n+  while (curr)\n+    if (XEXP (curr, 0) == reg)\n       {\n \tif (prev)\n-\t  XEXP (prev, 1) = XEXP (this, 1);\n+\t  XEXP (prev, 1) = XEXP (curr, 1);\n \telse\n-\t  old = XEXP (this, 1);\n-\tXEXP (this, 1) = REG_NOTES (insn);\n-\tREG_NOTES (insn) = this;\n+\t  old = XEXP (curr, 1);\n+\tXEXP (curr, 1) = REG_NOTES (insn);\n+\tREG_NOTES (insn) = curr;\n \treturn old;\n       }\n     else\n       {\n-\tprev = this;\n-\tthis = XEXP (this, 1);\n+\tprev = curr;\n+\tcurr = XEXP (curr, 1);\n       }\n   \n   /* Did not find the note.  */"}, {"sha": "0ce48b5d1e046a33d58e109f13461aecf93988f7", "filename": "gcc/df-scan.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -1887,10 +1887,10 @@ df_insn_change_bb (rtx insn, basic_block new_bb)\n /* Helper function for df_ref_change_reg_with_loc.  */\n \n static void\n-df_ref_change_reg_with_loc_1 (struct df_reg_info *old, struct df_reg_info *new,\n+df_ref_change_reg_with_loc_1 (struct df_reg_info *old_df, struct df_reg_info *new_df,\n \t\t\t      int new_regno, rtx loc)\n {\n-  struct df_ref *the_ref = old->reg_chain;\n+  struct df_ref *the_ref = old_df->reg_chain;\n \n   while (the_ref)\n     {\n@@ -1908,18 +1908,18 @@ df_ref_change_reg_with_loc_1 (struct df_reg_info *old, struct df_reg_info *new,\n \t  if (prev_ref)\n \t    prev_ref->next_reg = next_ref;\n \t  else\n-\t    old->reg_chain = next_ref;\n+\t    old_df->reg_chain = next_ref;\n \t  if (next_ref)\n \t    next_ref->prev_reg = prev_ref;\n-\t  old->n_refs--;\n+\t  old_df->n_refs--;\n \n \t  /* Put the ref into the new regno chain.  */\n \t  the_ref->prev_reg = NULL;\n-\t  the_ref->next_reg = new->reg_chain;\n-\t  if (new->reg_chain)\n-\t    new->reg_chain->prev_reg = the_ref;\n-\t  new->reg_chain = the_ref;\n-\t  new->n_refs++;\n+\t  the_ref->next_reg = new_df->reg_chain;\n+\t  if (new_df->reg_chain)\n+\t    new_df->reg_chain->prev_reg = the_ref;\n+\t  new_df->reg_chain = the_ref;\n+\t  new_df->n_refs++;\n \t  df_set_bb_dirty (DF_REF_BB (the_ref));\n \n \t  /* Need to resort the record that the ref was in because the"}, {"sha": "4d5120160fa29425ceede7abfe0d0beb67e751e6", "filename": "gcc/dse.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -1295,7 +1295,7 @@ record_store (rtx body, bb_info_t bb_info)\n     {\n       insn_info_t next = ptr->next_local_store;\n       store_info_t s_info = ptr->store_rec;\n-      bool delete = true;\n+      bool del = true;\n \n       /* Skip the clobbers. We delete the active insn if this insn\n \t shadows the set.  To have been put on the active list, it\n@@ -1304,7 +1304,7 @@ record_store (rtx body, bb_info_t bb_info)\n \ts_info = s_info->next;\n \n       if (s_info->alias_set != spill_alias_set)\n-\tdelete = false;\n+\tdel = false;\n       else if (s_info->alias_set)\n \t{\n \t  struct clear_alias_mode_holder *entry \n@@ -1317,7 +1317,7 @@ record_store (rtx body, bb_info_t bb_info)\n \t  if ((GET_MODE (mem) == GET_MODE (s_info->mem))\n \t      && (GET_MODE (mem) == entry->mode))\n \t    {\n-\t      delete = true;\n+\t      del = true;\n \t      s_info->positions_needed = (unsigned HOST_WIDE_INT) 0;\n \t    }\n \t  if (dump_file)\n@@ -1352,9 +1352,9 @@ record_store (rtx body, bb_info_t bb_info)\n       /* An insn can be deleted if every position of every one of\n \t its s_infos is zero.  */\n       if (s_info->positions_needed != (unsigned HOST_WIDE_INT) 0)\n-\tdelete = false;\n+\tdel = false;\n       \n-      if (delete)\n+      if (del)\n \t{\n \t  insn_info_t insn_to_delete = ptr;\n \t  \n@@ -2080,7 +2080,7 @@ remove_useless_values (cselib_val *base)\n   while (insn_info)\n     {\n       store_info_t store_info = insn_info->store_rec;\n-      bool delete = false;\n+      bool del = false;\n \n       /* If ANY of the store_infos match the cselib group that is\n \t being deleted, then the insn can not be deleted.  */\n@@ -2089,13 +2089,13 @@ remove_useless_values (cselib_val *base)\n \t  if ((store_info->group_id == -1) \n \t      && (store_info->cse_base == base))\n \t    {\n-\t      delete = true;\n+\t      del = true;\n \t      break;\n \t    }\n \t  store_info = store_info->next;\n \t}\n \n-      if (delete)\n+      if (del)\n \t{\n \t  if (last)\n \t    last->next_local_store = insn_info->next_local_store;"}, {"sha": "65fa8e457ecda6fd9f31776af765aee8cadaa879", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 70, "deletions": 70, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -890,12 +890,12 @@ gen_reg_rtx (enum machine_mode mode)\n   if (reg_rtx_no == crtl->emit.regno_pointer_align_length)\n     {\n       int old_size = crtl->emit.regno_pointer_align_length;\n-      char *new;\n+      char *tmp;\n       rtx *new1;\n \n-      new = XRESIZEVEC (char, crtl->emit.regno_pointer_align, old_size * 2);\n-      memset (new + old_size, 0, old_size);\n-      crtl->emit.regno_pointer_align = (unsigned char *) new;\n+      tmp = XRESIZEVEC (char, crtl->emit.regno_pointer_align, old_size * 2);\n+      memset (tmp + old_size, 0, old_size);\n+      crtl->emit.regno_pointer_align = (unsigned char *) tmp;\n \n       new1 = GGC_RESIZEVEC (rtx, regno_reg_rtx, old_size * 2);\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n@@ -913,9 +913,9 @@ gen_reg_rtx (enum machine_mode mode)\n    to the REG_OFFSET.  */\n \n static void\n-update_reg_offset (rtx new, rtx reg, int offset)\n+update_reg_offset (rtx new_rtx, rtx reg, int offset)\n {\n-  REG_ATTRS (new) = get_reg_attrs (REG_EXPR (reg),\n+  REG_ATTRS (new_rtx) = get_reg_attrs (REG_EXPR (reg),\n \t\t\t\t   REG_OFFSET (reg) + offset);\n }\n \n@@ -926,10 +926,10 @@ rtx\n gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno,\n \t\t    int offset)\n {\n-  rtx new = gen_rtx_REG (mode, regno);\n+  rtx new_rtx = gen_rtx_REG (mode, regno);\n \n-  update_reg_offset (new, reg, offset);\n-  return new;\n+  update_reg_offset (new_rtx, reg, offset);\n+  return new_rtx;\n }\n \n /* Generate a new pseudo-register with the same attributes as REG, but\n@@ -938,10 +938,10 @@ gen_rtx_REG_offset (rtx reg, enum machine_mode mode, unsigned int regno,\n rtx\n gen_reg_rtx_offset (rtx reg, enum machine_mode mode, int offset)\n {\n-  rtx new = gen_reg_rtx (mode);\n+  rtx new_rtx = gen_reg_rtx (mode);\n \n-  update_reg_offset (new, reg, offset);\n-  return new;\n+  update_reg_offset (new_rtx, reg, offset);\n+  return new_rtx;\n }\n \n /* Adjust REG in-place so that it has mode MODE.  It is assumed that the\n@@ -1372,18 +1372,18 @@ operand_subword (rtx op, unsigned int offset, int validate_address, enum machine\n   /* Form a new MEM at the requested address.  */\n   if (MEM_P (op))\n     {\n-      rtx new = adjust_address_nv (op, word_mode, offset * UNITS_PER_WORD);\n+      rtx new_rtx = adjust_address_nv (op, word_mode, offset * UNITS_PER_WORD);\n \n       if (! validate_address)\n-\treturn new;\n+\treturn new_rtx;\n \n       else if (reload_completed)\n \t{\n-\t  if (! strict_memory_address_p (word_mode, XEXP (new, 0)))\n+\t  if (! strict_memory_address_p (word_mode, XEXP (new_rtx, 0)))\n \t    return 0;\n \t}\n       else\n-\treturn replace_equiv_address (new, XEXP (new, 0));\n+\treturn replace_equiv_address (new_rtx, XEXP (new_rtx, 0));\n     }\n \n   /* Rest can be handled by simplify_subreg.  */\n@@ -1834,7 +1834,7 @@ set_mem_size (rtx mem, rtx size)\n static rtx\n change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n {\n-  rtx new;\n+  rtx new_rtx;\n \n   gcc_assert (MEM_P (memref));\n   if (mode == VOIDmode)\n@@ -1856,9 +1856,9 @@ change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n     return memref;\n \n-  new = gen_rtx_MEM (mode, addr);\n-  MEM_COPY_ATTRIBUTES (new, memref);\n-  return new;\n+  new_rtx = gen_rtx_MEM (mode, addr);\n+  MEM_COPY_ATTRIBUTES (new_rtx, memref);\n+  return new_rtx;\n }\n \n /* Like change_address_1 with VALIDATE nonzero, but we are not saying in what\n@@ -1867,31 +1867,31 @@ change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n rtx\n change_address (rtx memref, enum machine_mode mode, rtx addr)\n {\n-  rtx new = change_address_1 (memref, mode, addr, 1), size;\n-  enum machine_mode mmode = GET_MODE (new);\n+  rtx new_rtx = change_address_1 (memref, mode, addr, 1), size;\n+  enum machine_mode mmode = GET_MODE (new_rtx);\n   unsigned int align;\n \n   size = mmode == BLKmode ? 0 : GEN_INT (GET_MODE_SIZE (mmode));\n   align = mmode == BLKmode ? BITS_PER_UNIT : GET_MODE_ALIGNMENT (mmode);\n \n   /* If there are no changes, just return the original memory reference.  */\n-  if (new == memref)\n+  if (new_rtx == memref)\n     {\n       if (MEM_ATTRS (memref) == 0\n \t  || (MEM_EXPR (memref) == NULL\n \t      && MEM_OFFSET (memref) == NULL\n \t      && MEM_SIZE (memref) == size\n \t      && MEM_ALIGN (memref) == align))\n-\treturn new;\n+\treturn new_rtx;\n \n-      new = gen_rtx_MEM (mmode, XEXP (memref, 0));\n-      MEM_COPY_ATTRIBUTES (new, memref);\n+      new_rtx = gen_rtx_MEM (mmode, XEXP (memref, 0));\n+      MEM_COPY_ATTRIBUTES (new_rtx, memref);\n     }\n \n-  MEM_ATTRS (new)\n+  MEM_ATTRS (new_rtx)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), 0, 0, size, align, mmode);\n \n-  return new;\n+  return new_rtx;\n }\n \n /* Return a memory reference like MEMREF, but with its mode changed\n@@ -1905,7 +1905,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \t\t  int validate, int adjust)\n {\n   rtx addr = XEXP (memref, 0);\n-  rtx new;\n+  rtx new_rtx;\n   rtx memoffset = MEM_OFFSET (memref);\n   rtx size = 0;\n   unsigned int memalign = MEM_ALIGN (memref);\n@@ -1934,7 +1934,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \taddr = plus_constant (addr, offset);\n     }\n \n-  new = change_address_1 (memref, mode, addr, validate);\n+  new_rtx = change_address_1 (memref, mode, addr, validate);\n \n   /* Compute the new values of the memory attributes due to this adjustment.\n      We add the offsets and update the alignment.  */\n@@ -1950,17 +1950,17 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \t     (unsigned HOST_WIDE_INT) (offset & -offset) * BITS_PER_UNIT);\n \n   /* We can compute the size in a number of ways.  */\n-  if (GET_MODE (new) != BLKmode)\n-    size = GEN_INT (GET_MODE_SIZE (GET_MODE (new)));\n+  if (GET_MODE (new_rtx) != BLKmode)\n+    size = GEN_INT (GET_MODE_SIZE (GET_MODE (new_rtx)));\n   else if (MEM_SIZE (memref))\n     size = plus_constant (MEM_SIZE (memref), -offset);\n \n-  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n-\t\t\t\t   memoffset, size, memalign, GET_MODE (new));\n+  MEM_ATTRS (new_rtx) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref),\n+\t\t\t\t   memoffset, size, memalign, GET_MODE (new_rtx));\n \n   /* At some point, we should validate that this offset is within the object,\n      if all the appropriate values are known.  */\n-  return new;\n+  return new_rtx;\n }\n \n /* Return a memory reference like MEMREF, but with its mode changed\n@@ -1983,9 +1983,9 @@ adjust_automodify_address_1 (rtx memref, enum machine_mode mode, rtx addr,\n rtx\n offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n {\n-  rtx new, addr = XEXP (memref, 0);\n+  rtx new_rtx, addr = XEXP (memref, 0);\n \n-  new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+  new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);\n \n   /* At this point we don't know _why_ the address is invalid.  It\n      could have secondary memory references, multiplies or anything.\n@@ -1994,28 +1994,28 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n      being able to recognize the magic around pic_offset_table_rtx.\n      This stuff is fragile, and is yet another example of why it is\n      bad to expose PIC machinery too early.  */\n-  if (! memory_address_p (GET_MODE (memref), new)\n+  if (! memory_address_p (GET_MODE (memref), new_rtx)\n       && GET_CODE (addr) == PLUS\n       && XEXP (addr, 0) == pic_offset_table_rtx)\n     {\n       addr = force_reg (GET_MODE (addr), addr);\n-      new = simplify_gen_binary (PLUS, Pmode, addr, offset);\n+      new_rtx = simplify_gen_binary (PLUS, Pmode, addr, offset);\n     }\n \n-  update_temp_slot_address (XEXP (memref, 0), new);\n-  new = change_address_1 (memref, VOIDmode, new, 1);\n+  update_temp_slot_address (XEXP (memref, 0), new_rtx);\n+  new_rtx = change_address_1 (memref, VOIDmode, new_rtx, 1);\n \n   /* If there are no changes, just return the original memory reference.  */\n-  if (new == memref)\n-    return new;\n+  if (new_rtx == memref)\n+    return new_rtx;\n \n   /* Update the alignment to reflect the offset.  Reset the offset, which\n      we don't know.  */\n-  MEM_ATTRS (new)\n+  MEM_ATTRS (new_rtx)\n     = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_EXPR (memref), 0, 0,\n \t\t     MIN (MEM_ALIGN (memref), pow2 * BITS_PER_UNIT),\n-\t\t     GET_MODE (new));\n-  return new;\n+\t\t     GET_MODE (new_rtx));\n+  return new_rtx;\n }\n \n /* Return a memory reference like MEMREF, but with its address changed to\n@@ -2048,14 +2048,14 @@ replace_equiv_address_nv (rtx memref, rtx addr)\n rtx\n widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n {\n-  rtx new = adjust_address_1 (memref, mode, offset, 1, 1);\n-  tree expr = MEM_EXPR (new);\n-  rtx memoffset = MEM_OFFSET (new);\n+  rtx new_rtx = adjust_address_1 (memref, mode, offset, 1, 1);\n+  tree expr = MEM_EXPR (new_rtx);\n+  rtx memoffset = MEM_OFFSET (new_rtx);\n   unsigned int size = GET_MODE_SIZE (mode);\n \n   /* If there are no changes, just return the original memory reference.  */\n-  if (new == memref)\n-    return new;\n+  if (new_rtx == memref)\n+    return new_rtx;\n \n   /* If we don't know what offset we were at within the expression, then\n      we can't know if we've overstepped the bounds.  */\n@@ -2117,10 +2117,10 @@ widen_memory_access (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset)\n   /* The widened memory may alias other stuff, so zap the alias set.  */\n   /* ??? Maybe use get_alias_set on any remaining expression.  */\n \n-  MEM_ATTRS (new) = get_mem_attrs (0, expr, memoffset, GEN_INT (size),\n-\t\t\t\t   MEM_ALIGN (new), mode);\n+  MEM_ATTRS (new_rtx) = get_mem_attrs (0, expr, memoffset, GEN_INT (size),\n+\t\t\t\t   MEM_ALIGN (new_rtx), mode);\n \n-  return new;\n+  return new_rtx;\n }\n \f\n /* Return a newly created CODE_LABEL rtx with a unique label number.  */\n@@ -5464,27 +5464,27 @@ init_emit_once (int line_numbers)\n rtx\n emit_copy_of_insn_after (rtx insn, rtx after)\n {\n-  rtx new, link;\n+  rtx new_rtx, link;\n \n   switch (GET_CODE (insn))\n     {\n     case INSN:\n-      new = emit_insn_after (copy_insn (PATTERN (insn)), after);\n+      new_rtx = emit_insn_after (copy_insn (PATTERN (insn)), after);\n       break;\n \n     case JUMP_INSN:\n-      new = emit_jump_insn_after (copy_insn (PATTERN (insn)), after);\n+      new_rtx = emit_jump_insn_after (copy_insn (PATTERN (insn)), after);\n       break;\n \n     case CALL_INSN:\n-      new = emit_call_insn_after (copy_insn (PATTERN (insn)), after);\n+      new_rtx = emit_call_insn_after (copy_insn (PATTERN (insn)), after);\n       if (CALL_INSN_FUNCTION_USAGE (insn))\n-\tCALL_INSN_FUNCTION_USAGE (new)\n+\tCALL_INSN_FUNCTION_USAGE (new_rtx)\n \t  = copy_insn (CALL_INSN_FUNCTION_USAGE (insn));\n-      SIBLING_CALL_P (new) = SIBLING_CALL_P (insn);\n-      RTL_CONST_CALL_P (new) = RTL_CONST_CALL_P (insn);\n-      RTL_PURE_CALL_P (new) = RTL_PURE_CALL_P (insn);\n-      RTL_LOOPING_CONST_OR_PURE_CALL_P (new) \n+      SIBLING_CALL_P (new_rtx) = SIBLING_CALL_P (insn);\n+      RTL_CONST_CALL_P (new_rtx) = RTL_CONST_CALL_P (insn);\n+      RTL_PURE_CALL_P (new_rtx) = RTL_PURE_CALL_P (insn);\n+      RTL_LOOPING_CONST_OR_PURE_CALL_P (new_rtx) \n \t= RTL_LOOPING_CONST_OR_PURE_CALL_P (insn);\n       break;\n \n@@ -5493,14 +5493,14 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n     }\n \n   /* Update LABEL_NUSES.  */\n-  mark_jump_label (PATTERN (new), new, 0);\n+  mark_jump_label (PATTERN (new_rtx), new_rtx, 0);\n \n-  INSN_LOCATOR (new) = INSN_LOCATOR (insn);\n+  INSN_LOCATOR (new_rtx) = INSN_LOCATOR (insn);\n \n   /* If the old insn is frame related, then so is the new one.  This is\n      primarily needed for IA-64 unwind info which marks epilogue insns,\n      which may be duplicated by the basic block reordering code.  */\n-  RTX_FRAME_RELATED_P (new) = RTX_FRAME_RELATED_P (insn);\n+  RTX_FRAME_RELATED_P (new_rtx) = RTX_FRAME_RELATED_P (insn);\n \n   /* Copy all REG_NOTES except REG_LABEL_OPERAND since mark_jump_label\n      will make them.  REG_LABEL_TARGETs are created there too, but are\n@@ -5509,14 +5509,14 @@ emit_copy_of_insn_after (rtx insn, rtx after)\n     if (REG_NOTE_KIND (link) != REG_LABEL_OPERAND)\n       {\n \tif (GET_CODE (link) == EXPR_LIST)\n-\t  add_reg_note (new, REG_NOTE_KIND (link),\n+\t  add_reg_note (new_rtx, REG_NOTE_KIND (link),\n \t\t\tcopy_insn_1 (XEXP (link, 0)));\n \telse\n-\t  add_reg_note (new, REG_NOTE_KIND (link), XEXP (link, 0));\n+\t  add_reg_note (new_rtx, REG_NOTE_KIND (link), XEXP (link, 0));\n       }\n \n-  INSN_CODE (new) = INSN_CODE (insn);\n-  return new;\n+  INSN_CODE (new_rtx) = INSN_CODE (insn);\n+  return new_rtx;\n }\n \n static GTY((deletable)) rtx hard_reg_clobbers [NUM_MACHINE_MODES][FIRST_PSEUDO_REGISTER];"}, {"sha": "0c941d5b337badabbce911e3bc0b2dbec08d5df9", "filename": "gcc/explow.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -874,10 +874,10 @@ round_push (rtx size)\n \n   if (GET_CODE (size) == CONST_INT)\n     {\n-      HOST_WIDE_INT new = (INTVAL (size) + align - 1) / align * align;\n+      HOST_WIDE_INT new_size = (INTVAL (size) + align - 1) / align * align;\n \n-      if (INTVAL (size) != new)\n-\tsize = GEN_INT (new);\n+      if (INTVAL (size) != new_size)\n+\tsize = GEN_INT (new_size);\n     }\n   else\n     {\n@@ -1136,10 +1136,10 @@ allocate_dynamic_stack_space (rtx size, rtx target, int known_align)\n \n       if (GET_CODE (size) == CONST_INT)\n \t{\n-\t  HOST_WIDE_INT new = INTVAL (size) / align * align;\n+\t  HOST_WIDE_INT new_size = INTVAL (size) / align * align;\n \n-\t  if (INTVAL (size) != new)\n-\t    size = GEN_INT (new);\n+\t  if (INTVAL (size) != new_size)\n+\t    size = GEN_INT (new_size);\n \t}\n       else\n \t{"}, {"sha": "e670001964415b6d4e0fb52909da8db7e097ce1f", "filename": "gcc/fwprop.c", "status": "modified", "additions": 43, "deletions": 43, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Ffwprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Ffwprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffwprop.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -184,26 +184,26 @@ canonicalize_address (rtx x)\n    for a memory access in the given MODE.  */\n \n static bool\n-should_replace_address (rtx old, rtx new, enum machine_mode mode)\n+should_replace_address (rtx old_rtx, rtx new_rtx, enum machine_mode mode)\n {\n   int gain;\n \n-  if (rtx_equal_p (old, new) || !memory_address_p (mode, new))\n+  if (rtx_equal_p (old_rtx, new_rtx) || !memory_address_p (mode, new_rtx))\n     return false;\n \n   /* Copy propagation is always ok.  */\n-  if (REG_P (old) && REG_P (new))\n+  if (REG_P (old_rtx) && REG_P (new_rtx))\n     return true;\n \n   /* Prefer the new address if it is less expensive.  */\n-  gain = address_cost (old, mode) - address_cost (new, mode);\n+  gain = address_cost (old_rtx, mode) - address_cost (new_rtx, mode);\n \n   /* If the addresses have equivalent cost, prefer the new address\n      if it has the highest `rtx_cost'.  That has the potential of\n      eliminating the most insns without additional costs, and it\n      is the same that cse.c used to do.  */\n   if (gain == 0)\n-    gain = rtx_cost (new, SET) - rtx_cost (old, SET);\n+    gain = rtx_cost (new_rtx, SET) - rtx_cost (old_rtx, SET);\n \n   return (gain > 0);\n }\n@@ -244,7 +244,7 @@ enum {\n    that is because there is no simplify_gen_* function for LO_SUM).  */\n \n static bool\n-propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n+propagate_rtx_1 (rtx *px, rtx old_rtx, rtx new_rtx, int flags)\n {\n   rtx x = *px, tem = NULL_RTX, op0, op1, op2;\n   enum rtx_code code = GET_CODE (x);\n@@ -265,9 +265,9 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n \n   /* If X is OLD_RTX, return NEW_RTX.  But not if replacing only within an\n      address, and we are *not* inside one.  */\n-  if (x == old)\n+  if (x == old_rtx)\n     {\n-      *px = new;\n+      *px = new_rtx;\n       return can_appear;\n     }\n \n@@ -277,7 +277,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n     case RTX_UNARY:\n       op0 = XEXP (x, 0);\n       op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n       if (op0 == XEXP (x, 0))\n \treturn true;\n       tem = simplify_gen_unary (code, mode, op0, op_mode);\n@@ -287,8 +287,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n     case RTX_COMM_ARITH:\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn true;\n       tem = simplify_gen_binary (code, mode, op0, op1);\n@@ -299,8 +299,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n       op0 = XEXP (x, 0);\n       op1 = XEXP (x, 1);\n       op_mode = GET_MODE (op0) != VOIDmode ? GET_MODE (op0) : GET_MODE (op1);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \treturn true;\n       tem = simplify_gen_relational (code, mode, op_mode, op0, op1);\n@@ -312,9 +312,9 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n       op1 = XEXP (x, 1);\n       op2 = XEXP (x, 2);\n       op_mode = GET_MODE (op0);\n-      valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n-      valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n-      valid_ops &= propagate_rtx_1 (&op2, old, new, flags);\n+      valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n+      valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n+      valid_ops &= propagate_rtx_1 (&op2, old_rtx, new_rtx, flags);\n       if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1) && op2 == XEXP (x, 2))\n \treturn true;\n       if (op_mode == VOIDmode)\n@@ -327,7 +327,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n       if (code == SUBREG)\n \t{\n           op0 = XEXP (x, 0);\n-\t  valid_ops &= propagate_rtx_1 (&op0, old, new, flags);\n+\t  valid_ops &= propagate_rtx_1 (&op0, old_rtx, new_rtx, flags);\n           if (op0 == XEXP (x, 0))\n \t    return true;\n \t  tem = simplify_gen_subreg (mode, op0, GET_MODE (SUBREG_REG (x)),\n@@ -336,7 +336,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n       break;\n \n     case RTX_OBJ:\n-      if (code == MEM && x != new)\n+      if (code == MEM && x != new_rtx)\n \t{\n \t  rtx new_op0;\n \t  op0 = XEXP (x, 0);\n@@ -346,7 +346,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n \t    return true;\n \n \t  op0 = new_op0 = targetm.delegitimize_address (op0);\n-\t  valid_ops &= propagate_rtx_1 (&new_op0, old, new,\n+\t  valid_ops &= propagate_rtx_1 (&new_op0, old_rtx, new_rtx,\n \t\t\t\t\tflags | PR_CAN_APPEAR);\n \n \t  /* Dismiss transformation that we do not want to carry on.  */\n@@ -359,7 +359,7 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n \t  canonicalize_address (new_op0);\n \n \t  /* Copy propagations are always ok.  Otherwise check the costs.  */\n-\t  if (!(REG_P (old) && REG_P (new))\n+\t  if (!(REG_P (old_rtx) && REG_P (new_rtx))\n \t      && !should_replace_address (op0, new_op0, GET_MODE (x)))\n \t    return true;\n \n@@ -374,8 +374,8 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n \t  /* The only simplification we do attempts to remove references to op0\n \t     or make it constant -- in both cases, op0's invalidity will not\n \t     make the result invalid.  */\n-\t  propagate_rtx_1 (&op0, old, new, flags | PR_CAN_APPEAR);\n-\t  valid_ops &= propagate_rtx_1 (&op1, old, new, flags);\n+\t  propagate_rtx_1 (&op0, old_rtx, new_rtx, flags | PR_CAN_APPEAR);\n+\t  valid_ops &= propagate_rtx_1 (&op1, old_rtx, new_rtx, flags);\n           if (op0 == XEXP (x, 0) && op1 == XEXP (x, 1))\n \t    return true;\n \n@@ -393,9 +393,9 @@ propagate_rtx_1 (rtx *px, rtx old, rtx new, int flags)\n \n       else if (code == REG)\n \t{\n-\t  if (rtx_equal_p (x, old))\n+\t  if (rtx_equal_p (x, old_rtx))\n \t    {\n-              *px = new;\n+              *px = new_rtx;\n               return can_appear;\n \t    }\n \t}\n@@ -438,23 +438,23 @@ varying_mem_p (rtx *body, void *data ATTRIBUTE_UNUSED)\n    Otherwise, we accept simplifications that have a lower or equal cost.  */\n \n static rtx\n-propagate_rtx (rtx x, enum machine_mode mode, rtx old, rtx new)\n+propagate_rtx (rtx x, enum machine_mode mode, rtx old_rtx, rtx new_rtx)\n {\n   rtx tem;\n   bool collapsed;\n   int flags;\n \n-  if (REG_P (new) && REGNO (new) < FIRST_PSEUDO_REGISTER)\n+  if (REG_P (new_rtx) && REGNO (new_rtx) < FIRST_PSEUDO_REGISTER)\n     return NULL_RTX;\n \n   flags = 0;\n-  if (REG_P (new) || CONSTANT_P (new))\n+  if (REG_P (new_rtx) || CONSTANT_P (new_rtx))\n     flags |= PR_CAN_APPEAR;\n-  if (!for_each_rtx (&new, varying_mem_p, NULL))\n+  if (!for_each_rtx (&new_rtx, varying_mem_p, NULL))\n     flags |= PR_HANDLE_MEM;\n \n   tem = x;\n-  collapsed = propagate_rtx_1 (&tem, old, copy_rtx (new), flags);\n+  collapsed = propagate_rtx_1 (&tem, old_rtx, copy_rtx (new_rtx), flags);\n   if (tem == x || !collapsed)\n     return NULL_RTX;\n \n@@ -717,7 +717,7 @@ update_df (rtx insn, rtx *loc, struct df_ref **use_rec, enum df_ref_type type,\n    performed.  */\n \n static bool\n-try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_reg_equal)\n+try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new_rtx, rtx def_insn, bool set_reg_equal)\n {\n   rtx insn = DF_REF_INSN (use);\n   enum df_ref_type type = DF_REF_TYPE (use);\n@@ -731,11 +731,11 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n       fprintf (dump_file, \"\\nIn insn %d, replacing\\n \", INSN_UID (insn));\n       print_inline_rtx (dump_file, *loc, 2);\n       fprintf (dump_file, \"\\n with \");\n-      print_inline_rtx (dump_file, new, 2);\n+      print_inline_rtx (dump_file, new_rtx, 2);\n       fprintf (dump_file, \"\\n\");\n     }\n \n-  validate_unshare_change (insn, loc, new, true);\n+  validate_unshare_change (insn, loc, new_rtx, true);\n   if (!verify_changes (0))\n     {\n       if (dump_file)\n@@ -766,7 +766,7 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n       num_changes++;\n \n       df_ref_remove (use);\n-      if (!CONSTANT_P (new))\n+      if (!CONSTANT_P (new_rtx))\n \t{\n \t  struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n \t  update_df (insn, loc, DF_INSN_INFO_USES (insn_info), type, flags);\n@@ -784,11 +784,11 @@ try_fwprop_subst (struct df_ref *use, rtx *loc, rtx new, rtx def_insn, bool set_\n \t  if (dump_file)\n \t    fprintf (dump_file, \" Setting REG_EQUAL note\\n\");\n \n-\t  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (new));\n+\t  set_unique_reg_note (insn, REG_EQUAL, copy_rtx (new_rtx));\n \n \t  /* ??? Is this still necessary if we add the note through\n \t     set_unique_reg_note?  */\n-          if (!CONSTANT_P (new))\n+          if (!CONSTANT_P (new_rtx))\n \t    {\n \t      struct df_insn_info *insn_info = DF_INSN_INFO_GET (def_insn);\n \t      update_df (insn, loc, DF_INSN_INFO_USES (insn_info),\n@@ -845,7 +845,7 @@ forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n {\n   rtx use_insn = DF_REF_INSN (use);\n   rtx use_set = single_set (use_insn);\n-  rtx src, reg, new, *loc;\n+  rtx src, reg, new_rtx, *loc;\n   bool set_reg_equal;\n   enum machine_mode mode;\n \n@@ -888,10 +888,10 @@ forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n       if (x != src)\n \t{\n           rtx note = find_reg_note (use_insn, REG_EQUAL, NULL_RTX);\n-\t  rtx old = note ? XEXP (note, 0) : SET_SRC (use_set);\n-\t  rtx new = simplify_replace_rtx (old, src, x);\n-\t  if (old != new)\n-            set_unique_reg_note (use_insn, REG_EQUAL, copy_rtx (new));\n+\t  rtx old_rtx = note ? XEXP (note, 0) : SET_SRC (use_set);\n+\t  rtx new_rtx = simplify_replace_rtx (old_rtx, src, x);\n+\t  if (old_rtx != new_rtx)\n+            set_unique_reg_note (use_insn, REG_EQUAL, copy_rtx (new_rtx));\n \t}\n       return false;\n     }\n@@ -923,12 +923,12 @@ forward_propagate_and_simplify (struct df_ref *use, rtx def_insn, rtx def_set)\n   else\n     mode = GET_MODE (*loc);\n \n-  new = propagate_rtx (*loc, mode, reg, src);\n+  new_rtx = propagate_rtx (*loc, mode, reg, src);\n \n-  if (!new)\n+  if (!new_rtx)\n     return false;\n \n-  return try_fwprop_subst (use, loc, new, def_insn, set_reg_equal);\n+  return try_fwprop_subst (use, loc, new_rtx, def_insn, set_reg_equal);\n }\n \n "}, {"sha": "008544f0f64dda4eb84ab02e3595b42cab682306", "filename": "gcc/gcse.c", "status": "modified", "additions": 26, "deletions": 26, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -2791,7 +2791,7 @@ find_avail_set (int regno, rtx insn)\n static int\n cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n {\n-  rtx new, set_src, note_src;\n+  rtx new_rtx, set_src, note_src;\n   rtx set = pc_set (jump);\n   rtx note = find_reg_equal_equiv_note (jump);\n \n@@ -2823,22 +2823,22 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n   else\n     setcc = NULL_RTX;\n \n-  new = simplify_replace_rtx (set_src, from, src);\n+  new_rtx = simplify_replace_rtx (set_src, from, src);\n \n   /* If no simplification can be made, then try the next register.  */\n-  if (rtx_equal_p (new, SET_SRC (set)))\n+  if (rtx_equal_p (new_rtx, SET_SRC (set)))\n     return 0;\n \n   /* If this is now a no-op delete it, otherwise this must be a valid insn.  */\n-  if (new == pc_rtx)\n+  if (new_rtx == pc_rtx)\n     delete_insn (jump);\n   else\n     {\n       /* Ensure the value computed inside the jump insn to be equivalent\n          to one computed by setcc.  */\n-      if (setcc && modified_in_p (new, setcc))\n+      if (setcc && modified_in_p (new_rtx, setcc))\n \treturn 0;\n-      if (! validate_unshare_change (jump, &SET_SRC (set), new, 0))\n+      if (! validate_unshare_change (jump, &SET_SRC (set), new_rtx, 0))\n \t{\n \t  /* When (some) constants are not valid in a comparison, and there\n \t     are two registers to be replaced by constants before the entire\n@@ -2849,8 +2849,8 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n \t     we need to attach a note to the branch itself to make this\n \t     optimization work.  */\n \n-\t  if (!rtx_equal_p (new, note_src))\n-\t    set_unique_reg_note (jump, REG_EQUAL, copy_rtx (new));\n+\t  if (!rtx_equal_p (new_rtx, note_src))\n+\t    set_unique_reg_note (jump, REG_EQUAL, copy_rtx (new_rtx));\n \t  return 0;\n \t}\n \n@@ -2881,7 +2881,7 @@ cprop_jump (basic_block bb, rtx setcc, rtx jump, rtx from, rtx src)\n   /* If a conditional jump has been changed into unconditional jump, remove\n      the jump and make the edge fallthru - this is always called in\n      cfglayout mode.  */\n-  if (new != pc_rtx && simplejump_p (jump))\n+  if (new_rtx != pc_rtx && simplejump_p (jump))\n     {\n       edge e;\n       edge_iterator ei;\n@@ -3306,7 +3306,7 @@ find_implicit_sets (void)\n {\n   basic_block bb, dest;\n   unsigned int count;\n-  rtx cond, new;\n+  rtx cond, new_rtx;\n \n   count = 0;\n   FOR_EACH_BB (bb)\n@@ -3327,9 +3327,9 @@ find_implicit_sets (void)\n \t    if (dest && single_pred_p (dest)\n \t\t&& dest != EXIT_BLOCK_PTR)\n \t      {\n-\t\tnew = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n+\t\tnew_rtx = gen_rtx_SET (VOIDmode, XEXP (cond, 0),\n \t\t\t\t\t     XEXP (cond, 1));\n-\t\timplicit_sets[dest->index] = new;\n+\t\timplicit_sets[dest->index] = new_rtx;\n \t\tif (dump_file)\n \t\t  {\n \t\t    fprintf(dump_file, \"Implicit set of reg %d in \",\n@@ -3539,7 +3539,7 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t  unsigned int regno = REGNO (reg_used->reg_rtx);\n \t  basic_block dest, old_dest;\n \t  struct expr *set;\n-\t  rtx src, new;\n+\t  rtx src, new_rtx;\n \n \t  if (regno >= max_gcse_regno)\n \t    continue;\n@@ -3560,22 +3560,22 @@ bypass_block (basic_block bb, rtx setcc, rtx jump)\n \t\t\t\t\t  SET_DEST (PATTERN (setcc)),\n \t\t\t\t\t  SET_SRC (PATTERN (setcc)));\n \n-\t  new = simplify_replace_rtx (src, reg_used->reg_rtx,\n+\t  new_rtx = simplify_replace_rtx (src, reg_used->reg_rtx,\n \t\t\t\t      SET_SRC (set->expr));\n \n \t  /* Jump bypassing may have already placed instructions on\n \t     edges of the CFG.  We can't bypass an outgoing edge that\n \t     has instructions associated with it, as these insns won't\n \t     get executed if the incoming edge is redirected.  */\n \n-\t  if (new == pc_rtx)\n+\t  if (new_rtx == pc_rtx)\n \t    {\n \t      edest = FALLTHRU_EDGE (bb);\n \t      dest = edest->insns.r ? NULL : edest->dest;\n \t    }\n-\t  else if (GET_CODE (new) == LABEL_REF)\n+\t  else if (GET_CODE (new_rtx) == LABEL_REF)\n \t    {\n-\t      dest = BLOCK_FOR_INSN (XEXP (new, 0));\n+\t      dest = BLOCK_FOR_INSN (XEXP (new_rtx, 0));\n \t      /* Don't bypass edges containing instructions.  */\n \t      edest = find_edge (bb, dest);\n \t      if (edest && edest->insns.r)\n@@ -4336,28 +4336,28 @@ pre_insert_copies (void)\n static rtx\n gcse_emit_move_after (rtx src, rtx dest, rtx insn)\n {\n-  rtx new;\n+  rtx new_rtx;\n   rtx set = single_set (insn), set2;\n   rtx note;\n   rtx eqv;\n \n   /* This should never fail since we're creating a reg->reg copy\n      we've verified to be valid.  */\n \n-  new = emit_insn_after (gen_move_insn (dest, src), insn);\n+  new_rtx = emit_insn_after (gen_move_insn (dest, src), insn);\n \n   /* Note the equivalence for local CSE pass.  */\n-  set2 = single_set (new);\n+  set2 = single_set (new_rtx);\n   if (!set2 || !rtx_equal_p (SET_DEST (set2), dest))\n-    return new;\n+    return new_rtx;\n   if ((note = find_reg_equal_equiv_note (insn)))\n     eqv = XEXP (note, 0);\n   else\n     eqv = SET_SRC (set);\n \n-  set_unique_reg_note (new, REG_EQUAL, copy_insn_1 (eqv));\n+  set_unique_reg_note (new_rtx, REG_EQUAL, copy_insn_1 (eqv));\n \n-  return new;\n+  return new_rtx;\n }\n \n /* Delete redundant computations.\n@@ -5384,7 +5384,7 @@ update_ld_motion_stores (struct expr * expr)\n \t  rtx pat = PATTERN (insn);\n \t  rtx src = SET_SRC (pat);\n \t  rtx reg = expr->reaching_reg;\n-\t  rtx copy, new;\n+\t  rtx copy, new_rtx;\n \n \t  /* If we've already copied it, continue.  */\n \t  if (expr->reaching_reg == src)\n@@ -5400,8 +5400,8 @@ update_ld_motion_stores (struct expr * expr)\n \t    }\n \n \t  copy = gen_move_insn ( reg, copy_rtx (SET_SRC (pat)));\n-\t  new = emit_insn_before (copy, insn);\n-\t  record_one_set (REGNO (reg), new);\n+\t  new_rtx = emit_insn_before (copy, insn);\n+\t  record_one_set (REGNO (reg), new_rtx);\n \t  SET_SRC (pat) = reg;\n \t  df_insn_rescan (insn);\n "}, {"sha": "c5c2cfc5621e46fcce7d8d4df0c47d24bd738ff4", "filename": "gcc/lcm.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -350,13 +350,13 @@ compute_laterin (struct edge_list *edge_list, sbitmap *earliest,\n static void\n compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n \t\t       sbitmap *later, sbitmap *laterin, sbitmap *insert,\n-\t\t       sbitmap *delete)\n+\t\t       sbitmap *del)\n {\n   int x;\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    sbitmap_difference (delete[bb->index], antloc[bb->index],\n+    sbitmap_difference (del[bb->index], antloc[bb->index],\n \t\t\tlaterin[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n@@ -377,7 +377,7 @@ compute_insert_delete (struct edge_list *edge_list, sbitmap *antloc,\n struct edge_list *\n pre_edge_lcm (int n_exprs, sbitmap *transp,\n \t      sbitmap *avloc, sbitmap *antloc, sbitmap *kill,\n-\t      sbitmap **insert, sbitmap **delete)\n+\t      sbitmap **insert, sbitmap **del)\n {\n   sbitmap *antin, *antout, *earliest;\n   sbitmap *avin, *avout;\n@@ -450,8 +450,8 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n   sbitmap_vector_free (earliest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *delete = sbitmap_vector_alloc (last_basic_block, n_exprs);\n-  compute_insert_delete (edge_list, antloc, later, laterin, *insert, *delete);\n+  *del = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  compute_insert_delete (edge_list, antloc, later, laterin, *insert, *del);\n \n   sbitmap_vector_free (laterin);\n   sbitmap_vector_free (later);\n@@ -460,7 +460,7 @@ pre_edge_lcm (int n_exprs, sbitmap *transp,\n   if (dump_file)\n     {\n       dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *delete,\n+      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n \t\t\t   last_basic_block);\n     }\n #endif\n@@ -684,13 +684,13 @@ compute_nearerout (struct edge_list *edge_list, sbitmap *farthest,\n static void\n compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n \t\t\t   sbitmap *nearer, sbitmap *nearerout,\n-\t\t\t   sbitmap *insert, sbitmap *delete)\n+\t\t\t   sbitmap *insert, sbitmap *del)\n {\n   int x;\n   basic_block bb;\n \n   FOR_EACH_BB (bb)\n-    sbitmap_difference (delete[bb->index], st_avloc[bb->index],\n+    sbitmap_difference (del[bb->index], st_avloc[bb->index],\n \t\t\tnearerout[bb->index]);\n \n   for (x = 0; x < NUM_EDGES (edge_list); x++)\n@@ -711,7 +711,7 @@ compute_rev_insert_delete (struct edge_list *edge_list, sbitmap *st_avloc,\n struct edge_list *\n pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n \t\t  sbitmap *st_avloc, sbitmap *st_antloc, sbitmap *kill,\n-\t\t  sbitmap **insert, sbitmap **delete)\n+\t\t  sbitmap **insert, sbitmap **del)\n {\n   sbitmap *st_antin, *st_antout;\n   sbitmap *st_avout, *st_avin, *farthest;\n@@ -790,9 +790,9 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n   sbitmap_vector_free (farthest);\n \n   *insert = sbitmap_vector_alloc (num_edges, n_exprs);\n-  *delete = sbitmap_vector_alloc (last_basic_block, n_exprs);\n+  *del = sbitmap_vector_alloc (last_basic_block, n_exprs);\n   compute_rev_insert_delete (edge_list, st_avloc, nearer, nearerout,\n-\t\t\t     *insert, *delete);\n+\t\t\t     *insert, *del);\n \n   sbitmap_vector_free (nearerout);\n   sbitmap_vector_free (nearer);\n@@ -801,7 +801,7 @@ pre_edge_rev_lcm (int n_exprs, sbitmap *transp,\n   if (dump_file)\n     {\n       dump_sbitmap_vector (dump_file, \"pre_insert_map\", \"\", *insert, num_edges);\n-      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *delete,\n+      dump_sbitmap_vector (dump_file, \"pre_delete_map\", \"\", *del,\n \t\t\t   last_basic_block);\n     }\n #endif"}, {"sha": "fd3b7fe971f692a37dadbe8927096e8295125e76", "filename": "gcc/lower-subreg.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Flower-subreg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Flower-subreg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flower-subreg.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -577,22 +577,22 @@ resolve_reg_notes (rtx insn)\n   pnote = &REG_NOTES (insn);\n   while (*pnote != NULL_RTX)\n     {\n-      bool delete = false;\n+      bool del = false;\n \n       note = *pnote;\n       switch (REG_NOTE_KIND (note))\n \t{\n \tcase REG_DEAD:\n \tcase REG_UNUSED:\n \t  if (resolve_reg_p (XEXP (note, 0)))\n-\t    delete = true;\n+\t    del = true;\n \t  break;\n \n \tdefault:\n \t  break;\n \t}\n \n-      if (delete)\n+      if (del)\n \t*pnote = XEXP (note, 1);\n       else\n \tpnote = &XEXP (note, 1);"}, {"sha": "e6fd61d4fda8218df63bf675c667a777137b6e29", "filename": "gcc/mode-switching.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fmode-switching.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/60564289186303fb1368800ed9dd466668300e8f/gcc%2Fmode-switching.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmode-switching.c?ref=60564289186303fb1368800ed9dd466668300e8f", "patch": "@@ -585,7 +585,7 @@ optimize_mode_switching (void)\n   for (i = 0; i < max_num_modes; i++)\n     {\n       int current_mode[N_ENTITIES];\n-      sbitmap *delete;\n+      sbitmap *del;\n       sbitmap *insert;\n \n       /* Set the anticipatable and computing arrays.  */\n@@ -612,7 +612,7 @@ optimize_mode_switching (void)\n       FOR_EACH_BB (bb)\n \tsbitmap_not (kill[bb->index], transp[bb->index]);\n       edge_list = pre_edge_lcm (n_entities, transp, comp, antic,\n-\t\t\t\tkill, &insert, &delete);\n+\t\t\t\tkill, &insert, &del);\n \n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n@@ -663,15 +663,15 @@ optimize_mode_switching (void)\n \t    }\n \n \t  FOR_EACH_BB_REVERSE (bb)\n-\t    if (TEST_BIT (delete[bb->index], j))\n+\t    if (TEST_BIT (del[bb->index], j))\n \t      {\n \t\tmake_preds_opaque (bb, j);\n \t\t/* Cancel the 'deleted' mode set.  */\n \t\tbb_info[j][bb->index].seginfo->mode = no_mode;\n \t      }\n \t}\n \n-      sbitmap_vector_free (delete);\n+      sbitmap_vector_free (del);\n       sbitmap_vector_free (insert);\n       clear_aux_for_edges ();\n       free_edge_list (edge_list);"}]}