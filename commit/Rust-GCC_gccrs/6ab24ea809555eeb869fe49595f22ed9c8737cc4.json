{"sha": "6ab24ea809555eeb869fe49595f22ed9c8737cc4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFiMjRlYTgwOTU1NWVlYjg2OWZlNDk1OTVmMjJlZDljODczN2NjNA==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2018-09-14T03:34:19Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2018-09-14T03:34:19Z"}, "message": "builtins.h (c_srlen): Add argument.\n\n\t* builtins.h (c_srlen): Add argument.\n\t* builtins.c (warn_string_no_nul): New function.\n\t(c_strlen): Add argument and use it.  Update recursive calls.\n\tPass DECL argument to string_constant to get info on non\n\tterminated strings.  Update *NONSTR as needed.\n\t(fold_builtin_strlen): Add argument to calls to c_strlen.\n\tWarn for unterminated arrays.\n\t(warn_string_no_null): Add prototype.\n\t* expr.c (string_constant): Update arguments.  Update recursive\n\tcalls appropriately.  Detect missing NUL terminator and outermost\n\tdeclaration its missing in.\n\tImprove checks for arrays with nonzero lower bound or elements\n\tthat are not a single byte.  Simplify offset computation.\n\tSimplify checks for non-NUL terminated strings.\n\t* gimple-fold.c (get_range_strlen): Add argument to c_strlen call.\n\t* gimple-ssa-sprintf.c (get_string_length): Remove unnecessary code.\n\n\t* gcc.dg/warn-strlen-no-nul.c: New test.\n\nCo-Authored-By: Bernd Edlinger <bernd.edlinger@hotmail.de>\nCo-Authored-By: Jeff Law <law@redhat.com>\n\nFrom-SVN: r264302", "tree": {"sha": "a6a98bb3c25e71934a2ae133c6e5116dcb9349b9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a6a98bb3c25e71934a2ae133c6e5116dcb9349b9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ab24ea809555eeb869fe49595f22ed9c8737cc4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab24ea809555eeb869fe49595f22ed9c8737cc4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ab24ea809555eeb869fe49595f22ed9c8737cc4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ab24ea809555eeb869fe49595f22ed9c8737cc4/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "d01b568a78351beb6b693b613e6b48bcb2475eae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d01b568a78351beb6b693b613e6b48bcb2475eae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d01b568a78351beb6b693b613e6b48bcb2475eae"}], "stats": {"total": 471, "additions": 409, "deletions": 62}, "files": [{"sha": "4ef577f82f16d404a4642c7c0bcf984b3fdbc450", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -1,3 +1,23 @@\n+2018-09-13  Martin Sebor  <msebor@redhat.com>\n+\t    Bernd Edlinger  <bernd.edlinger@hotmail.de>\n+\n+\t* builtins.h (c_srlen): Add argument.\n+\t* builtins.c (warn_string_no_nul): New function.\n+\t(c_strlen): Add argument and use it.  Update recursive calls.\n+\tPass DECL argument to string_constant to get info on non\n+\tterminated strings.  Update *NONSTR as needed.\n+\t(fold_builtin_strlen): Add argument to calls to c_strlen.\n+\tWarn for unterminated arrays.\n+\t(warn_string_no_null): Add prototype.\n+\t* expr.c (string_constant): Update arguments.  Update recursive\n+\tcalls appropriately.  Detect missing NUL terminator and outermost\n+\tdeclaration its missing in.\n+\tImprove checks for arrays with nonzero lower bound or elements\n+\tthat are not a single byte.  Simplify offset computation.\n+\tSimplify checks for non-NUL terminated strings.\n+\t* gimple-fold.c (get_range_strlen): Add argument to c_strlen call.\n+\t* gimple-ssa-sprintf.c (get_string_length): Remove unnecessary code.\n+\n 2018-09-13  Bernd Edlinger  <bernd.edlinger@hotmail.de>\n \n \t* builtins.c (c_strlen): Handle not zero terminated STRING_CSTs"}, {"sha": "a345704a8f8e5aceea106a1649db4bc8f620eba4", "filename": "gcc/builtins.c", "status": "modified", "additions": 58, "deletions": 8, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -542,6 +542,27 @@ string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n   return n;\n }\n \n+/* For a call at LOC to a function FN that expects a string in the argument\n+   ARG, issue a diagnostic due to it being a called with an argument\n+   declared at NONSTR that is a character array with no terminating NUL.  */\n+\n+void\n+warn_string_no_nul (location_t loc, const char *fn, tree arg, tree decl)\n+{\n+  if (TREE_NO_WARNING (arg))\n+    return;\n+\n+  loc = expansion_point_location_if_in_system_header (loc);\n+\n+  if (warning_at (loc, OPT_Wstringop_overflow_,\n+\t\t  \"%qs argument missing terminating nul\", fn))\n+    {\n+      inform (DECL_SOURCE_LOCATION (decl),\n+\t      \"referenced argument declared here\");\n+      TREE_NO_WARNING (arg) = 1;\n+    }\n+}\n+\n /* Compute the length of a null-terminated character string or wide\n    character string handling character sizes of 1, 2, and 4 bytes.\n    TREE_STRING_LENGTH is not the right way because it evaluates to\n@@ -559,13 +580,18 @@ string_length (const void *ptr, unsigned eltsize, unsigned maxelts)\n    accesses.  Note that this implies the result is not going to be emitted\n    into the instruction stream.\n \n+   If a not zero-terminated string value is encountered and NONSTR is\n+   non-zero, the declaration of the string value is assigned to *NONSTR.\n+   *NONSTR is accumulating, thus not cleared on success, therefore it has\n+   to be initialized to NULL_TREE by the caller.\n+\n    ELTSIZE is 1 for normal single byte character strings, and 2 or\n    4 for wide characer strings.  ELTSIZE is by default 1.\n \n    The value returned is of type `ssizetype'.  */\n \n tree\n-c_strlen (tree src, int only_value, unsigned eltsize)\n+c_strlen (tree src, int only_value, tree *nonstr, unsigned eltsize)\n {\n   gcc_checking_assert (eltsize == 1 || eltsize == 2 || eltsize == 4);\n   STRIP_NOPS (src);\n@@ -574,22 +600,23 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n     {\n       tree len1, len2;\n \n-      len1 = c_strlen (TREE_OPERAND (src, 1), only_value, eltsize);\n-      len2 = c_strlen (TREE_OPERAND (src, 2), only_value, eltsize);\n+      len1 = c_strlen (TREE_OPERAND (src, 1), only_value, nonstr, eltsize);\n+      len2 = c_strlen (TREE_OPERAND (src, 2), only_value, nonstr, eltsize);\n       if (tree_int_cst_equal (len1, len2))\n \treturn len1;\n     }\n \n   if (TREE_CODE (src) == COMPOUND_EXPR\n       && (only_value || !TREE_SIDE_EFFECTS (TREE_OPERAND (src, 0))))\n-    return c_strlen (TREE_OPERAND (src, 1), only_value, eltsize);\n+    return c_strlen (TREE_OPERAND (src, 1), only_value, nonstr, eltsize);\n \n   location_t loc = EXPR_LOC_OR_LOC (src, input_location);\n \n   /* Offset from the beginning of the string in bytes.  */\n   tree byteoff;\n   tree memsize;\n-  src = string_constant (src, &byteoff, &memsize, NULL);\n+  tree decl;\n+  src = string_constant (src, &byteoff, &memsize, &decl);\n   if (src == 0)\n     return NULL_TREE;\n \n@@ -628,8 +655,14 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n       unsigned len = string_length (ptr, eltsize, strelts);\n \n       /* Return when an embedded null character is found or none at all.  */\n-      if (len + 1 < strelts || len >= maxelts)\n+      if (len + 1 < strelts)\n \treturn NULL_TREE;\n+      else if (len >= maxelts)\n+\t{\n+\t  if (nonstr && decl)\n+\t    *nonstr = decl;\n+\t  return NULL_TREE;\n+\t}\n \n       /* For empty strings the result should be zero.  */\n       if (len == 0)\n@@ -694,7 +727,11 @@ c_strlen (tree src, int only_value, unsigned eltsize)\n   /* Don't know what to return if there was no zero termination.\n      Ideally this would turn into a gcc_checking_assert over time.  */\n   if (len >= maxelts - eltoff)\n-    return NULL_TREE;\n+    {\n+      if (nonstr && decl)\n+\t*nonstr = decl;\n+      return NULL_TREE;\n+    }\n \n   return ssize_int (len);\n }\n@@ -8373,11 +8410,24 @@ fold_builtin_strlen (location_t loc, tree type, tree arg)\n     return NULL_TREE;\n   else\n     {\n-      tree len = c_strlen (arg, 0);\n+      tree nonstr = NULL_TREE;\n+      tree len = c_strlen (arg, 0, &nonstr);\n \n       if (len)\n \treturn fold_convert_loc (loc, type, len);\n \n+      if (!nonstr)\n+\tc_strlen (arg, 1, &nonstr); /* TODO: add test coverage here.  */\n+\n+      if (nonstr)\n+\t{\n+\t  if (EXPR_HAS_LOCATION (arg))\n+\t    loc = EXPR_LOCATION (arg);\n+\t  else if (loc == UNKNOWN_LOCATION)\n+\t    loc = input_location;\n+\t  warn_string_no_nul (loc, \"strlen\", arg, nonstr);\n+\t}\n+\n       return NULL_TREE;\n     }\n }"}, {"sha": "7790c85a508ed2b0599680b9aa64a06d720304f7", "filename": "gcc/builtins.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fbuiltins.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fbuiltins.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.h?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -57,7 +57,7 @@ extern bool get_pointer_alignment_1 (tree, unsigned int *,\n \t\t\t\t     unsigned HOST_WIDE_INT *);\n extern unsigned int get_pointer_alignment (tree);\n extern unsigned string_length (const void*, unsigned, unsigned);\n-extern tree c_strlen (tree, int, unsigned = 1);\n+extern tree c_strlen (tree, int, tree * = NULL, unsigned = 1);\n extern void expand_builtin_setjmp_setup (rtx, rtx);\n extern void expand_builtin_setjmp_receiver (rtx);\n extern void expand_builtin_update_setjmp_buf (rtx);\n@@ -103,6 +103,7 @@ extern bool target_char_cst_p (tree t, char *p);\n extern internal_fn associated_internal_fn (tree);\n extern internal_fn replacement_internal_fn (gcall *);\n \n+extern void warn_string_no_nul (location_t, const char *, tree, tree);\n extern tree max_object_size ();\n \n #endif /* GCC_BUILTINS_H */"}, {"sha": "67aa0520e4432a5d05a14a820b1e7b91ace03157", "filename": "gcc/expr.c", "status": "modified", "additions": 15, "deletions": 32, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -11303,16 +11303,11 @@ is_aligning_offset (const_tree offset, const_tree exp)\n /* Return the tree node if an ARG corresponds to a string constant or zero\n    if it doesn't.  If we return nonzero, set *PTR_OFFSET to the (possibly\n    non-constant) offset in bytes within the string that ARG is accessing.\n-   If NONSTR is non-null, consider valid even sequences of characters that\n-   aren't nul-terminated strings.  In that case, if ARG refers to such\n-   a sequence set *NONSTR to its declaration and clear it otherwise.\n-   The type of the offset is sizetype.  If MEM_SIZE is non-zero the storage\n-   size of the memory is returned.  The returned STRING_CST object is\n-   valid up to TREE_STRING_LENGTH.  Bytes between TREE_STRING_LENGTH\n-   and MEM_SIZE are zero.  MEM_SIZE is at least TREE_STRING_LENGTH.  */\n+   If MEM_SIZE is non-zero the storage size of the memory is returned.\n+   If DECL is non-zero the constant declaration is returned if available.  */\n \n tree\n-string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n+string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *decl)\n {\n   tree array;\n   STRIP_NOPS (arg);\n@@ -11341,6 +11336,12 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n \n \t      if (TREE_CODE (TREE_TYPE (arg)) == ARRAY_TYPE)\n \t\treturn NULL_TREE;\n+\n+\t      if (!integer_zerop (array_ref_low_bound (arg)))\n+\t\treturn NULL_TREE;\n+\n+\t      if (!integer_onep (array_ref_element_size (arg)))\n+\t\treturn NULL_TREE;\n \t    }\n \t}\n       array = get_addr_base_and_unit_offset (ref, &base_off);\n@@ -11366,7 +11367,7 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n \treturn NULL_TREE;\n \n       tree offset;\n-      if (tree str = string_constant (arg0, &offset, mem_size, nonstr))\n+      if (tree str = string_constant (arg0, &offset, mem_size, decl))\n \t{\n \t  /* Avoid pointers to arrays (see bug 86622).  */\n \t  if (POINTER_TYPE_P (TREE_TYPE (arg))\n@@ -11396,21 +11397,16 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n       if (TREE_CODE (chartype) != INTEGER_TYPE)\n \treturn NULL;\n \n-      tree charsize = array_ref_element_size (arg);\n-      /* Set the non-constant offset to the non-constant index scaled\n-\t by the size of the character type.  */\n-      offset = fold_build2 (MULT_EXPR, TREE_TYPE (offset),\n-\t\t\t    fold_convert (sizetype, varidx), charsize);\n+      offset = fold_convert (sizetype, varidx);\n     }\n \n   if (TREE_CODE (array) == STRING_CST)\n     {\n       *ptr_offset = fold_convert (sizetype, offset);\n       if (mem_size)\n \t*mem_size = TYPE_SIZE_UNIT (TREE_TYPE (array));\n-      /* This is not strictly correct.  FIXME in follow-up patch.  */\n-      if (nonstr)\n-\t*nonstr = NULL_TREE;\n+      if (decl)\n+\t*decl = NULL_TREE;\n       gcc_checking_assert (tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (array)))\n \t\t\t   >= TREE_STRING_LENGTH (array));\n       return array;\n@@ -11455,23 +11451,10 @@ string_constant (tree arg, tree *ptr_offset, tree *mem_size, tree *nonstr)\n   if (!init || TREE_CODE (init) != STRING_CST)\n     return NULL_TREE;\n \n-  /* Compute the lower bound number of elements (not bytes) in the array\n-     that the string is used to initialize.  The actual size of the array\n-     may be greater if the string is shorter, but the the important\n-     data point is whether the literal, inlcuding the terminating nul,\n-     fits the array.  */\n-  unsigned HOST_WIDE_INT charsize\n-    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (TREE_TYPE (init))));\n-  unsigned HOST_WIDE_INT array_elts\n-    = tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (init))) / charsize;\n-\n-  /* Compute the string length in (wide) characters.  */\n-  unsigned HOST_WIDE_INT length = TREE_STRING_LENGTH (init);\n-\n   if (mem_size)\n     *mem_size = TYPE_SIZE_UNIT (TREE_TYPE (init));\n-  if (nonstr)\n-    *nonstr = array_elts > length ? NULL_TREE : array;\n+  if (decl)\n+    *decl = array;\n \n   gcc_checking_assert (tree_to_shwi (TYPE_SIZE_UNIT (TREE_TYPE (init)))\n \t\t       >= TREE_STRING_LENGTH (init));"}, {"sha": "6b4b6a423ca41e8901bb03a8945a88130aa38345", "filename": "gcc/fold-const.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -14595,6 +14595,10 @@ c_getstr (tree src, unsigned HOST_WIDE_INT *strlen /* = NULL */)\n   unsigned HOST_WIDE_INT string_length = TREE_STRING_LENGTH (src);\n   unsigned HOST_WIDE_INT string_size = tree_to_uhwi (mem_size);\n \n+  /* Ideally this would turn into a gcc_checking_assert over time.  */\n+  if (string_length > string_size)\n+    string_length = string_size;\n+\n   const char *string = TREE_STRING_POINTER (src);\n \n   /* Ideally this would turn into a gcc_checking_assert over time.  */"}, {"sha": "36a85c7eb7fb86ea174d74fa9926c06701f69311", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -1335,7 +1335,7 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t    return false;\n \t}\n       else\n-\tval = c_strlen (arg, 1, eltsize);\n+\tval = c_strlen (arg, 1, NULL, eltsize);\n \n       if (!val && fuzzy)\n \t{"}, {"sha": "9f3eebc6dbad6ff4be9191d547429a18f6cf39fd", "filename": "gcc/gimple-ssa-sprintf.c", "status": "modified", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fgimple-ssa-sprintf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Fgimple-ssa-sprintf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-sprintf.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -1999,13 +1999,6 @@ get_string_length (tree str, unsigned eltsize)\n   if (!str)\n     return fmtresult ();\n \n-  if (tree slen = c_strlen (str, 1, eltsize))\n-    {\n-      /* Simply return the length of the string.  */\n-      fmtresult res (tree_to_shwi (slen));\n-      return res;\n-    }\n-\n   /* Determine the length of the shortest and longest string referenced\n      by STR.  Strings of unknown lengths are bounded by the sizes of\n      arrays that subexpressions of STR may refer to.  Pointers that"}, {"sha": "e455d8986306a33bfa4bb3bb036e88c1727bdf6d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -1,3 +1,8 @@\n+2018-09-13  Martin Sebor  <msebor@redhat.com>\n+\t    Jeff Law  <law@redhat.com>\n+\n+\t* gcc.dg/warn-strlen-no-nul.c: New test.\n+\n 2018-09-13  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/87263"}, {"sha": "d2bc5257d535be871bdd3dd681d39ab7034ea8c6", "filename": "gcc/testsuite/gcc.dg/warn-strlen-no-nul.c", "status": "added", "additions": 301, "deletions": 0, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strlen-no-nul.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strlen-no-nul.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fwarn-strlen-no-nul.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -0,0 +1,301 @@\n+/* PR tree-optimization/86552 - missing warning for reading past the end\n+   of non-string arrays\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -ftrack-macro-expansion=0\" } */\n+\n+extern __SIZE_TYPE__ strlen (const char*);\n+\n+const char a[5] = \"12345\";   /* { dg-message \"declared here\" } */\n+\n+int v0 = 0;\n+int v1 = 1;\n+\n+void sink (int, ...);\n+\n+#define CONCAT(a, b)   a ## b\n+#define CAT(a, b)      CONCAT(a, b)\n+\n+#define T(str)\t\t\t\t\t\t\\\n+  __attribute__ ((noipa))\t\t\t\t\\\n+  void CAT (test_, __LINE__) (void) {\t\t\t\\\n+    int i0 = 0, i1 = i0 + 1, i2 = i1 + 1, i3 = i2 + 1;\t\\\n+    sink (strlen (str), i0, i1, i2, i3);\t\t\\\n+  } typedef void dummy_type\n+\n+T (a);                /* { dg-warning \"argument missing terminating nul\" }  */\n+T (&a[0]);            /* { dg-warning \"nul\" }  */\n+T (&a[0] + 1);        /* { dg-warning \"nul\" }  */\n+T (&a[1]);            /* { dg-warning \"nul\" }  */\n+T (&a[v0]);           /* { dg-warning \"nul\" }  */\n+T (&a[v0] + 1);       /* { dg-warning \"nul\" }  */\n+\n+\n+const char b[][5] = { /* { dg-message \"declared here\" } */\n+  \"12\", \"123\", \"1234\", \"54321\"\n+};\n+\n+T (b[0]);\n+T (b[1]);\n+T (b[2]);\n+T (b[3]);             /* { dg-warning \"nul\" }  */\n+\n+T (b[i0]);\n+T (b[i1]);\n+T (b[i2]);\n+T (b[i3]);            /* { dg-warning \"nul\" }  */\n+\n+T (b[v0]);\n+\n+T (&b[i2][i1]);\n+T (&b[i2][i1] + i1);\n+T (&b[i2][v0]);\n+T (&b[i2][i1] + v0);\n+\n+T (&b[2][1]);\n+T (&b[2][1] + i1);\n+T (&b[2][i0]);\n+T (&b[2][1] + i0);\n+\n+T (&b[2][1]);\n+T (&b[2][1] + v0);\n+T (&b[2][v0]);\n+\n+T (&b[3][1]);           /* { dg-warning \"nul\" }  */\n+T (&b[3][1] + 1);       /* { dg-warning \"nul\" }  */\n+T (&b[3][1] + i1);      /* { dg-warning \"nul\" }  */\n+T (&b[3][v0]);          /* { dg-warning \"nul\" }  */\n+T (&b[3][1] + v0);      /* { dg-warning \"nul\" }  */\n+T (&b[3][v0] + v1);     /* { dg-warning \"nul\" }  */\n+\n+T (&b[i3][i1]);         /* { dg-warning \"nul\" }  */\n+T (&b[i3][i1] + 1);     /* { dg-warning \"nul\" }  */\n+T (&b[i3][i1] + i1);    /* { dg-warning \"nul\" }  */\n+T (&b[i3][v0]);         /* { dg-warning \"nul\" \"pr86919\" { xfail *-*-* } }  */\n+T (&b[i3][i1] + v0);    /* { dg-warning \"nul\" \"pr86919\" { xfail *-*-* } }  */\n+T (&b[i3][v0] + v1);    /* { dg-warning \"nul\" \"pr86919\" { xfail *-*-* } }  */\n+\n+T (v0 ? \"\" : b[0]);\n+T (v0 ? \"\" : b[1]);\n+T (v0 ? \"\" : b[2]);\n+T (v0 ? \"\" : b[3]);               /* { dg-warning \"nul\" }  */\n+T (v0 ? b[0] : \"\");\n+T (v0 ? b[1] : \"\");\n+T (v0 ? b[2] : \"\");\n+T (v0 ? b[3] : \"\");               /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? \"\" : b[i0]);\n+T (v0 ? \"\" : b[i1]);\n+T (v0 ? \"\" : b[i2]);\n+/* The following is diagnosed but the warning location is wrong\n+   (the PRE pass loses it).  */\n+T (v0 ? \"\" : b[i3]);              /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i0] : \"\");\n+T (v0 ? b[i1] : \"\");\n+T (v0 ? b[i2] : \"\");\n+T (v0 ? b[i3] : \"\");              /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? \"1234\" : b[3]);           /* { dg-warning \"nul\" }  */\n+T (v0 ? \"1234\" : b[i3]);          /* { dg-warning \"nul\" }  */\n+T (v0 ? b[3] : \"1234\");           /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i3] : \"1234\");          /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? a : b[3]);                /* { dg-warning \"nul\" }  */\n+T (v0 ? b[0] : b[2]);\n+T (v0 ? b[2] : b[3]);             /* { dg-warning \"nul\" }  */\n+T (v0 ? b[3] : b[2]);             /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? a : b[i3]);               /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i0] : b[i2]);\n+T (v0 ? b[i2] : b[i3]);           /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i3] : b[i2]);           /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? b[0] : &b[3][0] + 1);     /* { dg-warning \"nul\" }  */\n+T (v0 ? b[0] : &b[3][0] + i1);    /* { dg-warning \"nul\" }  */\n+T (v0 ? b[1] : &b[3][1] + v0);    /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? b[i0] : &b[i3][i0] + i1);    /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i0] : &b[i3][i0] + i1);    /* { dg-warning \"nul\" }  */\n+T (v0 ? b[i1] : &b[i3][i1] + v0);    /* { dg-warning \"nul\" }  */\n+\n+/* It's possible to detect the missing nul in the following two\n+   expressions but GCC doesn't do it yet.  */\n+T (v0 ? &b[3][1] + v0 : b[2]);    /* { dg-warning \"nul\" \"bug\" }  */\n+T (v0 ? &b[3][v0] : &b[3][v1]);   /* { dg-warning \"nul\" \"bug\" }  */\n+\n+\n+struct A { char a[5], b[5]; };\n+\n+const struct A s = { \"1234\", \"12345\" };\n+\n+T (s.a);\n+T (&s.a[0]);\n+T (&s.a[0] + 1);\n+T (&s.a[0] + v0);\n+T (&s.a[1]);\n+T (&s.a[1] + 1);\n+T (&s.a[1] + v0);\n+\n+T (&s.a[i0]);\n+T (&s.a[i0] + i1);\n+T (&s.a[i0] + v0);\n+T (&s.a[i1]);\n+T (&s.a[i1] + i1);\n+T (&s.a[i1] + v0);\n+\n+T (s.b);              /* { dg-warning \"nul\" }  */\n+T (&s.b[0]);          /* { dg-warning \"nul\" }  */\n+T (&s.b[0] + 1);      /* { dg-warning \"nul\" }  */\n+T (&s.b[0] + v0);     /* { dg-warning \"nul\" }  */\n+T (&s.b[1]);          /* { dg-warning \"nul\" }  */\n+T (&s.b[1] + 1);      /* { dg-warning \"nul\" }  */\n+T (&s.b[1] + i0);     /* { dg-warning \"nul\" }  */\n+T (&s.b[1] + v0);     /* { dg-warning \"nul\" }  */\n+\n+T (&s.b[i0]);         /* { dg-warning \"nul\" }  */\n+T (&s.b[i0] + i1);    /* { dg-warning \"nul\" }  */\n+T (&s.b[i0] + v0);    /* { dg-warning \"nul\" \"pr86919\" { xfail *-*-* } }  */\n+T (&s.b[i1]);         /* { dg-warning \"nul\" }  */\n+T (&s.b[i1] + i1);    /* { dg-warning \"nul\" }  */\n+T (&s.b[i1] + v0);    /* { dg-warning \"nul\" \"pr86919\" { xfail *-*-* } }  */\n+\n+struct B { struct A a[2]; };\n+\n+const struct B ba[] = {\n+  { { { \"123\", \"12345\" }, { \"12345\", \"123\" } } },\n+  { { { \"12345\", \"123\" }, { \"123\", \"12345\" } } },\n+  { { { \"1\", \"12\" },      { \"123\", \"1234\" } } },\n+  { { { \"123\", \"1234\" },  { \"12345\", \"12\" } } }\n+};\n+\n+T (ba[0].a[0].a);\n+T (&ba[0].a[0].a[0]);\n+T (&ba[0].a[0].a[0] + 1);\n+T (&ba[0].a[0].a[0] + v0);\n+T (&ba[0].a[0].a[1]);\n+T (&ba[0].a[0].a[1] + 1);\n+T (&ba[0].a[0].a[1] + v0);\n+\n+T (ba[0].a[0].b);           /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[0]);       /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[0] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[0] + v0);  /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[1]);       /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[1] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[0].b[1] + v0);  /* { dg-warning \"nul\" }  */\n+\n+T (ba[0].a[1].a);           /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[0]);       /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[0] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[0] + v0);  /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[1]);       /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[1] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[0].a[1].a[1] + v0);  /* { dg-warning \"nul\" }  */\n+\n+T (ba[0].a[1].b);\n+T (&ba[0].a[1].b[0]);\n+T (&ba[0].a[1].b[0] + 1);\n+T (&ba[0].a[1].b[0] + v0);\n+T (&ba[0].a[1].b[1]);\n+T (&ba[0].a[1].b[1] + 1);\n+T (&ba[0].a[1].b[1] + v0);\n+\n+\n+T (ba[1].a[0].a);           /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[0]);       /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[0] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[0] + v0);  /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[1]);       /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[1] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[0].a[1] + v0);  /* { dg-warning \"nul\" }  */\n+\n+T (ba[1].a[0].b);\n+T (&ba[1].a[0].b[0]);\n+T (&ba[1].a[0].b[0] + 1);\n+T (&ba[1].a[0].b[0] + v0);\n+T (&ba[1].a[0].b[1]);\n+T (&ba[1].a[0].b[1] + 1);\n+T (&ba[1].a[0].b[1] + v0);\n+\n+T (ba[1].a[1].a);\n+T (&ba[1].a[1].a[0]);\n+T (&ba[1].a[1].a[0] + 1);\n+T (&ba[1].a[1].a[0] + v0);\n+T (&ba[1].a[1].a[1]);\n+T (&ba[1].a[1].a[1] + 1);\n+T (&ba[1].a[1].a[1] + v0);\n+\n+T (ba[1].a[1].b);           /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[0]);       /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[0] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[0] + v0);  /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[1]);       /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[1] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[1].a[1].b[1] + v0);  /* { dg-warning \"nul\" }  */\n+\n+\n+T (ba[2].a[0].a);\n+T (&ba[2].a[0].a[0]);\n+T (&ba[2].a[0].a[0] + 1);\n+T (&ba[2].a[0].a[0] + v0);\n+T (&ba[2].a[0].a[1]);\n+T (&ba[2].a[0].a[1] + 1);\n+T (&ba[2].a[0].a[1] + v0);\n+\n+T (ba[2].a[0].b);\n+T (&ba[2].a[0].b[0]);\n+T (&ba[2].a[0].b[0] + 1);\n+T (&ba[2].a[0].b[0] + v0);\n+T (&ba[2].a[0].b[1]);\n+T (&ba[2].a[0].b[1] + 1);\n+T (&ba[2].a[0].b[1] + v0);\n+\n+T (ba[2].a[1].a);\n+T (&ba[2].a[1].a[0]);\n+T (&ba[2].a[1].a[0] + 1);\n+T (&ba[2].a[1].a[0] + v0);\n+T (&ba[2].a[1].a[1]);\n+T (&ba[2].a[1].a[1] + 1);\n+T (&ba[2].a[1].a[1] + v0);\n+\n+\n+T (ba[3].a[0].a);\n+T (&ba[3].a[0].a[0]);\n+T (&ba[3].a[0].a[0] + 1);\n+T (&ba[3].a[0].a[0] + v0);\n+T (&ba[3].a[0].a[1]);\n+T (&ba[3].a[0].a[1] + 1);\n+T (&ba[3].a[0].a[1] + v0);\n+\n+T (ba[3].a[0].b);\n+T (&ba[3].a[0].b[0]);\n+T (&ba[3].a[0].b[0] + 1);\n+T (&ba[3].a[0].b[0] + v0);\n+T (&ba[3].a[0].b[1]);\n+T (&ba[3].a[0].b[1] + 1);\n+T (&ba[3].a[0].b[1] + v0);\n+\n+T (ba[3].a[1].a);           /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[0]);\t    /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[0] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[0] + v0);  /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[1]);\t    /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[1] + 1);   /* { dg-warning \"nul\" }  */\n+T (&ba[3].a[1].a[1] + v0);  /* { dg-warning \"nul\" }  */\n+\n+T (ba[3].a[1].b);\n+T (&ba[3].a[1].b[0]);\n+T (&ba[3].a[1].b[0] + 1);\n+T (&ba[3].a[1].b[0] + v0);\n+T (&ba[3].a[1].b[1]);\n+T (&ba[3].a[1].b[1] + 1);\n+T (&ba[3].a[1].b[1] + v0);\n+\n+\n+T (v0 ? ba[0].a[0].a : ba[0].a[0].b);           /* { dg-warning \"nul\" }  */\n+T (v0 ? ba[0].a[0].a : ba[0].a[0].b);           /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? &ba[0].a[0].a[0] : &ba[3].a[1].a[0]);   /* { dg-warning \"nul\" }  */\n+T (v0 ? &ba[3].a[1].a[1] :  ba[0].a[0].a);      /* { dg-warning \"nul\" }  */\n+\n+T (v0 ? ba[0].a[0].a : ba[0].a[1].b);\n+T (v0 ? ba[0].a[1].b : ba[0].a[0].a);"}, {"sha": "3fa5ef56f38e726276d9146e542aff324d4c8c27", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ab24ea809555eeb869fe49595f22ed9c8737cc4/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=6ab24ea809555eeb869fe49595f22ed9c8737cc4", "patch": "@@ -291,8 +291,6 @@ get_addr_stridx (tree exp, tree ptr, unsigned HOST_WIDE_INT *offset_out)\n static int\n get_stridx (tree exp)\n {\n-  tree s, o;\n-\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n       if (ssa_ver_to_stridx[SSA_NAME_VERSION (exp)])\n@@ -336,18 +334,10 @@ get_stridx (tree exp)\n \treturn idx;\n     }\n \n-  s = string_constant (exp, &o, NULL, NULL);\n-  if (s != NULL_TREE\n-      && (o == NULL_TREE || tree_fits_shwi_p (o))\n-      && TREE_STRING_LENGTH (s) > 0)\n-    {\n-      HOST_WIDE_INT offset = o ? tree_to_shwi (o) : 0;\n-      const char *p = TREE_STRING_POINTER (s);\n-      int max = TREE_STRING_LENGTH (s) - 1;\n+  const char *p = c_getstr (exp);\n+  if (p)\n+    return ~(int) strlen (p);\n \n-      if (p[max] == '\\0' && offset >= 0 && offset <= max)\n-\treturn ~(int) strlen (p + offset);\n-    }\n   return 0;\n }\n "}]}