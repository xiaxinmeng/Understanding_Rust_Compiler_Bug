{"sha": "5bdebb51a649d04569324f4f1124d5e64a3cbff7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWJkZWJiNTFhNjQ5ZDA0NTY5MzI0ZjRmMTEyNGQ1ZTY0YTNjYmZmNw==", "commit": {"author": {"name": "Iain Buclaw", "email": "ibuclaw@gdcproject.org", "date": "2019-01-20T12:55:38Z"}, "committer": {"name": "Iain Buclaw", "email": "ibuclaw@gcc.gnu.org", "date": "2019-01-20T12:55:38Z"}, "message": "[D] Fix identity comparison for structs with complex float fields.\n\ngcc/d/ChangeLog:\n\n2019-01-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* d-codegen.cc (identity_compare_p): Return false if seen built-in\n\ttype with padding.\n\t(build_float_identity): Moved here from expr.cc.\n\t(lower_struct_comparison): Handle real and complex types.\n\t* d-tree.h (build_float_identity): New.\n\t* expr.cc (build_float_identity): Move to d-codegen.cc.\n\ngcc/testsuite/ChangeLog:\n\n2019-01-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n\n\t* gdc.dg/runnable.d: Add more tests for comparing complex types.\n\nFrom-SVN: r268104", "tree": {"sha": "420e7c58ae557015dac5d880c91f9f924489f3aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/420e7c58ae557015dac5d880c91f9f924489f3aa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5bdebb51a649d04569324f4f1124d5e64a3cbff7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdebb51a649d04569324f4f1124d5e64a3cbff7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5bdebb51a649d04569324f4f1124d5e64a3cbff7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5bdebb51a649d04569324f4f1124d5e64a3cbff7/comments", "author": {"login": "ibuclaw", "id": 397929, "node_id": "MDQ6VXNlcjM5NzkyOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/397929?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ibuclaw", "html_url": "https://github.com/ibuclaw", "followers_url": "https://api.github.com/users/ibuclaw/followers", "following_url": "https://api.github.com/users/ibuclaw/following{/other_user}", "gists_url": "https://api.github.com/users/ibuclaw/gists{/gist_id}", "starred_url": "https://api.github.com/users/ibuclaw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ibuclaw/subscriptions", "organizations_url": "https://api.github.com/users/ibuclaw/orgs", "repos_url": "https://api.github.com/users/ibuclaw/repos", "events_url": "https://api.github.com/users/ibuclaw/events{/privacy}", "received_events_url": "https://api.github.com/users/ibuclaw/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "70d87497e760dca94ef78e4e936f6d461f36e80d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/70d87497e760dca94ef78e4e936f6d461f36e80d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/70d87497e760dca94ef78e4e936f6d461f36e80d"}], "stats": {"total": 106, "additions": 81, "deletions": 25}, "files": [{"sha": "aa3bb7f90417ff5b4161f179932f05c8f4941fa1", "filename": "gcc/d/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2FChangeLog?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -1,3 +1,12 @@\n+2019-01-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* d-codegen.cc (identity_compare_p): Return false if seen built-in\n+\ttype with padding.\n+\t(build_float_identity): Moved here from expr.cc.\n+\t(lower_struct_comparison): Handle real and complex types.\n+\t* d-tree.h (build_float_identity): New.\n+\t* expr.cc (build_float_identity): Move to d-codegen.cc.\n+\n 2019-01-20  Johannes Pfau  <johannespfau@gmail.com>\n \n \t* expr.cc (build_float_identity): New function."}, {"sha": "58c8257c63c508725d24e90dd961f74c0e64db2f", "filename": "gcc/d/d-codegen.cc", "status": "modified", "additions": 47, "deletions": 11, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fd-codegen.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fd-codegen.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-codegen.cc?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -798,15 +798,21 @@ identity_compare_p (StructDeclaration *sd)\n   for (size_t i = 0; i < sd->fields.dim; i++)\n     {\n       VarDeclaration *vd = sd->fields[i];\n+      Type *tb = vd->type->toBasetype ();\n \n       /* Check inner data structures.  */\n-      if (vd->type->ty == Tstruct)\n+      if (tb->ty == Tstruct)\n \t{\n-\t  TypeStruct *ts = (TypeStruct *) vd->type;\n+\t  TypeStruct *ts = (TypeStruct *) tb;\n \t  if (!identity_compare_p (ts->sym))\n \t    return false;\n \t}\n \n+      /* Check for types that may have padding.  */\n+      if ((tb->ty == Tcomplex80 || tb->ty == Tfloat80 || tb->ty == Timaginary80)\n+\t  && Target::realpad != 0)\n+\treturn false;\n+\n       if (offset <= vd->offset)\n \t{\n \t  /* There's a hole in the struct.  */\n@@ -824,6 +830,20 @@ identity_compare_p (StructDeclaration *sd)\n   return true;\n }\n \n+/* Build a floating-point identity comparison between T1 and T2, ignoring any\n+   excessive padding in the type.  CODE is EQ_EXPR or NE_EXPR comparison.  */\n+\n+tree\n+build_float_identity (tree_code code, tree t1, tree t2)\n+{\n+  tree tmemcmp = builtin_decl_explicit (BUILT_IN_MEMCMP);\n+  tree size = size_int (TYPE_PRECISION (TREE_TYPE (t1)) / BITS_PER_UNIT);\n+\n+  tree result = build_call_expr (tmemcmp, 3, build_address (t1),\n+\t\t\t\t build_address (t2), size);\n+  return build_boolop (code, result, integer_zero_node);\n+}\n+\n /* Lower a field-by-field equality expression between T1 and T2 of type SD.\n    CODE is the EQ_EXPR or NE_EXPR comparison.  */\n \n@@ -859,29 +879,45 @@ lower_struct_comparison (tree_code code, StructDeclaration *sd,\n   for (size_t i = 0; i < sd->fields.dim; i++)\n     {\n       VarDeclaration *vd = sd->fields[i];\n+      Type *type = vd->type->toBasetype ();\n       tree sfield = get_symbol_decl (vd);\n \n       tree t1ref = component_ref (t1, sfield);\n       tree t2ref = component_ref (t2, sfield);\n       tree tcmp;\n \n-      if (vd->type->ty == Tstruct)\n+      if (type->ty == Tstruct)\n \t{\n \t  /* Compare inner data structures.  */\n-\t  StructDeclaration *decl = ((TypeStruct *) vd->type)->sym;\n+\t  StructDeclaration *decl = ((TypeStruct *) type)->sym;\n \t  tcmp = lower_struct_comparison (code, decl, t1ref, t2ref);\n \t}\n+      else if (type->ty != Tvector && type->isintegral ())\n+\t{\n+\t  /* Integer comparison, no special handling required.  */\n+\t  tcmp = build_boolop (code, t1ref, t2ref);\n+\t}\n+      else if (type->ty != Tvector && type->isfloating ())\n+\t{\n+\t  /* Floating-point comparison, don't compare padding in type.  */\n+\t  if (!type->iscomplex ())\n+\t    tcmp = build_float_identity (code, t1ref, t2ref);\n+\t  else\n+\t    {\n+\t      tree req = build_float_identity (code, real_part (t1ref),\n+\t\t\t\t\t       real_part (t2ref));\n+\t      tree ieq = build_float_identity (code, imaginary_part (t1ref),\n+\t\t\t\t\t       imaginary_part (t2ref));\n+\n+\t      tcmp = build_boolop (tcode, req, ieq);\n+\t    }\n+\t}\n       else\n \t{\n-\t  tree stype = build_ctype (vd->type);\n+\t  tree stype = build_ctype (type);\n \t  opt_scalar_int_mode mode = int_mode_for_mode (TYPE_MODE (stype));\n \n-\t  if (vd->type->ty != Tvector && vd->type->isintegral ())\n-\t    {\n-\t      /* Integer comparison, no special handling required.  */\n-\t      tcmp = build_boolop (code, t1ref, t2ref);\n-\t    }\n-\t  else if (mode.exists ())\n+\t  if (mode.exists ())\n \t    {\n \t      /* Compare field bits as their corresponding integer type.\n \t\t    *((T*) &t1) == *((T*) &t2)  */"}, {"sha": "0b3c5eddedd6e2ded70a95e9f70c2633116185d0", "filename": "gcc/d/d-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fd-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fd-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fd-tree.h?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -522,6 +522,7 @@ extern tree d_mark_addressable (tree);\n extern tree d_mark_used (tree);\n extern tree d_mark_read (tree);\n extern bool identity_compare_p (StructDeclaration *);\n+extern tree build_float_identity (tree_code, tree, tree);\n extern tree build_struct_comparison (tree_code, StructDeclaration *,\n \t\t\t\t     tree, tree);\n extern tree build_array_struct_comparison (tree_code, StructDeclaration *,"}, {"sha": "4bfdde5a29ab22246223c61d7e813529272ea207", "filename": "gcc/d/expr.cc", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fexpr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Fd%2Fexpr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fd%2Fexpr.cc?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -43,20 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"d-tree.h\"\n \n \n-/* Build a floating-point identity comparison between T1 and T2, ignoring any\n-   excessive padding in the type.  CODE is EQ_EXPR or NE_EXPR comparison.  */\n-\n-static tree\n-build_float_identity (tree_code code, tree t1, tree t2)\n-{\n-  tree tmemcmp = builtin_decl_explicit (BUILT_IN_MEMCMP);\n-  tree size = size_int (TYPE_PRECISION (TREE_TYPE (t1)) / BITS_PER_UNIT);\n-\n-  tree result = build_call_expr (tmemcmp, 3, build_address (t1),\n-\t\t\t\t build_address (t2), size);\n-  return build_boolop (code, result, integer_zero_node);\n-}\n-\n /* Implements the visitor interface to build the GCC trees of all Expression\n    AST classes emitted from the D Front-end.\n    All visit methods accept one parameter E, which holds the frontend AST"}, {"sha": "853224023fd1711326502294c411ea5c9a62df5e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -1,3 +1,7 @@\n+2019-01-20  Iain Buclaw  <ibuclaw@gdcproject.org>\n+\n+\t* gdc.dg/runnable.d: Add more tests for comparing complex types.\n+\n 2019-01-20  Johannes Pfau  <johannespfau@gmail.com>\n \n \t* gdc.dg/runnable.d: Add tests for comparing complex types."}, {"sha": "e36a25850270738f6ee189c294d24c52c1b5d1a5", "filename": "gcc/testsuite/gdc.dg/runnable.d", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Ftestsuite%2Fgdc.dg%2Frunnable.d", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5bdebb51a649d04569324f4f1124d5e64a3cbff7/gcc%2Ftestsuite%2Fgdc.dg%2Frunnable.d", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgdc.dg%2Frunnable.d?ref=5bdebb51a649d04569324f4f1124d5e64a3cbff7", "patch": "@@ -1553,6 +1553,26 @@ void test309()\n     assert(!(f1 is f3));\n     assert(!(f2 is f3));\n     assert(!(f1 !is f4));\n+\n+    struct CReal\n+    {\n+        creal value;\n+    }\n+\n+    CReal s1 = CReal(+0.0 + 0.0i);\n+    CReal s2 = CReal(+0.0 - 0.0i);\n+    CReal s3 = CReal(-0.0 + 0.0i);\n+    CReal s4 = CReal(+0.0 + 0.0i);\n+\n+    assert(s1 !is s2);\n+    assert(s1 !is s3);\n+    assert(s2 !is s3);\n+    assert(s1 is s4);\n+\n+    assert(!(s1 is s2));\n+    assert(!(s1 is s3));\n+    assert(!(s2 is s3));\n+    assert(!(s1 !is s4));\n }\n \n /******************************************/"}]}