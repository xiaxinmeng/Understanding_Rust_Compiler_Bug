{"sha": "74d27244ecfc02a14355efc26855034a684daeb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzRkMjcyNDRlY2ZjMDJhMTQzNTVlZmMyNjg1NTAzNGE2ODRkYWViOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2009-06-29T12:23:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2009-06-29T12:23:21Z"}, "message": "re PR middle-end/14187 ([tree-ssa] C restricted pointers are not properly implemented)\n\n2009-06-29  Richard Guenther  <rguenther@suse.de>\n\n\tPR middle-end/14187\n\t* tree-ssa-alias.h (struct pt_solution): Add vars_contains_restrict\n\tflag.\n\t(pt_solutions_same_restrict_base): Declare.\n\t* tree-ssa-structalias.c (struct variable_info): Add is_restrict_var\n\tflag.\n\t(new_var_info): Initialize is_global_var properly for SSA_NAMEs.\n\t(make_constraint_from, make_copy_constraint): Move earlier.\n\t(make_constraint_from_heapvar): New function.\n\t(make_constraint_from_restrict): Likewise.\n\t(handle_lhs_call): Use it.\n\t(find_func_aliases): Use it to track conversions to restrict\n\tqualified pointers.\n\t(struct fieldoff): Add only_restrict_pointers flag.\n\t(push_fields_onto_fieldstack): Initialize it.\n\t(create_variable_info_for): Track global restrict qualified pointers.\n\t(intra_create_variable_infos): Use make_constraint_from_heapvar.\n\tTrack restrict qualified pointer arguments.\n\t(set_uids_in_ptset): Use varinfo is_global_var flag.\n\t(find_what_var_points_to): Set the vars_contains_restrict flag.\n\tAlways create the points-to solution for sets including restrict tags.\n\t(pt_solutions_same_restrict_base): New function.\n\t* tree-ssa-alias.c (ptr_derefs_may_alias_p): For two restrict\n\tqualified pointers use pt_solutions_same_restrict_base as\n\tadditional source for disambiguation.\n\n\t* gcc.dg/tree-ssa/restrict-1.c: New testcase.\n\t* gcc.dg/tree-ssa/restrict-2.c: Likewise.\n\t* gcc.dg/tree-ssa/restrict-3.c: Likewise.\n\t* gcc.c-torture/execute/20090623-1.c: Likewise.\n\t* gcc.dg/tree-ssa/ldist-13.c: Likewise.\n\t* gcc.dg/tree-ssa/ldist-14.c: Likewise.\n\nFrom-SVN: r149048", "tree": {"sha": "9628cef93c202d8f6bd22c558673343fbd31f01a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9628cef93c202d8f6bd22c558673343fbd31f01a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/74d27244ecfc02a14355efc26855034a684daeb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d27244ecfc02a14355efc26855034a684daeb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/74d27244ecfc02a14355efc26855034a684daeb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/74d27244ecfc02a14355efc26855034a684daeb9/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "5b21f0f37dd072967e60c5e413dbabec1eb1c837", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b21f0f37dd072967e60c5e413dbabec1eb1c837", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b21f0f37dd072967e60c5e413dbabec1eb1c837"}], "stats": {"total": 466, "additions": 344, "deletions": 122}, "files": [{"sha": "351175cfaab97e2fabc64bbc95a5bf05e9044beb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -1,3 +1,31 @@\n+2009-06-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/14187\n+\t* tree-ssa-alias.h (struct pt_solution): Add vars_contains_restrict\n+\tflag.\n+\t(pt_solutions_same_restrict_base): Declare.\n+\t* tree-ssa-structalias.c (struct variable_info): Add is_restrict_var\n+\tflag.\n+\t(new_var_info): Initialize is_global_var properly for SSA_NAMEs.\n+\t(make_constraint_from, make_copy_constraint): Move earlier.\n+\t(make_constraint_from_heapvar): New function.\n+\t(make_constraint_from_restrict): Likewise.\n+\t(handle_lhs_call): Use it.\n+\t(find_func_aliases): Use it to track conversions to restrict\n+\tqualified pointers.\n+\t(struct fieldoff): Add only_restrict_pointers flag.\n+\t(push_fields_onto_fieldstack): Initialize it.\n+\t(create_variable_info_for): Track global restrict qualified pointers.\n+\t(intra_create_variable_infos): Use make_constraint_from_heapvar.\n+\tTrack restrict qualified pointer arguments.\n+\t(set_uids_in_ptset): Use varinfo is_global_var flag.\n+\t(find_what_var_points_to): Set the vars_contains_restrict flag.\n+\tAlways create the points-to solution for sets including restrict tags.\n+\t(pt_solutions_same_restrict_base): New function.\n+\t* tree-ssa-alias.c (ptr_derefs_may_alias_p): For two restrict\n+\tqualified pointers use pt_solutions_same_restrict_base as\n+\tadditional source for disambiguation.\n+\n 2009-06-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/38212"}, {"sha": "d325d4ab0a6f5e0303a0f656273de2cc8123f390", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -1,3 +1,13 @@\n+2009-06-29  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR middle-end/14187\n+\t* gcc.dg/tree-ssa/restrict-1.c: New testcase.\n+\t* gcc.dg/tree-ssa/restrict-2.c: Likewise.\n+\t* gcc.dg/tree-ssa/restrict-3.c: Likewise.\n+\t* gcc.c-torture/execute/20090623-1.c: Likewise.\n+\t* gcc.dg/tree-ssa/ldist-13.c: Likewise.\n+\t* gcc.dg/tree-ssa/ldist-14.c: Likewise.\n+\n 2009-06-29  Richard Guenther  <rguenther@suse.de>\n \n \tPR middle-end/38212"}, {"sha": "09a5672cd7484893471006ca57d4708a1dd24b72", "filename": "gcc/testsuite/gcc.c-torture/execute/20090623-1.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090623-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090623-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2F20090623-1.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,18 @@\n+int * __restrict__ x;\n+\n+int foo (int y)\n+{\n+  *x = y;\n+  return *x;\n+}\n+\n+extern void abort (void);\n+\n+int main()\n+{\n+  int i = 0;\n+  x = &i;\n+  if (foo(1) != 1)\n+    abort ();\n+  return 0;\n+}"}, {"sha": "9841569543e0c745b45c5154d0e54956eae80831", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-13.c", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-13.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,22 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+\n+float * __restrict__ x;\n+float * __restrict__ y;\n+\n+float foo (int n)\n+{\n+  int i;\n+  float tmp = 0.0;\n+  for (i = 0; i < n; ++i)\n+    {\n+      x[i] = 0.0;\n+      tmp += y[i];\n+    }\n+  return tmp;\n+}\n+\n+/* We should apply loop distribution.  */\n+\n+/* { dg-final { scan-tree-dump \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "700599f1ccb83a1f0e795465b5f0d45e61d17402", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ldist-14.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fldist-14.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-strict-aliasing -ftree-loop-distribution -fdump-tree-ldist-details\" } */\n+\n+struct desc {\n+  int i;\n+  void * __restrict__ data;\n+  int j;\n+} a, b;\n+\n+float foo (int n)\n+{\n+  int i;\n+  float * __restrict__ x, * __restrict__ y, tmp = 0.0;\n+  x = (float * __restrict__)a.data;\n+  y = (float * __restrict__)b.data;\n+  for (i = 0; i < n; ++i)\n+    {\n+      x[i] = 0.0;\n+      tmp += y[i];\n+    }\n+  return tmp;\n+}\n+\n+/* We should apply loop distribution.  */\n+\n+/* { dg-final { scan-tree-dump \"Loop 1 distributed: split to 2 loops\" \"ldist\" } } */\n+/* { dg-final { cleanup-tree-dump \"ldist\" } } */"}, {"sha": "08fc10f5609635a188ac86618b73eb7a70c26070", "filename": "gcc/testsuite/gcc.dg/tree-ssa/restrict-1.c", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-1.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,20 @@\n+/* { dg-do link } */\n+/* { dg-options \"-O -fno-strict-aliasing -fdump-tree-optimized\" } */\n+\n+extern void link_error (void);\n+\n+void bar0 (int * __restrict__ arr1, int * __restrict__ arr2)\n+{\n+  arr1[0] = 1;\n+  arr2[0] = 1;\n+  if (arr1[0] != 1)\n+    link_error ();\n+}\n+\n+int main()\n+{\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"link_error\" \"optimized\" } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "b76ad98fa88938eea57e7e759de9ea7764c848a7", "filename": "gcc/testsuite/gcc.dg/tree-ssa/restrict-2.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-2.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-strict-aliasing -fdump-tree-lim-details\" } */\n+\n+void foo (float * __restrict__ a, float * __restrict__ b, int n, int j)\n+{\n+  int i;\n+  for(i = 0; i < n; ++i)\n+    a[i] = (b[j+50] + b[j-50]) * 0.5f;\n+}\n+\n+/* We should move the RHS of the store out of the loop.  */\n+\n+/* { dg-final { scan-tree-dump-times \"Moving statement\" 11 \"lim\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "08faafada2596e6d32b176f7335a0385e95e1fc8", "filename": "gcc/testsuite/gcc.dg/tree-ssa/restrict-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Frestrict-3.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fno-strict-aliasing -fdump-tree-lim-details\" } */\n+\n+void f(int * __restrict__ r,\n+       int a[__restrict__ 16][16],\n+       int b[__restrict__ 16][16],\n+       int i, int j)\n+{\n+  int x;\n+  *r = 0;\n+  for (x = 1; x < 16; ++x)\n+    *r = *r + a[i][x] * b[x][j];\n+}\n+\n+/* We should apply store motion to the store to *r.  */\n+\n+/* { dg-final { scan-tree-dump \"Executing store motion of \\\\\\*r\" \"lim\" } } */\n+/* { dg-final { cleanup-tree-dump \"lim\" } } */"}, {"sha": "e8bca84ba35dbd5d309bd2634b01ea83db662fee", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -273,6 +273,13 @@ ptr_derefs_may_alias_p (tree ptr1, tree ptr2)\n   if (!pi1 || !pi2)\n     return true;\n \n+  /* If both pointers are restrict-qualified try to disambiguate\n+     with restrict information.  */\n+  if (TYPE_RESTRICT (TREE_TYPE (ptr1))\n+      && TYPE_RESTRICT (TREE_TYPE (ptr2))\n+      && !pt_solutions_same_restrict_base (&pi1->pt, &pi2->pt))\n+    return false;\n+\n   /* ???  This does not use TBAA to prune decls from the intersection\n      that not both pointers may access.  */\n   return pt_solutions_intersect (&pi1->pt, &pi2->pt);"}, {"sha": "b071e4b1b8104497a2b867430a5758763fa08645", "filename": "gcc/tree-ssa-alias.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-alias.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-alias.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.h?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -49,6 +49,9 @@ struct GTY(()) pt_solution\n   /* Nonzero if the pt_vars bitmap includes a global variable.  */\n   unsigned int vars_contains_global : 1;\n \n+  /* Nonzero if the pt_vars bitmap includes a restrict tag variable.  */\n+  unsigned int vars_contains_restrict : 1;\n+\n   /* Set of variables that this pointer may point to.  */\n   bitmap vars;\n };\n@@ -115,6 +118,8 @@ extern void delete_alias_heapvars (void);\n extern bool pt_solution_includes_global (struct pt_solution *);\n extern bool pt_solution_includes (struct pt_solution *, const_tree);\n extern bool pt_solutions_intersect (struct pt_solution *, struct pt_solution *);\n+extern bool pt_solutions_same_restrict_base (struct pt_solution *,\n+\t\t\t\t\t     struct pt_solution *);\n extern void pt_solution_reset (struct pt_solution *);\n extern void dump_pta_stats (FILE *);\n "}, {"sha": "ad5482aa4aec92cbbd8808eca940786f0984e4a0", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 175, "deletions": 122, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/74d27244ecfc02a14355efc26855034a684daeb9/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=74d27244ecfc02a14355efc26855034a684daeb9", "patch": "@@ -211,20 +211,23 @@ struct variable_info\n \n   /* True if this is a variable created by the constraint analysis, such as\n      heap variables and constraints we had to break up.  */\n-  unsigned int is_artificial_var:1;\n+  unsigned int is_artificial_var : 1;\n \n   /* True if this is a special variable whose solution set should not be\n      changed.  */\n-  unsigned int is_special_var:1;\n+  unsigned int is_special_var : 1;\n \n   /* True for variables whose size is not known or variable.  */\n-  unsigned int is_unknown_size_var:1;\n+  unsigned int is_unknown_size_var : 1;\n \n   /* True for (sub-)fields that represent a whole variable.  */\n   unsigned int is_full_var : 1;\n \n   /* True if this is a heap variable.  */\n-  unsigned int is_heap_var:1;\n+  unsigned int is_heap_var : 1;\n+\n+  /* True if this is a variable tracking a restrict pointer source.  */\n+  unsigned int is_restrict_var : 1;\n \n   /* True if this field may contain pointers.  */\n   unsigned int may_have_pointers : 1;\n@@ -339,7 +342,7 @@ new_var_info (tree t, const char *name)\n   ret->is_special_var = false;\n   ret->is_unknown_size_var = false;\n   ret->may_have_pointers = true;\n-  ret->is_global_var = true;\n+  ret->is_global_var = (t == NULL_TREE);\n   if (t && DECL_P (t))\n     ret->is_global_var = is_global_var (t);\n   ret->solution = BITMAP_ALLOC (&pta_obstack);\n@@ -3312,6 +3315,40 @@ make_constraint_to (unsigned id, tree op)\n   VEC_free (ce_s, heap, rhsc);\n }\n \n+/* Create a constraint ID = &FROM.  */\n+\n+static void\n+make_constraint_from (varinfo_t vi, int from)\n+{\n+  struct constraint_expr lhs, rhs;\n+\n+  lhs.var = vi->id;\n+  lhs.offset = 0;\n+  lhs.type = SCALAR;\n+\n+  rhs.var = from;\n+  rhs.offset = 0;\n+  rhs.type = ADDRESSOF;\n+  process_constraint (new_constraint (lhs, rhs));\n+}\n+\n+/* Create a constraint ID = FROM.  */\n+\n+static void\n+make_copy_constraint (varinfo_t vi, int from)\n+{\n+  struct constraint_expr lhs, rhs;\n+\n+  lhs.var = vi->id;\n+  lhs.offset = 0;\n+  lhs.type = SCALAR;\n+\n+  rhs.var = from;\n+  rhs.offset = 0;\n+  rhs.type = SCALAR;\n+  process_constraint (new_constraint (lhs, rhs));\n+}\n+\n /* Make constraints necessary to make OP escape.  */\n \n static void\n@@ -3320,6 +3357,61 @@ make_escape_constraint (tree op)\n   make_constraint_to (escaped_id, op);\n }\n \n+/* Create a new artificial heap variable with NAME and make a\n+   constraint from it to LHS.  Return the created variable.  */\n+\n+static varinfo_t\n+make_constraint_from_heapvar (varinfo_t lhs, const char *name)\n+{\n+  varinfo_t vi;\n+  tree heapvar = heapvar_lookup (lhs->decl);\n+\n+  if (heapvar == NULL_TREE)\n+    {\n+      var_ann_t ann;\n+      heapvar = create_tmp_var_raw (ptr_type_node, name);\n+      DECL_EXTERNAL (heapvar) = 1;\n+\n+      heapvar_insert (lhs->decl, heapvar);\n+\n+      ann = get_var_ann (heapvar);\n+      ann->is_heapvar = 1;\n+    }\n+\n+  /* For global vars we need to add a heapvar to the list of referenced\n+     vars of a different function than it was created for originally.  */\n+  if (gimple_referenced_vars (cfun))\n+    add_referenced_var (heapvar);\n+\n+  vi = new_var_info (heapvar, name);\n+  vi->is_artificial_var = true;\n+  vi->is_heap_var = true;\n+  vi->is_unknown_size_var = true;\n+  vi->fullsize = ~0;\n+  vi->size = ~0;\n+  vi->is_full_var = true;\n+  insert_vi_for_tree (heapvar, vi);\n+\n+  make_constraint_from (lhs, vi->id);\n+\n+  return vi;\n+}\n+\n+/* Create a new artificial heap variable with NAME and make a\n+   constraint from it to LHS.  Set flags according to a tag used\n+   for tracking restrict pointers.  */\n+\n+static void\n+make_constraint_from_restrict (varinfo_t lhs, const char *name)\n+{\n+  varinfo_t vi;\n+  vi = make_constraint_from_heapvar (lhs, name);\n+  vi->is_restrict_var = 1;\n+  vi->is_global_var = 0;\n+  vi->is_special_var = 1;\n+  vi->may_have_pointers = 0;\n+}\n+\n /* For non-IPA mode, generate constraints necessary for a call on the\n    RHS.  */\n \n@@ -3374,39 +3466,14 @@ static void\n handle_lhs_call (tree lhs, int flags, VEC(ce_s, heap) *rhsc)\n {\n   VEC(ce_s, heap) *lhsc = NULL;\n-  unsigned int j;\n-  struct constraint_expr *lhsp;\n \n   get_constraint_for (lhs, &lhsc);\n \n   if (flags & ECF_MALLOC)\n     {\n-      struct constraint_expr rhsc;\n-      tree heapvar = heapvar_lookup (lhs);\n       varinfo_t vi;\n-\n-      if (heapvar == NULL)\n-\t{\n-\t  heapvar = create_tmp_var_raw (ptr_type_node, \"HEAP\");\n-\t  DECL_EXTERNAL (heapvar) = 1;\n-\t  get_var_ann (heapvar)->is_heapvar = 1;\n-\t  if (gimple_referenced_vars (cfun))\n-\t    add_referenced_var (heapvar);\n-\t  heapvar_insert (lhs, heapvar);\n-\t}\n-\n-      rhsc.var = create_variable_info_for (heapvar,\n-\t\t\t\t\t   alias_get_name (heapvar));\n-      vi = get_varinfo (rhsc.var);\n-      vi->is_artificial_var = 1;\n-      vi->is_heap_var = 1;\n-      vi->is_unknown_size_var = true;\n-      vi->fullsize = ~0;\n-      vi->size = ~0;\n-      rhsc.type = ADDRESSOF;\n-      rhsc.offset = 0;\n-      for (j = 0; VEC_iterate (ce_s, lhsc, j, lhsp); j++)\n-\tprocess_constraint (new_constraint (*lhsp, rhsc));\n+      vi = make_constraint_from_heapvar (get_vi_for_tree (lhs), \"HEAP\");\n+      make_copy_constraint (vi, nonlocal_id);\n     }\n   else if (VEC_length (ce_s, rhsc) > 0)\n     {\n@@ -3826,6 +3893,15 @@ find_func_aliases (gimple origt)\n \t  && DECL_P (lhsop)\n \t  && is_global_var (lhsop))\n \tmake_escape_constraint (rhsop);\n+      /* If this is a conversion of a non-restrict pointer to a\n+\t restrict pointer track it with a new heapvar.  */\n+      else if (gimple_assign_cast_p (t)\n+\t       && POINTER_TYPE_P (TREE_TYPE (rhsop))\n+\t       && POINTER_TYPE_P (TREE_TYPE (lhsop))\n+\t       && !TYPE_RESTRICT (TREE_TYPE (rhsop))\n+\t       && TYPE_RESTRICT (TREE_TYPE (lhsop)))\n+\tmake_constraint_from_restrict (get_vi_for_tree (lhsop),\n+\t\t\t\t       \"CAST_RESTRICT\");\n     }\n   /* For conversions of pointers to non-pointers the pointer escapes.  */\n   else if (gimple_assign_cast_p (t)\n@@ -4017,6 +4093,8 @@ struct fieldoff\n   unsigned has_unknown_size : 1;\n \n   unsigned may_have_pointers : 1;\n+\n+  unsigned only_restrict_pointers : 1;\n };\n typedef struct fieldoff fieldoff_s;\n \n@@ -4155,6 +4233,10 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n \t\telse\n \t\t  pair->size = -1;\n \t\tpair->may_have_pointers = could_have_pointers (field);\n+\t\tpair->only_restrict_pointers\n+\t\t  = (!has_unknown_size\n+\t\t     && POINTER_TYPE_P (TREE_TYPE (field))\n+\t\t     && TYPE_RESTRICT (TREE_TYPE (field)));\n \t\tcount++;\n \t      }\n \t  }\n@@ -4165,40 +4247,6 @@ push_fields_onto_fieldstack (tree type, VEC(fieldoff_s,heap) **fieldstack,\n   return count;\n }\n \n-/* Create a constraint ID = &FROM.  */\n-\n-static void\n-make_constraint_from (varinfo_t vi, int from)\n-{\n-  struct constraint_expr lhs, rhs;\n-\n-  lhs.var = vi->id;\n-  lhs.offset = 0;\n-  lhs.type = SCALAR;\n-\n-  rhs.var = from;\n-  rhs.offset = 0;\n-  rhs.type = ADDRESSOF;\n-  process_constraint (new_constraint (lhs, rhs));\n-}\n-\n-/* Create a constraint ID = FROM.  */\n-\n-static void\n-make_copy_constraint (varinfo_t vi, int from)\n-{\n-  struct constraint_expr lhs, rhs;\n-\n-  lhs.var = vi->id;\n-  lhs.offset = 0;\n-  lhs.type = SCALAR;\n-\n-  rhs.var = from;\n-  rhs.offset = 0;\n-  rhs.type = SCALAR;\n-  process_constraint (new_constraint (lhs, rhs));\n-}\n-\n /* Count the number of arguments DECL has, and set IS_VARARGS to true\n    if it is a varargs function.  */\n \n@@ -4346,17 +4394,12 @@ create_variable_info_for (tree decl, const char *name)\n   varinfo_t vi;\n   tree decl_type = TREE_TYPE (decl);\n   tree declsize = DECL_P (decl) ? DECL_SIZE (decl) : TYPE_SIZE (decl_type);\n-  bool is_global = DECL_P (decl) ? is_global_var (decl) : false;\n   VEC (fieldoff_s,heap) *fieldstack = NULL;\n \n   if (TREE_CODE (decl) == FUNCTION_DECL && in_ipa_mode)\n     return create_function_info_for (decl, name);\n \n-  if (var_can_have_subvars (decl) && use_field_sensitive\n-      && (!var_ann (decl)\n-\t  || var_ann (decl)->noalias_state == 0)\n-      && (!var_ann (decl)\n-\t  || !var_ann (decl)->is_heapvar))\n+  if (var_can_have_subvars (decl) && use_field_sensitive)\n     push_fields_onto_fieldstack (decl_type, &fieldstack, 0);\n \n   /* If the variable doesn't have subvars, we may end up needing to\n@@ -4379,14 +4422,14 @@ create_variable_info_for (tree decl, const char *name)\n     }\n \n   insert_vi_for_tree (vi->decl, vi);\n-  if (is_global && (!flag_whole_program || !in_ipa_mode)\n+  if (vi->is_global_var\n+      && (!flag_whole_program || !in_ipa_mode)\n       && vi->may_have_pointers)\n     {\n-      if (var_ann (decl)\n-\t  && var_ann (decl)->noalias_state == NO_ALIAS_ANYTHING)\n-\tmake_constraint_from (vi, vi->id);\n-      else\n-\tmake_copy_constraint (vi, nonlocal_id);\n+      if (POINTER_TYPE_P (TREE_TYPE (decl))\n+\t  && TYPE_RESTRICT (TREE_TYPE (decl)))\n+\tmake_constraint_from_restrict (vi, \"GLOBAL_RESTRICT\");\n+      make_copy_constraint (vi, nonlocal_id);\n     }\n \n   stats.total_vars++;\n@@ -4463,9 +4506,14 @@ create_variable_info_for (tree decl, const char *name)\n \t  newvi->fullsize = vi->fullsize;\n \t  newvi->may_have_pointers = fo->may_have_pointers;\n \t  insert_into_field_list (vi, newvi);\n-\t  if (is_global && (!flag_whole_program || !in_ipa_mode)\n+\t  if (newvi->is_global_var\n+\t      && (!flag_whole_program || !in_ipa_mode)\n \t      && newvi->may_have_pointers)\n-\t    make_copy_constraint (newvi, nonlocal_id);\n+\t    {\n+\t       if (fo->only_restrict_pointers)\n+\t\t make_constraint_from_restrict (newvi, \"GLOBAL_RESTRICT\");\n+\t       make_copy_constraint (newvi, nonlocal_id);\n+\t    }\n \n \t  stats.total_vars++;\n \t}\n@@ -4518,7 +4566,6 @@ static void\n intra_create_variable_infos (void)\n {\n   tree t;\n-  struct constraint_expr lhs, rhs;\n \n   /* For each incoming pointer argument arg, create the constraint ARG\n      = NONLOCAL or a dummy variable if flag_argument_noalias is set.  */\n@@ -4536,50 +4583,28 @@ intra_create_variable_infos (void)\n       if (POINTER_TYPE_P (TREE_TYPE (t)) && flag_argument_noalias > 0)\n \t{\n \t  varinfo_t vi;\n-\t  tree heapvar = heapvar_lookup (t);\n-\n-\t  lhs.offset = 0;\n-\t  lhs.type = SCALAR;\n-\t  lhs.var  = get_vi_for_tree (t)->id;\n+\t  var_ann_t ann;\n \n-\t  if (heapvar == NULL_TREE)\n+\t  vi = make_constraint_from_heapvar (get_vi_for_tree (t),\n+\t\t\t\t\t     \"PARM_NOALIAS\");\n+\t  ann = get_var_ann (vi->decl);\n+\t  if (flag_argument_noalias == 1)\n \t    {\n-\t      var_ann_t ann;\n-\t      heapvar = create_tmp_var_raw (ptr_type_node,\n-\t\t\t\t\t    \"PARM_NOALIAS\");\n-\t      DECL_EXTERNAL (heapvar) = 1;\n-\t      if (gimple_referenced_vars (cfun))\n-\t\tadd_referenced_var (heapvar);\n-\n-\t      heapvar_insert (t, heapvar);\n-\n-\t      ann = get_var_ann (heapvar);\n-\t      ann->is_heapvar = 1;\n-\t      if (flag_argument_noalias == 1)\n-\t\tann->noalias_state = NO_ALIAS;\n-\t      else if (flag_argument_noalias == 2)\n-\t\tann->noalias_state = NO_ALIAS_GLOBAL;\n-\t      else if (flag_argument_noalias == 3)\n-\t\tann->noalias_state = NO_ALIAS_ANYTHING;\n-\t      else\n-\t\tgcc_unreachable ();\n+\t      ann->noalias_state = NO_ALIAS;\n+\t      make_copy_constraint (vi, nonlocal_id);\n \t    }\n-\n-\t  vi = get_vi_for_tree (heapvar);\n-\t  vi->is_artificial_var = 1;\n-\t  vi->is_heap_var = 1;\n-\t  vi->is_unknown_size_var = true;\n-\t  vi->fullsize = ~0;\n-\t  vi->size = ~0;\n-\t  rhs.var = vi->id;\n-\t  rhs.type = ADDRESSOF;\n-\t  rhs.offset = 0;\n-\t  for (p = get_varinfo (lhs.var); p; p = p->next)\n+\t  else if (flag_argument_noalias == 2)\n+\t    {\n+\t      ann->noalias_state = NO_ALIAS_GLOBAL;\n+\t      make_constraint_from (vi, vi->id);\n+\t    }\n+\t  else if (flag_argument_noalias == 3)\n \t    {\n-\t      struct constraint_expr temp = lhs;\n-\t      temp.var = p->id;\n-\t      process_constraint (new_constraint (temp, rhs));\n+\t      ann->noalias_state = NO_ALIAS_ANYTHING;\n+\t      make_constraint_from (vi, vi->id);\n \t    }\n+\t  else\n+\t    gcc_unreachable ();\n \t}\n       else\n \t{\n@@ -4588,6 +4613,9 @@ intra_create_variable_infos (void)\n \t  for (p = arg_vi; p; p = p->next)\n \t    make_constraint_from (p, nonlocal_id);\n \t}\n+      if (POINTER_TYPE_P (TREE_TYPE (t))\n+\t  && TYPE_RESTRICT (TREE_TYPE (t)))\n+\tmake_constraint_from_restrict (get_vi_for_tree (t), \"PARM_RESTRICT\");\n     }\n \n   /* Add a constraint for a result decl that is passed by reference.  */\n@@ -4704,7 +4732,7 @@ set_uids_in_ptset (bitmap into, bitmap from, struct pt_solution *pt)\n \t  /* Add the decl to the points-to set.  Note that the points-to\n \t     set contains global variables.  */\n \t  bitmap_set_bit (into, DECL_UID (vi->decl));\n-\t  if (is_global_var (vi->decl))\n+\t  if (vi->is_global_var)\n \t    pt->vars_contains_global = true;\n \t}\n     }\n@@ -4753,11 +4781,15 @@ find_what_var_points_to (varinfo_t vi, struct pt_solution *pt)\n \t\t   || vi->id == integer_id)\n \t    pt->anything = 1;\n \t}\n+      if (vi->is_restrict_var)\n+\tpt->vars_contains_restrict = true;\n     }\n \n   /* Instead of doing extra work, simply do not create\n      elaborate points-to information for pt_anything pointers.  */\n-  if (pt->anything)\n+  if (pt->anything\n+      && (vi->is_artificial_var\n+\t  || !pt->vars_contains_restrict))\n     return;\n \n   /* Share the final set of variables when possible.  */\n@@ -4967,6 +4999,27 @@ pt_solutions_intersect (struct pt_solution *pt1, struct pt_solution *pt2)\n   return res;\n }\n \n+/* Return true if both points-to solutions PT1 and PT2 for two restrict\n+   qualified pointers are possibly based on the same pointer.  */\n+\n+bool\n+pt_solutions_same_restrict_base (struct pt_solution *pt1,\n+\t\t\t\t struct pt_solution *pt2)\n+{\n+  /* If we deal with points-to solutions of two restrict qualified\n+     pointers solely rely on the pointed-to variable bitmap intersection.\n+     For two pointers that are based on each other the bitmaps will\n+     intersect.  */\n+  if (pt1->vars_contains_restrict\n+      && pt2->vars_contains_restrict)\n+    {\n+      gcc_assert (pt1->vars && pt2->vars);\n+      return bitmap_intersect_p (pt1->vars, pt2->vars);\n+    }\n+\n+  return true;\n+}\n+\n \n /* Dump points-to information to OUTFILE.  */\n "}]}