{"sha": "5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWU2ZmY2YmRhMzhmOGQ5MmVmMTUyMmI0NWNkZDc4YzkwNTU3YWUxYg==", "commit": {"author": {"name": "David Daney", "email": "ddaney@avtrex.com", "date": "2005-11-15T19:11:53Z"}, "committer": {"name": "David Daney", "email": "daney@gcc.gnu.org", "date": "2005-11-15T19:11:53Z"}, "message": "re PR libgcj/15430 (Cannot interrupt blocking I/O calls with close())\n\n\tPR libgcj/15430\n\t* gnu/java/net/natPlainSocketImplPosix.cc (throw_on_sock_closed): New\n\tfunction.\n\t(accept): Call it.\n\t(close): Call shutdown before closing.\n\t(read()): Call read_helper with proper parameters.\n\t(read(buffer, int, int)): Likewise.\n\t(read_helper):  Pass pointer to the PlainSocketImpl, remove native_fd\n\tand timeout parameters.  Make prototype to match. Use \n\tpointer to PlainSocketImpl to access members. Call throw_on_sock_closed\n\tin two places.\n\nFrom-SVN: r107036", "tree": {"sha": "b24e7f59a4d050f706a76e11e684d9f172e30439", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b24e7f59a4d050f706a76e11e684d9f172e30439"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b/comments", "author": null, "committer": null, "parents": [{"sha": "7735d402c405f05343b3ea732426eb5ca4b43b6a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7735d402c405f05343b3ea732426eb5ca4b43b6a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7735d402c405f05343b3ea732426eb5ca4b43b6a"}], "stats": {"total": 72, "additions": 58, "deletions": 14}, "files": [{"sha": "724fcd73e6e52b5fd2b0c5968278f3c0289c133a", "filename": "libjava/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "patch": "@@ -1,3 +1,17 @@\n+2005-15-09  David Daney <ddaney@avtrex.com>\n+\n+\tPR libgcj/15430\n+\t* gnu/java/net/natPlainSocketImplPosix.cc (throw_on_sock_closed): New\n+\tfunction.\n+\t(accept): Call it.\n+\t(close): Call shutdown before closing.\n+\t(read()): Call read_helper with proper parameters.\n+\t(read(buffer, int, int)): Likewise.\n+\t(read_helper):  Pass pointer to the PlainSocketImpl, remove native_fd\n+\tand timeout parameters.  Make prototype to match. Use \n+\tpointer to PlainSocketImpl to access members. Call throw_on_sock_closed\n+\tin two places.\n+\n 2005-11-15  Andrew Haley  <aph@redhat.com>\n \n \t* Merge from Classpath head:"}, {"sha": "643f4e4909a5fdaa0252ab72fb6ba8e0475965b6", "filename": "libjava/gnu/java/net/natPlainSocketImplPosix.cc", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Fnet%2FnatPlainSocketImplPosix.cc?ref=5e6ff6bda38f8d92ef1522b45cdd78c90557ae1b", "patch": "@@ -226,6 +226,21 @@ gnu::java::net::PlainSocketImpl::listen (jint backlog)\n     }\n }\n \n+static void \n+throw_on_sock_closed (gnu::java::net::PlainSocketImpl *soc_impl)\n+{\n+    // Avoid races from asynchronous close().\n+    JvSynchronize sync (soc_impl);\n+    if (soc_impl->native_fd == -1)\n+      {\n+        using namespace java::net;\n+        // Socket was closed.\n+        SocketException *se =\n+            new SocketException (JvNewStringUTF (\"Socket Closed\"));\n+        throw se;\n+      }\n+}\n+\n void\n gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n {\n@@ -284,6 +299,7 @@ gnu::java::net::PlainSocketImpl::accept (gnu::java::net::PlainSocketImpl *s)\n \n  error:\n   char* strerr = strerror (errno);\n+  throw_on_sock_closed (this);\n   throw new ::java::io::IOException (JvNewStringUTF (strerr));\n }\n \n@@ -294,7 +310,11 @@ gnu::java::net::PlainSocketImpl::close()\n   // Avoid races from asynchronous finalization.\n   JvSynchronize sync (this);\n \n-  // should we use shutdown here? how would that effect so_linger?\n+  // Should we use shutdown here? Yes.\n+  // How would that effect so_linger? Uncertain.\n+  ::shutdown (native_fd, 2);\n+  // Ignore errors in shutdown as we are closing and all the same\n+  // errors are handled in the close.\n   int res = _Jv_close (native_fd);\n \n   if (res == -1)\n@@ -371,24 +391,26 @@ gnu::java::net::PlainSocketImpl::sendUrgentData (jint)\n }\n \n static jint\n-read_helper (jint native_fd, jint timeout, jbyte *bytes, jint count);\n+read_helper (gnu::java::net::PlainSocketImpl *soc_impl,\n+             jbyte *bytes, jint count);\n \n // Read a single byte from the socket.\n jint\n gnu::java::net::PlainSocketImpl$SocketInputStream::read(void)\n {\n   jbyte data;\n \n-  if (read_helper (this$0->native_fd, this$0->timeout, &data, 1) == 1)\n+  if (read_helper (this$0, &data, 1) == 1)\n     return data & 0xFF;\n \n   return -1;\n }\n \n // Read count bytes into the buffer, starting at offset.\n jint\n-gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint offset, \n-  jint count)\n+gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer,\n+                                                        jint offset, \n+                                                        jint count)\n {\n  if (! buffer)\n     throw new ::java::lang::NullPointerException;\n@@ -398,32 +420,36 @@ gnu::java::net::PlainSocketImpl$SocketInputStream::read(jbyteArray buffer, jint\n   if (offset < 0 || count < 0 || offset + count > bsize)\n     throw new ::java::lang::ArrayIndexOutOfBoundsException;\n \n-  return read_helper (this$0->native_fd, this$0->timeout,\n+  return read_helper (this$0,\n \t\t      elements (buffer) + offset * sizeof (jbyte), count);\n }\n \n static jint\n-read_helper (jint native_fd, jint timeout, jbyte *bytes, jint count)\n+read_helper (gnu::java::net::PlainSocketImpl *soc_impl,\n+             jbyte *bytes, jint count)\n {\n   // If zero bytes were requested, short circuit so that recv\n   // doesn't signal EOF.\n   if (count == 0)\n     return 0;\n     \n   // Do timeouts via select.\n-  if (timeout > 0 && native_fd >= 0 && native_fd < FD_SETSIZE)\n+  if (soc_impl->timeout > 0\n+      && soc_impl->native_fd >= 0\n+      && soc_impl->native_fd < FD_SETSIZE)\n     {\n       // Create the file descriptor set.\n       fd_set read_fds;\n       FD_ZERO (&read_fds);\n-      FD_SET (native_fd, &read_fds);\n+      FD_SET (soc_impl->native_fd, &read_fds);\n       // Create the timeout struct based on our internal timeout value.\n       struct timeval timeout_value;\n-      timeout_value.tv_sec = timeout / 1000;\n-      timeout_value.tv_usec =(timeout % 1000) * 1000;\n+      timeout_value.tv_sec = soc_impl->timeout / 1000;\n+      timeout_value.tv_usec =(soc_impl->timeout % 1000) * 1000;\n       // Select on the fds.\n       int sel_retval =\n-        _Jv_select (native_fd + 1, &read_fds, NULL, NULL, &timeout_value);\n+        _Jv_select (soc_impl->native_fd + 1,\n+                    &read_fds, NULL, NULL, &timeout_value);\n       // We're only interested in the 0 return.\n       // error returns still require us to try to read \n       // the socket to see what happened.\n@@ -437,10 +463,13 @@ read_helper (jint native_fd, jint timeout, jbyte *bytes, jint count)\n     }\n \n   // Read the socket.\n-  int r = ::recv (native_fd, (char *) bytes, count, 0);\n+  int r = ::recv (soc_impl->native_fd, (char *) bytes, count, 0);\n \n   if (r == 0)\n-    return -1;\n+    {\n+      throw_on_sock_closed (soc_impl);\n+      return -1;\n+    }\n \n   if (::java::lang::Thread::interrupted())\n     {\n@@ -452,6 +481,7 @@ read_helper (jint native_fd, jint timeout, jbyte *bytes, jint count)\n     }\n   else if (r == -1)\n     {\n+      throw_on_sock_closed (soc_impl);\n       // Some errors cause us to return end of stream...\n       if (errno == ENOTCONN)\n         return -1;"}]}