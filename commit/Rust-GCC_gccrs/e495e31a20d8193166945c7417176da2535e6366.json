{"sha": "e495e31a20d8193166945c7417176da2535e6366", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ5NWUzMWEyMGQ4MTkzMTY2OTQ1Yzc0MTcxNzZkYTI1MzVlNjM2Ng==", "commit": {"author": {"name": "Martin Sebor", "email": "msebor@redhat.com", "date": "2017-02-06T20:11:51Z"}, "committer": {"name": "Martin Sebor", "email": "msebor@gcc.gnu.org", "date": "2017-02-06T20:11:51Z"}, "message": "PR tree-optimization/ 79376 - wrong lower bound with %s and non-constant\nstrings in -Wformat-overflow\n\ngcc/ChangeLog:\n\t* gimple-fold.c (get_range_strlen): Set the minimum length to zero.\n\nFrom-SVN: r245221", "tree": {"sha": "bc768ffcdcb8e346b3fac3d979a9bd371ae07479", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bc768ffcdcb8e346b3fac3d979a9bd371ae07479"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e495e31a20d8193166945c7417176da2535e6366", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e495e31a20d8193166945c7417176da2535e6366", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e495e31a20d8193166945c7417176da2535e6366", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e495e31a20d8193166945c7417176da2535e6366/comments", "author": {"login": "msebor", "id": 381149, "node_id": "MDQ6VXNlcjM4MTE0OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/381149?v=4", "gravatar_id": "", "url": "https://api.github.com/users/msebor", "html_url": "https://github.com/msebor", "followers_url": "https://api.github.com/users/msebor/followers", "following_url": "https://api.github.com/users/msebor/following{/other_user}", "gists_url": "https://api.github.com/users/msebor/gists{/gist_id}", "starred_url": "https://api.github.com/users/msebor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/msebor/subscriptions", "organizations_url": "https://api.github.com/users/msebor/orgs", "repos_url": "https://api.github.com/users/msebor/repos", "events_url": "https://api.github.com/users/msebor/events{/privacy}", "received_events_url": "https://api.github.com/users/msebor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "98e092450153399c1c2b6db5eee6722ebfcb2957", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e092450153399c1c2b6db5eee6722ebfcb2957", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e092450153399c1c2b6db5eee6722ebfcb2957"}], "stats": {"total": 335, "additions": 333, "deletions": 2}, "files": [{"sha": "76dc97edd3507fbd6a3fbfc86804cbf0615f00ec", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e495e31a20d8193166945c7417176da2535e6366/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e495e31a20d8193166945c7417176da2535e6366/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e495e31a20d8193166945c7417176da2535e6366", "patch": "@@ -1,3 +1,8 @@\n+2017-02-06  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR  tree-optimization/79376\n+\t* gimple-fold.c (get_range_strlen): Set the minimum length to zero.\n+\n 2017-02-06  Uros Bizjak  <ubizjak@gmail.com>\n \n \t* config/i386/sse.md (vector modes -> vec_extract* splitter): Use"}, {"sha": "a75dd917fe4e22a73047f820052dda1925c194a9", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e495e31a20d8193166945c7417176da2535e6366/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e495e31a20d8193166945c7417176da2535e6366/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=e495e31a20d8193166945c7417176da2535e6366", "patch": "@@ -1244,8 +1244,9 @@ get_range_strlen (tree arg, tree length[2], bitmap *visited, int type,\n \t\treturn false;\n \t      val = fold_build2 (MINUS_EXPR, TREE_TYPE (val), val,\n \t\t\t\t integer_one_node);\n-\t      /* Avoid using the array size as the minimum.  */\n-\t      minlen = NULL;\n+\t      /* Set the minimum size to zero since the string in\n+\t\t the array could have zero length.  */\n+\t      *minlen = ssize_int (0);\n \t    }\n \t}\n "}, {"sha": "b29d283541942fd3abbe33f90621ab0fdb4881ea", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e495e31a20d8193166945c7417176da2535e6366", "patch": "@@ -1,3 +1,9 @@\n+2017-02-06  Martin Sebor  <msebor@redhat.com>\n+\n+\tPR tree-optimization/79376\n+\t* gcc.dg/tree-ssa/builtin-sprintf-warn-14.c: New test.\n+\t* gcc.dg/tree-ssa/pr79376.c: Ditto.\n+\n 2017-02-06  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/79379"}, {"sha": "dc3f132707b4943484db884f16705b549fe86a4e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/builtin-sprintf-warn-14.c", "status": "added", "additions": 210, "deletions": 0, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fbuiltin-sprintf-warn-14.c?ref=e495e31a20d8193166945c7417176da2535e6366", "patch": "@@ -0,0 +1,210 @@\n+/* PR middle-end/79376 - wrong lower bound with %s and non-constant\n+   strings in -Wformat-overflow\n+   { dg-do compile }\n+   { dg-options \"-O2 -Wall -Wformat-overflow=1 -ftrack-macro-expansion=0\" } */\n+\n+typedef __SIZE_TYPE__  size_t;\n+\n+#define INT_MAX __INT_MAX__\n+#define INT_MIN (-INT_MAX - 1)\n+\n+/* When debugging, define LINE to the line number of the test case to exercise\n+   and avoid exercising any of the others.  The buffer and objsize macros\n+   below make use of LINE to avoid warnings for other lines.  */\n+#ifndef LINE\n+# define LINE 0\n+#endif\n+\n+extern int int_value (void);\n+\n+int int_range (int min, int max)\n+{\n+  int n = int_value ();\n+  return n < min || max < n ? min : n;\n+}\n+\n+const char*\n+choose_string (const char *s1, const char *s2, const char *s3)\n+{\n+  int i = int_value ();\n+  return i < 0 ? s1 : 0 < i ? s3 : s2;\n+}\n+\n+void sink (char*, char*);\n+\n+int dummy_sprintf (char*, const char*, ...);\n+\n+char buffer [256];\n+extern char *ptr;\n+\n+const char s0[] = \"\";\n+const char s1[] = \"1\";\n+const char s2[] = \"12\";\n+const char s3[] = \"123\";\n+const char s4[] = \"1234\";\n+const char s5[] = \"12345\";\n+const char s6[] = \"123456\";\n+const char s7[] = \"1234567\";\n+const char s8[] = \"12345678\";\n+const char s9[] = \"123456789\";\n+extern const char sx[];\n+extern const char sy[];\n+\n+/* Evaluate to an array of SIZE characters when non-negative, or to\n+   a pointer to an unknown object otherwise.  */\n+#define buffer(size)\t\t\t\t\t\\\n+  ((0 <= size) ? buffer + sizeof buffer - (size) : ptr)\n+\n+/* Helper to expand function to either __builtin_f or dummy_f to\n+   make debugging GCC easy.  */\n+#define FUNC(f)\t\t\t\t\t\t\t\\\n+  ((!LINE || LINE == __LINE__) ? __builtin_ ## f : dummy_ ## f)\n+\n+/* Macro to verify that calls to __builtin_sprintf (i.e., with no size\n+   argument) issue diagnostics by correctly determining the size of\n+   the destination buffer.  */\n+#define T(size, ...)\t\t\t\t\t\t\\\n+  (FUNC (sprintf) (buffer (size),  __VA_ARGS__),\t\t\\\n+   sink (buffer, ptr))\n+\n+/* Return a value in the range [MIN, MAX].  */\n+#define R(min, max)  int_range (min, max)\n+\n+/* Return one of the strings S1, S2, S3.  */\n+#define S(s1, s2, s3) choose_string (s1, s2, s3)\n+\n+struct S {\n+  char a1[1];\n+  char a2[2];\n+  char a3[3];\n+  char a4[4];\n+  char a5[5];\n+  char ax[];\n+};\n+\n+void test_strings (struct S *s)\n+{\n+  T (0, \"%-s\", S (s->a1, s->a1, s1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s->a1, s->a2, s1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s->a2, s->a1, s1));   /* { dg-warning \"writing up to 1 byte\" } */\n+\n+  T (0, \"%-s\", S (s->a1, s1, s->a1));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s->a1, s1, s->a2));   /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s->a2, s1, s->a1));   /* { dg-warning \"writing up to 1 byte\" } */\n+\n+  T (0, \"%-s\", S (s1, s->a1, s1));      /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s1, s->a1, s1));      /* { dg-warning \"writing up to 1 byte\" } */\n+  T (0, \"%-s\", S (s1, s->a2, s1));      /* { dg-warning \"writing up to 1 byte\" } */\n+\n+  T (0, \"%-s\", S (s->a1, s->a1, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a1, s->a2, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a2, s->a1, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+\n+  T (0, \"%-s\", S (s->a1, s2, s->a1));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a1, s2, s->a2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a2, s2, s->a1));   /* { dg-warning \"writing up to 2 bytes\" } */\n+\n+  T (0, \"%-s\", S (s2, s->a1, s1));      /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s2, s->a1, s1));      /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s2, s->a2, s1));      /* { dg-warning \"writing up to 2 bytes\" } */\n+\n+  T (0, \"%-s\", S (s->a1, s->a1, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a1, s->a2, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a2, s->a1, s2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+\n+  T (0, \"%-s\", S (s->a1, s2, s->a1));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a1, s2, s->a2));   /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s->a2, s2, s->a1));   /* { dg-warning \"writing up to 2 bytes\" } */\n+\n+  T (0, \"%-s\", S (s2, s->a1, s1));      /* { dg-warning \"writing up to 2 bytes\" } */\n+  T (0, \"%-s\", S (s3, s->a1, s2));      /* { dg-warning \"writing up to 3 bytes\" } */\n+  T (0, \"%-s\", S (s4, s->a2, s3));      /* { dg-warning \"writing up to 4 bytes\" } */\n+\n+  T (0, \"%-s\", S (s->a3, s->a5, s3));   /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (0, \"%-s\", S (s->a3, s->a5, s3));   /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (0, \"%-s\", S (s->a3, s->a5, s3));   /* { dg-warning \"writing up to 4 bytes\" } */\n+\n+  T (0, \"%-s\", S (s->a3, s3, s->a5));   /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (0, \"%-s\", S (s->a5, s3, s->a3));   /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (0, \"%-s\", S (s->a3, s3, s->a5));   /* { dg-warning \"writing up to 4 bytes\" } */\n+\n+  T (0, \"%-s\", S (s3, s->a1, s4));      /* { dg-warning \"writing up to 4 bytes\" } */\n+  T (0, \"%-s\", S (s4, s->a2, s3));      /* { dg-warning \"writing up to 4 bytes\" } */\n+}\n+\n+void test_strings_with_width (struct S *s)\n+{\n+  T (0, \"%*s\",                          /* { dg-warning \"writing up to 4 bytes\" } */\n+     R (0, 1),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing up to 4 bytes\" } */\n+     R (0, 4),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing between 1 and 4 bytes\" } */\n+     R (1, 4),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing between 2 and 4 bytes\" } */\n+     R (2, 4),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing between 3 and 4 bytes\" } */\n+     R (3, 4),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing between 3 and 5 bytes\" } */\n+     R (3, 5),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*s\",                          /* { dg-warning \"writing between 3 and 9 bytes\" } */\n+     R (3, 9),\n+     S (s->a3, s->a5, s3));\n+\n+  T (3, \"%*s\",                          /* { dg-warning \"writing between 3 and 9 bytes\" } */\n+     R (3, 9),\n+     S (s->a3, s->a5, s3));\n+\n+  /* The longest string fits but the terminating nul will overflow.  Since\n+     the null won't overflow with the shorter strings the warning is a \"may\n+     write.\"  */\n+  T (4, \"%*s\",                          /* { dg-warning \"may write a terminating nul\" } */\n+     R (3, 9),\n+     S (s->a3, s->a5, s3));\n+}\n+\n+void test_strings_with_width_and_precisin (struct S *s)\n+{\n+  T (0, \"%*.*s\",                        /* { dg-warning \"writing up to 1 byte\" } */\n+     R (0, 1),\n+     R (0, 1),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*.*s\",                        /* { dg-warning \"writing up to 2 bytes\" } */\n+     R (0, 2),\n+     R (0, 1),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*.*s\",                        /* { dg-warning \"writing up to 9 bytes\" } */\n+     R (0, 9),\n+     R (0, 1),\n+     S (s->a3, s->a5, s3));\n+\n+  /* Since the longest string/array fits there is no warning even if\n+     the maximum width would cause overflow.  */\n+  T (6, \"%*.*s\",\n+     R (0, 9),\n+     R (0, 1),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*.*s\",                        /* { dg-warning \"writing up to 2 bytes\" } */\n+     R (0, 2),\n+     R (0, 2),\n+     S (s->a3, s->a5, s3));\n+\n+  T (0, \"%*.*s\",                        /* { dg-warning \"writing up to 3 bytes\" } */\n+     R (0, 3),\n+     R (0, 2),\n+     S (s->a3, s->a5, s3));\n+}"}, {"sha": "838bfe0508e373f6da8708e7c5952277ec55d11f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr79376.c", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e495e31a20d8193166945c7417176da2535e6366/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr79376.c?ref=e495e31a20d8193166945c7417176da2535e6366", "patch": "@@ -0,0 +1,109 @@\n+/* PR tree-optimization/79376 - wrong lower bound with %s and non-constant\n+   strings in -Wformat-overflow\n+   { dg-compile }\n+   { dg-options \"-O2 -fdump-tree-optimized\" } */\n+\n+#define CAT(s, n)   s ## n\n+#define FAIL(line)  CAT (failure_on_line_, line)\n+\n+/* Emit a call to a function named failure_on_line_NNN when EXPR is false.  */\n+#define ASSERT(expr)\t\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern void FAIL (__LINE__)(void);\t\t\\\n+    if (!(expr)) FAIL (__LINE__)();\t\t\\\n+  } while (0)\n+\n+#define KEEP(line)  CAT (keep_call_on_line_, line)\n+\n+/* Emit a call to a function named keep_call_on_line_NNN when EXPR is true.\n+   Used to verify that the expression need not be the only one that holds.  */\n+#define ASSERT_MAYBE(expr)\t\t\t\\\n+  do {\t\t\t\t\t\t\\\n+    extern void KEEP (__LINE__)(void);\t\t\\\n+    if (expr) KEEP (__LINE__)();\t\t\\\n+  } while (0)\n+\n+struct Arrays\n+{\n+  char a1[1];\n+  char a2[2];\n+  char a3[3];\n+  char a4[4];\n+  char a5[5];\n+  char ax[];\n+};\n+\n+void test_arrays (int i, struct Arrays *a)\n+{\n+  {\n+    const char *s = i < 0 ? a->a3 : a->a1;\n+\n+    int n = __builtin_snprintf (0, 0, \"%-s\", s);\n+\n+    ASSERT (0 <= n && n < 3);\n+\n+    ASSERT_MAYBE (0 == n);\n+    ASSERT_MAYBE (1 == n);\n+    ASSERT_MAYBE (2 == n);\n+  }\n+\n+  {\n+    const char *s = i < 0 ? a->a3 : a->a5;\n+\n+    int n = __builtin_snprintf (0, 0, \"%-s\", s);\n+\n+    ASSERT (0 <= n && n < 5);\n+\n+    ASSERT_MAYBE (0 == n);\n+    ASSERT_MAYBE (1 == n);\n+    ASSERT_MAYBE (2 == n);\n+    ASSERT_MAYBE (3 == n);\n+    ASSERT_MAYBE (4 == n);\n+  }\n+}\n+\n+void test_string_and_array (int i, struct Arrays *a)\n+{\n+  {\n+    const char *s = i < 0 ? a->a3 : \"1\";\n+\n+    int n = __builtin_snprintf (0, 0, \"%-s\", s);\n+\n+    ASSERT (0 <= n && n < 3);\n+\n+    ASSERT_MAYBE (0 == n);\n+    ASSERT_MAYBE (1 == n);\n+    ASSERT_MAYBE (2 == n);\n+  }\n+\n+  {\n+    const char *s = i < 0 ? \"12\" : a->a5;\n+\n+    int n = __builtin_snprintf (0, 0, \"%-s\", s);\n+\n+    ASSERT (0 <= n && n < 5);\n+\n+    ASSERT_MAYBE (0 == n);\n+    ASSERT_MAYBE (1 == n);\n+    ASSERT_MAYBE (2 == n);\n+    ASSERT_MAYBE (3 == n);\n+    ASSERT_MAYBE (4 == n);\n+  }\n+\n+  {\n+    const char *s = i < 0 ? a->a4 : 0 < i ? \"12\" : a->a5;\n+\n+    int n = __builtin_snprintf (0, 0, \"%-s\", s);\n+\n+    ASSERT (0 <= n && n < 5);\n+\n+    ASSERT_MAYBE (0 == n);\n+    ASSERT_MAYBE (1 == n);\n+    ASSERT_MAYBE (2 == n);\n+    ASSERT_MAYBE (3 == n);\n+    ASSERT_MAYBE (4 == n);\n+  }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"failure_on_line\" \"optimized\"} }\n+   { dg-final { scan-tree-dump-times \"keep_call_on_line\" 21 \"optimized\"} } */"}]}