{"sha": "af3eb1106883dffe6b1164070a00ad0c14df1146", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWYzZWIxMTA2ODgzZGZmZTZiMTE2NDA3MGEwMGFkMGMxNGRmMTE0Ng==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2015-03-23T05:21:04Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2015-03-23T05:21:04Z"}, "message": "re PR rtl-optimization/64317 (Ineffective allocation of PIC base register)\n\n       PR rtl-optimization/64317\n        * Makefile.in (OBJS): Add gcse-common.c\n        * gcse.c: Include gcse-common.h\n        (struct modify_pair_s): Move structure definition to gcse-common.h\n        (compute_transp): Move function to gcse-common.c.\n        (canon_list_insert): Similarly.\n        (record_last_mem_set_info): Break out some code and put it into\n        gcse-common.c.  Call into the new common code.\n        (compute_local_properties): Pass additional arguments to compute_transp.\n        * postreload-gcse.c: Include gcse-common.h and df.h\n        (modify_mem_list_set, blocks_with_calls): New variables.\n        (modify_mem_list, canon_modify_mem_list, transp): Likewise.\n        (get_bb_avail_insn): Pass in the expression index too.\n        (alloc_mem): Allocate memory for the new bitmaps and lists.\n        (free_mem): Free memory for the new bitmaps and lists.\n        (insert_expr_in_table): Record a bitmap index for each entry we\n        add to the table.\n        (record_last_mem_set_info): Call into common code in gcse-common.c.\n        (get_bb_avail_insn): If no available insn was found in the requested\n        BB.  If BB has a single predecessor, see if the expression is\n        transparent in BB and available in that single predecessor.\n        (compute_expr_transp): New wrapper for compute_transp.\n        (eliminate_partially_redundant_load): Pass expression's bitmap_index\n        to get_bb_avail_insn.  Compute next_pred_bb_end a bit later.\n        (gcse_after_reload_main): If there are elements in the hash table,\n        then compute transparency for all the elements in the hash table.\n        * gcse-common.h: New file.\n        * gcse-common.c: New file.\n\nFrom-SVN: r221585", "tree": {"sha": "ff31c846a2349895a68d8feecadffa34bf433a27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff31c846a2349895a68d8feecadffa34bf433a27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/af3eb1106883dffe6b1164070a00ad0c14df1146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3eb1106883dffe6b1164070a00ad0c14df1146", "html_url": "https://github.com/Rust-GCC/gccrs/commit/af3eb1106883dffe6b1164070a00ad0c14df1146", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/af3eb1106883dffe6b1164070a00ad0c14df1146/comments", "author": null, "committer": null, "parents": [{"sha": "4460b2dc61de31c84b9a25464eea06be0567c0db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4460b2dc61de31c84b9a25464eea06be0567c0db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4460b2dc61de31c84b9a25464eea06be0567c0db"}], "stats": {"total": 603, "additions": 424, "deletions": 179}, "files": [{"sha": "b615c1f520fe18829441c6bd34bc4b2b49bf1c9b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -1,3 +1,34 @@\n+2015-03-22  Jeff Law  <law@redhat.com>\n+\n+\tPR rtl-optimization/64317\n+\t* Makefile.in (OBJS): Add gcse-common.c\n+\t* gcse.c: Include gcse-common.h\n+\t(struct modify_pair_s): Move structure definition to gcse-common.h\n+\t(compute_transp): Move function to gcse-common.c.\n+\t(canon_list_insert): Similarly.\n+\t(record_last_mem_set_info): Break out some code and put it into\n+\tgcse-common.c.  Call into the new common code.\n+\t(compute_local_properties): Pass additional arguments to compute_transp.\n+\t* postreload-gcse.c: Include gcse-common.h and df.h\n+\t(modify_mem_list_set, blocks_with_calls): New variables.\n+\t(modify_mem_list, canon_modify_mem_list, transp): Likewise.\n+\t(get_bb_avail_insn): Pass in the expression index too.\n+\t(alloc_mem): Allocate memory for the new bitmaps and lists.\n+\t(free_mem): Free memory for the new bitmaps and lists.\n+\t(insert_expr_in_table): Record a bitmap index for each entry we\n+\tadd to the table.\n+\t(record_last_mem_set_info): Call into common code in gcse-common.c.\n+\t(get_bb_avail_insn): If no available insn was found in the requested\n+\tBB.  If BB has a single predecessor, see if the expression is\n+\ttransparent in BB and available in that single predecessor.\n+\t(compute_expr_transp): New wrapper for compute_transp.\n+\t(eliminate_partially_redundant_load): Pass expression's bitmap_index\n+\tto get_bb_avail_insn.  Compute next_pred_bb_end a bit later.\n+\t(gcse_after_reload_main): If there are elements in the hash table,\n+\tthen compute transparency for all the elements in the hash table.\n+\t* gcse-common.h: New file.\n+\t* gcse-common.c: New file.\n+\n 2015-03-22  Sandra Loosemore  <sandra@codesourcery.com>\n \n \t* doc/cpp.texi (Search Path): Hyphenate \"command-line\" when used"}, {"sha": "f924fb86f095481113e5c0b06f6f6e40a2943942", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -1235,6 +1235,7 @@ OBJS = \\\n \tfunction.o \\\n \tfwprop.o \\\n \tgcse.o \\\n+\tgcse-common.o \\\n \tggc-common.o \\\n \tgimple.o \\\n \tgimple-builder.o \\"}, {"sha": "f7cf4fbd7625146ac41e377a0c88c0bfdd4afd08", "filename": "gcc/gcse-common.c", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse-common.c?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -0,0 +1,227 @@\n+/* Shared code for before and after reload gcse implementations.\n+   Copyright (C) 1997-2015 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+\n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>. \n+\n+   It is expected that more hunks of gcse.c and postreload-gcse.c should\n+   migrate into this file.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"vec.h\"\n+#include \"predict.h\"\n+#include \"bitmap.h\"\n+#include \"basic-block.h\"\n+#include \"df.h\"\n+#include \"gcse-common.h\"\n+\n+\n+/* Record all of the canonicalized MEMs of record_last_mem_set_info's insn.\n+   Note we store a pair of elements in the list, so they have to be\n+   taken off pairwise.  */\n+\n+void\n+canon_list_insert (rtx dest, const_rtx x ATTRIBUTE_UNUSED, void *data)\n+{\n+  rtx dest_addr, insn;\n+  int bb;\n+  modify_pair pair;\n+\n+  while (GET_CODE (dest) == SUBREG\n+      || GET_CODE (dest) == ZERO_EXTRACT\n+      || GET_CODE (dest) == STRICT_LOW_PART)\n+    dest = XEXP (dest, 0);\n+\n+  /* If DEST is not a MEM, then it will not conflict with a load.  Note\n+     that function calls are assumed to clobber memory, but are handled\n+     elsewhere.  */\n+\n+  if (! MEM_P (dest))\n+    return;\n+\n+  dest_addr = get_addr (XEXP (dest, 0));\n+  dest_addr = canon_rtx (dest_addr);\n+  insn = ((struct gcse_note_stores_info *)data)->insn;\n+  bb = BLOCK_FOR_INSN (insn)->index;\n+\n+  pair.dest = dest;\n+  pair.dest_addr = dest_addr;\n+  vec<modify_pair> *canon_mem_list\n+    = ((struct gcse_note_stores_info *)data)->canon_mem_list;\n+  canon_mem_list[bb].safe_push (pair);\n+}\n+\n+/* Record memory modification information for INSN.  We do not actually care\n+   about the memory location(s) that are set, or even how they are set (consider\n+   a CALL_INSN).  We merely need to record which insns modify memory.  */\n+\n+void\n+record_last_mem_set_info_common (rtx_insn *insn,\n+\t\t\t\t vec<rtx_insn *> *modify_mem_list,\n+\t\t\t\t vec<modify_pair> *canon_modify_mem_list,\n+\t\t\t\t bitmap modify_mem_list_set,\n+\t\t\t\t bitmap blocks_with_calls)\n+\n+{\n+  int bb;\n+\n+  bb = BLOCK_FOR_INSN (insn)->index;\n+  modify_mem_list[bb].safe_push (insn);\n+  bitmap_set_bit (modify_mem_list_set, bb);\n+\n+  if (CALL_P (insn))\n+    bitmap_set_bit (blocks_with_calls, bb);\n+  else\n+    {\n+      struct gcse_note_stores_info data;\n+      data.insn = insn;\n+      data.canon_mem_list = canon_modify_mem_list;\n+      note_stores (PATTERN (insn), canon_list_insert, (void*) &data);\n+    }\n+}\n+\n+\n+/* For each block, compute whether X is transparent.  X is either an\n+   expression or an assignment [though we don't care which, for this context\n+   an assignment is treated as an expression].  For each block where an\n+   element of X is modified, reset the INDX bit in BMAP. \n+\n+   BLOCKS_WITH_CALLS indicates which blocks contain CALL_INSNs which kill\n+   memory.\n+\n+   MODIFY_MEM_LIST_SET indicates which blocks have memory stores which might\n+   kill a particular memory location.\n+\n+   CANON_MODIFY_MEM_LIST is the canonicalized list of memory locations modified\n+   for each block.  */\n+\n+void\n+compute_transp (const_rtx x, int indx, sbitmap *bmap,\n+\t\tbitmap blocks_with_calls,\n+\t\tbitmap modify_mem_list_set,\n+\t        vec<modify_pair> *canon_modify_mem_list)\n+{\n+  int i, j;\n+  enum rtx_code code;\n+  const char *fmt;\n+\n+  /* repeat is used to turn tail-recursion into iteration since GCC\n+     can't do it when there's no return value.  */\n+ repeat:\n+\n+  if (x == 0)\n+    return;\n+\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case REG:\n+\t{\n+\t  df_ref def;\n+\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n+\t       def;\n+\t       def = DF_REF_NEXT_REG (def))\n+\t    bitmap_clear_bit (bmap[DF_REF_BB (def)->index], indx);\n+\t}\n+\n+      return;\n+\n+    case MEM:\n+      if (! MEM_READONLY_P (x))\n+\t{\n+\t  bitmap_iterator bi;\n+\t  unsigned bb_index;\n+\t  rtx x_addr;\n+\n+\t  x_addr = get_addr (XEXP (x, 0));\n+\t  x_addr = canon_rtx (x_addr);\n+\n+\t  /* First handle all the blocks with calls.  We don't need to\n+\t     do any list walking for them.  */\n+\t  EXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n+\t    {\n+\t      bitmap_clear_bit (bmap[bb_index], indx);\n+\t    }\n+\n+\t  /* Now iterate over the blocks which have memory modifications\n+\t     but which do not have any calls.  */\n+\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set,\n+\t\t\t\t\t  blocks_with_calls,\n+\t\t\t\t\t  0, bb_index, bi)\n+\t    {\n+\t      vec<modify_pair> list\n+\t\t= canon_modify_mem_list[bb_index];\n+\t      modify_pair *pair;\n+\t      unsigned ix;\n+\n+\t      FOR_EACH_VEC_ELT_REVERSE (list, ix, pair)\n+\t\t{\n+\t\t  rtx dest = pair->dest;\n+\t\t  rtx dest_addr = pair->dest_addr;\n+\n+\t\t  if (canon_true_dependence (dest, GET_MODE (dest),\n+\t\t\t\t\t     dest_addr, x, x_addr))\n+\t\t    {\n+\t\t      bitmap_clear_bit (bmap[bb_index], indx);\n+\t\t      break;\n+\t\t    }\n+\t        }\n+\t    }\n+\t}\n+\n+      x = XEXP (x, 0);\n+      goto repeat;\n+\n+    case PC:\n+    case CC0: /*FIXME*/\n+    case CONST:\n+    CASE_CONST_ANY:\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+    case ADDR_VEC:\n+    case ADDR_DIFF_VEC:\n+      return;\n+\n+    default:\n+      break;\n+    }\n+\n+  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n+    {\n+      if (fmt[i] == 'e')\n+\t{\n+\t  /* If we are about to do the last recursive call\n+\t     needed at this level, change it into iteration.\n+\t     This function is called enough to be worth it.  */\n+\t  if (i == 0)\n+\t    {\n+\t      x = XEXP (x, i);\n+\t      goto repeat;\n+\t    }\n+\n+\t  compute_transp (XEXP (x, i), indx, bmap, blocks_with_calls,\n+\t\t\t  modify_mem_list_set, canon_modify_mem_list);\n+\t}\n+      else if (fmt[i] == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  compute_transp (XVECEXP (x, i, j), indx, bmap, blocks_with_calls,\n+\t\t\t  modify_mem_list_set, canon_modify_mem_list);\n+    }\n+}"}, {"sha": "a6b1a0c3bde617ee036962396da914d4ef39df26", "filename": "gcc/gcse-common.h", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse-common.h?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -0,0 +1,47 @@\n+/* Structures and prototypes common across the normal GCSE\n+   implementation and the post-reload implementation.\n+   Copyright (C) 1997-2015 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_GCSE_COMMON_H\n+#define GCC_GCSE_COMMON_H\n+\n+typedef vec<rtx_insn *> vec_rtx_heap;\n+typedef struct modify_pair_s\n+{\n+  rtx dest;                     /* A MEM.  */\n+  rtx dest_addr;                /* The canonical address of `dest'.  */\n+} modify_pair;\n+\n+typedef vec<modify_pair> vec_modify_pair_heap;\n+\n+struct gcse_note_stores_info\n+{\n+  rtx_insn *insn;\n+  vec<modify_pair> *canon_mem_list;\n+};\n+\n+extern void compute_transp (const_rtx, int, sbitmap *, bitmap,\n+\t\t\t    bitmap, vec<modify_pair> *);\n+extern void record_last_mem_set_info_common (rtx_insn *,\n+\t\t\t\t\t     vec<rtx_insn *> *,\n+\t\t\t\t\t     vec<modify_pair> *,\n+\t\t\t\t\t     bitmap, bitmap);\n+\n+\n+#endif"}, {"sha": "37aac6ae98f61062f02a7fc4370c100cbe2b5ebc", "filename": "gcc/gcse.c", "status": "modified", "additions": 9, "deletions": 170, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -189,6 +189,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"dbgcnt.h\"\n #include \"target.h\"\n #include \"gcse.h\"\n+#include \"gcse-common.h\"\n \n /* We support GCSE via Partial Redundancy Elimination.  PRE optimizations\n    are a superset of those done by classic GCSE.\n@@ -424,13 +425,6 @@ static regset reg_set_bitmap;\n static vec<rtx_insn *> *modify_mem_list;\n static bitmap modify_mem_list_set;\n \n-typedef struct modify_pair_s\n-{\n-  rtx dest;\t\t\t/* A MEM.  */\n-  rtx dest_addr;\t\t/* The canonical address of `dest'.  */\n-} modify_pair;\n-\n-\n /* This array parallels modify_mem_list, except that it stores MEMs\n    being set and their canonicalized memory addresses.  */\n static vec<modify_pair> *canon_modify_mem_list;\n@@ -507,12 +501,10 @@ static void alloc_hash_table (struct gcse_hash_table_d *);\n static void free_hash_table (struct gcse_hash_table_d *);\n static void compute_hash_table_work (struct gcse_hash_table_d *);\n static void dump_hash_table (FILE *, const char *, struct gcse_hash_table_d *);\n-static void compute_transp (const_rtx, int, sbitmap *);\n static void compute_local_properties (sbitmap *, sbitmap *, sbitmap *,\n \t\t\t\t      struct gcse_hash_table_d *);\n static void mems_conflict_for_gcse_p (rtx, const_rtx, void *);\n static int load_killed_in_block_p (const_basic_block, int, const_rtx, int);\n-static void canon_list_insert (rtx, const_rtx, void *);\n static void alloc_pre_mem (int, int);\n static void free_pre_mem (void);\n static struct edge_list *compute_pre_data (void);\n@@ -733,7 +725,10 @@ compute_local_properties (sbitmap *transp, sbitmap *comp, sbitmap *antloc,\n \t     We start by assuming all are transparent [none are killed], and\n \t     then reset the bits for those that are.  */\n \t  if (transp)\n-\t    compute_transp (expr->expr, indx, transp);\n+\t    compute_transp (expr->expr, indx, transp,\n+\t\t\t    blocks_with_calls,\n+\t\t\t    modify_mem_list_set,\n+\t\t\t    canon_modify_mem_list);\n \n \t  /* The occurrences recorded in antic_occr are exactly those that\n \t     we want to set to nonzero in ANTLOC.  */\n@@ -1489,62 +1484,20 @@ record_last_reg_set_info (rtx insn, int regno)\n     }\n }\n \n-/* Record all of the canonicalized MEMs of record_last_mem_set_info's insn.\n-   Note we store a pair of elements in the list, so they have to be\n-   taken off pairwise.  */\n-\n-static void\n-canon_list_insert (rtx dest ATTRIBUTE_UNUSED, const_rtx x ATTRIBUTE_UNUSED,\n-\t\t   void * v_insn)\n-{\n-  rtx dest_addr, insn;\n-  int bb;\n-  modify_pair pair;\n-\n-  while (GET_CODE (dest) == SUBREG\n-      || GET_CODE (dest) == ZERO_EXTRACT\n-      || GET_CODE (dest) == STRICT_LOW_PART)\n-    dest = XEXP (dest, 0);\n-\n-  /* If DEST is not a MEM, then it will not conflict with a load.  Note\n-     that function calls are assumed to clobber memory, but are handled\n-     elsewhere.  */\n-\n-  if (! MEM_P (dest))\n-    return;\n-\n-  dest_addr = get_addr (XEXP (dest, 0));\n-  dest_addr = canon_rtx (dest_addr);\n-  insn = (rtx) v_insn;\n-  bb = BLOCK_FOR_INSN (insn)->index;\n-\n-  pair.dest = dest;\n-  pair.dest_addr = dest_addr;\n-  canon_modify_mem_list[bb].safe_push (pair);\n-}\n-\n /* Record memory modification information for INSN.  We do not actually care\n    about the memory location(s) that are set, or even how they are set (consider\n    a CALL_INSN).  We merely need to record which insns modify memory.  */\n \n static void\n record_last_mem_set_info (rtx_insn *insn)\n {\n-  int bb;\n-\n   if (! flag_gcse_lm)\n     return;\n \n-  /* load_killed_in_block_p will handle the case of calls clobbering\n-     everything.  */\n-  bb = BLOCK_FOR_INSN (insn)->index;\n-  modify_mem_list[bb].safe_push (insn);\n-  bitmap_set_bit (modify_mem_list_set, bb);\n-\n-  if (CALL_P (insn))\n-    bitmap_set_bit (blocks_with_calls, bb);\n-  else\n-    note_stores (PATTERN (insn), canon_list_insert, (void*) insn);\n+  record_last_mem_set_info_common (insn, modify_mem_list,\n+\t\t\t\t   canon_modify_mem_list,\n+\t\t\t\t   modify_mem_list_set,\n+\t\t\t\t   blocks_with_calls);\n }\n \n /* Called from compute_hash_table via note_stores to handle one\n@@ -1699,120 +1652,6 @@ free_modify_mem_tables (void)\n   canon_modify_mem_list = 0;\n }\n \f\n-/* For each block, compute whether X is transparent.  X is either an\n-   expression or an assignment [though we don't care which, for this context\n-   an assignment is treated as an expression].  For each block where an\n-   element of X is modified, reset the INDX bit in BMAP.  */\n-\n-static void\n-compute_transp (const_rtx x, int indx, sbitmap *bmap)\n-{\n-  int i, j;\n-  enum rtx_code code;\n-  const char *fmt;\n-\n-  /* repeat is used to turn tail-recursion into iteration since GCC\n-     can't do it when there's no return value.  */\n- repeat:\n-\n-  if (x == 0)\n-    return;\n-\n-  code = GET_CODE (x);\n-  switch (code)\n-    {\n-    case REG:\n-\t{\n-\t  df_ref def;\n-\t  for (def = DF_REG_DEF_CHAIN (REGNO (x));\n-\t       def;\n-\t       def = DF_REF_NEXT_REG (def))\n-\t    bitmap_clear_bit (bmap[DF_REF_BB (def)->index], indx);\n-\t}\n-\n-      return;\n-\n-    case MEM:\n-      if (! MEM_READONLY_P (x))\n-\t{\n-\t  bitmap_iterator bi;\n-\t  unsigned bb_index;\n-\t  rtx x_addr;\n-\n-\t  x_addr = get_addr (XEXP (x, 0));\n-\t  x_addr = canon_rtx (x_addr);\n-\n-\t  /* First handle all the blocks with calls.  We don't need to\n-\t     do any list walking for them.  */\n-\t  EXECUTE_IF_SET_IN_BITMAP (blocks_with_calls, 0, bb_index, bi)\n-\t    {\n-\t      bitmap_clear_bit (bmap[bb_index], indx);\n-\t    }\n-\n-\t  /* Now iterate over the blocks which have memory modifications\n-\t     but which do not have any calls.  */\n-\t  EXECUTE_IF_AND_COMPL_IN_BITMAP (modify_mem_list_set,\n-\t\t\t\t\t  blocks_with_calls,\n-\t\t\t\t\t  0, bb_index, bi)\n-\t    {\n-\t      vec<modify_pair> list\n-\t\t= canon_modify_mem_list[bb_index];\n-\t      modify_pair *pair;\n-\t      unsigned ix;\n-\n-\t      FOR_EACH_VEC_ELT_REVERSE (list, ix, pair)\n-\t\t{\n-\t\t  rtx dest = pair->dest;\n-\t\t  rtx dest_addr = pair->dest_addr;\n-\n-\t\t  if (canon_true_dependence (dest, GET_MODE (dest),\n-\t\t\t\t\t     dest_addr, x, x_addr))\n-\t\t    {\n-\t\t      bitmap_clear_bit (bmap[bb_index], indx);\n-\t\t      break;\n-\t\t    }\n-\t        }\n-\t    }\n-\t}\n-\n-      x = XEXP (x, 0);\n-      goto repeat;\n-\n-    case PC:\n-    case CC0: /*FIXME*/\n-    case CONST:\n-    CASE_CONST_ANY:\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-    case ADDR_VEC:\n-    case ADDR_DIFF_VEC:\n-      return;\n-\n-    default:\n-      break;\n-    }\n-\n-  for (i = GET_RTX_LENGTH (code) - 1, fmt = GET_RTX_FORMAT (code); i >= 0; i--)\n-    {\n-      if (fmt[i] == 'e')\n-\t{\n-\t  /* If we are about to do the last recursive call\n-\t     needed at this level, change it into iteration.\n-\t     This function is called enough to be worth it.  */\n-\t  if (i == 0)\n-\t    {\n-\t      x = XEXP (x, i);\n-\t      goto repeat;\n-\t    }\n-\n-\t  compute_transp (XEXP (x, i), indx, bmap);\n-\t}\n-      else if (fmt[i] == 'E')\n-\tfor (j = 0; j < XVECLEN (x, i); j++)\n-\t  compute_transp (XVECEXP (x, i, j), indx, bmap);\n-    }\n-}\n-\f\n /* Compute PRE+LCM working variables.  */\n \n /* Local properties of expressions.  */"}, {"sha": "83048bd49108d51fe6cb81f14d5629cbcd261567", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 109, "deletions": 9, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/af3eb1106883dffe6b1164070a00ad0c14df1146/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=af3eb1106883dffe6b1164070a00ad0c14df1146", "patch": "@@ -67,6 +67,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"target.h\"\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n+#include \"df.h\"\n+#include \"gcse-common.h\"\n \n /* The following code implements gcse after reload, the purpose of this\n    pass is to cleanup redundant loads generated by reload and other\n@@ -121,6 +123,9 @@ struct expr\n   /* The same hash for this entry.  */\n   hashval_t hash;\n \n+  /* Index in the transparent bitmaps.  */\n+  unsigned int bitmap_index;\n+\n   /* List of available occurrence in basic blocks in the function.  */\n   struct occr *avail_occr;\n };\n@@ -235,6 +240,24 @@ static struct modifies_mem  *modifies_mem_obstack_bottom;\n    block, have no gaps, and only apply to real insns.  */\n static int *uid_cuid;\n #define INSN_CUID(INSN) (uid_cuid[INSN_UID (INSN)])\n+\n+/* Bitmap of blocks which have memory stores.  */\n+static bitmap modify_mem_list_set;\n+\n+/* Bitmap of blocks which have calls.  */\n+static bitmap blocks_with_calls;\n+\n+/* Vector indexed by block # with a list of all the insns that\n+   modify memory within the block.  */\n+static vec<rtx_insn *> *modify_mem_list;\n+\n+/* Vector indexed by block # with a canonicalized list of insns\n+   that modify memory in the block.  */\n+static vec<modify_pair> *canon_modify_mem_list;\n+\n+/* Vector of simple bitmaps indexed by block number.  Each component sbitmap\n+   indicates which expressions are transparent through the block.  */\n+static sbitmap *transp;\n \f\n \n /* Helpers for memory allocation/freeing.  */\n@@ -266,7 +289,7 @@ static bool reg_used_on_edge (rtx, edge);\n static rtx get_avail_load_store_reg (rtx_insn *);\n \n static bool bb_has_well_behaved_predecessors (basic_block);\n-static struct occr* get_bb_avail_insn (basic_block, struct occr *);\n+static struct occr* get_bb_avail_insn (basic_block, struct occr *, int);\n static void hash_scan_set (rtx_insn *);\n static void compute_hash_table (void);\n \n@@ -321,6 +344,15 @@ alloc_mem (void)\n   modifies_mem_obstack_bottom =\n     (struct modifies_mem *) obstack_alloc (&modifies_mem_obstack,\n \t\t\t\t\t   sizeof (struct modifies_mem));\n+\n+  blocks_with_calls = BITMAP_ALLOC (NULL);\n+  modify_mem_list_set = BITMAP_ALLOC (NULL);\n+\n+  modify_mem_list = (vec_rtx_heap *) xcalloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t\t      sizeof (vec_rtx_heap));\n+  canon_modify_mem_list\n+    = (vec_modify_pair_heap *) xcalloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t\tsizeof (vec_modify_pair_heap));\n }\n \n /* Free memory allocated by alloc_mem.  */\n@@ -338,6 +370,16 @@ free_mem (void)\n   obstack_free (&unoccr_obstack, NULL);\n   obstack_free (&modifies_mem_obstack, NULL);\n \n+  unsigned i;\n+  bitmap_iterator bi;\n+  EXECUTE_IF_SET_IN_BITMAP (modify_mem_list_set, 0, i, bi)\n+    {\n+      modify_mem_list[i].release ();\n+      canon_modify_mem_list[i].release ();\n+    }\n+\n+  BITMAP_FREE (blocks_with_calls);\n+  BITMAP_FREE (modify_mem_list_set);\n   free (reg_avail_info);\n }\n \f\n@@ -376,8 +418,15 @@ insert_expr_in_table (rtx x, rtx_insn *insn)\n   slot = expr_table->find_slot_with_hash (cur_expr, hash, INSERT);\n \n   if (! (*slot))\n-    /* The expression isn't found, so insert it.  */\n-    *slot = cur_expr;\n+    {\n+      /* The expression isn't found, so insert it.  */\n+      *slot = cur_expr;\n+\n+      /* Anytime we add an entry to the table, record the index\n+\t of the new entry.  The bitmap index starts counting\n+\t at zero.  */\n+      cur_expr->bitmap_index = expr_table->elements () - 1;\n+    }\n   else\n     {\n       /* The expression is already in the table, so roll back the\n@@ -698,6 +747,11 @@ record_last_mem_set_info (rtx_insn *insn)\n   list_entry->insn = insn;\n   list_entry->next = modifies_mem_list;\n   modifies_mem_list = list_entry;\n+\n+  record_last_mem_set_info_common (insn, modify_mem_list,\n+\t\t\t\t   canon_modify_mem_list,\n+\t\t\t\t   modify_mem_list_set,\n+\t\t\t\t   blocks_with_calls);\n }\n \n /* Called from compute_hash_table via note_stores to handle one\n@@ -955,15 +1009,45 @@ bb_has_well_behaved_predecessors (basic_block bb)\n /* Search for the occurrences of expression in BB.  */\n \n static struct occr*\n-get_bb_avail_insn (basic_block bb, struct occr *occr)\n+get_bb_avail_insn (basic_block bb, struct occr *orig_occr, int bitmap_index)\n {\n+  struct occr *occr = orig_occr;\n+\n   for (; occr != NULL; occr = occr->next)\n     if (BLOCK_FOR_INSN (occr->insn) == bb)\n       return occr;\n+\n+  /* If we could not find an occurrence in BB, see if BB\n+     has a single predecessor with an occurrence that is\n+     transparent through BB.  */\n+  if (single_pred_p (bb)\n+      && bitmap_bit_p (transp[bb->index], bitmap_index)\n+      && (occr = get_bb_avail_insn (single_pred (bb), orig_occr, bitmap_index)))\n+    {\n+      rtx avail_reg = get_avail_load_store_reg (occr->insn);\n+      if (!reg_set_between_p (avail_reg,\n+\t\t\t      PREV_INSN (BB_HEAD (bb)),\n+\t\t\t      NEXT_INSN (BB_END (bb)))\n+\t  && !reg_killed_on_edge (avail_reg, single_pred_edge (bb)))\n+\treturn occr;\n+    }\n+\n   return NULL;\n }\n \n \n+/* This helper is called via htab_traverse.  */\n+int\n+compute_expr_transp (expr **slot, FILE *dump_file ATTRIBUTE_UNUSED)\n+{\n+  struct expr *expr = *slot;\n+\n+  compute_transp (expr->expr, expr->bitmap_index, transp,\n+\t\t  blocks_with_calls, modify_mem_list_set,\n+\t\t  canon_modify_mem_list);\n+  return 1;\n+}\n+\n /* This handles the case where several stores feed a partially redundant\n    load. It checks if the redundancy elimination is possible and if it's\n    worth it.\n@@ -1016,9 +1100,13 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n       avail_insn = NULL;\n       avail_reg = NULL_RTX;\n       pred_bb = pred->src;\n-      next_pred_bb_end = NEXT_INSN (BB_END (pred_bb));\n-      for (a_occr = get_bb_avail_insn (pred_bb, expr->avail_occr); a_occr;\n-\t   a_occr = get_bb_avail_insn (pred_bb, a_occr->next))\n+      for (a_occr = get_bb_avail_insn (pred_bb,\n+\t\t\t\t       expr->avail_occr,\n+\t\t\t\t       expr->bitmap_index);\n+\t   a_occr;\n+\t   a_occr = get_bb_avail_insn (pred_bb,\n+\t\t\t\t       a_occr->next,\n+\t\t\t\t       expr->bitmap_index))\n \t{\n \t  /* Check if the loaded register is not used.  */\n \t  avail_insn = a_occr->insn;\n@@ -1038,6 +1126,7 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \t      avail_insn = NULL;\n \t      continue;\n \t    }\n+\t  next_pred_bb_end = NEXT_INSN (BB_END (BLOCK_FOR_INSN (avail_insn)));\n \t  if (!reg_set_between_p (avail_reg, avail_insn, next_pred_bb_end))\n \t    /* AVAIL_INSN remains non-null.  */\n \t    break;\n@@ -1150,9 +1239,9 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n   /* Delete the insn if it is not available in this block and mark it\n      for deletion if it is available. If insn is available it may help\n      discover additional redundancies, so mark it for later deletion.  */\n-  for (a_occr = get_bb_avail_insn (bb, expr->avail_occr);\n+  for (a_occr = get_bb_avail_insn (bb, expr->avail_occr, expr->bitmap_index);\n        a_occr && (a_occr->insn != insn);\n-       a_occr = get_bb_avail_insn (bb, a_occr->next))\n+       a_occr = get_bb_avail_insn (bb, a_occr->next, expr->bitmap_index))\n     ;\n \n   if (!a_occr)\n@@ -1308,8 +1397,19 @@ gcse_after_reload_main (rtx f ATTRIBUTE_UNUSED)\n \n   if (expr_table->elements () > 0)\n     {\n+      /* Knowing which MEMs are transparent through a block can signifiantly\n+\t increase the number of redundant loads found.  So compute transparency\n+\t information for each memory expression in the hash table.  */\n+      df_analyze ();\n+      /* This can not be part of the normal allocation routine because\n+\t we have to know the number of elements in the hash table.  */\n+      transp = sbitmap_vector_alloc (last_basic_block_for_fn (cfun),\n+\t\t\t\t     expr_table->elements ());\n+      bitmap_vector_ones (transp, last_basic_block_for_fn (cfun));\n+      expr_table->traverse <FILE *, compute_expr_transp> (dump_file);\n       eliminate_partially_redundant_loads ();\n       delete_redundant_insns ();\n+      sbitmap_vector_free (transp);\n \n       if (dump_file)\n \t{"}]}