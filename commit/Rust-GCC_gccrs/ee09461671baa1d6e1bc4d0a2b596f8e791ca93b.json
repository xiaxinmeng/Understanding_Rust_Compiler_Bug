{"sha": "ee09461671baa1d6e1bc4d0a2b596f8e791ca93b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWUwOTQ2MTY3MWJhYTFkNmUxYmM0ZDBhMmI1OTZmOGU3OTFjYTkzYg==", "commit": {"author": {"name": "Robert Dewar", "email": "dewar@adacore.com", "date": "2005-12-09T17:20:03Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:20:03Z"}, "message": "freeze.adb (Freeze_Record_Type): Only test for useless pack on record types, not on record subtypes.\n\n2005-12-05  Robert Dewar  <dewar@adacore.com>\n\n\t* freeze.adb (Freeze_Record_Type): Only test for useless pack on record\n\ttypes, not on record subtypes.\n\t(Freeze_Entity): Code cleanup. Add barrier to the loop\n\tthat generates the references for primitive operations. This allows to\n\tremove an unnecessary exception handler.\n\tCode reformatting and comment clean ups.\n\nFrom-SVN: r108296", "tree": {"sha": "2016af73f33d0ee6db5d264ae30cbdd744bedfe0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2016af73f33d0ee6db5d264ae30cbdd744bedfe0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b/comments", "author": null, "committer": null, "parents": [{"sha": "653da906036b7c3bd8c573fed889ddc151fce7c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/653da906036b7c3bd8c573fed889ddc151fce7c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/653da906036b7c3bd8c573fed889ddc151fce7c6"}], "stats": {"total": 340, "additions": 169, "deletions": 171}, "files": [{"sha": "1a12c4fb991066f93aa1649afee850a9e32795c8", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 169, "deletions": 171, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ee09461671baa1d6e1bc4d0a2b596f8e791ca93b/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=ee09461671baa1d6e1bc4d0a2b596f8e791ca93b", "patch": "@@ -207,7 +207,6 @@ package body Freeze is\n       After : in out Node_Id)\n    is\n       Body_Node : constant Node_Id := Build_Renamed_Body (Decl, New_S);\n-\n    begin\n       Insert_After (After, Body_Node);\n       Mark_Rewrite_Insertion (Body_Node);\n@@ -1554,7 +1553,6 @@ package body Freeze is\n \n          Comp := First_Entity (Rec);\n          Prev := Empty;\n-\n          while Present (Comp) loop\n \n             --  First handle the (real) component case\n@@ -1883,26 +1881,37 @@ package body Freeze is\n             Error_Msg_N (\"\\?since no component clauses were specified\", ADC);\n          end if;\n \n-         --  Check for useless pragma Pack when all components placed\n+         --  Check for useless pragma Pack when all components placed. We only\n+         --  do this check for record types, not subtypes, since a subtype may\n+         --  have all its components placed, and it still makes perfectly good\n+         --  sense to pack other subtypes or the parent type.\n \n-         if Is_Packed (Rec)\n+         if Ekind (Rec) = E_Record_Type\n+           and then Is_Packed (Rec)\n            and then not Unplaced_Component\n-           and then Warn_On_Redundant_Constructs\n          then\n-            Error_Msg_N\n-              (\"?pragma Pack has no effect, no unplaced components\",\n-               Get_Rep_Pragma (Rec, Name_Pack));\n+            --  Reset packed status. Probably not necessary, but we do it\n+            --  so that there is no chance of the back end doing something\n+            --  strange with this redundant indication of packing.\n+\n             Set_Is_Packed (Rec, False);\n+\n+            --  Give warning if redundant constructs warnings on\n+\n+            if Warn_On_Redundant_Constructs then\n+               Error_Msg_N\n+                 (\"?pragma Pack has no effect, no unplaced components\",\n+                  Get_Rep_Pragma (Rec, Name_Pack));\n+            end if;\n          end if;\n \n-         --  If this is the record corresponding to a remote type,\n-         --  freeze the remote type here since that is what we are\n-         --  semantically freezing. This prevents having the freeze\n-         --  node for that type in an inner scope.\n+         --  If this is the record corresponding to a remote type, freeze the\n+         --  remote type here since that is what we are semantically freezing.\n+         --  This prevents the freeze node for that type in an inner scope.\n \n          --  Also, Check for controlled components and unchecked unions.\n-         --  Finally, enforce the restriction that access attributes with\n-         --  a current instance prefix can only apply to limited types.\n+         --  Finally, enforce the restriction that access attributes with a\n+         --  current instance prefix can only apply to limited types.\n \n          if  Ekind (Rec) = E_Record_Type then\n             if Present (Corresponding_Remote_Type (Rec)) then\n@@ -1932,9 +1941,8 @@ package body Freeze is\n                if Has_Per_Object_Constraint (Comp)\n                  and then not Is_Limited_Type (Rec)\n                then\n-                  --  Scan component declaration for likely misuses of\n-                  --  current instance, either in a constraint or in a\n-                  --  default expression.\n+                  --  Scan component declaration for likely misuses of current\n+                  --  instance, either in a constraint or a default expression.\n \n                   Check_Current_Instance (Parent (Comp));\n                end if;\n@@ -1945,11 +1953,11 @@ package body Freeze is\n \n          Set_Component_Alignment_If_Not_Set (Rec);\n \n-         --  For first subtypes, check if there are any fixed-point\n-         --  fields with component clauses, where we must check the size.\n-         --  This is not done till the freeze point, since for fixed-point\n-         --  types, we do not know the size until the type is frozen.\n-         --  Similar processing applies to bit packed arrays.\n+         --  For first subtypes, check if there are any fixed-point fields with\n+         --  component clauses, where we must check the size. This is not done\n+         --  till the freeze point, since for fixed-point types, we do not know\n+         --  the size until the type is frozen. Similar processing applies to\n+         --  bit packed arrays.\n \n          if Is_First_Subtype (Rec) then\n             Comp := First_Component (Rec);\n@@ -2103,12 +2111,12 @@ package body Freeze is\n                if Nkind (Expr) = N_Aggregate then\n                   Expand_Atomic_Aggregate (Expr, Etype (E));\n \n-               --  If the expression is a reference to a record or array\n-               --  object entity, then reset Is_True_Constant to False so\n-               --  that the compiler will not optimize away the intermediate\n-               --  object, which we need in this case for the same reason\n-               --  (to ensure that the actual assignment is atomic, rather\n-               --  than component-wise).\n+               --  If the expression is a reference to a record or array object\n+               --  entity, then reset Is_True_Constant to False so that the\n+               --  compiler will not optimize away the intermediate object,\n+               --  which we need in this case for the same reason (to ensure\n+               --  that the actual assignment is atomic, rather than\n+               --  component-wise).\n \n                elsif Is_Entity_Name (Expr)\n                  and then (Is_Record_Type (Etype (Expr))\n@@ -2854,23 +2862,21 @@ package body Freeze is\n                Next_Entity (Comp);\n             end loop;\n \n-         --  Private types are required to point to the same freeze node\n-         --  as their corresponding full views. The freeze node itself\n-         --  has to point to the partial view of the entity (because\n-         --  from the partial view, we can retrieve the full view, but\n-         --  not the reverse). However, in order to freeze correctly,\n-         --  we need to freeze the full view. If we are freezing at the\n-         --  end of a scope (or within the scope of the private type),\n-         --  the partial and full views will have been swapped, the\n-         --  full view appears first in the entity chain and the swapping\n-         --  mechanism ensures that the pointers are properly set (on\n-         --  scope exit).\n-\n-         --  If we encounter the partial view before the full view\n-         --  (e.g. when freezing from another scope), we freeze the\n-         --  full view, and then set the pointers appropriately since\n-         --  we cannot rely on swapping to fix things up (subtypes in an\n-         --  outer scope might not get swapped).\n+         --  Private types are required to point to the same freeze node as\n+         --  their corresponding full views. The freeze node itself has to\n+         --  point to the partial view of the entity (because from the partial\n+         --  view, we can retrieve the full view, but not the reverse).\n+         --  However, in order to freeze correctly, we need to freeze the full\n+         --  view. If we are freezing at the end of a scope (or within the\n+         --  scope of the private type), the partial and full views will have\n+         --  been swapped, the full view appears first in the entity chain and\n+         --  the swapping mechanism ensures that the pointers are properly set\n+         --  (on scope exit).\n+\n+         --  If we encounter the partial view before the full view (e.g. when\n+         --  freezing from another scope), we freeze the full view, and then\n+         --  set the pointers appropriately since we cannot rely on swapping to\n+         --  fix things up (subtypes in an outer scope might not get swapped).\n \n          elsif Is_Incomplete_Or_Private_Type (E)\n            and then not Is_Generic_Type (E)\n@@ -2879,18 +2885,17 @@ package body Freeze is\n \n             if Present (Full_View (E)) then\n \n-               --  If full view has already been frozen, then no\n-               --  further processing is required\n+               --  If full view has already been frozen, then no further\n+               --  processing is required\n \n                if Is_Frozen (Full_View (E)) then\n \n                   Set_Has_Delayed_Freeze (E, False);\n                   Set_Freeze_Node (E, Empty);\n                   Check_Debug_Info_Needed (E);\n \n-               --  Otherwise freeze full view and patch the pointers\n-               --  so that the freeze node will elaborate both views\n-               --  in the back-end.\n+               --  Otherwise freeze full view and patch the pointers so that\n+               --  the freeze node will elaborate both views in the back-end.\n \n                else\n                   declare\n@@ -2926,11 +2931,11 @@ package body Freeze is\n                   Check_Debug_Info_Needed (E);\n                end if;\n \n-               --  AI-117 requires that the convention of a partial view\n-               --  be the same as the convention of the full view. Note\n-               --  that this is a recognized breach of privacy, but it's\n-               --  essential for logical consistency of representation,\n-               --  and the lack of a rule in RM95 was an oversight.\n+               --  AI-117 requires that the convention of a partial view be the\n+               --  same as the convention of the full view. Note that this is a\n+               --  recognized breach of privacy, but it's essential for logical\n+               --  consistency of representation, and the lack of a rule in\n+               --  RM95 was an oversight.\n \n                Set_Convention (E, Convention (Full_View (E)));\n \n@@ -2940,10 +2945,10 @@ package body Freeze is\n                --  Size information is copied from the full view to the\n                --  incomplete or private view for consistency\n \n-               --  We skip this is the full view is not a type. This is\n-               --  very strange of course, and can only happen as a result\n-               --  of certain illegalities, such as a premature attempt to\n-               --  derive from an incomplete type.\n+               --  We skip this is the full view is not a type. This is very\n+               --  strange of course, and can only happen as a result of\n+               --  certain illegalities, such as a premature attempt to derive\n+               --  from an incomplete type.\n \n                if Is_Type (Full_View (E)) then\n                   Set_Size_Info (E, Full_View (E));\n@@ -3003,9 +3008,9 @@ package body Freeze is\n                  (\"(Ada 2005): invalid use of tagged incomplete type\", E);\n             end if;\n \n-         --  For access to a protected subprogram, freeze the equivalent\n-         --  type (however this is not set if we are not generating code\n-         --  or if this is an anonymous type used just for resolution).\n+         --  For access to a protected subprogram, freeze the equivalent type\n+         --  (however this is not set if we are not generating code or if this\n+         --  is an anonymous type used just for resolution).\n \n          elsif Ekind (E) = E_Access_Protected_Subprogram_Type then\n \n@@ -3053,9 +3058,9 @@ package body Freeze is\n          if Is_Fixed_Point_Type (E) then\n             Freeze_Fixed_Point_Type (E);\n \n-            --  Some error checks required for ordinary fixed-point type.\n-            --  Defer these till the freeze-point since we need the small\n-            --  and range values. We only do these checks for base types\n+            --  Some error checks required for ordinary fixed-point type. Defer\n+            --  these till the freeze-point since we need the small and range\n+            --  values. We only do these checks for base types\n \n             if Is_Ordinary_Fixed_Point_Type (E)\n               and then E = Base_Type (E)\n@@ -3117,13 +3122,13 @@ package body Freeze is\n             --  inherit the convention of the full view of the type. Inherited\n             --  and overriding operations are defined to inherit the convention\n             --  of their parent or overridden subprogram (also specified in\n-            --  AI-117), and that will have occurred earlier (in\n-            --  Derive_Subprogram and New_Overloaded_Entity). Here we set the\n-            --  convention of primitives that are still convention Ada, which\n-            --  will ensure that any new primitives inherit the type's\n-            --  convention. Class-wide types can have a foreign convention\n-            --  inherited from their specific type, but are excluded from this\n-            --  since they don't have any associated primitives.\n+            --  AI-117), which will have occurred earlier (in Derive_Subprogram\n+            --  and New_Overloaded_Entity). Here we set the convention of\n+            --  primitives that are still convention Ada, which will ensure\n+            --  that any new primitives inherit the type's convention.\n+            --  Class-wide types can have a foreign convention inherited from\n+            --  their specific type, but are excluded from this since they\n+            --  don't have any associated primitives.\n \n             if Is_Tagged_Type (E)\n               and then not Is_Class_Wide_Type (E)\n@@ -3178,35 +3183,30 @@ package body Freeze is\n \n                --  Loop to generate references for primitive operations\n \n-               Prim := First_Elmt (Prim_List);\n-               while Present (Prim) loop\n-                  Ent := Node (Prim);\n-\n-                  --  If the operation is derived, get the original for cross-\n-                  --  reference purposes (it is the original for which we want\n-                  --  the xref, and for which the comes from source test needs\n-                  --  to be performed).\n-\n-                  while Present (Alias (Ent)) loop\n-                     Ent := Alias (Ent);\n-                  end loop;\n+               if Present (Prim_List) then\n+                  Prim := First_Elmt (Prim_List);\n+                  while Present (Prim) loop\n \n-                  Generate_Reference (E, Ent, 'p', Set_Ref => False);\n-                  Next_Elmt (Prim);\n-               end loop;\n+                     --  If the operation is derived, get the original for\n+                     --  cross-reference purposes (it is the original for\n+                     --  which we want the xref, and for which the comes\n+                     --  from source test needs to be performed).\n \n-            --  If we get an exception, then something peculiar has happened\n-            --  probably as a result of a previous error. Since this is only\n-            --  for non-critical cross-references, ignore the error.\n+                     Ent := Node (Prim);\n+                     while Present (Alias (Ent)) loop\n+                        Ent := Alias (Ent);\n+                     end loop;\n \n-            exception\n-               when others => null;\n+                     Generate_Reference (E, Ent, 'p', Set_Ref => False);\n+                     Next_Elmt (Prim);\n+                  end loop;\n+               end if;\n             end;\n          end if;\n \n-         --  Now that all types from which E may depend are frozen, see\n-         --  if the size is known at compile time, if it must be unsigned,\n-         --  or if strict alignent is required\n+         --  Now that all types from which E may depend are frozen, see if the\n+         --  size is known at compile time, if it must be unsigned, or if\n+         --  strict alignent is required\n \n          Check_Compile_Time_Size (E);\n          Check_Unsigned_Type (E);\n@@ -3509,11 +3509,11 @@ package body Freeze is\n \n       --  For an allocator freeze designated type if not frozen already\n \n-      --  For an aggregate whose component type is an access type, freeze\n-      --  the designated type now, so that its freeze  does not appear within\n-      --  the loop that might be created in the expansion of the aggregate.\n-      --  If the designated type is a private type without full view, the\n-      --  expression cannot contain an allocator, so the type is not frozen.\n+      --  For an aggregate whose component type is an access type, freeze the\n+      --  designated type now, so that its freeze does not appear within the\n+      --  loop that might be created in the expansion of the aggregate. If the\n+      --  designated type is a private type without full view, the expression\n+      --  cannot contain an allocator, so the type is not frozen.\n \n       Desig_Typ := Empty;\n \n@@ -3567,11 +3567,11 @@ package body Freeze is\n       loop\n          Parent_P := Parent (P);\n \n-         --  If we don't have a parent, then we are not in a well-formed\n-         --  tree. This is an unusual case, but there are some legitimate\n-         --  situations in which this occurs, notably when the expressions\n-         --  in the range of a type declaration are resolved. We simply\n-         --  ignore the freeze request in this case. Is this right ???\n+         --  If we don't have a parent, then we are not in a well-formed tree.\n+         --  This is an unusual case, but there are some legitimate situations\n+         --  in which this occurs, notably when the expressions in the range of\n+         --  a type declaration are resolved. We simply ignore the freeze\n+         --  request in this case. Is this right ???\n \n          if No (Parent_P) then\n             return;\n@@ -3636,9 +3636,9 @@ package body Freeze is\n                   then\n                      return;\n \n-                  --  If enumeration literal appears as the name of a\n-                  --  function which is the choice, then also do not freeze.\n-                  --  This happens in the overloaded literal case, where the\n+                  --  If enumeration literal appears as the name of function\n+                  --  which is the choice, then also do not freeze. This\n+                  --  happens in the overloaded literal case, where the\n                   --  enumeration literal is temporarily changed to a function\n                   --  call for overloading analysis purposes.\n \n@@ -3710,9 +3710,9 @@ package body Freeze is\n                   exit;\n                end if;\n \n-            --  If parent is a body or a spec or a block, then the current\n-            --  node is a statement or declaration and we can insert the\n-            --  freeze node before it.\n+            --  If parent is a body or a spec or a block, then the current node\n+            --  is a statement or declaration and we can insert the freeze node\n+            --  before it.\n \n             when N_Package_Specification |\n                  N_Package_Body          |\n@@ -3746,9 +3746,9 @@ package body Freeze is\n             --  appears in the source can never be frozen in a loop (this\n             --  occurs only because of a loop expanded by the expander), so we\n             --  keep on going. Otherwise we terminate the search. Same is true\n-            --  of any entity which comes from source. (if they have a\n-            --  predefined type, that type does not appear to come from source,\n-            --  but the entity should not be frozen here).\n+            --  of any entity which comes from source. (if they have predefined\n+            --  type, that type does not appear to come from source, but the\n+            --  entity should not be frozen here).\n \n             when N_Loop_Statement =>\n                exit when not Comes_From_Source (Etype (N))\n@@ -3779,14 +3779,14 @@ package body Freeze is\n       --  the outer record type so they can eventually be placed in the\n       --  enclosing declaration list.\n \n-      --  The other case requiring this special handling is if we are in\n-      --  a default expression, since in that case we are about to freeze\n-      --  a static type, and the freeze scope needs to be the outer scope,\n-      --  not the scope of the subprogram with the default parameter.\n+      --  The other case requiring this special handling is if we are in a\n+      --  default expression, since in that case we are about to freeze a\n+      --  static type, and the freeze scope needs to be the outer scope, not\n+      --  the scope of the subprogram with the default parameter.\n \n       --  For default expressions in generic units, the Move_Freeze_Nodes\n-      --  mechanism (see sem_ch12.adb) takes care of placing them at the\n-      --  proper place, after the generic unit.\n+      --  mechanism (see sem_ch12.adb) takes care of placing them at the proper\n+      --  place, after the generic unit.\n \n       if (In_Def_Exp and not Inside_A_Generic)\n         or else Freeze_Outside\n@@ -3837,13 +3837,12 @@ package body Freeze is\n \n       --  Now we have the right place to do the freezing. First, a special\n       --  adjustment, if we are in default expression analysis mode, these\n-      --  freeze actions must not be thrown away (normally all inserted\n-      --  actions are thrown away in this mode. However, the freeze actions\n-      --  are from static expressions and one of the important reasons we\n-      --  are doing this special analysis is to get these freeze actions.\n-      --  Therefore we turn off the In_Default_Expression mode to propagate\n-      --  these freeze actions. This also means they get properly analyzed\n-      --  and expanded.\n+      --  freeze actions must not be thrown away (normally all inserted actions\n+      --  are thrown away in this mode. However, the freeze actions are from\n+      --  static expressions and one of the important reasons we are doing this\n+      --  special analysis is to get these freeze actions. Therefore we turn\n+      --  off the In_Default_Expression mode to propagate these freeze actions.\n+      --  This also means they get properly analyzed and expanded.\n \n       In_Default_Expression := False;\n \n@@ -3928,9 +3927,9 @@ package body Freeze is\n          end if;\n       end if;\n \n-      --  Immediate return if the range is already analyzed. This means\n-      --  that the range is already set, and does not need to be computed\n-      --  by this routine.\n+      --  Immediate return if the range is already analyzed. This means that\n+      --  the range is already set, and does not need to be computed by this\n+      --  routine.\n \n       if Analyzed (Rng) then\n          return;\n@@ -3952,16 +3951,16 @@ package body Freeze is\n       if Is_Ordinary_Fixed_Point_Type (Typ) then\n \n          --  For the ordinary fixed-point case, we are allowed to fudge the\n-         --  end-points up or down by small. Generally we prefer to fudge\n-         --  up, i.e. widen the bounds for non-model numbers so that the\n-         --  end points are included. However there are cases in which this\n-         --  cannot be done, and indeed cases in which we may need to narrow\n-         --  the bounds. The following circuit makes the decision.\n+         --  end-points up or down by small. Generally we prefer to fudge up,\n+         --  i.e. widen the bounds for non-model numbers so that the end points\n+         --  are included. However there are cases in which this cannot be\n+         --  done, and indeed cases in which we may need to narrow the bounds.\n+         --  The following circuit makes the decision.\n \n-         --  Note: our terminology here is that Incl_EP means that the\n-         --  bounds are widened by Small if necessary to include the end\n-         --  points, and Excl_EP means that the bounds are narrowed by\n-         --  Small to exclude the end-points if this reduces the size.\n+         --  Note: our terminology here is that Incl_EP means that the bounds\n+         --  are widened by Small if necessary to include the end points, and\n+         --  Excl_EP means that the bounds are narrowed by Small to exclude the\n+         --  end-points if this reduces the size.\n \n          --  Note that in the Incl case, all we care about is including the\n          --  end-points. In the Excl case, we want to narrow the bounds as\n@@ -4045,11 +4044,11 @@ package body Freeze is\n                Hival_Excl_EP := Hival_Incl_EP;\n             end if;\n \n-            --  One further adjustment is needed. In the case of subtypes,\n-            --  we cannot go outside the range of the base type, or we get\n+            --  One further adjustment is needed. In the case of subtypes, we\n+            --  cannot go outside the range of the base type, or we get\n             --  peculiarities, and the base type range is already set. This\n-            --  only applies to the Incl values, since clearly the Excl\n-            --  values are already as restricted as they are allowed to be.\n+            --  only applies to the Incl values, since clearly the Excl values\n+            --  are already as restricted as they are allowed to be.\n \n             if Typ /= Btyp then\n                Loval_Incl_EP := UR_Max (Loval_Incl_EP, Realval (BLo));\n@@ -4334,10 +4333,10 @@ package body Freeze is\n       --  static. This happens if the type depends on non-global objects.\n \n       procedure Ensure_Expression_Is_SA (N : Node_Id);\n-      --  Called to ensure that an expression used as part of a type\n-      --  definition is statically allocatable, which means that the type\n-      --  of the expression is statically allocatable, and the expression\n-      --  is either static, or a reference to a library level constant.\n+      --  Called to ensure that an expression used as part of a type definition\n+      --  is statically allocatable, which means that the expression type is\n+      --  statically allocatable, and the expression is either static, or a\n+      --  reference to a library level constant.\n \n       procedure Ensure_Type_Is_SA (Typ : Entity_Id);\n       --  Called to mark a type as static, checking that it is possible\n@@ -4386,8 +4385,8 @@ package body Freeze is\n             return;\n          end if;\n \n-         --  We are also OK if the type is already marked as statically\n-         --  allocated, which means we processed it before.\n+         --  We are also OK if the type already marked as statically allocated,\n+         --  which means we processed it before.\n \n          if Is_Statically_Allocated (Typ) then\n             return;\n@@ -4521,10 +4520,10 @@ package body Freeze is\n \n       --  Reset the Pure indication on an imported subprogram unless an\n       --  explicit Pure_Function pragma was present. We do this because\n-      --  otherwise it is an insidious error to call a non-pure function\n-      --  from pure unit and have calls mysteriously optimized away. What\n-      --  happens here is that the Import can bypass the normal check to\n-      --  ensure that pure units call only pure subprograms.\n+      --  otherwise it is an insidious error to call a non-pure function from\n+      --  pure unit and have calls mysteriously optimized away. What happens\n+      --  here is that the Import can bypass the normal check to ensure that\n+      --  pure units call only pure subprograms.\n \n       if Is_Imported (E)\n         and then Is_Pure (E)\n@@ -4659,8 +4658,8 @@ package body Freeze is\n       elsif Is_Record_Type (T)\n         and not Is_Private_Type (T)\n       then\n-         --  Verify that the record type has no components with\n-         --  private types without completion.\n+         --  Verify that the record type has no components with private types\n+         --  without completion.\n \n          declare\n             Comp : Entity_Id;\n@@ -4700,10 +4699,10 @@ package body Freeze is\n    begin\n       Set_Default_Expressions_Processed (E);\n \n-      --  A subprogram instance and its associated anonymous subprogram\n-      --  share their signature. The default expression functions are defined\n-      --  in the wrapper packages for the anonymous subprogram, and should\n-      --  not be generated again for the instance.\n+      --  A subprogram instance and its associated anonymous subprogram share\n+      --  their signature. The default expression functions are defined in the\n+      --  wrapper packages for the anonymous subprogram, and should not be\n+      --  generated again for the instance.\n \n       if Is_Generic_Instance (E)\n         and then Present (Alias (E))\n@@ -4743,11 +4742,10 @@ package body Freeze is\n             then\n \n                --  If there is no default function, we must still do a full\n-               --  analyze call on the default value, to ensure that all\n-               --  error checks are performed, e.g. those associated with\n-               --  static evaluation. Note that this branch will always be\n-               --  taken if the analyzer is turned off (but we still need the\n-               --  error checks).\n+               --  analyze call on the default value, to ensure that all error\n+               --  checks are performed, e.g. those associated with static\n+               --  evaluation. Note: this branch will always be taken if the\n+               --  analyzer is turned off (but we still need the error checks).\n \n                --  Note: the setting of parent here is to meet the requirement\n                --  that we can only analyze the expression while attached to\n@@ -4927,13 +4925,13 @@ package body Freeze is\n       --  Full_View or Corresponding_Record_Type to have one either.\n \n       --  ??? Fundamentally, this whole handling is a kludge. What we really\n-      --  want is to be sure that for an Itype that's part of record R and is\n-      --  a subtype of type T, that it's frozen after the later of the freeze\n+      --  want is to be sure that for an Itype that's part of record R and is a\n+      --  subtype of type T, that it's frozen after the later of the freeze\n       --  points of R and T. We have no way of doing that directly, so what we\n       --  do is force most such Itypes to be frozen as part of freezing R via\n       --  this procedure and only delay the ones that need to be delayed\n-      --  (mostly the designated types of access types that are defined as\n-      --  part of the record).\n+      --  (mostly the designated types of access types that are defined as part\n+      --  of the record).\n \n       if Is_Private_Type (T)\n         and then Present (Full_View (T))\n@@ -5013,9 +5011,9 @@ package body Freeze is\n                return;\n             end if;\n \n-         --  A function call (most likely to To_Address) is probably not\n-         --  an overlay, so skip warning. Ditto if the function call was\n-         --  inlined and transformed into an entity.\n+         --  A function call (most likely to To_Address) is probably not an\n+         --  overlay, so skip warning. Ditto if the function call was inlined\n+         --  and transformed into an entity.\n \n          elsif Nkind (Original_Node (Expr)) = N_Function_Call then\n             return;"}]}