{"sha": "83e03963466636419bccb8b08997164e93c1790b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNlMDM5NjM0NjY2MzY0MTliY2NiOGIwODk5NzE2NGU5M2MxNzkwYg==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-04-09T10:02:35Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-04-09T10:02:35Z"}, "message": "gfortran.texi (KIND Type Parameters, [...]): Add crossrefs.\n\n2013-04-09  Tobias Burnus  <burnus@net-b.de>\n\n        * gfortran.texi (KIND Type Parameters,\n        Internal representation of LOGICAL variables): Add crossrefs.\n        (Intrinsic Types): Mention issues with _Bool interop.\n        (Naming and argument-passing conventions): New section.\n\nFrom-SVN: r197624", "tree": {"sha": "da549aeb47bddad19106c82a8c1020a1847e2887", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da549aeb47bddad19106c82a8c1020a1847e2887"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83e03963466636419bccb8b08997164e93c1790b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e03963466636419bccb8b08997164e93c1790b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83e03963466636419bccb8b08997164e93c1790b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83e03963466636419bccb8b08997164e93c1790b/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "343881fd9eb2b7e8f90ac10cd17688b3dcce3186", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/343881fd9eb2b7e8f90ac10cd17688b3dcce3186", "html_url": "https://github.com/Rust-GCC/gccrs/commit/343881fd9eb2b7e8f90ac10cd17688b3dcce3186"}], "stats": {"total": 170, "additions": 159, "deletions": 11}, "files": [{"sha": "6a5702f136e89dd5dc7f70108bb580dcadb31d40", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e03963466636419bccb8b08997164e93c1790b/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e03963466636419bccb8b08997164e93c1790b/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=83e03963466636419bccb8b08997164e93c1790b", "patch": "@@ -1,3 +1,10 @@\n+2013-04-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* gfortran.texi (KIND Type Parameters,\n+\tInternal representation of LOGICAL variables): Add crossrefs.\n+\t(Intrinsic Types): Mention issues with _Bool interop.\n+\t(Naming and argument-passing conventions): New section.\n+\n 2013-04-08  Thomas Koenig  <tkoenig@gcc.gnu.org>\n \n \tPR fortran/56782"}, {"sha": "61cb3bb9746e8dda41d653bd3e756bb4c09e2b15", "filename": "gcc/fortran/gfortran.texi", "status": "modified", "additions": 152, "deletions": 11, "changes": 163, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83e03963466636419bccb8b08997164e93c1790b/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83e03963466636419bccb8b08997164e93c1790b/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=83e03963466636419bccb8b08997164e93c1790b", "patch": "@@ -1166,7 +1166,8 @@ parameters of the @code{ISO_FORTRAN_ENV} module instead of the concrete values.\n The available kind parameters can be found in the constant arrays\n @code{CHARACTER_KINDS}, @code{INTEGER_KINDS}, @code{LOGICAL_KINDS} and\n @code{REAL_KINDS} in the @code{ISO_FORTRAN_ENV} module\n-(see @ref{ISO_FORTRAN_ENV}).\n+(see @ref{ISO_FORTRAN_ENV}).  For C interoperability, the kind parameters of\n+the @code{ISO_C_BINDING} module should be used (see @ref{ISO_C_BINDING}).\n \n \n @node Internal representation of LOGICAL variables\n@@ -1184,16 +1185,7 @@ A @code{LOGICAL(KIND=N)} variable is represented as an\n values: @code{1} for @code{.TRUE.} and @code{0} for\n @code{.FALSE.}.  Any other integer value results in undefined behavior.\n \n-Note that for mixed-language programming using the\n-@code{ISO_C_BINDING} feature, there is a @code{C_BOOL} kind that can\n-be used to create @code{LOGICAL(KIND=C_BOOL)} variables which are\n-interoperable with the C99 _Bool type.  The C99 _Bool type has an\n-internal representation described in the C99 standard, which is\n-identical to the above description, i.e. with 1 for true and 0 for\n-false being the only permissible values.  Thus the internal\n-representation of @code{LOGICAL} variables in GNU Fortran is identical\n-to C99 _Bool, except for a possible difference in storage size\n-depending on the kind.\n+See also @ref{Argument passing conventions} and @ref{Interoperability with C}.\n \n \n @node Thread-safety of the runtime library\n@@ -2204,6 +2196,7 @@ common, but not the former.\n * Interoperability with C::\n * GNU Fortran Compiler Directives::\n * Non-Fortran Main Program::\n+* Naming and argument-passing conventions::\n @end menu\n \n This chapter is about mixed-language interoperability, but also applies\n@@ -2250,6 +2243,16 @@ in C and Fortran, the named constants shall be used which are defined in the\n for kind parameters and character named constants for the escape sequences\n in C.  For a list of the constants, see @ref{ISO_C_BINDING}.\n \n+For logical types, please note that the Fortran standard only guarantees\n+interoperability between C99's @code{_Bool} and Fortran's @code{C_Bool}-kind\n+logicals and C99 defines that @code{true} has the value 1 and @code{false}\n+the value 0.  Using any other integer value with GNU Fortran's @code{LOGICAL}\n+(with any kind parameter) gives an undefined result.  (Passing other integer\n+values than 0 and 1 to GCC's @code{_Bool} is also undefined, unless the\n+integer is explicitly or implicitly casted to @code{_Bool}.)\n+\n+\n+\n @node Derived Types and struct\n @subsection Derived Types and struct\n \n@@ -2975,6 +2978,144 @@ int main (int argc, char *argv[])\n @end table\n \n \n+@node Naming and argument-passing conventions\n+@section Naming and argument-passing conventions\n+\n+This section gives an overview about the naming convention of procedures\n+and global variables and about the argument passing conventions used by\n+GNU Fortran.  If a C binding has been specified, the naming convention\n+and some of the argument-passing conventions change.  If possible,\n+mixed-language and mixed-compiler projects should use the better defined\n+C binding for interoperability.  See @pxref{Interoperability with C}.\n+\n+@menu\n+* Naming conventions::\n+* Argument passing conventions::\n+@end menu\n+\n+\n+@node Naming conventions\n+@subsection Naming conventions\n+\n+According the Fortran standard, valid Fortran names consist of a letter\n+between @code{A} to @code{Z}, @code{a} to @code{z}, digits @code{0},\n+@code{1} to @code{9} and underscores (@code{_}) with the restriction\n+that names may only start with a letter.  As vendor extension, the\n+dollar sign (@code{$}) is additionally permitted with the option\n+@option{-fdollar-ok}, but not as first character and only if the\n+target system supports it.\n+\n+By default, the procedure name is the lower-cased Fortran name with an\n+appended underscore (@code{_}); using @option{-fno-underscoring} no\n+underscore is appended while @code{-fsecond-underscore} appends two\n+underscores.  Depending on the target system and the calling convention,\n+the procedure might be additionally dressed; for instance, on 32bit\n+Windows with @code{stdcall}, an at-sign @code{@@} followed by an integer\n+number is appended.  For the changing the calling convention, see\n+@pxref{GNU Fortran Compiler Directives}.\n+\n+For common blocks, the same convention is used, i.e. by default an\n+underscore is appended to the lower-cased Fortran name.  Blank commons\n+have the name @code{__BLNK__}.\n+\n+For procedures and variables declared in the specification space of a\n+module, the name is formed by @code{__}, followed by the lower-cased\n+module name, @code{_MOD_}, and the lower-cased Fortran name.  Note that\n+no underscore is appended.\n+\n+\n+@node Argument passing conventions\n+@subsection Argument passing conventions\n+\n+Subroutines do not return a value (matching C99's @code{void}) while\n+functions either return a value as specified in the platform ABI or\n+the result variable is passed as hidden argument to the function and\n+no result is returned.  A hidden result variable is used when the\n+result variable is an array or of type @code{CHARACTER}.\n+\n+Arguments are passed according to the platform ABI. In particular,\n+complex arguments might not be compatible to a struct with two real\n+components for the real and imaginary part. The argument passing\n+matches the one of C99's @code{_Complex}.  Functions with scalar\n+complex result variables return their value and do not use a\n+by-reference argument.  Note that with the @option{-ff2c} option,\n+the argument passing is modified and no longer completely matches\n+the platform ABI.  Some other Fortran compilers use @code{f2c}\n+semantic by default; this might cause problems with\n+interoperablility. \n+\n+GNU Fortran passes most arguments by reference, i.e. by passing a\n+pointer to the data.  Note that the compiler might use a temporary\n+variable into which the actual argument has been copied, if required\n+semantically (copy-in/copy-out).\n+\n+For arguments with @code{ALLOCATABLE} and @code{POINTER}\n+attribute (including procedure pointers), a pointer to the pointer\n+is passed such that the pointer address can be modified in the\n+procedure.\n+\n+For dummy arguments with the @code{VALUE} attribute: Scalar arguments\n+of the type @code{INTEGER}, @code{LOGICAL}, @code{REAL} and\n+@code{COMPLEX} are passed by value according to the platform ABI.\n+(As vendor extension and not recommended, using @code{%VAL()} in the\n+call to a procedure has the same effect.) For @code{TYPE(C_PTR)} and\n+procedure pointers, the pointer itself is passed such that it can be\n+modified without affecting the caller.\n+@c FIXME: Document how VALUE is handled for CHARACTER, TYPE,\n+@c CLASS and arrays, i.e. whether the copy-in is done in the caller\n+@c or in the callee.\n+\n+For Boolean (@code{LOGICAL}) arguments, please note that GCC expects\n+only the integer value 0 and 1.  If a GNU Fortran @code{LOGICAL}\n+variable contains another integer value, the result is undefined.\n+As some other Fortran compilers use @math{-1} for @code{.TRUE.},\n+extra care has to be taken -- such as passing the value as\n+@code{INTEGER}.  (The same value restriction also applies to other\n+front ends of GCC, e.g. to GCC's C99 compiler for @code{_Bool}\n+or GCC's Ada compiler for @code{Boolean}.)\n+\n+For arguments of @code{CHARACTER} type, the character length is passed\n+as hidden argument.  For deferred-length strings, the value is passed\n+by reference, otherwise by value.  The character length has the type\n+@code{INTEGER(kind=4)}.  Note with C binding, @code{CHARACTER(len=1)}\n+result variables are returned according to the platform ABI and no\n+hidden length argument is used for dummy arguments; with @code{VALUE},\n+those variables are passed by value.\n+\n+For @code{OPTIONAL} dummy arguments, an absent argument is denoted\n+by a NULL pointer, except for scalar dummy arguments of type\n+@code{INTEGER}, @code{LOGICAL}, @code{REAL} and @code{COMPLEX}\n+which have the @code{VALUE} attribute.  For those, a hidden Boolean\n+argument (@code{logical(kind=C_bool),value}) is used to indicate\n+whether the argument is present.\n+\n+Arguments which are assumed-shape, assumed-rank or deferred-rank\n+arrays or, with @option{-fcoarray=lib}, allocatable scalar coarrays use\n+an array descriptor.  All other arrays pass the address of the\n+first element of the array.  With @option{-fcoarray=lib}, the token\n+and the offset belonging to nonallocatable coarrays dummy arguments\n+are passed as hidden argument along the character length hidden\n+arguments.  The token is an oparque pointer identifying the coarray\n+and the offset is a passed-by-value integer of kind @code{C_PTRDIFF_T},\n+denoting the byte offset between the base address of the coarray and\n+the passed scalar or first element of the passed array.\n+\n+The arguments are passed in the following order\n+@itemize @bullet\n+@item Result variable, when the function result is passed by reference\n+@item Character length of the function result, if it is a of type\n+@code{CHARACTER} and no C binding is used\n+@item The arguments in the order in which they appear in the Fortran\n+declaration\n+@item The the present status for optional arguments with value attribute,\n+which are internally passed by value\n+@item The character length and/or coarray token and offset for the first\n+argument which is a @code{CHARACTER} or a nonallocatable coarray dummy\n+argument, followed by the hidden arguments of the next dummy argument\n+of such a type\n+@end itemize\n+\n+\n \n @c Intrinsic Procedures\n @c ---------------------------------------------------------------------"}]}