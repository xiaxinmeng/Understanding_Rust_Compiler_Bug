{"sha": "42c5169549014e6f1b8be662d04b6530a4298c95", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDJjNTE2OTU0OTAxNGU2ZjFiOGJlNjYyZDA0YjY1MzBhNDI5OGM5NQ==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@redhat.com", "date": "2005-06-24T22:48:33Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-06-24T22:48:33Z"}, "message": "natClassLoader.cc (_Jv_UnregisterClass): Handle case where class' name is NULL.\n\n\t* java/lang/natClassLoader.cc (_Jv_UnregisterClass): Handle case\n\twhere class' name is NULL.\n\t(_Jv_FindClass): Don't wait for class state.\n\t* java/lang/natVMClassLoader.cc (defineClass): Only unregister if\n\tname found.\n\t* include/java-interp.h (_Jv_DefineClass): Updated.\n\t* defineclass.cc (_Jv_DefineClass): Added 'name_result' argument.\n\t(struct _Jv_ClassReader): Likewise.\n\t(found_name): New field.\n\t(handleClassBegin): Set *found_name.\n\t(_Jv_VerifyMethodSignature): Handle case where ptr==NULL.\n\t(handleClassBegin): Throw error if super class not set.\n\t(read_methods): Correctly call check_tag and prepare_pool_entry.\n\nFrom-SVN: r101301", "tree": {"sha": "de416528940c92c7487c2e3625d257a047026d0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de416528940c92c7487c2e3625d257a047026d0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/42c5169549014e6f1b8be662d04b6530a4298c95", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c5169549014e6f1b8be662d04b6530a4298c95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/42c5169549014e6f1b8be662d04b6530a4298c95", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/42c5169549014e6f1b8be662d04b6530a4298c95/comments", "author": null, "committer": null, "parents": [{"sha": "b7938f087dc0934e674e7cf7f6049145bd1a345d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7938f087dc0934e674e7cf7f6049145bd1a345d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7938f087dc0934e674e7cf7f6049145bd1a345d"}], "stats": {"total": 75, "additions": 53, "deletions": 22}, "files": [{"sha": "fca7044704c7bfabb39ea4515545fb85961e3969", "filename": "libjava/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=42c5169549014e6f1b8be662d04b6530a4298c95", "patch": "@@ -1,3 +1,19 @@\n+2005-06-24  Tom Tromey  <tromey@redhat.com>\n+\n+\t* java/lang/natClassLoader.cc (_Jv_UnregisterClass): Handle case\n+\twhere class' name is NULL.\n+\t(_Jv_FindClass): Don't wait for class state.\n+\t* java/lang/natVMClassLoader.cc (defineClass): Only unregister if\n+\tname found.\n+\t* include/java-interp.h (_Jv_DefineClass): Updated.\n+\t* defineclass.cc (_Jv_DefineClass): Added 'name_result' argument.\n+\t(struct _Jv_ClassReader): Likewise.\n+\t(found_name): New field.\n+\t(handleClassBegin): Set *found_name.\n+\t(_Jv_VerifyMethodSignature): Handle case where ptr==NULL.\n+\t(handleClassBegin): Throw error if super class not set.\n+\t(read_methods): Correctly call check_tag and prepare_pool_entry.\n+\n 2005-06-24  Tom Tromey  <tromey@redhat.com>\n \n \t* boehm.cc (_Jv_MarkObj): Handle case where field's type is NULL."}, {"sha": "e0e209cbfd22585f80dfa9af495f137b6e7a517a", "filename": "libjava/defineclass.cc", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fdefineclass.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fdefineclass.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fdefineclass.cc?ref=42c5169549014e6f1b8be662d04b6530a4298c95", "patch": "@@ -70,7 +70,8 @@ static void throw_class_circularity_error (jstring msg)\n  * public or private members here.\n  */\n \n-struct _Jv_ClassReader {\n+struct _Jv_ClassReader\n+{\n \n   // do verification?  Currently, there is no option to disable this.\n   // This flag just controls the verificaiton done by the class loader;\n@@ -104,6 +105,9 @@ struct _Jv_ClassReader {\n   // the classes associated interpreter data.\n   _Jv_InterpClass  *def_interp;\n \n+  // The name we found.\n+  _Jv_Utf8Const **found_name;\n+\n   /* check that the given number of input bytes are available */\n   inline void check (int num)\n   {\n@@ -219,7 +223,8 @@ struct _Jv_ClassReader {\n   }\n \n   _Jv_ClassReader (jclass klass, jbyteArray data, jint offset, jint length,\n-\t\t   java::security::ProtectionDomain *pd)\n+\t\t   java::security::ProtectionDomain *pd,\n+\t\t   _Jv_Utf8Const **name_result)\n   {\n     if (klass == 0 || length < 0 || offset+length > data->length)\n       throw_internal_error (\"arguments to _Jv_DefineClass\");\n@@ -229,6 +234,7 @@ struct _Jv_ClassReader {\n     len    = length;\n     pos    = 0;\n     def    = klass;\n+    found_name = name_result;\n \n     def->size_in_bytes = -1;\n     def->vtable_method_count = -1;\n@@ -279,11 +285,15 @@ struct _Jv_ClassReader {\n    */\n };\n \n+// Note that *NAME_RESULT will only be set if the class is registered\n+// with the class loader.  This is how the caller can know whether\n+// unregistration is require.\n void\n _Jv_DefineClass (jclass klass, jbyteArray data, jint offset, jint length,\n-\t\t java::security::ProtectionDomain *pd)\n+\t\t java::security::ProtectionDomain *pd,\n+\t\t _Jv_Utf8Const **name_result)\n {\n-  _Jv_ClassReader reader (klass, data, offset, length, pd);\n+  _Jv_ClassReader reader (klass, data, offset, length, pd, name_result);\n   reader.parse();\n \n   /* that's it! */\n@@ -499,9 +509,9 @@ void _Jv_ClassReader::read_methods ()\n       int attributes_count = read2u ();\n       \n       check_tag (name_index, JV_CONSTANT_Utf8);\n-      prepare_pool_entry (descriptor_index, JV_CONSTANT_Utf8);\n+      prepare_pool_entry (name_index, JV_CONSTANT_Utf8);\n \n-      check_tag (name_index, JV_CONSTANT_Utf8);\n+      check_tag (descriptor_index, JV_CONSTANT_Utf8);\n       prepare_pool_entry (descriptor_index, JV_CONSTANT_Utf8);\n \n       handleMethod (i, access_flags, name_index,\n@@ -930,11 +940,11 @@ _Jv_ClassReader::handleClassBegin (int access_flags, int this_class, int super_c\n   pool_data[this_class].clazz = def;\n   pool_tags[this_class] = JV_CONSTANT_ResolvedClass;\n \n-  if (super_class == 0 && ! (access_flags & Modifier::INTERFACE))\n+  if (super_class == 0)\n     {\n-      // FIXME: Consider this carefully!  \n-      if (! _Jv_equalUtf8Consts (def->name, java::lang::Object::class$.name))\n-\tthrow_no_class_def_found_error (\"loading java.lang.Object\");\n+      // Note that this is ok if we are defining java.lang.Object.\n+      // But there is no way to have this class be interpreted.\n+      throw_class_format_error (\"no superclass reference\");\n     }\n \n   def->state = JV_STATE_PRELOADING;\n@@ -946,15 +956,19 @@ _Jv_ClassReader::handleClassBegin (int access_flags, int this_class, int super_c\n   // lock here, as our caller has acquired it.\n   _Jv_RegisterInitiatingLoader (def, def->loader);\n \n+  // Note that we found a name so that unregistration can happen if\n+  // needed.\n+  *found_name = def->name;\n+\n+  jclass the_super = NULL;\n   if (super_class != 0)\n     {\n       // Load the superclass.\n       check_tag (super_class, JV_CONSTANT_Class);\n       _Jv_Utf8Const* super_name = pool_data[super_class].utf8; \n \n       // Load the superclass using our defining loader.\n-      jclass the_super = _Jv_FindClass (super_name,\n-\t\t\t\t\tdef->loader);\n+      jclass the_super = _Jv_FindClass (super_name, def->loader);\n \n       // This will establish that we are allowed to be a subclass,\n       // and check for class circularity error.\n@@ -1547,7 +1561,7 @@ _Jv_VerifyMethodSignature (_Jv_Utf8Const*sig)\n   while (ptr && UTF8_PEEK (ptr, limit) != ')')\n     ptr = _Jv_VerifyOne (ptr, limit, false);\n \n-  if (UTF8_GET (ptr, limit) != ')')\n+  if (! ptr || UTF8_GET (ptr, limit) != ')')\n     return false;\n \n   // get the return type"}, {"sha": "5155557c769b5173f9994808c06a29c9dcc9454b", "filename": "libjava/include/java-interp.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Finclude%2Fjava-interp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Finclude%2Fjava-interp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjava-interp.h?ref=42c5169549014e6f1b8be662d04b6530a4298c95", "patch": "@@ -36,7 +36,8 @@ struct _Jv_ResolvedMethod;\n \n void _Jv_InitInterpreter ();\n void _Jv_DefineClass (jclass, jbyteArray, jint, jint,\n-\t\t      java::security::ProtectionDomain *);\n+\t\t      java::security::ProtectionDomain *,\n+\t\t      _Jv_Utf8Const **);\n \n void _Jv_InitField (jobject, jclass, int);\n void * _Jv_AllocMethodInvocation (jsize size);"}, {"sha": "43016bf5e63e6b6ef0020cd34a63672bef4c4cb2", "filename": "libjava/java/lang/natClassLoader.cc", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fjava%2Flang%2FnatClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatClassLoader.cc?ref=42c5169549014e6f1b8be662d04b6530a4298c95", "patch": "@@ -107,6 +107,10 @@ _Jv_FindClassInCache (_Jv_Utf8Const *name)\n void\n _Jv_UnregisterClass (jclass the_class)\n {\n+  // This can happen if the class could not be defined properly.\n+  if (! the_class->name)\n+    return;\n+\n   JvSynchronize sync (&java::lang::Class::class$);\n   jint hash = HASH_UTF(the_class->name);\n \n@@ -328,12 +332,6 @@ _Jv_FindClass (_Jv_Utf8Const *name, java::lang::ClassLoader *loader)\n \t    }\n \t}\n     }\n-  else\n-    {\n-      // We need classes to be in the hash while we're loading, so\n-      // that they can refer to themselves.\n-      _Jv_Linker::wait_for_state (klass, JV_STATE_LOADED);\n-    }\n \n   return klass;\n }"}, {"sha": "bffbfc067db139ae955904241d21d9115ff1f794", "filename": "libjava/java/lang/natVMClassLoader.cc", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/42c5169549014e6f1b8be662d04b6530a4298c95/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatVMClassLoader.cc?ref=42c5169549014e6f1b8be662d04b6530a4298c95", "patch": "@@ -71,16 +71,18 @@ java::lang::VMClassLoader::defineClass (java::lang::ClassLoader *loader,\n \t  klass->name = name2;\n \t}\n \n+      _Jv_Utf8Const *found_name = NULL;\n       try\n \t{\n-\t  _Jv_DefineClass (klass, data, offset, length, pd);\n+\t  _Jv_DefineClass (klass, data, offset, length, pd, &found_name);\n \t}\n       catch (java::lang::Throwable *ex)\n \t{\n \t  klass->state = JV_STATE_ERROR;\n \t  klass->notifyAll ();\n \n-\t  _Jv_UnregisterInitiatingLoader (klass, klass->loader);\n+\t  if (found_name != NULL)\n+\t    _Jv_UnregisterInitiatingLoader (klass, klass->loader);\n \n \t  // If EX is not a ClassNotFoundException, that's ok, because we\n \t  // account for the possibility in defineClass()."}]}