{"sha": "4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "node_id": "C_kwDOANBUbNoAKDRmMmMxNDk5ZmVhZmI0NmJmODg4MjRjNDAxOWVmMTVkMmE2OGQzZTg", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-19T11:54:04Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-10-19T12:54:47Z"}, "message": "ast: Refactor ASTFragment -> Fragment class", "tree": {"sha": "ff1343bbf92e38d1c45fdd5356e19f3e570ffe46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ff1343bbf92e38d1c45fdd5356e19f3e570ffe46"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3922772f5f2e5ab245342defca6b53e1563de881", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3922772f5f2e5ab245342defca6b53e1563de881", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3922772f5f2e5ab245342defca6b53e1563de881"}], "stats": {"total": 273, "additions": 273, "deletions": 0}, "files": [{"sha": "5499e8ca157bce365124389134f8dc2818c7217b", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "patch": "@@ -69,6 +69,7 @@ GRS_OBJS = \\\n     rust/rust-cfg-parser.o \\\n     rust/rust-parse.o \\\n     rust/rust-ast-full-test.o \\\n+    rust/rust-ast-fragment.o \\\n     rust/rust-ast-dump.o \\\n     rust/rust-hir-dump.o \\\n     rust/rust-session-manager.o \\"}, {"sha": "1a2dd99835ad75239139ec9597c128aac061c862", "filename": "gcc/rust/ast/rust-ast-fragment.cc", "status": "added", "additions": 168, "deletions": 0, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2Fast%2Frust-ast-fragment.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.cc?ref=4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "patch": "@@ -0,0 +1,168 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include \"rust-ast-fragment.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+Fragment::Fragment (std::vector<SingleASTNode> nodes, bool fragment_is_error)\n+  : kind (fragment_is_error ? FragmentKind::Error : FragmentKind::Complete),\n+    nodes (std::move (nodes))\n+{\n+  if (fragment_is_error)\n+    rust_assert (nodes.empty ());\n+}\n+\n+Fragment::Fragment (Fragment const &other) : kind (other.get_kind ())\n+{\n+  nodes.clear ();\n+  nodes.reserve (other.nodes.size ());\n+  for (auto &n : other.nodes)\n+    {\n+      nodes.push_back (n);\n+    }\n+}\n+\n+Fragment &\n+Fragment::operator= (Fragment const &other)\n+{\n+  nodes.clear ();\n+  nodes.reserve (other.nodes.size ());\n+  kind = other.get_kind ();\n+  for (auto &n : other.nodes)\n+    {\n+      nodes.push_back (n);\n+    }\n+\n+  return *this;\n+}\n+\n+Fragment\n+Fragment::create_error ()\n+{\n+  return Fragment ({}, true);\n+}\n+\n+std::vector<SingleASTNode> &\n+Fragment::get_nodes ()\n+{\n+  return nodes;\n+}\n+\n+FragmentKind\n+Fragment::get_kind () const\n+{\n+  return kind;\n+}\n+\n+bool\n+Fragment::is_error () const\n+{\n+  return get_kind () == FragmentKind::Error;\n+}\n+\n+bool\n+Fragment::should_expand () const\n+{\n+  return !is_error ();\n+}\n+\n+bool\n+Fragment::is_expression_fragment () const\n+{\n+  return is_single_fragment_of_kind (SingleASTNode::NodeType::EXPRESSION);\n+}\n+\n+bool\n+Fragment::is_type_fragment () const\n+{\n+  return is_single_fragment_of_kind (SingleASTNode::NodeType::TYPE);\n+}\n+\n+std::unique_ptr<Expr>\n+Fragment::take_expression_fragment ()\n+{\n+  assert_single_fragment (SingleASTNode::NodeType::EXPRESSION);\n+  return nodes[0].take_expr ();\n+}\n+\n+std::unique_ptr<Type>\n+Fragment::take_type_fragment ()\n+{\n+  assert_single_fragment (SingleASTNode::NodeType::TYPE);\n+  return nodes[0].take_type ();\n+}\n+\n+void\n+Fragment::accept_vis (ASTVisitor &vis)\n+{\n+  for (auto &node : nodes)\n+    node.accept_vis (vis);\n+}\n+\n+bool\n+Fragment::is_single_fragment () const\n+{\n+  return nodes.size () == 1;\n+}\n+\n+bool\n+Fragment::is_single_fragment_of_kind (SingleASTNode::NodeType expected) const\n+{\n+  return is_single_fragment () && nodes[0].get_kind () == expected;\n+}\n+\n+void\n+Fragment::assert_single_fragment (SingleASTNode::NodeType expected) const\n+{\n+  static const std::map<SingleASTNode::NodeType, const char *> str_map = {\n+    {SingleASTNode::NodeType::IMPL, \"impl\"},\n+    {SingleASTNode::NodeType::ITEM, \"item\"},\n+    {SingleASTNode::NodeType::TYPE, \"type\"},\n+    {SingleASTNode::NodeType::EXPRESSION, \"expr\"},\n+    {SingleASTNode::NodeType::STMT, \"stmt\"},\n+    {SingleASTNode::NodeType::EXTERN, \"extern\"},\n+    {SingleASTNode::NodeType::TRAIT, \"trait\"},\n+    {SingleASTNode::NodeType::TRAIT_IMPL, \"trait impl\"},\n+  };\n+\n+  auto actual = nodes[0].get_kind ();\n+  auto fail = false;\n+\n+  if (!is_single_fragment ())\n+    {\n+      rust_error_at (Location (), \"fragment is not single\");\n+      fail = true;\n+    }\n+\n+  if (actual != expected)\n+    {\n+      rust_error_at (\n+\tLocation (),\n+\t\"invalid fragment operation: expected %qs node, got %qs node\",\n+\tstr_map.find (expected)->second,\n+\tstr_map.find (nodes[0].get_kind ())->second);\n+      fail = true;\n+    }\n+\n+  rust_assert (!fail);\n+}\n+\n+} // namespace AST\n+} // namespace Rust"}, {"sha": "ee6ab0d84339380794aac2770667ed1e5d785379", "filename": "gcc/rust/ast/rust-ast-fragment.h", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f2c1499feafb46bf88824c4019ef15d2a68d3e8/gcc%2Frust%2Fast%2Frust-ast-fragment.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-fragment.h?ref=4f2c1499feafb46bf88824c4019ef15d2a68d3e8", "patch": "@@ -0,0 +1,104 @@\n+// Copyright (C) 2020-2022 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_AST_FRAGMENT_H\n+#define RUST_AST_FRAGMENT_H\n+\n+#include \"rust-ast.h\"\n+#include \"rust-system.h\"\n+\n+namespace Rust {\n+namespace AST {\n+\n+enum class FragmentKind\n+{\n+  /**\n+   * If an AST Fragment still contains unexpanded tokens - this should only be\n+   * used in the case of builtin macros which need to be expanded eagerly.\n+   */\n+  Unexpanded,\n+  /**\n+   * A completely expanded AST Fragment. This signifies that all\n+   * `SingleASTNode`s in the `nodes` vector are valid.\n+   *\n+   * Note that this doesn't imply that the expansion is \"done\". One of the\n+   * expanded nodes could very well be another macro invocation\n+   */\n+  Complete,\n+  /**\n+   * An error fragment.\n+   */\n+  Error,\n+};\n+\n+/**\n+ * An AST Fragment. Previously named `ASTFragment`.\n+ *\n+ * Basically, a \"fragment\" that can be incorporated into the AST, created as\n+ * a result of macro expansion. Really annoying to work with due to the fact\n+ * that macros can really expand to anything. As such, horrible representation\n+ * at the moment.\n+ */\n+class Fragment\n+{\n+public:\n+  Fragment (std::vector<SingleASTNode> nodes, bool fragment_is_error = false);\n+  Fragment (Fragment const &other);\n+  static Fragment create_error ();\n+\n+  Fragment &operator= (Fragment const &other);\n+\n+  FragmentKind get_kind () const;\n+  std::vector<SingleASTNode> &get_nodes ();\n+\n+  bool is_error () const;\n+  bool should_expand () const;\n+\n+  bool is_expression_fragment () const;\n+  bool is_type_fragment () const;\n+\n+  std::unique_ptr<Expr> take_expression_fragment ();\n+  std::unique_ptr<Type> take_type_fragment ();\n+\n+  void accept_vis (ASTVisitor &vis);\n+\n+private:\n+  FragmentKind kind;\n+\n+  /**\n+   * Basic idea: essentially, a vector of tagged unions of different AST node\n+   * types. Now, this could actually be stored without a tagged union if the\n+   * different AST node types had a unified parent, but that would create\n+   * issues with the diamond problem or significant performance penalties. So\n+   * a tagged union had to be used instead. A vector is used to represent the\n+   * ability for a macro to expand to two statements, for instance.\n+   */\n+  std::vector<SingleASTNode> nodes;\n+\n+  /**\n+   * We need to make a special case for Expression and Type fragments as only\n+   * one Node will be extracted from the `nodes` vector\n+   */\n+  bool is_single_fragment () const;\n+  bool is_single_fragment_of_kind (SingleASTNode::NodeType expected) const;\n+  void assert_single_fragment (SingleASTNode::NodeType expected) const;\n+};\n+} // namespace AST\n+} // namespace Rust\n+\n+#endif // !RUST_AST_FRAGMENT_H"}]}