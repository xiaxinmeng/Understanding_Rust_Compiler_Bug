{"sha": "4702d3cf044924970a9a00142542da1edacfd76c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDcwMmQzY2YwNDQ5MjQ5NzBhOWEwMDE0MjU0MmRhMWVkYWNmZDc2Yw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-06-11T16:18:12Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2021-08-24T10:45:12Z"}, "message": "arm: Fix general issues with patterns for VLLDM and VLSTM\n\nBoth lazy_store_multiple_insn and lazy_load_multiple_insn contain\ninvalid RTL (eg they contain a post_inc statement outside of a mem).\nWhat's more, the instructions concerned do not modify their input\naddress register.  We probably got away with this because they are\ngenerated so late in the compilation that no subsequent pass needed to\nunderstand them.  Nevertheless, this could cause problems someday, so\nfixed to use a simple legal unspec.\n\ngcc:\n\t* config/arm/vfp.md (lazy_store_multiple_insn): Rewrite as valid RTL.\n\t(lazy_load_multiple_insn): Likewise.", "tree": {"sha": "e0a50ee146a00dbc3eb6fcb851646d3fc683a51a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e0a50ee146a00dbc3eb6fcb851646d3fc683a51a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4702d3cf044924970a9a00142542da1edacfd76c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4702d3cf044924970a9a00142542da1edacfd76c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4702d3cf044924970a9a00142542da1edacfd76c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4702d3cf044924970a9a00142542da1edacfd76c/comments", "author": null, "committer": null, "parents": [{"sha": "8da9b4f73c2c878b48f45fa2ed47d8a9edd31262", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8da9b4f73c2c878b48f45fa2ed47d8a9edd31262", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8da9b4f73c2c878b48f45fa2ed47d8a9edd31262"}], "stats": {"total": 21, "additions": 11, "deletions": 10}, "files": [{"sha": "9961f9389fedb5778ef7e9876eea38a071d37714", "filename": "gcc/config/arm/vfp.md", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4702d3cf044924970a9a00142542da1edacfd76c/gcc%2Fconfig%2Farm%2Fvfp.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4702d3cf044924970a9a00142542da1edacfd76c/gcc%2Fconfig%2Farm%2Fvfp.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fvfp.md?ref=4702d3cf044924970a9a00142542da1edacfd76c", "patch": "@@ -1703,24 +1703,25 @@\n    (set_attr \"type\" \"mov_reg\")]\n )\n \n+;; Both this and the next instruction are treated by GCC in the same\n+;; way as a blockage pattern.  That's perhaps stronger than it needs\n+;; to be, but we do not want accesses to the VFP register bank to be\n+;; moved across either instruction.\n+\n (define_insn \"lazy_store_multiple_insn\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"+&rk\")\n-\t(post_dec:SI (match_dup 0)))\n-   (unspec_volatile [(const_int 0)\n-\t\t     (mem:SI (post_dec:SI (match_dup 0)))]\n-\t\t    VUNSPEC_VLSTM)]\n+  [(unspec_volatile\n+    [(mem:BLK (match_operand:SI 0 \"s_register_operand\" \"rk\"))]\n+    VUNSPEC_VLSTM)]\n   \"use_cmse && reload_completed\"\n   \"vlstm%?\\\\t%0\"\n   [(set_attr \"predicable\" \"yes\")\n    (set_attr \"type\" \"store_4\")]\n )\n \n (define_insn \"lazy_load_multiple_insn\"\n-  [(set (match_operand:SI 0 \"s_register_operand\" \"+&rk\")\n-\t(post_inc:SI (match_dup 0)))\n-   (unspec_volatile:SI [(const_int 0)\n-\t\t\t(mem:SI (match_dup 0))]\n-\t\t       VUNSPEC_VLLDM)]\n+  [(unspec_volatile\n+    [(mem:BLK (match_operand:SI 0 \"s_register_operand\" \"rk\"))]\n+    VUNSPEC_VLLDM)]\n   \"use_cmse && reload_completed\"\n   \"vlldm%?\\\\t%0\"\n   [(set_attr \"predicable\" \"yes\")"}]}