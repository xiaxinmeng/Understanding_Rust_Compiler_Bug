{"sha": "a55583e90977b5445ab295de13f82010f2e1bf82", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTU1NTgzZTkwOTc3YjU0NDVhYjI5NWRlMTNmODIwMTBmMmUxYmY4Mg==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2000-05-19T23:06:55Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2000-05-19T23:06:55Z"}, "message": "Don't create a separate copy of virtual bases for the CLASSTYPE_VBASECLASSES list.\n\n\tDon't create a separate copy of virtual bases for the\n\tCLASSTYPE_VBASECLASSES list.\n\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Change documentation.\n\t(BINFO_FOR_VBASE): Remove.\n\t(CANONICAL_BINFO): Adjust.\n\t(binfo_for_vbase): New function.\n\t* class.c (build_vbase_pointer_fields): Use binfo_for_vbase\n\tinstead of BINFO_FOR_VBASE.\n\t(build_vbase_pointer): Likewise.\n\t(build_secondary_vtable): Likewise.\n\t(dfs_mark_primary_bases): Likewise.\n\t(mark_primary_bases): Likewise.\n\t(layout_nonempty_base_or_field): Likewise.\n\t(dfs_set_offset_for_shared_vbases): Likewise.\n\t(dfs_set_offset_for_unshared_vbases): Likewise.\n\t(layout_virtual_bases): Likewise.  Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t(dump_class_hierarchy_r): Use binfo_for_vbase\n\tinstead of BINFO_FOR_VBASE.\n\t(dump_class_hierarchy): Likewise.\n\t(finish_vtbls): Likewise.\n\t(build_vtbl_initializer): Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t(build_vbase_offset_vtbl_entries): Use binfo_for_vbase.\n\t* decl.c (finish_destructor_body): Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t* init.c (sort_base_init): Use binfo_for_vbase.\n\t(construct_virtual_bases): Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t(expand_member_init): Use binfo_for_vbase.\n\t(build_vbase_delete):  Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t* method.c (do_build_copy_constructor): Likewise.\n\t* rtti.c (get_base_offset): Use binfo_for_vbase.\n\t(expand_class_desc): Remove #if 0'd code.\n\t* search.c (struct vbase_info): Remove vbase_types.\n\t(get_base_distance):  Use binfo_for_vbase.\n\t(lookup_field_queue_p): Use CANONICAL_BINFO.\n\t(get_shared_vbase_if_not_primary): Use binfo_for_vbase.\n\t(get_pure_virtuals): Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t(dfs_find_vbases): Use binfo_for_vbase.\n\t(dfs_init_vbase_pointers): Likewise.\n\t(init_vbase_pointers): Don't initialize vi.vbase_types.\n\t(virtual_context): Use binfo_for_vbase.\n\t(fixup_all_virtual_upcast_offsets): Adjust for changes to the\n\tCLASSTYPE_VBASECLASSES list.\n\t(expand_indirect_vtbls_init): Simplify.\n\t(dfs_get_vbase_types): Don't replicate virtual bases.\n\t(find_vbase_instance): Use binfo_for_vbase.\n\t(binfo_for_vbase): New function.\n\t* typeck.c (get_delta_difference): Use binfo_for_vbase.\n\nFrom-SVN: r34040", "tree": {"sha": "b999522d5742e318d0ff17adb2b626999b6dea96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b999522d5742e318d0ff17adb2b626999b6dea96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a55583e90977b5445ab295de13f82010f2e1bf82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55583e90977b5445ab295de13f82010f2e1bf82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a55583e90977b5445ab295de13f82010f2e1bf82", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a55583e90977b5445ab295de13f82010f2e1bf82/comments", "author": null, "committer": null, "parents": [{"sha": "efc9bd412d3e48467658e5e8c5905669f160dc82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/efc9bd412d3e48467658e5e8c5905669f160dc82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/efc9bd412d3e48467658e5e8c5905669f160dc82"}], "stats": {"total": 330, "additions": 160, "deletions": 170}, "files": [{"sha": "ebe1d698a33041e95ee6cf96743eb2be20c44af1", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -1,3 +1,58 @@\n+2000-05-19  Mark Mitchell  <mark@codesourcery.com>\n+\n+\tDon't create a separate copy of virtual bases for the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t* cp-tree.h (CLASSTYPE_VBASECLASSES): Change documentation.\n+\t(BINFO_FOR_VBASE): Remove.\n+\t(CANONICAL_BINFO): Adjust.\n+\t(binfo_for_vbase): New function.\n+\t* class.c (build_vbase_pointer_fields): Use binfo_for_vbase\n+\tinstead of BINFO_FOR_VBASE.\n+\t(build_vbase_pointer): Likewise.\n+\t(build_secondary_vtable): Likewise.\n+\t(dfs_mark_primary_bases): Likewise.\n+\t(mark_primary_bases): Likewise.\n+\t(layout_nonempty_base_or_field): Likewise.\n+\t(dfs_set_offset_for_shared_vbases): Likewise.\n+\t(dfs_set_offset_for_unshared_vbases): Likewise.\n+\t(layout_virtual_bases): Likewise.  Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t(dump_class_hierarchy_r): Use binfo_for_vbase\n+\tinstead of BINFO_FOR_VBASE.\n+\t(dump_class_hierarchy): Likewise.\n+\t(finish_vtbls): Likewise.\n+\t(build_vtbl_initializer): Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t(build_vbase_offset_vtbl_entries): Use binfo_for_vbase.\n+\t* decl.c (finish_destructor_body): Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t* init.c (sort_base_init): Use binfo_for_vbase.\n+\t(construct_virtual_bases): Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t(expand_member_init): Use binfo_for_vbase.\n+\t(build_vbase_delete):  Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t* method.c (do_build_copy_constructor): Likewise.\n+\t* rtti.c (get_base_offset): Use binfo_for_vbase.\n+\t(expand_class_desc): Remove #if 0'd code.\n+\t* search.c (struct vbase_info): Remove vbase_types.\n+\t(get_base_distance):  Use binfo_for_vbase.\n+\t(lookup_field_queue_p): Use CANONICAL_BINFO.\n+\t(get_shared_vbase_if_not_primary): Use binfo_for_vbase.\n+\t(get_pure_virtuals): Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t(dfs_find_vbases): Use binfo_for_vbase.\n+\t(dfs_init_vbase_pointers): Likewise.\n+\t(init_vbase_pointers): Don't initialize vi.vbase_types.\n+\t(virtual_context): Use binfo_for_vbase.\n+\t(fixup_all_virtual_upcast_offsets): Adjust for changes to the\n+\tCLASSTYPE_VBASECLASSES list.\n+\t(expand_indirect_vtbls_init): Simplify.\n+\t(dfs_get_vbase_types): Don't replicate virtual bases.\n+\t(find_vbase_instance): Use binfo_for_vbase.\n+\t(binfo_for_vbase): New function.\n+\t* typeck.c (get_delta_difference): Use binfo_for_vbase.\n+\t\n 2000-05-17  Mark Mitchell  <mark@codesourcery.com>\n \n \t* decl2.c (finish_anon_union): Generalize error messages to handle"}, {"sha": "cc6323949f5776ff250583686659e4127948145e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 29, "deletions": 31, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -246,7 +246,7 @@ build_vbase_pointer_fields (rli, empty_p)\n \t    {\n \t      tree other_base_binfo = TREE_VEC_ELT (binfos, j);\n \t      if (! TREE_VIA_VIRTUAL (other_base_binfo)\n-\t\t  && BINFO_FOR_VBASE (basetype, BINFO_TYPE (other_base_binfo)))\n+\t\t  && binfo_for_vbase (basetype, BINFO_TYPE (other_base_binfo)))\n \t\tgoto got_it;\n \t    }\n \t  FORMAT_VBASE_NAME (name, basetype);\n@@ -285,7 +285,7 @@ build_vbase_pointer (exp, type)\n \n       /* Find the shared copy of TYPE; that's where the vtable offset\n \t is recorded.  */\n-      vbase = BINFO_FOR_VBASE (type, TREE_TYPE (exp));\n+      vbase = binfo_for_vbase (type, TREE_TYPE (exp));\n       /* Find the virtual function table pointer.  */\n       vbase_ptr = build_vfield_ref (exp, TREE_TYPE (exp));\n       /* Compute the location where the offset will lie.  */\n@@ -841,7 +841,7 @@ build_secondary_vtable (binfo, for_type)\n #endif\n \n   if (TREE_VIA_VIRTUAL (binfo))\n-    my_friendly_assert (binfo == BINFO_FOR_VBASE (BINFO_TYPE (binfo),\n+    my_friendly_assert (binfo == binfo_for_vbase (BINFO_TYPE (binfo),\n \t\t\t\t\t\t  current_class_type),\n \t\t\t170);\n \n@@ -859,7 +859,7 @@ build_secondary_vtable (binfo, for_type)\n \n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n-      tree binfo1 = BINFO_FOR_VBASE (BINFO_TYPE (binfo), for_type);\n+      tree binfo1 = binfo_for_vbase (BINFO_TYPE (binfo), for_type);\n \n       /* XXX - This should never happen, if it does, the caller should\n \t ensure that the binfo is from for_type's binfos, not from any\n@@ -1694,7 +1694,7 @@ dfs_mark_primary_bases (binfo, data)\n       tree shared_binfo;\n \n       shared_binfo \n-\t= BINFO_FOR_VBASE (BINFO_TYPE (base_binfo), (tree) data);\n+\t= binfo_for_vbase (BINFO_TYPE (base_binfo), (tree) data);\n \n       /* If this virtual base is not already primary somewhere else in\n \t the hiearchy, then we'll be using this copy.  */\n@@ -1741,7 +1741,7 @@ mark_primary_bases (type)\n       if (!TREE_VIA_VIRTUAL (vbases))\n \tcontinue;\n \n-      vbase = BINFO_FOR_VBASE (BINFO_TYPE (vbases), type);\n+      vbase = binfo_for_vbase (BINFO_TYPE (vbases), type);\n       if (BINFO_VBASE_PRIMARY_P (vbase))\n \t/* This virtual base was already included in the hierarchy, so\n \t   there's nothing to do here.  */\n@@ -3667,7 +3667,7 @@ layout_nonempty_base_or_field (rli, decl, binfo, v)\n \t a data member.  */\n       if (binfo && flag_new_abi && layout_conflict_p (binfo, v))\n \t{\n-\t  /* Undo the propogate_binfo_offsets call.  */\n+\t  /* Undo the propagate_binfo_offsets call.  */\n \t  offset = size_diffop (size_zero_node, offset);\n \t  propagate_binfo_offsets (binfo, convert (ssizetype, offset));\n \t \n@@ -4376,7 +4376,7 @@ dfs_set_offset_for_shared_vbases (binfo, data)\n       /* Update the shared copy.  */\n       tree shared_binfo;\n \n-      shared_binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), (tree) data);\n+      shared_binfo = binfo_for_vbase (BINFO_TYPE (binfo), (tree) data);\n       BINFO_OFFSET (shared_binfo) = BINFO_OFFSET (binfo);\n     }\n \n@@ -4399,7 +4399,7 @@ dfs_set_offset_for_unshared_vbases (binfo, data)\n       tree vbase;\n       tree offset;\n       \n-      vbase = BINFO_FOR_VBASE (BINFO_TYPE (binfo), t);\n+      vbase = binfo_for_vbase (BINFO_TYPE (binfo), t);\n       offset = size_diffop (BINFO_OFFSET (vbase), BINFO_OFFSET (binfo));\n       propagate_binfo_offsets (binfo, offset);\n     }\n@@ -4448,13 +4448,14 @@ layout_virtual_bases (t, base_offsets)\n     {\n       tree vbase;\n \n-      if (!TREE_VIA_VIRTUAL (vbases))\n-\tcontinue;\n-\n       if (flag_new_abi)\n-\tvbase = BINFO_FOR_VBASE (BINFO_TYPE (vbases), t);\n+\t{\n+\t  if (!TREE_VIA_VIRTUAL (vbases))\n+\t    continue;\n+\t  vbase = binfo_for_vbase (BINFO_TYPE (vbases), t);\n+\t}\n       else\n-\tvbase = vbases;\n+\tvbase = TREE_VALUE (vbases);\n \n       if (!BINFO_VBASE_PRIMARY_P (vbase))\n \t{\n@@ -4486,9 +4487,15 @@ layout_virtual_bases (t, base_offsets)\n \t\t\t       *base_offsets);\n \t  else\n \t    {\n+\t      tree offset;\n+\n+\t      offset = ssize_int (CEIL (dsize, BITS_PER_UNIT));\n+\t      offset = size_diffop (offset, \n+\t\t\t\t    convert (ssizetype, \n+\t\t\t\t\t     BINFO_OFFSET (vbase)));\n+\n \t      /* And compute the offset of the virtual base.  */\n-\t      propagate_binfo_offsets (vbase, \n-\t\t\t\t       ssize_int (CEIL (dsize, BITS_PER_UNIT)));\n+\t      propagate_binfo_offsets (vbase, offset);\n \t      /* Every virtual baseclass takes a least a UNIT, so that\n \t\t we can take it's address and get something different\n \t\t for each base.  */\n@@ -4516,10 +4523,6 @@ layout_virtual_bases (t, base_offsets)\n      in get_base_distance depend on the BINFO_OFFSETs being set\n      correctly.  */\n   dfs_walk (TYPE_BINFO (t), dfs_set_offset_for_unshared_vbases, NULL, t);\n-  for (vbases = CLASSTYPE_VBASECLASSES (t);\n-       vbases;\n-       vbases = TREE_CHAIN (vbases))\n-    dfs_walk (vbases, dfs_set_offset_for_unshared_vbases, NULL, t);\n \n   /* If we had empty base classes that protruded beyond the end of the\n      class, we didn't update DSIZE above; we were hoping to overlay\n@@ -4542,7 +4545,7 @@ layout_virtual_bases (t, base_offsets)\n \t vbases; \n \t vbases = TREE_CHAIN (vbases))\n       {\n-\ttree basetype = BINFO_TYPE (vbases);\n+\ttree basetype = BINFO_TYPE (TREE_VALUE (vbases));\n \tif (get_base_distance (basetype, t, 0, (tree*)0) == -2)\n \t  cp_warning (\"virtual base `%T' inaccessible in `%T' due to ambiguity\",\n \t\t      basetype, t);\n@@ -6334,7 +6337,7 @@ dump_class_hierarchy_r (t, binfo, indent)\n     fprintf (stderr, \" virtual\");\n   if (BINFO_PRIMARY_MARKED_P (binfo)\n       || (TREE_VIA_VIRTUAL (binfo) \n-\t  && BINFO_VBASE_PRIMARY_P (BINFO_FOR_VBASE (BINFO_TYPE (binfo), \n+\t  && BINFO_VBASE_PRIMARY_P (binfo_for_vbase (BINFO_TYPE (binfo), \n \t\t\t\t\t\t     t))))\n     fprintf (stderr, \" primary\");\n   fprintf (stderr, \"\\n\");\n@@ -6349,12 +6352,7 @@ void\n dump_class_hierarchy (t)\n      tree t;\n {\n-  tree vbase;\n-\n   dump_class_hierarchy_r (t, TYPE_BINFO (t), 0);\n-  fprintf (stderr, \"virtual bases\\n\");\n-  for (vbase = CLASSTYPE_VBASECLASSES (t); vbase; vbase = TREE_CHAIN (vbase))\n-    dump_class_hierarchy_r (t, vbase, 0);\n }\n \n /* Virtual function table initialization.  */\n@@ -6383,7 +6381,7 @@ finish_vtbls (t)\n \t{\n \t  if (!TREE_VIA_VIRTUAL (vbase))\n \t    continue;\n-\t  accumulate_vtbl_inits (BINFO_FOR_VBASE (BINFO_TYPE (vbase), t),\n+\t  accumulate_vtbl_inits (binfo_for_vbase (BINFO_TYPE (vbase), t),\n \t\t\t\t list);\n \t}\n \n@@ -6554,7 +6552,7 @@ build_vtbl_initializer (binfo, original_binfo, t, rtti_binfo,\n   for (vbase = CLASSTYPE_VBASECLASSES (t); \n        vbase; \n        vbase = TREE_CHAIN (vbase))\n-    CLEAR_BINFO_VTABLE_PATH_MARKED (vbase);\n+    CLEAR_BINFO_VTABLE_PATH_MARKED (TREE_VALUE (vbase));\n \n   /* Add entries to the vtable for RTTI.  */\n   inits = chainon (inits, build_rtti_vtbl_entries (binfo, rtti_binfo));\n@@ -6673,7 +6671,7 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \n       /* Find the instance of this virtual base in the complete\n \t object.  */\n-      b = BINFO_FOR_VBASE (BINFO_TYPE (vbase), t);\n+      b = binfo_for_vbase (BINFO_TYPE (vbase), t);\n \n       /* If we've already got an offset for this virtual base, we\n \t don't need another one.  */\n@@ -6694,7 +6692,7 @@ build_vbase_offset_vtbl_entries (binfo, vod)\n \t  tree orig_vbase;\n \n \t  /* Find the instance of this virtual base in the type of BINFO.  */\n-\t  orig_vbase = BINFO_FOR_VBASE (BINFO_TYPE (vbase),\n+\t  orig_vbase = binfo_for_vbase (BINFO_TYPE (vbase),\n \t\t\t\t\tBINFO_TYPE (binfo));\n \n \t  /* The vbase offset had better be the same.  */"}, {"sha": "aa9fdaf729342a789360aa7c3aa73b311381ffb6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -1598,34 +1598,15 @@ struct lang_type\n /* A chain of BINFOs for the direct and indirect virtual base classes\n    that this type uses in a post-order depth-first left-to-right\n    order.  (In other words, these bases appear in the order that they\n-   should be initialized.)\n-\n-   These BINFOs are distinct from those in the TYPE_BINFO hierarchy.\n-   So, given:\n-\n-     struct A {};\n-     struct B : public A {};\n-     struct C : virtual public B {};\n-     struct D : virtual public B {};\n-     struct E : public C, public D {};\n-\n-   there will be two copies of `A' and `B' in the TYPE_BINFO hierarchy\n-   for `E'.  On the CLASSTYPE_VBASECLASSES list, there will be just\n-   one copy of `B' (distinct from the other two) with its own copy of `A'\n-   (also distinct from the copies in the TYPE_BINFO hierarchy.)  */\n+   should be initialized.)  */\n #define CLASSTYPE_VBASECLASSES(NODE) (TYPE_LANG_SPECIFIC(NODE)->vbases)\n \n-/* The BINFO (if any) for the virtual baseclass T of the class C from\n-   the CLASSTYPE_VBASECLASSES list.  */\n-#define BINFO_FOR_VBASE(T, C) \\\n-  (binfo_member (T, CLASSTYPE_VBASECLASSES (C)))\n-\n /* For a non-virtual BINFO, the BINFO itself; for a virtual BINFO, the\n-   BINFO_FOR_VBASE.  C is the most derived class for the hierarchy\n+   binfo_for_vbase.  C is the most derived class for the hierarchy\n    containing BINFO.  */\n #define CANONICAL_BINFO(BINFO, C)\t\t\\\n   (TREE_VIA_VIRTUAL (BINFO) \t\t\t\\\n-   ? BINFO_FOR_VBASE (BINFO_TYPE (BINFO), C) \t\\\n+   ? binfo_for_vbase (BINFO_TYPE (BINFO), C) \t\\\n    : BINFO)\n \n /* Number of direct baseclasses of NODE.  */\n@@ -1718,9 +1699,7 @@ struct lang_type\n    for B (in D) will have a BINFO_INHERITANCE_CHAIN pointing to\n    D.  In tree.h, this pointer is described as pointing in other\n    direction.  There is a different BINFO for each path to a virtual\n-   base; BINFOs for virtual bases are not shared.  In addition, shared\n-   versions of each of the virtual class BINFOs are stored in\n-   CLASSTYPE_VBASECLASSES.\n+   base; BINFOs for virtual bases are not shared.\n \n    We use TREE_VIA_PROTECTED and TREE_VIA_PUBLIC, but private\n    inheritance is indicated by the absence of the other two flags, not\n@@ -1760,29 +1739,13 @@ struct lang_type\n /* Nonzero if this BINFO is a primary base class.\n \n    In the TYPE_BINFO hierarchy, this flag is never set for a base\n-   class of a non-primary virtual base because the copies of a\n-   non-primary virtual base that appear in the TYPE_BINFO hierarchy do\n-   not really exist.  Instead, it is the BINFOs in the\n-   CLASSTYPE_VBASECLASSES list that are used.  In other words, this\n-   flag is only valid for paths (given by BINFO_INHERITANCE_CHAIN)\n-   that really exist in the final object.  \n-\n-   For example, consider:\n-\n-      struct A {};\n-      struct B : public A { };\n-      struct C : virtual public B { void f(); int i; };\n-\n-   `A' is the primary base class for `B'.  But, `B' is not a primary\n-   base class for `C'.  So, in the copy of `A' that appears in the\n-   TYPE_BINFO hierarcy for `C' does not have BINFO_PRIMARY_MARKED_P\n-   set; the copy in the CLASSTYPE_VBASECLASSES list does have this\n-   set.  */\n+   class of a non-primary virtual base.  This flag is only valid for\n+   paths (given by BINFO_INHERITANCE_CHAIN) that really exist in the\n+   final object.  */\n #define BINFO_PRIMARY_MARKED_P(NODE) TREE_LANG_FLAG_5 (NODE)\n \n /* Nonzero if the virtual baseclass with the type given by this BINFO\n-   is primary *somewhere* in the hierarchy.  This flag is only set on \n-   entries in the CLASSTYPE_VBASECLASSES list.  */\n+   is primary *somewhere* in the hierarchy.  */\n #define BINFO_VBASE_PRIMARY_P(NODE) TREE_LANG_FLAG_6 (NODE)\n \n /* Used by various search routines.  */\n@@ -4365,6 +4328,7 @@ extern tree marked_vtable_pathp                 PARAMS ((tree, void *));\n extern tree unmarked_vtable_pathp               PARAMS ((tree, void *));\n extern tree convert_pointer_to_vbase            PARAMS ((tree, tree));\n extern tree find_vbase_instance                 PARAMS ((tree, tree));\n+extern tree binfo_for_vbase                     PARAMS ((tree, tree));\n \n /* in semantics.c */\n extern void finish_expr_stmt                    PARAMS ((tree));"}, {"sha": "52e67ae83ef8c7880adf7cc358069c70eaeebc38", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -13863,26 +13863,34 @@ finish_destructor_body ()\n       /* Run destructors for all virtual baseclasses.  */\n       if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n \t{\n-\t  tree vbases = nreverse (copy_list (CLASSTYPE_VBASECLASSES (current_class_type)));\n-\t  tree if_stmt = begin_if_stmt ();\n+\t  tree vbases;\n+\t  tree if_stmt;\n+\n+\t  if_stmt = begin_if_stmt ();\n \t  finish_if_stmt_cond (build (BIT_AND_EXPR, integer_type_node,\n \t\t\t\t      current_in_charge_parm,\n \t\t\t\t      integer_two_node),\n \t\t\t       if_stmt);\n \n-\t  while (vbases)\n+\t  vbases = CLASSTYPE_VBASECLASSES (current_class_type);\n+\t  /* The CLASSTYPE_VBASECLASSES list is in initialization\n+\t     order, so we have to march through it in reverse order.  */\n+\t  for (vbases = nreverse (copy_list (vbases));\n+\t       vbases;\n+\t       vbases = TREE_CHAIN (vbases))\n \t    {\n-\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (vbases)))\n+\t      tree vbase = TREE_VALUE (vbases);\n+\n+\t      if (TYPE_HAS_NONTRIVIAL_DESTRUCTOR (BINFO_TYPE (vbase)))\n \t\t{\n \t\t  tree vb = get_vbase\n-\t\t    (BINFO_TYPE (vbases),\n+\t\t    (BINFO_TYPE (vbase),\n \t\t     TYPE_BINFO (current_class_type));\n \t\t  finish_expr_stmt\n \t\t    (build_scoped_method_call\n \t\t     (current_class_ref, vb, base_dtor_identifier,\n \t\t      NULL_TREE));\n \t\t}\n-\t      vbases = TREE_CHAIN (vbases);\n \t    }\n \n \t  finish_then_clause (if_stmt);"}, {"sha": "d31728dc04e4fb206712b6da76b9f50d18e04f99", "filename": "gcc/cp/init.c", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -537,7 +537,7 @@ sort_base_init (t, rbase_ptr, vbase_ptr)\n \t     this constructor is the top-level constructor called.  */\n \t  if (TREE_VIA_VIRTUAL (binfo))\n \t    {\n-\t      tree v = BINFO_FOR_VBASE (BINFO_TYPE (binfo), t);\n+\t      tree v = binfo_for_vbase (BINFO_TYPE (binfo), t);\n \t      vbases = tree_cons (v, TREE_VALUE (x), vbases);\n \t      continue;\n \t    }\n@@ -855,6 +855,7 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n       tree inner_if_stmt;\n       tree compound_stmt;\n       tree exp;\n+      tree vbase;\n \n       /* If there are virtual base classes with destructors, we need to\n \t emit cleanups to destroy them if an exception is thrown during\n@@ -878,21 +879,22 @@ construct_virtual_bases (type, this_ref, this_ptr, init_list, flag)\n \t constructing virtual bases, then we must be the most derived\n \t class.  Therefore, we don't have to look up the virtual base;\n \t we already know where it is.  */\n+      vbase = TREE_VALUE (vbases);\n       exp = build (PLUS_EXPR,\n \t\t   TREE_TYPE (this_ptr),\n \t\t   this_ptr,\n \t\t   fold (build1 (NOP_EXPR, TREE_TYPE (this_ptr),\n-\t\t\t\t BINFO_OFFSET (vbases))));\n+\t\t\t\t BINFO_OFFSET (vbase))));\n       exp = build1 (NOP_EXPR, \n-\t\t    build_pointer_type (BINFO_TYPE (vbases)), \n+\t\t    build_pointer_type (BINFO_TYPE (vbase)), \n \t\t    exp);\n \n-      expand_aggr_vbase_init_1 (vbases, this_ref, exp, init_list);\n+      expand_aggr_vbase_init_1 (vbase, this_ref, exp, init_list);\n       finish_compound_stmt (/*has_no_scope=*/1, compound_stmt);\n       finish_then_clause (inner_if_stmt);\n       finish_if_stmt ();\n       \n-      expand_cleanup_for_base (vbases, flag);\n+      expand_cleanup_for_base (vbase, flag);\n     }\n }\n \n@@ -1022,7 +1024,7 @@ expand_member_init (exp, name, init)\n \t       && ! current_template_parms\n \t       && ! vec_binfo_member (basetype,\n \t\t\t\t      TYPE_BINFO_BASETYPES (type))\n-\t       && ! BINFO_FOR_VBASE (basetype, type))\n+\t       && ! binfo_for_vbase (basetype, type))\n \t{\n \t  if (IDENTIFIER_CLASS_VALUE (name))\n \t    goto try_member;\n@@ -3290,8 +3292,9 @@ build_vbase_delete (type, decl)\n \n   while (vbases)\n     {\n-      tree this_addr = convert_force (build_pointer_type (BINFO_TYPE (vbases)),\n-\t\t\t\t      addr, 0);\n+      tree this_addr \n+\t= convert_force (build_pointer_type (BINFO_TYPE (TREE_VALUE (vbases))),\n+\t\t\t addr, 0);\n       result = tree_cons (NULL_TREE,\n \t\t\t  build_delete (TREE_TYPE (this_addr), this_addr,\n \t\t\t\t\tinteger_zero_node,"}, {"sha": "81df59aab8b79eff88f61260690a7faf0131e111", "filename": "gcc/cp/method.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -2262,7 +2262,8 @@ do_build_copy_constructor (fndecl)\n       for (t = CLASSTYPE_VBASECLASSES (current_class_type); t;\n \t   t = TREE_CHAIN (t))\n \tcurrent_base_init_list \n-\t  = tree_cons (BINFO_TYPE (t), parm, current_base_init_list);\n+\t  = tree_cons (BINFO_TYPE (TREE_VALUE (t)), parm, \n+\t\t       current_base_init_list);\n       for (i = 0; i < n_bases; ++i)\n \t{\n \t  t = TREE_VEC_ELT (binfos, i);"}, {"sha": "a7c13b52c4a115f15ebfaa73b38d2f699cfcb0b9", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 39, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -548,7 +548,7 @@ get_base_offset (binfo, parent)\n     /* Under the new ABI, we store the vtable offset at which\n        the virtual base offset can be found.  */\n     return convert (sizetype,\n-\t\t    BINFO_VPTR_FIELD (BINFO_FOR_VBASE (BINFO_TYPE (binfo),\n+\t\t    BINFO_VPTR_FIELD (binfo_for_vbase (BINFO_TYPE (binfo),\n \t\t\t\t\t\t       parent)));\n \n }\n@@ -930,11 +930,6 @@ expand_class_desc (tdecl, type)\n   int i = CLASSTYPE_N_BASECLASSES (type);\n   int base_cnt = 0;\n   tree binfos = TYPE_BINFO_BASETYPES (type);\n-#if 0\n-  /* See code below that used these.  */\n-  tree vb = CLASSTYPE_VBASECLASSES (type);\n-  int n_base = i;\n-#endif\n   tree base, elems, access, offset, isvir;\n   tree elt, elts = NULL_TREE;\n \n@@ -1000,39 +995,6 @@ expand_class_desc (tdecl, type)\n       elts = tree_cons (NULL_TREE, elt, elts);\n       base_cnt++;\n     }\n-#if 0\n-  i = n_base;\n-  while (vb)\n-    {\n-      tree b;\n-      access = access_public_node;\n-      while (--i >= 0)\n-\t{\n-\t  b = TREE_VEC_ELT (binfos, i);\n-\t  if (BINFO_TYPE (vb) == BINFO_TYPE (b) && TREE_VIA_VIRTUAL (b))\n-\t    {\n-\t      if (TREE_VIA_PUBLIC (b))\n-\t\taccess = access_public_node;\n-\t      else if (TREE_VIA_PROTECTED (b))\n-\t\taccess = access_protected_node;\n-\t      else\n-\t\taccess = access_private_node;\n-\t      break;\n-\t    }\n-\t}\n-      base = build_t_desc (BINFO_TYPE (vb), 1);\n-      offset = BINFO_OFFSET (vb);\n-      isvir = build_int_2 (1, 0);\n-\n-      base_list = tree_cons (NULL_TREE, base, base_list);\n-      isvir_list = tree_cons (NULL_TREE, isvir, isvir_list);\n-      acc_list = tree_cons (NULL_TREE, access, acc_list);\n-      off_list = tree_cons (NULL_TREE, offset, off_list);\n-\n-      base_cnt++;\n-      vb = TREE_CHAIN (vb);\n-    }\n-#endif\n \n   name_string = tinfo_name (type);\n "}, {"sha": "7dd03d420658a5ef234976fd0ebc9d399984f8d5", "filename": "gcc/cp/search.c", "status": "modified", "additions": 34, "deletions": 34, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -82,7 +82,6 @@ struct vbase_info\n   tree type;\n   tree decl_ptr;\n   tree inits;\n-  tree vbase_types;\n };\n \n static tree next_baselink PARAMS ((tree));\n@@ -491,9 +490,8 @@ get_base_distance (parent, binfo, protect, path_ptr)\n      tree, deal with it.  This happens when we are called from\n      expand_upcast_fixups.  */\n   if (rval == -1 && TREE_CODE (parent) == TREE_VEC\n-      && parent == BINFO_FOR_VBASE (BINFO_TYPE (parent), type))\n+      && parent == binfo_for_vbase (BINFO_TYPE (parent), type))\n     {\n-      my_friendly_assert (BINFO_INHERITANCE_CHAIN (parent) == binfo, 980827);\n       new_binfo = parent;\n       rval = 1;\n     }\n@@ -1351,10 +1349,7 @@ lookup_field_queue_p (binfo, data)\n       && hides (lfi->rval_binfo, binfo))\n     return NULL_TREE;\n \n-  if (TREE_VIA_VIRTUAL (binfo))\n-    return BINFO_FOR_VBASE (BINFO_TYPE (binfo), lfi->type);\n-  else\n-    return binfo;\n+  return CANONICAL_BINFO (binfo, lfi->type);\n }\n \n /* Within the scope of a template class, you can refer to the to the\n@@ -2230,7 +2225,7 @@ get_shared_vbase_if_not_primary (binfo, data)\n \n       /* This is a non-primary virtual base.  If there is no primary\n \t version, get the shared version.  */\n-      binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), type);\n+      binfo = binfo_for_vbase (BINFO_TYPE (binfo), type);\n       if (BINFO_VBASE_PRIMARY_P (binfo))\n \treturn NULL_TREE;\n     }\n@@ -2344,7 +2339,7 @@ get_pure_virtuals (type)\n     {\n       tree virtuals;\n \n-      for (virtuals = BINFO_VIRTUALS (vbases);\n+      for (virtuals = BINFO_VIRTUALS (TREE_VALUE (vbases));\n \t   virtuals;\n \t   virtuals = TREE_CHAIN (virtuals))\n \t{\n@@ -2492,7 +2487,7 @@ dfs_find_vbases (binfo, data)\n \t  && CLASSTYPE_SEARCH_SLOT (BINFO_TYPE (base_binfo)) == 0)\n \t{\n \t  tree vbase = BINFO_TYPE (base_binfo);\n-\t  tree binfo = binfo_member (vbase, vi->vbase_types);\n+\t  tree binfo = binfo_for_vbase (vbase, vi->type);\n \t  tree ptr_type = build_pointer_type (vbase);\n \n \t  CLASSTYPE_SEARCH_SLOT (vbase)\n@@ -2546,10 +2541,11 @@ dfs_init_vbase_pointers (binfo, data)\n       tree ref = build (COMPONENT_REF, TREE_TYPE (fields),\n \t\t\tbuild_indirect_ref (this_vbase_ptr, NULL_PTR), fields);\n       tree init = CLASSTYPE_SEARCH_SLOT (TREE_TYPE (TREE_TYPE (fields)));\n-      vi->inits = tree_cons (binfo_member (TREE_TYPE (TREE_TYPE (fields)),\n-\t\t\t\t\t   vi->vbase_types),\n-\t\t\t     build_modify_expr (ref, NOP_EXPR, init),\n-\t\t\t     vi->inits);\n+      vi->inits \n+\t= tree_cons (binfo_for_vbase (TREE_TYPE (TREE_TYPE (fields)),\n+\t\t\t\t      vi->type),\n+\t\t     build_modify_expr (ref, NOP_EXPR, init),\n+\t\t     vi->inits);\n       fields = TREE_CHAIN (fields);\n     }\n   \n@@ -2590,7 +2586,6 @@ init_vbase_pointers (type, decl_ptr)\n \t initialization.  */\n       vi.type = type;\n       vi.decl_ptr = decl_ptr;\n-      vi.vbase_types = CLASSTYPE_VBASECLASSES (type);\n       vi.inits = NULL_TREE;\n \n       dfs_walk (binfo, dfs_find_vbases, unmarked_vtable_pathp, &vi);\n@@ -2635,7 +2630,7 @@ virtual_context (fndecl, t, vbase)\n \t      /* Not sure if checking path == vbase is necessary here, but just in\n \t\t case it is.  */\n \t      if (TREE_VIA_VIRTUAL (path) || path == vbase)\n-\t\treturn BINFO_FOR_VBASE (BINFO_TYPE (path), t);\n+\t\treturn binfo_for_vbase (BINFO_TYPE (path), t);\n \t      path = BINFO_INHERITANCE_CHAIN (path);\n \t    }\n \t}\n@@ -2646,7 +2641,7 @@ virtual_context (fndecl, t, vbase)\n   while (path)\n     {\n       if (TREE_VIA_VIRTUAL (path))\n-\treturn BINFO_FOR_VBASE (BINFO_TYPE (path), t);\n+\treturn binfo_for_vbase (BINFO_TYPE (path), t);\n       path = BINFO_INHERITANCE_CHAIN (path);\n     }\n   return 0;\n@@ -2873,11 +2868,11 @@ fixup_all_virtual_upcast_offsets (type, decl_ptr)\n \t  tree vbase_offsets;\n \t  tree addr;\n \n-\t  vbase = find_vbase_instance (BINFO_TYPE (vbases), type);\n+\t  vbase = find_vbase_instance (TREE_PURPOSE (vbases), type);\n \t  vbase_offsets = NULL_TREE;\n-\t  addr = convert_pointer_to_vbase (BINFO_TYPE (vbases), decl_ptr);\n+\t  addr = convert_pointer_to_vbase (TREE_PURPOSE (vbases), decl_ptr);\n \t  fixup_virtual_upcast_offsets (vbase,\n-\t\t\t\t\tTYPE_BINFO (BINFO_TYPE (vbases)),\n+\t\t\t\t\tTYPE_BINFO (TREE_PURPOSE (vbases)),\n \t\t\t\t\t1, 0, addr, decl_ptr,\n \t\t\t\t\ttype, vbase, &vbase_offsets);\n \t}\n@@ -2916,11 +2911,9 @@ expand_indirect_vtbls_init (binfo, decl_ptr)\n \n   if (TYPE_USES_VIRTUAL_BASECLASSES (type))\n     {\n-      tree vbases = CLASSTYPE_VBASECLASSES (type);\n       struct vbase_info vi;\n       vi.type = type;\n       vi.decl_ptr = decl_ptr;\n-      vi.vbase_types = vbases;\n \n       dfs_walk (binfo, dfs_find_vbases, NULL, &vi);\n       fixup_all_virtual_upcast_offsets (type, vi.decl_ptr);\n@@ -2940,17 +2933,10 @@ dfs_get_vbase_types (binfo, data)\n   tree type = (tree) data;\n \n   if (TREE_VIA_VIRTUAL (binfo))\n-    {\n-      tree new_vbase = make_binfo (size_zero_node, \n-\t\t\t\t   BINFO_TYPE (binfo),\n-\t\t\t\t   BINFO_VTABLE (binfo),\n-\t\t\t\t   BINFO_VIRTUALS (binfo));\n-      unshare_base_binfos (new_vbase);\n-      TREE_VIA_VIRTUAL (new_vbase) = 1;\n-      BINFO_INHERITANCE_CHAIN (new_vbase) = TYPE_BINFO (type);\n-      TREE_CHAIN (new_vbase) = CLASSTYPE_VBASECLASSES (type);\n-      CLASSTYPE_VBASECLASSES (type) = new_vbase;\n-    }\n+    CLASSTYPE_VBASECLASSES (type)\n+      = tree_cons (BINFO_TYPE (binfo), \n+\t\t   binfo, \n+\t\t   CLASSTYPE_VBASECLASSES (type));\n   SET_BINFO_MARKED (binfo);\n   return NULL_TREE;\n }\n@@ -3022,7 +3008,7 @@ find_vbase_instance (base, type)\n {\n   tree instance;\n \n-  instance = BINFO_FOR_VBASE (base, type);\n+  instance = binfo_for_vbase (base, type);\n   if (!BINFO_VBASE_PRIMARY_P (instance))\n     return instance;\n \n@@ -3527,3 +3513,17 @@ binfo_from_vbase (binfo)\n     }\n   return 0;\n }\n+\n+/* Returns the BINFO (if any) for the virtual baseclass T of the class\n+   C from the CLASSTYPE_VBASECLASSES list.  */\n+\n+tree\n+binfo_for_vbase (basetype, classtype)\n+     tree basetype;\n+     tree classtype;\n+{\n+  tree binfo;\n+\n+  binfo = purpose_member (basetype, CLASSTYPE_VBASECLASSES (classtype));\n+  return binfo ? TREE_VALUE (binfo) : NULL_TREE;\n+}"}, {"sha": "378fc6be6bd6793bb7c63d2560e74d54eac1b3ef", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a55583e90977b5445ab295de13f82010f2e1bf82/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=a55583e90977b5445ab295de13f82010f2e1bf82", "patch": "@@ -5986,11 +5986,10 @@ get_delta_difference (from, to, force)\n   if (to == from)\n     return delta;\n \n-  /* Should get_base_distance here, so we can check if any thing along the\n-     path is virtual, and we need to make sure we stay\n-     inside the real binfos when going through virtual bases.\n-     Maybe we should replace virtual bases with\n-     binfo_member (...CLASSTYPE_VBASECLASSES...)...  (mrs) */\n+  /* Should get_base_distance here, so we can check if any thing along\n+     the path is virtual, and we need to make sure we stay inside the\n+     real binfos when going through virtual bases.  Maybe we should\n+     replace virtual bases with BINFO_FOR_VBASE ... (mrs) */\n   binfo = get_binfo (from, to, 1);\n   if (binfo == error_mark_node)\n     {\n@@ -6010,7 +6009,7 @@ get_delta_difference (from, to, force)\n \treturn delta;\n       if (binfo_from_vbase (binfo))\n \t{\n-\t  binfo = BINFO_FOR_VBASE (BINFO_TYPE (binfo), from);\n+\t  binfo = binfo_for_vbase (BINFO_TYPE (binfo), from);\n \t  cp_warning (\"pointer to member cast to virtual base `%T' will only work if you are very careful\", BINFO_TYPE (binfo));\n \t}\n       delta = BINFO_OFFSET (binfo);"}]}