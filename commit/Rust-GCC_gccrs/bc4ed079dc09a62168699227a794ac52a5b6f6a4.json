{"sha": "bc4ed079dc09a62168699227a794ac52a5b6f6a4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmM0ZWQwNzlkYzA5YTYyMTY4Njk5MjI3YTc5NGFjNTJhNWI2ZjZhNA==", "commit": {"author": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-06-18T12:11:08Z"}, "committer": {"name": "Julian Brown", "email": "julian@codesourcery.com", "date": "2020-07-27T16:16:57Z"}, "message": "openacc: Deep copy attach/detach should not affect reference counts\n\nAttach and detach operations are not supposed to affect structural or\ndynamic reference counts for OpenACC. Previously they did so, which led to\nsubtle problems in some circumstances. We can avoid reference-counting\nattach/detach operations by extending and slightly repurposing the\ndo_detach field in target_var_desc. It is now called is_attach to better\nreflect its new role.\n\n2020-07-27  Julian Brown  <julian@codesourcery.com>\n\t    Thomas Schwinge  <thomas@codesourcery.com>\n\nlibgomp/\n\t* libgomp.h (struct target_var_desc): Rename do_detach field to\n\tis_attach.\n\t* oacc-mem.c (goacc_exit_datum_1): Add assert.  Don't set finalize for\n\tGOMP_MAP_FORCE_DETACH. Update checking to use is_attach field.\n\t(goacc_enter_data_internal): Don't affect reference counts\n\tfor attach mappings.\n\t(goacc_exit_data_internal): Don't affect reference counts for detach\n\tmappings.\n\t* target.c (gomp_map_vars_existing): Don't affect reference counts for\n\tattach mappings.\n\t(gomp_map_vars_internal): Set renamed is_attach flag unconditionally to\n\tmark attach mappings.\n\t(gomp_unmap_vars_internal): Use is_attach flag to prevent affecting\n\treference count for attach mappings.\n\t* testsuite/libgomp.oacc-c-c++-common/mdc-refcount-1.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/mdc-refcount-2.c: New test.\n\t* testsuite/libgomp.oacc-c-c++-common/mdc-refcount-2.c: New test.\n\t* testsuite/libgomp.oacc-fortran/deep-copy-6-no_finalize.F90: Mark\n\ttest as shouldfail.\n\t* testsuite/libgomp.oacc-fortran/deep-copy-6.f90: Adjust to fail\n\tgracefully in no-finalize mode.\n\nCo-Authored-By: Thomas Schwinge <thomas@codesourcery.com>", "tree": {"sha": "48c5dac67ba13e457724af37f8cec35501cf3d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48c5dac67ba13e457724af37f8cec35501cf3d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bc4ed079dc09a62168699227a794ac52a5b6f6a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4ed079dc09a62168699227a794ac52a5b6f6a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc4ed079dc09a62168699227a794ac52a5b6f6a4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc4ed079dc09a62168699227a794ac52a5b6f6a4/comments", "author": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jtb20", "id": 6094880, "node_id": "MDQ6VXNlcjYwOTQ4ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/6094880?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jtb20", "html_url": "https://github.com/jtb20", "followers_url": "https://api.github.com/users/jtb20/followers", "following_url": "https://api.github.com/users/jtb20/following{/other_user}", "gists_url": "https://api.github.com/users/jtb20/gists{/gist_id}", "starred_url": "https://api.github.com/users/jtb20/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jtb20/subscriptions", "organizations_url": "https://api.github.com/users/jtb20/orgs", "repos_url": "https://api.github.com/users/jtb20/repos", "events_url": "https://api.github.com/users/jtb20/events{/privacy}", "received_events_url": "https://api.github.com/users/jtb20/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2251b4a5423efa8ee0d7e67537b63e404a1f6afa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2251b4a5423efa8ee0d7e67537b63e404a1f6afa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2251b4a5423efa8ee0d7e67537b63e404a1f6afa"}], "stats": {"total": 350, "additions": 324, "deletions": 26}, "files": [{"sha": "f9080e9f70f91dee636185bdba45c7260f0c35a7", "filename": "libgomp/libgomp.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Flibgomp.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Flibgomp.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.h?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -952,8 +952,8 @@ struct target_var_desc {\n   bool copy_from;\n   /* True if data always should be copied from device to host at the end.  */\n   bool always_copy_from;\n-  /* True if variable should be detached at end of region.  */\n-  bool do_detach;\n+  /* True if this is for OpenACC 'attach'.  */\n+  bool is_attach;\n   /* Relative offset against key host_start.  */\n   uintptr_t offset;\n   /* Actual length.  */"}, {"sha": "65757ab2ffcac2893fd5ee83b4c1d42a387f3b38", "filename": "libgomp/oacc-mem.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Foacc-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Foacc-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Foacc-mem.c?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -667,6 +667,9 @@ static void\n goacc_exit_datum_1 (struct gomp_device_descr *acc_dev, void *h, size_t s,\n \t\t    unsigned short kind, splay_tree_key n, goacc_aq aq)\n {\n+  assert (kind != GOMP_MAP_DETACH\n+\t  && kind != GOMP_MAP_FORCE_DETACH);\n+\n   if ((uintptr_t) h < n->host_start || (uintptr_t) h + s > n->host_end)\n     {\n       size_t host_size = n->host_end - n->host_start;\n@@ -676,8 +679,7 @@ goacc_exit_datum_1 (struct gomp_device_descr *acc_dev, void *h, size_t s,\n     }\n \n   bool finalize = (kind == GOMP_MAP_FORCE_FROM\n-\t\t   || kind == GOMP_MAP_DELETE\n-\t\t   || kind == GOMP_MAP_FORCE_DETACH);\n+\t\t   || kind == GOMP_MAP_DELETE);\n \n   assert (n->refcount != REFCOUNT_LINK);\n   if (n->refcount != REFCOUNT_INFINITY\n@@ -725,7 +727,8 @@ goacc_exit_datum_1 (struct gomp_device_descr *acc_dev, void *h, size_t s,\n \t     zero.  Otherwise (e.g. for a 'GOMP_MAP_STRUCT' mapping with\n \t     multiple members), fall back to skipping the test.  */\n \t  for (size_t l_i = 0; l_i < n->tgt->list_count; ++l_i)\n-\t    if (n->tgt->list[l_i].key)\n+\t    if (n->tgt->list[l_i].key\n+\t\t&& !n->tgt->list[l_i].is_attach)\n \t      ++num_mappings;\n \t  bool is_tgt_unmapped = gomp_remove_var (acc_dev, n);\n \t  assert (is_tgt_unmapped || num_mappings > 1);\n@@ -1135,12 +1138,15 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  void *h = hostaddrs[i];\n \t  size_t s = sizes[i];\n \n-\t  /* A standalone attach clause.  */\n \t  if ((kinds[i] & 0xff) == GOMP_MAP_ATTACH)\n-\t    gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n,\n-\t\t\t\t (uintptr_t) h, s, NULL);\n-\n-\t  goacc_map_var_existing (acc_dev, h, s, n);\n+\t    {\n+\t      gomp_attach_pointer (acc_dev, aq, &acc_dev->mem_map, n,\n+\t\t\t\t   (uintptr_t) h, s, NULL);\n+\t      /* OpenACC 'attach'/'detach' doesn't affect structured/dynamic\n+\t\t reference counts ('n->refcount', 'n->dynamic_refcount').  */\n+\t    }\n+\t  else\n+\t    goacc_map_var_existing (acc_dev, h, s, n);\n \t}\n       else if (n && groupnum > 1)\n \t{\n@@ -1168,7 +1174,9 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t\t   list, and increment the refcounts for each item in that\n \t\t   group.  */\n \t\tfor (size_t k = 0; k < groupnum; k++)\n-\t\t  if (j + k < tgt->list_count && tgt->list[j + k].key)\n+\t\t  if (j + k < tgt->list_count\n+\t\t      && tgt->list[j + k].key\n+\t\t      && !tgt->list[j + k].is_attach)\n \t\t    {\n \t\t      tgt->list[j + k].key->refcount++;\n \t\t      tgt->list[j + k].key->dynamic_refcount++;\n@@ -1202,7 +1210,7 @@ goacc_enter_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t  for (size_t j = 0; j < tgt->list_count; j++)\n \t    {\n \t      n = tgt->list[j].key;\n-\t      if (n)\n+\t      if (n && !tgt->list[j].is_attach)\n \t\tn->dynamic_refcount++;\n \t    }\n \t}\n@@ -1268,14 +1276,10 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \tcase GOMP_MAP_POINTER:\n \tcase GOMP_MAP_DELETE:\n \tcase GOMP_MAP_RELEASE:\n-\tcase GOMP_MAP_DETACH:\n-\tcase GOMP_MAP_FORCE_DETACH:\n \t  {\n \t    struct splay_tree_key_s cur_node;\n \t    size_t size;\n-\t    if (kind == GOMP_MAP_POINTER\n-\t\t|| kind == GOMP_MAP_DETACH\n-\t\t|| kind == GOMP_MAP_FORCE_DETACH)\n+\t    if (kind == GOMP_MAP_POINTER)\n \t      size = sizeof (void *);\n \t    else\n \t      size = sizes[i];\n@@ -1298,6 +1302,12 @@ goacc_exit_data_internal (struct gomp_device_descr *acc_dev, size_t mapnum,\n \t     'GOMP_MAP_STRUCT's anymore.  */\n \t  break;\n \n+\tcase GOMP_MAP_DETACH:\n+\tcase GOMP_MAP_FORCE_DETACH:\n+\t  /* OpenACC 'attach'/'detach' doesn't affect structured/dynamic\n+\t     reference counts ('n->refcount', 'n->dynamic_refcount').  */\n+\t  break;\n+\n \tdefault:\n \t  gomp_fatal (\">>>> goacc_exit_data_internal UNHANDLED kind 0x%.2x\",\n \t\t\t  kind);"}, {"sha": "3e292eb8c627576092f0b54fefd0141496753f18", "filename": "libgomp/target.c", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftarget.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftarget.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftarget.c?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -362,7 +362,7 @@ gomp_map_vars_existing (struct gomp_device_descr *devicep,\n   tgt_var->key = oldn;\n   tgt_var->copy_from = GOMP_MAP_COPY_FROM_P (kind);\n   tgt_var->always_copy_from = GOMP_MAP_ALWAYS_FROM_P (kind);\n-  tgt_var->do_detach = false;\n+  tgt_var->is_attach = false;\n   tgt_var->offset = newn->host_start - oldn->host_start;\n   tgt_var->length = newn->host_end - newn->host_start;\n \n@@ -1093,9 +1093,10 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t      tgt->list[i].length = n->host_end - n->host_start;\n \t\t      tgt->list[i].copy_from = false;\n \t\t      tgt->list[i].always_copy_from = false;\n-\t\t      tgt->list[i].do_detach\n-\t\t\t= (pragma_kind != GOMP_MAP_VARS_ENTER_DATA);\n-\t\t      n->refcount++;\n+\t\t      tgt->list[i].is_attach = true;\n+\t\t      /* OpenACC 'attach'/'detach' doesn't affect\n+\t\t\t structured/dynamic reference counts ('n->refcount',\n+\t\t\t 'n->dynamic_refcount').  */\n \t\t    }\n \t\t  else\n \t\t    {\n@@ -1151,7 +1152,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\ttgt->list[i].copy_from = GOMP_MAP_COPY_FROM_P (kind & typemask);\n \t\ttgt->list[i].always_copy_from\n \t\t  = GOMP_MAP_ALWAYS_FROM_P (kind & typemask);\n-\t\ttgt->list[i].do_detach = false;\n+\t\ttgt->list[i].is_attach = false;\n \t\ttgt->list[i].offset = 0;\n \t\ttgt->list[i].length = k->host_end - k->host_start;\n \t\tk->refcount = 1;\n@@ -1206,7 +1207,7 @@ gomp_map_vars_internal (struct gomp_device_descr *devicep,\n \t\t\t  tgt->list[j].key = k;\n \t\t\t  tgt->list[j].copy_from = false;\n \t\t\t  tgt->list[j].always_copy_from = false;\n-\t\t\t  tgt->list[j].do_detach = false;\n+\t\t\t  tgt->list[j].is_attach = false;\n \t\t\t  if (k->refcount != REFCOUNT_INFINITY)\n \t\t\t    k->refcount++;\n \t\t\t  gomp_map_pointer (tgt, aq,\n@@ -1434,7 +1435,7 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n     {\n       splay_tree_key k = tgt->list[i].key;\n \n-      if (k != NULL && tgt->list[i].do_detach)\n+      if (k != NULL && tgt->list[i].is_attach)\n \tgomp_detach_pointer (devicep, aq, k, tgt->list[i].key->host_start\n \t\t\t\t\t     + tgt->list[i].offset,\n \t\t\t     false, NULL);\n@@ -1446,6 +1447,11 @@ gomp_unmap_vars_internal (struct target_mem_desc *tgt, bool do_copyfrom,\n       if (k == NULL)\n \tcontinue;\n \n+      /* OpenACC 'attach'/'detach' doesn't affect structured/dynamic reference\n+\t counts ('n->refcount', 'n->dynamic_refcount').  */\n+      if (tgt->list[i].is_attach)\n+\tcontinue;\n+\n       bool do_unmap = false;\n       if (k->refcount > 1 && k->refcount != REFCOUNT_INFINITY)\n \tk->refcount--;"}, {"sha": "6170447e7d31372eddc9f5bf6b7093d68634db52", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/mdc-refcount-1.c", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-1.c?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -0,0 +1,60 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+#include <openacc.h>\n+#include <assert.h>\n+\n+#define N 1024\n+\n+struct mystr {\n+  int *data;\n+};\n+\n+static void\n+test (unsigned variant)\n+{\n+  int arr[N];\n+  struct mystr s;\n+\n+  s.data = arr;\n+\n+  acc_copyin (&s, sizeof (s));\n+  acc_create (s.data, N * sizeof (int));\n+\n+  for (int i = 0; i < 20; i++)\n+    {\n+      if ((variant + i) % 1)\n+\t{\n+#pragma acc enter data attach(s.data)\n+\t}\n+      else\n+\tacc_attach ((void **) &s.data);\n+\n+      if ((variant + i) % 2)\n+\t{\n+#pragma acc exit data detach(s.data)\n+\t}\n+      else\n+\tacc_detach ((void **) &s.data);\n+    }\n+\n+  assert (acc_is_present (arr, N * sizeof (int)));\n+  assert (acc_is_present (&s, sizeof (s)));\n+\n+  acc_delete (arr, N * sizeof (int));\n+\n+  assert (!acc_is_present (arr, N * sizeof (int)));\n+\n+  acc_copyout (&s, sizeof (s));\n+\n+  assert (!acc_is_present (&s, sizeof (s)));\n+  assert (s.data == arr);\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  for (unsigned variant = 0; variant < 4; ++variant)\n+    test (variant);\n+\n+  return 0;\n+}"}, {"sha": "2431a76a805c6f230689b30a75f4239561c9637e", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/mdc-refcount-2.c", "status": "added", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-2.c?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -0,0 +1,123 @@\n+/* Verify that OpenACC 'attach'/'detach' doesn't interfere with reference\n+   counting.  */\n+\n+#include <assert.h>\n+#include <stdlib.h>\n+#include <openacc.h>\n+\n+/* Need to shared this (and, in particular, implicit '&data_work' in\n+   'attach'/'detach' clauses) between 'test' and 'test_'.  */\n+static unsigned char *data_work;\n+\n+static void test_(unsigned variant,\n+\t\t  unsigned char *data,\n+\t\t  void *data_d)\n+{\n+  assert(acc_is_present(&data_work, sizeof data_work));\n+  assert(data_work == data);\n+\n+  acc_update_self(&data_work, sizeof data_work);\n+  assert(data_work == data);\n+\n+  if (variant & 1)\n+    {\n+#pragma acc enter data attach(data_work)\n+    }\n+  else\n+    acc_attach((void **) &data_work);\n+  acc_update_self(&data_work, sizeof data_work);\n+  assert(data_work == data_d);\n+\n+  if (variant & 4)\n+    {\n+      if (variant & 2)\n+\t{ // attach some more\n+\t  data_work = data;\n+\t  acc_attach((void **) &data_work);\n+#pragma acc enter data attach(data_work)\n+\t  acc_attach((void **) &data_work);\n+#pragma acc enter data attach(data_work)\n+#pragma acc enter data attach(data_work)\n+#pragma acc enter data attach(data_work)\n+\t  acc_attach((void **) &data_work);\n+\t  acc_attach((void **) &data_work);\n+#pragma acc enter data attach(data_work)\n+\t}\n+      else\n+\t{}\n+    }\n+  else\n+    { // detach\n+      data_work = data;\n+      if (variant & 2)\n+\t{\n+#pragma acc exit data detach(data_work)\n+\t}\n+      else\n+\tacc_detach((void **) &data_work);\n+      acc_update_self(&data_work, sizeof data_work);\n+      assert(data_work == data);\n+\n+      // now not attached anymore\n+\n+#if 0\n+      if (TODO)\n+\t{\n+\t  acc_detach(&data_work); //TODO PR95203 \"libgomp: attach count underflow\"\n+\t  acc_update_self(&data_work, sizeof data_work);\n+\t  assert(data_work == data);\n+\t}\n+#endif\n+    }\n+\n+  assert(acc_is_present(&data_work, sizeof data_work));\n+}\n+\n+static void test(unsigned variant)\n+{\n+  const int size = sizeof (void *);\n+  unsigned char *data = (unsigned char *) malloc(size);\n+  assert(data);\n+  void *data_d = acc_create(data, size);\n+  assert(data_d);\n+  assert(acc_is_present(data, size));\n+\n+  data_work = data;\n+\n+  if (variant & 8)\n+    {\n+#pragma acc data copyin(data_work)\n+      test_(variant, data, data_d);\n+    }\n+  else\n+    {\n+      acc_copyin(&data_work, sizeof data_work);\n+      test_(variant, data, data_d);\n+      acc_delete(&data_work, sizeof data_work);\n+    }\n+#if ACC_MEM_SHARED\n+  assert(acc_is_present(&data_work, sizeof data_work));\n+#else\n+  assert(!acc_is_present(&data_work, sizeof data_work));\n+#endif\n+  data_work = NULL;\n+\n+  assert(acc_is_present(data, size));\n+  acc_delete(data, size);\n+  data_d = NULL;\n+#if ACC_MEM_SHARED\n+  assert(acc_is_present(data, size));\n+#else\n+  assert(!acc_is_present(data, size));\n+#endif\n+  free(data);\n+  data = NULL;\n+}\n+\n+int main()\n+{\n+  for (size_t i = 0; i < 16; ++i)\n+    test(i);\n+\n+  return 0;\n+}"}, {"sha": "0f5e7becada8b1da688def995d36971f97669d96", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/mdc-refcount-3.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fmdc-refcount-3.c?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -0,0 +1,86 @@\n+/* { dg-skip-if \"\" { *-*-* } { \"-DACC_MEM_SHARED=1\" } } */\n+\n+/* Variant of 'deep-copy-7.c'.  */\n+\n+#include <stdlib.h>\n+#include <assert.h>\n+#include <openacc.h>\n+\n+struct dc\n+{\n+  int a;\n+  int *b;\n+};\n+\n+int\n+main ()\n+{\n+  int n = 100, i, j, k;\n+  struct dc v = { .a = 3 };\n+\n+  v.b = (int *) malloc (sizeof (int) * n);\n+\n+  for (k = 0; k < 16; k++)\n+    {\n+      /* Here, we do not explicitly copy the enclosing structure, but work\n+\t with fields directly.  Make sure attachment counters and reference\n+\t counters work properly in that case.  */\n+#pragma acc enter data copyin(v.a, v.b[0:n]) // 1\n+      assert (acc_is_present (&v.b, sizeof v.b));\n+      assert (acc_is_present (v.b, sizeof (int) * n));\n+#pragma acc enter data pcopyin(v.b[0:n]) // 2\n+#pragma acc enter data pcopyin(v.b[0:n]) // 3\n+\n+#pragma acc parallel loop present(v.a, v.b)\n+      for (i = 0; i < n; i++)\n+\tv.b[i] = k + v.a + i;\n+\n+      switch (k % 5)\n+\t{ // All optional.\n+\tcase 0:\n+\t  break;\n+\tcase 1:\n+\t  ; //TODO PR95901\n+#pragma acc exit data detach(v.b) finalize\n+\t  break;\n+\tcase 2:\n+\t  ; //TODO PR95901\n+#pragma acc exit data detach(v.b)\n+\t  break;\n+\tcase 3:\n+\t  acc_detach_finalize ((void **) &v.b);\n+\t  break;\n+\tcase 4:\n+\t  acc_detach ((void **) &v.b);\n+\t  break;\n+\t}\n+      assert (acc_is_present (&v.b, sizeof v.b));\n+      assert (acc_is_present (v.b, sizeof (int) * n));\n+      { // 3\n+\tacc_delete (&v.b, sizeof v.b);\n+\tassert (acc_is_present (&v.b, sizeof v.b));\n+\tacc_copyout (v.b, sizeof (int) * n);\n+\tassert (acc_is_present (v.b, sizeof (int) * n));\n+      }\n+      { // 2\n+\tacc_delete (&v.b, sizeof v.b);\n+\tassert (acc_is_present (&v.b, sizeof v.b));\n+\tacc_copyout (v.b, sizeof (int) * n);\n+\tassert (acc_is_present (v.b, sizeof (int) * n));\n+      }\n+      { // 1\n+\tacc_delete (&v.b, sizeof v.b);\n+\tassert (!acc_is_present (&v.b, sizeof v.b));\n+\tacc_copyout (v.b, sizeof (int) * n);\n+\tassert (!acc_is_present (v.b, sizeof (int) * n));\n+      }\n+#pragma acc exit data delete(v.a)\n+\n+      for (i = 0; i < n; i++)\n+\tassert (v.b[i] == k + v.a + i);\n+\n+      assert (!acc_is_present (&v, sizeof (v)));\n+    }\n+\n+  return 0;\n+}"}, {"sha": "1daff2dadf1167b13614365f80b88a82cc707a2b", "filename": "libgomp/testsuite/libgomp.oacc-fortran/deep-copy-6-no_finalize.F90", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6-no_finalize.F90?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -1,5 +1,12 @@\n ! { dg-do run }\n \n-/* Nullify the 'finalize' clause.  */\n+/* Nullify the 'finalize' clause.\n+\n+   That means, we do not detach properly, the host sees a device pointer, and\n+   we fail as follows.\n+   { dg-output \"STOP 30(\\n|\\r\\n|\\r)+\" { target { ! openacc_host_selected } } }\n+   { dg-shouldfail \"\" { ! openacc_host_selected } }\n+*/\n #define finalize\n #include \"deep-copy-6.f90\"\n+"}, {"sha": "94ddca3bce8eb42de3d42400fb4fd9a7a0a47c8a", "filename": "libgomp/testsuite/libgomp.oacc-fortran/deep-copy-6.f90", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bc4ed079dc09a62168699227a794ac52a5b6f6a4/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-fortran%2Fdeep-copy-6.f90?ref=bc4ed079dc09a62168699227a794ac52a5b6f6a4", "patch": "@@ -12,11 +12,14 @@ program dtype\n   end type mytype\n   integer i\n \n-  type(mytype) :: var\n+  type(mytype), target :: var\n+  integer, pointer :: hostptr(:)\n \n   allocate(var%a(1:n))\n   allocate(var%b(1:n))\n \n+  hostptr => var%a\n+\n !$acc data copy(var)\n \n   do i = 1, n\n@@ -49,6 +52,9 @@ program dtype\n \n !$acc end data\n \n+  ! See 'deep-copy-6-no_finalize.F90'.\n+  if (.not. associated(hostptr, var%a)) stop 30\n+\n   do i = 1,4\n     if (var%a(i) .ne. 0) stop 1\n     if (var%b(i) .ne. 0) stop 2"}]}