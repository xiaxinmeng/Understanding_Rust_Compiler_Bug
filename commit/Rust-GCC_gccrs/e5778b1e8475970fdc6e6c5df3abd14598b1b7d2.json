{"sha": "e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU3NzhiMWU4NDc1OTcwZmRjNmU2YzVkZjNhYmQxNDU5OGIxYjdkMg==", "commit": {"author": {"name": "Kaveh R. Ghazi", "email": "ghazi@caip.rutgers.edu", "date": "2000-01-12T19:50:19Z"}, "committer": {"name": "Kaveh Ghazi", "email": "ghazi@gcc.gnu.org", "date": "2000-01-12T19:50:19Z"}, "message": "m88k-protos.h: New file.\n\n        * m88k-protos.h: New file.\n\n        * m88k.c: Include tm_p.h.  Add static prototypes.  Fix compile\n        time warnings.\n\n        * m88k.h: Move prototypes to m88k-protos.h.  Fix compile time warnings.\n\n        * m88k.md: Likewise.\n\n        * tekXD88.h: Likewise.\n\nFrom-SVN: r31359", "tree": {"sha": "e6a1c470ce2f2c6f93f25f0ef5eb58ef5102fc2a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e6a1c470ce2f2c6f93f25f0ef5eb58ef5102fc2a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/comments", "author": null, "committer": null, "parents": [{"sha": "5505f548bb1e7140e23b3db245fe28c747fb1b77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5505f548bb1e7140e23b3db245fe28c747fb1b77", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5505f548bb1e7140e23b3db245fe28c747fb1b77"}], "stats": {"total": 377, "additions": 237, "deletions": 140}, "files": [{"sha": "38d3bddeb125a33dbe6b24cea86040e8da70924f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -1,3 +1,16 @@\n+2000-01-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n+\n+\t* m88k-protos.h: New file.\n+\n+\t* m88k.c: Include tm_p.h.  Add static prototypes.  Fix compile\n+\ttime warnings.\n+\t\n+\t* m88k.h: Move prototypes to m88k-protos.h.  Fix compile time warnings.\n+\t\n+\t* m88k.md: Likewise.\n+\n+\t* tekXD88.h: Likewise.\n+\n 2000-01-12  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* m68k-protos.h: New file."}, {"sha": "2812b20060a079fc237fdd83a1406e1639ce1855", "filename": "gcc/config/m88k/m88k-protos.h", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k-protos.h?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -0,0 +1,108 @@\n+/* Definitions of target machine for GNU compiler for\n+   Motorola m88100 in an 88open OCS/BCS environment.\n+   Copyright (C) 2000 Free Software Foundation, Inc.\n+   Contributed by Michael Tiemann (tiemann@cygnus.com).\n+   Currently maintained by (gcc@dg-rtp.dg.com)\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+#ifdef RTX_CODE\n+extern int m88k_debugger_offset PARAMS ((rtx, int));\n+extern void emit_bcnd PARAMS ((enum rtx_code, rtx));\n+extern void expand_block_move PARAMS ((rtx, rtx, rtx *));\n+extern void print_operand PARAMS ((FILE *, rtx, int));\n+extern void print_operand_address PARAMS ((FILE *, rtx));\n+extern const char *output_load_const_int PARAMS ((enum machine_mode, rtx *));\n+extern const char *output_load_const_float PARAMS ((rtx *));\n+extern const char *output_load_const_double PARAMS ((rtx *));\n+extern const char *output_load_const_dimode PARAMS ((rtx *));\n+extern const char *output_and PARAMS ((rtx[]));\n+extern const char *output_ior PARAMS ((rtx[]));\n+extern const char *output_xor PARAMS ((rtx[]));\n+extern const char *output_call PARAMS ((rtx[], rtx));\n+\n+extern struct rtx_def *emit_test PARAMS ((enum rtx_code, enum machine_mode));\n+extern struct rtx_def *legitimize_address PARAMS ((int, rtx, rtx, rtx));\n+extern struct rtx_def *legitimize_operand PARAMS ((rtx, enum machine_mode));\n+\n+extern int pic_address_needs_scratch PARAMS ((rtx));\n+extern int symbolic_address_p PARAMS ((rtx));\n+extern int condition_value PARAMS ((rtx));\n+extern int emit_move_sequence PARAMS ((rtx *, enum machine_mode, rtx));\n+extern int mostly_false_jump PARAMS ((rtx, rtx));\n+extern int real_power_of_2_operand PARAMS ((rtx, enum machine_mode));\n+extern int move_operand PARAMS ((rtx, enum machine_mode));\n+extern int call_address_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_0_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith5_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith32_operand PARAMS ((rtx, enum machine_mode));\n+extern int arith64_operand PARAMS ((rtx, enum machine_mode));\n+extern int int5_operand PARAMS ((rtx, enum machine_mode));\n+extern int int32_operand PARAMS ((rtx, enum machine_mode));\n+extern int add_operand PARAMS ((rtx, enum machine_mode));\n+extern int reg_or_bbx_mask_operand PARAMS ((rtx, enum machine_mode));\n+extern int real_or_0_operand PARAMS ((rtx, enum machine_mode));\n+extern int partial_ccmode_register_operand PARAMS ((rtx, enum machine_mode));\n+extern int relop PARAMS ((rtx, enum machine_mode));\n+extern int even_relop PARAMS ((rtx, enum machine_mode));\n+extern int odd_relop PARAMS ((rtx, enum machine_mode));\n+extern int relop_no_unsigned PARAMS ((rtx, enum machine_mode));\n+extern int equality_op PARAMS ((rtx, enum machine_mode));\n+extern int pc_or_label_ref PARAMS ((rtx, enum machine_mode));\n+extern int symbolic_operand PARAMS ((rtx, enum machine_mode));\n+#ifdef TREE_CODE\n+extern void m88k_va_start PARAMS ((int, tree, rtx));\n+#endif /* TREE_CODE */\n+#endif /* RTX_CODE */\n+\n+#ifdef ANSI_PROTOTYPES\n+struct m88k_lang_independent_options;\n+#endif\n+extern void output_file_start PARAMS ((FILE *,\n+\t\t\t\t       struct m88k_lang_independent_options *,\n+\t\t\t\t       int,\n+\t\t\t\t       struct m88k_lang_independent_options *,\n+\t\t\t\t       int));\n+\n+extern int null_prologue PARAMS ((void));\n+extern int integer_ok_for_set PARAMS ((unsigned));\n+extern void m88k_layout_frame PARAMS ((void));\n+extern void m88k_expand_prologue PARAMS ((void));\n+extern void m88k_begin_prologue PARAMS ((FILE *, int));\n+extern void m88k_end_prologue PARAMS ((FILE *));\n+extern void m88k_expand_epilogue PARAMS ((void));\n+extern void m88k_begin_epilogue PARAMS ((FILE *));\n+extern void m88k_end_epilogue PARAMS ((FILE *, int));\n+extern void output_function_profiler PARAMS ((FILE *, int, const char *, int));\n+extern void output_function_block_profiler PARAMS ((FILE *, int));\n+extern void output_block_profiler PARAMS ((FILE *, int));\n+extern void output_ascii PARAMS ((FILE *, const char *, int,\n+\t\t\t\t  const unsigned char *, int));\n+extern void output_label PARAMS ((int));\n+extern struct rtx_def *m88k_builtin_saveregs PARAMS ((void));\n+extern enum m88k_instruction classify_integer PARAMS ((enum machine_mode, int));\n+extern int mak_mask_p PARAMS ((int));\n+\n+#ifdef TREE_CODE\n+extern struct rtx_def *m88k_function_arg PARAMS ((CUMULATIVE_ARGS,\n+\t\t\t\t\t\t  enum machine_mode, tree,\n+\t\t\t\t\t\t  int));\n+extern struct rtx_def *m88k_va_arg PARAMS ((tree, tree));\n+extern tree m88k_build_va_list PARAMS ((void));\n+#endif /* TREE_CODE */"}, {"sha": "4e3ce2c94c344d1c1a03b8587b848336d7947191", "filename": "gcc/config/m88k/m88k.c", "status": "modified", "additions": 87, "deletions": 70, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.c?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -1,5 +1,5 @@\n /* Subroutines for insn-output.c for Motorola 88000.\n-   Copyright (C) 1988, 92, 93, 94, 95, 96, 1997, 1998, 1999 Free Software\n+   Copyright (C) 1988, 92-99, 2000 Free Software\n    Foundation, Inc. \n    Contributed by Michael Tiemann (tiemann@mcc.com)\n    Currently maintained by (gcc@dg-rtp.dg.com)\n@@ -37,14 +37,17 @@ Boston, MA 02111-1307, USA.  */\n #include \"c-tree.h\"\n #include \"expr.h\"\n #include \"flags.h\"\n+#include \"recog.h\"\n+#include \"toplev.h\"\n+#include \"tm_p.h\"\n \n extern char *version_string;\n extern int flag_traditional;\n extern FILE *asm_out_file;\n \n-char *m88k_pound_sign = \"\";\t/* Either # for SVR4 or empty for SVR3 */\n-char *m88k_short_data;\n-char *m88k_version;\n+const char *m88k_pound_sign = \"\"; /* Either # for SVR4 or empty for SVR3 */\n+const char *m88k_short_data;\n+const char *m88k_version;\n char m88k_volatile_code;\n \n unsigned m88k_gp_threshold = 0;\n@@ -68,8 +71,6 @@ classify_integer (mode, value)\n      enum machine_mode mode;\n      register int value;\n {\n-  register int mask;\n-\n   if (value == 0)\n     return m88k_zero;\n   else if (SMALL_INTVAL (value))\n@@ -120,12 +121,12 @@ integer_ok_for_set (value)\n   return (value && POWER_OF_2_or_0 (mask + 1));\n }\n \n-char *\n+const char *\n output_load_const_int (mode, operands)\n      enum machine_mode mode;\n      rtx *operands;\n {\n-  static char *patterns[] =\n+  static const char *const patterns[] =\n     { \"or %0,%#r0,0\",\n       \"or %0,%#r0,%1\",\n       \"subu %0,%#r0,%n1\",\n@@ -145,7 +146,7 @@ output_load_const_int (mode, operands)\n /* These next two routines assume that floating point numbers are represented\n    in a manner which is consistent between host and target machines.  */\n \n-char *\n+const char *\n output_load_const_float (operands)\n      rtx *operands;\n {\n@@ -156,7 +157,7 @@ output_load_const_float (operands)\n   return output_load_const_int (SImode, operands);\n }\n \n-char *\n+const char *\n output_load_const_double (operands)\n      rtx *operands;\n {\n@@ -178,7 +179,7 @@ output_load_const_double (operands)\n   return output_load_const_int (SImode, operands);\n }\n \n-char *\n+const char *\n output_load_const_dimode (operands)\n      rtx *operands;\n {\n@@ -340,7 +341,7 @@ legitimize_address (pic, orig, reg, scratch)\n \t}\n       else if (GET_CODE (addr) == CONST)\n \t{\n-\t  rtx base, offset;\n+\t  rtx base;\n \n \t  if (GET_CODE (XEXP (addr, 0)) == PLUS\n \t      && XEXP (XEXP (addr, 0), 0) == pic_offset_table_rtx)\n@@ -466,17 +467,21 @@ static int max_from_align[] = {0, MOVSTR_QI, MOVSTR_HI, 0, MOVSTR_SI,\n static int all_from_align[] = {0, MOVSTR_QI, MOVSTR_ODD_HI, 0, MOVSTR_ODD_SI,\n \t\t\t       0, 0, 0, MOVSTR_ODD_DI};\n \n-static int best_from_align[3][9] =\n-  {0, MOVSTR_QI_LIMIT_88100, MOVSTR_HI_LIMIT_88100, 0, MOVSTR_SI_LIMIT_88100, \n-   0, 0, 0, MOVSTR_DI_LIMIT_88100,\n-   0, MOVSTR_QI_LIMIT_88110, MOVSTR_HI_LIMIT_88110, 0, MOVSTR_SI_LIMIT_88110, \n-   0, 0, 0, MOVSTR_DI_LIMIT_88110,  \n-   0, MOVSTR_QI_LIMIT_88000, MOVSTR_HI_LIMIT_88000, 0, MOVSTR_SI_LIMIT_88000,\n-   0, 0, 0, MOVSTR_DI_LIMIT_88000};\n+static int best_from_align[3][9] = {\n+  {0, MOVSTR_QI_LIMIT_88100, MOVSTR_HI_LIMIT_88100, 0, MOVSTR_SI_LIMIT_88100,\n+   0, 0, 0, MOVSTR_DI_LIMIT_88100},\n+  {0, MOVSTR_QI_LIMIT_88110, MOVSTR_HI_LIMIT_88110, 0, MOVSTR_SI_LIMIT_88110,\n+   0, 0, 0, MOVSTR_DI_LIMIT_88110},\n+  {0, MOVSTR_QI_LIMIT_88000, MOVSTR_HI_LIMIT_88000, 0, MOVSTR_SI_LIMIT_88000,\n+   0, 0, 0, MOVSTR_DI_LIMIT_88000}\n+};\n \n-static void block_move_loop ();\n-static void block_move_no_loop ();\n-static void block_move_sequence ();\n+static void block_move_loop PARAMS ((rtx, rtx, rtx, rtx, int, int));\n+static void block_move_no_loop PARAMS ((rtx, rtx, rtx, rtx, int, int));\n+static void block_move_sequence PARAMS ((rtx, rtx, rtx, rtx, int, int, int));\n+static void output_short_branch_defs PARAMS ((FILE *));\n+static int output_option PARAMS ((FILE *, const char *, const char *,\n+\t\t\t\t  const char *, const char *, int, int));\n \n /* Emit code to perform a block move.  Choose the best method.\n \n@@ -751,7 +756,7 @@ block_move_sequence (dest, dest_mem, src, src_mem, size, align, offset)\n \f\n /* Emit the code to do an AND operation.  */\n \n-char *\n+const char *\n output_and (operands)\n      rtx operands[];\n {\n@@ -777,7 +782,7 @@ output_and (operands)\n \n /* Emit the code to do an inclusive OR operation.  */\n \n-char *\n+const char *\n output_ior (operands)\n      rtx operands[];\n {\n@@ -799,7 +804,7 @@ output_ior (operands)\n \n /* Emit the instructions for doing an XOR.  */\n \n-char *\n+const char *\n output_xor (operands)\n      rtx operands[];\n {\n@@ -831,7 +836,7 @@ static rtx sb_name = 0;\n static rtx sb_high = 0;\n static rtx sb_low = 0;\n \n-char *\n+const char *\n output_call (operands, addr)\n      rtx operands[];\n      rtx addr;\n@@ -852,7 +857,7 @@ output_call (operands, addr)\n       if (GET_CODE (jump) == JUMP_INSN)\n \t{\n \t  rtx low, high;\n-\t  char *last;\n+\t  const char *last;\n \t  rtx dest = XEXP (SET_SRC (PATTERN (jump)), 0);\n \t  int delta = 4 * (insn_addresses[INSN_UID (dest)]\n \t\t\t   - insn_addresses[INSN_UID (seq_insn)]\n@@ -1071,6 +1076,8 @@ mostly_false_jump (jump_insn, condition)\n       if (XEXP (condition, 1) == const0_rtx)\n \treturn 0;\n       break;\n+    default:\n+      break;\n     }\n \n   return 0;\n@@ -1082,7 +1089,7 @@ mostly_false_jump (jump_insn, condition)\n int\n real_power_of_2_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   union {\n     REAL_VALUE_TYPE d;\n@@ -1196,7 +1203,7 @@ move_operand (op, mode)\n int\n call_address_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (REG_P (op) || symbolic_address_p (op));\n }\n@@ -1278,15 +1285,15 @@ arith64_operand (op, mode)\n int\n int5_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == CONST_INT && (unsigned) INTVAL (op) < 32);\n }\n \n int\n int32_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == CONST_INT);\n }\n@@ -1353,7 +1360,7 @@ real_or_0_operand (op, mode)\n int\n partial_ccmode_register_operand (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return register_operand (op, CCmode) || register_operand (op, CCEVENmode);\n }\n@@ -1363,7 +1370,7 @@ partial_ccmode_register_operand (op, mode)\n int\n relop (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (op))\n     {\n@@ -1386,7 +1393,7 @@ relop (op, mode)\n int\n even_relop (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (op))\n     {\n@@ -1404,7 +1411,7 @@ even_relop (op, mode)\n int\n odd_relop (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (op))\n     {\n@@ -1425,7 +1432,7 @@ odd_relop (op, mode)\n int\n relop_no_unsigned (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   switch (GET_CODE (op))\n     {\n@@ -1454,7 +1461,7 @@ relop_no_unsigned (op, mode)\n int\n equality_op (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == EQ || GET_CODE (op) == NE);\n }\n@@ -1464,52 +1471,61 @@ equality_op (op, mode)\n int\n pc_or_label_ref (op, mode)\n      rtx op;\n-     enum machine_mode mode;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n {\n   return (GET_CODE (op) == PC || GET_CODE (op) == LABEL_REF);\n }\n \f\n /* Output to FILE the start of the assembler file.  */\n \n-struct options\n+/* This definition must match lang_independent_options from toplev.c.  */\n+struct m88k_lang_independent_options\n {\n-  char *string;\n+  const char *string;\n   int *variable;\n   int on_value;\n-  char *description;\n+  const char *description;\n };\n \n+static void output_options PARAMS ((FILE *,\n+\t\t\t\t    struct m88k_lang_independent_options *,\n+\t\t\t\t    int,\n+\t\t\t\t    struct m88k_lang_independent_options *,\n+\t\t\t\t    int, int, int, const char *, const char *,\n+\t\t\t\t    const char *));\n+\n static int\n output_option (file, sep, type, name, indent, pos, max)\n      FILE *file;\n-     char *sep;\n-     char *type;\n-     char *name;\n-     char *indent;\n+     const char *sep;\n+     const char *type;\n+     const char *name;\n+     const char *indent;\n      int pos;\n      int max;\n {\n-  if (strlen (sep) + strlen (type) + strlen (name) + pos > max)\n+  if ((long)(strlen (sep) + strlen (type) + strlen (name) + pos) > max)\n     {\n       fprintf (file, indent);\n       return fprintf (file, \"%s%s\", type, name);\n     }\n   return pos + fprintf (file, \"%s%s%s\", sep, type, name);\n }\n \n-static struct { char *name; int value; } m_options[] = TARGET_SWITCHES;\n+static struct { const char *name; int value; } m_options[] = TARGET_SWITCHES;\n \n static void\n output_options (file, f_options, f_len, W_options, W_len,\n \t\tpos, max, sep, indent, term)\n      FILE *file;\n-     struct options *f_options;\n-     struct options *W_options;\n+     struct m88k_lang_independent_options *f_options;\n+     struct m88k_lang_independent_options *W_options;\n      int f_len, W_len;\n      int pos;\n      int max;\n-     char *indent;\n-     char *term;\n+     const char *sep;\n+     const char *indent;\n+     const char *term;\n {\n   register int j;\n \n@@ -1534,7 +1550,7 @@ output_options (file, f_options, f_len, W_options, W_len,\n       pos = output_option (file, sep, \"-W\", W_options[j].string,\n \t\t\t   indent, pos, max);\n \n-  for (j = 0; j < sizeof m_options / sizeof m_options[0]; j++)\n+  for (j = 0; j < (long) (sizeof m_options / sizeof m_options[0]); j++)\n     if (m_options[j].name[0] != '\\0'\n \t&& m_options[j].value > 0\n \t&& ((m_options[j].value & target_flags)\n@@ -1552,8 +1568,8 @@ output_options (file, f_options, f_len, W_options, W_len,\n void\n output_file_start (file, f_options, f_len, W_options, W_len)\n      FILE *file;\n-     struct options *f_options;\n-     struct options *W_options;\n+     struct m88k_lang_independent_options *f_options;\n+     struct m88k_lang_independent_options *W_options;\n      int f_len, W_len;\n {\n   register int pos;\n@@ -1595,9 +1611,9 @@ output_file_start (file, f_options, f_len, W_options, W_len)\n void\n output_ascii (file, opcode, max, p, size)\n      FILE *file;\n-     char *opcode;\n+     const char *opcode;\n      int max;\n-     unsigned char *p;\n+     const unsigned char *p;\n      int size;\n {\n   int i;\n@@ -1741,10 +1757,11 @@ output_label (label_number)\n   variable space.\n   */\n \n-static void emit_add ();\n-static void preserve_registers ();\n-static void emit_ldst ();\n-static void output_tdesc ();\n+static void emit_add PARAMS ((rtx, rtx, int));\n+static void preserve_registers PARAMS ((int, int));\n+static void emit_ldst PARAMS ((int, int, enum machine_mode, int));\n+static void output_tdesc PARAMS ((FILE *, int));\n+static int uses_arg_area_p PARAMS ((void));\n \n static int  nregs;\n static int  nxregs;\n@@ -1922,8 +1939,8 @@ uses_arg_area_p ()\n \f\n void\n m88k_begin_prologue (stream, size)\n-     FILE *stream;\n-     int size;\n+     FILE *stream ATTRIBUTE_UNUSED;\n+     int size ATTRIBUTE_UNUSED;\n {\n   if (TARGET_OMIT_LEAF_FRAME_POINTER && ! quiet_flag && leaf_function_p ())\n     fprintf (stderr, \"$\");\n@@ -2022,7 +2039,7 @@ m88k_begin_epilogue (stream)\n void\n m88k_end_epilogue (stream, size)\n      FILE *stream;\n-     int size;\n+     int size ATTRIBUTE_UNUSED;\n {\n   rtx insn = get_last_insn ();\n \n@@ -2341,9 +2358,9 @@ output_tdesc (file, offset)\n   ASM_GENERATE_INTERNAL_LABEL (buf, OCS_END_PREFIX, m88k_function_number);\n   fprintf (file, \",%s%s\", buf+1, flag_pic ? \"#rel\" : \"\");\n \n-  fprintf (file, \",0x%x,0x%x,0x%x,0x%x\",\n+  fprintf (file, \",0x%x,0x%x,0x%lx,0x%lx\",\n \t   /* 8:1,17:0x%.3x,1:0,1:%d,5:%d */\n-\t   (((xmask ? 3 : 1) << (17+1+1+5))\n+\t   (int)(((xmask ? 3 : 1) << (17+1+1+5))\n \t    | (mask << (1+1+5))\n \t    | ((!!save_regs[1]) << 5)\n \t    | (frame_pointer_needed\n@@ -2353,7 +2370,7 @@ output_tdesc (file, offset)\n \t   return_address_info,\n \t   register_save_offset);\n   if (xmask)\n-    fprintf (file, \",0x%x%04x\", xmask, (0xffff & xregister_save_offset));\n+    fprintf (file, \",0x%lx%04lx\", xmask, (0xffff & xregister_save_offset));\n   fputc ('\\n', file);\n \n   text_section ();\n@@ -2368,7 +2385,7 @@ void\n output_function_profiler (file, labelno, name, savep)\n      FILE *file;\n      int labelno;\n-     char *name;\n+     const char *name;\n      int savep;\n {\n   char label[256];\n@@ -2526,7 +2543,7 @@ m88k_function_arg (args_so_far, mode, type, named)\n      CUMULATIVE_ARGS args_so_far;\n      enum machine_mode mode;\n      tree type;\n-     int named;\n+     int named ATTRIBUTE_UNUSED;\n {\n   int bytes, words;\n \n@@ -2655,7 +2672,7 @@ m88k_build_va_list ()\n \n void\n m88k_va_start (stdarg_p, valist, nextarg)\n-     int stdarg_p;\n+     int stdarg_p ATTRIBUTE_UNUSED;\n      tree valist;\n      rtx nextarg ATTRIBUTE_UNUSED;\n {\n@@ -2840,7 +2857,7 @@ void\n print_operand (file, x, code)\n     FILE *file;\n     rtx x;\n-    char code;\n+    int code;\n {\n   enum rtx_code xc = (x ? GET_CODE (x) : UNKNOWN);\n   register int value = (xc == CONST_INT ? INTVAL (x) : 0);"}, {"sha": "d043f23a2dfda657e20b4a05480f9277edcf8786", "filename": "gcc/config/m88k/m88k.h", "status": "modified", "additions": 21, "deletions": 58, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.h?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -1,6 +1,6 @@\n /* Definitions of target machine for GNU compiler for\n    Motorola m88100 in an 88open OCS/BCS environment.\n-   Copyright (C) 1988, 92-97, 1998 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 92-99, 2000 Free Software Foundation, Inc.\n    Contributed by Michael Tiemann (tiemann@cygnus.com).\n    Currently maintained by (gcc@dg-rtp.dg.com)\n \n@@ -93,9 +93,9 @@ enum processor_type {\n \n /* External variables/functions defined in m88k.c.  */\n \n-extern char *m88k_pound_sign;\n-extern char *m88k_short_data;\n-extern char *m88k_version;\n+extern const char *m88k_pound_sign;\n+extern const char *m88k_short_data;\n+extern const char *m88k_version;\n extern char m88k_volatile_code;\n \n extern unsigned m88k_gp_threshold;\n@@ -111,46 +111,6 @@ extern struct rtx_def *m88k_compare_op1;\n \n extern enum processor_type m88k_cpu;\n \n-extern int null_prologue ();\n-extern int integer_ok_for_set ();\n-extern int m88k_debugger_offset ();\n-\n-\n-extern void emit_bcnd ();\n-extern void expand_block_move ();\n-extern void m88k_layout_frame ();\n-extern void m88k_expand_prologue ();\n-extern void m88k_begin_prologue ();\n-extern void m88k_end_prologue ();\n-extern void m88k_expand_epilogue ();\n-extern void m88k_begin_epilogue ();\n-extern void m88k_end_epilogue ();\n-extern void output_function_profiler ();\n-extern void output_function_block_profiler ();\n-extern void output_block_profiler ();\n-extern void output_file_start ();\n-extern void output_ascii ();\n-extern void output_label ();\n-extern void print_operand ();\n-extern void print_operand_address ();\n-\n-extern char *output_load_const_int ();\n-extern char *output_load_const_float ();\n-extern char *output_load_const_double ();\n-extern char *output_load_const_dimode ();\n-extern char *output_and ();\n-extern char *output_ior ();\n-extern char *output_xor ();\n-extern char *output_call ();\n-\n-extern struct rtx_def *emit_test ();\n-extern struct rtx_def *legitimize_address ();\n-extern struct rtx_def *legitimize_operand ();\n-extern struct rtx_def *m88k_function_arg ();\n-extern struct rtx_def *m88k_builtin_saveregs ();\n-\n-extern enum m88k_instruction classify_integer ();\n-\n /* external variables defined elsewhere in the compiler */\n \n extern int target_flags;\t\t\t/* -m compiler switches */\n@@ -329,7 +289,7 @@ extern int flag_pic;\t\t\t\t/* -fpic */\n \t\t\t\t\t\t\t\t\t     \\\n     if (m88k_short_data)\t\t\t\t\t\t     \\\n       {\t\t\t\t\t\t\t\t\t     \\\n-\tchar *p = m88k_short_data;\t\t\t\t\t     \\\n+\tconst char *p = m88k_short_data;\t\t\t\t     \\\n \twhile (*p)\t\t\t\t\t\t\t     \\\n \t  if (*p >= '0' && *p <= '9')\t\t\t\t\t     \\\n \t    p++;\t\t\t\t\t\t\t     \\\n@@ -1076,17 +1036,14 @@ enum reg_class { NO_REGS, AP_REG, XRF_REGS, GENERAL_REGS, AGRF_REGS,\n /* Define the `__builtin_va_list' type for the ABI.  */\n #define BUILD_VA_LIST_TYPE(VALIST) \\\n   (VALIST) = m88k_build_va_list ()\n-extern union tree_node *m88k_build_va_list ();\n \n /* Implement `va_start' for varargs and stdarg.  */\n #define EXPAND_BUILTIN_VA_START(stdarg, valist, nextarg) \\\n   m88k_va_start (stdarg, valist, nextarg)\n-extern void m88k_va_start ();\n \n /* Implement `va_arg'.  */\n #define EXPAND_BUILTIN_VA_ARG(valist, type) \\\n   m88k_va_arg (valist, type)\n-extern struct rtx_def *m88k_va_arg ();\n \n /* Generate the assembly code for function entry. */\n #define FUNCTION_PROLOGUE(FILE, SIZE) m88k_begin_prologue(FILE, SIZE)\n@@ -1858,8 +1815,11 @@ extern struct rtx_def *m88k_va_arg ();\n /* Override svr[34].h.  */\n #undef\tASM_FILE_START\n #define ASM_FILE_START(FILE) \\\n-  output_file_start (FILE, f_options, sizeof f_options / sizeof f_options[0], \\\n-\t\t     W_options, sizeof W_options / sizeof W_options[0])\n+  output_file_start (FILE, \\\n+\t(struct m88k_lang_independent_options *) f_options, \\\n+\tsizeof f_options / sizeof f_options[0], \\\n+\t(struct m88k_lang_independent_options *) W_options, \\\n+\tsizeof W_options / sizeof W_options[0])\n \n #undef\tASM_FILE_END\n \n@@ -1898,7 +1858,7 @@ extern struct rtx_def *m88k_va_arg ();\n #define ASM_OUTPUT_OPCODE(STREAM, PTR)\t\t\t\t\t\\\n   {\t\t\t\t\t\t\t\t\t\\\n     int ch;\t\t\t\t\t\t\t\t\\\n-    char *orig_ptr;\t\t\t\t\t\t\t\\\n+    const char *orig_ptr;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n     for (orig_ptr = (PTR);\t\t\t\t\t\t\\\n \t (ch = *(PTR)) && ch != ' ' && ch != '\\t' && ch != '\\n' && ch != '%'; \\\n@@ -1929,7 +1889,7 @@ extern struct rtx_def *m88k_va_arg ();\n    is our `condition code' register), so that condition codes can easily\n    be clobbered by an asm.  The carry bit in the PSR is now used.  */\n \n-#define ADDITIONAL_REGISTER_NAMES\t{\"psr\", 0, \"cc\", 0}\n+#define ADDITIONAL_REGISTER_NAMES\t{{\"psr\", 0}, {\"cc\", 0}}\n \n /* How to renumber registers for dbx and gdb.  */\n #define DBX_REGISTER_NUMBER(REGNO) (REGNO)\n@@ -1985,7 +1945,7 @@ extern struct rtx_def *m88k_va_arg ();\n #undef ASM_FINISH_DECLARE_OBJECT\n #define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\t \\\n do {\t\t\t\t\t\t\t\t\t \\\n-     char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t\t \\\n+     const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\t \\\n      if (!flag_inhibit_size_directive && DECL_SIZE (DECL)\t\t \\\n \t && DECLARE_ASM_NAME\t\t\t\t\t\t \\\n          && ! AT_END && TOP_LEVEL\t\t\t\t\t \\\n@@ -2117,8 +2077,8 @@ do {\t\t\t\t\t\t\t\t\t \\\n   do {\t\t\t\t\t\t\t\t\t\\\n     union { REAL_VALUE_TYPE d; long l[2]; } x;\t\t\t\t\\\n     x.d = (VALUE);\t\t\t\t\t\t\t\\\n-    fprintf (FILE, \"\\t%s\\t 0x%.8x, 0x%.8x\\n\", INT_ASM_OP,\t\t\t\\\n-\t     x.l[0], x.l[1]);\t\t\t\t\t\t\\\n+    fprintf (FILE, \"\\t%s\\t 0x%.8lx, 0x%.8lx\\n\", INT_ASM_OP,\t\t\\\n+\t     (long) x.l[0], (long) x.l[1]);\t\t\t\t\\\n   } while (0)\n \n /* This is how to output an assembler line defining a `float' constant.  */\n@@ -2317,7 +2277,7 @@ do {\t\t\t\t\t\t\t\t\t \\\n #define PUT_SDB_SCL(a)\t\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\\\n     register int s = (a);\t\t\t\t\t\\\n-    register char *scl;\t\t\t\t\t\t\\\n+    register const char *scl;\t\t\t\t\t\\\n     switch (s)\t\t\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n       case C_EFCN:\tscl = \"end of function\";\tbreak;\t\\\n@@ -2357,9 +2317,10 @@ do {\t\t\t\t\t\t\t\t\t \\\n   do {\t\t\t\t\t\t\t\t\\\n     register int t = (a);\t\t\t\t\t\\\n     static char buffer[100];\t\t\t\t\t\\\n-    register char *p = buffer, *q;\t\t\t\t\\\n+    register char *p = buffer;\t\t\t\t\t\\\n+    register const char *q;\t\t\t\t\t\\\n     register int typ = t;\t\t\t\t\t\\\n-    register int i,d;\t\t\t\t\t\t\\\n+    register int i;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\\\n     for (i = 0; i <= 5; i++)\t\t\t\t\t\\\n       {\t\t\t\t\t\t\t\t\\\n@@ -2611,6 +2572,7 @@ sdata_section ()\t\t\t\t\t\t\t\\\n #define ENCODE_SECTION_INFO(DECL)\t\t\t\t\t\\\n   do {\t\t\t\t\t\t\t\t\t\\\n     if (m88k_gp_threshold > 0)\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n       if (TREE_CODE (DECL) == VAR_DECL)\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (!TREE_READONLY (DECL) || TREE_SIDE_EFFECTS (DECL))\t\\\n@@ -2625,6 +2587,7 @@ sdata_section ()\t\t\t\t\t\t\t\\\n \t       && flag_writable_strings\t\t\t\t\t\\\n \t       && TREE_STRING_LENGTH (DECL) <= m88k_gp_threshold)\t\\\n \tSYMBOL_REF_FLAG (XEXP (TREE_CST_RTL (DECL), 0)) = 1;\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n   } while (0)\n \f\n /* Print operand X (an rtx) in assembler syntax to file FILE."}, {"sha": "9cc810b1d885ceba4f33069eb4eb4f744c720cf5", "filename": "gcc/config/m88k/m88k.md", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2Fm88k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2Fm88k.md?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -1,5 +1,5 @@\n ;;- Machine description for the Motorola 88000 for GNU C compiler\n-;;;  Copyright (C) 1988, 92-96, 1998, 1999 Free Software Foundation, Inc.\n+;;  Copyright (C) 1988, 92-96, 98, 99, 2000 Free Software Foundation, Inc.\n ;;  Contributed by Michael Tiemann (tiemann@mcc.com)\n ;;  Currently maintained by (gcc@dg-rtp.dg.com)\n \n@@ -23,14 +23,6 @@\n \n ;;- See file \"rtl.def\" for documentation on define_insn, match_*, et. al.\n \n-;; RCS rev field.  This is a NOP, just to get the RCS id into the\n-;; program image.\n-(define_expand \"m88k_rcs_id\"\n-  [(match_operand:SI 0 \"\" \"\")]\n-  \"\"\n-  \"{ static char rcs_id[] = \\\"$What: <@(#) m88k.md,v\t1.1.1.2.2.2> $\\\";\n-     FAIL; }\")\n-\f\n ;; Attribute describing the processor.  This attribute must match exactly\n ;; with the processor_type enumeration in m88k.h.\n \n@@ -3058,7 +3050,7 @@\n   \"\n {\n   operands[1] = legitimize_operand (operands[1], DFmode);\n-  if (real_power_of_2_operand (operands[2]))\n+  if (real_power_of_2_operand (operands[2], DFmode))\n     {\n       union real_extract u;\n       bcopy (&CONST_DOUBLE_LOW (operands[2]), &u, sizeof u);"}, {"sha": "8a52f14a0fb36eea69b91244578986fdc006ab52", "filename": "gcc/config/m88k/tekXD88.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e5778b1e8475970fdc6e6c5df3abd14598b1b7d2/gcc%2Fconfig%2Fm88k%2FtekXD88.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm88k%2FtekXD88.h?ref=e5778b1e8475970fdc6e6c5df3abd14598b1b7d2", "patch": "@@ -1,6 +1,6 @@\n /* Tektronix XD88 UTekV 3.2e   (svr3 derived from UniSoft System V/88)\n \n-   Copyright (C) 1993 Free Software Foundation, Inc.\n+   Copyright (C) 1993, 2000 Free Software Foundation, Inc.\n    Contributed by Kaveh R. Ghazi (ghazi@caip.rutgers.edu)  2/22/93.\n \n    This file is part of GNU CC.\n@@ -36,8 +36,12 @@\n /* I don't know if this SDB thing is needed or not --KRG */\n \n \n-/* Use T_ARG as T_VOID.  T_VOID is not defined in <syms.h> as it should be.  */\n+/* Use T_ARG as T_VOID.  T_VOID is not defined in <syms.h> as it\n+   should be.  If we're cross compiling, then don't do this because\n+   \"gsyms.h\" has T_VOID.  */\n+#ifndef CROSS_COMPILE\n #define T_VOID T_ARG\n+#endif\n \n \n /* The bundled ld program needs link editor directives which normally"}]}