{"sha": "517b711f9ac6df41f4e1bea5aafd75d28e45f322", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTE3YjcxMWY5YWM2ZGY0MWY0ZTFiZWE1YWFmZDc1ZDI4ZTQ1ZjMyMg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dan@cgsoftware.com", "date": "2002-01-04T15:23:30Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2002-01-04T15:23:30Z"}, "message": "lcm.c: Include df.h.\n\n2001-01-04  Daniel Berlin  <dan@cgsoftware.com>\n\n\t* lcm.c: Include df.h.\n\tAdd available_transfer_function prototype.\n\t(compute_available): Rework to use iterative dataflow framework.\n\t(struct bb_info): s/bb_info/lcm_bb_info/g to avoid conflict\n\twith bb_info in df.h\n\t(available_transfer_function): New function.\n\n\t* Makefile.in (lcm.o): add df.h to dependencies.\n\nFrom-SVN: r48536", "tree": {"sha": "1d2b5d10566fb1bbd4b6b1352bb0d524a42ccdfb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d2b5d10566fb1bbd4b6b1352bb0d524a42ccdfb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/517b711f9ac6df41f4e1bea5aafd75d28e45f322", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517b711f9ac6df41f4e1bea5aafd75d28e45f322", "html_url": "https://github.com/Rust-GCC/gccrs/commit/517b711f9ac6df41f4e1bea5aafd75d28e45f322", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/517b711f9ac6df41f4e1bea5aafd75d28e45f322/comments", "author": null, "committer": null, "parents": [{"sha": "f11ee281f7aedc2224eb2f9e1986ff3c836e3c82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f11ee281f7aedc2224eb2f9e1986ff3c836e3c82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f11ee281f7aedc2224eb2f9e1986ff3c836e3c82"}], "stats": {"total": 152, "additions": 61, "deletions": 91}, "files": [{"sha": "e82aac97cce658e4cbb45a41f484d20ca05c292e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=517b711f9ac6df41f4e1bea5aafd75d28e45f322", "patch": "@@ -1,3 +1,14 @@\n+2001-01-04  Daniel Berlin  <dan@cgsoftware.com>\n+\n+\t* lcm.c: Include df.h.\n+\tAdd available_transfer_function prototype.\n+\t(compute_available): Rework to use iterative dataflow framework.\n+\t(struct bb_info): s/bb_info/lcm_bb_info/g to avoid conflict\n+\twith bb_info in df.h\n+\t(available_transfer_function): New function.\n+\n+\t* Makefile.in (lcm.o): add df.h to dependencies.\n+\n 2002-01-04  Richard Henderson  <rth@redhat.com>\n \n \t* config/alpha/alpha.c (some_operand): Accept HIGH."}, {"sha": "2fa38d7a9586c54edf1c1ee011503cfcfb171dbe", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=517b711f9ac6df41f4e1bea5aafd75d28e45f322", "patch": "@@ -1435,7 +1435,7 @@ resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) \\\n    $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)\n lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) $(RTL_H) $(REGS_H) hard-reg-set.h flags.h \\\n    real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) $(BASIC_BLOCK_H) \\\n-   $(TM_P_H)\n+   $(TM_P_H) df.h\n ssa.o : ssa.c $(CONFIG_H) $(SYSTEM_H) $(REGS_H) varray.h $(EXPR_H) \\\n    hard-reg-set.h flags.h function.h real.h insn-config.h $(RECOG_H)\t\\\n    $(BASIC_BLOCK_H) output.h ssa.h"}, {"sha": "7c5015324fb1435e1e9b6ab58d64dbf94083e4e8", "filename": "gcc/lcm.c", "status": "modified", "additions": 49, "deletions": 90, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2Flcm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/517b711f9ac6df41f4e1bea5aafd75d28e45f322/gcc%2Flcm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flcm.c?ref=517b711f9ac6df41f4e1bea5aafd75d28e45f322", "patch": "@@ -60,6 +60,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"recog.h\"\n #include \"basic-block.h\"\n #include \"tm_p.h\"\n+#include \"df.h\"\n \n /* We want target macros for the mode switching code to be able to refer\n    to instruction attribute values.  */\n@@ -92,9 +93,11 @@ static void compute_rev_insert_delete\tPARAMS ((struct edge_list *edge_list,\n \t\t\t\t\t\t sbitmap *, sbitmap *,\n \t\t\t\t\t\t sbitmap *, sbitmap *,\n \t\t\t\t\t\t sbitmap *));\n+\n+static void available_transfer_function PARAMS ((int, int *, sbitmap, sbitmap, \n+\t\t\t\t\t\t sbitmap, sbitmap, void *));\n \f\n /* Edge based lcm routines.  */\n-\n /* Compute expression anticipatability at entrance and exit of each block.\n    This is done based on the flow graph, and not on the pred-succ lists.\n    Other than that, its pretty much identical to compute_antinout.  */\n@@ -110,7 +113,6 @@ compute_antinout_edge (antloc, transp, antin, antout)\n   edge e;\n   basic_block *worklist, *qin, *qout, *qend;\n   unsigned int qlen;\n-\n   /* Allocate a worklist array/queue.  Entries are only added to the\n      list if they were not already on the list.  So the size is\n      bounded by the number of basic blocks.  */\n@@ -145,7 +147,6 @@ compute_antinout_edge (antloc, transp, antin, antout)\n       basic_block b = *qout++;\n       bb = b->index;\n       qlen--;\n-\n       if (qout >= qend)\n         qout = worklist;\n \n@@ -487,90 +488,48 @@ pre_edge_lcm (file, n_exprs, transp, avloc, antloc, kill, insert, delete)\n \n   return edge_list;\n }\n-\n-/* Compute the AVIN and AVOUT vectors from the AVLOC and KILL vectors.\n-   Return the number of passes we performed to iterate to a solution.  */\n-\n+/* Availability transfer function */\n+static void\n+available_transfer_function (bb, changed, in, out, gen, kill, data)\n+     int bb ATTRIBUTE_UNUSED;\n+     int *changed;\n+     sbitmap in,out,gen,kill;\n+     void *data ATTRIBUTE_UNUSED;\n+{\n+  *changed = sbitmap_union_of_diff (out, gen, in, kill);\n+}\n+/* Compute the AVIN and AVOUT vectors from the AVLOC and KILL\n+   vectors.  */\n void\n compute_available (avloc, kill, avout, avin)\n-     sbitmap *avloc, *kill, *avout, *avin;\n+     sbitmap *avloc;\n+     sbitmap *kill;\n+     sbitmap *avout;\n+     sbitmap *avin;\n {\n-  int bb;\n-  edge e;\n-  basic_block *worklist, *qin, *qout, *qend;\n-  unsigned int qlen;\n-\n-  /* Allocate a worklist array/queue.  Entries are only added to the\n-     list if they were not already on the list.  So the size is\n-     bounded by the number of basic blocks.  */\n-  qin = qout = worklist\n-    = (basic_block *) xmalloc (sizeof (basic_block) * n_basic_blocks);\n-\n-  /* We want a maximal solution.  */\n+  int *dfs_order;\n+  int *rc_order;\n+  bitmap blocks;\n+  int *inverse_rc_map;\n+  int i;\n+  dfs_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  rc_order = xmalloc (sizeof (int) * n_basic_blocks);\n+  inverse_rc_map = xmalloc (sizeof (int) * n_basic_blocks);\n+  flow_depth_first_order_compute (dfs_order, rc_order);\n+  blocks = BITMAP_XMALLOC ();\n+  for (i = 0; i < n_basic_blocks; i ++)\n+   {\n+     inverse_rc_map[rc_order[i]] = i;\n+     bitmap_set_bit (blocks, i);\n+   }\n   sbitmap_vector_ones (avout, n_basic_blocks);\n-\n-  /* Put every block on the worklist; this is necessary because of the\n-     optimistic initialization of AVOUT above.  */\n-  for (bb = 0; bb < n_basic_blocks; bb++)\n-    {\n-      *qin++ = BASIC_BLOCK (bb);\n-      BASIC_BLOCK (bb)->aux = BASIC_BLOCK (bb);\n-    }\n-\n-  qin = worklist;\n-  qend = &worklist[n_basic_blocks];\n-  qlen = n_basic_blocks;\n-\n-  /* Mark blocks which are successors of the entry block so that we\n-     can easily identify them below.  */\n-  for (e = ENTRY_BLOCK_PTR->succ; e; e = e->succ_next)\n-    e->dest->aux = ENTRY_BLOCK_PTR;\n-\n-  /* Iterate until the worklist is empty.  */\n-  while (qlen)\n-    {\n-      /* Take the first entry off the worklist.  */\n-      basic_block b = *qout++;\n-      bb = b->index;\n-      qlen--;\n-\n-      if (qout >= qend)\n-        qout = worklist;\n-\n-      /* If one of the predecessor blocks is the ENTRY block, then the\n-\t intersection of avouts is the null set.  We can identify such blocks\n-\t by the special value in the AUX field in the block structure.  */\n-      if (b->aux == ENTRY_BLOCK_PTR)\n-\t/* Do not clear the aux field for blocks which are successors of the\n-\t   ENTRY block.  That way we never add then to the worklist again.  */\n-\tsbitmap_zero (avin[bb]);\n-      else\n-\t{\n-\t  /* Clear the aux field of this block so that it can be added to\n-\t     the worklist again if necessary.  */\n-\t  b->aux = NULL;\n-\t  sbitmap_intersection_of_preds (avin[bb], avout, bb);\n-\t}\n-\n-      if (sbitmap_union_of_diff (avout[bb], avloc[bb], avin[bb], kill[bb]))\n-\t/* If the out state of this block changed, then we need\n-\t   to add the successors of this block to the worklist\n-\t   if they are not already on the worklist.  */\n-\tfor (e = b->succ; e; e = e->succ_next)\n-\t  if (!e->dest->aux && e->dest != EXIT_BLOCK_PTR)\n-\t    {\n-\t      *qin++ = e->dest;\n-\t      e->dest->aux = e;\n-\t      qlen++;\n-\n-\t      if (qin >= qend)\n-\t        qin = worklist;\n-\t    }\n-    }\n-\n-  clear_aux_for_edges ();\n-  clear_aux_for_blocks ();\n-  free (worklist);\n+  iterative_dataflow_sbitmap (avin, avout, avloc, kill, blocks, \n+\t\t\t      FORWARD, INTERSECTION, \n+\t\t\t      available_transfer_function, inverse_rc_map, 0);\n+  BITMAP_XFREE (blocks);\n+  free (dfs_order);\n+  free (rc_order);\n+  free (inverse_rc_map);\n }\n \n /* Compute the farthest vector for edge based lcm.  */\n@@ -876,7 +835,7 @@ struct seginfo\n   HARD_REG_SET regs_live;\n };\n \n-struct bb_info\n+struct lcm_bb_info\n {\n   struct seginfo *seginfo;\n   int computing;\n@@ -892,7 +851,7 @@ static sbitmap *delete;\n static sbitmap *insert;\n \n static struct seginfo * new_seginfo PARAMS ((int, rtx, int, HARD_REG_SET));\n-static void add_seginfo PARAMS ((struct bb_info *, struct seginfo *));\n+static void add_seginfo PARAMS ((struct lcm_bb_info *, struct seginfo *));\n static void reg_dies PARAMS ((rtx, HARD_REG_SET));\n static void reg_becomes_live PARAMS ((rtx, rtx, void *));\n static void make_preds_opaque PARAMS ((basic_block, int));\n@@ -926,7 +885,7 @@ new_seginfo (mode, insn, bb, regs_live)\n \n static void\n add_seginfo (head, info)\n-     struct bb_info *head;\n+     struct lcm_bb_info *head;\n      struct seginfo *info;\n {\n   struct seginfo *ptr;\n@@ -1025,7 +984,7 @@ optimize_mode_switching (file)\n   static const int num_modes[] = NUM_MODES_FOR_MODE_SWITCHING;\n #define N_ENTITIES (sizeof num_modes / sizeof (int))\n   int entity_map[N_ENTITIES];\n-  struct bb_info *bb_info[N_ENTITIES];\n+  struct lcm_bb_info *bb_info[N_ENTITIES];\n   int i, j;\n   int n_entities;\n   int max_num_modes = 0;\n@@ -1041,7 +1000,7 @@ optimize_mode_switching (file)\n       {\n \t/* Create the list of segments within each basic block.  */\n \tbb_info[n_entities]\n-\t  = (struct bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n+\t  = (struct lcm_bb_info *) xcalloc (n_basic_blocks, sizeof **bb_info);\n \tentity_map[n_entities++] = e;\n \tif (num_modes[e] > max_num_modes)\n \t  max_num_modes = num_modes[e];\n@@ -1080,7 +1039,7 @@ optimize_mode_switching (file)\n     {\n       int e = entity_map[j];\n       int no_mode = num_modes[e];\n-      struct bb_info *info = bb_info[j];\n+      struct lcm_bb_info *info = bb_info[j];\n \n       /* Determine what the first use (if any) need for a mode of entity E is.\n \t This will be the mode that is anticipatable for this block.\n@@ -1182,7 +1141,7 @@ optimize_mode_switching (file)\n       for (j = n_entities - 1; j >= 0; j--)\n \t{\n \t  int m = current_mode[j] = MODE_PRIORITY_TO_MODE (entity_map[j], i);\n-\t  struct bb_info *info = bb_info[j];\n+\t  struct lcm_bb_info *info = bb_info[j];\n \n \t  for (bb = 0 ; bb < n_basic_blocks; bb++)\n \t    {"}]}