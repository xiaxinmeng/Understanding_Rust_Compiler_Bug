{"sha": "3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzI1OGU5OTYxYzBjMTBiNjI1Y2YxYmNhZjdkZWMyNGE1YzcyMmY0NQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-11-21T23:41:40Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-11-21T23:41:40Z"}, "message": "function.c (keep_stack_depressed): Major rework.\n\n\t* function.c (keep_stack_depressed): Major rework.\n\t(handle_epilogue_set, emit_equiv_load): New functions.\n\t(thread_prologue_and_epilogue_insns): keep_stack_depressed now\n\thas return value.\n\t* jump.c (returnjump_p_1): Also return 1 if SET with SET_IS_RETURN_P.\n\t* rtl.h (SET_IS_RETURN_P): New macro.\n\nFrom-SVN: r47250", "tree": {"sha": "4228f1e4d4f65d67074c0259afaae71d1cb46c05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4228f1e4d4f65d67074c0259afaae71d1cb46c05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/comments", "author": null, "committer": null, "parents": [{"sha": "c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c11c10d87b229fc9bfa4a1e0a5a342e3344f737d"}], "stats": {"total": 323, "additions": 282, "deletions": 41}, "files": [{"sha": "d21b6e5d20c50f93e4c6b488d97eb7b9346c3b09", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "patch": "@@ -1,5 +1,12 @@\n Wed Nov 21 17:37:16 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* function.c (keep_stack_depressed): Major rework.\n+\t(handle_epilogue_set, emit_equiv_load): New functions.\n+\t(thread_prologue_and_epilogue_insns): keep_stack_depressed now\n+\thas return value.\n+\t* jump.c (returnjump_p_1): Also return 1 if SET with SET_IS_RETURN_P.\n+\t* rtl.h (SET_IS_RETURN_P): New macro.\n+\n \t* expr.c (expand_expr, case VIEW_CONVERT_EXPR): Refine slightly\n \tand also support TREE_ADDRESSABLE.\n \t* tree.def (VIEW_CONVERT_EXPR): Document TREE_ADDRESSABLE."}, {"sha": "e24874b007132d06ba2c99c771741939305a45a1", "filename": "gcc/function.c", "status": "modified", "additions": 269, "deletions": 39, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "patch": "@@ -288,8 +288,8 @@ static void put_addressof_into_stack PARAMS ((rtx, struct hash_table *));\n static bool purge_addressof_1 PARAMS ((rtx *, rtx, int, int,\n \t\t\t\t\t  struct hash_table *));\n static void purge_single_hard_subreg_set PARAMS ((rtx));\n-#ifdef HAVE_epilogue\n-static void keep_stack_depressed PARAMS ((rtx));\n+#if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n+static rtx keep_stack_depressed PARAMS ((rtx));\n #endif\n static int is_addressof\t\tPARAMS ((rtx *, void *));\n static struct hash_entry *insns_for_mem_newfunc PARAMS ((struct hash_entry *,\n@@ -7115,68 +7115,296 @@ emit_return_into_block (bb, line_note)\n }\n #endif /* HAVE_return */\n \n-#ifdef HAVE_epilogue\n+#if defined(HAVE_epilogue) && defined(INCOMING_RETURN_ADDR_RTX)\n+\n+/* These functions convert the epilogue into a variant that does not modify the\n+   stack pointer.  This is used in cases where a function returns an object\n+   whose size is not known until it is computed.  The called function leavs the\n+   object on the stack, leaves the stack depressed, and returns a pointer to\n+   the object.\n+\n+   What we need to do is track all modifications and references to the stack\n+   pointer, deleting the modifications and changing the references to point to\n+   the location the stack pointer would have pointed to had the modifications\n+   taken place.\n+\n+   These functions need to be portable so we need to make as few assumptions\n+   about the epilogue as we can.  However, the epilogue basically contains\n+   three things: instructions to reset the stack pointer, instructions to\n+   reload registers, possibly including the frame pointer, and an\n+   instruction to return to the caller.\n+\n+   If we can't be sure of what a relevant epilogue insn is doing, we abort.\n+   We also make no attempt to validate the insns we make since if they are\n+   invalid, we probably can't do anything valid.  The intent is that these\n+   routines get \"smarter\" as more and more machines start to use them and\n+   they try operating on different epilogues.\n+\n+   We use the following structure to track what the part of the epilogue that\n+   we've already processed has done.  We keep two copies of the SP equivalence,\n+   one for use during the insn we are processing and one for use in the next\n+   insn.  The difference is because one part of a PARALLEL may adjust SP\n+   and the other may use it.  */\n+\n+struct epi_info\n+{\n+  rtx sp_equiv_reg;\t\t/* REG that SP is set from, perhaps SP.  */\n+  HOST_WIDE_INT sp_offset;\t/* Offset from SP_EQUIV_REG of present SP.  */\n+  rtx new_sp_equiv_reg;\t\t/* REG to be used at end of insn.   */\n+  HOST_WIDE_INT new_sp_offset;\t/* Offset to be used at end of insn.  */\n+  rtx equiv_reg_src;\t\t/* If nonzero, the value that SP_EQUIV_REG\n+\t\t\t\t   should be set to once we no longer need\n+\t\t\t\t   its value.  */\n+};\n+\n+static void handle_epilogue_set PARAMS ((rtx, struct epi_info *));\n+static void emit_equiv_load PARAMS ((struct epi_info *));\n \n /* Modify SEQ, a SEQUENCE that is part of the epilogue, to no modifications\n-   to the stack pointer.  */\n+   to the stack pointer.  Return the new sequence.  */\n \n-static void\n+static rtx\n keep_stack_depressed (seq)\n      rtx seq;\n {\n-  int i;\n-  rtx sp_from_reg = 0;\n-  int sp_modified_unknown = 0;\n+  int i, j;\n+  struct epi_info info;\n \n-  /* If the epilogue is just a single instruction, it's OK as is */\n+  /* If the epilogue is just a single instruction, it ust be OK as is.   */\n \n   if (GET_CODE (seq) != SEQUENCE)\n-    return;\n+    return seq;\n \n-  /* Scan all insns in SEQ looking for ones that modified the stack\n-     pointer.  Record if it modified the stack pointer by copying it\n-     from the frame pointer or if it modified it in some other way.\n-     Then modify any subsequent stack pointer references to take that\n-     into account.  We start by only allowing SP to be copied from a\n-     register (presumably FP) and then be subsequently referenced.  */\n+  /* Otherwise, start a sequence, initialize the information we have, and\n+     process all the insns we were given.  */\n+  start_sequence ();\n+\n+  info.sp_equiv_reg = stack_pointer_rtx;\n+  info.sp_offset = 0;\n+  info.equiv_reg_src = 0;\n \n   for (i = 0; i < XVECLEN (seq, 0); i++)\n     {\n       rtx insn = XVECEXP (seq, 0, i);\n \n-      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n-\tcontinue;\n+      if (!INSN_P (insn))\n+\t{\n+\t  add_insn (insn);\n+\t  continue;\n+\t}\n \n-      if (reg_set_p (stack_pointer_rtx, insn))\n+      /* If this insn references the register that SP is equivalent to and\n+\t we have a pending load to that register, we must force out the load\n+\t first and then indicate we no longer know what SP's equivalent is.  */\n+      if (info.equiv_reg_src != 0\n+\t  && reg_referenced_p (info.sp_equiv_reg, PATTERN (insn)))\n \t{\n-\t  rtx set = single_set (insn);\n+\t  emit_equiv_load (&info);\n+\t  info.sp_equiv_reg = 0;\n+\t}\n \n-\t  /* If SP is set as a side-effect, we can't support this.  */\n-\t  if (set == 0)\n-\t    abort ();\n+      info.new_sp_equiv_reg = info.sp_equiv_reg;\n+      info.new_sp_offset = info.sp_offset;\n \n-\t  if (GET_CODE (SET_SRC (set)) == REG)\n-\t    sp_from_reg = SET_SRC (set);\n+      /* If this is a (RETURN) and the return address is on the stack,\n+\t update the address and change to an indirect jump.  */\n+      if (GET_CODE (PATTERN (insn)) == RETURN\n+\t  || (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t      && GET_CODE (XVECEXP (PATTERN (insn), 0, 0)) == RETURN))\n+\t{\n+\t  rtx retaddr = INCOMING_RETURN_ADDR_RTX;\n+\t  rtx base = 0;\n+\t  HOST_WIDE_INT offset = 0;\n+\t  rtx jump_insn, jump_set;\n+\n+\t  /* If the return address is in a register, we can emit the insn\n+\t     unchanged.  Otherwise, it must be a MEM and we see what the\n+\t     base register and offset are.  In any case, we have to emit any\n+\t     pending load to the equivalent reg of SP, if any.  */\n+\t  if (GET_CODE (retaddr) == REG)\n+\t    {\n+\t      emit_equiv_load (&info);\n+\t      add_insn (insn);\n+\t      continue;\n+\t    }\n+\t  else if (GET_CODE (retaddr) == MEM\n+\t\t   && GET_CODE (XEXP (retaddr, 0)) == REG)\n+\t    base = gen_rtx_REG (Pmode, REGNO (XEXP (retaddr, 0))), offset = 0;\n+\t  else if (GET_CODE (retaddr) == MEM\n+\t\t   && GET_CODE (XEXP (retaddr, 0)) == PLUS\n+\t\t   && GET_CODE (XEXP (XEXP (retaddr, 0), 0)) == REG\n+\t\t   && GET_CODE (XEXP (XEXP (retaddr, 0), 1)) == CONST_INT)\n+\t    {\n+\t      base = gen_rtx_REG (Pmode, REGNO (XEXP (XEXP (retaddr, 0), 0)));\n+\t      offset = INTVAL (XEXP (XEXP (retaddr, 0), 1));\n+\t    }\n \t  else\n-\t    sp_modified_unknown = 1;\n+\t    abort ();\n+\n+\t  /* If the base of the location containing the return pointer\n+\t     is SP, we must update it with the replacement address.  Otherwise,\n+\t     just build the necessary MEM.  */\n+\t  retaddr = plus_constant (base, offset);\n+\t  if (base == stack_pointer_rtx)\n+\t    retaddr = simplify_replace_rtx (retaddr, stack_pointer_rtx,\n+\t\t\t\t\t    plus_constant (info.sp_equiv_reg,\n+\t\t\t\t\t\t\t   info.sp_offset));\n+\n+\t  retaddr = gen_rtx_MEM (Pmode, retaddr);\n+\n+\t  /* If there is a pending load to the equivalent register for SP\n+\t     and we reference that register, we must load our address into\n+\t     a scratch register and then do that load.  */\n+\t  if (info.equiv_reg_src\n+\t      && reg_overlap_mentioned_p (info.equiv_reg_src, retaddr))\n+\t    {\n+\t      unsigned int regno;\n+\t      rtx reg;\n+\n+\t      for (regno = 0; regno < FIRST_PSEUDO_REGISTER; regno++)\n+\t\tif (HARD_REGNO_MODE_OK (regno, Pmode)\n+\t\t    && !fixed_regs[regno] && call_used_regs[regno]\n+\t\t    && !FUNCTION_VALUE_REGNO_P (regno))\n+\t\t  break;\n+\n+\t      if (regno == FIRST_PSEUDO_REGISTER)\n+\t\tabort ();\n \n-\t  /* Don't allow the SP modification to happen.  We don't call\n-\t     delete_insn here since INSN isn't in any chain.  */\n-\t  PUT_CODE (insn, NOTE);\n-\t  NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n-\t  NOTE_SOURCE_FILE (insn) = 0;\n+\t      reg = gen_rtx_REG (Pmode, regno);\n+\t      emit_move_insn (reg, retaddr);\n+\t      retaddr = reg;\n+\t    }\n+\n+\t  emit_equiv_load (&info);\n+\t  jump_insn = emit_jump_insn (gen_indirect_jump (retaddr));\n+\n+\t  /* Show the SET in the above insn is a RETURN.  */\n+\t  jump_set = single_set (jump_insn);\n+\t  if (jump_set == 0)\n+\t    abort ();\n+\t  else\n+\t    SET_IS_RETURN_P (jump_set) = 1;\n \t}\n-      else if (reg_referenced_p (stack_pointer_rtx, PATTERN (insn)))\n+\n+      /* If SP is not mentioned in the pattern and its equivalent register, if\n+\t any, is not modified, just emit it.  Otherwise, if neither is set,\n+\t replace the reference to SP and emit the insn.  If none of those are\n+\t true, handle each SET individually.  */\n+      else if (!reg_mentioned_p (stack_pointer_rtx, PATTERN (insn))\n+\t       && (info.sp_equiv_reg == stack_pointer_rtx\n+\t\t   || !reg_set_p (info.sp_equiv_reg, insn)))\n+\tadd_insn (insn);\n+      else if (! reg_set_p (stack_pointer_rtx, insn)\n+\t       && (info.sp_equiv_reg == stack_pointer_rtx\n+\t\t   || !reg_set_p (info.sp_equiv_reg, insn)))\n \t{\n-\t  if (sp_modified_unknown)\n+\t  if (! validate_replace_rtx (stack_pointer_rtx,\n+\t\t\t\t      plus_constant (info.sp_equiv_reg,\n+\t\t\t\t\t\t     info.sp_offset),\n+\t\t\t\t      insn))\n \t    abort ();\n \n-\t  else if (sp_from_reg != 0)\n-\t    PATTERN (insn)\n-\t      = replace_rtx (PATTERN (insn), stack_pointer_rtx, sp_from_reg);\n+\t  add_insn (insn);\n+\t}\n+      else if (GET_CODE (PATTERN (insn)) == SET)\n+\thandle_epilogue_set (PATTERN (insn), &info);\n+      else if (GET_CODE (PATTERN (insn)) == PARALLEL)\n+\t{\n+\t  for (j = 0; j < XVECLEN (PATTERN (insn), 0); j++)\n+\t    if (GET_CODE (XVECEXP (PATTERN (insn), 0, j)) == SET)\n+\t      handle_epilogue_set (XVECEXP (PATTERN (insn), 0, j), &info);\n+\t}\n+      else\n+\tadd_insn (insn);\n+\n+      info.sp_equiv_reg = info.new_sp_equiv_reg;\n+      info.sp_offset = info.new_sp_offset;\n+    }\n+\n+  seq = gen_sequence ();\n+  end_sequence ();\n+  return seq;\n+}\n+\n+/* SET is a SET from an insn in the epilogue.  P is a pointr to the epi_info\n+   structure that contains information about what we've seen so far.  We\n+   process this SET by either updating that data or by emitting one or \n+   more insns.  */\n+\n+static void\n+handle_epilogue_set (set, p)\n+     rtx set;\n+     struct epi_info *p;\n+{\n+  /* First handle the case where we are setting SP.  Record what it is being\n+     set from.  If unknown, abort.  */\n+  if (reg_set_p (stack_pointer_rtx, set))\n+    {\n+      if (SET_DEST (set) != stack_pointer_rtx)\n+\tabort ();\n+\n+      if (GET_CODE (SET_SRC (set)) == PLUS\n+\t  && GET_CODE (XEXP (SET_SRC (set), 1)) == CONST_INT)\n+\t{\n+\t  p->new_sp_equiv_reg = XEXP (SET_SRC (set), 0);\n+\t  p->new_sp_offset = INTVAL (XEXP (SET_SRC (set), 1));\n \t}\n+      else\n+\tp->new_sp_equiv_reg = SET_SRC (set), p->new_sp_offset = 0;\n+\n+      /* If we are adjusting SP, we adjust from the old data.  */\n+      if (p->new_sp_equiv_reg == stack_pointer_rtx)\n+\t{\n+\t  p->new_sp_equiv_reg = p->sp_equiv_reg;\n+\t  p->new_sp_offset += p->sp_offset;\n+\t}\n+\n+      if (p->new_sp_equiv_reg == 0 || GET_CODE (p->new_sp_equiv_reg) != REG)\n+\tabort ();\n+\n+      return;\n+    }\n+\n+  /* Next handle the case where we are setting SP's equivalent register.\n+     If we already have a value to set it to, abort.  We could update, but\n+     there seems little point in handling that case.  */\n+  else if (p->sp_equiv_reg != 0 && reg_set_p (p->sp_equiv_reg, set))\n+    {\n+      if (!rtx_equal_p (p->sp_equiv_reg, SET_DEST (set))\n+\t  || p->equiv_reg_src != 0)\n+\tabort ();\n+      else\n+\tp->equiv_reg_src\n+\t  = simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n+\t\t\t\t  plus_constant (p->sp_equiv_reg,\n+\t\t\t\t\t\t p->sp_offset));\n+    }\n+\n+  /* Otherwise, replace any references to SP in the insn to its new value\n+     and emit the insn.  */\n+  else\n+    {\n+      SET_SRC (set) = simplify_replace_rtx (SET_SRC (set), stack_pointer_rtx,\n+\t\t\t\t\t    plus_constant (p->sp_equiv_reg,\n+\t\t\t\t\t\t\t   p->sp_offset));\n+      SET_DEST (set) = simplify_replace_rtx (SET_DEST (set), stack_pointer_rtx,\n+\t\t\t\t\t     plus_constant (p->sp_equiv_reg,\n+\t\t\t\t\t\t\t    p->sp_offset));\n+      emit_insn (set);\n     }\n }\n+\n+/* Emit an insn to do the load shown in p->equiv_reg_src, if needed.  */\n+\n+static void\n+emit_equiv_load (p)\n+     struct epi_info *p;\n+{\n+  if (p->equiv_reg_src != 0)\n+    emit_move_insn (p->sp_equiv_reg, p->equiv_reg_src);\n+\n+  p->equiv_reg_src = 0;\n+}\n #endif\n \n /* Generate the prologue and epilogue RTL if the machine supports it.  Thread\n@@ -7360,11 +7588,13 @@ thread_prologue_and_epilogue_insns (f)\n \n       seq = gen_epilogue ();\n \n-      /* If this function returns with the stack depressed, massage\n-\t the epilogue to actually do that.  */\n+#ifdef INCOMING_RETURN_ADDR_RTX\n+      /* If this function returns with the stack depressed and we can support\n+\t it, massage the epilogue to actually do that.  */\n       if (TREE_CODE (TREE_TYPE (current_function_decl)) == FUNCTION_TYPE\n \t  && TYPE_RETURNS_STACK_DEPRESSED (TREE_TYPE (current_function_decl)))\n-\tkeep_stack_depressed (seq);\n+\tseq = keep_stack_depressed (seq);\n+#endif\n \n       emit_jump_insn (seq);\n "}, {"sha": "4ef0c486101a2679504e0d1d7741de9e51140a99", "filename": "gcc/jump.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "patch": "@@ -1244,7 +1244,9 @@ returnjump_p_1 (loc, data)\n      void *data ATTRIBUTE_UNUSED;\n {\n   rtx x = *loc;\n-  return x && GET_CODE (x) == RETURN;\n+\n+  return x && (GET_CODE (x) == RETURN\n+\t       || (GET_CODE (x) == SET && SET_IS_RETURN_P (x)));\n }\n \n int"}, {"sha": "31dabb86dd05573bb1923131a71c3a6b198d39fb", "filename": "gcc/rtl.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3258e9961c0c10b625cf1bcaf7dec24a5c722f45/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=3258e9961c0c10b625cf1bcaf7dec24a5c722f45", "patch": "@@ -130,7 +130,8 @@ struct rtx_def\n   /* 1 in an INSN if it can alter flow of control\n      within this function.\n      MEM_KEEP_ALIAS_SET_P in a MEM.\n-     LINK_COST_ZERO in an INSN_LIST.  */\n+     LINK_COST_ZERO in an INSN_LIST.\n+     SET_IS_RETURN_P in a SET.  */\n   unsigned int jump : 1;\n   /* 1 in an INSN if it can call another function.\n      LINK_COST_FREE in an INSN_LIST.  */\n@@ -965,6 +966,7 @@ extern unsigned int subreg_regno \tPARAMS ((rtx));\n    and SET_SRC is the value it is set to.  */\n #define SET_DEST(RTX) XC2EXP(RTX, 0, SET, CLOBBER)\n #define SET_SRC(RTX) XCEXP(RTX, 1, SET)\n+#define SET_IS_RETURN_P(RTX) ((RTX)->jump)\n \n /* For a TRAP_IF rtx, TRAP_CONDITION is an expression.  */\n #define TRAP_CONDITION(RTX) XCEXP(RTX, 0, TRAP_IF)"}]}