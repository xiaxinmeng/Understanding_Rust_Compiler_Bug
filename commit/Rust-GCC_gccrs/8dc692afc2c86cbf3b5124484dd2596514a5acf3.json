{"sha": "8dc692afc2c86cbf3b5124484dd2596514a5acf3", "node_id": "C_kwDOANBUbNoAKDhkYzY5MmFmYzJjODZjYmYzYjUxMjQ0ODRkZDI1OTY1MTRhNWFjZjM", "commit": {"author": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-20T13:28:23Z"}, "committer": {"name": "Arthur Cohen", "email": "arthur.cohen@embecosm.com", "date": "2022-07-21T09:16:19Z"}, "message": "ast: Add new AttributeChecker visitor\n\nThis commit adds a new attribute checker visitor. Its role is to take care of validating builtin attributes and their inputs.\n\nIn order to validate doc(alias) strings properly, as well as handle\nmultiline (byte) strings, this also fixes the lexer to better handle EOF\nin bytes and codepoints.", "tree": {"sha": "9bc01a3484c3786743ab0d4a65cfca4dae95321e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9bc01a3484c3786743ab0d4a65cfca4dae95321e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8dc692afc2c86cbf3b5124484dd2596514a5acf3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc692afc2c86cbf3b5124484dd2596514a5acf3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dc692afc2c86cbf3b5124484dd2596514a5acf3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dc692afc2c86cbf3b5124484dd2596514a5acf3/comments", "author": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "committer": {"login": "CohenArthur", "id": 43524065, "node_id": "MDQ6VXNlcjQzNTI0MDY1", "avatar_url": "https://avatars.githubusercontent.com/u/43524065?v=4", "gravatar_id": "", "url": "https://api.github.com/users/CohenArthur", "html_url": "https://github.com/CohenArthur", "followers_url": "https://api.github.com/users/CohenArthur/followers", "following_url": "https://api.github.com/users/CohenArthur/following{/other_user}", "gists_url": "https://api.github.com/users/CohenArthur/gists{/gist_id}", "starred_url": "https://api.github.com/users/CohenArthur/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/CohenArthur/subscriptions", "organizations_url": "https://api.github.com/users/CohenArthur/orgs", "repos_url": "https://api.github.com/users/CohenArthur/repos", "events_url": "https://api.github.com/users/CohenArthur/events{/privacy}", "received_events_url": "https://api.github.com/users/CohenArthur/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "137cd3bbaa05038b01c46f7ac7472da7ca662ed7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/137cd3bbaa05038b01c46f7ac7472da7ca662ed7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/137cd3bbaa05038b01c46f7ac7472da7ca662ed7"}], "stats": {"total": 1046, "additions": 1023, "deletions": 23}, "files": [{"sha": "cae4428dea686b2d8901c39132a0dbdde74f1af9", "filename": "gcc/rust/hir/rust-ast-lower-base.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Frust-ast-lower-base.cc?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -872,6 +872,8 @@ ASTLoweringBase::handle_doc_item_attribute (const HIR::Item &item,\n   AST::AttrInputMetaItemContainer *meta_item = option.parse_to_meta_item ();\n \n   // TODO: add actual and complete checks for the doc attributes\n+  //\n+  // FIXME: Move this to the AttributeChecker visitor\n   rust_assert (meta_item);\n }\n "}, {"sha": "22da080bbb24e9fd86ab1e7ba50eb79643a640e2", "filename": "gcc/rust/lex/rust-codepoint.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-codepoint.h?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -32,11 +32,13 @@ struct Codepoint\n   // Creates a codepoint from an encoded UTF-8 value.\n   Codepoint (uint32_t value) : value (value) {}\n \n+  static Codepoint eof () { return Codepoint (UINT32_MAX); }\n+  bool is_eof () const { return value == UINT32_MAX; }\n+\n   // Returns a C++ string containing string value of codepoint.\n   std::string as_string ();\n \n   bool operator== (Codepoint other) const { return value == other.value; }\n-\n   bool operator!= (Codepoint other) const { return !operator== (other); }\n };\n } // namespace Rust"}, {"sha": "70e6b50209fda26c3166b6b5a806eea51a4e5f29", "filename": "gcc/rust/lex/rust-lex.cc", "status": "modified", "additions": 30, "deletions": 19, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -1696,7 +1696,7 @@ Lexer::parse_byte_string (Location loc)\n   int length = 1;\n   current_char = peek_input ();\n \n-  while (current_char != '\"' && current_char != '\\n')\n+  while (current_char != '\"' && current_char != EOF)\n     {\n       if (current_char == '\\\\')\n \t{\n@@ -1723,17 +1723,18 @@ Lexer::parse_byte_string (Location loc)\n \n   current_column += length;\n \n-  if (current_char == '\\n')\n-    {\n-      rust_error_at (get_current_location (), \"unended byte string literal\");\n-    }\n-  else if (current_char == '\"')\n+  if (current_char == '\"')\n     {\n       current_column++;\n \n       skip_input ();\n       current_char = peek_input ();\n     }\n+  else if (current_char == EOF)\n+    {\n+      rust_error_at (get_current_location (), \"unended byte string literal\");\n+      return Token::make (END_OF_FILE, get_current_location ());\n+    }\n   else\n     {\n       gcc_unreachable ();\n@@ -1917,7 +1918,8 @@ Lexer::parse_string (Location loc)\n   int length = 1;\n   current_char32 = peek_codepoint_input ();\n \n-  while (current_char32.value != '\\n' && current_char32.value != '\"')\n+  // FIXME: This fails if the input ends. How do we check for EOF?\n+  while (current_char32.value != '\"' && !current_char32.is_eof ())\n     {\n       if (current_char32.value == '\\\\')\n \t{\n@@ -1949,20 +1951,18 @@ Lexer::parse_string (Location loc)\n \n   current_column += length;\n \n-  if (current_char32.value == '\\n')\n-    {\n-      rust_error_at (get_current_location (), \"unended string literal\");\n-      // by this point, the parser will stuck at this position due to\n-      // undetermined string termination. we now need to unstuck the parser\n-      skip_broken_string_input (current_char32.value);\n-    }\n-  else if (current_char32.value == '\"')\n+  if (current_char32.value == '\"')\n     {\n       current_column++;\n \n       skip_input ();\n       current_char = peek_input ();\n     }\n+  else if (current_char32.is_eof ())\n+    {\n+      rust_error_at (get_current_location (), \"unended string literal\");\n+      return Token::make (END_OF_FILE, get_current_location ());\n+    }\n   else\n     {\n       gcc_unreachable ();\n@@ -2046,7 +2046,7 @@ Lexer::parse_raw_string (Location loc, int initial_hash_count)\n   skip_input ();\n   Codepoint current_char32 = peek_codepoint_input ();\n \n-  while (true)\n+  while (!current_char32.is_eof ())\n     {\n       if (current_char32.value == '\"')\n \t{\n@@ -2318,6 +2318,8 @@ Lexer::parse_char_or_lifetime (Location loc)\n   int length = 1;\n \n   current_char32 = peek_codepoint_input ();\n+  if (current_char32.is_eof ())\n+    return nullptr;\n \n   // parse escaped char literal\n   if (current_char32.value == '\\\\')\n@@ -2398,6 +2400,9 @@ Lexer::get_input_codepoint_length ()\n {\n   uint8_t input = peek_input ();\n \n+  if ((int8_t) input == EOF)\n+    return 0;\n+\n   if (input < 128)\n     {\n       // ascii -- 1 byte\n@@ -2467,7 +2472,8 @@ Lexer::get_input_codepoint_length ()\n     }\n   else\n     {\n-      rust_error_at (get_current_location (), \"invalid UTF-8 (too long)\");\n+      rust_error_at (get_current_location (),\n+\t\t     \"invalid UTF-8 [FIRST] (too long)\");\n       return 0;\n     }\n }\n@@ -2478,6 +2484,9 @@ Lexer::peek_codepoint_input ()\n {\n   uint8_t input = peek_input ();\n \n+  if ((int8_t) input == EOF)\n+    return Codepoint::eof ();\n+\n   if (input < 128)\n     {\n       // ascii -- 1 byte\n@@ -2534,7 +2543,8 @@ Lexer::peek_codepoint_input ()\n     }\n   else\n     {\n-      rust_error_at (get_current_location (), \"invalid UTF-8 (too long)\");\n+      rust_error_at (get_current_location (),\n+\t\t     \"invalid UTF-8 [SECND] (too long)\");\n       return {0xFFFE};\n     }\n }\n@@ -2620,7 +2630,8 @@ Lexer::test_get_input_codepoint_n_length (int n_start_offset)\n     }\n   else\n     {\n-      rust_error_at (get_current_location (), \"invalid UTF-8 (too long)\");\n+      rust_error_at (get_current_location (),\n+\t\t     \"invalid UTF-8 [THIRD] (too long)\");\n       return 0;\n     }\n }"}, {"sha": "1ef6765496917f8f9a44dd1956a1cf349e43e3bc", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -35,6 +35,7 @@\n #include \"rust-export-metadata.h\"\n #include \"rust-imports.h\"\n #include \"rust-extern-crate.h\"\n+#include \"rust-attributes.h\"\n \n #include \"diagnostic.h\"\n #include \"input.h\"\n@@ -738,6 +739,8 @@ Session::parse_file (const char *filename)\n       // TODO: what do I dump here? injected crate names?\n     }\n \n+  Analysis::AttributeChecker ().go (parsed_crate);\n+\n   // expansion pipeline stage\n   expansion (parsed_crate);\n   rust_debug (\"\\033[0;31mSUCCESSFULLY FINISHED EXPANSION \\033[0m\");"}, {"sha": "bf4bb2fbfe9376a0fbf15c6872aafe62cd22315d", "filename": "gcc/rust/util/rust-attributes.cc", "status": "modified", "additions": 767, "deletions": 0, "changes": 767, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Futil%2Frust-attributes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Futil%2Frust-attributes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.cc?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -17,6 +17,10 @@\n // <http://www.gnu.org/licenses/>.\n \n #include \"rust-attributes.h\"\n+#include \"rust-ast.h\"\n+#include \"rust-ast-full.h\"\n+#include \"rust-diagnostics.h\"\n+#include \"safe-ctype.h\"\n \n namespace Rust {\n namespace Analysis {\n@@ -68,5 +72,768 @@ BuiltinAttributeMappings::BuiltinAttributeMappings ()\n     }\n }\n \n+AttributeChecker::AttributeChecker () {}\n+\n+void\n+AttributeChecker::go (AST::Crate &crate)\n+{\n+  check_attributes (crate.get_inner_attrs ());\n+\n+  for (auto &item : crate.items)\n+    item->accept_vis (*this);\n+}\n+\n+static bool\n+is_builtin (const AST::Attribute &attribute, BuiltinAttrDefinition &builtin)\n+{\n+  auto &segments = attribute.get_path ().get_segments ();\n+\n+  // Builtin attributes always have a single segment. This avoids us creating\n+  // strings all over the place and performing a linear search in the builtins\n+  // map\n+  if (segments.size () != 1)\n+    return false;\n+\n+  builtin = BuiltinAttributeMappings::get ()->lookup_builtin (\n+    segments.at (0).get_segment_name ());\n+\n+  return !builtin.is_error ();\n+}\n+\n+/**\n+ * Check that the string given to #[doc(alias = ...)] or #[doc(alias(...))] is\n+ * valid.\n+ *\n+ * This means no whitespace characters other than spaces and no quoting\n+ * characters.\n+ */\n+static void\n+check_doc_alias (const std::string &alias_input, const Location &locus)\n+{\n+  // FIXME: The locus here is for the whole attribute. Can we get the locus\n+  // of the alias input instead?\n+  for (auto c : alias_input)\n+    if ((ISSPACE (c) && c != ' ') || c == '\\'' || c == '\\\"')\n+      {\n+\tauto to_print = std::string (1, c);\n+\tswitch (c)\n+\t  {\n+\t  case '\\n':\n+\t    to_print = \"\\\\n\";\n+\t    break;\n+\t  case '\\t':\n+\t    to_print = \"\\\\t\";\n+\t    break;\n+\t  default:\n+\t    break;\n+\t  }\n+\trust_error_at (locus,\n+\t\t       \"invalid character used in %<#[doc(alias)]%> input: %qs\",\n+\t\t       to_print.c_str ());\n+      }\n+\n+  if (alias_input.empty ())\n+    return;\n+\n+  if (alias_input.front () == ' ' || alias_input.back () == ' ')\n+    rust_error_at (locus,\n+\t\t   \"%<#[doc(alias)]%> input cannot start or end with a space\");\n+}\n+\n+static void\n+check_doc_attribute (const AST::Attribute &attribute)\n+{\n+  if (!attribute.has_attr_input ())\n+    {\n+      rust_error_at (\n+\tattribute.get_locus (),\n+\t// FIXME: Improve error message here. Rustc has a very good one\n+\t\"%<#[doc]%> cannot be an empty attribute\");\n+      return;\n+    }\n+\n+  switch (attribute.get_attr_input ().get_attr_input_type ())\n+    {\n+    case AST::AttrInput::LITERAL:\n+    case AST::AttrInput::META_ITEM:\n+      break;\n+      // FIXME: Handle them as well\n+\n+      case AST::AttrInput::TOKEN_TREE: {\n+\t// FIXME: This doesn't check for #[doc(alias(...))]\n+\tconst auto &option = static_cast<const AST::DelimTokenTree &> (\n+\t  attribute.get_attr_input ());\n+\tauto *meta_item = option.parse_to_meta_item ();\n+\n+\tfor (auto &item : meta_item->get_items ())\n+\t  {\n+\t    if (item->is_key_value_pair ())\n+\t      {\n+\t\tauto name_value\n+\t\t  = static_cast<AST::MetaNameValueStr *> (item.get ())\n+\t\t      ->get_name_value_pair ();\n+\n+\t\t// FIXME: Check for other stuff than #[doc(alias = ...)]\n+\t\tif (name_value.first == \"alias\")\n+\t\t  check_doc_alias (name_value.second, attribute.get_locus ());\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+    }\n+}\n+\n+void\n+AttributeChecker::check_attribute (const AST::Attribute &attribute)\n+{\n+  BuiltinAttrDefinition result;\n+\n+  // This checker does not check non-builtin attributes\n+  if (!is_builtin (attribute, result))\n+    return;\n+\n+  // TODO: Add checks here for each builtin attribute\n+  // TODO: Have an enum of builtins as well, switching on strings is annoying\n+  // and costly\n+  if (result.name == \"doc\")\n+    check_doc_attribute (attribute);\n+}\n+\n+void\n+AttributeChecker::check_attributes (const AST::AttrVec &attributes)\n+{\n+  for (auto &attr : attributes)\n+    check_attribute (attr);\n+}\n+\n+void\n+AttributeChecker::visit (AST::Token &tok)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::DelimTokenTree &delim_tok_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AttrInputMetaItemContainer &input)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IdentifierExpr &ident_expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Lifetime &lifetime)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LifetimeParam &lifetime_param)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ConstGenericParam &const_param)\n+{}\n+\n+// rust-path.h\n+void\n+AttributeChecker::visit (AST::PathInExpression &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegment &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegmentGeneric &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePathSegmentFunction &segment)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypePath &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::QualifiedPathInExpression &path)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::QualifiedPathInType &path)\n+{}\n+\n+// rust-expr.h\n+void\n+AttributeChecker::visit (AST::LiteralExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AttrInputLiteral &attr_input)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemLitExpr &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemPathLit &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BorrowExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::DereferenceExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ErrorPropagationExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::NegationExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArithmeticOrLogicalExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ComparisonExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LazyBooleanExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeCastExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AssignmentExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::CompoundAssignmentExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::GroupedExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayElemsValues &elems)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayElemsCopied &elems)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayIndexExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleIndexExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStruct &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIdentifier &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIdentifierValue &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprFieldIndexValue &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStructFields &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructExprStructBase &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::CallExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MethodCallExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::FieldAccessExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ClosureExprInner &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BlockExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ClosureExprInnerTyped &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ContinueExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BreakExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromToExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeToExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFullExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeFromToInclExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangeToInclExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReturnExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UnsafeBlockExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WhileLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WhileLetLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ForLoopExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqElse &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqIf &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfExprConseqIfLet &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqElse &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqIf &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IfLetExprConseqIfLet &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MatchExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AwaitExpr &expr)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::AsyncBlockExpr &expr)\n+{}\n+\n+// rust-item.h\n+void\n+AttributeChecker::visit (AST::TypeParam &param)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LifetimeWhereClauseItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeBoundWhereClauseItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Method &method)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Module &module)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternCrate &crate)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeGlob &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeList &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseTreeRebind &use_tree)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::UseDeclaration &use_decl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Function &function)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TypeAlias &type_alias)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructStruct &struct_item)\n+{\n+  check_attributes (struct_item.get_outer_attrs ());\n+}\n+\n+void\n+AttributeChecker::visit (AST::TupleStruct &tuple_struct)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemTuple &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemStruct &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::EnumItemDiscriminant &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Enum &enum_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Union &union_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ConstantItem &const_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StaticItem &static_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemFunc &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemMethod &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemConst &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitItemType &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::Trait &trait)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::InherentImpl &impl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitImpl &impl)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternalStaticItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternalFunctionItem &item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExternBlock &block)\n+{}\n+\n+// rust-macro.h\n+void\n+AttributeChecker::visit (AST::MacroMatchFragment &match)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroMatchRepetition &match)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroMatcher &matcher)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroRulesDefinition &rules_def)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MacroInvocation &macro_invoc)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemPath &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaItemSeq &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaWord &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaNameValueStr &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaListPaths &meta_item)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::MetaListNameValueStr &meta_item)\n+{}\n+\n+// rust-pattern.h\n+void\n+AttributeChecker::visit (AST::LiteralPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::IdentifierPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::WildcardPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(RangePatternBound& bound){}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundLiteral &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundPath &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePatternBoundQualPath &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RangePattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReferencePattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(StructPatternField& field){}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldTuplePat &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldIdentPat &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPatternFieldIdent &field)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::StructPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(TupleStructItems& tuple_items){}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructItemsNoRange &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructItemsRange &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleStructPattern &pattern)\n+{}\n+\n+// void AttributeChecker::visit(TuplePatternItems& tuple_items){}\n+\n+void\n+AttributeChecker::visit (AST::TuplePatternItemsMultiple &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TuplePatternItemsRanged &tuple_items)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TuplePattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::GroupedPattern &pattern)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::SlicePattern &pattern)\n+{}\n+\n+// rust-stmt.h\n+void\n+AttributeChecker::visit (AST::EmptyStmt &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::LetStmt &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExprStmtWithoutBlock &stmt)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ExprStmtWithBlock &stmt)\n+{}\n+\n+// rust-type.h\n+void\n+AttributeChecker::visit (AST::TraitBound &bound)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ImplTraitType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitObjectType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ParenthesisedType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ImplTraitTypeOneBound &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TraitObjectTypeOneBound &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::TupleType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::NeverType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::RawPointerType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ReferenceType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::ArrayType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::SliceType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::InferredType &type)\n+{}\n+\n+void\n+AttributeChecker::visit (AST::BareFunctionType &type)\n+{}\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "3ac93ff59080d0dfe90de9aaefade6692e851fd3", "filename": "gcc/rust/util/rust-attributes.h", "status": "modified", "additions": 200, "deletions": 0, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Futil%2Frust-attributes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Frust%2Futil%2Frust-attributes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-attributes.h?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -16,7 +16,9 @@\n // along with GCC; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n+#include \"rust-ast.h\"\n #include \"rust-system.h\"\n+#include \"rust-ast-visitor.h\"\n \n namespace Rust {\n namespace Analysis {\n@@ -66,5 +68,203 @@ class BuiltinAttributeMappings\n   std::map<std::string, const BuiltinAttrDefinition> mappings;\n };\n \n+/**\n+ * Checks the validity of various attributes. The goal of this visitor is to\n+ * make sure that attributes are applied in allowed contexts, for example to\n+ * make sure that #[inline] is only applied to functions and closures, as well\n+ * as checking the \"arguments\" or input given to these attributes, making sure\n+ * it is appropriate and valid.\n+ */\n+class AttributeChecker : public AST::ASTVisitor\n+{\n+public:\n+  AttributeChecker ();\n+\n+  /**\n+   * Check all the attributes of all the items of a crate\n+   */\n+  void go (AST::Crate &crate);\n+\n+private:\n+  /* Check the validity of a given attribute */\n+  void check_attribute (const AST::Attribute &attribute);\n+\n+  /* Check the validity of all given attributes */\n+  void check_attributes (const AST::AttrVec &attributes);\n+\n+  // rust-ast.h\n+  void visit (AST::Token &tok);\n+  void visit (AST::DelimTokenTree &delim_tok_tree);\n+  void visit (AST::AttrInputMetaItemContainer &input);\n+  void visit (AST::IdentifierExpr &ident_expr);\n+  void visit (AST::Lifetime &lifetime);\n+  void visit (AST::LifetimeParam &lifetime_param);\n+  void visit (AST::ConstGenericParam &const_param);\n+\n+  // rust-path.h\n+  void visit (AST::PathInExpression &path);\n+  void visit (AST::TypePathSegment &segment);\n+  void visit (AST::TypePathSegmentGeneric &segment);\n+  void visit (AST::TypePathSegmentFunction &segment);\n+  void visit (AST::TypePath &path);\n+  void visit (AST::QualifiedPathInExpression &path);\n+  void visit (AST::QualifiedPathInType &path);\n+\n+  // rust-expr.h\n+  void visit (AST::LiteralExpr &expr);\n+  void visit (AST::AttrInputLiteral &attr_input);\n+  void visit (AST::MetaItemLitExpr &meta_item);\n+  void visit (AST::MetaItemPathLit &meta_item);\n+  void visit (AST::BorrowExpr &expr);\n+  void visit (AST::DereferenceExpr &expr);\n+  void visit (AST::ErrorPropagationExpr &expr);\n+  void visit (AST::NegationExpr &expr);\n+  void visit (AST::ArithmeticOrLogicalExpr &expr);\n+  void visit (AST::ComparisonExpr &expr);\n+  void visit (AST::LazyBooleanExpr &expr);\n+  void visit (AST::TypeCastExpr &expr);\n+  void visit (AST::AssignmentExpr &expr);\n+  void visit (AST::CompoundAssignmentExpr &expr);\n+  void visit (AST::GroupedExpr &expr);\n+  void visit (AST::ArrayElemsValues &elems);\n+  void visit (AST::ArrayElemsCopied &elems);\n+  void visit (AST::ArrayExpr &expr);\n+  void visit (AST::ArrayIndexExpr &expr);\n+  void visit (AST::TupleExpr &expr);\n+  void visit (AST::TupleIndexExpr &expr);\n+  void visit (AST::StructExprStruct &expr);\n+  void visit (AST::StructExprFieldIdentifier &field);\n+  void visit (AST::StructExprFieldIdentifierValue &field);\n+  void visit (AST::StructExprFieldIndexValue &field);\n+  void visit (AST::StructExprStructFields &expr);\n+  void visit (AST::StructExprStructBase &expr);\n+  void visit (AST::CallExpr &expr);\n+  void visit (AST::MethodCallExpr &expr);\n+  void visit (AST::FieldAccessExpr &expr);\n+  void visit (AST::ClosureExprInner &expr);\n+  void visit (AST::BlockExpr &expr);\n+  void visit (AST::ClosureExprInnerTyped &expr);\n+  void visit (AST::ContinueExpr &expr);\n+  void visit (AST::BreakExpr &expr);\n+  void visit (AST::RangeFromToExpr &expr);\n+  void visit (AST::RangeFromExpr &expr);\n+  void visit (AST::RangeToExpr &expr);\n+  void visit (AST::RangeFullExpr &expr);\n+  void visit (AST::RangeFromToInclExpr &expr);\n+  void visit (AST::RangeToInclExpr &expr);\n+  void visit (AST::ReturnExpr &expr);\n+  void visit (AST::UnsafeBlockExpr &expr);\n+  void visit (AST::LoopExpr &expr);\n+  void visit (AST::WhileLoopExpr &expr);\n+  void visit (AST::WhileLetLoopExpr &expr);\n+  void visit (AST::ForLoopExpr &expr);\n+  void visit (AST::IfExpr &expr);\n+  void visit (AST::IfExprConseqElse &expr);\n+  void visit (AST::IfExprConseqIf &expr);\n+  void visit (AST::IfExprConseqIfLet &expr);\n+  void visit (AST::IfLetExpr &expr);\n+  void visit (AST::IfLetExprConseqElse &expr);\n+  void visit (AST::IfLetExprConseqIf &expr);\n+  void visit (AST::IfLetExprConseqIfLet &expr);\n+  void visit (AST::MatchExpr &expr);\n+  void visit (AST::AwaitExpr &expr);\n+  void visit (AST::AsyncBlockExpr &expr);\n+\n+  // rust-item.h\n+  void visit (AST::TypeParam &param);\n+  void visit (AST::LifetimeWhereClauseItem &item);\n+  void visit (AST::TypeBoundWhereClauseItem &item);\n+  void visit (AST::Method &method);\n+  void visit (AST::Module &module);\n+  void visit (AST::ExternCrate &crate);\n+  void visit (AST::UseTreeGlob &use_tree);\n+  void visit (AST::UseTreeList &use_tree);\n+  void visit (AST::UseTreeRebind &use_tree);\n+  void visit (AST::UseDeclaration &use_decl);\n+  void visit (AST::Function &function);\n+  void visit (AST::TypeAlias &type_alias);\n+  void visit (AST::StructStruct &struct_item);\n+  void visit (AST::TupleStruct &tuple_struct);\n+  void visit (AST::EnumItem &item);\n+  void visit (AST::EnumItemTuple &item);\n+  void visit (AST::EnumItemStruct &item);\n+  void visit (AST::EnumItemDiscriminant &item);\n+  void visit (AST::Enum &enum_item);\n+  void visit (AST::Union &union_item);\n+  void visit (AST::ConstantItem &const_item);\n+  void visit (AST::StaticItem &static_item);\n+  void visit (AST::TraitItemFunc &item);\n+  void visit (AST::TraitItemMethod &item);\n+  void visit (AST::TraitItemConst &item);\n+  void visit (AST::TraitItemType &item);\n+  void visit (AST::Trait &trait);\n+  void visit (AST::InherentImpl &impl);\n+  void visit (AST::TraitImpl &impl);\n+  void visit (AST::ExternalStaticItem &item);\n+  void visit (AST::ExternalFunctionItem &item);\n+  void visit (AST::ExternBlock &block);\n+\n+  // rust-macro.h\n+  void visit (AST::MacroMatchFragment &match);\n+  void visit (AST::MacroMatchRepetition &match);\n+  void visit (AST::MacroMatcher &matcher);\n+  void visit (AST::MacroRulesDefinition &rules_def);\n+  void visit (AST::MacroInvocation &macro_invoc);\n+  void visit (AST::MetaItemPath &meta_item);\n+  void visit (AST::MetaItemSeq &meta_item);\n+  void visit (AST::MetaWord &meta_item);\n+  void visit (AST::MetaNameValueStr &meta_item);\n+  void visit (AST::MetaListPaths &meta_item);\n+  void visit (AST::MetaListNameValueStr &meta_item);\n+\n+  // rust-pattern.h\n+  void visit (AST::LiteralPattern &pattern);\n+  void visit (AST::IdentifierPattern &pattern);\n+  void visit (AST::WildcardPattern &pattern);\n+  // void visit(RangePatternBound& bound);\n+  void visit (AST::RangePatternBoundLiteral &bound);\n+  void visit (AST::RangePatternBoundPath &bound);\n+  void visit (AST::RangePatternBoundQualPath &bound);\n+  void visit (AST::RangePattern &pattern);\n+  void visit (AST::ReferencePattern &pattern);\n+  // void visit(StructPatternField& field);\n+  void visit (AST::StructPatternFieldTuplePat &field);\n+  void visit (AST::StructPatternFieldIdentPat &field);\n+  void visit (AST::StructPatternFieldIdent &field);\n+  void visit (AST::StructPattern &pattern);\n+  // void visit(TupleStructItems& tuple_items);\n+  void visit (AST::TupleStructItemsNoRange &tuple_items);\n+  void visit (AST::TupleStructItemsRange &tuple_items);\n+  void visit (AST::TupleStructPattern &pattern);\n+  // void visit(TuplePatternItems& tuple_items);\n+  void visit (AST::TuplePatternItemsMultiple &tuple_items);\n+  void visit (AST::TuplePatternItemsRanged &tuple_items);\n+  void visit (AST::TuplePattern &pattern);\n+  void visit (AST::GroupedPattern &pattern);\n+  void visit (AST::SlicePattern &pattern);\n+\n+  // rust-stmt.h\n+  void visit (AST::EmptyStmt &stmt);\n+  void visit (AST::LetStmt &stmt);\n+  void visit (AST::ExprStmtWithoutBlock &stmt);\n+  void visit (AST::ExprStmtWithBlock &stmt);\n+\n+  // rust-type.h\n+  void visit (AST::TraitBound &bound);\n+  void visit (AST::ImplTraitType &type);\n+  void visit (AST::TraitObjectType &type);\n+  void visit (AST::ParenthesisedType &type);\n+  void visit (AST::ImplTraitTypeOneBound &type);\n+  void visit (AST::TraitObjectTypeOneBound &type);\n+  void visit (AST::TupleType &type);\n+  void visit (AST::NeverType &type);\n+  void visit (AST::RawPointerType &type);\n+  void visit (AST::ReferenceType &type);\n+  void visit (AST::ArrayType &type);\n+  void visit (AST::SliceType &type);\n+  void visit (AST::InferredType &type);\n+  void visit (AST::BareFunctionType &type);\n+};\n+\n } // namespace Analysis\n } // namespace Rust"}, {"sha": "e113120bdbc1b4f8cbfc4c8d0e7e289a348bf999", "filename": "gcc/testsuite/rust/compile/torture/check-doc-attr-string.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcheck-doc-attr-string.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcheck-doc-attr-string.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcheck-doc-attr-string.rs?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -5,9 +5,14 @@\n pub struct Bar;\n \n #[doc(alias = \"\n-\")] // { dg-error \"unended string literal\" \"\" { target *-*-* } .-1 }\n+\")] // { dg-error \"invalid character used\" \"\" { target *-*-* } .-1 }\n pub struct Foo;\n \n-#[doc(alias(\"\n-\"))] // { dg-error \"unended string literal\" \"\" { target *-*-* } .-1 }\n+#[doc(alias(\n+    \"\n+\"\n+))] // ko but unchecked for now\n pub struct Foo2;\n+\n+#[doc(whatever = \"buidule\")] // ko as well but unchecked for now\n+struct Boo;"}, {"sha": "66f0cd52269a584d4fb450b751c977f8cfb6d6cc", "filename": "gcc/testsuite/rust/compile/torture/undended-string-1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-1.rs?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -0,0 +1,5 @@\n+// { dg-excess-errors \"....\" }\n+fn main() {\n+    // { dg-error \"unended string literal\" \"\" { target *-*-* } .+1 }\n+    let s = \"123\n+}"}, {"sha": "c0f424927c20746ff837159384f954861f6ee322", "filename": "gcc/testsuite/rust/compile/torture/undended-string-2.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8dc692afc2c86cbf3b5124484dd2596514a5acf3/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fundended-string-2.rs?ref=8dc692afc2c86cbf3b5124484dd2596514a5acf3", "patch": "@@ -0,0 +1,5 @@\n+// { dg-excess-errors \"....\" }\n+fn main() {\n+    // { dg-error \"unended byte string literal\" \"\" { target *-*-* } .+1 }\n+    let s = b\"123\n+}"}]}