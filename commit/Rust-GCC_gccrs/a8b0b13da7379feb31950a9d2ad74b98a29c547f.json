{"sha": "a8b0b13da7379feb31950a9d2ad74b98a29c547f", "node_id": "C_kwDOANBUbNoAKGE4YjBiMTNkYTczNzlmZWIzMTk1MGE5ZDJhZDc0Yjk4YTI5YzU0N2Y", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-09T10:06:38Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-09-09T12:31:35Z"}, "message": "tree-optimization/106722 - avoid invalid pointer association in predcom\n\nWhen predictive commoning builds a reference for iteration N it\nprematurely associates a constant offset into the MEM_REF offset\noperand which can be invalid if the base pointer then points\noutside of an object which alias-analysis does not consider valid.\n\n\tPR tree-optimization/106722\n\t* tree-predcom.cc (ref_at_iteration): Do not associate the\n\tconstant part of the offset into the MEM_REF offset\n\toperand, across a non-zero offset.\n\n\t* gcc.dg/torture/pr106892.c: New testcase.", "tree": {"sha": "5bfbc119e5a4fa89046fdb2cf4e6ac1545b1fdbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bfbc119e5a4fa89046fdb2cf4e6ac1545b1fdbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a8b0b13da7379feb31950a9d2ad74b98a29c547f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b0b13da7379feb31950a9d2ad74b98a29c547f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a8b0b13da7379feb31950a9d2ad74b98a29c547f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a8b0b13da7379feb31950a9d2ad74b98a29c547f/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26a1f4fcb264d110708483815c8c8d7bb4ff6788", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26a1f4fcb264d110708483815c8c8d7bb4ff6788", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26a1f4fcb264d110708483815c8c8d7bb4ff6788"}], "stats": {"total": 48, "additions": 46, "deletions": 2}, "files": [{"sha": "73a66a037b7a57b3a07c411a18d386e617ddd933", "filename": "gcc/testsuite/gcc.dg/torture/pr106892.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b0b13da7379feb31950a9d2ad74b98a29c547f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106892.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b0b13da7379feb31950a9d2ad74b98a29c547f/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106892.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr106892.c?ref=a8b0b13da7379feb31950a9d2ad74b98a29c547f", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run } */\n+\n+int a, b, c, d, e;\n+int f[8];\n+static int g() {\n+  while (a)\n+    a >>= 4;\n+  return 0;\n+}\n+static int h(int i) {\n+  if (i >= '0')\n+    return i - '0';\n+  //__builtin_unreachable ();\n+}\n+void __attribute__((noipa)) j(int i) {\n+  for (b = 2; g() <= 7; b++)\n+    if (i) {\n+      for (; e <= 7; e++)\n+        for (c = 1; c <= 7; c++) {\n+          d = h(b + '0');\n+          f[-d + 4] ^= 3;\n+        }\n+      return;\n+    }\n+}\n+int main() {\n+  j(1);\n+  if (f[2] != 0)\n+    __builtin_abort ();\n+}"}, {"sha": "a6e45e36ffda1083cc31d8d479a79e75df303474", "filename": "gcc/tree-predcom.cc", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a8b0b13da7379feb31950a9d2ad74b98a29c547f/gcc%2Ftree-predcom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a8b0b13da7379feb31950a9d2ad74b98a29c547f/gcc%2Ftree-predcom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.cc?ref=a8b0b13da7379feb31950a9d2ad74b98a29c547f", "patch": "@@ -1771,10 +1771,24 @@ ref_at_iteration (data_reference_p dr, int iter,\n \t  ref = TREE_OPERAND (ref, 0);\n \t}\n     }\n-  tree addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);\n+  /* We may not associate the constant offset across the pointer plus\n+     expression because that might form a pointer to before the object\n+     then.  But for some cases we can retain that to allow tree_could_trap_p\n+     to return false - see gcc.dg/tree-ssa/predcom-1.c  */\n+  tree addr, alias_ptr;\n+  if (integer_zerop  (off))\n+    {\n+      alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);\n+      addr = DR_BASE_ADDRESS (dr);\n+    }\n+  else\n+    {\n+      alias_ptr = build_zero_cst (reference_alias_ptr_type (ref));\n+      off = size_binop (PLUS_EXPR, off, coff);\n+      addr = fold_build_pointer_plus (DR_BASE_ADDRESS (dr), off);\n+    }\n   addr = force_gimple_operand_1 (unshare_expr (addr), stmts,\n \t\t\t\t is_gimple_mem_ref_addr, NULL_TREE);\n-  tree alias_ptr = fold_convert (reference_alias_ptr_type (ref), coff);\n   tree type = build_aligned_type (TREE_TYPE (ref),\n \t\t\t\t  get_object_alignment (ref));\n   ref = build2 (MEM_REF, type, addr, alias_ptr);"}]}