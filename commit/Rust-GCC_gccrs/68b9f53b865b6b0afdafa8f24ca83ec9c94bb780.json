{"sha": "68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjhiOWY1M2I4NjViNmIwYWZkYWZhOGYyNGNhODNlYzljOTRiYjc4MA==", "commit": {"author": {"name": "Andrew MacLeod", "email": "amacleod@redhat.com", "date": "2004-08-10T18:31:26Z"}, "committer": {"name": "Andrew Macleod", "email": "amacleod@gcc.gnu.org", "date": "2004-08-10T18:31:26Z"}, "message": "tree-cfg.c (bsi_insert_before, [...]): Call modify_stmt after linking stmt into the program.\n\n\n2004-08-10  Andrew MacLeod  <amacleod@redhat.com>\n\n\t* tree-cfg.c (bsi_insert_before, bsi_insert_after): Call modify_stmt\n\tafter linking stmt into the program.\n\t(bsi_remove): Don't call modify_stmt.\n\t* tree-complex.c (update_complex_assignment,\n\texpand_complex_comparison): Call modify_stmt after changing the stmt.\n\t* tree-outof-ssa.c (rewrite_trees): Call modify_stmt only if not\n\tremoving the stmt.\n\t* tree-ssa-ccp.c (substitute_and_fold): Call modify_stmt after changing\n\tthe stmt, and only if needed.\n\t* tree-ssa-dom.c (thread_across_edge): Pass no annotation for a dummy\n\texpression.\n\t(simplify_rhs_and_lookup_avail_expr): Don't take an annotation param.\n\t(simplify_cond_and_lookup_avail_expr): Use modify_stmt.\n\t(simplify_switch_and_lookup_avail_expr): Don't take an annotation param.\n\t(eliminate_redundant_computations): Don't pass an annotation. Call\n\tmodify_stmt rather than setting the annotation directly.\n\t(record_equivalences_from_stmt): Remove unused local 'j'.\n\t(cprop_operand): Take a stmt rather than an annotation as a parameter.\n\tCall modify_stmt.\n\t(cprop_into_stmt): Pass stmt rather than annotation.\n\t(update_rhs_and_lookup_avail_expr): Call modify_stmt.\n\t* tree-ssa-loop-im.c (schedule_sm): Call get_stmt_ann rather than\n\tmodify_stmt.\n\t* tree-ssa.c (propagate_into_addr): Dont call modify_stmt.\n\nFrom-SVN: r85765", "tree": {"sha": "94a21421b527ae4b4227ebca0308a5feadea6008", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/94a21421b527ae4b4227ebca0308a5feadea6008"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "html_url": "https://github.com/Rust-GCC/gccrs/commit/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/comments", "author": null, "committer": null, "parents": [{"sha": "6c9c452695f66cfb588e4001e3a2b774a8a52015", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c9c452695f66cfb588e4001e3a2b774a8a52015", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c9c452695f66cfb588e4001e3a2b774a8a52015"}], "stats": {"total": 110, "additions": 64, "deletions": 46}, "files": [{"sha": "e8d1398d3f877262a7c3b436d7f2db0d19f0e2f8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -1,3 +1,30 @@\n+2004-08-10  Andrew MacLeod  <amacleod@redhat.com>\n+\n+\t* tree-cfg.c (bsi_insert_before, bsi_insert_after): Call modify_stmt\n+\tafter linking stmt into the program.\n+\t(bsi_remove): Don't call modify_stmt.\n+\t* tree-complex.c (update_complex_assignment, \n+\texpand_complex_comparison): Call modify_stmt after changing the stmt.\n+\t* tree-outof-ssa.c (rewrite_trees): Call modify_stmt only if not \n+\tremoving the stmt.\n+\t* tree-ssa-ccp.c (substitute_and_fold): Call modify_stmt after changing\n+\tthe stmt, and only if needed.\n+\t* tree-ssa-dom.c (thread_across_edge): Pass no annotation for a dummy\n+\texpression.\n+\t(simplify_rhs_and_lookup_avail_expr): Don't take an annotation param.\n+\t(simplify_cond_and_lookup_avail_expr): Use modify_stmt.\n+\t(simplify_switch_and_lookup_avail_expr): Don't take an annotation param.\n+\t(eliminate_redundant_computations): Don't pass an annotation. Call \n+\tmodify_stmt rather than setting the annotation directly.\n+\t(record_equivalences_from_stmt): Remove unused local 'j'.\n+\t(cprop_operand): Take a stmt rather than an annotation as a parameter.\n+\tCall modify_stmt.\n+\t(cprop_into_stmt): Pass stmt rather than annotation.\n+\t(update_rhs_and_lookup_avail_expr): Call modify_stmt.\n+\t* tree-ssa-loop-im.c (schedule_sm): Call get_stmt_ann rather than \n+\tmodify_stmt.\n+\t* tree-ssa.c (propagate_into_addr): Dont call modify_stmt.\n+\n 2004-08-10  Jason Merrill  <jason@redhat.com>\n \n \tPR middle-end/16948"}, {"sha": "33c8325041b108014eeb8fcf3388b3fc0bc4a876", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -2814,8 +2814,8 @@ void\n bsi_insert_before (block_stmt_iterator *i, tree t, enum bsi_iterator_update m)\n {\n   set_bb_for_stmt (t, i->bb);\n-  modify_stmt (t);\n   tsi_link_before (&i->tsi, t, m);\n+  modify_stmt (t);\n }\n \n \n@@ -2827,8 +2827,8 @@ void\n bsi_insert_after (block_stmt_iterator *i, tree t, enum bsi_iterator_update m)\n {\n   set_bb_for_stmt (t, i->bb);\n-  modify_stmt (t);\n   tsi_link_after (&i->tsi, t, m);\n+  modify_stmt (t);\n }\n \n \n@@ -2840,7 +2840,6 @@ bsi_remove (block_stmt_iterator *i)\n {\n   tree t = bsi_stmt (*i);\n   set_bb_for_stmt (t, NULL);\n-  modify_stmt (t);\n   tsi_delink (&i->tsi);\n }\n "}, {"sha": "54ea8197df180f5946db932a26b4793f85185128", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -78,12 +78,12 @@ update_complex_assignment (block_stmt_iterator *bsi, tree r, tree i)\n   tree stmt = bsi_stmt (*bsi);\n   tree type;\n \n-  modify_stmt (stmt);\n   if (TREE_CODE (stmt) == RETURN_EXPR)\n     stmt = TREE_OPERAND (stmt, 0);\n   \n   type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n   TREE_OPERAND (stmt, 1) = build (COMPLEX_EXPR, type, r, i);\n+  modify_stmt (stmt);\n }\n \n /* Expand complex addition to scalars:\n@@ -326,32 +326,33 @@ static void\n expand_complex_comparison (block_stmt_iterator *bsi, tree ar, tree ai,\n \t\t\t   tree br, tree bi, enum tree_code code)\n {\n-  tree cr, ci, cc, stmt, type;\n+  tree cr, ci, cc, stmt, expr, type;\n \n   cr = gimplify_build2 (bsi, code, boolean_type_node, ar, br);\n   ci = gimplify_build2 (bsi, code, boolean_type_node, ai, bi);\n   cc = gimplify_build2 (bsi,\n \t\t\t(code == EQ_EXPR ? TRUTH_AND_EXPR : TRUTH_OR_EXPR),\n \t\t\tboolean_type_node, cr, ci);\n \n-  stmt = bsi_stmt (*bsi);\n-  modify_stmt (stmt);\n+  stmt = expr = bsi_stmt (*bsi);\n \n   switch (TREE_CODE (stmt))\n     {\n     case RETURN_EXPR:\n-      stmt = TREE_OPERAND (stmt, 0);\n+      expr = TREE_OPERAND (stmt, 0);\n       /* FALLTHRU */\n     case MODIFY_EXPR:\n-      type = TREE_TYPE (TREE_OPERAND (stmt, 1));\n-      TREE_OPERAND (stmt, 1) = fold_convert (type, cc);\n+      type = TREE_TYPE (TREE_OPERAND (expr, 1));\n+      TREE_OPERAND (expr, 1) = fold_convert (type, cc);\n       break;\n     case COND_EXPR:\n       TREE_OPERAND (stmt, 0) = cc;\n       break;\n     default:\n       abort ();\n     }\n+\n+  modify_stmt (stmt);\n }\n \n /* Process one statement.  If we identify a complex operation, expand it.  */"}, {"sha": "5b1e2a8fc1e4225012a4a9ef25c4fcbe6da5b376", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -1935,7 +1935,7 @@ rewrite_trees (var_map map, tree *values)\n \t\t      && (DEF_FROM_PTR (def_p) == USE_OP (uses, 0)))\n \t\t    remove = 1;\n \t\t}\n-\t      if (changed)\n+\t      if (changed & !remove)\n \t\tmodify_stmt (stmt);\n \t    }\n "}, {"sha": "e2d3bbf180af0eff5adff16c8fcc73855f849c65", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -427,7 +427,6 @@ substitute_and_fold (void)\n \t    {\n \t      bool changed = fold_stmt (bsi_stmt_ptr (i));\n \t      stmt = bsi_stmt(i);\n-\t      modify_stmt (stmt);\n \t      /* If we folded a builtin function, we'll likely\n \t\t need to rename VDEFs.  */\n \t      if (replaced_address || changed)\n@@ -436,6 +435,8 @@ substitute_and_fold (void)\n \t\t  if (maybe_clean_eh_stmt (stmt))\n \t\t    tree_purge_dead_eh_edges (bb);\n \t\t}\n+\t      else\n+\t\tmodify_stmt (stmt);\n \t    }\n \n \t  if (dump_file && (dump_flags & TDF_DETAILS))"}, {"sha": "c089cf1b590b34dde72786ed2dd84b5d9f981b56", "filename": "gcc/tree-ssa-dom.c", "status": "modified", "additions": 22, "deletions": 31, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-dom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-dom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -223,14 +223,12 @@ static void record_cond (tree, tree, varray_type *);\n static void record_dominating_conditions (tree, varray_type *);\n static void record_const_or_copy (tree, tree, varray_type *);\n static void record_equality (tree, tree, varray_type *);\n-static tree update_rhs_and_lookup_avail_expr (tree, tree, varray_type *,\n-\t\t\t\t\t      stmt_ann_t, bool);\n+static tree update_rhs_and_lookup_avail_expr (tree, tree, varray_type *, bool);\n static tree simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *,\n-\t\t\t\t\t\ttree, stmt_ann_t, int);\n+\t\t\t\t\t\ttree, int);\n static tree simplify_cond_and_lookup_avail_expr (tree, varray_type *,\n \t\t\t\t\t\t stmt_ann_t, int);\n-static tree simplify_switch_and_lookup_avail_expr (tree, varray_type *,\n-\t\t\t\t\t\t   stmt_ann_t, int);\n+static tree simplify_switch_and_lookup_avail_expr (tree, varray_type *, int);\n static tree find_equivalent_equality_comparison (tree);\n static void record_range (tree, basic_block, varray_type *);\n static bool extract_range_from_cond (tree, tree *, tree *, int *);\n@@ -652,10 +650,9 @@ thread_across_edge (struct dom_walk_data *walk_data, edge e)\n \t    cached_lhs = lookup_avail_expr (dummy_cond, NULL, false);\n  \t  if (!cached_lhs || ! is_gimple_min_invariant (cached_lhs))\n \t    {\n-\t      stmt_ann_t ann = get_stmt_ann (dummy_cond);\n \t      cached_lhs = simplify_cond_and_lookup_avail_expr (dummy_cond,\n \t\t\t\t\t\t\t\tNULL,\n-\t\t\t\t\t\t\t\tann,\n+\t\t\t\t\t\t\t\tNULL,\n \t\t\t\t\t\t\t\tfalse);\n \t    }\n \t}\n@@ -1628,9 +1625,7 @@ record_equality (tree x, tree y, varray_type *block_const_and_copies_p)\n \n static tree\n simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n-\t\t\t\t    tree stmt,\n-\t\t\t\t    stmt_ann_t ann,\n-\t\t\t\t    int insert)\n+\t\t\t\t    tree stmt, int insert)\n {\n   tree rhs = TREE_OPERAND (stmt, 1);\n   enum tree_code rhs_code = TREE_CODE (rhs);\n@@ -1663,7 +1658,6 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t    result = update_rhs_and_lookup_avail_expr (stmt,\n \t\t\t\t\t\t       rhs_def_operand,\n \t\t\t\t\t\t       &bd->avail_exprs,\n-\t\t\t\t\t\t       ann,\n \t\t\t\t\t\t       insert);\n \t}\n     }\n@@ -1748,7 +1742,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t\t  && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME\n \t\t\t  && is_gimple_val (TREE_OPERAND (t, 1))))\n \t\t    result = update_rhs_and_lookup_avail_expr\n-\t\t      (stmt, t, &bd->avail_exprs, ann, insert);\n+\t\t      (stmt, t, &bd->avail_exprs, insert);\n \t\t}\n \t    }\n \t}\n@@ -1808,8 +1802,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t\t\t\t\t  op1, integer_one_node)));\n \n \t  result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t     &bd->avail_exprs,\n-\t\t\t\t\t\t     ann, insert);\n+\t\t\t\t\t\t     &bd->avail_exprs, insert);\n \t}\n     }\n \n@@ -1880,8 +1873,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \t    t = op;\n \n \t  result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t     &bd->avail_exprs,\n-\t\t\t\t\t\t     ann, insert);\n+\t\t\t\t\t\t     &bd->avail_exprs, insert);\n \t}\n     }\n \n@@ -1893,8 +1885,7 @@ simplify_rhs_and_lookup_avail_expr (struct dom_walk_data *walk_data,\n \n       if (t)\n         result = update_rhs_and_lookup_avail_expr (stmt, t,\n-\t\t\t\t\t\t   &bd->avail_exprs,\n-\t\t\t\t\t\t   ann, insert);\n+\t\t\t\t\t\t   &bd->avail_exprs, insert);\n     }\n \n   return result;\n@@ -2001,7 +1992,11 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n \t\t  /* Update the statement to use the new equivalent\n \t\t     condition.  */\n \t\t  COND_EXPR_COND (stmt) = new_cond;\n-\t\t  ann->modified = 1;\n+\n+\t\t  /* If this is not a real stmt, ann will be NULL and we\n+\t\t     avoid processing the operands.  */\n+\t\t  if (ann)\n+\t\t    modify_stmt (stmt);\n \n \t\t  /* Lookup the condition and return its known value if it\n \t\t     exists.  */\n@@ -2197,7 +2192,6 @@ simplify_cond_and_lookup_avail_expr (tree stmt,\n static tree\n simplify_switch_and_lookup_avail_expr (tree stmt,\n \t\t\t\t       varray_type *block_avail_exprs_p,\n-\t\t\t\t       stmt_ann_t ann,\n \t\t\t\t       int insert)\n {\n   tree cond = SWITCH_COND (stmt);\n@@ -2243,7 +2237,7 @@ simplify_switch_and_lookup_avail_expr (tree stmt,\n \t      if (!fail)\n \t\t{\n \t\t  SWITCH_COND (stmt) = def;\n-\t\t  ann->modified = 1;\n+\t\t  modify_stmt (stmt);\n \n \t\t  return lookup_avail_expr (stmt, block_avail_exprs_p, insert);\n \t\t}\n@@ -2404,7 +2398,6 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n   if (! cached_lhs && TREE_CODE (stmt) == MODIFY_EXPR)\n     cached_lhs = simplify_rhs_and_lookup_avail_expr (walk_data,\n \t\t\t\t\t\t     stmt,\n-\t\t\t\t\t\t     ann,\n \t\t\t\t\t\t     insert);\n   /* Similarly if this is a COND_EXPR and we did not find its\n      expression in the hash table, simplify the condition and\n@@ -2418,7 +2411,6 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n   else if (!cached_lhs && TREE_CODE (stmt) == SWITCH_EXPR)\n     cached_lhs = simplify_switch_and_lookup_avail_expr (stmt,\n \t\t\t\t\t\t        &bd->avail_exprs,\n-\t\t\t\t\t\t        ann,\n \t\t\t\t\t\t        insert);\n \n   opt_stats.num_exprs_considered++;\n@@ -2465,7 +2457,7 @@ eliminate_redundant_computations (struct dom_walk_data *walk_data,\n \tretval = true;\n \n       propagate_tree_value (expr_p, cached_lhs);\n-      ann->modified = 1;\n+      modify_stmt (stmt);\n     }\n   return retval;\n }\n@@ -2642,7 +2634,7 @@ record_equivalences_from_stmt (tree stmt,\n    CONST_AND_COPIES.  */\n \n static bool\n-cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n+cprop_operand (tree stmt, use_operand_p op_p, varray_type const_and_copies)\n {\n   bool may_have_exposed_new_symbols = false;\n   tree val;\n@@ -2721,7 +2713,7 @@ cprop_operand (stmt_ann_t ann, use_operand_p op_p, varray_type const_and_copies)\n       /* And note that we modified this statement.  This is now\n \t safe, even if we changed virtual operands since we will\n \t rescan the statement and rewrite its operands again.  */\n-      ann->modified = 1;\n+      modify_stmt (stmt);\n     }\n   return may_have_exposed_new_symbols;\n }\n@@ -2749,7 +2741,7 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n       use_operand_p op_p = USE_OP_PTR (uses, i);\n       if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n+\t  |= cprop_operand (stmt, op_p, const_and_copies);\n     }\n \n   vuses = VUSE_OPS (ann);\n@@ -2759,7 +2751,7 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n       use_operand_p op_p = VUSE_OP_PTR (vuses, i);\n       if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n+\t  |= cprop_operand (stmt, op_p, const_and_copies);\n     }\n \n   v_may_defs = V_MAY_DEF_OPS (ann);\n@@ -2769,7 +2761,7 @@ cprop_into_stmt (tree stmt, varray_type const_and_copies)\n       use_operand_p op_p = V_MAY_DEF_OP_PTR (v_may_defs, i);\n       if (TREE_CODE (USE_FROM_PTR (op_p)) == SSA_NAME)\n \tmay_have_exposed_new_symbols\n-\t  |= cprop_operand (ann, op_p, const_and_copies);\n+\t  |= cprop_operand (stmt, op_p, const_and_copies);\n     }\n   return may_have_exposed_new_symbols;\n }\n@@ -2936,7 +2928,6 @@ optimize_stmt (struct dom_walk_data *walk_data, basic_block bb,\n static tree\n update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs, \n \t\t\t\t  varray_type *block_avail_exprs_p,\n-\t\t\t\t  stmt_ann_t ann,\n \t\t\t\t  bool insert)\n {\n   tree cached_lhs = NULL;\n@@ -2982,7 +2973,7 @@ update_rhs_and_lookup_avail_expr (tree stmt, tree new_rhs,\n \n   /* And make sure we record the fact that we modified this\n      statement.  */\n-  ann->modified = 1;\n+  modify_stmt (stmt);\n \n   return cached_lhs;\n }"}, {"sha": "3d2d1c6a7a9933e655fe4e985ce21eecbbe17a1b", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -1007,8 +1007,7 @@ schedule_sm (struct loop *loop, edge *exits, unsigned n_exits, tree ref,\n \n   /* Emit the load & stores.  */\n   load = build (MODIFY_EXPR, void_type_node, tmp_var, ref);\n-  modify_stmt (load);\n-  stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n+  get_stmt_ann (load)->common.aux = xcalloc (1, sizeof (struct lim_aux_data));\n   LIM_DATA (load)->max_loop = loop;\n   LIM_DATA (load)->tgt_loop = loop;\n "}, {"sha": "eb6f9676617370d7ae1222f0c426b94d93dbda7b", "filename": "gcc/tree-ssa.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/68b9f53b865b6b0afdafa8f24ca83ec9c94bb780/gcc%2Ftree-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa.c?ref=68b9f53b865b6b0afdafa8f24ca83ec9c94bb780", "patch": "@@ -925,14 +925,14 @@ propagate_into_addr (tree stmt, tree var, tree *x, tree repl)\n       || TREE_OPERAND (*x, 0) != var)\n     return;\n \n-  modify_stmt (stmt);\n   if (TREE_TYPE (*x) == TREE_TYPE (addr_var))\n     {\n       *x = addr_var;\n       mark_new_vars_to_rename (stmt, vars_to_rename);\n       return;\n     }\n \n+\n   /* Frontends sometimes produce expressions like *&a instead of a[0].\n      Create a temporary variable to handle this case.  */\n   ass_stmt = build2 (MODIFY_EXPR, void_type_node, NULL_TREE, repl);"}]}