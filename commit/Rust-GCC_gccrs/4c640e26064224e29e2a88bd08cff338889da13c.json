{"sha": "4c640e26064224e29e2a88bd08cff338889da13c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGM2NDBlMjYwNjQyMjRlMjllMmE4OGJkMDhjZmYzMzg4ODlkYTEzYw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2016-10-16T20:13:32Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2016-10-16T20:13:32Z"}, "message": "re PR ada/37139 (DEP prevents using Ada tasking)\n\n\tPR ada/37139\n\tPR ada/67205\n\t* common.opt (-ftrampolines): New option.\n\t* doc/invoke.texi (Code Gen Options): Document it.\n\t* doc/tm.texi.in (Trampolines): Add TARGET_CUSTOM_FUNCTION_DESCRIPTORS.\n\t* doc/tm.texi: Regenerate.\n\t* builtins.def: Add init_descriptor and adjust_descriptor.\n\t* builtins.c (expand_builtin_init_trampoline): Do not issue a warning\n\ton platforms with descriptors.\n\t(expand_builtin_init_descriptor): New function.\n\t(expand_builtin_adjust_descriptor): Likewise.\n\t(expand_builtin) <BUILT_IN_INIT_DESCRIPTOR>: New case.\n\t<BUILT_IN_ADJUST_DESCRIPTOR>: Likewise.\n\t* calls.c (prepare_call_address): Remove SIBCALLP parameter and add\n\tFLAGS parameter.  Deal with indirect calls by descriptor and adjust.\n\tSet STATIC_CHAIN_REG_P on the static chain register, if any.\n\t(call_expr_flags): Set ECF_BY_DESCRIPTOR for calls by descriptor.\n\t(expand_call): Likewise.  Move around call to prepare_call_address\n\tand pass all flags to it.\n\t* cfgexpand.c (expand_call_stmt): Reinstate CALL_EXPR_BY_DESCRIPTOR.\n\t* gimple.h (enum gf_mask): New GF_CALL_BY_DESCRIPTOR value.\n\t(gimple_call_set_by_descriptor): New setter.\n\t(gimple_call_by_descriptor_p): New getter.\n\t* gimple.c (gimple_build_call_from_tree): SetCALL_EXPR_BY_DESCRIPTOR.\n\t(gimple_call_flags): Deal with GF_CALL_BY_DESCRIPTOR.\n\t* langhooks.h (struct lang_hooks): Add custom_function_descriptors.\n\t* langhooks-def.h (LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS): Define.\n\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS.\n\t* rtl.h (STATIC_CHAIN_REG_P): New macro.\n\t* rtlanal.c (find_first_parameter_load): Skip static chain registers.\n\t* target.def (custom_function_descriptors): New POD hook.\n\t* tree.h (FUNC_ADDR_BY_DESCRIPTOR): New flag on ADDR_EXPR.\n\t(CALL_EXPR_BY_DESCRIPTOR): New flag on CALL_EXPR.\n\t* tree-core.h (ECF_BY_DESCRIPTOR): New mask.\n\tDocument FUNC_ADDR_BY_DESCRIPTOR and CALL_EXPR_BY_DESCRIPTOR.\n\t* tree.c (make_node_stat) <tcc_declaration>: Use FUNCTION_ALIGNMENT.\n\t(build_common_builtin_nodes): Initialize init_descriptor and\n\tadjust_descriptor.\n\t* tree-nested.c: Include target.h.\n\t(struct nesting_info): Add 'any_descr_created' field.\n\t(get_descriptor_type): New function.\n\t(lookup_element_for_decl): New function extracted from...\n\t(create_field_for_decl): Likewise.\n\t(lookup_tramp_for_decl): ...here.  Adjust.\n\t(lookup_descr_for_decl): New function.\n\t(convert_tramp_reference_op): Deal with descriptors.\n\t(build_init_call_stmt): New function extracted from...\n\t(finalize_nesting_tree_1): ...here.  Adjust and deal withdescriptors.\n\t* defaults.h (FUNCTION_ALIGNMENT): Define.\n\t(TRAMPOLINE_ALIGNMENT): Set to above instead of FUNCTION_BOUNDARY.\n\t* config/i386/i386.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Define.\n\t* config/ia64/ia64.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Likewise.\n\t* config/rs6000/rs6000.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS):Likewise.\n\t* config/sparc/sparc.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Likewise.\nada/\n\t* gcc-interface/misc.c (LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS):Define.\n\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Access>: Deal with\n\ta zero TARGET_CUSTOM_FUNCTION_DESCRIPTORS specially for Code_Address.\n\tOtherwise, if TARGET_CUSTOM_FUNCTION_DESCRIPTORS is positive, set\n\tFUNC_ADDR_BY_DESCRIPTOR for 'Access/'Unrestricted_Access of nested\n\tsubprograms if the type can use an internal representation.\n\t(call_to_gnu): Likewise, but set CALL_EXPR_BY_DESCRIPTOR on indirect\n\tcalls if the type can use an internal representation.\n\nFrom-SVN: r241222", "tree": {"sha": "4b953aabbc75af0eb299014b434f26373a999694", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4b953aabbc75af0eb299014b434f26373a999694"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c640e26064224e29e2a88bd08cff338889da13c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c640e26064224e29e2a88bd08cff338889da13c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c640e26064224e29e2a88bd08cff338889da13c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c640e26064224e29e2a88bd08cff338889da13c/comments", "author": null, "committer": null, "parents": [{"sha": "855db69891d4f2a61a16f219d78daf8cd56e3058", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/855db69891d4f2a61a16f219d78daf8cd56e3058", "html_url": "https://github.com/Rust-GCC/gccrs/commit/855db69891d4f2a61a16f219d78daf8cd56e3058"}], "stats": {"total": 653, "additions": 603, "deletions": 50}, "files": [{"sha": "7874e063d2f6535674da46de7e4795e9694b4ee6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1,3 +1,60 @@\n+2016-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\tPR ada/37139\n+\tPR ada/67205\n+\t* common.opt (-ftrampolines): New option.\n+\t* doc/invoke.texi (Code Gen Options): Document it.\n+\t* doc/tm.texi.in (Trampolines): Add TARGET_CUSTOM_FUNCTION_DESCRIPTORS.\n+\t* doc/tm.texi: Regenerate.\n+\t* builtins.def: Add init_descriptor and adjust_descriptor.\n+\t* builtins.c (expand_builtin_init_trampoline): Do not issue a warning\n+\ton platforms with descriptors.\n+\t(expand_builtin_init_descriptor): New function.\n+\t(expand_builtin_adjust_descriptor): Likewise.\n+\t(expand_builtin) <BUILT_IN_INIT_DESCRIPTOR>: New case.\n+\t<BUILT_IN_ADJUST_DESCRIPTOR>: Likewise.\n+\t* calls.c (prepare_call_address): Remove SIBCALLP parameter and add\n+\tFLAGS parameter.  Deal with indirect calls by descriptor and adjust.\n+\tSet STATIC_CHAIN_REG_P on the static chain register, if any.\n+\t(call_expr_flags): Set ECF_BY_DESCRIPTOR for calls by descriptor.\n+\t(expand_call): Likewise.  Move around call to prepare_call_address\n+\tand pass all flags to it.\n+\t* cfgexpand.c (expand_call_stmt): Reinstate CALL_EXPR_BY_DESCRIPTOR.\n+\t* gimple.h (enum gf_mask): New GF_CALL_BY_DESCRIPTOR value.\n+\t(gimple_call_set_by_descriptor): New setter.\n+\t(gimple_call_by_descriptor_p): New getter.\n+\t* gimple.c (gimple_build_call_from_tree): SetCALL_EXPR_BY_DESCRIPTOR.\n+\t(gimple_call_flags): Deal with GF_CALL_BY_DESCRIPTOR.\n+\t* langhooks.h (struct lang_hooks): Add custom_function_descriptors.\n+\t* langhooks-def.h (LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS): Define.\n+\t(LANG_HOOKS_INITIALIZER): Add LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS.\n+\t* rtl.h (STATIC_CHAIN_REG_P): New macro.\n+\t* rtlanal.c (find_first_parameter_load): Skip static chain registers.\n+\t* target.def (custom_function_descriptors): New POD hook.\n+\t* tree.h (FUNC_ADDR_BY_DESCRIPTOR): New flag on ADDR_EXPR.\n+\t(CALL_EXPR_BY_DESCRIPTOR): New flag on CALL_EXPR.\n+\t* tree-core.h (ECF_BY_DESCRIPTOR): New mask.\n+\tDocument FUNC_ADDR_BY_DESCRIPTOR and CALL_EXPR_BY_DESCRIPTOR.\n+\t* tree.c (make_node_stat) <tcc_declaration>: Use FUNCTION_ALIGNMENT.\n+\t(build_common_builtin_nodes): Initialize init_descriptor and\n+\tadjust_descriptor.\n+\t* tree-nested.c: Include target.h.\n+\t(struct nesting_info): Add 'any_descr_created' field.\n+\t(get_descriptor_type): New function.\n+\t(lookup_element_for_decl): New function extracted from...\n+\t(create_field_for_decl): Likewise.\n+\t(lookup_tramp_for_decl): ...here.  Adjust.\n+\t(lookup_descr_for_decl): New function.\n+\t(convert_tramp_reference_op): Deal with descriptors.\n+\t(build_init_call_stmt): New function extracted from...\n+\t(finalize_nesting_tree_1): ...here.  Adjust and deal withdescriptors.\n+\t* defaults.h (FUNCTION_ALIGNMENT): Define.\n+\t(TRAMPOLINE_ALIGNMENT): Set to above instead of FUNCTION_BOUNDARY.\n+\t* config/i386/i386.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Define.\n+\t* config/ia64/ia64.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Likewise.\n+\t* config/rs6000/rs6000.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS):Likewise.\n+\t* config/sparc/sparc.h (TARGET_CUSTOM_FUNCTION_DESCRIPTORS): Likewise.\n+\n 2016-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* config/sparc/sparc.c (sparc_expand_vector_init): Only accept literal"}, {"sha": "cd133895ccd8cb0f41f1a204ad6ce72eeeccc4fb", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1,3 +1,14 @@\n+2016-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/misc.c (LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS):Define.\n+\t* gcc-interface/trans.c (Attribute_to_gnu) <Attr_Access>: Deal with\n+\ta zero TARGET_CUSTOM_FUNCTION_DESCRIPTORS specially for Code_Address.\n+\tOtherwise, if TARGET_CUSTOM_FUNCTION_DESCRIPTORS is positive, set\n+\tFUNC_ADDR_BY_DESCRIPTOR for 'Access/'Unrestricted_Access of nested\n+\tsubprograms if the type can use an internal representation.\n+\t(call_to_gnu): Likewise, but set CALL_EXPR_BY_DESCRIPTOR on indirect\n+\tcalls if the type can use an internal representation.\n+\n 2016-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* system-aix.ads (Always_Compatible_Rep): Change to False."}, {"sha": "76ad06c6e8d2787d04789d505ca7c724c8cdf221", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1415,6 +1415,8 @@ get_lang_specific (tree node)\n #define LANG_HOOKS_EH_PERSONALITY\tgnat_eh_personality\n #undef  LANG_HOOKS_DEEP_UNSHARING\n #define LANG_HOOKS_DEEP_UNSHARING\ttrue\n+#undef  LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS\n+#define LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS true\n \n struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n "}, {"sha": "e5047f0de460715b5b6b2634f48a556642435a1d", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 35, "deletions": 5, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1702,6 +1702,17 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \n \t  if (TREE_CODE (gnu_expr) == ADDR_EXPR)\n \t    TREE_NO_TRAMPOLINE (gnu_expr) = TREE_CONSTANT (gnu_expr) = 1;\n+\n+\t  /* On targets for which function symbols denote a descriptor, the\n+\t     code address is stored within the first slot of the descriptor\n+\t     so we do an additional dereference:\n+\t       result = *((result_type *) result)\n+\t     where we expect result to be of some pointer type already.  */\n+\t  if (targetm.calls.custom_function_descriptors == 0)\n+\t    gnu_result\n+\t      = build_unary_op (INDIRECT_REF, NULL_TREE,\n+\t\t\t\tconvert (build_pointer_type (gnu_result_type),\n+\t\t\t\t\t gnu_result));\n \t}\n \n       /* For 'Access, issue an error message if the prefix is a C++ method\n@@ -1728,10 +1739,19 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t      /* Also check the inlining status.  */\n \t      check_inlining_for_nested_subprog (TREE_OPERAND (gnu_expr, 0));\n \n-\t      /* Check that we're not violating the No_Implicit_Dynamic_Code\n-\t\t restriction.  Be conservative if we don't know anything\n-\t\t about the trampoline strategy for the target.  */\n-\t      Check_Implicit_Dynamic_Code_Allowed (gnat_node);\n+\t      /* Moreover, for 'Access or 'Unrestricted_Access with non-\n+\t\t foreign-compatible representation, mark the ADDR_EXPR so\n+\t\t that we can build a descriptor instead of a trampoline.  */\n+\t      if ((attribute == Attr_Access\n+\t\t   || attribute == Attr_Unrestricted_Access)\n+\t\t  && targetm.calls.custom_function_descriptors > 0\n+\t\t  && Can_Use_Internal_Rep (Etype (gnat_node)))\n+\t\tFUNC_ADDR_BY_DESCRIPTOR (gnu_expr) = 1;\n+\n+\t      /* Otherwise, we need to check that we are not violating the\n+\t\t No_Implicit_Dynamic_Code restriction.  */\n+\t      else if (targetm.calls.custom_function_descriptors != 0)\n+\t        Check_Implicit_Dynamic_Code_Allowed (gnat_node);\n \t    }\n \t}\n       break;\n@@ -4228,6 +4248,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n   tree gnu_after_list = NULL_TREE;\n   tree gnu_retval = NULL_TREE;\n   tree gnu_call, gnu_result;\n+  bool by_descriptor = false;\n   bool went_into_elab_proc = false;\n   bool pushed_binding_level = false;\n   Entity_Id gnat_formal;\n@@ -4267,7 +4288,15 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n      type the access type is pointing to.  Otherwise, get the formals from the\n      entity being called.  */\n   if (Nkind (Name (gnat_node)) == N_Explicit_Dereference)\n-    gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n+    {\n+      gnat_formal = First_Formal_With_Extras (Etype (Name (gnat_node)));\n+\n+      /* If the access type doesn't require foreign-compatible representation,\n+\t be prepared for descriptors.  */\n+      if (targetm.calls.custom_function_descriptors > 0\n+\t  && Can_Use_Internal_Rep (Etype (Prefix (Name (gnat_node)))))\n+\tby_descriptor = true;\n+    }\n   else if (Nkind (Name (gnat_node)) == N_Attribute_Reference)\n     /* Assume here that this must be 'Elab_Body or 'Elab_Spec.  */\n     gnat_formal = Empty;\n@@ -4670,6 +4699,7 @@ Call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target,\n \n   gnu_call\n     = build_call_vec (gnu_result_type, gnu_subprog_addr, gnu_actual_vec);\n+  CALL_EXPR_BY_DESCRIPTOR (gnu_call) = by_descriptor;\n   set_expr_location_from_node (gnu_call, gnat_node);\n \n   /* If we have created a temporary for the return value, initialize it.  */"}, {"sha": "ff377732b9fbd16d080798aef4d0c20c2fe673be", "filename": "gcc/builtins.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -4608,8 +4608,9 @@ expand_builtin_init_trampoline (tree exp, bool onstack)\n     {\n       trampolines_created = 1;\n \n-      warning_at (DECL_SOURCE_LOCATION (t_func), OPT_Wtrampolines,\n-\t\t  \"trampoline generated for nested function %qD\", t_func);\n+      if (targetm.calls.custom_function_descriptors != 0)\n+\twarning_at (DECL_SOURCE_LOCATION (t_func), OPT_Wtrampolines,\n+\t\t    \"trampoline generated for nested function %qD\", t_func);\n     }\n \n   return const0_rtx;\n@@ -4631,6 +4632,58 @@ expand_builtin_adjust_trampoline (tree exp)\n   return tramp;\n }\n \n+/* Expand a call to the builtin descriptor initialization routine.\n+   A descriptor is made up of a couple of pointers to the static\n+   chain and the code entry in this order.  */\n+\n+static rtx\n+expand_builtin_init_descriptor (tree exp)\n+{\n+  tree t_descr, t_func, t_chain;\n+  rtx m_descr, r_descr, r_func, r_chain;\n+\n+  if (!validate_arglist (exp, POINTER_TYPE, POINTER_TYPE, POINTER_TYPE,\n+\t\t\t VOID_TYPE))\n+    return NULL_RTX;\n+\n+  t_descr = CALL_EXPR_ARG (exp, 0);\n+  t_func = CALL_EXPR_ARG (exp, 1);\n+  t_chain = CALL_EXPR_ARG (exp, 2);\n+\n+  r_descr = expand_normal (t_descr);\n+  m_descr = gen_rtx_MEM (BLKmode, r_descr);\n+  MEM_NOTRAP_P (m_descr) = 1;\n+\n+  r_func = expand_normal (t_func);\n+  r_chain = expand_normal (t_chain);\n+\n+  /* Generate insns to initialize the descriptor.  */\n+  emit_move_insn (adjust_address_nv (m_descr, ptr_mode, 0), r_chain);\n+  emit_move_insn (adjust_address_nv (m_descr, ptr_mode,\n+\t\t\t\t     POINTER_SIZE / BITS_PER_UNIT), r_func);\n+\n+  return const0_rtx;\n+}\n+\n+/* Expand a call to the builtin descriptor adjustment routine.  */\n+\n+static rtx\n+expand_builtin_adjust_descriptor (tree exp)\n+{\n+  rtx tramp;\n+\n+  if (!validate_arglist (exp, POINTER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tramp = expand_normal (CALL_EXPR_ARG (exp, 0));\n+\n+  /* Unalign the descriptor to allow runtime identification.  */\n+  tramp = plus_constant (ptr_mode, tramp,\n+\t\t\t targetm.calls.custom_function_descriptors);\n+\n+  return force_operand (tramp, NULL_RTX);\n+}\n+\n /* Expand the call EXP to the built-in signbit, signbitf or signbitl\n    function.  The function first checks whether the back end provides\n    an insn to implement signbit for the respective mode.  If not, it\n@@ -6330,6 +6383,11 @@ expand_builtin (tree exp, rtx target, rtx subtarget, machine_mode mode,\n     case BUILT_IN_ADJUST_TRAMPOLINE:\n       return expand_builtin_adjust_trampoline (exp);\n \n+    case BUILT_IN_INIT_DESCRIPTOR:\n+      return expand_builtin_init_descriptor (exp);\n+    case BUILT_IN_ADJUST_DESCRIPTOR:\n+      return expand_builtin_adjust_descriptor (exp);\n+\n     case BUILT_IN_FORK:\n     case BUILT_IN_EXECL:\n     case BUILT_IN_EXECV:"}, {"sha": "219feebd3aebefbd079bf37cc801453cd1965e00", "filename": "gcc/builtins.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -883,6 +883,8 @@ DEF_C99_BUILTIN        (BUILT_IN__EXIT2, \"_Exit\", BT_FN_VOID_INT, ATTR_NORETURN_\n DEF_BUILTIN_STUB (BUILT_IN_INIT_TRAMPOLINE, \"__builtin_init_trampoline\")\n DEF_BUILTIN_STUB (BUILT_IN_INIT_HEAP_TRAMPOLINE, \"__builtin_init_heap_trampoline\")\n DEF_BUILTIN_STUB (BUILT_IN_ADJUST_TRAMPOLINE, \"__builtin_adjust_trampoline\")\n+DEF_BUILTIN_STUB (BUILT_IN_INIT_DESCRIPTOR, \"__builtin_init_descriptor\")\n+DEF_BUILTIN_STUB (BUILT_IN_ADJUST_DESCRIPTOR, \"__builtin_adjust_descriptor\")\n DEF_BUILTIN_STUB (BUILT_IN_NONLOCAL_GOTO, \"__builtin_nonlocal_goto\")\n \n /* Implementing __builtin_setjmp.  */"}, {"sha": "c916e0725dc0de6f2503442cc95fed47c1bdfca2", "filename": "gcc/calls.c", "status": "modified", "additions": 85, "deletions": 16, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -184,17 +184,76 @@ static void restore_fixed_argument_area (rtx, rtx, int, int);\n \n rtx\n prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n-\t\t      rtx *call_fusage, int reg_parm_seen, int sibcallp)\n+\t\t      rtx *call_fusage, int reg_parm_seen, int flags)\n {\n   /* Make a valid memory address and copy constants through pseudo-regs,\n      but not for a constant address if -fno-function-cse.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n-    /* If we are using registers for parameters, force the\n-       function address into a register now.  */\n-    funexp = ((reg_parm_seen\n-\t       && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))\n-\t      ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n-\t      : memory_address (FUNCTION_MODE, funexp));\n+    {\n+      /* If it's an indirect call by descriptor, generate code to perform\n+\t runtime identification of the pointer and load the descriptor.  */\n+      if ((flags & ECF_BY_DESCRIPTOR) && !flag_trampolines)\n+\t{\n+\t  const int bit_val = targetm.calls.custom_function_descriptors;\n+\t  rtx call_lab = gen_label_rtx ();\n+\n+\t  gcc_assert (fndecl_or_type && TYPE_P (fndecl_or_type));\n+\t  fndecl_or_type\n+\t    = build_decl (UNKNOWN_LOCATION, FUNCTION_DECL, NULL_TREE,\n+\t\t\t  fndecl_or_type);\n+\t  DECL_STATIC_CHAIN (fndecl_or_type) = 1;\n+\t  rtx chain = targetm.calls.static_chain (fndecl_or_type, false);\n+\n+\t  /* Avoid long live ranges around function calls.  */\n+\t  funexp = copy_to_mode_reg (Pmode, funexp);\n+\n+\t  if (REG_P (chain))\n+\t    emit_insn (gen_rtx_CLOBBER (VOIDmode, chain));\n+\n+\t  /* Emit the runtime identification pattern.  */\n+\t  rtx mask = gen_rtx_AND (Pmode, funexp, GEN_INT (bit_val));\n+\t  emit_cmp_and_jump_insns (mask, const0_rtx, EQ, NULL_RTX, Pmode, 1,\n+\t\t\t\t   call_lab);\n+\n+\t  /* Statically predict the branch to very likely taken.  */\n+\t  rtx_insn *insn = get_last_insn ();\n+\t  if (JUMP_P (insn))\n+\t    predict_insn_def (insn, PRED_BUILTIN_EXPECT, TAKEN);\n+\n+\t  /* Load the descriptor.  */\n+\t  rtx mem = gen_rtx_MEM (ptr_mode,\n+\t\t\t\t plus_constant (Pmode, funexp, - bit_val));\n+\t  MEM_NOTRAP_P (mem) = 1;\n+\t  mem = convert_memory_address (Pmode, mem);\n+\t  emit_move_insn (chain, mem);\n+\n+\t  mem = gen_rtx_MEM (ptr_mode,\n+\t\t\t     plus_constant (Pmode, funexp,\n+\t\t\t\t\t    POINTER_SIZE / BITS_PER_UNIT\n+\t\t\t\t\t      - bit_val));\n+\t  MEM_NOTRAP_P (mem) = 1;\n+\t  mem = convert_memory_address (Pmode, mem);\n+\t  emit_move_insn (funexp, mem);\n+\n+\t  emit_label (call_lab);\n+\n+\t  if (REG_P (chain))\n+\t    {\n+\t      use_reg (call_fusage, chain);\n+\t      STATIC_CHAIN_REG_P (chain) = 1;\n+\t    }\n+\n+\t  /* Make sure we're not going to be overwritten below.  */\n+\t  gcc_assert (!static_chain_value);\n+\t}\n+\n+      /* If we are using registers for parameters, force the\n+\t function address into a register now.  */\n+      funexp = ((reg_parm_seen\n+\t\t && targetm.small_register_classes_for_mode_p (FUNCTION_MODE))\n+\t\t ? force_not_mem (memory_address (FUNCTION_MODE, funexp))\n+\t\t : memory_address (FUNCTION_MODE, funexp));\n+    }\n   else\n     {\n       /* funexp could be a SYMBOL_REF represents a function pointer which is\n@@ -203,7 +262,7 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n       if (GET_MODE (funexp) != Pmode)\n \tfunexp = convert_memory_address (Pmode, funexp);\n \n-      if (! sibcallp)\n+      if (!(flags & ECF_SIBCALL))\n \t{\n \t  if (!NO_FUNCTION_CSE && optimize && ! flag_no_function_cse)\n \t    funexp = force_reg (Pmode, funexp);\n@@ -221,7 +280,10 @@ prepare_call_address (tree fndecl_or_type, rtx funexp, rtx static_chain_value,\n \n       emit_move_insn (chain, static_chain_value);\n       if (REG_P (chain))\n-\tuse_reg (call_fusage, chain);\n+\t{\n+\t  use_reg (call_fusage, chain);\n+\t  STATIC_CHAIN_REG_P (chain) = 1;\n+\t}\n     }\n \n   return funexp;\n@@ -807,11 +869,13 @@ call_expr_flags (const_tree t)\n     flags = internal_fn_flags (CALL_EXPR_IFN (t));\n   else\n     {\n-      t = TREE_TYPE (CALL_EXPR_FN (t));\n-      if (t && TREE_CODE (t) == POINTER_TYPE)\n-\tflags = flags_from_decl_or_type (TREE_TYPE (t));\n+      tree type = TREE_TYPE (CALL_EXPR_FN (t));\n+      if (type && TREE_CODE (type) == POINTER_TYPE)\n+\tflags = flags_from_decl_or_type (TREE_TYPE (type));\n       else\n \tflags = 0;\n+      if (CALL_EXPR_BY_DESCRIPTOR (t))\n+\tflags |= ECF_BY_DESCRIPTOR;\n     }\n \n   return flags;\n@@ -2648,6 +2712,8 @@ expand_call (tree exp, rtx target, int ignore)\n     {\n       fntype = TREE_TYPE (TREE_TYPE (addr));\n       flags |= flags_from_decl_or_type (fntype);\n+      if (CALL_EXPR_BY_DESCRIPTOR (exp))\n+\tflags |= ECF_BY_DESCRIPTOR;\n     }\n   rettype = TREE_TYPE (exp);\n \n@@ -3359,6 +3425,13 @@ expand_call (tree exp, rtx target, int ignore)\n       if (STRICT_ALIGNMENT)\n \tstore_unaligned_arguments_into_pseudos (args, num_actuals);\n \n+      /* Prepare the address of the call.  This must be done before any\n+\t register parameters is loaded for find_first_parameter_load to\n+\t work properly in the presence of descriptors.  */\n+      funexp = prepare_call_address (fndecl ? fndecl : fntype, funexp,\n+\t\t\t\t     static_chain_value, &call_fusage,\n+\t\t\t\t     reg_parm_seen, flags);\n+\n       /* Now store any partially-in-registers parm.\n \t This is the last place a block-move can happen.  */\n       if (reg_parm_seen)\n@@ -3469,10 +3542,6 @@ expand_call (tree exp, rtx target, int ignore)\n \t}\n \n       after_args = get_last_insn ();\n-      funexp = prepare_call_address (fndecl ? fndecl : fntype, funexp,\n-\t\t\t\t     static_chain_value, &call_fusage,\n-\t\t\t\t     reg_parm_seen, pass == 0);\n-\n       load_register_parameters (args, num_actuals, &call_fusage, flags,\n \t\t\t\tpass == 0, &sibcall_failure);\n "}, {"sha": "1fce43017efe2b990dd4d79ad0b46863e792dc7a", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -2642,6 +2642,7 @@ expand_call_stmt (gcall *stmt)\n   else\n     CALL_FROM_THUNK_P (exp) = gimple_call_from_thunk_p (stmt);\n   CALL_EXPR_VA_ARG_PACK (exp) = gimple_call_va_arg_pack_p (stmt);\n+  CALL_EXPR_BY_DESCRIPTOR (exp) = gimple_call_by_descriptor_p (stmt);\n   SET_EXPR_LOCATION (exp, gimple_location (stmt));\n   CALL_WITH_BOUNDS_P (exp) = gimple_call_with_bounds_p (stmt);\n "}, {"sha": "6f24f568d313bbf8f35e8809639ba4d976b57765", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -2350,6 +2350,11 @@ ftracer\n Common Report Var(flag_tracer) Optimization\n Perform superblock formation via tail duplication.\n \n+ftrampolines\n+Common Report Var(flag_trampolines) Init(0)\n+For targets that normally need trampolines for nested functions, always\n+generate them instead of using descriptors.\n+\n ; Zero means that floating-point math operations cannot generate a\n ; (user-visible) trap.  This is the case, for example, in nonstop\n ; IEEE 754 arithmetic."}, {"sha": "fe3735d01b99a8172dd96e4c2757e9616a6a080a", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -2666,6 +2666,9 @@ extern void debug_dispatch_window (int);\n \n #define TARGET_SUPPORTS_WIDE_INT 1\n \n+/* Use custom descriptors instead of trampolines when possible.  */\n+#define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1\n+\n /*\n Local variables:\n version-control: t"}, {"sha": "82971a4a0f505af49ee13425ad2e9f8cb762cd86", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1715,4 +1715,7 @@ struct GTY(()) machine_function\n /* Switch on code for querying unit reservations.  */\n #define CPU_UNITS_QUERY 1\n \n+/* IA-64 already uses descriptors for its standard calling sequence.  */\n+#define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 0\n+\n /* End of ia64.h */"}, {"sha": "f1c338eb771ec2cf727adcdcb5bc05b8409c8ab6", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -2922,6 +2922,9 @@ extern GTY(()) tree rs6000_builtin_decls[RS6000_BUILTIN_COUNT];\n \n #define TARGET_SUPPORTS_WIDE_INT 1\n \n+/* Use custom descriptors instead of trampolines if not AIX or ELFv1.  */\n+#define TARGET_CUSTOM_FUNCTION_DESCRIPTORS (DEFAULT_ABI != ABI_AIX)\n+\n #if (GCC_VERSION >= 3000)\n #pragma GCC poison TARGET_FLOAT128 OPTION_MASK_FLOAT128 MASK_FLOAT128\n #endif"}, {"sha": "108769ff893edeeb94ab3423adaa3ca9832c9c4d", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1813,3 +1813,6 @@ extern int sparc_indent_opcode;\n #define SPARC_LOW_FE_EXCEPT_VALUES 0\n \n #define TARGET_SUPPORTS_WIDE_INT 1\n+\n+/* Use custom descriptors instead of trampolines when possible.  */\n+#define TARGET_CUSTOM_FUNCTION_DESCRIPTORS 1"}, {"sha": "74d41e72e0fd385451ecfeffa00ed7865c1a79a9", "filename": "gcc/defaults.h", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1048,9 +1048,18 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define CASE_VECTOR_PC_RELATIVE 0\n #endif\n \n+/* Force minimum alignment to be able to use the least significant bits\n+   for distinguishing descriptor addresses from code addresses.  */\n+#define FUNCTION_ALIGNMENT(ALIGN)\t\t\t\t\t\\\n+  (lang_hooks.custom_function_descriptors\t\t\t\t\\\n+   && targetm.calls.custom_function_descriptors > 0\t\t\t\\\n+   ? MAX ((ALIGN),\t\t\t\t\t\t\\\n+\t  2 * targetm.calls.custom_function_descriptors * BITS_PER_UNIT)\\\n+   : (ALIGN))\n+\n /* Assume that trampolines need function alignment.  */\n #ifndef TRAMPOLINE_ALIGNMENT\n-#define TRAMPOLINE_ALIGNMENT FUNCTION_BOUNDARY\n+#define TRAMPOLINE_ALIGNMENT FUNCTION_ALIGNMENT (FUNCTION_BOUNDARY)\n #endif\n \n /* Register mappings for target machines without register windows.  */"}, {"sha": "795ad1b63a914de50113cd83a1eb7094306f0634", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -502,7 +502,7 @@ Objective-C and Objective-C++ Dialects}.\n -fverbose-asm  -fpack-struct[=@var{n}]  @gol\n -fleading-underscore  -ftls-model=@var{model} @gol\n -fstack-reuse=@var{reuse_level} @gol\n--ftrapv  -fwrapv @gol\n+-ftrampolines  -ftrapv  -fwrapv @gol\n -fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]} @gol\n -fstrict-volatile-bitfields -fsync-libcalls}\n \n@@ -12067,6 +12067,28 @@ unit, or if @option{-fpic} is not given on the command line.\n The default without @option{-fpic} is @samp{initial-exec}; with\n @option{-fpic} the default is @samp{global-dynamic}.\n \n+@item -ftrampolines\n+@opindex ftrampolines\n+For targets that normally need trampolines for nested functions, always\n+generate them instead of using descriptors.  Otherwise, for targets that\n+do not need them, like for example HP-PA or IA-64, do nothing.\n+\n+A trampoline is a small piece of code that is created at run time on the\n+stack when the address of a nested function is taken, and is used to call\n+the nested function indirectly.  Therefore, it requires the stack to be\n+made executable in order for the program to work properly.\n+\n+@option{-fno-trampolines} is enabled by default on a language by language\n+basis to let the compiler avoid generating them, if it computes that this\n+is safe, and replace them with descriptors.  Descriptors are made up of data\n+only, but the generated code must be prepared to deal with them.  As of this\n+writing, @option{-fno-trampolines} is enabled by default only for Ada.\n+\n+Moreover, code compiled with @option{-ftrampolines} and code compiled with\n+@option{-fno-trampolines} are not binary compatible if nested functions are\n+present.  This option must therefore be used on a program-wide basis and be\n+manipulated with extreme care.\n+\n @item -fvisibility=@r{[}default@r{|}internal@r{|}hidden@r{|}protected@r{]}\n @opindex fvisibility\n Set the default ELF image symbol visibility to the specified option---all"}, {"sha": "29dc73b6764948866249d5931c843ecc1345524b", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -5245,6 +5245,24 @@ be returned; otherwise @var{addr} should be returned unchanged.\n If this hook is not defined, @var{addr} will be used for function calls.\n @end deftypefn\n \n+@deftypevr {Target Hook} int TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+This hook should be defined to a power of 2 if the target will benefit\n+from the use of custom descriptors for nested functions instead of the\n+standard trampolines.  Such descriptors are created at run time on the\n+stack and made up of data only, but they are non-standard so the generated\n+code must be prepared to deal with them.  This hook should be defined to 0\n+if the target uses function descriptors for its standard calling sequence,\n+like for example HP-PA or IA-64.  Using descriptors for nested functions\n+eliminates the need for trampolines that reside on the stack and require\n+it to be made executable.\n+\n+The value of the macro is used to parameterize the run-time identification\n+scheme implemented to distinguish descriptors from function addresses: it\n+gives the number of bytes by which their address is misaligned compared\n+with function addresses.  The value of 1 will generally work, unless it is\n+already reserved by the target for another purpose, like for example on ARM.\n+@end deftypevr\n+\n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location\n fails to clear the memory in the instruction cache, so when the program"}, {"sha": "efcd7416e4e922cc2af485990ccc7d31fa94db3b", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -3971,6 +3971,8 @@ is used for aligning trampolines.\n \n @hook TARGET_TRAMPOLINE_ADJUST_ADDRESS\n \n+@hook TARGET_CUSTOM_FUNCTION_DESCRIPTORS\n+\n Implementing trampolines is difficult on many machines because they have\n separate instruction and data caches.  Writing into a stack location\n fails to clear the memory in the instruction cache, so when the program"}, {"sha": "26e9322dcff85d748b5b385ae63196705e170a45", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -373,6 +373,7 @@ gimple_build_call_from_tree (tree t)\n     gimple_call_set_from_thunk (call, CALL_FROM_THUNK_P (t));\n   gimple_call_set_va_arg_pack (call, CALL_EXPR_VA_ARG_PACK (t));\n   gimple_call_set_nothrow (call, TREE_NOTHROW (t));\n+  gimple_call_set_by_descriptor (call, CALL_EXPR_BY_DESCRIPTOR (t));\n   gimple_set_no_warning (call, TREE_NO_WARNING (t));\n   gimple_call_set_with_bounds (call, CALL_WITH_BOUNDS_P (t));\n \n@@ -1386,6 +1387,9 @@ gimple_call_flags (const gimple *stmt)\n   if (stmt->subcode & GF_CALL_NOTHROW)\n     flags |= ECF_NOTHROW;\n \n+  if (stmt->subcode & GF_CALL_BY_DESCRIPTOR)\n+    flags |= ECF_BY_DESCRIPTOR;\n+\n   return flags;\n }\n "}, {"sha": "0eafada61b46039df0b1e981e4e91fcccc485d51", "filename": "gcc/gimple.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -146,6 +146,7 @@ enum gf_mask {\n     GF_CALL_CTRL_ALTERING       = 1 << 7,\n     GF_CALL_WITH_BOUNDS \t= 1 << 8,\n     GF_CALL_MUST_TAIL_CALL\t= 1 << 9,\n+    GF_CALL_BY_DESCRIPTOR\t= 1 << 10,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_PARALLEL_GRID_PHONY = 1 << 1,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n@@ -3368,6 +3369,26 @@ gimple_call_alloca_for_var_p (gcall *s)\n   return (s->subcode & GF_CALL_ALLOCA_FOR_VAR) != 0;\n }\n \n+/* If BY_DESCRIPTOR_P is true, GIMPLE_CALL S is an indirect call for which\n+   pointers to nested function are descriptors instead of trampolines.  */\n+\n+static inline void\n+gimple_call_set_by_descriptor (gcall  *s, bool by_descriptor_p)\n+{\n+  if (by_descriptor_p)\n+    s->subcode |= GF_CALL_BY_DESCRIPTOR;\n+  else\n+    s->subcode &= ~GF_CALL_BY_DESCRIPTOR;\n+}\n+\n+/* Return true if S is a by-descriptor call.  */\n+\n+static inline bool\n+gimple_call_by_descriptor_p (gcall *s)\n+{\n+  return (s->subcode & GF_CALL_BY_DESCRIPTOR) != 0;\n+}\n+\n /* Copy all the GF_CALL_* flags from ORIG_CALL to DEST_CALL.  */\n \n static inline void"}, {"sha": "7395440986a486bfe18192f1ca57dec6578c6d3b", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -123,6 +123,7 @@ extern const char *lhd_get_substring_location (const substring_loc &,\n #define LANG_HOOKS_BLOCK_MAY_FALLTHRU\thook_bool_const_tree_true\n #define LANG_HOOKS_EH_USE_CXA_END_CLEANUP\tfalse\n #define LANG_HOOKS_DEEP_UNSHARING\tfalse\n+#define LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS\tfalse\n #define LANG_HOOKS_RUN_LANG_SELFTESTS   lhd_do_nothing\n #define LANG_HOOKS_GET_SUBSTRING_LOCATION lhd_get_substring_location\n \n@@ -327,6 +328,7 @@ extern void lhd_end_section (void);\n   LANG_HOOKS_BLOCK_MAY_FALLTHRU, \\\n   LANG_HOOKS_EH_USE_CXA_END_CLEANUP, \\\n   LANG_HOOKS_DEEP_UNSHARING, \\\n+  LANG_HOOKS_CUSTOM_FUNCTION_DESCRIPTORS, \\\n   LANG_HOOKS_RUN_LANG_SELFTESTS, \\\n   LANG_HOOKS_GET_SUBSTRING_LOCATION \\\n }"}, {"sha": "c89cd091d67e66648bdb16daf75add05410c8056", "filename": "gcc/langhooks.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -512,6 +512,10 @@ struct lang_hooks\n      gimplification.  */\n   bool deep_unsharing;\n \n+  /* True if this language may use custom descriptors for nested functions\n+     instead of trampolines.  */\n+  bool custom_function_descriptors;\n+\n   /* Run all lang-specific selftests.  */\n   void (*run_lang_selftests) (void);\n "}, {"sha": "68d96fcbb3db0e0aae8dca993c88c3eb8749110a", "filename": "gcc/rtl.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -317,6 +317,7 @@ struct GTY((desc(\"0\"), tag(\"0\"),\n      1 in a CONCAT is VAL_EXPR_IS_COPIED in var-tracking.c.\n      1 in a VALUE is SP_BASED_VALUE_P in cselib.c.\n      1 in a SUBREG generated by LRA for reload insns.\n+     1 in a REG if this is a static chain register.\n      1 in a CALL for calls instrumented by Pointer Bounds Checker.\n      Dumped as \"/j\" in RTL dumps.  */\n   unsigned int jump : 1;\n@@ -2271,6 +2272,10 @@ do {\t\t\t\t\t\t\t\t        \\\n  : (SIGN) == SRP_SIGNED ? SUBREG_PROMOTED_SIGNED_P (RTX)\t\t\\\n  : SUBREG_PROMOTED_UNSIGNED_P (RTX))\n \n+/* True if the REG is the static chain register for some CALL_INSN.  */\n+#define STATIC_CHAIN_REG_P(RTX)\t\\\n+  (RTL_FLAG_CHECK1 (\"STATIC_CHAIN_REG_P\", (RTX), REG)->jump)\n+\n /* True if the subreg was generated by LRA for reload insns.  Such\n    subregs are valid only during LRA.  */\n #define LRA_SUBREG_P(RTX)\t\\"}, {"sha": "d2b38d19c1e72e404295ff66bf51700b034009ee", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -3886,7 +3886,8 @@ find_first_parameter_load (rtx_insn *call_insn, rtx_insn *boundary)\n   parm.nregs = 0;\n   for (p = CALL_INSN_FUNCTION_USAGE (call_insn); p; p = XEXP (p, 1))\n     if (GET_CODE (XEXP (p, 0)) == USE\n-\t&& REG_P (XEXP (XEXP (p, 0), 0)))\n+\t&& REG_P (XEXP (XEXP (p, 0), 0))\n+\t&& !STATIC_CHAIN_REG_P (XEXP (XEXP (p, 0), 0)))\n       {\n \tgcc_assert (REGNO (XEXP (XEXP (p, 0), 0)) < FIRST_PSEUDO_REGISTER);\n "}, {"sha": "29d1f81fa0d7a2f38c4b33814b864b0b85d2e563", "filename": "gcc/target.def", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -4796,6 +4796,25 @@ be returned; otherwise @var{addr} should be returned unchanged.\\n\\\n If this hook is not defined, @var{addr} will be used for function calls.\",\n  rtx, (rtx addr), NULL)\n \n+DEFHOOKPOD\n+(custom_function_descriptors,\n+ \"This hook should be defined to a power of 2 if the target will benefit\\n\\\n+from the use of custom descriptors for nested functions instead of the\\n\\\n+standard trampolines.  Such descriptors are created at run time on the\\n\\\n+stack and made up of data only, but they are non-standard so the generated\\n\\\n+code must be prepared to deal with them.  This hook should be defined to 0\\n\\\n+if the target uses function descriptors for its standard calling sequence,\\n\\\n+like for example HP-PA or IA-64.  Using descriptors for nested functions\\n\\\n+eliminates the need for trampolines that reside on the stack and require\\n\\\n+it to be made executable.\\n\\\n+\\n\\\n+The value of the macro is used to parameterize the run-time identification\\n\\\n+scheme implemented to distinguish descriptors from function addresses: it\\n\\\n+gives the number of bytes by which their address is misaligned compared\\n\\\n+with function addresses.  The value of 1 will generally work, unless it is\\n\\\n+already reserved by the target for another purpose, like for example on ARM.\",\\\n+ int, -1)\n+\n /* Return the number of bytes of its own arguments that a function\n    pops on returning, or 0 if the function pops no arguments and the\n    caller must therefore pop them all after the function returns.  */"}, {"sha": "92a0a3ad67668f0bd70ef09fe4611180615af94c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1,3 +1,8 @@\n+2016-10-16  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gnat.dg/trampoline3.adb: New test.\n+\t* gnat.dg/trampoline4.adb: Likewise.\n+\n 2016-10-16  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \t* gfortran.dg/dtio_16.f90: New test."}, {"sha": "280576624524c18600594eaa1791fc6993ad3e0d", "filename": "gcc/testsuite/gnat.dg/trampoline3.adb", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline3.adb?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -0,0 +1,22 @@\n+-- { dg-do compile { target *-*-linux* } }\n+-- { dg-options \"-gnatws\" }\n+\n+procedure Trampoline3 is\n+\n+  A : Integer;\n+\n+  type FuncPtr is access function (I : Integer) return Integer;\n+\n+  function F (I : Integer) return Integer is\n+  begin\n+    return A + I;\n+  end F;\n+\n+  P : FuncPtr := F'Access;\n+  I : Integer;\n+\n+begin\n+  I := P(0);\n+end;\n+\n+-- { dg-final { scan-assembler-not \"GNU-stack.*x\" } }"}, {"sha": "f825c0210ce3568e07244f79aaa96b3c86f4d882", "filename": "gcc/testsuite/gnat.dg/trampoline4.adb", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Ftrampoline4.adb?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -0,0 +1,23 @@\n+-- { dg-do compile { target *-*-linux* } }\n+-- { dg-options \"-ftrampolines -gnatws\" }\n+-- { dg-skip-if \"native descriptors\" { ia64-*-* powerpc64-*-* } }\n+\n+procedure Trampoline4 is\n+\n+  A : Integer;\n+\n+  type FuncPtr is access function (I : Integer) return Integer;\n+\n+  function F (I : Integer) return Integer is\n+  begin\n+    return A + I;\n+  end F;\n+\n+  P : FuncPtr := F'Access;\n+  I : Integer;\n+\n+begin\n+  I := P(0);\n+end;\n+\n+-- { dg-final { scan-assembler \"GNU-stack.*x\" } }"}, {"sha": "1bfe682361083a5b2cb495251806e2240a913507", "filename": "gcc/tree-core.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree-core.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree-core.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-core.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -90,6 +90,9 @@ struct die_struct;\n /* Nonzero if this call is into the transaction runtime library.  */\n #define ECF_TM_BUILTIN\t\t  (1 << 13)\n \n+/* Nonzero if this is an indirect call by descriptor.  */\n+#define ECF_BY_DESCRIPTOR\t  (1 << 14)\n+\n /* Call argument flags.  */\n /* Nonzero if the argument is not dereferenced recursively, thus only\n    directly reachable memory is read or written.  */\n@@ -1250,6 +1253,12 @@ struct GTY(()) tree_base {\n \n        REF_REVERSE_STORAGE_ORDER in\n            BIT_FIELD_REF, MEM_REF\n+\n+       FUNC_ADDR_BY_DESCRIPTOR in\n+           ADDR_EXPR\n+\n+       CALL_EXPR_BY_DESCRIPTOR in\n+           CALL_EXPR\n */\n \n struct GTY(()) tree_typed {"}, {"sha": "36b120ce570709327d26ae32b1fdeff9b89895bf", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 146, "deletions": 23, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -21,6 +21,7 @@\n #include \"system.h\"\n #include \"coretypes.h\"\n #include \"backend.h\"\n+#include \"target.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n #include \"gimple.h\"\n@@ -104,6 +105,7 @@ struct nesting_info\n \n   bool any_parm_remapped;\n   bool any_tramp_created;\n+  bool any_descr_created;\n   char static_chain_added;\n };\n \n@@ -487,12 +489,38 @@ get_trampoline_type (struct nesting_info *info)\n   return trampoline_type;\n }\n \n-/* Given DECL, a nested function, find or create a field in the non-local\n-   frame structure for a trampoline for this function.  */\n+/* Build or return the type used to represent a nested function descriptor.  */\n+\n+static GTY(()) tree descriptor_type;\n \n static tree\n-lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n-\t\t       enum insert_option insert)\n+get_descriptor_type (struct nesting_info *info)\n+{\n+  tree t;\n+\n+  if (descriptor_type)\n+    return descriptor_type;\n+\n+  t = build_index_type (integer_one_node);\n+  t = build_array_type (ptr_type_node, t);\n+  t = build_decl (DECL_SOURCE_LOCATION (info->context),\n+\t\t  FIELD_DECL, get_identifier (\"__data\"), t);\n+\n+  descriptor_type = make_node (RECORD_TYPE);\n+  TYPE_NAME (descriptor_type) = get_identifier (\"__builtin_descriptor\");\n+  TYPE_FIELDS (descriptor_type) = t;\n+  layout_type (descriptor_type);\n+  DECL_CONTEXT (t) = descriptor_type;\n+\n+  return descriptor_type;\n+}\n+\n+/* Given DECL, a nested function, find or create an element in the\n+   var map for this function.  */\n+\n+static tree\n+lookup_element_for_decl (struct nesting_info *info, tree decl,\n+\t\t\t enum insert_option insert)\n {\n   if (insert == NO_INSERT)\n     {\n@@ -502,19 +530,73 @@ lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n \n   tree *slot = &info->var_map->get_or_insert (decl);\n   if (!*slot)\n-    {\n-      tree field = make_node (FIELD_DECL);\n-      DECL_NAME (field) = DECL_NAME (decl);\n-      TREE_TYPE (field) = get_trampoline_type (info);\n-      TREE_ADDRESSABLE (field) = 1;\n+    *slot = build_tree_list (NULL_TREE, NULL_TREE);\n \n-      insert_field_into_struct (get_frame_type (info), field);\n-      *slot = field;\n+  return (tree) *slot;\n+} \n+\n+/* Given DECL, a nested function, create a field in the non-local\n+   frame structure for this function.  */\n+\n+static tree\n+create_field_for_decl (struct nesting_info *info, tree decl, tree type)\n+{\n+  tree field = make_node (FIELD_DECL);\n+  DECL_NAME (field) = DECL_NAME (decl);\n+  TREE_TYPE (field) = type;\n+  TREE_ADDRESSABLE (field) = 1;\n+  insert_field_into_struct (get_frame_type (info), field);\n+  return field;\n+}\n+\n+/* Given DECL, a nested function, find or create a field in the non-local\n+   frame structure for a trampoline for this function.  */\n+\n+static tree\n+lookup_tramp_for_decl (struct nesting_info *info, tree decl,\n+\t\t       enum insert_option insert)\n+{\n+  tree elt, field;\n+\n+  elt = lookup_element_for_decl (info, decl, insert);\n+  if (!elt)\n+    return NULL_TREE;\n \n+  field = TREE_PURPOSE (elt);\n+\n+  if (!field && insert == INSERT)\n+    {\n+      field = create_field_for_decl (info, decl, get_trampoline_type (info));\n+      TREE_PURPOSE (elt) = field;\n       info->any_tramp_created = true;\n     }\n \n-  return *slot;\n+  return field;\n+}\n+\n+/* Given DECL, a nested function, find or create a field in the non-local\n+   frame structure for a descriptor for this function.  */\n+\n+static tree\n+lookup_descr_for_decl (struct nesting_info *info, tree decl,\n+\t\t       enum insert_option insert)\n+{\n+  tree elt, field;\n+\n+  elt = lookup_element_for_decl (info, decl, insert);\n+  if (!elt)\n+    return NULL_TREE;\n+\n+  field = TREE_VALUE (elt);\n+\n+  if (!field && insert == INSERT)\n+    {\n+      field = create_field_for_decl (info, decl, get_descriptor_type (info));\n+      TREE_VALUE (elt) = field;\n+      info->any_descr_created = true;\n+    }\n+\n+  return field;\n }\n \n /* Build or return the field within the non-local frame state that holds\n@@ -2304,6 +2386,7 @@ convert_tramp_reference_op (tree *tp, int *walk_subtrees, void *data)\n   struct walk_stmt_info *wi = (struct walk_stmt_info *) data;\n   struct nesting_info *const info = (struct nesting_info *) wi->info, *i;\n   tree t = *tp, decl, target_context, x, builtin;\n+  bool descr;\n   gcall *call;\n \n   *walk_subtrees = 0;\n@@ -2338,7 +2421,14 @@ convert_tramp_reference_op (tree *tp, int *walk_subtrees, void *data)\n \t we need to insert the trampoline.  */\n       for (i = info; i->context != target_context; i = i->outer)\n \tcontinue;\n-      x = lookup_tramp_for_decl (i, decl, INSERT);\n+\n+      /* Decide whether to generate a descriptor or a trampoline. */\n+      descr = FUNC_ADDR_BY_DESCRIPTOR (t) && !flag_trampolines;\n+\n+      if (descr)\n+\tx = lookup_descr_for_decl (i, decl, INSERT);\n+      else\n+\tx = lookup_tramp_for_decl (i, decl, INSERT);\n \n       /* Compute the address of the field holding the trampoline.  */\n       x = get_frame_field (info, target_context, x, &wi->gsi);\n@@ -2347,7 +2437,10 @@ convert_tramp_reference_op (tree *tp, int *walk_subtrees, void *data)\n \n       /* Do machine-specific ugliness.  Normally this will involve\n \t computing extra alignment, but it can really be anything.  */\n-      builtin = builtin_decl_implicit (BUILT_IN_ADJUST_TRAMPOLINE);\n+      if (descr)\n+\tbuiltin = builtin_decl_implicit (BUILT_IN_ADJUST_DESCRIPTOR);\n+      else\n+\tbuiltin = builtin_decl_implicit (BUILT_IN_ADJUST_TRAMPOLINE);\n       call = gimple_build_call (builtin, 1, x);\n       x = init_tmp_var_with_call (info, &wi->gsi, call);\n \n@@ -2821,6 +2914,27 @@ fold_mem_refs (tree *const &e, void *data ATTRIBUTE_UNUSED)\n   return true;\n }\n \n+/* Given DECL, a nested function, build an initialization call for FIELD,\n+   the trampoline or descriptor for DECL, using FUNC as the function.  */\n+\n+static gcall *\n+build_init_call_stmt (struct nesting_info *info, tree decl, tree field,\n+\t\t      tree func)\n+{\n+  tree arg1, arg2, arg3, x;\n+\n+  gcc_assert (DECL_STATIC_CHAIN (decl));\n+  arg3 = build_addr (info->frame_decl);\n+\n+  arg2 = build_addr (decl);\n+\n+  x = build3 (COMPONENT_REF, TREE_TYPE (field),\n+\t      info->frame_decl, field, NULL_TREE);\n+  arg1 = build_addr (x);\n+\n+  return gimple_build_call (func, 3, arg1, arg2, arg3);\n+}\n+\n /* Do \"everything else\" to clean up or complete state collected by the various\n    walking passes -- create a field to hold the frame base address, lay out the\n    types and decls, generate code to initialize the frame decl, store critical\n@@ -2966,23 +3080,32 @@ finalize_nesting_tree_1 (struct nesting_info *root)\n       struct nesting_info *i;\n       for (i = root->inner; i ; i = i->next)\n \t{\n-\t  tree arg1, arg2, arg3, x, field;\n+\t  tree field, x;\n \n \t  field = lookup_tramp_for_decl (root, i->context, NO_INSERT);\n \t  if (!field)\n \t    continue;\n \n-\t  gcc_assert (DECL_STATIC_CHAIN (i->context));\n-\t  arg3 = build_addr (root->frame_decl);\n+\t  x = builtin_decl_implicit (BUILT_IN_INIT_TRAMPOLINE);\n+\t  stmt = build_init_call_stmt (root, i->context, field, x);\n+\t  gimple_seq_add_stmt (&stmt_list, stmt);\n+\t}\n+    }\n \n-\t  arg2 = build_addr (i->context);\n+  /* If descriptors were created, then we need to initialize them.  */\n+  if (root->any_descr_created)\n+    {\n+      struct nesting_info *i;\n+      for (i = root->inner; i ; i = i->next)\n+\t{\n+\t  tree field, x;\n \n-\t  x = build3 (COMPONENT_REF, TREE_TYPE (field),\n-\t\t      root->frame_decl, field, NULL_TREE);\n-\t  arg1 = build_addr (x);\n+\t  field = lookup_descr_for_decl (root, i->context, NO_INSERT);\n+\t  if (!field)\n+\t    continue;\n \n-\t  x = builtin_decl_implicit (BUILT_IN_INIT_TRAMPOLINE);\n-\t  stmt = gimple_build_call (x, 3, arg1, arg2, arg3);\n+\t  x = builtin_decl_implicit (BUILT_IN_INIT_DESCRIPTOR);\n+\t  stmt = build_init_call_stmt (root, i->context, field, x);\n \t  gimple_seq_add_stmt (&stmt_list, stmt);\n \t}\n     }"}, {"sha": "30d4373a20d625c64da1bb0ee89950b2e143dc9d", "filename": "gcc/tree.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -1019,7 +1019,7 @@ make_node_stat (enum tree_code code MEM_STAT_DECL)\n \t{\n \t  if (code == FUNCTION_DECL)\n \t    {\n-\t      SET_DECL_ALIGN (t, FUNCTION_BOUNDARY);\n+\t      SET_DECL_ALIGN (t, FUNCTION_ALIGNMENT (FUNCTION_BOUNDARY));\n \t      DECL_MODE (t) = FUNCTION_MODE;\n \t    }\n \t  else\n@@ -10602,12 +10602,19 @@ build_common_builtin_nodes (void)\n \t\t\tBUILT_IN_INIT_HEAP_TRAMPOLINE,\n \t\t\t\"__builtin_init_heap_trampoline\",\n \t\t\tECF_NOTHROW | ECF_LEAF);\n+  local_define_builtin (\"__builtin_init_descriptor\", ftype,\n+\t\t\tBUILT_IN_INIT_DESCRIPTOR,\n+\t\t\t\"__builtin_init_descriptor\", ECF_NOTHROW | ECF_LEAF);\n \n   ftype = build_function_type_list (ptr_type_node, ptr_type_node, NULL_TREE);\n   local_define_builtin (\"__builtin_adjust_trampoline\", ftype,\n \t\t\tBUILT_IN_ADJUST_TRAMPOLINE,\n \t\t\t\"__builtin_adjust_trampoline\",\n \t\t\tECF_CONST | ECF_NOTHROW);\n+  local_define_builtin (\"__builtin_adjust_descriptor\", ftype,\n+\t\t\tBUILT_IN_ADJUST_DESCRIPTOR,\n+\t\t\t\"__builtin_adjust_descriptor\",\n+\t\t\tECF_CONST | ECF_NOTHROW);\n \n   ftype = build_function_type_list (void_type_node,\n \t\t\t\t    ptr_type_node, ptr_type_node, NULL_TREE);"}, {"sha": "9624a01676bef3041b9e462edea63ab9fa180bdf", "filename": "gcc/tree.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c640e26064224e29e2a88bd08cff338889da13c/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4c640e26064224e29e2a88bd08cff338889da13c", "patch": "@@ -967,6 +967,16 @@ extern void omp_clause_range_check_failed (const_tree, const char *, int,\n #define REF_REVERSE_STORAGE_ORDER(NODE) \\\n   (TREE_CHECK2 (NODE, BIT_FIELD_REF, MEM_REF)->base.default_def_flag)\n \n+  /* In an ADDR_EXPR, indicates that this is a pointer to nested function\n+   represented by a descriptor instead of a trampoline.  */\n+#define FUNC_ADDR_BY_DESCRIPTOR(NODE) \\\n+  (TREE_CHECK (NODE, ADDR_EXPR)->base.default_def_flag)\n+\n+/* In a CALL_EXPR, indicates that this is an indirect call for which\n+   pointers to nested function are descriptors instead of trampolines.  */\n+#define CALL_EXPR_BY_DESCRIPTOR(NODE) \\\n+  (TREE_CHECK (NODE, CALL_EXPR)->base.default_def_flag)\n+\n /* These flags are available for each language front end to use internally.  */\n #define TREE_LANG_FLAG_0(NODE) \\\n   (TREE_NOT_CHECK2 (NODE, TREE_VEC, SSA_NAME)->base.u.bits.lang_flag_0)"}]}