{"sha": "ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhYWE5ZmU5M2ZkNWMzMzAyOGI3NGVmZjM3NmFmZjgzMjFlY2ZhNQ==", "commit": {"author": {"name": "Joern Rennecke", "email": "joern.rennecke@embecosm.com", "date": "2016-04-28T18:48:43Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "2016-04-28T18:48:43Z"}, "message": "arc.h (SYMBOL_FLAG_CMEM): Define.\n\n2016-04-28  Joern Rennecke  <joern.rennecke@embecosm.com>\n            Andrew Burgess  <andrew.burgess@embecosm.com>\ngcc:\n        * config/arc/arc.h (SYMBOL_FLAG_CMEM): Define.\n        (TARGET_NPS_CMEM_DEFAULT): Provide default definition.\n        * config/arc/arc.c (arc_address_cost): Return 0 for cmem_address.\n        (arc_encode_section_info): Set SYMBOL_FLAG_CMEM where indicated.\n        * config/arc/arc.opt (mcmem): New option.\n        * config/arc/arc.md (*extendqihi2_i): Add r/Uex alternative,\n        supply length for r/m alternative.\n        (*extendqisi2_ac): Likewise.\n        (*extendhisi2_i): Add r/Uex alternative, supply length for r/m and\n        r/Uex alternative.\n        (movqi_insn): Add r/Ucm and Ucm/?Rac alternatives.\n        (movhi_insn): Likewise.\n        (movsi_insn): Add r/Ucm,Ucm/w alternatives.\n        (*zero_extendqihi2_i): Add r/Ucm alternative.\n        (*zero_extendqisi2_ac): Likewise.\n        (*zero_extendhisi2_i): Likewise.\n        * config/arc/constraints.md (Uex): New memory constraint.\n        (Ucm): New define_constraint.\n        * config/arc/predicates.md (long_immediate_loadstore_operand):\n        Return 0 for MEM with cmem_address address.\n        (cmem_address_0): New predicates.\n        (cmem_address_1): Likewise.\n        (cmem_address_2): Likewise.\n        (cmem_address): Likewise.\ngcc/testsuite:\n        * gcc.target/arc/cmem-1.c: New file.\n        * gcc.target/arc/cmem-2.c: New file.\n        * gcc.target/arc/cmem-3.c: New file.\n        * gcc.target/arc/cmem-4.c: New file.\n        * gcc.target/arc/cmem-5.c: New file.\n        * gcc.target/arc/cmem-6.c: New file.\n        * gcc.target/arc/cmem-7.c: New file.\n        * gcc.target/arc/cmem-ld.inc: New file.\n        * gcc.target/arc/cmem-st.inc: New file.\n\nCo-Authored-By: Andrew Burgess <andrew.burgess@embecosm.com>\n\nFrom-SVN: r235595", "tree": {"sha": "77a9de810077cb4fa344012baea8feeb0a147483", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/77a9de810077cb4fa344012baea8feeb0a147483"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/comments", "author": {"login": "amylaar", "id": 1663475, "node_id": "MDQ6VXNlcjE2NjM0NzU=", "avatar_url": "https://avatars.githubusercontent.com/u/1663475?v=4", "gravatar_id": "", "url": "https://api.github.com/users/amylaar", "html_url": "https://github.com/amylaar", "followers_url": "https://api.github.com/users/amylaar/followers", "following_url": "https://api.github.com/users/amylaar/following{/other_user}", "gists_url": "https://api.github.com/users/amylaar/gists{/gist_id}", "starred_url": "https://api.github.com/users/amylaar/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/amylaar/subscriptions", "organizations_url": "https://api.github.com/users/amylaar/orgs", "repos_url": "https://api.github.com/users/amylaar/repos", "events_url": "https://api.github.com/users/amylaar/events{/privacy}", "received_events_url": "https://api.github.com/users/amylaar/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc236a9d78d10bda700ca2997ca3134cd6e80775", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc236a9d78d10bda700ca2997ca3134cd6e80775", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc236a9d78d10bda700ca2997ca3134cd6e80775"}], "stats": {"total": 705, "additions": 648, "deletions": 57}, "files": [{"sha": "c5edb75c771ac7c1d4a410cdf33515cd04285461", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -1,3 +1,45 @@\n+2016-04-28  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* config/arc/arc.c (arc_conditional_register_usage): Take\n+\tTARGET_RRQ_CLASS into account.\n+\t(arc_print_operand): Support printing 'p' and 's' operands.\n+\t* config/arc/arc.h (TARGET_NPS_BITOPS_DEFAULT): Provide default\n+\tas 0.\n+\t(TARGET_RRQ_CLASS): Define.\n+\t(IS_POWEROF2_OR_0_P): Define.\n+\t* config/arc/arc.md (*movsi_insn): Add w/Clo, w/Chi, and w/Cbi\n+\talternatives.\n+\t(*tst_movb): New define_insn.\n+\t(*tst): Avoid recognition if it could prevent '*tst_movb'\n+\tcombination; replace c/CnL with c/Chs alternative.\n+\t(*tst_bitfield_tst): New define_insn.\n+\t(*tst_bitfield_asr): New define_insn.\n+\t(*tst_bitfield): New define_insn.\n+\t(andsi3_i): Add Rrq variant.\n+\t(extzv): New define_expand.\n+\t(insv): New define_expand.\n+\t(*insv_i): New define_insn.\n+\t(*movb): New define_insn.\n+\t(*movb_signed): New define_insn.\n+\t(*movb_high): New define_insn.\n+\t(*movb_high_signed): New define_insn.\n+\t(*movb_high_signed + 1): New define_split pattern.\n+\t(*mrgb): New define_insn.\n+\t(*mrgb + 1): New define_peephole2 pattern.\n+\t(*mrgb + 2): New define_peephole2 pattern.\n+\t* config/arc/arc.opt (mbitops): New option for nps400, uses\n+\tTARGET_NPS_BITOPS_DEFAULT.\n+\t* config/arc/constraints.md (q): Make register class conditional.\n+\t(Rrq): New register constraint.\n+\t(Chs): New constraint.\n+\t(Clo): New constraint.\n+\t(Chi): New constraint.\n+\t(Cbf): New constraint.\n+\t(Cbn): New constraint.\n+\t(C18): New constraint.\n+\t(Cbi): New constraint.\n+\n 2016-04-28  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* cfganal.c (bitmap_intersection_of_succs): Delete assert checking"}, {"sha": "b7dfab1e0d864aa0866cf04b4c24e0f72ff2a3cd", "filename": "gcc/config/arc/arc.c", "status": "modified", "additions": 27, "deletions": 6, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -1430,7 +1430,8 @@ arc_conditional_register_usage (void)\n     {\n       if (i < 29)\n \t{\n-\t  if (TARGET_Q_CLASS && ((i <= 3) || ((i >= 12) && (i <= 15))))\n+\t  if ((TARGET_Q_CLASS || TARGET_RRQ_CLASS)\n+\t      && ((i <= 3) || ((i >= 12) && (i <= 15))))\n \t    arc_regno_reg_class[i] = ARCOMPACT16_REGS;\n \t  else\n \t    arc_regno_reg_class[i] = GENERAL_REGS;\n@@ -1447,12 +1448,12 @@ arc_conditional_register_usage (void)\n \tarc_regno_reg_class[i] = NO_REGS;\n     }\n \n-  /* ARCOMPACT16_REGS is empty, if TARGET_Q_CLASS has not been activated.  */\n+  /* ARCOMPACT16_REGS is empty, if TARGET_Q_CLASS / TARGET_RRQ_CLASS\n+     has not been activated.  */\n+  if (!TARGET_Q_CLASS && !TARGET_RRQ_CLASS)\n+    CLEAR_HARD_REG_SET(reg_class_contents [ARCOMPACT16_REGS]);\n   if (!TARGET_Q_CLASS)\n-    {\n-      CLEAR_HARD_REG_SET(reg_class_contents [ARCOMPACT16_REGS]);\n-      CLEAR_HARD_REG_SET(reg_class_contents [AC16_BASE_REGS]);\n-    }\n+    CLEAR_HARD_REG_SET(reg_class_contents [AC16_BASE_REGS]);\n \n   gcc_assert (FIRST_PSEUDO_REGISTER >= 144);\n \n@@ -2994,6 +2995,8 @@ static int output_scaled = 0;\n     'Z': log2(x+1)-1\n     'z': log2\n     'M': log2(~x)\n+    'p': bit Position of lsb\n+    's': size of bit field\n     '#': condbranch delay slot suffix\n     '*': jump delay slot suffix\n     '?' : nonjump-insn suffix for conditional execution or short instruction\n@@ -3044,6 +3047,24 @@ arc_print_operand (FILE *file, rtx x, int code)\n \n       return;\n \n+    case 'p':\n+      if (GET_CODE (x) == CONST_INT)\n+\tfprintf (file, \"%d\", exact_log2 (INTVAL (x) & -INTVAL (x)));\n+      else\n+\toutput_operand_lossage (\"invalid operand to %%p code\");\n+      return;\n+\n+    case 's':\n+      if (GET_CODE (x) == CONST_INT)\n+\t{\n+\t  HOST_WIDE_INT i = INTVAL (x);\n+\t  HOST_WIDE_INT s = exact_log2 (i & -i);\n+\t  fprintf (file, \"%d\", exact_log2 (((0xffffffffUL & i) >> s) + 1));\n+\t}\n+      else\n+\toutput_operand_lossage (\"invalid operand to %%s code\");\n+      return;\n+\n     case '#' :\n       /* Conditional branches depending on condition codes.\n \t Note that this is only for branches that were known to depend on"}, {"sha": "4235eabc96d38a57d1dba86d3a867b5b017250f9", "filename": "gcc/config/arc/arc.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.h?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -326,10 +326,18 @@ along with GCC; see the file COPYING3.  If not see\n #define UNALIGNED_ACCESS_DEFAULT 0\n #endif\n \n+#ifndef TARGET_NPS_BITOPS_DEFAULT\n+#define TARGET_NPS_BITOPS_DEFAULT 0\n+#endif\n+\n #ifndef TARGET_NPS_CMEM_DEFAULT\n #define TARGET_NPS_CMEM_DEFAULT 0\n #endif\n \n+/* Enable the RRQ instruction alternatives.  */\n+\n+#define TARGET_RRQ_CLASS TARGET_NPS_BITOPS\n+\n /* Target machine storage layout.  */\n \n /* We want zero_extract to mean the same\n@@ -1033,6 +1041,7 @@ extern int arc_initial_elimination_offset(int from, int to);\n \n /* Is the argument a const_int rtx, containing an exact power of 2 */\n #define  IS_POWEROF2_P(X) (! ( (X) & ((X) - 1)) && (X))\n+#define  IS_POWEROF2_OR_0_P(X) (! ( (X) & ((X) - 1)))\n \n /* The macros REG_OK_FOR..._P assume that the arg is a REG rtx\n    and check its validity for a certain class."}, {"sha": "7c30eb46e072448a7e45ad79b584f070f893058b", "filename": "gcc/config/arc/arc.md", "status": "modified", "additions": 332, "deletions": 50, "changes": 382, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.md?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -700,8 +700,8 @@\n ; insns it should lengthen the return insn.\n ; N.B. operand 1 of alternative 7 expands into pcl,symbol@gotpc .\n (define_insn \"*movsi_insn\"\n-  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,w, w,w,  w,???w, ?w,  w,Rcq#q, w,Rcq,  S,Us<,RcqRck,!*x,r,r,Ucm,m,???m,VUsc\")\n-\t(match_operand:SI 1 \"move_src_operand\"  \" cL,cP,Rcq#q,cL,I,Crr,?Rac,Cpc,Clb,?Cal,?Cal,T,Rcq,RcqRck,Us>,Usd,Ucm,m,w,c,?Rac,C32\"))]\n+  [(set (match_operand:SI 0 \"move_dest_operand\" \"=Rcq,Rcq#q,w,w,w,w,w,w,w,???w,?w,w,Rcq#q,w,Rcq,S,Us<,RcqRck,!*x,r,r,Ucm,m,???m,VUsc\")\n+\t(match_operand:SI 1 \"move_src_operand\"  \"cL,cP,Rcq#q,cL,I,Crr,Clo,Chi,Cbi,?Rac,Cpc,Clb,?Cal,?Cal,T,Rcq,RcqRck,Us>,Usd,Ucm,m,w,c,?Rac,C32\"))]\n   \"register_operand (operands[0], SImode)\n    || register_operand (operands[1], SImode)\n    || (CONSTANT_P (operands[1])\n@@ -716,29 +716,32 @@\n    mov%? %0,%1\t\t;3\n    mov%? %0,%1\t\t;4\n    ror %0,((%1*2+1) & 0x3f) ;5\n-   mov%? %0,%1\t\t;6\n-   add %0,%S1\t\t;7\n+   movl.cl %0,%1       ;6\n+   movh.cl %0,%L1>>16  ;7\n+   * return INTVAL (operands[1]) & 0xffffff ? \\\"movbi.cl %0,%1 >> %p1,%p1,8;8\\\" : \\\"movbi.cl %0,%L1 >> 24,24,8;9\\\";\n+   mov%? %0,%1\t\t;9\n+   add %0,%S1\t\t;10\n    * return arc_get_unalign () ? \\\"add %0,pcl,%1-.+2\\\" : \\\"add %0,pcl,%1-.\\\";\n-   mov%? %0,%S1%&\t;9\n-   mov%? %0,%S1\t\t;10\n-   ld%? %0,%1%&\t\t;11\n-   st%? %1,%0%&\t\t;12\n+   mov%? %0,%S1%&\t;12\n+   mov%? %0,%S1\t\t;13\n+   ld%? %0,%1%&\t\t;14\n+   st%? %1,%0%&\t\t;15\n    * return arc_short_long (insn, \\\"push%? %1%&\\\", \\\"st%U0 %1,%0%&\\\");\n    * return arc_short_long (insn, \\\"pop%? %0%&\\\",  \\\"ld%U1 %0,%1%&\\\");\n-   ld%? %0,%1%&\t\t;15\n-   xld%U1 %0,%1         ;16\n-   ld%U1%V1 %0,%1\t;17\n-   xst%U0 %1,%0         ;18\n-   st%U0%V0 %1,%0       ;19\n-   st%U0%V0 %1,%0       ;20\n-   st%U0%V0 %S1,%0      ;21\"\n-  [(set_attr \"type\" \"move,move,move,move,move,two_cycle_core,move,binary,binary,move,move,load,store,store,load,load,load,load,store,store,store,store\")\n-   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,false,false,maybe_limm,false,true,true,true,true,true,false,false,false,false,false,false\")\n+   ld%? %0,%1%&\t\t;18\n+   xld%U1 %0,%1                ;19\n+   ld%U1%V1 %0,%1\t;20\n+   xst%U0 %1,%0                ;21\n+   st%U0%V0 %1,%0       ;22\n+   st%U0%V0 %1,%0       ;23\n+   st%U0%V0 %S1,%0      ;24\"\n+  [(set_attr \"type\" \"move,move,move,move,move,two_cycle_core,shift,shift,shift,move,binary,binary,move,move,load,store,store,load,load,load,load,store,store,store,store\")\n+   (set_attr \"iscompact\" \"maybe,maybe,maybe,false,false,false,false,false,false,false,false,false,maybe_limm,false,true,true,true,true,true,false,false,false,false,false,false\")\n    ; Use default length for iscompact to allow for COND_EXEC.  But set length\n    ; of Crr to 4.\n-   (set_attr \"length\" \"*,*,*,4,4,4,4,8,8,*,8,*,*,*,*,*,4,*,4,*,*,8\")\n-   (set_attr \"predicable\" \"yes,no,yes,yes,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no,no,no\")\n-   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n+   (set_attr \"length\" \"*,*,*,4,4,4,4,4,4,4,8,8,*,8,*,*,*,*,*,4,*,4,*,*,8\")\n+   (set_attr \"predicable\" \"yes,no,yes,yes,no,no,no,no,no,yes,no,no,yes,yes,no,no,no,no,no,no,no,no,no,no,no\")\n+   (set_attr \"cpu_facility\" \"*,*,av1,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*\")])\n \n ;; Sometimes generated by the epilogue code.  We don't want to\n ;; recognize these addresses in general, because the limm is costly,\n@@ -809,6 +812,24 @@\n    (set_attr \"cond\" \"set_zn\")\n    (set_attr \"length\" \"4\")])\n \n+; reload is too stingy with reloads for Rrq/Cbf/Rrq when it sees\n+; a c/???Cal/X alternative, so we say it's c/???Cal/c instead,\n+; even if we don't need the clobber.\n+(define_insn_and_split \"*tst_movb\"\n+  [(set\n+     (match_operand 0 \"cc_register\" \"\")\n+     (match_operator 4 \"zn_compare_operator\"\n+       [(and:SI\n+\t  (match_operand:SI 1 \"register_operand\"  \"%Rcq,Rcq, c,  c,  c,  c,Rrq,  3,  c\")\n+\t  (match_operand:SI 2 \"nonmemory_operand\"  \"Rcq,C0p,cI,C1p,Ccp,Chs,Cbf,Cbf,???Cal\"))\n+\t(const_int 0)]))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,X,X,X,Rrq,Rrq,c\"))]\n+  \"TARGET_NPS_BITOPS\"\n+  \"movb.f.cl %3,%1,%p2,%p2,%s2\"\n+  \"reload_completed\n+   && (extract_constrain_insn_cached (insn), (which_alternative & ~1) != 6)\"\n+  [(set (match_dup 0) (match_dup 4))])\n+\n (define_insn \"*tst\"\n   [(set\n      (match_operand 0 \"cc_register\" \"\")\n@@ -817,12 +838,14 @@\n \t  (match_operand:SI 1 \"register_operand\"\n \t   \"%Rcq,Rcq, c, c, c,  c,  c,  c\")\n \t  (match_operand:SI 2 \"nonmemory_operand\"\n-\t   \" Rcq,C0p,cI,cL,C1p,Ccp,CnL,Cal\"))\n+\t   \" Rcq,C0p,cI,cL,C1p,Ccp,Chs,Cal\"))\n \t(const_int 0)]))]\n-  \"(register_operand (operands[1], SImode)\n-    && nonmemory_operand (operands[2], SImode))\n-   || (memory_operand (operands[1], SImode)\n-       && satisfies_constraint_Cux (operands[2]))\"\n+  \"reload_completed\n+   || !satisfies_constraint_Cbf (operands[2])\n+   || satisfies_constraint_C0p (operands[2])\n+   || satisfies_constraint_I (operands[2])\n+   || satisfies_constraint_C1p (operands[2])\n+   || satisfies_constraint_Chs (operands[2])\"\n   \"*\n     switch (which_alternative)\n     {\n@@ -835,17 +858,79 @@\n     case 5:\n       return \\\"bclr%?.f 0,%1,%M2%&\\\";\n     case 6:\n-      return \\\"bic%?.f 0,%1,%n2-1\\\";\n+      return \\\"asr.f 0,%1,%p2\\\";\n     default:\n       gcc_unreachable ();\n     }\n   \"\n   [(set_attr \"iscompact\" \"maybe,maybe,false,false,false,false,false,false\")\n-   (set_attr \"type\" \"compare\")\n+   (set_attr \"type\" \"compare,compare,compare,compare,compare,compare,shift,compare\")\n    (set_attr \"length\" \"*,*,4,4,4,4,4,8\")\n    (set_attr \"predicable\" \"no,yes,no,yes,no,no,no,yes\")\n    (set_attr \"cond\" \"set_zn\")])\n \n+; ??? Sometimes, if an AND with a constant can be expressed as a zero_extract,\n+; combine will do that and not try the AND.\n+\n+; It would take 66 constraint combinations to describe the zero_extract\n+; constants that are covered by the 12-bit signed constant for tst\n+; (excluding the ones that are better done by mov or btst).\n+; so we rather use an extra pattern for tst;\n+; since this is about constants, reload shouldn't care.\n+(define_insn \"*tst_bitfield_tst\"\n+  [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n+\t(match_operator 4 \"zn_compare_operator\"\n+\t  [(zero_extract:SI\n+\t     (match_operand:SI 1 \"register_operand\"  \"c\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 3 \"const_int_operand\" \"n\"))\n+\t   (const_int 0)]))]\n+  \"INTVAL (operands[2]) > 1\n+   && (INTVAL (operands[3]) + INTVAL (operands[2]) <= 11\n+       || (INTVAL (operands[3]) <= 11\n+\t   && INTVAL (operands[3]) + INTVAL (operands[2]) == 32))\"\n+  \"tst %1,(1<<%2)-1<<%3\"\n+  [(set_attr \"type\" \"compare\")\n+   (set_attr \"cond\" \"set_zn\")\n+   (set_attr \"length\" \"4\")])\n+\n+; Likewise for asr.f.\n+(define_insn \"*tst_bitfield_asr\"\n+  [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n+\t(match_operator 4 \"zn_compare_operator\"\n+\t  [(zero_extract:SI\n+\t     (match_operand:SI 1 \"register_operand\"  \"c\")\n+\t     (match_operand:SI 2 \"const_int_operand\" \"n\")\n+\t     (match_operand:SI 3 \"const_int_operand\" \"n\"))\n+\t   (const_int 0)]))]\n+  \"INTVAL (operands[2]) > 1\n+   && INTVAL (operands[3]) + INTVAL (operands[2]) == 32\"\n+  \"asr.f 0,%1,%3\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"cond\" \"set_zn\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*tst_bitfield\"\n+  [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n+\t(match_operator 5 \"zn_compare_operator\"\n+\t  [(zero_extract:SI\n+\t     (match_operand:SI 1 \"register_operand\" \"%Rcqq,c,  c,Rrq,c\")\n+\t     (match_operand:SI 2 \"const_int_operand\"    \"N,N,  n,Cbn,n\")\n+\t     (match_operand:SI 3 \"const_int_operand\"    \"n,n,C_0,Cbn,n\"))\n+\t   (const_int 0)]))\n+   (clobber (match_scratch:SI 4 \"=X,X,X,Rrq,X\"))]\n+  \"\"\n+  \"@\n+   btst%? %1,%3\n+   btst %1,%3\n+   bmsk.f 0,%1,%2-1\n+   movb.f.cl %4,%1,%3,%3,%2\n+   and.f 0,%1,((1<<%2)-1)<<%3\"\n+  [(set_attr \"iscompact\" \"maybe,false,false,false,false\")\n+   (set_attr \"type\" \"compare,compare,compare,shift,compare\")\n+   (set_attr \"cond\" \"set_zn\")\n+   (set_attr \"length\" \"*,4,4,4,8\")])\n+\n (define_insn \"*commutative_binary_comparison\"\n   [(set (match_operand:CC_ZN 0 \"cc_set_register\" \"\")\n \t(match_operator:CC_ZN 5 \"zn_compare_operator\"\n@@ -2956,52 +3041,60 @@\n      operands[1] = arc_rewrite_small_data (operands[1]);\")\n \n (define_insn \"andsi3_i\"\n-  [(set (match_operand:SI 0 \"dest_reg_operand\"          \"=Rcqq,Rcq,Rcqq,Rcqq,Rcqq,Rcw,Rcw,Rcw,Rcw,Rcw,Rcw,  w,  w,  w,  w,w,Rcw,  w,  W\")\n-\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,Rcq,   0,   0,Rcqq,  0,  c,  0,  0,  0,  0,  c,  c,  c,  c,0,  0,  c,  o\")\n-\t\t(match_operand:SI 2 \"nonmemory_operand\" \" Rcqq,  0, C1p, Ccp, Cux, cL,  0,C1p,Ccp,CnL,  I, Lc,C1p,Ccp,CnL,I,Cal,Cal,Cux\")))]\n+  [(set (match_operand:SI 0 \"dest_reg_operand\" \"=Rcqq,Rcq,Rcqq,Rcqq,Rcqq,Rcw,Rcw,Rcw,Rcw,Rcw,Rcw,w,w,w,w,Rrq,w,Rcw,w,W\")\n+\t(and:SI (match_operand:SI 1 \"nonimmediate_operand\" \"%0,Rcq,0,0,Rcqq,0,c,0,0,0,0,c,c,c,c,Rrq,0,0,c,o\")\n+\t\t(match_operand:SI 2 \"nonmemory_operand\" \"Rcqq,0,C1p,Ccp,Cux,cL,0,C1p,Ccp,CnL,I,Lc,C1p,Ccp,CnL,Cbf,I,Cal,Cal,Cux\")))]\n   \"(register_operand (operands[1], SImode)\n     && nonmemory_operand (operands[2], SImode))\n    || (memory_operand (operands[1], SImode)\n        && satisfies_constraint_Cux (operands[2]))\"\n-  \"*\n {\n   switch (which_alternative)\n     {\n-    case 0: case 5: case 10: case 11: case 15: case 16: case 17:\n-      return \\\"and%? %0,%1,%2%&\\\";\n+    case 0: case 5: case 10: case 11: case 16: case 17: case 18:\n+      return \"and%? %0,%1,%2%&\";\n     case 1: case 6:\n-      return \\\"and%? %0,%2,%1%&\\\";\n+      return \"and%? %0,%2,%1%&\";\n     case 2: case 7: case 12:\n-      return \\\"bmsk%? %0,%1,%Z2%&\\\";\n+      return \"bmsk%? %0,%1,%Z2%&\";\n     case 3: case 8: case 13:\n-      return \\\"bclr%? %0,%1,%M2%&\\\";\n+      return \"bclr%? %0,%1,%M2%&\";\n     case 4:\n       return (INTVAL (operands[2]) == 0xff\n-\t      ? \\\"extb%? %0,%1%&\\\" : \\\"ext%_%? %0,%1%&\\\");\n+\t      ? \"extb%? %0,%1%&\" : \"ext%_%? %0,%1%&\");\n     case 9: case 14: return \\\"bic%? %0,%1,%n2-1\\\";\n-    case 18:\n+    case 15:\n+      return \"movb.cl %0,%1,%p2,%p2,%s2\";\n+\n+    case 19:\n+      const char *tmpl;\n+\n+      if (satisfies_constraint_Ucm (operands[1]))\n+\ttmpl = (INTVAL (operands[2]) == 0xff\n+\t\t? \"xldb%U1 %0,%1\" : \"xld%_%U1 %0,%1\");\n+      else\n+\ttmpl = INTVAL (operands[2]) == 0xff ? \"ldb %0,%1\" : \"ld%_ %0,%1\";\n+\n       if (TARGET_BIG_ENDIAN)\n \t{\n \t  rtx xop[2];\n \n \t  xop[0] = operands[0];\n \t  xop[1] = adjust_address (operands[1], QImode,\n \t\t\t\t   INTVAL (operands[2]) == 0xff ? 3 : 2);\n-\t  output_asm_insn (INTVAL (operands[2]) == 0xff\n-\t\t\t   ? \\\"ldb %0,%1\\\" : \\\"ld%_ %0,%1\\\",\n-\t\t\t   xop);\n-\t  return \\\"\\\";\n+\t  output_asm_insn (tmpl, xop);\n+\t  return \"\";\n \t}\n-      return INTVAL (operands[2]) == 0xff ? \\\"ldb %0,%1\\\" : \\\"ld%_ %0,%1\\\";\n+      return tmpl;\n     default:\n       gcc_unreachable ();\n     }\n-}\"\n-  [(set_attr \"iscompact\" \"maybe,maybe,maybe,maybe,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false\")\n-   (set_attr \"type\" \"binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,load\")\n-   (set_attr \"length\" \"*,*,*,*,*,4,4,4,4,4,4,4,4,4,4,4,8,8,*\")\n-   (set_attr \"predicable\" \"no,no,no,no,no,yes,yes,yes,yes,yes,no,no,no,no,no,no,yes,no,no\")\n-   (set_attr \"cond\" \"canuse,canuse,canuse,canuse,nocond,canuse,canuse,canuse,canuse,canuse,canuse_limm,nocond,nocond,nocond,nocond,canuse_limm,canuse,nocond,nocond\")])\n+}\n+  [(set_attr \"iscompact\" \"maybe,maybe,maybe,maybe,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false\")\n+   (set_attr \"type\" \"binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,binary,shift,binary,binary,binary,load\")\n+   (set_attr \"length\" \"*,*,*,*,*,4,4,4,4,4,4,4,4,4,4,4,4,8,8,*\")\n+   (set_attr \"predicable\" \"no,no,no,no,no,yes,yes,yes,yes,yes,no,no,no,no,no,no,no,yes,no,no\")\n+   (set_attr \"cond\" \"canuse,canuse,canuse,canuse,nocond,canuse,canuse,canuse,canuse,canuse,canuse_limm,nocond,nocond,nocond,nocond,nocond,canuse_limm,canuse,nocond,nocond\")])\n \n ; combiner splitter, pattern found in ldtoa.c .\n ; and op3,op0,op1 / cmp op3,op2 -> add op3,op0,op4 / bmsk.f 0,op3,op1\n@@ -5717,7 +5810,6 @@\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"misc\")])\n \n-\n ;; FPU/FPX expands\n \n ;;add\n@@ -5862,6 +5954,196 @@\n    gcc_unreachable ();\n  \")\n \n+(define_expand \"extzv\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\")))]\n+  \"TARGET_NPS_BITOPS\")\n+\n+; We need a sanity check in the instuction predicate because combine\n+; will throw any old rubbish at us and see what sticks.\n+(define_insn \"*extzv_i\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=Rrq\")\n+\t(zero_extract:SI (match_operand:SI 1 \"register_operand\" \"Rrq\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS && INTVAL (operands[2]) + INTVAL (operands[3]) <= 32\"\n+  \"movb.cl %0,%1,0,%3,%2\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_expand \"insv\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t(match_operand:SI 3 \"nonmemory_operand\" \"\"))]\n+  \"TARGET_NPS_BITOPS\"\n+{\n+  int size = INTVAL (operands[1]);\n+\n+  if (size != 1 && size != 2 && size != 4 && size != 8)\n+    operands[3] = force_reg (SImode, operands[3]);\n+})\n+\n+(define_insn \"*insv_i\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+w,Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"C18,n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n,n\"))\n+\t(match_operand:SI 3 \"nonmemory_operand\" \"P,Rrq\"))]\n+  \"TARGET_NPS_BITOPS\n+   && (register_operand (operands[3], SImode)\n+       || satisfies_constraint_C18 (operands[1]))\"\n+  \"@\n+   movbi %0,%0,%3,%2,%1\n+   movb %0,%0,%3,%2,0,%1\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movb\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(zero_extract:SI (match_operand:SI 3 \"register_operand\" \"Rrq\")\n+\t\t\t (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS\"\n+  \"movb %0,%0,%3,%2,%4,%1\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movb_signed\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(sign_extract:SI (match_operand:SI 3 \"register_operand\" \"Rrq\")\n+\t\t\t (match_dup 1)\n+\t\t\t (match_operand:SI 4 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS\"\n+  \"movb %0,%0,%3,%2,%4,%1\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_insn \"*movb_high\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(lshiftrt:SI (match_operand:SI 3 \"register_operand\" \"Rrq\")\n+\t\t     (match_operand:SI 4 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS\n+   && INTVAL (operands[4]) + INTVAL (operands[1]) <= 32\"\n+  \"movb %0,%0,%3,%2,%4,%1\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+; N.B.: when processing signed bitfields that fit in the top half of\n+; a word, gcc will use a narrow sign extending load, and in this case\n+; we will see INTVAL (operands[4]) + INTVAL (operands[1]) == 16 (or 8)\n+(define_insn \"*movb_high_signed\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(ashiftrt:SI (match_operand:SI 3 \"register_operand\" \"Rrq\")\n+\t\t     (match_operand:SI 4 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS\n+   && INTVAL (operands[4]) + INTVAL (operands[1]) <= 32\"\n+  \"movb %0,%0,%3,%2,%4,%1\"\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(ior:SI (ashift:SI (match_operand:SI 1 \"register_operand\" \"\")\n+\t\t\t   (match_operand:SI 2 \"const_int_operand\" \"\"))\n+\t\t(subreg:SI (match_operand 3 \"\") 0)))]\n+  \"TARGET_NPS_BITOPS\n+   && GET_MODE_BITSIZE (GET_MODE (operands[3])) <= INTVAL (operands[2])\n+   && !reg_overlap_mentioned_p (operands[0], operands[1])\"\n+  [(set (match_dup 0) (zero_extend:SI (match_dup 3)))\n+   (set (zero_extract:SI (match_dup 0) (match_dup 4) (match_dup 2))\n+\t(match_dup 1))]\n+  \"operands[4] = GEN_INT (32 - INTVAL (operands[2]));\")\n+\n+(define_insn \"*mrgb\"\n+  [(set (zero_extract:SI (match_operand:SI 0 \"register_operand\" \"+Rrq\")\n+\t\t\t (match_operand:SI 1 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"n\"))\n+\t(zero_extract:SI (match_dup 0) (match_dup 1)\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"n\")))\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (match_operand:SI 4 \"const_int_operand\" \"n\")\n+\t\t\t (match_operand:SI 5 \"const_int_operand\" \"n\"))\n+\t(zero_extract:SI (match_operand:SI 6 \"register_operand\" \"Rrq\")\n+\t\t\t (match_dup 4)\n+\t\t\t (match_operand:SI 7 \"const_int_operand\" \"n\")))]\n+  \"TARGET_NPS_BITOPS\"\n+{\n+  output_asm_insn (\"mrgb %0,%0,%6,%2,%3,%1,%5,%7,%4\", operands);\n+  /* The ;%? updates the known unalignment.  */\n+  return arc_short_long (insn, \";%?\", \"nop_s\");\n+}\n+  [(set_attr \"type\" \"shift\")\n+   (set_attr \"length\" \"6\")\n+   (set_attr \"iscompact\" \"true\")])\n+\n+;; combine fumbles combination of two movb patterns, and then the\n+;; combination is rejected by combinable_i3pat.\n+;; Thus, we can only use a peephole2 to combine two such insns.\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\"))\n+\t(zero_extract:SI (match_dup 1)\n+\t\t\t (match_dup 2)\n+\t\t\t (match_operand:SI 4 \"const_int_operand\" \"\")))\n+   (match_operand 9) ; unrelated insn scheduled here\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (match_operand:SI 5 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 6 \"const_int_operand\" \"\"))\n+\t(zero_extract:SI (match_operand:SI 7 \"register_operand\" \"\")\n+\t\t\t (match_dup 5)\n+\t\t\t (match_operand:SI 8 \"const_int_operand\" \"\")))]\n+  \"TARGET_NPS_BITOPS\n+   // Check that the second movb doesn't clobber an input of the extra insn.\n+   && !reg_overlap_mentioned_p (operands[0], operands[9])\n+   // And vice versa.\n+   && !reg_set_p (operands[0], operands[9])\n+   && !reg_set_p (operands[7], operands[9])\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (parallel [(set (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))\n+\t\t   (zero_extract:SI (match_dup 3) (match_dup 1) (match_dup 4)))\n+\t      (set (zero_extract:SI (match_dup 0) (match_dup 1) (match_dup 2))\n+\t\t   (zero_extract:SI (match_dup 3) (match_dup 1) (match_dup 4)))])\n+   (match_dup 9)])\n+\n+(define_peephole2\n+  [(set (match_operand:SI 0 \"register_operand\" \"\")\n+\t(match_operand:SI 1 \"register_operand\" \"\"))\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (match_operand:SI 2 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 3 \"const_int_operand\" \"\"))\n+\t(zero_extract:SI (match_dup 1)\n+\t\t\t (match_dup 2)\n+\t\t\t (match_operand:SI 4 \"const_int_operand\" \"\")))\n+   (set (match_dup 1) (match_operand 8))\n+   (set (zero_extract:SI (match_dup 0)\n+\t\t\t (match_operand:SI 5 \"const_int_operand\" \"\")\n+\t\t\t (match_operand:SI 6 \"const_int_operand\" \"\"))\n+\t(zero_extract:SI (match_dup 1) (match_dup 5)\n+\t\t\t (match_operand:SI 7 \"const_int_operand\" \"\")))]\n+  \"TARGET_NPS_BITOPS\n+   && !reg_overlap_mentioned_p (operands[0], operands[8])\"\n+  [(set (match_dup 0) (match_dup 1))\n+   (set (match_dup 1) (match_dup 8))\n+   (parallel [(set (zero_extract:SI (match_dup 0) (match_dup 2) (match_dup 3))\n+\t\t   (zero_extract:SI (match_dup 0) (match_dup 2) (match_dup 4)))\n+\t      (set (zero_extract:SI (match_dup 0) (match_dup 5) (match_dup 6))\n+\t\t   (zero_extract:SI (match_dup 1) (match_dup 5) (match_dup 7)))])\n+   (match_dup 1)])\n+\n ;; include the arc-FPX instructions\n (include \"fpx.md\")\n "}, {"sha": "d957a92dd6f0aae86d64981f4a32a8bc37cd01cb", "filename": "gcc/config/arc/arc.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Farc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Farc.opt?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -470,6 +470,10 @@ Specify thread pointer register number\n mtp-regno=none\n Target RejectNegative Var(arc_tp_regno,-1)\n \n+mbitops\n+Target Report Var(TARGET_NPS_BITOPS) Init(TARGET_NPS_BITOPS_DEFAULT)\n+Enable use of NPS400 bit operations.\n+\n mcmem\n Target Report Var(TARGET_NPS_CMEM) Init(TARGET_NPS_CMEM_DEFAULT)\n Enable use of NPS400 xld/xst extension."}, {"sha": "f30572c48579dbdcdcacae1c11ba83e13d15fe29", "filename": "gcc/config/arc/constraints.md", "status": "modified", "additions": 57, "deletions": 1, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Fconstraints.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Fconfig%2Farc%2Fconstraints.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farc%2Fconstraints.md?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -66,10 +66,18 @@\n    Link Registers @code{ilink1}:@code{r29}, @code{ilink2}:@code{r30},\n    @code{blink}:@code{r31},\")\n \n-(define_register_constraint \"q\" \"ARCOMPACT16_REGS\"\n+(define_register_constraint \"q\" \"TARGET_Q_CLASS ? ARCOMPACT16_REGS : NO_REGS\"\n   \"Registers usable in ARCompact 16-bit instructions: @code{r0}-@code{r3},\n    @code{r12}-@code{r15}\")\n \n+; NPS400 bitfield instructions require registers from the r0-r3,r12-r15\n+; range, and thus we need a register class and constraint that works\n+; independently of size optimization.\n+(define_register_constraint\n+ \"Rrq\" \"TARGET_RRQ_CLASS ? ARCOMPACT16_REGS : NO_REGS\"\n+  \"Registers usable in NPS400 bitfield instructions: @code{r0}-@code{r3},\n+   @code{r12}-@code{r15}\")\n+\n (define_register_constraint \"e\" \"AC16_BASE_REGS\"\n   \"Registers usable as base-regs of memory addresses in ARCompact 16-bit memory\n    instructions: @code{r0}-@code{r3}, @code{r12}-@code{r15}, @code{sp}\")\n@@ -236,12 +244,60 @@\n   (and (match_code \"const_int\")\n        (match_test \"ival == 0xff || ival == 0xffff\")))\n \n+(define_constraint \"Chs\"\n+ \"@internal\n+  constant for a highpart that can be checked with a shift (asr.f 0,rn,m)\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IS_POWEROF2_P (-ival)\")))\n+\n+(define_constraint \"Clo\"\n+ \"@internal\n+  constant that fits into 16 lower bits, for movl\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_NPS_BITOPS\")\n+       (match_test \"(ival & ~0xffffU) == 0\")))\n+\n+(define_constraint \"Chi\"\n+ \"@internal\n+  constant that fits into 16 higher bits, for movh_i\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_NPS_BITOPS\")\n+       (match_test \"trunc_int_for_mode (ival >> 16, HImode) << 16 == ival\")))\n+\n+(define_constraint \"Cbf\"\n+ \"@internal\n+  a mask for a bit field, for AND using movb_i\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_NPS_BITOPS\")\n+       (match_test \"IS_POWEROF2_OR_0_P (ival + (ival & -ival))\")))\n+\n+(define_constraint \"Cbn\"\n+ \"@internal\n+  a constant integer, valid only if TARGET_NPS_BITOPS is true\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_NPS_BITOPS\")))\n+\n+(define_constraint \"C18\"\n+ \"@internal\n+  1,2,4 or 8\"\n+  (and (match_code \"const_int\")\n+       (match_test \"ival == 1 || ival == 2 || ival == 4 || ival == 8\")))\n+\n (define_constraint \"Crr\"\n  \"@internal\n   constant that can be loaded with ror b,u6\"\n   (and (match_code \"const_int\")\n        (match_test \"(ival & ~0x8000001f) == 0 && !arc_ccfsm_cond_exec_p ()\")))\n \n+(define_constraint \"Cbi\"\n+ \"@internal\n+  constant that can be loaded with movbi.cl\"\n+  (and (match_code \"const_int\")\n+       (match_test \"TARGET_NPS_BITOPS\")\n+       (match_test \"!ival\n+\t\t    || ((ival & 0xffffffffUL) >> exact_log2 (ival & -ival)\n+\t\t\t<= 0xff)\")))\n+\n ;; Floating-point constraints\n \n (define_constraint \"G\""}, {"sha": "6c44ee953b9cb2f93fe4f57abfda90008b342a1e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -1,3 +1,19 @@\n+2016-04-28  Joern Rennecke  <joern.rennecke@embecosm.com>\n+\t    Andrew Burgess  <andrew.burgess@embecosm.com>\n+\n+\t* gcc.target/arc/extzv-1.c: New file.\n+\t* gcc.target/arc/insv-1.c: New file.\n+\t* gcc.target/arc/insv-2.c: New file.\n+\t* gcc.target/arc/movb-1.c: New file.\n+\t* gcc.target/arc/movb-2.c: New file.\n+\t* gcc.target/arc/movb-3.c: New file.\n+\t* gcc.target/arc/movb-4.c: New file.\n+\t* gcc.target/arc/movb-5.c: New file.\n+\t* gcc.target/arc/movb_cl-1.c: New file.\n+\t* gcc.target/arc/movb_cl-2.c: New file.\n+\t* gcc.target/arc/movbi_cl-1.c: New file.\n+\t* gcc.target/arc/movl-1.c: New file.\n+\n 2016-04-28  Joern Rennecke  <joern.rennecke@embecosm.com>\n \t    Andrew Burgess  <andrew.burgess@embecosm.com>\n "}, {"sha": "242f522f187e155964fd715221f3b6140236e8ea", "filename": "gcc/testsuite/gcc.target/arc/extzv-1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fextzv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fextzv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fextzv-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct foo { unsigned a: 3, b: 5, c: 24; };\n+\n+int\n+f (struct foo i)\n+{\n+  return i.b;\n+}\n+/* { dg-final { scan-assembler \"movb\\.cl\" } } */"}, {"sha": "75d47e9b1b3f79f902a4726cee408ba9e50c378e", "filename": "gcc/testsuite/gcc.target/arc/insv-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+/* ??? Irrespective of insn set, generated code for this is a mess.  */\n+struct foo { unsigned a: 3, b: 8, c: 21; };\n+\n+struct foo\n+f (struct foo i)\n+{\n+  i.b = 42;\n+  return i;\n+}\n+\n+struct foo\n+g (struct foo i, int j)\n+{\n+  i.b = j;\n+  return i;\n+}\n+/* { dg-final { scan-assembler \"movbi\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]\" } } */"}, {"sha": "16525511698c0a3958b597e56960b19e26c0953f", "filename": "gcc/testsuite/gcc.target/arc/insv-2.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Finsv-2.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct foo { unsigned a: 3, b: 8, c: 21; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.b = 42;\n+}\n+\n+void\n+g (int j)\n+{\n+  bar.b = j;\n+}\n+/* { dg-final { scan-assembler \"movbi\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]\" } } */"}, {"sha": "65d4ba4b6ab4d55635b6d26eae0c908e76cab715", "filename": "gcc/testsuite/gcc.target/arc/movb-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct { unsigned a: 5, b: 8, c: 19; } foo;\n+struct { unsigned a: 3, b: 8, c: 21; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.b = foo.b;\n+}\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *5, *3, *8\" { target arceb-*-* } } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *19, *21, *8\" { target arc-*-* } } } */"}, {"sha": "1ba9976a566d7f0cc69e39aa832d0c986f8b40e2", "filename": "gcc/testsuite/gcc.target/arc/movb-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-2.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct { unsigned a: 23, b: 9; } foo;\n+struct { unsigned a: 23, b: 9; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.b = foo.b;\n+}\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *23, *23, *9\" { target arc-*-* } } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *0, *0, *9\" { target arceb-*-* } } } */"}, {"sha": "0895154abb673a47c482500fcde7fdfe00824d80", "filename": "gcc/testsuite/gcc.target/arc/movb-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-3.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct { int a: 23, b: 9; } foo;\n+struct { int a: 23, b: 9; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.a = foo.a;\n+}\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *0, *0, *23\" { target arc-*-* } } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *9, *9, *23\" { target arceb-*-* } } } */"}, {"sha": "89bf2c2b1232d43f0981e10ead10cb4cf49b89f9", "filename": "gcc/testsuite/gcc.target/arc/movb-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-4.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct { int a: 13, b: 19; } foo;\n+struct { int a: 13, b: 19; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.b = foo.b;\n+}\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *13, *13, *19\" { target arc-*-* } } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *0, *0, *19\" { target arceb-*-* } } } */"}, {"sha": "9dbe8a1e09a887a4b0bfb20f61d1a3732b6dc35a", "filename": "gcc/testsuite/gcc.target/arc/movb-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb-5.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+struct { int a: 23, b: 9; } foo;\n+struct { int a: 23, b: 9; } bar;\n+\n+void\n+f (void)\n+{\n+  bar.b = foo.b;\n+}\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *23, *(23|7), *9\" { target arc-*-* } } } */\n+/* { dg-final { scan-assembler \"movb\\[ \\t\\]+r\\[0-5\\]+, *r\\[0-5\\]+, *r\\[0-5\\]+, *0, *0, *9\" { target arceb-*-* } } } */"}, {"sha": "402250ce530238ea1f94790d8ad05a7ee9cbc673", "filename": "gcc/testsuite/gcc.target/arc/movb_cl-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+int\n+f (int i)\n+{\n+  return i & 0x0ffff000;\n+}\n+/* { dg-final { scan-assembler \"movb\\.cl\" } } */"}, {"sha": "d2e5a944a6ea764c351e4edbae144dca6f0de90c", "filename": "gcc/testsuite/gcc.target/arc/movb_cl-2.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovb_cl-2.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,11 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+extern void g (void);\n+int\n+f (int i)\n+{\n+  if (i & 0x0ffff000)\n+    g ();\n+}\n+/* { dg-final { scan-assembler \"movb\\.f\\.cl\" } } */"}, {"sha": "3c457dbe528741f233b1f0482915c0ac56012d3a", "filename": "gcc/testsuite/gcc.target/arc/movbi_cl-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovbi_cl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovbi_cl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovbi_cl-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+int\n+f (int i)\n+{\n+  return 0x6e00;\n+}\n+/* { dg-final { scan-assembler \"mov(bi|l)\\.cl\" } } */"}, {"sha": "f1f0130a2b07a0ac48714aabc8f645444e143135", "filename": "gcc/testsuite/gcc.target/arc/movl-1.c", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovl-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ceaaa9fe93fd5c33028b74eff376aff8321ecfa5/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovl-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farc%2Fmovl-1.c?ref=ceaaa9fe93fd5c33028b74eff376aff8321ecfa5", "patch": "@@ -0,0 +1,17 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-mcpu=nps400 -O2 -mbitops\" } */\n+\n+int\n+f (void)\n+{\n+  return 0xd00d;\n+}\n+\n+int\n+g (void)\n+{\n+  return 0x7ff00000;\n+}\n+\n+/* { dg-final { scan-assembler \"movl\\.cl\\[ \\t\\]\" } } */\n+/* { dg-final { scan-assembler \"movh\\.cl\\[ \\t\\]\" } } */"}]}