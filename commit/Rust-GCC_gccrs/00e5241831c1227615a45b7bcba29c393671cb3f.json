{"sha": "00e5241831c1227615a45b7bcba29c393671cb3f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDBlNTI0MTgzMWMxMjI3NjE1YTQ1YjdiY2JhMjljMzkzNjcxY2IzZg==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2015-11-27T13:57:09Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2015-11-27T13:57:09Z"}, "message": "nvptx-protos.h (nvptx_record_needed_decl): Don't declaree.\n\n\t* config/nvptx/nvptx-protos.h (nvptx_record_needed_decl): Don't\n\tdeclaree.\n\t* config/nvptx/nvptx.c (write_func_decl_from_insn): Move earlier.\n\t(nvptx_record_fndecl): Don't return value, remove force\n\targyment. Require fndecl.\n\t(nvptx_record_libfunc): New.\n\t(nvptx_record_needed_decl): Deteermine how to record decl here.\n\t(nvptx_maybe_record_fnsym): New.\n\t(nvptx_expand_call): Don't record libfuncs here,\n\t(nvptx_maybe_convert_symbolic_operand): Use\n\tnvptx_maye_record_fnsym.\n\t(nvptx_assemble_integer): Reimplement with single switch.\n\t(nvptx_output_call_insn): Register libfuncs here.\n\t(nvptx_file_end): Adjust  nvptx_record_fndecl call.\n\t* config/nvptx/nvptx.md (expand_movdi): Don't call\n\tnvptx_record_needed_decl.\n\nFrom-SVN: r231013", "tree": {"sha": "2f56b0db575f922105988159228e63ec4aad4e9c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2f56b0db575f922105988159228e63ec4aad4e9c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/00e5241831c1227615a45b7bcba29c393671cb3f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e5241831c1227615a45b7bcba29c393671cb3f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/00e5241831c1227615a45b7bcba29c393671cb3f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/00e5241831c1227615a45b7bcba29c393671cb3f/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "f574fc3ac5a136886dbdaf5124326d744f1e06de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f574fc3ac5a136886dbdaf5124326d744f1e06de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f574fc3ac5a136886dbdaf5124326d744f1e06de"}], "stats": {"total": 292, "additions": 150, "deletions": 142}, "files": [{"sha": "ca9635b7f227e95ad746da911f1a7bcb2cf3ad37", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=00e5241831c1227615a45b7bcba29c393671cb3f", "patch": "@@ -1,3 +1,22 @@\n+2015-11-27  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* config/nvptx/nvptx-protos.h (nvptx_record_needed_decl): Don't\n+\tdeclaree.\n+\t* config/nvptx/nvptx.c (write_func_decl_from_insn): Move earlier.\n+\t(nvptx_record_fndecl): Don't return value, remove force\n+\targyment. Require fndecl.\n+\t(nvptx_record_libfunc): New.\n+\t(nvptx_record_needed_decl): Deteermine how to record decl here.\n+\t(nvptx_maybe_record_fnsym): New.\n+\t(nvptx_expand_call): Don't record libfuncs here,\n+\t(nvptx_maybe_convert_symbolic_operand): Use\n+\tnvptx_maye_record_fnsym.\n+\t(nvptx_assemble_integer): Reimplement with single switch.\n+\t(nvptx_output_call_insn): Register libfuncs here.\n+\t(nvptx_file_end): Adjust  nvptx_record_fndecl call.\n+\t* config/nvptx/nvptx.md (expand_movdi): Don't call\n+\tnvptx_record_needed_decl.\n+\n 2015-11-27  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/68553"}, {"sha": "a2d8f9763efa599253653bc5de6685b15e44011d", "filename": "gcc/config/nvptx/nvptx-protos.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx-protos.h?ref=00e5241831c1227615a45b7bcba29c393671cb3f", "patch": "@@ -24,7 +24,6 @@\n extern void nvptx_declare_function_name (FILE *, const char *, const_tree decl);\n extern void nvptx_declare_object_name (FILE *file, const char *name,\n \t\t\t\t       const_tree decl);\n-extern void nvptx_record_needed_fndecl (tree decl);\n extern void nvptx_function_end (FILE *);\n extern void nvptx_output_skip (FILE *, unsigned HOST_WIDE_INT);\n extern void nvptx_output_ascii (FILE *, const char *, unsigned HOST_WIDE_INT);"}, {"sha": "530ed7a0220998c4a1008f150526ff6991a56b7d", "filename": "gcc/config/nvptx/nvptx.c", "status": "modified", "additions": 131, "deletions": 139, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.c?ref=00e5241831c1227615a45b7bcba29c393671cb3f", "patch": "@@ -452,6 +452,55 @@ write_function_decl_and_comment (std::stringstream &s, const char *name, const_t\n   s << \";\\n\";\n }\n \n+/* Construct a function declaration from a call insn.  This can be\n+   necessary for two reasons - either we have an indirect call which\n+   requires a .callprototype declaration, or we have a libcall\n+   generated by emit_library_call for which no decl exists.  */\n+\n+static void\n+write_func_decl_from_insn (std::stringstream &s, const char *name,\n+\t\t\t   rtx result, rtx pat)\n+{\n+  if (!name)\n+    {\n+      s << \"\\t.callprototype \";\n+      name = \"_\";\n+    }\n+  else\n+    {\n+      s << \"\\n// BEGIN GLOBAL FUNCTION DECL: \" << name << \"\\n\";\n+      s << \"\\t.extern .func \";\n+    }\n+\n+  if (result != NULL_RTX)\n+    s << \"(.param\"\n+      << nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)), false)\n+      << \" %rval) \";\n+\n+  s << name;\n+\n+  const char *sep = \" (\";\n+  int arg_end = XVECLEN (pat, 0);\n+  for (int i = 1; i < arg_end; i++)\n+    {\n+      /* We don't have to deal with mode splitting here, as that was\n+\t already done when generating the call sequence.  */\n+      machine_mode mode = GET_MODE (XEXP (XVECEXP (pat, 0, i), 0));\n+\n+      s << sep\n+\t<< \".param\"\n+\t<< nvptx_ptx_type_from_mode (mode, false)\n+\t<< \" %arg\"\n+\t<< i;\n+      if (mode == QImode || mode == HImode)\n+\ts << \"[1]\";\n+      sep = \", \";\n+    }\n+  if (arg_end != 1)\n+    s << \")\";\n+  s << \";\\n\";\n+}\n+\n /* Check NAME for special function names and redirect them by returning a\n    replacement.  This applies to malloc, free and realloc, for which we\n    want to use libgcc wrappers, and call, which triggers a bug in ptxas.  */\n@@ -470,20 +519,13 @@ nvptx_name_replacement (const char *name)\n   return name;\n }\n \n-/* If DECL is a FUNCTION_DECL, check the hash table to see if we\n-   already encountered it, and if not, insert it and write a ptx\n-   declarations that will be output at the end of compilation.  */\n+/* DECL is an external FUNCTION_DECL, make sure its in the fndecl hash\n+   table and and write a ptx prototype.  These are emitted at end of\n+   compilation.  */\n \n-static bool\n-nvptx_record_fndecl (tree decl, bool force = false)\n+static void\n+nvptx_record_fndecl (tree decl)\n {\n-  if (decl == NULL_TREE || TREE_CODE (decl) != FUNCTION_DECL\n-      || !DECL_EXTERNAL (decl))\n-    return true;\n-\n-  if (!force && TYPE_ARG_TYPES (TREE_TYPE (decl)) == NULL_TREE)\n-    return false;\n-\n   tree *slot = declared_fndecls_htab->find_slot (decl, INSERT);\n   if (*slot == NULL)\n     {\n@@ -492,22 +534,53 @@ nvptx_record_fndecl (tree decl, bool force = false)\n       name = nvptx_name_replacement (name);\n       write_function_decl_and_comment (func_decls, name, decl);\n     }\n-  return true;\n }\n \n-/* Record that we need to emit a ptx decl for DECL.  Either do it now, or\n-   record it for later in case we have no argument information at this\n-   point.  */\n+/* Record a libcall or unprototyped external function. CALLEE is the\n+   SYMBOL_REF.  Insert into the libfunc hash table and emit a ptx\n+   declaration for it.  */\n+\n+static void\n+nvptx_record_libfunc (rtx callee, rtx retval, rtx pat)\n+{\n+  rtx *slot = declared_libfuncs_htab->find_slot (callee, INSERT);\n+  if (*slot == NULL)\n+    {\n+      *slot = callee;\n+\n+      const char *name = XSTR (callee, 0);\n+      name = nvptx_name_replacement (name);\n+      write_func_decl_from_insn (func_decls, name, retval, pat);\n+    }\n+}\n+\n+/* DECL is an external FUNCTION_DECL, that we're referencing.  If it\n+   is prototyped, record it now.  Otherwise record it as needed at end\n+   of compilation, when we might have more information about it.  */\n \n void\n nvptx_record_needed_fndecl (tree decl)\n {\n-  if (nvptx_record_fndecl (decl))\n-    return;\n+  if (TYPE_ARG_TYPES (TREE_TYPE (decl)) == NULL_TREE)\n+    {\n+      tree *slot = needed_fndecls_htab->find_slot (decl, INSERT);\n+      if (*slot == NULL)\n+\t*slot = decl;\n+    }\n+  else\n+    nvptx_record_fndecl (decl);\n+}\n \n-  tree *slot = needed_fndecls_htab->find_slot (decl, INSERT);\n-  if (*slot == NULL)\n-    *slot = decl;\n+/* SYM is a SYMBOL_REF.  If it refers to an external function, record\n+   it as needed.  */\n+\n+static void\n+nvptx_maybe_record_fnsym (rtx sym)\n+{\n+  tree decl = SYMBOL_REF_DECL (sym);\n+  \n+  if (decl && TREE_CODE (decl) == FUNCTION_DECL && DECL_EXTERNAL (decl))\n+    nvptx_record_needed_fndecl (decl);\n }\n \n /* Emit code to initialize the REGNO predicate register to indicate\n@@ -713,55 +786,6 @@ nvptx_output_return (void)\n   return \"ret;\";\n }\n \n-/* Construct a function declaration from a call insn.  This can be\n-   necessary for two reasons - either we have an indirect call which\n-   requires a .callprototype declaration, or we have a libcall\n-   generated by emit_library_call for which no decl exists.  */\n-\n-static void\n-write_func_decl_from_insn (std::stringstream &s, const char *name,\n-\t\t\t   rtx result, rtx pat)\n-{\n-  if (!name)\n-    {\n-      s << \"\\t.callprototype \";\n-      name = \"_\";\n-    }\n-  else\n-    {\n-      s << \"\\n// BEGIN GLOBAL FUNCTION DECL: \" << name << \"\\n\";\n-      s << \"\\t.extern .func \";\n-    }\n-\n-  if (result != NULL_RTX)\n-    s << \"(.param\"\n-      << nvptx_ptx_type_from_mode (arg_promotion (GET_MODE (result)), false)\n-      << \" %rval) \";\n-\n-  s << name;\n-\n-  const char *sep = \" (\";\n-  int arg_end = XVECLEN (pat, 0);\n-  for (int i = 1; i < arg_end; i++)\n-    {\n-      /* We don't have to deal with mode splitting here, as that was\n-\t already done when generating the call sequence.  */\n-      machine_mode mode = GET_MODE (XEXP (XVECEXP (pat, 0, i), 0));\n-\n-      s << sep\n-\t<< \".param\"\n-\t<< nvptx_ptx_type_from_mode (mode, false)\n-\t<< \" %arg\"\n-\t<< i;\n-      if (mode == QImode || mode == HImode)\n-\ts << \"[1]\";\n-      sep = \", \";\n-    }\n-  if (arg_end != 1)\n-    s << \")\";\n-  s << \";\\n\";\n-}\n-\n /* Terminate a function by writing a closing brace to FILE.  */\n \n void\n@@ -830,9 +854,7 @@ nvptx_expand_call (rtx retval, rtx address)\n   rtx callee = XEXP (address, 0);\n   rtx pat, t;\n   rtvec vec;\n-  bool external_decl = false;\n   rtx varargs = NULL_RTX;\n-  tree decl_type = NULL_TREE;\n   unsigned parallel = 0;\n \n   for (t = cfun->machine->call_args; t; t = XEXP (t, 1))\n@@ -849,11 +871,9 @@ nvptx_expand_call (rtx retval, rtx address)\n       tree decl = SYMBOL_REF_DECL (callee);\n       if (decl != NULL_TREE)\n \t{\n-\t  decl_type = TREE_TYPE (decl);\n \t  if (DECL_STATIC_CHAIN (decl))\n \t    cfun->machine->has_call_with_sc = true;\n-\t  if (DECL_EXTERNAL (decl))\n-\t    external_decl = true;\n+\n \t  tree attr = get_oacc_fn_attrib (decl);\n \t  if (attr)\n \t    {\n@@ -913,26 +933,6 @@ nvptx_expand_call (rtx retval, rtx address)\n \n   gcc_assert (vec_pos = XVECLEN (pat, 0));\n \n-  /* If this is a libcall, decl_type is NULL. For a call to a non-libcall\n-     undeclared function, we'll have an external decl without arg types.\n-     In either case we have to try to construct a ptx declaration from one of\n-     the calls to the function.  */\n-  if (!REG_P (callee)\n-      && (decl_type == NULL_TREE\n-\t  || (external_decl && TYPE_ARG_TYPES (decl_type) == NULL_TREE)))\n-    {\n-      rtx *slot = declared_libfuncs_htab->find_slot (callee, INSERT);\n-      if (*slot == NULL)\n-\t{\n-\t  *slot = callee;\n-\n-\t  const char *name = XSTR (callee, 0);\n-\t  if (decl_type)\n-\t    name = nvptx_name_replacement (name);\n-\t  write_func_decl_from_insn (func_decls, name, retval, pat);\n-\t}\n-    }\n-\n   nvptx_emit_forking (parallel, true);\n   emit_call_insn (pat);\n   nvptx_emit_joining (parallel, true);\n@@ -1354,10 +1354,9 @@ nvptx_gen_wcast (rtx reg, propagate_mask pm, unsigned rep, wcast_data_t *data)\n }\n \n /* When loading an operand ORIG_OP, verify whether an address space\n-   conversion to generic is required, and if so, perform it.  Also\n-   check for SYMBOL_REFs for function decls and call\n-   nvptx_record_needed_fndecl as needed.\n-   Return either the original operand, or the converted one.  */\n+   conversion to generic is required, and if so, perform it.  Check\n+   for SYMBOL_REFs and record them if needed.  Return either the\n+   original operand, or the converted one.  */\n \n rtx\n nvptx_maybe_convert_symbolic_operand (rtx orig_op)\n@@ -1371,13 +1370,8 @@ nvptx_maybe_convert_symbolic_operand (rtx orig_op)\n   if (GET_CODE (op) != SYMBOL_REF)\n     return orig_op;\n \n-  tree decl = SYMBOL_REF_DECL (op);\n-  if (decl && TREE_CODE (decl) == FUNCTION_DECL)\n-    {\n-      nvptx_record_needed_fndecl (decl);\n-      return orig_op;\n-    }\n-\n+  nvptx_maybe_record_fnsym (op);\n+  \n   addr_space_t as = nvptx_addr_space_from_address (op);\n   if (as == ADDR_SPACE_GENERIC)\n     return orig_op;\n@@ -1570,48 +1564,43 @@ nvptx_assemble_value (HOST_WIDE_INT val, unsigned int size)\n static bool\n nvptx_assemble_integer (rtx x, unsigned int size, int ARG_UNUSED (aligned_p))\n {\n-  if (GET_CODE (x) == SYMBOL_REF || GET_CODE (x) == CONST)\n+  HOST_WIDE_INT val = 0;\n+\n+  switch (GET_CODE (x))\n     {\n+    default:\n+      gcc_unreachable ();\n+\n+    case CONST_INT:\n+      val = INTVAL (x);\n+      nvptx_assemble_value (val, size);\n+      break;\n+\n+    case CONST:\n+      x = XEXP (x, 0);\n+      gcc_assert (GET_CODE (x) == PLUS);\n+      val = INTVAL (XEXP (x, 1));\n+      x = XEXP (x, 0);\n+      gcc_assert (GET_CODE (x) == SYMBOL_REF);\n+      /* FALLTHROUGH */\n+\n+    case SYMBOL_REF:\n       gcc_assert (size = decl_chunk_size);\n       if (decl_offset % decl_chunk_size != 0)\n \tsorry (\"cannot emit unaligned pointers in ptx assembly\");\n       decl_offset += size;\n       begin_decl_field ();\n \n-      HOST_WIDE_INT off = 0;\n-      if (GET_CODE (x) == CONST)\n-\tx = XEXP (x, 0);\n-      if (GET_CODE (x) == PLUS)\n-\t{\n-\t  off = INTVAL (XEXP (x, 1));\n-\t  x = XEXP (x, 0);\n-\t}\n-      if (GET_CODE (x) == SYMBOL_REF)\n-\t{\n-\t  nvptx_record_needed_fndecl (SYMBOL_REF_DECL (x));\n-\t  fprintf (asm_out_file, \"generic(\");\n-\t  output_address (VOIDmode, x);\n-\t  fprintf (asm_out_file, \")\");\n-\t}\n-      if (off != 0)\n-\tfprintf (asm_out_file, \" + \" HOST_WIDE_INT_PRINT_DEC, off);\n-      return true;\n-    }\n+      nvptx_maybe_record_fnsym (x);\n+      fprintf (asm_out_file, \"generic(\");\n+      output_address (VOIDmode, x);\n+      fprintf (asm_out_file, \")\");\n \n-  HOST_WIDE_INT val;\n-  switch (GET_CODE (x))\n-    {\n-    case CONST_INT:\n-      val = INTVAL (x);\n-      break;\n-    case CONST_DOUBLE:\n-      gcc_unreachable ();\n+      if (val)\n+\tfprintf (asm_out_file, \" + \" HOST_WIDE_INT_PRINT_DEC, val);\n       break;\n-    default:\n-      gcc_unreachable ();\n     }\n \n-  nvptx_assemble_value (val, size);\n   return true;\n }\n \n@@ -1793,7 +1782,10 @@ nvptx_output_call_insn (rtx_insn *insn, rtx result, rtx callee)\n   if (GET_CODE (callee) == SYMBOL_REF)\n     {\n       decl = SYMBOL_REF_DECL (callee);\n-      if (decl && DECL_EXTERNAL (decl))\n+      if (!decl\n+\t  || (DECL_EXTERNAL (decl) && !TYPE_ARG_TYPES (TREE_TYPE (decl))))\n+\tnvptx_record_libfunc (callee, result, pat);\n+      else if (DECL_EXTERNAL (decl))\n \tnvptx_record_fndecl (decl);\n     }\n \n@@ -3889,7 +3881,7 @@ nvptx_file_end (void)\n   hash_table<tree_hasher>::iterator iter;\n   tree decl;\n   FOR_EACH_HASH_TABLE_ELEMENT (*needed_fndecls_htab, decl, tree, iter)\n-    nvptx_record_fndecl (decl, true);\n+    nvptx_record_fndecl (decl);\n   fputs (func_decls.str().c_str(), asm_out_file);\n \n   if (worker_bcast_size)"}, {"sha": "8d7535a622a6c0456065883bd0f5f8c9f0ae7986", "filename": "gcc/config/nvptx/nvptx.md", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/00e5241831c1227615a45b7bcba29c393671cb3f/gcc%2Fconfig%2Fnvptx%2Fnvptx.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fnvptx%2Fnvptx.md?ref=00e5241831c1227615a45b7bcba29c393671cb3f", "patch": "@@ -391,8 +391,6 @@\n       emit_move_insn (operands[0], tmp);\n       DONE;\n     }\n-  if (GET_CODE (operands[1]) == SYMBOL_REF)\n-    nvptx_record_needed_fndecl (SYMBOL_REF_DECL (operands[1]));\n })\n \n (define_insn \"highpartscsf2\""}]}