{"sha": "59a23beb9e71a0259b076693dd1e551500c08f24", "node_id": "C_kwDOANBUbNoAKDU5YTIzYmViOWU3MWEwMjU5YjA3NjY5M2RkMWU1NTE1MDBjMDhmMjQ", "commit": {"author": {"name": "Piotr Trojanek", "email": "trojanek@adacore.com", "date": "2022-07-31T20:11:30Z"}, "committer": {"name": "Marc Poulhi\u00e8s", "email": "poulhies@adacore.com", "date": "2022-09-05T07:21:07Z"}, "message": "[Ada] Fix inconsistent building of itypes for null array aggregates\n\nTo analyze Ada 2022 null array aggregates we introduced a dedicated\nroutine and bypassed the code for ordinary array aggregates. However,\nthe types for the array indexes created by this dedicated routine\ndiffered from the types created for ordinary array aggregates, i.e.\nitypes for null array aggregates were associated with the array subtype\ndeclaration, while itypes for ordinary array aggregates were associated\nwith the aggregate itself. These differences cause trouble for various\nroutines in GNATprove.\n\nThis patch reduces the special handling of null array aggregates and\nreuses the building of itypes for ordinary array aggregates.\n\ngcc/ada/\n\n\t* sem_aggr.adb\n\t(Array_Aggr_Subtype): Bypass call to Collect_Aggr_Bound with\n\tdedicated code for null array aggregates.\n\t(Resolve_Array_Aggregate): Remove special handling of null array\n\taggregates.\n\t(Resolve_Array_Aggregate): Create bounds, but let\n\tArray_Aggr_Subtype create itype entities.", "tree": {"sha": "de6bb6a37991d0562155dc2dd7904af5ef90f35f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/de6bb6a37991d0562155dc2dd7904af5ef90f35f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/59a23beb9e71a0259b076693dd1e551500c08f24", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a23beb9e71a0259b076693dd1e551500c08f24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/59a23beb9e71a0259b076693dd1e551500c08f24", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/59a23beb9e71a0259b076693dd1e551500c08f24/comments", "author": {"login": "ptroja", "id": 161602, "node_id": "MDQ6VXNlcjE2MTYwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/161602?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ptroja", "html_url": "https://github.com/ptroja", "followers_url": "https://api.github.com/users/ptroja/followers", "following_url": "https://api.github.com/users/ptroja/following{/other_user}", "gists_url": "https://api.github.com/users/ptroja/gists{/gist_id}", "starred_url": "https://api.github.com/users/ptroja/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ptroja/subscriptions", "organizations_url": "https://api.github.com/users/ptroja/orgs", "repos_url": "https://api.github.com/users/ptroja/repos", "events_url": "https://api.github.com/users/ptroja/events{/privacy}", "received_events_url": "https://api.github.com/users/ptroja/received_events", "type": "User", "site_admin": false}, "committer": {"login": "dkm", "id": 87603, "node_id": "MDQ6VXNlcjg3NjAz", "avatar_url": "https://avatars.githubusercontent.com/u/87603?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dkm", "html_url": "https://github.com/dkm", "followers_url": "https://api.github.com/users/dkm/followers", "following_url": "https://api.github.com/users/dkm/following{/other_user}", "gists_url": "https://api.github.com/users/dkm/gists{/gist_id}", "starred_url": "https://api.github.com/users/dkm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dkm/subscriptions", "organizations_url": "https://api.github.com/users/dkm/orgs", "repos_url": "https://api.github.com/users/dkm/repos", "events_url": "https://api.github.com/users/dkm/events{/privacy}", "received_events_url": "https://api.github.com/users/dkm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b26be61b8d23cc9d7a4e36feeadd9c8f0ec8b909", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b26be61b8d23cc9d7a4e36feeadd9c8f0ec8b909", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b26be61b8d23cc9d7a4e36feeadd9c8f0ec8b909"}], "stats": {"total": 54, "additions": 31, "deletions": 23}, "files": [{"sha": "8da4f8081b26eba6c61b334f1ae9656a43634d82", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 31, "deletions": 23, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/59a23beb9e71a0259b076693dd1e551500c08f24/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/59a23beb9e71a0259b076693dd1e551500c08f24/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=59a23beb9e71a0259b076693dd1e551500c08f24", "patch": "@@ -567,7 +567,29 @@ package body Sem_Aggr is\n       end if;\n \n       Set_Parent (Index_Constraints, N);\n-      Collect_Aggr_Bounds (N, 1);\n+\n+      --  When resolving a null aggregate we created a list of aggregate bounds\n+      --  for the consecutive dimensions. The bounds for the first dimension\n+      --  are attached as the Aggregate_Bounds of the aggregate node.\n+\n+      if Is_Null_Aggregate (N) then\n+         declare\n+            This_Range : Node_Id := Aggregate_Bounds (N);\n+         begin\n+            for J in 1 .. Aggr_Dimension loop\n+               Aggr_Range (J) := This_Range;\n+               Next_Index (This_Range);\n+\n+               --  Remove bounds from the list, so they can be reattached as\n+               --  the First_Index/Next_Index again by the code that also\n+               --  handles non-null aggregates.\n+\n+               Remove (Aggr_Range (J));\n+            end loop;\n+         end;\n+      else\n+         Collect_Aggr_Bounds (N, 1);\n+      end if;\n \n       --  Build the list of constrained indexes of our aggregate itype\n \n@@ -1203,9 +1225,6 @@ package body Sem_Aggr is\n \n                Aggr_Subtyp := Any_Composite;\n \n-            elsif Is_Null_Aggr then\n-               Aggr_Subtyp := Etype (N);\n-\n             else\n                Aggr_Subtyp := Array_Aggr_Subtype (N, Typ);\n             end if;\n@@ -4084,16 +4103,16 @@ package body Sem_Aggr is\n       Typ    : constant Entity_Id := Etype (N);\n \n       Check  : Node_Id;\n-      Decl   : Node_Id;\n       Index  : Node_Id;\n       Lo, Hi : Node_Id;\n       Constr : constant List_Id := New_List;\n-      Subt   : constant Entity_Id :=\n-        Create_Itype (Ekind       => E_Array_Subtype,\n-                      Related_Nod => N,\n-                      Suffix      => 'S');\n \n    begin\n+      --  Attach the list of constraints at the location of the aggregate, so\n+      --  the individual constraints can be analyzed.\n+\n+      Set_Parent (Constr, N);\n+\n       --  Create a constrained subtype with null dimensions\n \n       Index := First_Index (Typ);\n@@ -4120,25 +4139,14 @@ package body Sem_Aggr is\n \n          Insert_Action (N, Check);\n \n-         Append (Make_Range (Loc, Lo, Hi), Constr);\n+         Append (Make_Range (Loc, New_Copy_Tree (Lo), Hi), Constr);\n+         Analyze_And_Resolve (Last (Constr), Etype (Index));\n \n          Index := Next_Index (Index);\n       end loop;\n \n-      Decl := Make_Subtype_Declaration (Loc,\n-                Defining_Identifier => Subt,\n-                Subtype_Indication  =>\n-                  Make_Subtype_Indication (Loc,\n-                    Subtype_Mark =>\n-                      New_Occurrence_Of (Base_Type (Typ), Loc),\n-                    Constraint =>\n-                      Make_Index_Or_Discriminant_Constraint (Loc, Constr)));\n-\n-      Insert_Action (N, Decl);\n-      Analyze (Decl);\n-      Set_Etype (N, Subt);\n       Set_Compile_Time_Known_Aggregate (N);\n-      Set_Aggregate_Bounds (N, New_Copy_Tree (First_Index (Etype (N))));\n+      Set_Aggregate_Bounds (N, First (Constr));\n \n       return True;\n    end Resolve_Null_Array_Aggregate;"}]}