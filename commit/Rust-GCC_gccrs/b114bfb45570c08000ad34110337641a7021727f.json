{"sha": "b114bfb45570c08000ad34110337641a7021727f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjExNGJmYjQ1NTcwYzA4MDAwYWQzNDExMDMzNzY0MWE3MDIxNzI3Zg==", "commit": {"author": {"name": "Zhenqiang Chen", "email": "zhenqiang.chen@arm.com", "date": "2013-10-15T17:48:44Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2013-10-15T17:48:44Z"}, "message": "tree-ssa-reassoc.c: Include rtl.h and tm_p.h.\n\n\t* tree-ssa-reassoc.c: Include rtl.h and tm_p.h.\n\t(optimize_range_tests_1): New function,\n\textracted from optimize_range_tests.\n\t(optimize_range_tests_xor): Similarly.\n\t(optimize_range_tests_diff): New function.\n\t(optimize_range_tests): Use optimize_range_tests_1.\n\n\t* gcc.dg/tree-ssa/reassoc-32.c: New test case.\n\t* gcc.dg/tree-ssa/reassoc-33.c: New test case.\n\t* gcc.dg/tree-ssa/reassoc-34.c: New test case.\n\t* gcc.dg/tree-ssa/reassoc-35.c: New test case.\n\t* gcc.dg/tree-ssa/reassoc-36.c: New test case.\n\nFrom-SVN: r203627", "tree": {"sha": "eaac3bb1da94acebdb800a0ac1c3087cc892c98b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eaac3bb1da94acebdb800a0ac1c3087cc892c98b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b114bfb45570c08000ad34110337641a7021727f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b114bfb45570c08000ad34110337641a7021727f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b114bfb45570c08000ad34110337641a7021727f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b114bfb45570c08000ad34110337641a7021727f/comments", "author": null, "committer": null, "parents": [{"sha": "69b8f2f943c302fcf0623d6b78d367d95d5450fd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b8f2f943c302fcf0623d6b78d367d95d5450fd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b8f2f943c302fcf0623d6b78d367d95d5450fd"}], "stats": {"total": 370, "additions": 301, "deletions": 69}, "files": [{"sha": "dd10a5fc8663c1ca10d5ee92eda7e3bb0e38c24b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -1,3 +1,12 @@\n+2013-10-15  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n+\n+\t* tree-ssa-reassoc.c: Include rtl.h and tm_p.h.\n+\t(optimize_range_tests_1): New function,\n+\textracted from optimize_range_tests.\n+\t(optimize_range_tests_xor): Similarly.\n+\t(optimize_range_tests_diff): New function.\n+\t(optimize_range_tests): Use optimize_range_tests_1.\n+\n 2013-10-15  Cong Hou  <congh@google.com>\n \n \t* tree-vect-loop.c (vect_is_simple_reduction_1): Relax the "}, {"sha": "d59cc4f5ad7724d223cda74123d05f719ac07b09", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -1,3 +1,11 @@\n+2013-10-15  Zhenqiang Chen  <zhenqiang.chen@arm.com>\n+\n+\t* gcc.dg/tree-ssa/reassoc-32.c: New test case.\n+\t* gcc.dg/tree-ssa/reassoc-33.c: New test case.\n+\t* gcc.dg/tree-ssa/reassoc-34.c: New test case.\n+\t* gcc.dg/tree-ssa/reassoc-35.c: New test case.\n+\t* gcc.dg/tree-ssa/reassoc-36.c: New test case.\n+\n 2013-10-15  Cong Hou  <congh@google.com>\n \n \t* gcc.dg/vect/vect-reduc-pattern-3.c: New test."}, {"sha": "303b3f32bd9f355058fab8580a25a5a6ca29dd34", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-32.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-32.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* picochip*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n+\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target avr-*-* } } */\n+\n+\n+int test (int a, int b, int c)\n+{\n+  if ( a == 10 || a == 12 || a == 26)\n+    return b;\n+  else\n+    return c;\n+}\n+\n+int main ()\n+{\n+  if (test (10, 20, 30) != 20)\n+    __builtin_abort ();\n+  if (test (12, 20, 30) != 20)\n+    __builtin_abort ();\n+  if (test (26, 20, 30) != 20)\n+    __builtin_abort ();\n+  if (test (30, 20, 30) != 30)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests .* 26\" 1 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "bb27daa8c14efda87099fe141afb513e53bada7a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-33.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-33.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-33.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-33.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -0,0 +1,27 @@\n+/* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* picochip*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n+\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target avr-*-* } } */\n+\n+int test (int a, int b, int c)\n+{\n+  if (a == 43 || a == 75 || a == 44 || a == 78\n+      || a == 77 || a == 46 || a == 76 || a == 45)\n+    return b;\n+  else\n+    return c;\n+}\n+\n+int\n+main ()\n+{\n+  volatile int n43, n47, n75, n79;\n+  n43 = 43; n47 = n43 + 4; n75 = 75; n79 = n75 + 4;\n+  int i;\n+  for (i = -10; i <= 100; i++)\n+    if (test (i, 2, 3) != 3 - ((i >= n43 && i < n47) || (i >= n75 && i < n79)))\n+      __builtin_abort ();\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests\" 3 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "156e18242222e9bca970600306ee5e1ea25c84ad", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-34.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-34.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-34.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-34.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* picochip*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n+\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target avr-*-* } } */\n+\n+int test (int a, int b, int c)\n+{\n+  if (a == 10 || a == 12)\n+    return b;\n+  else\n+    return c;\n+}\n+int main ()\n+{\n+  if (test (10, 20, 30) != 20)\n+    __builtin_abort ();\n+  if (test (12, 20, 30) != 20)\n+    __builtin_abort ();\n+  if (test (26, 20, 30) != 30)\n+    __builtin_abort ();\n+  return 0;\n+}\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests\" 1 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "c486b783dce250b2936e05a245b9a9daf23af159", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-35.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-35.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-35.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-35.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* picochip*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n+\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target avr-*-* } } */\n+\n+int test (unsigned int a, int b, int c)\n+{\n+  if ((a - 43) <= 3 || (a - 75) <= 3)\n+    return b;\n+  else\n+    return c;\n+}\n+int\n+main ()\n+{\n+  volatile int n43, n47, n75, n79;\n+  n43 = 43; n47 = n43 + 4; n75 = 75; n79 = n75 + 4;\n+  int i;\n+  for (i = -10; i <= 100; i++)\n+    if (test (i, 2, 3) != 3 - ((i >= n43 && i < n47) || (i >= n75 && i < n79)))\n+      __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests\" 1 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "930dbe289fb469fe908a6abdac91991e7e4f7bf3", "filename": "gcc/testsuite/gcc.dg/tree-ssa/reassoc-36.c", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Freassoc-36.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -0,0 +1,25 @@\n+/* { dg-do run { target { ! \"m68k*-*-* mmix*-*-* mep*-*-* bfin*-*-* v850*-*-* picochip*-*-* moxie*-*-* cris*-*-* m32c*-*-* fr30*-*-* mcore*-*-* powerpc*-*-* xtensa*-*-*\"} } } */\n+\n+/* { dg-options \"-O2 -fno-inline -fdump-tree-reassoc1-details\" } */\n+/* { dg-additional-options \"-mbranch-cost=2\" { target avr-*-* } } */\n+\n+int test (int a, int b, int c)\n+{\n+  if (a != 10 && a != 12)\n+    return b;\n+  else\n+    return c;\n+}\n+int main ()\n+{\n+  if (test (10, 20, 30) != 30)\n+    __builtin_abort ();\n+  if (test (12, 20, 30) != 30)\n+    __builtin_abort ();\n+  if (test (26, 20, 30) != 20)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Optimizing range tests\" 1 \"reassoc1\"} }*/\n+/* { dg-final { cleanup-tree-dump \"reassoc1\" } } */"}, {"sha": "17541c643d2d9784e04b794f17304b0de7f0c4b5", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 153, "deletions": 69, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b114bfb45570c08000ad34110337641a7021727f/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=b114bfb45570c08000ad34110337641a7021727f", "patch": "@@ -23,6 +23,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"coretypes.h\"\n #include \"hash-table.h\"\n #include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n #include \"tree.h\"\n #include \"basic-block.h\"\n #include \"gimple-pretty-print.h\"\n@@ -2131,6 +2133,152 @@ update_range_test (struct range_entry *range, struct range_entry *otherrange,\n   return true;\n }\n \n+/* Optimize X == CST1 || X == CST2\n+   if popcount (CST1 ^ CST2) == 1 into\n+   (X & ~(CST1 ^ CST2)) == (CST1 & ~(CST1 ^ CST2)).\n+   Similarly for ranges.  E.g.\n+   X != 2 && X != 3 && X != 10 && X != 11\n+   will be transformed by the previous optimization into\n+   !((X - 2U) <= 1U || (X - 10U) <= 1U)\n+   and this loop can transform that into\n+   !(((X & ~8) - 2U) <= 1U).  */\n+\n+static bool\n+optimize_range_tests_xor (enum tree_code opcode, tree type,\n+\t\t\t  tree lowi, tree lowj, tree highi, tree highj,\n+\t\t\t  vec<operand_entry_t> *ops,\n+\t\t\t  struct range_entry *rangei,\n+\t\t\t  struct range_entry *rangej)\n+{\n+  tree lowxor, highxor, tem, exp;\n+  /* Check highi ^ lowi == highj ^ lowj and\n+     popcount (highi ^ lowi) == 1.  */\n+  lowxor = fold_binary (BIT_XOR_EXPR, type, lowi, lowj);\n+  if (lowxor == NULL_TREE || TREE_CODE (lowxor) != INTEGER_CST)\n+    return false;\n+  if (tree_log2 (lowxor) < 0)\n+    return false;\n+  highxor = fold_binary (BIT_XOR_EXPR, type, highi, highj);\n+  if (!tree_int_cst_equal (lowxor, highxor))\n+    return false;\n+\n+  tem = fold_build1 (BIT_NOT_EXPR, type, lowxor);\n+  exp = fold_build2 (BIT_AND_EXPR, type, rangei->exp, tem);\n+  lowj = fold_build2 (BIT_AND_EXPR, type, lowi, tem);\n+  highj = fold_build2 (BIT_AND_EXPR, type, highi, tem);\n+  if (update_range_test (rangei, rangej, 1, opcode, ops, exp,\n+\t\t\t rangei->in_p, lowj, highj,\n+\t\t\t rangei->strict_overflow_p\n+\t\t\t || rangej->strict_overflow_p))\n+    return true;\n+  return false;\n+}\n+\n+/* Optimize X == CST1 || X == CST2\n+   if popcount (CST2 - CST1) == 1 into\n+   ((X - CST1) & ~(CST2 - CST1)) == 0.\n+   Similarly for ranges.  E.g.\n+   X == 43 || X == 76 || X == 44 || X == 78 || X == 77 || X == 46\n+   || X == 75 || X == 45\n+   will be transformed by the previous optimization into\n+   (X - 43U) <= 3U || (X - 75U) <= 3U\n+   and this loop can transform that into\n+   ((X - 43U) & ~(75U - 43U)) <= 3U.  */\n+static bool\n+optimize_range_tests_diff (enum tree_code opcode, tree type,\n+\t\t\t    tree lowi, tree lowj, tree highi, tree highj,\n+\t\t\t    vec<operand_entry_t> *ops,\n+\t\t\t    struct range_entry *rangei,\n+\t\t\t    struct range_entry *rangej)\n+{\n+  tree tem1, tem2, mask;\n+  /* Check highi - lowi == highj - lowj.  */\n+  tem1 = fold_binary (MINUS_EXPR, type, highi, lowi);\n+  if (tem1 == NULL_TREE || TREE_CODE (tem1) != INTEGER_CST)\n+    return false;\n+  tem2 = fold_binary (MINUS_EXPR, type, highj, lowj);\n+  if (!tree_int_cst_equal (tem1, tem2))\n+    return false;\n+  /* Check popcount (lowj - lowi) == 1.  */\n+  tem1 = fold_binary (MINUS_EXPR, type, lowj, lowi);\n+  if (tem1 == NULL_TREE || TREE_CODE (tem1) != INTEGER_CST)\n+    return false;\n+  if (tree_log2 (tem1) < 0)\n+    return false;\n+\n+  mask = fold_build1 (BIT_NOT_EXPR, type, tem1);\n+  tem1 = fold_binary (MINUS_EXPR, type, rangei->exp, lowi);\n+  tem1 = fold_build2 (BIT_AND_EXPR, type, tem1, mask);\n+  lowj = build_int_cst (type, 0);\n+  if (update_range_test (rangei, rangej, 1, opcode, ops, tem1,\n+\t\t\t rangei->in_p, lowj, tem2,\n+\t\t\t rangei->strict_overflow_p\n+\t\t\t || rangej->strict_overflow_p))\n+    return true;\n+  return false;\n+}\n+\n+/* It does some common checks for function optimize_range_tests_xor and\n+   optimize_range_tests_diff.\n+   If OPTIMIZE_XOR is TRUE, it calls optimize_range_tests_xor.\n+   Else it calls optimize_range_tests_diff.  */\n+\n+static bool\n+optimize_range_tests_1 (enum tree_code opcode, int first, int length,\n+\t\t\tbool optimize_xor, vec<operand_entry_t> *ops,\n+\t\t\tstruct range_entry *ranges)\n+{\n+  int i, j;\n+  bool any_changes = false;\n+  for (i = first; i < length; i++)\n+    {\n+      tree lowi, highi, lowj, highj, type, tem;\n+\n+      if (ranges[i].exp == NULL_TREE || ranges[i].in_p)\n+\tcontinue;\n+      type = TREE_TYPE (ranges[i].exp);\n+      if (!INTEGRAL_TYPE_P (type))\n+\tcontinue;\n+      lowi = ranges[i].low;\n+      if (lowi == NULL_TREE)\n+\tlowi = TYPE_MIN_VALUE (type);\n+      highi = ranges[i].high;\n+      if (highi == NULL_TREE)\n+\tcontinue;\n+      for (j = i + 1; j < length && j < i + 64; j++)\n+\t{\n+\t  bool changes;\n+\t  if (ranges[i].exp != ranges[j].exp || ranges[j].in_p)\n+\t    continue;\n+\t  lowj = ranges[j].low;\n+\t  if (lowj == NULL_TREE)\n+\t    continue;\n+\t  highj = ranges[j].high;\n+\t  if (highj == NULL_TREE)\n+\t    highj = TYPE_MAX_VALUE (type);\n+\t  /* Check lowj > highi.  */\n+\t  tem = fold_binary (GT_EXPR, boolean_type_node,\n+\t\t\t     lowj, highi);\n+\t  if (tem == NULL_TREE || !integer_onep (tem))\n+\t    continue;\n+\t  if (optimize_xor)\n+\t    changes = optimize_range_tests_xor (opcode, type, lowi, lowj,\n+\t\t\t\t\t\thighi, highj, ops,\n+\t\t\t\t\t\tranges + i, ranges + j);\n+\t  else\n+\t    changes = optimize_range_tests_diff (opcode, type, lowi, lowj,\n+\t\t\t\t\t\t highi, highj, ops,\n+\t\t\t\t\t\t ranges + i, ranges + j);\n+\t  if (changes)\n+\t    {\n+\t      any_changes = true;\n+\t      break;\n+\t    }\n+\t}\n+    }\n+  return any_changes;\n+}\n+\n /* Optimize range tests, similarly how fold_range_test optimizes\n    it on trees.  The tree code for the binary\n    operation between all the operands is OPCODE.\n@@ -2208,76 +2356,12 @@ optimize_range_tests (enum tree_code opcode,\n \t++update_fail_count;\n     }\n \n-  /* Optimize X == CST1 || X == CST2\n-     if popcount (CST1 ^ CST2) == 1 into\n-     (X & ~(CST1 ^ CST2)) == (CST1 & ~(CST1 ^ CST2)).\n-     Similarly for ranges.  E.g.\n-     X != 2 && X != 3 && X != 10 && X != 11\n-     will be transformed by the above loop into\n-     (X - 2U) <= 1U && (X - 10U) <= 1U\n-     and this loop can transform that into\n-     ((X & ~8) - 2U) <= 1U.  */\n-  for (i = first; i < length; i++)\n-    {\n-      tree lowi, highi, lowj, highj, type, lowxor, highxor, tem, exp;\n+  any_changes |= optimize_range_tests_1 (opcode, first, length, true,\n+\t\t\t\t\t ops, ranges);\n \n-      if (ranges[i].exp == NULL_TREE || ranges[i].in_p)\n-\tcontinue;\n-      type = TREE_TYPE (ranges[i].exp);\n-      if (!INTEGRAL_TYPE_P (type))\n-\tcontinue;\n-      lowi = ranges[i].low;\n-      if (lowi == NULL_TREE)\n-\tlowi = TYPE_MIN_VALUE (type);\n-      highi = ranges[i].high;\n-      if (highi == NULL_TREE)\n-\tcontinue;\n-      for (j = i + 1; j < length && j < i + 64; j++)\n-\t{\n-\t  if (ranges[j].exp == NULL_TREE)\n-\t    continue;\n-\t  if (ranges[i].exp != ranges[j].exp)\n-\t    break;\n-\t  if (ranges[j].in_p)\n-\t    continue;\n-\t  lowj = ranges[j].low;\n-\t  if (lowj == NULL_TREE)\n-\t    continue;\n-\t  highj = ranges[j].high;\n-\t  if (highj == NULL_TREE)\n-\t    highj = TYPE_MAX_VALUE (type);\n-\t  tem = fold_binary (GT_EXPR, boolean_type_node,\n-\t\t\t     lowj, highi);\n-\t  if (tem == NULL_TREE || !integer_onep (tem))\n-\t    continue;\n-\t  lowxor = fold_binary (BIT_XOR_EXPR, type, lowi, lowj);\n-\t  if (lowxor == NULL_TREE || TREE_CODE (lowxor) != INTEGER_CST)\n-\t    continue;\n-\t  gcc_checking_assert (!integer_zerop (lowxor));\n-\t  tem = fold_binary (MINUS_EXPR, type, lowxor,\n-\t\t\t     build_int_cst (type, 1));\n-\t  if (tem == NULL_TREE)\n-\t    continue;\n-\t  tem = fold_binary (BIT_AND_EXPR, type, lowxor, tem);\n-\t  if (tem == NULL_TREE || !integer_zerop (tem))\n-\t    continue;\n-\t  highxor = fold_binary (BIT_XOR_EXPR, type, highi, highj);\n-\t  if (!tree_int_cst_equal (lowxor, highxor))\n-\t    continue;\n-\t  tem = fold_build1 (BIT_NOT_EXPR, type, lowxor);\n-\t  exp = fold_build2 (BIT_AND_EXPR, type, ranges[i].exp, tem);\n-\t  lowj = fold_build2 (BIT_AND_EXPR, type, lowi, tem);\n-\t  highj = fold_build2 (BIT_AND_EXPR, type, highi, tem);\n-\t  if (update_range_test (ranges + i, ranges + j, 1, opcode, ops, exp,\n-\t\t\t\t ranges[i].in_p, lowj, highj,\n-\t\t\t\t ranges[i].strict_overflow_p\n-\t\t\t\t || ranges[j].strict_overflow_p))\n-\t    {\n-\t      any_changes = true;\n-\t      break;\n-\t    }\n-\t}\n-    }\n+  if (BRANCH_COST (optimize_function_for_speed_p (cfun), false) >= 2)\n+    any_changes |= optimize_range_tests_1 (opcode, first, length, false,\n+\t\t\t\t\t   ops, ranges);\n \n   if (any_changes && opcode != ERROR_MARK)\n     {"}]}