{"sha": "7b3bda2ce269e858b2a7defa904bc748bc0b5854", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2IzYmRhMmNlMjY5ZTg1OGIyYTdkZWZhOTA0YmM3NDhiYzBiNTg1NA==", "commit": {"author": {"name": "Steve Baird", "email": "baird@adacore.com", "date": "2020-08-06T18:09:50Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-22T12:11:26Z"}, "message": "[Ada] AI12-0211: Consistency of inherited nonoverridable aspects\n\ngcc/ada/\n\n\t* aspects.ads: Introduce the subtype Nonoverridable_Aspect_Id,\n\twhose Static_Predicate reflects the list of nonoverridable\n\taspects given in Ada RM 13.1.1(18.7).\n\t* sem_util.ads, sem_util.adb: Add two new visible subprograms,\n\tCheck_Inherited_Nonoverridable_Aspects and Is_Confirming. The\n\tformer is used to check the consistency of inherited\n\tnonoverridable aspects from multiple sources. The latter\n\tindicates whether two aspect specifications for a nonoverridable\n\taspect are confirming. Because of compatibility concerns in\n\tcompiling QGen, Is_Confirming always returns True if\n\tRelaxed_RM_Semantics (i.e., -gnatd.M) is specified.\n\t* sem_ch3.adb (Derived_Type_Declaration): Call new\n\tCheck_Inherited_Nonoverridable_Aspects procedure if interface\n\tlist is non-empty.\n\t* sem_ch9.adb (Check_Interfaces): Call new\n\tCheck_Inherited_Nonoverridable_Aspects procedure if interface\n\tlist is non-empty.\n\t* sem_ch13.adb (Analyze_Aspect_Specifications): When an explicit\n\taspect specification overrides an inherited nonoverridable\n\taspect, check that the explicit specification is confirming.", "tree": {"sha": "ec0d6059aeaa428ddbe569bf418f38d6da40da41", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ec0d6059aeaa428ddbe569bf418f38d6da40da41"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7b3bda2ce269e858b2a7defa904bc748bc0b5854", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3bda2ce269e858b2a7defa904bc748bc0b5854", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b3bda2ce269e858b2a7defa904bc748bc0b5854", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b3bda2ce269e858b2a7defa904bc748bc0b5854/comments", "author": {"login": "swbaird", "id": 50751052, "node_id": "MDQ6VXNlcjUwNzUxMDUy", "avatar_url": "https://avatars.githubusercontent.com/u/50751052?v=4", "gravatar_id": "", "url": "https://api.github.com/users/swbaird", "html_url": "https://github.com/swbaird", "followers_url": "https://api.github.com/users/swbaird/followers", "following_url": "https://api.github.com/users/swbaird/following{/other_user}", "gists_url": "https://api.github.com/users/swbaird/gists{/gist_id}", "starred_url": "https://api.github.com/users/swbaird/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/swbaird/subscriptions", "organizations_url": "https://api.github.com/users/swbaird/orgs", "repos_url": "https://api.github.com/users/swbaird/repos", "events_url": "https://api.github.com/users/swbaird/events{/privacy}", "received_events_url": "https://api.github.com/users/swbaird/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "944fed738c3f300b4e3cf5f89a4d2b40c85e0a75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944fed738c3f300b4e3cf5f89a4d2b40c85e0a75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944fed738c3f300b4e3cf5f89a4d2b40c85e0a75"}], "stats": {"total": 320, "additions": 317, "deletions": 3}, "files": [{"sha": "425d210b0e3b81187daeae149a27ab494088acca", "filename": "gcc/ada/aspects.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Faspects.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Faspects.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Faspects.ads?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -229,6 +229,16 @@ package Aspects is\n      Aspect_Id range Aspect_Id'Succ (No_Aspect) .. Aspect_Id'Last;\n    --  Aspect_Id's excluding No_Aspect\n \n+   subtype Nonoverridable_Aspect_Id is Aspect_Id with\n+     Static_Predicate => Nonoverridable_Aspect_Id in\n+       Aspect_Default_Iterator | Aspect_Iterator_Element |\n+       Aspect_Implicit_Dereference | Aspect_Constant_Indexing |\n+       Aspect_Variable_Indexing | Aspect_Aggregate |\n+       Aspect_Max_Entry_Queue_Length\n+       --  | Aspect_No_Controlled_Parts\n+       --  ??? No_Controlled_Parts not yet in Aspect_Id enumeration\n+       ;  --  see RM 13.1.1(18.7)\n+\n    --  The following array indicates aspects that accept 'Class\n \n    Class_Aspect_OK : constant array (Aspect_Id) of Boolean :="}, {"sha": "27faac2de128ebd392149b55d4ac2daa0e5154b1", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -4159,7 +4159,7 @@ package body Sem_Ch13 is\n                when Aspect_Aggregate =>\n                   Validate_Aspect_Aggregate (Expr);\n                   Record_Rep_Item (E, Aspect);\n-                  return;\n+                  goto Continue;\n \n                when Aspect_Integer_Literal\n                   | Aspect_Real_Literal\n@@ -4751,9 +4751,39 @@ package body Sem_Ch13 is\n                Insert_After (Ins_Node, Aitem);\n                Ins_Node := Aitem;\n             end if;\n+\n+            <<Continue>>\n+\n+            --  If a nonoverridable aspect is explicitly specified for a\n+            --  derived type, then check consistency with the parent type.\n+\n+            if A_Id in Nonoverridable_Aspect_Id\n+              and then Nkind (N) = N_Full_Type_Declaration\n+              and then Nkind (Type_Definition (N)) = N_Derived_Type_Definition\n+              and then not In_Instance_Body\n+            then\n+               declare\n+                  Parent_Type      : constant Entity_Id := Etype (E);\n+                  Inherited_Aspect : constant Node_Id :=\n+                    Find_Aspect (Parent_Type, A_Id);\n+               begin\n+                  if Present (Inherited_Aspect)\n+                    and then not Is_Confirming\n+                                   (A_Id, Inherited_Aspect, Aspect)\n+                  then\n+                     Error_Msg_Name_1 := Aspect_Names (A_Id);\n+                     Error_Msg_Sloc := Sloc (Inherited_Aspect);\n+\n+                     Error_Msg\n+                       (\"overriding aspect specification for \"\n+                          & \"nonoverridable aspect % does not confirm \"\n+                          & \"aspect specification inherited from #\",\n+                        Sloc (Aspect));\n+                  end if;\n+               end;\n+            end if;\n          end Analyze_One_Aspect;\n \n-      <<Continue>>\n          Next (Aspect);\n       end loop Aspect_Loop;\n "}, {"sha": "cea12f22661b38448ad9287c5608b64a051f4eee", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -16754,6 +16754,14 @@ package body Sem_Ch3 is\n                Next (Intf);\n             end loop;\n          end;\n+\n+         --  Check consistency of any nonoverridable aspects that are\n+         --  inherited from multiple sources.\n+\n+         Check_Inherited_Nonoverridable_Aspects\n+           (Inheritor      => T,\n+            Interface_List => Interface_List (Def),\n+            Parent_Type    => Parent_Type);\n       end if;\n \n       if Parent_Type = Any_Type"}, {"sha": "fd3a29cfcbdf066e154f75046aa7da0f28101884", "filename": "gcc/ada/sem_ch9.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch9.adb?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -3532,6 +3532,14 @@ package body Sem_Ch9 is\n \n             Next (Iface);\n          end loop;\n+\n+         --  Check consistency of any nonoverridable aspects that are\n+         --  inherited from multiple sources.\n+\n+         Check_Inherited_Nonoverridable_Aspects\n+           (Inheritor      => N,\n+            Interface_List => Interface_List (N),\n+            Parent_Type    => Empty);\n       end if;\n \n       if not Has_Private_Declaration (T) then"}, {"sha": "7a83d655fb139871171c91ea366ff1be07fbb5b7", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 241, "deletions": 1, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -25,7 +25,6 @@\n \n with Treepr; -- ???For debugging code below\n \n-with Aspects;  use Aspects;\n with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n@@ -53,6 +52,7 @@ with Sem_Attr; use Sem_Attr;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n+with Sem_Ch13; use Sem_Ch13;\n with Sem_Disp; use Sem_Disp;\n with Sem_Elab; use Sem_Elab;\n with Sem_Eval; use Sem_Eval;\n@@ -4142,6 +4142,132 @@ package body Sem_Util is\n       end if;\n    end Check_No_Hidden_State;\n \n+   ---------------------------------------------\n+   -- Check_Nonoverridable_Aspect_Consistency --\n+   ---------------------------------------------\n+\n+   procedure Check_Inherited_Nonoverridable_Aspects\n+     (Inheritor      : Entity_Id;\n+      Interface_List : List_Id;\n+      Parent_Type    : Entity_Id) is\n+\n+      --  array needed for iterating over subtype values\n+      Nonoverridable_Aspects : constant array (Positive range <>) of\n+        Nonoverridable_Aspect_Id :=\n+          (Aspect_Default_Iterator,\n+           Aspect_Iterator_Element,\n+           Aspect_Implicit_Dereference,\n+           Aspect_Constant_Indexing,\n+           Aspect_Variable_Indexing,\n+           Aspect_Aggregate,\n+           Aspect_Max_Entry_Queue_Length\n+           --  , Aspect_No_Controlled_Parts\n+          );\n+\n+      --  Note that none of these 8 aspects can be specified (for a type)\n+      --  via a pragma. For 7 of them, the corresponding pragma does not\n+      --  exist. The Pragma_Id enumeration type does include\n+      --  Pragma_Max_Entry_Queue_Length, but that pragma is only use to\n+      --  specify the aspect for a protected entry or entry family, not for\n+      --  a type, and therefore cannot introduce the sorts of inheritance\n+      --  issues that we are concerned with in this procedure.\n+\n+      type Entity_Array is array (Nat range <>) of Entity_Id;\n+\n+      function Ancestor_Entities return Entity_Array;\n+      --  Returns all progenitors (including parent type, if present)\n+\n+      procedure Check_Consistency_For_One_Aspect_Of_Two_Ancestors\n+        (Aspect        : Nonoverridable_Aspect_Id;\n+         Ancestor_1    : Entity_Id;\n+         Aspect_Spec_1 : Node_Id;\n+         Ancestor_2    : Entity_Id;\n+         Aspect_Spec_2 : Node_Id);\n+      --  A given aspect has been specified for each of two ancestors;\n+      --  check that the two aspect specifications are compatible (see\n+      --  RM 13.1.1(18.5) and AI12-0211).\n+\n+      -----------------------\n+      -- Ancestor_Entities --\n+      -----------------------\n+\n+      function Ancestor_Entities return Entity_Array is\n+         Ifc_Count : constant Nat := List_Length (Interface_List);\n+         Ifc_Ancestors : Entity_Array (1 .. Ifc_Count);\n+         Ifc : Node_Id := First (Interface_List);\n+      begin\n+         for Idx in Ifc_Ancestors'Range loop\n+            Ifc_Ancestors (Idx) := Entity (Ifc);\n+            pragma Assert (Present (Ifc_Ancestors (Idx)));\n+            Ifc := Next (Ifc);\n+         end loop;\n+         pragma Assert (not Present (Ifc));\n+         if Present (Parent_Type) then\n+            return Parent_Type & Ifc_Ancestors;\n+         else\n+            return Ifc_Ancestors;\n+         end if;\n+      end Ancestor_Entities;\n+\n+      -------------------------------------------------------\n+      -- Check_Consistency_For_One_Aspect_Of_Two_Ancestors --\n+      -------------------------------------------------------\n+\n+      procedure Check_Consistency_For_One_Aspect_Of_Two_Ancestors\n+        (Aspect        : Nonoverridable_Aspect_Id;\n+         Ancestor_1    : Entity_Id;\n+         Aspect_Spec_1 : Node_Id;\n+         Ancestor_2    : Entity_Id;\n+         Aspect_Spec_2 : Node_Id) is\n+      begin\n+         if not Is_Confirming (Aspect, Aspect_Spec_1, Aspect_Spec_2) then\n+            Error_Msg_Name_1 := Aspect_Names (Aspect);\n+            Error_Msg_Name_2 := Chars (Ancestor_1);\n+            Error_Msg_Name_3 := Chars (Ancestor_2);\n+\n+            Error_Msg (\n+              \"incompatible % aspects inherited from ancestors % and %\",\n+              Sloc (Inheritor));\n+         end if;\n+      end Check_Consistency_For_One_Aspect_Of_Two_Ancestors;\n+\n+      Ancestors : constant Entity_Array := Ancestor_Entities;\n+\n+      --  start of processing for Check_Inherited_Nonoverridable_Aspects\n+   begin\n+      --  No Ada_Version check here; AI12-0211 is a binding interpretation.\n+\n+      if Ancestors'Length < 2 then\n+         return; --  Inconsistency impossible; it takes 2 to disagree.\n+      elsif In_Instance_Body then\n+         return;  -- No legality checking in an instance body.\n+      end if;\n+\n+      for Aspect of Nonoverridable_Aspects loop\n+         declare\n+            First_Ancestor_With_Aspect : Entity_Id := Empty;\n+            First_Aspect_Spec, Current_Aspect_Spec : Node_Id := Empty;\n+         begin\n+            for Ancestor of Ancestors loop\n+               Current_Aspect_Spec := Find_Aspect (Ancestor, Aspect);\n+               if Present (Current_Aspect_Spec) then\n+                  if Present (First_Ancestor_With_Aspect) then\n+                     Check_Consistency_For_One_Aspect_Of_Two_Ancestors\n+                       (Aspect        => Aspect,\n+                        Ancestor_1    => First_Ancestor_With_Aspect,\n+                        Aspect_Spec_1 => First_Aspect_Spec,\n+                        Ancestor_2    => Ancestor,\n+                        Aspect_Spec_2 => Current_Aspect_Spec);\n+                  else\n+                     First_Ancestor_With_Aspect := Ancestor;\n+                     First_Aspect_Spec := Current_Aspect_Spec;\n+                  end if;\n+               end if;\n+            end loop;\n+         end;\n+      end loop;\n+   end Check_Inherited_Nonoverridable_Aspects;\n+\n    ----------------------------------------\n    -- Check_Nonvolatile_Function_Profile --\n    ----------------------------------------\n@@ -15265,6 +15391,120 @@ package body Sem_Util is\n       return False;\n    end Is_Child_Or_Sibling;\n \n+   -------------------\n+   -- Is_Confirming --\n+   -------------------\n+\n+   function Is_Confirming (Aspect : Nonoverridable_Aspect_Id;\n+                           Aspect_Spec_1, Aspect_Spec_2 : Node_Id)\n+                          return Boolean is\n+      function Names_Match (Nm1, Nm2 : Node_Id) return Boolean;\n+      function Names_Match (Nm1, Nm2 : Node_Id) return Boolean is\n+      begin\n+         if Nkind (Nm1) /= Nkind (Nm2) then\n+            return False;\n+         end if;\n+         case Nkind (Nm1) is\n+            when N_Identifier =>\n+               return Name_Equals (Chars (Nm1), Chars (Nm2));\n+            when N_Expanded_Name =>\n+               return Names_Match (Prefix (Nm1), Prefix (Nm2))\n+                 and then Names_Match (Selector_Name (Nm1),\n+                                       Selector_Name (Nm2));\n+            when N_Empty =>\n+               return True; -- needed for Aggregate aspect checking\n+\n+            when others =>\n+               --  e.g., 'Class attribute references\n+               if Is_Entity_Name (Nm1) and Is_Entity_Name (Nm2) then\n+                  return Entity (Nm1) = Entity (Nm2);\n+               end if;\n+\n+               raise Program_Error;\n+         end case;\n+      end Names_Match;\n+   begin\n+      --  allow users to disable \"shall be confirming\" check, at least for now\n+      if Relaxed_RM_Semantics then\n+         return True;\n+      end if;\n+\n+      --  ??? Type conversion here (along with \"when others =>\" below) is a\n+      --  workaround for a bootstrapping problem related to casing on a\n+      --  static-predicate-bearing subtype.\n+\n+      case Aspect_Id (Aspect) is\n+         --  name-valued aspects; compare text of names, not resolution.\n+         when Aspect_Default_Iterator\n+            | Aspect_Iterator_Element\n+            | Aspect_Constant_Indexing\n+            | Aspect_Variable_Indexing\n+            | Aspect_Implicit_Dereference =>\n+            declare\n+               Item_1 : constant Node_Id := Aspect_Rep_Item (Aspect_Spec_1);\n+               Item_2 : constant Node_Id := Aspect_Rep_Item (Aspect_Spec_2);\n+            begin\n+               if (Nkind (Item_1) /= N_Attribute_Definition_Clause)\n+                 or (Nkind (Item_2) /= N_Attribute_Definition_Clause)\n+               then\n+                  pragma Assert (Serious_Errors_Detected > 0);\n+                  return True;\n+               end if;\n+\n+               return Names_Match (Expression (Item_1),\n+                                   Expression (Item_2));\n+            end;\n+\n+         --  one of a kind\n+         when Aspect_Aggregate =>\n+            declare\n+               Empty_1,\n+               Add_Named_1,\n+               Add_Unnamed_1,\n+               New_Indexed_1,\n+               Assign_Indexed_1,\n+               Empty_2,\n+               Add_Named_2,\n+               Add_Unnamed_2,\n+               New_Indexed_2,\n+               Assign_Indexed_2 : Node_Id := Empty;\n+            begin\n+               Parse_Aspect_Aggregate\n+                 (N                   => Expression (Aspect_Spec_1),\n+                  Empty_Subp          => Empty_1,\n+                  Add_Named_Subp      => Add_Named_1,\n+                  Add_Unnamed_Subp    => Add_Unnamed_1,\n+                  New_Indexed_Subp    => New_Indexed_1,\n+                  Assign_Indexed_Subp => Assign_Indexed_1);\n+               Parse_Aspect_Aggregate\n+                 (N                   => Expression (Aspect_Spec_2),\n+                  Empty_Subp          => Empty_2,\n+                  Add_Named_Subp      => Add_Named_2,\n+                  Add_Unnamed_Subp    => Add_Unnamed_2,\n+                  New_Indexed_Subp    => New_Indexed_2,\n+                  Assign_Indexed_Subp => Assign_Indexed_2);\n+               return\n+                 Names_Match (Empty_1, Empty_2) and then\n+                 Names_Match (Add_Named_1, Add_Named_2) and then\n+                 Names_Match (Add_Unnamed_1, Add_Unnamed_2) and then\n+                 Names_Match (New_Indexed_1, New_Indexed_2) and then\n+                 Names_Match (Assign_Indexed_1, Assign_Indexed_2);\n+            end;\n+\n+         --  scalar-valued aspects; compare (static) values.\n+         when Aspect_Max_Entry_Queue_Length --  | Aspect_No_Controlled_Parts\n+              =>\n+            --  This should be unreachable. No_Controlled_Parts is\n+            --  not yet supported at all in GNAT and Max_Entry_Queue_Length\n+            --  is supported only for protected entries, not for types.\n+            pragma Assert (Serious_Errors_Detected /= 0);\n+            return True;\n+\n+         when others =>\n+            raise Program_Error;\n+      end case;\n+   end Is_Confirming;\n+\n    -----------------------------\n    -- Is_Concurrent_Interface --\n    -----------------------------"}, {"sha": "2b49a44db7aa0bd253b379bef302186de2f08610", "filename": "gcc/ada/sem_util.ads", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_util.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7b3bda2ce269e858b2a7defa904bc748bc0b5854/gcc%2Fada%2Fsem_util.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.ads?ref=7b3bda2ce269e858b2a7defa904bc748bc0b5854", "patch": "@@ -25,6 +25,7 @@\n \n --  Package containing utility procedures used throughout the semantics\n \n+with Aspects; use Aspects;\n with Atree;   use Atree;\n with Einfo;   use Einfo;\n with Exp_Tss; use Exp_Tss;\n@@ -413,6 +414,17 @@ package Sem_Util is\n    --  Determine whether object or state Id introduces a hidden state. If this\n    --  is the case, emit an error.\n \n+   procedure Check_Inherited_Nonoverridable_Aspects\n+     (Inheritor      : Entity_Id;\n+      Interface_List : List_Id;\n+      Parent_Type    : Entity_Id);\n+   --  Verify consistency of inherited nonoverridable aspects\n+   --  when aspects are inherited from more than one source.\n+   --  Parent_Type may be void (e.g., for a tagged task/protected type\n+   --  whose declaration includes a non-empty interface list).\n+   --  In the error case, error message is associate with Inheritor;\n+   --  Inheritor parameter is otherwise unused.\n+\n    procedure Check_Nonvolatile_Function_Profile (Func_Id : Entity_Id);\n    --  Verify that the profile of nonvolatile function Func_Id does not contain\n    --  effectively volatile parameters or return type for reading.\n@@ -1685,6 +1697,12 @@ package Sem_Util is\n    --  Determine whether entity Id denotes a procedure with synchronization\n    --  kind By_Protected_Procedure.\n \n+   function Is_Confirming (Aspect : Nonoverridable_Aspect_Id;\n+                           Aspect_Spec_1, Aspect_Spec_2 : Node_Id)\n+                          return Boolean;\n+   --  Returns true if the two specifications of the given\n+   --  nonoverridable aspect are compatible.\n+\n    function Is_Constant_Bound (Exp : Node_Id) return Boolean;\n    --  Exp is the expression for an array bound. Determines whether the\n    --  bound is a compile-time known value, or a constant entity, or an"}]}