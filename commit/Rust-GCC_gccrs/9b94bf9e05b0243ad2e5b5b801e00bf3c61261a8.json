{"sha": "9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWI5NGJmOWUwNWIwMjQzYWQyZTViNWI4MDFlMDBiZjNjNjEyNjFhOA==", "commit": {"author": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-12-16T00:53:08Z"}, "committer": {"name": "Joseph Myers", "email": "jsm28@gcc.gnu.org", "date": "2001-12-16T00:53:08Z"}, "message": "* ChangeLog: Remove piece of diff output.\n\nFrom-SVN: r48051", "tree": {"sha": "a07955fb580e161805ce3c4411de13242520afa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a07955fb580e161805ce3c4411de13242520afa5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8/comments", "author": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jsm28", "id": 10537793, "node_id": "MDQ6VXNlcjEwNTM3Nzkz", "avatar_url": "https://avatars.githubusercontent.com/u/10537793?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jsm28", "html_url": "https://github.com/jsm28", "followers_url": "https://api.github.com/users/jsm28/followers", "following_url": "https://api.github.com/users/jsm28/following{/other_user}", "gists_url": "https://api.github.com/users/jsm28/gists{/gist_id}", "starred_url": "https://api.github.com/users/jsm28/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jsm28/subscriptions", "organizations_url": "https://api.github.com/users/jsm28/orgs", "repos_url": "https://api.github.com/users/jsm28/repos", "events_url": "https://api.github.com/users/jsm28/events{/privacy}", "received_events_url": "https://api.github.com/users/jsm28/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1e2bba3565ca5532c366c57cff647489cef060f5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e2bba3565ca5532c366c57cff647489cef060f5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e2bba3565ca5532c366c57cff647489cef060f5"}], "stats": {"total": 774, "additions": 4, "deletions": 770}, "files": [{"sha": "1c52121ad31b97cfb8f65356b9376810846abd32", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 4, "deletions": 770, "changes": 774, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=9b94bf9e05b0243ad2e5b5b801e00bf3c61261a8", "patch": "@@ -1,3 +1,7 @@\n+2001-12-16  Joseph S. Myers  <jsm28@cam.ac.uk>\n+\n+\t* ChangeLog: Remove piece of diff output.\n+\n 2001-12-14  Geert Bosch <bosch@gnat.com>\n \n \t* config-lang.in: Update copyright notice\n@@ -103,776 +107,6 @@\n \t* g-dirope.adb (Expand_Path.Var): Correctly detect end of \n \tvariable name.\n \n-*** s-stalib.adb\t2001/09/03 15:24:33\t1.17\n---- s-stalib.adb\t2001/10/16 13:14:46\t1.18\n-***************\n-*** 46,59 ****\n-  --  elaboration circularities with Ada.Exceptions if polling is on.\n-  \n-  with System.Soft_Links;\n-! --  Referenced directly from generated code\n-! --  Also referenced from exception handling routines.\n-  --  This is needed for programs that don't use exceptions explicitely but\n-  --  direct calls to Ada.Exceptions are generated by gigi (for example,\n-  --  by calling __gnat_raise_constraint_error directly).\n-  \n-  with System.Memory;\n-! --  Referenced directly from generated code\n-  \n-  package body System.Standard_Library is\n-  \n---- 46,62 ----\n-  --  elaboration circularities with Ada.Exceptions if polling is on.\n-  \n-  with System.Soft_Links;\n-! --  Referenced directly from generated code using external symbols so it\n-! --  must always be present in a build, even if no unit has a direct with\n-! --  of this unit. Also referenced from exception handling routines.\n-  --  This is needed for programs that don't use exceptions explicitely but\n-  --  direct calls to Ada.Exceptions are generated by gigi (for example,\n-  --  by calling __gnat_raise_constraint_error directly).\n-  \n-  with System.Memory;\n-! --  Referenced directly from generated code using external symbols, so it\n-! --  must always be present in a build, even if no unit has a direct with\n-! --  of this unit.\n-  \n-  package body System.Standard_Library is\n-  \n-\n-*** par-ch12.adb\t2001/10/19 15:22:18\t1.48\n---- par-ch12.adb\t2001/10/19 15:24:48\t1.49\n-***************\n-*** 452,466 ****\n-        if Def_Node /= Error then\n-           Set_Formal_Type_Definition (Decl_Node, Def_Node);\n-           TF_Semicolon;\n-        else\n-           Decl_Node := Error;\n-  \n-           if Token = Tok_Semicolon then\n--             --   Avoid further cascaded errors.\n-              Scan;\n-           end if;\n-        end if;\n-- \n-  \n-        return Decl_Node;\n-     end P_Formal_Type_Declaration;\n---- 452,467 ----\n-        if Def_Node /= Error then\n-           Set_Formal_Type_Definition (Decl_Node, Def_Node);\n-           TF_Semicolon;\n-+ \n-        else\n-           Decl_Node := Error;\n-  \n-+          --  If we have semicolon, skip it to avoid cascaded errors\n-+ \n-           if Token = Tok_Semicolon then\n-              Scan;\n-           end if;\n-        end if;\n-  \n-        return Decl_Node;\n-     end P_Formal_Type_Declaration;\n-\n-*** prj-dect.ads\t2001/10/20 10:28:13\t1.4\n---- prj-dect.ads\t2001/10/20 11:43:56\t1.5\n-***************\n-*** 8,14 ****\n-  --                                                                          --\n-  --                            $Revision$\n-  --                                                                          --\n-! --          Copyright (C) 2000-2001 Free Software Foundation, Inc.          --\n-  --                                                                          --\n-  -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n-  -- terms of the  GNU General Public License as published  by the Free Soft- --\n---- 8,14 ----\n-  --                                                                          --\n-  --                            $Revision$\n-  --                                                                          --\n-! --             Copyright (C) 2001 Free Software Foundation, Inc.            --\n-  --                                                                          --\n-  -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n-  -- terms of the  GNU General Public License as published  by the Free Soft- --\n-\n-*** s-arit64.adb\t2001/02/09 15:10:29\t1.16\n---- s-arit64.adb\t2001/10/20 14:50:39\t1.17\n-***************\n-*** 325,337 ****\n-              T2 := Xhi * Ylo;\n-           end if;\n-  \n-!       else\n-!          if Yhi /= 0 then\n-!             T2 := Xlo * Yhi;\n-!          else\n-!             return X * Y;\n-!          end if;\n-        end if;\n-  \n-        T1 := Xlo * Ylo;\n-        T2 := T2 + Hi (T1);\n---- 325,339 ----\n-              T2 := Xhi * Ylo;\n-           end if;\n-  \n-!       elsif Yhi /= 0 then\n-!          T2 := Xlo * Yhi;\n-! \n-!       else -- Yhi = Xhi = 0\n-!          T2 := 0;\n-        end if;\n-+ \n-+       --  Here we have T2 set to the contribution to the upper half\n-+       --  of the result from the upper halves of the input values.\n-  \n-        T1 := Xlo * Ylo;\n-        T2 := T2 + Hi (T1);\n-\n-*** s-fatgen.ads\t2001/07/20 00:59:34\t1.9\n---- s-fatgen.ads\t2001/10/20 18:37:39\t1.10\n-***************\n-*** 89,97 ****\n-  \n-     function Unbiased_Rounding (X : T)                       return T;\n-  \n-!    function Valid             (X : access T)                return Boolean;\n-!    --  The argument must be passed by reference here, as T may be\n-!    --  an abnormal value that can be passed in a floating point register.\n-  \n-  private\n-     pragma Inline (Machine);\n---- 89,100 ----\n-  \n-     function Unbiased_Rounding (X : T)                       return T;\n-  \n-!    function Valid (X : access T) return Boolean;\n-!    --  This function checks if the object of type T referenced by X\n-!    --  is valid, and returns True/False accordingly. The parameter is\n-!    --  passed by reference (access) here, as the object of type T may\n-!    --  be an abnormal value that cannot be passed in a floating-point\n-!    --  register, and the whole point of 'Valid is to prevent exceptions.\n-  \n-  private\n-     pragma Inline (Machine);\n-\n-*** sem_ch4.adb\t2001/09/24 22:32:31\t1.511\n---- sem_ch4.adb\t2001/10/21 17:41:52\t1.512\n-***************\n-*** 2691,2696 ****\n---- 2691,2708 ----\n-  \n-              Check_Misspelled_Selector (Entity_List, Sel);\n-  \n-+          elsif Is_Generic_Type (Prefix_Type)\n-+            and then Ekind (Prefix_Type) = E_Record_Type_With_Private\n-+            and then Is_Record_Type (Etype (Prefix_Type))\n-+          then\n-+             --  If this is a derived formal type, the parent may have a\n-+             --  different visibility at this point. Try for an inherited\n-+             --  component before reporting an error.\n-+ \n-+             Set_Etype (Prefix (N), Etype (Prefix_Type));\n-+             Analyze_Selected_Component (N);\n-+             return;\n-+ \n-           else\n-              if Ekind (Prefix_Type) = E_Record_Subtype then\n-  \n-\n-*** checks.ads\t2001/07/16 01:26:04\t1.55\n---- checks.ads\t2001/10/28 15:13:02\t1.56\n-***************\n-*** 83,88 ****\n---- 83,95 ----\n-     --  the object denoted by the access parameter is not deeper than the\n-     --  level of the type Typ. Program_Error is raised if the check fails.\n-  \n-+    procedure Apply_Alignment_Check (E : Entity_Id; N : Node_Id);\n-+    --  E is the entity for an object. If there is an address clause for\n-+    --  this entity, and checks are enabled, then this procedure generates\n-+    --  a check that the specified address has an alignment consistent with\n-+    --  the alignment of the object, raising PE if this is not the case. The\n-+    --  resulting check (if one is generated) is inserted before node N.\n-+ \n-     procedure Apply_Array_Size_Check (N : Node_Id; Typ : Entity_Id);\n-     --  N is the node for an object declaration that declares an object of\n-     --  array type Typ. This routine generates, if necessary, a check that\n-\n-*** exp_ch13.adb\t2001/07/16 21:21:29\t1.76\n---- exp_ch13.adb\t2001/10/28 15:13:25\t1.77\n-***************\n-*** 27,32 ****\n---- 27,33 ----\n-  ------------------------------------------------------------------------------\n-  \n-  with Atree;    use Atree;\n-+ with Checks;   use Checks;\n-  with Einfo;    use Einfo;\n-  with Exp_Ch3;  use Exp_Ch3;\n-  with Exp_Ch6;  use Exp_Ch6;\n-***************\n-*** 236,245 ****\n-        Decl           : Node_Id;\n-  \n-     begin\n-!       if not Is_Type (E) and then not Is_Subprogram (E) then\n-           return;\n-        end if;\n-  \n-        E_Scope := Scope (E);\n-  \n-        --  If we are freezing entities defined in protected types, they\n---- 237,256 ----\n-        Decl           : Node_Id;\n-  \n-     begin\n-!       --  For object, with address clause, check alignment is OK\n-! \n-!       if Is_Object (E) then\n-!          Apply_Alignment_Check (E, N);\n-! \n-!       --  Only other items requiring any front end action are\n-!       --  types and subprograms.\n-! \n-!       elsif not Is_Type (E) and then not Is_Subprogram (E) then\n-           return;\n-        end if;\n-  \n-+       --  Here E is a type or a subprogram\n-+ \n-        E_Scope := Scope (E);\n-  \n-        --  If we are freezing entities defined in protected types, they\n-***************\n-*** 304,314 ****\n-  \n-        elsif Is_Subprogram (E) then\n-           Freeze_Subprogram (N);\n-- \n--       --  No other entities require any front end freeze actions\n-- \n--       else\n--          null;\n-        end if;\n-  \n-        --  Analyze actions generated by freezing. The init_proc contains\n---- 315,320 ----\n-\n-*** exp_util.ads\t2001/07/23 10:05:17\t1.112\n---- exp_util.ads\t2001/10/28 15:14:04\t1.113\n-***************\n-*** 372,386 ****\n-     --  routine is to help avoid generating troublesome temporaries that\n-     --  intefere with the stack checking mechanism.\n-  \n--    function Must_Be_Aligned (Obj : Node_Id) return Boolean;\n--    --  Given an object reference, determines whether or not the object\n--    --  is required to be aligned according to its type'alignment value.\n--    --  Normally, objects are required to be aligned, and the result will\n--    --  be True. The situation in which this is not the case is if the\n--    --  object reference involves a component of a packed array, where\n--    --  the type of the component is not required to have strict alignment.\n--    --  In this case, false will be returned.\n-- \n-     procedure Remove_Side_Effects\n-       (Exp          : Node_Id;\n-        Name_Req     : Boolean := False;\n---- 372,377 ----\n-\n-*** mdllfile.ads\t2001/10/29 02:06:24\t1.2\n---- mdllfile.ads\t2001/10/29 02:50:12\t1.3\n-***************\n-*** 26,52 ****\n-  --                                                                          --\n-  ------------------------------------------------------------------------------\n-  \n-! --  Simple services used by GNATDLL to deal with Filename extension.\n-  \n-  package MDLL.Files is\n-  \n-     No_Ext : constant String := \"\";\n-  \n-!    function Get_Ext (Filename : in String)\n-!                      return String;\n-!    --  return filename's extension.\n-! \n-!    function Is_Ali (Filename : in String)\n-!                     return Boolean;\n-!    --  test if Filename is an Ada library file (.ali).\n-! \n-!    function Is_Obj (Filename : in String)\n-!                     return Boolean;\n-!    --  test if Filename is an object file (.o or .obj).\n-! \n-!    function Ext_To (Filename : in String;\n-!                     New_Ext  : in String := No_Ext)\n-!                     return String;\n-!    --  return Filename with the extension change to New_Ext.\n-  \n-  end MDLL.Files;\n---- 26,51 ----\n-  --                                                                          --\n-  ------------------------------------------------------------------------------\n-  \n-! --  Simple services used by GNATDLL to deal with Filename extension\n-  \n-  package MDLL.Files is\n-  \n-     No_Ext : constant String := \"\";\n-+    --  Used to mark the absence of an extension\n-  \n-!    function Get_Ext (Filename : String) return String;\n-!    --  Return extension of Filename\n-! \n-!    function Is_Ali (Filename : String) return Boolean;\n-!    --  Test if Filename is an Ada library file (.ali).\n-! \n-!    function Is_Obj (Filename : String) return Boolean;\n-!    --  Test if Filename is an object file (.o or .obj)\n-! \n-!    function Ext_To\n-!      (Filename : String;\n-!       New_Ext  : String := No_Ext)\n-!       return     String;\n-!    --  Return Filename with the extension change to New_Ext\n-  \n-  end MDLL.Files;\n-\n-*** mlib-fil.ads\t2001/10/29 02:06:26\t1.3\n---- mlib-fil.ads\t2001/10/29 02:51:28\t1.4\n-***************\n-*** 36,51 ****\n-        return     String;\n-     --  Return Filename with the extension change to New_Ext.\n-  \n-!    function Get_Ext (Filename : in String) return String;\n-     --  Return extension of filename.\n-  \n-     function Is_Archive (Filename : String) return Boolean;\n-     --  Test if filename is an archive\n-  \n-!    function Is_C (Filename : in String) return Boolean;\n-     --  Test if Filename is a C file\n-  \n-!    function Is_Obj (Filename : in String) return Boolean;\n-     --  Test if Filename is an object file\n-  \n-  end MLib.Fil;\n---- 36,51 ----\n-        return     String;\n-     --  Return Filename with the extension change to New_Ext.\n-  \n-!    function Get_Ext (Filename : String) return String;\n-     --  Return extension of filename.\n-  \n-     function Is_Archive (Filename : String) return Boolean;\n-     --  Test if filename is an archive\n-  \n-!    function Is_C (Filename : String) return Boolean;\n-     --  Test if Filename is a C file\n-  \n-!    function Is_Obj (Filename : String) return Boolean;\n-     --  Test if Filename is an object file\n-  \n-  end MLib.Fil;\n-\n-*** exp_ch8.adb\t2001/10/03 02:17:32\t1.30\n---- exp_ch8.adb\t2001/10/29 17:32:24\t1.31\n-***************\n-*** 59,65 ****\n-     --  of the renamed object. The cases in which this is not true are when\n-     --  this address is not computable, since it involves extraction of a\n-     --  packed array element, or of a record component to which a component\n-!    --  clause applies (that can specify an arbitrary bit boundary).\n-  \n-     --  In these two cases, we pre-evaluate the renaming expression, by\n-     --  extracting and freezing the values of any subscripts, and then we\n---- 59,66 ----\n-     --  of the renamed object. The cases in which this is not true are when\n-     --  this address is not computable, since it involves extraction of a\n-     --  packed array element, or of a record component to which a component\n-!    --  clause applies (that can specify an arbitrary bit boundary), or where\n-!    --  the enclosing record itself has a non-standard representation.\n-  \n-     --  In these two cases, we pre-evaluate the renaming expression, by\n-     --  extracting and freezing the values of any subscripts, and then we\n-***************\n-*** 211,228 ****\n-              end if;\n-  \n-           elsif Nkind (Nam) = N_Selected_Component then\n-!             if Present (Component_Clause (Entity (Selector_Name (Nam)))) then\n-!                return True;\n-  \n-!             elsif Ekind (Entity (Selector_Name (Nam))) = E_Discriminant\n-!               and then Is_Record_Type (Etype (Prefix (Nam)))\n-!               and then not Is_Concurrent_Record_Type (Etype (Prefix (Nam)))\n-!             then\n-!                return True;\n-  \n-!             else\n-!                return Evaluation_Required (Prefix (Nam));\n-!             end if;\n-  \n-           else\n-              return False;\n---- 212,236 ----\n-              end if;\n-  \n-           elsif Nkind (Nam) = N_Selected_Component then\n-!             declare\n-!                Rec_Type : Entity_Id := Etype (Prefix (Nam));\n-  \n-!             begin\n-!                if Present (Component_Clause (Entity (Selector_Name (Nam))))\n-!                  or else Has_Non_Standard_Rep (Rec_Type)\n-!                then\n-!                   return True;\n-! \n-!                elsif Ekind (Entity (Selector_Name (Nam))) = E_Discriminant\n-!                  and then Is_Record_Type (Rec_Type)\n-!                  and then not Is_Concurrent_Record_Type (Rec_Type)\n-!                then\n-!                   return True;\n-  \n-!                else\n-!                   return Evaluation_Required (Prefix (Nam));\n-!                end if;\n-!             end;\n-  \n-           else\n-              return False;\n-\n-*** g-dirope.ads\t2001/08/27 09:48:38\t1.12\n---- g-dirope.ads\t2001/10/29 19:18:13\t1.13\n-***************\n-*** 38,43 ****\n---- 38,47 ----\n-  --  can be treated as a file, using open and close routines, and a scanning\n-  --  routine is provided for iterating through the entries in a directory.\n-  \n-+ --  See also child package GNAT.Directory_Operations.Iteration\n-+ \n-+ with Ada.Strings.Maps;\n-+ \n-  package GNAT.Directory_Operations is\n-  \n-     subtype Dir_Name_Str is String;\n-***************\n-*** 187,248 ****\n-     --  returned in target-OS form. Raises Directory_Error if Dir has not\n-     --  be opened (Dir = Null_Dir).\n-  \n--    generic\n--       with procedure Action\n--         (Item  :        String;\n--          Index :        Positive;\n--          Quit  : in out Boolean);\n--    procedure Wildcard_Iterator (Path : Path_Name);\n--    --  Calls Action for each path matching Path. Path can include wildcards '*'\n--    --  and '?' and [...]. The rules are:\n--    --\n--    --     *       can be replaced by any sequence of characters\n--    --     ?       can be replaced by a single character\n--    --     [a-z]   match one character in the range 'a' through 'z'\n--    --     [abc]   match either character 'a', 'b' or 'c'\n--    --\n--    --  Item is the filename that has been matched. Index is set to one for the\n--    --  first call and is incremented by one at each call. The iterator's\n--    --  termination can be controlled by setting Quit to True. It is by default\n--    --  set to False.\n--    --\n--    --  For example, if we have the following directory structure:\n--    --     /boo/\n--    --        foo.ads\n--    --     /sed/\n--    --        foo.ads\n--    --        file/\n--    --          foo.ads\n--    --     /sid/\n--    --        foo.ads\n--    --        file/\n--    --          foo.ads\n--    --     /life/\n--    --\n--    --  A call with expression \"/s*/file/*\" will call Action for the following\n--    --  items:\n--    --     /sed/file/foo.ads\n--    --     /sid/file/foo.ads\n-- \n--    generic\n--       with procedure Action\n--         (Item  :        String;\n--          Index :        Positive;\n--          Quit  : in out Boolean);\n--    procedure Find\n--      (Root_Directory : Dir_Name_Str;\n--       File_Pattern   : String);\n--    --  Recursively searches the directory structure rooted at Root_Directory.\n--    --  This provides functionality similar to the UNIX 'find' command.\n--    --  Action will be called for every item matching the regular expression\n--    --  File_Pattern (see GNAT.Regexp). Item is the full pathname to the file\n--    --  starting with Root_Directory that has been matched. Index is set to one\n--    --  for the first call and is incremented by one at each call. The iterator\n--    --  will pass in the value False on each call to Action. The iterator will\n--    --  terminate after passing the last matched path to Action or after\n--    --  returning from a call to Action which sets Quit to True.\n--    --  Raises GNAT.Regexp.Error_In_Regexp if File_Pattern is ill formed.\n-- \n-     function Read_Is_Thread_Safe return Boolean;\n-     --  Indicates if procedure Read is thread safe. On systems where the\n-     --  target system supports this functionality, Read is thread safe,\n---- 191,196 ----\n-***************\n-*** 259,263 ****\n---- 207,215 ----\n-     Null_Dir : constant Dir_Type := null;\n-  \n-     pragma Import (C, Dir_Separator, \"__gnat_dir_separator\");\n-+ \n-+    Dir_Seps : constant Ada.Strings.Maps.Character_Set :=\n-+                 Ada.Strings.Maps.To_Set (\"/\\\");\n-+    --  UNIX and DOS style directory separators.\n-  \n-  end GNAT.Directory_Operations;\n-\n-*** freeze.ads\t2001/10/29 02:06:04\t1.15\n---- freeze.ads\t2001/10/30 01:36:24\t1.16\n-***************\n-*** 205,210 ****\n---- 205,215 ----\n-     --  so need to be similarly treated. Freeze_Expression takes care of\n-     --  determining the proper insertion point for generated freeze actions.\n-  \n-+    procedure Freeze_Fixed_Point_Type (Typ : Entity_Id);\n-+    --  Freeze fixed point type. For fixed-point types, we have to defer\n-+    --  setting the size and bounds till the freeze point, since they are\n-+    --  potentially affected by the presence of size and small clauses.\n-+ \n-     procedure Freeze_Itype (T : Entity_Id; N : Node_Id);\n-     --  This routine is called when an Itype is created and must be frozen\n-     --  immediately at the point of creation (for the sake of the expansion\n-\n-*** impunit.adb\t2001/09/26 07:14:11\t1.14\n---- impunit.adb\t2001/10/30 04:33:45\t1.15\n-***************\n-*** 195,200 ****\n---- 195,201 ----\n-       \"g-curexc\",    -- GNAT.Current_Exception\n-       \"g-debpoo\",    -- GNAT.Debug_Pools\n-       \"g-debuti\",    -- GNAT.Debug_Utilities\n-+      \"g-diopit\",    -- GNAT.Directory_Operations.Iteration\n-       \"g-dirope\",    -- GNAT.Directory_Operations\n-       \"g-dyntab\",    -- GNAT.Dynamic_Tables\n-       \"g-exctra\",    -- GNAT.Exception_Traces\n-\n-*** g-regexp.adb\t2001/10/21 11:04:16\t1.28\n---- g-regexp.adb\t2001/10/30 15:25:04\t1.29\n-***************\n-*** 32,38 ****\n-  --                                                                          --\n-  ------------------------------------------------------------------------------\n-  \n-- with System.IO;\n-  with Unchecked_Deallocation;\n-  with Ada.Exceptions;\n-  with GNAT.Case_Util;\n---- 32,37 ----\n-***************\n-*** 73,82 ****\n-     end record;\n-     --  Deterministic finite-state machine\n-  \n--    Debug : constant Boolean := False;\n--    --  When True, the primary and secondary tables will be printed.\n--    --  Gnat does not generate any code if this variable is False;\n-- \n-     -----------------------\n-     -- Local Subprograms --\n-     -----------------------\n---- 72,77 ----\n-***************\n-*** 188,199 ****\n-        pragma No_Return (Raise_Exception);\n-        --  Raise an exception, indicating an error at character Index in S.\n-  \n--       procedure Print_Table\n--         (Table      : Regexp_Array;\n--          Num_States : State_Index;\n--          Is_Primary : Boolean := True);\n--       --  Print a table for debugging purposes\n-- \n-        --------------------\n-        -- Create_Mapping --\n-        --------------------\n---- 183,188 ----\n-***************\n-*** 1225,1309 ****\n-                 end loop;\n-              end loop;\n-  \n--             if Debug then\n--                System.IO.New_Line;\n--                System.IO.Put_Line (\"Secondary table : \");\n--                Print_Table (R.States, Nb_State, False);\n--             end if;\n-- \n-              return (Ada.Finalization.Controlled with R => R);\n-           end;\n-        end Create_Secondary_Table;\n-  \n--       -----------------\n--       -- Print_Table --\n--       -----------------\n-- \n--       procedure Print_Table\n--         (Table      : Regexp_Array;\n--          Num_States : State_Index;\n--          Is_Primary : Boolean := True)\n--       is\n--          function Reverse_Mapping (N : Column_Index) return Character;\n--          --  Return the character corresponding to a column in the mapping\n-- \n--          ---------------------\n--          -- Reverse_Mapping --\n--          ---------------------\n-- \n--          function Reverse_Mapping (N : Column_Index) return Character is\n--          begin\n--             for Column in Map'Range loop\n--                if Map (Column) = N then\n--                   return Column;\n--                end if;\n--             end loop;\n-- \n--             return ' ';\n--          end Reverse_Mapping;\n-- \n--       --  Start of processing for Print_Table\n-- \n--       begin\n--          --  Print the header line\n-- \n--          System.IO.Put (\"   [*]  \");\n-- \n--          for Column in 1 .. Alphabet_Size  loop\n--             System.IO.Put\n--               (String'(1 .. 1 => Reverse_Mapping (Column)) & \"   \");\n--          end loop;\n-- \n--          if Is_Primary then\n--             System.IO.Put (\"closure....\");\n--          end if;\n-- \n--          System.IO.New_Line;\n-- \n--          --  Print every line\n-- \n--          for State in 1 .. Num_States loop\n--             System.IO.Put (State'Img);\n-- \n--             for K in 1 .. 3 - State'Img'Length loop\n--                System.IO.Put (\" \");\n--             end loop;\n-- \n--             for K in 0 .. Alphabet_Size loop\n--                System.IO.Put (Table (State, K)'Img & \"  \");\n--             end loop;\n-- \n--             for K in Alphabet_Size + 1 .. Table'Last (2) loop\n--                if Table (State, K) /= 0 then\n--                   System.IO.Put (Table (State, K)'Img & \",\");\n--                end if;\n--             end loop;\n-- \n--             System.IO.New_Line;\n--          end loop;\n-- \n--       end Print_Table;\n-- \n-        ---------------------\n-        -- Raise_Exception --\n-        ---------------------\n---- 1214,1223 ----\n-***************\n-*** 1345,1356 ****\n-                (Table, Num_States, Start_State, End_State);\n-           end if;\n-  \n--          if Debug then\n--             Print_Table (Table.all, Num_States);\n--             System.IO.Put_Line (\"Start_State : \" & Start_State'Img);\n--             System.IO.Put_Line (\"End_State   : \" & End_State'Img);\n--          end if;\n-- \n-           --  Creates the secondary table\n-  \n-           R := Create_Secondary_Table\n---- 1259,1264 ----\n-***************\n-*** 1451,1467 ****\n-           New_Table := new Regexp_Array (Table'First (1) .. New_Lines,\n-                                          Table'First (2) .. New_Columns);\n-           New_Table.all := (others => (others => 0));\n-- \n--          if Debug then\n--             System.IO.Put_Line (\"Reallocating table: Lines from \"\n--                                 & State_Index'Image (Table'Last (1))\n--                                 & \" to \"\n--                                 & State_Index'Image (New_Lines));\n--             System.IO.Put_Line (\"   and columns from \"\n--                                 & Column_Index'Image (Table'Last (2))\n--                                 & \" to \"\n--                                 & Column_Index'Image (New_Columns));\n--          end if;\n-  \n-           for J in Table'Range (1) loop\n-              for K in Table'Range (2) loop\n---- 1359,1364 ----\n-\n-*** g-dirope.adb\t2001/10/31 21:36:04\t1.20\n---- g-dirope.adb\t2001/11/01 16:39:33\t1.21\n-***************\n-*** 371,387 ****\n-                 E := E + 1;\n-  \n-                 Var_Name : loop\n-!                   exit Var_Name when E = Path'Last;\n-  \n-                    if Characters.Handling.Is_Letter (Path (E))\n-                      or else Characters.Handling.Is_Digit (Path (E))\n-                    then\n-                       E := E + 1;\n-                    else\n--                      E := E - 1;\n-                       exit Var_Name;\n-                    end if;\n-                 end loop Var_Name;\n-  \n-                 declare\n-                    Env : OS_Lib.String_Access := OS_Lib.Getenv (Path (K .. E));\n---- 371,388 ----\n-                 E := E + 1;\n-  \n-                 Var_Name : loop\n-!                   exit Var_Name when E > Path'Last;\n-  \n-                    if Characters.Handling.Is_Letter (Path (E))\n-                      or else Characters.Handling.Is_Digit (Path (E))\n-                    then\n-                       E := E + 1;\n-                    else\n-                       exit Var_Name;\n-                    end if;\n-                 end loop Var_Name;\n-+ \n-+                E := E - 1;\n-  \n-                 declare\n-                    Env : OS_Lib.String_Access := OS_Lib.Getenv (Path (K .. E));\n 2001-12-11  Ed Schonberg <schonber@gnat.com>\n \n \t* sem_ch10.adb (Install_Withed_Unit): If the unit is a generic instance"}]}