{"sha": "97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "node_id": "C_kwDOANBUbNoAKDk3Y2ZiNTRjM2ZmMTViOTY5MWZkMWMxMmEyOWRlNTY5NjZiZjhlMGQ", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T07:24:12Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-09-21T16:55:14Z"}, "message": "path solver: Use ranger to solve unknowns.\n\nThe default behavior for the path solver is to resort to VARYING when\nthe range for an unknown SSA is outside the given path.  This is both\ncheap and fast, but fails to get a significant amount of ranges that\ntraditionally the DOM and VRP threaders could get.\n\nThis patch uses the ranger to resolve any unknown names upon entry to\nthe path.  It also uses equivalences to improve ranges.\n\ngcc/ChangeLog:\n\n\t* gimple-range-path.cc (path_range_query::defined_outside_path):\n\tNew.\n\t(path_range_query::range_on_path_entry): New.\n\t(path_range_query::internal_range_of_expr): Resolve unknowns\n\twith ranger.\n\t(path_range_query::improve_range_with_equivs): New.\n\t(path_range_query::ssa_range_in_phi): Resolve unknowns with\n\tranger.\n\t* gimple-range-path.h (class path_range_query): Add\n\tdefined_outside_path, range_on_path_entry, and\n\timprove_range_with_equivs.", "tree": {"sha": "8d7f17bee680f8445056a4ced6d40cdeaa35d683", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8d7f17bee680f8445056a4ced6d40cdeaa35d683"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e4249b10038bd906f50c00759b37807dd2fffede", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4249b10038bd906f50c00759b37807dd2fffede", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4249b10038bd906f50c00759b37807dd2fffede"}], "stats": {"total": 92, "additions": 88, "deletions": 4}, "files": [{"sha": "e65c7996bb76fb0925fd094154fa0ea5074d32ae", "filename": "gcc/gimple-range-path.cc", "status": "modified", "additions": 85, "deletions": 4, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d/gcc%2Fgimple-range-path.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d/gcc%2Fgimple-range-path.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.cc?ref=97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "patch": "@@ -121,6 +121,34 @@ path_range_query::debug ()\n   dump (stderr);\n }\n \n+// Return TRUE if NAME is defined outside the current path.\n+\n+bool\n+path_range_query::defined_outside_path (tree name)\n+{\n+  gimple *def = SSA_NAME_DEF_STMT (name);\n+  basic_block bb = gimple_bb (def);\n+\n+  return !bb || !m_path->contains (bb);\n+}\n+\n+// Return the range of NAME on entry to the path.\n+\n+void\n+path_range_query::range_on_path_entry (irange &r, tree name)\n+{\n+  int_range_max tmp;\n+  basic_block entry = entry_bb ();\n+  r.set_undefined ();\n+  for (unsigned i = 0; i < EDGE_COUNT (entry->preds); ++i)\n+    {\n+      edge e = EDGE_PRED (entry, i);\n+      if (e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun)\n+\t  && m_ranger.range_on_edge (tmp, e, name))\n+\tr.union_ (tmp);\n+    }\n+}\n+\n // Return the range of NAME at the end of the path being analyzed.\n \n bool\n@@ -132,13 +160,26 @@ path_range_query::internal_range_of_expr (irange &r, tree name, gimple *stmt)\n   if (get_cache (r, name))\n     return true;\n \n+  if (m_resolve && defined_outside_path (name))\n+    {\n+      range_on_path_entry (r, name);\n+\n+      if (r.varying_p ())\n+\timprove_range_with_equivs (r, name);\n+\n+      set_cache (r, name);\n+      return true;\n+    }\n \n   basic_block bb = stmt ? gimple_bb (stmt) : exit_bb ();\n   if (stmt && range_defined_in_block (r, name, bb))\n     {\n       if (TREE_CODE (name) == SSA_NAME)\n \tr.intersect (gimple_range_global (name));\n \n+      if (m_resolve && r.varying_p ())\n+\timprove_range_with_equivs (r, name);\n+\n       set_cache (r, name);\n       return true;\n     }\n@@ -160,6 +201,33 @@ path_range_query::range_of_expr (irange &r, tree name, gimple *stmt)\n   return false;\n }\n \n+// Improve the range of NAME with the range of any of its equivalences.\n+\n+void\n+path_range_query::improve_range_with_equivs (irange &r, tree name)\n+{\n+  if (TREE_CODE (name) != SSA_NAME)\n+    return;\n+\n+  basic_block entry = entry_bb ();\n+  relation_oracle *oracle = m_ranger.oracle ();\n+\n+  if (const bitmap_head *equivs = oracle->equiv_set (name, entry))\n+    {\n+      int_range_max t;\n+      bitmap_iterator bi;\n+      unsigned i;\n+\n+      EXECUTE_IF_SET_IN_BITMAP (equivs, 0, i, bi)\n+\tif (i != SSA_NAME_VERSION (name) && r.varying_p ())\n+\t  {\n+\t    tree equiv = ssa_name (i);\n+\t    range_on_path_entry (t, equiv);\n+\t    r.intersect (t);\n+\t  }\n+    }\n+}\n+\n bool\n path_range_query::unreachable_path_p ()\n {\n@@ -189,10 +257,11 @@ path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n   tree name = gimple_phi_result (phi);\n   basic_block bb = gimple_bb (phi);\n \n-  // We experimented with querying ranger's range_on_entry here, but\n-  // the performance penalty was too high, for hardly any improvements.\n   if (at_entry ())\n     {\n+      if (m_resolve && m_ranger.range_of_expr (r, name, phi))\n+\treturn;\n+\n       // Try fold just in case we can resolve simple things like PHI <5(99), 6(88)>.\n       if (!fold_range (r, phi, this))\n \tr.set_varying (TREE_TYPE (name));\n@@ -210,8 +279,20 @@ path_range_query::ssa_range_in_phi (irange &r, gphi *phi)\n \ttree arg = gimple_phi_arg_def (phi, i);\n \n \tif (!get_cache (r, arg))\n-\t  r.set_varying (TREE_TYPE (name));\n-\n+\t  {\n+\t    if (m_resolve)\n+\t      {\n+\t\tint_range_max tmp;\n+\t\t// Using both the range on entry to the path, and the\n+\t\t// range on this edge yields significantly better\n+\t\t// results.\n+\t\trange_on_path_entry (r, arg);\n+\t\tm_ranger.range_on_edge (tmp, e_in, arg);\n+\t\tr.intersect (tmp);\n+\t\treturn;\n+\t      }\n+\t    r.set_varying (TREE_TYPE (name));\n+\t  }\n \treturn;\n       }\n   gcc_unreachable ();"}, {"sha": "6f81f21d42f6270d12df378f5aed38c09be6f3ab", "filename": "gcc/gimple-range-path.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d/gcc%2Fgimple-range-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97cfb54c3ff15b9691fd1c12a29de56966bf8e0d/gcc%2Fgimple-range-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-range-path.h?ref=97cfb54c3ff15b9691fd1c12a29de56966bf8e0d", "patch": "@@ -48,6 +48,8 @@ class path_range_query : public range_query\n \n private:\n   bool internal_range_of_expr (irange &r, tree name, gimple *);\n+  bool defined_outside_path (tree name);\n+  void range_on_path_entry (irange &r, tree name);\n \n   // Cache manipulation.\n   void set_cache (const irange &r, tree name);\n@@ -61,6 +63,7 @@ class path_range_query : public range_query\n   void ssa_range_in_phi (irange &r, gphi *phi);\n   void precompute_relations (const vec<basic_block> &);\n   void precompute_phi_relations (basic_block bb, basic_block prev);\n+  void improve_range_with_equivs (irange &r, tree name);\n   void add_copies_to_imports ();\n   bool add_to_imports (tree name, bitmap imports);\n "}]}