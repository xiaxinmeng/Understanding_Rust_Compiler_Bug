{"sha": "d7deee423f993bee8ee440f6fe0c9126c316c64b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdkZWVlNDIzZjk5M2JlZThlZTQ0MGY2ZmUwYzkxMjZjMzE2YzY0Yg==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-16T11:18:46Z"}, "committer": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2021-06-16T11:23:14Z"}, "message": "tree-sra: Do not refresh readonly decls (PR 100453)\n\nWhen SRA transforms an assignment where the RHS is an aggregate decl\nthat it creates replacements for, the (least efficient) fallback\nmethod of dealing with them is to store all the replacements back into\nthe original decl and then let the original assignment takes its\ncourse.\n\nThat of course should not need to be done for TREE_READONLY bases\nwhich cannot change contents.  The SRA code handled this situation\nonly for DECL_IN_CONSTANT_POOL const decls, this patch modifies the\ncheck so that it tests for TREE_READONLY and I also looked at all\nother callers of generate_subtree_copies and added checks to another\none dealing with the same exact situation and one which deals with it\nin a non-assignment context.\n\ngcc/ChangeLog:\n\n2021-06-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/100453\n\t* tree-sra.c (create_access): Disqualify any const candidates\n\twhich are written to.\n\t(sra_modify_expr): Do not store sub-replacements back to a const base.\n\t(handle_unscalarized_data_in_subtree): Likewise.\n\t(sra_modify_assign): Likewise.  Earlier, use TREE_READONLy test\n\tinstead of constant_decl_p.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-10  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/100453\n\t* gcc.dg/tree-ssa/pr100453.c: New test.", "tree": {"sha": "5a3bb7aaab48cc4b86f7677ed7963243a817f760", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a3bb7aaab48cc4b86f7677ed7963243a817f760"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7deee423f993bee8ee440f6fe0c9126c316c64b", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEE5elVTFt/d09Vsoczv2PBvD+kNUAFAmDJ3zwACgkQv2PBvD+k\nNUA31xAAu6xVbe25K9A6/YyfvEhvvncOSUMZ7SfQ0HnYzN5eoAIF4npXC2Jo8Wkp\n1lDMYLXn1fiKVozhS9n8wL7cQVlM/ywT59p0KHQfYzxyhgCr9/l+pgUPwmy1wEm3\nKowkUTiZ/SkxuoHY8EDtGT4bhJjKmYk1+UMuKmGfbOx2CIqcs0psUMd9kLZhkaGq\n2stBQe+VdHPT41QYLmkQ/jNk3JHieFOXhsRjKyYJCLLnU2j2WBIHHJ1TpnygQFkz\nhwEa0MN3X3liH+GjUbWX3VP0eqaD4eQ6e6pTkHkAD6XbpSUXFinjNbqdlj76bEmn\nnwIYI8R5uDOu6ab5AQjIXupIsaC1pmsXCL1Mc3fkuttxKvt++0j6q0E6tOOvwef6\n3J427GU5GzF4UaY0Z2/xIHNZq3uO/QTCU2XubS25umxW2pHRLHpJ2zhp6Exu6W7c\n/lp2YMstwAF0y08OEdcX8Qc9zPvWK77krOh44H4xUC/Ki/jszOaIQRLbOnGqxhiq\n+lug5BrdcB4+ybY/LXqmdSXZbdIJJeFkl9j4q8gL1HSQ0HtgGoSZJIWugO/+dm8S\nE/xZ9/QeTy/a8ObdCcvAoHQJWysf738FJf9Ubhi78So5mcO30fA0HXgHMmGX/2tQ\nyeEIObnMoP2QMUGeNRrAwDB3PSIeIn4B+FTBGx242qocqePGNeU=\n=h1tf\n-----END PGP SIGNATURE-----", "payload": "tree 5a3bb7aaab48cc4b86f7677ed7963243a817f760\nparent a490b1dc0b3c26bff2ee00ac0da2d606d2009e3a\nauthor Martin Jambor <mjambor@suse.cz> 1623842326 +0200\ncommitter Martin Jambor <mjambor@suse.cz> 1623842594 +0200\n\ntree-sra: Do not refresh readonly decls (PR 100453)\n\nWhen SRA transforms an assignment where the RHS is an aggregate decl\nthat it creates replacements for, the (least efficient) fallback\nmethod of dealing with them is to store all the replacements back into\nthe original decl and then let the original assignment takes its\ncourse.\n\nThat of course should not need to be done for TREE_READONLY bases\nwhich cannot change contents.  The SRA code handled this situation\nonly for DECL_IN_CONSTANT_POOL const decls, this patch modifies the\ncheck so that it tests for TREE_READONLY and I also looked at all\nother callers of generate_subtree_copies and added checks to another\none dealing with the same exact situation and one which deals with it\nin a non-assignment context.\n\ngcc/ChangeLog:\n\n2021-06-11  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/100453\n\t* tree-sra.c (create_access): Disqualify any const candidates\n\twhich are written to.\n\t(sra_modify_expr): Do not store sub-replacements back to a const base.\n\t(handle_unscalarized_data_in_subtree): Likewise.\n\t(sra_modify_assign): Likewise.  Earlier, use TREE_READONLy test\n\tinstead of constant_decl_p.\n\ngcc/testsuite/ChangeLog:\n\n2021-06-10  Martin Jambor  <mjambor@suse.cz>\n\n\tPR tree-optimization/100453\n\t* gcc.dg/tree-ssa/pr100453.c: New test.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7deee423f993bee8ee440f6fe0c9126c316c64b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7deee423f993bee8ee440f6fe0c9126c316c64b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7deee423f993bee8ee440f6fe0c9126c316c64b/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a490b1dc0b3c26bff2ee00ac0da2d606d2009e3a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a490b1dc0b3c26bff2ee00ac0da2d606d2009e3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a490b1dc0b3c26bff2ee00ac0da2d606d2009e3a"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "0cf0ad23815350f4be1eacc72432ff25bca8b82a", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr100453.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7deee423f993bee8ee440f6fe0c9126c316c64b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100453.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7deee423f993bee8ee440f6fe0c9126c316c64b/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100453.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr100453.c?ref=d7deee423f993bee8ee440f6fe0c9126c316c64b", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-do run } */\n+/* { dg-options \"-O1\" } */\n+\n+struct a {\n+  int b : 4;\n+} d;\n+static int c, e;\n+static const struct a f;\n+static void g(const struct a h) {\n+  for (; c < 1; c++)\n+    d = h;\n+  e = h.b;\n+  c = h.b;\n+}\n+int main() {\n+  g(f);\n+  return 0;\n+}"}, {"sha": "5e86d3fbb9dfdcfb5563f54f3d3b60aa40ea33e1", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7deee423f993bee8ee440f6fe0c9126c316c64b/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7deee423f993bee8ee440f6fe0c9126c316c64b/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=d7deee423f993bee8ee440f6fe0c9126c316c64b", "patch": "@@ -915,6 +915,12 @@ create_access (tree expr, gimple *stmt, bool write)\n   if (!DECL_P (base) || !bitmap_bit_p (candidate_bitmap, DECL_UID (base)))\n     return NULL;\n \n+  if (write && TREE_READONLY (base))\n+    {\n+      disqualify_candidate (base, \"Encountered a store to a read-only decl.\");\n+      return NULL;\n+    }\n+\n   HOST_WIDE_INT offset, size, max_size;\n   if (!poffset.is_constant (&offset)\n       || !psize.is_constant (&size)\n@@ -3826,7 +3832,7 @@ sra_modify_expr (tree *expr, gimple_stmt_iterator *gsi, bool write)\n       gsi_insert_after (gsi, ds, GSI_NEW_STMT);\n     }\n \n-  if (access->first_child)\n+  if (access->first_child && !TREE_READONLY (access->base))\n     {\n       HOST_WIDE_INT start_offset, chunk_size;\n       if (bfr\n@@ -3890,6 +3896,13 @@ static void\n handle_unscalarized_data_in_subtree (struct subreplacement_assignment_data *sad)\n {\n   tree src;\n+  /* If the RHS is a load from a constant, we do not need to (and must not)\n+     flush replacements to it and can use it directly as if we did.  */\n+  if (TREE_READONLY (sad->top_racc->base))\n+    {\n+      sad->refreshed = SRA_UDH_RIGHT;\n+      return;\n+    }\n   if (sad->top_racc->grp_unscalarized_data)\n     {\n       src = sad->assignment_rhs;\n@@ -4243,8 +4256,8 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n       || contains_vce_or_bfcref_p (lhs)\n       || stmt_ends_bb_p (stmt))\n     {\n-      /* No need to copy into a constant-pool, it comes pre-initialized.  */\n-      if (access_has_children_p (racc) && !constant_decl_p (racc->base))\n+      /* No need to copy into a constant, it comes pre-initialized.  */\n+      if (access_has_children_p (racc) && !TREE_READONLY (racc->base))\n \tgenerate_subtree_copies (racc->first_child, rhs, racc->offset, 0, 0,\n \t\t\t\t gsi, false, false, loc);\n       if (access_has_children_p (lacc))\n@@ -4333,7 +4346,7 @@ sra_modify_assign (gimple *stmt, gimple_stmt_iterator *gsi)\n \t    }\n \t  /* Restore the aggregate RHS from its components so the\n \t     prevailing aggregate copy does the right thing.  */\n-\t  if (access_has_children_p (racc))\n+\t  if (access_has_children_p (racc) && !TREE_READONLY (racc->base))\n \t    generate_subtree_copies (racc->first_child, rhs, racc->offset, 0, 0,\n \t\t\t\t     gsi, false, false, loc);\n \t  /* Re-load the components of the aggregate copy destination."}]}