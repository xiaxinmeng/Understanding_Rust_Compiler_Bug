{"sha": "89aec4b191cba0ac6433229c6af10f1273a349db", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODlhZWM0YjE5MWNiYTBhYzY0MzMyMjljNmFmMTBmMTI3M2EzNDlkYg==", "commit": {"author": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-17T00:06:38Z"}, "committer": {"name": "Nathanael Nerode", "email": "neroden@gcc.gnu.org", "date": "2003-06-17T00:06:38Z"}, "message": "mangle.c: Convert to ISO C.\n\n\t2003-06-16  Jens-Michael Hoffmann  <jensmh@gmx.de>\n\t* mangle.c: Convert to ISO C.\n\nFrom-SVN: r68050", "tree": {"sha": "7a7059a07c23338533da58558614d6b438e0bc57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7a7059a07c23338533da58558614d6b438e0bc57"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/89aec4b191cba0ac6433229c6af10f1273a349db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89aec4b191cba0ac6433229c6af10f1273a349db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/89aec4b191cba0ac6433229c6af10f1273a349db", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/89aec4b191cba0ac6433229c6af10f1273a349db/comments", "author": null, "committer": null, "parents": [{"sha": "0a84d874f1b8dd6d93b426b6a66cd028a81406b4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0a84d874f1b8dd6d93b426b6a66cd028a81406b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0a84d874f1b8dd6d93b426b6a66cd028a81406b4"}], "stats": {"total": 337, "additions": 136, "deletions": 201}, "files": [{"sha": "d74a2b50b9dc67ac356e54f6be3e672544b818aa", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89aec4b191cba0ac6433229c6af10f1273a349db/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89aec4b191cba0ac6433229c6af10f1273a349db/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=89aec4b191cba0ac6433229c6af10f1273a349db", "patch": "@@ -1,3 +1,8 @@\n+2003-06-16  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t2003-06-16  Jens-Michael Hoffmann  <jensmh@gmx.de>\n+\t* mangle.c: Convert to ISO C.\n+\n 2003-06-16  Kaveh R. Ghazi  <ghazi@caip.rutgers.edu>\n \n \t* cp/decl.c, cp/pt.c, cp/search.c, cp/tree.c: Don't use the PTR"}, {"sha": "c0d31ba79083ce72afd3ee80ddf5c49fa3cbd81b", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 131, "deletions": 201, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/89aec4b191cba0ac6433229c6af10f1273a349db/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/89aec4b191cba0ac6433229c6af10f1273a349db/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=89aec4b191cba0ac6433229c6af10f1273a349db", "patch": "@@ -148,71 +148,74 @@ integer_type_codes[itk_none] =\n   'y'   /* itk_unsigned_long_long */\n };\n \n-static int decl_is_template_id PARAMS ((tree, tree*));\n+static int decl_is_template_id (const tree, tree* const);\n \n /* Functions for handling substitutions.  */\n \n-static inline tree canonicalize_for_substitution PARAMS ((tree));\n-static void add_substitution PARAMS ((tree));\n-static inline int is_std_substitution PARAMS ((tree, substitution_identifier_index_t));\n-static inline int is_std_substitution_char PARAMS ((tree, substitution_identifier_index_t));\n-static int find_substitution PARAMS ((tree));\n-static void mangle_call_offset PARAMS ((tree, tree));\n+static inline tree canonicalize_for_substitution (tree);\n+static void add_substitution (tree);\n+static inline int is_std_substitution (const tree,\n+\t\t\t\t       const substitution_identifier_index_t);\n+static inline int is_std_substitution_char (const tree,\n+\t\t\t\t\t    const substitution_identifier_index_t);\n+static int find_substitution (tree);\n+static void mangle_call_offset (const tree, const tree);\n \n /* Functions for emitting mangled representations of things.  */\n \n-static void write_mangled_name PARAMS ((tree));\n-static void write_encoding PARAMS ((tree));\n-static void write_name PARAMS ((tree, int));\n-static void write_unscoped_name PARAMS ((tree));\n-static void write_unscoped_template_name PARAMS ((tree));\n-static void write_nested_name PARAMS ((tree));\n-static void write_prefix PARAMS ((tree));\n-static void write_template_prefix PARAMS ((tree));\n-static void write_unqualified_name PARAMS ((tree));\n-static void write_conversion_operator_name (tree);\n-static void write_source_name PARAMS ((tree));\n-static int hwint_to_ascii PARAMS ((unsigned HOST_WIDE_INT, unsigned int, char *, unsigned));\n-static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n-\t\t\t\t  unsigned int));\n-static void write_integer_cst PARAMS ((tree));\n-static void write_real_cst PARAMS ((tree));\n-static void write_identifier PARAMS ((const char *));\n-static void write_special_name_constructor PARAMS ((tree));\n-static void write_special_name_destructor PARAMS ((tree));\n-static void write_type PARAMS ((tree));\n-static int write_CV_qualifiers_for_type PARAMS ((tree));\n-static void write_builtin_type PARAMS ((tree));\n-static void write_function_type PARAMS ((tree));\n-static void write_bare_function_type PARAMS ((tree, int, tree));\n-static void write_method_parms PARAMS ((tree, int, tree));\n-static void write_class_enum_type PARAMS ((tree));\n-static void write_template_args PARAMS ((tree));\n-static void write_expression PARAMS ((tree));\n-static void write_template_arg_literal PARAMS ((tree));\n-static void write_template_arg PARAMS ((tree));\n-static void write_template_template_arg PARAMS ((tree));\n-static void write_array_type PARAMS ((tree));\n-static void write_pointer_to_member_type PARAMS ((tree));\n-static void write_template_param PARAMS ((tree));\n-static void write_template_template_param PARAMS ((tree));\n-static void write_substitution PARAMS ((int));\n-static int discriminator_for_local_entity PARAMS ((tree));\n-static int discriminator_for_string_literal PARAMS ((tree, tree));\n-static void write_discriminator PARAMS ((int));\n-static void write_local_name PARAMS ((tree, tree, tree));\n-static void dump_substitution_candidates PARAMS ((void));\n-static const char *mangle_decl_string PARAMS ((tree));\n+static void write_mangled_name (const tree);\n+static void write_encoding (const tree);\n+static void write_name (tree, const int);\n+static void write_unscoped_name (const tree);\n+static void write_unscoped_template_name (const tree);\n+static void write_nested_name (const tree);\n+static void write_prefix (const tree);\n+static void write_template_prefix (const tree);\n+static void write_unqualified_name (const tree);\n+static void write_conversion_operator_name (const tree);\n+static void write_source_name (tree);\n+static int hwint_to_ascii (unsigned HOST_WIDE_INT, const unsigned int, char *,\n+\t\t\t   const unsigned int);\n+static void write_number (unsigned HOST_WIDE_INT, const int,\n+\t\t\t  const unsigned int);\n+static void write_integer_cst (const tree);\n+static void write_real_cst (const tree);\n+static void write_identifier (const char *);\n+static void write_special_name_constructor (const tree);\n+static void write_special_name_destructor (const tree);\n+static void write_type (tree);\n+static int write_CV_qualifiers_for_type (const tree);\n+static void write_builtin_type (tree);\n+static void write_function_type (const tree);\n+static void write_bare_function_type (const tree, const int, const tree);\n+static void write_method_parms (tree, const int, const tree);\n+static void write_class_enum_type (const tree);\n+static void write_template_args (tree);\n+static void write_expression (tree);\n+static void write_template_arg_literal (const tree);\n+static void write_template_arg (tree);\n+static void write_template_template_arg (const tree);\n+static void write_array_type (const tree);\n+static void write_pointer_to_member_type (const tree);\n+static void write_template_param (const tree);\n+static void write_template_template_param (const tree);\n+static void write_substitution (const int);\n+static int discriminator_for_local_entity (tree);\n+static int discriminator_for_string_literal (tree, tree);\n+static void write_discriminator (const int);\n+static void write_local_name (const tree, const tree, const tree);\n+static void dump_substitution_candidates (void);\n+static const char *mangle_decl_string (const tree);\n \n /* Control functions.  */\n \n-static inline void start_mangling (tree);\n-static inline const char *finish_mangling (bool);\n-static tree mangle_special_for_type PARAMS ((tree, const char *));\n+static inline void start_mangling (const tree);\n+static inline const char *finish_mangling (const bool);\n+static tree mangle_special_for_type (const tree, const char *);\n \n /* Foreign language functions.  */\n \n-static void write_java_integer_type_codes PARAMS ((tree));\n+static void write_java_integer_type_codes (const tree);\n \n /* Append a single character to the end of the mangled\n    representation.  */\n@@ -249,15 +252,13 @@ static void write_java_integer_type_codes PARAMS ((tree));\n    Otherwise return zero.  */\n \n static int\n-decl_is_template_id (decl, template_info)\n-     tree decl;\n-     tree* template_info;\n+decl_is_template_id (const tree decl, tree* const template_info)\n {\n   if (TREE_CODE (decl) == TYPE_DECL)\n     {\n       /* TYPE_DECLs are handled specially.  Look at its type to decide\n \t if this is a template instantiation.  */\n-      tree type = TREE_TYPE (decl);\n+      const tree type = TREE_TYPE (decl);\n \n       if (CLASS_TYPE_P (type) && CLASSTYPE_TEMPLATE_ID_P (type))\n \t{\n@@ -328,8 +329,7 @@ dump_substitution_candidates ()\n    and substitution candidates and finding matches.  */\n \n static inline tree\n-canonicalize_for_substitution (node)\n-     tree node;\n+canonicalize_for_substitution (tree node)\n {\n   /* For a TYPE_DECL, use the type instead.  */\n   if (TREE_CODE (node) == TYPE_DECL)\n@@ -344,8 +344,7 @@ canonicalize_for_substitution (node)\n    the list of candidates.  */\n \n static void\n-add_substitution (node)\n-     tree node;\n+add_substitution (tree node)\n {\n   tree c;\n \n@@ -366,7 +365,7 @@ add_substitution (node)\n     int i;\n     for (i = VARRAY_ACTIVE_SIZE (G.substitutions); --i >= 0; )\n       {\n-\ttree candidate = VARRAY_TREE (G.substitutions, i);\n+\tconst tree candidate = VARRAY_TREE (G.substitutions, i);\n \tif ((DECL_P (node) \n \t     && node == candidate)\n \t    || (TYPE_P (node) \n@@ -389,9 +388,8 @@ add_substitution (node)\n    name of substitution_index[INDEX] in the ::std namespace.  */\n \n static inline int \n-is_std_substitution (node, index)\n-     tree node;\n-     substitution_identifier_index_t index;\n+is_std_substitution (const tree node,\n+\t\t     const substitution_identifier_index_t index)\n {\n   tree type = NULL;\n   tree decl = NULL;\n@@ -423,9 +421,8 @@ is_std_substitution (node, index)\n    substitution_index[INDEX].  */\n \n static inline int\n-is_std_substitution_char (node, index)\n-     tree node;\n-     substitution_identifier_index_t index;\n+is_std_substitution_char (const tree node,\n+\t\t\t  const substitution_identifier_index_t index)\n {\n   tree args;\n   /* Check NODE's name is ::std::identifier.  */\n@@ -480,11 +477,10 @@ is_std_substitution_char (node, index)\n    return nonzero.  If none is found, just return zero.  */\n \n static int\n-find_substitution (node)\n-     tree node;\n+find_substitution (tree node)\n {\n   int i;\n-  int size = VARRAY_ACTIVE_SIZE (G.substitutions);\n+  const int size = VARRAY_ACTIVE_SIZE (G.substitutions);\n   tree decl;\n   tree type;\n \n@@ -613,8 +609,7 @@ find_substitution (node)\n /*  <mangled-name>      ::= _Z <encoding>  */\n \n static inline void\n-write_mangled_name (decl)\n-     tree decl;\n+write_mangled_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"mangled-name\", decl);\n \n@@ -639,8 +634,7 @@ write_mangled_name (decl)\n \t\t\t::= <data name>  */\n \n static void\n-write_encoding (decl)\n-     tree decl;\n+write_encoding (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"encoding\", decl);\n \n@@ -686,9 +680,7 @@ write_encoding (decl)\n    production, to avoid an infinite recursion.  */\n \n static void\n-write_name (decl, ignore_local_scope)\n-     tree decl;\n-     int ignore_local_scope;\n+write_name (tree decl, const int ignore_local_scope)\n {\n   tree context;\n \n@@ -770,8 +762,7 @@ write_name (decl, ignore_local_scope)\n                    ::= St <unqualified-name>   # ::std::  */\n \n static void\n-write_unscoped_name (decl)\n-     tree decl;\n+write_unscoped_name (const tree decl)\n {\n   tree context = CP_DECL_CONTEXT (decl);\n \n@@ -797,8 +788,7 @@ write_unscoped_name (decl)\n                             ::= <substitution>  */\n \n static void\n-write_unscoped_template_name (decl)\n-     tree decl;\n+write_unscoped_template_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"unscoped-template-name\", decl);\n \n@@ -816,8 +806,7 @@ write_unscoped_template_name (decl)\n    <CV-qualifiers> ::= [r] [V] [K]  */\n \n static void\n-write_nested_name (decl)\n-     tree decl;\n+write_nested_name (const tree decl)\n {\n   tree template_info;\n \n@@ -858,8 +847,7 @@ write_nested_name (decl)\n \t    ::= <substitution>  */\n \n static void\n-write_prefix (node)\n-     tree node;\n+write_prefix (const tree node)\n {\n   tree decl;\n   /* Non-NULL if NODE represents a template-id.  */\n@@ -924,8 +912,7 @@ write_prefix (node)\n                      ::= <substitution>  */\n \n static void\n-write_template_prefix (node)\n-     tree node;\n+write_template_prefix (const tree node)\n {\n   tree decl = DECL_P (node) ? node : TYPE_NAME (node);\n   tree type = DECL_P (node) ? TREE_TYPE (node) : node;\n@@ -1000,8 +987,7 @@ write_template_prefix (node)\n \t\t\t::= <source-name>  */\n \n static void\n-write_unqualified_name (decl)\n-     tree decl;\n+write_unqualified_name (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"unqualified-name\", decl);\n \n@@ -1040,7 +1026,7 @@ write_unqualified_name (decl)\n /* Write the unqualified-name for a conversion operator to TYPE.  */\n \n static void\n-write_conversion_operator_name (tree type)\n+write_conversion_operator_name (const tree type)\n {\n   write_string (\"cv\");\n   write_type (type);\n@@ -1051,8 +1037,7 @@ write_conversion_operator_name (tree type)\n      <source-name> ::= </length/ number> <identifier>  */\n \n static void\n-write_source_name (identifier)\n-     tree identifier;\n+write_source_name (tree identifier)\n {\n   MANGLE_TRACE_TREE (\"source-name\", identifier);\n \n@@ -1072,11 +1057,8 @@ write_source_name (identifier)\n    BUFFER points).  */\n \n static int\n-hwint_to_ascii (number, base, buffer, min_digits)\n-     unsigned HOST_WIDE_INT number;\n-     unsigned int base;\n-     char *buffer;\n-     unsigned min_digits;\n+hwint_to_ascii (unsigned HOST_WIDE_INT number, const unsigned int base,\n+\t\tchar *buffer, const unsigned int min_digits)\n {\n   static const char base_digits[] = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n   unsigned digits = 0;\n@@ -1102,10 +1084,8 @@ hwint_to_ascii (number, base, buffer, min_digits)\n      <number> ::= [n] </decimal integer/>  */\n \n static void\n-write_number (number, unsigned_p, base)\n-     unsigned HOST_WIDE_INT number;\n-     int unsigned_p;\n-     unsigned int base;\n+write_number (unsigned HOST_WIDE_INT number, const int unsigned_p,\n+\t      const unsigned int base)\n {\n   char buffer[sizeof (HOST_WIDE_INT) * 8];\n   unsigned count = 0;\n@@ -1124,8 +1104,7 @@ write_number (number, unsigned_p, base)\n    bigger than that, which we must deal with.  */\n \n static inline void\n-write_integer_cst (cst)\n-     tree cst;\n+write_integer_cst (const tree cst)\n {\n   int sign = tree_int_cst_sgn (cst);\n \n@@ -1168,7 +1147,7 @@ write_integer_cst (cst)\n \t  tree d = fold (build (FLOOR_DIV_EXPR, type, n, base));\n \t  tree tmp = fold (build (MULT_EXPR, type, d, base));\n \t  unsigned c;\n-\t  \n+\n \t  done = integer_zerop (d);\n \t  tmp = fold (build (MINUS_EXPR, type, n, tmp));\n \t  c = hwint_to_ascii (TREE_INT_CST_LOW (tmp), 10, ptr,\n@@ -1215,8 +1194,7 @@ write_integer_cst (cst)\n \n    Caller is responsible for the Lx and the E.  */\n static void\n-write_real_cst (value)\n-     tree value;\n+write_real_cst (const tree value)\n {\n   if (abi_version_at_least (2))\n     {\n@@ -1265,8 +1243,7 @@ write_real_cst (value)\n      <identifier> ::= </unqualified source code identifier>  */\n \n static void\n-write_identifier (identifier)\n-     const char *identifier;\n+write_identifier (const char *identifier)\n {\n   MANGLE_TRACE (\"identifier\", identifier);\n   write_string (identifier);\n@@ -1286,8 +1263,7 @@ write_identifier (identifier)\n    append *INTERNAL* to that, to make sure we never emit it.  */\n \n static void\n-write_special_name_constructor (ctor)\n-     tree ctor;\n+write_special_name_constructor (const tree ctor)\n {\n   if (DECL_COMPLETE_CONSTRUCTOR_P (ctor)\n       /* Even though we don't ever emit a definition of the\n@@ -1313,8 +1289,7 @@ write_special_name_constructor (ctor)\n    append *INTERNAL* to that, to make sure we never emit it.  */\n \n static void\n-write_special_name_destructor (dtor)\n-     tree dtor;\n+write_special_name_destructor (const tree dtor)\n {\n   if (DECL_DELETING_DESTRUCTOR_P (dtor))\n     write_string (\"D0\");\n@@ -1335,14 +1310,12 @@ write_special_name_destructor (dtor)\n    entities with the same name in the same FUNCTION.  */\n \n static int\n-discriminator_for_local_entity (entity)\n-     tree entity;\n+discriminator_for_local_entity (tree entity)\n {\n   tree *type;\n-  int discriminator;\n \n   /* Assume this is the only local entity with this name.  */\n-  discriminator = 0;\n+  int discriminator = 0;\n \n   if (DECL_DISCRIMINATOR_P (entity) && DECL_LANG_SPECIFIC (entity))\n     discriminator = DECL_DISCRIMINATOR (entity);\n@@ -1379,8 +1352,7 @@ discriminator_for_string_literal (function, string)\n    n - 2, if this is the nth occurrence, in lexical order.  */\n \n static void\n-write_discriminator (discriminator)\n-     int discriminator;\n+write_discriminator (const int discriminator)\n {\n   /* If discriminator is zero, don't write anything.  Otherwise...  */\n   if (discriminator > 0)\n@@ -1400,10 +1372,8 @@ write_discriminator (discriminator)\n                   := Z <function encoding> E s [<discriminator>]  */\n \n static void\n-write_local_name (function, local_entity, entity)\n-     tree function;\n-     tree local_entity;\n-     tree entity;\n+write_local_name (const tree function, const tree local_entity,\n+\t\t  const tree entity)\n {\n   MANGLE_TRACE_TREE (\"local-name\", entity);\n \n@@ -1445,8 +1415,7 @@ write_local_name (function, local_entity, entity)\n    TYPE is a type node.  */\n \n static void \n-write_type (type)\n-     tree type;\n+write_type (tree type)\n {\n   /* This gets set to nonzero if TYPE turns out to be a (possibly\n      CV-qualified) builtin type.  */\n@@ -1574,8 +1543,7 @@ write_type (type)\n      <CV-qualifiers> ::= [r] [V] [K]  */\n \n static int\n-write_CV_qualifiers_for_type (type)\n-     tree type;\n+write_CV_qualifiers_for_type (const tree type)\n {\n   int num_qualifiers = 0;\n \n@@ -1633,8 +1601,7 @@ write_CV_qualifiers_for_type (type)\n                     ::= u <source-name>  # vendor extended type */\n \n static void \n-write_builtin_type (type)\n-     tree type;\n+write_builtin_type (tree type)\n {\n   switch (TREE_CODE (type))\n     {\n@@ -1717,8 +1684,7 @@ write_builtin_type (type)\n      <function-type> ::= F [Y] <bare-function-type> E   */\n \n static void\n-write_function_type (type)\n-     tree type;\n+write_function_type (const tree type)\n {\n   MANGLE_TRACE_TREE (\"function-type\", type);\n \n@@ -1759,10 +1725,8 @@ write_function_type (type)\n      <bare-function-type> ::= </signature/ type>+  */\n \n static void\n-write_bare_function_type (type, include_return_type_p, decl)\n-     tree type;\n-     int include_return_type_p;\n-     tree decl;\n+write_bare_function_type (const tree type, const int include_return_type_p,\n+\t\t\t  const tree decl)\n {\n   MANGLE_TRACE_TREE (\"bare-function-type\", type);\n \n@@ -1783,10 +1747,7 @@ write_bare_function_type (type, include_return_type_p, decl)\n    parameters are being emitted.  */\n \n static void\n-write_method_parms (parm_types, method_p, decl)\n-     tree decl;\n-     tree parm_types;\n-     int method_p;\n+write_method_parms (tree parm_types, const int method_p, const tree decl)\n {\n   tree first_parm_type;\n   tree parm_decl = decl ? DECL_ARGUMENTS (decl) : NULL_TREE;\n@@ -1844,8 +1805,7 @@ write_method_parms (parm_types, method_p, decl)\n /* <class-enum-type> ::= <name>  */\n \n static void \n-write_class_enum_type (type)\n-     tree type;\n+write_class_enum_type (const tree type)\n {\n   write_name (TYPE_NAME (type), /*ignore_local_scope=*/0);\n }\n@@ -1856,8 +1816,7 @@ write_class_enum_type (type)\n      <template-args> ::= I <template-arg>+ E  */\n \n static void\n-write_template_args (args)\n-     tree args;\n+write_template_args (tree args)\n {\n   MANGLE_TRACE_TREE (\"template-args\", args);\n \n@@ -1904,8 +1863,7 @@ write_template_args (args)\n                   ::= sr <type> <unqualified-name> <template-args> */\n \n static void\n-write_expression (expr)\n-     tree expr;\n+write_expression (tree expr)\n {\n   enum tree_code code;\n \n@@ -2095,8 +2053,7 @@ write_expression (expr)\n      encoded as 0, true as 1.\"  */\n \n static void\n-write_template_arg_literal (value)\n-     tree value;\n+write_template_arg_literal (const tree value)\n {\n   tree type = TREE_TYPE (value);\n   write_char ('L');\n@@ -2134,8 +2091,7 @@ write_template_arg_literal (value)\n                     ::= X <expression> E              # expression  */\n \n static void\n-write_template_arg (node)\n-     tree node;\n+write_template_arg (tree node)\n {\n   enum tree_code code = TREE_CODE (node);\n \n@@ -2187,7 +2143,7 @@ write_template_arg (node)\n \t\t\t::= <substitution>  */\n \n void\n-write_template_template_arg (tree decl)\n+write_template_template_arg (const tree decl)\n {\n   MANGLE_TRACE_TREE (\"template-template-arg\", decl);\n \n@@ -2207,9 +2163,8 @@ write_template_template_arg (tree decl)\n      element type. For variable length arrays, the dimension (but not\n      the '_' separator) is omitted.\"  */\n \n-static void \n-write_array_type (type)\n-  tree type;\n+static void\n+write_array_type (const tree type)\n {\n   write_char ('A');\n   if (TYPE_DOMAIN (type))\n@@ -2241,8 +2196,7 @@ write_array_type (type)\n      <pointer-to-member-type> ::= M </class/ type> </member/ type>  */\n \n static void\n-write_pointer_to_member_type (type)\n-     tree type;\n+write_pointer_to_member_type (const tree type)\n {\n   write_char ('M');\n   write_type (TYPE_PTRMEM_CLASS_TYPE (type));\n@@ -2263,8 +2217,7 @@ write_pointer_to_member_type (type)\n    This is used by mangle_conv_op_name_for_type.  */\n \n static void\n-write_template_param (parm)\n-     tree parm;\n+write_template_param (const tree parm)\n {\n   int parm_index;\n   int parm_level;\n@@ -2313,8 +2266,7 @@ write_template_param (parm)\n \t\t\t::= <substitution>  */\n \n static void\n-write_template_template_param (parm)\n-     tree parm;\n+write_template_template_param (const tree parm)\n {\n   tree template = NULL_TREE;\n \n@@ -2342,8 +2294,7 @@ write_template_template_param (parm)\n                      ::= S_  */\n \n static void\n-write_substitution (seq_id)\n-     int seq_id;\n+write_substitution (const int seq_id)\n {\n   MANGLE_TRACE (\"substitution\", \"\");\n \n@@ -2356,7 +2307,7 @@ write_substitution (seq_id)\n /* Start mangling ENTITY.  */\n \n static inline void\n-start_mangling (tree entity)\n+start_mangling (const tree entity)\n {\n   G.entity = entity;\n   G.need_abi_warning = false;\n@@ -2369,7 +2320,7 @@ start_mangling (tree entity)\n    future version of the ABI, issue a warning.  */\n \n static inline const char *\n-finish_mangling (bool warn)\n+finish_mangling (const bool warn)\n {\n   if (warn_abi && warn && G.need_abi_warning)\n     warning (\"the mangled name of `%D' will change in a future \"\n@@ -2405,8 +2356,7 @@ init_mangle ()\n /* Generate the mangled name of DECL.  */\n \n static const char *\n-mangle_decl_string (decl)\n-     tree decl;\n+mangle_decl_string (const tree decl)\n {\n   const char *result;\n \n@@ -2446,8 +2396,7 @@ mangle_decl_string (decl)\n /* Create an identifier for the external mangled name of DECL.  */\n \n void\n-mangle_decl (decl)\n-     tree decl;\n+mangle_decl (const tree decl)\n {\n   tree id = get_identifier (mangle_decl_string (decl));\n \n@@ -2457,8 +2406,7 @@ mangle_decl (decl)\n /* Generate the mangled representation of TYPE.  */\n \n const char *\n-mangle_type_string (type)\n-     tree type;\n+mangle_type_string (const tree type)\n {\n   const char *result;\n \n@@ -2473,8 +2421,7 @@ mangle_type_string (type)\n /* Create an identifier for the mangled representation of TYPE.  */\n \n tree\n-mangle_type (type)\n-     tree type;\n+mangle_type (const tree type)\n {\n   return get_identifier (mangle_type_string (type));\n }\n@@ -2484,9 +2431,7 @@ mangle_type (type)\n    component.  */\n \n static tree\n-mangle_special_for_type (type, code)\n-     tree type;\n-     const char *code;\n+mangle_special_for_type (const tree type, const char *code)\n {\n   const char *result;\n \n@@ -2512,8 +2457,7 @@ mangle_special_for_type (type, code)\n    structure for TYPE.  */\n \n tree\n-mangle_typeinfo_for_type (type)\n-     tree type;\n+mangle_typeinfo_for_type (const tree type)\n {\n   return mangle_special_for_type (type, \"TI\");\n }\n@@ -2522,26 +2466,23 @@ mangle_typeinfo_for_type (type)\n    the mangled name of TYPE.  */\n \n tree\n-mangle_typeinfo_string_for_type (type)\n-     tree type;\n+mangle_typeinfo_string_for_type (const tree type)\n {\n   return mangle_special_for_type (type, \"TS\");\n }\n \n /* Create an identifier for the mangled name of the vtable for TYPE.  */\n \n tree\n-mangle_vtbl_for_type (type)\n-     tree type;\n+mangle_vtbl_for_type (const tree type)\n {\n   return mangle_special_for_type (type, \"TV\");\n }\n \n /* Returns an identifier for the mangled name of the VTT for TYPE.  */\n \n tree\n-mangle_vtt_for_type (type)\n-     tree type;\n+mangle_vtt_for_type (const tree type)\n {\n   return mangle_special_for_type (type, \"TT\");\n }\n@@ -2561,9 +2502,7 @@ mangle_vtt_for_type (type)\n     <special-name> ::= CT <type> <offset number> _ <base type>  */\n \n tree\n-mangle_ctor_vtbl_for_type (type, binfo)\n-     tree type;\n-     tree binfo;\n+mangle_ctor_vtbl_for_type (const tree type, const tree binfo)\n {\n   const char *result;\n \n@@ -2588,9 +2527,7 @@ mangle_ctor_vtbl_for_type (type, binfo)\n \t\t ::= v <fixed offset number> _ <virtual offset number> _ */\n    \n static void\n-mangle_call_offset (fixed_offset, virtual_offset)\n-     tree fixed_offset;\n-     tree virtual_offset;\n+mangle_call_offset (const tree fixed_offset, const tree virtual_offset)\n {\n   write_char (virtual_offset ? 'v' : 'h');\n \n@@ -2621,11 +2558,8 @@ mangle_call_offset (fixed_offset, virtual_offset)\n */\n \n tree\n-mangle_thunk (fn_decl, this_adjusting, fixed_offset, virtual_offset)\n-     tree fn_decl;\n-     int this_adjusting;\n-     tree fixed_offset;\n-     tree virtual_offset;\n+mangle_thunk (tree fn_decl, const int this_adjusting, tree fixed_offset,\n+\t      tree virtual_offset)\n {\n   const char *result;\n   \n@@ -2671,8 +2605,7 @@ mangle_thunk (fn_decl, this_adjusting, fixed_offset, virtual_offset)\n    ABI spec; it is only used internally.  */\n \n tree\n-mangle_conv_op_name_for_type (type)\n-     tree type;\n+mangle_conv_op_name_for_type (const tree type)\n {\n   tree identifier;\n   const char *mangled_type;\n@@ -2716,8 +2649,7 @@ mangle_conv_op_name_for_type (type)\n    variable for indicated VARIABLE.  */\n \n tree\n-mangle_guard_variable (variable)\n-     tree variable;\n+mangle_guard_variable (const tree variable)\n {\n   start_mangling (variable);\n   write_string (\"_ZGV\");\n@@ -2735,8 +2667,7 @@ mangle_guard_variable (variable)\n    as well call them something readable.  */\n \n tree\n-mangle_ref_init_variable (variable)\n-     tree variable;\n+mangle_ref_init_variable (const tree variable)\n {\n   start_mangling (variable);\n   write_string (\"_ZGR\");\n@@ -2750,8 +2681,7 @@ mangle_ref_init_variable (variable)\n /* How to write the type codes for the integer Java type.  */\n \n static void\n-write_java_integer_type_codes (type)\n-     tree type;\n+write_java_integer_type_codes (const tree type)\n {\n   if (type == java_int_type_node)\n     write_char ('i');"}]}