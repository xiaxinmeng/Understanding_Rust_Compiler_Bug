{"sha": "0ddb93ce77374004c49cdfbd748ba35867620cf1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRkYjkzY2U3NzM3NDAwNGM0OWNkZmJkNzQ4YmEzNTg2NzYyMGNmMQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-04T03:50:06Z"}, "committer": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2020-06-04T19:11:42Z"}, "message": "c++: Fix FE devirt with diamond inheritance [PR95158]\n\nThis started breaking in GCC 8 because of the fix for PR15272; after that\nchange, we (correctly) remember the lookup from template parsing time that\nfound Base::foo through the non-dependent MiddleB base, and so we overlook\nthe overrider in MiddleA.  But given that, the devirtualization condition\nfrom the fix for PR59031 is insufficient; we know that d has to be a\nDerived, and we found Base::foo in Base, but forcing a non-virtual call\ngets the wrong function.\n\nFixed by removing the PR59031 code that the PR67184 patch moved to\nbuild_over_call, and instead looking up the overrider in BINFO_VIRTUALS.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/95158\n\t* class.c (lookup_vfn_in_binfo): New.\n\t* call.c (build_over_call): Use it.\n\t* cp-tree.h (resolves_to_fixed_type_p): Add default argument.\n\t(lookup_vfn_in_binfo): Declare.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/95158\n\t* g++.dg/template/virtual5.C: New test.", "tree": {"sha": "e72f9c9d166a469f442772331639a2fbf04ee818", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e72f9c9d166a469f442772331639a2fbf04ee818"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0ddb93ce77374004c49cdfbd748ba35867620cf1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ddb93ce77374004c49cdfbd748ba35867620cf1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ddb93ce77374004c49cdfbd748ba35867620cf1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ddb93ce77374004c49cdfbd748ba35867620cf1/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8c727bdf4acf28c8315b119a1c8f6d6af745c2af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c727bdf4acf28c8315b119a1c8f6d6af745c2af", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c727bdf4acf28c8315b119a1c8f6d6af745c2af"}], "stats": {"total": 70, "additions": 59, "deletions": 11}, "files": [{"sha": "2b393f96e5bda607bcf9d4846b2a03a478ab784c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=0ddb93ce77374004c49cdfbd748ba35867620cf1", "patch": "@@ -8704,19 +8704,21 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n \t    return error_mark_node;\n \t}\n \n-      /* Optimize away vtable lookup if we know that this\n-\t function can't be overridden.  We need to check if\n-\t the context and the type where we found fn are the same,\n-\t actually FN might be defined in a different class\n-\t type because of a using-declaration. In this case, we\n-\t do not want to perform a non-virtual call.  Note that\n-\t resolves_to_fixed_type_p checks CLASSTYPE_FINAL too.  */\n+      /* See if the function member or the whole class type is declared\n+\t final and the call can be devirtualized.  */\n       if (DECL_FINAL_P (fn)\n-\t  || (resolves_to_fixed_type_p (arg, 0)\n-\t      && same_type_ignoring_top_level_qualifiers_p\n-\t      (DECL_CONTEXT (fn), BINFO_TYPE (cand->conversion_path)))) \n+\t  || CLASSTYPE_FINAL (TYPE_METHOD_BASETYPE (TREE_TYPE (fn))))\n \tflags |= LOOKUP_NONVIRTUAL;\n \n+      /* If we know the dynamic type of the object, look up the final overrider\n+\t in the BINFO.  */\n+      if (DECL_VINDEX (fn) && (flags & LOOKUP_NONVIRTUAL) == 0\n+\t  && resolves_to_fixed_type_p (arg))\n+\t{\n+\t  fn = lookup_vfn_in_binfo (DECL_VINDEX (fn), cand->conversion_path);\n+\t  flags |= LOOKUP_NONVIRTUAL;\n+\t}\n+\n       /* [class.mfct.non-static]: If a non-static member function of a class\n \t X is called for an object that is not of type X, or of a type\n \t derived from X, the behavior is undefined."}, {"sha": "f8e38ec9d8c88c0ba0d53467874ab733fe23dbe5", "filename": "gcc/cp/class.c", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=0ddb93ce77374004c49cdfbd748ba35867620cf1", "patch": "@@ -2445,6 +2445,20 @@ get_vcall_index (tree fn, tree type)\n   gcc_unreachable ();\n }\n \n+/* Given a DECL_VINDEX of a virtual function found in BINFO, return the final\n+   overrider at that index in the vtable.  This should only be used when we\n+   know that BINFO is correct for the dynamic type of the object.  */\n+\n+tree\n+lookup_vfn_in_binfo (tree idx, tree binfo)\n+{\n+  int ix = tree_to_shwi (idx);\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    ix /= MAX (TARGET_VTABLE_USES_DESCRIPTORS, 1);\n+  tree virtuals = BINFO_VIRTUALS (binfo);\n+  return TREE_VALUE (chain_index (ix, virtuals));\n+}\n+\n /* Update an entry in the vtable for BINFO, which is in the hierarchy\n    dominated by T.  FN is the old function; VIRTUALS points to the\n    corresponding position in the new BINFO_VIRTUALS list.  IX is the index"}, {"sha": "44cb10cfee5710e99f45f3e0de0fc146c68e999b", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=0ddb93ce77374004c49cdfbd748ba35867620cf1", "patch": "@@ -6401,7 +6401,7 @@ extern tree outermost_open_class\t\t(void);\n extern tree current_nonlambda_class_type\t(void);\n extern tree finish_struct\t\t\t(tree, tree);\n extern void finish_struct_1\t\t\t(tree);\n-extern int resolves_to_fixed_type_p\t\t(tree, int *);\n+extern int resolves_to_fixed_type_p\t\t(tree, int * = NULL);\n extern void init_class_processing\t\t(void);\n extern int is_empty_class\t\t\t(tree);\n extern bool is_really_empty_class\t\t(tree, bool);\n@@ -6415,6 +6415,7 @@ extern void pop_lang_context\t\t\t(void);\n extern tree instantiate_type\t\t\t(tree, tree, tsubst_flags_t);\n extern void build_self_reference\t\t(void);\n extern int same_signature_p\t\t\t(const_tree, const_tree);\n+extern tree lookup_vfn_in_binfo\t\t\t(tree, tree);\n extern void maybe_add_class_template_decl_list\t(tree, tree, int);\n extern void unreverse_member_declarations\t(tree);\n extern void invalidate_class_lookup_cache\t(void);"}, {"sha": "4d9044579ca998b3fcb980ad1a9cf0006db01795", "filename": "gcc/testsuite/g++.dg/template/virtual5.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvirtual5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0ddb93ce77374004c49cdfbd748ba35867620cf1/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvirtual5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fvirtual5.C?ref=0ddb93ce77374004c49cdfbd748ba35867620cf1", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/95158\n+// { dg-do run }\n+\n+class Base {\n+    public:\n+        virtual void foo()=0;\n+};\n+\n+template <typename T>\n+class MiddleA : virtual public Base {\n+    public:\n+        virtual void foo() {}\n+};\n+\n+class MiddleB : virtual public Base {};\n+\n+template <typename T>\n+class Derived : public MiddleA<T>, public MiddleB {\n+    public:\n+        void bar()\n+        {\n+\t  Derived d;\n+\t  d.foo();\n+        }\n+};\n+\n+int main()\n+{\n+  Derived<void> a;\n+  a.bar(); // Instantiate the template\n+}"}]}