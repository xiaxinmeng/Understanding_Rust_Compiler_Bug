{"sha": "10069d53fb535c72d70e2c7dab53347d40a89f37", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAwNjlkNTNmYjUzNWM3MmQ3MGUyYzdkYWI1MzM0N2Q0MGE4OWYzNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2009-04-07T09:41:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2009-04-07T09:41:40Z"}, "message": "gigi.h (standard_datatypes): Remove ADT_void_type_decl.\n\n\t* gcc-interface/gigi.h (standard_datatypes): Remove ADT_void_type_decl.\n\t(void_type_decl_node): Remove.\n\t(init_gigi_decls): Likewise.\n\t(gnat_install_builtins): Declare.\n\t(record_builtin_type): Likewise.\n\t(create_type_stub_decl): Likewise.\n\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Void>: Use void_type.\n\t(gnat_to_gnu_entity) <E_Array_Type>: Make fat and thin pointer types\n\tartificial.\n\t<E_Array_Subtype>: Use the index types, not only their name, in the\n\trecord giving the names of the bounds, if any.\n\tFor a packed array type, make it artificial only if the base type\n\twas artificial as well.  Remove redundant statement.\n\t(gnat_to_gnu_entity) <E_Incomplete_Type>: Do not create TYPE_DECL for\n\tdummy types.\n\tUse create_type_stub_decl to build the TYPE_STUB_DECL of types.\n\t(rest_of_type_decl_compilation_no_defer): Likewise.\n\t* gcc-interface/misc.c (gnat_printable_name): Add missing guard.\n\t* gcc-interface/utils.c (make_dummy_type): Always create TYPE_STUB_DECL\n\tand use create_type_stub_decl to build it.\n\t(gnat_pushdecl): Rewrite condition.\n\t(gnat_install_builtins): Remove bogus declaration.\n\t(record_builtin_type): New function.\n\t(finish_record_type): Use create_type_stub_decl to build TYPE_STUB_DECL\n\tof types.\n\t(create_type_stub_decl): New function.\n\t(create_type_decl): Assert that the type is not dummy.  If the type\n\thasn't been named yet, equate the TYPE_STUB_DECL to the created node.\n\t(build_vms_descriptor32): Do not create TYPE_DECL for the descriptor.\n\t(build_vms_descriptor): Likewise.\n\t(init_gigi_decls): Delete and move bulk of code to...\n\t* gcc-interface/trans.c (gigi): ...here.  Use record_builtin_type.\n\t(emit_range_check): Add gnat_node parameter.\n\t(emit_index_check): Likewise.\n\t(emit_check): Likewise.\n\t(build_unary_op_trapv): Likewise.\n\t(build_binary_op_trapv): Likewise.\n\t(convert_with_check): Likewise.\n\t(Attribute_to_gnu): Adjust calls for above changes.\n\t(call_to_gnu): Likewise.\n\t(gnat_to_gnu): Likewise.\n\t(assoc_to_constructor): Likewise.\n\t(pos_to_constructor): Likewise.\n\t(Sloc_to_locus): Set BUILTINS_LOCATION for Standard_Location nodes.\n\t(process_type): Do not create TYPE_DECL for dummy types.\n\nFrom-SVN: r145660", "tree": {"sha": "7bfd8c79bf5aaa359b8138379bc370dafdabe883", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7bfd8c79bf5aaa359b8138379bc370dafdabe883"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/10069d53fb535c72d70e2c7dab53347d40a89f37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10069d53fb535c72d70e2c7dab53347d40a89f37", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10069d53fb535c72d70e2c7dab53347d40a89f37", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10069d53fb535c72d70e2c7dab53347d40a89f37/comments", "author": null, "committer": null, "parents": [{"sha": "1e17ef870e0889e68c707702cb9bb528aa960aa5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1e17ef870e0889e68c707702cb9bb528aa960aa5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1e17ef870e0889e68c707702cb9bb528aa960aa5"}], "stats": {"total": 937, "additions": 504, "deletions": 433}, "files": [{"sha": "9dbf5a51f91aec6ae3cbdcf2e5e6dcb1462108c5", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -1,3 +1,51 @@\n+2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (standard_datatypes): Remove ADT_void_type_decl.\n+\t(void_type_decl_node): Remove.\n+\t(init_gigi_decls): Likewise.\n+\t(gnat_install_builtins): Declare.\n+\t(record_builtin_type): Likewise.\n+\t(create_type_stub_decl): Likewise.\n+\t* gcc-interface/decl.c (gnat_to_gnu_entity) <E_Void>: Use void_type.\n+\t(gnat_to_gnu_entity) <E_Array_Type>: Make fat and thin pointer types\n+\tartificial.\n+\t<E_Array_Subtype>: Use the index types, not only their name, in the\n+\trecord giving the names of the bounds, if any.\n+\tFor a packed array type, make it artificial only if the base type\n+\twas artificial as well.  Remove redundant statement.\n+\t(gnat_to_gnu_entity) <E_Incomplete_Type>: Do not create TYPE_DECL for\n+\tdummy types.\n+\tUse create_type_stub_decl to build the TYPE_STUB_DECL of types.\n+\t(rest_of_type_decl_compilation_no_defer): Likewise.\n+\t* gcc-interface/misc.c (gnat_printable_name): Add missing guard.\n+\t* gcc-interface/utils.c (make_dummy_type): Always create TYPE_STUB_DECL\n+\tand use create_type_stub_decl to build it.\n+\t(gnat_pushdecl): Rewrite condition.\n+\t(gnat_install_builtins): Remove bogus declaration.\n+\t(record_builtin_type): New function.\n+\t(finish_record_type): Use create_type_stub_decl to build TYPE_STUB_DECL\n+\tof types.\n+\t(create_type_stub_decl): New function.\n+\t(create_type_decl): Assert that the type is not dummy.  If the type\n+\thasn't been named yet, equate the TYPE_STUB_DECL to the created node.\n+\t(build_vms_descriptor32): Do not create TYPE_DECL for the descriptor.\n+\t(build_vms_descriptor): Likewise.\n+\t(init_gigi_decls): Delete and move bulk of code to...\n+\t* gcc-interface/trans.c (gigi): ...here.  Use record_builtin_type.\n+\t(emit_range_check): Add gnat_node parameter.\n+\t(emit_index_check): Likewise.\n+\t(emit_check): Likewise.\n+\t(build_unary_op_trapv): Likewise.\n+\t(build_binary_op_trapv): Likewise.\n+\t(convert_with_check): Likewise.\n+\t(Attribute_to_gnu): Adjust calls for above changes.\n+\t(call_to_gnu): Likewise.\n+\t(gnat_to_gnu): Likewise.\n+\t(assoc_to_constructor): Likewise.\n+\t(pos_to_constructor): Likewise.\n+\t(Sloc_to_locus): Set BUILTINS_LOCATION for Standard_Location nodes.\n+\t(process_type): Do not create TYPE_DECL for dummy types.\n+\n 2009-04-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/decl.c (gnat_to_gnu_entity): Reorder local variables."}, {"sha": "6cf616e961ba21c6ff4d9cddfc991147e0e72e13", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -1384,7 +1384,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n     case E_Void:\n       /* Return a TYPE_DECL for \"void\" that we previously made.  */\n-      gnu_decl = void_type_decl_node;\n+      gnu_decl = TYPE_NAME (void_type_node);\n       break;\n \n     case E_Enumeration_Type:\n@@ -2033,7 +2033,7 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Give the fat pointer type a name.  */\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUP\"),\n-\t\t\t  gnu_fat_type, NULL, !Comes_From_Source (gnat_entity),\n+\t\t\t  gnu_fat_type, NULL, true,\n \t\t\t  debug_info_p, gnat_entity);\n \n        /* Create the type to be used as what a thin pointer designates: an\n@@ -2048,9 +2048,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \n \t/* Give the thin pointer type a name.  */\n \tcreate_type_decl (create_concat_name (gnat_entity, \"XUX\"),\n-\t\t\t  build_pointer_type (tem), NULL,\n-\t\t\t  !Comes_From_Source (gnat_entity), debug_info_p,\n-\t\t\t  gnat_entity);\n+\t\t\t  build_pointer_type (tem), NULL, true,\n+\t\t\t  debug_info_p, gnat_entity);\n       }\n       break;\n \n@@ -2352,6 +2351,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\tTYPE_NONALIASED_COMPONENT (gnu_type) = 1;\n \t    }\n \n+\t  /* Attach the TYPE_STUB_DECL in case we have a parallel type.  */\n+\t  if (need_index_type_struct)\n+\t    TYPE_STUB_DECL (gnu_type)\n+\t      = create_type_stub_decl (gnu_entity_id, gnu_type);\n+\n \t  /* If we are at file level and this is a multi-dimensional array, we\n \t     need to make a variable corresponding to the stride of the\n \t     inner dimensions.   */\n@@ -2395,40 +2399,35 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    }\n \n \t  /* If we need to write out a record type giving the names of\n-\t     the bounds, do it now.  */\n+\t     the bounds, do it now.  Make sure to reference the index\n+\t     types themselves, not just their names, as the debugger\n+\t     may fall back on them in some cases.  */\n \t  if (need_index_type_struct && debug_info_p)\n \t    {\n-\t      tree gnu_bound_rec_type = make_node (RECORD_TYPE);\n+\t      tree gnu_bound_rec = make_node (RECORD_TYPE);\n \t      tree gnu_field_list = NULL_TREE;\n \t      tree gnu_field;\n \n-\t      TYPE_NAME (gnu_bound_rec_type)\n+\t      TYPE_NAME (gnu_bound_rec)\n \t\t= create_concat_name (gnat_entity, \"XA\");\n \n \t      for (index = array_dim - 1; index >= 0; index--)\n \t\t{\n-\t\t  tree gnu_type_name\n-\t\t    = TYPE_NAME (TYPE_INDEX_TYPE (gnu_index_type[index]));\n+\t\t  tree gnu_index = TYPE_INDEX_TYPE (gnu_index_type[index]);\n+\t\t  tree gnu_index_name = TYPE_NAME (gnu_index);\n \n-\t\t  if (TREE_CODE (gnu_type_name) == TYPE_DECL)\n-\t\t    gnu_type_name = DECL_NAME (gnu_type_name);\n+\t\t  if (TREE_CODE (gnu_index_name) == TYPE_DECL)\n+\t\t    gnu_index_name = DECL_NAME (gnu_index_name);\n \n-\t\t  gnu_field = create_field_decl (gnu_type_name,\n-\t\t\t\t\t\t integer_type_node,\n-\t\t\t\t\t\t gnu_bound_rec_type,\n+\t\t  gnu_field = create_field_decl (gnu_index_name, gnu_index,\n+\t\t\t\t\t\t gnu_bound_rec,\n \t\t\t\t\t\t 0, NULL_TREE, NULL_TREE, 0);\n \t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n \n-\t      finish_record_type (gnu_bound_rec_type, gnu_field_list,\n-\t\t\t\t  0, false);\n-\n-\t      TYPE_STUB_DECL (gnu_type)\n-\t\t= build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n-\n-\t      add_parallel_type\n-\t\t(TYPE_STUB_DECL (gnu_type), gnu_bound_rec_type);\n+\t      finish_record_type (gnu_bound_rec, gnu_field_list, 0, false);\n+\t      add_parallel_type (TYPE_STUB_DECL (gnu_type), gnu_bound_rec);\n \t    }\n \n \t  TYPE_CONVENTION_FORTRAN_P (gnu_type)\n@@ -2459,25 +2458,28 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t}\n \n       /* If this is a packed type, make this type the same as the packed\n-\t array type, but do some adjusting in the type first.   */\n-\n+\t array type, but do some adjusting in the type first.  */\n       if (Present (Packed_Array_Type (gnat_entity)))\n \t{\n \t  Entity_Id gnat_index;\n \t  tree gnu_inner_type;\n \n \t  /* First finish the type we had been making so that we output\n-\t     debugging information for it  */\n+\t     debugging information for it.  */\n \t  gnu_type\n \t    = build_qualified_type (gnu_type,\n \t\t\t\t    (TYPE_QUALS (gnu_type)\n \t\t\t\t     | (TYPE_QUAL_VOLATILE\n \t\t\t\t\t* Treat_As_Volatile (gnat_entity))));\n-\t  gnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t       !Comes_From_Source (gnat_entity),\n-\t\t\t\t       debug_info_p, gnat_entity);\n-\t  if (!Comes_From_Source (gnat_entity))\n-\t    DECL_ARTIFICIAL (gnu_decl) = 1;\n+\n+\t  /* Make it artificial only if the base type was artificial as well.\n+\t     That's sort of \"morally\" true and will make it possible for the\n+\t     debugger to look it up by name in DWARF more easily.  */\n+\t  gnu_decl\n+\t    = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n+\t\t\t\t!Comes_From_Source (gnat_entity)\n+\t\t\t\t&& !Comes_From_Source (Etype (gnat_entity)),\n+\t\t\t\tdebug_info_p, gnat_entity);\n \n \t  /* Save it as our equivalent in case the call below elaborates\n \t     this type again.  */\n@@ -4195,7 +4197,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \tif (No (full_view))\n \t  {\n \t    if (kind == E_Incomplete_Type)\n-\t      gnu_type = make_dummy_type (gnat_entity);\n+\t      {\n+\t\tgnu_type = make_dummy_type (gnat_entity);\n+\t\tgnu_decl = TYPE_STUB_DECL (gnu_type);\n+\t      }\n \t    else\n \t      {\n \t\tgnu_decl = gnat_to_gnu_entity (Etype (gnat_entity),\n@@ -4227,14 +4232,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  }\n \n \t/* For incomplete types, make a dummy type entry which will be\n-\t   replaced later.  */\n+\t   replaced later.  Save it as the full declaration's type so\n+\t   we can do any needed updates when we see it.  */\n \tgnu_type = make_dummy_type (gnat_entity);\n-\n-\t/* Save this type as the full declaration's type so we can do any\n-\t   needed updates when we see it.  */\n-\tgnu_decl = create_type_decl (gnu_entity_id, gnu_type, attr_list,\n-\t\t\t\t     !Comes_From_Source (gnat_entity),\n-\t\t\t\t     debug_info_p, gnat_entity);\n+\tgnu_decl = TYPE_STUB_DECL (gnu_type);\n \tsave_gnu_tree (full_view, gnu_decl, 0);\n \tbreak;\n       }\n@@ -4790,10 +4791,7 @@ rest_of_type_decl_compilation_no_defer (tree decl)\n \tcontinue;\n \n       if (!TYPE_STUB_DECL (t))\n-\t{\n-\t  TYPE_STUB_DECL (t) = build_decl (TYPE_DECL, DECL_NAME (decl), t);\n-\t  DECL_ARTIFICIAL (TYPE_STUB_DECL (t)) = 1;\n-\t}\n+\tTYPE_STUB_DECL (t) = create_type_stub_decl (DECL_NAME (decl), t);\n \n       rest_of_type_compilation (t, toplev);\n     }"}, {"sha": "ffd1767c12daa70bb13a634f28fd8db70620c214", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                              C Header File                               *\n  *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -363,9 +363,8 @@ extern const struct attribute_spec gnat_internal_attribute_table[];\n /* Define the entries in the standard data array.  */\n enum standard_datatypes\n {\n-/* Various standard data types and nodes.  */\n+  /* The longest floating-point type.  */\n   ADT_longest_float_type,\n-  ADT_void_type_decl,\n \n   /* The type of an exception.  */\n   ADT_except_type,\n@@ -418,7 +417,6 @@ extern GTY(()) tree gnat_std_decls[(int) ADT_LAST];\n extern GTY(()) tree gnat_raise_decls[(int) LAST_REASON_CODE + 1];\n \n #define longest_float_type_node gnat_std_decls[(int) ADT_longest_float_type]\n-#define void_type_decl_node gnat_std_decls[(int) ADT_void_type_decl]\n #define except_type_node gnat_std_decls[(int) ADT_except_type]\n #define ptr_void_type_node gnat_std_decls[(int) ADT_ptr_void_type]\n #define void_ftype gnat_std_decls[(int) ADT_void_ftype]\n@@ -468,8 +466,8 @@ extern tree get_block_jmpbuf_decl (void);\n extern void gnat_pushdecl (tree decl, Node_Id gnat_node);\n \n extern void gnat_init_decl_processing (void);\n-extern void init_gigi_decls (tree long_long_float_type, tree exception_type);\n extern void gnat_init_gcc_eh (void);\n+extern void gnat_install_builtins (void);\n \n /* Return an integer type with the number of bits of precision given by\n    PRECISION.  UNSIGNEDP is nonzero if the type is unsigned; otherwise\n@@ -522,6 +520,9 @@ extern bool present_gnu_tree (Entity_Id gnat_entity);\n /* Initialize tables for above routines.  */\n extern void init_gnat_to_gnu (void);\n \n+/* Record TYPE as a builtin type for Ada.  NAME is the name of the type.  */\n+extern void record_builtin_type (const char *name, tree type);\n+\n /* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n    finish constructing the record or union type.  If REP_LEVEL is zero, this\n    record has no representation clause and so will be entirely laid out here.\n@@ -569,12 +570,16 @@ extern tree copy_type (tree type);\n extern tree create_index_type (tree min, tree max, tree index,\n \t\t\t       Node_Id gnat_node);\n \n-/* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n-   string) and TYPE is a ..._TYPE node giving its data type.\n-   ARTIFICIAL_P is true if this is a declaration that was generated\n-   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n-   information about this type.  GNAT_NODE is used for the position of\n-   the decl.  */\n+/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n+   TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n+   its data type.  */\n+extern tree create_type_stub_decl (tree type_name, tree type);\n+\n+/* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n+   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if this\n+   is a declaration that was generated by the compiler.  DEBUG_INFO_P is\n+   true if we need to write debug information about this type.  GNAT_NODE\n+   is used for the position of the decl.  */\n extern tree create_type_decl (tree type_name, tree type,\n                               struct attrib *attr_list,\n                               bool artificial_p, bool debug_info_p,"}, {"sha": "4dc00fc977f651ac588a2e9a1fc025f0b490b2b8", "filename": "gcc/ada/gcc-interface/misc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fmisc.c?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -610,7 +610,7 @@ gnat_printable_name (tree decl, int verbosity)\n \n   __gnat_decode (coded_name, ada_name, 0);\n \n-  if (verbosity == 2)\n+  if (verbosity == 2 && !DECL_IS_BUILTIN (decl))\n     {\n       Set_Identifier_Casing (ada_name, (char *) DECL_SOURCE_FILE (decl));\n       return ggc_strdup (Name_Buffer);"}, {"sha": "96e7c80f659e7b686a9a3523861c02cf8381e17b", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 331, "deletions": 79, "changes": 410, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -213,12 +213,12 @@ static void elaborate_all_entities (Node_Id);\n static void process_freeze_entity (Node_Id);\n static void process_inlined_subprograms (Node_Id);\n static void process_decls (List_Id, List_Id, Node_Id, bool, bool);\n-static tree emit_range_check (tree, Node_Id);\n-static tree emit_index_check (tree, tree, tree, tree);\n-static tree emit_check (tree, tree, int);\n-static tree build_unary_op_trapv (enum tree_code, tree, tree);\n-static tree build_binary_op_trapv (enum tree_code, tree, tree, tree);\n-static tree convert_with_check (Entity_Id, tree, bool, bool, bool);\n+static tree emit_range_check (tree, Node_Id, Node_Id);\n+static tree emit_index_check (tree, tree, tree, tree, Node_Id);\n+static tree emit_check (tree, tree, int, Node_Id);\n+static tree build_unary_op_trapv (enum tree_code, tree, tree, Node_Id);\n+static tree build_binary_op_trapv (enum tree_code, tree, tree, tree, Node_Id);\n+static tree convert_with_check (Entity_Id, tree, bool, bool, bool, Node_Id);\n static bool smaller_packable_type_p (tree, tree);\n static bool addressable_p (tree, tree);\n static tree assoc_to_constructor (Entity_Id, Node_Id, tree);\n@@ -249,7 +249,8 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n       Entity_Id standard_exception_type, Int gigi_operating_mode)\n {\n   Entity_Id gnat_literal;\n-  tree gnu_standard_long_long_float, gnu_standard_exception_type, t;\n+  tree long_long_float_type, exception_type, t;\n+  tree int64_type = gnat_type_for_size (64, 0);\n   struct elab_info *info;\n   int i;\n \n@@ -321,17 +322,20 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   if (!Stack_Check_Probes_On_Target)\n     set_stack_check_libfunc (gen_rtx_SYMBOL_REF (Pmode, \"_gnat_stack_check\"));\n \n-  /* Give names and make TYPE_DECLs for common types.  */\n-  create_type_decl (get_identifier (SIZE_TYPE), sizetype,\n-\t\t    NULL, false, true, Empty);\n-  create_type_decl (get_identifier (\"boolean\"), boolean_type_node,\n-\t\t    NULL, false, true, Empty);\n-  create_type_decl (get_identifier (\"integer\"), integer_type_node,\n-\t\t    NULL, false, true, Empty);\n-  create_type_decl (get_identifier (\"unsigned char\"), char_type_node,\n-\t\t    NULL, false, true, Empty);\n-  create_type_decl (get_identifier (\"long integer\"), long_integer_type_node,\n-\t\t    NULL, false, true, Empty);\n+  /* Record the builtin types.  Define `integer' and `unsigned char' first so\n+     that dbx will output them first.  */\n+  record_builtin_type (\"integer\", integer_type_node);\n+  record_builtin_type (\"unsigned char\", char_type_node);\n+  record_builtin_type (\"long integer\", long_integer_type_node);\n+  unsigned_type_node = gnat_type_for_size (INT_TYPE_SIZE, 1);\n+  record_builtin_type (\"unsigned int\", unsigned_type_node);\n+  record_builtin_type (SIZE_TYPE, sizetype);\n+  record_builtin_type (\"boolean\", boolean_type_node);\n+  record_builtin_type (\"void\", void_type_node);\n+\n+  /* Save the type we made for integer as the type for Standard.Integer.  */\n+  save_gnu_tree (Base_Type (standard_integer), TYPE_NAME (integer_type_node),\n+\t\t false);\n \n   /* Save the type we made for boolean as the type for Standard.Boolean.  */\n   save_gnu_tree (Base_Type (standard_boolean), TYPE_NAME (boolean_type_node),\n@@ -353,25 +357,256 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name,\n   DECL_IGNORED_P (t) = 1;\n   save_gnu_tree (gnat_literal, t, false);\n \n-  /* Save the type we made for integer as the type for Standard.Integer.\n-     Then make the rest of the standard types.  Note that some of these\n-     may be subtypes.  */\n-  save_gnu_tree (Base_Type (standard_integer), TYPE_NAME (integer_type_node),\n-\t\t false);\n+  void_ftype = build_function_type (void_type_node, NULL_TREE);\n+  ptr_void_ftype = build_pointer_type (void_ftype);\n+\n+  /* Now declare runtime functions.  */\n+  t = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n+\n+  /* malloc is a function declaration tree for a function to allocate\n+     memory.  */\n+  malloc_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_malloc\"), NULL_TREE,\n+\t\t\t   build_function_type (ptr_void_type_node,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   sizetype, t)),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+  DECL_IS_MALLOC (malloc_decl) = 1;\n+\n+  /* malloc32 is a function declaration tree for a function to allocate\n+     32-bit memory on a 64-bit system.  Needed only on 64-bit VMS.  */\n+  malloc32_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_malloc32\"), NULL_TREE,\n+\t\t\t   build_function_type (ptr_void_type_node,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   sizetype, t)),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+  DECL_IS_MALLOC (malloc32_decl) = 1;\n+\n+  /* free is a function declaration tree for a function to free memory.  */\n+  free_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_free\"), NULL_TREE,\n+\t\t\t   build_function_type (void_type_node,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   ptr_void_type_node,\n+\t\t\t\t\t\t\t   t)),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n+  /* This is used for 64-bit multiplication with overflow checking.  */\n+  mulv64_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n+\t\t\t   build_function_type_list (int64_type, int64_type,\n+\t\t\t\t\t\t     int64_type, NULL_TREE),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n+  /* Make the types and functions used for exception processing.  */\n+  jmpbuf_type\n+    = build_array_type (gnat_type_for_mode (Pmode, 0),\n+\t\t\tbuild_index_type (build_int_cst (NULL_TREE, 5)));\n+  record_builtin_type (\"JMPBUF_T\", jmpbuf_type);\n+  jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);\n+\n+  /* Functions to get and set the jumpbuf pointer for the current thread.  */\n+  get_jmpbuf_decl\n+    = create_subprog_decl\n+    (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n+     NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n+     NULL_TREE, false, true, true, NULL, Empty);\n+  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n+  DECL_PURE_P (get_jmpbuf_decl) = 1;\n+\n+  set_jmpbuf_decl\n+    = create_subprog_decl\n+    (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n+     NULL_TREE,\n+     build_function_type (void_type_node,\n+\t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, t)),\n+     NULL_TREE, false, true, true, NULL, Empty);\n+\n+  /* setjmp returns an integer and has one operand, which is a pointer to\n+     a jmpbuf.  */\n+  setjmp_decl\n+    = create_subprog_decl\n+      (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n+       build_function_type (integer_type_node,\n+\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n+       NULL_TREE, false, true, true, NULL, Empty);\n+\n+  DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n+  DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n+\n+  /* update_setjmp_buf updates a setjmp buffer from the current stack pointer\n+     address.  */\n+  update_setjmp_buf_decl\n+    = create_subprog_decl\n+      (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n+       build_function_type (void_type_node,\n+\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, t)),\n+       NULL_TREE, false, true, true, NULL, Empty);\n+\n+  DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n+  DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n+\n+  /* Hooks to call when entering/leaving an exception handler.  */\n+  begin_handler_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n+\t\t\t   build_function_type (void_type_node,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   ptr_void_type_node,\n+\t\t\t\t\t\t\t   t)),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n+  end_handler_decl\n+    = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n+\t\t\t   build_function_type (void_type_node,\n+\t\t\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t\t\t   ptr_void_type_node,\n+\t\t\t\t\t\t\t   t)),\n+\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n+  /* If in no exception handlers mode, all raise statements are redirected to\n+     __gnat_last_chance_handler.  No need to redefine raise_nodefer_decl since\n+     this procedure will never be called in this mode.  */\n+  if (No_Exception_Handlers_Set ())\n+    {\n+      tree decl\n+\t= create_subprog_decl\n+\t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE,\n+\t   build_function_type (void_type_node,\n+\t\t\t\ttree_cons (NULL_TREE,\n+\t\t\t\t\t   build_pointer_type (char_type_node),\n+\t\t\t\t\t   tree_cons (NULL_TREE,\n+\t\t\t\t\t\t      integer_type_node,\n+\t\t\t\t\t\t      t))),\n+\t   NULL_TREE, false, true, true, NULL, Empty);\n+\n+      for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n+\tgnat_raise_decls[i] = decl;\n+    }\n+  else\n+    /* Otherwise, make one decl for each exception reason.  */\n+    for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n+      {\n+\tchar name[17];\n+\n+\tsprintf (name, \"__gnat_rcheck_%.2d\", i);\n+\tgnat_raise_decls[i]\n+\t  = create_subprog_decl\n+\t    (get_identifier (name), NULL_TREE,\n+\t     build_function_type (void_type_node,\n+\t\t\t\t  tree_cons (NULL_TREE,\n+\t\t\t\t\t     build_pointer_type\n+\t\t\t\t\t     (char_type_node),\n+\t\t\t\t\t     tree_cons (NULL_TREE,\n+\t\t\t\t\t\t\tinteger_type_node,\n+\t\t\t\t\t\t\tt))),\n+\t     NULL_TREE, false, true, true, NULL, Empty);\n+      }\n+\n+  for (i = 0; i < (int) ARRAY_SIZE (gnat_raise_decls); i++)\n+    {\n+      TREE_THIS_VOLATILE (gnat_raise_decls[i]) = 1;\n+      TREE_SIDE_EFFECTS (gnat_raise_decls[i]) = 1;\n+      TREE_TYPE (gnat_raise_decls[i])\n+\t= build_qualified_type (TREE_TYPE (gnat_raise_decls[i]),\n+\t\t\t\tTYPE_QUAL_VOLATILE);\n+    }\n+\n+  /* Set the types that GCC and Gigi use from the front end.  We would\n+     like to do this for char_type_node, but it needs to correspond to\n+     the C char type.  */\n+  exception_type\n+    = gnat_to_gnu_entity (Base_Type (standard_exception_type),  NULL_TREE, 0);\n+  except_type_node = TREE_TYPE (exception_type);\n+\n+  /* Make other functions used for exception processing.  */\n+  get_excptr_decl\n+    = create_subprog_decl\n+    (get_identifier (\"system__soft_links__get_gnat_exception\"),\n+     NULL_TREE,\n+     build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n+     NULL_TREE, false, true, true, NULL, Empty);\n+  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n+  DECL_PURE_P (get_excptr_decl) = 1;\n+\n+  raise_nodefer_decl\n+    = create_subprog_decl\n+      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n+       build_function_type (void_type_node,\n+\t\t\t    tree_cons (NULL_TREE,\n+\t\t\t\t       build_pointer_type (except_type_node),\n+\t\t\t\t       t)),\n+       NULL_TREE, false, true, true, NULL, Empty);\n+\n+  /* Indicate that these never return.  */\n+  TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n+  TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n+  TREE_TYPE (raise_nodefer_decl)\n+    = build_qualified_type (TREE_TYPE (raise_nodefer_decl),\n+\t\t\t    TYPE_QUAL_VOLATILE);\n+\n+  long_long_float_type\n+    = gnat_to_gnu_entity (Base_Type (standard_long_long_float), NULL_TREE, 0);\n+\n+  if (TREE_CODE (TREE_TYPE (long_long_float_type)) == INTEGER_TYPE)\n+    {\n+      /* In this case, the builtin floating point types are VAX float,\n+\t so make up a type for use.  */\n+      longest_float_type_node = make_node (REAL_TYPE);\n+      TYPE_PRECISION (longest_float_type_node) = LONG_DOUBLE_TYPE_SIZE;\n+      layout_type (longest_float_type_node);\n+      record_builtin_type (\"longest float type\", longest_float_type_node);\n+    }\n+  else\n+    longest_float_type_node = TREE_TYPE (long_long_float_type);\n+\n+  /* Build the special descriptor type and its null node if needed.  */\n+  if (TARGET_VTABLE_USES_DESCRIPTORS)\n+    {\n+      tree null_node = fold_convert (ptr_void_ftype, null_pointer_node);\n+      tree field_list = NULL_TREE, null_list = NULL_TREE;\n+      int j;\n+\n+      fdesc_type_node = make_node (RECORD_TYPE);\n+\n+      for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n+\t{\n+\t  tree field = create_field_decl (NULL_TREE, ptr_void_ftype,\n+\t\t\t\t\t  fdesc_type_node, 0, 0, 0, 1);\n+\t  TREE_CHAIN (field) = field_list;\n+\t  field_list = field;\n+\t  null_list = tree_cons (field, null_node, null_list);\n+\t}\n+\n+      finish_record_type (fdesc_type_node, nreverse (field_list), 0, false);\n+      null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_list);\n+    }\n+\n+  /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n+     tables.  These are exported by a-exexpr.adb, so see this unit for the\n+     types to use.  */\n+  others_decl\n+    = create_var_decl (get_identifier (\"OTHERS\"),\n+\t\t       get_identifier (\"__gnat_others_value\"),\n+\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n+\n+  all_others_decl\n+    = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n+\t\t       get_identifier (\"__gnat_all_others_value\"),\n+\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n+\n+  main_identifier_node = get_identifier (\"main\");\n+\n+  /* Install the builtins we might need, either internally or as\n+     user available facilities for Intrinsic imports.  */\n+  gnat_install_builtins ();\n \n   gnu_except_ptr_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n   gnu_constraint_error_label_stack\n     = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n   gnu_storage_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n   gnu_program_error_label_stack = tree_cons (NULL_TREE, NULL_TREE, NULL_TREE);\n \n-  gnu_standard_long_long_float\n-    = gnat_to_gnu_entity (Base_Type (standard_long_long_float), NULL_TREE, 0);\n-  gnu_standard_exception_type\n-    = gnat_to_gnu_entity (Base_Type (standard_exception_type),  NULL_TREE, 0);\n-\n-  init_gigi_decls (gnu_standard_long_long_float, gnu_standard_exception_type);\n-\n   /* Process any Pragma Ident for the main unit.  */\n #ifdef ASM_OUTPUT_IDENT\n   if (Present (Ident_String (Main_Unit)))\n@@ -873,7 +1108,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \tgnu_result = gnat_to_gnu (First (Expressions (gnat_node)));\n \tgnu_result_type = get_unpadded_type (Etype (gnat_node));\n \tgnu_result = convert_with_check (Etype (gnat_node), gnu_result,\n-\t\t\t\t\t checkp, checkp, true);\n+\t\t\t\t\t checkp, checkp, true, gnat_node);\n       }\n       break;\n \n@@ -894,7 +1129,7 @@ Attribute_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, int attribute)\n \t\t\t\tattribute == Attr_Pred\n \t\t\t\t? TYPE_MIN_VALUE (gnu_result_type)\n \t\t\t\t: TYPE_MAX_VALUE (gnu_result_type)),\n-\t       gnu_expr, CE_Range_Check_Failed);\n+\t       gnu_expr, CE_Range_Check_Failed, gnat_node);\n \t}\n \n       gnu_result\n@@ -2343,13 +2578,15 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \n \t  if (Ekind (gnat_formal) != E_Out_Parameter\n \t      && Do_Range_Check (gnat_actual))\n-\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n+\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal),\n+\t\t\t\t\t   gnat_actual);\n \t}\n       else\n \t{\n \t  if (Ekind (gnat_formal) != E_Out_Parameter\n \t      && Do_Range_Check (gnat_actual))\n-\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal));\n+\t    gnu_actual = emit_range_check (gnu_actual, Etype (gnat_formal),\n+\t\t\t\t\t   gnat_actual);\n \n \t  /* We may have suppressed a conversion to the Etype of the actual\n \t     since the parent is a procedure call.  So put it back here.\n@@ -2636,7 +2873,7 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t\t    (Etype (Expression (gnat_actual)), gnu_result,\n \t\t     Do_Overflow_Check (gnat_actual),\n \t\t     Do_Range_Check (Expression (gnat_actual)),\n-\t\t     Float_Truncate (gnat_actual));\n+\t\t     Float_Truncate (gnat_actual), gnat_actual);\n \n \t\tif (!Is_Composite_Type (Underlying_Type (Etype (gnat_formal))))\n \t\t  gnu_actual = convert (TREE_TYPE (gnu_result), gnu_actual);\n@@ -2653,8 +2890,9 @@ call_to_gnu (Node_Id gnat_node, tree *gnu_result_type_p, tree gnu_target)\n \t    else\n \t      {\n \t\tif (Do_Range_Check (gnat_actual))\n-\t\t  gnu_result = emit_range_check (gnu_result,\n-\t\t\t\t\t\t Etype (gnat_actual));\n+\t\t  gnu_result\n+\t\t    = emit_range_check (gnu_result, Etype (gnat_actual),\n+\t\t\t\t\tgnat_actual);\n \n \t\tif (!(!TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_actual)))\n \t\t      && TREE_CONSTANT (TYPE_SIZE (TREE_TYPE (gnu_result)))))\n@@ -3434,7 +3672,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t{\n \t  gnu_expr = gnat_to_gnu (Expression (gnat_node));\n \t  if (Do_Range_Check (Expression (gnat_node)))\n-\t    gnu_expr = emit_range_check (gnu_expr, Etype (gnat_temp));\n+\t    gnu_expr\n+\t      = emit_range_check (gnu_expr, Etype (gnat_temp), gnat_node);\n \n \t  /* If this object has its elaboration delayed, we must force\n \t     evaluation of GNU_EXPR right now and save it for when the object\n@@ -3569,7 +3808,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t= emit_index_check\n \t\t  (gnu_array_object, gnu_expr,\n \t\t   TYPE_MIN_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n-\t\t   TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))));\n+\t\t   TYPE_MAX_VALUE (TYPE_INDEX_TYPE (TYPE_DOMAIN (gnu_type))),\n+\t\t   gnat_temp);\n \n \t    gnu_result = build_binary_op (ARRAY_REF, NULL_TREE,\n \t\t\t\t\t  gnu_result, gnu_expr);\n@@ -3633,7 +3873,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t    gnu_expr = emit_check\n \t      (build_binary_op (TRUTH_ORIF_EXPR, integer_type_node,\n \t\t\t\tgnu_expr_l, gnu_expr_h),\n-\t       gnu_min_expr, CE_Index_Check_Failed);\n+\t       gnu_min_expr, CE_Index_Check_Failed, gnat_node);\n \n \t   /* Build a conditional expression that does the index checks and\n \t      returns the low bound if the slice is not empty (max >= min),\n@@ -3813,7 +4053,7 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t\t      Do_Overflow_Check (gnat_node),\n \t\t\t      Do_Range_Check (Expression (gnat_node)),\n \t\t\t      Nkind (gnat_node) == N_Type_Conversion\n-\t\t\t      && Float_Truncate (gnat_node));\n+\t\t\t      && Float_Truncate (gnat_node), gnat_node);\n       break;\n \n     case N_Unchecked_Type_Conversion:\n@@ -4028,8 +4268,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \t\t|| Nkind (gnat_node) == N_Op_Multiply)\n \t    && !TYPE_UNSIGNED (gnu_type)\n \t    && !FLOAT_TYPE_P (gnu_type))\n-\t  gnu_result\n-\t    = build_binary_op_trapv (code, gnu_type, gnu_lhs, gnu_rhs);\n+\t  gnu_result = build_binary_op_trapv (code, gnu_type,\n+\t\t\t\t\t      gnu_lhs, gnu_rhs, gnat_node);\n \telse\n \t  gnu_result = build_binary_op (code, gnu_type, gnu_lhs, gnu_rhs);\n \n@@ -4099,8 +4339,9 @@ gnat_to_gnu (Node_Id gnat_node)\n       if (Do_Overflow_Check (gnat_node)\n \t  && !TYPE_UNSIGNED (gnu_result_type)\n \t  && !FLOAT_TYPE_P (gnu_result_type))\n-\tgnu_result = build_unary_op_trapv (gnu_codes[Nkind (gnat_node)],\n-\t\t\t\t\t   gnu_result_type, gnu_expr);\n+\tgnu_result\n+\t  = build_unary_op_trapv (gnu_codes[Nkind (gnat_node)],\n+\t\t\t\t  gnu_result_type, gnu_expr, gnat_node);\n       else\n \tgnu_result = build_unary_op (gnu_codes[Nkind (gnat_node)],\n \t\t\t\t     gnu_result_type, gnu_expr);\n@@ -4131,7 +4372,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t    gnu_init = maybe_unconstrained_array (gnu_init);\n \t    if (Do_Range_Check (Expression (gnat_temp)))\n-\t      gnu_init = emit_range_check (gnu_init, gnat_desig_type);\n+\t      gnu_init\n+\t\t= emit_range_check (gnu_init, gnat_desig_type, gnat_temp);\n \n \t    if (Is_Elementary_Type (gnat_desig_type)\n \t\t|| Is_Constrained (gnat_desig_type))\n@@ -4196,7 +4438,8 @@ gnat_to_gnu (Node_Id gnat_node)\n \n \t  /* If range check is needed, emit code to generate it.  */\n \t  if (Do_Range_Check (Expression (gnat_node)))\n-\t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)));\n+\t    gnu_rhs = emit_range_check (gnu_rhs, Etype (Name (gnat_node)),\n+\t\t\t\t\tgnat_node);\n \n \t  gnu_result\n \t    = build_binary_op (MODIFY_EXPR, NULL_TREE, gnu_lhs, gnu_rhs);\n@@ -6002,10 +6245,13 @@ process_decls (List_Id gnat_decls, List_Id gnat_decls2,\n /* Make a unary operation of kind CODE using build_unary_op, but guard\n    the operation by an overflow check.  CODE can be one of NEGATE_EXPR\n    or ABS_EXPR.  GNU_TYPE is the type desired for the result.  Usually\n-   the operation is to be performed in that type.  */\n+   the operation is to be performed in that type.  GNAT_NODE is the gnat\n+   node conveying the source location for which the error should be\n+   signaled.  */\n \n static tree\n-build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand)\n+build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand,\n+\t\t      Node_Id gnat_node)\n {\n   gcc_assert (code == NEGATE_EXPR || code == ABS_EXPR);\n \n@@ -6014,17 +6260,19 @@ build_unary_op_trapv (enum tree_code code, tree gnu_type, tree operand)\n   return emit_check (build_binary_op (EQ_EXPR, integer_type_node,\n \t\t\t\t      operand, TYPE_MIN_VALUE (gnu_type)),\n \t\t     build_unary_op (code, gnu_type, operand),\n-\t\t     CE_Overflow_Check_Failed);\n+\t\t     CE_Overflow_Check_Failed, gnat_node);\n }\n \n /* Make a binary operation of kind CODE using build_binary_op, but guard\n    the operation by an overflow check.  CODE can be one of PLUS_EXPR,\n    MINUS_EXPR or MULT_EXPR.  GNU_TYPE is the type desired for the result.\n-   Usually the operation is to be performed in that type.  */\n+   Usually the operation is to be performed in that type.  GNAT_NODE is\n+   the GNAT node conveying the source location for which the error should\n+   be signaled.  */\n \n static tree\n build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n-\t\t       tree right)\n+\t\t       tree right, Node_Id gnat_node)\n {\n   tree lhs = protect_multiple_eval (left);\n   tree rhs = protect_multiple_eval (right);\n@@ -6098,7 +6346,8 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \n \t  tree result = convert (gnu_type, wide_result);\n \n-\t  return emit_check (check, result, CE_Overflow_Check_Failed);\n+\t  return\n+\t    emit_check (check, result, CE_Overflow_Check_Failed, gnat_node);\n \t}\n \n       else if (code == PLUS_EXPR || code == MINUS_EXPR)\n@@ -6119,7 +6368,8 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n \t     build_binary_op (code == PLUS_EXPR ? LT_EXPR : GT_EXPR,\n \t\t\t      integer_type_node, wrapped_expr, lhs));\n \n-\t  return emit_check (check, result, CE_Overflow_Check_Failed);\n+\t  return\n+\t    emit_check (check, result, CE_Overflow_Check_Failed, gnat_node);\n \t}\n    }\n \n@@ -6191,15 +6441,16 @@ build_binary_op_trapv (enum tree_code code, tree gnu_type, tree left,\n   check = fold_build3 (COND_EXPR, integer_type_node,\n \t\t       rhs_lt_zero,  check_neg, check_pos);\n \n-  return emit_check (check, gnu_expr, CE_Overflow_Check_Failed);\n+  return emit_check (check, gnu_expr, CE_Overflow_Check_Failed, gnat_node);\n }\n \n /* Emit code for a range check.  GNU_EXPR is the expression to be checked,\n    GNAT_RANGE_TYPE the gnat type or subtype containing the bounds against\n-   which we have to check.  */\n+   which we have to check.  GNAT_NODE is the GNAT node conveying the source\n+   location for which the error should be signaled.  */\n \n static tree\n-emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n+emit_range_check (tree gnu_expr, Entity_Id gnat_range_type, Node_Id gnat_node)\n {\n   tree gnu_range_type = get_unpadded_type (gnat_range_type);\n   tree gnu_low  = TYPE_MIN_VALUE (gnu_range_type);\n@@ -6238,7 +6489,7 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n \t\t\t\t\tconvert (gnu_compare_type, gnu_expr),\n \t\t\t\t\tconvert (gnu_compare_type,\n \t\t\t\t\t\t gnu_high)))),\n-     gnu_expr, CE_Range_Check_Failed);\n+     gnu_expr, CE_Range_Check_Failed, gnat_node);\n }\n \f\n /* Emit code for an index check.  GNU_ARRAY_OBJECT is the array object which\n@@ -6250,11 +6501,12 @@ emit_range_check (tree gnu_expr, Entity_Id gnat_range_type)\n    checking the indices may be unconstrained and consequently we need to get\n    the actual index bounds from the array object itself (GNU_ARRAY_OBJECT).\n    The place where we need to do that is in subprograms having unconstrained\n-   array formal parameters.  */\n+   array formal parameters.  GNAT_NODE is the GNAT node conveying the source\n+   location for which the error should be signaled.  */\n \n static tree\n emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n-\t\t  tree gnu_high)\n+\t\t  tree gnu_high, Node_Id gnat_node)\n {\n   tree gnu_expr_check;\n \n@@ -6282,18 +6534,21 @@ emit_index_check (tree gnu_array_object, tree gnu_expr, tree gnu_low,\n \t\t\t\t       gnu_expr_check,\n \t\t\t\t       convert (TREE_TYPE (gnu_expr_check),\n \t\t\t\t\t\tgnu_high))),\n-     gnu_expr, CE_Index_Check_Failed);\n+     gnu_expr, CE_Index_Check_Failed, gnat_node);\n }\n \f\n /* GNU_COND contains the condition corresponding to an access, discriminant or\n    range check of value GNU_EXPR.  Build a COND_EXPR that returns GNU_EXPR if\n    GNU_COND is false and raises a CONSTRAINT_ERROR if GNU_COND is true.\n-   REASON is the code that says why the exception was raised.  */\n+   REASON is the code that says why the exception was raised.  GNAT_NODE is\n+   the GNAT node conveying the source location for which the error should be\n+   signaled.  */\n \n static tree\n-emit_check (tree gnu_cond, tree gnu_expr, int reason)\n+emit_check (tree gnu_cond, tree gnu_expr, int reason, Node_Id gnat_node)\n {\n-  tree gnu_call = build_call_raise (reason, Empty, N_Raise_Constraint_Error);\n+  tree gnu_call\n+    = build_call_raise (reason, gnat_node, N_Raise_Constraint_Error);\n   tree gnu_result\n     = fold_build3 (COND_EXPR, TREE_TYPE (gnu_expr), gnu_cond,\n \t\t   build2 (COMPOUND_EXPR, TREE_TYPE (gnu_expr), gnu_call,\n@@ -6313,11 +6568,13 @@ emit_check (tree gnu_cond, tree gnu_expr, int reason)\n /* Return an expression that converts GNU_EXPR to GNAT_TYPE, doing overflow\n    checks if OVERFLOW_P is true and range checks if RANGE_P is true.\n    GNAT_TYPE is known to be an integral type.  If TRUNCATE_P true, do a\n-   float to integer conversion with truncation; otherwise round.  */\n+   float to integer conversion with truncation; otherwise round.\n+   GNAT_NODE is the GNAT node conveying the source location for which the\n+   error should be signaled.  */\n \n static tree\n convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n-\t\t    bool rangep, bool truncatep)\n+\t\t    bool rangep, bool truncatep, Node_Id gnat_node)\n {\n   tree gnu_type = get_unpadded_type (gnat_type);\n   tree gnu_in_type = TREE_TYPE (gnu_expr);\n@@ -6408,8 +6665,8 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n \t\t\t\t\t\t\tgnu_out_ub))));\n \n       if (!integer_zerop (gnu_cond))\n-\tgnu_result\n-\t  = emit_check (gnu_cond, gnu_input, CE_Overflow_Check_Failed);\n+\tgnu_result = emit_check (gnu_cond, gnu_input,\n+\t\t\t\t CE_Overflow_Check_Failed, gnat_node);\n     }\n \n   /* Now convert to the result base type.  If this is a non-truncating\n@@ -6484,7 +6741,7 @@ convert_with_check (Entity_Id gnat_type, tree gnu_expr, bool overflowp,\n   if (rangep\n       || (TREE_CODE (gnu_base_type) == INTEGER_TYPE\n \t  && TYPE_MODULAR_P (gnu_base_type) && overflowp))\n-    gnu_result = emit_range_check (gnu_result, gnat_type);\n+    gnu_result = emit_range_check (gnu_result, gnat_type, gnat_node);\n \n   return convert (gnu_type, gnu_result);\n }\n@@ -6685,10 +6942,7 @@ process_type (Entity_Id gnat_entity)\n \n       if (!gnu_old)\n \t{\n-\t  tree gnu_decl = create_type_decl (get_entity_name (gnat_entity),\n-\t\t\t\t\t    make_dummy_type (gnat_entity),\n-\t\t\t\t\t    NULL, false, false, gnat_entity);\n-\n+\t  tree gnu_decl = TYPE_STUB_DECL (make_dummy_type (gnat_entity));\n \t  save_gnu_tree (gnat_entity, gnu_decl, false);\n \t  if (IN (Ekind (gnat_entity), Incomplete_Or_Private_Kind)\n \t      && Present (Full_View (gnat_entity)))\n@@ -6781,7 +7035,7 @@ assoc_to_constructor (Entity_Id gnat_entity, Node_Id gnat_assoc, tree gnu_type)\n       /* Before assigning a value in an aggregate make sure range checks\n \t are done if required.  Then convert to the type of the field.  */\n       if (Do_Range_Check (Expression (gnat_assoc)))\n-\tgnu_expr = emit_range_check (gnu_expr, Etype (gnat_field));\n+\tgnu_expr = emit_range_check (gnu_expr, Etype (gnat_field), Empty);\n \n       gnu_expr = convert (TREE_TYPE (gnu_field), gnu_expr);\n \n@@ -6823,7 +7077,6 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n       /* If the expression is itself an array aggregate then first build the\n \t innermost constructor if it is part of our array (multi-dimensional\n \t case).  */\n-\n       if (Nkind (gnat_expr) == N_Aggregate\n \t  && TREE_CODE (TREE_TYPE (gnu_array_type)) == ARRAY_TYPE\n \t  && TYPE_MULTI_ARRAY_P (TREE_TYPE (gnu_array_type)))\n@@ -6834,10 +7087,10 @@ pos_to_constructor (Node_Id gnat_expr, tree gnu_array_type,\n \t{\n \t  gnu_expr = gnat_to_gnu (gnat_expr);\n \n-\t  /* before assigning the element to the array make sure it is\n+\t  /* Before assigning the element to the array, make sure it is\n \t     in range.  */\n \t  if (Do_Range_Check (gnat_expr))\n-\t    gnu_expr = emit_range_check (gnu_expr, gnat_component_type);\n+\t    gnu_expr = emit_range_check (gnu_expr, gnat_component_type, Empty);\n \t}\n \n       gnu_expr_list\n@@ -7183,8 +7436,7 @@ Sloc_to_locus (Source_Ptr Sloc, location_t *locus)\n \n   if (Sloc <= Standard_Location)\n     {\n-      if (*locus == UNKNOWN_LOCATION)\n-\t*locus = BUILTINS_LOCATION;\n+      *locus = BUILTINS_LOCATION;\n       return false;\n     }\n   else"}, {"sha": "78080b1909c430c4f347c453a9fcf8b817f37437", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 67, "deletions": 299, "changes": 366, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/10069d53fb535c72d70e2c7dab53347d40a89f37/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=10069d53fb535c72d70e2c7dab53347d40a89f37", "patch": "@@ -6,7 +6,7 @@\n  *                                                                          *\n  *                          C Implementation File                           *\n  *                                                                          *\n- *          Copyright (C) 1992-2008, Free Software Foundation, Inc.         *\n+ *          Copyright (C) 1992-2009, Free Software Foundation, Inc.         *\n  *                                                                          *\n  * GNAT is free software;  you can  redistribute it  and/or modify it under *\n  * terms of the  GNU General Public License as published  by the Free Soft- *\n@@ -188,7 +188,6 @@ static GTY(()) VEC(tree,gc) *global_renaming_pointers;\n /* A chain of unused BLOCK nodes. */\n static GTY((deletable)) tree free_block_chain;\n \n-static void gnat_install_builtins (void);\n static tree merge_sizes (tree, tree, tree, bool, bool);\n static tree compute_related_constant (tree, tree);\n static tree split_plus (tree, tree *);\n@@ -287,11 +286,10 @@ make_dummy_type (Entity_Id gnat_type)\n \t\t\t: ENUMERAL_TYPE);\n   TYPE_NAME (gnu_type) = get_entity_name (gnat_type);\n   TYPE_DUMMY_P (gnu_type) = 1;\n+  TYPE_STUB_DECL (gnu_type)\n+    = create_type_stub_decl (TYPE_NAME (gnu_type), gnu_type);\n   if (AGGREGATE_TYPE_P (gnu_type))\n-    {\n-      TYPE_STUB_DECL (gnu_type) = build_decl (TYPE_DECL, NULL_TREE, gnu_type);\n-      TYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_type);\n-    }\n+    TYPE_BY_REFERENCE_P (gnu_type) = Is_By_Reference_Type (gnat_type);\n \n   SET_DUMMY_NODE (gnat_underlying, gnu_type);\n \n@@ -465,8 +463,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     }\n \n   /* For the declaration of a type, set its name if it either is not already\n-     set, was set to an IDENTIFIER_NODE, indicating an internal name,\n-     or if the previous type name was not derived from a source name.\n+     set or if the previous type name was not derived from a source name.\n      We'd rather have the type named with a real name and all the pointer\n      types to the same object have the same POINTER_TYPE node.  Code in the\n      equivalent function of c-decl.c makes a copy of the type node here, but\n@@ -478,7 +475,7 @@ gnat_pushdecl (tree decl, Node_Id gnat_node)\n     {\n       tree t = TREE_TYPE (decl);\n \n-      if (!TYPE_NAME (t) || TREE_CODE (TYPE_NAME (t)) == IDENTIFIER_NODE)\n+      if (!(TYPE_NAME (t) && TREE_CODE (TYPE_NAME (t)) == TYPE_DECL))\n \t;\n       else if (TYPE_FAT_POINTER_P (t))\n \t{\n@@ -534,271 +531,18 @@ gnat_init_decl_processing (void)\n \n   ptr_void_type_node = build_pointer_type (void_type_node);\n }\n-\n-/* Create the predefined scalar types such as `integer_type_node' needed\n-   in the gcc back-end and initialize the global binding level.  */\n+\f\n+/* Record TYPE as a builtin type for Ada.  NAME is the name of the type.  */\n \n void\n-init_gigi_decls (tree long_long_float_type, tree exception_type)\n+record_builtin_type (const char *name, tree type)\n {\n-  tree endlink, decl;\n-  tree int64_type = gnat_type_for_size (64, 0);\n-  unsigned int i;\n-\n-  /* Set the types that GCC and Gigi use from the front end.  We would like\n-     to do this for char_type_node, but it needs to correspond to the C\n-     char type.  */\n-  if (TREE_CODE (TREE_TYPE (long_long_float_type)) == INTEGER_TYPE)\n-    {\n-      /* In this case, the builtin floating point types are VAX float,\n-\t so make up a type for use.  */\n-      longest_float_type_node = make_node (REAL_TYPE);\n-      TYPE_PRECISION (longest_float_type_node) = LONG_DOUBLE_TYPE_SIZE;\n-      layout_type (longest_float_type_node);\n-      create_type_decl (get_identifier (\"longest float type\"),\n-\t\t\tlongest_float_type_node, NULL, false, true, Empty);\n-    }\n-  else\n-    longest_float_type_node = TREE_TYPE (long_long_float_type);\n-\n-  except_type_node = TREE_TYPE (exception_type);\n-\n-  unsigned_type_node = gnat_type_for_size (INT_TYPE_SIZE, 1);\n-  create_type_decl (get_identifier (\"unsigned int\"), unsigned_type_node,\n-\t\t    NULL, false, true, Empty);\n-\n-  void_type_decl_node = create_type_decl (get_identifier (\"void\"),\n-\t\t\t\t\t  void_type_node, NULL, false, true,\n-\t\t\t\t\t  Empty);\n-\n-  void_ftype = build_function_type (void_type_node, NULL_TREE);\n-  ptr_void_ftype = build_pointer_type (void_ftype);\n-\n-  /* Build the special descriptor type and its null node if needed.  */\n-  if (TARGET_VTABLE_USES_DESCRIPTORS)\n-    {\n-      tree null_node = fold_convert (ptr_void_ftype, null_pointer_node);\n-      tree field_list = NULL_TREE, null_list = NULL_TREE;\n-      int j;\n-\n-      fdesc_type_node = make_node (RECORD_TYPE);\n-\n-      for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n-\t{\n-\t  tree field = create_field_decl (NULL_TREE, ptr_void_ftype,\n-\t\t\t\t\t  fdesc_type_node, 0, 0, 0, 1);\n-\t  TREE_CHAIN (field) = field_list;\n-\t  field_list = field;\n-\t  null_list = tree_cons (field, null_node, null_list);\n-\t}\n-\n-      finish_record_type (fdesc_type_node, nreverse (field_list), 0, false);\n-      null_fdesc_node = gnat_build_constructor (fdesc_type_node, null_list);\n-    }\n+  tree type_decl = build_decl (TYPE_DECL, get_identifier (name), type);\n \n-  /* Now declare runtime functions. */\n-  endlink = tree_cons (NULL_TREE, void_type_node, NULL_TREE);\n-\n-  /* malloc is a function declaration tree for a function to allocate\n-     memory.  */\n-  malloc_decl = create_subprog_decl (get_identifier (\"__gnat_malloc\"),\n-\t\t\t\t     NULL_TREE,\n-\t\t\t\t     build_function_type (ptr_void_type_node,\n-\t\t\t\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t\t     sizetype,\n-\t\t\t\t\t\t\t\t     endlink)),\n-\t\t\t\t     NULL_TREE, false, true, true, NULL,\n-\t\t\t\t     Empty);\n-  DECL_IS_MALLOC (malloc_decl) = 1;\n-\n-  /* malloc32 is a function declaration tree for a function to allocate\n-     32bit memory on a 64bit system. Needed only on 64bit VMS.  */\n-  malloc32_decl = create_subprog_decl (get_identifier (\"__gnat_malloc32\"),\n-\t\t\t\t     NULL_TREE,\n-\t\t\t\t     build_function_type (ptr_void_type_node,\n-\t\t\t\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t\t     sizetype,\n-\t\t\t\t\t\t\t\t     endlink)),\n-\t\t\t\t     NULL_TREE, false, true, true, NULL,\n-\t\t\t\t     Empty);\n-  DECL_IS_MALLOC (malloc32_decl) = 1;\n-\n-  /* free is a function declaration tree for a function to free memory.  */\n-  free_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_free\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n-\n-  /* This is used for 64-bit multiplication with overflow checking.  */\n-  mulv64_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_mulv64\"), NULL_TREE,\n-\t\t\t   build_function_type_list (int64_type, int64_type,\n-\t\t\t\t\t\t     int64_type, NULL_TREE),\n-\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n-\n-  /* Make the types and functions used for exception processing.    */\n-  jmpbuf_type\n-    = build_array_type (gnat_type_for_mode (Pmode, 0),\n-\t\t\tbuild_index_type (build_int_cst (NULL_TREE, 5)));\n-  create_type_decl (get_identifier (\"JMPBUF_T\"), jmpbuf_type, NULL,\n-\t\t    true, true, Empty);\n-  jmpbuf_ptr_type = build_pointer_type (jmpbuf_type);\n-\n-  /* Functions to get and set the jumpbuf pointer for the current thread.  */\n-  get_jmpbuf_decl\n-    = create_subprog_decl\n-    (get_identifier (\"system__soft_links__get_jmpbuf_address_soft\"),\n-     NULL_TREE, build_function_type (jmpbuf_ptr_type, NULL_TREE),\n-     NULL_TREE, false, true, true, NULL, Empty);\n-  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n-  DECL_PURE_P (get_jmpbuf_decl) = 1;\n-\n-  set_jmpbuf_decl\n-    = create_subprog_decl\n-    (get_identifier (\"system__soft_links__set_jmpbuf_address_soft\"),\n-     NULL_TREE,\n-     build_function_type (void_type_node,\n-\t\t\t  tree_cons (NULL_TREE, jmpbuf_ptr_type, endlink)),\n-     NULL_TREE, false, true, true, NULL, Empty);\n-\n-  /* Function to get the current exception.  */\n-  get_excptr_decl\n-    = create_subprog_decl\n-    (get_identifier (\"system__soft_links__get_gnat_exception\"),\n-     NULL_TREE,\n-     build_function_type (build_pointer_type (except_type_node), NULL_TREE),\n-     NULL_TREE, false, true, true, NULL, Empty);\n-  /* Avoid creating superfluous edges to __builtin_setjmp receivers.  */\n-  DECL_PURE_P (get_excptr_decl) = 1;\n-\n-  /* Functions that raise exceptions. */\n-  raise_nodefer_decl\n-    = create_subprog_decl\n-      (get_identifier (\"__gnat_raise_nodefer_with_msg\"), NULL_TREE,\n-       build_function_type (void_type_node,\n-\t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t       build_pointer_type (except_type_node),\n-\t\t\t\t       endlink)),\n-       NULL_TREE, false, true, true, NULL, Empty);\n-\n-  /* Dummy objects to materialize \"others\" and \"all others\" in the exception\n-     tables.  These are exported by a-exexpr.adb, so see this unit for the\n-     types to use.  */\n-\n-  others_decl\n-    = create_var_decl (get_identifier (\"OTHERS\"),\n-\t\t       get_identifier (\"__gnat_others_value\"),\n-\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n-\n-  all_others_decl\n-    = create_var_decl (get_identifier (\"ALL_OTHERS\"),\n-\t\t       get_identifier (\"__gnat_all_others_value\"),\n-\t\t       integer_type_node, 0, 1, 0, 1, 1, 0, Empty);\n-\n-  /* Hooks to call when entering/leaving an exception handler.  */\n-  begin_handler_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_begin_handler\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n-\n-  end_handler_decl\n-    = create_subprog_decl (get_identifier (\"__gnat_end_handler\"), NULL_TREE,\n-\t\t\t   build_function_type (void_type_node,\n-\t\t\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t\t   endlink)),\n-\t\t\t   NULL_TREE, false, true, true, NULL, Empty);\n-\n-  /* If in no exception handlers mode, all raise statements are redirected to\n-     __gnat_last_chance_handler. No need to redefine raise_nodefer_decl, since\n-     this procedure will never be called in this mode.  */\n-  if (No_Exception_Handlers_Set ())\n-    {\n-      decl\n-\t= create_subprog_decl\n-\t  (get_identifier (\"__gnat_last_chance_handler\"), NULL_TREE,\n-\t   build_function_type (void_type_node,\n-\t\t\t\ttree_cons (NULL_TREE,\n-\t\t\t\t\t   build_pointer_type (char_type_node),\n-\t\t\t\t\t   tree_cons (NULL_TREE,\n-\t\t\t\t\t\t      integer_type_node,\n-\t\t\t\t\t\t      endlink))),\n-\t   NULL_TREE, false, true, true, NULL, Empty);\n-\n-      for (i = 0; i < ARRAY_SIZE (gnat_raise_decls); i++)\n-\tgnat_raise_decls[i] = decl;\n-    }\n-  else\n-    /* Otherwise, make one decl for each exception reason.  */\n-    for (i = 0; i < ARRAY_SIZE (gnat_raise_decls); i++)\n-      {\n-\tchar name[17];\n-\n-\tsprintf (name, \"__gnat_rcheck_%.2d\", i);\n-\tgnat_raise_decls[i]\n-\t  = create_subprog_decl\n-\t    (get_identifier (name), NULL_TREE,\n-\t     build_function_type (void_type_node,\n-\t\t\t\t  tree_cons (NULL_TREE,\n-\t\t\t\t\t     build_pointer_type\n-\t\t\t\t\t     (char_type_node),\n-\t\t\t\t\t     tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\tinteger_type_node,\n-\t\t\t\t\t\t\tendlink))),\n-\t     NULL_TREE, false, true, true, NULL, Empty);\n-      }\n-\n-  /* Indicate that these never return.  */\n-  TREE_THIS_VOLATILE (raise_nodefer_decl) = 1;\n-  TREE_SIDE_EFFECTS (raise_nodefer_decl) = 1;\n-  TREE_TYPE (raise_nodefer_decl)\n-    = build_qualified_type (TREE_TYPE (raise_nodefer_decl),\n-\t\t\t    TYPE_QUAL_VOLATILE);\n+  gnat_pushdecl (type_decl, Empty);\n \n-  for (i = 0; i < ARRAY_SIZE (gnat_raise_decls); i++)\n-    {\n-      TREE_THIS_VOLATILE (gnat_raise_decls[i]) = 1;\n-      TREE_SIDE_EFFECTS (gnat_raise_decls[i]) = 1;\n-      TREE_TYPE (gnat_raise_decls[i])\n-\t= build_qualified_type (TREE_TYPE (gnat_raise_decls[i]),\n-\t\t\t\tTYPE_QUAL_VOLATILE);\n-    }\n-\n-  /* setjmp returns an integer and has one operand, which is a pointer to\n-     a jmpbuf.  */\n-  setjmp_decl\n-    = create_subprog_decl\n-      (get_identifier (\"__builtin_setjmp\"), NULL_TREE,\n-       build_function_type (integer_type_node,\n-\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, false, true, true, NULL, Empty);\n-\n-  DECL_BUILT_IN_CLASS (setjmp_decl) = BUILT_IN_NORMAL;\n-  DECL_FUNCTION_CODE (setjmp_decl) = BUILT_IN_SETJMP;\n-\n-  /* update_setjmp_buf updates a setjmp buffer from the current stack pointer\n-     address.  */\n-  update_setjmp_buf_decl\n-    = create_subprog_decl\n-      (get_identifier (\"__builtin_update_setjmp_buf\"), NULL_TREE,\n-       build_function_type (void_type_node,\n-\t\t\t    tree_cons (NULL_TREE,  jmpbuf_ptr_type, endlink)),\n-       NULL_TREE, false, true, true, NULL, Empty);\n-\n-  DECL_BUILT_IN_CLASS (update_setjmp_buf_decl) = BUILT_IN_NORMAL;\n-  DECL_FUNCTION_CODE (update_setjmp_buf_decl) = BUILT_IN_UPDATE_SETJMP_BUF;\n-\n-  main_identifier_node = get_identifier (\"main\");\n-\n-  /* Install the builtins we might need, either internally or as\n-     user available facilities for Intrinsic imports.  */\n-  gnat_install_builtins ();\n+  if (debug_hooks->type_decl)\n+    debug_hooks->type_decl (type_decl, false);\n }\n \f\n /* Given a record type RECORD_TYPE and a chain of FIELD_DECL nodes FIELDLIST,\n@@ -824,15 +568,13 @@ finish_record_type (tree record_type, tree fieldlist, int rep_level,\n   bool had_align = TYPE_ALIGN (record_type) != 0;\n   tree field;\n \n-  if (name && TREE_CODE (name) == TYPE_DECL)\n-    name = DECL_NAME (name);\n-\n   TYPE_FIELDS (record_type) = fieldlist;\n-  TYPE_STUB_DECL (record_type) = build_decl (TYPE_DECL, name, record_type);\n \n-  /* We don't need both the typedef name and the record name output in\n-     the debugging information, since they are the same.  */\n-  DECL_ARTIFICIAL (TYPE_STUB_DECL (record_type)) = 1;\n+  /* Always attach the TYPE_STUB_DECL for a record type.  It is required to\n+     generate debug info and have a parallel type.  */\n+  if (name && TREE_CODE (name) == TYPE_DECL)\n+    name = DECL_NAME (name);\n+  TYPE_STUB_DECL (record_type) = create_type_stub_decl (name, record_type);\n \n   /* Globally initialize the record first.  If this is a rep'ed record,\n      that just means some initializations; otherwise, layout the record.  */\n@@ -1075,8 +817,7 @@ rest_of_record_type_compilation (tree record_type)\n       TYPE_NAME (new_record_type) = new_id;\n       TYPE_ALIGN (new_record_type) = BIGGEST_ALIGNMENT;\n       TYPE_STUB_DECL (new_record_type)\n-\t= build_decl (TYPE_DECL, new_id, new_record_type);\n-      DECL_ARTIFICIAL (TYPE_STUB_DECL (new_record_type)) = 1;\n+\t= create_type_stub_decl (new_id, new_record_type);\n       DECL_IGNORED_P (TYPE_STUB_DECL (new_record_type))\n \t= DECL_IGNORED_P (TYPE_STUB_DECL (record_type));\n       TYPE_SIZE (new_record_type) = size_int (TYPE_ALIGN (record_type));\n@@ -1448,30 +1189,62 @@ create_index_type (tree min, tree max, tree index, Node_Id gnat_node)\n   return type;\n }\n \f\n-/* Return a TYPE_DECL node. TYPE_NAME gives the name of the type (a character\n-   string) and TYPE is a ..._TYPE node giving its data type.\n-   ARTIFICIAL_P is true if this is a declaration that was generated\n-   by the compiler.  DEBUG_INFO_P is true if we need to write debugging\n-   information about this type.  GNAT_NODE is used for the position of\n-   the decl.  */\n+/* Return a TYPE_DECL node suitable for the TYPE_STUB_DECL field of a type.\n+   TYPE_NAME gives the name of the type and TYPE is a ..._TYPE node giving\n+   its data type.  */\n+\n+tree\n+create_type_stub_decl (tree type_name, tree type)\n+{\n+  /* Using a named TYPE_DECL ensures that a type name marker is emitted in\n+     STABS while setting DECL_ARTIFICIAL ensures that no DW_TAG_typedef is\n+     emitted in DWARF.  */\n+  tree type_decl = build_decl (TYPE_DECL, type_name, type);\n+  DECL_ARTIFICIAL (type_decl) = 1;\n+  return type_decl;\n+}\n+\n+/* Return a TYPE_DECL node.  TYPE_NAME gives the name of the type and TYPE\n+   is a ..._TYPE node giving its data type.  ARTIFICIAL_P is true if this\n+   is a declaration that was generated by the compiler.  DEBUG_INFO_P is\n+   true if we need to write debug information about this type.  GNAT_NODE\n+   is used for the position of the decl.  */\n \n tree\n create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \t\t  bool artificial_p, bool debug_info_p, Node_Id gnat_node)\n {\n-  tree type_decl = build_decl (TYPE_DECL, type_name, type);\n   enum tree_code code = TREE_CODE (type);\n+  bool named = TYPE_NAME (type) && TREE_CODE (TYPE_NAME (type)) == TYPE_DECL;\n+  tree type_decl;\n \n-  DECL_ARTIFICIAL (type_decl) = artificial_p;\n+  /* Only the builtin TYPE_STUB_DECL should be used for dummy types.  */\n+  gcc_assert (!TYPE_IS_DUMMY_P (type));\n \n-  if (!TYPE_IS_DUMMY_P (type))\n-    gnat_pushdecl (type_decl, gnat_node);\n+  /* If the type hasn't been named yet, we're naming it; preserve an existing\n+     TYPE_STUB_DECL that has been attached to it for some purpose.  */\n+  if (!named && TYPE_STUB_DECL (type))\n+    {\n+      type_decl = TYPE_STUB_DECL (type);\n+      DECL_NAME (type_decl) = type_name;\n+    }\n+  else\n+    type_decl = build_decl (TYPE_DECL, type_name, type);\n \n+  DECL_ARTIFICIAL (type_decl) = artificial_p;\n+  gnat_pushdecl (type_decl, gnat_node);\n   process_attributes (type_decl, attr_list);\n \n-  /* Pass type declaration information to the debugger unless this is an\n-     UNCONSTRAINED_ARRAY_TYPE, which the debugger does not support,\n-     and ENUMERAL_TYPE or RECORD_TYPE which is handled separately, or\n+  /* If we're naming the type, equate the TYPE_STUB_DECL to the name.\n+     This causes the name to be also viewed as a \"tag\" by the debug\n+     back-end, with the advantage that no DW_TAG_typedef is emitted\n+     for artificial \"tagged\" types in DWARF.  */\n+  if (!named)\n+    TYPE_STUB_DECL (type) = type_decl;\n+\n+  /* Pass the type declaration to the debug back-end unless this is an\n+     UNCONSTRAINED_ARRAY_TYPE that the back-end does not support, an\n+     ENUMERAL_TYPE or RECORD_TYPE which are handled separately, or a\n      type for which debugging information was not requested.  */\n   if (code == UNCONSTRAINED_ARRAY_TYPE || !debug_info_p)\n     DECL_IGNORED_P (type_decl) = 1;\n@@ -1483,7 +1256,7 @@ create_type_decl (tree type_name, tree type, struct attrib *attr_list,\n \n   return type_decl;\n }\n-\n+\f\n /* Return a VAR_DECL or CONST_DECL node.\n \n    VAR_NAME gives the name of the variable.  ASM_NAME is its assembler name\n@@ -2297,7 +2070,6 @@ gnat_gimplify_function (tree fndecl)\n   for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n     gnat_gimplify_function (cgn->decl);\n }\n-\f\n \n tree\n gnat_builtin_function (tree decl)\n@@ -2966,10 +2738,8 @@ build_vms_descriptor32 (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       post_error (\"unsupported descriptor type for &\", gnat_entity);\n     }\n \n+  TYPE_NAME (record_type) = create_concat_name (gnat_entity, \"DESC\");\n   finish_record_type (record_type, field_list, 0, true);\n-  create_type_decl (create_concat_name (gnat_entity, \"DESC\"), record_type,\n-\t\t    NULL, true, false, gnat_entity);\n-\n   return record_type;\n }\n \n@@ -3282,10 +3052,8 @@ build_vms_descriptor (tree type, Mechanism_Type mech, Entity_Id gnat_entity)\n       post_error (\"unsupported descriptor type for &\", gnat_entity);\n     }\n \n+  TYPE_NAME (record64_type) = create_concat_name (gnat_entity, \"DESC64\");\n   finish_record_type (record64_type, field_list64, 0, true);\n-  create_type_decl (create_concat_name (gnat_entity, \"DESC64\"), record64_type,\n-\t\t    NULL, true, false, gnat_entity);\n-\n   return record64_type;\n }\n "}]}