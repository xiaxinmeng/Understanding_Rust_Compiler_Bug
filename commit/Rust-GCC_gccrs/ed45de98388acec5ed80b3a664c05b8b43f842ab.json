{"sha": "ed45de98388acec5ed80b3a664c05b8b43f842ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWQ0NWRlOTgzODhhY2VjNWVkODBiM2E2NjRjMDViOGI0M2Y4NDJhYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@rabi.columbia.edu", "date": "1999-04-12T12:03:10Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "1999-04-12T12:03:10Z"}, "message": "cpphash.c (collect_expansion, [...]): Make the escape character in macro buffers '\\r', not '@'.\n\n1999-04-12 14:55 -0400  Zack Weinberg  <zack@rabi.columbia.edu>\n\t* cpphash.c (collect_expansion, macroexpand,\n\tpush_macro_expansion): Make the escape character in macro\n\tbuffers '\\r', not '@'.  Remove code to protect literal\n\toccurences of the escape character; '\\r' cannot appear\n\tin a macro buffer unless we put it there.\n\t* cpplib.c (skip_comment, copy_comment, cpp_skip_hspace,\n\tcopy_rest_of_line, cpp_get_token, parse_string,\n\tparse_assertion): '\\r' might be a backslash-newline marker, or\n\tit might be a macro escape marker, depending on\n\tCPP_BUFFER (pfile)->has_escapes.  '@' is not a special\n\tcharacter.\n\t* cpplib.h: Update commentary.\n\nFrom-SVN: r26371", "tree": {"sha": "2e0d76a1e5b4079159764fc03161a906466d6b74", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2e0d76a1e5b4079159764fc03161a906466d6b74"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ed45de98388acec5ed80b3a664c05b8b43f842ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed45de98388acec5ed80b3a664c05b8b43f842ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ed45de98388acec5ed80b3a664c05b8b43f842ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ed45de98388acec5ed80b3a664c05b8b43f842ab/comments", "author": null, "committer": null, "parents": [{"sha": "802dbc34915da16c5fe637f54d1a18287eabb9d2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/802dbc34915da16c5fe637f54d1a18287eabb9d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/802dbc34915da16c5fe637f54d1a18287eabb9d2"}], "stats": {"total": 228, "additions": 125, "deletions": 103}, "files": [{"sha": "148fb5772ef623b65cf1f6fde6f44dde9d76f080", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ed45de98388acec5ed80b3a664c05b8b43f842ab", "patch": "@@ -1,3 +1,18 @@\n+1999-04-12 14:55 -0400  Zack Weinberg  <zack@rabi.columbia.edu>\n+\n+\t* cpphash.c (collect_expansion, macroexpand,\n+\tpush_macro_expansion): Make the escape character in macro\n+\tbuffers '\\r', not '@'.  Remove code to protect literal\n+\toccurences of the escape character; '\\r' cannot appear\n+\tin a macro buffer unless we put it there.\n+\t* cpplib.c (skip_comment, copy_comment, cpp_skip_hspace,\n+\tcopy_rest_of_line, cpp_get_token, parse_string,\n+\tparse_assertion): '\\r' might be a backslash-newline marker, or\n+\tit might be a macro escape marker, depending on\n+\tCPP_BUFFER (pfile)->has_escapes.  '@' is not a special\n+\tcharacter.\n+\t* cpplib.h: Update commentary.\n+\n Mon Apr 12 09:30:03 1999  Richard Earnshaw (rearnsha@arm.com)\n \n \t* arm.h (target_fp_name, structure_size_string, arm_cpu_select):"}, {"sha": "06de9d443efb8c7bf5de0ab1af1e002aeb756f8d", "filename": "gcc/cpphash.c", "status": "modified", "additions": 15, "deletions": 42, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpphash.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpphash.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.c?ref=ed45de98388acec5ed80b3a664c05b8b43f842ab", "patch": "@@ -304,10 +304,6 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n      leading and trailing newline-marker and final null.  */\n   maxsize = (sizeof (DEFINITION)\n \t     + (limit - p) + 5);\n-  /* Occurrences of '@' get doubled, so allocate extra space for them.  */\n-  while (p < limit)\n-    if (*p++ == '@')\n-      maxsize++;\n   defn = (DEFINITION *) xcalloc (1, maxsize);\n \n   defn->nargs = nargs;\n@@ -318,7 +314,7 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \n   /* Add one initial space escape-marker to prevent accidental\n      token-pasting (often removed by macroexpand).  */\n-  *exp_p++ = '@';\n+  *exp_p++ = '\\r';\n   *exp_p++ = ' ';\n \n   if (limit - p >= 2 && p[0] == '#' && p[1] == '#')\n@@ -359,13 +355,6 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \t\t}\n \t      break;\n \n-\t    case '@':\n-\t      /* An '@' in a string or character constant stands for itself,\n-\t         and does not need to be escaped.  */\n-\t      if (!expected_delimiter)\n-\t\t*exp_p++ = c;\n-\t      break;\n-\n \t    case '#':\n \t      /* # is ordinary inside a string.  */\n \t      if (expected_delimiter)\n@@ -548,10 +537,10 @@ collect_expansion (pfile, buf, limit, nargs, arglist)\n \n   if (!CPP_TRADITIONAL (pfile) && expected_delimiter == 0)\n     {\n-      /* If ANSI, put in a \"@ \" marker to prevent token pasting.\n+      /* If ANSI, put in a \"\\r \" marker to prevent token pasting.\n          But not if \"inside a string\" (which in ANSI mode\n          happens only for -D option).  */\n-      *exp_p++ = '@';\n+      *exp_p++ = '\\r';\n       *exp_p++ = ' ';\n     }\n \n@@ -965,7 +954,7 @@ special_symbol (hp, pfile)\n       if (!buf)\n \treturn;\n       if (*buf == '\\0')\n-\tbuf = \"@ \";\n+\tbuf = \"\\r \";\n \n       len = strlen (buf);\n       CPP_RESERVE (pfile, len + 1);\n@@ -1224,9 +1213,9 @@ macroexpand (pfile, hp)\n \t\t\t  if (is_space[c])\n \t\t\t    {\n \t\t\t      if (CPP_WRITTEN (pfile) > (unsigned) arg->stringified\n-\t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '@')\n+\t\t\t\t  && (CPP_PWRITTEN (pfile))[-1] == '\\r')\n \t\t\t\t{\n-\t\t\t\t  /* \"@ \" escape markers are removed */\n+\t\t\t\t  /* \"\\r \" escape markers are removed */\n \t\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n \t\t\t\t  continue;\n \t\t\t\t}\n@@ -1360,27 +1349,11 @@ macroexpand (pfile, hp)\n \t\t    {\n \t\t      if (is_space[l1[-1]])\n \t\t\tl1--;\n-\t\t      else if (l1[-1] == '@')\n-\t\t\t{\n-\t\t\t  U_CHAR *p2 = l1 - 1;\n-\t\t\t  /* If whitespace is preceded by an odd number\n-\t\t\t     of `@' signs, the last `@' was a whitespace\n-\t\t\t     marker; drop it too. */\n-\t\t\t  while (p2 != p1 && p2[0] == '@')\n-\t\t\t    p2--;\n-\t\t\t  if ((l1 - p2) & 1)\n-\t\t\t    l1--;\n-\t\t\t  break;\n-\t\t\t}\n+\t\t      else if (l1[-1] == '\\r')\n+\t\t\tl1--;\n \t\t      else if (l1[-1] == '-')\n \t\t\t{\n-\t\t\t  U_CHAR *p2 = l1 - 1;\n-\t\t\t  /* If a `-' is preceded by an odd number of\n-\t\t\t     `@' signs then it and the last `@' are\n-\t\t\t     a no-reexpansion marker.  */\n-\t\t\t  while (p2 != p1 && p2[0] == '@')\n-\t\t\t    p2--;\n-\t\t\t  if ((l1 - p2) & 1)\n+\t\t\t  if (l1 != p1 + 1 && l1[-2] == '\\r')\n \t\t\t    l1 -= 2;\n \t\t\t  else\n \t\t\t    break;\n@@ -1392,7 +1365,7 @@ macroexpand (pfile, hp)\n \n \t      /* Delete any no-reexpansion marker that precedes\n \t         an identifier at the beginning of the argument. */\n-\t      if (p1[0] == '@' && p1[1] == '-')\n+\t      if (p1[0] == '\\r' && p1[1] == '-')\n \t\tp1 += 2;\n \n \t      bcopy (p1, xbuf + totlen, l1 - p1);\n@@ -1405,7 +1378,7 @@ macroexpand (pfile, hp)\n \t\t  && !CPP_TRADITIONAL (pfile)\n \t\t  && unsafe_chars (xbuf[totlen - 1], expanded[0]))\n \t\t{\n-\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = '\\r';\n \t\t  xbuf[totlen++] = ' ';\n \t\t}\n \n@@ -1416,7 +1389,7 @@ macroexpand (pfile, hp)\n \t\t  && !CPP_TRADITIONAL (pfile)\n \t\t  && unsafe_chars (xbuf[totlen - 1], exp[offset]))\n \t\t{\n-\t\t  xbuf[totlen++] = '@';\n+\t\t  xbuf[totlen++] = '\\r';\n \t\t  xbuf[totlen++] = ' ';\n \t\t}\n \n@@ -1533,7 +1506,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n   mbuf->cleanup = macro_cleanup;\n   mbuf->data = hp;\n \n-  /* The first chars of the expansion should be a \"@ \" added by\n+  /* The first chars of the expansion should be a \"\\r \" added by\n      collect_expansion.  This is to prevent accidental token-pasting\n      between the text preceding the macro invocation, and the macro\n      expansion text.\n@@ -1551,7 +1524,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n      Also, we don't need the extra space if the first char is '(',\n      or some other (less common) characters.  */\n \n-  if (xbuf[0] == '@' && xbuf[1] == ' '\n+  if (xbuf[0] == '\\r' && xbuf[1] == ' '\n       && (is_idchar[xbuf[2]] || xbuf[2] == '(' || xbuf[2] == '\\''\n \t  || xbuf[2] == '\\\"'))\n     mbuf->cur += 2;\n@@ -1560,7 +1533,7 @@ push_macro_expansion (pfile, xbuf, xbuf_len, hp)\n      if this is safe.  We can do a better job here since we can know\n      what the next char will be.  */\n   if (xbuf_len >= 3\n-      && mbuf->rlimit[-2] == '@'\n+      && mbuf->rlimit[-2] == '\\r'\n       && mbuf->rlimit[-1] == ' ')\n     {\n       int c1 = mbuf->rlimit[-3];"}, {"sha": "3ed75db1d66a5575b3a0b7feec18e25d972cc875", "filename": "gcc/cpplib.c", "status": "modified", "additions": 85, "deletions": 56, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=ed45de98388acec5ed80b3a664c05b8b43f842ab", "patch": "@@ -260,6 +260,7 @@ skip_comment (pfile, m)\n \t      return EOF;\n \t    }\n \t  else if (c == '\\n' || c == '\\r')\n+\t    /* \\r cannot be a macro escape marker here. */\n \t    CPP_BUMP_LINE (pfile);\n \t  else if (c == '/' && prev_c == '*')\n \t    return ' ';\n@@ -288,6 +289,7 @@ skip_comment (pfile, m)\n \t\t  return ' ';\n \t\t}\n \t      else if (c == '\\r')\n+\t\t/* \\r cannot be a macro escape marker here. */\n \t\tCPP_BUMP_LINE (pfile);\n \t}\n     }\n@@ -323,6 +325,7 @@ copy_comment (pfile, m)\n \t    }\n \t  else if (c == '\\r')\n \t    {\n+\t      /* \\r cannot be a macro escape marker here. */\n \t      CPP_BUMP_LINE (pfile);\n \t      continue;\n \t    }\n@@ -362,6 +365,7 @@ copy_comment (pfile, m)\n \t      return ' ';\n \t    }\n \t  else if (c == '\\r')\n+\t    /* \\r cannot be a macro escape marker here. */\n \t    CPP_BUMP_LINE (pfile);\n \n \t  CPP_PUTC (pfile, c);\n@@ -392,30 +396,30 @@ cpp_skip_hspace (pfile)\n \t}\n       else if (c == '\\r')\n \t{\n-\t  CPP_BUFFER (pfile)->lineno++;\n+\t  /* \\r is a backslash-newline marker if !has_escapes, and\n+\t     a deletable-whitespace or no-reexpansion marker otherwise. */\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    {\n+\t      if (PEEKC() == ' ')\n+\t\tFORWARD(1);\n+\t      else\n+\t\tbreak;\n+\t    }\n+\t  else\n+\t    CPP_BUFFER (pfile)->lineno++;\n \t}\n       else if (c == '/' || c == '-')\n \t{\n \t  c = skip_comment (pfile, c);\n \t  if (c == EOF)\n \t    return;\n \t  else if (c != ' ')\n-\t    {\n-\t      FORWARD(-1);\n-\t      return;\n-\t    }\n-\t}\n-      else if (c == '@' && CPP_BUFFER (pfile)->has_escapes\n-\t       && PEEKC() == ' ')\n-\t{\n-\t  FORWARD(1);\n+\t    break;\n \t}\n       else\n-\t{\n-\t  FORWARD(-1);\n-\t  return;\n-\t}\n+\tbreak;\n     }\n+  FORWARD(-1);\n }\n \n /* Read the rest of the current line.\n@@ -437,8 +441,13 @@ copy_rest_of_line (pfile)\n \t  return;\n \n \tcase '\\r':\n-\t  CPP_BUFFER (pfile)->lineno++;\n-\t  continue;\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    break;\n+\t  else\n+\t    {\n+\t      CPP_BUFFER (pfile)->lineno++;\n+\t      continue;\n+\t    }\n \tcase '\\'':\n \tcase '\\\"':\n \t  parse_string (pfile, c);\n@@ -2233,9 +2242,23 @@ cpp_get_token (pfile)\n \t\t    }\n \t\t  else if (c == '\\r')\n \t\t    {\n-\t\t      /* Backslash newline is replaced by nothing. */\n-\t\t      CPP_ADJUST_WRITTEN (pfile, -1);\n-\t\t      CPP_BUMP_LINE (pfile);\n+\t\t      if (!CPP_BUFFER (pfile)->has_escapes)\n+\t\t\t{\n+\t\t\t  /* Backslash newline is replaced by nothing. */\n+\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t\t  CPP_BUMP_LINE (pfile);\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  /* We might conceivably get \\r- or \\r<space> in\n+\t\t\t     here.  Just delete 'em. */\n+\t\t\t  int d = GETC();\n+\t\t\t  if (d != '-' && d != ' ')\n+\t\t\t    cpp_fatal (pfile,\n+\t\t\t\t  \"internal error: unrecognized escape \\\\r%c\",\n+\t\t\t\t       d);\n+\t\t\t  CPP_ADJUST_WRITTEN (pfile, -1);\n+\t\t\t}\t\t\t  \n \t\t    }\n \t\t}\n \t      return CPP_STRING;\n@@ -2258,33 +2281,6 @@ cpp_get_token (pfile)\n \t  pfile->only_seen_white = 0;\n \t  return CPP_OTHER;\n \n-\tcase '@':\n-\t  if (CPP_BUFFER (pfile)->has_escapes)\n-\t    {\n-\t      c = GETC ();\n-\t      if (c == '-')\n-\t\t{\n-\t\t  if (pfile->output_escapes)\n-\t\t    CPP_PUTS (pfile, \"@-\", 2);\n-\t\t  parse_name (pfile, GETC ());\n-\t\t  return CPP_NAME;\n-\t\t}\n-\t      else if (c == ' ')\n-\t\t{\n-\t\t  CPP_RESERVE (pfile, 2);\n-\t\t  if (pfile->output_escapes)\n-\t\t    CPP_PUTC_Q (pfile, '@');\n-\t\t  CPP_PUTC_Q (pfile, c);\n-\t\t  return CPP_HSPACE;\n-\t\t}\n-\t    }\n-\t  if (pfile->output_escapes)\n-\t    {\n-\t      CPP_PUTS (pfile, \"@@\", 2);\n-\t      return CPP_OTHER;\n-\t    }\n-\t  goto randomchar;\n-\n \tcase '.':\n \t  c2 = PEEKC ();\n \t  if (ISDIGIT(c2))\n@@ -2410,13 +2406,13 @@ cpp_get_token (pfile)\n \t    if (hp->type == T_DISABLED)\n \t      {\n \t\tif (pfile->output_escapes)\n-\t\t  { /* Return \"@-IDENT\", followed by '\\0'.  */\n+\t\t  { /* Return \"\\r-IDENT\", followed by '\\0'.  */\n \t\t    int i;\n \t\t    CPP_RESERVE (pfile, 3);\n \t\t    ident = pfile->token_buffer + before_name_written;\n \t\t    CPP_ADJUST_WRITTEN (pfile, 2);\n \t\t    for (i = ident_len; i >= 0; i--) ident[i+2] = ident[i];\n-\t\t    ident[0] = '@';\n+\t\t    ident[0] = '\\r';\n \t\t    ident[1] = '-';\n \t\t  }\n \t\treturn CPP_NAME;\n@@ -2490,13 +2486,38 @@ cpp_get_token (pfile)\n \t    }\n \t  return CPP_HSPACE;\n \n-        case '\\\\':\n-\t  goto randomchar;\n-\n \tcase '\\r':\n-\t  /* Backslash newline is ignored. */\n-\t  CPP_BUMP_LINE (pfile);\n-\t  goto get_next;\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    {\n+\t      c = GETC ();\n+\t      if (c == '-')\n+\t\t{\n+\t\t  if (pfile->output_escapes)\n+\t\t    CPP_PUTS (pfile, \"\\r-\", 2);\n+\t\t  parse_name (pfile, GETC ());\n+\t\t  return CPP_NAME;\n+\t\t}\n+\t      else if (c == ' ')\n+\t\t{\n+\t\t  CPP_RESERVE (pfile, 2);\n+\t\t  if (pfile->output_escapes)\n+\t\t    CPP_PUTC_Q (pfile, '\\r');\n+\t\t  CPP_PUTC_Q (pfile, c);\n+\t\t  return CPP_HSPACE;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  cpp_fatal (pfile,\n+\t\t\t     \"internal error: unrecognized escape \\\\r%c\", c);\n+\t\t  goto get_next;\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Backslash newline is ignored. */\n+\t      CPP_BUMP_LINE (pfile);\n+\t      goto get_next;\n+\t    }\n \n \tcase '\\n':\n \t  CPP_PUTC (pfile, c);\n@@ -2639,9 +2660,16 @@ parse_string (pfile, c)\n \t  break;\n \n \tcase '\\r':\n-\t  /* Backslash newline is replaced by nothing at all.  */\n \t  CPP_ADJUST_WRITTEN (pfile, -1);\n-\t  CPP_BUMP_LINE (pfile);\n+\t  if (CPP_BUFFER (pfile)->has_escapes)\n+\t    {\n+\t      cpp_fatal (pfile,\n+\t\t\t \"internal error: \\\\r escape inside string constant\");\n+\t      FORWARD(1);\n+\t    }\n+\t  else\n+\t    /* Backslash newline is replaced by nothing at all.  */\n+\t    CPP_BUMP_LINE (pfile);\n \t  break;\n \n \tcase '\\\\':\n@@ -2711,6 +2739,7 @@ parse_assertion (pfile)\n \t  return 0;\n \t}\n       else if (c == '\\r')\n+\t/* \\r cannot be a macro escape here. */\n \tCPP_BUMP_LINE (pfile);\n       else\n \t{"}, {"sha": "bffd493232ff4a6664d2627ce433eac22e01e4a4", "filename": "gcc/cpplib.h", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ed45de98388acec5ed80b3a664c05b8b43f842ab/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=ed45de98388acec5ed80b3a664c05b8b43f842ab", "patch": "@@ -124,12 +124,17 @@ struct cpp_buffer\n   char seen_eof;\n \n   /* True if buffer contains escape sequences.\n-     Currently there are three kinds:\n-     \"@-\" means following identifier should not be macro-expanded.\n-     \"@ \" means a token-separator.  This turns into \" \" in final output\n+     Currently there are two kinds:\n+     \"\\r-\" means following identifier should not be macro-expanded.\n+     \"\\r \" means a token-separator.  This turns into \" \" in final output\n           if not stringizing and needed to separate tokens; otherwise nothing.\n-     \"@@\" means a normal '@'.\n-     (An '@' inside a string stands for itself and is never an escape.) */\n+     Any other two-character sequence beginning with \\r is an error.\n+\n+     If this is NOT set, then \\r is a one-character escape meaning backslash\n+     newline.  This is guaranteed not to occur in the middle of a token.\n+     The two interpretations of \\r do not conflict, because the two-character\n+     escapes are used only in macro buffers, and backslash-newline is removed\n+     from macro expansion text in collect_expansion and/or macarg.  */\n   char has_escapes;\n };\n "}]}