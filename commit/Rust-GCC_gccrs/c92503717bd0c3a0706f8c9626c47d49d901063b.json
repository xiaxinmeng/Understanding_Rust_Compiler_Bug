{"sha": "c92503717bd0c3a0706f8c9626c47d49d901063b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzkyNTAzNzE3YmQwYzNhMDcwNmY4Yzk2MjZjNDdkNDlkOTAxMDYzYg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2019-09-30T16:20:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2019-09-30T16:20:30Z"}, "message": "Remove global call sets: DF (EH edges)\n\nThe DF dense_invalidated_by_call and sparse_invalidated_by_call\nsets are actually only used on EH edges, and so are more the set\nof registers that are invalidated by a taken EH edge.  Under the\nnew order, that means that they describe eh_edge_abi.\n\n2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* df-problems.c: Include regs.h and function-abi.h.\n\t(df_rd_problem_data): Rename sparse_invalidated_by_call to\n\tsparse_invalidated_by_eh and dense_invalidated_by_call to\n\tdense_invalidated_by_eh.\n\t(df_print_bb_index): Update accordingly.\n\t(df_rd_alloc, df_rd_start_dump, df_rd_confluence_n): Likewise.\n\t(df_lr_confluence_n): Use eh_edge_abi to get the set of registers\n\tthat are clobbered by an EH edge.  Clobber partially-clobbered\n\tregisters as well as fully-clobbered ones.\n\t(df_md_confluence_n): Likewise.\n\t(df_rd_local_compute): Likewise.  Update for changes to\n\tdf_rd_problem_data.\n\t* df-scan.c (df_scan_start_dump): Use eh_edge_abi to get the set\n\tof registers that are clobbered by an EH edge.  Includde partially-\n\tclobbered registers as well as fully-clobbered ones.\n\nFrom-SVN: r276319", "tree": {"sha": "9c3753a137684133b3af3c2d8cf8e898e962e725", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c3753a137684133b3af3c2d8cf8e898e962e725"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c92503717bd0c3a0706f8c9626c47d49d901063b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c92503717bd0c3a0706f8c9626c47d49d901063b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c92503717bd0c3a0706f8c9626c47d49d901063b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c92503717bd0c3a0706f8c9626c47d49d901063b/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3bd2918594dae34ae84f802747471445a976af09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3bd2918594dae34ae84f802747471445a976af09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3bd2918594dae34ae84f802747471445a976af09"}], "stats": {"total": 75, "additions": 52, "deletions": 23}, "files": [{"sha": "13caa919728916adeb835853e248db6ab6e8a6c6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c92503717bd0c3a0706f8c9626c47d49d901063b", "patch": "@@ -1,3 +1,21 @@\n+2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* df-problems.c: Include regs.h and function-abi.h.\n+\t(df_rd_problem_data): Rename sparse_invalidated_by_call to\n+\tsparse_invalidated_by_eh and dense_invalidated_by_call to\n+\tdense_invalidated_by_eh.\n+\t(df_print_bb_index): Update accordingly.\n+\t(df_rd_alloc, df_rd_start_dump, df_rd_confluence_n): Likewise.\n+\t(df_lr_confluence_n): Use eh_edge_abi to get the set of registers\n+\tthat are clobbered by an EH edge.  Clobber partially-clobbered\n+\tregisters as well as fully-clobbered ones.\n+\t(df_md_confluence_n): Likewise.\n+\t(df_rd_local_compute): Likewise.  Update for changes to\n+\tdf_rd_problem_data.\n+\t* df-scan.c (df_scan_start_dump): Use eh_edge_abi to get the set\n+\tof registers that are clobbered by an EH edge.  Includde partially-\n+\tclobbered registers as well as fully-clobbered ones.\n+\n 2019-09-30  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* cselib.c (cselib_process_insn): If we know what mode a"}, {"sha": "f1fd0afb1fe76291bd7f18606e419c8705778d25", "filename": "gcc/df-problems.c", "status": "modified", "additions": 31, "deletions": 21, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2Fdf-problems.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2Fdf-problems.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-problems.c?ref=c92503717bd0c3a0706f8c9626c47d49d901063b", "patch": "@@ -36,6 +36,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"valtrack.h\"\n #include \"dumpfile.h\"\n #include \"rtl-iter.h\"\n+#include \"regs.h\"\n+#include \"function-abi.h\"\n \n /* Note that turning REG_DEAD_DEBUGGING on will cause\n    gcc.c-torture/unsorted/dump-noaddr.c to fail because it prints\n@@ -139,18 +141,17 @@ df_print_bb_index (basic_block bb, FILE *file)\n    these along with the bitmap_clear_range call to remove ranges of\n    bits without actually generating a knockout vector.\n \n-   The kill and sparse_kill and the dense_invalidated_by_call and\n-   sparse_invalidated_by_call both play this game.  */\n+   The kill and sparse_kill and the dense_invalidated_by_eh and\n+   sparse_invalidated_by_eh both play this game.  */\n \n /* Private data used to compute the solution for this problem.  These\n    data structures are not accessible outside of this module.  */\n class df_rd_problem_data\n {\n public:\n-  /* The set of defs to regs invalidated by call.  */\n-  bitmap_head sparse_invalidated_by_call;\n-  /* The set of defs to regs invalidate by call for rd.  */\n-  bitmap_head dense_invalidated_by_call;\n+  /* The set of defs to regs invalidated by EH edges.  */\n+  bitmap_head sparse_invalidated_by_eh;\n+  bitmap_head dense_invalidated_by_eh;\n   /* An obstack for the bitmaps we need for this problem.  */\n   bitmap_obstack rd_bitmaps;\n };\n@@ -187,18 +188,18 @@ df_rd_alloc (bitmap all_blocks)\n   if (df_rd->problem_data)\n     {\n       problem_data = (class df_rd_problem_data *) df_rd->problem_data;\n-      bitmap_clear (&problem_data->sparse_invalidated_by_call);\n-      bitmap_clear (&problem_data->dense_invalidated_by_call);\n+      bitmap_clear (&problem_data->sparse_invalidated_by_eh);\n+      bitmap_clear (&problem_data->dense_invalidated_by_eh);\n     }\n   else\n     {\n       problem_data = XNEW (class df_rd_problem_data);\n       df_rd->problem_data = problem_data;\n \n       bitmap_obstack_initialize (&problem_data->rd_bitmaps);\n-      bitmap_initialize (&problem_data->sparse_invalidated_by_call,\n+      bitmap_initialize (&problem_data->sparse_invalidated_by_eh,\n \t\t\t &problem_data->rd_bitmaps);\n-      bitmap_initialize (&problem_data->dense_invalidated_by_call,\n+      bitmap_initialize (&problem_data->dense_invalidated_by_eh,\n \t\t\t &problem_data->rd_bitmaps);\n     }\n \n@@ -391,8 +392,8 @@ df_rd_local_compute (bitmap all_blocks)\n   bitmap_iterator bi;\n   class df_rd_problem_data *problem_data\n     = (class df_rd_problem_data *) df_rd->problem_data;\n-  bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n-  bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n+  bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_eh;\n+  bitmap dense_invalidated = &problem_data->dense_invalidated_by_eh;\n \n   bitmap_initialize (&seen_in_block, &df_bitmap_obstack);\n   bitmap_initialize (&seen_in_insn, &df_bitmap_obstack);\n@@ -404,10 +405,13 @@ df_rd_local_compute (bitmap all_blocks)\n       df_rd_bb_local_compute (bb_index);\n     }\n \n-  /* Set up the knockout bit vectors to be applied across EH_EDGES.  */\n+  /* Set up the knockout bit vectors to be applied across EH_EDGES.\n+     Conservatively treat partially-clobbered registers as surviving\n+     across the EH edge, i.e. assume that definitions before the edge\n+     is taken *might* reach uses after it has been taken.  */\n   if (!(df->changeable_flags & DF_NO_HARD_REGS))\n     for (unsigned int regno = 0; regno < FIRST_PSEUDO_REGISTER; ++regno)\n-      if (TEST_HARD_REG_BIT (regs_invalidated_by_call, regno))\n+      if (eh_edge_abi.clobbers_full_reg_p (regno))\n \t{\n \t  if (DF_DEFS_COUNT (regno) > DF_SPARSE_THRESHOLD)\n \t    bitmap_set_bit (sparse_invalidated, regno);\n@@ -455,8 +459,8 @@ df_rd_confluence_n (edge e)\n     {\n       class df_rd_problem_data *problem_data\n \t= (class df_rd_problem_data *) df_rd->problem_data;\n-      bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_call;\n-      bitmap dense_invalidated = &problem_data->dense_invalidated_by_call;\n+      bitmap sparse_invalidated = &problem_data->sparse_invalidated_by_eh;\n+      bitmap dense_invalidated = &problem_data->dense_invalidated_by_eh;\n       bitmap_iterator bi;\n       unsigned int regno;\n \n@@ -579,9 +583,9 @@ df_rd_start_dump (FILE *file)\n   fprintf (file, \";; Reaching defs:\\n\");\n \n   fprintf (file, \";;  sparse invalidated \\t\");\n-  dump_bitmap (file, &problem_data->sparse_invalidated_by_call);\n+  dump_bitmap (file, &problem_data->sparse_invalidated_by_eh);\n   fprintf (file, \";;  dense invalidated \\t\");\n-  dump_bitmap (file, &problem_data->dense_invalidated_by_call);\n+  dump_bitmap (file, &problem_data->dense_invalidated_by_eh);\n \n   fprintf (file, \";;  reg->defs[] map:\\t\");\n   for (regno = 0; regno < m; regno++)\n@@ -976,12 +980,15 @@ df_lr_confluence_n (edge e)\n   bitmap op2 = &df_lr_get_bb_info (e->dest->index)->in;\n   bool changed = false;\n \n-  /* Call-clobbered registers die across exception and call edges.  */\n+  /* Call-clobbered registers die across exception and call edges.\n+     Conservatively treat partially-clobbered registers as surviving\n+     across the edges; they might or might not, depending on what\n+     mode they have.  */\n   /* ??? Abnormal call edges ignored for the moment, as this gets\n      confused by sibling call edges, which crashes reg-stack.  */\n   if (e->flags & EDGE_EH)\n     {\n-      bitmap_view<HARD_REG_SET> eh_kills (regs_invalidated_by_call);\n+      bitmap_view<HARD_REG_SET> eh_kills (eh_edge_abi.full_reg_clobbers ());\n       changed = bitmap_ior_and_compl_into (op1, op2, eh_kills);\n     }\n   else\n@@ -4636,7 +4643,10 @@ df_md_confluence_n (edge e)\n \n   if (e->flags & EDGE_EH)\n     {\n-      bitmap_view<HARD_REG_SET> eh_kills (regs_invalidated_by_call);\n+      /* Conservatively treat partially-clobbered registers as surviving\n+\t across the edge; they might or might not, depending on what mode\n+\t they have.  */\n+      bitmap_view<HARD_REG_SET> eh_kills (eh_edge_abi.full_reg_clobbers ());\n       return bitmap_ior_and_compl_into (op1, op2, eh_kills);\n     }\n   else"}, {"sha": "7dda4cacf7adfec358bbea30a9194cc4825faac0", "filename": "gcc/df-scan.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2Fdf-scan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c92503717bd0c3a0706f8c9626c47d49d901063b/gcc%2Fdf-scan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf-scan.c?ref=c92503717bd0c3a0706f8c9626c47d49d901063b", "patch": "@@ -312,8 +312,9 @@ df_scan_start_dump (FILE *file ATTRIBUTE_UNUSED)\n   basic_block bb;\n   rtx_insn *insn;\n \n-  fprintf (file, \";;  invalidated by call \\t\");\n-  df_print_regset (file, bitmap_view<HARD_REG_SET> (regs_invalidated_by_call));\n+  fprintf (file, \";;  fully invalidated by EH \\t\");\n+  df_print_regset\n+    (file, bitmap_view<HARD_REG_SET> (eh_edge_abi.full_reg_clobbers ()));\n   fprintf (file, \";;  hardware regs used \\t\");\n   df_print_regset (file, &df->hardware_regs_used);\n   fprintf (file, \";;  regular block artificial uses \\t\");"}]}