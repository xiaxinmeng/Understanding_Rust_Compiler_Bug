{"sha": "17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTdmM2MyYjhhYzQ3N2IwN2NhMGFhZmJjN2Q3NGJhMzA1ZGMxZWUzMw==", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-04-13T01:13:40Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2021-04-13T01:13:40Z"}, "message": "gimple UIDs, LTO and -fanalyzer [PR98599]\n\ngimple.h has this comment for gimple's uid field:\n\n  /* UID of this statement.  This is used by passes that want to\n     assign IDs to statements.  It must be assigned and used by each\n     pass.  By default it should be assumed to contain garbage.  */\n  unsigned uid;\n\nand gimple_set_uid has:\n\n   Please note that this UID property is supposed to be undefined at\n   pass boundaries.  This means that a given pass should not assume it\n   contains any useful value when the pass starts and thus can set it\n   to any value it sees fit.\n\nwhich suggests that any pass can use the uid field as an arbitrary\nscratch space.\n\nPR analyzer/98599 reports a case where this error occurs in LTO mode:\n  fatal error: Cgraph edge statement index out of range\non certain inputs with -fanalyzer.\n\nThe error occurs in the LTRANS phase after -fanalyzer runs in the\nWPA phase.  The analyzer pass writes to the uid fields of all stmts.\n\nThe error occurs when LTRANS is streaming callgraph edges back in.\nThe LTO format uses stmt uids to associate call stmts with callgraph\nedges between WPA and LTRANS.\nFor example, in lto-cgraph.c, lto_output_edge writes out the\ngimple_uid, and input_edge reads it back in.\n\nlto_prepare_function_for_streaming has code to renumber the stmt UIDs\nwhen the code is streamed back out, but for some reason this isn't\ncalled for clones:\n    307\t  /* Do body modifications needed for streaming before we fork out\n    308\t     worker processes.  */\n    309\t  FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n    310\t    if (!node->clone_of && gimple_has_body_p (node->decl))\n    311\t      lto_prepare_function_for_streaming (node);\n\nHence the combination of -fanalyzer and -flto will fail in LTRANS's\nstream-in if any function clones are encountered.\n\nIt's not fully clear to me why this isn't done for clones, and what the\ncorrect fix should be to allow arbitrary changes to uids within WPA\npasses.\n\nIn the meantime, this patch works around the issue by updating the\nanalyzer to save and restore the UIDs, fixing the error.\n\ngcc/analyzer/ChangeLog:\n\tPR analyzer/98599\n\t* supergraph.cc (saved_uids::make_uid_unique): New.\n\t(saved_uids::restore_uids): New.\n\t(supergraph::supergraph): Replace assignments to stmt->uid with\n\tcalls to m_stmt_uids.make_uid_unique.\n\t(supergraph::~supergraph): New.\n\t* supergraph.h (class saved_uids): New.\n\t(supergraph::~supergraph): New decl.\n\t(supergraph::m_stmt_uids): New field.\n\ngcc/testsuite/ChangeLog:\n\tPR analyzer/98599\n\t* gcc.dg/analyzer/pr98599-a.c: New test.\n\t* gcc.dg/analyzer/pr98599-b.c: New test.", "tree": {"sha": "9fadab37a810ffc6c9fa8af0f6be3c04a6069dd3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9fadab37a810ffc6c9fa8af0f6be3c04a6069dd3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "287ad814d7703a26d5623a9deafd5932c248d49c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/287ad814d7703a26d5623a9deafd5932c248d49c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/287ad814d7703a26d5623a9deafd5932c248d49c"}], "stats": {"total": 81, "additions": 77, "deletions": 4}, "files": [{"sha": "8611d0f8689868847d9d56ec9cae55b82084c307", "filename": "gcc/analyzer/supergraph.cc", "status": "modified", "additions": 53, "deletions": 4, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Fanalyzer%2Fsupergraph.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Fanalyzer%2Fsupergraph.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.cc?ref=17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "patch": "@@ -87,6 +87,50 @@ supergraph_call_edge (function *fun, gimple *stmt)\n   return edge;\n }\n \n+/* class saved_uids.\n+\n+   In order to ensure consistent results without relying on the ordering\n+   of pointer values we assign a uid to each gimple stmt, globally unique\n+   across all functions.\n+\n+   Normally, the stmt uids are a scratch space that each pass can freely\n+   assign its own values to.  However, in the case of LTO, the uids are\n+   used to associate call stmts with callgraph edges between the WPA phase\n+   (where the analyzer runs in LTO mode) and the LTRANS phase; if the\n+   analyzer changes them in the WPA phase, it leads to errors when\n+   streaming the code back in at LTRANS.\n+   lto_prepare_function_for_streaming has code to renumber the stmt UIDs\n+   when the code is streamed back out, but for some reason this isn't\n+   called for clones.\n+\n+   Hence, as a workaround, this class has responsibility for tracking\n+   the original uids and restoring them once the pass is complete\n+   (in the supergraph dtor).  */\n+\n+/* Give STMT a globally unique uid, storing its original uid so it can\n+   later be restored.  */\n+\n+void\n+saved_uids::make_uid_unique (gimple *stmt)\n+{\n+  unsigned next_uid = m_old_stmt_uids.length ();\n+  unsigned old_stmt_uid = stmt->uid;\n+  stmt->uid = next_uid;\n+  m_old_stmt_uids.safe_push\n+    (std::pair<gimple *, unsigned> (stmt, old_stmt_uid));\n+}\n+\n+/* Restore the saved uids of all stmts.  */\n+\n+void\n+saved_uids::restore_uids () const\n+{\n+  unsigned i;\n+  std::pair<gimple *, unsigned> *pair;\n+  FOR_EACH_VEC_ELT (m_old_stmt_uids, i, pair)\n+    pair->first->uid = pair->second;\n+}\n+\n /* supergraph's ctor.  Walk the callgraph, building supernodes for each\n    CFG basic block, splitting the basic blocks at callsites.  Join\n    together the supernodes with interprocedural and intraprocedural\n@@ -101,8 +145,6 @@ supergraph::supergraph (logger *logger)\n \n   /* First pass: make supernodes (and assign UIDs to the gimple stmts).  */\n   {\n-    unsigned next_uid = 0;\n-\n     /* Sort the cgraph_nodes?  */\n     cgraph_node *node;\n     FOR_EACH_FUNCTION_WITH_GIMPLE_BODY (node)\n@@ -127,7 +169,7 @@ supergraph::supergraph (logger *logger)\n \t    {\n \t      gimple *stmt = gsi_stmt (gpi);\n \t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n-\t      stmt->uid = next_uid++;\n+\t      m_stmt_uids.make_uid_unique (stmt);\n \t    }\n \n \t  /* Append statements from BB to the current supernode, splitting\n@@ -139,7 +181,7 @@ supergraph::supergraph (logger *logger)\n \t      gimple *stmt = gsi_stmt (gsi);\n \t      node_for_stmts->m_stmts.safe_push (stmt);\n \t      m_stmt_to_node_t.put (stmt, node_for_stmts);\n-\t      stmt->uid = next_uid++;\n+\t      m_stmt_uids.make_uid_unique (stmt);\n \t      if (cgraph_edge *edge = supergraph_call_edge (fun, stmt))\n \t\t{\n \t\t  m_cgraph_edge_to_caller_prev_node.put(edge, node_for_stmts);\n@@ -257,6 +299,13 @@ supergraph::supergraph (logger *logger)\n   }\n }\n \n+/* supergraph's dtor.  Reset stmt uids.  */\n+\n+supergraph::~supergraph ()\n+{\n+  m_stmt_uids.restore_uids ();\n+}\n+\n /* Dump this graph in .dot format to PP, using DUMP_ARGS.\n    Cluster the supernodes by function, then by BB from original CFG.  */\n "}, {"sha": "f4090fd5e0eddfd38ac43e33d39afcff2f50105e", "filename": "gcc/analyzer/supergraph.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Fanalyzer%2Fsupergraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Fanalyzer%2Fsupergraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fsupergraph.h?ref=17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "patch": "@@ -79,6 +79,18 @@ struct supergraph_traits\n   typedef supercluster cluster_t;\n };\n \n+/* A class to manage the setting and restoring of statement uids.  */\n+\n+class saved_uids\n+{\n+public:\n+  void make_uid_unique (gimple *stmt);\n+  void restore_uids () const;\n+\n+private:\n+  auto_vec<std::pair<gimple *, unsigned> > m_old_stmt_uids;\n+};\n+\n /* A \"supergraph\" is a directed graph formed by joining together all CFGs,\n    linking them via interprocedural call and return edges.\n \n@@ -90,6 +102,7 @@ class supergraph : public digraph<supergraph_traits>\n {\n public:\n   supergraph (logger *logger);\n+  ~supergraph ();\n \n   supernode *get_node_for_function_entry (function *fun) const\n   {\n@@ -205,6 +218,8 @@ class supergraph : public digraph<supergraph_traits>\n \n   typedef hash_map<const function *, unsigned> function_to_num_snodes_t;\n   function_to_num_snodes_t m_function_to_num_snodes;\n+\n+  saved_uids m_stmt_uids;\n };\n \n /* A node within a supergraph.  */"}, {"sha": "2bbf37b0e6e29664f90f1279852ac0ed5d12ec39", "filename": "gcc/testsuite/gcc.dg/analyzer/pr98599-a.c", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-a.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-a.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-a.c?ref=17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "patch": "@@ -0,0 +1,8 @@\n+/* { dg-do link } */\n+/* { dg-require-effective-target lto } */\n+/* { dg-additional-options \"-Os -flto\" } */\n+/* { dg-additional-sources pr98599-b.c } */\n+\n+int b(int x);\n+int a() { b(5); }\n+int main() { a(); }"}, {"sha": "cfdeb3bf1340c2235977dcafc04728f1da0b08db", "filename": "gcc/testsuite/gcc.dg/analyzer/pr98599-b.c", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-b.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-b.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fanalyzer%2Fpr98599-b.c?ref=17f3c2b8ac477b07ca0aafbc7d74ba305dc1ee33", "patch": "@@ -0,0 +1 @@\n+int b(int x) { return x; }"}]}