{"sha": "944fa280bc92d197c443e369bb24405f007d46ab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTQ0ZmEyODBiYzkyZDE5N2M0NDNlMzY5YmIyNDQwNWYwMDdkNDZhYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-08-01T07:52:43Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2014-08-01T07:52:43Z"}, "message": "opts.c (common_handle_option): Handle -fsanitize=alignment.\n\n\t* opts.c (common_handle_option): Handle -fsanitize=alignment.\n\t* ubsan.h (enum ubsan_null_ckind): Add UBSAN_CTOR_CALL.\n\t(ubsan_expand_bounds_ifn, ubsan_expand_null_ifn): Change return\n\ttype to bool.\n\t* stor-layout.h (min_align_of_type): New prototype.\n\t* asan.c (pass_sanopt::execute): Don't perform gsi_next if\n\tubsan_expand* told us not to do it.  Remove the extra gsi_end_p\n\tcheck.\n\t* ubsan.c: Include builtins.h.\n\t(ubsan_expand_bounds_ifn): Change return type to bool,\n\talways return true.\n\t(ubsan_expand_null_ifn): Change return type to bool, change\n\targument to gimple_stmt_iterator *.  Handle both null and alignment\n\tsanitization, take type from ckind argument's type rather than\n\tfirst argument.\n\t(instrument_member_call): Removed.\n\t(instrument_mem_ref): Remove t argument, add mem and base arguments.\n\tHandle both null and alignment sanitization, don't say whole\n\tstruct access is member access.  Build 3 argument IFN_UBSAN_NULL\n\tcall instead of 2 argument.\n\t(instrument_null): Adjust instrument_mem_ref caller.  Don't\n\tinstrument calls here.\n\t(pass_ubsan::gate, pass_ubsan::execute): Handle SANITIZE_ALIGNMENT\n\tlike SANITIZE_NULL.\n\t* stor-layout.c (min_align_of_type): New function.\n\t* flag-types.h (enum sanitize_code): Add SANITIZE_ALIGNMENT.\n\tOr it into SANITIZE_UNDEFINED.\n\t* doc/invoke.texi (-fsanitize=alignment): Document.\ncp/\n\t* cp-gimplify.c (cp_genericize_r): For -fsanitize=null and/or\n\t-fsanitize=alignment call ubsan_maybe_instrument_reference\n\tfor casts to REFERENCE_TYPE and ubsan_maybe_instrument_member_call\n\tfor calls to member functions.\nc-family/\n\t* c-common.h (min_align_of_type): Removed prototype.\n\t* c-common.c (min_align_of_type): Removed.\n\t* c-ubsan.h (ubsan_maybe_instrument_reference,\n\tubsan_maybe_instrument_member_call): New prototypes.\n\t* c-ubsan.c: Include stor-layout.h and builtins.h.\n\t(ubsan_maybe_instrument_reference_or_call,\n\tubsan_maybe_instrument_reference, ubsan_maybe_instrument_call): New\n\tfunctions.\ntestsuite/\n\t* c-c++-common/ubsan/align-1.c: New test.\n\t* c-c++-common/ubsan/align-2.c: New test.\n\t* c-c++-common/ubsan/align-3.c: New test.\n\t* c-c++-common/ubsan/align-4.c: New test.\n\t* c-c++-common/ubsan/align-5.c: New test.\n\t* c-c++-common/ubsan/attrib-4.c: New test.\n\t* g++.dg/ubsan/align-1.C: New test.\n\t* g++.dg/ubsan/align-2.C: New test.\n\t* g++.dg/ubsan/align-3.C: New test.\n\t* g++.dg/ubsan/attrib-1.C: New test.\n\t* g++.dg/ubsan/null-1.C: New test.\n\t* g++.dg/ubsan/null-2.C: New test.\n\nFrom-SVN: r213406", "tree": {"sha": "893b88f145db7b629d24315901550a2b349d00ae", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/893b88f145db7b629d24315901550a2b349d00ae"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/944fa280bc92d197c443e369bb24405f007d46ab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944fa280bc92d197c443e369bb24405f007d46ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/944fa280bc92d197c443e369bb24405f007d46ab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/944fa280bc92d197c443e369bb24405f007d46ab/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bbe2542f728dbd46ffc9997537e62228173ffa24", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bbe2542f728dbd46ffc9997537e62228173ffa24", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bbe2542f728dbd46ffc9997537e62228173ffa24"}], "stats": {"total": 859, "additions": 785, "deletions": 74}, "files": [{"sha": "414b53b1f7a62d301fe97809e7ffeaa210e1319e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1,3 +1,34 @@\n+2014-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* opts.c (common_handle_option): Handle -fsanitize=alignment.\n+\t* ubsan.h (enum ubsan_null_ckind): Add UBSAN_CTOR_CALL.\n+\t(ubsan_expand_bounds_ifn, ubsan_expand_null_ifn): Change return\n+\ttype to bool.\n+\t* stor-layout.h (min_align_of_type): New prototype.\n+\t* asan.c (pass_sanopt::execute): Don't perform gsi_next if\n+\tubsan_expand* told us not to do it.  Remove the extra gsi_end_p\n+\tcheck.\n+\t* ubsan.c: Include builtins.h.\n+\t(ubsan_expand_bounds_ifn): Change return type to bool,\n+\talways return true.\n+\t(ubsan_expand_null_ifn): Change return type to bool, change\n+\targument to gimple_stmt_iterator *.  Handle both null and alignment\n+\tsanitization, take type from ckind argument's type rather than\n+\tfirst argument.\n+\t(instrument_member_call): Removed.\n+\t(instrument_mem_ref): Remove t argument, add mem and base arguments.\n+\tHandle both null and alignment sanitization, don't say whole\n+\tstruct access is member access.  Build 3 argument IFN_UBSAN_NULL\n+\tcall instead of 2 argument.\n+\t(instrument_null): Adjust instrument_mem_ref caller.  Don't\n+\tinstrument calls here.\n+\t(pass_ubsan::gate, pass_ubsan::execute): Handle SANITIZE_ALIGNMENT\n+\tlike SANITIZE_NULL.\n+\t* stor-layout.c (min_align_of_type): New function.\n+\t* flag-types.h (enum sanitize_code): Add SANITIZE_ALIGNMENT.\n+\tOr it into SANITIZE_UNDEFINED.\n+\t* doc/invoke.texi (-fsanitize=alignment): Document.\n+\n 2014-07-31  Andi Kleen  <ak@linux.intel.com>\n \n \t* tree-ssa-tail-merge.c (same_succ_hash): Convert to inchash."}, {"sha": "76f21bd7020fe596a28c6b19376f370ecefa6b7e", "filename": "gcc/asan.c", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -2750,21 +2750,25 @@ pass_sanopt::execute (function *fun)\n   FOR_EACH_BB_FN (bb, fun)\n     {\n       gimple_stmt_iterator gsi;\n-      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+      for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n \t{\n \t  gimple stmt = gsi_stmt (gsi);\n+\t  bool no_next = false;\n \n \t  if (!is_gimple_call (stmt))\n-\t    continue;\n+\t    {\n+\t      gsi_next (&gsi);\n+\t      continue;\n+\t    }\n \n \t  if (gimple_call_internal_p (stmt))\n \t    switch (gimple_call_internal_fn (stmt))\n \t      {\n \t      case IFN_UBSAN_NULL:\n-\t\tubsan_expand_null_ifn (gsi);\n+\t\tno_next = ubsan_expand_null_ifn (&gsi);\n \t\tbreak;\n \t      case IFN_UBSAN_BOUNDS:\n-\t\tubsan_expand_bounds_ifn (&gsi);\n+\t\tno_next = ubsan_expand_bounds_ifn (&gsi);\n \t\tbreak;\n \t      default:\n \t\tbreak;\n@@ -2777,9 +2781,8 @@ pass_sanopt::execute (function *fun)\n \t      fprintf (dump_file, \"\\n\");\n \t    }\n \n-\t  /* ubsan_expand_bounds_ifn might move us to the end of the BB.  */\n-\t  if (gsi_end_p (gsi))\n-\t    break;\n+\t  if (!no_next)\n+\t    gsi_next (&gsi);\n \t}\n     }\n   return 0;"}, {"sha": "55e4a66df4ad1ffb6ef9276115daabf041d35a61", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1,3 +1,14 @@\n+2014-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-common.h (min_align_of_type): Removed prototype.\n+\t* c-common.c (min_align_of_type): Removed.\n+\t* c-ubsan.h (ubsan_maybe_instrument_reference,\n+\tubsan_maybe_instrument_member_call): New prototypes.\n+\t* c-ubsan.c: Include stor-layout.h and builtins.h.\n+\t(ubsan_maybe_instrument_reference_or_call,\n+\tubsan_maybe_instrument_reference, ubsan_maybe_instrument_call): New\n+\tfunctions.\n+\n 2014-07-31  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/60517"}, {"sha": "b2a053ed6297a540dfc1679fc1cdb9f810193a82", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -4965,26 +4965,6 @@ c_common_get_alias_set (tree t)\n   return -1;\n }\n \f\n-/* Return the least alignment required for type TYPE.  */\n-\n-unsigned int\n-min_align_of_type (tree type)\n-{\n-  unsigned int align = TYPE_ALIGN (type);\n-  align = MIN (align, BIGGEST_ALIGNMENT);\n-#ifdef BIGGEST_FIELD_ALIGNMENT\n-  align = MIN (align, BIGGEST_FIELD_ALIGNMENT);\n-#endif\n-  unsigned int field_align = align;\n-#ifdef ADJUST_FIELD_ALIGN\n-  tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n-\t\t\t   type);\n-  field_align = ADJUST_FIELD_ALIGN (field, field_align);\n-#endif\n-  align = MIN (align, field_align);\n-  return align / BITS_PER_UNIT;\n-}\n-\n /* Compute the value of 'sizeof (TYPE)' or '__alignof__ (TYPE)', where\n    the IS_SIZEOF parameter indicates which operator is being applied.\n    The COMPLAIN flag controls whether we should diagnose possibly"}, {"sha": "26aaee26cddda516df36e7d90ed4bf24a1cfd29d", "filename": "gcc/c-family/c-common.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.h?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -762,7 +762,6 @@ extern tree c_wrap_maybe_const (tree, bool);\n extern tree c_save_expr (tree);\n extern tree c_common_truthvalue_conversion (location_t, tree);\n extern void c_apply_type_quals_to_decl (int, tree);\n-extern unsigned int min_align_of_type (tree);\n extern tree c_sizeof_or_alignof_type (location_t, tree, bool, bool, int);\n extern tree c_alignof_expr (location_t, tree);\n /* Print an error message for invalid operands to arith operation CODE."}, {"sha": "e048c53ac3ee4e3051091cff841d712cb366d089", "filename": "gcc/c-family/c-ubsan.c", "status": "modified", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-ubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-ubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -31,6 +31,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"c-family/c-ubsan.h\"\n #include \"asan.h\"\n #include \"internal-fn.h\"\n+#include \"stor-layout.h\"\n+#include \"builtins.h\"\n \n /* Instrument division by zero and INT_MIN / -1.  If not instrumenting,\n    return NULL_TREE.  */\n@@ -350,3 +352,99 @@ ubsan_maybe_instrument_array_ref (tree *expr_p, bool ignore_off_by_one)\n \t}\n     }\n }\n+\n+static tree\n+ubsan_maybe_instrument_reference_or_call (location_t loc, tree op, tree type,\n+\t\t\t\t\t  enum ubsan_null_ckind ckind)\n+{\n+  tree orig_op = op;\n+  bool instrument = false;\n+  unsigned int mina = 0;\n+\n+  if (current_function_decl == NULL_TREE\n+      || lookup_attribute (\"no_sanitize_undefined\",\n+\t\t\t   DECL_ATTRIBUTES (current_function_decl)))\n+    return NULL_TREE;\n+\n+  if (flag_sanitize & SANITIZE_ALIGNMENT)\n+    {\n+      mina = min_align_of_type (type);\n+      if (mina <= 1)\n+\tmina = 0;\n+    }\n+  while ((TREE_CODE (op) == NOP_EXPR\n+\t  || TREE_CODE (op) == NON_LVALUE_EXPR)\n+\t && TREE_CODE (TREE_TYPE (op)) == POINTER_TYPE)\n+    op = TREE_OPERAND (op, 0);\n+  if (TREE_CODE (op) == NOP_EXPR\n+      && TREE_CODE (TREE_TYPE (op)) == REFERENCE_TYPE)\n+    {\n+      if (mina && mina > min_align_of_type (TREE_TYPE (TREE_TYPE (op))))\n+\tinstrument = true;\n+    }\n+  else\n+    {\n+      if ((flag_sanitize & SANITIZE_NULL) && TREE_CODE (op) == ADDR_EXPR)\n+\t{\n+\t  bool strict_overflow_p = false;\n+\t  /* tree_single_nonzero_warnv_p will not return true for non-weak\n+\t     non-automatic decls with -fno-delete-null-pointer-checks,\n+\t     which is disabled during -fsanitize=null.  We don't want to\n+\t     instrument those, just weak vars though.  */\n+\t  int save_flag_delete_null_pointer_checks\n+\t    = flag_delete_null_pointer_checks;\n+\t  flag_delete_null_pointer_checks = 1;\n+\t  if (!tree_single_nonzero_warnv_p (op, &strict_overflow_p)\n+\t      || strict_overflow_p)\n+\t    instrument = true;\n+\t  flag_delete_null_pointer_checks\n+\t    = save_flag_delete_null_pointer_checks;\n+\t}\n+      else if (flag_sanitize & SANITIZE_NULL)\n+\tinstrument = true;\n+      if (mina && mina > get_pointer_alignment (op) / BITS_PER_UNIT)\n+\tinstrument = true;\n+    }\n+  if (!instrument)\n+    return NULL_TREE;\n+  op = save_expr (orig_op);\n+  tree kind = build_int_cst (TREE_TYPE (op), ckind);\n+  tree align = build_int_cst (pointer_sized_int_node, mina);\n+  tree call\n+    = build_call_expr_internal_loc (loc, IFN_UBSAN_NULL, void_type_node,\n+\t\t\t\t    3, op, kind, align);\n+  TREE_SIDE_EFFECTS (call) = 1;\n+  return fold_build2 (COMPOUND_EXPR, TREE_TYPE (op), call, op);\n+}\n+\n+/* Instrument a NOP_EXPR to REFERENCE_TYPE if needed.  */\n+\n+void\n+ubsan_maybe_instrument_reference (tree stmt)\n+{\n+  tree op = TREE_OPERAND (stmt, 0);\n+  op = ubsan_maybe_instrument_reference_or_call (EXPR_LOCATION (stmt), op,\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (stmt)),\n+\t\t\t\t\t\t UBSAN_REF_BINDING);\n+  if (op)\n+    TREE_OPERAND (stmt, 0) = op;\n+}\n+\n+/* Instrument a CALL_EXPR to a method if needed.  */\n+\n+void\n+ubsan_maybe_instrument_member_call (tree stmt, bool is_ctor)\n+{\n+  if (call_expr_nargs (stmt) == 0)\n+    return;\n+  tree op = CALL_EXPR_ARG (stmt, 0);\n+  if (op == error_mark_node\n+      || !POINTER_TYPE_P (TREE_TYPE (op)))\n+    return;\n+  op = ubsan_maybe_instrument_reference_or_call (EXPR_LOCATION (stmt), op,\n+\t\t\t\t\t\t TREE_TYPE (TREE_TYPE (op)),\n+\t\t\t\t\t\t is_ctor ? UBSAN_CTOR_CALL\n+\t\t\t\t\t\t : UBSAN_MEMBER_CALL);\n+  if (op)\n+    CALL_EXPR_ARG (stmt, 0) = op;\n+}"}, {"sha": "7feec45db069013826b637f04f334376b9b74121", "filename": "gcc/c-family/c-ubsan.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-ubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fc-family%2Fc-ubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-ubsan.h?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -28,5 +28,7 @@ extern tree ubsan_instrument_return (location_t);\n extern tree ubsan_instrument_bounds (location_t, tree, tree *, bool);\n extern bool ubsan_array_ref_instrumented_p (const_tree);\n extern void ubsan_maybe_instrument_array_ref (tree *, bool);\n+extern void ubsan_maybe_instrument_reference (tree);\n+extern void ubsan_maybe_instrument_member_call (tree, bool);\n \n #endif  /* GCC_C_UBSAN_H  */"}, {"sha": "89a6a7b9e0266954164e07f4a835fd2b0e7ca650", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1,3 +1,10 @@\n+2014-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* cp-gimplify.c (cp_genericize_r): For -fsanitize=null and/or\n+\t-fsanitize=alignment call ubsan_maybe_instrument_reference\n+\tfor casts to REFERENCE_TYPE and ubsan_maybe_instrument_member_call\n+\tfor calls to member functions.\n+\n 2014-07-31  Marc Glisse  <marc.glisse@inria.fr>\n \n \tPR c++/60517"}, {"sha": "5f5ba47848c56e5d34f5f39695c82372cf09072d", "filename": "gcc/cp/cp-gimplify.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fcp%2Fcp-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fcp%2Fcp-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-gimplify.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1198,6 +1198,27 @@ cp_genericize_r (tree *stmt_p, int *walk_subtrees, void *data)\n \t*stmt_p = size_one_node;\n       return NULL;\n     }    \n+  else if (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n+    {\n+      if (TREE_CODE (stmt) == NOP_EXPR\n+\t  && TREE_CODE (TREE_TYPE (stmt)) == REFERENCE_TYPE)\n+\tubsan_maybe_instrument_reference (stmt);\n+      else if (TREE_CODE (stmt) == CALL_EXPR)\n+\t{\n+\t  tree fn = CALL_EXPR_FN (stmt);\n+\t  if (fn != NULL_TREE\n+\t      && !error_operand_p (fn)\n+\t      && POINTER_TYPE_P (TREE_TYPE (fn))\n+\t      && TREE_CODE (TREE_TYPE (TREE_TYPE (fn))) == METHOD_TYPE)\n+\t    {\n+\t      bool is_ctor\n+\t\t= TREE_CODE (fn) == ADDR_EXPR\n+\t\t  && TREE_CODE (TREE_OPERAND (fn, 0)) == FUNCTION_DECL\n+\t\t  && DECL_CONSTRUCTOR_P (TREE_OPERAND (fn, 0));\n+\t      ubsan_maybe_instrument_member_call (stmt, is_ctor);\n+\t    }\n+\t}\n+    }\n \n   pointer_set_insert (p_set, *stmt_p);\n "}, {"sha": "7378a2e34533dd039413541ed2f30e49e87ea78b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -5463,7 +5463,8 @@ instead.\n This option enables pointer checking.  Particularly, the application\n built with this option turned on will issue an error message when it\n tries to dereference a NULL pointer, or if a reference (possibly an\n-rvalue reference) is bound to a NULL pointer.\n+rvalue reference) is bound to a NULL pointer, or if a method is invoked\n+on an object pointed by a NULL pointer.\n \n @item -fsanitize=return\n @opindex fsanitize=return\n@@ -5490,6 +5491,13 @@ This option enables instrumentation of array bounds.  Various out of bounds\n accesses are detected.  Flexible array members and initializers of variables\n with static storage are not instrumented.\n \n+@item -fsanitize=alignment\n+@opindex fsanitize=alignment\n+\n+This option enables checking of alignment of pointers when they are\n+dereferenced, or when a reference is bound to insufficiently aligned target,\n+or when a method or constructor is invoked on insufficiently aligned object.\n+\n @item -fsanitize=float-divide-by-zero\n @opindex fsanitize=float-divide-by-zero\n Detect floating-point division by zero.  Unlike other similar options,"}, {"sha": "135c3434bbf659425fa38e50758cb47e35d7244e", "filename": "gcc/flag-types.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fflag-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fflag-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflag-types.h?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -233,10 +233,11 @@ enum sanitize_code {\n   SANITIZE_FLOAT_DIVIDE = 1 << 14,\n   SANITIZE_FLOAT_CAST = 1 << 15,\n   SANITIZE_BOUNDS = 1 << 16,\n+  SANITIZE_ALIGNMENT = 1 << 17,\n   SANITIZE_UNDEFINED = SANITIZE_SHIFT | SANITIZE_DIVIDE | SANITIZE_UNREACHABLE\n \t\t       | SANITIZE_VLA | SANITIZE_NULL | SANITIZE_RETURN\n \t\t       | SANITIZE_SI_OVERFLOW | SANITIZE_BOOL | SANITIZE_ENUM\n-\t\t       | SANITIZE_BOUNDS,\n+\t\t       | SANITIZE_BOUNDS | SANITIZE_ALIGNMENT,\n   SANITIZE_NONDEFAULT = SANITIZE_FLOAT_DIVIDE | SANITIZE_FLOAT_CAST\n };\n "}, {"sha": "be1867c23882890d472b32a75d846f2a23c26119", "filename": "gcc/opts.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1492,6 +1492,7 @@ common_handle_option (struct gcc_options *opts,\n \t      { \"float-cast-overflow\", SANITIZE_FLOAT_CAST,\n \t\tsizeof \"float-cast-overflow\" - 1 },\n \t      { \"bounds\", SANITIZE_BOUNDS, sizeof \"bounds\" - 1 },\n+\t      { \"alignment\", SANITIZE_ALIGNMENT, sizeof \"alignment\" - 1 },\n \t      { NULL, 0, 0 }\n \t    };\n \t    const char *comma;"}, {"sha": "1c65490ae777cc49b3d90aedbd0189260b078a40", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -2390,6 +2390,27 @@ layout_type (tree type)\n     gcc_assert (!TYPE_ALIAS_SET_KNOWN_P (type));\n }\n \n+/* Return the least alignment required for type TYPE.  */\n+\n+unsigned int\n+min_align_of_type (tree type)\n+{\n+  unsigned int align = TYPE_ALIGN (type);\n+  align = MIN (align, BIGGEST_ALIGNMENT);\n+#ifdef BIGGEST_FIELD_ALIGNMENT\n+  align = MIN (align, BIGGEST_FIELD_ALIGNMENT);\n+#endif\n+  unsigned int field_align = align;\n+#ifdef ADJUST_FIELD_ALIGN\n+  tree field = build_decl (UNKNOWN_LOCATION, FIELD_DECL, NULL_TREE,\n+\t\t\t   type);\n+  field_align = ADJUST_FIELD_ALIGN (field, field_align);\n+  ggc_free (field);\n+#endif\n+  align = MIN (align, field_align);\n+  return align / BITS_PER_UNIT;\n+}\n+\n /* Vector types need to re-check the target flags each time we report\n    the machine mode.  We need to do this because attribute target can\n    change the result of vector_mode_supported_p and have_regs_of_mode"}, {"sha": "f7c52670a934e148798d2bcf979c29dba089dd3f", "filename": "gcc/stor-layout.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fstor-layout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fstor-layout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.h?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -59,6 +59,9 @@ extern void layout_decl (tree, unsigned);\n    node, does nothing except for the first time.  */\n extern void layout_type (tree);\n \n+/* Return the least alignment in bytes required for type TYPE.  */\n+extern unsigned int min_align_of_type (tree);\n+\n /* Construct various nodes representing fract or accum data types.  */\n extern tree make_fract_type (int, int, int);\n extern tree make_accum_type (int, int, int);"}, {"sha": "cf2237113bf4858cae03625e1c2f060304af6741", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -1,3 +1,18 @@\n+2014-08-01  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* c-c++-common/ubsan/align-1.c: New test.\n+\t* c-c++-common/ubsan/align-2.c: New test.\n+\t* c-c++-common/ubsan/align-3.c: New test.\n+\t* c-c++-common/ubsan/align-4.c: New test.\n+\t* c-c++-common/ubsan/align-5.c: New test.\n+\t* c-c++-common/ubsan/attrib-4.c: New test.\n+\t* g++.dg/ubsan/align-1.C: New test.\n+\t* g++.dg/ubsan/align-2.C: New test.\n+\t* g++.dg/ubsan/align-3.C: New test.\n+\t* g++.dg/ubsan/attrib-1.C: New test.\n+\t* g++.dg/ubsan/null-1.C: New test.\n+\t* g++.dg/ubsan/null-2.C: New test.\n+\n 2014-08-01  Tom de Vries  <tom@codesourcery.com>\n \n \t* lib/target-supports.exp (check_effective_target_glibc)"}, {"sha": "2e40e839261dc0fba02b20984f845728e8d4fecd", "filename": "gcc/testsuite/c-c++-common/ubsan/align-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-1.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,41 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=undefined -fno-sanitize-recover\" } */\n+\n+struct S { int a; char b; long long c; short d[10]; };\n+struct T { char a; long long b; };\n+struct U { char a; int b; int c; long long d; struct S e; struct T f; };\n+struct V { long long a; struct S b; struct T c; struct U u; } v;\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int *p, int *q, char *r, long long *s)\n+{\n+  *p = *q + *r + *s;\n+}\n+\n+\n+__attribute__((noinline, noclone)) int\n+f2 (struct S *p)\n+{\n+  return p->a;\n+}\n+\n+__attribute__((noinline, noclone)) long long\n+f3 (struct S *p, int i)\n+{\n+  return p->c + p->d[1] + p->d[i];\n+}\n+\n+__attribute__((noinline, noclone)) long long\n+f4 (long long *p)\n+{\n+  return *p;\n+}\n+\n+int\n+main ()\n+{\n+  f1 (&v.u.b, &v.u.c, &v.u.a, &v.u.d);\n+  if (f2 (&v.u.e) + f3 (&v.u.e, 4) + f4 (&v.u.f.b) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "071de8c202a782b7bf363edd196b9ce15ce3f9f3", "filename": "gcc/testsuite/c-c++-common/ubsan/align-2.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-2.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,56 @@\n+/* Limit this to known non-strict alignment targets.  */\n+/* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */\n+/* { dg-options \"-fsanitize=alignment\" } */\n+\n+struct S { int a; char b; long long c; short d[10]; };\n+struct T { char a; long long b; };\n+struct U { char a; int b; int c; long long d; struct S e; struct T f; } __attribute__((packed));\n+struct V { long long a; struct S b; struct T c; struct U u; } v;\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int *p, int *q, char *r, long long *s)\n+{\n+  *p =\n+      *q\n+      + *r\n+      + *s;\n+}\n+\n+\n+__attribute__((noinline, noclone)) int\n+f2 (struct S *p)\n+{\n+  return p->a;\n+}\n+\n+__attribute__((noinline, noclone)) long long\n+f3 (struct S *p, int i)\n+{\n+  return p->c\n+\t + p->d[1]\n+\t + p->d[i];\n+}\n+\n+__attribute__((noinline, noclone)) long long\n+f4 (long long *p)\n+{\n+  return *p;\n+}\n+\n+int\n+main ()\n+{\n+  f1 (&v.u.b, &v.u.c, &v.u.a, &v.u.d);\n+  if (f2 (&v.u.e) + f3 (&v.u.e, 4) + f4 (&v.u.f.b) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-output \"\\.c:(14|15):\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" } */\n+/* { dg-output \"\\.c:16:\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'long long int', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\.c:(13|16):\\[0-9]*: \\[^\\n\\r]*store to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" } */\n+/* { dg-output \"\\.c:23:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\.c:(29|30):\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\.c:30:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\.c:31:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\.c:37:\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'long long int', which requires \\[48] byte alignment\" } */"}, {"sha": "a509fa992e566d0f19e1f73814998358a1b5a57a", "filename": "gcc/testsuite/c-c++-common/ubsan/align-3.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-3.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-do run } */\n+/* { dg-options \"-fsanitize=undefined -fno-sanitize-recover\" } */\n+\n+int c;\n+\n+__attribute__((noinline, noclone)) void\n+f1 (int *a, char *b)\n+{\n+  __builtin_memcpy (a, b, sizeof (*a));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f2 (int *a, char *b)\n+{\n+  __builtin_memcpy (b, a, sizeof (*a));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f3 (char *b)\n+{\n+  __builtin_memcpy (&c, b, sizeof (c));\n+}\n+\n+__attribute__((noinline, noclone)) void\n+f4 (char *b)\n+{\n+  __builtin_memcpy (b, &c, sizeof (c));\n+}\n+\n+struct T\n+{\n+  char a;\n+  short b;\n+  int c;\n+  long d;\n+  long long e;\n+  short f;\n+  float g;\n+  double h;\n+  long double i;\n+} __attribute__((packed));\n+\n+__attribute__((noinline, noclone)) int\n+f5 (struct T *p)\n+{\n+  return p->a + p->b + p->c + p->d + p->e + p->f + p->g + p->h + p->i;\n+}\n+\n+int\n+main ()\n+{\n+  struct S { int a; char b[sizeof (int) + 1]; } s;\n+  s.a = 6;\n+  f2 (&s.a, &s.b[1]);\n+  f1 (&s.a, &s.b[1]);\n+  c = s.a + 1;\n+  f4 (&s.b[1]);\n+  f3 (&s.b[1]);\n+  if (c != 7 || s.a != 6)\n+    __builtin_abort ();\n+  struct U { long long a; long double b; char c; struct T d; } u;\n+  __builtin_memset (&u, 0, sizeof (u));\n+  if (f5 (&u.d) != 0)\n+    __builtin_abort ();\n+  return 0;\n+}"}, {"sha": "3252595d33014311345cd66362897bd584425d7f", "filename": "gcc/testsuite/c-c++-common/ubsan/align-4.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-4.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,14 @@\n+/* Limit this to known non-strict alignment targets.  */\n+/* { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } } */\n+/* { dg-options \"-fsanitize=null,alignment\" } */\n+\n+#include \"align-2.c\"\n+\n+/* { dg-output \"\\.c:(14|15):\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:16:\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'long long int', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:(13|16):\\[0-9]*: \\[^\\n\\r]*store to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:23:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:(29|30):\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:30:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:31:\\[0-9]*: \\[^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct S', which requires \\[48] byte alignment.*\" } */\n+/* { dg-output \"\\[^\\n\\r]*\\.c:37:\\[0-9]*: \\[^\\n\\r]*load of misaligned address 0x\\[0-9a-fA-F]* for type 'long long int', which requires \\[48] byte alignment\" } */"}, {"sha": "b94e167bb67b8b701711955c1ef5b29d6b02ce22", "filename": "gcc/testsuite/c-c++-common/ubsan/align-5.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Falign-5.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fno-sanitize=null -fsanitize=alignment -O2\" } */\n+/* Check that when optimizing if we know the alignment is right\n+   and we are not doing -fsanitize=null instrumentation we don't\n+   instrument the alignment check.  */\n+\n+__attribute__((noinline, noclone)) int\n+foo (char *p)\n+{\n+  p = (char *) __builtin_assume_aligned (p, __alignof__(int));\n+  int *q = (int *) p;\n+  return *q;\n+}\n+\n+/* { dg-final { scan-assembler-not \"__ubsan_handle\" } } */"}, {"sha": "ba0f00cfb7f653cce38eefd970929b9b9a415c4a", "filename": "gcc/testsuite/c-c++-common/ubsan/attrib-4.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fattrib-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fattrib-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fc-c%2B%2B-common%2Fubsan%2Fattrib-4.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,15 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fsanitize=undefined\" } */\n+\n+/* Test that we don't instrument functions marked with\n+   no_sanitize_undefined attribute.  */\n+\n+struct S { int a[16]; };\n+\n+__attribute__((no_sanitize_undefined)) long long\n+foo (int *a, long long *b, struct S *c)\n+{\n+  return a[1] + *b + c->a[a[0]];\n+}\n+\n+/* { dg-final { scan-assembler-not \"__ubsan_handle\" } } */"}, {"sha": "65b1222a5c063120ce52b719e6761e363e475232", "filename": "gcc/testsuite/g++.dg/ubsan/align-1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-1.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do run }\n+// { dg-options \"-fsanitize=alignment -Wall -Wno-unused-variable -std=c++11\" }\n+\n+typedef const long int L;\n+int a = 1;\n+L b = 2;\n+\n+int\n+main (void)\n+{\n+  int *p = &a;\n+  L *l = &b;\n+\n+  int &r = *p;\n+  auto &r2 = *p;\n+  L &lr = *l;\n+\n+  // Try an rvalue reference.\n+  auto &&r3 = *p;\n+\n+  // Don't evaluate the reference initializer twice.\n+  int i = 1;\n+  int *q = &i;\n+  int &qr = ++*q;\n+  if (i != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "3e4f5485d02b2944408acfafcf57eda4823ff2d2", "filename": "gcc/testsuite/g++.dg/ubsan/align-2.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-2.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,45 @@\n+// Limit this to known non-strict alignment targets.\n+// { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } }\n+// { dg-options \"-fsanitize=alignment -Wall -Wno-unused-variable -std=c++11\" }\n+\n+typedef const long int L;\n+struct S { long int l; char buf[1 + sizeof (int) + sizeof (L)]; } s;\n+struct T { char a; int b; long int c; } __attribute__((packed));\n+struct U { long int a; struct T b; } u;\n+\n+int\n+main (void)\n+{\n+  int *p = (int *) &s.buf[1];\n+  L *l = (L *) &s.buf[1 + sizeof(int)];\n+\n+  int &r = *p;\n+  auto &r2 = *p;\n+  L &lr = *l;\n+\n+  // Try an rvalue reference.\n+  auto &&r3 = *p;\n+\n+  // Don't evaluate the reference initializer twice.\n+  int i = 1;\n+  int *q = &i;\n+  int &qr = ++*q;\n+  if (i != 2)\n+    __builtin_abort ();\n+\n+  int *s = &u.b.b;\n+  L *t = &u.b.c;\n+  int &r4 = *s;\n+  auto &r5 = *s;\n+  L &lr2 = *t;\n+  auto &&r6 = *s;\n+}\n+\n+// { dg-output \"\\.C:16:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:17:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:18:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'const L', which requires \\[48] byte alignment.*\" }\n+// { dg-output \"\\.C:21:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:32:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:33:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:34:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'const L', which requires \\[48] byte alignment.*\" }\n+// { dg-output \"\\.C:35:\\[0-9]*:\\[\\^\\n\\r]*reference binding to misaligned address 0x\\[0-9a-fA-F]* for type 'int', which requires 4 byte alignment\" }"}, {"sha": "1cc40fc4c9bf7e2d8fa16e092a243a40ce3466a4", "filename": "gcc/testsuite/g++.dg/ubsan/align-3.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Falign-3.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,45 @@\n+// Limit this to known non-strict alignment targets.\n+// { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } }\n+// { dg-options \"-fsanitize=alignment -Wall -Wno-unused-variable -std=c++11\" }\n+\n+#include <new>\n+\n+struct U\n+{\n+  int a;\n+  void foo () {}\n+};\n+struct V\n+{\n+  V () : a (0) {};\n+  ~V () { a = 0; };\n+  int a;\n+  void foo () {}\n+  static void bar () {}\n+};\n+struct S { long int l; char buf[1 + sizeof (U) + 2 * sizeof (V)]; } s;\n+\n+int\n+main (void)\n+{\n+  U *p = (U *) &s.buf[1];\n+  p->foo ();\n+  char *q = &s.buf[1 + sizeof (U)];\n+  V *u = new (q) V;\n+  u->a = 1;\n+  u->~V ();\n+  V *v = new (&s.buf[1 + sizeof (U) + sizeof (V)]) V;\n+  v->foo ();\n+  v->bar ();\t// We don't instrument this right now.\n+  v->~V ();\n+}\n+\n+// { dg-output \"\\.C:26:\\[0-9]*:\\[\\^\\n\\r]*member call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct U', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:28:\\[0-9]*:\\[\\^\\n\\r]*constructor call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:14:\\[0-9]*:\\[\\^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:29:\\[0-9]*:\\[\\^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:30:\\[0-9]*:\\[\\^\\n\\r]*member call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:15:\\[0-9]*:\\[\\^\\n\\r]*member access within misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:31:\\[0-9]*:\\[\\^\\n\\r]*constructor call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:32:\\[0-9]*:\\[\\^\\n\\r]*member call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment.*\" }\n+// { dg-output \"\\.C:34:\\[0-9]*:\\[\\^\\n\\r]*member call on misaligned address 0x\\[0-9a-fA-F]* for type 'struct V', which requires 4 byte alignment\" }"}, {"sha": "f701d02dad3a110dd33c3335888297636f7b241c", "filename": "gcc/testsuite/g++.dg/ubsan/attrib-1.C", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fattrib-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fattrib-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fattrib-1.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,27 @@\n+// { dg-do compile }\n+// { dg-options \"-fsanitize=undefined -Wall -Wno-unused-variable -std=c++11\" }\n+\n+typedef const long int L;\n+\n+__attribute__((no_sanitize_undefined)) void\n+foo (int *p, L *l)\n+{\n+  int &r = *p;\n+  auto &r2 = *p;\n+  L &lr = *l;\n+  auto &&r3 = *p;\n+}\n+\n+struct U\n+{\n+  int a;\n+  void foo () {}\n+};\n+\n+__attribute__((no_sanitize_undefined)) void\n+bar (U *p)\n+{\n+  p->foo ();\n+}\n+\n+// { dg-final { scan-assembler-not \"__ubsan_handle\" } }"}, {"sha": "e1524b1f922e277cf3065ed48738976fb5012513", "filename": "gcc/testsuite/g++.dg/ubsan/null-1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-1.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do run }\n+// { dg-options \"-fsanitize=null -Wall -Wno-unused-variable -std=c++11\" }\n+\n+typedef const long int L;\n+\n+int\n+main (void)\n+{\n+  int *p = 0;\n+  L *l = 0;\n+\n+  int &r = *p;\n+  auto &r2 = *p;\n+  L &lr = *l;\n+\n+  // Try an rvalue reference.\n+  auto &&r3 = *p;\n+\n+  // Don't evaluate the reference initializer twice.\n+  int i = 1;\n+  int *q = &i;\n+  int &qr = ++*q;\n+  if (i != 2)\n+    __builtin_abort ();\n+}\n+\n+// { dg-output \"reference binding to null pointer of type 'int'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"\\[^\\n\\r]*reference binding to null pointer of type 'int'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"\\[^\\n\\r]*reference binding to null pointer of type 'const L'(\\n|\\r\\n|\\r)\" }\n+// { dg-output \"\\[^\\n\\r]*reference binding to null pointer of type 'int'(\\n|\\r\\n|\\r)\" }"}, {"sha": "88f387e17c917d274e6bc0dabef63b2e3e53a382", "filename": "gcc/testsuite/g++.dg/ubsan/null-2.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fubsan%2Fnull-2.C?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -0,0 +1,39 @@\n+// Limit this to known non-strict alignment targets.\n+// { dg-do run { target { i?86-*-linux* x86_64-*-linux* } } }\n+// { dg-options \"-fsanitize=null -Wall -Wno-unused-variable -std=c++11\" }\n+\n+#include <new>\n+\n+struct U\n+{\n+  int a;\n+  void foo () {}\n+};\n+struct V\n+{\n+  V () {};\n+  ~V () {};\n+  int a;\n+  void foo () {}\n+  static void bar () {}\n+};\n+struct S { long int l; char buf[1 + sizeof (U) + 2 * sizeof (V)]; } s;\n+\n+int\n+main (void)\n+{\n+  U *p = 0;\n+  p->foo ();\n+  char *q = 0;\n+  V *u = new (q) V;\n+  u->~V ();\n+  V *v = new (q) V;\n+  v->foo ();\n+  v->bar ();\t// We don't instrument this right now.\n+  v->~V ();\n+}\n+\n+// { dg-output \"\\.C:26:\\[0-9]*:\\[\\^\\n\\r]*member call on null pointer of type 'struct U'.*\" }\n+// { dg-output \"\\.C:29:\\[0-9]*:\\[\\^\\n\\r]*member call on null pointer of type 'struct V'.*\" }\n+// { dg-output \"\\.C:31:\\[0-9]*:\\[\\^\\n\\r]*member call on null pointer of type 'struct V'.*\" }\n+// { dg-output \"\\.C:33:\\[0-9]*:\\[\\^\\n\\r]*member call on null pointer of type 'struct V'\" }"}, {"sha": "0dbb104d2e8885a646f37a7823d530759f1ce640", "filename": "gcc/ubsan.c", "status": "modified", "additions": 130, "deletions": 41, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fubsan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fubsan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.c?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -49,6 +49,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"intl.h\"\n #include \"realmpfr.h\"\n #include \"dfp.h\"\n+#include \"builtins.h\"\n \n /* Map from a tree to a VAR_DECL tree.  */\n \n@@ -586,7 +587,7 @@ is_ubsan_builtin_p (tree t)\n \n /* Expand the UBSAN_BOUNDS special builtin function.  */\n \n-void\n+bool\n ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n {\n   gimple stmt = gsi_stmt (*gsi);\n@@ -645,21 +646,52 @@ ubsan_expand_bounds_ifn (gimple_stmt_iterator *gsi)\n \n   /* Point GSI to next logical statement.  */\n   *gsi = gsi_start_bb (fallthru_bb);\n+  return true;\n }\n \n-/* Expand UBSAN_NULL internal call.  */\n+/* Expand UBSAN_NULL internal call.  The type is kept on the ckind\n+   argument which is a constant, because the middle-end treats pointer\n+   conversions as useless and therefore the type of the first argument\n+   could be changed to any other pointer type.  */\n \n-void\n-ubsan_expand_null_ifn (gimple_stmt_iterator gsi)\n+bool\n+ubsan_expand_null_ifn (gimple_stmt_iterator *gsip)\n {\n+  gimple_stmt_iterator gsi = *gsip;\n   gimple stmt = gsi_stmt (gsi);\n   location_t loc = gimple_location (stmt);\n-  gcc_assert (gimple_call_num_args (stmt) == 2);\n+  gcc_assert (gimple_call_num_args (stmt) == 3);\n   tree ptr = gimple_call_arg (stmt, 0);\n   tree ckind = gimple_call_arg (stmt, 1);\n+  tree align = gimple_call_arg (stmt, 2);\n+  tree check_align = NULL_TREE;\n+  bool check_null;\n \n   basic_block cur_bb = gsi_bb (gsi);\n \n+  gimple g;\n+  if (!integer_zerop (align))\n+    {\n+      unsigned int ptralign = get_pointer_alignment (ptr) / BITS_PER_UNIT;\n+      if (compare_tree_int (align, ptralign) == 1)\n+\t{\n+\t  check_align = make_ssa_name (pointer_sized_int_node, NULL);\n+\t  g = gimple_build_assign_with_ops (NOP_EXPR, check_align,\n+\t\t\t\t\t    ptr, NULL_TREE);\n+\t  gimple_set_location (g, loc);\n+\t  gsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\t}\n+    }\n+  check_null = (flag_sanitize & SANITIZE_NULL) != 0;\n+\n+  if (check_align == NULL_TREE && !check_null)\n+    {\n+      gsi_remove (gsip, true);\n+      /* Unlink the UBSAN_NULLs vops before replacing it.  */\n+      unlink_stmt_vdef (stmt);\n+      return true;\n+    }\n+\n   /* Split the original block holding the pointer dereference.  */\n   edge e = split_block (cur_bb, stmt);\n \n@@ -689,12 +721,11 @@ ubsan_expand_null_ifn (gimple_stmt_iterator gsi)\n \n   /* Update dominance info for the newly created then_bb; note that\n      fallthru_bb's dominance info has already been updated by\n-     split_bock.  */\n+     split_block.  */\n   if (dom_info_available_p (CDI_DOMINATORS))\n     set_immediate_dominator (CDI_DOMINATORS, then_bb, cond_bb);\n \n   /* Put the ubsan builtin call into the newly created BB.  */\n-  gimple g;\n   if (flag_sanitize_undefined_trap_on_error)\n     g = gimple_build_call (builtin_decl_implicit (BUILT_IN_TRAP), 0);\n   else\n@@ -705,54 +736,115 @@ ubsan_expand_null_ifn (gimple_stmt_iterator gsi)\n \t  : BUILT_IN_UBSAN_HANDLE_TYPE_MISMATCH_ABORT;\n       tree fn = builtin_decl_implicit (bcode);\n       const struct ubsan_mismatch_data m\n-\t= { build_zero_cst (pointer_sized_int_node), ckind };\n+\t= { align, fold_convert (unsigned_char_type_node, ckind) };\n       tree data\n \t= ubsan_create_data (\"__ubsan_null_data\", &loc, &m,\n-\t\t\t     ubsan_type_descriptor (TREE_TYPE (ptr),\n+\t\t\t     ubsan_type_descriptor (TREE_TYPE (ckind),\n \t\t\t\t\t\t    UBSAN_PRINT_POINTER),\n \t\t\t     NULL_TREE);\n       data = build_fold_addr_expr_loc (loc, data);\n       g = gimple_build_call (fn, 2, data,\n-\t\t\t     build_zero_cst (pointer_sized_int_node));\n+\t\t\t     check_align ? check_align\n+\t\t\t     : build_zero_cst (pointer_sized_int_node));\n     }\n-  gimple_set_location (g, loc);\n   gimple_stmt_iterator gsi2 = gsi_start_bb (then_bb);\n+  gimple_set_location (g, loc);\n   gsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n \n   /* Unlink the UBSAN_NULLs vops before replacing it.  */\n   unlink_stmt_vdef (stmt);\n \n-  g = gimple_build_cond (EQ_EXPR, ptr, build_int_cst (TREE_TYPE (ptr), 0),\n-\t\t\t NULL_TREE, NULL_TREE);\n-  gimple_set_location (g, loc);\n+  if (check_null)\n+    {\n+      g = gimple_build_cond (EQ_EXPR, ptr, build_int_cst (TREE_TYPE (ptr), 0),\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n \n-  /* Replace the UBSAN_NULL with a GIMPLE_COND stmt.  */\n-  gsi_replace (&gsi, g, false);\n-}\n+      /* Replace the UBSAN_NULL with a GIMPLE_COND stmt.  */\n+      gsi_replace (&gsi, g, false);\n+    }\n \n-/* Instrument a member call.  We check whether 'this' is NULL.  */\n+  if (check_align)\n+    {\n+      if (check_null)\n+\t{\n+\t  /* Split the block with the condition again.  */\n+\t  e = split_block (cond_bb, stmt);\n+\t  basic_block cond1_bb = e->src;\n+\t  basic_block cond2_bb = e->dest;\n+\n+\t  /* Make an edge coming from the 'cond1 block' into the 'then block';\n+\t     this edge is unlikely taken, so set up the probability\n+\t     accordingly.  */\n+\t  e = make_edge (cond1_bb, then_bb, EDGE_TRUE_VALUE);\n+\t  e->probability = PROB_VERY_UNLIKELY;\n+\n+\t  /* Set up the fallthrough basic block.  */\n+\t  e = find_edge (cond1_bb, cond2_bb);\n+\t  e->flags = EDGE_FALSE_VALUE;\n+\t  e->count = cond1_bb->count;\n+\t  e->probability = REG_BR_PROB_BASE - PROB_VERY_UNLIKELY;\n+\n+\t  /* Update dominance info.  */\n+\t  if (dom_info_available_p (CDI_DOMINATORS))\n+\t    {\n+\t      set_immediate_dominator (CDI_DOMINATORS, fallthru_bb, cond1_bb);\n+\t      set_immediate_dominator (CDI_DOMINATORS, then_bb, cond1_bb);\n+\t    }\n \n-static void\n-instrument_member_call (gimple_stmt_iterator *iter)\n-{\n-  tree this_parm = gimple_call_arg (gsi_stmt (*iter), 0);\n-  tree kind = build_int_cst (unsigned_char_type_node, UBSAN_MEMBER_CALL);\n-  gimple g = gimple_build_call_internal (IFN_UBSAN_NULL, 2, this_parm, kind);\n-  gimple_set_location (g, gimple_location (gsi_stmt (*iter)));\n-  gsi_insert_before (iter, g, GSI_SAME_STMT);\n+\t  gsi2 = gsi_start_bb (cond2_bb);\n+\t}\n+\n+      tree mask = build_int_cst (pointer_sized_int_node,\n+\t\t\t\t tree_to_uhwi (align) - 1);\n+      g = gimple_build_assign_with_ops (BIT_AND_EXPR,\n+\t\t\t\t\tmake_ssa_name (pointer_sized_int_node,\n+\t\t\t\t\t\t       NULL),\n+\t\t\t\t\tcheck_align, mask);\n+      gimple_set_location (g, loc);\n+      if (check_null)\n+\tgsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n+      else\n+\tgsi_insert_before (&gsi, g, GSI_SAME_STMT);\n+\n+      g = gimple_build_cond (NE_EXPR, gimple_assign_lhs (g),\n+\t\t\t     build_int_cst (pointer_sized_int_node, 0),\n+\t\t\t     NULL_TREE, NULL_TREE);\n+      gimple_set_location (g, loc);\n+      if (check_null)\n+\tgsi_insert_after (&gsi2, g, GSI_NEW_STMT);\n+      else\n+\t/* Replace the UBSAN_NULL with a GIMPLE_COND stmt.  */\n+\tgsi_replace (&gsi, g, false);\n+    }\n+  return false;\n }\n \n-/* Instrument a memory reference.  T is the pointer, IS_LHS says\n+/* Instrument a memory reference.  BASE is the base of MEM, IS_LHS says\n    whether the pointer is on the left hand side of the assignment.  */\n \n static void\n-instrument_mem_ref (tree t, gimple_stmt_iterator *iter, bool is_lhs)\n+instrument_mem_ref (tree mem, tree base, gimple_stmt_iterator *iter,\n+\t\t    bool is_lhs)\n {\n   enum ubsan_null_ckind ikind = is_lhs ? UBSAN_STORE_OF : UBSAN_LOAD_OF;\n-  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_TYPE (t))))\n+  unsigned int align = 0;\n+  if (flag_sanitize & SANITIZE_ALIGNMENT)\n+    {\n+      align = min_align_of_type (TREE_TYPE (base));\n+      if (align <= 1)\n+\talign = 0;\n+    }\n+  if (align == 0 && (flag_sanitize & SANITIZE_NULL) == 0)\n+    return;\n+  tree t = TREE_OPERAND (base, 0);\n+  if (!POINTER_TYPE_P (TREE_TYPE (t)))\n+    return;\n+  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (TREE_TYPE (t))) && mem != base)\n     ikind = UBSAN_MEMBER_ACCESS;\n-  tree kind = build_int_cst (unsigned_char_type_node, ikind);\n-  gimple g = gimple_build_call_internal (IFN_UBSAN_NULL, 2, t, kind);\n+  tree kind = build_int_cst (TREE_TYPE (t), ikind);\n+  tree alignt = build_int_cst (pointer_sized_int_node, align);\n+  gimple g = gimple_build_call_internal (IFN_UBSAN_NULL, 3, t, kind, alignt);\n   gimple_set_location (g, gimple_location (gsi_stmt (*iter)));\n   gsi_insert_before (iter, g, GSI_SAME_STMT);\n }\n@@ -764,15 +856,11 @@ instrument_null (gimple_stmt_iterator gsi, bool is_lhs)\n {\n   gimple stmt = gsi_stmt (gsi);\n   tree t = is_lhs ? gimple_get_lhs (stmt) : gimple_assign_rhs1 (stmt);\n-  t = get_base_address (t);\n-  const enum tree_code code = TREE_CODE (t);\n+  tree base = get_base_address (t);\n+  const enum tree_code code = TREE_CODE (base);\n   if (code == MEM_REF\n-      && TREE_CODE (TREE_OPERAND (t, 0)) == SSA_NAME)\n-    instrument_mem_ref (TREE_OPERAND (t, 0), &gsi, is_lhs);\n-  else if (code == ADDR_EXPR\n-\t   && POINTER_TYPE_P (TREE_TYPE (t))\n-\t   && TREE_CODE (TREE_TYPE (TREE_TYPE (t))) == METHOD_TYPE)\n-    instrument_member_call (&gsi);\n+      && TREE_CODE (TREE_OPERAND (base, 0)) == SSA_NAME)\n+    instrument_mem_ref (t, base, &gsi, is_lhs);\n }\n \n /* Build an ubsan builtin call for the signed-integer-overflow\n@@ -1147,7 +1235,8 @@ class pass_ubsan : public gimple_opt_pass\n   virtual bool gate (function *)\n     {\n       return flag_sanitize & (SANITIZE_NULL | SANITIZE_SI_OVERFLOW\n-\t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM)\n+\t\t\t      | SANITIZE_BOOL | SANITIZE_ENUM\n+\t\t\t      | SANITIZE_ALIGNMENT)\n \t     && current_function_decl != NULL_TREE\n \t     && !lookup_attribute (\"no_sanitize_undefined\",\n \t\t\t\t   DECL_ATTRIBUTES (current_function_decl));\n@@ -1180,7 +1269,7 @@ pass_ubsan::execute (function *fun)\n \t      && is_gimple_assign (stmt))\n \t    instrument_si_overflow (gsi);\n \n-\t  if (flag_sanitize & SANITIZE_NULL)\n+\t  if (flag_sanitize & (SANITIZE_NULL | SANITIZE_ALIGNMENT))\n \t    {\n \t      if (gimple_store_p (stmt))\n \t\tinstrument_null (gsi, true);"}, {"sha": "c92732375276795d4097e7ba3153a197077c22d5", "filename": "gcc/ubsan.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fubsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/944fa280bc92d197c443e369bb24405f007d46ab/gcc%2Fubsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fubsan.h?ref=944fa280bc92d197c443e369bb24405f007d46ab", "patch": "@@ -27,7 +27,8 @@ enum ubsan_null_ckind {\n   UBSAN_STORE_OF,\n   UBSAN_REF_BINDING,\n   UBSAN_MEMBER_ACCESS,\n-  UBSAN_MEMBER_CALL\n+  UBSAN_MEMBER_CALL,\n+  UBSAN_CTOR_CALL\n };\n \n /* This controls how ubsan prints types.  Used in ubsan_type_descriptor.  */\n@@ -43,8 +44,8 @@ struct ubsan_mismatch_data {\n   tree ckind;\n };\n \n-extern void ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n-extern void ubsan_expand_null_ifn (gimple_stmt_iterator);\n+extern bool ubsan_expand_bounds_ifn (gimple_stmt_iterator *);\n+extern bool ubsan_expand_null_ifn (gimple_stmt_iterator *);\n extern tree ubsan_instrument_unreachable (location_t);\n extern tree ubsan_create_data (const char *, const location_t *,\n \t\t\t       const struct ubsan_mismatch_data *, ...);"}]}