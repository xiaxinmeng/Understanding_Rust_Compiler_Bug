{"sha": "7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2U1N2RhMTIxYWM3MGQwZmM5YTUzYzNiMWYyYTM2NTdlMTFlMjA5Yg==", "commit": {"author": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T17:40:04Z"}, "committer": {"name": "James A. Morrison", "email": "phython@gcc.gnu.org", "date": "2004-10-02T17:40:04Z"}, "message": "lex.l: Remove random whitespace.\n\n2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n\n        * lex.l: Remove random whitespace.\n        * parse.y: Reformat copyright notice.  Indent declarations.\n        Wrap long lines, unwrap short lines.\n        * tree1.c: Reformat copyright notice.  Wrap long lines.\n        Remove random whitespace.\n        (lookup_tree_name): Use LOCATION_LINE.\n        * treetree.c: Reformat copyright notice.  Wrap long lines.\n        Remove random whitespace.\n\nFrom-SVN: r88428", "tree": {"sha": "3b54fb65f8c0bf2e59e1b16cfe00c70ae8a79aad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b54fb65f8c0bf2e59e1b16cfe00c70ae8a79aad"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/comments", "author": null, "committer": null, "parents": [{"sha": "1abb828af191bb7b36ee17c32f253f5eec371c29", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1abb828af191bb7b36ee17c32f253f5eec371c29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1abb828af191bb7b36ee17c32f253f5eec371c29"}], "stats": {"total": 356, "additions": 181, "deletions": 175}, "files": [{"sha": "88e85408612030b04778001adab34fb3e032902c", "filename": "gcc/treelang/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2FChangeLog?ref=7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "patch": "@@ -1,3 +1,14 @@\n+2004-10-02  James A. Morrison  <phython@gcc.gnu.org>\n+\n+\t* lex.l: Remove random whitespace.\n+\t* parse.y: Reformat copyright notice.  Indent declarations.\n+\tWrap long lines, unwrap short lines.\n+\t* tree1.c: Reformat copyright notice.  Wrap long lines.\n+\tRemove random whitespace.\n+\t(lookup_tree_name): Use LOCATION_LINE.\n+\t* treetree.c: Reformat copyright notice.  Wrap long lines.\n+\tRemove random whitespace.\n+\n 2004-10-01  James A. Morrison  <phython@gcc.gnu.org>\n \n \t* parse.y (ELSE): Set tok to $1."}, {"sha": "41be1e07ea722b5910e72135d7b9c443f717b421", "filename": "gcc/treelang/lex.l", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Flex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Flex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Flex.l?ref=7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "patch": "@@ -29,9 +29,7 @@\n    ---------------------------------------------------------------------\n    \n    Written by Tim Josling 1999-2001, based in part on other parts of\n-   the GCC compiler. \n- \n-*/\n+   the GCC compiler.  */\n \n %{\n #include \"config.h\"\n@@ -51,7 +49,7 @@ extern int option_lexer_trace;\n int yylex (void);\n void update_yylval (int a); \n \n-static int next_tree_charno=1;\n+static int next_tree_charno = 1;\n  \n static void update_lineno_charno (void);\n static void dump_lex_value (int lexret);\n@@ -80,13 +78,13 @@ static void dump_lex_value (int lexret);\n \n [ \\n\\t]+ {\n   update_lineno_charno ();\n-    NOT_RETURN (WHITESPACE);\n+  NOT_RETURN (WHITESPACE);\n }\n   \n \"//\".*  {\n   /* Comment.  */\n-    update_lineno_charno ();\n-    NOT_RETURN (COMMENT);\n+  update_lineno_charno ();\n+  NOT_RETURN (COMMENT);\n }\n    \n \"{\" {\n@@ -254,7 +252,7 @@ void\n update_yylval (int a)\n {\n   struct prod_token_parm_item * tok;\n-  tok=yylval;\n+  tok = yylval;\n   \n   tok->category = token_category;\n   tok->type = a;"}, {"sha": "b55795d256d0dd3abd6e4392d488ad01178d3b56", "filename": "gcc/treelang/parse.y", "status": "modified", "additions": 92, "deletions": 88, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Fparse.y?ref=7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "patch": "@@ -1,48 +1,40 @@\n-%{ /* -*- c -*- emacs mode c */\n-  /* \n+/* -*- c -*- emacs mode c */\n+/* TREELANG Compiler parser.  \n \n-     TREELANG Compiler parser.  \n+---------------------------------------------------------------------\n \n-     ---------------------------------------------------------------------\n+Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n+Free Software Foundation, Inc.\n \n-     Copyright (C) 1999, 2000, 2001, 2002, 2003, 2004\n-     Free Software Foundation, Inc.\n+This program is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n \n-     This program is free software; you can redistribute it and/or modify it\n-     under the terms of the GNU General Public License as published by the\n-     Free Software Foundation; either version 2, or (at your option) any\n-     later version.\n+This program is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n \n-     This program is distributed in the hope that it will be useful,\n-     but WITHOUT ANY WARRANTY; without even the implied warranty of\n-     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-     GNU General Public License for more details.\n+You should have received a copy of the GNU General Public License\n+along with this program; if not, write to the Free Software\n+Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n \n-     You should have received a copy of the GNU General Public License\n-     along with this program; if not, write to the Free Software\n-     Foundation, 59 Temple Place - Suite 330,\n-     Boston, MA 02111-1307, USA.\n+In other words, you are welcome to use, share and improve this program.\n+You are forbidden to forbid anyone else to use, share and improve\n+what you give them.   Help stamp out software-hoarding!  \n \n-     In other words, you are welcome to use, share and improve this program.\n-     You are forbidden to forbid anyone else to use, share and improve\n-     what you give them.   Help stamp out software-hoarding!  \n+---------------------------------------------------------------------\n \n-     ---------------------------------------------------------------------\n+Written by Tim Josling 1999-2001, based in part on other parts of\n+the GCC compiler.  */\n \n-     Written by Tim Josling 1999-2001, based in part on other parts of\n-     the GCC compiler.\n- \n-   */\n-\n-  /* \n-\n-     Grammar Conflicts\n-     *****************\n-\n-     There are no conflicts in this grammar.  Please keep it that way.\n-\n-   */\n+/* Grammar Conflicts\n+   *****************\n+   There are no conflicts in this grammar.  Please keep it that way.  */\n \n+%{ \n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -57,44 +49,46 @@\n #define YYPRINT(file, type, value) print_token (file, type, value) \n #define YYERROR_VERBOSE YES\n \n-/* My yylex routine used to intercept calls to flex generated code, to\n+  /* My yylex routine used to intercept calls to flex generated code, to\n      record lex time.  */\n-int yylex (void);\n-static inline int my_yylex (void);\n-/* Call lex, but ensure time is charged to TV_LEX.  */ \n-static inline int\n-my_yylex (void)\n-{\n-  int res;\n-  timevar_push (TV_LEX);\n-  res = yylex ();\n-  timevar_pop (TV_LEX);\n-  return res;\n-}\n-#define yylex my_yylex\n-\n-extern int option_parser_trace;\n-\n-/* Local prototypes.  */\n+  int yylex (void);\n+  static inline int my_yylex (void);\n \n-static void yyerror (const char *error_message);\n-int yyparse (void);\n-void print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED, YYSTYPE value);\n-static struct prod_token_parm_item *reverse_prod_list (struct prod_token_parm_item *old_first);\n-static void ensure_not_void (unsigned int type, struct prod_token_parm_item* name);\n-static int check_type_match (int type_num, struct prod_token_parm_item *exp);\n-static int get_common_type (struct prod_token_parm_item *type1,\n-                            struct prod_token_parm_item *type2);\n-static struct prod_token_parm_item *make_integer_constant (struct prod_token_parm_item* value);\n-static struct prod_token_parm_item *make_plus_expression\n-  (struct prod_token_parm_item* tok, struct prod_token_parm_item* op1,\n-   struct prod_token_parm_item* op2, int type_code, int prod_code);\n-static void set_storage (struct prod_token_parm_item *prod);\n-\n-/* File global variables.  */\n-\n-static struct prod_token_parm_item *current_function=NULL;\n+  /* Call lex, but ensure time is charged to TV_LEX.  */ \n+  static inline int\n+    my_yylex (void)\n+    {\n+      int res;\n+      timevar_push (TV_LEX);\n+      res = yylex ();\n+      timevar_pop (TV_LEX);\n+      return res;\n+    }\n+#define yylex my_yylex\n \n+  extern int option_parser_trace;\n+\n+  /* Local prototypes.  */\n+  static void yyerror (const char *error_message);\n+  int yyparse (void);\n+  void print_token (FILE * file, unsigned int type ATTRIBUTE_UNUSED,\n+\t\t    YYSTYPE value);\n+  static struct prod_token_parm_item *reverse_prod_list\n+    (struct prod_token_parm_item *old_first);\n+  static void ensure_not_void (unsigned int type,\n+\t\t\t       struct prod_token_parm_item* name);\n+  static int check_type_match (int type_num, struct prod_token_parm_item *exp);\n+  static int get_common_type (struct prod_token_parm_item *type1,\n+\t\t\t      struct prod_token_parm_item *type2);\n+  static struct prod_token_parm_item *make_integer_constant\n+    (struct prod_token_parm_item* value);\n+  static struct prod_token_parm_item *make_plus_expression\n+    (struct prod_token_parm_item* tok, struct prod_token_parm_item* op1,\n+     struct prod_token_parm_item* op2, int type_code, int prod_code);\n+  static void set_storage (struct prod_token_parm_item *prod);\n+\n+  /* File global variables.  */\n+  static struct prod_token_parm_item *current_function = NULL;\n %}\n \n /* Not %raw - seems to have bugs.  */\n@@ -191,7 +185,8 @@ storage typename NAME init_opt SEMICOLON {\n   SYMBOL_TABLE_NAME (prod) = tok;\n   EXPRESSION_TYPE (prod) = $2;\n   VAR_INIT (prod) = $4;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) = \n+    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -219,7 +214,8 @@ storage typename NAME init_opt SEMICOLON {\n      ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.chars,\n      ((struct prod_token_parm_item*)SYMBOL_TABLE_NAME (prod))->tp.tok.length,\n      NUMERIC_TYPE (prod),\n-     VAR_INIT (prod)? ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code:NULL,\n+     VAR_INIT (prod) ?\n+     ((struct prod_token_parm_item*)VAR_INIT (prod))->tp.pro.code : NULL,\n      tok->tp.tok.location);\n   if (!prod->tp.pro.code) \n     abort ();\n@@ -242,7 +238,8 @@ typename NAME {\n   prod = make_production (PROD_VARIABLE_NAME, tok);\n   SYMBOL_TABLE_NAME (prod) = $2;\n   EXPRESSION_TYPE (prod) = $1;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) =\n+    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   ensure_not_void (NUMERIC_TYPE (prod), tok);\n   if (insert_tree_name (prod))\n     {\n@@ -268,7 +265,8 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n   prod = make_production (PROD_FUNCTION_NAME, $3);\n   SYMBOL_TABLE_NAME (prod) = $3;\n   EXPRESSION_TYPE (prod) = $2;\n-  NUMERIC_TYPE (prod) = NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n+  NUMERIC_TYPE (prod) =\n+    NUMERIC_TYPE (( (struct prod_token_parm_item*)EXPRESSION_TYPE (prod)));\n   PARAMETERS (prod) = reverse_prod_list ($5); \n   insert_tree_name (prod);\n   STORAGE_CLASS_TOKEN (prod) = $1;\n@@ -307,7 +305,9 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n       this_parms = my_malloc (sizeof (struct prod_token_parm_item));\n       if (!this_parm_var->tp.pro.main_token)\n         abort ();\n-      this_parms->tp.par.variable_name = this_parm_var->tp.pro.main_token->tp.tok.chars;\n+\n+      this_parms->tp.par.variable_name =\n+\tthis_parm_var->tp.pro.main_token->tp.tok.chars;\n       this_parms->category = parameter_category;\n       this_parms->type = NUMERIC_TYPE \n         (( (struct prod_token_parm_item*)EXPRESSION_TYPE (this_parm_var)));\n@@ -326,9 +326,11 @@ storage typename NAME LEFT_PARENTHESIS parameters_opt RIGHT_PARENTHESIS SEMICOLO\n     }\n   FIRST_PARMS (prod) = first_parms;\n \n-  prod->tp.pro.code = tree_code_create_function_prototype\n-    (tok->tp.tok.chars, STORAGE_CLASS (prod), NUMERIC_TYPE (type),\n-     first_parms, tok->tp.tok.location);\n+  prod->tp.pro.code =\n+    tree_code_create_function_prototype (tok->tp.tok.chars,\n+\t\t\t\t\t STORAGE_CLASS (prod),\n+\t\t\t\t\t NUMERIC_TYPE (type),\n+\t\t\t\t\t first_parms, tok->tp.tok.location);\n }\n ;\n \n@@ -592,8 +594,7 @@ INTEGER {\n   int type_code = get_common_type (op1, op2);\n   if (!type_code)\n     YYERROR;\n-  $$ = make_plus_expression\n-     (tok, op1, op2, type_code, EXP_PLUS);\n+  $$ = make_plus_expression (tok, op1, op2, type_code, EXP_PLUS);\n }\n |expression tl_MINUS expression %prec tl_PLUS {\n   struct prod_token_parm_item *tok = $2;\n@@ -602,8 +603,7 @@ INTEGER {\n   int type_code = get_common_type (op1, op2);\n   if (!type_code)\n     YYERROR;\n-  $$ = make_plus_expression\n-     (tok, op1, op2, type_code, EXP_MINUS);\n+  $$ = make_plus_expression (tok, op1, op2, type_code, EXP_MINUS);\n }\n |expression EQUALS expression {\n   struct prod_token_parm_item *tok = $2;\n@@ -695,8 +695,9 @@ NAME LEFT_PARENTHESIS expressions_with_commas RIGHT_PARENTHESIS {\n     parms = tree_code_add_parameter (parms, var->tp.pro.code, exp->tp.pro.code);\n   }\n   type = tree_code_get_type (NUMERIC_TYPE (prod));\n-  prod->tp.pro.code = tree_code_get_expression\n-    (EXP_FUNCTION_INVOCATION, type, proto->tp.pro.code, parms, NULL);\n+  prod->tp.pro.code = tree_code_get_expression (EXP_FUNCTION_INVOCATION, type,\n+                                                proto->tp.pro.code, parms,\n+                                                NULL);\n   $$ = prod;\n }\n ;\n@@ -746,8 +747,9 @@ NAME {\n     YYERROR;\n   OP1 (prod) = $1;\n   \n-  prod->tp.pro.code = tree_code_get_expression (EXP_REFERENCE, type, \n-                                      symbol_table_entry->tp.pro.code, NULL, NULL);\n+  prod->tp.pro.code =\n+    tree_code_get_expression (EXP_REFERENCE, type, \n+\t\t\t      symbol_table_entry->tp.pro.code, NULL, NULL);\n   $$ = prod;\n }\n ;\n@@ -853,7 +855,8 @@ ensure_not_void (unsigned int type, struct prod_token_parm_item* name)\n    common type (min is signed int).  */\n \n static int \n-get_common_type (struct prod_token_parm_item *type1, struct prod_token_parm_item *type2)\n+get_common_type (struct prod_token_parm_item *type1,\n+\t\t struct prod_token_parm_item *type2)\n {\n   if (NUMERIC_TYPE (type1) == UNSIGNED_INT)\n     return UNSIGNED_INT;\n@@ -915,7 +918,8 @@ make_integer_constant (struct prod_token_parm_item* value)\n     NUMERIC_TYPE (prod) = SIGNED_INT;\n   else\n     NUMERIC_TYPE (prod) = UNSIGNED_INT;\n-  prod->tp.pro.code = tree_code_get_integer_value (tok->tp.tok.chars, tok->tp.tok.length);\n+  prod->tp.pro.code = tree_code_get_integer_value (tok->tp.tok.chars,\n+\t\t\t\t\t\t   tok->tp.tok.length);\n   return prod;\n }\n "}, {"sha": "5a3e3d10a93f5316d485a5da09e3804f755ba748", "filename": "gcc/treelang/tree1.c", "status": "modified", "additions": 31, "deletions": 33, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Ftree1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Ftree1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftree1.c?ref=7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "patch": "@@ -1,36 +1,32 @@\n-  /* \n+/* TREELANG Compiler almost main (tree1)\n+   Called by GCC's toplev.c\n \n-    TREELANG Compiler almost main (tree1)\n-    Called by GCC's toplev.c\n+   Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n+   Free Software Foundation, Inc.\n \n-    Copyright (C) 1986, 87, 89, 92-96, 1997, 1999, 2000, 2001, 2002, 2003, 2004\n-    Free Software Foundation, Inc.\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n \n-    This program is free software; you can redistribute it and/or modify it\n-    under the terms of the GNU General Public License as published by the\n-    Free Software Foundation; either version 2, or (at your option) any\n-    later version.\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.\n \n-    You should have received a copy of the GNU General Public License\n-    along with this program; if not, write to the Free Software\n-    Foundation, 59 Temple Place - Suite 330,\n-    Boston, MA 02111-1307, USA.\n+   In other words, you are welcome to use, share and improve this program.\n+   You are forbidden to forbid anyone else to use, share and improve\n+   what you give them.   Help stamp out software-hoarding!  \n \n-    In other words, you are welcome to use, share and improve this program.\n-    You are forbidden to forbid anyone else to use, share and improve\n-    what you give them.   Help stamp out software-hoarding!  \n+   ---------------------------------------------------------------------------\n \n-    ---------------------------------------------------------------------------\n-\n-    Written by Tim Josling 1999, 2000, 2001, based in part on other\n-    parts of the GCC compiler.\n-\n-*/\n+   Written by Tim Josling 1999, 2000, 2001, based in part on other\n+   parts of the GCC compiler.  */\n \n #include \"config.h\"\n #include \"system.h\"\n@@ -232,19 +228,21 @@ lookup_tree_name (struct prod_token_parm_item *prod)\n       sanity_check (this_tok);\n       if (tok->tp.tok.length != this_tok->tp.tok.length) \n         continue;\n-      if (memcmp (tok->tp.tok.chars, this_tok->tp.tok.chars, this_tok->tp.tok.length))\n+      if (memcmp (tok->tp.tok.chars, this_tok->tp.tok.chars,\n+\t\t  this_tok->tp.tok.length))\n         continue;\n+\n       if (option_parser_trace)\n         fprintf (stderr, \"Found symbol %s (%i:%i) as %i \\n\",\n-\t\t tok->tp.tok.chars, \n-\t\t tok->tp.tok.location.line, tok->tp.tok.charno,\n-\t\t NUMERIC_TYPE (this));\n+\t\t tok->tp.tok.chars, LOCATION_LINE (tok->tp.tok.location),\n+\t\t tok->tp.tok.charno, NUMERIC_TYPE (this));\n       return this;\n     }\n+\n   if (option_parser_trace)\n     fprintf (stderr, \"Not found symbol %s (%i:%i) as %i \\n\",\n-\t     tok->tp.tok.chars, \n-\t     tok->tp.tok.location.line, tok->tp.tok.charno, tok->type);\n+\t     tok->tp.tok.chars, LOCATION_LINE (tok->tp.tok.location),\n+\t     tok->tp.tok.charno, tok->type);\n   return NULL;\n }\n \n@@ -290,7 +288,7 @@ sanity_check (struct prod_token_parm_item *item)\n {\n   switch (item->category)\n     {\n-    case   token_category:\n+    case token_category:\n     case production_category:\n     case parameter_category:\n       break;"}, {"sha": "a559c5d57a00656c606ad1a9e6df9ee2dac6ba6b", "filename": "gcc/treelang/treetree.c", "status": "modified", "additions": 41, "deletions": 46, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Ftreetree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7e57da121ac70d0fc9a53c3b1f2a3657e11e209b/gcc%2Ftreelang%2Ftreetree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftreelang%2Ftreetree.c?ref=7e57da121ac70d0fc9a53c3b1f2a3657e11e209b", "patch": "@@ -1,57 +1,52 @@\n-/*\n-\n-    TREELANG Compiler interface to GCC's middle end (treetree.c)\n-    Called by the parser.\n+/* TREELANG Compiler interface to GCC's middle end (treetree.c)\n+   Called by the parser.\n \n-    If you want a working example of how to write a front end to GCC,\n-    you are in the right place.\n+   If you want a working example of how to write a front end to GCC,\n+   you are in the right place.\n \n-    Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n-    1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Copyright (C) 1988, 1992, 1993, 1994, 1995, 1996, 1997, 1998,\n+   1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.\n \n-    This code is based on toy.c written by Richard Kenner.\n+   This code is based on toy.c written by Richard Kenner.\n \n-    It was later modified by Jonathan Bartlett whose changes have all\n-    been removed (by Tim Josling).\n+   It was later modified by Jonathan Bartlett whose changes have all\n+   been removed (by Tim Josling).\n \n-    Various bits and pieces were cloned from the GCC main tree, as\n-    GCC evolved, for COBOLForGCC, by Tim Josling.\n+   Various bits and pieces were cloned from the GCC main tree, as\n+   GCC evolved, for COBOLForGCC, by Tim Josling.\n \n-    It was adapted to TREELANG by Tim Josling 2001.\n+   It was adapted to TREELANG by Tim Josling 2001.\n \n-    Updated to function-at-a-time by James A. Morrison, 2004.\n+   Updated to function-at-a-time by James A. Morrison, 2004.\n \n-    ---------------------------------------------------------------------------\n+   -----------------------------------------------------------------------\n \n-    This program is free software; you can redistribute it and/or modify it\n-    under the terms of the GNU General Public License as published by the\n-    Free Software Foundation; either version 2, or (at your option) any\n-    later version.\n+   This program is free software; you can redistribute it and/or modify it\n+   under the terms of the GNU General Public License as published by the\n+   Free Software Foundation; either version 2, or (at your option) any\n+   later version.\n \n-    This program is distributed in the hope that it will be useful,\n-    but WITHOUT ANY WARRANTY; without even the implied warranty of\n-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-    GNU General Public License for more details.\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n \n-    You should have received a copy of the GNU General Public License\n-    along with this program; if not, write to the Free Software\n-    Foundation, 59 Temple Place - Suite 330,\n-    Boston, MA 02111-1307, USA.\n+   You should have received a copy of the GNU General Public License\n+   along with this program; if not, write to the Free Software\n+   Foundation, 59 Temple Place - Suite 330,\n+   Boston, MA 02111-1307, USA.\n \n-    In other words, you are welcome to use, share and improve this program.\n-    You are forbidden to forbid anyone else to use, share and improve\n-    what you give them.   Help stamp out software-hoarding!\n+   In other words, you are welcome to use, share and improve this program.\n+   You are forbidden to forbid anyone else to use, share and improve\n+   what you give them.   Help stamp out software-hoarding!\n \n-    ---------------------------------------------------------------------------\n+   -----------------------------------------------------------------------  */\n \n- */\n-\n-/*\n-  Assumption: garbage collection is never called implicitly.  It will\n-  not be called 'at any time' when short of memory.  It will only be\n-  called explicitly at the end of each function.  This removes the\n-  need for a *lot* of bother to ensure everything is in the mark trees\n-  at all times.  */\n+/* Assumption: garbage collection is never called implicitly.  It will\n+   not be called 'at any time' when short of memory.  It will only be\n+   called explicitly at the end of each function.  This removes the\n+   need for a *lot* of bother to ensure everything is in the mark trees\n+   at all times.  */\n \n /* Note, it is OK to use GCC extensions such as long long in a compiler front\n    end.  This is because the GCC front ends are built using GCC.   */\n@@ -263,7 +258,8 @@ tree_code_if_start (tree exp, location_t loc)\n {\n   tree cond_exp, cond;\n   cond_exp = fold (build2 (NE_EXPR, boolean_type_node, exp,\n-                     fold (build1 (CONVERT_EXPR, TREE_TYPE (exp), integer_zero_node))));\n+\t\t\t   fold (build1 (CONVERT_EXPR, TREE_TYPE (exp),\n+\t\t\t\t\t integer_zero_node))));\n   SET_EXPR_LOCATION (cond_exp, loc);\n   cond = build3 (COND_EXPR, void_type_node, cond_exp, NULL_TREE,\n                  NULL_TREE);\n@@ -603,7 +599,6 @@ tree_code_create_variable (unsigned int storage_class,\n \n   TYPE_NAME (TREE_TYPE (var_decl)) = TYPE_NAME (var_type);\n   return pushdecl (copy_node (var_decl));\n-\n }\n \n \n@@ -744,8 +739,8 @@ tree_code_get_expression (unsigned int exp_type,\n \n       {\n         tree fun_ptr;\n-        fun_ptr = fold (build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (op1)),\n-                                op1));\n+        fun_ptr = fold (build1 (ADDR_EXPR,\n+                                build_pointer_type (TREE_TYPE (op1)), op1));\n         ret1 = build3 (CALL_EXPR, type, fun_ptr, nreverse (op2), NULL_TREE);\n       }\n       break;\n@@ -773,8 +768,8 @@ tree_code_add_parameter (tree list, tree proto_exp, tree exp)\n {\n   tree new_exp;\n   new_exp = tree_cons (NULL_TREE,\n-                       fold (build1 (CONVERT_EXPR, TREE_TYPE (proto_exp), exp)),\n-                       NULL_TREE);\n+                       fold (build1 (CONVERT_EXPR, TREE_TYPE (proto_exp),\n+\t\t\t\t     exp)), NULL_TREE);\n   if (!list)\n     return new_exp;\n   return chainon (new_exp, list);"}]}