{"sha": "15aba5a67c61a005497ddad766377889d2442df6", "node_id": "C_kwDOANBUbNoAKDE1YWJhNWE2N2M2MWEwMDU0OTdkZGFkNzY2Mzc3ODg5ZDI0NDJkZjY", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:00Z"}, "committer": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2021-11-12T17:33:00Z"}, "message": "aarch64: Fold aarch64_sve_op_count into aarch64_vec_op_count\n\nLater patches make aarch64 use the new vector hooks.  We then\nonly need to track one set of ops for each aarch64_vector_costs\nstructure.  This in turn means that it's more convenient to merge\naarch64_sve_op_count and aarch64_vec_op_count.\n\nThe patch also adds issue info and vec flags to aarch64_vec_op_count,\nso that the structure is more self-descriptive.  This simplifies some\nthings later.\n\ngcc/\n\t* config/aarch64/aarch64.c (aarch64_sve_op_count): Fold into...\n\t(aarch64_vec_op_count): ...this.  Add a constructor.\n\t(aarch64_vec_op_count::vec_flags): New function.\n\t(aarch64_vec_op_count::base_issue_info): Likewise.\n\t(aarch64_vec_op_count::simd_issue_info): Likewise.\n\t(aarch64_vec_op_count::sve_issue_info): Likewise.\n\t(aarch64_vec_op_count::m_issue_info): New member variable.\n\t(aarch64_vec_op_count::m_vec_flags): Likewise.\n\t(aarch64_vector_costs): Add a constructor.\n\t(aarch64_vector_costs::m_sve_ops): Change type to aarch64_vec_op_count.\n\t(aarch64_vector_costs::aarch64_vector_costs): New function.\n\tInitialize m_scalar_ops, m_advsimd_ops and m_sve_ops.\n\t(aarch64_vector_costs::count_ops): Remove vec_flags and\n\tissue_info parameters, using the new aarch64_vec_op_count\n\tfunctions instead.\n\t(aarch64_vector_costs::add_stmt_cost): Update call accordingly.\n\t(aarch64_sve_op_count::dump): Fold into...\n\t(aarch64_vec_op_count::dump): ..here.", "tree": {"sha": "10e222abf722d8431394674e1d0bea3a39a23319", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10e222abf722d8431394674e1d0bea3a39a23319"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15aba5a67c61a005497ddad766377889d2442df6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15aba5a67c61a005497ddad766377889d2442df6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15aba5a67c61a005497ddad766377889d2442df6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15aba5a67c61a005497ddad766377889d2442df6/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "526e1639aa76b0a8496b0dc3a3ff2c450229544e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/526e1639aa76b0a8496b0dc3a3ff2c450229544e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/526e1639aa76b0a8496b0dc3a3ff2c450229544e"}], "stats": {"total": 153, "additions": 96, "deletions": 57}, "files": [{"sha": "c8a3cb38473057ab35a427131863d6231fdd3000", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 96, "deletions": 57, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15aba5a67c61a005497ddad766377889d2442df6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15aba5a67c61a005497ddad766377889d2442df6/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=15aba5a67c61a005497ddad766377889d2442df6", "patch": "@@ -14707,8 +14707,16 @@ aarch64_first_cycle_multipass_dfa_lookahead_guard (rtx_insn *insn,\n /* Information about how the CPU would issue the scalar, Advanced SIMD\n    or SVE version of a vector loop, using the scheme defined by the\n    aarch64_base_vec_issue_info hierarchy of structures.  */\n-struct aarch64_vec_op_count\n+class aarch64_vec_op_count\n {\n+public:\n+  aarch64_vec_op_count (const aarch64_vec_issue_info *, unsigned int);\n+\n+  unsigned int vec_flags () const { return m_vec_flags; }\n+  const aarch64_base_vec_issue_info *base_issue_info () const;\n+  const aarch64_simd_vec_issue_info *simd_issue_info () const;\n+  const aarch64_sve_vec_issue_info *sve_issue_info () const;\n+\n   void dump () const;\n \n   /* The number of individual \"general\" operations.  See the comments\n@@ -14724,23 +14732,71 @@ struct aarch64_vec_op_count\n      operations, which in the vector code become associated with\n      reductions.  */\n   unsigned int reduction_latency = 0;\n-};\n-\n-/* Extends aarch64_vec_op_count with SVE-specific information.  */\n-struct aarch64_sve_op_count : aarch64_vec_op_count\n-{\n-  void dump () const;\n \n   /* The number of individual predicate operations.  See the comments\n      in aarch64_sve_vec_issue_info for details.  */\n   unsigned int pred_ops = 0;\n+\n+private:\n+  /* The issue information for the core.  */\n+  const aarch64_vec_issue_info *m_issue_info;\n+\n+  /* - If M_VEC_FLAGS is zero then this structure describes scalar code\n+     - If M_VEC_FLAGS & VEC_ADVSIMD is nonzero then this structure describes\n+       Advanced SIMD code.\n+     - If M_VEC_FLAGS & VEC_ANY_SVE is nonzero then this structure describes\n+       SVE code.  */\n+  unsigned int m_vec_flags;\n };\n \n+aarch64_vec_op_count::\n+aarch64_vec_op_count (const aarch64_vec_issue_info *issue_info,\n+\t\t      unsigned int vec_flags)\n+  : m_issue_info (issue_info),\n+    m_vec_flags (vec_flags)\n+{\n+}\n+\n+/* Return the base issue information (i.e. the parts that make sense\n+   for both scalar and vector code).  Return null if we have no issue\n+   information.  */\n+const aarch64_base_vec_issue_info *\n+aarch64_vec_op_count::base_issue_info () const\n+{\n+  if (auto *ret = simd_issue_info ())\n+    return ret;\n+  if (m_issue_info)\n+    return m_issue_info->scalar;\n+  return nullptr;\n+}\n+\n+/* If the structure describes vector code and we have associated issue\n+   information, return that issue information, otherwise return null.  */\n+const aarch64_simd_vec_issue_info *\n+aarch64_vec_op_count::simd_issue_info () const\n+{\n+  if (auto *ret = sve_issue_info ())\n+    return ret;\n+  if (m_issue_info && m_vec_flags)\n+    return m_issue_info->advsimd;\n+  return nullptr;\n+}\n+\n+/* If the structure describes SVE code and we have associated issue\n+   information, return that issue information, otherwise return null.  */\n+const aarch64_sve_vec_issue_info *\n+aarch64_vec_op_count::sve_issue_info () const\n+{\n+  if (m_issue_info && (m_vec_flags & VEC_ANY_SVE))\n+    return m_issue_info->sve;\n+  return nullptr;\n+}\n+\n /* Information about vector code that we're in the process of costing.  */\n class aarch64_vector_costs : public vector_costs\n {\n public:\n-  using vector_costs::vector_costs;\n+  aarch64_vector_costs (vec_info *, bool);\n \n   unsigned int add_stmt_cost (int count, vect_cost_for_stmt kind,\n \t\t\t      stmt_vec_info stmt_info, tree vectype,\n@@ -14752,8 +14808,7 @@ class aarch64_vector_costs : public vector_costs\n   void record_potential_advsimd_unrolling (loop_vec_info);\n   void analyze_loop_vinfo (loop_vec_info);\n   void count_ops (unsigned int, vect_cost_for_stmt, stmt_vec_info, tree,\n-\t\t  unsigned int, aarch64_vec_op_count *,\n-\t\t  const aarch64_base_vec_issue_info *, unsigned int);\n+\t\t  aarch64_vec_op_count *, unsigned int);\n   fractional_cost adjust_body_cost_sve (const aarch64_vec_issue_info *,\n \t\t\t\t\tfractional_cost, fractional_cost,\n \t\t\t\t\tbool, unsigned int, unsigned int *,\n@@ -14809,14 +14864,23 @@ class aarch64_vector_costs : public vector_costs\n \n   /* Used only when vectorizing loops with SVE.  It estimates the number and\n      kind of operations that the SVE loop would contain.  */\n-  aarch64_sve_op_count m_sve_ops;\n+  aarch64_vec_op_count m_sve_ops;\n \n   /* Used to detect cases in which we end up costing the same load twice,\n      once to account for results that are actually used and once to account\n      for unused results.  */\n   hash_map<nofree_ptr_hash<_stmt_vec_info>, unsigned int> m_seen_loads;\n };\n \n+aarch64_vector_costs::aarch64_vector_costs (vec_info *vinfo,\n+\t\t\t\t\t    bool costing_for_scalar)\n+  : vector_costs (vinfo, costing_for_scalar),\n+    m_scalar_ops (aarch64_tune_params.vec_costs->issue_info, 0),\n+    m_advsimd_ops (aarch64_tune_params.vec_costs->issue_info, VEC_ADVSIMD),\n+    m_sve_ops (aarch64_tune_params.vec_costs->issue_info, VEC_ANY_SVE)\n+{\n+}\n+\n /* Implement TARGET_VECTORIZE_CREATE_COSTS.  */\n vector_costs *\n aarch64_vectorize_create_costs (vec_info *vinfo, bool costing_for_scalar)\n@@ -15484,36 +15548,21 @@ aarch64_adjust_stmt_cost (vect_cost_for_stmt kind, stmt_vec_info stmt_info,\n    body of a vector loop.  Record issue information relating to the vector\n    operation in OPS, where OPS is one of m_scalar_ops, m_advsimd_ops\n    or m_sve_ops; see the comments above those variables for details.\n-   In addition:\n \n-   - VEC_FLAGS is zero if OPS is m_scalar_ops.\n-\n-   - VEC_FLAGS & VEC_ADVSIMD is nonzero if OPS is m_advsimd_ops.\n-\n-   - VEC_FLAGS & VEC_ANY_SVE is nonzero if OPS is m_sve_ops.\n-\n-   ISSUE_INFO provides the scalar, Advanced SIMD or SVE issue information\n-   associated with OPS and VEC_FLAGS.  FACTOR says how many iterations of\n-   the loop described by VEC_FLAGS would be needed to match one iteration\n-   of the vector loop in VINFO.  */\n+   FACTOR says how many iterations of the loop described by VEC_FLAGS would be\n+   needed to match one iteration of the vector loop in VINFO.  */\n void\n aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n \t\t\t\t stmt_vec_info stmt_info, tree vectype,\n-\t\t\t\t unsigned int vec_flags,\n \t\t\t\t aarch64_vec_op_count *ops,\n-\t\t\t\t const aarch64_base_vec_issue_info *issue_info,\n \t\t\t\t unsigned int factor)\n {\n-  if (!issue_info)\n+  const aarch64_base_vec_issue_info *base_issue = ops->base_issue_info ();\n+  if (!base_issue)\n     return;\n-\n-  const aarch64_simd_vec_issue_info *simd_issue = nullptr;\n-  if (vec_flags)\n-    simd_issue = static_cast<const aarch64_simd_vec_issue_info *> (issue_info);\n-\n-  const aarch64_sve_vec_issue_info *sve_issue = nullptr;\n-  if (vec_flags & VEC_ANY_SVE)\n-    sve_issue = static_cast<const aarch64_sve_vec_issue_info *> (issue_info);\n+  const aarch64_simd_vec_issue_info *simd_issue = ops->simd_issue_info ();\n+  const aarch64_sve_vec_issue_info *sve_issue = ops->sve_issue_info ();\n+  unsigned int vec_flags = ops->vec_flags ();\n \n   /* Calculate the minimum cycles per iteration imposed by a reduction\n      operation.  */\n@@ -15608,15 +15657,15 @@ aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n \t}\n       ops->loads += num_copies;\n       if (vec_flags || FLOAT_TYPE_P (vectype))\n-\tops->general_ops += issue_info->fp_simd_load_general_ops * num_copies;\n+\tops->general_ops += base_issue->fp_simd_load_general_ops * num_copies;\n       break;\n \n     case vector_store:\n     case unaligned_store:\n     case scalar_store:\n       ops->stores += num_copies;\n       if (vec_flags || FLOAT_TYPE_P (vectype))\n-\tops->general_ops += issue_info->fp_simd_store_general_ops * num_copies;\n+\tops->general_ops += base_issue->fp_simd_store_general_ops * num_copies;\n       break;\n     }\n \n@@ -15644,7 +15693,7 @@ aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n \tunsigned int base = (FLOAT_TYPE_P (type)\n \t\t\t     ? sve_issue->fp_cmp_pred_ops\n \t\t\t     : sve_issue->int_cmp_pred_ops);\n-\tm_sve_ops.pred_ops += base * num_copies;\n+\tops->pred_ops += base * num_copies;\n       }\n \n   /* Add any extra overhead associated with LD[234] and ST[234] operations.  */\n@@ -15670,7 +15719,7 @@ aarch64_vector_costs::count_ops (unsigned int count, vect_cost_for_stmt kind,\n       && STMT_VINFO_MEMORY_ACCESS_TYPE (stmt_info) == VMAT_GATHER_SCATTER)\n     {\n       unsigned int pairs = CEIL (count, 2);\n-      m_sve_ops.pred_ops += sve_issue->gather_scatter_pair_pred_ops * pairs;\n+      ops->pred_ops += sve_issue->gather_scatter_pair_pred_ops * pairs;\n       ops->general_ops += sve_issue->gather_scatter_pair_general_ops * pairs;\n     }\n }\n@@ -15740,36 +15789,32 @@ aarch64_vector_costs::add_stmt_cost (int count, vect_cost_for_stmt kind,\n       /* If we're recording a nonzero vector loop body cost for the\n \t innermost loop, also estimate the operations that would need\n \t to be issued by all relevant implementations of the loop.  */\n-      auto *issue_info = aarch64_tune_params.vec_costs->issue_info;\n       if (loop_vinfo\n-\t  && issue_info\n \t  && m_vec_flags\n \t  && where == vect_body\n \t  && (!LOOP_VINFO_LOOP (loop_vinfo)->inner || in_inner_loop_p)\n \t  && vectype\n \t  && stmt_cost != 0)\n \t{\n \t  /* Record estimates for the scalar code.  */\n-\t  count_ops (count, kind, stmt_info, vectype, 0, &m_scalar_ops,\n-\t\t     issue_info->scalar, vect_nunits_for_cost (vectype));\n+\t  count_ops (count, kind, stmt_info, vectype, &m_scalar_ops,\n+\t\t     vect_nunits_for_cost (vectype));\n \n-\t  if (aarch64_sve_mode_p (m_vinfo->vector_mode) && issue_info->sve)\n+\t  if (aarch64_sve_mode_p (m_vinfo->vector_mode)\n+\t      && m_sve_ops.base_issue_info ())\n \t    {\n \t      /* Record estimates for a possible Advanced SIMD version\n \t\t of the SVE code.  */\n-\t      count_ops (count, kind, stmt_info, vectype, VEC_ADVSIMD,\n-\t\t\t &m_advsimd_ops, issue_info->advsimd,\n+\t      count_ops (count, kind, stmt_info, vectype, &m_advsimd_ops,\n \t\t\t aarch64_estimated_sve_vq ());\n \n \t      /* Record estimates for the SVE code itself.  */\n-\t      count_ops (count, kind, stmt_info, vectype, VEC_ANY_SVE,\n-\t\t\t &m_sve_ops, issue_info->sve, 1);\n+\t      count_ops (count, kind, stmt_info, vectype, &m_sve_ops, 1);\n \t    }\n \t  else\n \t    /* Record estimates for the Advanced SIMD code.  Treat SVE like\n \t       Advanced SIMD if the CPU has no specific SVE costs.  */\n-\t    count_ops (count, kind, stmt_info, vectype, VEC_ADVSIMD,\n-\t\t       &m_advsimd_ops, issue_info->advsimd, 1);\n+\t    count_ops (count, kind, stmt_info, vectype, &m_advsimd_ops, 1);\n \t}\n \n       /* If we're applying the SVE vs. Advanced SIMD unrolling heuristic,\n@@ -15793,19 +15838,13 @@ aarch64_vec_op_count::dump () const\n \t\t   \"  store operations = %d\\n\", stores);\n   dump_printf_loc (MSG_NOTE, vect_location,\n \t\t   \"  general operations = %d\\n\", general_ops);\n+  if (sve_issue_info ())\n+    dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t     \"  predicate operations = %d\\n\", pred_ops);\n   dump_printf_loc (MSG_NOTE, vect_location,\n \t\t   \"  reduction latency = %d\\n\", reduction_latency);\n }\n \n-/* Dump information about the structure.  */\n-void\n-aarch64_sve_op_count::dump () const\n-{\n-  aarch64_vec_op_count::dump ();\n-  dump_printf_loc (MSG_NOTE, vect_location,\n-\t\t   \"  predicate operations = %d\\n\", pred_ops);\n-}\n-\n /* Use ISSUE_INFO to estimate the minimum number of cycles needed to issue\n    the operations described by OPS.  This is a very simplistic model!  */\n static fractional_cost"}]}