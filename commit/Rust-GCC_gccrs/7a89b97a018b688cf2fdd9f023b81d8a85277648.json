{"sha": "7a89b97a018b688cf2fdd9f023b81d8a85277648", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2E4OWI5N2EwMThiNjg4Y2YyZmRkOWYwMjNiODFkOGE4NTI3NzY0OA==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-11T09:51:41Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-11T09:51:41Z"}, "message": "tree-ssa-address.c: Include header file.\n\n\t* tree-ssa-address.c: Include header file.\n\t(move_hint_to_base): Return TRUE if BASE_HINT is moved to memory\n\taddress.\n\t(add_to_parts): Refactor.\n\t(addr_to_parts): New parameter.  Update use of move_hint_to_base.\n\t(create_mem_ref): Update use of addr_to_parts.  Re-associate addr\n\tin new order.\n\nFrom-SVN: r247894", "tree": {"sha": "78177b1a6288ca894fa29591bc786573bc997f50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/78177b1a6288ca894fa29591bc786573bc997f50"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7a89b97a018b688cf2fdd9f023b81d8a85277648", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a89b97a018b688cf2fdd9f023b81d8a85277648", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7a89b97a018b688cf2fdd9f023b81d8a85277648", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7a89b97a018b688cf2fdd9f023b81d8a85277648/comments", "author": null, "committer": null, "parents": [{"sha": "80ca1cfad49fbdd8e446023c5ebabf03d23a83ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80ca1cfad49fbdd8e446023c5ebabf03d23a83ef", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80ca1cfad49fbdd8e446023c5ebabf03d23a83ef"}], "stats": {"total": 191, "additions": 136, "deletions": 55}, "files": [{"sha": "96c7b3f5238707907feb5955f17124d3812cded8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a89b97a018b688cf2fdd9f023b81d8a85277648/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a89b97a018b688cf2fdd9f023b81d8a85277648/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7a89b97a018b688cf2fdd9f023b81d8a85277648", "patch": "@@ -1,3 +1,13 @@\n+2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-address.c: Include header file.\n+\t(move_hint_to_base): Return TRUE if BASE_HINT is moved to memory\n+\taddress.\n+\t(add_to_parts): Refactor.\n+\t(addr_to_parts): New parameter.  Update use of move_hint_to_base.\n+\t(create_mem_ref): Update use of addr_to_parts.  Re-associate addr\n+\tin new order.\n+\n 2017-05-11  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/53090"}, {"sha": "8257fde524049f0c39b48f5477d594b037729b0a", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 126, "deletions": 55, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7a89b97a018b688cf2fdd9f023b81d8a85277648/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7a89b97a018b688cf2fdd9f023b81d8a85277648/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=7a89b97a018b688cf2fdd9f023b81d8a85277648", "patch": "@@ -46,6 +46,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-dfa.h\"\n #include \"dumpfile.h\"\n #include \"tree-affine.h\"\n+#include \"gimplify.h\"\n \n /* FIXME: We compute address costs using RTL.  */\n #include \"tree-ssa-address.h\"\n@@ -427,9 +428,10 @@ move_fixed_address_to_symbol (struct mem_address *parts, aff_tree *addr)\n   aff_combination_remove_elt (addr, i);\n }\n \n-/* If ADDR contains an instance of BASE_HINT, move it to PARTS->base.  */\n+/* Return true if ADDR contains an instance of BASE_HINT and it's moved to\n+   PARTS->base.  */\n \n-static void\n+static bool\n move_hint_to_base (tree type, struct mem_address *parts, tree base_hint,\n \t\t   aff_tree *addr)\n {\n@@ -448,7 +450,7 @@ move_hint_to_base (tree type, struct mem_address *parts, tree base_hint,\n     }\n \n   if (i == addr->n)\n-    return;\n+    return false;\n \n   /* Cast value to appropriate pointer type.  We cannot use a pointer\n      to TYPE directly, as the back-end will assume registers of pointer\n@@ -458,6 +460,7 @@ move_hint_to_base (tree type, struct mem_address *parts, tree base_hint,\n   type = build_qualified_type (void_type_node, qual);\n   parts->base = fold_convert (build_pointer_type (type), val);\n   aff_combination_remove_elt (addr, i);\n+  return true;\n }\n \n /* If ADDR contains an address of a dereferenced pointer, move it to\n@@ -535,8 +538,7 @@ add_to_parts (struct mem_address *parts, tree elt)\n   if (POINTER_TYPE_P (type))\n     parts->base = fold_build_pointer_plus (parts->base, elt);\n   else\n-    parts->base = fold_build2 (PLUS_EXPR, type,\n-\t\t\t       parts->base, elt);\n+    parts->base = fold_build2 (PLUS_EXPR, type, parts->base, elt);\n }\n \n /* Returns true if multiplying by RATIO is allowed in an address.  Test the\n@@ -668,7 +670,8 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n /* Splits address ADDR for a memory access of type TYPE into PARTS.\n    If BASE_HINT is non-NULL, it specifies an SSA name to be used\n    preferentially as base of the reference, and IV_CAND is the selected\n-   iv candidate used in ADDR.\n+   iv candidate used in ADDR.  Store true to VAR_IN_BASE if variant\n+   part of address is split to PARTS.base.\n \n    TODO -- be more clever about the distribution of the elements of ADDR\n    to PARTS.  Some architectures do not support anything but single\n@@ -678,9 +681,8 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n    addressing modes is useless.  */\n \n static void\n-addr_to_parts (tree type, aff_tree *addr, tree iv_cand,\n-\t       tree base_hint, struct mem_address *parts,\n-               bool speed)\n+addr_to_parts (tree type, aff_tree *addr, tree iv_cand, tree base_hint,\n+\t       struct mem_address *parts, bool *var_in_base, bool speed)\n {\n   tree part;\n   unsigned i;\n@@ -698,23 +700,20 @@ addr_to_parts (tree type, aff_tree *addr, tree iv_cand,\n   /* Try to find a symbol.  */\n   move_fixed_address_to_symbol (parts, addr);\n \n-  /* No need to do address parts reassociation if the number of parts\n-     is <= 2 -- in that case, no loop invariant code motion can be\n-     exposed.  */\n-\n-  if (!base_hint && (addr->n > 2))\n+  /* Since at the moment there is no reliable way to know how to\n+     distinguish between pointer and its offset, we decide if var\n+     part is the pointer based on guess.  */\n+  *var_in_base = (base_hint != NULL && parts->symbol == NULL);\n+  if (*var_in_base)\n+    *var_in_base = move_hint_to_base (type, parts, base_hint, addr);\n+  else\n     move_variant_to_index (parts, addr, iv_cand);\n \n-  /* First move the most expensive feasible multiplication\n-     to index.  */\n+  /* First move the most expensive feasible multiplication to index.  */\n   if (!parts->index)\n     most_expensive_mult_to_index (type, parts, addr, speed);\n \n-  /* Try to find a base of the reference.  Since at the moment\n-     there is no reliable way how to distinguish between pointer and its\n-     offset, this is just a guess.  */\n-  if (!parts->symbol && base_hint)\n-    move_hint_to_base (type, parts, base_hint, addr);\n+  /* Move pointer into base.  */\n   if (!parts->symbol && !parts->base)\n     move_pointer_to_base (parts, addr);\n \n@@ -756,20 +755,61 @@ tree\n create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \t\ttree alias_ptr_type, tree iv_cand, tree base_hint, bool speed)\n {\n+  bool var_in_base;\n   tree mem_ref, tmp;\n   struct mem_address parts;\n \n-  addr_to_parts (type, addr, iv_cand, base_hint, &parts, speed);\n+  addr_to_parts (type, addr, iv_cand, base_hint, &parts, &var_in_base, speed);\n   gimplify_mem_ref_parts (gsi, &parts);\n   mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n   if (mem_ref)\n     return mem_ref;\n \n   /* The expression is too complicated.  Try making it simpler.  */\n \n+  /* Merge symbol into other parts.  */\n+  if (parts.symbol)\n+    {\n+      tmp = parts.symbol;\n+      parts.symbol = NULL_TREE;\n+      gcc_assert (is_gimple_val (tmp));\n+\n+      if (parts.base)\n+\t{\n+\t  gcc_assert (useless_type_conversion_p (sizetype,\n+\t\t\t\t\t\t TREE_TYPE (parts.base)));\n+\n+\t  if (parts.index)\n+\t    {\n+\t      /* Add the symbol to base, eventually forcing it to register.  */\n+\t      tmp = fold_build_pointer_plus (tmp, parts.base);\n+\t      tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n+\t\t\t\t\t\tis_gimple_mem_ref_addr,\n+\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\tGSI_SAME_STMT);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Move base to index, then move the symbol to base.  */\n+\t      parts.index = parts.base;\n+\t    }\n+\t  parts.base = tmp;\n+\t}\n+      else\n+\tparts.base = tmp;\n+\n+      mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n+      if (mem_ref)\n+\treturn mem_ref;\n+    }\n+\n+  /* Move multiplication to index by transforming address expression:\n+       [... + index << step + ...]\n+     into:\n+       index' = index << step;\n+       [... + index' + ,,,].  */\n   if (parts.step && !integer_onep (parts.step))\n     {\n-      /* Move the multiplication to index.  */\n       gcc_assert (parts.index);\n       parts.index = force_gimple_operand_gsi (gsi,\n \t\t\t\tfold_build2 (MULT_EXPR, sizetype,\n@@ -782,69 +822,100 @@ create_mem_ref (gimple_stmt_iterator *gsi, tree type, aff_tree *addr,\n \treturn mem_ref;\n     }\n \n-  if (parts.symbol)\n+  /* Add offset to invariant part by transforming address expression:\n+       [base + index + offset]\n+     into:\n+       base' = base + offset;\n+       [base' + index]\n+     or:\n+       index' = index + offset;\n+       [base + index']\n+     depending on which one is invariant.  */\n+  if (parts.offset && !integer_zerop (parts.offset))\n     {\n-      tmp = parts.symbol;\n-      gcc_assert (is_gimple_val (tmp));\n+      tree old_base = unshare_expr (parts.base);\n+      tree old_index = unshare_expr (parts.index);\n+      tree old_offset = unshare_expr (parts.offset);\n \n-      /* Add the symbol to base, eventually forcing it to register.  */\n-      if (parts.base)\n+      tmp = parts.offset;\n+      parts.offset = NULL_TREE;\n+      /* Add offset to invariant part.  */\n+      if (!var_in_base)\n \t{\n-\t  gcc_assert (useless_type_conversion_p\n-\t\t\t\t(sizetype, TREE_TYPE (parts.base)));\n-\n-\t  if (parts.index)\n+\t  if (parts.base)\n \t    {\n-\t      parts.base = force_gimple_operand_gsi_1 (gsi,\n-\t\t\tfold_build_pointer_plus (tmp, parts.base),\n-\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n+\t      tmp = fold_build_pointer_plus (parts.base, tmp);\n+\t      tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n+\t\t\t\t\t\tis_gimple_mem_ref_addr,\n+\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\tGSI_SAME_STMT);\n \t    }\n-\t  else\n+\t  parts.base = tmp;\n+\t}\n+      else\n+\t{\n+\t  if (parts.index)\n \t    {\n-\t      parts.index = parts.base;\n-\t      parts.base = tmp;\n+\t      tmp = fold_build_pointer_plus (parts.index, tmp);\n+\t      tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n+\t\t\t\t\t\tis_gimple_mem_ref_addr,\n+\t\t\t\t\t\tNULL_TREE, true,\n+\t\t\t\t\t\tGSI_SAME_STMT);\n \t    }\n+\t  parts.index = tmp;\n \t}\n-      else\n-\tparts.base = tmp;\n-      parts.symbol = NULL_TREE;\n \n       mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n+\n+      /* Restore parts.base, index and offset so that we can check if\n+\t [base + offset] addressing mode is supported in next step.\n+\t This is necessary for targets only support [base + offset],\n+\t but not [base + index] addressing mode.  */\n+      parts.base = old_base;\n+      parts.index = old_index;\n+      parts.offset = old_offset;\n     }\n \n+  /* Transform [base + index + ...] into:\n+       base' = base + index;\n+       [base' + ...].  */\n   if (parts.index)\n     {\n+      tmp = parts.index;\n+      parts.index = NULL_TREE;\n       /* Add index to base.  */\n       if (parts.base)\n \t{\n-\t  parts.base = force_gimple_operand_gsi_1 (gsi,\n-\t\t\tfold_build_pointer_plus (parts.base, parts.index),\n-\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n+\t  tmp = fold_build_pointer_plus (parts.base, tmp);\n+\t  tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n+\t\t\t\t\t    is_gimple_mem_ref_addr,\n+\t\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n \t}\n-      else\n-\tparts.base = parts.index;\n-      parts.index = NULL_TREE;\n+      parts.base = tmp;\n \n       mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)\n \treturn mem_ref;\n     }\n \n+  /* Transform [base + offset] into:\n+       base' = base + offset;\n+       [base'].  */\n   if (parts.offset && !integer_zerop (parts.offset))\n     {\n-      /* Try adding offset to base.  */\n+      tmp = parts.offset;\n+      parts.offset = NULL_TREE;\n+      /* Add offset to base.  */\n       if (parts.base)\n \t{\n-\t  parts.base = force_gimple_operand_gsi_1 (gsi,\n-\t\t\tfold_build_pointer_plus (parts.base, parts.offset),\n-\t\t\tis_gimple_mem_ref_addr, NULL_TREE, true, GSI_SAME_STMT);\n+\t  tmp = fold_build_pointer_plus (parts.base, tmp);\n+\t  tmp = force_gimple_operand_gsi_1 (gsi, tmp,\n+\t\t\t\t\t    is_gimple_mem_ref_addr,\n+\t\t\t\t\t    NULL_TREE, true, GSI_SAME_STMT);\n \t}\n-      else\n-\tparts.base = parts.offset;\n-\n-      parts.offset = NULL_TREE;\n+      parts.base = tmp;\n \n       mem_ref = create_mem_ref_raw (type, alias_ptr_type, &parts, true);\n       if (mem_ref)"}]}