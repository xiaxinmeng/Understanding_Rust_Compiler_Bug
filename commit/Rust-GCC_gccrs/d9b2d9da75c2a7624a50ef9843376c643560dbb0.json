{"sha": "d9b2d9da75c2a7624a50ef9843376c643560dbb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDliMmQ5ZGE3NWMyYTc2MjRhNTBlZjk4NDMzNzZjNjQzNTYwZGJiMA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "1999-12-05T00:49:26Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "1999-12-05T00:49:26Z"}, "message": "cp-tree.def (SCOPE_STMT): Take one operand.\n\n\t* cp-tree.def (SCOPE_STMT): Take one operand.\n\t* cp-tree.h (SCOPE_STMT_BLOCK): New macro.\n\t(SCOPE_NULLIFIED_P): Redefine.\n\t(SCOPE_NO_CLEANUPS_P): New macro.\n\t(add_scope_stmt): Change prototype.\n\t* decl.c (poplevel): Tidy.  Warn about unused variables here.\n\tRecord SCOPE_STMT_BLOCKs.\n\t(finish_function): Keep DECL_INITIAL for functions that might be\n\tinlined.\n\t* ir.texi: Document SCOPE_NO_CLEANUPS_P.\n\t* semantics.c: Include rtl.h.\n\t(add_scope_stmt): Return the new scope statement and, for an\n\tend-of-scope statement, its matching begin statement.  Don't set\n\tSCOPE_NULLIFIED_P.\n\t(do_pushlevel): Simplify, now that we are always\n\tfunction-at-a-time.\n\t(do_poplevel): Likewise.  Record SCOPE_STMT_BLOCKs.\n\t(expand_stmt): Don't call expand_start_bindings or\n\texpand_end_bindings for a scope with SCOPE_NO_CLEANUPS_P set.\n\t* tree.c (copy_tree_r): Clear SCOPE_STMT_BLOCK rather than setting\n\tSCOPE_NULLIFIED_P.\n\nFrom-SVN: r30779", "tree": {"sha": "5dbc0fc3b366c061db6ce54fee8b5bca88b6eb07", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5dbc0fc3b366c061db6ce54fee8b5bca88b6eb07"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d9b2d9da75c2a7624a50ef9843376c643560dbb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b2d9da75c2a7624a50ef9843376c643560dbb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d9b2d9da75c2a7624a50ef9843376c643560dbb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d9b2d9da75c2a7624a50ef9843376c643560dbb0/comments", "author": null, "committer": null, "parents": [{"sha": "2c0f17dc4f33028746fa39329f1779a98ad8b0ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c0f17dc4f33028746fa39329f1779a98ad8b0ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c0f17dc4f33028746fa39329f1779a98ad8b0ac"}], "stats": {"total": 199, "additions": 139, "deletions": 60}, "files": [{"sha": "d67e30d98e10ca7ec4718d4e6a6ff6fc3a753b04", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -1,5 +1,27 @@\n 1999-12-04  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* cp-tree.def (SCOPE_STMT): Take one operand.\n+\t* cp-tree.h (SCOPE_STMT_BLOCK): New macro.\n+\t(SCOPE_NULLIFIED_P): Redefine.\n+\t(SCOPE_NO_CLEANUPS_P): New macro.\n+\t(add_scope_stmt): Change prototype.\n+\t* decl.c (poplevel): Tidy.  Warn about unused variables here.\n+\tRecord SCOPE_STMT_BLOCKs.\n+\t(finish_function): Keep DECL_INITIAL for functions that might be\n+\tinlined.\n+\t* ir.texi: Document SCOPE_NO_CLEANUPS_P.\n+\t* semantics.c: Include rtl.h.\n+\t(add_scope_stmt): Return the new scope statement and, for an\n+\tend-of-scope statement, its matching begin statement.  Don't set\n+\tSCOPE_NULLIFIED_P.\n+\t(do_pushlevel): Simplify, now that we are always\n+\tfunction-at-a-time.\n+\t(do_poplevel): Likewise.  Record SCOPE_STMT_BLOCKs.\n+\t(expand_stmt): Don't call expand_start_bindings or\n+\texpand_end_bindings for a scope with SCOPE_NO_CLEANUPS_P set.\n+\t* tree.c (copy_tree_r): Clear SCOPE_STMT_BLOCK rather than setting\n+\tSCOPE_NULLIFIED_P.\n+\t\n \t* decl2.c (pending_statics_used): Make it a macro.\n \t(saved_inlines_used): Likewise.\n \t(finish_static_data_member_decl): Use VARRAY_PUSH_TREE."}, {"sha": "71c1d8d1ab5054781f8ca3ccec8b7254581fd1b2", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -254,8 +254,9 @@ DEFTREECODE (START_CATCH_STMT, \"start_catch_stmt\", 'e', 0)\n    SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n    SCOPE_END_P holds, then this is the end of a scope.  If\n    SCOPE_NULLIFIED_P holds then there turned out to be no variables in\n-   this scope.  */\n-DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 0)\n+   this scope.  The SCOPE_STMT_BLOCK is the BLOCK containing the\n+   variables declared in this scope.  */\n+DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n DEFTREECODE (CTOR_INITIALIZER, \"ctor_initializer\", 'e', 2)\n DEFTREECODE (CASE_LABEL, \"case_label\", 'e', 2)\n DEFTREECODE (RETURN_INIT, \"return_init\", 'e', 2)"}, {"sha": "d31a6ce8963c8eb592170b7375320b983d00cd8c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -66,7 +66,7 @@ Boston, MA 02111-1307, USA.  */\n       (TREE_REFERENCE_EXPR) (in NON_LVALUE_EXPR) (commented-out).\n       ICS_BAD_FLAG (in _CONV)\n       FN_TRY_BLOCK_P (in TRY_BLOCK)\n-      SCOPE_NULLIFIED_P (in SCOPE_STMT)\n+      SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n    4: BINFO_NEW_VTABLE_MARKED.\n       TREE_HAS_CONSTRUCTOR (in INDIRECT_REF, SAVE_EXPR, CONSTRUCTOR,\n           or FIELD_DECL).\n@@ -2697,6 +2697,10 @@ extern int flag_new_for_scope;\n #define SCOPE_END_P(NODE) \\\n   (!SCOPE_BEGIN_P (SCOPE_STMT_CHECK (NODE)))\n \n+/* The BLOCK containing the declarations contained in this scope.  */\n+#define SCOPE_STMT_BLOCK(NODE) \\\n+  (TREE_OPERAND (SCOPE_STMT_CHECK (NODE), 0))\n+\n /* Nonzero if this CTOR_STMT is for the beginning of a constructor.  */\n #define CTOR_BEGIN_P(NODE) \\\n   (TREE_LANG_FLAG_0 (CTOR_STMT_CHECK (NODE)))\n@@ -2707,6 +2711,12 @@ extern int flag_new_for_scope;\n \n /* Nonzero for a SCOPE_STMT if there were no variables in this scope.  */\n #define SCOPE_NULLIFIED_P(NODE) \\\n+  (SCOPE_STMT_BLOCK ((NODE)) == NULL_TREE)\n+\n+/* Nonzero for a SCOPE_STMT which represents a lexical scope, but\n+   which should be treated as non-existant from the point of view of\n+   running cleanup actions.  */\n+#define SCOPE_NO_CLEANUPS_P(NODE) \\\n   (TREE_LANG_FLAG_3 (SCOPE_STMT_CHECK (NODE)))\n \n /* Nonzero for a SCOPE_STMT if this statement is for a partial scope.\n@@ -3969,7 +3979,7 @@ extern void expand_body                         PROTO((tree));\n extern void begin_stmt_tree                     PROTO((tree *));\n extern void finish_stmt_tree                    PROTO((tree *));\n extern void prep_stmt                           PROTO((tree));\n-extern void add_scope_stmt                      PROTO((int, int));\n+extern tree add_scope_stmt                      PROTO((int, int));\n extern void do_pushlevel                        PROTO((void));\n extern tree do_poplevel                         PROTO((void));\n /* Non-zero if we are presently building a statement tree, rather"}, {"sha": "20915577f89a0a029b412bdaeeb2afc24659a0ca", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -1170,7 +1170,6 @@ poplevel (keep, reverse, functionbody)\n \n   /* Output any nested inline functions within this block\n      if they weren't already output.  */\n-\n   for (decl = decls; decl; decl = TREE_CHAIN (decl))\n     if (TREE_CODE (decl) == FUNCTION_DECL\n \t&& ! TREE_ASM_WRITTEN (decl)\n@@ -1191,10 +1190,17 @@ poplevel (keep, reverse, functionbody)\n \t  }\n       }\n \n+  /* When not in function-at-a-time mode, expand_end_bindings will\n+     warn about unused variables.  But, in function-at-a-time mode\n+     expand_end_bindings is not passed the list of variables in the\n+     current scope, and therefore no warning is emitted.  So, we\n+     explicitly warn here.  */\n+  if (!processing_template_decl)\n+    warn_about_unused_variables (getdecls ());\n+\n   /* If there were any declarations or structure tags in that level,\n      or if this level is a function body,\n      create a BLOCK to record them for the life of this function.  */\n-\n   block = NULL_TREE;\n   block_previously_created = (current_binding_level->this_block != NULL_TREE);\n   if (block_previously_created)\n@@ -1227,7 +1233,6 @@ poplevel (keep, reverse, functionbody)\n     }\n \n   /* In each subblock, record that this is its superior.  */\n-\n   if (keep >= 0)\n     for (link = subblocks; link; link = TREE_CHAIN (link))\n       BLOCK_SUPERCONTEXT (link) = block;\n@@ -1406,23 +1411,28 @@ poplevel (keep, reverse, functionbody)\n     current_binding_level->blocks\n       = chainon (current_binding_level->blocks, subblocks);\n \n+  /* Each and every BLOCK node created here in `poplevel' is important\n+     (e.g. for proper debugging information) so if we created one\n+     earlier, mark it as \"used\".  */\n+  if (block)\n+    TREE_USED (block) = 1;\n+\n   /* Take care of compiler's internal binding structures.  */\n   if (tmp == 2)\n     {\n-      add_scope_stmt (/*begin_p=*/0, /*partial_p=*/1);\n-      /* Each and every BLOCK node created here in `poplevel' is important\n-\t (e.g. for proper debugging information) so if we created one\n-\t earlier, mark it as \"used\".  */\n+      tree scope_stmts;\n+\n+      scope_stmts \n+\t= add_scope_stmt (/*begin_p=*/0, /*partial_p=*/1);\n       if (block)\n-\tTREE_USED (block) = 1;\n+\t{\n+\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n+\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n+\t}\n+\n       block = poplevel (keep, reverse, functionbody);\n     }\n \n-  /* Each and every BLOCK node created here in `poplevel' is important\n-     (e.g. for proper debugging information) so if we created one\n-     earlier, mark it as \"used\".  */\n-  if (block)\n-    TREE_USED (block) = 1;\n   return block;\n }\n \n@@ -13777,7 +13787,8 @@ finish_function (lineno, flags)\n \n   --function_depth;\n \n-  if (!DECL_SAVED_INSNS (fndecl) && !DECL_SAVED_FUNCTION_DATA (fndecl))\n+  if (!DECL_SAVED_INSNS (fndecl) && !DECL_SAVED_FUNCTION_DATA (fndecl)\n+      && !(flag_inline_trees && DECL_INLINE (fndecl)))\n     {\n       tree t;\n "}, {"sha": "cb6e1385d1fd88fbc8877d62d5f10f2f375e5a6e", "filename": "gcc/cp/ir.texi", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fir.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fir.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fir.texi?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -1374,9 +1374,9 @@ A scope-statement represents the beginning or end of a scope.  If\n scope; if @code{SCOPE_END_P} holds this statement represents the end of\n a scope.  On exit from a scope, all cleanups from @code{CLEANUP_STMT}s\n occurring in the scope must be run, in reverse order to the order in\n-which they were encountered.  If @code{SCOPE_NULLIFIED_P} holds of the\n-scope, back-ends should behave as if the @code{SCOPE_STMT} were not\n-present at all.\n+which they were encountered.  If @code{SCOPE_NULLIFIED_P} or\n+@code{SCOPE_NO_CLEANUPS_P} holds of the scope, back-ends should behave\n+as if the @code{SCOPE_STMT} were not present at all.\n \n @item START_CATCH_STMT\n "}, {"sha": "028279f820952d7e7743358cf421a514722dc7ee", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 53, "deletions": 38, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -33,6 +33,7 @@\n #include \"toplev.h\"\n #include \"flags.h\"\n #include \"ggc.h\"\n+#include \"rtl.h\"\n \n /* There routines provide a modular interface to perform many parsing\n    operations.  They may therefore be used during actual parsing, or\n@@ -1264,38 +1265,44 @@ setup_vtbl_ptr ()\n /* Add a scope-statement to the statement-tree.  BEGIN_P indicates\n    whether this statements opens or closes a scope.  PARTIAL_P is true\n    for a partial scope, i.e, the scope that begins after a label when\n-   an object that needs a cleanup is created.  */\n+   an object that needs a cleanup is created.  If BEGIN_P is nonzero,\n+   returns a new TREE_LIST representing the top of the SCOPE_STMT\n+   stack.  The TREE_PURPOSE is the new SCOPE_STMT.  If BEGIN_P is\n+   zero, returns a TREE_LIST whose TREE_VALUE is the new SCOPE_STMT,\n+   and whose TREE_PURPOSE is the matching SCOPE_STMT iwth\n+   SCOPE_BEGIN_P set.  */\n \n-void\n+tree\n add_scope_stmt (begin_p, partial_p)\n      int begin_p;\n      int partial_p;\n {\n   tree ss;\n+  tree top;\n \n   /* Build the statement.  */\n-  ss = build_min_nt (SCOPE_STMT);\n+  ss = build_min_nt (SCOPE_STMT, NULL_TREE);\n   SCOPE_BEGIN_P (ss) = begin_p;\n   SCOPE_PARTIAL_P (ss) = partial_p;\n \n-  /* If we're finishing a scope, figure out whether the scope was\n-     really necessary.  */\n-  if (!begin_p)\n-    {\n-      SCOPE_NULLIFIED_P (ss) = !kept_level_p ();\n-      SCOPE_NULLIFIED_P (TREE_VALUE (current_scope_stmt_stack))\n-\t= SCOPE_NULLIFIED_P (ss);\n-    }\n-\n   /* Keep the scope stack up to date.  */\n   if (begin_p)\n-    current_scope_stmt_stack \n-      = tree_cons (NULL_TREE, ss, current_scope_stmt_stack);\n+    {\n+      current_scope_stmt_stack \n+\t= tree_cons (ss, NULL_TREE, current_scope_stmt_stack);\n+      top = current_scope_stmt_stack;\n+    }\n   else\n-    current_scope_stmt_stack = TREE_CHAIN (current_scope_stmt_stack);\n+    {\n+      top = current_scope_stmt_stack;\n+      TREE_VALUE (top) = ss;\n+      current_scope_stmt_stack = TREE_CHAIN (top);\n+    }\n \n   /* Add the new statement to the statement-tree.  */\n   add_tree (ss);\n+\n+  return top;\n }\n \n /* Begin a new scope.  */\n@@ -1313,8 +1320,9 @@ do_pushlevel ()\n       pushlevel (0);\n       if (!building_stmt_tree ()\n \t  && !current_function->x_whole_function_mode_p)\n-\texpand_start_bindings (0);\n-      else if (building_stmt_tree () && !processing_template_decl)\n+\tmy_friendly_abort (19991129);\n+\n+      if (building_stmt_tree () && !processing_template_decl)\n \tadd_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n     }\n }\n@@ -1324,28 +1332,27 @@ do_pushlevel ()\n tree\n do_poplevel ()\n {\n-  tree t = NULL_TREE;\n+  tree block = NULL_TREE;\n \n   if (stmts_are_full_exprs_p)\n     {\n-      if (!building_stmt_tree ()\n-\t  && !current_function->x_whole_function_mode_p)\n-\texpand_end_bindings (getdecls (), kept_level_p (), 0);\n-      else if (building_stmt_tree () && !processing_template_decl)\n+      tree scope_stmts;\n+      int keep = kept_level_p ();\n+\n+      if (building_stmt_tree () && !processing_template_decl)\n+\tscope_stmts = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n+      else\n+\tscope_stmts = NULL_TREE;\n+\n+      block = poplevel (kept_level_p (), 1, 0);\n+      if (block && !processing_template_decl)\n \t{\n-\t  add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-\n-\t  /* When not in function-at-a-time mode, expand_end_bindings\n-\t     will warn about unused variables.  But, in\n-\t     function-at-a-time mode expand_end_bindings is not passed\n-\t     the list of variables in the current scope, and therefore\n-\t     no warning is emitted.  So, we explicitly warn here.  */\n-\t  warn_about_unused_variables (getdecls ());\n+\t  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope_stmts)) = block;\n+\t  SCOPE_STMT_BLOCK (TREE_VALUE (scope_stmts)) = block;\n \t}\n-\n-      t = poplevel (kept_level_p (), 1, 0);\n     }\n-  return t;\n+\n+  return block;\n }\n \n /* Finish a parenthesized expression EXPR.  */\n@@ -2473,11 +2480,19 @@ expand_stmt (t)\n \t  break;\n \n \tcase SCOPE_STMT:\n-\t  if (SCOPE_BEGIN_P (t))\n-\t    expand_start_bindings (2 * SCOPE_NULLIFIED_P (t));\n-\t  else if (SCOPE_END_P (t))\n-\t    expand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), \n-\t\t\t\t SCOPE_PARTIAL_P (t));\n+\t  if (!SCOPE_NO_CLEANUPS_P (t))\n+\t    {\n+\t      if (SCOPE_BEGIN_P (t))\n+\t\texpand_start_bindings (2 * SCOPE_NULLIFIED_P (t));\n+\t      else if (SCOPE_END_P (t))\n+\t\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), \n+\t\t\t\t     SCOPE_PARTIAL_P (t));\n+\t    }\n+\t  else if (!SCOPE_NULLIFIED_P (t))\n+\t    emit_note (NULL,\n+\t\t       (SCOPE_BEGIN_P (t) \n+\t\t\t? NOTE_INSN_BLOCK_BEG\n+\t\t\t: NOTE_INSN_BLOCK_END));\n \t  break;\n \n \tcase RETURN_INIT:"}, {"sha": "da15a2867dbdbcc3e43952333eefbd22e5dfbb2c", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -1821,7 +1821,7 @@ copy_tree_r (tp, walk_subtrees, data)\n       /* For now, we don't update BLOCKs when we make copies.  So, we\n \t have to nullify all scope-statements.  */\n       if (TREE_CODE (*tp) == SCOPE_STMT)\n-\tSCOPE_NULLIFIED_P (*tp) = 1;\n+\tSCOPE_STMT_BLOCK (*tp) = NULL_TREE;\n     }\n   else if (code == TEMPLATE_TEMPLATE_PARM)\n     /* These must be copied specially.  */"}, {"sha": "2b95273cd8b5e2563d3d31c4a9dff158eac92e31", "filename": "gcc/testsuite/g++.old-deja/g++.other/goto2.C", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d9b2d9da75c2a7624a50ef9843376c643560dbb0/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.other%2Fgoto2.C?ref=d9b2d9da75c2a7624a50ef9843376c643560dbb0", "patch": "@@ -0,0 +1,20 @@\n+// Build don't link:\n+// Origin: Mark Mitchell <mark@codesourcery.com>\n+// Special g++ Options: -Wunused\n+\n+struct S\n+{\n+  S ();\n+  ~S ();\n+};\n+\n+void f ()\n+{\n+  {\n+    S s1;\n+    int j; // WARNING - unused\n+    \n+  t:       // WARNING - unused\n+    S s2;\n+  }\n+}"}]}