{"sha": "b511626828a636ed6310cd94c4fa78365450fb34", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjUxMTYyNjgyOGE2MzZlZDYzMTBjZDk0YzRmYTc4MzY1NDUwZmIzNA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2014-06-17T20:54:14Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2014-06-17T20:54:14Z"}, "message": "check.c (gfc_check_atomic, [...]): Use argument for GFC_ISYM_CAF_GET.\n\ngcc/fortran/\n2014-06-17  Tobias Burnus  <burnus@net-b.de>\n\n        * check.c (gfc_check_atomic, gfc_check_atomic_def):\n        Use argument for GFC_ISYM_CAF_GET.\n        * resolve.c (resolve_variable): Enable CAF_GET insertion.\n        (resolve_lock_unlock): Remove GFC_ISYM_CAF_GET.\n        (resolve_ordinary_assign): Enable CAF_SEND insertion.\n        * trans-const.c (gfc_build_string_const,\n        gfc_build_wide_string_const): Set TYPE_STRING_FLAG.\n        * trans-decl.c (gfor_fndecl_caf_get, gfor_fndecl_caf_send,\n        gfor_fndecl_caf_sendget): New global variables.\n        (gfc_build_builtin_function_decls): Initialize them;\n        update co_min/max/sum initialization.\n        * trans-expr.c (gfc_get_tree_for_caf_expr): Renamed from\n        get_tree_for_caf_expr and removed static.\n        (gfc_conv_procedure_call): Update call.\n        * trans-intrinsic.c (caf_get_image_index,\n        conv_caf_vector_subscript_elem, conv_caf_vector_subscript,\n        get_caf_token_offset, gfc_conv_intrinsic_caf_get,\n        conv_caf_send): New.\n        (gfc_conv_intrinsic_function, gfc_conv_intrinsic_subroutine,\n        gfc_walk_intrinsic_function): Handle CAF_GET and CAF_SEND.\n        (conv_co_minmaxsum): Update call for remove unused vector\n        subscript.\n        (conv_intrinsic_atomic_def, conv_intrinsic_atomic_ref):\n        Skip a CAF_GET of the argument.\n        * trans-types.c (gfc_get_caf_vector_type): New.\n        * trans-types.h (gfc_get_caf_vector_type): New.\n        * trans.h (gfor_fndecl_caf_get, gfor_fndecl_caf_send,\n        gfor_fndecl_caf_sendget): New global variables.\n        (gfc_get_tree_for_caf_expr): New prototypes.\n\nlibgfortran/\n2014-06-17  Tobias Burnus  <burnus@net-b.de>\n\n        * caf/libcaf.h (gfc_descriptor_t): New typedef.\n        (caf_vector_t): Update.\n        (_gfortran_caf_co_sum, _gfortran_caf_co_max, _gfortran_caf_co_min):\n        Remove vector-subscript argument.\n        (_gfortran_caf_co_send, _gfortran_caf_co_get,\n        _gfortran_caf_co_sendget): New.\n        * caf/single.c (_gfortran_caf_co_sum, _gfortran_caf_co_max,\n        _gfortran_caf_co_min): Remove vector-subscript argument.\n        (_gfortran_caf_co_send, _gfortran_caf_co_get,\n        _gfortran_caf_co_sendget): New.\n\ngcc/testsuite/\n2014-06-17  Tobias Burnus  <burnus@net-b.de>\n            Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n\n        * gfortran.dg/coarray/send_array.f90: New.\n        * gfortran.dg/coarray/get_array.f90: New.\n        * gfortran.dg/coarray/sendget_array.f90: New.\n        * gfortran.dg/coarray/collectives_1.f90: Correct subroutine\n        names.\n        * gfortran.dg/coarray/collectives_2.f90: New.\n\n\n\nCo-Authored-By: Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n\nFrom-SVN: r211748", "tree": {"sha": "96324659ad7bf83699d956687f06a317bffeb7e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96324659ad7bf83699d956687f06a317bffeb7e3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b511626828a636ed6310cd94c4fa78365450fb34", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b511626828a636ed6310cd94c4fa78365450fb34", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b511626828a636ed6310cd94c4fa78365450fb34", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b511626828a636ed6310cd94c4fa78365450fb34/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dc3368d0f58b7385875a916689a1193e5716a14e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc3368d0f58b7385875a916689a1193e5716a14e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc3368d0f58b7385875a916689a1193e5716a14e"}], "stats": {"total": 2117, "additions": 2076, "deletions": 41}, "files": [{"sha": "262858d6edfd3bbe29720debcfb5d2e668dda1cd", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -1,3 +1,35 @@\n+2014-06-17  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* check.c (gfc_check_atomic, gfc_check_atomic_def):\n+\tUse argument for GFC_ISYM_CAF_GET.\n+\t* resolve.c (resolve_variable): Enable CAF_GET insertion.\n+\t(resolve_lock_unlock): Remove GFC_ISYM_CAF_GET.\n+\t(resolve_ordinary_assign): Enable CAF_SEND insertion.\n+\t* trans-const.c (gfc_build_string_const,\n+\tgfc_build_wide_string_const): Set TYPE_STRING_FLAG.\n+\t* trans-decl.c (gfor_fndecl_caf_get, gfor_fndecl_caf_send,\n+\tgfor_fndecl_caf_sendget): New global variables.\n+\t(gfc_build_builtin_function_decls): Initialize them;\n+\tupdate co_min/max/sum initialization.\n+\t* trans-expr.c (gfc_get_tree_for_caf_expr): Renamed from\n+\tget_tree_for_caf_expr and removed static.\n+\t(gfc_conv_procedure_call): Update call.\n+\t* trans-intrinsic.c (caf_get_image_index,\n+\tconv_caf_vector_subscript_elem, conv_caf_vector_subscript,\n+\tget_caf_token_offset, gfc_conv_intrinsic_caf_get,\n+\tconv_caf_send): New.\n+\t(gfc_conv_intrinsic_function, gfc_conv_intrinsic_subroutine,\n+\tgfc_walk_intrinsic_function): Handle CAF_GET and CAF_SEND.\n+\t(conv_co_minmaxsum): Update call for remove unused vector\n+\tsubscript.\n+\t(conv_intrinsic_atomic_def, conv_intrinsic_atomic_ref):\n+\tSkip a CAF_GET of the argument.\n+\t* trans-types.c (gfc_get_caf_vector_type): New.\n+\t* trans-types.h (gfc_get_caf_vector_type): New.\n+\t* trans.h (gfor_fndecl_caf_get, gfor_fndecl_caf_send,\n+\tgfor_fndecl_caf_sendget): New global variables.\n+\t(gfc_get_tree_for_caf_expr): New prototypes.\n+\n 2014-06-15  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* trans-common.c (build_common_decl): Use"}, {"sha": "bd3eff681568bd33c66f690cd65771d9251f5384", "filename": "gcc/fortran/check.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -1008,6 +1008,11 @@ gfc_check_atan2 (gfc_expr *y, gfc_expr *x)\n static bool\n gfc_check_atomic (gfc_expr *atom, gfc_expr *value)\n {\n+  if (atom->expr_type == EXPR_FUNCTION\n+      && atom->value.function.isym\n+      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom = atom->value.function.actual->expr;\n+\n   if (!(atom->ts.type == BT_INTEGER && atom->ts.kind == gfc_atomic_int_kind)\n       && !(atom->ts.type == BT_LOGICAL\n \t   && atom->ts.kind == gfc_atomic_logical_kind))\n@@ -1040,6 +1045,11 @@ gfc_check_atomic (gfc_expr *atom, gfc_expr *value)\n bool\n gfc_check_atomic_def (gfc_expr *atom, gfc_expr *value)\n {\n+  if (atom->expr_type == EXPR_FUNCTION\n+      && atom->value.function.isym\n+      && atom->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom = atom->value.function.actual->expr;\n+\n   if (!scalar_check (atom, 0) || !scalar_check (value, 1))\n     return false;\n "}, {"sha": "7ea7c36e8f9c23f4708cd6edf0d157b5272fd6ea", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -4766,7 +4766,7 @@ remove_caf_get_intrinsic (gfc_expr *e)\n   gcc_assert (e->expr_type == EXPR_FUNCTION && e->value.function.isym\n \t      && e->value.function.isym->id == GFC_ISYM_CAF_GET);\n   gfc_expr *e2 = e->value.function.actual->expr;\n-  e->value.function.actual->expr =NULL;\n+  e->value.function.actual->expr = NULL;\n   gfc_free_actual_arglist (e->value.function.actual);\n   gfc_free_shape (&e->shape, e->rank);\n   *e = *e2;\n@@ -5056,7 +5056,7 @@ resolve_variable (gfc_expr *e)\n   if (t)\n     expression_rank (e);\n \n-  if (0 && t && gfc_option.coarray == GFC_FCOARRAY_LIB && gfc_is_coindexed (e))\n+  if (t && gfc_option.coarray == GFC_FCOARRAY_LIB && gfc_is_coindexed (e))\n     add_caf_get_intrinsic (e);\n \n   return t;\n@@ -8424,6 +8424,11 @@ find_reachable_labels (gfc_code *block)\n static void\n resolve_lock_unlock (gfc_code *code)\n {\n+  if (code->expr1->expr_type == EXPR_FUNCTION\n+      && code->expr1->value.function.isym\n+      && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    remove_caf_get_intrinsic (code->expr1);\n+\n   if (code->expr1->ts.type != BT_DERIVED\n       || code->expr1->expr_type != EXPR_VARIABLE\n       || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n@@ -9276,8 +9281,22 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \n   gfc_check_assign (lhs, rhs, 1);\n \n-  if (0 && lhs_coindexed && gfc_option.coarray == GFC_FCOARRAY_LIB)\n-    {\n+  /* Insert a GFC_ISYM_CAF_SEND intrinsic, when the LHS is a coindexed variable.\n+     Additionally, insert this code when the RHS is a CAF as we then use the\n+     GFC_ISYM_CAF_SEND intrinsic just to avoid a temporary; but do not do so if\n+     the LHS is (re)allocatable or has a vector subscript.  */\n+  if (gfc_option.coarray == GFC_FCOARRAY_LIB\n+      && (lhs_coindexed\n+\t  || (code->expr2->expr_type == EXPR_FUNCTION\n+\t      && code->expr2->value.function.isym\n+\t      && code->expr2->value.function.isym->id == GFC_ISYM_CAF_GET\n+\t      && !gfc_expr_attr (rhs).allocatable\n+              && !gfc_has_vector_subscript (rhs))))\n+    {\n+      if (code->expr2->expr_type == EXPR_FUNCTION\n+\t  && code->expr2->value.function.isym\n+\t  && code->expr2->value.function.isym->id == GFC_ISYM_CAF_GET)\n+\tremove_caf_get_intrinsic (code->expr2);\n       code->op = EXEC_CALL;\n       gfc_get_sym_tree (GFC_PREFIX (\"caf_send\"), ns, &code->symtree, true);\n       code->resolved_sym = code->symtree->n.sym;\n@@ -9919,6 +9938,8 @@ resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (!t)\n \t    break;\n \n+\t  /* Remove a GFC_ISYM_CAF_GET inserted for a coindexed variable on\n+\t     the LHS. */\n \t  if (code->expr1->expr_type == EXPR_FUNCTION\n \t      && code->expr1->value.function.isym\n \t      && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)"}, {"sha": "34ab78e25d65f6e9171625505e2e9d035e040f24", "filename": "gcc/fortran/trans-const.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -81,6 +81,7 @@ gfc_build_string_const (int length, const char *s)\n     build_array_type (gfc_character1_type_node,\n \t\t      build_range_type (gfc_charlen_type_node,\n \t\t\t\t\tsize_one_node, len));\n+  TYPE_STRING_FLAG (TREE_TYPE (str)) = 1;\n   return str;\n }\n \n@@ -110,6 +111,7 @@ gfc_build_wide_string_const (int kind, int length, const gfc_char_t *string)\n     build_array_type (gfc_get_char_type (kind),\n \t\t      build_range_type (gfc_charlen_type_node,\n \t\t\t\t\tsize_one_node, len));\n+  TYPE_STRING_FLAG (TREE_TYPE (str)) = 1;\n   return str;\n }\n "}, {"sha": "2e129c961183f1b215b13e42eccdd1a32516248c", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -127,6 +127,9 @@ tree gfor_fndecl_caf_this_image;\n tree gfor_fndecl_caf_num_images;\n tree gfor_fndecl_caf_register;\n tree gfor_fndecl_caf_deregister;\n+tree gfor_fndecl_caf_get;\n+tree gfor_fndecl_caf_send;\n+tree gfor_fndecl_caf_sendget;\n tree gfor_fndecl_caf_critical;\n tree gfor_fndecl_caf_end_critical;\n tree gfor_fndecl_caf_sync_all;\n@@ -3327,6 +3330,22 @@ gfc_build_builtin_function_decls (void)\n \tget_identifier (PREFIX(\"caf_deregister\")), \".WWW\", void_type_node, 4,\n         ppvoid_type_node, pint_type, pchar_type_node, integer_type_node);\n \n+      gfor_fndecl_caf_get = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_get\")), \".R.RRRW\", void_type_node, 8,\n+        pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_send = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_send\")), \".R.RRRR\", void_type_node, 8,\n+        pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\n+      gfor_fndecl_caf_sendget = gfc_build_library_function_decl_with_spec (\n+\tget_identifier (PREFIX(\"caf_sendget\")), \".R.RRRR.RRR\", void_type_node,\n+\t12, pvoid_type_node, size_type_node, integer_type_node, pvoid_type_node,\n+\tpvoid_type_node, pvoid_type_node, size_type_node, integer_type_node,\n+\tpvoid_type_node, pvoid_type_node, integer_type_node, integer_type_node);\n+\n       gfor_fndecl_caf_critical = gfc_build_library_function_decl (\n \tget_identifier (PREFIX(\"caf_critical\")), void_type_node, 0);\n \n@@ -3355,18 +3374,18 @@ gfc_build_builtin_function_decls (void)\n       TREE_THIS_VOLATILE (gfor_fndecl_caf_error_stop_str) = 1;\n \n       gfor_fndecl_co_max = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_co_max\")), \"WR.WW\",\n-\tvoid_type_node, 7, pvoid_type_node, pvoid_type_node, integer_type_node,\n+\tget_identifier (PREFIX(\"caf_co_max\")), \"W.WW\",\n+\tvoid_type_node, 6, pvoid_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node, integer_type_node);\n \n       gfor_fndecl_co_min = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_co_min\")), \"WR.WW\",\n-\tvoid_type_node, 7, pvoid_type_node, pvoid_type_node, integer_type_node,\n+\tget_identifier (PREFIX(\"caf_co_min\")), \"W.WW\",\n+\tvoid_type_node, 6, pvoid_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node, integer_type_node);\n \n       gfor_fndecl_co_sum = gfc_build_library_function_decl_with_spec (\n-\tget_identifier (PREFIX(\"caf_co_sum\")), \"WR.WW\",\n-\tvoid_type_node, 6, pvoid_type_node, pvoid_type_node, integer_type_node,\n+\tget_identifier (PREFIX(\"caf_co_sum\")), \"W.WW\",\n+\tvoid_type_node, 5, pvoid_type_node, integer_type_node,\n \tpint_type, pchar_type_node, integer_type_node);\n     }\n "}, {"sha": "d67d737f92d02cfbb98afba51da2cad39489b23f", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -1384,8 +1384,8 @@ gfc_get_expr_charlen (gfc_expr *e)\n \n /* Return for an expression the backend decl of the coarray.  */\n \n-static tree\n-get_tree_for_caf_expr (gfc_expr *expr)\n+tree\n+gfc_get_tree_for_caf_expr (gfc_expr *expr)\n {\n   tree caf_decl;\n   bool found;\n@@ -4807,7 +4807,7 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  tree caf_decl, caf_type;\n \t  tree offset, tmp2;\n \n-\t  caf_decl = get_tree_for_caf_expr (e);\n+\t  caf_decl = gfc_get_tree_for_caf_expr (e);\n \t  caf_type = TREE_TYPE (caf_decl);\n \n \t  if (GFC_DESCRIPTOR_TYPE_P (caf_type)"}, {"sha": "52a2788080edfb22acdd84b131597bcefaf49091", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 584, "deletions": 10, "changes": 594, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -926,6 +926,560 @@ gfc_conv_intrinsic_exponent (gfc_se *se, gfc_expr *expr)\n }\n \n \n+/* Convert the coindex of a coarray into an image index; the result is\n+   image_num =  (idx(1)-lcobound(1)+1) + (idx(2)-lcobound(2)+1)*extent(1)\n+              + (idx(3)-lcobound(3)+1)*extent(2) + ...  */\n+\n+static tree\n+caf_get_image_index (stmtblock_t *block, gfc_expr *e, tree desc)\n+{\n+  gfc_ref *ref;\n+  tree lbound, ubound, extent, tmp, img_idx;\n+  gfc_se se;\n+  int i;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+      break;\n+  gcc_assert (ref != NULL);\n+\n+  img_idx = integer_zero_node;\n+  extent = integer_one_node;\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc)))\n+    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n+      {\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n+\tgfc_add_block_to_block (block, &se.pre);\n+\tlbound = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       integer_type_node, se.expr,\n+\t\t\t       fold_convert(integer_type_node, lbound));\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n+\t\t\t       extent, tmp);\n+\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t   img_idx, tmp);\n+\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n+\t  {\n+\t    ubound = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\t    extent = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+\t    extent = fold_convert (integer_type_node, extent);\n+\t  }\n+      }\n+  else\n+    for (i = ref->u.ar.dimen; i < ref->u.ar.dimen + ref->u.ar.codimen; i++)\n+      {\n+\tgfc_init_se (&se, NULL);\n+\tgfc_conv_expr_type (&se, ref->u.ar.start[i], integer_type_node);\n+\tgfc_add_block_to_block (block, &se.pre);\n+\tlbound = GFC_TYPE_ARRAY_LBOUND (TREE_TYPE (desc), i);\n+\tlbound = fold_convert (integer_type_node, lbound);\n+\ttmp = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t       integer_type_node, se.expr, lbound);\n+\ttmp = fold_build2_loc (input_location, MULT_EXPR, integer_type_node,\n+\t\t\t       extent, tmp);\n+\timg_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t   img_idx, tmp);\n+\tif (i < ref->u.ar.dimen + ref->u.ar.codimen - 1)\n+\t  {\n+\t    ubound = GFC_TYPE_ARRAY_UBOUND (TREE_TYPE (desc), i);\n+\t    ubound = fold_convert (integer_type_node, ubound);\n+\t    extent = fold_build2_loc (input_location, MINUS_EXPR,\n+\t\t\t\t      integer_type_node, ubound, lbound);\n+\t    extent = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t\t      extent, integer_one_node);\n+\t  }\n+      }\n+  img_idx = fold_build2_loc (input_location, PLUS_EXPR, integer_type_node,\n+\t\t\t     img_idx, integer_one_node);\n+  return img_idx;\n+}\n+\n+\n+/* Fill in the following structure\n+     struct caf_vector_t {\n+       size_t nvec;  // size of the vector\n+       union {\n+         struct {\n+           void *vector;\n+           int kind;\n+         } v;\n+         struct {\n+           ptrdiff_t lower_bound;\n+           ptrdiff_t upper_bound;\n+           ptrdiff_t stride;\n+         } triplet;\n+       } u;\n+     }  */\n+\n+static void\n+conv_caf_vector_subscript_elem (stmtblock_t *block, int i, tree desc,\n+\t\t\t\ttree lower, tree upper, tree stride,\n+\t\t\t\ttree vector, int kind, tree nvec)\n+{\n+  tree field, type, tmp;\n+\n+  desc = gfc_build_array_ref (desc, gfc_rank_cst[i], NULL_TREE);\n+  type = TREE_TYPE (desc);\n+\n+  field = gfc_advance_chain (TYPE_FIELDS (type), 0);\n+  tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t desc, field, NULL_TREE);\n+  gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field), nvec));\n+\n+  /* Access union.  */\n+  field = gfc_advance_chain (TYPE_FIELDS (type), 1);\n+  desc = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t  desc, field, NULL_TREE);\n+  type = TREE_TYPE (desc);\n+\n+  /* Access the inner struct.  */\n+  field = gfc_advance_chain (TYPE_FIELDS (type), vector != NULL_TREE ? 0 : 1);\n+  desc = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t      desc, field, NULL_TREE);\n+  type = TREE_TYPE (desc);\n+\n+  if (vector != NULL_TREE)\n+    {\n+      /* Set dim.lower/upper/stride.  */\n+      field = gfc_advance_chain (TYPE_FIELDS (type), 0);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t desc, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field), vector));\n+      field = gfc_advance_chain (TYPE_FIELDS (type), 1);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t desc, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, build_int_cst (integer_type_node, kind));\n+    }\n+  else\n+    {\n+      /* Set vector and kind.  */\n+      field = gfc_advance_chain (TYPE_FIELDS (type), 0);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     desc, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field), lower));\n+\n+      field = gfc_advance_chain (TYPE_FIELDS (type), 1);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     desc, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field), upper));\n+\n+      field = gfc_advance_chain (TYPE_FIELDS (type), 2);\n+      tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n+\t\t\t     desc, field, NULL_TREE);\n+      gfc_add_modify (block, tmp, fold_convert (TREE_TYPE (field), stride));\n+    }\n+}\n+\n+\n+static tree\n+conv_caf_vector_subscript (stmtblock_t *block, tree desc, gfc_array_ref *ar)\n+{\n+  gfc_se argse;\n+  tree var, lower, upper = NULL_TREE, stride = NULL_TREE, vector, nvec;\n+  tree lbound, ubound, tmp;\n+  int i;\n+\n+  var = gfc_create_var (gfc_get_caf_vector_type (ar->dimen), \"vector\");\n+\n+  for (i = 0; i < ar->dimen; i++)\n+    switch (ar->dimen_type[i])\n+      {\n+      case DIMEN_RANGE:\n+        if (ar->end[i])\n+\t  {\n+\t    gfc_init_se (&argse, NULL);\n+\t    gfc_conv_expr (&argse, ar->end[i]);\n+\t    gfc_add_block_to_block (block, &argse.pre);\n+\t    upper = gfc_evaluate_now (argse.expr, block);\n+\t  }\n+        else\n+\t  upper = gfc_conv_descriptor_ubound_get (desc, gfc_rank_cst[i]);\n+\tif (ar->stride[i])\n+\t  {\n+\t    gfc_init_se (&argse, NULL);\n+\t    gfc_conv_expr (&argse, ar->stride[i]);\n+\t    gfc_add_block_to_block (block, &argse.pre);\n+\t    stride = gfc_evaluate_now (argse.expr, block);\n+\t  }\n+\telse\n+\t  stride = gfc_index_one_node;\n+\n+\t/* Fall through.  */\n+      case DIMEN_ELEMENT:\n+\tif (ar->start[i])\n+\t  {\n+\t    gfc_init_se (&argse, NULL);\n+\t    gfc_conv_expr (&argse, ar->start[i]);\n+\t    gfc_add_block_to_block (block, &argse.pre);\n+\t    lower = gfc_evaluate_now (argse.expr, block);\n+\t  }\n+\telse\n+\t  lower = gfc_conv_descriptor_lbound_get (desc, gfc_rank_cst[i]);\n+\tif (ar->dimen_type[i] == DIMEN_ELEMENT)\n+\t  {\n+\t    upper = lower;\n+\t    stride = gfc_index_one_node;\n+\t  }\n+\tvector = NULL_TREE;\n+\tnvec = size_zero_node;\n+\tconv_caf_vector_subscript_elem (block, i, var, lower, upper, stride,\n+\t\t\t\t\tvector, 0, nvec);\n+\tbreak;\n+\n+      case DIMEN_VECTOR:\n+\tgfc_init_se (&argse, NULL);\n+\targse.descriptor_only = 1;\n+\tgfc_conv_expr_descriptor (&argse, ar->start[i]);\n+\tgfc_add_block_to_block (block, &argse.pre);\n+\tvector = argse.expr;\n+\tlbound = gfc_conv_descriptor_lbound_get (vector, gfc_rank_cst[0]);\n+\tubound = gfc_conv_descriptor_ubound_get (vector, gfc_rank_cst[0]);\n+\tnvec = gfc_conv_array_extent_dim (lbound, ubound, NULL);\n+        tmp = gfc_conv_descriptor_stride_get (vector, gfc_rank_cst[0]);\n+\tnvec = fold_build2_loc (input_location, TRUNC_DIV_EXPR,\n+\t\t\t\tTREE_TYPE (nvec), nvec, tmp);\n+\tlower = gfc_index_zero_node;\n+\tupper = gfc_index_zero_node;\n+\tstride = gfc_index_zero_node;\n+\tvector = gfc_conv_descriptor_data_get (vector);\n+\tconv_caf_vector_subscript_elem (block, i, var, lower, upper, stride,\n+\t\t\t\t\tvector, ar->start[i]->ts.kind, nvec);\n+\tbreak;\n+      default:\n+\tgcc_unreachable();\n+    }\n+  return gfc_build_addr_expr (NULL_TREE, var);\n+}\n+\n+\n+static void\n+get_caf_token_offset (tree *token, tree *offset, tree caf_decl, tree se_expr,\n+\t\t      gfc_expr *expr)\n+{\n+  tree tmp;\n+\n+  /* Coarray token.  */\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n+    {\n+      gcc_assert (GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl))\n+\t\t    == GFC_ARRAY_ALLOCATABLE\n+\t\t  || expr->symtree->n.sym->attr.select_type_temporary);\n+      *token = gfc_conv_descriptor_token (caf_decl);\n+    }\n+  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t   && GFC_DECL_TOKEN (caf_decl) != NULL_TREE)\n+    *token = GFC_DECL_TOKEN (caf_decl);\n+  else\n+    {\n+      gcc_assert (GFC_ARRAY_TYPE_P (TREE_TYPE (caf_decl))\n+\t\t  && GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl)) != NULL_TREE);\n+      *token = GFC_TYPE_ARRAY_CAF_TOKEN (TREE_TYPE (caf_decl));\n+    }\n+\n+  /* Offset between the coarray base address and the address wanted.  */\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl))\n+      && GFC_TYPE_ARRAY_AKIND (TREE_TYPE (caf_decl)) == GFC_ARRAY_ALLOCATABLE)\n+    *offset = build_int_cst (gfc_array_index_type, 0);\n+  else if (DECL_LANG_SPECIFIC (caf_decl)\n+\t   && GFC_DECL_CAF_OFFSET (caf_decl) != NULL_TREE)\n+    *offset = GFC_DECL_CAF_OFFSET (caf_decl);\n+  else if (GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl)) != NULL_TREE)\n+    *offset = GFC_TYPE_ARRAY_CAF_OFFSET (TREE_TYPE (caf_decl));\n+  else\n+    *offset = build_int_cst (gfc_array_index_type, 0);\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (se_expr))\n+      && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (TREE_TYPE (se_expr))))\n+    {\n+      tmp = build_fold_indirect_ref_loc (input_location, se_expr);\n+      tmp = gfc_conv_descriptor_data_get (tmp);\n+    }\n+  else if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se_expr)))\n+    tmp = gfc_conv_descriptor_data_get (se_expr);\n+  else\n+    {\n+      gcc_assert (POINTER_TYPE_P (TREE_TYPE (se_expr)));\n+      tmp = se_expr;\n+    }\n+\n+  *offset = fold_build2_loc (input_location, PLUS_EXPR, gfc_array_index_type,\n+\t\t\t     *offset, fold_convert (gfc_array_index_type, tmp));\n+\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (caf_decl)))\n+    tmp = gfc_conv_descriptor_data_get (caf_decl);\n+  else\n+   {\n+     gcc_assert (POINTER_TYPE_P (TREE_TYPE (caf_decl)));\n+     tmp = caf_decl;\n+   }\n+\n+  *offset = fold_build2_loc (input_location, MINUS_EXPR, gfc_array_index_type,\n+\t\t\t    fold_convert (gfc_array_index_type, *offset),\n+\t\t\t    fold_convert (gfc_array_index_type, tmp));\n+}\n+\n+\n+/* Get data from a remote coarray.  */\n+\n+static void\n+gfc_conv_intrinsic_caf_get (gfc_se *se, gfc_expr *expr, tree lhs, tree lhs_kind)\n+{\n+  gfc_expr *array_expr;\n+  gfc_se argse;\n+  tree caf_decl, token, offset, image_index, tmp;\n+  tree res_var, dst_var, type, kind, vec;\n+\n+  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+\n+  if (se->ss && se->ss->info->useflags)\n+    {\n+       /* Access the previously obtained result.  */\n+       gfc_conv_tmp_array_ref (se);\n+       return;\n+    }\n+\n+  /* If lhs is set, the CAF_GET intrinsic has already been stripped.  */\n+  array_expr = (lhs == NULL_TREE) ? expr->value.function.actual->expr : expr;\n+  type = gfc_typenode_for_spec (&array_expr->ts);\n+\n+  res_var = lhs;\n+  dst_var = lhs;\n+\n+  gfc_init_se (&argse, NULL);\n+  if (array_expr->rank == 0)\n+    {\n+      symbol_attribute attr;\n+\n+      gfc_clear_attr (&attr);\n+      gfc_conv_expr (&argse, array_expr);\n+\n+      if (lhs == NULL_TREE)\n+\t{\n+\t  gfc_clear_attr (&attr);\n+\t  if (array_expr->ts.type == BT_CHARACTER)\n+\t    res_var = gfc_conv_string_tmp (se, type, argse.string_length);\n+\t  else\n+\t    res_var = gfc_create_var (type, \"caf_res\");\n+\t  dst_var = gfc_conv_scalar_to_descriptor (&argse, res_var, attr);\n+\t  dst_var = gfc_build_addr_expr (NULL_TREE, dst_var);\n+\t}\n+      argse.expr = gfc_conv_scalar_to_descriptor (&argse, argse.expr, attr);\n+      argse.expr = gfc_build_addr_expr (NULL_TREE, argse.expr);\n+    }\n+  else\n+    {\n+      /* If has_vector, pass descriptor for whole array and the\n+         vector bounds separately.  */\n+      gfc_array_ref *ar, ar2;\n+      bool has_vector = false;\n+\n+      if (gfc_is_coindexed (expr) && gfc_has_vector_subscript (expr))\n+\t{\n+          has_vector = true;\n+          ar = gfc_find_array_ref (expr);\n+\t  ar2 = *ar;\n+\t  memset (ar, '\\0', sizeof (*ar));\n+\t  ar->as = ar2.as;\n+\t  ar->type = AR_FULL;\n+\t}\n+      gfc_conv_expr_descriptor (&argse, array_expr);\n+\n+      if (has_vector)\n+\t{\n+\t  vec = conv_caf_vector_subscript (&argse.pre, argse.expr, ar);\n+\t  *ar = ar2;\n+\t}\n+\n+      if (lhs == NULL_TREE)\n+\t{\n+\t  /* Create temporary.  */\n+\t  for (int n = 0; n < se->ss->loop->dimen; n++)\n+\t    if (se->loop->to[n] == NULL_TREE)\n+\t      {\n+\t\tse->loop->from[n] =\n+\t\t\tgfc_conv_descriptor_lbound_get (argse.expr, gfc_rank_cst[n]);\n+\t\tse->loop->to[n] =\n+\t\t\tgfc_conv_descriptor_ubound_get (argse.expr, gfc_rank_cst[n]);\n+\t      }\n+\t  gfc_trans_create_temp_array (&argse.pre, &argse.post, se->ss, type,\n+\t\t\t\t       NULL_TREE, false, true, false,\n+\t\t\t\t       &array_expr->where);\n+\t  res_var = se->ss->info->data.array.descriptor;\n+\t  dst_var = gfc_build_addr_expr (NULL_TREE, res_var);\n+\t}\n+      argse.expr = gfc_build_addr_expr (NULL_TREE, argse.expr);\n+    }\n+\n+  kind = build_int_cst (integer_type_node, expr->ts.kind);\n+  if (lhs_kind == NULL_TREE)\n+    lhs_kind = kind;\n+\n+  vec = null_pointer_node;\n+\n+  gfc_add_block_to_block (&se->pre, &argse.pre);\n+  gfc_add_block_to_block (&se->post, &argse.post);\n+\n+  caf_decl = gfc_get_tree_for_caf_expr (array_expr);\n+  if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+    caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+  image_index = caf_get_image_index (&se->pre, array_expr, caf_decl);\n+  get_caf_token_offset (&token, &offset, caf_decl, argse.expr, array_expr);\n+\n+  tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_get, 8,\n+\t\t\t     token, offset, image_index, argse.expr, vec,\n+\t\t\t     dst_var, kind, lhs_kind);\n+  gfc_add_expr_to_block (&se->pre, tmp);\n+\n+  if (se->ss)\n+    gfc_advance_se_ss_chain (se);\n+\n+  se->expr = res_var;\n+  if (array_expr->ts.type == BT_CHARACTER)\n+    se->string_length = argse.string_length;\n+}\n+\n+\n+/* Send data to a remove coarray.  */\n+ \n+static tree\n+conv_caf_send (gfc_code *code) {\n+  gfc_expr *lhs_expr, *rhs_expr;\n+  gfc_se lhs_se, rhs_se;\n+  stmtblock_t block;\n+  tree caf_decl, token, offset, image_index, tmp, lhs_kind, rhs_kind;\n+  tree vec = null_pointer_node, rhs_vec = null_pointer_node;\n+\n+  gcc_assert (gfc_option.coarray == GFC_FCOARRAY_LIB);\n+\n+  lhs_expr = code->ext.actual->expr;\n+  rhs_expr = code->ext.actual->next->expr;\n+  gfc_init_block (&block);\n+\n+  /* LHS.  */\n+  gfc_init_se (&lhs_se, NULL);\n+  if (lhs_expr->rank == 0)\n+    {\n+      symbol_attribute attr;\n+      gfc_clear_attr (&attr);\n+      gfc_conv_expr (&lhs_se, lhs_expr);\n+      lhs_se.expr = gfc_conv_scalar_to_descriptor (&lhs_se, lhs_se.expr, attr);\n+      lhs_se.expr = gfc_build_addr_expr (NULL_TREE, lhs_se.expr);\n+    }\n+  else\n+    {\n+      /* If has_vector, pass descriptor for whole array and the\n+         vector bounds separately.  */\n+      gfc_array_ref *ar, ar2;\n+      bool has_vector = false;\n+\n+      if (gfc_is_coindexed (lhs_expr) && gfc_has_vector_subscript (lhs_expr))\n+\t{\n+          has_vector = true;\n+          ar = gfc_find_array_ref (lhs_expr);\n+\t  ar2 = *ar;\n+\t  memset (ar, '\\0', sizeof (*ar));\n+\t  ar->as = ar2.as;\n+\t  ar->type = AR_FULL;\n+\t}\n+      lhs_se.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&lhs_se, lhs_expr);\n+      if (has_vector)\n+\t{\n+\t  vec = conv_caf_vector_subscript (&block, lhs_se.expr, ar);\n+\t  *ar = ar2;\n+\t}\n+    }\n+\n+  lhs_kind = build_int_cst (integer_type_node, lhs_expr->ts.kind);\n+  gfc_add_block_to_block (&block, &lhs_se.pre);\n+\n+  /* Special case: RHS is a coarray but LHS is not; this code path avoids a\n+     temporary and a loop.  */\n+  if (!gfc_is_coindexed (lhs_expr))\n+    {\n+      gcc_assert (gfc_is_coindexed (rhs_expr));\n+      gfc_init_se (&rhs_se, NULL);\n+      gfc_conv_intrinsic_caf_get (&rhs_se, rhs_expr, lhs_se.expr, lhs_kind);\n+      gfc_add_block_to_block (&block, &rhs_se.pre);\n+      gfc_add_block_to_block (&block, &rhs_se.post);\n+      gfc_add_block_to_block (&block, &lhs_se.post);\n+      return gfc_finish_block (&block);\n+    }\n+\n+  /* Obtain token, offset and image index for the LHS.  */\n+\n+  caf_decl = gfc_get_tree_for_caf_expr (lhs_expr);\n+  if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+    caf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+  image_index = caf_get_image_index (&block, lhs_expr, caf_decl);\n+  get_caf_token_offset (&token, &offset, caf_decl, lhs_se.expr, lhs_expr);\n+\n+  /* RHS.  */\n+  gfc_init_se (&rhs_se, NULL);\n+  if (rhs_expr->rank == 0)\n+    {\n+      symbol_attribute attr;\n+      gfc_clear_attr (&attr);\n+      gfc_conv_expr (&rhs_se, rhs_expr);\n+      rhs_se.expr = gfc_conv_scalar_to_descriptor (&rhs_se, rhs_se.expr, attr);\n+      rhs_se.expr = gfc_build_addr_expr (NULL_TREE, rhs_se.expr);\n+    }\n+  else\n+    {\n+      /* If has_vector, pass descriptor for whole array and the\n+         vector bounds separately.  */\n+      gfc_array_ref *ar, ar2;\n+      bool has_vector = false;\n+\n+      if (gfc_is_coindexed (rhs_expr) && gfc_has_vector_subscript (rhs_expr))\n+\t{\n+          has_vector = true;\n+          ar = gfc_find_array_ref (rhs_expr);\n+\t  ar2 = *ar;\n+\t  memset (ar, '\\0', sizeof (*ar));\n+\t  ar->as = ar2.as;\n+\t  ar->type = AR_FULL;\n+\t}\n+      rhs_se.want_pointer = 1;\n+      gfc_conv_expr_descriptor (&rhs_se, rhs_expr);\n+      if (has_vector)\n+\t{\n+\t  rhs_vec = conv_caf_vector_subscript (&block, rhs_se.expr, ar);\n+\t  *ar = ar2;\n+\t}\n+    }\n+\n+  gfc_add_block_to_block (&block, &rhs_se.pre);\n+\n+  rhs_kind = build_int_cst (integer_type_node, rhs_expr->ts.kind);\n+\n+  if (!gfc_is_coindexed (rhs_expr))\n+    tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_send, 8, token,\n+\t\t\t     offset, image_index, lhs_se.expr, vec,\n+\t\t\t     rhs_se.expr, lhs_kind, rhs_kind);\n+  else\n+    {\n+      tree rhs_token, rhs_offset, rhs_image_index;\n+\n+      caf_decl = gfc_get_tree_for_caf_expr (rhs_expr);\n+      if (TREE_CODE (TREE_TYPE (caf_decl)) == REFERENCE_TYPE)\n+\tcaf_decl = build_fold_indirect_ref_loc (input_location, caf_decl);\n+      rhs_image_index = caf_get_image_index (&block, rhs_expr, caf_decl);\n+      get_caf_token_offset (&rhs_token, &rhs_offset, caf_decl, rhs_se.expr,\n+\t\t\t    rhs_expr);\n+      tmp = build_call_expr_loc (input_location, gfor_fndecl_caf_sendget, 12,\n+\t\t\t\t token, offset, image_index, lhs_se.expr, vec,\n+\t\t\t\t rhs_token, rhs_offset, rhs_image_index,\n+\t\t\t\t rhs_se.expr, rhs_vec, lhs_kind, rhs_kind);\n+    }\n+  gfc_add_expr_to_block (&block, tmp);\n+  gfc_add_block_to_block (&block, &lhs_se.post);\n+  gfc_add_block_to_block (&block, &rhs_se.post);\n+  return gfc_finish_block (&block);\n+}\n+\n+\n static void\n trans_this_image (gfc_se * se, gfc_expr *expr)\n {\n@@ -6866,6 +7420,10 @@ gfc_conv_intrinsic_function (gfc_se * se, gfc_expr * expr)\n       gfc_conv_intrinsic_mod (se, expr, 1);\n       break;\n \n+    case GFC_ISYM_CAF_GET:\n+      gfc_conv_intrinsic_caf_get (se, expr, NULL_TREE, NULL_TREE);\n+      break;\n+\n     case GFC_ISYM_CMPLX:\n       gfc_conv_intrinsic_cmplx (se, expr, name[5] == '1');\n       break;\n@@ -7629,6 +8187,7 @@ gfc_walk_intrinsic_function (gfc_ss * ss, gfc_expr * expr,\n       return gfc_walk_intrinsic_bound (ss, expr);\n \n     case GFC_ISYM_TRANSFER:\n+    case GFC_ISYM_CAF_GET:\n       return gfc_walk_intrinsic_libfunc (ss, expr);\n \n     default:\n@@ -7645,7 +8204,7 @@ conv_co_minmaxsum (gfc_code *code)\n {\n   gfc_se argse;\n   stmtblock_t block, post_block;\n-  tree fndecl, array, vec, strlen, image_index, stat, errmsg, errmsg_len;\n+  tree fndecl, array, strlen, image_index, stat, errmsg, errmsg_len;\n \n   gfc_start_block (&block);\n   gfc_init_block (&post_block);\n@@ -7702,8 +8261,6 @@ conv_co_minmaxsum (gfc_code *code)\n   else\n     strlen = integer_zero_node;\n \n-  vec = null_pointer_node;\n-\n   /* image_index.  */\n   if (code->ext.actual->next->expr)\n     {\n@@ -7743,12 +8300,13 @@ conv_co_minmaxsum (gfc_code *code)\n     gcc_unreachable ();\n \n   if (code->resolved_isym->id == GFC_ISYM_CO_SUM)\n-    fndecl = build_call_expr_loc (input_location, fndecl, 6, array, vec,\n-\t\t\t\t  image_index, stat, errmsg, errmsg_len);\n-  else\n-    fndecl = build_call_expr_loc (input_location, fndecl, 7, array, vec,\n-\t\t\t\t  image_index, stat, errmsg, strlen,\n+    fndecl = build_call_expr_loc (input_location, fndecl, 6, array,\n+\t\t\t\t  null_pointer_node, image_index, stat, errmsg,\n \t\t\t\t  errmsg_len);\n+  else\n+    fndecl = build_call_expr_loc (input_location, fndecl, 7, array,\n+\t\t\t\t  null_pointer_node, image_index, stat, errmsg,\n+\t\t\t\t  strlen, errmsg_len);\n   gfc_add_expr_to_block (&block, fndecl);\n   gfc_add_block_to_block (&block, &post_block);\n \n@@ -7762,10 +8320,16 @@ conv_intrinsic_atomic_def (gfc_code *code)\n {\n   gfc_se atom, value;\n   stmtblock_t block;\n+  gfc_expr *atom_expr = code->ext.actual->expr;\n+\n+  if (atom_expr->expr_type == EXPR_FUNCTION\n+      && atom_expr->value.function.isym\n+      && atom_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom_expr = atom_expr->value.function.actual->expr;\n \n   gfc_init_se (&atom, NULL);\n   gfc_init_se (&value, NULL);\n-  gfc_conv_expr (&atom, code->ext.actual->expr);\n+  gfc_conv_expr (&atom, atom_expr);\n   gfc_conv_expr (&value, code->ext.actual->next->expr);\n \n   gfc_init_block (&block);\n@@ -7780,10 +8344,16 @@ conv_intrinsic_atomic_ref (gfc_code *code)\n {\n   gfc_se atom, value;\n   stmtblock_t block;\n+  gfc_expr *atom_expr = code->ext.actual->expr;\n+\n+  if (atom_expr->expr_type == EXPR_FUNCTION\n+      && atom_expr->value.function.isym\n+      && atom_expr->value.function.isym->id == GFC_ISYM_CAF_GET)\n+    atom_expr = atom_expr->value.function.actual->expr;\n \n   gfc_init_se (&atom, NULL);\n   gfc_init_se (&value, NULL);\n-  gfc_conv_expr (&value, code->ext.actual->expr);\n+  gfc_conv_expr (&value, atom_expr);\n   gfc_conv_expr (&atom, code->ext.actual->next->expr);\n \n   gfc_init_block (&block);\n@@ -8052,6 +8622,10 @@ gfc_conv_intrinsic_subroutine (gfc_code *code)\n       res = conv_isocbinding_subroutine (code);\n       break;\n \n+    case GFC_ISYM_CAF_SEND:\n+      res = conv_caf_send (code);\n+      break;\n+\n     case GFC_ISYM_CO_MIN:\n     case GFC_ISYM_CO_MAX:\n     case GFC_ISYM_CO_SUM:"}, {"sha": "bb930f9cdeaaf198aa38a7fbd52c083af578be0c", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -3107,4 +3107,91 @@ gfc_get_array_descr_info (const_tree type, struct array_descr_info *info)\n   return true;\n }\n \n+\n+/* Create a type to handle vector subscripts for coarray library calls. It\n+   has the form:\n+     struct caf_vector_t {\n+       size_t nvec;  // size of the vector\n+       union {\n+         struct {\n+           void *vector;\n+           int kind;\n+         } v;\n+         struct {\n+           ptrdiff_t lower_bound;\n+           ptrdiff_t upper_bound;\n+           ptrdiff_t stride;\n+         } triplet;\n+       } u;\n+     }\n+   where nvec == 0 for DIMEN_ELEMENT or DIMEN_RANGE and nvec being the vector\n+   size in case of DIMEN_VECTOR, where kind is the integer type of the vector.  */\n+\n+tree\n+gfc_get_caf_vector_type (int dim)\n+{\n+  static tree vector_types[GFC_MAX_DIMENSIONS];\n+  static tree vec_type = NULL_TREE;\n+  tree triplet_struct_type, vect_struct_type, union_type, tmp, *chain;\n+\n+  if (vector_types[dim-1] != NULL_TREE)\n+    return vector_types[dim-1];\n+\n+  if (vec_type == NULL_TREE)\n+    {\n+      chain = 0;\n+      vect_struct_type = make_node (RECORD_TYPE);\n+      tmp = gfc_add_field_to_struct_1 (vect_struct_type,\n+\t\t\t\t       get_identifier (\"vector\"),\n+\t\t\t\t       pvoid_type_node, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      tmp = gfc_add_field_to_struct_1 (vect_struct_type,\n+\t\t\t\t       get_identifier (\"kind\"),\n+\t\t\t\t       integer_type_node, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      gfc_finish_type (vect_struct_type);\n+\n+      chain = 0;\n+      triplet_struct_type = make_node (RECORD_TYPE);\n+      tmp = gfc_add_field_to_struct_1 (triplet_struct_type,\n+\t\t\t\t       get_identifier (\"lower_bound\"),\n+\t\t\t\t       gfc_array_index_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      tmp = gfc_add_field_to_struct_1 (triplet_struct_type,\n+\t\t\t\t       get_identifier (\"upper_bound\"),\n+\t\t\t\t       gfc_array_index_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      tmp = gfc_add_field_to_struct_1 (triplet_struct_type, get_identifier (\"stride\"),\n+\t\t\t\t       gfc_array_index_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      gfc_finish_type (triplet_struct_type);\n+\n+      chain = 0;\n+      union_type = make_node (UNION_TYPE);\n+      tmp = gfc_add_field_to_struct_1 (union_type, get_identifier (\"v\"),\n+                                       vect_struct_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      tmp = gfc_add_field_to_struct_1 (union_type, get_identifier (\"triplet\"),\n+\t\t\t\t       triplet_struct_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      gfc_finish_type (union_type);\n+\n+      chain = 0;\n+      vec_type = make_node (RECORD_TYPE);\n+      tmp = gfc_add_field_to_struct_1 (vec_type, get_identifier (\"nvec\"),\n+\t\t\t\t       size_type_node, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      tmp = gfc_add_field_to_struct_1 (vec_type, get_identifier (\"u\"),\n+\t\t\t\t       union_type, &chain);\n+      TREE_NO_WARNING (tmp) = 1;\n+      gfc_finish_type (vec_type);\n+      TYPE_NAME (vec_type) = get_identifier (\"caf_vector_t\");\n+    }\n+\n+  tmp = build_range_type (gfc_array_index_type, gfc_index_zero_node,\n+\t\t\t  gfc_rank_cst[dim-1]);\n+  vector_types[dim-1] = build_array_type (vec_type, tmp);\n+  return vector_types[dim-1];\n+}\n+\n #include \"gt-fortran-trans-types.h\""}, {"sha": "5ed87c0bb5a7ee6404df0abaa6912f753aa8225e", "filename": "gcc/fortran/trans-types.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -100,5 +100,6 @@ int gfc_is_nodesc_array (gfc_symbol *);\n tree gfc_get_dtype (tree);\n \n tree gfc_get_ppc_type (gfc_component *);\n+tree gfc_get_caf_vector_type (int dim);\n \n #endif"}, {"sha": "7ab9dd4feedc6bb4d61de262187355b90afdc2d4", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -418,6 +418,7 @@ tree gfc_conv_scalar_to_descriptor (gfc_se *, tree, symbol_attribute);\n /* trans-expr.c */\n void gfc_conv_scalar_char_value (gfc_symbol *sym, gfc_se *se, gfc_expr **expr);\n tree gfc_string_to_single_character (tree len, tree str, int kind);\n+tree gfc_get_tree_for_caf_expr (gfc_expr *);\n \n /* Find the decl containing the auxiliary variables for assigned variables.  */\n void gfc_conv_label_variable (gfc_se * se, gfc_expr * expr);\n@@ -708,6 +709,9 @@ extern GTY(()) tree gfor_fndecl_caf_this_image;\n extern GTY(()) tree gfor_fndecl_caf_num_images;\n extern GTY(()) tree gfor_fndecl_caf_register;\n extern GTY(()) tree gfor_fndecl_caf_deregister;\n+extern GTY(()) tree gfor_fndecl_caf_get;\n+extern GTY(()) tree gfor_fndecl_caf_send;\n+extern GTY(()) tree gfor_fndecl_caf_sendget;\n extern GTY(()) tree gfor_fndecl_caf_critical;\n extern GTY(()) tree gfor_fndecl_caf_end_critical;\n extern GTY(()) tree gfor_fndecl_caf_sync_all;"}, {"sha": "560f45abdeea882f5b3c90f8a775137096cb7ed5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -1,3 +1,13 @@\n+2014-06-17  Tobias Burnus  <burnus@net-b.de>\n+\t    Alessandro Fanfarillo <alessandro.fanfarillo@gmail.com>\n+\n+\t* gfortran.dg/coarray/send_array.f90: New.\n+\t* gfortran.dg/coarray/get_array.f90: New.\n+\t* gfortran.dg/coarray/sendget_array.f90: New.\n+\t* gfortran.dg/coarray/collectives_1.f90: Correct subroutine\n+\tnames.\n+\t* gfortran.dg/coarray/collectives_2.f90: New.\n+\n 2014-06-17  Rainer Orth  <ro@CeBiTec.Uni-Bielefeld.DE>\n \n \tPR target/61533"}, {"sha": "68b19a0dda8d41424a9f73789b911a95050a338f", "filename": "gcc/testsuite/gfortran.dg/coarray/collectives_1.f90", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_1.f90?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -11,25 +11,25 @@ program test\n   call test_max\n   call test_sum\n contains\n-  subroutine test_min\n+  subroutine test_max\n     integer :: val\n     val = this_image ()\n     call co_max (val, result_image=1)\n     if (this_image() == 1) then\n       !write(*,*) \"Maximal value\", val\n       if (val /= num_images()) call abort()\n     end if\n-  end subroutine test_min\n+  end subroutine test_max\n \n-  subroutine test_max\n+  subroutine test_min\n     integer :: val\n     val = this_image ()\n     call co_min (val, result_image=1)\n     if (this_image() == 1) then\n       !write(*,*) \"Minimal value\", val\n       if (val /= 1) call abort()\n     end if\n-  end subroutine test_max\n+  end subroutine test_min\n \n   subroutine test_sum\n     integer :: val, n"}, {"sha": "a2f5939160cadbfb0d743c9058d5de2719536604", "filename": "gcc/testsuite/gfortran.dg/coarray/collectives_2.f90", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fcollectives_2.f90?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -0,0 +1,59 @@\n+! { dg-do run }\n+!\n+! CO_SUM/CO_MIN/CO_MAX\n+!\n+program test\n+  implicit none\n+  intrinsic co_max\n+  intrinsic co_min\n+  intrinsic co_sum\n+  integer :: val(3)\n+  integer :: vec(3)\n+  vec = [2,3,1]\n+  if (this_image() == 1) then\n+    val(1) = 42\n+  else\n+    val(1) = -99\n+  endif\n+  val(2) = this_image()\n+  if (this_image() == num_images()) then\n+    val(3) = -55\n+  else\n+    val(3) = 101\n+  endif\n+  call test_min\n+  call test_max\n+  call test_sum\n+contains\n+  subroutine test_max\n+    call co_max (val(vec))\n+    !write(*,*) \"Maximal value\", val\n+    if (num_images() > 1) then\n+      if (any (val /= [42, num_images(), 101])) call abort()\n+    else\n+      if (any (val /= [42, num_images(), -55])) call abort()\n+    endif\n+  end subroutine test_max\n+\n+  subroutine test_min\n+    call co_min (val, result_image=num_images())\n+    if (this_image() == num_images()) then\n+      !write(*,*) \"Minimal value\", val\n+      if (num_images() > 1) then\n+        if (any (val /= [-99, num_images(), -55])) call abort()\n+      else\n+        if (any (val /= [42, num_images(), -55])) call abort()\n+      endif\n+    endif\n+  end subroutine test_min\n+\n+  subroutine test_sum\n+    integer :: n\n+    call co_sum (val, result_image=1)\n+    if (this_image() == 1) then\n+      n = num_images()\n+      !write(*,*) \"The sum is \", val\n+      if (any (val /= [42 + (n-1)*(-99), (n**2 + n)/2, -55+(n-1)*101])) call abort()\n+    end if\n+  end subroutine test_sum\n+end program test"}, {"sha": "cf7674ab273386e734cb1a7c24d8216a2582ffdf", "filename": "gcc/testsuite/gfortran.dg/coarray/get_array.f90", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_array.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_array.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fget_array.f90?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -0,0 +1,279 @@\n+! { dg-do run }\n+!\n+! This program does a correctness check for\n+! ... = ARRAY[idx] and ... = SCALAR[idx]\n+!\n+\n+\n+!\n+! FIXME: two/three has to be modified, test has to be checked and\n+! diagnostic has to be removed\n+! \n+\n+program main\n+  implicit none\n+  integer, parameter :: n = 3\n+  integer, parameter :: m = 4\n+\n+  ! Allocatable coarrays\n+  call one(-5, 1)\n+  call one(0, 0)\n+  call one(1, -5)\n+  call one(0, -11)\n+\n+  ! Static coarrays\n+  call two()\n+  call three()\n+contains\n+  subroutine one(lb1, lb2)\n+    integer, value :: lb1, lb2\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, allocatable :: caf(:,:)[:]\n+    integer, allocatable :: a(:,:), b(:,:), c(:,:)\n+\n+    allocate(caf(lb1:n+lb1-1, lb2:m+lb2-1)[*], &\n+         a(lb1:n+lb1-1, lb2:m+lb2-1), &\n+         b(lb1:n+lb1-1, lb2:m+lb2-1), &\n+         c(lb1:n+lb1-1, lb2:m+lb2-1))\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    c(:,:) = caf(:,:)[num_images()]\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    c = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    c(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (c /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine one\n+\n+  subroutine two()\n+    integer, parameter :: lb1 = -5, lb2 = 1\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: c(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    c(:,:) = caf(:,:)[num_images()]\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    c = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    c(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (c /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine two\n+\n+  subroutine three()\n+    integer, parameter :: lb1 = 0, lb2 = 0\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: c(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    c(:,:) = caf(:,:)[num_images()]\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    c = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        c(i,j) = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= c)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    c = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    c(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (c /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine three\n+end program main"}, {"sha": "372718f53b9b0463d925d81564edb3c8ed54bc33", "filename": "gcc/testsuite/gfortran.dg/coarray/send_array.f90", "status": "added", "additions": 398, "deletions": 0, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_array.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_array.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsend_array.f90?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -0,0 +1,398 @@\n+! { dg-do run }\n+!\n+! This program does a correctness check for\n+! ARRAY[idx] = SCALAR, ARRAY[idx] = ARRAY and SCALAR[idx] = SCALAR\n+!\n+program main\n+  implicit none\n+  integer, parameter :: n = 3\n+  integer, parameter :: m = 4\n+\n+  ! Allocatable coarrays\n+  call one(-5, 1)\n+  call one(0, 0)\n+  call one(1, -5)\n+  call one(0, -11)\n+\n+  ! Static coarrays\n+  call two()\n+  call three()\n+contains\n+  subroutine one(lb1, lb2)\n+    integer, value :: lb1, lb2\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, allocatable :: caf(:,:)[:]\n+    integer, allocatable :: a(:,:), b(:,:)\n+\n+    allocate(caf(lb1:n+lb1-1, lb2:m+lb2-1)[*], &\n+         a(lb1:n+lb1-1, lb2:m+lb2-1), &\n+         b(lb1:n+lb1-1, lb2:m+lb2-1))\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = SCALAR\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(lb1, lb2)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(lb1, lb2)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(:, :)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(:, :)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, 1, -2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = 1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    sync all\n+    if (this_image() == 1) then\n+      do j = lb2, m+lb2-1\n+        do i = n+lb1-1, 1, -2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+      do j = lb2, m+lb2-1\n+        do i = 1, n+lb1-1, 2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = SCALAR\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) = b(lb1, lb2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(lb1, lb2)\n+                    end if\n+                    sync all\n+\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    end if\n+                    sync all\n+\n+                    if (this_image() == num_images()) then\n+                      if (any (a /= caf)) then\n+                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", &\n+                             lb2,\":\",m+lb2-1\n+                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, &\n+                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2\n+                        print *, i\n+                        print *, a\n+                        print *, caf\n+                        print *, a-caf\n+                        call abort()\n+                      endif\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine one\n+\n+  subroutine two()\n+    integer, parameter :: lb1 = -5, lb2 = 1\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = SCALAR\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(lb1, lb2)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(lb1, lb2)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(:, :)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(:, :)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, 1, -2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = 1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    sync all\n+    if (this_image() == 1) then\n+      do j = lb2, m+lb2-1\n+        do i = n+lb1-1, 1, -2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+      do j = lb2, m+lb2-1\n+        do i = 1, n+lb1-1, 2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = SCALAR\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) = b(lb1, lb2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(lb1, lb2)\n+                    end if\n+                    sync all\n+\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    end if\n+                    sync all\n+\n+                    if (this_image() == num_images()) then\n+                      if (any (a /= caf)) then\n+                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", &\n+                             lb2,\":\",m+lb2-1\n+                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, &\n+                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2\n+                        print *, i\n+                        print *, a\n+                        print *, caf\n+                        print *, a-caf\n+                        call abort()\n+                      endif\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine two\n+\n+  subroutine three()\n+    integer, parameter :: lb1 = 0, lb2 = 0\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = SCALAR\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(lb1, lb2)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(lb1, lb2)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    a(:,:) = b(:, :)\n+    sync all\n+    if (this_image() == 1) then\n+      caf(:,:)[num_images()] = b(:, :)\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, 1, -2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = 1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+      end do\n+    end do\n+    sync all\n+    if (this_image() == 1) then\n+      do j = lb2, m+lb2-1\n+        do i = n+lb1-1, 1, -2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+      do j = lb2, m+lb2-1\n+        do i = 1, n+lb1-1, 2\n+          caf(i,j)[num_images()] = b(i, j)\n+        end do\n+      end do\n+    end if\n+    sync all\n+    if (this_image() == num_images()) then\n+      if (any (a /= caf)) &\n+           call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = SCALAR\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) = b(lb1, lb2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(lb1, lb2)\n+                    end if\n+                    sync all\n+\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    sync all\n+                    if (this_image() == 1) then\n+                      caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()] &\n+                           = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    end if\n+                    sync all\n+\n+                    if (this_image() == num_images()) then\n+                      if (any (a /= caf)) then\n+                        print '(*(g0))', \"bounds: \", lb1,\":\",n+lb1-1,\", \", &\n+                             lb2,\":\",m+lb2-1\n+                        print '(*(g0))', \"section: \", i,\":\",i_e,\":\",i_s*i_sgn1, &\n+                             \", \", j,\":\",j_e,\":\",j_s*i_sgn2\n+                        print *, i\n+                        print *, a\n+                        print *, caf\n+                        print *, a-caf\n+                        call abort()\n+                      endif\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine three\n+end program main"}, {"sha": "98e4cbe8c46173397467964de448bb2758cabe03", "filename": "gcc/testsuite/gfortran.dg/coarray/sendget_array.f90", "status": "added", "additions": 279, "deletions": 0, "changes": 279, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsendget_array.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsendget_array.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray%2Fsendget_array.f90?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -0,0 +1,279 @@\n+! { dg-do run }\n+!\n+! This program does a correctness check for\n+! ARRAY[idx] = ARRAY[idx] and SCALAR[idx] = SCALAR[idx]\n+!\n+\n+\n+!\n+! FIXME: two/three has to be modified, test has to be checked and\n+! diagnostic has to be removed\n+! \n+\n+program main\n+  implicit none\n+  integer, parameter :: n = 3\n+  integer, parameter :: m = 4\n+\n+  ! Allocatable coarrays\n+  call one(-5, 1)\n+  call one(0, 0)\n+  call one(1, -5)\n+  call one(0, -11)\n+\n+  ! Static coarrays\n+  call two()\n+  call three()\n+contains\n+  subroutine one(lb1, lb2)\n+    integer, value :: lb1, lb2\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, allocatable :: caf(:,:)[:], caf2(:,:)[:]\n+    integer, allocatable :: a(:,:), b(:,:)\n+\n+    allocate(caf(lb1:n+lb1-1, lb2:m+lb2-1)[*], &\n+             caf2(lb1:n+lb1-1, lb2:m+lb2-1)[*], &\n+             a(lb1:n+lb1-1, lb2:m+lb2-1), &\n+             b(lb1:n+lb1-1, lb2:m+lb2-1))\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    caf2(:,:)[this_image()] = caf(:,:)[num_images()]\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    caf2 = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    caf2(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[this_image()] &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (caf2 /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine one\n+\n+  subroutine two()\n+    integer, parameter :: lb1 = -5, lb2 = 1\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: caf2(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    caf2(:,:)[this_image()] = caf(:,:)[num_images()]\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    caf2 = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    caf2(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[this_image()] &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (caf2 /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine two\n+\n+  subroutine three()\n+    integer, parameter :: lb1 = 0, lb2 = 0\n+\n+    integer :: i_sgn1, i_sgn2, i, i_e, i_s, j, j_e, j_s\n+    integer, save :: caf(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: caf2(lb1:n+lb1-1, lb2:m+lb2-1)[*]\n+    integer, save :: a(lb1:n+lb1-1, lb2:m+lb2-1)\n+    integer, save :: b(lb1:n+lb1-1, lb2:m+lb2-1)\n+\n+    b = reshape([(i*33, i = 1, size(b))], shape(b))\n+\n+    ! Whole array: ARRAY = ARRAY\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    a(:,:) = b(:,:)\n+    caf2(:,:)[this_image()] = caf(:,:)[num_images()]\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Scalar assignment\n+    caf = -42\n+    a = -42\n+    caf2 = -42\n+    if (this_image() == num_images()) then\n+      caf(:,:) = b(:,:)\n+    endif\n+    sync all\n+    do j = lb2, m+lb2-1\n+      do i = n+lb1-1, lb1, -2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    do j = lb2, m+lb2-1\n+      do i = lb1, n+lb1-1, 2\n+        a(i,j) = b(i,j)\n+        caf2(i,j)[this_image()] = caf(i,j)[num_images()]\n+      end do\n+    end do\n+    if (any (a /= caf2)) then\n+      call abort()\n+    end if\n+\n+    ! Array sections with different ranges and pos/neg strides\n+    do i_sgn1 = -1, 1, 2\n+      do i_sgn2 = -1, 1, 2\n+        do i=lb1, n+lb1-1\n+          do i_e=lb1, n+lb1-1\n+            do i_s=1, n\n+              do j=lb2, m+lb2-1\n+                do j_e=lb2, m+lb2-1\n+                  do j_s=1, m\n+                    ! ARRAY = ARRAY\n+                    caf = -42\n+                    a = -42\n+                    caf2 = -42\n+                    if (this_image() == num_images()) then\n+                      caf(:,:) = b(:,:)\n+                    endif\n+                    sync all\n+                    a(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2) &\n+                         = b(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)\n+                    caf2(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[this_image()] &\n+                         = caf(i:i_e:i_s*i_sgn1, j:j_e:j_s*i_sgn2)[num_images()]\n+                    if (any (caf2 /= a)) then\n+                      call abort()\n+                    end if\n+                  end do\n+                end do\n+              end do\n+            end do\n+          end do\n+        end do\n+      end do\n+    end do\n+  end subroutine three\n+end program main"}, {"sha": "0a89a989635a242be369e552fe6e9a6f2fee599a", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -1,3 +1,16 @@\n+2014-06-17  Tobias Burnus  <burnus@net-b.de>\n+\n+\t* caf/libcaf.h (gfc_descriptor_t): New typedef.\n+\t(caf_vector_t): Update.\n+\t(_gfortran_caf_co_sum, _gfortran_caf_co_max, _gfortran_caf_co_min):\n+\tRemove vector-subscript argument.\n+\t(_gfortran_caf_co_send, _gfortran_caf_co_get,\n+\t_gfortran_caf_co_sendget): New.\n+\t* caf/single.c (_gfortran_caf_co_sum, _gfortran_caf_co_max,\n+\t_gfortran_caf_co_min): Remove vector-subscript argument.\n+\t(_gfortran_caf_co_send, _gfortran_caf_co_get,\n+\t_gfortran_caf_co_sendget): New.\n+\n 2014-06-17  Janne Blomqvist  <jb@gcc.gnu.org>\n \n \t* libgfortran.h (xmallocarray): New prototype."}, {"sha": "2c97880f122cbd475cc4ed069a480e981785761d", "filename": "libgfortran/caf/libcaf.h", "status": "modified", "additions": 27, "deletions": 8, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -30,6 +30,9 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #include <stddef.h>\t/* For size_t.  */\n #include <stdint.h>\t/* For int32_t.  */\n \n+#include \"libgfortran.h\"\n+\n+#if 0\n #ifndef __GNUC__\n #define __attribute__(x)\n #define likely(x)       (x)\n@@ -45,6 +48,7 @@ see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n #define STAT_LOCKED\t\t1\n #define STAT_LOCKED_OTHER_IMAGE\t2\n #define STAT_STOPPED_IMAGE \t6000\n+#endif\n \n /* Describes what type of array we are registerring. Keep in sync with\n    gcc/fortran/trans.h.  */\n@@ -57,6 +61,7 @@ typedef enum caf_register_t {\n caf_register_t;\n \n typedef void* caf_token_t;\n+typedef gfc_array_void gfc_descriptor_t;\n \n /* Linked list of static coarrays registered.  */\n typedef struct caf_static_t {\n@@ -65,13 +70,19 @@ typedef struct caf_static_t {\n }\n caf_static_t;\n \n+/* When there is a vector subscript in this dimension, nvec == 0, otherwise,\n+   lower_bound, upper_bound, stride contains the bounds relative to the declared\n+   bounds; kind denotes the integer kind of the elements of vector[].  */\n typedef struct caf_vector_t {\n-  size_t nvec;  /* size of the vector; 0 means dim triplet.  */\n+  size_t nvec;\n   union {\n+    struct {\n+      void *vector;\n+      int kind;\n+    } v;\n     struct {\n       ptrdiff_t lower_bound, upper_bound, stride;\n     } triplet;\n-    ptrdiff_t *vector;\n   } u;\n }\n caf_vector_t;\n@@ -103,10 +114,18 @@ void _gfortran_caf_error_stop_str (const char *, int32_t)\n      __attribute__ ((noreturn));\n void _gfortran_caf_error_stop (int32_t) __attribute__ ((noreturn));\n \n-void _gfortran_caf_co_sum (void *, caf_vector_t *, int, int *, char *, int);\n-void _gfortran_caf_co_min (void *, caf_vector_t *, int, int *, char *, int,\n-\t\t\t   int);\n-void _gfortran_caf_co_max (void *, caf_vector_t *, int, int *, char *, int,\n-\t\t\t   int);\n-\n+void _gfortran_caf_co_sum (gfc_descriptor_t *, int, int *,\n+\t\t\t   char *, int);\n+void _gfortran_caf_co_min (gfc_descriptor_t *, int, int *, char *,\n+\t\t\t   int, int);\n+void _gfortran_caf_co_max (gfc_descriptor_t *, int, int *, char *,\n+\t\t\t   int, int);\n+\n+void _gfortran_caf_get (caf_token_t, size_t, int, gfc_descriptor_t *,\n+                        caf_vector_t *, gfc_descriptor_t *, int, int);\n+void _gfortran_caf_send (caf_token_t, size_t, int, gfc_descriptor_t *,\n+\t\t\t caf_vector_t *, gfc_descriptor_t *, int, int);\n+void _gfortran_caf_sendget (caf_token_t, size_t, int, gfc_descriptor_t *,\n+\t\t\t    caf_vector_t *, caf_token_t, size_t, int,\n+\t\t\t    gfc_descriptor_t *, caf_vector_t *, int, int);\n #endif  /* LIBCAF_H  */"}, {"sha": "cf1d420758a99035846e411c6710d1d100f466b1", "filename": "libgfortran/caf/single.c", "status": "modified", "additions": 234, "deletions": 6, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b511626828a636ed6310cd94c4fa78365450fb34/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=b511626828a636ed6310cd94c4fa78365450fb34", "patch": "@@ -205,8 +205,7 @@ _gfortran_caf_error_stop (int32_t error)\n \n \n void\n-_gfortran_caf_co_sum (void *a __attribute__ ((unused)),\n-\t\t      caf_vector_t vector[] __attribute__ ((unused)),\n+_gfortran_caf_co_sum (gfc_descriptor_t *a __attribute__ ((unused)),\n \t\t      int result_image __attribute__ ((unused)),\n \t\t      int *stat, char *errmsg __attribute__ ((unused)),\n \t\t      int errmsg_len __attribute__ ((unused)))\n@@ -216,8 +215,7 @@ _gfortran_caf_co_sum (void *a __attribute__ ((unused)),\n }\n \n void\n-_gfortran_caf_co_min (void *a __attribute__ ((unused)),\n-\t\t      caf_vector_t vector[] __attribute__ ((unused)),\n+_gfortran_caf_co_min (gfc_descriptor_t *a __attribute__ ((unused)),\n \t\t      int result_image __attribute__ ((unused)),\n \t\t      int *stat, char *errmsg __attribute__ ((unused)),\n \t\t      int src_len __attribute__ ((unused)),\n@@ -228,8 +226,7 @@ _gfortran_caf_co_min (void *a __attribute__ ((unused)),\n }\n \n void\n-_gfortran_caf_co_max (void *a __attribute__ ((unused)),\n-\t\t      caf_vector_t vector[] __attribute__ ((unused)),\n+_gfortran_caf_co_max (gfc_descriptor_t *a __attribute__ ((unused)),\n \t\t      int result_image __attribute__ ((unused)),\n \t\t      int *stat, char *errmsg __attribute__ ((unused)),\n \t\t      int src_len __attribute__ ((unused)),\n@@ -238,3 +235,234 @@ _gfortran_caf_co_max (void *a __attribute__ ((unused)),\n   if (stat)\n     stat = 0;\n }\n+\n+void\n+_gfortran_caf_get (caf_token_t token, size_t offset,\n+\t\t   int image_index __attribute__ ((unused)),\n+\t\t   gfc_descriptor_t *src ,\n+\t\t   caf_vector_t *src_vector __attribute__ ((unused)),\n+\t\t   gfc_descriptor_t *dest, int src_kind, int dst_kind)\n+{\n+  /* FIXME: Handle vector subscript, type conversion and assignment \"array = scalar\".\n+     check in particular whether strings of different kinds are permitted and\n+     whether it makes sense to handle array = scalar.  */\n+  size_t i, k, size;\n+  int j;\n+  int rank = GFC_DESCRIPTOR_RANK (dest);\n+  size_t src_size = GFC_DESCRIPTOR_SIZE (src);\n+  size_t dst_size = GFC_DESCRIPTOR_SIZE (dest);\n+\n+  if (rank == 0)\n+    {\n+      void *sr = (void *) ((char *) TOKEN (token) + offset);\n+      if (dst_kind == src_kind)\n+\tmemmove (GFC_DESCRIPTOR_DATA (dest), sr,\n+\t\t dst_size > src_size ? src_size : dst_size);\n+      /* else: FIXME: type conversion.  */\n+      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_size > src_size)\n+\t{\n+\t  if (dst_kind == 1)\n+\t    memset ((void*)(char*) GFC_DESCRIPTOR_DATA (dest) + src_size, ' ',\n+\t\t    dst_size-src_size);\n+\t  else /* dst_kind == 4.  */\n+\t    for (i = src_size/4; i < dst_size/4; i++)\n+\t      ((int32_t*) GFC_DESCRIPTOR_DATA (dest))[i] = (int32_t)' ';\n+\t}\n+      return;\n+    }\n+\n+  size = 1;\n+  for (j = 0; j < rank; j++)\n+    {\n+      ptrdiff_t dimextent = dest->dim[j]._ubound - dest->dim[j].lower_bound + 1;\n+      if (dimextent < 0)\n+\tdimextent = 0;\n+      size *= dimextent;\n+    }\n+\n+  if (size == 0)\n+    return;\n+\n+  for (i = 0; i < size; i++)\n+    {\n+      ptrdiff_t array_offset_dst = 0;\n+      ptrdiff_t stride = 1;\n+      ptrdiff_t extent = 1;\n+      for (j = 0; j < rank-1; j++)\n+\t{\n+\t  array_offset_dst += ((i / (extent*stride))\n+\t\t\t       % (dest->dim[j]._ubound\n+\t\t\t\t  - dest->dim[j].lower_bound + 1))\n+\t\t\t      * dest->dim[j]._stride;\n+\t  extent = (dest->dim[j]._ubound - dest->dim[j].lower_bound + 1);\n+          stride = dest->dim[j]._stride;\n+\t}\n+      array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n+      void *dst = dest->base_addr + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest);\n+\n+      void *sr;\n+      if (GFC_DESCRIPTOR_RANK (src) != 0)\n+\t{\n+\t  ptrdiff_t array_offset_sr = 0;\n+\t  stride = 1;\n+\t  extent = 1;\n+\t  for (j = 0; j < GFC_DESCRIPTOR_RANK (src)-1; j++)\n+\t    {\n+\t      array_offset_sr += ((i / (extent*stride))\n+\t\t\t\t  % (src->dim[j]._ubound\n+\t\t\t\t     - src->dim[j].lower_bound + 1))\n+\t\t\t\t * src->dim[j]._stride;\n+\t      extent = (src->dim[j]._ubound - src->dim[j].lower_bound + 1);\n+\t      stride = src->dim[j]._stride;\n+\t    }\n+\t  array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n+\t  sr = (void *)((char *) TOKEN (token) + offset\n+\t\t\t+ array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n+\t}\n+      else\n+\tsr = (void *)((char *) TOKEN (token) + offset);\n+\n+      if (dst_kind == src_kind)\n+\tmemmove (dst, sr, dst_size > src_size ? src_size : dst_size);\n+      /* else: FIXME: type conversion.  */\n+      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_size > src_size)\n+\t{\n+\t  if (dst_kind == 1)\n+\t    memset ((void*)(char*) dst + src_size, ' ', dst_size-src_size);\n+\t  else /* dst_kind == 4.  */\n+\t    for (k = src_size/4; k < dst_size/4; i++)\n+\t      ((int32_t*) dst)[i] = (int32_t)' ';\n+\t}\n+    }\n+}\n+\n+\n+void\n+_gfortran_caf_send (caf_token_t token, size_t offset,\n+\t\t    int image_index __attribute__ ((unused)),\n+\t\t    gfc_descriptor_t *dest,\n+\t\t    caf_vector_t *dst_vector __attribute__ ((unused)),\n+\t\t    gfc_descriptor_t *src, int dst_kind,\n+\t\t    int src_kind __attribute__ ((unused)))\n+{\n+  /* FIXME: Handle vector subscript, type conversion and assignment \"array = scalar\".\n+     check in particular whether strings of different kinds are permitted.  */\n+  size_t i, k, size;\n+  int j;\n+  int rank = GFC_DESCRIPTOR_RANK (dest);\n+  size_t src_size = GFC_DESCRIPTOR_SIZE (src);\n+  size_t dst_size = GFC_DESCRIPTOR_SIZE (dest);\n+\n+  if (rank == 0)\n+    {\n+      void *dst = (void *) ((char *) TOKEN (token) + offset);\n+      if (dst_kind == src_kind)\n+\tmemmove (dst, GFC_DESCRIPTOR_DATA (src),\n+\t\t dst_size > src_size ? src_size : dst_size);\n+      /* else: FIXME: type conversion.  */\n+      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_size > src_size)\n+\t{\n+\t  if (dst_kind == 1)\n+\t    memset ((void*)(char*) dst + src_size, ' ', dst_size-src_size);\n+\t  else /* dst_kind == 4.  */\n+\t    for (i = src_size/4; i < dst_size/4; i++)\n+\t      ((int32_t*) dst)[i] = (int32_t)' ';\n+\t}\n+      return;\n+    }\n+\n+  size = 1;\n+  for (j = 0; j < rank; j++)\n+    {\n+      ptrdiff_t dimextent = dest->dim[j]._ubound - dest->dim[j].lower_bound + 1;\n+      if (dimextent < 0)\n+\tdimextent = 0;\n+      size *= dimextent;\n+    }\n+\n+  if (size == 0)\n+    return;\n+\n+#if 0\n+  if (dst_len == src_len && PREFIX (is_contiguous) (dest)\n+      && PREFIX (is_contiguous) (src))\n+    {\n+      void *dst = (void *)((char *) TOKEN (token) + offset);\n+      memmove (dst, src->base_addr, GFC_DESCRIPTOR_SIZE (dest)*size);\n+      return;\n+    }\n+#endif\n+\n+  for (i = 0; i < size; i++)\n+    {\n+      ptrdiff_t array_offset_dst = 0;\n+      ptrdiff_t stride = 1;\n+      ptrdiff_t extent = 1;\n+      for (j = 0; j < rank-1; j++)\n+\t{\n+\t  array_offset_dst += ((i / (extent*stride))\n+\t\t\t       % (dest->dim[j]._ubound\n+\t\t\t\t  - dest->dim[j].lower_bound + 1))\n+\t\t\t      * dest->dim[j]._stride;\n+\t  extent = (dest->dim[j]._ubound - dest->dim[j].lower_bound + 1);\n+          stride = dest->dim[j]._stride;\n+\t}\n+      array_offset_dst += (i / extent) * dest->dim[rank-1]._stride;\n+      void *dst = (void *)((char *) TOKEN (token) + offset\n+\t\t\t   + array_offset_dst*GFC_DESCRIPTOR_SIZE (dest));\n+      void *sr;\n+      if (GFC_DESCRIPTOR_RANK (src) != 0)\n+\t{\n+\t  ptrdiff_t array_offset_sr = 0;\n+\t  stride = 1;\n+\t  extent = 1;\n+\t  for (j = 0; j < GFC_DESCRIPTOR_RANK (src)-1; j++)\n+\t    {\n+\t      array_offset_sr += ((i / (extent*stride))\n+\t\t\t\t  % (src->dim[j]._ubound\n+\t\t\t\t     - src->dim[j].lower_bound + 1))\n+\t\t\t\t * src->dim[j]._stride;\n+\t      extent = (src->dim[j]._ubound - src->dim[j].lower_bound + 1);\n+\t      stride = src->dim[j]._stride;\n+\t    }\n+\t  array_offset_sr += (i / extent) * src->dim[rank-1]._stride;\n+\t  sr = (void *)((char *) src->base_addr\n+\t\t\t+ array_offset_sr*GFC_DESCRIPTOR_SIZE (src));\n+\t}\n+      else\n+\tsr = src->base_addr;\n+\n+      if (dst_kind == src_kind)\n+\tmemmove (dst, sr, dst_size > src_size ? src_size : dst_size);\n+      /* else: FIXME: type conversion.  */\n+      if (GFC_DESCRIPTOR_TYPE (dest) == BT_CHARACTER && dst_size > src_size)\n+\t{\n+\t  if (dst_kind == 1)\n+\t    memset ((void*)(char*) dst + src_size, ' ', dst_size-src_size);\n+\t  else /* dst_kind == 4.  */\n+\t    for (k = src_size/4; k < dst_size/4; i++)\n+\t      ((int32_t*) dst)[i] = (int32_t)' ';\n+\t}\n+    }\n+}\n+\n+\n+void\n+_gfortran_caf_sendget (caf_token_t dst_token, size_t dst_offset,\n+\t\t       int dst_image_index, gfc_descriptor_t *dest,\n+\t\t       caf_vector_t *dst_vector, caf_token_t src_token,\n+\t\t       size_t src_offset,\n+\t\t       int src_image_index __attribute__ ((unused)),\n+\t\t       gfc_descriptor_t *src,\n+\t\t       caf_vector_t *src_vector __attribute__ ((unused)),\n+\t\t       int dst_len, int src_len)\n+{\n+  /* FIXME: Handle vector subscript of 'src_vector'.  */\n+  /* For a single image, src->base_addr should be the same as src_token + offset\n+     but to play save, we do it properly.  */\n+  void *src_base = GFC_DESCRIPTOR_DATA (src);\n+  GFC_DESCRIPTOR_DATA (src) = (void *) ((char *) TOKEN (src_token) + src_offset);\n+  _gfortran_caf_send (dst_token, dst_offset, dst_image_index, dest, dst_vector,\n+\t\t      src, dst_len, src_len);\n+  GFC_DESCRIPTOR_DATA (src) = src_base;\n+}"}]}