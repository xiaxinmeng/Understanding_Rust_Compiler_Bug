{"sha": "48b881a36e2143eea33ed049da4905e341e7eb0f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDhiODgxYTM2ZTIxNDNlZWEzM2VkMDQ5ZGE0OTA1ZTM0MWU3ZWIwZg==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@hxi.com", "date": "2000-08-03T15:01:36Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-08-03T15:01:36Z"}, "message": "* jump.c: Fix formatting.\n\nFrom-SVN: r35453", "tree": {"sha": "db0e95fa7225df86fbbe911c8aaac9de62a8acfc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db0e95fa7225df86fbbe911c8aaac9de62a8acfc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/48b881a36e2143eea33ed049da4905e341e7eb0f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b881a36e2143eea33ed049da4905e341e7eb0f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48b881a36e2143eea33ed049da4905e341e7eb0f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48b881a36e2143eea33ed049da4905e341e7eb0f/comments", "author": null, "committer": null, "parents": [{"sha": "2e71ae828891078647eb38a16ac62dd865848c30", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2e71ae828891078647eb38a16ac62dd865848c30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2e71ae828891078647eb38a16ac62dd865848c30"}], "stats": {"total": 213, "additions": 114, "deletions": 99}, "files": [{"sha": "28f0b4e30716f7bf221f2c8f77616f5493c58350", "filename": "gcc/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b881a36e2143eea33ed049da4905e341e7eb0f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b881a36e2143eea33ed049da4905e341e7eb0f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=48b881a36e2143eea33ed049da4905e341e7eb0f", "patch": "@@ -10,6 +10,8 @@ Thu Aug  3 15:53:03 2000  J\"orn Rennecke <amylaar@cygnus.co.uk>\n \n 2000-08-03  Kazu Hirata  <kazu@hxi.com>\n \n+\t* jump.c: Fix formatting.\n+\n \t* toplev.c: Fix formatting.\n \n Thu Aug  3 01:05:32 2000  Jeffrey A Law  (law@cygnus.com)"}, {"sha": "5f575894a3062fe9cb4d60ed9870a7a1e33645d0", "filename": "gcc/jump.c", "status": "modified", "additions": 112, "deletions": 99, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/48b881a36e2143eea33ed049da4905e341e7eb0f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/48b881a36e2143eea33ed049da4905e341e7eb0f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=48b881a36e2143eea33ed049da4905e341e7eb0f", "patch": "@@ -19,7 +19,6 @@ along with GNU CC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n \n-\n /* This is the jump-optimization pass of the compiler.\n    It is run two or three times: once before cse, sometimes once after cse,\n    and once after reload (before final).\n@@ -156,6 +155,7 @@ rebuild_jump_labels (f)\n }\n \n /* Alternate entry into the jump optimizer.  Do only trivial optimizations.  */\n+\n void\n jump_optimize_minimal (f)\n      rtx f;\n@@ -280,7 +280,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t    && REGNO_FIRST_UID (REGNO (SET_DEST (set))) == INSN_UID (insn)\n \t    /* We use regno_last_note_uid so as not to delete the setting\n \t       of a reg that's used in notes.  A subsequent optimization\n-\t       might arrange to use that reg for real.  */\t       \n+\t       might arrange to use that reg for real.  */\n \t    && REGNO_LAST_NOTE_UID (REGNO (SET_DEST (set))) == INSN_UID (insn)\n \t    && ! side_effects_p (SET_SRC (set))\n \t    && ! find_reg_note (insn, REG_RETVAL, 0)\n@@ -374,7 +374,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\t  && dispatch != 0\n \t\t  && GET_CODE (dispatch) == JUMP_INSN\n \t\t  && JUMP_LABEL (dispatch) != 0\n-\t\t  /* Don't mess with a casesi insn. \n+\t\t  /* Don't mess with a casesi insn.\n \t\t     XXX according to the comment before computed_jump_p(),\n \t\t     all casesi insns should be a parallel of the jump\n \t\t     and a USE of a LABEL_REF.  */\n@@ -422,7 +422,7 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan,\n \t\tfor (temp2 = insn; temp2 != temp; temp2 = NEXT_INSN (temp2))\n \t\t  if (GET_CODE (temp2) == NOTE && NOTE_LINE_NUMBER (temp2) > 0)\n \t\t    break;\n-\t\t  \n+\n \t      if (temp2 == temp)\n \t\t{\n \t\t  delete_jump (insn);\n@@ -791,7 +791,7 @@ init_label_info (f)\n   return largest_uid;\n }\n \n-/* Delete insns following barriers, up to next label. \n+/* Delete insns following barriers, up to next label.\n \n    Also delete no-op jumps created by gcse.  */\n \n@@ -865,7 +865,7 @@ mark_all_labels (f, cross_jump)\n \t    mark_all_labels (XEXP (PATTERN (insn), 2), cross_jump);\n \t    continue;\n \t  }\n-\t\n+\n \tmark_jump_label (PATTERN (insn), insn, cross_jump, 0);\n \tif (! INSN_DELETED_P (insn) && GET_CODE (insn) == JUMP_INSN)\n \t  {\n@@ -894,11 +894,11 @@ delete_unreferenced_labels (f)\n   rtx final = NULL_RTX;\n   rtx insn;\n \n-  for (insn = f; insn; )\n+  for (insn = f; insn;)\n     {\n       if (GET_CODE (insn) == CODE_LABEL\n-          && LABEL_NUSES (insn) == 0\n-          && LABEL_ALTERNATE_NAME (insn) == NULL)\n+\t  && LABEL_NUSES (insn) == 0\n+\t  && LABEL_ALTERNATE_NAME (insn) == NULL)\n \tinsn = delete_insn (insn);\n       else\n \t{\n@@ -919,7 +919,7 @@ delete_noop_moves (f)\n {\n   rtx insn, next;\n \n-  for (insn = f; insn; )\n+  for (insn = f; insn;)\n     {\n       next = NEXT_INSN (insn);\n \n@@ -1043,7 +1043,7 @@ delete_noop_moves (f)\n \t\t      || dreg != sreg)\n \t\t    break;\n \t\t}\n-\t\t  \n+\n \t      if (i < 0)\n \t\tdelete_insn (insn);\n \t    }\n@@ -1261,14 +1261,14 @@ duplicate_loop_exit_test (loop_start)\n \t      NOTE_SOURCE_FILE (copy) = NOTE_SOURCE_FILE (insn);\n \t    }\n \t  break;\n-\t  \n+\n \tcase INSN:\n \t  copy = emit_insn_before (copy_insn (PATTERN (insn)), loop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n-\t  \n+\n \t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n-\t  \n+\n \t  /* Copy all REG_NOTES except REG_LABEL since mark_jump_label will\n \t     make them.  */\n \t  for (link = REG_NOTES (insn); link; link = XEXP (link, 1))\n@@ -1289,9 +1289,10 @@ duplicate_loop_exit_test (loop_start)\n \t  if (reg_map && REG_NOTES (copy))\n \t    replace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t  break;\n-\t  \n+\n \tcase JUMP_INSN:\n-\t  copy = emit_jump_insn_before (copy_insn (PATTERN (insn)), loop_start);\n+\t  copy = emit_jump_insn_before (copy_insn (PATTERN (insn)),\n+\t\t\t\t\tloop_start);\n \t  if (reg_map)\n \t    replace_regs (PATTERN (copy), reg_map, max_reg, 1);\n \t  mark_jump_label (PATTERN (copy), copy, 0, 0);\n@@ -1301,9 +1302,9 @@ duplicate_loop_exit_test (loop_start)\n \t      if (reg_map)\n \t\treplace_regs (REG_NOTES (copy), reg_map, max_reg, 1);\n \t    }\n-\t  \n+\n \t  /* If this is a simple jump, add it to the jump chain.  */\n-\t  \n+\n \t  if (INSN_UID (copy) < max_jump_chain && JUMP_LABEL (copy)\n \t      && simplejump_p (copy))\n \t    {\n@@ -1312,7 +1313,7 @@ duplicate_loop_exit_test (loop_start)\n \t      jump_chain[INSN_UID (JUMP_LABEL (copy))] = copy;\n \t    }\n \t  break;\n-\t  \n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -1357,7 +1358,7 @@ duplicate_loop_exit_test (loop_start)\n   emit_note_before (NOTE_INSN_LOOP_VTOP, exitcode);\n \n   delete_insn (next_nonnote_insn (loop_start));\n-  \n+\n   /* Clean up.  */\n   if (reg_map)\n     free (reg_map);\n@@ -1477,7 +1478,7 @@ find_cross_jump (e1, e2, minimum, f1, f2)\n \n       p1 = PATTERN (i1);\n       p2 = PATTERN (i2);\n-\t\n+\n       /* If this is a CALL_INSN, compare register usage information.\n \t If we don't check this on stack register machines, the two\n \t CALL_INSNs might be merged leaving reg-stack.c with mismatching\n@@ -1775,7 +1776,7 @@ can_reverse_comparison_p (comparison, insn)\n   arg0 = XEXP (comparison, 0);\n \n   /* Make sure ARG0 is one of the actual objects being compared.  If we\n-     can't do this, we can't be sure the comparison can be reversed. \n+     can't do this, we can't be sure the comparison can be reversed.\n \n      Handle cc0 and a MODE_CC register.  */\n   if ((GET_CODE (arg0) == REG && GET_MODE_CLASS (GET_MODE (arg0)) == MODE_CC)\n@@ -1799,7 +1800,7 @@ can_reverse_comparison_p (comparison, insn)\n \n       if (! insn)\n \treturn 0;\n-\t\n+\n       for (prev = prev_nonnote_insn (insn);\n \t   prev != 0 && GET_CODE (prev) != CODE_LABEL;\n \t   prev = prev_nonnote_insn (prev))\n@@ -1827,7 +1828,7 @@ can_reverse_comparison_p (comparison, insn)\n \n    WATCH OUT!  reverse_condition is not safe to use on a jump that might\n    be acting on the results of an IEEE floating point comparison, because\n-   of the special treatment of non-signaling nans in comparisons.  \n+   of the special treatment of non-signaling nans in comparisons.\n    Use can_reverse_comparison_p to be sure.  */\n \n enum rtx_code\n@@ -2092,7 +2093,7 @@ comparison_dominates_p (code1, code2)\n       if (code2 == NE)\n \treturn 1;\n       break;\n-      \n+\n     default:\n       break;\n     }\n@@ -2113,8 +2114,8 @@ simplejump_p (insn)\n }\n \n /* Return nonzero if INSN is a (possibly) conditional jump\n-   and nothing more.  \n- \n+   and nothing more.\n+\n    Use this function is deprecated, since we need to support combined\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n@@ -2131,20 +2132,21 @@ condjump_p (insn)\n   x = SET_SRC (x);\n   if (GET_CODE (x) == LABEL_REF)\n     return 1;\n-  else return (GET_CODE (x) == IF_THEN_ELSE\n-\t       && ((GET_CODE (XEXP (x, 2)) == PC\n-\t\t    && (GET_CODE (XEXP (x, 1)) == LABEL_REF\n-\t\t\t|| GET_CODE (XEXP (x, 1)) == RETURN))\n-\t\t   || (GET_CODE (XEXP (x, 1)) == PC\n-\t\t       && (GET_CODE (XEXP (x, 2)) == LABEL_REF\n-\t\t\t   || GET_CODE (XEXP (x, 2)) == RETURN))));\n+  else\n+    return (GET_CODE (x) == IF_THEN_ELSE\n+\t    && ((GET_CODE (XEXP (x, 2)) == PC\n+\t\t && (GET_CODE (XEXP (x, 1)) == LABEL_REF\n+\t\t     || GET_CODE (XEXP (x, 1)) == RETURN))\n+\t\t|| (GET_CODE (XEXP (x, 1)) == PC\n+\t\t    && (GET_CODE (XEXP (x, 2)) == LABEL_REF\n+\t\t\t|| GET_CODE (XEXP (x, 2)) == RETURN))));\n \n   return 0;\n }\n \n /* Return nonzero if INSN is a (possibly) conditional jump inside a\n    PARALLEL.\n- \n+\n    Use this function is deprecated, since we need to support combined\n    branch and compare insns.  Use any_condjump_p instead whenever possible.  */\n \n@@ -2237,7 +2239,7 @@ any_condjump_p (insn)\n   b = GET_CODE (XEXP (SET_SRC (x), 2));\n \n   return ((b == PC && (a == LABEL_REF || a == RETURN))\n-          || (a == PC && (b == LABEL_REF || b == RETURN)));\n+\t  || (a == PC && (b == LABEL_REF || b == RETURN)));\n }\n \n /* Return the label of a conditional jump.  */\n@@ -2469,11 +2471,11 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \n     case SYMBOL_REF:\n       if (!in_mem)\n-        return;\n+\treturn;\n \n       /* If this is a constant-pool reference, see if it is a label.  */\n       if (CONSTANT_POOL_ADDRESS_P (x))\n-        mark_jump_label (get_pool_constant (x), insn, cross_jump, in_mem);\n+\tmark_jump_label (get_pool_constant (x), insn, cross_jump, in_mem);\n       break;\n \n     case LABEL_REF:\n@@ -2485,7 +2487,7 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \n \t/* Ignore remaining references to unreachable labels that\n \t   have been deleted.  */\n-        if (GET_CODE (label) == NOTE\n+\tif (GET_CODE (label) == NOTE\n \t    && NOTE_LINE_NUMBER (label) == NOTE_INSN_DELETED_LABEL)\n \t  break;\n \n@@ -2513,7 +2515,8 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t\t\t || NOTE_LINE_NUMBER (next) == NOTE_INSN_FUNCTION_END\n \t\t\t /* ??? Optional.  Disables some optimizations, but\n \t\t\t    makes gcov output more accurate with -O.  */\n-\t\t\t || (flag_test_coverage && NOTE_LINE_NUMBER (next) > 0)))\n+\t\t\t || (flag_test_coverage\n+\t\t\t     && NOTE_LINE_NUMBER (next) > 0)))\n \t      break;\n \t  }\n \n@@ -2565,11 +2568,11 @@ mark_jump_label (x, insn, cross_jump, in_mem)\n \t  int eltnum = code == ADDR_DIFF_VEC ? 1 : 0;\n \n \t  for (i = 0; i < XVECLEN (x, eltnum); i++)\n-\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX, \n-                    cross_jump, in_mem);\n+\t    mark_jump_label (XVECEXP (x, eltnum, i), NULL_RTX,\n+\t\t\t     cross_jump, in_mem);\n \t}\n       return;\n-      \n+\n     default:\n       break;\n     }\n@@ -2680,12 +2683,15 @@ delete_prior_computation (note, insn)\n \t    {\n \t      int dest_regno = REGNO (SET_DEST (pat));\n \t      int dest_endregno\n-\t\t    = dest_regno + (dest_regno < FIRST_PSEUDO_REGISTER \n+\t\t= (dest_regno\n+\t\t   + (dest_regno < FIRST_PSEUDO_REGISTER\n \t\t      ? HARD_REGNO_NREGS (dest_regno,\n-\t\t\t\tGET_MODE (SET_DEST (pat))) : 1);\n+\t\t\t\t\t  GET_MODE (SET_DEST (pat))) : 1));\n \t      int regno = REGNO (reg);\n-\t      int endregno = regno + (regno < FIRST_PSEUDO_REGISTER \n-\t\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (reg)) : 1);\n+\t      int endregno\n+\t\t= (regno\n+\t\t   + (regno < FIRST_PSEUDO_REGISTER\n+\t\t      ? HARD_REGNO_NREGS (regno, GET_MODE (reg)) : 1));\n \n \t      if (dest_regno >= regno\n \t\t  && dest_endregno <= endregno)\n@@ -2701,7 +2707,8 @@ delete_prior_computation (note, insn)\n \t\t  int i;\n \n \t\t  REG_NOTES (our_prev)\n-\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED, reg, REG_NOTES (our_prev));\n+\t\t    = gen_rtx_EXPR_LIST (REG_UNUSED, reg,\n+\t\t\t\t\t REG_NOTES (our_prev));\n \n \t\t  for (i = dest_regno; i < dest_endregno; i++)\n \t\t    if (! find_regno_note (our_prev, REG_UNUSED, i))\n@@ -2787,24 +2794,25 @@ delete_computation (insn)\n   set = single_set (insn);\n   if (set && GET_CODE (SET_DEST (set)) == REG)\n     {\n-    int dest_regno = REGNO (SET_DEST (set));\n-    int dest_endregno\n-\t  = dest_regno + (dest_regno < FIRST_PSEUDO_REGISTER \n-\t    ? HARD_REGNO_NREGS (dest_regno,\n-\t\t\t\tGET_MODE (SET_DEST (set))) : 1);\n-    int i;\n-\n-    for (i = dest_regno; i < dest_endregno; i++)\n-      {\n-\tif (! refers_to_regno_p (i, i + 1, SET_SRC (set), NULL_PTR)\n-\t    || find_regno_note (insn, REG_DEAD, i))\n-\t  continue;\n-\n-\tnote = gen_rtx_EXPR_LIST (REG_DEAD, (i < FIRST_PSEUDO_REGISTER\n-\t\t\t\t\t     ? gen_rtx_REG (reg_raw_mode[i], i)\n-\t\t\t\t\t     : SET_DEST (set)), NULL_RTX);\n-\tdelete_prior_computation (note, insn);\n-      }\n+      int dest_regno = REGNO (SET_DEST (set));\n+      int dest_endregno\n+\t= dest_regno + (dest_regno < FIRST_PSEUDO_REGISTER\n+\t\t\t? HARD_REGNO_NREGS (dest_regno,\n+\t\t\t\t\t    GET_MODE (SET_DEST (set))) : 1);\n+      int i;\n+\n+      for (i = dest_regno; i < dest_endregno; i++)\n+\t{\n+\t  if (! refers_to_regno_p (i, i + 1, SET_SRC (set), NULL_PTR)\n+\t      || find_regno_note (insn, REG_DEAD, i))\n+\t    continue;\n+\n+\t  note = gen_rtx_EXPR_LIST (REG_DEAD,\n+\t\t\t\t    (i < FIRST_PSEUDO_REGISTER\n+\t\t\t\t     ? gen_rtx_REG (reg_raw_mode[i], i)\n+\t\t\t\t     : SET_DEST (set)), NULL_RTX);\n+\t  delete_prior_computation (note, insn);\n+\t}\n     }\n \n   for (note = REG_NOTES (insn); note; note = next)\n@@ -3067,28 +3075,28 @@ never_reached_warning (avoided_insn)\n   rtx a_line_note = NULL;\n   int two_avoided_lines = 0;\n   int contains_insn = 0;\n-  \n+\n   if (! warn_notreached)\n     return;\n \n   /* Scan forwards, looking at LINE_NUMBER notes, until\n      we hit a LABEL or we run out of insns.  */\n-  \n+\n   for (insn = avoided_insn; insn != NULL; insn = NEXT_INSN (insn))\n     {\n-       if (GET_CODE (insn) == CODE_LABEL)\n-\t break;\n-       else if (GET_CODE (insn) == NOTE\t\t/* A line number note? */ \n-\t\t&& NOTE_LINE_NUMBER (insn) >= 0)\n+      if (GET_CODE (insn) == CODE_LABEL)\n+\tbreak;\n+      else if (GET_CODE (insn) == NOTE\t\t/* A line number note?  */\n+\t       && NOTE_LINE_NUMBER (insn) >= 0)\n \t{\n \t  if (a_line_note == NULL)\n \t    a_line_note = insn;\n \t  else\n \t    two_avoided_lines |= (NOTE_LINE_NUMBER (a_line_note)\n \t\t\t\t  != NOTE_LINE_NUMBER (insn));\n \t}\n-       else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n-\t contains_insn = 1;\n+      else if (GET_RTX_CLASS (GET_CODE (insn)) == 'i')\n+\tcontains_insn = 1;\n     }\n   if (two_avoided_lines && contains_insn)\n     warning_with_file_and_line (NOTE_SOURCE_FILE (a_line_note),\n@@ -3118,7 +3126,7 @@ redirect_exp_1 (loc, olabel, nlabel, insn)\n \t  if (nlabel)\n \t    n = gen_rtx_LABEL_REF (VOIDmode, nlabel);\n \t  else\n-\t    n = gen_rtx_RETURN (VOIDmode); \n+\t    n = gen_rtx_RETURN (VOIDmode);\n \n \t  validate_change (insn, loc, n, 1);\n \t  return;\n@@ -3254,7 +3262,7 @@ redirect_jump (jump, nlabel, delete_unused)\n   return 1;\n }\n \n-/* Invert the jump condition of rtx X contained in jump insn, INSN.  \n+/* Invert the jump condition of rtx X contained in jump insn, INSN.\n    Accrue the modifications into the change group.  */\n \n static void\n@@ -3265,7 +3273,7 @@ invert_exp_1 (insn)\n   rtx x = pc_set (insn);\n \n   if (!x)\n-    abort();\n+    abort ();\n   x = SET_SRC (x);\n \n   code = GET_CODE (x);\n@@ -3289,7 +3297,7 @@ invert_exp_1 (insn)\n \t\t\t   1);\n \t  return;\n \t}\n-\t\t\t\t       \n+\n       tem = XEXP (x, 1);\n       validate_change (insn, &XEXP (x, 1), XEXP (x, 2), 1);\n       validate_change (insn, &XEXP (x, 2), tem, 1);\n@@ -3298,7 +3306,7 @@ invert_exp_1 (insn)\n     abort ();\n }\n \n-/* Invert the jump condition of conditional jump insn, INSN. \n+/* Invert the jump condition of conditional jump insn, INSN.\n \n    Return 1 if we can do so, 0 if we cannot find a way to do so that\n    matches a pattern.  */\n@@ -3386,7 +3394,8 @@ delete_from_jump_chain (jump)\n   /* Handle return insns.  */\n   else if (jump_chain && GET_CODE (PATTERN (jump)) == RETURN)\n     index = 0;\n-  else return;\n+  else\n+    return;\n \n   if (jump_chain[index] == jump)\n     jump_chain[index] = jump_chain[INSN_UID (jump)];\n@@ -3497,7 +3506,7 @@ rtx_renumbered_equal_p (x, y)\n   register int i;\n   register RTX_CODE code = GET_CODE (x);\n   register const char *fmt;\n-      \n+\n   if (x == y)\n     return 1;\n \n@@ -3557,7 +3566,7 @@ rtx_renumbered_equal_p (x, y)\n       return reg_x >= 0 && reg_x == reg_y && word_x == word_y;\n     }\n \n-  /* Now we have disposed of all the cases \n+  /* Now we have disposed of all the cases\n      in which different rtx codes can match.  */\n   if (code != GET_CODE (y))\n     return 0;\n@@ -3711,7 +3720,7 @@ true_regnum (x)\n    In general, if the first test fails, the program can branch\n    directly to `foo' and skip the second try which is doomed to fail.\n    We run this after loop optimization and before flow analysis.  */\n-   \n+\n /* When comparing the insn patterns, we track the fact that different\n    pseudo-register numbers may have been used in each computation.\n    The following array stores an equivalence -- same_regs[I] == J means\n@@ -3733,7 +3742,7 @@ static char *modified_regs;\n \n static int modified_mem;\n \n-/* Called via note_stores on each insn between the target of the first \n+/* Called via note_stores on each insn between the target of the first\n    branch and the second branch.  It marks any changed registers.  */\n \n static void\n@@ -3763,7 +3772,7 @@ mark_modified_reg (dest, x, data)\n }\n \n /* F is the first insn in the chain of insns.  */\n-   \n+\n void\n thread_jumps (f, max_reg, flag_before_loop)\n      rtx f;\n@@ -3779,7 +3788,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n      will either always succeed or always fail depending on the relative\n      senses of the two branches.  So adjust the first branch accordingly\n      in this case.  */\n-     \n+\n   rtx label, b1, b2, t1, t2;\n   enum rtx_code code1, code2;\n   rtx b1op0, b1op1, b2op0, b2op1;\n@@ -3793,7 +3802,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n   all_reset = (int *) xmalloc (max_reg * sizeof (int));\n   for (i = 0; i < max_reg; i++)\n     all_reset[i] = -1;\n-    \n+\n   while (changed)\n     {\n       changed = 0;\n@@ -3802,6 +3811,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t{\n \t  rtx set;\n \t  rtx set2;\n+\n \t  /* Get to a candidate branch insn.  */\n \t  if (GET_CODE (b1) != JUMP_INSN\n \t      || ! any_condjump_p (b1) || JUMP_LABEL (b1) == 0)\n@@ -3891,12 +3901,13 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t      && rtx_equal_for_thread_p (b1op1, b2op1, b2)\n \t      && (comparison_dominates_p (code1, code2)\n \t\t  || (can_reverse_comparison_p (XEXP (SET_SRC (set), 0), b1)\n-\t\t      && comparison_dominates_p (code1, reverse_condition (code2)))))\n+\t\t      && comparison_dominates_p (code1,\n+\t\t\t\t\t\t reverse_condition (code2)))))\n \n \t    {\n \t      t1 = prev_nonnote_insn (b1);\n \t      t2 = prev_nonnote_insn (b2);\n-\t      \n+\n \t      while (t1 != 0 && t2 != 0)\n \t\t{\n \t\t  if (t2 == label)\n@@ -3912,7 +3923,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t\t\tbreak;\n \n \t\t      if (comparison_dominates_p (code1, code2))\n-\t\t      \tnew_label = JUMP_LABEL (b2);\n+\t\t\tnew_label = JUMP_LABEL (b2);\n \t\t      else\n \t\t\tnew_label = get_label_after (b2);\n \n@@ -3934,7 +3945,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t\t\t}\n \t\t      break;\n \t\t    }\n-\t\t    \n+\n \t\t  /* If either of these is not a normal insn (it might be\n \t\t     a JUMP_INSN, CALL_INSN, or CODE_LABEL) we fail.  (NOTEs\n \t\t     have already been skipped above.)  Similarly, fail\n@@ -3944,7 +3955,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n \t\t      || ! rtx_equal_for_thread_p (PATTERN (t1),\n \t\t\t\t\t\t   PATTERN (t2), t2))\n \t\t    break;\n-\t\t    \n+\n \t\t  t1 = prev_nonnote_insn (t1);\n \t\t  t2 = prev_nonnote_insn (t2);\n \t\t}\n@@ -3961,7 +3972,7 @@ thread_jumps (f, max_reg, flag_before_loop)\n /* This is like RTX_EQUAL_P except that it knows about our handling of\n    possibly equivalent registers and knows to consider volatile and\n    modified objects as not equal.\n-   \n+\n    YINSN is the insn containing Y.  */\n \n int\n@@ -4025,7 +4036,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \t  num_same_regs++;\n \n \t  /* If this is the first time we are seeing a register on the `Y'\n-\t     side, see if it is the last use.  If not, we can't thread the \n+\t     side, see if it is the last use.  If not, we can't thread the\n \t     jump, so mark it as not equivalent.  */\n \t  if (REGNO_LAST_UID (REGNO (y)) != INSN_UID (yinsn))\n \t    return 0;\n@@ -4057,7 +4068,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n       if (GET_CODE (SET_DEST (x)) == REG\n           && GET_CODE (SET_DEST (y)) == REG)\n \t{\n-          if (same_regs[REGNO (SET_DEST (x))] == (int) REGNO (SET_DEST (y)))\n+\t  if (same_regs[REGNO (SET_DEST (x))] == (int) REGNO (SET_DEST (y)))\n \t    {\n \t      same_regs[REGNO (SET_DEST (x))] = -1;\n \t      num_same_regs--;\n@@ -4066,8 +4077,10 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \t    return 0;\n \t}\n       else\n-\tif (rtx_equal_for_thread_p (SET_DEST (x), SET_DEST (y), yinsn) == 0)\n-\t  return 0;\n+\t{\n+\t  if (rtx_equal_for_thread_p (SET_DEST (x), SET_DEST (y), yinsn) == 0)\n+\t    return 0;\n+\t}\n \n       return rtx_equal_for_thread_p (SET_SRC (x), SET_SRC (y), yinsn);\n \n@@ -4076,7 +4089,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \n     case SYMBOL_REF:\n       return XSTR (x, 0) == XSTR (y, 0);\n-      \n+\n     default:\n       break;\n     }\n@@ -4109,7 +4122,7 @@ rtx_equal_for_thread_p (x, y, yinsn)\n \t  /* And the corresponding elements must match.  */\n \t  for (j = 0; j < XVECLEN (x, i); j++)\n \t    if (rtx_equal_for_thread_p (XVECEXP (x, i, j),\n-\t    \t\t\t        XVECEXP (y, i, j), yinsn) == 0)\n+\t\t\t\t\tXVECEXP (y, i, j), yinsn) == 0)\n \t      return 0;\n \t  break;\n "}]}