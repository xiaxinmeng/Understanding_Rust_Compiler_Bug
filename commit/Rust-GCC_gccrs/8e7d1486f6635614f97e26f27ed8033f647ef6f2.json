{"sha": "8e7d1486f6635614f97e26f27ed8033f647ef6f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGU3ZDE0ODZmNjYzNTYxNGY5N2UyNmYyN2VkODAzM2Y2NDdlZjZmMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2017-11-06T13:45:41Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2017-11-06T13:45:41Z"}, "message": "re PR bootstrap/82832 (Broken PGO LTO bootstrap on x86_64 after r254379)\n\n\n\tPR bootstrap/82832\n\t* ipa-inline-transform.c (update_noncloned_frequencies): Always\n\tscale.\n\t(inline_transform): Likewise.\n\t* predict.c (counts_to_freqs): Remove useless conditional.\n\t* profile-count.h (profile_count::apply_scale): Move sanity check.\n\t* tree-inline.c (copy_bb): Always scale.\n\t(copy_cfg_body): Likewise.\n\nFrom-SVN: r254452", "tree": {"sha": "48517ad3ae0dc37801c611131c9093c4b7475294", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48517ad3ae0dc37801c611131c9093c4b7475294"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8e7d1486f6635614f97e26f27ed8033f647ef6f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7d1486f6635614f97e26f27ed8033f647ef6f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8e7d1486f6635614f97e26f27ed8033f647ef6f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8e7d1486f6635614f97e26f27ed8033f647ef6f2/comments", "author": null, "committer": null, "parents": [{"sha": "454f8b2b0c6f9645b3df6be98efe2ca520f2ce82", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/454f8b2b0c6f9645b3df6be98efe2ca520f2ce82", "html_url": "https://github.com/Rust-GCC/gccrs/commit/454f8b2b0c6f9645b3df6be98efe2ca520f2ce82"}], "stats": {"total": 74, "additions": 57, "deletions": 17}, "files": [{"sha": "26afa77f726622ace592c9f7a578c7c26840ddf6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8e7d1486f6635614f97e26f27ed8033f647ef6f2", "patch": "@@ -1,3 +1,14 @@\n+2017-11-06  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR bootstrap/82832\n+\t* ipa-inline-transform.c (update_noncloned_frequencies): Always\n+\tscale.\n+\t(inline_transform): Likewise.\n+\t* predict.c (counts_to_freqs): Remove useless conditional.\n+\t* profile-count.h (profile_count::apply_scale): Move sanity check.\n+\t* tree-inline.c (copy_bb): Always scale.\n+\t(copy_cfg_body): Likewise.\n+\n 2017-11-06  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \tPR target/67591"}, {"sha": "e367df7df0e5c507f7ebf2bd8da86462cf82b4b4", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=8e7d1486f6635614f97e26f27ed8033f647ef6f2", "patch": "@@ -59,7 +59,18 @@ update_noncloned_frequencies (struct cgraph_node *node,\n \t\t\t      profile_count den)\n {\n   struct cgraph_edge *e;\n-  bool scale = (num == profile_count::zero () || den > 0);\n+\n+  /* We always must scale to be sure counters end up compatible.\n+     If den is zero, just force it nonzero and hope for reasonable\n+     approximation.\n+     When num is forced nonzero, also update den, so we do not scale profile\n+     to 0.   */\n+  if (!(num == den)\n+      && !(den.force_nonzero () == den))\n+    {\n+      den = den.force_nonzero ();\n+      num = num.force_nonzero ();\n+    }\n \n   /* We do not want to ignore high loop nest after freq drops to 0.  */\n   if (!freq_scale)\n@@ -71,19 +82,16 @@ update_noncloned_frequencies (struct cgraph_node *node,\n         e->frequency = CGRAPH_FREQ_MAX;\n       if (!e->inline_failed)\n         update_noncloned_frequencies (e->callee, freq_scale, num, den);\n-      if (scale)\n-\te->count = e->count.apply_scale (num, den);\n+      e->count = e->count.apply_scale (num, den);\n     }\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       e->frequency = e->frequency * (gcov_type) freq_scale / CGRAPH_FREQ_BASE;\n       if (e->frequency > CGRAPH_FREQ_MAX)\n         e->frequency = CGRAPH_FREQ_MAX;\n-      if (scale)\n-\te->count = e->count.apply_scale (num, den);\n+      e->count = e->count.apply_scale (num, den);\n     }\n-  if (scale)\n-    node->count = node->count.apply_scale (num, den);\n+  node->count = node->count.apply_scale (num, den);\n }\n \n /* We removed or are going to remove the last call to NODE.\n@@ -692,7 +700,10 @@ inline_transform (struct cgraph_node *node)\n \n \t  basic_block bb;\n \t  FOR_ALL_BB_FN (bb, cfun)\n-\t    bb->count = bb->count.apply_scale (num, den);\n+\t    if (num == profile_count::zero ())\n+\t      bb->count = bb->count.global0 ();\n+\t    else\n+\t      bb->count = bb->count.apply_scale (num, den);\n \t  ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = node->count;\n \t}\n       todo = optimize_inline_calls (current_function_decl);"}, {"sha": "0fd2b72e135841c7ce57381e877ae8c32f85e16e", "filename": "gcc/predict.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=8e7d1486f6635614f97e26f27ed8033f647ef6f2", "patch": "@@ -3324,8 +3324,7 @@ counts_to_freqs (void)\n   basic_block bb;\n \n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR_FOR_FN (cfun), NULL, next_bb)\n-    if (!(bb->count < true_count_max))\n-      true_count_max = true_count_max.max (bb->count);\n+    true_count_max = true_count_max.max (bb->count);\n \n   cfun->cfg->count_max = true_count_max;\n "}, {"sha": "f16bbcb2b9f77cf7838f95df3305d627302622d4", "filename": "gcc/profile-count.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=8e7d1486f6635614f97e26f27ed8033f647ef6f2", "patch": "@@ -949,9 +949,9 @@ class GTY(()) profile_count\n \treturn num;\n       if (!initialized_p () || !num.initialized_p () || !den.initialized_p ())\n \treturn profile_count::uninitialized ();\n-      gcc_checking_assert (den.m_val);\n       if (num == den)\n \treturn *this;\n+      gcc_checking_assert (den.m_val);\n \n       profile_count ret;\n       uint64_t val;"}, {"sha": "7ef107247b55400cf7b7f46280107dcb187c3aba", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8e7d1486f6635614f97e26f27ed8033f647ef6f2/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=8e7d1486f6635614f97e26f27ed8033f647ef6f2", "patch": "@@ -1770,8 +1770,18 @@ copy_bb (copy_body_data *id, basic_block bb,\n   basic_block copy_basic_block;\n   tree decl;\n   basic_block prev;\n-  bool scale = !num.initialized_p ()\n-\t       || (den.nonzero_p () || num == profile_count::zero ());\n+\n+  /* We always must scale to be sure counters end up compatible.\n+     If den is zero, just force it nonzero and hope for reasonable\n+     approximation.\n+     When num is forced nonzero, also update den, so we do not scale profile\n+     to 0.   */\n+  if (!(num == den)\n+      && !(den.force_nonzero () == den))\n+    {\n+      den = den.force_nonzero ();\n+      num = num.force_nonzero ();\n+    }\n \n   /* Search for previous copied basic block.  */\n   prev = bb->prev_bb;\n@@ -1781,10 +1791,7 @@ copy_bb (copy_body_data *id, basic_block bb,\n   /* create_basic_block() will append every new block to\n      basic_block_info automatically.  */\n   copy_basic_block = create_basic_block (NULL, (basic_block) prev->aux);\n-  if (scale)\n-    copy_basic_block->count = bb->count.apply_scale (num, den);\n-  else if (num.initialized_p ())\n-    copy_basic_block->count = bb->count;\n+  copy_basic_block->count = bb->count.apply_scale (num, den);\n \n   copy_gsi = gsi_start_bb (copy_basic_block);\n \n@@ -2691,6 +2698,18 @@ copy_cfg_body (copy_body_data * id, profile_count,\n   profile_count den = ENTRY_BLOCK_PTR_FOR_FN (src_cfun)->count;\n   profile_count num = entry_block_map->count;\n \n+  /* We always must scale to be sure counters end up compatible.\n+     If den is zero, just force it nonzero and hope for reasonable\n+     approximation.\n+     When num is forced nonzero, also update den, so we do not scale profile\n+     to 0.   */\n+  if (!(num == den)\n+      && !(den.force_nonzero () == den))\n+    {\n+      den = den.force_nonzero ();\n+      num = num.force_nonzero ();\n+    }\n+\n   cfun_to_copy = id->src_cfun = DECL_STRUCT_FUNCTION (callee_fndecl);\n \n   /* Register specific tree functions.  */"}]}