{"sha": "622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjIyZDUyNTgyNmUyM2EyMGQ5ZjQwY2RmZDY1ZTBiNWZlNmJmMDNjYw==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2006-01-03T07:18:48Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2006-01-03T07:18:48Z"}, "message": "combine.c (reg_subword_p): New predicate to test whether the destination of a set refers to a...\n\n\n\t* combine.c (reg_subword_p): New predicate to test whether the\n\tdestination of a set refers to a subword/piece of a register.\n\t(try_combine): Generalize the code to merge the setting of a\n\tpseudo to a constant followed by a set of a subword of that\n\tregister to a constant.\n\nFrom-SVN: r109267", "tree": {"sha": "ca71c4d6b7a7a0bb7a6af6d0408755e5d2b2e383", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ca71c4d6b7a7a0bb7a6af6d0408755e5d2b2e383"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc/comments", "author": null, "committer": null, "parents": [{"sha": "36c88f344676f5fe62757d7a786a3643a6a332e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/36c88f344676f5fe62757d7a786a3643a6a332e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/36c88f344676f5fe62757d7a786a3643a6a332e9"}], "stats": {"total": 195, "additions": 145, "deletions": 50}, "files": [{"sha": "2aaeb5342f20c7d9f023d4b95f3617fafbe36539", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "patch": "@@ -1,3 +1,11 @@\n+2006-01-03  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* combine.c (reg_subword_p): New predicate to test whether the\n+\tdestination of a set refers to a subword/piece of a register.\n+\t(try_combine): Generalize the code to merge the setting of a\n+\tpseudo to a constant followed by a set of a subword of that\n+\tregister to a constant.\n+\n 2006-01-03  Kazu Hirata  <kazu@codesourcery.com>\n \n \t* basic-block.h (control_flow_graph): Change the type of"}, {"sha": "29ee191cba7f42878ac3c6a8536bf7c34be910c7", "filename": "gcc/combine.c", "status": "modified", "additions": 137, "deletions": 50, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/622d525826e23a20d9f40cdfd65e0b5fe6bf03cc/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=622d525826e23a20d9f40cdfd65e0b5fe6bf03cc", "patch": "@@ -1706,6 +1706,27 @@ can_change_dest_mode (rtx x, int added_sets, enum machine_mode mode)\n \t  && !REG_USERVAR_P (x));\n }\n \n+\n+/* Check whether X, the destination of a set, refers to part of\n+   the register specified by REG.  */\n+\n+static bool\n+reg_subword_p (rtx x, rtx reg)\n+{\n+  /* Check that reg is an integer mode register.  */\n+  if (!REG_P (reg) || GET_MODE_CLASS (GET_MODE (reg)) != MODE_INT)\n+    return false;\n+\n+  if (GET_CODE (x) == STRICT_LOW_PART\n+      || GET_CODE (x) == ZERO_EXTRACT)\n+    x = XEXP (x, 0);\n+\n+  return GET_CODE (x) == SUBREG\n+\t && SUBREG_REG (x) == reg\n+\t && GET_MODE_CLASS (GET_MODE (x)) == MODE_INT;\n+}\n+\n+\n /* Try to combine the insns I1 and I2 into I3.\n    Here I1 and I2 appear earlier than I3.\n    I1 can be zero; then we combine just I2 into I3.\n@@ -1870,74 +1891,140 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t    }\n     }\n \n-  /* If I2 is setting a double-word pseudo to a constant and I3 is setting\n-     one of those words to another constant, merge them by making a new\n+  /* If I2 is setting a pseudo to a constant and I3 is setting some\n+     sub-part of it to another constant, merge them by making a new\n      constant.  */\n   if (i1 == 0\n       && (temp = single_set (i2)) != 0\n       && (GET_CODE (SET_SRC (temp)) == CONST_INT\n \t  || GET_CODE (SET_SRC (temp)) == CONST_DOUBLE)\n-      && REG_P (SET_DEST (temp))\n-      && GET_MODE_CLASS (GET_MODE (SET_DEST (temp))) == MODE_INT\n-      && GET_MODE_SIZE (GET_MODE (SET_DEST (temp))) == 2 * UNITS_PER_WORD\n       && GET_CODE (PATTERN (i3)) == SET\n-      && GET_CODE (SET_DEST (PATTERN (i3))) == SUBREG\n-      && SUBREG_REG (SET_DEST (PATTERN (i3))) == SET_DEST (temp)\n-      && GET_MODE_CLASS (GET_MODE (SET_DEST (PATTERN (i3)))) == MODE_INT\n-      && GET_MODE_SIZE (GET_MODE (SET_DEST (PATTERN (i3)))) == UNITS_PER_WORD\n-      && GET_CODE (SET_SRC (PATTERN (i3))) == CONST_INT)\n+      && (GET_CODE (SET_SRC (PATTERN (i3))) == CONST_INT\n+\t  || GET_CODE (SET_SRC (PATTERN (i3))) == CONST_DOUBLE)\n+      && reg_subword_p (SET_DEST (PATTERN (i3)), SET_DEST (temp)))\n     {\n-      HOST_WIDE_INT lo, hi;\n+      rtx dest = SET_DEST (PATTERN (i3));\n+      int offset = -1;\n+      int width = 0;\n \n-      if (GET_CODE (SET_SRC (temp)) == CONST_INT)\n-\tlo = INTVAL (SET_SRC (temp)), hi = lo < 0 ? -1 : 0;\n-      else\n+      if (GET_CODE (dest) == STRICT_LOW_PART)\n \t{\n-\t  lo = CONST_DOUBLE_LOW (SET_SRC (temp));\n-\t  hi = CONST_DOUBLE_HIGH (SET_SRC (temp));\n+\t  width = GET_MODE_BITSIZE (GET_MODE (XEXP (dest, 0)));\n+\t  offset = 0;\n \t}\n-\n-      if (subreg_lowpart_p (SET_DEST (PATTERN (i3))))\n+      else if (GET_CODE (dest) == ZERO_EXTRACT)\n \t{\n-\t  /* We don't handle the case of the target word being wider\n-\t     than a host wide int.  */\n-\t  gcc_assert (HOST_BITS_PER_WIDE_INT >= BITS_PER_WORD);\n+\t  if (GET_CODE (XEXP (dest, 1)) == CONST_INT\n+\t      && GET_CODE (XEXP (dest, 2)) == CONST_INT)\n+\t    {\n+\t      width = INTVAL (XEXP (dest, 1));\n+\t      offset = INTVAL (XEXP (dest, 2));\n \n-\t  lo &= ~(UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1);\n-\t  lo |= (INTVAL (SET_SRC (PATTERN (i3)))\n-\t\t & (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1));\n+\t      if (BITS_BIG_ENDIAN)\n+\t\toffset = GET_MODE_BITSIZE (GET_MODE (XEXP (dest, 0)))\n+\t\t\t - width - offset;\n+\t    }\n \t}\n-      else if (HOST_BITS_PER_WIDE_INT == BITS_PER_WORD)\n-\thi = INTVAL (SET_SRC (PATTERN (i3)));\n-      else if (HOST_BITS_PER_WIDE_INT >= 2 * BITS_PER_WORD)\n+      else if (subreg_lowpart_p (dest))\n \t{\n-\t  int sign = -(int) ((unsigned HOST_WIDE_INT) lo\n-\t\t\t     >> (HOST_BITS_PER_WIDE_INT - 1));\n-\n-\t  lo &= ~ (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD\n-\t\t   (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD (1) - 1));\n-\t  lo |= (UWIDE_SHIFT_LEFT_BY_BITS_PER_WORD\n-\t\t (INTVAL (SET_SRC (PATTERN (i3)))));\n-\t  if (hi == sign)\n-\t    hi = lo < 0 ? -1 : 0;\n+\t  width = GET_MODE_BITSIZE (GET_MODE (dest));\n+\t  offset = 0;\n+\t}\n+      /* ??? Preserve the original logic to handle setting the high word\n+\t of double-word pseudos, where inner is half the size of outer\n+\t but not the lowpart.  This could be generalized by handling\n+\t SUBREG_BYTE, WORDS_BIG_ENDIAN and BYTES_BIG_ENDIAN ourselves.\n+\t Unfortunately this logic is tricky to get right and probably\n+\t not worth the effort.  */\n+      else if (GET_MODE_BITSIZE (GET_MODE (SET_DEST (temp)))\n+\t       == 2 * GET_MODE_BITSIZE (GET_MODE (dest)))\n+\t{\n+\t  width = GET_MODE_BITSIZE (GET_MODE (dest));\n+\t  offset = width;\n \t}\n-      else\n-\t/* We don't handle the case of the higher word not fitting\n-\t   entirely in either hi or lo.  */\n-\tgcc_unreachable ();\n \n-      combine_merges++;\n-      subst_insn = i3;\n-      subst_low_cuid = INSN_CUID (i2);\n-      added_sets_2 = added_sets_1 = 0;\n-      i2dest = SET_DEST (temp);\n-      i2dest_killed = dead_or_set_p (i2, i2dest);\n+      if (offset >= 0)\n+\t{\n+\t  HOST_WIDE_INT mhi, ohi, ihi;\n+\t  HOST_WIDE_INT mlo, olo, ilo;\n+\t  rtx inner = SET_SRC (PATTERN (i3));\n+\t  rtx outer = SET_SRC (temp);\n+\n+\t  if (GET_CODE (outer) == CONST_INT)\n+\t    {\n+\t      olo = INTVAL (outer);\n+\t      ohi = olo < 0 ? -1 : 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      olo = CONST_DOUBLE_LOW (outer);\n+\t      ohi = CONST_DOUBLE_HIGH (outer);\n+\t    }\n \n-      SUBST (SET_SRC (temp),\n-\t     immed_double_const (lo, hi, GET_MODE (SET_DEST (temp))));\n+\t  if (GET_CODE (inner) == CONST_INT)\n+\t    {\n+\t      ilo = INTVAL (inner);\n+\t      ihi = ilo < 0 ? -1 : 0;\n+\t    }\n+\t  else\n+\t    {\n+\t      ilo = CONST_DOUBLE_LOW (inner);\n+\t      ihi = CONST_DOUBLE_HIGH (inner);\n+\t    }\n \n-      newpat = PATTERN (i2);\n-      goto validate_replacement;\n+\t  if (width < HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      mlo = ((unsigned HOST_WIDE_INT) 1 << width) - 1;\n+\t      mhi = 0;\n+\t    }\n+\t  else if (width < HOST_BITS_PER_WIDE_INT * 2)\n+\t    {\n+\t      mhi = ((unsigned HOST_WIDE_INT) 1\n+\t\t     << (width - HOST_BITS_PER_WIDE_INT)) - 1;\n+\t      mlo = -1;\n+\t    }\n+\t  else\n+\t    {\n+\t      mlo = -1;\n+\t      mhi = -1;\n+\t    }\n+\n+\t  ilo &= mlo;\n+\t  ihi &= mhi;\n+\n+\t  if (offset >= HOST_BITS_PER_WIDE_INT)\n+\t    {\n+\t      mhi = mlo << (offset - HOST_BITS_PER_WIDE_INT);\n+\t      mlo = 0;\n+\t      ihi = ilo << (offset - HOST_BITS_PER_WIDE_INT);\n+\t      ilo = 0;\n+\t    }\n+\t  else if (offset > 0)\n+\t    {\n+\t      mhi = (mhi << offset) | ((unsigned HOST_WIDE_INT) mlo\n+\t\t     \t\t       >> (HOST_BITS_PER_WIDE_INT - offset));\n+\t      mlo = mlo << offset;\n+\t      ihi = (ihi << offset) | ((unsigned HOST_WIDE_INT) ilo\n+\t\t     \t\t       >> (HOST_BITS_PER_WIDE_INT - offset));\n+\t      ilo = ilo << offset;\n+\t    }\n+\n+\t  olo = (olo & ~mlo) | ilo;\n+\t  ohi = (ohi & ~mhi) | ihi;\n+\n+\t  combine_merges++;\n+\t  subst_insn = i3;\n+\t  subst_low_cuid = INSN_CUID (i2);\n+\t  added_sets_2 = added_sets_1 = 0;\n+\t  i2dest = SET_DEST (temp);\n+\t  i2dest_killed = dead_or_set_p (i2, i2dest);\n+\n+\t  SUBST (SET_SRC (temp),\n+\t\t immed_double_const (olo, ohi, GET_MODE (SET_DEST (temp))));\n+\n+\t  newpat = PATTERN (i2);\n+\t  goto validate_replacement;\n+\t}\n     }\n \n #ifndef HAVE_cc0"}]}