{"sha": "15a17b722961146c81c7fca21031053f3f27db03", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTVhMTdiNzIyOTYxMTQ2YzgxYzdmY2EyMTAzMTA1M2YzZjI3ZGIwMw==", "commit": {"author": {"name": "Geoff Keating", "email": "geoffk@cygnus.com", "date": "1999-12-10T19:15:32Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "1999-12-10T19:15:32Z"}, "message": "m68k.h (CONDITIONAL_REGISTER_USAGE): If we have no 68881, we have no 68881 registers at all.\n\n* config/m68k/m68k.h (CONDITIONAL_REGISTER_USAGE): If we have no\n68881, we have no 68881 registers at all.\n(HARD_REGNO_MODE_OK): It is always OK to put a MODE_FLOAT\nvalue in a 68881 register if it is available.\n\nFrom-SVN: r30861", "tree": {"sha": "8770ae50ac0afbd5ffffd690203890a499344c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8770ae50ac0afbd5ffffd690203890a499344c9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15a17b722961146c81c7fca21031053f3f27db03", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a17b722961146c81c7fca21031053f3f27db03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15a17b722961146c81c7fca21031053f3f27db03", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15a17b722961146c81c7fca21031053f3f27db03/comments", "author": null, "committer": null, "parents": [{"sha": "ff8ee66b0084bb559aecd48283936afffe84b675", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff8ee66b0084bb559aecd48283936afffe84b675", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff8ee66b0084bb559aecd48283936afffe84b675"}], "stats": {"total": 45, "additions": 30, "deletions": 15}, "files": [{"sha": "bcc4137f91648184c3d58f4cd569fb3eb3314aa0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a17b722961146c81c7fca21031053f3f27db03/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a17b722961146c81c7fca21031053f3f27db03/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=15a17b722961146c81c7fca21031053f3f27db03", "patch": "@@ -1,3 +1,10 @@\n+1999-12-10  Geoff Keating  <geoffk@cygnus.com>\n+\n+\t* config/m68k/m68k.h (CONDITIONAL_REGISTER_USAGE): If we have no\n+\t68881, we have no 68881 registers at all.\n+\t(HARD_REGNO_MODE_OK): It is always OK to put a MODE_FLOAT\n+\tvalue in a 68881 register if it is available.\n+\n 1999-12-10  Clinton Popetz  <cpopetz@cygnus.com>\n \n \t* config/arm/arm.md (*mulsidi3adddi, *umulsidi3adddi): New patterns"}, {"sha": "21acb268afc89689a1c787edf020a3605ee35dde", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 23, "deletions": 15, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15a17b722961146c81c7fca21031053f3f27db03/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15a17b722961146c81c7fca21031053f3f27db03/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=15a17b722961146c81c7fca21031053f3f27db03", "patch": "@@ -438,24 +438,22 @@ extern int target_flags;\n /* Make sure everything's fine if we *don't* have a given processor.\n    This assumes that putting a register in fixed_regs will keep the\n    compiler's mitts completely off it.  We don't bother to zero it out\n-   of register classes.  If neither TARGET_FPA or TARGET_68881 is set,\n-   the compiler won't touch since no instructions that use these\n-   registers will be valid.  */\n+   of register classes.  */\n \n #ifdef SUPPORT_SUN_FPA\n \n #define CONDITIONAL_REGISTER_USAGE \\\n { \t\t\t\t\t\t\\\n   int i; \t\t\t\t\t\\\n   HARD_REG_SET x; \t\t\t\t\\\n-  if (!TARGET_FPA)\t\t\t\t\\\n+  if (! TARGET_FPA)\t\t\t\t\\\n     { \t\t\t\t\t\t\\\n       COPY_HARD_REG_SET (x, reg_class_contents[(int)FPA_REGS]); \\\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n        if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n \tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n     } \t\t\t\t\t\t\\\n-  if (TARGET_FPA)\t\t\t\t\\\n+  if (! TARGET_68881)\t\t\t\t\\\n     { \t\t\t\t\t\t\\\n       COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n@@ -469,6 +467,15 @@ extern int target_flags;\n #else\n #define CONDITIONAL_REGISTER_USAGE \\\n { \t\t\t\t\t\t\\\n+  int i; \t\t\t\t\t\\\n+  HARD_REG_SET x; \t\t\t\t\\\n+  if (! TARGET_68881)\t\t\t\t\\\n+    { \t\t\t\t\t\t\\\n+      COPY_HARD_REG_SET (x, reg_class_contents[(int)FP_REGS]); \\\n+      for (i = 0; i < FIRST_PSEUDO_REGISTER; i++ ) \\\n+       if (TEST_HARD_REG_BIT (x, i)) \t\t\\\n+\tfixed_regs[i] = call_used_regs[i] = 1; \t\\\n+    } \t\t\t\t\t\t\\\n   if (flag_pic)\t\t\t\t\t\\\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM]\t\t\\\n       = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\\\n@@ -492,14 +499,12 @@ extern int target_flags;\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the 68000, the cpu registers can hold any mode but the 68881 registers\n-   can hold only SFmode or DFmode.  The 68881 registers can't hold anything\n-   if 68881 use is disabled.  */\n+   can hold only SFmode or DFmode.  */\n \n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n   (((REGNO) < 16\t\t\t\t\t\\\n     && !((REGNO) < 8 && (REGNO) + GET_MODE_SIZE (MODE) / 4 > 8))\t\\\n    || ((REGNO) >= 16 && (REGNO) < 24\t\t\t\t        \\\n-       && TARGET_68881                                  \\\n        && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\\\n \t   || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n        && GET_MODE_UNIT_SIZE (MODE) <= 12))\n@@ -508,27 +513,30 @@ extern int target_flags;\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    On the 68000, the cpu registers can hold any mode but the 68881 registers\n-   can hold only SFmode or DFmode.  And the 68881 registers can't hold anything\n-   if 68881 use is disabled.  However, the Sun FPA register can\n+   can hold only SFmode or DFmode.  However, the Sun FPA register can\n    (apparently) hold whatever you feel like putting in them.\n    If using the fpa, don't put a double in d7/a0.  */\n \n /* ??? This is confused.  The check to prohibit d7/a0 overlaps should always\n    be enabled regardless of whether TARGET_FPA is specified.  It isn't clear\n    what the other d/a register checks are for.  Every check using REGNO\n    actually needs to use a range, e.g. 24>=X<56 not <56.  There is probably\n-   no one using this code anymore.  */\n+   no one using this code anymore.  \n+   This code used to be used to suppress register usage for the 68881 by\n+   saying that the 68881 registers couldn't hold values of any mode if there\n+   was no 68881.  This was wrong, because reload (etc.) will still try\n+   to save and restore call-saved registers during, for instance, non-local\n+   goto.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE) \\\n (((REGNO) < 16\t\t\t\t\t\t\t\t\\\n   && !(TARGET_FPA\t\t\t\t\t\t\t\\\n        && GET_MODE_CLASS ((MODE)) != MODE_INT\t\t\t\t\\\n        && GET_MODE_UNIT_SIZE ((MODE)) > 4\t\t\t\t\\\n        && (REGNO) < 8 && (REGNO) + GET_MODE_SIZE ((MODE)) / 4 > 8\t\\\n        && (REGNO) % (GET_MODE_UNIT_SIZE ((MODE)) / 4) != 0))\t\t\\\n- || ((REGNO) < 24\t\t\t\t\t\t\t\\\n-     ? (TARGET_68881\t\t\t\t\t\t\t\\\n-\t&& (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n-\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n+ || ((REGNO) >= 16 && (REGNO) < 24\t\t\t\t\t\\\n+     ? ((GET_MODE_CLASS (MODE) == MODE_FLOAT\t\t\t\t\\\n+\t || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\t\t\\\n \t&& GET_MODE_UNIT_SIZE (MODE) <= 12)\t\t\t\t\\\n      : ((REGNO) < 56 ? TARGET_FPA && GET_MODE_UNIT_SIZE (MODE) <= 8 : 0)))\n "}]}