{"sha": "94d3ea58ff99483cba839ec978f65da745b209d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTRkM2VhNThmZjk5NDgzY2JhODM5ZWM5NzhmNjVkYTc0NWIyMDlkMA==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-06-09T18:47:40Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2003-06-09T18:47:40Z"}, "message": "re PR c++/8861 ([ABI] mangling floating point literal in template arg expression)\n\n\tPR 8861\n\t* mangle.c (write_real_cst): New function.  Implement\n\tABI-compliant mangling of floating-point literals when\n\t-fabi-version>=2; provide backward compatibility with 3.3 when\n\t-fabi-version=1 (with warning).  Clarify commentary.\n\t(write_template_arg_literal): Use write_real_cst.\n\nFrom-SVN: r67670", "tree": {"sha": "bd2d94cde7a0a25aec7bf7173ff72d09ff6c8bf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bd2d94cde7a0a25aec7bf7173ff72d09ff6c8bf4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/94d3ea58ff99483cba839ec978f65da745b209d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d3ea58ff99483cba839ec978f65da745b209d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/94d3ea58ff99483cba839ec978f65da745b209d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/94d3ea58ff99483cba839ec978f65da745b209d0/comments", "author": null, "committer": null, "parents": [{"sha": "b14e185fc8fabfe13dca42e9aa7c2990958f64c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b14e185fc8fabfe13dca42e9aa7c2990958f64c6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b14e185fc8fabfe13dca42e9aa7c2990958f64c6"}], "stats": {"total": 107, "additions": 81, "deletions": 26}, "files": [{"sha": "417fb863ce45b76aaa019c1fd5d5333ec425e9db", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d3ea58ff99483cba839ec978f65da745b209d0/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d3ea58ff99483cba839ec978f65da745b209d0/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=94d3ea58ff99483cba839ec978f65da745b209d0", "patch": "@@ -1,3 +1,12 @@\n+2003-06-09  Zack Weinberg  <zack@codesourcery.com>\n+\n+\tPR 8861\n+\t* mangle.c (write_real_cst): New function.  Implement\n+\tABI-compliant mangling of floating-point literals when\n+\t-fabi-version>=2; provide backward compatibility with 3.3 when\n+\t-fabi-version=1 (with warning).  Clarify commentary.\n+\t(write_template_arg_literal): Use write_real_cst.\n+\n 2003-06-07  Andreas Jaeger  <aj@suse.de>\n \n \t* cp/decl.c (xref_tag): Remove undefined macro NONNESTED_CLASSES.\n@@ -23,11 +32,11 @@ Thu Jun  5 18:33:40 CEST 2003  Jan Hubicka  <jh@suse.cz>\n \n 2003-06-03  Jason Merrill  <jason@redhat.com>\n \n-        * cp/cp-tree.h (CP_AGGREGATE_TYPE_P): Accept vectors.\n+\t* cp/cp-tree.h (CP_AGGREGATE_TYPE_P): Accept vectors.\n \n-        * cp/decl.c (reshape_init): Handle vectors.\n+\t* cp/decl.c (reshape_init): Handle vectors.\n \n-        * testsuite/g++.dg/init/array10.C: New.\n+\t* testsuite/g++.dg/init/array10.C: New.\n \n 2003-06-03  Kriang Lerdsuwanakij  <lerdsuwa@users.sourceforge.net>\n "}, {"sha": "343cca556c25541a3d7d148ad5165f41ecedc087", "filename": "gcc/cp/mangle.c", "status": "modified", "additions": 69, "deletions": 23, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/94d3ea58ff99483cba839ec978f65da745b209d0/gcc%2Fcp%2Fmangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/94d3ea58ff99483cba839ec978f65da745b209d0/gcc%2Fcp%2Fmangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmangle.c?ref=94d3ea58ff99483cba839ec978f65da745b209d0", "patch": "@@ -175,6 +175,7 @@ static int hwint_to_ascii PARAMS ((unsigned HOST_WIDE_INT, unsigned int, char *,\n static void write_number PARAMS ((unsigned HOST_WIDE_INT, int,\n \t\t\t\t  unsigned int));\n static void write_integer_cst PARAMS ((tree));\n+static void write_real_cst PARAMS ((tree));\n static void write_identifier PARAMS ((const char *));\n static void write_special_name_constructor PARAMS ((tree));\n static void write_special_name_destructor PARAMS ((tree));\n@@ -1192,6 +1193,72 @@ write_integer_cst (cst)\n     }\n }\n \n+/* Write out a floating-point literal.  \n+    \n+    \"Floating-point literals are encoded using the bit pattern of the\n+    target processor's internal representation of that number, as a\n+    fixed-length lowercase hexadecimal string, high-order bytes first\n+    (even if the target processor would store low-order bytes first).\n+    The \"n\" prefix is not used for floating-point literals; the sign\n+    bit is encoded with the rest of the number.\n+\n+    Here are some examples, assuming the IEEE standard representation\n+    for floating point numbers.  (Spaces are for readability, not\n+    part of the encoding.)\n+\n+        1.0f                    Lf 3f80 0000 E\n+       -1.0f                    Lf bf80 0000 E\n+        1.17549435e-38f         Lf 0080 0000 E\n+        1.40129846e-45f         Lf 0000 0001 E\n+        0.0f                    Lf 0000 0000 E\"\n+\n+   Caller is responsible for the Lx and the E.  */\n+static void\n+write_real_cst (value)\n+     tree value;\n+{\n+  if (abi_version_at_least (2))\n+    {\n+      long target_real[4];  /* largest supported float */\n+      char buffer[9];       /* eight hex digits in a 32-bit number */\n+      int i, limit, dir;\n+\n+      tree type = TREE_TYPE (value);\n+      int words = GET_MODE_BITSIZE (TYPE_MODE (type)) / 32;\n+\n+      real_to_target (target_real, &TREE_REAL_CST (value),\n+\t\t      TYPE_MODE (type));\n+\n+      /* The value in target_real is in the target word order,\n+         so we must write it out backward if that happens to be\n+\t little-endian.  write_number cannot be used, it will\n+\t produce uppercase.  */\n+      if (FLOAT_WORDS_BIG_ENDIAN)\n+\ti = 0, limit = words, dir = 1;\n+      else\n+\ti = words - 1, limit = -1, dir = -1;\n+\n+      for (; i != limit; i += dir)\n+\t{\n+\t  sprintf (buffer, \"%08lx\", target_real[i]);\n+\t  write_chars (buffer, 8);\n+\t}\n+    }\n+  else\n+    {\n+      /* In G++ 3.3 and before the REAL_VALUE_TYPE was written out\n+\t literally.  Note that compatibility with 3.2 is impossible,\n+\t because the old floating-point emulator used a different\n+\t format for REAL_VALUE_TYPE.  */\n+      size_t i;\n+      for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n+\twrite_number (((unsigned char *) &TREE_REAL_CST (value))[i], \n+\t\t      /*unsigned_p*/ 1,\n+\t\t      /*base*/ 16);\n+      G.need_abi_warning = 1;\n+    }\n+}\n+\n /* Non-terminal <identifier>.\n \n      <identifier> ::= </unqualified source code identifier>  */\n@@ -2024,11 +2091,7 @@ write_expression (expr)\n      \"Literal arguments, e.g. \"A<42L>\", are encoded with their type\n      and value. Negative integer values are preceded with \"n\"; for\n      example, \"A<-42L>\" becomes \"1AILln42EE\". The bool value false is\n-     encoded as 0, true as 1. If floating-point arguments are accepted\n-     as an extension, their values should be encoded using a\n-     fixed-length lowercase hexadecimal string corresponding to the\n-     internal representation (IEEE on IA-64), high-order bytes first,\n-     without leading zeroes. For example: \"Lfbff000000E\" is -1.0f.\"  */\n+     encoded as 0, true as 1.\"  */\n \n static void\n write_template_arg_literal (value)\n@@ -2055,24 +2118,7 @@ write_template_arg_literal (value)\n \twrite_integer_cst (value);\n     }\n   else if (TREE_CODE (value) == REAL_CST)\n-    {\n-#ifdef CROSS_COMPILE\n-      static int explained;\n-\n-      if (!explained) \n-\t{\n-\t  sorry (\"real-valued template parameters when cross-compiling\");\n-\t  explained = 1;\n-\t}\n-#else\n-      size_t i;\n-      for (i = 0; i < sizeof (TREE_REAL_CST (value)); ++i)\n-\twrite_number (((unsigned char *) \n-\t\t       &TREE_REAL_CST (value))[i], \n-\t\t      /*unsigned_p=*/1,\n-\t\t      16);\n-#endif\n-    }\n+    write_real_cst (value);\n   else\n     abort ();\n "}]}