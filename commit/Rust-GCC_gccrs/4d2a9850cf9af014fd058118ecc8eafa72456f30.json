{"sha": "4d2a9850cf9af014fd058118ecc8eafa72456f30", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGQyYTk4NTBjZjlhZjAxNGZkMDU4MTE4ZWNjOGVhZmE3MjQ1NmYzMA==", "commit": {"author": {"name": "Daniel Jacobowitz", "email": "dan@codesourcery.com", "date": "2008-07-01T20:49:40Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2008-07-01T20:49:40Z"}, "message": "function.c (assign_parm_remove_parallels): New.\n\n\t* function.c (assign_parm_remove_parallels): New.\n\t(assign_parm_setup_block_p): Do not return true for non-BLKmode\n\tPARALLELs.\n\t(assign_parm_setup_block): Do not handle them.\n\t(assign_parm_setup_reg, assign_parm_setup_stack): Call\n\tassign_parm_remove_parallels.\n\nFrom-SVN: r137326", "tree": {"sha": "1aa92657c6dd16fdbe1442fbe6606da02e7eed9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1aa92657c6dd16fdbe1442fbe6606da02e7eed9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4d2a9850cf9af014fd058118ecc8eafa72456f30", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2a9850cf9af014fd058118ecc8eafa72456f30", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4d2a9850cf9af014fd058118ecc8eafa72456f30", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4d2a9850cf9af014fd058118ecc8eafa72456f30/comments", "author": null, "committer": null, "parents": [{"sha": "f83c7f631f959a5c1189527e90c065b68cdacd4d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83c7f631f959a5c1189527e90c065b68cdacd4d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83c7f631f959a5c1189527e90c065b68cdacd4d"}], "stats": {"total": 88, "additions": 37, "deletions": 51}, "files": [{"sha": "01ed439fdcf45801c1b2f84f63d93aa3e626c844", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d2a9850cf9af014fd058118ecc8eafa72456f30/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d2a9850cf9af014fd058118ecc8eafa72456f30/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4d2a9850cf9af014fd058118ecc8eafa72456f30", "patch": "@@ -1,3 +1,12 @@\n+2008-07-01  Daniel Jacobowitz  <dan@codesourcery.com>\n+\n+\t* function.c (assign_parm_remove_parallels): New.\n+\t(assign_parm_setup_block_p): Do not return true for non-BLKmode\n+\tPARALLELs.\n+\t(assign_parm_setup_block): Do not handle them.\n+\t(assign_parm_setup_reg, assign_parm_setup_stack): Call\n+\tassign_parm_remove_parallels.\n+\n 2008-07-01  Daniel Jacobowitz  <dan@codesourcery.com>\n \n \t* c-typeck.c (convert_for_assignment): Use"}, {"sha": "d8234da38771098f5e4d8963832234d56d84ebef", "filename": "gcc/function.c", "status": "modified", "additions": 28, "deletions": 51, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4d2a9850cf9af014fd058118ecc8eafa72456f30/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4d2a9850cf9af014fd058118ecc8eafa72456f30/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=4d2a9850cf9af014fd058118ecc8eafa72456f30", "patch": "@@ -2352,6 +2352,30 @@ assign_parm_adjust_entry_rtl (struct assign_parm_data_one *data)\n   data->entry_parm = entry_parm;\n }\n \n+/* A subroutine of assign_parms.  Reconstitute any values which were\n+   passed in multiple registers and would fit in a single register.  */\n+\n+static void\n+assign_parm_remove_parallels (struct assign_parm_data_one *data)\n+{\n+  rtx entry_parm = data->entry_parm;\n+\n+  /* Convert the PARALLEL to a REG of the same mode as the parallel.\n+     This can be done with register operations rather than on the\n+     stack, even if we will store the reconstituted parameter on the\n+     stack later.  */\n+  if (GET_CODE (entry_parm) == PARALLEL\n+      && data->passed_mode != BLKmode)\n+    {\n+      rtx parmreg = gen_reg_rtx (GET_MODE (entry_parm));\n+      emit_group_store (parmreg, entry_parm, NULL_TREE,\n+\t\t\tGET_MODE_SIZE (GET_MODE (entry_parm)));\n+      entry_parm = parmreg;\n+    }\n+\n+  data->entry_parm = entry_parm;\n+}\n+\n /* A subroutine of assign_parms.  Adjust DATA->STACK_RTL such that it's\n    always valid and properly aligned.  */\n \n@@ -2397,8 +2421,6 @@ assign_parm_setup_block_p (struct assign_parm_data_one *data)\n {\n   if (data->nominal_mode == BLKmode)\n     return true;\n-  if (GET_CODE (data->entry_parm) == PARALLEL)\n-    return true;\n \n #ifdef BLOCK_REG_PADDING\n   /* Only assign_parm_setup_block knows how to deal with register arguments\n@@ -2424,59 +2446,10 @@ assign_parm_setup_block (struct assign_parm_data_all *all,\n   rtx stack_parm = data->stack_parm;\n   HOST_WIDE_INT size;\n   HOST_WIDE_INT size_stored;\n-  rtx orig_entry_parm = entry_parm;\n \n   if (GET_CODE (entry_parm) == PARALLEL)\n     entry_parm = emit_group_move_into_temps (entry_parm);\n \n-  /* If we've a non-block object that's nevertheless passed in parts,\n-     reconstitute it in register operations rather than on the stack.  */\n-  if (GET_CODE (entry_parm) == PARALLEL\n-      && data->nominal_mode != BLKmode)\n-    {\n-      rtx elt0 = XEXP (XVECEXP (orig_entry_parm, 0, 0), 0);\n-\n-      if ((XVECLEN (entry_parm, 0) > 1\n-\t   || hard_regno_nregs[REGNO (elt0)][GET_MODE (elt0)] > 1)\n-\t  && use_register_for_decl (parm))\n-\t{\n-\t  rtx parmreg = gen_reg_rtx (data->nominal_mode);\n-\n-\t  push_to_sequence2 (all->first_conversion_insn,\n-\t\t\t     all->last_conversion_insn);\n-\n-\t  /* For values returned in multiple registers, handle possible\n-\t     incompatible calls to emit_group_store.\n-\n-\t     For example, the following would be invalid, and would have to\n-\t     be fixed by the conditional below:\n-\n-\t     emit_group_store ((reg:SF), (parallel:DF))\n-\t     emit_group_store ((reg:SI), (parallel:DI))\n-\n-\t     An example of this are doubles in e500 v2:\n-\t     (parallel:DF (expr_list (reg:SI) (const_int 0))\n-\t     (expr_list (reg:SI) (const_int 4))).  */\n-\t  if (data->nominal_mode != data->passed_mode)\n-\t    {\n-\t      rtx t = gen_reg_rtx (GET_MODE (entry_parm));\n-\t      emit_group_store (t, entry_parm, NULL_TREE,\n-\t\t\t\tGET_MODE_SIZE (GET_MODE (entry_parm)));\n-\t      convert_move (parmreg, t, 0);\n-\t    }\n-\t  else\n-\t    emit_group_store (parmreg, entry_parm, data->nominal_type,\n-\t\t\t      int_size_in_bytes (data->nominal_type));\n-\n-\t  all->first_conversion_insn = get_insns ();\n-\t  all->last_conversion_insn = get_last_insn ();\n-\t  end_sequence ();\n-\n-\t  SET_DECL_RTL (parm, parmreg);\n-\t  return;\n-\t}\n-    }\n-\n   size = int_size_in_bytes (data->passed_type);\n   size_stored = CEIL_ROUND (size, UNITS_PER_WORD);\n   if (stack_parm == 0)\n@@ -2641,6 +2614,8 @@ assign_parm_setup_reg (struct assign_parm_data_all *all, tree parm,\n   else\n     SET_DECL_RTL (parm, parmreg);\n \n+  assign_parm_remove_parallels (data);\n+\n   /* Copy the value into the register.  */\n   if (data->nominal_mode != data->passed_mode\n       || promoted_nominal_mode != data->promoted_mode)\n@@ -2803,6 +2778,8 @@ assign_parm_setup_stack (struct assign_parm_data_all *all, tree parm,\n      execution.  */\n   bool to_conversion = false;\n \n+  assign_parm_remove_parallels (data);\n+\n   if (data->promoted_mode != data->nominal_mode)\n     {\n       /* Conversion is required.  */"}]}