{"sha": "920e81727482ab7c10dd4cadf78e7ff052644762", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTIwZTgxNzI3NDgyYWI3YzEwZGQ0Y2FkZjc4ZTdmZjA1MjY0NDc2Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2011-04-14T11:54:43Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2011-04-14T11:54:43Z"}, "message": "tree-vectorizer.h (vect_create_data_ref_ptr): Add an extra type parameter.\n\ngcc/\n\t* tree-vectorizer.h (vect_create_data_ref_ptr): Add an extra\n\ttype parameter.\n\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Add an aggr_type\n\tparameter.  Generalise code to handle arrays as well as vectors.\n\t(vect_setup_realignment): Update accordingly.\n\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n\t(vectorizable_load): Likewise.\n\nFrom-SVN: r172423", "tree": {"sha": "1835bb35c9f4039a9323ecc485940d41b6c9a22e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1835bb35c9f4039a9323ecc485940d41b6c9a22e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/920e81727482ab7c10dd4cadf78e7ff052644762", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920e81727482ab7c10dd4cadf78e7ff052644762", "html_url": "https://github.com/Rust-GCC/gccrs/commit/920e81727482ab7c10dd4cadf78e7ff052644762", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/920e81727482ab7c10dd4cadf78e7ff052644762/comments", "author": null, "committer": null, "parents": [{"sha": "5ce1ee7fdd558b1bb5f02f84cbc435acf8184c9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ce1ee7fdd558b1bb5f02f84cbc435acf8184c9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ce1ee7fdd558b1bb5f02f84cbc435acf8184c9b"}], "stats": {"total": 167, "additions": 92, "deletions": 75}, "files": [{"sha": "4469232b67581266ce8d07d806b415c748412473", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=920e81727482ab7c10dd4cadf78e7ff052644762", "patch": "@@ -1,3 +1,13 @@\n+2011-04-14  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* tree-vectorizer.h (vect_create_data_ref_ptr): Add an extra\n+\ttype parameter.\n+\t* tree-vect-data-refs.c (vect_create_data_ref_ptr): Add an aggr_type\n+\tparameter.  Generalise code to handle arrays as well as vectors.\n+\t(vect_setup_realignment): Update accordingly.\n+\t* tree-vect-stmts.c (vectorizable_store): Likewise.\n+\t(vectorizable_load): Likewise.\n+\n 2011-04-14  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* tree-vect-stmts.c (vectorizable_load): Allocate and free dr_chain"}, {"sha": "6db06c8d8c4e959a7343985a875b0ae39397d051", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 73, "deletions": 66, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=920e81727482ab7c10dd4cadf78e7ff052644762", "patch": "@@ -2911,32 +2911,33 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n \n /* Function vect_create_data_ref_ptr.\n \n-   Create a new pointer to vector type (vp), that points to the first location\n-   accessed in the loop by STMT, along with the def-use update chain to\n-   appropriately advance the pointer through the loop iterations. Also set\n-   aliasing information for the pointer.  This vector pointer is used by the\n-   callers to this function to create a memory reference expression for vector\n-   load/store access.\n+   Create a new pointer-to-AGGR_TYPE variable (ap), that points to the first\n+   location accessed in the loop by STMT, along with the def-use update\n+   chain to appropriately advance the pointer through the loop iterations.\n+   Also set aliasing information for the pointer.  This pointer is used by\n+   the callers to this function to create a memory reference expression for\n+   vector load/store access.\n \n    Input:\n    1. STMT: a stmt that references memory. Expected to be of the form\n          GIMPLE_ASSIGN <name, data-ref> or\n \t GIMPLE_ASSIGN <data-ref, name>.\n-   2. AT_LOOP: the loop where the vector memref is to be created.\n-   3. OFFSET (optional): an offset to be added to the initial address accessed\n+   2. AGGR_TYPE: the type of the reference, which should be either a vector\n+        or an array.\n+   3. AT_LOOP: the loop where the vector memref is to be created.\n+   4. OFFSET (optional): an offset to be added to the initial address accessed\n         by the data-ref in STMT.\n-   4. BSI: location where the new stmts are to be placed if there is no loop\n-   5. ONLY_INIT: indicate if vp is to be updated in the loop, or remain\n+   5. BSI: location where the new stmts are to be placed if there is no loop\n+   6. ONLY_INIT: indicate if ap is to be updated in the loop, or remain\n         pointing to the initial address.\n-   6. TYPE: if not NULL indicates the required type of the data-ref.\n \n    Output:\n    1. Declare a new ptr to vector_type, and have it point to the base of the\n       data reference (initial addressed accessed by the data reference).\n       For example, for vector of type V8HI, the following code is generated:\n \n-      v8hi *vp;\n-      vp = (v8hi *)initial_address;\n+      v8hi *ap;\n+      ap = (v8hi *)initial_address;\n \n       if OFFSET is not supplied:\n          initial_address = &a[init];\n@@ -2956,27 +2957,27 @@ vect_create_addr_base_for_vector_ref (gimple stmt,\n    4. Return the pointer.  */\n \n tree\n-vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n-\t\t\t  tree *initial_address, gimple_stmt_iterator *gsi,\n-\t\t\t  gimple *ptr_incr, bool only_init, bool *inv_p)\n+vect_create_data_ref_ptr (gimple stmt, tree aggr_type, struct loop *at_loop,\n+\t\t\t  tree offset, tree *initial_address,\n+\t\t\t  gimple_stmt_iterator *gsi, gimple *ptr_incr,\n+\t\t\t  bool only_init, bool *inv_p)\n {\n   tree base_name;\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = NULL;\n   bool nested_in_vect_loop = false;\n   struct loop *containing_loop = NULL;\n-  tree vectype = STMT_VINFO_VECTYPE (stmt_info);\n-  tree vect_ptr_type;\n-  tree vect_ptr;\n+  tree aggr_ptr_type;\n+  tree aggr_ptr;\n   tree new_temp;\n   gimple vec_stmt;\n   gimple_seq new_stmt_list = NULL;\n   edge pe = NULL;\n   basic_block new_bb;\n-  tree vect_ptr_init;\n+  tree aggr_ptr_init;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n-  tree vptr;\n+  tree aptr;\n   gimple_stmt_iterator incr_gsi;\n   bool insert_after;\n   bool negative;\n@@ -2986,6 +2987,9 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n   bb_vec_info bb_vinfo = STMT_VINFO_BB_VINFO (stmt_info);\n   tree base;\n \n+  gcc_assert (TREE_CODE (aggr_type) == ARRAY_TYPE\n+\t      || TREE_CODE (aggr_type) == VECTOR_TYPE);\n+\n   if (loop_vinfo)\n     {\n       loop = LOOP_VINFO_LOOP (loop_vinfo);\n@@ -3020,8 +3024,9 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n   if (vect_print_dump_info (REPORT_DETAILS))\n     {\n       tree data_ref_base = base_name;\n-      fprintf (vect_dump, \"create vector-pointer variable to type: \");\n-      print_generic_expr (vect_dump, vectype, TDF_SLIM);\n+      fprintf (vect_dump, \"create %s-pointer variable to type: \",\n+\t       tree_code_name[(int) TREE_CODE (aggr_type)]);\n+      print_generic_expr (vect_dump, aggr_type, TDF_SLIM);\n       if (TREE_CODE (data_ref_base) == VAR_DECL\n           || TREE_CODE (data_ref_base) == ARRAY_REF)\n         fprintf (vect_dump, \"  vectorizing an array ref: \");\n@@ -3032,27 +3037,28 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n       print_generic_expr (vect_dump, base_name, TDF_SLIM);\n     }\n \n-  /* (1) Create the new vector-pointer variable.  */\n-  vect_ptr_type = build_pointer_type (vectype);\n+  /* (1) Create the new aggregate-pointer variable.  */\n+  aggr_ptr_type = build_pointer_type (aggr_type);\n   base = get_base_address (DR_REF (dr));\n   if (base\n       && TREE_CODE (base) == MEM_REF)\n-    vect_ptr_type\n-      = build_qualified_type (vect_ptr_type,\n+    aggr_ptr_type\n+      = build_qualified_type (aggr_ptr_type,\n \t\t\t      TYPE_QUALS (TREE_TYPE (TREE_OPERAND (base, 0))));\n-  vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n+  aggr_ptr = vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var,\n                                     get_name (base_name));\n \n-  /* Vector types inherit the alias set of their component type by default so\n-     we need to use a ref-all pointer if the data reference does not conflict\n-     with the created vector data reference because it is not addressable.  */\n-  if (!alias_sets_conflict_p (get_deref_alias_set (vect_ptr),\n+  /* Vector and array types inherit the alias set of their component\n+     type by default so we need to use a ref-all pointer if the data\n+     reference does not conflict with the created aggregated data\n+     reference because it is not addressable.  */\n+  if (!alias_sets_conflict_p (get_deref_alias_set (aggr_ptr),\n \t\t\t      get_alias_set (DR_REF (dr))))\n     {\n-      vect_ptr_type\n-\t= build_pointer_type_for_mode (vectype,\n-\t\t\t\t       TYPE_MODE (vect_ptr_type), true);\n-      vect_ptr = vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n+      aggr_ptr_type\n+\t= build_pointer_type_for_mode (aggr_type,\n+\t\t\t\t       TYPE_MODE (aggr_ptr_type), true);\n+      aggr_ptr = vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var,\n \t\t\t\t\tget_name (base_name));\n     }\n \n@@ -3063,14 +3069,14 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n       do\n \t{\n \t  tree lhs = gimple_assign_lhs (orig_stmt);\n-\t  if (!alias_sets_conflict_p (get_deref_alias_set (vect_ptr),\n+\t  if (!alias_sets_conflict_p (get_deref_alias_set (aggr_ptr),\n \t\t\t\t      get_alias_set (lhs)))\n \t    {\n-\t      vect_ptr_type\n-\t\t= build_pointer_type_for_mode (vectype,\n-\t\t\t\t\t       TYPE_MODE (vect_ptr_type), true);\n-\t      vect_ptr\n-\t\t= vect_get_new_vect_var (vect_ptr_type, vect_pointer_var,\n+\t      aggr_ptr_type\n+\t\t= build_pointer_type_for_mode (aggr_type,\n+\t\t\t\t\t       TYPE_MODE (aggr_ptr_type), true);\n+\t      aggr_ptr\n+\t\t= vect_get_new_vect_var (aggr_ptr_type, vect_pointer_var,\n \t\t\t\t\t get_name (base_name));\n \t      break;\n \t    }\n@@ -3080,7 +3086,7 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n       while (orig_stmt);\n     }\n \n-  add_referenced_var (vect_ptr);\n+  add_referenced_var (aggr_ptr);\n \n   /* Note: If the dataref is in an inner-loop nested in LOOP, and we are\n      vectorizing LOOP (i.e., outer-loop vectorization), we need to create two\n@@ -3113,8 +3119,8 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n \t\tvp2 = vp1 + step\n \t\tif () goto LOOP   */\n \n-  /* (2) Calculate the initial address the vector-pointer, and set\n-         the vector-pointer to point to it before the loop.  */\n+  /* (2) Calculate the initial address of the aggregate-pointer, and set\n+     the aggregate-pointer to point to it before the loop.  */\n \n   /* Create: (&(base[init_val+offset]) in the loop preheader.  */\n \n@@ -3133,17 +3139,17 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n \n   *initial_address = new_temp;\n \n-  /* Create: p = (vectype *) initial_base  */\n+  /* Create: p = (aggr_type *) initial_base  */\n   if (TREE_CODE (new_temp) != SSA_NAME\n-      || !useless_type_conversion_p (vect_ptr_type, TREE_TYPE (new_temp)))\n+      || !useless_type_conversion_p (aggr_ptr_type, TREE_TYPE (new_temp)))\n     {\n-      vec_stmt = gimple_build_assign (vect_ptr,\n-\t\t\t\t      fold_convert (vect_ptr_type, new_temp));\n-      vect_ptr_init = make_ssa_name (vect_ptr, vec_stmt);\n+      vec_stmt = gimple_build_assign (aggr_ptr,\n+\t\t\t\t      fold_convert (aggr_ptr_type, new_temp));\n+      aggr_ptr_init = make_ssa_name (aggr_ptr, vec_stmt);\n       /* Copy the points-to information if it exists. */\n       if (DR_PTR_INFO (dr))\n-\tduplicate_ssa_name_ptr_info (vect_ptr_init, DR_PTR_INFO (dr));\n-      gimple_assign_set_lhs (vec_stmt, vect_ptr_init);\n+\tduplicate_ssa_name_ptr_info (aggr_ptr_init, DR_PTR_INFO (dr));\n+      gimple_assign_set_lhs (vec_stmt, aggr_ptr_init);\n       if (pe)\n \t{\n \t  new_bb = gsi_insert_on_edge_immediate (pe, vec_stmt);\n@@ -3153,19 +3159,19 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n \tgsi_insert_before (gsi, vec_stmt, GSI_SAME_STMT);\n     }\n   else\n-    vect_ptr_init = new_temp;\n+    aggr_ptr_init = new_temp;\n \n-  /* (3) Handle the updating of the vector-pointer inside the loop.\n+  /* (3) Handle the updating of the aggregate-pointer inside the loop.\n      This is needed when ONLY_INIT is false, and also when AT_LOOP is the\n      inner-loop nested in LOOP (during outer-loop vectorization).  */\n \n   /* No update in loop is required.  */\n   if (only_init && (!loop_vinfo || at_loop == loop))\n-    vptr = vect_ptr_init;\n+    aptr = aggr_ptr_init;\n   else\n     {\n-      /* The step of the vector pointer is the Vector Size.  */\n-      tree step = TYPE_SIZE_UNIT (vectype);\n+      /* The step of the aggregate pointer is the type size.  */\n+      tree step = TYPE_SIZE_UNIT (aggr_type);\n       /* One exception to the above is when the scalar step of the load in\n \t LOOP is zero. In this case the step here is also zero.  */\n       if (*inv_p)\n@@ -3175,9 +3181,9 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n \n       standard_iv_increment_position (loop, &incr_gsi, &insert_after);\n \n-      create_iv (vect_ptr_init,\n-\t\t fold_convert (vect_ptr_type, step),\n-\t\t vect_ptr, loop, &incr_gsi, insert_after,\n+      create_iv (aggr_ptr_init,\n+\t\t fold_convert (aggr_ptr_type, step),\n+\t\t aggr_ptr, loop, &incr_gsi, insert_after,\n \t\t &indx_before_incr, &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n       set_vinfo_for_stmt (incr, new_stmt_vec_info (incr, loop_vinfo, NULL));\n@@ -3191,22 +3197,22 @@ vect_create_data_ref_ptr (gimple stmt, struct loop *at_loop, tree offset,\n       if (ptr_incr)\n \t*ptr_incr = incr;\n \n-      vptr = indx_before_incr;\n+      aptr = indx_before_incr;\n     }\n \n   if (!nested_in_vect_loop || only_init)\n-    return vptr;\n+    return aptr;\n \n \n-  /* (4) Handle the updating of the vector-pointer inside the inner-loop\n+  /* (4) Handle the updating of the aggregate-pointer inside the inner-loop\n      nested in LOOP, if exists.  */\n \n   gcc_assert (nested_in_vect_loop);\n   if (!only_init)\n     {\n       standard_iv_increment_position (containing_loop, &incr_gsi,\n \t\t\t\t      &insert_after);\n-      create_iv (vptr, fold_convert (vect_ptr_type, DR_STEP (dr)), vect_ptr,\n+      create_iv (aptr, fold_convert (aggr_ptr_type, DR_STEP (dr)), aggr_ptr,\n \t\t containing_loop, &incr_gsi, insert_after, &indx_before_incr,\n \t\t &indx_after_incr);\n       incr = gsi_stmt (incr_gsi);\n@@ -3674,8 +3680,9 @@ vect_setup_realignment (gimple stmt, gimple_stmt_iterator *gsi,\n \n       gcc_assert (!compute_in_loop);\n       vec_dest = vect_create_destination_var (scalar_dest, vectype);\n-      ptr = vect_create_data_ref_ptr (stmt, loop_for_initial_load, NULL_TREE,\n-\t\t\t\t      &init_addr, NULL, &inc, true, &inv_p);\n+      ptr = vect_create_data_ref_ptr (stmt, vectype, loop_for_initial_load,\n+\t\t\t\t      NULL_TREE, &init_addr, NULL, &inc,\n+\t\t\t\t      true, &inv_p);\n       new_stmt = gimple_build_assign_with_ops\n \t\t   (BIT_AND_EXPR, NULL_TREE, ptr,\n \t\t    build_int_cst (TREE_TYPE (ptr),"}, {"sha": "ffcbd287bcf419f8777b020b7ce5012bc4c69bb0", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=920e81727482ab7c10dd4cadf78e7ff052644762", "patch": "@@ -3581,9 +3581,9 @@ vectorizable_store (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n \t  /* We should have catched mismatched types earlier.  */\n \t  gcc_assert (useless_type_conversion_p (vectype,\n \t\t\t\t\t\t TREE_TYPE (vec_oprnd)));\n-\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, NULL, NULL_TREE,\n-\t\t\t\t\t\t  &dummy, gsi, &ptr_incr, false,\n-\t\t\t\t\t\t  &inv_p);\n+\t  dataref_ptr = vect_create_data_ref_ptr (first_stmt, vectype, NULL,\n+\t\t\t\t\t\t  NULL_TREE, &dummy, gsi,\n+\t\t\t\t\t\t  &ptr_incr, false, &inv_p);\n \t  gcc_assert (bb_vinfo || !inv_p);\n \t}\n       else\n@@ -4107,9 +4107,9 @@ vectorizable_load (gimple stmt, gimple_stmt_iterator *gsi, gimple *vec_stmt,\n     {\n       /* 1. Create the vector pointer update chain.  */\n       if (j == 0)\n-        dataref_ptr = vect_create_data_ref_ptr (first_stmt, at_loop, offset,\n-\t\t\t\t\t\t&dummy, gsi, &ptr_incr, false,\n-\t\t\t\t\t\t&inv_p);\n+        dataref_ptr = vect_create_data_ref_ptr (first_stmt, vectype, at_loop,\n+\t\t\t\t\t\toffset, &dummy, gsi,\n+\t\t\t\t\t\t&ptr_incr, false, &inv_p);\n       else\n         dataref_ptr =\n \t\tbump_vector_ptr (dataref_ptr, ptr_incr, gsi, stmt, NULL_TREE);"}, {"sha": "0ed2d6eb88befda81225de81e9a5667b5c5b6ec7", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/920e81727482ab7c10dd4cadf78e7ff052644762/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=920e81727482ab7c10dd4cadf78e7ff052644762", "patch": "@@ -823,9 +823,9 @@ extern bool vect_verify_datarefs_alignment (loop_vec_info, bb_vec_info);\n extern bool vect_analyze_data_ref_accesses (loop_vec_info, bb_vec_info);\n extern bool vect_prune_runtime_alias_test_list (loop_vec_info);\n extern bool vect_analyze_data_refs (loop_vec_info, bb_vec_info, int *);\n-extern tree vect_create_data_ref_ptr (gimple, struct loop *, tree, tree *,\n-                                      gimple_stmt_iterator *, gimple *,\n-                                      bool, bool *);\n+extern tree vect_create_data_ref_ptr (gimple, tree, struct loop *, tree,\n+\t\t\t\t      tree *, gimple_stmt_iterator *,\n+\t\t\t\t      gimple *, bool, bool *);\n extern tree bump_vector_ptr (tree, gimple, gimple_stmt_iterator *, gimple, tree);\n extern tree vect_create_destination_var (tree, tree);\n extern bool vect_strided_store_supported (tree);"}]}