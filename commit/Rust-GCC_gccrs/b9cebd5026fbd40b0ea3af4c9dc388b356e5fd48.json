{"sha": "b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjljZWJkNTAyNmZiZDQwYjBlYTNhZjRjOWRjMzg4YjM1NmU1ZmQ0OA==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2006-05-17T16:28:01Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2006-05-17T16:28:01Z"}, "message": "hashtable (hashtable<>::m_find): Remove; update callers.\n\n2006-05-17  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/tr1/hashtable (hashtable<>::m_find): Remove; update callers.\n\n\t* include/tr1/hashtable (map_base<>::operator[]): Move out of line.\n\n\t* include/tr1/hashtable (hashtable<>::m_insert(const value_type&,\n\tstd::tr1::false_type)): Avoid memory leak risk for new_node.\n\nFrom-SVN: r113868", "tree": {"sha": "a252d3f48794625f67290c64cf923577a5e021eb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a252d3f48794625f67290c64cf923577a5e021eb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48/comments", "author": null, "committer": null, "parents": [{"sha": "edbaf6a24d220fe50ec0bbb245952bf9a19a3561", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/edbaf6a24d220fe50ec0bbb245952bf9a19a3561", "html_url": "https://github.com/Rust-GCC/gccrs/commit/edbaf6a24d220fe50ec0bbb245952bf9a19a3561"}], "stats": {"total": 66, "additions": 35, "deletions": 31}, "files": [{"sha": "eeea743d59e26ef14060177e36a3f11e53f194bc", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "patch": "@@ -1,3 +1,12 @@\n+2006-05-17  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/tr1/hashtable (hashtable<>::m_find): Remove; update callers.\n+\n+\t* include/tr1/hashtable (map_base<>::operator[]): Move out of line.\n+\n+\t* include/tr1/hashtable (hashtable<>::m_insert(const value_type&,\n+\tstd::tr1::false_type)): Avoid memory leak risk for new_node.\n+\n 2006-05-15  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/tr1/hashtable (hashtable<>::m_find, m_insert_bucket): Add."}, {"sha": "7c7c14478024454d7770e97d1a8f377b5626f756", "filename": "libstdc++-v3/include/tr1/hashtable", "status": "modified", "additions": 26, "deletions": 31, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Ftr1%2Fhashtable?ref=b9cebd5026fbd40b0ea3af4c9dc388b356e5fd48", "patch": "@@ -677,18 +677,25 @@ namespace Internal\n       typedef typename Pair::second_type mapped_type;\n       \n       mapped_type&\n-      operator[](const K& k)\n-      {\n-\tHashtable* h = static_cast<Hashtable*>(this);\n-\ttypename Hashtable::hash_code_t code = h->m_hash_code(k);\n-\ttypename Hashtable::iterator it = h->m_find(k, code);\n-\tif (!it.m_cur_node)\n-\t  it = h->m_insert_bucket(std::make_pair(k, mapped_type()),\n-\t\t\t\t  it.m_cur_bucket - h->m_buckets, code);\n-\treturn it->second;\n-      }\n+      operator[](const K& k);\n     };\n \n+  template<typename K, typename Pair, typename Hashtable>\n+    typename map_base<K, Pair, extract1st<Pair>, true, Hashtable>::mapped_type&\n+    map_base<K, Pair, extract1st<Pair>, true, Hashtable>::\n+    operator[](const K& k)\n+    {\n+      Hashtable* h = static_cast<Hashtable*>(this);\n+      typename Hashtable::hash_code_t code = h->m_hash_code(k);\n+      std::size_t n = h->bucket_index(k, code, h->bucket_count());\n+\n+      typename Hashtable::node* p = h->m_find_node(h->m_buckets[n], k, code);\n+      if (!p)\n+\treturn h->m_insert_bucket(std::make_pair(k, mapped_type()),\n+\t\t\t\t  n, code)->second;\n+      return (p->m_v).second;\n+    }\n+\n   // class template rehash_base.  Give hashtable the max_load_factor\n   // functions iff the rehash policy is prime_rehash_policy.\n   template<typename RehashPolicy, typename Hashtable>\n@@ -1223,9 +1230,6 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n                                    >::type\n         Insert_Conv_Type;\n \n-      iterator\n-      m_find(const key_type&, typename hashtable::hash_code_t) const;\n-\n       node*\n       m_find_node(node*, const key_type&,\n \t\t  typename hashtable::hash_code_t) const;\n@@ -1541,26 +1545,14 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n \t   bool c, bool ci, bool u>\n     typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n     hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    m_find(const key_type& k, typename hashtable::hash_code_t code) const\n+    find(const key_type& k)\n     {\n+      typename hashtable::hash_code_t code = this->m_hash_code(k);\n       std::size_t n = this->bucket_index(k, code, this->bucket_count());\n       node* p = m_find_node(m_buckets[n], k, code);\n-      return iterator(p, m_buckets + n);\n+      return p ? iterator(p, m_buckets + n) : this->end();\n     }\n \n-  template<typename K, typename V, \n-\t   typename A, typename Ex, typename Eq,\n-\t   typename H1, typename H2, typename H, typename RP,\n-\t   bool c, bool ci, bool u>\n-    typename hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::iterator\n-    hashtable<K, V, A, Ex, Eq, H1, H2, H, RP, c, ci, u>::\n-    find(const key_type& k)\n-    {\n-      typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      iterator i = m_find(k, code);\n-      return i.m_cur_node ? i : this->end();\n-    }\n-  \n   template<typename K, typename V, \n \t   typename A, typename Ex, typename Eq,\n \t   typename H1, typename H2, typename H, typename RP,\n@@ -1570,8 +1562,9 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n     find(const key_type& k) const\n     {\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n-      const_iterator i = const_iterator(m_find(k, code));\n-      return i.m_cur_node ? i : this->end();\n+      std::size_t n = this->bucket_index(k, code, this->bucket_count());\n+      node* p = m_find_node(m_buckets[n], k, code);\n+      return p ? const_iterator(p, m_buckets + n) : this->end();\n     }\n \n   template<typename K, typename V, \n@@ -1750,8 +1743,10 @@ _GLIBCXX_BEGIN_NAMESPACE(tr1)\n       typename hashtable::hash_code_t code = this->m_hash_code(k);\n       size_type n = this->bucket_index(k, code, m_bucket_count);\n \n-      node* new_node = m_allocate_node(v);\n+      // First find the node, avoid leaking new_node if compare throws.\n       node* prev = m_find_node(m_buckets[n], k, code);\n+      node* new_node = m_allocate_node(v);\n+\n       if (prev)\n \t{\n \t  new_node->m_next = prev->m_next;"}]}