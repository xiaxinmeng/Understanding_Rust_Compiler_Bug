{"sha": "40a777e840f74dd5c19ea26c55d1248a335fd11b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDBhNzc3ZTg0MGY3NGRkNWMxOWVhMjZjNTVkMTI0OGEzMzVmZDExYg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-11-03T22:32:56Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-11-03T22:32:56Z"}, "message": "Improve effectivity of ipa_polymorphi_context cache.\n\n        * ipa-fnsummary.c (set_cond_stmt_execution_predicate,\n\tset_switch_stmt_execution_predicate, compute_bb_predicates,\n\twill_be_nonconstant_expr_predicate,\n\tphi_result_unknown_predicate,\n\tanalyze_function_body): Pass arround params summary.\n\t(ipa_call_context::duplicate_from): New comment;\n\tonly duplicate useful values.\n\t(ipa_call_context::equal_to): Only compare useful values.\n\t(remap_edge_summaries): Pass params_summary.\n\t(remap_hint_predicate): Likewise.\n\t(ipa_merge_fn_summary_after_inlining): Likewise.\n\t(inline_read_section): Initialize params summary used flags.\n\t* ipa-predicate.c (predicate::remap_after_inlining): Pass\n\taround param_summary.\n\t(add_condition): Initialized used params summary flags.\n\t* ipa-predicate.h (inline_param_summary::equals_to): Make const.\n\t(inline_param_summary::useless_p): New predicate.\n\t(remap_after_inlining, add_condition): Update prototype\n\t* ipa-prop.c (ipa_populate_param_decls): Watch overflow in\n\tmove_cost.\n\t(ipa_note_param_call): Add parameter POLYMORPHIC; update params\n\tsummaries.\n\t(ipa_analyze_indirect_call_uses): Update use of ipa_note_param_call.\n\t(ipa_analyze_virtual_call_uses): Likewise.\n\t(update_indirect_edges_after_inlining): Update param summaries.\n\t(ipa_print_node_params): Print used flags.\n\t(ipa_read_indirect_edge_info): Update param summareis.\n\t* ipa-prop.h (ipa_param_descriptor): Add\n\tused_by_ipa_predicates, used_by_indirect_call\n\tand used_by_polymorphic_call.\n\t(ipa_set_param_used_by_ipa_predicates,\n\tipa_set_param_used_by_indirect_call,\n\tipa_set_param_used_by_polymorphic_call,\n\tipa_is_param_used_by_ipa_predicates,\n\tipa_is_param_used_by_indirect_call,\n\tipa_is_param_used_by_polymorphic_call): New inline functions.\n\nFrom-SVN: r277759", "tree": {"sha": "d986b1ce6aa2a9086a52ad6e19d0181b37c71a3c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d986b1ce6aa2a9086a52ad6e19d0181b37c71a3c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/40a777e840f74dd5c19ea26c55d1248a335fd11b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a777e840f74dd5c19ea26c55d1248a335fd11b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/40a777e840f74dd5c19ea26c55d1248a335fd11b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/40a777e840f74dd5c19ea26c55d1248a335fd11b/comments", "author": null, "committer": null, "parents": [{"sha": "4bcd578ab4927bc42b72b66d6d4d816ae5598ae7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bcd578ab4927bc42b72b66d6d4d816ae5598ae7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bcd578ab4927bc42b72b66d6d4d816ae5598ae7"}], "stats": {"total": 477, "additions": 383, "deletions": 94}, "files": [{"sha": "c108ac2108d311aa427e669147f20b6fd7c458cd", "filename": "gcc/ChangeLog", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -1,3 +1,42 @@\n+2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* ipa-fnsummary.c (set_cond_stmt_execution_predicate,\n+\tset_switch_stmt_execution_predicate, compute_bb_predicates,\n+\twill_be_nonconstant_expr_predicate,\n+\tphi_result_unknown_predicate,\n+\tanalyze_function_body): Pass arround params summary.\n+\t(ipa_call_context::duplicate_from): New comment;\n+\tonly duplicate useful values.\n+\t(ipa_call_context::equal_to): Only compare useful values.\n+\t(remap_edge_summaries): Pass params_summary.\n+\t(remap_hint_predicate): Likewise.\n+\t(ipa_merge_fn_summary_after_inlining): Likewise.\n+\t(inline_read_section): Initialize params summary used flags.\n+\t* ipa-predicate.c (predicate::remap_after_inlining): Pass\n+\taround param_summary.\n+\t(add_condition): Initialized used params summary flags.\n+\t* ipa-predicate.h (inline_param_summary::equals_to): Make const.\n+\t(inline_param_summary::useless_p): New predicate.\n+\t(remap_after_inlining, add_condition): Update prototype\n+\t* ipa-prop.c (ipa_populate_param_decls): Watch overflow in\n+\tmove_cost.\n+\t(ipa_note_param_call): Add parameter POLYMORPHIC; update params\n+\tsummaries.\n+\t(ipa_analyze_indirect_call_uses): Update use of ipa_note_param_call.\n+\t(ipa_analyze_virtual_call_uses): Likewise.\n+\t(update_indirect_edges_after_inlining): Update param summaries.\n+\t(ipa_print_node_params): Print used flags.\n+\t(ipa_read_indirect_edge_info): Update param summareis.\n+\t* ipa-prop.h (ipa_param_descriptor): Add\n+\tused_by_ipa_predicates, used_by_indirect_call\n+\tand used_by_polymorphic_call.\n+\t(ipa_set_param_used_by_ipa_predicates,\n+\tipa_set_param_used_by_indirect_call,\n+\tipa_set_param_used_by_polymorphic_call,\n+\tipa_is_param_used_by_ipa_predicates,\n+\tipa_is_param_used_by_indirect_call,\n+\tipa_is_param_used_by_polymorphic_call): New inline functions.\n+\n 2019-11-02  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* ipa-fnsummary.c (ipa_call_context::duplicate_from): New"}, {"sha": "4a3cb760a265ba0b5b13eb785a84736b11b17db6", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 222, "deletions": 79, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -1312,6 +1312,7 @@ decompose_param_expr (struct ipa_func_body_info *fbi,\n static void\n set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t   class ipa_fn_summary *summary,\n+\t\t\t\t   class ipa_node_params *params_summary,\n \t\t\t\t   basic_block bb)\n {\n   gimple *last;\n@@ -1354,7 +1355,8 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t      && !dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \t    {\n \t      predicate p\n-\t\t= add_condition (summary, index, param_type, &aggpos,\n+\t\t= add_condition (summary, params_summary, index,\n+\t\t\t       \t param_type, &aggpos,\n \t\t\t\t this_code, gimple_cond_rhs (last), param_ops);\n \t      e->aux = edge_predicate_pool.allocate ();\n \t      *(predicate *) e->aux = p;\n@@ -1387,7 +1389,8 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n     return;\n   FOR_EACH_EDGE (e, ei, bb->succs) if (e->flags & EDGE_FALSE_VALUE)\n     {\n-      predicate p = add_condition (summary, index, param_type, &aggpos,\n+      predicate p = add_condition (summary, params_summary, index,\n+\t\t     \t\t   param_type, &aggpos,\n \t\t\t\t   predicate::is_not_constant, NULL_TREE);\n       e->aux = edge_predicate_pool.allocate ();\n       *(predicate *) e->aux = p;\n@@ -1401,6 +1404,7 @@ set_cond_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n static void\n set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t\t\t\t     class ipa_fn_summary *summary,\n+\t\t\t\t     class ipa_node_params *params_summary,\n \t\t\t\t     basic_block bb)\n {\n   gimple *lastg;\n@@ -1470,15 +1474,15 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       if (dominated_by_p (CDI_POST_DOMINATORS, bb, e->dest))\n \tp = true;\n       else if (min == max)\n-\tp = add_condition (summary, index, param_type, &aggpos, EQ_EXPR,\n-\t\t\t   min, param_ops);\n+\tp = add_condition (summary, params_summary, index, param_type,\n+\t\t           &aggpos, EQ_EXPR, min, param_ops);\n       else\n \t{\n \t  predicate p1, p2;\n-\t  p1 = add_condition (summary, index, param_type, &aggpos, GE_EXPR,\n-\t\t\t      min, param_ops);\n-\t  p2 = add_condition (summary, index, param_type, &aggpos, LE_EXPR,\n-\t\t\t      max, param_ops);\n+\t  p1 = add_condition (summary, params_summary, index, param_type,\n+\t\t\t      &aggpos, GE_EXPR, min, param_ops);\n+\t  p2 = add_condition (summary,  params_summary,index, param_type,\n+\t\t\t      &aggpos, LE_EXPR, max, param_ops);\n \t  p = p1 & p2;\n \t}\n       *(class predicate *) e->aux\n@@ -1559,15 +1563,17 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n       tree max = ranges[i].second;\n \n       if (min == max)\n-\tp_seg &= add_condition (summary, index, param_type, &aggpos, NE_EXPR,\n+\tp_seg &= add_condition (summary, params_summary, index,\n+\t\t       \t\tparam_type, &aggpos, NE_EXPR,\n \t\t\t\tmin, param_ops);\n       else\n \t{\n \t  /* Do not create sub-predicate for range that is beyond low bound\n \t     of switch index.  */\n \t  if (wi::lt_p (vr_wmin, wi::to_wide (min), TYPE_SIGN (type)))\n \t    {\n-\t      p_seg &= add_condition (summary, index, param_type, &aggpos,\n+\t      p_seg &= add_condition (summary, params_summary, index,\n+\t\t\t     \t      param_type, &aggpos,\n \t\t\t\t      LT_EXPR, min, param_ops);\n \t      p_all = p_all.or_with (summary->conds, p_seg);\n \t    }\n@@ -1580,7 +1586,8 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \t      break;\n \t    }\n \n-\t  p_seg = add_condition (summary, index, param_type, &aggpos, GT_EXPR,\n+\t  p_seg = add_condition (summary, params_summary, index,\n+\t\t\t \t param_type, &aggpos, GT_EXPR,\n \t\t\t\t max, param_ops);\n \t}\n     }\n@@ -1599,16 +1606,17 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n static void\n compute_bb_predicates (struct ipa_func_body_info *fbi,\n \t\t       struct cgraph_node *node,\n-\t\t       class ipa_fn_summary *summary)\n+\t\t       class ipa_fn_summary *summary,\n+\t\t       class ipa_node_params *params_summary)\n {\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   bool done = false;\n   basic_block bb;\n \n   FOR_EACH_BB_FN (bb, my_function)\n     {\n-      set_cond_stmt_execution_predicate (fbi, summary, bb);\n-      set_switch_stmt_execution_predicate (fbi, summary, bb);\n+      set_cond_stmt_execution_predicate (fbi, summary, params_summary, bb);\n+      set_switch_stmt_execution_predicate (fbi, summary, params_summary, bb);\n     }\n \n   /* Entry block is always executable.  */\n@@ -1701,6 +1709,7 @@ compute_bb_predicates (struct ipa_func_body_info *fbi,\n static predicate\n will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n \t\t\t\t    class ipa_fn_summary *summary,\n+\t\t\t\t    class ipa_node_params *params_summary,\n \t\t\t\t    tree expr,\n \t\t\t\t    vec<predicate> nonconstant_names)\n {\n@@ -1712,7 +1721,7 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n \n   parm = unmodified_parm (fbi, NULL, expr, NULL);\n   if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n-    return add_condition (summary, index, TREE_TYPE (parm), NULL,\n+    return add_condition (summary, params_summary, index, TREE_TYPE (parm), NULL,\n \t\t\t  predicate::changed, NULL_TREE);\n   if (is_gimple_min_invariant (expr))\n     return false;\n@@ -1722,13 +1731,15 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n     {\n       predicate p1\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 0),\n \t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n       predicate p2\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 1),\n \t\t\t\t\t      nonconstant_names);\n       return p1.or_with (summary->conds, p2);\n@@ -1737,19 +1748,22 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n     {\n       predicate p1\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 0),\n \t\t\t\t\t      nonconstant_names);\n       if (p1 == true)\n \treturn p1;\n \n       predicate p2\n \t= will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t      params_summary,\n \t\t\t\t\t      TREE_OPERAND (expr, 1),\n \t\t\t\t\t      nonconstant_names);\n       if (p2 == true)\n \treturn p2;\n       p1 = p1.or_with (summary->conds, p2);\n       p2 = will_be_nonconstant_expr_predicate (fbi, summary,\n+\t\t\t\t\t       params_summary,\n \t\t\t\t\t       TREE_OPERAND (expr, 2),\n \t\t\t\t\t       nonconstant_names);\n       return p2.or_with (summary->conds, p1);\n@@ -1771,6 +1785,7 @@ will_be_nonconstant_expr_predicate (ipa_func_body_info *fbi,\n static predicate\n will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \t\t\t       class ipa_fn_summary *summary,\n+\t\t\t       class ipa_node_params *params_summary,\n \t\t\t       gimple *stmt,\n \t\t\t       vec<predicate> nonconstant_names)\n {\n@@ -1828,7 +1843,8 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n \n   if (is_load)\n     op_non_const =\n-      add_condition (summary, base_index, param_type, &aggpos,\n+      add_condition (summary, params_summary,\n+\t\t     base_index, param_type, &aggpos,\n \t\t     predicate::changed, NULL_TREE);\n   else\n     op_non_const = false;\n@@ -1840,7 +1856,8 @@ will_be_nonconstant_predicate (struct ipa_func_body_info *fbi,\n       if (parm && (index = ipa_get_param_decl_index (fbi->info, parm)) >= 0)\n \t{\n \t  if (index != base_index)\n-\t    p = add_condition (summary, index, TREE_TYPE (parm), NULL,\n+\t    p = add_condition (summary, params_summary, index,\n+\t\t\t       TREE_TYPE (parm), NULL,\n \t\t\t       predicate::changed, NULL_TREE);\n \t  else\n \t    continue;\n@@ -2027,7 +2044,9 @@ param_change_prob (ipa_func_body_info *fbi, gimple *stmt, int i)\n \n static bool\n phi_result_unknown_predicate (ipa_func_body_info *fbi,\n-\t\t\t      ipa_fn_summary *summary, basic_block bb,\n+\t\t\t      ipa_fn_summary *summary,\n+\t\t\t      class ipa_node_params *params_summary,\n+\t\t\t      basic_block bb,\n \t\t\t      predicate *p,\n \t\t\t      vec<predicate> nonconstant_names)\n {\n@@ -2071,7 +2090,7 @@ phi_result_unknown_predicate (ipa_func_body_info *fbi,\n       || !is_gimple_ip_invariant (gimple_cond_rhs (stmt)))\n     return false;\n \n-  *p = will_be_nonconstant_expr_predicate (fbi, summary,\n+  *p = will_be_nonconstant_expr_predicate (fbi, summary, params_summary,\n \t\t\t\t\t   gimple_cond_lhs (stmt),\n \t\t\t\t\t   nonconstant_names);\n   if (*p == true)\n@@ -2264,6 +2283,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n   sreal freq;\n   class ipa_fn_summary *info = ipa_fn_summaries->get_create (node);\n+  class ipa_node_params *params_summary = early ? NULL : IPA_NODE_REF (node);\n   predicate bb_predicate;\n   struct ipa_func_body_info fbi;\n   vec<predicate> nonconstant_names = vNULL;\n@@ -2329,7 +2349,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t           bb_predicate);\n \n   if (fbi.info)\n-    compute_bb_predicates (&fbi, node, info);\n+    compute_bb_predicates (&fbi, node, info, params_summary);\n   order = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n   nblocks = pre_and_rev_post_order_compute (NULL, order, false);\n   for (n = 0; n < nblocks; n++)\n@@ -2371,7 +2391,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t       gsi_next (&bsi))\n \t    {\n \t      if (first_phi\n-\t\t  && !phi_result_unknown_predicate (&fbi, info, bb,\n+\t\t  && !phi_result_unknown_predicate (&fbi, info,\n+\t\t\t  \t\t\t    params_summary,\n+\t\t\t \t\t\t    bb,\n \t\t\t\t\t\t    &phi_predicate,\n \t\t\t\t\t\t    nonconstant_names))\n \t\tbreak;\n@@ -2469,7 +2491,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t     just maximum of the possible paths.  */\n \t  if (fbi.info)\n \t    will_be_nonconstant\n-\t      = will_be_nonconstant_predicate (&fbi, info,\n+\t      = will_be_nonconstant_predicate (&fbi, info, params_summary,\n \t\t\t\t\t       stmt, nonconstant_names);\n \t  else\n \t    will_be_nonconstant = true;\n@@ -2536,7 +2558,8 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t    predicate p = bb_predicate;\n \t\t    if (fbi.info)\n \t\t      p = p & will_be_nonconstant_expr_predicate\n-\t\t\t\t (&fbi, info, TREE_OPERAND (op, 1),\n+\t\t\t\t (&fbi, info, params_summary,\n+\t\t\t\t  TREE_OPERAND (op, 1),\n \t\t\t          nonconstant_names);\n \t\t    if (p != false)\n \t\t      {\n@@ -2581,6 +2604,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t    {\n \t      predicate will_be_nonconstant\n \t\t= will_be_nonconstant_expr_predicate (&fbi, info,\n+\t\t\t\t\t\t      params_summary,\n \t\t\t\t\t\t      niter_desc.niter,\n \t\t\t\t\t\t      nonconstant_names);\n \t      if (will_be_nonconstant != true)\n@@ -2625,7 +2649,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t\t    continue;\n \n \t\t  predicate will_be_nonconstant\n-\t\t    = will_be_nonconstant_expr_predicate (&fbi, info, iv.step,\n+\t\t    = will_be_nonconstant_expr_predicate (&fbi, info,\n+\t\t\t\t    \t\t\t  params_summary,\n+\t\t\t\t   \t\t\t  iv.step,\n \t\t\t\t\t\t\t  nonconstant_names);\n \t\t  if (will_be_nonconstant != true)\n \t\t    will_be_nonconstant = bb_predicate & will_be_nonconstant;\n@@ -2964,29 +2990,73 @@ ipa_call_context::ipa_call_context (cgraph_node *node,\n {\n }\n \n+/* Set THIS to be a duplicate of CTX.  Copy all relevant info.  */\n+\n void\n ipa_call_context::duplicate_from (const ipa_call_context &ctx)\n {\n   m_node = ctx.m_node;\n   m_possible_truths = ctx.m_possible_truths;\n   m_nonspec_possible_truths = ctx.m_nonspec_possible_truths;\n+  class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n+  unsigned int nargs = ipa_get_param_count (params_summary);\n \n+  m_inline_param_summary = vNULL;\n+  /* Copy the info only if there is at least one useful entry.  */\n   if (ctx.m_inline_param_summary.exists ())\n-    m_inline_param_summary = ctx.m_inline_param_summary.copy ();\n-  else\n-    m_inline_param_summary = vNULL;\n+    {\n+      unsigned int n = MIN (ctx.m_inline_param_summary.length (), nargs);\n+\n+      for (unsigned int i = 0; i < n; i++)\n+\tif (ipa_is_param_used_by_ipa_predicates (params_summary, i)\n+\t    && !ctx.m_inline_param_summary[i].useless_p ())\n+\t  {\n+            m_inline_param_summary\n+\t\t    = ctx.m_inline_param_summary.copy ();\n+\t    break;\n+\t  }\n+    }\n+  m_known_vals = vNULL;\n   if (ctx.m_known_vals.exists ())\n-    m_known_vals = ctx.m_known_vals.copy ();\n-  else\n-    m_known_vals = vNULL;\n+    {\n+      unsigned int n = MIN (ctx.m_known_vals.length (), nargs);\n+\n+      for (unsigned int i = 0; i < n; i++)\n+\tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n+\t    && ctx.m_known_vals[i])\n+\t  {\n+\t    m_known_vals = ctx.m_known_vals.copy ();\n+\t    break;\n+\t  }\n+    }\n+\n+  m_known_contexts = vNULL;\n   if (ctx.m_known_contexts.exists ())\n-    m_known_contexts = ctx.m_known_contexts.copy ();\n-  else\n-    m_known_contexts = vNULL;\n+    {\n+      unsigned int n = MIN (ctx.m_known_contexts.length (), nargs);\n+\n+      for (unsigned int i = 0; i < n; i++)\n+\tif (ipa_is_param_used_by_polymorphic_call (params_summary, i)\n+\t    && !ctx.m_known_contexts[i].useless_p ())\n+\t  {\n+\t    m_known_contexts = ctx.m_known_contexts.copy ();\n+\t    break;\n+\t  }\n+    }\n+\n+  m_known_aggs = vNULL;\n   if (ctx.m_known_aggs.exists ())\n-    m_known_aggs = ctx.m_known_aggs.copy ();\n-  else\n-    m_known_aggs = vNULL;\n+    {\n+      unsigned int n = MIN (ctx.m_known_aggs.length (), nargs);\n+\n+      for (unsigned int i = 0; i < n; i++)\n+\tif (ipa_is_param_used_by_indirect_call (params_summary, i)\n+\t    && ctx.m_known_aggs[i])\n+\t  {\n+\t    m_known_aggs = ctx.m_known_aggs.copy ();\n+\t    break;\n+\t  }\n+    }\n }\n \n /* Release memory used by known_vals/contexts/aggs vectors.\n@@ -3016,49 +3086,107 @@ ipa_call_context::equal_to (const ipa_call_context &ctx)\n       || m_possible_truths != ctx.m_possible_truths\n       || m_nonspec_possible_truths != ctx.m_nonspec_possible_truths)\n     return false;\n-  if (m_inline_param_summary.exists () != ctx.m_inline_param_summary.exists ()\n-      || m_known_vals.exists () != ctx.m_known_vals.exists()\n-      || m_known_contexts.exists () != ctx.m_known_contexts.exists ()\n-      || m_known_aggs.exists () != ctx.m_known_aggs.exists ())\n-    return false;\n-  if (m_inline_param_summary.exists ())\n+\n+  class ipa_node_params *params_summary = IPA_NODE_REF (m_node);\n+  unsigned int nargs = ipa_get_param_count (params_summary);\n+\n+  if (m_inline_param_summary.exists () || ctx.m_inline_param_summary.exists ())\n     {\n-      if (m_inline_param_summary.length () != ctx.m_inline_param_summary.length ())\n-\treturn false;\n-      for (unsigned int i = 0; i < m_inline_param_summary.length (); i++)\n-\tif (!m_inline_param_summary[i].equal_to (ctx.m_inline_param_summary[i]))\n-\t  return false;\n+      for (unsigned int i = 0; i < nargs; i++)\n+\t{\n+\t  if (!ipa_is_param_used_by_ipa_predicates (params_summary, i))\n+\t    continue;\n+\t  if (i >= m_inline_param_summary.length ()\n+\t      || m_inline_param_summary[i].useless_p ())\n+\t    {\n+\t      if (i < ctx.m_inline_param_summary.length ()\n+\t\t  && !ctx.m_inline_param_summary[i].useless_p ())\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (i >= ctx.m_inline_param_summary.length ()\n+\t      || ctx.m_inline_param_summary[i].useless_p ())\n+\t    {\n+\t      if (i < m_inline_param_summary.length ()\n+\t\t  && !m_inline_param_summary[i].useless_p ())\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (!m_inline_param_summary[i].equal_to\n+\t     \t (ctx.m_inline_param_summary[i]))\n+\t    return false;\n+\t}\n     }\n-  if (m_known_vals.exists ())\n+  if (m_known_vals.exists () || ctx.m_known_vals.exists ())\n     {\n-      if (m_known_vals.length () != ctx.m_known_vals.length ())\n-\treturn false;\n-      for (unsigned int i = 0; i < m_known_vals.length (); i++)\n+      for (unsigned int i = 0; i < nargs; i++)\n \t{\n-\t  tree t1 = m_known_vals[i];\n-\t  tree t2 = ctx.m_known_vals[i];\n-\n-\t  if (t1 != t2\n-\t      && (!t1 || !t2 || !operand_equal_p (m_known_vals[i],\n-\t\t\t\t\t\t  ctx.m_known_vals[i], 0)))\n+\t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n+\t    continue;\n+\t  if (i >= m_known_vals.length () || !m_known_vals[i])\n+\t    {\n+\t      if (i < ctx.m_known_vals.length () && ctx.m_known_vals[i])\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (i >= ctx.m_known_vals.length () || !ctx.m_known_vals[i])\n+\t    {\n+\t      if (i < m_known_vals.length () && m_known_vals[i])\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (m_known_vals[i] != ctx.m_known_vals[i])\n \t    return false;\n \t}\n     }\n-  if (m_known_contexts.exists ())\n+  if (m_known_contexts.exists () || ctx.m_known_contexts.exists ())\n     {\n-      if (m_known_contexts.length () != ctx.m_known_contexts.length ())\n-\treturn false;\n-      for (unsigned int i = 0; i < m_known_contexts.length (); i++)\n-\tif (!m_known_contexts[i].equal_to (ctx.m_known_contexts[i]))\n-\t  return false;\n+      for (unsigned int i = 0; i < nargs; i++)\n+\t{\n+\t  if (!ipa_is_param_used_by_polymorphic_call (params_summary, i))\n+\t    continue;\n+\t  if (i >= m_known_contexts.length ()\n+\t      || m_known_contexts[i].useless_p ())\n+\t    {\n+\t      if (i < ctx.m_known_contexts.length ()\n+\t\t  && !ctx.m_known_contexts[i].useless_p ())\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (i >= ctx.m_known_contexts.length ()\n+\t      || ctx.m_known_contexts[i].useless_p ())\n+\t    {\n+\t      if (i < m_known_contexts.length ()\n+\t\t  && !m_known_contexts[i].useless_p ())\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (!m_known_contexts[i].equal_to\n+\t     \t (ctx.m_known_contexts[i]))\n+\t    return false;\n+\t}\n     }\n-  if (m_known_aggs.exists ())\n+  if (m_known_aggs.exists () || ctx.m_known_aggs.exists ())\n     {\n-      if (m_known_aggs.length () != ctx.m_known_aggs.length ())\n-\treturn false;\n-      for (unsigned int i = 0; i < m_known_aggs.length (); i++)\n-\tif (!m_known_aggs[i]->equal_to (*ctx.m_known_aggs[i]))\n-\t  return false;\n+      for (unsigned int i = 0; i < nargs; i++)\n+\t{\n+\t  if (!ipa_is_param_used_by_indirect_call (params_summary, i))\n+\t    continue;\n+\t  if (i >= m_known_aggs.length () || !m_known_aggs[i])\n+\t    {\n+\t      if (i < ctx.m_known_aggs.length () && ctx.m_known_aggs[i])\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (i >= ctx.m_known_aggs.length () || !ctx.m_known_aggs[i])\n+\t    {\n+\t      if (i < m_known_aggs.length () && m_known_aggs[i])\n+\t\treturn false;\n+\t      continue;\n+\t    }\n+\t  if (m_known_aggs[i] != ctx.m_known_aggs[i])\n+\t    return false;\n+\t}\n     }\n   return true;\n }\n@@ -3319,6 +3447,7 @@ static void\n remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t\t      struct cgraph_node *node,\n \t\t      class ipa_fn_summary *info,\n+\t\t      class ipa_node_params *params_summary,\n \t\t      class ipa_fn_summary *callee_info,\n \t\t      vec<int> operand_map,\n \t\t      vec<int> offset_map,\n@@ -3339,7 +3468,8 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t  if (es->predicate)\n \t    {\n \t      p = es->predicate->remap_after_inlining\n-\t\t\t\t     (info, callee_info, operand_map,\n+\t\t\t\t     (info, params_summary,\n+\t\t\t\t      callee_info, operand_map,\n \t\t\t\t      offset_map, possible_truths,\n \t\t\t\t      *toplev_predicate);\n \t      edge_set_predicate (e, &p);\n@@ -3348,7 +3478,8 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \t    edge_set_predicate (e, toplev_predicate);\n \t}\n       else\n-\tremap_edge_summaries (inlined_edge, e->callee, info, callee_info,\n+\tremap_edge_summaries (inlined_edge, e->callee, info,\n+\t\t              params_summary, callee_info,\n \t\t\t      operand_map, offset_map, possible_truths,\n \t\t\t      toplev_predicate);\n     }\n@@ -3362,7 +3493,8 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n       if (es->predicate)\n \t{\n \t  p = es->predicate->remap_after_inlining\n-\t\t\t\t (info, callee_info, operand_map, offset_map,\n+\t\t\t\t (info, params_summary,\n+\t\t\t\t  callee_info, operand_map, offset_map,\n \t\t\t          possible_truths, *toplev_predicate);\n \t  edge_set_predicate (e, &p);\n \t}\n@@ -3375,6 +3507,7 @@ remap_edge_summaries (struct cgraph_edge *inlined_edge,\n \n static void\n remap_hint_predicate (class ipa_fn_summary *info,\n+\t\t      class ipa_node_params *params_summary,\n \t\t      class ipa_fn_summary *callee_info,\n \t\t      predicate **hint,\n \t\t      vec<int> operand_map,\n@@ -3387,7 +3520,7 @@ remap_hint_predicate (class ipa_fn_summary *info,\n   if (!*hint)\n     return;\n   p = (*hint)->remap_after_inlining\n-\t\t\t (info, callee_info,\n+\t\t\t (info, params_summary, callee_info,\n \t\t\t  operand_map, offset_map,\n \t\t\t  possible_truths, *toplev_predicate);\n   if (p != false && p != true)\n@@ -3415,6 +3548,8 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n   int i;\n   predicate toplev_predicate;\n   class ipa_call_summary *es = ipa_call_summaries->get (edge);\n+  class ipa_node_params *params_summary = (ipa_node_params_sum\n+\t\t \t\t\t   ? IPA_NODE_REF (to) : NULL);\n \n   if (es->predicate)\n     toplev_predicate = *es->predicate;\n@@ -3461,19 +3596,21 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t\t}\n \t    }\n \t  operand_map[i] = map;\n-\t  gcc_assert (map < ipa_get_param_count (IPA_NODE_REF (to)));\n+\t  gcc_assert (map < ipa_get_param_count (params_summary));\n \t}\n     }\n   for (i = 0; vec_safe_iterate (callee_info->size_time_table, i, &e); i++)\n     {\n       predicate p;\n       p = e->exec_predicate.remap_after_inlining\n-\t\t\t     (info, callee_info, operand_map,\n+\t\t\t     (info, params_summary,\n+\t\t\t      callee_info, operand_map,\n \t\t\t      offset_map, clause,\n \t\t\t      toplev_predicate);\n       predicate nonconstp;\n       nonconstp = e->nonconst_predicate.remap_after_inlining\n-\t\t\t\t     (info, callee_info, operand_map,\n+\t\t\t\t     (info, params_summary,\n+\t\t\t\t      callee_info, operand_map,\n \t\t\t\t      offset_map, clause,\n \t\t\t\t      toplev_predicate);\n       if (p != false && nonconstp != false)\n@@ -3491,12 +3628,13 @@ ipa_merge_fn_summary_after_inlining (struct cgraph_edge *edge)\n \t  info->account_size_time (e->size, add_time, p, nonconstp);\n \t}\n     }\n-  remap_edge_summaries (edge, edge->callee, info, callee_info, operand_map,\n+  remap_edge_summaries (edge, edge->callee, info, params_summary,\n+\t\t \tcallee_info, operand_map,\n \t\t\toffset_map, clause, &toplev_predicate);\n-  remap_hint_predicate (info, callee_info,\n+  remap_hint_predicate (info, params_summary, callee_info,\n \t\t\t&callee_info->loop_iterations,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n-  remap_hint_predicate (info, callee_info,\n+  remap_hint_predicate (info, params_summary, callee_info,\n \t\t\t&callee_info->loop_stride,\n \t\t\toperand_map, offset_map, clause, &toplev_predicate);\n \n@@ -3687,6 +3825,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       unsigned int index;\n       struct cgraph_node *node;\n       class ipa_fn_summary *info;\n+      class ipa_node_params *params_summary;\n       class ipa_size_summary *size_info;\n       lto_symtab_encoder_t encoder;\n       struct bitpack_d bp;\n@@ -3698,6 +3837,7 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n       node = dyn_cast<cgraph_node *> (lto_symtab_encoder_deref (encoder,\n \t\t\t\t\t\t\t\tindex));\n       info = node->prevailing_p () ? ipa_fn_summaries->get_create (node) : NULL;\n+      params_summary = node->prevailing_p () ? IPA_NODE_REF (node) : NULL;\n       size_info = node->prevailing_p ()\n \t\t  ? ipa_size_summaries->get_create (node) : NULL;\n \n@@ -3746,6 +3886,9 @@ inline_read_section (struct lto_file_decl_data *file_data, const char *data,\n \t  c.param_ops = NULL;\n \t  if (info)\n \t    vec_safe_reserve_exact (c.param_ops, count3);\n+\t  if (params_summary)\n+\t    ipa_set_param_used_by_ipa_predicates\n+\t\t    (params_summary, c.operand_num, true);\n \t  for (k = 0; k < count3; k++)\n \t    {\n \t      struct expr_eval_op op;"}, {"sha": "721f0957f9f9bfbf062cd0f826ab12fd3c54cfdc", "filename": "gcc/ipa-predicate.c", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-predicate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-predicate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.c?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -505,6 +505,7 @@ predicate::remap_after_duplication (clause_t possible_truths)\n \n predicate\n predicate::remap_after_inlining (class ipa_fn_summary *info,\n+\t\t\t\t class ipa_node_params *params_summary,\n \t\t\t\t class ipa_fn_summary *callee_info,\n \t\t\t\t vec<int> operand_map,\n \t\t\t\t vec<int> offset_map,\n@@ -566,7 +567,7 @@ predicate::remap_after_inlining (class ipa_fn_summary *info,\n \t\t    ap.offset = c->offset + offset_delta;\n \t\t    ap.agg_contents = c->agg_contents;\n \t\t    ap.by_ref = c->by_ref;\n-\t\t    cond_predicate = add_condition (info,\n+\t\t    cond_predicate = add_condition (info, params_summary,\n \t\t\t\t\t\t    operand_map[c->operand_num],\n \t\t\t\t\t\t    c->type, &ap, c->code,\n \t\t\t\t\t\t    c->val, c->param_ops);\n@@ -629,7 +630,9 @@ predicate::stream_out (struct output_block *ob)\n    aggregate.  */\n \n predicate\n-add_condition (class ipa_fn_summary *summary, int operand_num,\n+add_condition (class ipa_fn_summary *summary,\n+\t       class ipa_node_params *params_summary,\n+\t       int operand_num,\n \t       tree type, struct agg_position_info *aggpos,\n \t       enum tree_code code, tree val, expr_eval_ops param_ops)\n {\n@@ -640,6 +643,9 @@ add_condition (class ipa_fn_summary *summary, int operand_num,\n   bool agg_contents, by_ref;\n   expr_eval_op *op;\n \n+  if (params_summary)\n+    ipa_set_param_used_by_ipa_predicates (params_summary, operand_num, true);\n+\n   if (aggpos)\n     {\n       offset = aggpos->offset;"}, {"sha": "25cd5f2797dd4c87e522e44d34ed00cb3295f731", "filename": "gcc/ipa-predicate.h", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-predicate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-predicate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-predicate.h?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -77,10 +77,14 @@ struct inline_param_summary\n \n      Value 0 is reserved for compile time invariants. */\n   int change_prob;\n-  bool equal_to (const inline_param_summary &other)\n+  bool equal_to (const inline_param_summary &other) const\n   {\n     return change_prob == other.change_prob;\n   }\n+  bool useless_p (void) const\n+  {\n+    return change_prob == REG_BR_PROB_BASE;\n+  }\n };\n \n typedef vec<condition, va_gc> *conditions;\n@@ -233,6 +237,7 @@ class predicate\n \n   /* Return predicate equal to THIS after inlining.  */\n   predicate remap_after_inlining (class ipa_fn_summary *,\n+\t\t  \t\t  class ipa_node_params *params_summary,\n \t\t\t          class ipa_fn_summary *,\n \t\t\t          vec<int>, vec<int>, clause_t, const predicate &);\n \n@@ -254,7 +259,9 @@ class predicate\n };\n \n void dump_condition (FILE *f, conditions conditions, int cond);\n-predicate add_condition (class ipa_fn_summary *summary, int operand_num,\n+predicate add_condition (class ipa_fn_summary *summary,\n+\t\t\t class ipa_node_params *params_summary,\n+\t       \t\t int operand_num,\n \t\t\t tree type, struct agg_position_info *aggpos,\n \t\t\t enum tree_code code, tree val,\n \t\t\t expr_eval_ops param_ops = NULL);"}, {"sha": "83cf4d1c7bacf94778e19b917aef21e83da9f535", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 41, "deletions": 10, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -227,8 +227,10 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n     {\n       descriptors[param_num].decl_or_type = parm;\n-      descriptors[param_num].move_cost = estimate_move_cost (TREE_TYPE (parm),\n-\t\t\t\t\t\t\t     true);\n+      unsigned int cost = estimate_move_cost (TREE_TYPE (parm), true);\n+      descriptors[param_num].move_cost = cost;\n+      /* Watch overflow, move_cost is a bitfield.  */\n+      gcc_checking_assert (cost == descriptors[param_num].move_cost);\n       param_num++;\n     }\n }\n@@ -2116,11 +2118,12 @@ ipa_is_ssa_with_stmt_def (tree t)\n \n /* Find the indirect call graph edge corresponding to STMT and mark it as a\n    call to a parameter number PARAM_INDEX.  NODE is the caller.  Return the\n-   indirect call graph edge.  */\n+   indirect call graph edge.\n+   If POLYMORPHIC is true record is as a destination of polymorphic call.  */\n \n static struct cgraph_edge *\n ipa_note_param_call (struct cgraph_node *node, int param_index,\n-\t\t     gcall *stmt)\n+\t\t     gcall *stmt, bool polymorphic)\n {\n   struct cgraph_edge *cs;\n \n@@ -2129,6 +2132,11 @@ ipa_note_param_call (struct cgraph_node *node, int param_index,\n   cs->indirect_info->agg_contents = 0;\n   cs->indirect_info->member_ptr = 0;\n   cs->indirect_info->guaranteed_unmodified = 0;\n+  ipa_set_param_used_by_indirect_call (IPA_NODE_REF (node),\n+\t\t\t\t\t  param_index, true);\n+  if (cs->indirect_info->polymorphic || polymorphic)\n+    ipa_set_param_used_by_polymorphic_call\n+\t    (IPA_NODE_REF (node), param_index, true);\n   return cs;\n }\n \n@@ -2204,7 +2212,7 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n       tree var = SSA_NAME_VAR (target);\n       int index = ipa_get_param_decl_index (info, var);\n       if (index >= 0)\n-\tipa_note_param_call (fbi->node, index, call);\n+\tipa_note_param_call (fbi->node, index, call, false);\n       return;\n     }\n \n@@ -2216,7 +2224,8 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n \t\t\t\t gimple_assign_rhs1 (def), &index, &offset,\n \t\t\t\t NULL, &by_ref, &guaranteed_unmodified))\n     {\n-      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n+      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index,\n+\t \t\t\t\t\t    call, false);\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->by_ref = by_ref;\n@@ -2317,7 +2326,8 @@ ipa_analyze_indirect_call_uses (struct ipa_func_body_info *fbi, gcall *call,\n   if (index >= 0\n       && parm_preserved_before_stmt_p (fbi, index, call, rec))\n     {\n-      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n+      struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index,\n+\t \t\t\t\t\t    call, false);\n       cs->indirect_info->offset = offset;\n       cs->indirect_info->agg_contents = 1;\n       cs->indirect_info->member_ptr = 1;\n@@ -2377,7 +2387,8 @@ ipa_analyze_virtual_call_uses (struct ipa_func_body_info *fbi,\n \treturn;\n     }\n \n-  struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index, call);\n+  struct cgraph_edge *cs = ipa_note_param_call (fbi->node, index,\n+     \t\t\t\t\t\tcall, true);\n   class cgraph_indirect_call_info *ii = cs->indirect_info;\n   ii->offset = anc_offset;\n   ii->otr_token = tree_to_uhwi (OBJ_TYPE_REF_TOKEN (target));\n@@ -3510,6 +3521,11 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t      if (ici->polymorphic\n \t\t  && !ipa_get_jf_pass_through_type_preserved (jfunc))\n \t\tici->vptr_changed = true;\n+\t      ipa_set_param_used_by_indirect_call (new_root_info,\n+\t\t\t     \t\t\t   ici->param_index, true);\n+\t      if (ici->polymorphic)\n+\t\tipa_set_param_used_by_polymorphic_call (new_root_info,\n+\t\t\t\t\t\t        ici->param_index, true);\n \t    }\n \t}\n       else if (jfunc->type == IPA_JF_ANCESTOR)\n@@ -4055,6 +4071,12 @@ ipa_print_node_params (FILE *f, struct cgraph_node *node)\n       ipa_dump_param (f, info, i);\n       if (ipa_is_param_used (info, i))\n \tfprintf (f, \" used\");\n+      if (ipa_is_param_used_by_ipa_predicates (info, i))\n+\tfprintf (f, \" used_by_ipa_predicates\");\n+      if (ipa_is_param_used_by_indirect_call (info, i))\n+\tfprintf (f, \" used_by_indirect_call\");\n+      if (ipa_is_param_used_by_polymorphic_call (info, i))\n+\tfprintf (f, \" used_by_polymorphic_call\");\n       c = ipa_get_controlled_uses (info, i);\n       if (c == IPA_UNDESCRIBED_USE)\n \tfprintf (f, \" undescribed_use\");\n@@ -4331,7 +4353,8 @@ ipa_write_indirect_edge_info (struct output_block *ob,\n static void\n ipa_read_indirect_edge_info (class lto_input_block *ib,\n \t\t\t     class data_in *data_in,\n-\t\t\t     struct cgraph_edge *cs)\n+\t\t\t     struct cgraph_edge *cs,\n+\t\t\t     class ipa_node_params *info)\n {\n   class cgraph_indirect_call_info *ii = cs->indirect_info;\n   struct bitpack_d bp;\n@@ -4354,6 +4377,14 @@ ipa_read_indirect_edge_info (class lto_input_block *ib,\n       ii->otr_type = stream_read_tree (ib, data_in);\n       ii->context.stream_in (ib, data_in);\n     }\n+  if (info && ii->param_index >= 0)\n+    {\n+      if (ii->polymorphic)\n+\tipa_set_param_used_by_polymorphic_call (info,\n+\t\t\t\t\t\tii->param_index , true);\n+      ipa_set_param_used_by_indirect_call (info,\n+\t\t\t\t\t   ii->param_index, true);\n+    }\n }\n \n /* Stream out NODE info to OB.  */\n@@ -4523,7 +4554,7 @@ ipa_read_node_info (class lto_input_block *ib, struct cgraph_node *node,\n   for (e = node->indirect_calls; e; e = e->next_callee)\n     {\n       ipa_read_edge_info (ib, data_in, e, prevails);\n-      ipa_read_indirect_edge_info (ib, data_in, e);\n+      ipa_read_indirect_edge_info (ib, data_in, e, info);\n     }\n }\n "}, {"sha": "9f2479e7fdc51b1a90c142dd617c94b5103de3f9", "filename": "gcc/ipa-prop.h", "status": "modified", "additions": 64, "deletions": 1, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-prop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/40a777e840f74dd5c19ea26c55d1248a335fd11b/gcc%2Fipa-prop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.h?ref=40a777e840f74dd5c19ea26c55d1248a335fd11b", "patch": "@@ -333,9 +333,12 @@ struct GTY(()) ipa_param_descriptor\n      says how many there are.  If any use could not be described by means of\n      ipa-prop structures, this is IPA_UNDESCRIBED_USE.  */\n   int controlled_uses;\n-  unsigned int move_cost : 31;\n+  unsigned int move_cost : 28;\n   /* The parameter is used.  */\n   unsigned used : 1;\n+  unsigned used_by_ipa_predicates : 1;\n+  unsigned used_by_indirect_call : 1;\n+  unsigned used_by_polymorphic_call : 1;\n };\n \n /* ipa_node_params stores information related to formal parameters of functions\n@@ -519,6 +522,36 @@ ipa_set_param_used (class ipa_node_params *info, int i, bool val)\n   (*info->descriptors)[i].used = val;\n }\n \n+/* Set the used_by_ipa_predicates flag corresponding to the Ith formal\n+   parameter of the function associated with INFO to VAL.  */\n+\n+static inline void\n+ipa_set_param_used_by_ipa_predicates (class ipa_node_params *info, int i, bool val)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].used_by_ipa_predicates = val;\n+}\n+\n+/* Set the used_by_indirect_call flag corresponding to the Ith formal\n+   parameter of the function associated with INFO to VAL.  */\n+\n+static inline void\n+ipa_set_param_used_by_indirect_call (class ipa_node_params *info, int i, bool val)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].used_by_indirect_call = val;\n+}\n+\n+/* Set the .used_by_polymorphic_call flag corresponding to the Ith formal\n+   parameter of the function associated with INFO to VAL.  */\n+\n+static inline void\n+ipa_set_param_used_by_polymorphic_call (class ipa_node_params *info, int i, bool val)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  (*info->descriptors)[i].used_by_polymorphic_call = val;\n+}\n+\n /* Return how many uses described by ipa-prop a parameter has or\n    IPA_UNDESCRIBED_USE if there is a use that is not described by these\n    structures.  */\n@@ -550,6 +583,36 @@ ipa_is_param_used (class ipa_node_params *info, int i)\n   return (*info->descriptors)[i].used;\n }\n \n+/* Return the used_by_ipa_predicates flag corresponding to the Ith formal\n+   parameter of the function associated with INFO.  */\n+\n+static inline bool\n+ipa_is_param_used_by_ipa_predicates (class ipa_node_params *info, int i)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  return (*info->descriptors)[i].used_by_ipa_predicates;\n+}\n+\n+/* Return the used_by_indirect_call flag corresponding to the Ith formal\n+   parameter of the function associated with INFO.  */\n+\n+static inline bool\n+ipa_is_param_used_by_indirect_call (class ipa_node_params *info, int i)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  return (*info->descriptors)[i].used_by_indirect_call;\n+}\n+\n+/* Return the used_by_polymorphic_call flag corresponding to the Ith formal\n+   parameter of the function associated with INFO.  */\n+\n+static inline bool\n+ipa_is_param_used_by_polymorphic_call (class ipa_node_params *info, int i)\n+{\n+  gcc_checking_assert (info->descriptors);\n+  return (*info->descriptors)[i].used_by_polymorphic_call;\n+}\n+\n /* Information about replacements done in aggregates for a given node (each\n    node has its linked list).  */\n struct GTY(()) ipa_agg_replacement_value"}]}