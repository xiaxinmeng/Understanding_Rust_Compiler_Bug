{"sha": "28ed46164618631d07f5ddee9a9743c378d6cbcc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlZDQ2MTY0NjE4NjMxZDA3ZjVkZGVlOWE5NzQzYzM3OGQ2Y2JjYw==", "commit": {"author": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-01-20T05:57:47Z"}, "committer": {"name": "Jason Merrill", "email": "merrill@gnu.org", "date": "1995-01-20T05:57:47Z"}, "message": "bool changes\n\nFrom-SVN: r8775", "tree": {"sha": "1d8b77268b5d4718a10cb4dda8c5da37d52a6f77", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1d8b77268b5d4718a10cb4dda8c5da37d52a6f77"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ed46164618631d07f5ddee9a9743c378d6cbcc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ed46164618631d07f5ddee9a9743c378d6cbcc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ed46164618631d07f5ddee9a9743c378d6cbcc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ed46164618631d07f5ddee9a9743c378d6cbcc/comments", "author": null, "committer": null, "parents": [{"sha": "46299de919c7e2d651b606c45f4327438ef8d6b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/46299de919c7e2d651b606c45f4327438ef8d6b7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/46299de919c7e2d651b606c45f4327438ef8d6b7"}], "stats": {"total": 28, "additions": 6, "deletions": 22}, "files": [{"sha": "f3d3764cf5299e142c625dce6709bb3f90e87daf", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed46164618631d07f5ddee9a9743c378d6cbcc/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed46164618631d07f5ddee9a9743c378d6cbcc/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=28ed46164618631d07f5ddee9a9743c378d6cbcc", "patch": "@@ -1439,7 +1439,7 @@ extern tree delta_type_node;\n extern tree long_long_integer_type_node, long_long_unsigned_type_node;\n /* For building calls to `delete'.  */\n extern tree integer_two_node, integer_three_node;\n-extern tree bool_type_node, true_node, false_node;\n+extern tree boolean_type_node, boolean_true_node, boolean_false_node;\n \n /* in pt.c  */\n /* PARM_VEC is a vector of template parameters, either IDENTIFIER_NODEs or"}, {"sha": "4883e7b609aeda839f6bfb58582a67e4f7e07f78", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 5, "deletions": 21, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ed46164618631d07f5ddee9a9743c378d6cbcc/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ed46164618631d07f5ddee9a9743c378d6cbcc/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=28ed46164618631d07f5ddee9a9743c378d6cbcc", "patch": "@@ -1246,23 +1246,7 @@ cp_convert (type, expr, convtype, flags)\n \t  return error_mark_node;\n \t}\n       if (code == BOOLEAN_TYPE)\n-\t{\n-\t  tree newe = truthvalue_conversion (e);\n-\t  /* Avoid stupid (infinite) recursion from backend. */\n-\t  if (TREE_CODE (newe) != NOP_EXPR || e != TREE_OPERAND (newe, 0))\n-\t    e = newe;\n-\t  if (TREE_TYPE (e) == bool_type_node)\n-\t    return e;\n-\t  else if (TREE_CODE (e) == INTEGER_CST)\n-\t    {\n-\t      if (e == integer_zero_node)\n-\t\te = false_node;\n-\t      else\n-\t\te = true_node;\n-\t    }\n-\t  else\n-\t    return build1 (NOP_EXPR, bool_type_node, e);\n-\t}\n+\treturn truthvalue_conversion (e);\n       return fold (convert_to_integer (type, e));\n     }\n   if (code == POINTER_TYPE)\n@@ -1907,8 +1891,8 @@ build_default_binary_type_conversion (code, arg1, arg2)\n   if (code == TRUTH_ANDIF_EXPR\n       || code == TRUTH_ORIF_EXPR)\n     {\n-      *arg1 = convert (bool_type_node, *arg1);\n-      *arg2 = convert (bool_type_node, *arg2);\n+      *arg1 = convert (boolean_type_node, *arg1);\n+      *arg2 = convert (boolean_type_node, *arg2);\n     }\n   else if (TYPE_HAS_INT_CONVERSION (type1))\n     {\n@@ -1971,7 +1955,7 @@ build_default_unary_type_conversion (code, arg)\n     }\n \n   if (code == TRUTH_NOT_EXPR)\n-    *arg = convert (bool_type_node, *arg);\n+    *arg = convert (boolean_type_node, *arg);\n   else if (TYPE_HAS_INT_CONVERSION (type))\n     {\n       if (TYPE_HAS_REAL_CONVERSION (type))\n@@ -2006,7 +1990,7 @@ type_promotes_to (type)\n \n   /* bool always promotes to int (not unsigned), even if it's the same\n      size.  */\n-  if (type == bool_type_node)\n+  if (type == boolean_type_node)\n     type = integer_type_node;\n \n   /* Normally convert enums to int, but convert wide enums to something"}]}