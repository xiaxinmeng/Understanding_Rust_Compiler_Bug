{"sha": "804670f120cd78a0304b630e7e53b1e13c9f5bfb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODA0NjcwZjEyMGNkNzhhMDMwNGI2MzBlN2U1M2IxZTEzYzlmNWJmYg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-02T09:28:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-04-02T09:28:52Z"}, "message": "[multiple changes]\n\n2012-04-02  Emmanuel Briot  <briot@adacore.com>\n\n\t* g-expect.adb (Expect_Internal): Fix leak of the input file descriptor.\n\n2012-04-02  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch4.adb (Expand_N_Quantified_Expression): Reimplemented.\n\tThe expansion no longer uses the copy of the original QE created\n\tduring analysis.\n\t* sem.adb (Analyze): Add processing for loop parameter specifications.\n\t* sem_ch4.adb (Analyze_Quantified_Expression): Reimplemented. The\n\troutine no longer creates a copy of the original QE. All\n\tconstituents of a QE are now preanalyzed and resolved.\n\t* sem_ch5.adb (Analyze_Iteration_Scheme): Remove the guard which\n\tbypasses all processing when the iteration scheme is related to a\n\tQE. Relovate the code which analyzes loop parameter specifications\n\tto a separate routine.\t(Analyze_Iterator_Specification):\n\tPreanalyze the iterator name. This action was originally\n\tdone in Analyze_Iteration_Scheme. Update the check which\n\tdetects an iterator specification in the context of a QE.\n\t(Analyze_Loop_Parameter_Specification): New routine. This\n\tprocedure allows for a stand-alone analysis of a loop parameter\n\tspecification without the need of a parent iteration scheme. Add\n\tcode to update the type of the loop variable when the range\n\tgenerates an itype and the context is a QE.\n\t(Pre_Analyze_Range): Renamed to Preanalyze_Range. Update all references\n\tto the routine.\n\t* sem_ch5.ads: Code reformatting.\n\t(Analyze_Loop_Parameter_Specification): New routine.\n\t* sem_ch6.adb (Fully_Conformant_Expressions): Detect a case\n\twhen establishing conformance between two QEs utilizing different\n\tspecifications.\n\t* sem_res.adb (Proper_Current_Scope): New routine.\n\t(Resolve): Do not resolve a QE as there is nothing to be done now.\n\tIgnore any loop scopes generated for QEs when detecting an expression\n\tfunction as the scopes are cosmetic and do not appear in the tree.\n\t(Resolve_Quantified_Expression): Removed. All resolution of\n\tQE constituents is now performed during analysis. This ensures\n\tthat loop variables appearing in array aggregates are properly\n\tresolved.\n\n2012-04-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Build_Default_Subtype): If the base type is\n\tprivate and its full view is available, use the full view in\n\tthe subtype declaration.\n\nFrom-SVN: r186074", "tree": {"sha": "73b0c5e92f353bdabf9f5aa631a04ff869eba933", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/73b0c5e92f353bdabf9f5aa631a04ff869eba933"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/804670f120cd78a0304b630e7e53b1e13c9f5bfb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804670f120cd78a0304b630e7e53b1e13c9f5bfb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/804670f120cd78a0304b630e7e53b1e13c9f5bfb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/804670f120cd78a0304b630e7e53b1e13c9f5bfb/comments", "author": null, "committer": null, "parents": [{"sha": "a7942a0ee03599421323a893bfd9d868aa6ed3a6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7942a0ee03599421323a893bfd9d868aa6ed3a6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7942a0ee03599421323a893bfd9d868aa6ed3a6"}], "stats": {"total": 1597, "additions": 798, "deletions": 799}, "files": [{"sha": "73da545485652e742f2dc4edceb208a45443a1bd", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -1,3 +1,50 @@\n+2012-04-02  Emmanuel Briot  <briot@adacore.com>\n+\n+\t* g-expect.adb (Expect_Internal): Fix leak of the input file descriptor.\n+\n+2012-04-02  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch4.adb (Expand_N_Quantified_Expression): Reimplemented.\n+\tThe expansion no longer uses the copy of the original QE created\n+\tduring analysis.\n+\t* sem.adb (Analyze): Add processing for loop parameter specifications.\n+\t* sem_ch4.adb (Analyze_Quantified_Expression): Reimplemented. The\n+\troutine no longer creates a copy of the original QE. All\n+\tconstituents of a QE are now preanalyzed and resolved.\n+\t* sem_ch5.adb (Analyze_Iteration_Scheme): Remove the guard which\n+\tbypasses all processing when the iteration scheme is related to a\n+\tQE. Relovate the code which analyzes loop parameter specifications\n+\tto a separate routine.\t(Analyze_Iterator_Specification):\n+\tPreanalyze the iterator name. This action was originally\n+\tdone in Analyze_Iteration_Scheme. Update the check which\n+\tdetects an iterator specification in the context of a QE.\n+\t(Analyze_Loop_Parameter_Specification): New routine. This\n+\tprocedure allows for a stand-alone analysis of a loop parameter\n+\tspecification without the need of a parent iteration scheme. Add\n+\tcode to update the type of the loop variable when the range\n+\tgenerates an itype and the context is a QE.\n+\t(Pre_Analyze_Range): Renamed to Preanalyze_Range. Update all references\n+\tto the routine.\n+\t* sem_ch5.ads: Code reformatting.\n+\t(Analyze_Loop_Parameter_Specification): New routine.\n+\t* sem_ch6.adb (Fully_Conformant_Expressions): Detect a case\n+\twhen establishing conformance between two QEs utilizing different\n+\tspecifications.\n+\t* sem_res.adb (Proper_Current_Scope): New routine.\n+\t(Resolve): Do not resolve a QE as there is nothing to be done now.\n+\tIgnore any loop scopes generated for QEs when detecting an expression\n+\tfunction as the scopes are cosmetic and do not appear in the tree.\n+\t(Resolve_Quantified_Expression): Removed. All resolution of\n+\tQE constituents is now performed during analysis. This ensures\n+\tthat loop variables appearing in array aggregates are properly\n+\tresolved.\n+\n+2012-04-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Build_Default_Subtype): If the base type is\n+\tprivate and its full view is available, use the full view in\n+\tthe subtype declaration.\n+\n 2012-04-02  Jose Ruiz  <ruiz@adacore.com>\n \n \t* gnat_ugn.texi: Add some minimal documentation about how to"}, {"sha": "d08e375c96ebba8bd4c8d9350cc190ae502bad36", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 41, "deletions": 36, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -7884,73 +7884,78 @@ package body Exp_Ch4 is\n    --  given by an iterator specification, not a loop parameter specification.\n \n    procedure Expand_N_Quantified_Expression (N : Node_Id) is\n-      Loc          : constant Source_Ptr := Sloc (N);\n-      Is_Universal : constant Boolean := All_Present (N);\n-      Actions      : constant List_Id := New_List;\n-      Tnn          : constant Entity_Id := Make_Temporary (Loc, 'T', N);\n-      Cond         : Node_Id;\n-      Decl         : Node_Id;\n-      I_Scheme     : Node_Id;\n-      Original_N   : Node_Id;\n-      Test         : Node_Id;\n+      Actions   : constant List_Id    := New_List;\n+      For_All   : constant Boolean    := All_Present (N);\n+      Iter_Spec : constant Node_Id    := Iterator_Specification (N);\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Loop_Spec : constant Node_Id    := Loop_Parameter_Specification (N);\n+      Cond      : Node_Id;\n+      Flag      : Entity_Id;\n+      Scheme    : Node_Id;\n+      Stmts     : List_Id;\n \n    begin\n-      --  Retrieve the original quantified expression (non analyzed)\n+      --  Create the declaration of the flag which tracks the status of the\n+      --  quantified expression. Generate:\n \n-      if Present (Loop_Parameter_Specification (N)) then\n-         Original_N := Parent (Parent (Loop_Parameter_Specification (N)));\n-      else\n-         Original_N := Parent (Parent (Iterator_Specification (N)));\n-      end if;\n+      --    Flag : Boolean := (True | False);\n \n-      --  Rewrite N with the original quantified expression\n+      Flag := Make_Temporary (Loc, 'T', N);\n \n-      Rewrite (N, Original_N);\n-\n-      Decl :=\n+      Append_To (Actions,\n         Make_Object_Declaration (Loc,\n-          Defining_Identifier => Tnn,\n+          Defining_Identifier => Flag,\n           Object_Definition   => New_Occurrence_Of (Standard_Boolean, Loc),\n           Expression          =>\n-            New_Occurrence_Of (Boolean_Literals (Is_Universal), Loc));\n-      Append_To (Actions, Decl);\n+            New_Occurrence_Of (Boolean_Literals (For_All), Loc)));\n+\n+      --  Construct the circuitry which tracks the status of the quantified\n+      --  expression. Generate:\n+\n+      --    if [not] Cond then\n+      --       Flag := (False | True);\n+      --       exit;\n+      --    end if;\n \n       Cond := Relocate_Node (Condition (N));\n \n-      if Is_Universal then\n+      if For_All then\n          Cond := Make_Op_Not (Loc, Cond);\n       end if;\n \n-      Test :=\n+      Stmts := New_List (\n         Make_Implicit_If_Statement (N,\n           Condition       => Cond,\n           Then_Statements => New_List (\n             Make_Assignment_Statement (Loc,\n-              Name       => New_Occurrence_Of (Tnn, Loc),\n+              Name       => New_Occurrence_Of (Flag, Loc),\n               Expression =>\n-                New_Occurrence_Of (Boolean_Literals (not Is_Universal), Loc)),\n-            Make_Exit_Statement (Loc)));\n+                New_Occurrence_Of (Boolean_Literals (not For_All), Loc)),\n+            Make_Exit_Statement (Loc))));\n \n-      if Present (Loop_Parameter_Specification (N)) then\n-         I_Scheme :=\n+      --  Build the loop equivalent of the quantified expression\n+\n+      if Present (Iter_Spec) then\n+         Scheme :=\n            Make_Iteration_Scheme (Loc,\n-              Loop_Parameter_Specification =>\n-                Loop_Parameter_Specification (N));\n+             Iterator_Specification => Iter_Spec);\n       else\n-         I_Scheme :=\n+         Scheme :=\n            Make_Iteration_Scheme (Loc,\n-             Iterator_Specification => Iterator_Specification (N));\n+             Loop_Parameter_Specification => Loop_Spec);\n       end if;\n \n       Append_To (Actions,\n         Make_Loop_Statement (Loc,\n-          Iteration_Scheme => I_Scheme,\n-          Statements       => New_List (Test),\n+          Iteration_Scheme => Scheme,\n+          Statements       => Stmts,\n           End_Label        => Empty));\n \n+      --  Transform the quantified expression\n+\n       Rewrite (N,\n         Make_Expression_With_Actions (Loc,\n-          Expression => New_Occurrence_Of (Tnn, Loc),\n+          Expression => New_Occurrence_Of (Flag, Loc),\n           Actions    => Actions));\n \n       Analyze_And_Resolve (N, Standard_Boolean);"}, {"sha": "94f69642af4f24afd969737b42f89a1882b9b74d", "filename": "gcc/ada/g-expect.adb", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fg-expect.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fg-expect.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fg-expect.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---                     Copyright (C) 2000-2011, AdaCore                     --\n+--                     Copyright (C) 2000-2012, AdaCore                     --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -33,7 +33,7 @@ with System;              use System;\n with System.OS_Constants; use System.OS_Constants;\n with Ada.Calendar;        use Ada.Calendar;\n \n-with GNAT.IO;\n+with GNAT.IO;      use GNAT.IO;\n with GNAT.OS_Lib;  use GNAT.OS_Lib;\n with GNAT.Regpat;  use GNAT.Regpat;\n \n@@ -678,6 +678,7 @@ package body GNAT.Expect is\n                            --  ??? Note that ddd tries again up to three times\n                            --  in that case. See LiterateA.C:174\n \n+                           Close (Descriptors (D).Input_Fd);\n                            Descriptors (D).Input_Fd := Invalid_FD;\n                            Result := Expect_Process_Died;\n                            return;\n@@ -893,7 +894,8 @@ package body GNAT.Expect is\n \n    begin\n       Non_Blocking_Spawn\n-        (Process, Command, Arguments, Err_To_Out => Err_To_Out);\n+        (Process, Command, Arguments, Err_To_Out => Err_To_Out,\n+         Buffer_Size => 0);\n \n       if Input'Length > 0 then\n          Send (Process, Input);\n@@ -1055,17 +1057,18 @@ package body GNAT.Expect is\n       Command_With_Path : String_Access;\n \n    begin\n-      --  Create the rest of the pipes\n-\n-      Set_Up_Communications\n-        (Descriptor, Err_To_Out, Pipe1'Access, Pipe2'Access, Pipe3'Access);\n-\n       Command_With_Path := Locate_Exec_On_Path (Command);\n \n       if Command_With_Path = null then\n          raise Invalid_Process;\n       end if;\n \n+      --  Create the rest of the pipes once we know we will be able to\n+      --  execute the process.\n+\n+      Set_Up_Communications\n+        (Descriptor, Err_To_Out, Pipe1'Access, Pipe2'Access, Pipe3'Access);\n+\n       --  Fork a new process\n \n       Descriptor.Pid := Fork;\n@@ -1365,6 +1368,8 @@ package body GNAT.Expect is\n       end if;\n \n       if Create_Pipe (Pipe2) /= 0 then\n+         Close (Pipe1.Input);\n+         Close (Pipe1.Output);\n          return;\n       end if;\n \n@@ -1389,7 +1394,7 @@ package body GNAT.Expect is\n          --  Create a separate pipe for standard error\n \n          if Create_Pipe (Pipe3) /= 0 then\n-            return;\n+            Pipe3.all := Pipe2.all;\n          end if;\n       end if;\n "}, {"sha": "503d1f40d4349dfe2a39c42339b780e4f7800457", "filename": "gcc/ada/sem.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -314,6 +314,9 @@ package body Sem is\n          when N_Label =>\n             Analyze_Label (N);\n \n+         when N_Loop_Parameter_Specification =>\n+            Analyze_Loop_Parameter_Specification (N);\n+\n          when N_Loop_Statement =>\n             Analyze_Loop_Statement (N);\n \n@@ -681,7 +684,6 @@ package body Sem is\n            N_Generic_Association                    |\n            N_Index_Or_Discriminant_Constraint       |\n            N_Iteration_Scheme                       |\n-           N_Loop_Parameter_Specification           |\n            N_Mod_Clause                             |\n            N_Modular_Type_Definition                |\n            N_Ordinary_Fixed_Point_Definition        |"}, {"sha": "55238e2ca11806566ec4fdecfa3f818f688a783e", "filename": "gcc/ada/sem_ch4.adb", "status": "modified", "additions": 18, "deletions": 82, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch4.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -47,7 +47,6 @@ with Sem_Aux;  use Sem_Aux;\n with Sem_Case; use Sem_Case;\n with Sem_Cat;  use Sem_Cat;\n with Sem_Ch3;  use Sem_Ch3;\n-with Sem_Ch5;  use Sem_Ch5;\n with Sem_Ch6;  use Sem_Ch6;\n with Sem_Ch8;  use Sem_Ch8;\n with Sem_Dim;  use Sem_Dim;\n@@ -3403,101 +3402,38 @@ package body Sem_Ch4 is\n    -----------------------------------\n \n    procedure Analyze_Quantified_Expression (N : Node_Id) is\n-      Loc : constant Source_Ptr := Sloc (N);\n-      Ent : constant Entity_Id :=\n-             New_Internal_Entity (E_Loop, Current_Scope, Sloc (N), 'L');\n-\n-      Need_Preanalysis : constant Boolean :=\n-                           Operating_Mode /= Check_Semantics\n-                             and then not Alfa_Mode;\n-\n-      Iterator   : Node_Id;\n-      Original_N : Node_Id;\n+      QE_Scop : Entity_Id;\n \n    begin\n-      --  The approach in this procedure is very non-standard and at the\n-      --  very least, extensive comments are required saying why this very\n-      --  non-standard approach is needed???\n-\n-      --  Also general comments are needed in any case saying what is going\n-      --  on here, since tree rewriting of this kind should normally be done\n-      --  by the expander and not by the analyzer ??? Probably Ent, Iterator,\n-      --  and Original_N, and Needs_Preanalysis, all need comments above ???\n-\n-      --  Preserve the original node used for the expansion of the quantified\n-      --  expression.\n-\n-      --  This is a very unusual use of Copy_Separate_Tree, needs looking at???\n-\n-      if Need_Preanalysis then\n-         Original_N := Copy_Separate_Tree (N);\n-      end if;\n-\n-      Set_Etype  (Ent, Standard_Void_Type);\n-      Set_Scope  (Ent, Current_Scope);\n-      Set_Parent (Ent, N);\n-\n       Check_SPARK_Restriction (\"quantified expression is not allowed\", N);\n \n-      --  The following seems like expansion activity done at analysis\n-      --  time, which seems weird ???\n+      --  Create a scope to emulate the loop-like behavior of the quantified\n+      --  expression. The scope is needed to provide proper visibility of the\n+      --  loop variable.\n \n-      if Present (Loop_Parameter_Specification (N)) then\n-         Iterator :=\n-           Make_Iteration_Scheme (Loc,\n-             Loop_Parameter_Specification =>\n-               Loop_Parameter_Specification (N));\n-      else\n-         Iterator :=\n-           Make_Iteration_Scheme (Loc,\n-              Iterator_Specification =>\n-                Iterator_Specification (N));\n-      end if;\n+      QE_Scop := New_Internal_Entity (E_Loop, Current_Scope, Sloc (N), 'L');\n+      Set_Etype  (QE_Scop, Standard_Void_Type);\n+      Set_Scope  (QE_Scop, Current_Scope);\n+      Set_Parent (QE_Scop, N);\n \n-      Push_Scope (Ent);\n-      Set_Parent (Iterator, N);\n-      Analyze_Iteration_Scheme (Iterator);\n+      Push_Scope (QE_Scop);\n \n-      --  The loop specification may have been converted into an iterator\n-      --  specification during its analysis. Update the quantified node\n-      --  accordingly.\n+      --  All constituents are preanalyzed and resolved to avoid untimely\n+      --  generation of various temporaries and types. Full analysis and\n+      --  expansion is carried out when the quantified expression is\n+      --  transformed into an expression with actions.\n \n-      if Present (Iterator_Specification (Iterator)) then\n-         Set_Iterator_Specification\n-           (N, Iterator_Specification (Iterator));\n-         Set_Loop_Parameter_Specification (N, Empty);\n-         Set_Parent (Iterator_Specification (Iterator), Iterator);\n-      end if;\n-\n-      if Need_Preanalysis then\n-\n-         --  The full analysis will be performed during the expansion of the\n-         --  quantified expression, only a preanalysis of the condition needs\n-         --  to be done.\n-\n-         --  This is strange for two reasons\n-\n-         --  First, there is almost no situation in which Preanalyze vs\n-         --  Analyze should be conditioned on -gnatc mode (since error msgs\n-         --  must be 100% unaffected by -gnatc). Seconed doing a Preanalyze\n-         --  with no resolution almost certainly means that some messages are\n-         --  either missed, or flagged differently in the two cases.\n-\n-         Preanalyze (Condition (N));\n+      if Present (Iterator_Specification (N)) then\n+         Preanalyze (Iterator_Specification (N));\n       else\n-         Analyze (Condition (N));\n+         Preanalyze (Loop_Parameter_Specification (N));\n       end if;\n \n+      Preanalyze_And_Resolve (Condition (N), Standard_Boolean);\n+\n       End_Scope;\n \n       Set_Etype (N, Standard_Boolean);\n-\n-      --  Attach the original node to the iteration scheme created above\n-\n-      if Need_Preanalysis then\n-         Set_Etype (Original_N, Standard_Boolean);\n-         Set_Parent (Iterator, Original_N);\n-      end if;\n    end Analyze_Quantified_Expression;\n \n    -------------------"}, {"sha": "6b45c075ae93895170062158a56aab6d830ab193", "filename": "gcc/ada/sem_ch5.adb", "status": "modified", "additions": 602, "deletions": 623, "changes": 1225, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -76,7 +76,7 @@ package body Sem_Ch5 is\n    --  messages. This variable is recursively saved on entry to processing the\n    --  construct, and restored on exit.\n \n-   procedure Pre_Analyze_Range (R_Copy : Node_Id);\n+   procedure Preanalyze_Range (R_Copy : Node_Id);\n    --  Determine expected type of range or domain of iteration of Ada 2012\n    --  loop by analyzing separate copy. Do the analysis and resolution of the\n    --  copy of the bound(s) with expansion disabled, to prevent the generation\n@@ -1607,178 +1607,284 @@ package body Sem_Ch5 is\n    ------------------------------\n \n    procedure Analyze_Iteration_Scheme (N : Node_Id) is\n+      Cond      : Node_Id;\n+      Iter_Spec : Node_Id;\n+      Loop_Spec : Node_Id;\n \n-      procedure Process_Bounds (R : Node_Id);\n-      --  If the iteration is given by a range, create temporaries and\n-      --  assignment statements block to capture the bounds and perform\n-      --  required finalization actions in case a bound includes a function\n-      --  call that uses the temporary stack. We first pre-analyze a copy of\n-      --  the range in order to determine the expected type, and analyze and\n-      --  resolve the original bounds.\n+   begin\n+      --  For an infinite loop, there is no iteration scheme\n \n-      procedure Check_Controlled_Array_Attribute (DS : Node_Id);\n-      --  If the bounds are given by a 'Range reference on a function call\n-      --  that returns a controlled array, introduce an explicit declaration\n-      --  to capture the bounds, so that the function result can be finalized\n-      --  in timely fashion.\n+      if No (N) then\n+         return;\n+      end if;\n \n-      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n-      --  N is the node for an arbitrary construct. This function searches the\n-      --  construct N to see if any expressions within it contain function\n-      --  calls that use the secondary stack, returning True if any such call\n-      --  is found, and False otherwise.\n+      Cond      := Condition (N);\n+      Iter_Spec := Iterator_Specification (N);\n+      Loop_Spec := Loop_Parameter_Specification (N);\n \n-      --------------------\n-      -- Process_Bounds --\n-      --------------------\n+      if Present (Cond) then\n+         Analyze_And_Resolve (Cond, Any_Boolean);\n+         Check_Unset_Reference (Cond);\n+         Set_Current_Value_Condition (N);\n \n-      procedure Process_Bounds (R : Node_Id) is\n-         Loc          : constant Source_Ptr := Sloc (N);\n-         R_Copy       : constant Node_Id := New_Copy_Tree (R);\n-         Lo           : constant Node_Id := Low_Bound  (R);\n-         Hi           : constant Node_Id := High_Bound (R);\n-         New_Lo_Bound : Node_Id;\n-         New_Hi_Bound : Node_Id;\n-         Typ          : Entity_Id;\n+      elsif Present (Iter_Spec) then\n+         Analyze_Iterator_Specification (Iter_Spec);\n \n-         function One_Bound\n-           (Original_Bound : Node_Id;\n-            Analyzed_Bound : Node_Id) return Node_Id;\n-         --  Capture value of bound and return captured value\n+      else\n+         Analyze_Loop_Parameter_Specification (Loop_Spec);\n+      end if;\n+   end Analyze_Iteration_Scheme;\n \n-         ---------------\n-         -- One_Bound --\n-         ---------------\n+   ------------------------------------\n+   -- Analyze_Iterator_Specification --\n+   ------------------------------------\n \n-         function One_Bound\n-           (Original_Bound : Node_Id;\n-            Analyzed_Bound : Node_Id) return Node_Id\n-         is\n-            Assign : Node_Id;\n-            Decl   : Node_Id;\n-            Id     : Entity_Id;\n+   procedure Analyze_Iterator_Specification (N : Node_Id) is\n+      Loc       : constant Source_Ptr := Sloc (N);\n+      Def_Id    : constant Node_Id    := Defining_Identifier (N);\n+      Subt      : constant Node_Id    := Subtype_Indication (N);\n+      Iter_Name : constant Node_Id    := Name (N);\n \n-         begin\n-            --  If the bound is a constant or an object, no need for a separate\n-            --  declaration. If the bound is the result of previous expansion\n-            --  it is already analyzed and should not be modified. Note that\n-            --  the Bound will be resolved later, if needed, as part of the\n-            --  call to Make_Index (literal bounds may need to be resolved to\n-            --  type Integer).\n+      Ent : Entity_Id;\n+      Typ : Entity_Id;\n \n-            if Analyzed (Original_Bound) then\n-               return Original_Bound;\n+   begin\n+      Enter_Name (Def_Id);\n+      Set_Ekind (Def_Id, E_Variable);\n \n-            elsif Nkind_In (Analyzed_Bound, N_Integer_Literal,\n-                                            N_Character_Literal)\n-              or else Is_Entity_Name (Analyzed_Bound)\n-            then\n-               Analyze_And_Resolve (Original_Bound, Typ);\n-               return Original_Bound;\n-            end if;\n+      if Present (Subt) then\n+         Analyze (Subt);\n+      end if;\n \n-            --  Normally, the best approach is simply to generate a constant\n-            --  declaration that captures the bound. However, there is a nasty\n-            --  case where this is wrong. If the bound is complex, and has a\n-            --  possible use of the secondary stack, we need to generate a\n-            --  separate assignment statement to ensure the creation of a block\n-            --  which will release the secondary stack.\n+      Preanalyze_Range (Iter_Name);\n \n-            --  We prefer the constant declaration, since it leaves us with a\n-            --  proper trace of the value, useful in optimizations that get rid\n-            --  of junk range checks.\n+      --  If the domain of iteration is an expression, create a declaration for\n+      --  it, so that finalization actions are introduced outside of the loop.\n+      --  The declaration must be a renaming because the body of the loop may\n+      --  assign to elements. When the context is a quantified expression, the\n+      --  renaming declaration is delayed until the expansion phase.\n \n-            if not Has_Call_Using_Secondary_Stack (Analyzed_Bound) then\n-               Analyze_And_Resolve (Original_Bound, Typ);\n-               Force_Evaluation (Original_Bound);\n-               return Original_Bound;\n-            end if;\n+      if not Is_Entity_Name (Iter_Name)\n+        and then (Nkind (Parent (N)) /= N_Quantified_Expression\n+                   or else Operating_Mode = Check_Semantics\n+                   or else Alfa_Mode)\n+      then\n+         declare\n+            Id   : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n+            Decl : Node_Id;\n \n-            Id := Make_Temporary (Loc, 'R', Original_Bound);\n+         begin\n+            Typ := Etype (Iter_Name);\n \n-            --  Here we make a declaration with a separate assignment\n-            --  statement, and insert before loop header.\n+            --  The name in the renaming declaration may be a function call.\n+            --  Indicate that it does not come from source, to suppress\n+            --  spurious warnings on renamings of parameterless functions,\n+            --  a common enough idiom in user-defined iterators.\n \n             Decl :=\n-              Make_Object_Declaration (Loc,\n+              Make_Object_Renaming_Declaration (Loc,\n                 Defining_Identifier => Id,\n-                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n+                Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n+                Name                =>\n+                  New_Copy_Tree (Iter_Name, New_Sloc => Loc));\n \n-            Assign :=\n-              Make_Assignment_Statement (Loc,\n-                Name        => New_Occurrence_Of (Id, Loc),\n-                Expression  => Relocate_Node (Original_Bound));\n+            Insert_Actions (Parent (Parent (N)), New_List (Decl));\n+            Rewrite (Name (N), New_Occurrence_Of (Id, Loc));\n+            Set_Etype (Id, Typ);\n+            Set_Etype (Name (N), Typ);\n+         end;\n \n-            Insert_Actions (Parent (N), New_List (Decl, Assign));\n+      --  Container is an entity or an array with uncontrolled components, or\n+      --  else it is a container iterator given by a function call, typically\n+      --  called Iterate in the case of predefined containers, even though\n+      --  Iterate is not a reserved name. What matter is that the return type\n+      --  of the function is an iterator type.\n \n-            --  Now that this temporary variable is initialized we decorate it\n-            --  as safe-to-reevaluate to inform to the backend that no further\n-            --  asignment will be issued and hence it can be handled as side\n-            --  effect free. Note that this decoration must be done when the\n-            --  assignment has been analyzed because otherwise it will be\n-            --  rejected (see Analyze_Assignment).\n+      elsif Is_Entity_Name (Iter_Name) then\n+         Analyze (Iter_Name);\n \n-            Set_Is_Safe_To_Reevaluate (Id);\n+         if Nkind (Iter_Name) = N_Function_Call then\n+            declare\n+               C  : constant Node_Id := Name (Iter_Name);\n+               I  : Interp_Index;\n+               It : Interp;\n \n-            Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n+            begin\n+               if not Is_Overloaded (Iter_Name) then\n+                  Resolve (Iter_Name, Etype (C));\n \n-            if Nkind (Assign) = N_Assignment_Statement then\n-               return Expression (Assign);\n-            else\n-               return Original_Bound;\n+               else\n+                  Get_First_Interp (C, I, It);\n+                  while It.Typ /= Empty loop\n+                     if Reverse_Present (N) then\n+                        if Is_Reversible_Iterator (It.Typ) then\n+                           Resolve (Iter_Name, It.Typ);\n+                           exit;\n+                        end if;\n+\n+                     elsif Is_Iterator (It.Typ) then\n+                        Resolve (Iter_Name, It.Typ);\n+                        exit;\n+                     end if;\n+\n+                     Get_Next_Interp (I, It);\n+                  end loop;\n+               end if;\n+            end;\n+\n+         --  Domain of iteration is not overloaded\n+\n+         else\n+            Resolve (Iter_Name, Etype (Iter_Name));\n+         end if;\n+      end if;\n+\n+      Typ := Etype (Iter_Name);\n+\n+      if Is_Array_Type (Typ) then\n+         if Of_Present (N) then\n+            Set_Etype (Def_Id, Component_Type (Typ));\n+\n+         --  Here we have a missing Range attribute\n+\n+         else\n+            Error_Msg_N\n+              (\"missing Range attribute in iteration over an array\", N);\n+\n+            --  In Ada 2012 mode, this may be an attempt at an iterator\n+\n+            if Ada_Version >= Ada_2012 then\n+               Error_Msg_NE\n+                 (\"\\if& is meant to designate an element of the array, use OF\",\n+                    N, Def_Id);\n             end if;\n-         end One_Bound;\n \n-      --  Start of processing for Process_Bounds\n+            --  Prevent cascaded errors\n \n-      begin\n-         Set_Parent (R_Copy, Parent (R));\n-         Pre_Analyze_Range (R_Copy);\n-         Typ := Etype (R_Copy);\n+            Set_Ekind (Def_Id, E_Loop_Parameter);\n+            Set_Etype (Def_Id, Etype (First_Index (Typ)));\n+         end if;\n \n-         --  If the type of the discrete range is Universal_Integer, then the\n-         --  bound's type must be resolved to Integer, and any object used to\n-         --  hold the bound must also have type Integer, unless the literal\n-         --  bounds are constant-folded expressions with a user-defined type.\n+         --  Check for type error in iterator\n \n-         if Typ = Universal_Integer then\n-            if Nkind (Lo) = N_Integer_Literal\n-              and then Present (Etype (Lo))\n-              and then Scope (Etype (Lo)) /= Standard_Standard\n-            then\n-               Typ := Etype (Lo);\n+      elsif Typ = Any_Type then\n+         return;\n \n-            elsif Nkind (Hi) = N_Integer_Literal\n-              and then Present (Etype (Hi))\n-              and then Scope (Etype (Hi)) /= Standard_Standard\n+      --  Iteration over a container\n+\n+      else\n+         Set_Ekind (Def_Id, E_Loop_Parameter);\n+\n+         if Of_Present (N) then\n+\n+            --  The type of the loop variable is the Iterator_Element aspect of\n+            --  the container type.\n+\n+            declare\n+               Element : constant Entity_Id :=\n+                           Find_Aspect (Typ, Aspect_Iterator_Element);\n+            begin\n+               if No (Element) then\n+                  Error_Msg_NE (\"cannot iterate over&\", N, Typ);\n+                  return;\n+               else\n+                  Set_Etype (Def_Id, Entity (Element));\n+               end if;\n+            end;\n+\n+         else\n+            --  For an iteration of the form IN, the name must denote an\n+            --  iterator, typically the result of a call to Iterate. Give a\n+            --  useful error message when the name is a container by itself.\n+\n+            if Is_Entity_Name (Original_Node (Name (N)))\n+              and then not Is_Iterator (Typ)\n             then\n-               Typ := Etype (Hi);\n+               if No (Find_Aspect (Typ, Aspect_Iterator_Element)) then\n+                  Error_Msg_NE\n+                    (\"cannot iterate over&\", Name (N), Typ);\n+               else\n+                  Error_Msg_N\n+                    (\"name must be an iterator, not a container\", Name (N));\n+               end if;\n \n-            else\n-               Typ := Standard_Integer;\n+               Error_Msg_NE\n+                 (\"\\to iterate directly over the elements of a container, \" &\n+                   \"write `of &`\", Name (N), Original_Node (Name (N)));\n             end if;\n+\n+            --  The result type of Iterate function is the classwide type of\n+            --  the interface parent. We need the specific Cursor type defined\n+            --  in the container package.\n+\n+            Ent := First_Entity (Scope (Typ));\n+            while Present (Ent) loop\n+               if Chars (Ent) = Name_Cursor then\n+                  Set_Etype (Def_Id, Etype (Ent));\n+                  exit;\n+               end if;\n+\n+               Next_Entity (Ent);\n+            end loop;\n          end if;\n+      end if;\n+   end Analyze_Iterator_Specification;\n \n-         Set_Etype (R, Typ);\n+   -------------------\n+   -- Analyze_Label --\n+   -------------------\n+\n+   --  Note: the semantic work required for analyzing labels (setting them as\n+   --  reachable) was done in a prepass through the statements in the block,\n+   --  so that forward gotos would be properly handled. See Analyze_Statements\n+   --  for further details. The only processing required here is to deal with\n+   --  optimizations that depend on an assumption of sequential control flow,\n+   --  since of course the occurrence of a label breaks this assumption.\n \n-         New_Lo_Bound := One_Bound (Lo, Low_Bound  (R_Copy));\n-         New_Hi_Bound := One_Bound (Hi, High_Bound (R_Copy));\n+   procedure Analyze_Label (N : Node_Id) is\n+      pragma Warnings (Off, N);\n+   begin\n+      Kill_Current_Values;\n+   end Analyze_Label;\n \n-         --  Propagate staticness to loop range itself, in case the\n-         --  corresponding subtype is static.\n+   --------------------------\n+   -- Analyze_Label_Entity --\n+   --------------------------\n \n-         if New_Lo_Bound /= Lo\n-           and then Is_Static_Expression (New_Lo_Bound)\n-         then\n-            Rewrite (Low_Bound (R), New_Copy (New_Lo_Bound));\n-         end if;\n+   procedure Analyze_Label_Entity (E : Entity_Id) is\n+   begin\n+      Set_Ekind           (E, E_Label);\n+      Set_Etype           (E, Standard_Void_Type);\n+      Set_Enclosing_Scope (E, Current_Scope);\n+      Set_Reachable       (E, True);\n+   end Analyze_Label_Entity;\n \n-         if New_Hi_Bound /= Hi\n-           and then Is_Static_Expression (New_Hi_Bound)\n-         then\n-            Rewrite (High_Bound (R), New_Copy (New_Hi_Bound));\n-         end if;\n-      end Process_Bounds;\n+   ------------------------------------------\n+   -- Analyze_Loop_Parameter_Specification --\n+   ------------------------------------------\n+\n+   procedure Analyze_Loop_Parameter_Specification (N : Node_Id) is\n+      Loop_Nod : constant Node_Id := Parent (Parent (N));\n+\n+      procedure Check_Controlled_Array_Attribute (DS : Node_Id);\n+      --  If the bounds are given by a 'Range reference on a function call\n+      --  that returns a controlled array, introduce an explicit declaration\n+      --  to capture the bounds, so that the function result can be finalized\n+      --  in timely fashion.\n+\n+      function Has_Call_Using_Secondary_Stack (N : Node_Id) return Boolean;\n+      --  N is the node for an arbitrary construct. This function searches the\n+      --  construct N to see if any expressions within it contain function\n+      --  calls that use the secondary stack, returning True if any such call\n+      --  is found, and False otherwise.\n+\n+      procedure Process_Bounds (R : Node_Id);\n+      --  If the iteration is given by a range, create temporaries and\n+      --  assignment statements block to capture the bounds and perform\n+      --  required finalization actions in case a bound includes a function\n+      --  call that uses the temporary stack. We first pre-analyze a copy of\n+      --  the range in order to determine the expected type, and analyze and\n+      --  resolve the original bounds.\n \n       --------------------------------------\n       -- Check_Controlled_Array_Attribute --\n@@ -1787,13 +1893,12 @@ package body Sem_Ch5 is\n       procedure Check_Controlled_Array_Attribute (DS : Node_Id) is\n       begin\n          if Nkind (DS) = N_Attribute_Reference\n-            and then Is_Entity_Name (Prefix (DS))\n-            and then Ekind (Entity (Prefix (DS))) = E_Function\n-            and then Is_Array_Type (Etype (Entity (Prefix (DS))))\n-            and then\n-              Is_Controlled (\n-                Component_Type (Etype (Entity (Prefix (DS)))))\n-            and then Expander_Active\n+           and then Is_Entity_Name (Prefix (DS))\n+           and then Ekind (Entity (Prefix (DS))) = E_Function\n+           and then Is_Array_Type (Etype (Entity (Prefix (DS))))\n+           and then\n+             Is_Controlled (Component_Type (Etype (Entity (Prefix (DS)))))\n+           and then Expander_Active\n          then\n             declare\n                Loc  : constant Source_Ptr := Sloc (N);\n@@ -1809,17 +1914,17 @@ package body Sem_Ch5 is\n                    Defining_Identifier => Subt,\n                    Subtype_Indication  =>\n                       Make_Subtype_Indication (Loc,\n-                        Subtype_Mark  => New_Reference_To (Indx, Loc),\n-                        Constraint =>\n-                          Make_Range_Constraint (Loc,\n-                            Relocate_Node (DS))));\n-               Insert_Before (Parent (N), Decl);\n+                        Subtype_Mark => New_Reference_To (Indx, Loc),\n+                        Constraint   =>\n+                          Make_Range_Constraint (Loc, Relocate_Node (DS))));\n+               Insert_Before (Loop_Nod, Decl);\n                Analyze (Decl);\n \n                Rewrite (DS,\n-                  Make_Attribute_Reference (Loc,\n-                    Prefix => New_Reference_To (Subt, Loc),\n-                    Attribute_Name => Attribute_Name (DS)));\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix         => New_Reference_To (Subt, Loc),\n+                   Attribute_Name => Attribute_Name (DS)));\n+\n                Analyze (DS);\n             end;\n          end if;\n@@ -1889,561 +1994,435 @@ package body Sem_Ch5 is\n          return Check_Calls (N) = Abandon;\n       end Has_Call_Using_Secondary_Stack;\n \n-   --  Start of processing for Analyze_Iteration_Scheme\n-\n-   begin\n-      --  If this is a rewritten quantified expression, the iteration scheme\n-      --  has been analyzed already. Do no repeat analysis because the loop\n-      --  variable is already declared.\n-\n-      if Analyzed (N) then\n-         return;\n-      end if;\n-\n-      --  For an infinite loop, there is no iteration scheme\n-\n-      if No (N) then\n-         return;\n-      end if;\n-\n-      --  Iteration scheme is present\n-\n-      declare\n-         Cond : constant Node_Id := Condition (N);\n-\n-      begin\n-         --  For WHILE loop, verify that the condition is a Boolean expression\n-         --  and resolve and check it.\n-\n-         if Present (Cond) then\n-            Analyze_And_Resolve (Cond, Any_Boolean);\n-            Check_Unset_Reference (Cond);\n-            Set_Current_Value_Condition (N);\n-            return;\n-\n-         --  For an iterator specification with \"of\", pre-analyze range to\n-         --  capture function calls that may require finalization actions.\n-\n-         elsif Present (Iterator_Specification (N)) then\n-            Pre_Analyze_Range (Name (Iterator_Specification (N)));\n-            Analyze_Iterator_Specification (Iterator_Specification (N));\n-\n-         --  Else we have a FOR loop\n-\n-         else\n-            declare\n-               LP : constant Node_Id   := Loop_Parameter_Specification (N);\n-               Id : constant Entity_Id := Defining_Identifier (LP);\n-               DS : constant Node_Id   := Discrete_Subtype_Definition (LP);\n-\n-               D_Copy : Node_Id;\n-\n-            begin\n-               Enter_Name (Id);\n-\n-               --  We always consider the loop variable to be referenced, since\n-               --  the loop may be used just for counting purposes.\n-\n-               Generate_Reference (Id, N, ' ');\n-\n-               --  Check for the case of loop variable hiding a local variable\n-               --  (used later on to give a nice warning if the hidden variable\n-               --  is never assigned).\n-\n-               declare\n-                  H : constant Entity_Id := Homonym (Id);\n-               begin\n-                  if Present (H)\n-                    and then Enclosing_Dynamic_Scope (H) =\n-                               Enclosing_Dynamic_Scope (Id)\n-                    and then Ekind (H) = E_Variable\n-                    and then Is_Discrete_Type (Etype (H))\n-                  then\n-                     Set_Hiding_Loop_Variable (H, Id);\n-                  end if;\n-               end;\n-\n-               --  Loop parameter specification must include subtype mark in\n-               --  SPARK.\n-\n-               if Nkind (DS) = N_Range then\n-                  Check_SPARK_Restriction\n-                    (\"loop parameter specification must include subtype mark\",\n-                     N);\n-               end if;\n-\n-               --  Analyze the subtype definition and create temporaries for\n-               --  the bounds. Do not evaluate the range when preanalyzing a\n-               --  quantified expression because bounds expressed as function\n-               --  calls with side effects will be erroneously replicated.\n-\n-               if Nkind (DS) = N_Range\n-                 and then Expander_Active\n-                 and then Nkind (Parent (N)) /= N_Quantified_Expression\n-               then\n-                  Process_Bounds (DS);\n-\n-               --  Expander not active or else range of iteration is a subtype\n-               --  indication, an entity, or a function call that yields an\n-               --  aggregate or a container.\n-\n-               else\n-                  D_Copy := New_Copy_Tree (DS);\n-                  Set_Parent (D_Copy, Parent (DS));\n-                  Pre_Analyze_Range (D_Copy);\n-\n-                  --  Ada 2012: If the domain of iteration is a function call,\n-                  --  it is the new iterator form.\n+      --------------------\n+      -- Process_Bounds --\n+      --------------------\n \n-                  --  We have also implemented the shorter form : for X in S\n-                  --  for Alfa use. In this case, 'Old and 'Result must be\n-                  --  treated as entity names over which iterators are legal.\n+      procedure Process_Bounds (R : Node_Id) is\n+         Loc : constant Source_Ptr := Sloc (N);\n \n-                  if Nkind (D_Copy) = N_Function_Call\n-                    or else\n-                      (Alfa_Mode\n-                        and then (Nkind (D_Copy) = N_Attribute_Reference\n-                        and then\n-                          (Attribute_Name (D_Copy) = Name_Result\n-                            or else Attribute_Name (D_Copy) = Name_Old)))\n-                    or else\n-                      (Is_Entity_Name (D_Copy)\n-                        and then not Is_Type (Entity (D_Copy)))\n-                  then\n-                     --  This is an iterator specification. Rewrite as such\n-                     --  and analyze, to capture function calls that may\n-                     --  require finalization actions.\n-\n-                     declare\n-                        I_Spec : constant Node_Id :=\n-                                   Make_Iterator_Specification (Sloc (LP),\n-                                     Defining_Identifier =>\n-                                       Relocate_Node (Id),\n-                                     Name                => D_Copy,\n-                                     Subtype_Indication  => Empty,\n-                                     Reverse_Present     =>\n-                                       Reverse_Present (LP));\n-                     begin\n-                        Set_Iterator_Specification (N, I_Spec);\n-                        Set_Loop_Parameter_Specification (N, Empty);\n-                        Analyze_Iterator_Specification (I_Spec);\n-\n-                        --  In a generic context, analyze the original domain\n-                        --  of iteration, for name capture.\n-\n-                        if not Expander_Active then\n-                           Analyze (DS);\n-                        end if;\n+         function One_Bound\n+           (Original_Bound : Node_Id;\n+            Analyzed_Bound : Node_Id;\n+            Typ            : Entity_Id) return Node_Id;\n+         --  Capture value of bound and return captured value\n \n-                        --  Set kind of loop parameter, which may be used in\n-                        --  the subsequent analysis of the condition in a\n-                        --  quantified expression.\n+         ---------------\n+         -- One_Bound --\n+         ---------------\n \n-                        Set_Ekind (Id, E_Loop_Parameter);\n-                        return;\n-                     end;\n+         function One_Bound\n+           (Original_Bound : Node_Id;\n+            Analyzed_Bound : Node_Id;\n+            Typ            : Entity_Id) return Node_Id\n+         is\n+            Assign : Node_Id;\n+            Decl   : Node_Id;\n+            Id     : Entity_Id;\n \n-                  --  Domain of iteration is not a function call, and is\n-                  --  side-effect free.\n+         begin\n+            --  If the bound is a constant or an object, no need for a separate\n+            --  declaration. If the bound is the result of previous expansion\n+            --  it is already analyzed and should not be modified. Note that\n+            --  the Bound will be resolved later, if needed, as part of the\n+            --  call to Make_Index (literal bounds may need to be resolved to\n+            --  type Integer).\n \n-                  else\n-                     Analyze (DS);\n-                  end if;\n-               end if;\n+            if Analyzed (Original_Bound) then\n+               return Original_Bound;\n \n-               if DS = Error then\n-                  return;\n-               end if;\n+            elsif Nkind_In (Analyzed_Bound, N_Integer_Literal,\n+                                            N_Character_Literal)\n+              or else Is_Entity_Name (Analyzed_Bound)\n+            then\n+               Analyze_And_Resolve (Original_Bound, Typ);\n+               return Original_Bound;\n+            end if;\n \n-               --  Some additional checks if we are iterating through a type\n+            --  Normally, the best approach is simply to generate a constant\n+            --  declaration that captures the bound. However, there is a nasty\n+            --  case where this is wrong. If the bound is complex, and has a\n+            --  possible use of the secondary stack, we need to generate a\n+            --  separate assignment statement to ensure the creation of a block\n+            --  which will release the secondary stack.\n \n-               if Is_Entity_Name (DS)\n-                 and then Present (Entity (DS))\n-                 and then Is_Type (Entity (DS))\n-               then\n-                  --  The subtype indication may denote the completion of an\n-                  --  incomplete type declaration.\n+            --  We prefer the constant declaration, since it leaves us with a\n+            --  proper trace of the value, useful in optimizations that get rid\n+            --  of junk range checks.\n \n-                  if Ekind (Entity (DS)) = E_Incomplete_Type then\n-                     Set_Entity (DS, Get_Full_View (Entity (DS)));\n-                     Set_Etype  (DS, Entity (DS));\n-                  end if;\n+            if not Has_Call_Using_Secondary_Stack (Analyzed_Bound) then\n+               Analyze_And_Resolve (Original_Bound, Typ);\n+               Force_Evaluation (Original_Bound);\n+               return Original_Bound;\n+            end if;\n \n-                  --  Attempt to iterate through non-static predicate\n+            Id := Make_Temporary (Loc, 'R', Original_Bound);\n \n-                  if Is_Discrete_Type (Entity (DS))\n-                    and then Present (Predicate_Function (Entity (DS)))\n-                    and then No (Static_Predicate (Entity (DS)))\n-                  then\n-                     Bad_Predicated_Subtype_Use\n-                       (\"cannot use subtype& with non-static \"\n-                        & \"predicate for loop iteration\", DS, Entity (DS));\n-                  end if;\n-               end if;\n+            --  Here we make a declaration with a separate assignment\n+            --  statement, and insert before loop header.\n \n-               --  Error if not discrete type\n+            Decl :=\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Id,\n+                Object_Definition   => New_Occurrence_Of (Typ, Loc));\n \n-               if not Is_Discrete_Type (Etype (DS)) then\n-                  Wrong_Type (DS, Any_Discrete);\n-                  Set_Etype (DS, Any_Type);\n-               end if;\n+            Assign :=\n+              Make_Assignment_Statement (Loc,\n+                Name        => New_Occurrence_Of (Id, Loc),\n+                Expression  => Relocate_Node (Original_Bound));\n \n-               Check_Controlled_Array_Attribute (DS);\n+            Insert_Actions (Loop_Nod, New_List (Decl, Assign));\n \n-               --  The index is not processed during analysis of a quantified\n-               --  expression but delayed to its expansion where the quantified\n-               --  expression is transformed into an expression with actions.\n+            --  Now that this temporary variable is initialized we decorate it\n+            --  as safe-to-reevaluate to inform to the backend that no further\n+            --  asignment will be issued and hence it can be handled as side\n+            --  effect free. Note that this decoration must be done when the\n+            --  assignment has been analyzed because otherwise it will be\n+            --  rejected (see Analyze_Assignment).\n \n-               if Nkind (Parent (N)) /= N_Quantified_Expression\n-                 or else Operating_Mode = Check_Semantics\n-                 or else Alfa_Mode\n-               then\n-                  Make_Index (DS, LP, In_Iter_Schm => True);\n-               end if;\n+            Set_Is_Safe_To_Reevaluate (Id);\n \n-               Set_Ekind (Id, E_Loop_Parameter);\n+            Rewrite (Original_Bound, New_Occurrence_Of (Id, Loc));\n \n-               --  If the loop is part of a predicate or precondition, it may\n-               --  be analyzed twice, once in the source and once on the copy\n-               --  used to check conformance. Preserve the original itype\n-               --  because the second one may be created in a different scope,\n-               --  e.g. a precondition procedure, leading to a crash in GIGI.\n+            if Nkind (Assign) = N_Assignment_Statement then\n+               return Expression (Assign);\n+            else\n+               return Original_Bound;\n+            end if;\n+         end One_Bound;\n \n-               if No (Etype (Id)) or else Etype (Id) = Any_Type then\n-                  Set_Etype (Id, Etype (DS));\n-               end if;\n+         Hi     : constant Node_Id := High_Bound (R);\n+         Lo     : constant Node_Id := Low_Bound  (R);\n+         R_Copy : constant Node_Id := New_Copy_Tree (R);\n+         New_Hi : Node_Id;\n+         New_Lo : Node_Id;\n+         Typ    : Entity_Id;\n \n-               --  Treat a range as an implicit reference to the type, to\n-               --  inhibit spurious warnings.\n+      --  Start of processing for Process_Bounds\n \n-               Generate_Reference (Base_Type (Etype (DS)), N, ' ');\n-               Set_Is_Known_Valid (Id, True);\n+      begin\n+         Set_Parent (R_Copy, Parent (R));\n+         Preanalyze_Range (R_Copy);\n+         Typ := Etype (R_Copy);\n \n-               --  The loop is not a declarative part, so the only entity\n-               --  declared \"within\" must be frozen explicitly.\n+         --  If the type of the discrete range is Universal_Integer, then the\n+         --  bound's type must be resolved to Integer, and any object used to\n+         --  hold the bound must also have type Integer, unless the literal\n+         --  bounds are constant-folded expressions with a user-defined type.\n \n-               declare\n-                  Flist : constant List_Id := Freeze_Entity (Id, N);\n-               begin\n-                  if Is_Non_Empty_List (Flist) then\n-                     Insert_Actions (N, Flist);\n-                  end if;\n-               end;\n-\n-               --  Check for null or possibly null range and issue warning. We\n-               --  suppress such messages in generic templates and instances,\n-               --  because in practice they tend to be dubious in these cases.\n-\n-               if Nkind (DS) = N_Range and then Comes_From_Source (N) then\n-                  declare\n-                     L : constant Node_Id := Low_Bound  (DS);\n-                     H : constant Node_Id := High_Bound (DS);\n-\n-                  begin\n-                     --  If range of loop is null, issue warning\n-\n-                     if Compile_Time_Compare\n-                          (L, H, Assume_Valid => True) = GT\n-                     then\n-                        --  Suppress the warning if inside a generic template\n-                        --  or instance, since in practice they tend to be\n-                        --  dubious in these cases since they can result from\n-                        --  intended parametrization.\n-\n-                        if not Inside_A_Generic\n-                          and then not In_Instance\n-                        then\n-                           --  Specialize msg if invalid values could make the\n-                           --  loop non-null after all.\n-\n-                           if Compile_Time_Compare\n-                                (L, H, Assume_Valid => False) = GT\n-                           then\n-                              Error_Msg_N\n-                                (\"?loop range is null, loop will not execute\",\n-                                 DS);\n-\n-                              --  Since we know the range of the loop is null,\n-                              --  set the appropriate flag to remove the loop\n-                              --  entirely during expansion.\n-\n-                              Set_Is_Null_Loop (Parent (N));\n-\n-                              --  Here is where the loop could execute because\n-                              --  of invalid values, so issue appropriate\n-                              --  message and in this case we do not set the\n-                              --  Is_Null_Loop flag since the loop may execute.\n-\n-                           else\n-                              Error_Msg_N\n-                                (\"?loop range may be null, \"\n-                                 & \"loop may not execute\",\n-                                 DS);\n-                              Error_Msg_N\n-                                (\"?can only execute if invalid values \"\n-                                 & \"are present\",\n-                                 DS);\n-                           end if;\n-                        end if;\n+         if Typ = Universal_Integer then\n+            if Nkind (Lo) = N_Integer_Literal\n+              and then Present (Etype (Lo))\n+              and then Scope (Etype (Lo)) /= Standard_Standard\n+            then\n+               Typ := Etype (Lo);\n \n-                        --  In either case, suppress warnings in the body of\n-                        --  the loop, since it is likely that these warnings\n-                        --  will be inappropriate if the loop never actually\n-                        --  executes, which is likely.\n+            elsif Nkind (Hi) = N_Integer_Literal\n+              and then Present (Etype (Hi))\n+              and then Scope (Etype (Hi)) /= Standard_Standard\n+            then\n+               Typ := Etype (Hi);\n \n-                        Set_Suppress_Loop_Warnings (Parent (N));\n+            else\n+               Typ := Standard_Integer;\n+            end if;\n+         end if;\n \n-                        --  The other case for a warning is a reverse loop\n-                        --  where the upper bound is the integer literal zero\n-                        --  or one, and the lower bound can be positive.\n+         Set_Etype (R, Typ);\n \n-                        --  For example, we have\n+         New_Lo := One_Bound (Lo, Low_Bound  (R_Copy), Typ);\n+         New_Hi := One_Bound (Hi, High_Bound (R_Copy), Typ);\n \n-                        --     for J in reverse N .. 1 loop\n+         --  Propagate staticness to loop range itself, in case the\n+         --  corresponding subtype is static.\n \n-                        --  In practice, this is very likely to be a case of\n-                        --  reversing the bounds incorrectly in the range.\n+         if New_Lo /= Lo\n+           and then Is_Static_Expression (New_Lo)\n+         then\n+            Rewrite (Low_Bound (R), New_Copy (New_Lo));\n+         end if;\n \n-                     elsif Reverse_Present (LP)\n-                       and then Nkind (Original_Node (H)) =\n-                                                      N_Integer_Literal\n-                       and then (Intval (Original_Node (H)) = Uint_0\n-                                  or else\n-                                    Intval (Original_Node (H)) = Uint_1)\n-                     then\n-                        Error_Msg_N (\"?loop range may be null\", DS);\n-                        Error_Msg_N (\"\\?bounds may be wrong way round\", DS);\n-                     end if;\n-                  end;\n-               end if;\n-            end;\n+         if New_Hi /= Hi\n+           and then Is_Static_Expression (New_Hi)\n+         then\n+            Rewrite (High_Bound (R), New_Copy (New_Hi));\n          end if;\n-      end;\n-   end Analyze_Iteration_Scheme;\n+      end Process_Bounds;\n \n-   ------------------------------------\n-   -- Analyze_Iterator_Specification --\n-   ------------------------------------\n+      --  Local variables\n \n-   procedure Analyze_Iterator_Specification (N : Node_Id) is\n-      Loc       : constant Source_Ptr := Sloc (N);\n-      Def_Id    : constant Node_Id    := Defining_Identifier (N);\n-      Subt      : constant Node_Id    := Subtype_Indication (N);\n-      Iter_Name : constant Node_Id    := Name (N);\n+      DS : constant Node_Id   := Discrete_Subtype_Definition (N);\n+      Id : constant Entity_Id := Defining_Identifier (N);\n \n-      Ent : Entity_Id;\n-      Typ : Entity_Id;\n+      DS_Copy : Node_Id;\n+\n+   --  Start of processing for Analyze_Loop_Parameter_Specification\n \n    begin\n-      Enter_Name (Def_Id);\n+      Enter_Name (Id);\n \n-      Set_Ekind (Def_Id, E_Variable);\n+      --  We always consider the loop variable to be referenced, since the loop\n+      --  may be used just for counting purposes.\n \n-      if Present (Subt) then\n-         Analyze (Subt);\n-      end if;\n+      Generate_Reference (Id, N, ' ');\n \n-      --  If domain of iteration is an expression, create a declaration for\n-      --  it, so that finalization actions are introduced outside of the loop.\n-      --  The declaration must be a renaming because the body of the loop may\n-      --  assign to elements. In case of a quantified expression, this\n-      --  declaration is delayed to its expansion where the node is rewritten\n-      --  as an expression with actions.\n+      --  Check for the case of loop variable hiding a local variable (used\n+      --  later on to give a nice warning if the hidden variable is never\n+      --  assigned).\n \n-      if not Is_Entity_Name (Iter_Name)\n-        and then (Nkind (Parent (Parent (N))) /= N_Quantified_Expression\n-                   or else Operating_Mode = Check_Semantics\n-                   or else Alfa_Mode)\n-      then\n-         declare\n-            Id   : constant Entity_Id := Make_Temporary (Loc, 'R', Iter_Name);\n-            Decl : Node_Id;\n+      declare\n+         H : constant Entity_Id := Homonym (Id);\n+      begin\n+         if Present (H)\n+           and then Ekind (H) = E_Variable\n+           and then Is_Discrete_Type (Etype (H))\n+           and then Enclosing_Dynamic_Scope (H) = Enclosing_Dynamic_Scope (Id)\n+         then\n+            Set_Hiding_Loop_Variable (H, Id);\n+         end if;\n+      end;\n \n-         begin\n-            Typ := Etype (Iter_Name);\n+      --  Loop parameter specification must include subtype mark in SPARK\n \n-            --  The name in the renaming declaration may be a function call.\n-            --  Indicate that it does not come from source, to suppress\n-            --  spurious warnings on renamings of parameterless functions,\n-            --  a common enough idiom in user-defined iterators.\n+      if Nkind (DS) = N_Range then\n+         Check_SPARK_Restriction\n+           (\"loop parameter specification must include subtype mark\", N);\n+      end if;\n \n-            Decl :=\n-              Make_Object_Renaming_Declaration (Loc,\n-                Defining_Identifier => Id,\n-                Subtype_Mark        => New_Occurrence_Of (Typ, Loc),\n-                Name                =>\n-                  New_Copy_Tree (Iter_Name, New_Sloc => Loc));\n+      --  Analyze the subtype definition and create temporaries for the bounds.\n+      --  Do not evaluate the range when preanalyzing a quantified expression\n+      --  because bounds expressed as function calls with side effects will be\n+      --  erroneously replicated.\n \n-            Insert_Actions (Parent (Parent (N)), New_List (Decl));\n-            Rewrite (Name (N), New_Occurrence_Of (Id, Loc));\n-            Set_Etype (Id, Typ);\n-            Set_Etype (Name (N), Typ);\n-         end;\n+      if Nkind (DS) = N_Range\n+        and then Expander_Active\n+        and then Nkind (Parent (N)) /= N_Quantified_Expression\n+      then\n+         Process_Bounds (DS);\n \n-      --  Container is an entity or an array with uncontrolled components, or\n-      --  else it is a container iterator given by a function call, typically\n-      --  called Iterate in the case of predefined containers, even though\n-      --  Iterate is not a reserved name. What matter is that the return type\n-      --  of the function is an iterator type.\n+      --  Either the expander not active or the range of iteration is a subtype\n+      --  indication, an entity, or a function call that yields an aggregate or\n+      --  a container.\n \n-      elsif Is_Entity_Name (Iter_Name) then\n-         Analyze (Iter_Name);\n+      else\n+         DS_Copy := New_Copy_Tree (DS);\n+         Set_Parent (DS_Copy, Parent (DS));\n+         Preanalyze_Range (DS_Copy);\n+\n+         --  Ada 2012: If the domain of iteration is a function call, it is the\n+         --  new iterator form.\n+\n+         --  We have also implemented the shorter form : for X in S for Alfa\n+         --  use. In this case, 'Old and 'Result must be treated as entity\n+         --  names over which iterators are legal.\n+\n+         if Nkind (DS_Copy) = N_Function_Call\n+           or else\n+             (Alfa_Mode\n+               and then (Nkind (DS_Copy) = N_Attribute_Reference\n+               and then\n+                 (Attribute_Name (DS_Copy) = Name_Result\n+                   or else Attribute_Name (DS_Copy) = Name_Old)))\n+           or else\n+             (Is_Entity_Name (DS_Copy)\n+               and then not Is_Type (Entity (DS_Copy)))\n+         then\n+            --  This is an iterator specification. Rewrite it as such and\n+            --  analyze it to capture function calls that may require\n+            --  finalization actions.\n \n-         if Nkind (Iter_Name) = N_Function_Call then\n             declare\n-               C  : constant Node_Id := Name (Iter_Name);\n-               I  : Interp_Index;\n-               It : Interp;\n+               I_Spec : constant Node_Id :=\n+                          Make_Iterator_Specification (Sloc (N),\n+                            Defining_Identifier => Relocate_Node (Id),\n+                            Name                => DS_Copy,\n+                            Subtype_Indication  => Empty,\n+                            Reverse_Present     => Reverse_Present (N));\n+               Scheme : constant Node_Id := Parent (N);\n \n             begin\n-               if not Is_Overloaded (Iter_Name) then\n-                  Resolve (Iter_Name, Etype (C));\n-\n-               else\n-                  Get_First_Interp (C, I, It);\n-                  while It.Typ /= Empty loop\n-                     if Reverse_Present (N) then\n-                        if Is_Reversible_Iterator (It.Typ) then\n-                           Resolve (Iter_Name, It.Typ);\n-                           exit;\n-                        end if;\n+               Set_Iterator_Specification (Scheme, I_Spec);\n+               Set_Loop_Parameter_Specification (Scheme, Empty);\n+               Analyze_Iterator_Specification (I_Spec);\n \n-                     elsif Is_Iterator (It.Typ) then\n-                        Resolve (Iter_Name, It.Typ);\n-                        exit;\n-                     end if;\n+               --  In a generic context, analyze the original domain of\n+               --  iteration, for name capture.\n \n-                     Get_Next_Interp (I, It);\n-                  end loop;\n+               if not Expander_Active then\n+                  Analyze (DS);\n                end if;\n+\n+               --  Set kind of loop parameter, which may be used in the\n+               --  subsequent analysis of the condition in a quantified\n+               --  expression.\n+\n+               Set_Ekind (Id, E_Loop_Parameter);\n+               return;\n             end;\n \n-         --  Domain of iteration is not overloaded\n+         --  Domain of iteration is not a function call, and is side-effect\n+         --  free.\n \n          else\n-            Resolve (Iter_Name, Etype (Iter_Name));\n+            Analyze (DS);\n          end if;\n       end if;\n \n-      Typ := Etype (Iter_Name);\n+      if DS = Error then\n+         return;\n+      end if;\n \n-      if Is_Array_Type (Typ) then\n-         if Of_Present (N) then\n-            Set_Etype (Def_Id, Component_Type (Typ));\n+      --  Some additional checks if we are iterating through a type\n \n-         --  Here we have a missing Range attribute\n+      if Is_Entity_Name (DS)\n+        and then Present (Entity (DS))\n+        and then Is_Type (Entity (DS))\n+      then\n+         --  The subtype indication may denote the completion of an incomplete\n+         --  type declaration.\n \n-         else\n-            Error_Msg_N\n-              (\"missing Range attribute in iteration over an array\", N);\n+         if Ekind (Entity (DS)) = E_Incomplete_Type then\n+            Set_Entity (DS, Get_Full_View (Entity (DS)));\n+            Set_Etype  (DS, Entity (DS));\n+         end if;\n \n-            --  In Ada 2012 mode, this may be an attempt at an iterator\n+         --  Attempt to iterate through non-static predicate\n \n-            if Ada_Version >= Ada_2012 then\n-               Error_Msg_NE\n-                 (\"\\if& is meant to designate an element of the array, use OF\",\n-                    N, Def_Id);\n-            end if;\n+         if Is_Discrete_Type (Entity (DS))\n+           and then Present (Predicate_Function (Entity (DS)))\n+           and then No (Static_Predicate (Entity (DS)))\n+         then\n+            Bad_Predicated_Subtype_Use\n+              (\"cannot use subtype& with non-static predicate for loop \" &\n+               \"iteration\", DS, Entity (DS));\n+         end if;\n+      end if;\n \n-            --  Prevent cascaded errors\n+      --  Error if not discrete type\n \n-            Set_Ekind (Def_Id, E_Loop_Parameter);\n-            Set_Etype (Def_Id, Etype (First_Index (Typ)));\n-         end if;\n+      if not Is_Discrete_Type (Etype (DS)) then\n+         Wrong_Type (DS, Any_Discrete);\n+         Set_Etype (DS, Any_Type);\n+      end if;\n \n-         --  Check for type error in iterator\n+      Check_Controlled_Array_Attribute (DS);\n+\n+      Make_Index (DS, N, In_Iter_Schm => True);\n+      Set_Ekind (Id, E_Loop_Parameter);\n+\n+      --  A quantified expression which appears in a pre- or post-condition may\n+      --  be analyzed multiple times. The analysis of the range creates several\n+      --  itypes which reside in different scopes depending on whether the pre-\n+      --  or post-condition has been expanded. Update the type of the loop\n+      --  variable to reflect the proper itype at each stage of analysis.\n+\n+      if No (Etype (Id))\n+        or else Etype (Id) = Any_Type\n+        or else\n+          (Present (Etype (Id))\n+             and then Is_Itype (Etype (Id))\n+             and then Nkind (Parent (Loop_Nod)) = N_Expression_With_Actions\n+             and then Nkind (Original_Node (Parent (Loop_Nod))) =\n+                        N_Quantified_Expression)\n+      then\n+         Set_Etype (Id, Etype (DS));\n+      end if;\n \n-      elsif Typ = Any_Type then\n-         return;\n+      --  Treat a range as an implicit reference to the type, to inhibit\n+      --  spurious warnings.\n \n-      --  Iteration over a container\n+      Generate_Reference (Base_Type (Etype (DS)), N, ' ');\n+      Set_Is_Known_Valid (Id, True);\n \n-      else\n-         Set_Ekind (Def_Id, E_Loop_Parameter);\n+      --  The loop is not a declarative part, so the only entity declared\n+      --  \"within\" must be frozen explicitly.\n \n-         if Of_Present (N) then\n+      declare\n+         Flist : constant List_Id := Freeze_Entity (Id, N);\n+      begin\n+         if Is_Non_Empty_List (Flist) then\n+            Insert_Actions (N, Flist);\n+         end if;\n+      end;\n \n-            --  The type of the loop variable is the Iterator_Element aspect of\n-            --  the container type.\n+      --  Check for null or possibly null range and issue warning. We suppress\n+      --  such messages in generic templates and instances, because in practice\n+      --  they tend to be dubious in these cases.\n \n-            declare\n-               Element : constant Entity_Id :=\n-                           Find_Aspect (Typ, Aspect_Iterator_Element);\n-            begin\n-               if No (Element) then\n-                  Error_Msg_NE (\"cannot iterate over&\", N, Typ);\n-                  return;\n-               else\n-                  Set_Etype (Def_Id, Entity (Element));\n-               end if;\n-            end;\n+      if Nkind (DS) = N_Range and then Comes_From_Source (N) then\n+         declare\n+            L : constant Node_Id := Low_Bound  (DS);\n+            H : constant Node_Id := High_Bound (DS);\n \n-         else\n-            --  For an iteration of the form IN, the name must denote an\n-            --  iterator, typically the result of a call to Iterate. Give a\n-            --  useful error message when the name is a container by itself.\n+         begin\n+            --  If range of loop is null, issue warning\n \n-            if Is_Entity_Name (Original_Node (Name (N)))\n-              and then not Is_Iterator (Typ)\n-            then\n-               if No (Find_Aspect (Typ, Aspect_Iterator_Element)) then\n-                  Error_Msg_NE\n-                    (\"cannot iterate over&\", Name (N), Typ);\n-               else\n-                  Error_Msg_N\n-                    (\"name must be an iterator, not a container\", Name (N));\n-               end if;\n+            if Compile_Time_Compare (L, H, Assume_Valid => True) = GT then\n \n-               Error_Msg_NE\n-                 (\"\\to iterate directly over the elements of a container, \" &\n-                   \"write `of &`\", Name (N), Original_Node (Name (N)));\n-            end if;\n+               --  Suppress the warning if inside a generic template or\n+               --  instance, since in practice they tend to be dubious in these\n+               --  cases since they can result from intended parametrization.\n \n-            --  The result type of Iterate function is the classwide type of\n-            --  the interface parent. We need the specific Cursor type defined\n-            --  in the container package.\n+               if not Inside_A_Generic\n+                 and then not In_Instance\n+               then\n+                  --  Specialize msg if invalid values could make the loop\n+                  --  non-null after all.\n \n-            Ent := First_Entity (Scope (Typ));\n-            while Present (Ent) loop\n-               if Chars (Ent) = Name_Cursor then\n-                  Set_Etype (Def_Id, Etype (Ent));\n-                  exit;\n+                  if Compile_Time_Compare\n+                       (L, H, Assume_Valid => False) = GT\n+                  then\n+                     Error_Msg_N\n+                       (\"?loop range is null, loop will not execute\", DS);\n+\n+                     --  Since we know the range of the loop is null, set the\n+                     --  appropriate flag to remove the loop entirely during\n+                     --  expansion.\n+\n+                     Set_Is_Null_Loop (Loop_Nod);\n+\n+                  --  Here is where the loop could execute because of invalid\n+                  --  values, so issue appropriate message and in this case we\n+                  --  do not set the Is_Null_Loop flag since the loop may\n+                  --  execute.\n+\n+                  else\n+                     Error_Msg_N\n+                       (\"?loop range may be null, loop may not execute\", DS);\n+                     Error_Msg_N\n+                       (\"?can only execute if invalid values are present\", DS);\n+                  end if;\n                end if;\n \n-               Next_Entity (Ent);\n-            end loop;\n-         end if;\n-      end if;\n-   end Analyze_Iterator_Specification;\n+               --  In either case, suppress warnings in the body of the loop,\n+               --  since it is likely that these warnings will be inappropriate\n+               --  if the loop never actually executes, which is likely.\n \n-   -------------------\n-   -- Analyze_Label --\n-   -------------------\n+               Set_Suppress_Loop_Warnings (Loop_Nod);\n \n-   --  Note: the semantic work required for analyzing labels (setting them as\n-   --  reachable) was done in a prepass through the statements in the block,\n-   --  so that forward gotos would be properly handled. See Analyze_Statements\n-   --  for further details. The only processing required here is to deal with\n-   --  optimizations that depend on an assumption of sequential control flow,\n-   --  since of course the occurrence of a label breaks this assumption.\n+               --  The other case for a warning is a reverse loop where the\n+               --  upper bound is the integer literal zero or one, and the\n+               --  lower bound can be positive.\n \n-   procedure Analyze_Label (N : Node_Id) is\n-      pragma Warnings (Off, N);\n-   begin\n-      Kill_Current_Values;\n-   end Analyze_Label;\n+               --  For example, we have\n \n-   --------------------------\n-   -- Analyze_Label_Entity --\n-   --------------------------\n+               --     for J in reverse N .. 1 loop\n \n-   procedure Analyze_Label_Entity (E : Entity_Id) is\n-   begin\n-      Set_Ekind           (E, E_Label);\n-      Set_Etype           (E, Standard_Void_Type);\n-      Set_Enclosing_Scope (E, Current_Scope);\n-      Set_Reachable       (E, True);\n-   end Analyze_Label_Entity;\n+               --  In practice, this is very likely to be a case of reversing\n+               --  the bounds incorrectly in the range.\n+\n+            elsif Reverse_Present (N)\n+              and then Nkind (Original_Node (H)) = N_Integer_Literal\n+              and then\n+                (Intval (Original_Node (H)) = Uint_0\n+                  or else Intval (Original_Node (H)) = Uint_1)\n+            then\n+               Error_Msg_N (\"?loop range may be null\", DS);\n+               Error_Msg_N (\"\\?bounds may be wrong way round\", DS);\n+            end if;\n+         end;\n+      end if;\n+   end Analyze_Loop_Parameter_Specification;\n \n    ----------------------------\n    -- Analyze_Loop_Statement --\n@@ -2485,7 +2464,7 @@ package body Sem_Ch5 is\n             begin\n                Nam_Copy := New_Copy_Tree (Nam);\n                Set_Parent (Nam_Copy, Parent (Nam));\n-               Pre_Analyze_Range (Nam_Copy);\n+               Preanalyze_Range (Nam_Copy);\n \n                --  The only two options here are iteration over a container or\n                --  an array.\n@@ -2504,7 +2483,7 @@ package body Sem_Ch5 is\n             begin\n                DS_Copy := New_Copy_Tree (DS);\n                Set_Parent (DS_Copy, Parent (DS));\n-               Pre_Analyze_Range (DS_Copy);\n+               Preanalyze_Range (DS_Copy);\n \n                --  Check for a call to Iterate ()\n \n@@ -2910,11 +2889,11 @@ package body Sem_Ch5 is\n       end if;\n    end Check_Unreachable_Code;\n \n-   -----------------------\n-   -- Pre_Analyze_Range --\n-   -----------------------\n+   ----------------------\n+   -- Preanalyze_Range --\n+   ----------------------\n \n-   procedure Pre_Analyze_Range (R_Copy : Node_Id) is\n+   procedure Preanalyze_Range (R_Copy : Node_Id) is\n       Save_Analysis : constant Boolean := Full_Analysis;\n \n    begin\n@@ -2980,6 +2959,6 @@ package body Sem_Ch5 is\n \n       Expander_Mode_Restore;\n       Full_Analysis := Save_Analysis;\n-   end Pre_Analyze_Range;\n+   end Preanalyze_Range;\n \n end Sem_Ch5;"}, {"sha": "86a92b76c5e55b5d4ee72088da9a708147f1835a", "filename": "gcc/ada/sem_ch5.ads", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch5.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch5.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch5.ads?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2010, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2012, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -27,19 +27,20 @@ with Types; use Types;\n \n package Sem_Ch5 is\n \n-   procedure Analyze_Assignment                 (N : Node_Id);\n-   procedure Analyze_Block_Statement            (N : Node_Id);\n-   procedure Analyze_Case_Statement             (N : Node_Id);\n-   procedure Analyze_Exit_Statement             (N : Node_Id);\n-   procedure Analyze_Goto_Statement             (N : Node_Id);\n-   procedure Analyze_If_Statement               (N : Node_Id);\n-   procedure Analyze_Implicit_Label_Declaration (N : Node_Id);\n-   procedure Analyze_Iterator_Specification     (N : Node_Id);\n-   procedure Analyze_Iteration_Scheme           (N : Node_Id);\n-   procedure Analyze_Label                      (N : Node_Id);\n-   procedure Analyze_Loop_Statement             (N : Node_Id);\n-   procedure Analyze_Null_Statement             (N : Node_Id);\n-   procedure Analyze_Statements                 (L : List_Id);\n+   procedure Analyze_Assignment                   (N : Node_Id);\n+   procedure Analyze_Block_Statement              (N : Node_Id);\n+   procedure Analyze_Case_Statement               (N : Node_Id);\n+   procedure Analyze_Exit_Statement               (N : Node_Id);\n+   procedure Analyze_Goto_Statement               (N : Node_Id);\n+   procedure Analyze_If_Statement                 (N : Node_Id);\n+   procedure Analyze_Implicit_Label_Declaration   (N : Node_Id);\n+   procedure Analyze_Iterator_Specification       (N : Node_Id);\n+   procedure Analyze_Iteration_Scheme             (N : Node_Id);\n+   procedure Analyze_Label                        (N : Node_Id);\n+   procedure Analyze_Loop_Parameter_Specification (N : Node_Id);\n+   procedure Analyze_Loop_Statement               (N : Node_Id);\n+   procedure Analyze_Null_Statement               (N : Node_Id);\n+   procedure Analyze_Statements                   (L : List_Id);\n \n    procedure Analyze_Label_Entity (E : Entity_Id);\n    --  This procedure performs direct analysis of the label entity E. It"}, {"sha": "4c7f2e472247789371d1a62559e040c3467c5dfe", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -8702,7 +8702,9 @@ package body Sem_Ch6 is\n                                 Discrete_Subtype_Definition (L2));\n                   end;\n \n-               else   --  quantified expression with an iterator\n+               elsif Present (Iterator_Specification (E1))\n+                 and then Present (Iterator_Specification (E2))\n+               then\n                   declare\n                      I1 : constant Node_Id := Iterator_Specification (E1);\n                      I2 : constant Node_Id := Iterator_Specification (E2);\n@@ -8719,6 +8721,12 @@ package body Sem_Ch6 is\n                        and then FCE (Subtype_Indication (I1),\n                                       Subtype_Indication (I2));\n                   end;\n+\n+               --  The quantified expressions used different specifications to\n+               --  walk their respective ranges.\n+\n+               else\n+                  return False;\n                end if;\n \n             when N_Range =>"}, {"sha": "ab08e77153bb966732e179f29f9b96c22f0a3fd2", "filename": "gcc/ada/sem_res.adb", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_res.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_res.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_res.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -193,7 +193,6 @@ package body Sem_Res is\n    procedure Resolve_Op_Expon                  (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Op_Not                    (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Qualified_Expression      (N : Node_Id; Typ : Entity_Id);\n-   procedure Resolve_Quantified_Expression     (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Range                     (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Real_Literal              (N : Node_Id; Typ : Entity_Id);\n    procedure Resolve_Reference                 (N : Node_Id; Typ : Entity_Id);\n@@ -1770,6 +1769,10 @@ package body Sem_Res is\n       --  Try and fix up a literal so that it matches its expected type. New\n       --  literals are manufactured if necessary to avoid cascaded errors.\n \n+      function Proper_Current_Scope return Entity_Id;\n+      --  Return the current scope. Skip loop scopes created for the purpose of\n+      --  quantified expression analysis since those do not appear in the tree.\n+\n       procedure Report_Ambiguous_Argument;\n       --  Additional diagnostics when an ambiguous call has an ambiguous\n       --  argument (typically a controlling actual).\n@@ -1832,6 +1835,30 @@ package body Sem_Res is\n          end if;\n       end Patch_Up_Value;\n \n+      --------------------------\n+      -- Proper_Current_Scope --\n+      --------------------------\n+\n+      function Proper_Current_Scope return Entity_Id is\n+         S : Entity_Id := Current_Scope;\n+\n+      begin\n+         while Present (S) loop\n+\n+            --  Skip a loop scope created for quantified expression analysis\n+\n+            if Ekind (S) = E_Loop\n+              and then Nkind (Parent (S)) = N_Quantified_Expression\n+            then\n+               S := Scope (S);\n+            else\n+               exit;\n+            end if;\n+         end loop;\n+\n+         return S;\n+      end Proper_Current_Scope;\n+\n       -------------------------------\n       -- Report_Ambiguous_Argument --\n       -------------------------------\n@@ -2761,8 +2788,7 @@ package body Sem_Res is\n             when N_Qualified_Expression\n                              => Resolve_Qualified_Expression     (N, Ctx_Type);\n \n-            when N_Quantified_Expression\n-                             => Resolve_Quantified_Expression    (N, Ctx_Type);\n+            when N_Quantified_Expression => null;\n \n             when N_Raise_xxx_Error\n                              => Set_Etype (N, Ctx_Type);\n@@ -2857,10 +2883,9 @@ package body Sem_Res is\n          --  Ada 2012 (AI05-177): Expression functions do not freeze. Only\n          --  their use (in an expanded call) freezes.\n \n-         if Ekind (Current_Scope) /= E_Function\n-           or else\n-             Nkind (Original_Node (Unit_Declaration_Node (Current_Scope))) /=\n-                                                        N_Expression_Function\n+         if Ekind (Proper_Current_Scope) /= E_Function\n+           or else Nkind (Original_Node (Unit_Declaration_Node\n+                     (Proper_Current_Scope))) /= N_Expression_Function\n          then\n             Freeze_Expression (N);\n          end if;\n@@ -8290,31 +8315,6 @@ package body Sem_Res is\n       Eval_Qualified_Expression (N);\n    end Resolve_Qualified_Expression;\n \n-   -----------------------------------\n-   -- Resolve_Quantified_Expression --\n-   -----------------------------------\n-\n-   procedure Resolve_Quantified_Expression (N : Node_Id; Typ : Entity_Id) is\n-   begin\n-      if not Alfa_Mode then\n-\n-         --  The loop structure is already resolved during its analysis, only\n-         --  the resolution of the condition needs to be done. Expansion is\n-         --  disabled so that checks and other generated code are inserted in\n-         --  the tree after expression has been rewritten as a loop.\n-\n-         Expander_Mode_Save_And_Set (False);\n-         Resolve (Condition (N), Typ);\n-         Expander_Mode_Restore;\n-\n-      --  In Alfa mode, we need normal expansion in order to properly introduce\n-      --  the necessary transient scopes.\n-\n-      else\n-         Resolve (Condition (N), Typ);\n-      end if;\n-   end Resolve_Quantified_Expression;\n-\n    -------------------\n    -- Resolve_Range --\n    -------------------"}, {"sha": "e7958058cd63bdb2134371d83c336360e73eaaaf", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/804670f120cd78a0304b630e7e53b1e13c9f5bfb/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=804670f120cd78a0304b630e7e53b1e13c9f5bfb", "patch": "@@ -740,12 +740,28 @@ package body Sem_Util is\n       N : Node_Id) return Entity_Id\n    is\n       Loc  : constant Source_Ptr := Sloc (N);\n+      Bas  : Entity_Id;\n+      --  The base type that is to be constrained by the defaults.\n+\n       Disc : Entity_Id;\n \n    begin\n       if not Has_Discriminants (T) or else Is_Constrained (T) then\n          return T;\n       end if;\n+      Bas := Base_Type (T);\n+\n+      --  If T is non-private but its base type is private, this is\n+      --  the completion of a subtype declaration whose parent type\n+      --  is private (see Complete_Private_Subtype in sem_ch3). The\n+      --  proper discriminants are to be found in the full view of\n+      --  the base.\n+\n+      if Is_Private_Type (Bas)\n+        and then Present (Full_View (Bas))\n+      then\n+         Bas := Full_View (Bas);\n+      end if;\n \n       Disc := First_Discriminant (T);\n \n@@ -770,7 +786,7 @@ package body Sem_Util is\n              Defining_Identifier => Act,\n              Subtype_Indication =>\n                Make_Subtype_Indication (Loc,\n-                 Subtype_Mark => New_Occurrence_Of (T, Loc),\n+                 Subtype_Mark => New_Occurrence_Of (Bas, Loc),\n                  Constraint =>\n                    Make_Index_Or_Discriminant_Constraint (Loc,\n                      Constraints => Constraints)));"}]}