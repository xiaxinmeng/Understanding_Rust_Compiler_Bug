{"sha": "5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWY2NzNjNmExYzVjMThlOGE3NjcxZDZiMmFjMTMwZjYzN2Q5YjIzZQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2013-12-04T19:59:42Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2013-12-04T19:59:42Z"}, "message": "re PR debug/37132 (Debug: No DW_TAG_namelist emitted for NAMELISTS)\n\ngcc/\n2013-12-04  Tobias Burnus  <burnus@net-b.de>\n\n        PR debug/37132\n        * lto-streamer.h (LTO_tags): Add LTO_namelist_decl_ref.\n        * tree.def (NAMELIST_DECL): Add.\n        * tree.h (NAMELIST_DECL_ASSOCIATED_DECL): New macro.\n        * tree.c (initialize_tree_contains_struct): Add asserts for it.\n        * dwarf2out.c (gen_namelist_decl): New function.\n        (gen_decl_die, dwarf2out_decl): Call it.\n        (dwarf2out_imported_module_or_decl_1): Handle NAMELIST_DECL.\n        * lto-streamer-in.c (lto_input_tree_ref): Handle NAMELIST_DECL.\n        (lto_input_tree_ref, lto_input_tree_1): Update lto_tag_check_range\n        call.\n        * lto-streamer-out.c (lto_output_tree_ref): Handle\n        * NAMELIST_DECL.\n\ngcc/fortran\n2013-12-04  Tobias Burnus  <burnus@net-b.de>\n\n        PR debug/37132\n        * trans-decl.c (generate_namelist_decl, create_module_nml_decl):\n        New static functions.\n        (gfc_generate_module_vars, generate_local_vars): Call them.\n        (gfc_trans_use_stmts): Handle namelists for debug genertion.\n\nFrom-SVN: r205679", "tree": {"sha": "419e75c475a0f56792c605edf3b589a11b340fb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/419e75c475a0f56792c605edf3b589a11b340fb7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4f6843aa8c8a7216d0949c7ecf3d3f973222195a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6843aa8c8a7216d0949c7ecf3d3f973222195a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6843aa8c8a7216d0949c7ecf3d3f973222195a"}], "stats": {"total": 211, "additions": 207, "deletions": 4}, "files": [{"sha": "b42c3621461fb0b8de72857c42f3761d62ad8357", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -1,3 +1,18 @@\n+2013-12-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR debug/37132\n+\t* lto-streamer.h (LTO_tags): Add LTO_namelist_decl_ref.\n+\t* tree.def (NAMELIST_DECL): Add.\n+\t* tree.h (NAMELIST_DECL_ASSOCIATED_DECL): New macro.\n+\t* tree.c (initialize_tree_contains_struct): Add asserts for it.\n+\t* dwarf2out.c (gen_namelist_decl): New function.\n+\t(gen_decl_die, dwarf2out_decl): Call it.\n+\t(dwarf2out_imported_module_or_decl_1): Handle NAMELIST_DECL.\n+\t* lto-streamer-in.c (lto_input_tree_ref): Handle NAMELIST_DECL.\n+\t(lto_input_tree_ref, lto_input_tree_1): Update lto_tag_check_range\n+\tcall.\n+\t* lto-streamer-out.c (lto_output_tree_ref): Handle NAMELIST_DECL.\n+\n 2013-12-03  Xinliang David Li  <davidxl@google.com>\n \n \t* tree-ssa-structalias.c (constraint_set_union): Change return type"}, {"sha": "6586c939b9dae112704e66147bb51360cc8e3db7", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 52, "deletions": 1, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -3185,6 +3185,7 @@ static inline int is_redundant_typedef (const_tree);\n static bool is_naming_typedef_decl (const_tree);\n static inline dw_die_ref get_context_die (tree);\n static void gen_namespace_die (tree, dw_die_ref);\n+static dw_die_ref gen_namelist_decl (tree, dw_die_ref, tree);\n static dw_die_ref gen_decl_die (tree, tree, dw_die_ref);\n static dw_die_ref force_decl_die (tree);\n static dw_die_ref force_type_die (tree);\n@@ -20429,6 +20430,11 @@ gen_decl_die (tree decl, tree origin, dw_die_ref context_die)\n \tgen_namespace_die (decl, context_die);\n       break;\n \n+    case NAMELIST_DECL:\n+      gen_namelist_decl (DECL_NAME (decl), context_die,\n+\t\t\t NAMELIST_DECL_ASSOCIATED_DECL (decl));\n+      break;\n+\n     default:\n       /* Probably some frontend-internal decl.  Assume we don't care.  */\n       gcc_assert ((int)TREE_CODE (decl) > NUM_TREE_CODES);\n@@ -20518,7 +20524,12 @@ dwarf2out_imported_module_or_decl_1 (tree decl,\n \t      gen_type_die_for_member (type, decl,\n \t\t\t\t       get_context_die (TYPE_CONTEXT (type)));\n \t    }\n-\t  at_import_die = force_decl_die (decl);\n+\t  if (TREE_CODE (decl) == NAMELIST_DECL)\n+\t    at_import_die = gen_namelist_decl (DECL_NAME (decl),\n+\t\t\t\t\t get_context_die (DECL_CONTEXT (decl)),\n+\t\t\t\t\t NULL_TREE);\n+\t  else\n+\t    at_import_die = force_decl_die (decl);\n \t}\n     }\n \n@@ -20590,6 +20601,43 @@ dwarf2out_imported_module_or_decl (tree decl, tree name, tree context,\n \n }\n \n+/* Output debug information for namelists.   */\n+\n+static dw_die_ref\n+gen_namelist_decl (tree name, dw_die_ref scope_die, tree item_decls)\n+{\n+  dw_die_ref nml_die, nml_item_die, nml_item_ref_die;\n+  tree value;\n+  unsigned i;\n+\n+  if (debug_info_level <= DINFO_LEVEL_TERSE)\n+    return NULL;\n+\n+  gcc_assert (scope_die != NULL);\n+  nml_die = new_die (DW_TAG_namelist, scope_die, NULL);\n+  add_AT_string (nml_die, DW_AT_name, IDENTIFIER_POINTER (name));\n+\n+  /* If there are no item_decls, we have a nondefining namelist, e.g.\n+     with USE association; hence, set DW_AT_declaration.  */\n+  if (item_decls == NULL_TREE)\n+    {\n+      add_AT_flag (nml_die, DW_AT_declaration, 1);\n+      return nml_die;\n+    }\n+\n+  FOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (item_decls), i, value)\n+    {\n+      nml_item_ref_die = lookup_decl_die (value);\n+      if (!nml_item_ref_die)\n+\tnml_item_ref_die = force_decl_die (value);\n+\n+      nml_item_die = new_die (DW_TAG_namelist_item, nml_die, NULL);\n+      add_AT_die_ref (nml_item_die, DW_AT_namelist_items, nml_item_ref_die);\n+    }\n+  return nml_die;\n+}\n+\n+\n /* Write the debugging output for DECL.  */\n \n void\n@@ -20710,6 +20758,9 @@ dwarf2out_decl (tree decl)\n \n       break;\n \n+    case NAMELIST_DECL:\n+      break;\n+\n     default:\n       return;\n     }"}, {"sha": "bad7d6b611f78b4c780662b5116a384a8c03f024", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -1,3 +1,11 @@\n+2013-12-04  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR debug/37132\n+\t* trans-decl.c (generate_namelist_decl, create_module_nml_decl):\n+\tNew static functions.\n+\t(gfc_generate_module_vars, generate_local_vars): Call them.\n+\t(gfc_trans_use_stmts): Handle namelists for debug genertion.\n+\n 2013-12-01  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/57354"}, {"sha": "c1775b33496fdd7568acf76ebb5b7af545b41d3d", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -4144,6 +4144,37 @@ gfc_module_add_decl (struct module_htab_entry *entry, tree decl)\n \n static struct module_htab_entry *cur_module;\n \n+\n+/* Generate debugging symbols for namelists. This function must come after\n+   generate_local_decl to ensure that the variables in the namelist are\n+   already declared.  */\n+\n+static tree\n+generate_namelist_decl (gfc_symbol * sym)\n+{\n+  gfc_namelist *nml;\n+  tree decl;\n+  vec<constructor_elt, va_gc> *nml_decls = NULL;\n+\n+  gcc_assert (sym->attr.flavor == FL_NAMELIST);\n+  for (nml = sym->namelist; nml; nml = nml->next)\n+    {\n+      if (nml->sym->backend_decl == NULL_TREE)\n+\t{\n+\t  nml->sym->attr.referenced = 1;\n+\t  nml->sym->backend_decl = gfc_get_symbol_decl (nml->sym);\n+\t}\n+      CONSTRUCTOR_APPEND_ELT (nml_decls, NULL_TREE, nml->sym->backend_decl);\n+    }\n+\n+  decl = make_node (NAMELIST_DECL);\n+  TREE_TYPE (decl) = void_type_node;\n+  NAMELIST_DECL_ASSOCIATED_DECL (decl) = build_constructor (NULL_TREE, nml_decls);\n+  DECL_NAME (decl) = get_identifier (sym->name);\n+  return decl;\n+}\n+\n+\n /* Output an initialized decl for a module variable.  */\n \n static void\n@@ -4333,6 +4364,18 @@ gfc_trans_use_stmts (gfc_namespace * ns)\n \t\t  DECL_IGNORED_P (decl) = 0;\n \t\t  DECL_INITIAL (decl) = NULL_TREE;\n \t\t}\n+\t      else if (st->n.sym->attr.flavor == FL_NAMELIST\n+\t\t       && st->n.sym->attr.use_only\n+\t\t       && st->n.sym->module\n+\t\t       && strcmp (st->n.sym->module, use_stmt->module_name)\n+\t\t\t  == 0)\n+\t\t{\n+\t\t  decl = generate_namelist_decl (st->n.sym);\n+\t\t  DECL_CONTEXT (decl) = entry->namespace_decl;\n+\t\t  DECL_EXTERNAL (decl) = 1;\n+\t\t  DECL_IGNORED_P (decl) = 0;\n+\t\t  DECL_INITIAL (decl) = NULL_TREE;\n+\t\t}\n \t      else\n \t\t{\n \t\t  *slot = error_mark_node;\n@@ -4610,6 +4653,21 @@ generate_coarray_init (gfc_namespace * ns __attribute((unused)))\n }\n \n \n+static void\n+create_module_nml_decl (gfc_symbol *sym)\n+{\n+  if (sym->attr.flavor == FL_NAMELIST)\n+    {\n+      tree decl = generate_namelist_decl (sym);\n+      pushdecl (decl);\n+      gcc_assert (sym->ns->proc_name->attr.flavor == FL_MODULE);\n+      DECL_CONTEXT (decl) = sym->ns->proc_name->backend_decl;\n+      rest_of_decl_compilation (decl, 1, 0);\n+      gfc_module_add_decl (cur_module, decl);\n+    }\n+}\n+\n+\n /* Generate all the required code for module variables.  */\n \n void\n@@ -4628,6 +4686,7 @@ gfc_generate_module_vars (gfc_namespace * ns)\n \n   /* Create decls for all the module variables.  */\n   gfc_traverse_ns (ns, gfc_create_module_variable);\n+  gfc_traverse_ns (ns, create_module_nml_decl);\n \n   if (gfc_option.coarray == GFC_FCOARRAY_LIB && has_coarray_vars)\n     generate_coarray_init (ns);\n@@ -4893,10 +4952,23 @@ generate_local_decl (gfc_symbol * sym)\n     sym->backend_decl = gfc_typenode_for_spec (&(sym->ts));\n }\n \n+\n+static void\n+generate_local_nml_decl (gfc_symbol * sym)\n+{\n+  if (sym->attr.flavor == FL_NAMELIST && !sym->attr.use_assoc)\n+    {\n+      tree decl = generate_namelist_decl (sym);\n+      pushdecl (decl);\n+    }\n+}\n+\n+\n static void\n generate_local_vars (gfc_namespace * ns)\n {\n   gfc_traverse_ns (ns, generate_local_decl);\n+  gfc_traverse_ns (ns, generate_local_nml_decl);\n }\n \n "}, {"sha": "862e49d5a6a5ee596ba182befc628a0adec6a283", "filename": "gcc/lto-streamer-in.c", "status": "modified", "additions": 24, "deletions": 2, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer-in.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer-in.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-in.c?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -204,7 +204,7 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n   unsigned HOST_WIDE_INT ix_u;\n   tree result = NULL_TREE;\n \n-  lto_tag_check_range (tag, LTO_field_decl_ref, LTO_global_decl_ref);\n+  lto_tag_check_range (tag, LTO_field_decl_ref, LTO_namelist_decl_ref);\n \n   switch (tag)\n     {\n@@ -248,6 +248,28 @@ lto_input_tree_ref (struct lto_input_block *ib, struct data_in *data_in,\n       result = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n       break;\n \n+    case LTO_namelist_decl_ref:\n+      {\n+\ttree tmp;\n+\tvec<constructor_elt, va_gc> *nml_decls = NULL;\n+\tunsigned i, n;\n+\n+\tresult = make_node (NAMELIST_DECL);\n+\tTREE_TYPE (result) = void_type_node;\n+\tDECL_NAME (result) = stream_read_tree (ib, data_in);\n+\tn = streamer_read_uhwi (ib);\n+\tfor (i = 0; i < n; i++)\n+\t  {\n+\t    ix_u = streamer_read_uhwi (ib);\n+\t    tmp = lto_file_decl_data_get_var_decl (data_in->file_data, ix_u);\n+\t    gcc_assert (tmp != NULL_TREE);\n+\t    CONSTRUCTOR_APPEND_ELT (nml_decls, NULL_TREE, tmp);\n+\t  }\n+\tNAMELIST_DECL_ASSOCIATED_DECL (result) = build_constructor (NULL_TREE,\n+\t\t\t\t\t\t\t\t    nml_decls);\n+\tbreak;\n+      }\n+\n     default:\n       gcc_unreachable ();\n     }\n@@ -1248,7 +1270,7 @@ lto_input_tree_1 (struct lto_input_block *ib, struct data_in *data_in,\n \n   if (tag == LTO_null)\n     result = NULL_TREE;\n-  else if (tag >= LTO_field_decl_ref && tag <= LTO_global_decl_ref)\n+  else if (tag >= LTO_field_decl_ref && tag <= LTO_namelist_decl_ref)\n     {\n       /* If TAG is a reference to an indexable tree, the next value\n \t in IB is the index into the table where we expect to find"}, {"sha": "e99424e28a9edc351093f5d1f025f28886fb0e08", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -54,6 +54,8 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n \n \n+static void lto_write_tree (struct output_block*, tree, bool);\n+\n /* Clear the line info stored in DATA_IN.  */\n \n static void\n@@ -252,6 +254,21 @@ lto_output_tree_ref (struct output_block *ob, tree expr)\n       lto_output_type_decl_index (ob->decl_state, ob->main_stream, expr);\n       break;\n \n+    case NAMELIST_DECL:\n+      {\n+\tunsigned i;\n+\ttree value, tmp;\n+\n+\tstreamer_write_record_start (ob, LTO_namelist_decl_ref);\n+\tstream_write_tree (ob, DECL_NAME (expr), true);\n+\ttmp = NAMELIST_DECL_ASSOCIATED_DECL (expr);\n+\tgcc_assert (tmp != NULL_TREE);\n+\tstreamer_write_uhwi (ob, CONSTRUCTOR_ELTS (tmp)->length());\n+\tFOR_EACH_CONSTRUCTOR_VALUE (CONSTRUCTOR_ELTS (tmp), i, value)\n+\t  lto_output_var_decl_index (ob->decl_state, ob->main_stream, value);\n+\tbreak;\n+      }\n+\n     case NAMESPACE_DECL:\n       streamer_write_record_start (ob, LTO_namespace_decl_ref);\n       lto_output_namespace_decl_index (ob->decl_state, ob->main_stream, expr);"}, {"sha": "91bbb93b20201a0927d8e298c61be5be0011401b", "filename": "gcc/lto-streamer.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Flto-streamer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer.h?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -222,7 +222,8 @@ enum LTO_tags\n   LTO_const_decl_ref,\n   LTO_imported_decl_ref,\n   LTO_translation_unit_decl_ref,\n-  LTO_global_decl_ref,\t\t\t/* Do not change.  */\n+  LTO_global_decl_ref,\n+  LTO_namelist_decl_ref,\t\t/* Do not change.  */\n \n   /* This tag must always be last.  */\n   LTO_NUM_TAGS"}, {"sha": "e9da914ef6673be147be719ddef1748f57b19f0a", "filename": "gcc/tree.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -551,6 +551,8 @@ initialize_tree_contains_struct (void)\n   gcc_assert (tree_contains_struct[FUNCTION_DECL][TS_FUNCTION_DECL]);\n   gcc_assert (tree_contains_struct[IMPORTED_DECL][TS_DECL_MINIMAL]);\n   gcc_assert (tree_contains_struct[IMPORTED_DECL][TS_DECL_COMMON]);\n+  gcc_assert (tree_contains_struct[NAMELIST_DECL][TS_DECL_MINIMAL]);\n+  gcc_assert (tree_contains_struct[NAMELIST_DECL][TS_DECL_COMMON]);\n }\n \n "}, {"sha": "364e510adf91f48721c1f35011dd93a341318f33", "filename": "gcc/tree.def", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.def?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -372,6 +372,16 @@ DEFTREECODE (NAMESPACE_DECL, \"namespace_decl\", tcc_declaration, 0)\n    IMPORTED_DECL_ASSOCIATED_DECL (NODE) accesses the imported declaration.  */\n DEFTREECODE (IMPORTED_DECL, \"imported_decl\", tcc_declaration, 0)\n \n+/* A namelist declaration.\n+   The Fortran FE uses this to represent a namelist statement, e.g.:\n+   NAMELIST /namelist-group-name/ namelist-group-object-list.\n+   Whenever a declaration import appears in a lexical block, the BLOCK node\n+   representing that lexical block in GIMPLE will contain an NAMELIST_DECL\n+   node, linked via BLOCK_VARS accessor of the said BLOCK.\n+   For a given NODE which code is NAMELIST_DECL,\n+   NAMELIST_DECL_ASSOCIATED_DECL (NODE) accesses the imported declaration.  */\n+DEFTREECODE (NAMELIST_DECL, \"namelist_decl\", tcc_declaration, 0)\n+\n /* A translation unit.  This is not technically a declaration, since it\n    can't be looked up, but it's close enough.  */\n DEFTREECODE (TRANSLATION_UNIT_DECL, \"translation_unit_decl\",\\"}, {"sha": "664bdfd39538a835480652114b75fed2b481d5c1", "filename": "gcc/tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=5f673c6a1c5c18e8a7671d6b2ac130f637d9b23e", "patch": "@@ -2664,6 +2664,11 @@ extern vec<tree, va_gc> **decl_debug_args_insert (tree);\n #define IMPORTED_DECL_ASSOCIATED_DECL(NODE) \\\n (DECL_INITIAL (IMPORTED_DECL_CHECK (NODE)))\n \n+/* Getter of the symbol declaration associated with the\n+   NAMELIST_DECL node.  */\n+#define NAMELIST_DECL_ASSOCIATED_DECL(NODE) \\\n+  (DECL_INITIAL (NODE))\n+\n /* A STATEMENT_LIST chains statements together in GENERIC and GIMPLE.\n    To reduce overhead, the nodes containing the statements are not trees.\n    This avoids the overhead of tree_common on all linked list elements."}]}