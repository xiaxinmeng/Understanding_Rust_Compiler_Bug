{"sha": "c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzFiYzY4MjliNDM5ZGZkMzU5MGE1NGRkMjk4YjM0YTBiMzRjY2Y4OQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1997-09-03T20:01:18Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1997-09-03T20:01:18Z"}, "message": "typeck.c (c_expand_return): Always convert_for_initialization before checking for returning a pointer to local.\n\n\t* typeck.c (c_expand_return): Always convert_for_initialization\n \tbefore checking for returning a pointer to local.\n\nFrom-SVN: r15064", "tree": {"sha": "a2b2afc1196b8cca1f703b9eb7b9360ab1199c49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2b2afc1196b8cca1f703b9eb7b9360ab1199c49"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/comments", "author": null, "committer": null, "parents": [{"sha": "fa8b60246437510ca70a89f5d9a127849f4228e5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa8b60246437510ca70a89f5d9a127849f4228e5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa8b60246437510ca70a89f5d9a127849f4228e5"}], "stats": {"total": 153, "additions": 67, "deletions": 86}, "files": [{"sha": "21f2c6c982ea5860d296ff60bf2e3c056f9ccc02", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "patch": "@@ -1,5 +1,8 @@\n Wed Sep  3 11:09:25 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n+\t* typeck.c (c_expand_return): Always convert_for_initialization\n+ \tbefore checking for returning a pointer to local.\n+\n \t* pt.c (type_unification): If strict and the function parm doesn't\n \tuse template parms, just compare types.\n "}, {"sha": "e78b00d25a79c3f33e1f17134f776d660a53d848", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "patch": "@@ -321,7 +321,9 @@ int flag_memoize_lookups; int flag_save_memoized_contexts;\n \n int write_virtuals;\n \n-/* Nonzero means we should attempt to elide constructors when possible.  */\n+/* Nonzero means we should attempt to elide constructors when possible.\n+   FIXME: This flag is obsolete, and should be torn out along with the\n+   old overloading code.  */\n \n int flag_elide_constructors;\n "}, {"sha": "a442d4ec85a426d46660ebf6ac1f9493bc1b7a80", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 61, "deletions": 85, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c1bc6829b439dfd3590a54dd298b34a0b34ccf89/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=c1bc6829b439dfd3590a54dd298b34a0b34ccf89", "patch": "@@ -7204,79 +7204,6 @@ c_expand_return (retval)\n       expand_return (retval);\n       return;\n     }\n-  /* Add some useful error checking for C++.  */\n-  else if (TREE_CODE (valtype) == REFERENCE_TYPE)\n-    {\n-      tree whats_returned;\n-      tree tmp_result = result;\n-\n-      /* Don't initialize directly into a non-BLKmode retval, since that\n-\t could lose when being inlined by another caller.  (GCC can't\n-\t read the function return register in an inline function when\n-\t the return value is being ignored).  */\n-      if (result && TYPE_MODE (TREE_TYPE (tmp_result)) != BLKmode)\n-\ttmp_result = 0;\n-\n-      /* convert to reference now, so we can give error if we\n-\t return an reference to a non-lvalue.  */\n-      retval = convert_for_initialization\n-\t(tmp_result, valtype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n-\t \"return\", NULL_TREE, 0);\n-\n-      /* Sort through common things to see what it is\n-\t we are returning.  */\n-      whats_returned = retval;\n-      if (TREE_CODE (whats_returned) == COMPOUND_EXPR)\n-\t{\n-\t  whats_returned = TREE_OPERAND (whats_returned, 1);\n-\t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n-\t    whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t}\n-      while (TREE_CODE (whats_returned) == CONVERT_EXPR\n-\t     || TREE_CODE (whats_returned) == NOP_EXPR)\n-\twhats_returned = TREE_OPERAND (whats_returned, 0);\n-      if (TREE_CODE (whats_returned) == ADDR_EXPR)\n-\t{\n-\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t  while (TREE_CODE (whats_returned) == NEW_EXPR\n-\t\t || TREE_CODE (whats_returned) == TARGET_EXPR)\n-\t    {\n-\t      /* Get the target.  */\n-\t      whats_returned = TREE_OPERAND (whats_returned, 0);\n-\t      warning (\"returning reference to temporary\");\n-\t    }\n-\t}\n-\n-      if (TREE_CODE (whats_returned) == VAR_DECL && DECL_NAME (whats_returned))\n-\t{\n-\t  if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n-\t    warning (\"reference to non-lvalue returned\");\n-\t  else if (! TREE_STATIC (whats_returned)\n-\t\t   && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n-\t\t   && !TREE_PUBLIC (whats_returned))\n-\t    cp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n-\t}\n-    }\n-  else if (TREE_CODE (retval) == ADDR_EXPR)\n-    {\n-      tree whats_returned = TREE_OPERAND (retval, 0);\n-\n-      if (TREE_CODE (whats_returned) == VAR_DECL\n-\t  && DECL_NAME (whats_returned)\n-\t  && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n-\t  && !TREE_STATIC (whats_returned)\n-\t  && !TREE_PUBLIC (whats_returned))\n-\tcp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n-    }\n-  else if (TREE_CODE (retval) == VAR_DECL)\n-    {\n-      if (TREE_CODE (TREE_TYPE (retval)) == ARRAY_TYPE\n-\t  && DECL_NAME (retval)\n-\t  && IDENTIFIER_LOCAL_VALUE (DECL_NAME (retval))\n-\t  && !TREE_STATIC (retval)\n-\t  && !TREE_PUBLIC (retval))\n-\tcp_warning_at (\"address of local array `%D' returned\", retval);\n-    }\n   \n   /* Now deal with possible C++ hair:\n      (1) Compute the return value.\n@@ -7297,25 +7224,74 @@ c_expand_return (retval)\n     }\n   else\n     {\n-      /* We already did this above for refs, don't do it again.  */\n-      if (TREE_CODE (valtype) != REFERENCE_TYPE)\n-\tretval = convert_for_initialization\n-\t  (NULL_TREE, valtype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n-\t   \"return\", NULL_TREE, 0);\n-\n-      /* We can't initialize a register from a NEW_EXPR.  */\n-      if (! current_function_returns_struct\n-\t  && TREE_CODE (retval) == TARGET_EXPR\n-\t  && TREE_CODE (TREE_OPERAND (retval, 1)) == NEW_EXPR)\n-\tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n-\t\t\tTREE_OPERAND (retval, 0));\n+      retval = convert_for_initialization\n+\t(NULL_TREE, valtype, retval, LOOKUP_NORMAL|LOOKUP_ONLYCONVERTING,\n+\t \"return\", NULL_TREE, 0);\n \n       if (retval == error_mark_node)\n \t{\n \t  /* Avoid warning about control reaching end of function.  */\n \t  expand_null_return ();\n \t  return;\n \t}\n+\n+      /* We can't initialize a register from a NEW_EXPR.  */\n+      else if (! current_function_returns_struct\n+\t       && TREE_CODE (retval) == TARGET_EXPR\n+\t       && TREE_CODE (TREE_OPERAND (retval, 1)) == NEW_EXPR)\n+\tretval = build (COMPOUND_EXPR, TREE_TYPE (retval), retval,\n+\t\t\tTREE_OPERAND (retval, 0));\n+\n+      /* Add some useful error checking for C++.  */\n+      else if (TREE_CODE (valtype) == REFERENCE_TYPE)\n+\t{\n+\t  tree whats_returned;\n+\n+\t  /* Sort through common things to see what it is\n+\t     we are returning.  */\n+\t  whats_returned = retval;\n+\t  if (TREE_CODE (whats_returned) == COMPOUND_EXPR)\n+\t    {\n+\t      whats_returned = TREE_OPERAND (whats_returned, 1);\n+\t      if (TREE_CODE (whats_returned) == ADDR_EXPR)\n+\t\twhats_returned = TREE_OPERAND (whats_returned, 0);\n+\t    }\n+\t  while (TREE_CODE (whats_returned) == CONVERT_EXPR\n+\t\t || TREE_CODE (whats_returned) == NOP_EXPR)\n+\t    whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t  if (TREE_CODE (whats_returned) == ADDR_EXPR)\n+\t    {\n+\t      whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t      while (TREE_CODE (whats_returned) == NEW_EXPR\n+\t\t     || TREE_CODE (whats_returned) == TARGET_EXPR)\n+\t\t{\n+\t\t  /* Get the target.  */\n+\t\t  whats_returned = TREE_OPERAND (whats_returned, 0);\n+\t\t  warning (\"returning reference to temporary\");\n+\t\t}\n+\t    }\n+\n+\t  if (TREE_CODE (whats_returned) == VAR_DECL && DECL_NAME (whats_returned))\n+\t    {\n+\t      if (TEMP_NAME_P (DECL_NAME (whats_returned)))\n+\t\twarning (\"reference to non-lvalue returned\");\n+\t      else if (! TREE_STATIC (whats_returned)\n+\t\t       && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n+\t\t       && !TREE_PUBLIC (whats_returned))\n+\t\tcp_warning_at (\"reference to local variable `%D' returned\", whats_returned);\n+\t    }\n+\t}\n+      else if (TREE_CODE (retval) == ADDR_EXPR)\n+\t{\n+\t  tree whats_returned = TREE_OPERAND (retval, 0);\n+\n+\t  if (TREE_CODE (whats_returned) == VAR_DECL\n+\t      && DECL_NAME (whats_returned)\n+\t      && IDENTIFIER_LOCAL_VALUE (DECL_NAME (whats_returned))\n+\t      && !TREE_STATIC (whats_returned)\n+\t      && !TREE_PUBLIC (whats_returned))\n+\t    cp_warning_at (\"address of local variable `%D' returned\", whats_returned);\n+\t}\n     }\n \n   if (retval != NULL_TREE"}]}