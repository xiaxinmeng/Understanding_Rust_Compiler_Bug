{"sha": "3c3279fb5816565b149d1b06eb489114c4473d09", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2MzMjc5ZmI1ODE2NTY1YjE0OWQxYjA2ZWI0ODkxMTRjNDQ3M2QwOQ==", "commit": {"author": {"name": "Richard Earnshaw", "email": "rearnsha@arm.com", "date": "2013-03-11T11:48:34Z"}, "committer": {"name": "Richard Earnshaw", "email": "rearnsha@gcc.gnu.org", "date": "2013-03-11T11:48:34Z"}, "message": "re PR target/56470 (ICE output_operand: invalid shift operand)\n\n\tPR target/56470\n\t* arm.c (shift_op): Validate RTL pattern on the fly.\n\t(arm_print_operand, case 'S'): Don't use shift_operator to validate\n\tthe RTL.\n\nFrom-SVN: r196595", "tree": {"sha": "178fb59e89fbf75745000cba0fd09e9b6d1ad098", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/178fb59e89fbf75745000cba0fd09e9b6d1ad098"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3c3279fb5816565b149d1b06eb489114c4473d09", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3279fb5816565b149d1b06eb489114c4473d09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3c3279fb5816565b149d1b06eb489114c4473d09", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3c3279fb5816565b149d1b06eb489114c4473d09/comments", "author": null, "committer": null, "parents": [{"sha": "6be8b5f77c49e29195349e1d36a0ab75a0c80e9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6be8b5f77c49e29195349e1d36a0ab75a0c80e9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6be8b5f77c49e29195349e1d36a0ab75a0c80e9f"}], "stats": {"total": 113, "additions": 65, "deletions": 48}, "files": [{"sha": "54dd64c7059a3fefacf958d9b793c73b76f0a32c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3279fb5816565b149d1b06eb489114c4473d09/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3279fb5816565b149d1b06eb489114c4473d09/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3c3279fb5816565b149d1b06eb489114c4473d09", "patch": "@@ -1,3 +1,10 @@\n+2013-03-11  Richard Earnshaw  <rearnsha@arm.com>\n+\n+\tPR target/56470\n+\t* arm.c (shift_op): Validate RTL pattern on the fly.\n+\t(arm_print_operand, case 'S'): Don't use shift_operator to validate\n+\tthe RTL.\n+\n 2013-03-10  John David Anglin  <dave.anglin@nrc-cnrc.gc.ca>\n \n \tPR target/56347"}, {"sha": "ca367608c96c81ca4c7e0145bbf4ab40ad70206e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 58, "deletions": 48, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3c3279fb5816565b149d1b06eb489114c4473d09/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3c3279fb5816565b149d1b06eb489114c4473d09/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=3c3279fb5816565b149d1b06eb489114c4473d09", "patch": "@@ -15430,72 +15430,88 @@ shift_op (rtx op, HOST_WIDE_INT *amountp)\n   const char * mnem;\n   enum rtx_code code = GET_CODE (op);\n \n-  switch (GET_CODE (XEXP (op, 1)))\n-    {\n-    case REG:\n-    case SUBREG:\n-      *amountp = -1;\n-      break;\n-\n-    case CONST_INT:\n-      *amountp = INTVAL (XEXP (op, 1));\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n   switch (code)\n     {\n     case ROTATE:\n-      gcc_assert (*amountp != -1);\n-      *amountp = 32 - *amountp;\n-      code = ROTATERT;\n+      if (!CONST_INT_P (XEXP (op, 1)))\n+\t{\n+\t  output_operand_lossage (\"invalid shift operand\");\n+\t  return NULL;\n+\t}\n \n-      /* Fall through.  */\n+      code = ROTATERT;\n+      *amountp = 32 - INTVAL (XEXP (op, 1));\n+      mnem = \"ror\";\n+      break;\n \n     case ASHIFT:\n     case ASHIFTRT:\n     case LSHIFTRT:\n     case ROTATERT:\n       mnem = arm_shift_nmem(code);\n+      if (CONST_INT_P (XEXP (op, 1)))\n+\t{\n+\t  *amountp = INTVAL (XEXP (op, 1));\n+\t}\n+      else if (REG_P (XEXP (op, 1)))\n+\t{\n+\t  *amountp = -1;\n+\t  return mnem;\n+\t}\n+      else\n+\t{\n+\t  output_operand_lossage (\"invalid shift operand\");\n+\t  return NULL;\n+\t}\n       break;\n \n     case MULT:\n       /* We never have to worry about the amount being other than a\n \t power of 2, since this case can never be reloaded from a reg.  */\n-      gcc_assert (*amountp != -1);\n+      if (!CONST_INT_P (XEXP (op, 1)))\n+\t{\n+\t  output_operand_lossage (\"invalid shift operand\");\n+\t  return NULL;\n+\t}\n+\n+      *amountp = INTVAL (XEXP (op, 1)) & 0xFFFFFFFF;\n+\n+      /* Amount must be a power of two.  */\n+      if (*amountp & (*amountp - 1))\n+\t{\n+\t  output_operand_lossage (\"invalid shift operand\");\n+\t  return NULL;\n+\t}\n+\n       *amountp = int_log2 (*amountp);\n       return ARM_LSL_NAME;\n \n     default:\n-      gcc_unreachable ();\n+      output_operand_lossage (\"invalid shift operand\");\n+      return NULL;\n     }\n \n-  if (*amountp != -1)\n+  /* This is not 100% correct, but follows from the desire to merge\n+     multiplication by a power of 2 with the recognizer for a\n+     shift.  >=32 is not a valid shift for \"lsl\", so we must try and\n+     output a shift that produces the correct arithmetical result.\n+     Using lsr #32 is identical except for the fact that the carry bit\n+     is not set correctly if we set the flags; but we never use the\n+     carry bit from such an operation, so we can ignore that.  */\n+  if (code == ROTATERT)\n+    /* Rotate is just modulo 32.  */\n+    *amountp &= 31;\n+  else if (*amountp != (*amountp & 31))\n     {\n-      /* This is not 100% correct, but follows from the desire to merge\n-\t multiplication by a power of 2 with the recognizer for a\n-\t shift.  >=32 is not a valid shift for \"lsl\", so we must try and\n-\t output a shift that produces the correct arithmetical result.\n-\t Using lsr #32 is identical except for the fact that the carry bit\n-\t is not set correctly if we set the flags; but we never use the\n-\t carry bit from such an operation, so we can ignore that.  */\n-      if (code == ROTATERT)\n-\t/* Rotate is just modulo 32.  */\n-\t*amountp &= 31;\n-      else if (*amountp != (*amountp & 31))\n-\t{\n-\t  if (code == ASHIFT)\n-\t    mnem = \"lsr\";\n-\t  *amountp = 32;\n-\t}\n-\n-      /* Shifts of 0 are no-ops.  */\n-      if (*amountp == 0)\n-\treturn NULL;\n+      if (code == ASHIFT)\n+\tmnem = \"lsr\";\n+      *amountp = 32;\n     }\n \n+  /* Shifts of 0 are no-ops.  */\n+  if (*amountp == 0)\n+    return NULL;\n+\n   return mnem;\n }\n \n@@ -17743,12 +17759,6 @@ arm_print_operand (FILE *stream, rtx x, int code)\n \tHOST_WIDE_INT val;\n \tconst char *shift;\n \n-\tif (!shift_operator (x, SImode))\n-\t  {\n-\t    output_operand_lossage (\"invalid shift operand\");\n-\t    break;\n-\t  }\n-\n \tshift = shift_op (x, &val);\n \n \tif (shift)"}]}