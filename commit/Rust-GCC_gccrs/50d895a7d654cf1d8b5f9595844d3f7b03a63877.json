{"sha": "50d895a7d654cf1d8b5f9595844d3f7b03a63877", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTBkODk1YTdkNjU0Y2YxZDhiNWY5NTk1ODQ0ZDNmN2IwM2E2Mzg3Nw==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2004-10-28T14:41:05Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2004-10-28T14:41:05Z"}, "message": "* tree-phinodes.c: Remove trailing whitespace.\n\nFrom-SVN: r89760", "tree": {"sha": "e31f2e2322878986ee81ee0662905d8eb2e03b67", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e31f2e2322878986ee81ee0662905d8eb2e03b67"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/50d895a7d654cf1d8b5f9595844d3f7b03a63877", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d895a7d654cf1d8b5f9595844d3f7b03a63877", "html_url": "https://github.com/Rust-GCC/gccrs/commit/50d895a7d654cf1d8b5f9595844d3f7b03a63877", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/50d895a7d654cf1d8b5f9595844d3f7b03a63877/comments", "author": null, "committer": null, "parents": [{"sha": "1c170b5eba160dbdb474f2471af25437c88c5e50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1c170b5eba160dbdb474f2471af25437c88c5e50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1c170b5eba160dbdb474f2471af25437c88c5e50"}], "stats": {"total": 30, "additions": 17, "deletions": 13}, "files": [{"sha": "ac658b495af123a5a09db8e0831bce79901f7fd8", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d895a7d654cf1d8b5f9595844d3f7b03a63877/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d895a7d654cf1d8b5f9595844d3f7b03a63877/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=50d895a7d654cf1d8b5f9595844d3f7b03a63877", "patch": "@@ -1,3 +1,7 @@\n+2004-10-28  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-phinodes.c: Remove trailing whitespace.\n+\n 2004-10-28  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* tree-ssa-loop-ivopts.c: Fix a comment typo."}, {"sha": "fdeb57a45a17358151091f15ac3b6d6e8d1e58f9", "filename": "gcc/tree-phinodes.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/50d895a7d654cf1d8b5f9595844d3f7b03a63877/gcc%2Ftree-phinodes.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/50d895a7d654cf1d8b5f9595844d3f7b03a63877/gcc%2Ftree-phinodes.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-phinodes.c?ref=50d895a7d654cf1d8b5f9595844d3f7b03a63877", "patch": "@@ -1,23 +1,23 @@\n /* Generic routines for manipulating PHIs\n    Copyright (C) 2003 Free Software Foundation, Inc.\n-                                                                                \n+\n This file is part of GCC.\n-                                                                                \n+\n GCC is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n-                                                                                \n+\n GCC is distributed in the hope that it will be useful,\n but WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n GNU General Public License for more details.\n-                                                                                \n+\n You should have received a copy of the GNU General Public License\n along with GCC; see the file COPYING.  If not, write to\n the Free Software Foundation, 59 Temple Place - Suite 330,\n Boston, MA 02111-1307, USA.  */\n-                                                                                \n+\n #include \"config.h\"\n #include \"system.h\"\n #include \"coretypes.h\"\n@@ -32,7 +32,7 @@ Boston, MA 02111-1307, USA.  */\n \n /* Rewriting a function into SSA form can create a huge number of PHIs\n    many of which may be thrown away shortly after their creation if jumps\n-   were threaded through PHI nodes.  \n+   were threaded through PHI nodes.\n \n    While our garbage collection mechanisms will handle this situation, it\n    is extremely wasteful to create nodes and throw them away, especially\n@@ -46,12 +46,12 @@ Boston, MA 02111-1307, USA.  */\n \n    Right now we maintain our free list on a per-function basis.  It may\n    or may not make sense to maintain the free list for the duration of\n-   a compilation unit. \n+   a compilation unit.\n \n    We could also use a zone allocator for these objects since they have\n    a very well defined lifetime.  If someone wants to experiment with that\n    this is the place to try it.\n-   \n+\n    PHI nodes have different sizes, so we can't have a single list of all\n    the PHI nodes as it would be too expensive to walk down that list to\n    find a PHI of a suitable size.\n@@ -71,7 +71,7 @@ Boston, MA 02111-1307, USA.  */\n    be very expensive if the program has released a bunch of large PHI nodes,\n    but keeps asking for even larger PHI nodes.  Experiments have shown that\n    walking the elements of the last array entry would result in finding less\n-   than .1% additional reusable PHI nodes. \n+   than .1% additional reusable PHI nodes.\n \n    Note that we can never have less than two PHI argument slots.  Thus,\n    the -2 on all the calculations below.  */\n@@ -149,8 +149,8 @@ ideal_phi_node_len (int len)\n   /* Round it up to the next power of two.  */\n   log2 = ceil_log2 (size);\n   new_size = 1 << log2;\n-  \n-  /* Now compute and return the number of PHI argument slots given an \n+\n+  /* Now compute and return the number of PHI argument slots given an\n      ideal size allocation.  */\n   new_len = len + (new_size - size) / sizeof (struct phi_arg_d);\n   return new_len;\n@@ -228,7 +228,7 @@ release_phi_node (tree phi)\n \n /* Resize an existing PHI node.  The only way is up.  Return the\n    possibly relocated phi.  */\n-                                                                                \n+\n static void\n resize_phi_node (tree *phi, int len)\n {\n@@ -273,7 +273,7 @@ resize_phi_node (tree *phi, int len)\n \n   old_len = PHI_ARG_CAPACITY (new_phi);\n   PHI_ARG_CAPACITY (new_phi) = len;\n-                                                                                \n+\n   for (i = old_len; i < len; i++)\n     {\n       SET_PHI_ARG_DEF (new_phi, i, NULL_TREE);"}]}