{"sha": "b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yjk2MGU5MDlhZTE3NDViMGY5YjliY2I2ZjJkNWJlYzkxYmJmYmQ3Yg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-10-18T11:47:51Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-10-18T11:47:51Z"}, "message": "i386.c (ix86_vec_cost): Remove !parallel path and argument.\n\n2018-10-18  Richard Biener  <rguenther@suse.de>\n\n\t* config/i386/i386.c (ix86_vec_cost): Remove !parallel path\n\tand argument.\n\t(ix86_builtin_vectorization_cost): For vec_construct properly\n\tcost insertion into SSE regs.\n\t(...): Adjust calls to ix86_vec_cost.\n\nFrom-SVN: r265265", "tree": {"sha": "5aa7ab7ee89b872a9aa4ce500dbc3e2974b077b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5aa7ab7ee89b872a9aa4ce500dbc3e2974b077b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "75cdd535b1a47abdfc60a2950367fd4de7fae8ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75cdd535b1a47abdfc60a2950367fd4de7fae8ab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75cdd535b1a47abdfc60a2950367fd4de7fae8ab"}], "stats": {"total": 122, "additions": 53, "deletions": 69}, "files": [{"sha": "65b49e245ec7cbb6d51f526b3410b14c165cc527", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "patch": "@@ -1,3 +1,11 @@\n+2018-10-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* config/i386/i386.c (ix86_vec_cost): Remove !parallel path\n+\tand argument.\n+\t(ix86_builtin_vectorization_cost): For vec_construct properly\n+\tcost insertion into SSE regs.\n+\t(...): Adjust calls to ix86_vec_cost.\n+\n 2018-10-18  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/87087"}, {"sha": "bada12ccd1622336991b149e9fd92a8a7421da05", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 45, "deletions": 69, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=b960e909ae1745b0f9b9bcb6f2d5bec91bbfbd7b", "patch": "@@ -39840,17 +39840,14 @@ ix86_set_reg_reg_cost (machine_mode mode)\n }\n \n /* Return cost of vector operation in MODE given that scalar version has\n-   COST.  If PARALLEL is true assume that CPU has more than one unit\n-   performing the operation.  */\n+   COST.  */\n \n static int\n-ix86_vec_cost (machine_mode mode, int cost, bool parallel)\n+ix86_vec_cost (machine_mode mode, int cost)\n {\n   if (!VECTOR_MODE_P (mode))\n     return cost;\n- \n-  if (!parallel)\n-    return cost * GET_MODE_NUNITS (mode);\n+\n   if (GET_MODE_BITSIZE (mode) == 128\n       && TARGET_SSE_SPLIT_REGS)\n     return cost * 2;\n@@ -39876,13 +39873,12 @@ ix86_multiplication_cost (const struct processor_costs *cost,\n     return cost->fmul;\n   else if (FLOAT_MODE_P (mode))\n     return  ix86_vec_cost (mode,\n-\t\t\t   inner_mode == DFmode\n-\t\t\t   ? cost->mulsd : cost->mulss, true);\n+\t\t\t   inner_mode == DFmode ? cost->mulsd : cost->mulss);\n   else if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n     {\n       /* vpmullq is used in this case. No emulation is needed.  */\n       if (TARGET_AVX512DQ)\n-\treturn ix86_vec_cost (mode, cost->mulss, true);\n+\treturn ix86_vec_cost (mode, cost->mulss);\n \n       /* V*QImode is emulated with 7-13 insns.  */\n       if (mode == V16QImode || mode == V32QImode)\n@@ -39892,29 +39888,22 @@ ix86_multiplication_cost (const struct processor_costs *cost,\n \t    extra = 5;\n \t  else if (TARGET_SSSE3)\n \t    extra = 6;\n-\t  return ix86_vec_cost (mode,\n-\t\t\t\tcost->mulss * 2 + cost->sse_op * extra,\n-\t\t\t\ttrue);\n+\t  return ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * extra);\n \t}\n       /* V*DImode is emulated with 5-8 insns.  */\n       else if (mode == V2DImode || mode == V4DImode)\n \t{\n \t  if (TARGET_XOP && mode == V2DImode)\n-\t    return ix86_vec_cost (mode,\n-\t\t\t\t  cost->mulss * 2 + cost->sse_op * 3,\n-\t\t\t\t  true);\n+\t    return ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 3);\n \t  else\n-\t    return ix86_vec_cost (mode,\n-\t\t\t\t  cost->mulss * 3 + cost->sse_op * 5,\n-\t\t\t\t  true);\n+\t    return ix86_vec_cost (mode, cost->mulss * 3 + cost->sse_op * 5);\n \t}\n       /* Without sse4.1, we don't have PMULLD; it's emulated with 7\n \t insns, including two PMULUDQ.  */\n       else if (mode == V4SImode && !(TARGET_SSE4_1 || TARGET_AVX))\n-\treturn ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 5,\n-\t\t\t\ttrue);\n+\treturn ix86_vec_cost (mode, cost->mulss * 2 + cost->sse_op * 5);\n       else\n-\treturn ix86_vec_cost (mode, cost->mulss, true);\n+\treturn ix86_vec_cost (mode, cost->mulss);\n     }\n   else\n     return (cost->mult_init[MODE_INDEX (mode)] + cost->mult_bit * 7);\n@@ -39936,8 +39925,7 @@ ix86_division_cost (const struct processor_costs *cost,\n     return cost->fdiv;\n   else if (FLOAT_MODE_P (mode))\n     return ix86_vec_cost (mode,\n-\t\t\t    inner_mode == DFmode ? cost->divsd : cost->divss,\n-\t\t\t    true);\n+\t\t\t  inner_mode == DFmode ? cost->divsd : cost->divss);\n   else\n     return cost->divide[MODE_INDEX (mode)];\n }\n@@ -39977,20 +39965,20 @@ ix86_shift_rotate_cost (const struct processor_costs *cost,\n \t\t  if (skip_op1)\n \t\t    *skip_op1 = true;\n \t\t  return ix86_vec_cost (mode,\n-\t\t\t    cost->sse_op\n-\t\t\t    + (speed\n-\t\t\t       ? 2\n-\t\t\t       : COSTS_N_BYTES\n-\t\t\t\t (GET_MODE_UNIT_SIZE (mode))), true);\n+\t\t\t\t\tcost->sse_op\n+\t\t\t\t\t+ (speed\n+\t\t\t\t\t   ? 2\n+\t\t\t\t\t   : COSTS_N_BYTES\n+\t\t\t\t\t       (GET_MODE_UNIT_SIZE (mode))));\n \t\t}\n \t      count = 3;\n \t    }\n \t  else if (TARGET_SSSE3)\n \t    count = 7;\n-\t  return ix86_vec_cost (mode, cost->sse_op * count, true);\n+\t  return ix86_vec_cost (mode, cost->sse_op * count);\n \t}\n       else\n-\treturn ix86_vec_cost (mode, cost->sse_op, true);\n+\treturn ix86_vec_cost (mode, cost->sse_op);\n     }\n   if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n     {\n@@ -40183,8 +40171,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n         gcc_assert (TARGET_FMA || TARGET_FMA4 || TARGET_AVX512F);\n \n         *total = ix86_vec_cost (mode,\n-\t\t\t\tmode == SFmode ? cost->fmass : cost->fmasd,\n-\t\t\t\ttrue);\n+\t\t\t\tmode == SFmode ? cost->fmass : cost->fmasd);\n \t*total += rtx_cost (XEXP (x, 1), mode, FMA, 1, speed);\n \n         /* Negate in op0 or op2 is free: FMS, FNMA, FNMS.  */\n@@ -40340,7 +40327,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n-\t  *total = ix86_vec_cost (mode, cost->addss, true);\n+\t  *total = ix86_vec_cost (mode, cost->addss);\n \t  return false;\n \t}\n       /* FALLTHRU */\n@@ -40373,14 +40360,14 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t}\n       else if (FLOAT_MODE_P (mode))\n \t{\n-\t  *total = ix86_vec_cost (mode, cost->sse_op, true);\n+\t  *total = ix86_vec_cost (mode, cost->sse_op);\n \t  return false;\n \t}\n       /* FALLTHRU */\n \n     case NOT:\n       if (GET_MODE_CLASS (mode) == MODE_VECTOR_INT)\n-\t*total = ix86_vec_cost (mode, cost->sse_op, true);\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n       else if (GET_MODE_SIZE (mode) > UNITS_PER_WORD)\n \t*total = cost->add * 2;\n       else\n@@ -40414,14 +40401,14 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       if (!(SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH))\n \t*total = 0;\n       else\n-        *total = ix86_vec_cost (mode, cost->addss, true);\n+        *total = ix86_vec_cost (mode, cost->addss);\n       return false;\n \n     case FLOAT_TRUNCATE:\n       if (!(SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH))\n \t*total = cost->fadd;\n       else\n-        *total = ix86_vec_cost (mode, cost->addss, true);\n+        *total = ix86_vec_cost (mode, cost->addss);\n       return false;\n \n     case ABS:\n@@ -40433,7 +40420,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n       else if (X87_FLOAT_MODE_P (mode))\n \t*total = cost->fabs;\n       else if (FLOAT_MODE_P (mode))\n-\t*total = ix86_vec_cost (mode, cost->sse_op, true);\n+\t*total = ix86_vec_cost (mode, cost->sse_op);\n       return false;\n \n     case SQRT:\n@@ -40443,8 +40430,7 @@ ix86_rtx_costs (rtx x, machine_mode mode, int outer_code_i, int opno,\n \t*total = cost->fsqrt;\n       else if (FLOAT_MODE_P (mode))\n \t*total = ix86_vec_cost (mode,\n-\t\t\t\tmode == SFmode ? cost->sqrtss : cost->sqrtsd,\n-\t\t\t\ttrue);\n+\t\t\t\tmode == SFmode ? cost->sqrtss : cost->sqrtsd);\n       return false;\n \n     case UNSPEC:\n@@ -45114,30 +45100,27 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \n       case vector_stmt:\n         return ix86_vec_cost (mode,\n-\t\t\t      fp ? ix86_cost->addss : ix86_cost->sse_op,\n-\t\t\t      true);\n+\t\t\t      fp ? ix86_cost->addss : ix86_cost->sse_op);\n \n       case vector_load:\n \tindex = sse_store_index (mode);\n \t/* See PR82713 - we may end up being called on non-vector type.  */\n \tif (index < 0)\n \t  index = 2;\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_load[index]) / 2,\n-\t\t\t      true);\n+\t\t\t      COSTS_N_INSNS (ix86_cost->sse_load[index]) / 2);\n \n       case vector_store:\n \tindex = sse_store_index (mode);\n \t/* See PR82713 - we may end up being called on non-vector type.  */\n \tif (index < 0)\n \t  index = 2;\n         return ix86_vec_cost (mode,\n-\t\t\t      COSTS_N_INSNS (ix86_cost->sse_store[index]) / 2,\n-\t\t\t      true);\n+\t\t\t      COSTS_N_INSNS (ix86_cost->sse_store[index]) / 2);\n \n       case vec_to_scalar:\n       case scalar_to_vec:\n-        return ix86_vec_cost (mode, ix86_cost->sse_op, true);\n+        return ix86_vec_cost (mode, ix86_cost->sse_op);\n \n       /* We should have separate costs for unaligned loads and gather/scatter.\n \t Do that incrementally.  */\n@@ -45148,8 +45131,7 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \t  index = 2;\n         return ix86_vec_cost (mode,\n \t\t\t      COSTS_N_INSNS\n-\t\t\t\t (ix86_cost->sse_unaligned_load[index]) / 2,\n-\t\t\t      true);\n+\t\t\t\t (ix86_cost->sse_unaligned_load[index]) / 2);\n \n       case unaligned_store:\n \tindex = sse_store_index (mode);\n@@ -45158,24 +45140,21 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \t  index = 2;\n         return ix86_vec_cost (mode,\n \t\t\t      COSTS_N_INSNS\n-\t\t\t\t (ix86_cost->sse_unaligned_store[index]) / 2,\n-\t\t\t      true);\n+\t\t\t\t (ix86_cost->sse_unaligned_store[index]) / 2);\n \n       case vector_gather_load:\n         return ix86_vec_cost (mode,\n \t\t\t      COSTS_N_INSNS\n \t\t\t\t (ix86_cost->gather_static\n \t\t\t\t  + ix86_cost->gather_per_elt\n-\t\t\t\t    * TYPE_VECTOR_SUBPARTS (vectype)) / 2,\n-\t\t\t      true);\n+\t\t\t\t    * TYPE_VECTOR_SUBPARTS (vectype)) / 2);\n \n       case vector_scatter_store:\n         return ix86_vec_cost (mode,\n \t\t\t      COSTS_N_INSNS\n \t\t\t\t (ix86_cost->scatter_static\n \t\t\t\t  + ix86_cost->scatter_per_elt\n-\t\t\t\t    * TYPE_VECTOR_SUBPARTS (vectype)) / 2,\n-\t\t\t      true);\n+\t\t\t\t    * TYPE_VECTOR_SUBPARTS (vectype)) / 2);\n \n       case cond_branch_taken:\n         return ix86_cost->cond_taken_branch_cost;\n@@ -45185,20 +45164,20 @@ ix86_builtin_vectorization_cost (enum vect_cost_for_stmt type_of_cost,\n \n       case vec_perm:\n       case vec_promote_demote:\n-        return ix86_vec_cost (mode,\n-\t\t\t      ix86_cost->sse_op, true);\n+        return ix86_vec_cost (mode, ix86_cost->sse_op);\n \n       case vec_construct:\n \t{\n-\t  /* N element inserts.  */\n-\t  int cost = ix86_vec_cost (mode, ix86_cost->sse_op, false);\n+\t  gcc_assert (VECTOR_MODE_P (mode));\n+\t  /* N element inserts into SSE vectors.  */\n+\t  int cost = GET_MODE_NUNITS (mode) * ix86_cost->sse_op;\n \t  /* One vinserti128 for combining two SSE vectors for AVX256.  */\n \t  if (GET_MODE_BITSIZE (mode) == 256)\n-\t    cost += ix86_vec_cost (mode, ix86_cost->addss, true);\n+\t    cost += ix86_vec_cost (mode, ix86_cost->addss);\n \t  /* One vinserti64x4 and two vinserti128 for combining SSE\n \t     and AVX256 vectors to AVX512.  */\n \t  else if (GET_MODE_BITSIZE (mode) == 512)\n-\t    cost += 3 * ix86_vec_cost (mode, ix86_cost->addss, true);\n+\t    cost += 3 * ix86_vec_cost (mode, ix86_cost->addss);\n \t  return cost;\n \t}\n \n@@ -49519,10 +49498,8 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t        stmt_cost = ix86_cost->add;\n \t    }\n \t  else\n-\t    stmt_cost = ix86_vec_cost (mode,\n-\t\t\t\t       fp ? ix86_cost->addss\n-\t\t\t\t       : ix86_cost->sse_op,\n-\t\t\t\t       true);\n+\t    stmt_cost = ix86_vec_cost (mode, fp ? ix86_cost->addss\n+\t\t\t\t       : ix86_cost->sse_op);\n \t  break;\n \n \tcase MULT_EXPR:\n@@ -49536,7 +49513,7 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t  else if (X87_FLOAT_MODE_P (mode))\n \t    stmt_cost = ix86_cost->fchs;\n \t  else if (VECTOR_MODE_P (mode))\n-\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op, true);\n+\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op);\n \t  else\n \t    stmt_cost = ix86_cost->add;\n \t  break;\n@@ -49585,7 +49562,7 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n \t  if (SSE_FLOAT_MODE_P (mode) && TARGET_SSE_MATH)\n \t    stmt_cost = ix86_cost->sse_op;\n \t  else if (VECTOR_MODE_P (mode))\n-\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op, true);\n+\t    stmt_cost = ix86_vec_cost (mode, ix86_cost->sse_op);\n \t  else\n \t    stmt_cost = ix86_cost->add;\n \t  break;\n@@ -49604,8 +49581,7 @@ ix86_add_stmt_cost (void *data, int count, enum vect_cost_for_stmt kind,\n       case CFN_FMA:\n \tstmt_cost = ix86_vec_cost (mode,\n \t\t\t\t   mode == SFmode ? ix86_cost->fmass\n-\t\t\t\t   : ix86_cost->fmasd,\n-\t\t\t\t   true);\n+\t\t\t\t   : ix86_cost->fmasd);\n \tbreak;\n       default:\n \tbreak;"}]}