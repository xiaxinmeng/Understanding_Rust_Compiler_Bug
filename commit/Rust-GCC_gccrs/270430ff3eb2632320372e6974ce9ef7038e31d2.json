{"sha": "270430ff3eb2632320372e6974ce9ef7038e31d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjcwNDMwZmYzZWIyNjMyMzIwMzcyZTY5NzRjZTllZjcwMzhlMzFkMg==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2016-07-27T14:31:30Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2016-07-27T14:31:30Z"}, "message": "PR c++/71747 - ICE with self-referential partial spec\n\n\t* pt.c (get_partial_spec_bindings): Replace tparms and spec_args\n\tparameters with spec_tmpl.  Call push_tinst_level.\n\t(most_specialized_partial_spec): Adjust.\n\t(more_specialized_partial_spec): Adjust.\n\nFrom-SVN: r238785", "tree": {"sha": "a1799237fa9426cb2869bdb2fc49a23d865b5afa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a1799237fa9426cb2869bdb2fc49a23d865b5afa"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/270430ff3eb2632320372e6974ce9ef7038e31d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/270430ff3eb2632320372e6974ce9ef7038e31d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/270430ff3eb2632320372e6974ce9ef7038e31d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/270430ff3eb2632320372e6974ce9ef7038e31d2/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8de22ea0b15dbfdb61461d8732b05c9ce9ce0f48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8de22ea0b15dbfdb61461d8732b05c9ce9ce0f48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8de22ea0b15dbfdb61461d8732b05c9ce9ce0f48"}], "stats": {"total": 105, "additions": 61, "deletions": 44}, "files": [{"sha": "99c7c28d0a11e90f0f9d167e66e17d3342633a83", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=270430ff3eb2632320372e6974ce9ef7038e31d2", "patch": "@@ -1,3 +1,11 @@\n+2016-07-27  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/71747\n+\t* pt.c (get_partial_spec_bindings): Replace tparms and spec_args\n+\tparameters with spec_tmpl.  Call push_tinst_level.\n+\t(most_specialized_partial_spec): Adjust.\n+\t(more_specialized_partial_spec): Adjust.\n+\n 2016-07-25  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/65970"}, {"sha": "a23a05aff35ed591fa168b17940bb119502dee8c", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 25, "deletions": 40, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=270430ff3eb2632320372e6974ce9ef7038e31d2", "patch": "@@ -140,7 +140,7 @@ static int unify (tree, tree, tree, tree, int, bool);\n static void add_pending_template (tree);\n static tree reopen_tinst_level (struct tinst_level *);\n static tree tsubst_initializer_list (tree, tree);\n-static tree get_partial_spec_bindings (tree, tree, tree, tree);\n+static tree get_partial_spec_bindings (tree, tree, tree);\n static tree coerce_template_parms (tree, tree, tree, tsubst_flags_t,\n \t\t\t\t   bool, bool);\n static tree coerce_innermost_template_parms (tree, tree, tree, tsubst_flags_t,\n@@ -20689,8 +20689,6 @@ more_specialized_partial_spec (tree tmpl, tree pat1, tree pat2)\n \n   tree tmpl1 = TREE_VALUE (pat1);\n   tree tmpl2 = TREE_VALUE (pat2);\n-  tree parms1 = DECL_INNERMOST_TEMPLATE_PARMS (tmpl1);\n-  tree parms2 = DECL_INNERMOST_TEMPLATE_PARMS (tmpl2);\n   tree specargs1 = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (tmpl1)));\n   tree specargs2 = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (tmpl2)));\n \n@@ -20699,14 +20697,14 @@ more_specialized_partial_spec (tree tmpl, tree pat1, tree pat2)\n      types in the arguments, and we need our dependency check functions\n      to behave correctly.  */\n   ++processing_template_decl;\n-  targs = get_partial_spec_bindings (tmpl, parms1, specargs1, specargs2);\n+  targs = get_partial_spec_bindings (tmpl, tmpl1, specargs2);\n   if (targs)\n     {\n       --winner;\n       any_deductions = true;\n     }\n \n-  targs = get_partial_spec_bindings (tmpl, parms2, specargs2, specargs1);\n+  targs = get_partial_spec_bindings (tmpl, tmpl2, specargs1);\n   if (targs)\n     {\n       ++winner;\n@@ -20790,23 +20788,23 @@ get_bindings (tree fn, tree decl, tree explicit_args, bool check_rettype)\n }\n \n /* Return the innermost template arguments that, when applied to a partial\n-   specialization of TMPL whose innermost template parameters are\n-   TPARMS, and whose specialization arguments are SPEC_ARGS, yield the\n-   ARGS.\n+   specialization SPEC_TMPL of TMPL, yield the ARGS.\n \n    For example, suppose we have:\n \n      template <class T, class U> struct S {};\n      template <class T> struct S<T*, int> {};\n \n-   Then, suppose we want to get `S<double*, int>'.  The TPARMS will be\n-   {T}, the SPEC_ARGS will be {T*, int} and the ARGS will be {double*,\n-   int}.  The resulting vector will be {double}, indicating that `T'\n-   is bound to `double'.  */\n+   Then, suppose we want to get `S<double*, int>'.  SPEC_TMPL will be the\n+   partial specialization and the ARGS will be {double*, int}.  The resulting\n+   vector will be {double}, indicating that `T' is bound to `double'.  */\n \n static tree\n-get_partial_spec_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n+get_partial_spec_bindings (tree tmpl, tree spec_tmpl, tree args)\n {\n+  tree tparms = DECL_INNERMOST_TEMPLATE_PARMS (spec_tmpl);\n+  tree spec_args\n+    = TI_ARGS (get_template_info (DECL_TEMPLATE_RESULT (spec_tmpl)));\n   int i, ntparms = TREE_VEC_LENGTH (tparms);\n   tree deduced_args;\n   tree innermost_deduced_args;\n@@ -20832,6 +20830,13 @@ get_partial_spec_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n     if (! TREE_VEC_ELT (innermost_deduced_args, i))\n       return NULL_TREE;\n \n+  tree tinst = build_tree_list (spec_tmpl, deduced_args);\n+  if (!push_tinst_level (tinst))\n+    {\n+      excessive_deduction_depth = true;\n+      return NULL_TREE;\n+    }\n+\n   /* Verify that nondeduced template arguments agree with the type\n      obtained from argument deduction.\n \n@@ -20848,6 +20853,9 @@ get_partial_spec_bindings (tree tmpl, tree tparms, tree spec_args, tree args)\n   spec_args = coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n \t\t\t\t     spec_args, tmpl,\n \t\t\t\t     tf_none, false, false);\n+\n+  pop_tinst_level ();\n+\n   if (spec_args == error_mark_node\n       /* We only need to check the innermost arguments; the other\n \t arguments will always agree.  */\n@@ -21057,44 +21065,21 @@ most_specialized_partial_spec (tree target, tsubst_flags_t complain)\n \n   for (t = DECL_TEMPLATE_SPECIALIZATIONS (main_tmpl); t; t = TREE_CHAIN (t))\n     {\n-      tree partial_spec_args;\n       tree spec_args;\n       tree spec_tmpl = TREE_VALUE (t);\n \n-      partial_spec_args = TREE_PURPOSE (t);\n-\n-      ++processing_template_decl;\n-\n       if (outer_args)\n \t{\n-\t  /* Discard the outer levels of args, and then substitute in the\n-\t     template args from the enclosing class.  */\n-\t  partial_spec_args = INNERMOST_TEMPLATE_ARGS (partial_spec_args);\n-\t  partial_spec_args = tsubst_template_args\n-\t    (partial_spec_args, outer_args, tf_none, NULL_TREE);\n-\n-\t  /* And the same for the partial specialization TEMPLATE_DECL.  */\n+\t  /* Substitute in the template args from the enclosing class.  */\n+\t  ++processing_template_decl;\n \t  spec_tmpl = tsubst (spec_tmpl, outer_args, tf_none, NULL_TREE);\n+\t  --processing_template_decl;\n \t}\n \n-      partial_spec_args =\n-\t  coerce_template_parms (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n-\t\t\t\t partial_spec_args,\n-\t\t\t\t tmpl, tf_none,\n-\t\t\t\t /*require_all_args=*/true,\n-\t\t\t\t /*use_default_args=*/true);\n-\n-      --processing_template_decl;\n-\n-      if (partial_spec_args == error_mark_node)\n-\treturn error_mark_node;\n       if (spec_tmpl == error_mark_node)\n \treturn error_mark_node;\n \n-      tree parms = DECL_INNERMOST_TEMPLATE_PARMS (spec_tmpl);\n-      spec_args = get_partial_spec_bindings (tmpl, parms,\n-\t\t\t\t      partial_spec_args,\n-\t\t\t\t      args);\n+      spec_args = get_partial_spec_bindings (tmpl, spec_tmpl, args);\n       if (spec_args)\n \t{\n \t  if (outer_args)"}, {"sha": "40e3075c162a804f9ed70ab75a4e242316a63799", "filename": "gcc/testsuite/g++.dg/cpp0x/initlist-template2.C", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-template2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-template2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finitlist-template2.C?ref=270430ff3eb2632320372e6974ce9ef7038e31d2", "patch": "@@ -0,0 +1,23 @@\n+// PR c++/71747\n+// { dg-do compile { target c++11 } }\n+// { dg-options -ftemplate-depth=20 }\n+\n+template < bool > struct A\n+{\n+  typedef int type; \n+  constexpr bool operator() () const \n+  { \n+    return true; \n+  }\n+}; \n+\n+template < bool, typename = int > struct F; \n+template < bool X > \n+// should be: struct F < X, typename A < A < X > {} () >::type > \n+struct F < X, typename A < F < X > {} () >::type > // { dg-error \"\" }\n+{\n+};\n+\n+F < true > f;\n+\n+// { dg-prune-output \"compilation terminated\" }"}, {"sha": "467dd827218ece1c30500e07c4e8cfae1ba0fce5", "filename": "gcc/testsuite/g++.dg/template/pr55843.C", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr55843.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/270430ff3eb2632320372e6974ce9ef7038e31d2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr55843.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fpr55843.C?ref=270430ff3eb2632320372e6974ce9ef7038e31d2", "patch": "@@ -7,21 +7,22 @@ template<bool b> struct if_c {\n };\n template< typename T > struct has_type {\n   struct gcc_3_2_wknd {\n-    template< typename U > static yes_tag test( type_wrapper<U> const volatile*\n+    template< typename U > static yes_tag test( type_wrapper<U> const volatile* // { dg-message \"required\" }\n , type_wrapper<typename U::type>* = 0 );\n   };\n   typedef type_wrapper<T> t_;\n-  static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) ==\n+  static const bool value = sizeof(gcc_3_2_wknd::test(static_cast<t_*>(0))) == // { dg-message \"required\" }\n sizeof(yes_tag);\n };\n template <class K, class T, class=void> struct Get_type {\n };\n struct FT_tag {};\n struct RT_tag {};\n template <class K> struct Get_type<K, RT_tag, typename if_c<\n-!has_type<Get_type<K, FT_tag> >::value >::type> { };\n+!has_type<Get_type<K, FT_tag> >::value >::type> { }; // { dg-message \"required\" }\n template <class K> struct Get_type<K, FT_tag, typename if_c<\n-!has_type<Get_type<K, RT_tag> >::value >::type> { };  // { dg-error \"depth\" }\n+!has_type<Get_type<K, RT_tag> >::value >::type> { };  // { dg-message \"required\" }\n typedef Get_type<int, FT_tag>::type P;\n \n+// { dg-prune-output \"-ftemplate-depth\" }\n // { dg-prune-output \"compilation terminated\" }"}]}