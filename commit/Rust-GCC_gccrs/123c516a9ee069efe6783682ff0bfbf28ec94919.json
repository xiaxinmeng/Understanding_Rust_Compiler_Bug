{"sha": "123c516a9ee069efe6783682ff0bfbf28ec94919", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTIzYzUxNmE5ZWUwNjllZmU2NzgzNjgyZmYwYmZiZjI4ZWM5NDkxOQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-04-13T22:52:45Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2011-04-13T22:52:45Z"}, "message": "[multiple changes]\n\n2011-04-13  Daniel Krugler  <daniel.kruegler@googlemail.com>\n\t    Paolo Carlini  <paolo.carlini@oracle.com>\n\n\tPR libstdc++/48526\n\t* include/std/type_traits (struct is_constructible): Re-implement,\n\taccording to n3290.\n\t(struct is_default_constructible): Add.\n\t(struct is_destructible): Likewise.\n\t(struct __and_, __or_, __not_): Add and use throughout; reorder some\n\tfacilities, other minor tweaks.\n\t* testsuite/util/testsuite_tr1.h: Add test types.\n\t* testsuite/20_util/is_constructible/value-2.cc: New.\n\t* testsuite/20_util/is_default_constructible/value.cc: Likewise.\n\t* testsuite/20_util/is_default_constructible/requirements/typedefs.cc:\n\tLikewise.\n\t* testsuite/20_util/is_default_constructible/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_destructible/value.cc: Likewise.\n\t* testsuite/20_util/is_destructible/requirements/typedefs.cc:\n\tLikewise.\n\t* testsuite/20_util/is_destructible/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n\tdg-error line numbers.\n\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n\tLikewise.\n\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n\t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Likewise.\n\n2011-04-13  Paolo Carlini  <paolo.carlini@oracle.com>\n\n\t* testsuite/20_util/is_function/value.cc: Add, adapted from the tr\n\ttestsuite. \n\t* testsuite/20_util/is_function/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_function/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_function/24808.cc: Likewise.\n\t* testsuite/20_util/is_function/35637.cc: Likewise.\n\t* testsuite/20_util/is_object/value.cc: Likewise.\n\t* testsuite/20_util/is_object/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_object/requirements/explicit_instantiation.cc:\n\t: Likewise.\n\t* testsuite/20_util/is_object/24808.cc: Likewise.\n\t* testsuite/20_util/is_compound/value.cc: Likewise.\n\t* testsuite/20_util/is_compound/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_compound/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_member_object_pointer/value.cc: Likewise.\n\t* testsuite/20_util/is_member_object_pointer/requirements/\n\ttypedefs.cc: Likewise.\n\t* testsuite/20_util/is_member_object_pointer/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_fundamental/value.cc: Likewise.\n\t* testsuite/20_util/is_fundamental/requirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_fundamental/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_member_pointer/value.cc: Likewise.\n\t* testsuite/20_util/is_member_pointer/requirements/typedefs.cc: \n\tLikewise.\n\t* testsuite/20_util/is_member_pointer/requirements/\n\texplicit_instantiation.cc: Likewise.\n\t* testsuite/20_util/is_member_function_pointer/value.cc: Likewise.\n\t* testsuite/20_util/is_member_function_pointer/\n\trequirements/typedefs.cc: Likewise.\n\t* testsuite/20_util/is_member_function_pointer/requirements/\n\texplicit_instantiation.cc: Likewise.\n\n\t* testsuite/20_util/is_convertible/value.cc: Minor tweak, adjust\n\tCopyright years.\n\nFrom-SVN: r172401", "tree": {"sha": "5a4f9736070be057d7313e737d830a11cbdf0322", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a4f9736070be057d7313e737d830a11cbdf0322"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/123c516a9ee069efe6783682ff0bfbf28ec94919", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123c516a9ee069efe6783682ff0bfbf28ec94919", "html_url": "https://github.com/Rust-GCC/gccrs/commit/123c516a9ee069efe6783682ff0bfbf28ec94919", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/123c516a9ee069efe6783682ff0bfbf28ec94919/comments", "author": null, "committer": null, "parents": [{"sha": "12e058247353df410663e56435aaa21735255921", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/12e058247353df410663e56435aaa21735255921", "html_url": "https://github.com/Rust-GCC/gccrs/commit/12e058247353df410663e56435aaa21735255921"}], "stats": {"total": 3562, "additions": 3122, "deletions": 440}, "files": [{"sha": "eb87a87ce4c6252ebbe8bf5d74995e390fa5d316", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -1,3 +1,73 @@\n+2011-04-13  Daniel Krugler  <daniel.kruegler@googlemail.com>\n+\t    Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\tPR libstdc++/48526\n+\t* include/std/type_traits (struct is_constructible): Re-implement,\n+\taccording to n3290.\n+\t(struct is_default_constructible): Add.\n+\t(struct is_destructible): Likewise.\n+\t(struct __and_, __or_, __not_): Add and use throughout; reorder some\n+\tfacilities, other minor tweaks.\n+\t* testsuite/util/testsuite_tr1.h: Add test types.\n+\t* testsuite/20_util/is_constructible/value-2.cc: New.\n+\t* testsuite/20_util/is_default_constructible/value.cc: Likewise.\n+\t* testsuite/20_util/is_default_constructible/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_default_constructible/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_destructible/value.cc: Likewise.\n+\t* testsuite/20_util/is_destructible/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_destructible/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/make_signed/requirements/typedefs_neg.cc: Adjust\n+\tdg-error line numbers.\n+\t* testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc:\n+\tLikewise.\n+\t* testsuite/20_util/declval/requirements/1_neg.cc: Likewise.\n+\t* testsuite/20_util/ratio/cons/cons_overflow_neg.cc: Likewise.\n+\n+2011-04-13  Paolo Carlini  <paolo.carlini@oracle.com>\n+\n+\t* testsuite/20_util/is_function/value.cc: Add, adapted from the tr\n+\ttestsuite.\n+\t* testsuite/20_util/is_function/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_function/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_function/24808.cc: Likewise.\n+\t* testsuite/20_util/is_function/35637.cc: Likewise.\n+\t* testsuite/20_util/is_object/value.cc: Likewise.\n+\t* testsuite/20_util/is_object/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_object/requirements/explicit_instantiation.cc:\n+\t: Likewise.\n+\t* testsuite/20_util/is_object/24808.cc: Likewise.\n+\t* testsuite/20_util/is_compound/value.cc: Likewise.\n+\t* testsuite/20_util/is_compound/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_compound/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_member_object_pointer/value.cc: Likewise.\n+\t* testsuite/20_util/is_member_object_pointer/requirements/\n+\ttypedefs.cc: Likewise.\n+\t* testsuite/20_util/is_member_object_pointer/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_fundamental/value.cc: Likewise.\n+\t* testsuite/20_util/is_fundamental/requirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_fundamental/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_member_pointer/value.cc: Likewise.\n+\t* testsuite/20_util/is_member_pointer/requirements/typedefs.cc:\n+\tLikewise.\n+\t* testsuite/20_util/is_member_pointer/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\t* testsuite/20_util/is_member_function_pointer/value.cc: Likewise.\n+\t* testsuite/20_util/is_member_function_pointer/\n+\trequirements/typedefs.cc: Likewise.\n+\t* testsuite/20_util/is_member_function_pointer/requirements/\n+\texplicit_instantiation.cc: Likewise.\n+\n+\t* testsuite/20_util/is_convertible/value.cc: Minor tweak, adjust\n+\tCopyright years.\n+\n 2011-04-12  Takaya Saito  <gintensubaru@gmail.com>\n \n \tPR libstdc++/48476"}, {"sha": "a4c76730f5b79dfda1de36038e6c2bd1b1183b39", "filename": "libstdc++-v3/include/std/type_traits", "status": "modified", "additions": 801, "deletions": 429, "changes": 1230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftype_traits?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -1,6 +1,6 @@\n // C++0x type_traits -*- C++ -*-\n \n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -51,21 +51,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     typedef struct { char __arr[2]; } __two;\n   };\n \n-#define _DEFINE_SPEC_0_HELPER                          \\\n-  template<>\n+  // Meta programming helper types.\n \n-#define _DEFINE_SPEC_1_HELPER                          \\\n-  template<typename _Tp>\n+  template<bool, typename, typename>\n+    struct conditional;\n \n-#define _DEFINE_SPEC_2_HELPER                          \\\n-  template<typename _Tp, typename _Cp>\n+  template<typename _Tp, _Tp>\n+    struct integral_constant;\n+\n+  template<typename, typename, typename...>\n+    struct __or_;\n+\n+  template<typename _B1, typename _B2>\n+    struct __or_<_B1, _B2>\n+    : public conditional<_B1::value, _B1, _B2>::type\n+    { };\n+\n+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n+    struct __or_<_B1, _B2, _B3, _Bn...>\n+    : public conditional<_B1::value, _B1, __or_<_B2, _B3, _Bn...>>::type\n+    { };\n \n-#define _DEFINE_SPEC(_Order, _Trait, _Type, _Value)    \\\n-  _DEFINE_SPEC_##_Order##_HELPER                       \\\n-    struct _Trait<_Type>                               \\\n-    : public integral_constant<bool, _Value> { };\n+  template<typename, typename, typename...>\n+    struct __and_;\n \n-  // helper classes.\n+  template<typename _B1, typename _B2>\n+    struct __and_<_B1, _B2>\n+    : public conditional<_B1::value, _B2, _B1>::type\n+    { };\n+\n+  template<typename _B1, typename _B2, typename _B3, typename... _Bn>\n+    struct __and_<_B1, _B2, _B3, _Bn...>\n+    : public conditional<_B1::value, __and_<_B2, _B3, _Bn...>, _B1>::type\n+    { };\n+\n+  template<typename _Pp>\n+    struct __not_\n+    : public integral_constant<bool, !_Pp::value>\n+    { };\n+\n+  // helper class.\n \n   /// integral_constant\n   template<typename _Tp, _Tp __v>\n@@ -86,16 +111,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp, _Tp __v>\n     constexpr _Tp integral_constant<_Tp, __v>::value;\n \n-  /// remove_cv\n+  // primary type categories.\n+\n   template<typename>\n     struct remove_cv;\n \n   template<typename>\n     struct __is_void_helper\n     : public false_type { };\n-  _DEFINE_SPEC(0, __is_void_helper, void, true)\n \n-  // primary type categories.\n+  template<>\n+    struct __is_void_helper<void>\n+    : public true_type { };\n \n   /// is_void\n   template<typename _Tp>\n@@ -107,23 +134,68 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     struct __is_integral_helper\n     : public false_type { };\n-  _DEFINE_SPEC(0, __is_integral_helper, bool, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, char, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, signed char, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned char, true)\n+\n+  template<>\n+    struct __is_integral_helper<bool>\n+    : public true_type { };\n+  \n+  template<>\n+    struct __is_integral_helper<char>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<signed char>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned char>\n+    : public true_type { };\n+\n #ifdef _GLIBCXX_USE_WCHAR_T\n-  _DEFINE_SPEC(0, __is_integral_helper, wchar_t, true)\n+  template<>\n+    struct __is_integral_helper<wchar_t>\n+    : public true_type { };\n #endif\n-  _DEFINE_SPEC(0, __is_integral_helper, char16_t, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, char32_t, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, short, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned short, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, int, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned int, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, long long, true)\n-  _DEFINE_SPEC(0, __is_integral_helper, unsigned long long, true)\n+\n+  template<>\n+    struct __is_integral_helper<char16_t>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<char32_t>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<short>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned short>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<int>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned int>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<long>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned long>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<long long>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_integral_helper<unsigned long long>\n+    : public true_type { };\n \n   /// is_integral\n   template<typename _Tp>\n@@ -135,9 +207,18 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     struct __is_floating_point_helper\n     : public false_type { };\n-  _DEFINE_SPEC(0, __is_floating_point_helper, float, true)\n-  _DEFINE_SPEC(0, __is_floating_point_helper, double, true)\n-  _DEFINE_SPEC(0, __is_floating_point_helper, long double, true)\n+\n+  template<>\n+    struct __is_floating_point_helper<float>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_floating_point_helper<double>\n+    : public true_type { };\n+\n+  template<>\n+    struct __is_floating_point_helper<long double>\n+    : public true_type { };\n \n   /// is_floating_point\n   template<typename _Tp>\n@@ -162,7 +243,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     struct __is_pointer_helper\n     : public false_type { };\n-  _DEFINE_SPEC(1, __is_pointer_helper, _Tp*, true)\n+\n+  template<typename _Tp>\n+    struct __is_pointer_helper<_Tp*>\n+    : public true_type { };\n \n   /// is_pointer\n   template<typename _Tp>\n@@ -171,19 +255,34 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t      remove_cv<_Tp>::type>::value)>\n     { };\n \n-  /// is_reference\n+  /// is_lvalue_reference\n+  template<typename>\n+    struct is_lvalue_reference\n+    : public false_type { };\n+\n   template<typename _Tp>\n-    struct is_reference;\n+    struct is_lvalue_reference<_Tp&>\n+    : public true_type { };\n+\n+  /// is_rvalue_reference\n+  template<typename>\n+    struct is_rvalue_reference\n+    : public false_type { };\n \n-  /// is_function\n   template<typename _Tp>\n+    struct is_rvalue_reference<_Tp&&>\n+    : public true_type { };\n+\n+  template<typename>\n     struct is_function;\n \n   template<typename>\n     struct __is_member_object_pointer_helper\n     : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_object_pointer_helper, _Tp _Cp::*,\n-\t       !is_function<_Tp>::value)\n+\n+  template<typename _Tp, typename _Cp>\n+    struct __is_member_object_pointer_helper<_Tp _Cp::*>\n+    : public integral_constant<bool, !is_function<_Tp>::value> { };\n \n   /// is_member_object_pointer\n   template<typename _Tp>\n@@ -195,8 +294,10 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     struct __is_member_function_pointer_helper\n     : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_function_pointer_helper, _Tp _Cp::*,\n-\t       is_function<_Tp>::value)\n+\n+  template<typename _Tp, typename _Cp>\n+    struct __is_member_function_pointer_helper<_Tp _Cp::*>\n+    : public integral_constant<bool, is_function<_Tp>::value> { };\n \n   /// is_member_function_pointer\n   template<typename _Tp>\n@@ -227,35 +328,46 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename>\n     struct is_function\n     : public false_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes...)>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes......)>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes...) const>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes......) const>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes...) volatile>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes......) volatile>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes...) const volatile>\n     : public true_type { };\n+\n   template<typename _Res, typename... _ArgTypes>\n     struct is_function<_Res(_ArgTypes......) const volatile>\n     : public true_type { };\n \n   template<typename>\n     struct __is_nullptr_t_helper\n     : public false_type { };\n-  _DEFINE_SPEC(0, __is_nullptr_t_helper, std::nullptr_t, true)\n+\n+  template<>\n+    struct __is_nullptr_t_helper<std::nullptr_t>\n+    : public true_type { };\n \n   // __is_nullptr_t (extension).\n   template<typename _Tp>\n@@ -264,42 +376,42 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t      remove_cv<_Tp>::type>::value)>\n     { };\n \n-  // composite type traits.\n-  \n+  // composite type categories.\n+\n+  /// is_reference\n+  template<typename _Tp>\n+    struct is_reference\n+    : public __or_<is_lvalue_reference<_Tp>,\n+                   is_rvalue_reference<_Tp>>::type\n+    { };\n+\n   /// is_arithmetic\n   template<typename _Tp>\n     struct is_arithmetic\n-    : public integral_constant<bool, (is_integral<_Tp>::value\n-\t\t\t\t      || is_floating_point<_Tp>::value)>\n+    : public __or_<is_integral<_Tp>, is_floating_point<_Tp>>::type\n     { };\n \n   /// is_fundamental\n   template<typename _Tp>\n     struct is_fundamental\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_void<_Tp>::value)>\n+    : public __or_<is_arithmetic<_Tp>, is_void<_Tp>>::type\n     { };\n \n   /// is_object\n   template<typename _Tp>\n     struct is_object\n-    : public integral_constant<bool, !(is_function<_Tp>::value\n-\t\t\t\t       || is_reference<_Tp>::value\n-\t\t\t\t       || is_void<_Tp>::value)>\n+    : public __not_<__or_<is_function<_Tp>, is_reference<_Tp>,\n+                          is_void<_Tp>>>::type\n     { };\n \n-  /// is_member_pointer\n-  template<typename _Tp>\n+  template<typename>\n     struct is_member_pointer;\n \n   /// is_scalar\n   template<typename _Tp>\n     struct is_scalar\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      || is_enum<_Tp>::value\n-\t\t\t\t      || is_pointer<_Tp>::value\n-\t\t\t\t      || is_member_pointer<_Tp>::value\n-\t\t\t\t      || __is_nullptr_t<_Tp>::value)>\n+    : public __or_<is_arithmetic<_Tp>, is_enum<_Tp>, is_pointer<_Tp>,\n+                   is_member_pointer<_Tp>, __is_nullptr_t<_Tp>>::type\n     { };\n \n   /// is_compound\n@@ -311,15 +423,19 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Tp>\n     struct __is_member_pointer_helper\n     : public false_type { };\n-  _DEFINE_SPEC(2, __is_member_pointer_helper, _Tp _Cp::*, true)\n+\n+  template<typename _Tp, typename _Cp>\n+    struct __is_member_pointer_helper<_Tp _Cp::*>\n+    : public true_type { };\n \n   template<typename _Tp>\n-  struct is_member_pointer\n+    struct is_member_pointer\n     : public integral_constant<bool, (__is_member_pointer_helper<\n \t\t\t\t      typename remove_cv<_Tp>::type>::value)>\n     { };\n \n   // type properties.\n+\n   /// is_const\n   template<typename>\n     struct is_const\n@@ -338,6 +454,33 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct is_volatile<_Tp volatile>\n     : public true_type { };\n \n+  /// is_trivial\n+  template<typename _Tp>\n+    struct is_trivial\n+    : public integral_constant<bool, __is_trivial(_Tp)>\n+    { };\n+\n+  /// is_trivially_copyable (still unimplemented)\n+\n+  /// is_standard_layout\n+  template<typename _Tp>\n+    struct is_standard_layout\n+    : public integral_constant<bool, __is_standard_layout(_Tp)>\n+    { };\n+\n+  /// is_pod\n+  // Could use is_standard_layout && is_trivial instead of the builtin.\n+  template<typename _Tp>\n+    struct is_pod\n+    : public integral_constant<bool, __is_pod(_Tp)>\n+    { };\n+\n+  /// is_literal_type\n+  template<typename _Tp>\n+    struct is_literal_type\n+    : public integral_constant<bool, __is_literal_type(_Tp)>\n+    { };\n+\n   /// is_empty\n   template<typename _Tp>\n     struct is_empty\n@@ -356,336 +499,362 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public integral_constant<bool, __is_abstract(_Tp)>\n     { };\n \n-  /// has_virtual_destructor\n+  template<typename _Tp,\n+\t   bool = is_integral<_Tp>::value,\n+\t   bool = is_floating_point<_Tp>::value>\n+    struct __is_signed_helper\n+    : public false_type { };\n+\n   template<typename _Tp>\n-    struct has_virtual_destructor\n-    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n+    struct __is_signed_helper<_Tp, false, true>\n+    : public true_type { };\n+\n+  template<typename _Tp>\n+    struct __is_signed_helper<_Tp, true, false>\n+    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>\n     { };\n \n-  /// alignment_of\n+  /// is_signed\n   template<typename _Tp>\n-    struct alignment_of\n-    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n-  \n-  /// rank\n+    struct is_signed\n+    : public integral_constant<bool, __is_signed_helper<_Tp>::value>\n+    { };\n+\n+  /// is_unsigned\n+  template<typename _Tp>\n+    struct is_unsigned\n+    : public __and_<is_arithmetic<_Tp>, __not_<is_signed<_Tp>>>::type\n+    { };\n+\n+\n+  // destructible and constructible type properties\n+\n   template<typename>\n-    struct rank\n-    : public integral_constant<std::size_t, 0> { };\n-   \n-  template<typename _Tp, std::size_t _Size>\n-    struct rank<_Tp[_Size]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+    struct add_rvalue_reference;\n \n   template<typename _Tp>\n-    struct rank<_Tp[]>\n-    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+    typename add_rvalue_reference<_Tp>::type declval() noexcept;\n \n-  /// extent\n-  template<typename, unsigned _Uint = 0>\n-    struct extent\n-    : public integral_constant<std::size_t, 0> { };\n-  \n-  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n-    struct extent<_Tp[_Size], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n-\t\t\t\t\t\t\t   _Uint - 1>::value>\n+  template<typename, unsigned = 0>\n+    struct extent;\n+\n+  template<typename>\n+    struct remove_all_extents;\n+\n+  template<typename _Tp>\n+    struct __is_array_known_bounds\n+    : public integral_constant<bool, (extent<_Tp>::value > 0)>\n     { };\n \n-  template<typename _Tp, unsigned _Uint>\n-    struct extent<_Tp[], _Uint>\n-    : public integral_constant<std::size_t,\n-\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n-\t\t\t\t\t\t       _Uint - 1>::value>\n+  template<typename _Tp>\n+    struct __is_array_unknown_bounds\n+    : public __and_<is_array<_Tp>, __not_<extent<_Tp>>>::type\n     { };\n \n-  // relationships between types [4.6].\n+  struct __do_is_destructible_impl_1\n+  {\n+    template<typename _Up>\n+      struct __w { _Up __u; };\n \n-  /// is_same\n-  template<typename, typename>\n-    struct is_same\n-    : public false_type { };\n+    template<typename _Tp, typename\n+             = decltype(declval<__w<_Tp>&>().~__w<_Tp>())>\n+      static true_type __test(int);\n+\n+    template<typename>\n+      static false_type __test(...);\n+  };\n \n   template<typename _Tp>\n-    struct is_same<_Tp, _Tp>\n-    : public true_type { };\n+    struct __is_destructible_impl_1\n+    : public __do_is_destructible_impl_1\n+    {\n+      typedef decltype(__test<_Tp>(0)) type;\n+    };\n \n-  // const-volatile modifications [4.7.1].\n+  struct __do_is_destructible_impl_2\n+  {\n+    template<typename _Tp, typename = decltype(declval<_Tp&>().~_Tp())>\n+      static true_type __test(int);\n+\n+    template<typename>\n+      static false_type __test(...);\n+  };\n \n-  /// remove_const\n   template<typename _Tp>\n-    struct remove_const\n-    { typedef _Tp     type; };\n+    struct __is_destructible_impl_2\n+    : public __do_is_destructible_impl_2\n+    {\n+      typedef decltype(__test<_Tp>(0)) type;\n+    };\n+\n+  template<typename _Tp,\n+           bool = __or_<is_void<_Tp>,\n+                        __is_array_unknown_bounds<_Tp>>::value,\n+           bool = __or_<is_reference<_Tp>, is_function<_Tp>>::value>\n+    struct __is_destructible_safe;\n \n   template<typename _Tp>\n-    struct remove_const<_Tp const>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_volatile\n+    struct __is_destructible_safe<_Tp, false, false>\n+    : public conditional<is_abstract<_Tp>::value,\n+\t\t\t __is_destructible_impl_2<_Tp>,\n+                         __is_destructible_impl_1<_Tp>>::type::type\n+    { };\n+\n   template<typename _Tp>\n-    struct remove_volatile\n-    { typedef _Tp     type; };\n+    struct __is_destructible_safe<_Tp, true, false>\n+    : public false_type { };\n \n   template<typename _Tp>\n-    struct remove_volatile<_Tp volatile>\n-    { typedef _Tp     type; };\n-  \n-  /// remove_cv\n+    struct __is_destructible_safe<_Tp, false, true>\n+    : public true_type { };\n+\n+  /// is_destructible\n   template<typename _Tp>\n-    struct remove_cv\n+    struct is_destructible\n+    : public integral_constant<bool, (__is_destructible_safe<_Tp>::value)>\n+    { };\n+\n+  struct __do_is_default_constructible_impl\n+  {\n+    template<typename _Tp, typename = decltype(_Tp())>\n+      static true_type __test(int);\n+\n+    template<typename>\n+      static false_type __test(...);\n+  };\n+\n+  template<typename _Tp>\n+    struct __is_default_constructible_impl\n+    : public __do_is_default_constructible_impl\n     {\n-      typedef typename\n-      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n+      typedef decltype(__test<_Tp>(0)) type;\n     };\n-  \n-  /// add_const\n-  template<typename _Tp>\n-    struct add_const\n-    { typedef _Tp const     type; };\n-   \n-  /// add_volatile\n-  template<typename _Tp>\n-    struct add_volatile\n-    { typedef _Tp volatile     type; };\n-  \n-  /// add_cv\n-  template<typename _Tp>\n-    struct add_cv\n-    {\n-      typedef typename\n-      add_const<typename add_volatile<_Tp>::type>::type     type;\n-    };\n-\n-  // array modifications.\n-\n-  /// remove_extent\n-  template<typename _Tp>\n-    struct remove_extent\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_extent<_Tp[_Size]>\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp>\n-    struct remove_extent<_Tp[]>\n-    { typedef _Tp     type; };\n-\n-  /// remove_all_extents\n-  template<typename _Tp>\n-    struct remove_all_extents\n-    { typedef _Tp     type; };\n-\n-  template<typename _Tp, std::size_t _Size>\n-    struct remove_all_extents<_Tp[_Size]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n \n   template<typename _Tp>\n-    struct remove_all_extents<_Tp[]>\n-    { typedef typename remove_all_extents<_Tp>::type     type; };\n-\n-  // pointer modifications.\n+    struct __is_default_constructible_atom\n+    : public __and_<is_destructible<_Tp>,\n+                    __is_default_constructible_impl<_Tp>>::type::type\n+    { };\n \n-  template<typename _Tp, typename>\n-    struct __remove_pointer_helper\n-    { typedef _Tp     type; };\n+  template<typename _Tp, bool = is_array<_Tp>::value>\n+    struct __is_default_constructible_safe;\n \n-  template<typename _Tp, typename _Up>\n-    struct __remove_pointer_helper<_Tp, _Up*>\n-    { typedef _Up     type; };\n+  // The following technique is a workaround for a gcc defect, which does\n+  // not sfinae away attempts to default-construct arrays of unknown bounds.\n+  // Complete arrays can be default-constructed, if the element type is\n+  // default-constructible, but arrays with unknown bounds are not:\n \n-  /// remove_pointer\n   template<typename _Tp>\n-    struct remove_pointer\n-    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n+    struct __is_default_constructible_safe<_Tp, true>\n+    : public __and_<__is_array_known_bounds<_Tp>,\n+\t\t    __is_default_constructible_atom<typename\n+                      remove_all_extents<_Tp>::type>>::type::type\n     { };\n \n-  template<typename>\n-    struct remove_reference;\n-\n-  /// add_pointer\n   template<typename _Tp>\n-    struct add_pointer\n-    { typedef typename remove_reference<_Tp>::type*     type; };\n-\n-  // Primary classification traits.\n-\n-  /// is_lvalue_reference\n-  template<typename>\n-    struct is_lvalue_reference\n-    : public false_type { };\n+    struct __is_default_constructible_safe<_Tp, false>\n+    : public __is_default_constructible_atom<_Tp>::type\n+    { };\n \n+  /// is_default_constructible\n   template<typename _Tp>\n-    struct is_lvalue_reference<_Tp&>\n-    : public true_type { };\n+    struct is_default_constructible\n+    : public integral_constant<bool, (__is_default_constructible_safe<\n+\t\t\t\t      _Tp>::value)>\n+    { };\n \n-  /// is_rvalue_reference\n-  template<typename>\n-    struct is_rvalue_reference\n-    : public false_type { };\n+  struct __do_is_static_castable_impl\n+  {\n+    template<typename _From, typename _To, typename\n+             = decltype(static_cast<_To>(declval<_From>()))>\n+      static true_type __test(int);\n \n-  template<typename _Tp>\n-    struct is_rvalue_reference<_Tp&&>\n-    : public true_type { };\n+    template<typename, typename>\n+      static false_type __test(...);\n+  };\n \n-  // Secondary classification traits.\n+  template<typename _From, typename _To>\n+    struct __is_static_castable_impl\n+    : public __do_is_static_castable_impl\n+    {\n+      typedef decltype(__test<_From, _To>(0)) type;\n+    };\n \n-  /// is_reference\n-  template<typename _Tp>\n-    struct is_reference\n-    : public integral_constant<bool, (is_lvalue_reference<_Tp>::value\n-\t\t\t\t      || is_rvalue_reference<_Tp>::value)>\n+  template<typename _From, typename _To>\n+    struct __is_static_castable_safe\n+    : public __and_<__or_<is_void<_To>, is_destructible<_To>>,\n+                    __is_static_castable_impl<_From, _To>>::type::type\n     { };\n \n-  // Reference transformations.\n+  // __is_static_castable\n+  template<typename _From, typename _To>\n+    struct __is_static_castable\n+    : public integral_constant<bool, (__is_static_castable_safe<\n+\t\t\t\t      _From, _To>::value)>\n+    { };\n \n-  /// remove_reference\n-  template<typename _Tp>\n-    struct remove_reference\n-    { typedef _Tp   type; };\n+  struct __do_is_direct_constructible_impl\n+  {\n+    template<typename _Tp, typename _Arg, typename\n+\t     = decltype(::new _Tp(declval<_Arg>()))>\n+      static true_type __test(int);\n \n-  template<typename _Tp>\n-    struct remove_reference<_Tp&>\n-    { typedef _Tp   type; };\n+    template<typename, typename>\n+      static false_type __test(...);\n+  };\n \n-  template<typename _Tp>\n-    struct remove_reference<_Tp&&>\n-    { typedef _Tp   type; };\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_impl\n+    : public __do_is_direct_constructible_impl\n+    {\n+      typedef decltype(__test<_Tp, _Arg>(0)) type;\n+    };\n \n-  template<typename _Tp,\n-\t   bool = !is_reference<_Tp>::value && !is_void<_Tp>::value,\n-\t   bool = is_rvalue_reference<_Tp>::value>\n-    struct __add_lvalue_reference_helper\n-    { typedef _Tp   type; };\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_new_safe\n+    : public __and_<is_destructible<_Tp>,\n+                    __is_direct_constructible_impl<_Tp, _Arg>>::type::type\n+    { };\n \n-  template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, true, false>\n-    { typedef _Tp&   type; };\n+  template<typename, typename>\n+    struct is_same;\n \n-  template<typename _Tp>\n-    struct __add_lvalue_reference_helper<_Tp, false, true>\n-    { typedef typename remove_reference<_Tp>::type&   type; };\n+  template<typename, typename>\n+    struct is_base_of;\n \n-  /// add_lvalue_reference\n-  template<typename _Tp>\n-    struct add_lvalue_reference\n-    : public __add_lvalue_reference_helper<_Tp>\n-    { };\n+  template<typename>\n+    struct remove_reference;\n \n-  template<typename _Tp,\n-\t   bool = !is_reference<_Tp>::value && !is_void<_Tp>::value>\n-    struct __add_rvalue_reference_helper\n-    { typedef _Tp   type; };\n+  template<typename _From, typename _To, bool\n+           = is_reference<_From>::value>\n+    struct __is_base_to_derived_ref;\n \n-  template<typename _Tp>\n-    struct __add_rvalue_reference_helper<_Tp, true>\n-    { typedef _Tp&&   type; };\n+  template<typename _From, typename _To>\n+    struct __is_base_to_derived_ref<_From, _To, true>\n+    {\n+      typedef typename remove_cv<typename remove_reference<_From\n+        >::type>::type __src_t;\n+      typedef typename remove_cv<typename remove_reference<_To\n+        >::type>::type __dst_t;\n+      typedef typename __and_<\n+        __not_<is_same<__src_t, __dst_t>>,\n+        is_base_of<__src_t, __dst_t>\n+      >::type type;\n+      static constexpr bool value = type::value;\n+    };\n \n-  /// add_rvalue_reference\n-  template<typename _Tp>\n-    struct add_rvalue_reference\n-    : public __add_rvalue_reference_helper<_Tp>\n+  template<typename _From, typename _To>\n+    struct __is_base_to_derived_ref<_From, _To, false>\n+    : public false_type\n     { };\n \n-  // Scalar properties and transformations.\n-\n-  template<typename _Tp,\n-\t   bool = is_integral<_Tp>::value,\n-\t   bool = is_floating_point<_Tp>::value>\n-    struct __is_signed_helper\n-    : public false_type { };\n+  template<typename _From, typename _To, bool\n+           = __and_<is_lvalue_reference<_From>,\n+                    is_rvalue_reference<_To>>::value>\n+    struct __is_lvalue_to_rvalue_ref;\n \n-  template<typename _Tp>\n-    struct __is_signed_helper<_Tp, false, true>\n-    : public true_type { };\n+  template<typename _From, typename _To>\n+    struct __is_lvalue_to_rvalue_ref<_From, _To, true>\n+    {\n+      typedef typename remove_cv<typename remove_reference<\n+        _From>::type>::type __src_t;\n+      typedef typename remove_cv<typename remove_reference<\n+        _To>::type>::type __dst_t;\n+      typedef typename __or_<\n+        is_same<__src_t, __dst_t>,\n+        is_base_of<__dst_t, __src_t>\n+      >::type type;\n+      static constexpr bool value = type::value;\n+    };\n \n-  template<typename _Tp>\n-    struct __is_signed_helper<_Tp, true, false>\n-    : public integral_constant<bool, static_cast<bool>(_Tp(-1) < _Tp(0))>\n+  template<typename _From, typename _To>\n+    struct __is_lvalue_to_rvalue_ref<_From, _To, false>\n+    : public false_type\n     { };\n \n-  /// is_signed\n-  template<typename _Tp>\n-    struct is_signed\n-    : public integral_constant<bool, __is_signed_helper<_Tp>::value>\n-    { };\n+  // Here we handle direct-initialization to a reference type\n+  // as equivalent to a static_cast modulo overshooting conversions.\n+  // These are restricted to the following conversion:\n+  //    a) A base class to a derived class reference\n+  //    b) An lvalue-reference to an rvalue-reference\n \n-  /// is_unsigned\n-  template<typename _Tp>\n-    struct is_unsigned\n-    : public integral_constant<bool, (is_arithmetic<_Tp>::value\n-\t\t\t\t      && !is_signed<_Tp>::value)>\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_ref_cast\n+    : public __and_<__is_static_castable<_Arg, _Tp>,\n+                    __not_<__or_<__is_base_to_derived_ref<_Arg, _Tp>,\n+                                 __is_lvalue_to_rvalue_ref<_Arg, _Tp>\n+                   >>>::type::type\n     { };\n \n-  // Member introspection.\n-\n-  /// is_trivial\n-  template<typename _Tp>\n-    struct is_trivial\n-    : public integral_constant<bool, __is_trivial(_Tp)>\n-    { };\n+  // Direct-initialization is tricky, because of functional\n+  // casts: For a conversion to reference we fall back to a\n+  // static_cast modulo extra cases, otherwise we use a\n+  // new expression:\n \n-  /// is_standard_layout\n-  template<typename _Tp>\n-    struct is_standard_layout\n-    : public integral_constant<bool, __is_standard_layout(_Tp)>\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible_new\n+    : public conditional<is_reference<_Tp>::value,\n+\t\t\t __is_direct_constructible_ref_cast<_Tp, _Arg>,\n+\t\t\t __is_direct_constructible_new_safe<_Tp, _Arg>\n+\t\t\t >::type\n     { };\n \n-  /// is_pod\n-  // Could use is_standard_layout && is_trivial instead of the builtin.\n-  template<typename _Tp>\n-    struct is_pod\n-    : public integral_constant<bool, __is_pod(_Tp)>\n+  template<typename _Tp, typename _Arg>\n+    struct __is_direct_constructible\n+    : public integral_constant<bool, (__is_direct_constructible_new<\n+\t\t\t\t      _Tp, _Arg>::type::value)>\n     { };\n \n-  /// is_literal_type\n-  template<typename _Tp>\n-    struct is_literal_type\n-    : public integral_constant<bool, __is_literal_type(_Tp)>\n-    { };\n+  struct __do_is_nary_constructible_impl\n+  {\n+    template<typename _Tp, typename... _Args, typename\n+             = decltype(_Tp(declval<_Args>()...))>\n+      static true_type __test(int);\n \n-  template<typename _Tp>\n-    typename add_rvalue_reference<_Tp>::type declval() noexcept;\n+    template<typename, typename...>\n+      static false_type __test(...);\n+  };\n \n   template<typename _Tp, typename... _Args>\n-    class __is_constructible_helper\n-    : public __sfinae_types\n+    struct __is_nary_constructible_impl\n+    : public __do_is_nary_constructible_impl\n     {\n-      template<typename _Tp1, typename... _Args1>\n-        static decltype(_Tp1(declval<_Args1>()...), __one()) __test(int);\n-\n-      template<typename, typename...>\n-        static __two __test(...);\n-\n-    public:\n-      static const bool __value = sizeof(__test<_Tp, _Args...>(0)) == 1;\n+      typedef decltype(__test<_Tp, _Args...>(0)) type;\n     };\n \n-  template<typename _Tp, typename _Arg>\n-    class __is_constructible_helper<_Tp, _Arg>\n-    : public __sfinae_types\n+  template<typename _Tp, typename... _Args>\n+    struct __is_nary_constructible\n+    : public __and_<is_destructible<_Tp>,\n+\t\t    __is_nary_constructible_impl<_Tp, _Args...>\n+                   >::type::type\n     {\n-      template<typename _Tp1, typename _Arg1>\n-        static decltype(static_cast<_Tp1>(declval<_Arg1>()), __one())\n-\t__test(int);\n+      static_assert(sizeof...(_Args) > 1,\n+                    \"Only useful for > 1 arguments\");\n+    };\n \n-      template<typename, typename>\n-        static __two __test(...);\n+  template<typename _Tp, typename... _Args>\n+    struct __is_constructible_impl\n+    : public __is_nary_constructible<_Tp, _Args...>\n+    { };\n \n-    public:\n-      static const bool __value = sizeof(__test<_Tp, _Arg>(0)) == 1;\n-    };\n+  template<typename _Tp, typename _Arg>\n+    struct __is_constructible_impl<_Tp, _Arg>\n+    : public __is_direct_constructible<_Tp, _Arg>\n+    { };\n+\n+  template<typename _Tp>\n+    struct __is_constructible_impl<_Tp>\n+    : public is_default_constructible<_Tp>\n+    { };\n \n   /// is_constructible\n-  // XXX FIXME\n-  // The C++0x specifications require front-end support, see N2255.\n   template<typename _Tp, typename... _Args>\n     struct is_constructible\n-    : public integral_constant<bool,\n-\t\t\t       __is_constructible_helper<_Tp,\n-\t\t\t\t\t\t\t _Args...>::__value>\n+    : public integral_constant<bool, (__is_constructible_impl<_Tp,\n+\t\t\t\t      _Args...>::value)>\n     { };\n \n+\n   template<bool, typename _Tp, typename... _Args>\n     struct __is_nt_constructible_helper\n     { static const bool __value = false; };\n@@ -750,7 +919,63 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public integral_constant<bool, __has_nothrow_assign(_Tp)>\n     { };\n \n-  // Relationships between types.\n+  /// has_virtual_destructor\n+  template<typename _Tp>\n+    struct has_virtual_destructor\n+    : public integral_constant<bool, __has_virtual_destructor(_Tp)>\n+    { };\n+\n+  \n+  // type property queries.\n+\n+  /// alignment_of\n+  template<typename _Tp>\n+    struct alignment_of\n+    : public integral_constant<std::size_t, __alignof__(_Tp)> { };\n+  \n+  /// rank\n+  template<typename>\n+    struct rank\n+    : public integral_constant<std::size_t, 0> { };\n+   \n+  template<typename _Tp, std::size_t _Size>\n+    struct rank<_Tp[_Size]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  template<typename _Tp>\n+    struct rank<_Tp[]>\n+    : public integral_constant<std::size_t, 1 + rank<_Tp>::value> { };\n+\n+  /// extent\n+  template<typename, unsigned _Uint>\n+    struct extent\n+    : public integral_constant<std::size_t, 0> { };\n+  \n+  template<typename _Tp, unsigned _Uint, std::size_t _Size>\n+    struct extent<_Tp[_Size], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? _Size : extent<_Tp,\n+\t\t\t\t\t\t\t   _Uint - 1>::value>\n+    { };\n+\n+  template<typename _Tp, unsigned _Uint>\n+    struct extent<_Tp[], _Uint>\n+    : public integral_constant<std::size_t,\n+\t\t\t       _Uint == 0 ? 0 : extent<_Tp,\n+\t\t\t\t\t\t       _Uint - 1>::value>\n+    { };\n+\n+\n+  // type relations.\n+\n+  /// is_same\n+  template<typename, typename>\n+    struct is_same\n+    : public false_type { };\n+\n+  template<typename _Tp>\n+    struct is_same<_Tp, _Tp>\n+    : public true_type { };\n \n   /// is_base_of\n   template<typename _Base, typename _Derived>\n@@ -759,8 +984,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     { };\n \n   template<typename _From, typename _To,\n-\t   bool = (is_void<_From>::value || is_function<_To>::value\n-\t\t   || is_array<_To>::value)>\n+           bool = __or_<is_void<_From>, is_function<_To>,\n+                        is_array<_To>>::value>\n     struct __is_convertible_helper\n     { static const bool __value = is_void<_To>::value; };\n \n@@ -783,8 +1008,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   /// is_convertible\n-  // XXX FIXME\n-  // The C++0x specifications require front-end support, see N2255.\n   template<typename _From, typename _To>\n     struct is_convertible\n     : public integral_constant<bool,\n@@ -797,124 +1020,109 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public is_constructible<_To, _From>\n     { };\n \n-  template<std::size_t _Len>\n-    struct __aligned_storage_msa\n-    { \n-      union __type\n-      {\n-\tunsigned char __data[_Len];\n-\tstruct __attribute__((__aligned__)) { } __align; \n-      };\n-    };\n \n-  /**\n-   *  @brief Alignment type.\n-   *\n-   *  The value of _Align is a default-alignment which shall be the\n-   *  most stringent alignment requirement for any C++ object type\n-   *  whose size is no greater than _Len (3.9). The member typedef\n-   *  type shall be a POD type suitable for use as uninitialized\n-   *  storage for any object whose size is at most _Len and whose\n-   *  alignment is a divisor of _Align.\n-  */\n-  template<std::size_t _Len, std::size_t _Align =\n-\t   __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n-    struct aligned_storage\n-    { \n-      union type\n-      {\n-\tunsigned char __data[_Len];\n-\tstruct __attribute__((__aligned__((_Align)))) { } __align; \n-      };\n-    };\n-\n-\n-  // Define a nested type if some predicate holds.\n-  // Primary template.\n-  /// enable_if\n-  template<bool, typename _Tp = void>\n-    struct enable_if \n-    { };\n+  // const-volatile modifications.\n \n-  // Partial specialization for true.\n+  /// remove_const\n   template<typename _Tp>\n-    struct enable_if<true, _Tp>\n-    { typedef _Tp type; };\n-\n-\n-  // A conditional expression, but for types. If true, first, if false, second.\n-  // Primary template.\n-  /// conditional\n-  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n-    struct conditional\n-    { typedef _Iftrue type; };\n-\n-  // Partial specialization for false.\n-  template<typename _Iftrue, typename _Iffalse>\n-    struct conditional<false, _Iftrue, _Iffalse>\n-    { typedef _Iffalse type; };\n+    struct remove_const\n+    { typedef _Tp     type; };\n \n+  template<typename _Tp>\n+    struct remove_const<_Tp const>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_volatile\n+  template<typename _Tp>\n+    struct remove_volatile\n+    { typedef _Tp     type; };\n \n-  // Decay trait for arrays and functions, used for perfect forwarding\n-  // in make_pair, make_tuple, etc.\n-  template<typename _Up, \n-\t   bool _IsArray = is_array<_Up>::value,\n-\t   bool _IsFunction = is_function<_Up>::value> \n-    struct __decay_selector;\n+  template<typename _Tp>\n+    struct remove_volatile<_Tp volatile>\n+    { typedef _Tp     type; };\n+  \n+  /// remove_cv\n+  template<typename _Tp>\n+    struct remove_cv\n+    {\n+      typedef typename\n+      remove_const<typename remove_volatile<_Tp>::type>::type     type;\n+    };\n+  \n+  /// add_const\n+  template<typename _Tp>\n+    struct add_const\n+    { typedef _Tp const     type; };\n+   \n+  /// add_volatile\n+  template<typename _Tp>\n+    struct add_volatile\n+    { typedef _Tp volatile     type; };\n+  \n+  /// add_cv\n+  template<typename _Tp>\n+    struct add_cv\n+    {\n+      typedef typename\n+      add_const<typename add_volatile<_Tp>::type>::type     type;\n+    };\n \n-  // NB: DR 705.\n-  template<typename _Up> \n-    struct __decay_selector<_Up, false, false>\n-    { typedef typename remove_cv<_Up>::type __type; };\n \n-  template<typename _Up> \n-    struct __decay_selector<_Up, true, false>\n-    { typedef typename remove_extent<_Up>::type* __type; };\n+  // Reference transformations.\n \n-  template<typename _Up> \n-    struct __decay_selector<_Up, false, true>\n-    { typedef typename add_pointer<_Up>::type __type; };\n+  /// remove_reference\n+  template<typename _Tp>\n+    struct remove_reference\n+    { typedef _Tp   type; };\n \n-  /// decay\n-  template<typename _Tp> \n-    class decay \n-    { \n-      typedef typename remove_reference<_Tp>::type __remove_type;\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&>\n+    { typedef _Tp   type; };\n \n-    public:\n-      typedef typename __decay_selector<__remove_type>::__type type;\n-    };\n+  template<typename _Tp>\n+    struct remove_reference<_Tp&&>\n+    { typedef _Tp   type; };\n+\n+  template<typename _Tp,\n+\t   bool = __and_<__not_<is_reference<_Tp>>,\n+                         __not_<is_void<_Tp>>>::value,\n+\t   bool = is_rvalue_reference<_Tp>::value>\n+    struct __add_lvalue_reference_helper\n+    { typedef _Tp   type; };\n \n   template<typename _Tp>\n-    class reference_wrapper;\n+    struct __add_lvalue_reference_helper<_Tp, true, false>\n+    { typedef _Tp&   type; };\n \n-  // Helper which adds a reference to a type when given a reference_wrapper\n   template<typename _Tp>\n-    struct __strip_reference_wrapper\n-    {\n-      typedef _Tp __type;\n-    };\n+    struct __add_lvalue_reference_helper<_Tp, false, true>\n+    { typedef typename remove_reference<_Tp>::type&   type; };\n \n+  /// add_lvalue_reference\n   template<typename _Tp>\n-    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n+    struct add_lvalue_reference\n+    : public __add_lvalue_reference_helper<_Tp>\n+    { };\n+\n+  template<typename _Tp,\n+           bool = __and_<__not_<is_reference<_Tp>>,\n+                         __not_<is_void<_Tp>>>::value>\n+    struct __add_rvalue_reference_helper\n+    { typedef _Tp   type; };\n \n   template<typename _Tp>\n-    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n-    {\n-      typedef _Tp& __type;\n-    };\n+    struct __add_rvalue_reference_helper<_Tp, true>\n+    { typedef _Tp&&   type; };\n \n+  /// add_rvalue_reference\n   template<typename _Tp>\n-    struct __decay_and_strip\n-    {\n-      typedef typename __strip_reference_wrapper<\n-\ttypename decay<_Tp>::type>::__type __type;\n-    };\n+    struct add_rvalue_reference\n+    : public __add_rvalue_reference_helper<_Tp>\n+    { };\n \n \n+  // sign modifications.\n+\n   // Utility for constructing identically cv-qualified types.\n   template<typename _Unqualified, bool _IsConst, bool _IsVol>\n     struct __cv_selector;\n@@ -946,7 +1154,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef typename __match::__type __type; \n     };\n \n-\n   // Utility for finding the unsigned versions of signed integral types.\n   template<typename _Tp>\n     struct __make_unsigned\n@@ -976,7 +1183,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __make_unsigned<long long>\n     { typedef unsigned long long __type; };\n \n-\n   // Select between integral and enum: not possible to be both.\n   template<typename _Tp, \n \t   bool _IsInt = is_integral<_Tp>::value,\n@@ -1053,7 +1259,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     struct __make_signed<unsigned long long>\n     { typedef signed long long __type; };\n \n-\n   // Select between integral and enum: not possible to be both.\n   template<typename _Tp, \n \t   bool _IsInt = is_integral<_Tp>::value,\n@@ -1100,6 +1305,176 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n     struct make_signed<bool>;\n \n+\n+  // array modifications.\n+\n+  /// remove_extent\n+  template<typename _Tp>\n+    struct remove_extent\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_extent<_Tp[_Size]>\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp>\n+    struct remove_extent<_Tp[]>\n+    { typedef _Tp     type; };\n+\n+  /// remove_all_extents\n+  template<typename _Tp>\n+    struct remove_all_extents\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, std::size_t _Size>\n+    struct remove_all_extents<_Tp[_Size]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+  template<typename _Tp>\n+    struct remove_all_extents<_Tp[]>\n+    { typedef typename remove_all_extents<_Tp>::type     type; };\n+\n+\n+  // pointer modifications.\n+\n+  template<typename _Tp, typename>\n+    struct __remove_pointer_helper\n+    { typedef _Tp     type; };\n+\n+  template<typename _Tp, typename _Up>\n+    struct __remove_pointer_helper<_Tp, _Up*>\n+    { typedef _Up     type; };\n+\n+  /// remove_pointer\n+  template<typename _Tp>\n+    struct remove_pointer\n+    : public __remove_pointer_helper<_Tp, typename remove_cv<_Tp>::type>\n+    { };\n+\n+  /// add_pointer\n+  template<typename _Tp>\n+    struct add_pointer\n+    { typedef typename remove_reference<_Tp>::type*     type; };\n+\n+\n+  template<std::size_t _Len>\n+    struct __aligned_storage_msa\n+    { \n+      union __type\n+      {\n+\tunsigned char __data[_Len];\n+\tstruct __attribute__((__aligned__)) { } __align; \n+      };\n+    };\n+\n+  /**\n+   *  @brief Alignment type.\n+   *\n+   *  The value of _Align is a default-alignment which shall be the\n+   *  most stringent alignment requirement for any C++ object type\n+   *  whose size is no greater than _Len (3.9). The member typedef\n+   *  type shall be a POD type suitable for use as uninitialized\n+   *  storage for any object whose size is at most _Len and whose\n+   *  alignment is a divisor of _Align.\n+  */\n+  template<std::size_t _Len, std::size_t _Align =\n+\t   __alignof__(typename __aligned_storage_msa<_Len>::__type)>\n+    struct aligned_storage\n+    { \n+      union type\n+      {\n+\tunsigned char __data[_Len];\n+\tstruct __attribute__((__aligned__((_Align)))) { } __align; \n+      };\n+    };\n+\n+\n+  // Decay trait for arrays and functions, used for perfect forwarding\n+  // in make_pair, make_tuple, etc.\n+  template<typename _Up, \n+\t   bool _IsArray = is_array<_Up>::value,\n+\t   bool _IsFunction = is_function<_Up>::value> \n+    struct __decay_selector;\n+\n+  // NB: DR 705.\n+  template<typename _Up> \n+    struct __decay_selector<_Up, false, false>\n+    { typedef typename remove_cv<_Up>::type __type; };\n+\n+  template<typename _Up> \n+    struct __decay_selector<_Up, true, false>\n+    { typedef typename remove_extent<_Up>::type* __type; };\n+\n+  template<typename _Up> \n+    struct __decay_selector<_Up, false, true>\n+    { typedef typename add_pointer<_Up>::type __type; };\n+\n+  /// decay\n+  template<typename _Tp> \n+    class decay \n+    { \n+      typedef typename remove_reference<_Tp>::type __remove_type;\n+\n+    public:\n+      typedef typename __decay_selector<__remove_type>::__type type;\n+    };\n+\n+  template<typename _Tp>\n+    class reference_wrapper;\n+\n+  // Helper which adds a reference to a type when given a reference_wrapper\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper\n+    {\n+      typedef _Tp __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __strip_reference_wrapper<const reference_wrapper<_Tp> >\n+    {\n+      typedef _Tp& __type;\n+    };\n+\n+  template<typename _Tp>\n+    struct __decay_and_strip\n+    {\n+      typedef typename __strip_reference_wrapper<\n+\ttypename decay<_Tp>::type>::__type __type;\n+    };\n+\n+\n+  // Define a nested type if some predicate holds.\n+  // Primary template.\n+  /// enable_if\n+  template<bool, typename _Tp = void>\n+    struct enable_if \n+    { };\n+\n+  // Partial specialization for true.\n+  template<typename _Tp>\n+    struct enable_if<true, _Tp>\n+    { typedef _Tp type; };\n+\n+\n+  // A conditional expression, but for types. If true, first, if false, second.\n+  // Primary template.\n+  /// conditional\n+  template<bool _Cond, typename _Iftrue, typename _Iffalse>\n+    struct conditional\n+    { typedef _Iftrue type; };\n+\n+  // Partial specialization for false.\n+  template<typename _Iftrue, typename _Iffalse>\n+    struct conditional<false, _Iftrue, _Iffalse>\n+    { typedef _Iffalse type; };\n+\n+\n   /// common_type\n   template<typename... _Tp>\n     struct common_type;\n@@ -1119,6 +1494,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n         common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n     };\n \n+  /// underlying_type (still unimplemented)\n+\n+  /// result_of\n+  template<typename _Signature>\n+    class result_of;\n+\n+  template<typename _Functor, typename... _ArgTypes>\n+    struct result_of<_Functor(_ArgTypes...)>\n+    {\n+      typedef\n+        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n+        type;\n+    };\n+\n   /// declval\n   template<typename _Tp>\n     struct __declval_protector\n@@ -1136,18 +1525,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       return __declval_protector<_Tp>::__delegate();\n     }\n \n-  /// result_of\n-  template<typename _Signature>\n-    class result_of;\n-\n-  template<typename _Functor, typename... _ArgTypes>\n-    struct result_of<_Functor(_ArgTypes...)>\n-    {\n-      typedef\n-        decltype( std::declval<_Functor>()(std::declval<_ArgTypes>()...) )\n-        type;\n-    };\n-\n   /**\n    *  Use SFINAE to determine if the type _Tp has a publicly-accessible\n    *  member type _NTYPE.\n@@ -1177,11 +1554,6 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t<typename remove_cv<_Tp>::type>::value>  \\\n     { };\n \n-#undef _DEFINE_SPEC_0_HELPER\n-#undef _DEFINE_SPEC_1_HELPER\n-#undef _DEFINE_SPEC_2_HELPER\n-#undef _DEFINE_SPEC\n-\n   // @} group metaprogramming\n _GLIBCXX_END_NAMESPACE_VERSION\n } // namespace"}, {"sha": "aaf1fb029db5fdc0211f79e797fccf5c41671098", "filename": "libstdc++-v3/testsuite/20_util/declval/requirements/1_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fdeclval%2Frequirements%2F1_neg.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -19,7 +19,7 @@\n // with this library; see the file COPYING3.  If not see\n // <http://www.gnu.org/licenses/>.\n \n-// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1134 }\n+// { dg-error \"static assertion failed\" \"\" { target *-*-* } 1523 }\n \n #include <utility>\n "}, {"sha": "efa2b853a1d6e12eb8bc3903a22259fb22783d49", "filename": "libstdc++-v3/testsuite/20_util/is_compound/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_compound<test_type>;\n+}"}, {"sha": "c167b16b10423773242519c5b12855f53ee4240b", "filename": "libstdc++-v3/testsuite/20_util/is_compound/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_compound<int>               test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "053983a2f287090eb30b8d76374289aa6b1e20e8", "filename": "libstdc++-v3/testsuite/20_util/is_compound/value.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_compound%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_compound;\n+  using namespace __gnu_test;\n+  \n+  VERIFY( (test_category<is_compound, void>(false)) );\n+  VERIFY( (test_category<is_compound, char>(false)) );\n+  VERIFY( (test_category<is_compound, signed char>(false)) );\n+  VERIFY( (test_category<is_compound, unsigned char>(false)) );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  VERIFY( (test_category<is_compound, wchar_t>(false)) );\n+#endif\n+  VERIFY( (test_category<is_compound, short>(false)) );\n+  VERIFY( (test_category<is_compound, unsigned short>(false)) );\n+  VERIFY( (test_category<is_compound, int>(false)) );\n+  VERIFY( (test_category<is_compound, unsigned int>(false)) );\n+  VERIFY( (test_category<is_compound, long>(false)) );\n+  VERIFY( (test_category<is_compound, unsigned long>(false)) );\n+  VERIFY( (test_category<is_compound, long long>(false)) );\n+  VERIFY( (test_category<is_compound, unsigned long long>(false)) );\n+  VERIFY( (test_category<is_compound, float>(false)) );\n+  VERIFY( (test_category<is_compound, double>(false)) );\n+  VERIFY( (test_category<is_compound, long double>(false)) );\n+\n+  // Sanity check.\n+  VERIFY( (test_category<is_compound, ClassType>(true)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "9e4bd97ef938dbf2d8a293826b93ca192c9659bc", "filename": "libstdc++-v3/testsuite/20_util/is_constructible/value-2.cc", "status": "added", "additions": 819, "deletions": 0, "changes": 819, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_constructible%2Fvalue-2.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,819 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test::construct_destruct;\n+\n+static_assert(std::is_constructible<int, int>::value, \"Error\");\n+static_assert(std::is_constructible<std::nullptr_t, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<E, E>::value, \"Error\");\n+static_assert(std::is_constructible<SE, SE>::value, \"Error\");\n+static_assert(std::is_constructible<OpE, OpE>::value, \"Error\");\n+static_assert(std::is_constructible<OpSE, OpSE>::value, \"Error\");\n+static_assert(std::is_constructible<Empty, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<B, B>::value, \"Error\");\n+static_assert(std::is_constructible<U, U>::value, \"Error\");\n+static_assert(std::is_constructible<int B::*, int B::*>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, Ellipsis>::value, \"Error\");\n+static_assert(std::is_constructible<int*, int*>::value, \"Error\");\n+static_assert(std::is_constructible<void*, void*>::value, \"Error\");\n+static_assert(std::is_constructible<Any, Any>::value, \"Error\");\n+static_assert(std::is_constructible<nAny, nAny>::value, \"Error\");\n+static_assert(std::is_constructible<std::initializer_list<int>,\n+\t      std::initializer_list<int>>::value, \"Error\");\n+static_assert(std::is_constructible<DelDef, DelDef>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, Abstract>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], int[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<DelCopy, const DelCopy&>::value, \"Error\");\n+static_assert(!std::is_constructible<DelCopy, DelCopy&&>::value, \"Error\");\n+static_assert(!std::is_constructible<DelCopy, DelCopy>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, void>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, int>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, DelDtor>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, DelDtor&&>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, const DelDtor&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<DelEllipsis, const DelEllipsis&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<DelEllipsis, DelEllipsis&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<DelEllipsis, DelEllipsis>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, void>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, B>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, E>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, void() const>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, int[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, int*>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, void*>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, int B::*>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, int D::*>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, Abstract>::value, \"Error\");\n+static_assert(!std::is_constructible<int, DelImplicitTo<int>>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t,\n+\t      DelImplicitTo<std::nullptr_t>>::value, \"Error\");\n+static_assert(!std::is_constructible<int&,\n+\t      DelImplicitTo<const int&>>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int, void>::value, \"Error\");\n+static_assert(!std::is_constructible<void, int>::value, \"Error\");\n+static_assert(std::is_constructible<void*, int*>::value, \"Error\");\n+static_assert(!std::is_constructible<int*, void*>::value, \"Error\");\n+static_assert(std::is_constructible<int*, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, int*>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, E>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, void*>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, int[3]>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, Abstract>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, int[]>::value, \"Error\");\n+static_assert(std::is_constructible<B, D>::value, \"Error\");\n+static_assert(!std::is_constructible<D, B>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], int[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], Abstract>::value, \"Error\");\n+\n+static_assert(std::is_constructible<const int*, int*>::value, \"Error\");\n+static_assert(std::is_constructible<const void*, void*>::value, \"Error\");\n+static_assert(std::is_constructible<const void*, int*>::value, \"Error\");\n+static_assert(!std::is_constructible<int*, const void*>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int, E>::value, \"Error\");\n+static_assert(!std::is_constructible<E, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E, E2>::value, \"Error\");\n+static_assert(std::is_constructible<E, E>::value, \"Error\");\n+static_assert(std::is_constructible<bool, E>::value, \"Error\");\n+static_assert(!std::is_constructible<E, bool>::value, \"Error\");\n+static_assert(std::is_constructible<double, E>::value, \"Error\");\n+static_assert(!std::is_constructible<E, double>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, E>::value, \"Error\");\n+static_assert(!std::is_constructible<E, std::nullptr_t>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, E2>::value, \"Error\");\n+static_assert(std::is_constructible<OpE, OpE>::value, \"Error\");\n+static_assert(std::is_constructible<bool, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, bool>::value, \"Error\");\n+static_assert(std::is_constructible<double, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, double>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, std::nullptr_t>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, SE2>::value, \"Error\");\n+static_assert(std::is_constructible<SE, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<bool, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, bool>::value, \"Error\");\n+static_assert(!std::is_constructible<double, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, double>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, std::nullptr_t>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, SE2>::value, \"Error\");\n+static_assert(std::is_constructible<OpSE, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<bool, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, bool>::value, \"Error\");\n+static_assert(!std::is_constructible<double, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, double>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, std::nullptr_t>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<D*, B*>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile D*, B*>::value, \"Error\");\n+static_assert(!std::is_constructible<D*, const volatile B*>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<D*, B* const>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile D*, B* const>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<D*, const volatile B* const>::value,\n+\t      \"Error\");\n+\n+static_assert(!std::is_constructible<D*, B*&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile D*, B*&>::value, \"Error\");\n+static_assert(!std::is_constructible<D*, const volatile B*&>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int B::*, int D::*>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile int B::*, int D::*>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<int B::*, const volatile int D::*>::value,\n+\t      \"Error\");\n+\n+static_assert(!std::is_constructible<int B::*, int D::* const>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile int B::*,\n+\t      int D::* const>::value, \"Error\");\n+static_assert(!std::is_constructible<int B::*,\n+\t      const volatile int D::* const>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int B::*, int D::*&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile int B::*,\n+\t      int D::*&>::value, \"Error\");\n+static_assert(!std::is_constructible<int B::*,\n+\t      const volatile int D::*&>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int B::*, int D::* const &>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile int B::*,\n+\t      int D::* const &>::value, \"Error\");\n+static_assert(!std::is_constructible<int B::*,\n+\t      const volatile int D::* const &>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int&&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<const int&&, int&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<B&, D&>::value, \"Error\");\n+static_assert(std::is_constructible<B&&, D&&>::value, \"Error\");\n+static_assert(std::is_constructible<const B&, D&>::value, \"Error\");\n+static_assert(std::is_constructible<const B&&, D&&>::value, \"Error\");\n+static_assert(!std::is_constructible<B&, const D&>::value, \"Error\");\n+static_assert(!std::is_constructible<B&&, const D&&>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<D&, B&>::value, \"Error\");\n+static_assert(!std::is_constructible<D&&, B&&>::value, \"Error\");\n+static_assert(!std::is_constructible<D&, const B&>::value, \"Error\");\n+static_assert(!std::is_constructible<D&&, const B&&>::value, \"Error\");\n+static_assert(!std::is_constructible<const D&, B&>::value, \"Error\");\n+static_assert(!std::is_constructible<const D&&, B&&>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<B&&, B&>::value, \"Error\");\n+static_assert(!std::is_constructible<B&&, D&>::value, \"Error\");\n+static_assert(std::is_constructible<B&&, ImplicitTo<D&&>>::value, \"Error\");\n+static_assert(std::is_constructible<B&&, ImplicitTo<D&&>&>::value, \"Error\");\n+static_assert(std::is_constructible<int&&, double&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&,\n+\t      ImplicitTo<int&>&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&,\n+\t      ImplicitTo<int&>>::value, \"Error\");\n+static_assert(std::is_constructible<const int&,\n+\t      ExplicitTo<int&>&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&,\n+\t      ExplicitTo<int&>>::value, \"Error\");\n+\n+static_assert(std::is_constructible<B&&, ExplicitTo<D&&>>::value, \"Error\");\n+static_assert(std::is_constructible<B&&, ExplicitTo<D&&>&>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<B&, B&&>::value, \"Error\");\n+static_assert(!std::is_constructible<D&, B&&>::value, \"Error\");\n+static_assert(!std::is_constructible<B&, D&&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<void(&)(), void(&)()>::value, \"Error\");\n+static_assert(std::is_constructible<void(&&)(), void(&&)()>::value, \"Error\");\n+static_assert(std::is_constructible<void(&&)(), void()>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void>::value, \"Error\" );\n+static_assert(!std::is_constructible<void, int>::value, \"Error\" );\n+static_assert(!std::is_constructible<void, int, double>::value, \"Error\" );\n+\n+static_assert(!std::is_constructible<int&>::value, \"Error\" );\n+static_assert(!std::is_constructible<const int&>::value, \"Error\" );\n+static_assert(!std::is_constructible<int&, int, int>::value, \"Error\" );\n+static_assert(!std::is_constructible<const int&, int, int>::value, \"Error\" );\n+\n+static_assert(std::is_constructible<void(&)(), void()>::value, \"Error\");\n+static_assert(std::is_constructible<void(&)(), void(&&)()>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, const int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, const int&&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, int&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, int>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, const int>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, int&&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, const int&&>::value, \"Error\");\n+static_assert(std::is_constructible<volatile int&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile int&, const int&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile int&, int>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile int&, int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile int&, const int&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile int&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile int&, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile int&, const int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile int&, int&&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile int&, const int&&>::value,\n+\t      \"Error\");\n+\n+static_assert(std::is_constructible<int&&, int>::value, \"Error\");\n+static_assert(std::is_constructible<int&&, int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&&, const int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&&, const int&>::value, \"Error\");\n+static_assert(std::is_constructible<int&&, double&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&&, int>::value, \"Error\");\n+static_assert(std::is_constructible<const int&&, int&&>::value, \"Error\");\n+static_assert(std::is_constructible<const int&&, const int>::value, \"Error\");\n+static_assert(std::is_constructible<const int&&, const int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&&, const int&>::value, \"Error\");\n+static_assert(!std::is_constructible<const int&&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<const int&&, const int&>::value, \"Error\");\n+static_assert(std::is_constructible<volatile int&&, int>::value, \"Error\");\n+static_assert(std::is_constructible<volatile int&&, int&&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile int&&, const int&&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile int&&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile int&&, const int&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<volatile int&&, double&>::value, \"Error\");\n+static_assert(std::is_constructible<volatile const int&&, int>::value, \"Error\");\n+static_assert(std::is_constructible<const volatile int&&, int&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile int&&, const int>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile int&&, const int&&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile int&&, const int&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile int&&, int&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile int&&,\n+\t      const int&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<Empty&, Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, const Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, const Empty&&>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&, Empty&>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&, const Empty>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&, Empty&&>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&, const Empty&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<volatile Empty&, Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&, const Empty&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&, Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&, const Empty&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile Empty&, Empty&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&, Empty>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&,\n+\t      const Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&,\n+\t      Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&,\n+\t      const Empty&&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<Empty&&, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<Empty&&, Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&&, const Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&&, Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&&, const Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&&, double&>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&&, const double&>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&&, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&&, Empty&&>::value, \"Error\");\n+static_assert(std::is_constructible<const Empty&&, const Empty>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const Empty&&, const Empty&&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<Empty&&, const Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<const Empty&&, Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<const Empty&&, const Empty&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<volatile Empty&&, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<volatile Empty&&, Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&, const Empty&&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&, Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&, const Empty&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&, double&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&, const double&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile Empty&&, Empty>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile Empty&&, Empty&&>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<const volatile Empty&&,\n+\t      const Empty>::value, \"Error\");\n+static_assert(std::is_constructible<const volatile Empty&&,\n+\t      const Empty&&>::value, \"Error\");\n+static_assert(!std::is_constructible<volatile Empty&&,\n+\t      const Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&&,\n+\t      Empty&>::value, \"Error\");\n+static_assert(!std::is_constructible<const volatile Empty&&,\n+\t      const Empty&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<Ellipsis, int>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, Empty>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, int[]>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, int[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<Ellipsis, void>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int(&)[1], int(&)[1]>::value, \"Error\");\n+static_assert(std::is_constructible<const int(&)[1],\n+\t      int(&)[1]>::value, \"Error\");\n+static_assert(std::is_constructible<volatile int(&)[1],\n+\t      int(&)[1]>::value, \"Error\");\n+static_assert(std::is_constructible<const volatile int(&)[1],\n+\t      int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<int(&)[1],\n+\t      const int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<const int(&)[1],\n+\t      volatile int(&)[1]>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int(&)[], int(&)[]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int(&)[1], int(&)[2]>::value, \"Error\");\n+static_assert(!std::is_constructible<int(&)[1], int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, int(&)[1]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<U, int>::value, \"Error\");\n+static_assert(!std::is_constructible<U, Empty>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void(), void()>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), int>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), Abstract>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), U>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), E>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), SE>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), int[1]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void() const,\n+\t      void() volatile>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, Abstract>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<void() const, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, U>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, E>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, int[1]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void(int), void()>::value, \"Error\");\n+static_assert(!std::is_constructible<int, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<U, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<E, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, void()>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], void()>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], void()>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void(int) const,\n+\t      void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<int, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, void() const>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<Empty, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<U, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<E, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<int[], void() const>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], void() const>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void, Empty, B>::value, \"Error\");\n+static_assert(!std::is_constructible<void, Empty, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<void, U, Empty>::value, \"Error\");\n+static_assert(!std::is_constructible<void, U, U>::value, \"Error\");\n+static_assert(!std::is_constructible<void, std::nullptr_t,\n+\t      std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<void, int[1], int[1]>::value, \"Error\");\n+static_assert(!std::is_constructible<void, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<void, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<void, void(), void()>::value, \"Error\");\n+static_assert(!std::is_constructible<void, void() const,\n+\t      void() volatile>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const int, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const int, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const int, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<bool, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const bool, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const std::nullptr_t, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const std::nullptr_t, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const std::nullptr_t, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<E, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Empty, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Empty, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const Empty, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<U, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const U, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<U, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const U, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<U, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const U, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<B, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const B, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<B, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const B, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<B, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const B, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Any, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Any, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Any, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Any, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Any, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const Any, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<nAny, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const nAny, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<nAny, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const nAny, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<>, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<>, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<>, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<Abstract, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Abstract, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const Abstract, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<Abstract, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const Abstract, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<AbstractDelDtor, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const AbstractDelDtor, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<AbstractDelDtor, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const AbstractDelDtor, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<AbstractDelDtor, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const AbstractDelDtor, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<int[1], int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const int[1], int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const int[1], void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int[1], void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<const int[1], void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, int&, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, void, int&>::value, \"Error\");\n+static_assert(!std::is_constructible<int&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t&, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t&, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<std::nullptr_t&, void, void>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<E&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<E&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<SE&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<SE&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<SE&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Empty&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<U&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<U&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<U&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<B&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<B&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<B&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Any&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Any&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Any&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<nAny&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<nAny&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<FromArgs<>&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract&, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract&, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<Abstract&, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<int(&)[1], int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int(&)[1], void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<int(&)[1], void, void>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void(), int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), void(), int>::value, \"Error\");\n+static_assert(!std::is_constructible<void(), void(), void()>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<void() const, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, void, void>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, void() volatile,\n+\t      int>::value, \"Error\");\n+static_assert(!std::is_constructible<void() const, void() volatile const,\n+\t      void() const>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<FromArgs<int>, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<int>, int, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<FromArgs<int>, void, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<int>, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<FromArgs<int, int>, void, int>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const FromArgs<int, int>, void,\n+\t      int>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<DelDtor, int, B, U>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelDtor, int, B, U>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelDtor, int>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelDtor>::value, \"Error\");\n+static_assert(!std::is_constructible<DelDtor, void*, void(&)()>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const DelDtor, void*, void(&)()>::value,\n+\t      \"Error\");\n+\n+static_assert(!std::is_constructible<AbstractDelDtor>::value, \"Error\");\n+static_assert(!std::is_constructible<const AbstractDelDtor>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelEllipsis>::value, \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, double>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelEllipsis, double>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<DelEllipsis, double, int&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<const DelEllipsis, double, int&>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<DelnAny>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelnAny>::value, \"Error\");\n+static_assert(!std::is_constructible<DelnAny, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelnAny, int>::value, \"Error\");\n+static_assert(!std::is_constructible<DelnAny, int, void*>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelnAny, int, void*>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<DelnAny, Empty, B, D>::value, \"Error\");\n+static_assert(!std::is_constructible<const DelnAny, Empty, B, D>::value,\n+\t      \"Error\");\n+\n+// Deleted members in unions with non-trivial members:\n+static_assert(!std::is_constructible<NontrivialUnion>::value, \"Error\");\n+static_assert(!std::is_constructible<NontrivialUnion,\n+\t      const NontrivialUnion&>::value, \"Error\");\n+\n+// Unusual copy:\n+static_assert(!std::is_constructible<UnusualCopy>::value, \"Error\");\n+static_assert(!std::is_constructible<UnusualCopy, UnusualCopy>::value, \"Error\");\n+static_assert(!std::is_constructible<UnusualCopy,\n+\t      UnusualCopy&&>::value, \"Error\");\n+static_assert(!std::is_constructible<UnusualCopy,\n+\t      const UnusualCopy&>::value, \"Error\");\n+static_assert(std::is_constructible<UnusualCopy, UnusualCopy&>::value, \"Error\");\n+\n+static_assert(std::is_constructible<FromArgs<int, char>,\n+\t      int, char>::value, \"Error\");\n+static_assert(std::is_constructible<const FromArgs<int, char>,\n+\t      int, char>::value, \"Error\");\n+static_assert(std::is_constructible<FromArgs<int, char>,\n+\t      int, int>::value, \"Error\");\n+static_assert(std::is_constructible<const FromArgs<int, char>,\n+\t      int, int>::value, \"Error\");\n+static_assert(std::is_constructible<nAny, int, int>::value, \"Error\");\n+static_assert(std::is_constructible<const nAny, int, int>::value, \"Error\");\n+static_assert(std::is_constructible<FromArgs<int, char>,\n+\t      ImplicitTo<int>, ImplicitTo<char>>::value, \"Error\");\n+static_assert(std::is_constructible<const FromArgs<int, char>,\n+\t      ImplicitTo<int>, ImplicitTo<char>>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, int, char>::value, \"Error\");\n+static_assert(std::is_constructible<const Ellipsis, int, char>::value, \"Error\");\n+static_assert(std::is_constructible<Ellipsis, B, U, int&>::value, \"Error\");\n+static_assert(std::is_constructible<const Ellipsis,\n+\t      B, U, int&>::value, \"Error\");\n+static_assert(std::is_constructible<nAny, B, U, int&>::value, \"Error\");\n+static_assert(std::is_constructible<const nAny, B, U, int&>::value, \"Error\");\n+static_assert(std::is_constructible<FromArgs<std::initializer_list<int>,\n+\t      std::initializer_list<B>>, std::initializer_list<int>,\n+\t      std::initializer_list<B>>::value, \"Error\");\n+static_assert(std::is_constructible<const FromArgs<std::initializer_list<int>,\n+\t      std::initializer_list<B>>, std::initializer_list<int>,\n+\t      std::initializer_list<B>>::value, \"Error\");\n+static_assert(std::is_constructible<FromArgs<std::initializer_list<int>,\n+\t      std::initializer_list<B>>, std::initializer_list<int>&,\n+\t      std::initializer_list<B>&>::value, \"Error\");\n+static_assert(!std::is_constructible<FromArgs<std::initializer_list<int>&,\n+\t      std::initializer_list<B>&>, std::initializer_list<int>,\n+\t      std::initializer_list<B>>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<FromArgs<std::initializer_list<int>>,\n+\t      int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const \n+\t      FromArgs<std::initializer_list<int>>, int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<B[2], B, B>::value, \"Error\");\n+static_assert(!std::is_constructible<const B[2], B, B>::value, \"Error\");\n+static_assert(!std::is_constructible<U[2], U, U>::value, \"Error\");\n+static_assert(!std::is_constructible<const U[2], U, U>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<E, E, E>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, E, E>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, SE, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, SE, SE>::value, \"Error\");\n+static_assert(!std::is_constructible<E, B, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, B, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<SE, B, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, B, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<E, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<const E, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<SE, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<const SE, int[], int[]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<OpE, OpE, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, OpE, OpE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, OpSE, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, OpSE, OpSE>::value, \"Error\");\n+static_assert(!std::is_constructible<OpE, B, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, B, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<OpSE, B, std::nullptr_t>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, B, std::nullptr_t>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<OpE, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpE, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<OpSE, int[], int[]>::value, \"Error\");\n+static_assert(!std::is_constructible<const OpSE, int[], int[]>::value, \"Error\");\n+\n+static_assert(!std::is_constructible<int[], int, int>::value, \"Error\");\n+static_assert(!std::is_constructible<const int[], int, int>::value, \"Error\");\n+\n+static_assert(std::is_constructible<int&, ImplicitTo<int&>>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, ImplicitTo<int&&>>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<int&&, ImplicitTo<int&&>>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, ImplicitTo<int>>::value,\n+\t      \"Error\");\n+\n+static_assert(!std::is_constructible<const int&, ExplicitTo<int>>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<int&&, ExplicitTo<int>>::value, \"Error\");\n+\n+// Binding through reference-compatible type is required to perform\n+// direct-initialization as described in [over.match.ref] p. 1 b. 1:\n+static_assert(std::is_constructible<int&, ExplicitTo<int&>>::value, \"Error\");\n+static_assert(std::is_constructible<const int&, ExplicitTo<int&&>>::value,\n+\t      \"Error\");\n+static_assert(std::is_constructible<int&&, ExplicitTo<int&&>>::value, \"Error\");\n+\n+// Binding through temporary behaves like copy-initialization,\n+// see [dcl.init.ref] p. 5, very last sub-bullet:\n+static_assert(!std::is_constructible<const int&, ExplicitTo<double&&>>::value,\n+\t      \"Error\");\n+static_assert(!std::is_constructible<int&&, ExplicitTo<double&&>>::value,\n+\t      \"Error\");"}, {"sha": "92ad66071862b82a945ed6e7b37373947cb844cf", "filename": "libstdc++-v3/testsuite/20_util/is_convertible/value.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_convertible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_convertible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_convertible%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -2,7 +2,7 @@\n \n // 2009-10-29  Paolo Carlini  <paolo.carlini@oracle.com>\n //\n-// Copyright (C) 2009 Free Software Foundation, Inc.\n+// Copyright (C) 2009, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -58,6 +58,8 @@ void test01()\n   VERIFY( (test_relationship<is_convertible, void, volatile void>(true)) );\n   VERIFY( (test_relationship<is_convertible, double&, ExplicitClass>(true)) );\n \n+  VERIFY( (test_relationship<is_convertible, int(int), int(&)(int)>(true)) );\n+\n   // Negative tests.\n   VERIFY( (test_relationship<is_convertible, const int*, int*>(false)) );\n   VERIFY( (test_relationship<is_convertible, int*, float*>(false)) );\n@@ -93,8 +95,6 @@ void test01()\n \t                                     const volatile int&>(false)) );\n   VERIFY( (test_relationship<is_convertible, volatile int,\n \t                                     volatile int&>(false)) );\n-  VERIFY( (test_relationship<is_convertible, int(int), int(&)(int)>(true)) );\n-\n   VERIFY( (test_relationship<is_convertible, int&, ExplicitClass>(false)) );\n   VERIFY( (test_relationship<is_convertible, void*, ExplicitClass>(false)) );\n }"}, {"sha": "dec86a94ba831285df3652b07a81e8b60b565e69", "filename": "libstdc++-v3/testsuite/20_util/is_default_constructible/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_default_constructible<test_type>;\n+}"}, {"sha": "b97d54f26916e48e00ffca5d833d283e47c3d35f", "filename": "libstdc++-v3/testsuite/20_util/is_default_constructible/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_default_constructible<int>  test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "bd18d50482deb53554f8f73fadb2b591c3766569", "filename": "libstdc++-v3/testsuite/20_util/is_default_constructible/value.cc", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_default_constructible%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,134 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test::construct_destruct;\n+\n+static_assert(std::is_default_constructible<int>::value, \"Error\");\n+static_assert(std::is_default_constructible<int const>::value, \"Error\");\n+static_assert(std::is_default_constructible<int const volatile>::value,\n+\t      \"Error\");\n+static_assert(std::is_default_constructible<int*>::value, \"Error\");\n+static_assert(std::is_default_constructible<void*>::value, \"Error\");\n+static_assert(std::is_default_constructible<void* const>::value, \"Error\");\n+static_assert(std::is_default_constructible<int B::*>::value, \"Error\");\n+static_assert(std::is_default_constructible<void(*)()>::value, \"Error\");\n+static_assert(std::is_default_constructible<std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_default_constructible<std::nullptr_t const>::value,\n+\t      \"Error\");\n+static_assert(std::is_default_constructible<Empty>::value, \"Error\");\n+static_assert(std::is_default_constructible<Empty const>::value, \"Error\");\n+static_assert(std::is_default_constructible<FromArgs<>>::value, \"Error\");\n+static_assert(std::is_default_constructible<FromArgs<> const>::value, \"Error\");\n+static_assert(std::is_default_constructible<nAny>::value, \"Error\");\n+static_assert(std::is_default_constructible<nAny const>::value, \"Error\");\n+static_assert(std::is_default_constructible<Ellipsis>::value, \"Error\");\n+static_assert(std::is_default_constructible<Ellipsis const>::value, \"Error\");\n+static_assert(std::is_default_constructible<U>::value, \"Error\");\n+static_assert(std::is_default_constructible<U const>::value, \"Error\");\n+static_assert(std::is_default_constructible<E>::value, \"Error\");\n+static_assert(std::is_default_constructible<E const>::value, \"Error\");\n+static_assert(std::is_default_constructible<SE>::value, \"Error\");\n+static_assert(std::is_default_constructible<SE const>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpE>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpE const>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpSE>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpSE const>::value, \"Error\");\n+static_assert(std::is_default_constructible<int[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const int[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<int[1][2]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const int[1][2]>::value, \"Error\");\n+static_assert(std::is_default_constructible<FromArgs<>[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const FromArgs<>[1]>::value,\n+\t      \"Error\");\n+static_assert(std::is_default_constructible<U[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const U[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<Empty[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const Empty[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<Ellipsis[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const Ellipsis[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<std::nullptr_t[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const std::nullptr_t[1]>::value,\n+\t      \"Error\");\n+static_assert(std::is_default_constructible<nAny[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const nAny[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<E[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const E[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<SE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const SE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const OpE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<OpSE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const OpSE[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<int*[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<int* const[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<int B::*[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<int B::* const[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<std::initializer_list<int>>::value,\n+\t      \"Error\");\n+static_assert(std::is_default_constructible<const\n+\t      std::initializer_list<int>>::value, \"Error\");\n+static_assert(std::is_default_constructible<\n+\t      std::initializer_list<int>[1]>::value, \"Error\");\n+static_assert(std::is_default_constructible<const\n+\t      std::initializer_list<int>[1]>::value, \"Error\");\n+\n+static_assert(!std::is_default_constructible<void>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const void>::value, \"Error\");\n+static_assert(!std::is_default_constructible<Abstract>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const Abstract>::value, \"Error\");\n+static_assert(!std::is_default_constructible<Any>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const Any>::value, \"Error\");\n+static_assert(!std::is_default_constructible<FromArgs<int>>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const FromArgs<int>>::value,\n+\t      \"Error\");\n+static_assert(!std::is_default_constructible<int&>::value, \"Error\");\n+static_assert(!std::is_default_constructible<int&&>::value, \"Error\");\n+static_assert(!std::is_default_constructible<void()>::value, \"Error\");\n+static_assert(!std::is_default_constructible<void() const volatile>::value,\n+\t      \"Error\");\n+static_assert(!std::is_default_constructible<void(&)()>::value, \"Error\");\n+static_assert(!std::is_default_constructible<int(&)[1]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<int(&)[]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<int[]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const int[]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<int[][1][2]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const int[][1][2]>::value,\n+\t      \"Error\");\n+static_assert(!std::is_default_constructible<Any[1]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const Any[1]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<FromArgs<int>[1]>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const FromArgs<int>[1]>::value,\n+\t      \"Error\");\n+static_assert(!std::is_default_constructible<\n+\t      FromArgs<std::initializer_list<int>>>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const\n+\t      FromArgs<std::initializer_list<int>>>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const\n+\t      FromArgs<const std::initializer_list<int>>>::value, \"Error\");\n+static_assert(!std::is_default_constructible<DelDef>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const DelDef>::value, \"Error\");\n+static_assert(!std::is_default_constructible<DelCopy>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const DelCopy>::value, \"Error\");\n+static_assert(!std::is_default_constructible<DelDtor>::value, \"Error\");\n+static_assert(!std::is_default_constructible<const DelDtor>::value, \"Error\");"}, {"sha": "59b598051249fd14a2fef45ddcbc5770a0480ba7", "filename": "libstdc++-v3/testsuite/20_util/is_destructible/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_destructible<test_type>;\n+}"}, {"sha": "967842d3ea61f0135b625ca5e3adc395d2e527e8", "filename": "libstdc++-v3/testsuite/20_util/is_destructible/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_destructible<int>           test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "b0382c6e83d18acd90ed080967d7ed4a8346cca3", "filename": "libstdc++-v3/testsuite/20_util/is_destructible/value.cc", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_destructible%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,100 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <initializer_list>\n+#include <testsuite_tr1.h>\n+\n+using namespace __gnu_test::construct_destruct;\n+\n+static_assert(std::is_destructible<int>::value, \"Error\");\n+static_assert(std::is_destructible<const int>::value, \"Error\");\n+static_assert(std::is_destructible<bool>::value, \"Error\");\n+static_assert(std::is_destructible<const bool>::value, \"Error\");\n+static_assert(std::is_destructible<int*>::value, \"Error\");\n+static_assert(std::is_destructible<void*>::value, \"Error\");\n+static_assert(std::is_destructible<int B::*>::value, \"Error\");\n+static_assert(std::is_destructible<const int D::*>::value, \"Error\");\n+static_assert(std::is_destructible<E>::value, \"Error\");\n+static_assert(std::is_destructible<const E>::value, \"Error\");\n+static_assert(std::is_destructible<SE>::value, \"Error\");\n+static_assert(std::is_destructible<const SE>::value, \"Error\");\n+static_assert(std::is_destructible<OpE>::value, \"Error\");\n+static_assert(std::is_destructible<const OpE>::value, \"Error\");\n+static_assert(std::is_destructible<OpSE>::value, \"Error\");\n+static_assert(std::is_destructible<const OpSE>::value, \"Error\");\n+static_assert(std::is_destructible<std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_destructible<const std::nullptr_t>::value, \"Error\");\n+static_assert(std::is_destructible<B>::value, \"Error\");\n+static_assert(std::is_destructible<const B>::value, \"Error\");\n+static_assert(std::is_destructible<D>::value, \"Error\");\n+static_assert(std::is_destructible<const D>::value, \"Error\");\n+static_assert(std::is_destructible<Empty>::value, \"Error\");\n+static_assert(std::is_destructible<const Empty>::value, \"Error\");\n+static_assert(std::is_destructible<U>::value, \"Error\");\n+static_assert(std::is_destructible<const U>::value, \"Error\");\n+static_assert(std::is_destructible<Abstract>::value, \"Error\");\n+static_assert(std::is_destructible<const Abstract>::value, \"Error\");\n+static_assert(std::is_destructible<int[1]>::value, \"Error\");\n+static_assert(std::is_destructible<const int[1]>::value, \"Error\");\n+static_assert(std::is_destructible<int[1][2]>::value, \"Error\");\n+static_assert(std::is_destructible<const int[1][2]>::value, \"Error\");\n+static_assert(std::is_destructible<int&>::value, \"Error\");\n+static_assert(std::is_destructible<int&&>::value, \"Error\");\n+static_assert(std::is_destructible<void(&)()>::value, \"Error\");\n+static_assert(std::is_destructible<Ellipsis>::value, \"Error\");\n+static_assert(std::is_destructible<const Ellipsis>::value, \"Error\");\n+static_assert(std::is_destructible<Any>::value, \"Error\");\n+static_assert(std::is_destructible<const Any>::value, \"Error\");\n+static_assert(std::is_destructible<nAny>::value, \"Error\");\n+static_assert(std::is_destructible<const nAny>::value, \"Error\");\n+static_assert(std::is_destructible<DelDef>::value, \"Error\");\n+static_assert(std::is_destructible<const DelDef>::value, \"Error\");\n+static_assert(std::is_destructible<DelCopy>::value, \"Error\");\n+static_assert(std::is_destructible<const DelCopy>::value, \"Error\");\n+static_assert(std::is_destructible<DelEllipsis>::value, \"Error\");\n+static_assert(std::is_destructible<const DelEllipsis>::value, \"Error\");\n+static_assert(std::is_destructible<std::initializer_list<int>>::value,\n+\t      \"Error\");\n+static_assert(std::is_destructible<const std::initializer_list<int>>::value,\n+\t      \"Error\");\n+static_assert(std::is_destructible<void()>::value, \"Error\");\n+static_assert(std::is_destructible<void() const>::value, \"Error\");\n+\n+static_assert(!std::is_destructible<void>::value, \"Error\");\n+static_assert(!std::is_destructible<const void>::value, \"Error\");\n+static_assert(!std::is_destructible<int[]>::value, \"Error\");\n+static_assert(!std::is_destructible<const int[]>::value, \"Error\");\n+static_assert(!std::is_destructible<DelDtor>::value, \"Error\");\n+static_assert(!std::is_destructible<const DelDtor>::value, \"Error\");\n+static_assert(!std::is_destructible<AbstractDelDtor>::value, \"Error\");\n+static_assert(!std::is_destructible<const AbstractDelDtor>::value, \"Error\");\n+static_assert(!std::is_destructible<int[][1]>::value, \"Error\");\n+static_assert(!std::is_destructible<const int[][1]>::value, \"Error\");\n+static_assert(!std::is_destructible<DelDtor[1]>::value, \"Error\");\n+static_assert(!std::is_destructible<const DelDtor[1]>::value, \"Error\");\n+static_assert(!std::is_destructible<DelDtor[]>::value, \"Error\");\n+static_assert(!std::is_destructible<const DelDtor[]>::value, \"Error\");\n+\n+// Deleted members in unions with non-trivial members:\n+static_assert(!std::is_destructible<NontrivialUnion>::value, \"Error\");\n+\n+// Unusual copy:\n+static_assert(std::is_destructible<UnusualCopy>::value, \"Error\");"}, {"sha": "38358e550eb769264188d322c89888ab0f68aa18", "filename": "libstdc++-v3/testsuite/20_util/is_function/24808.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F24808.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F24808.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F24808.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+// libstdc++/24808\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_function;\n+  using namespace __gnu_test;\n+\n+  VERIFY( (test_category<is_function, IncompleteClass>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "52686fbcaf8464af05fe84f9f8cfbf60efdf2f1d", "filename": "libstdc++-v3/testsuite/20_util/is_function/35637.cc", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F35637.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F35637.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2F35637.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,32 @@\n+// { dg-options \"-std=gnu++0x -pedantic-errors\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <functional>\n+\n+struct S\n+{\n+  void F() const {}\n+};\n+\n+// libstdc++/35637\n+void test01()\n+{\n+  std::function<void (S *)> a(&S::F);\n+}"}, {"sha": "dc340d769cb3ad4b3653abd74463468606c86092", "filename": "libstdc++-v3/testsuite/20_util/is_function/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_function<test_type>;\n+}"}, {"sha": "5b5e35f3af708b655b5a658f8c772c8faa1896b6", "filename": "libstdc++-v3/testsuite/20_util/is_function/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_function<int>               test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "5f576eb7571cec55fc2d1cf43de4db8fd3843f6a", "filename": "libstdc++-v3/testsuite/20_util/is_function/value.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_function%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,52 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_function;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_category<is_function, int (int)>(true)) );\n+  VERIFY( (test_category<is_function, ClassType (ClassType)>(true)) );\n+  VERIFY( (test_category<is_function, float (int, float, int[], int&)>(true)) );\n+  VERIFY( (test_category<is_function, int (int, ...)>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_category<is_function, int&>(false)) );\n+  VERIFY( (test_category<is_function, void>(false)) );\n+  VERIFY( (test_category<is_function, const void>(false)) );\n+\n+  VERIFY( (test_category<is_function, AbstractClass>(false)) );\n+  VERIFY( (test_category<is_function, int(&)(int)>(false)) );\n+  \n+  // Sanity check.\n+  VERIFY( (test_category<is_function, ClassType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "b16826172babbf3472c0f45731e39bd82d9fdd55", "filename": "libstdc++-v3/testsuite/20_util/is_fundamental/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_fundamental<test_type>;\n+}"}, {"sha": "efb672eaadc9fdda40aacac7e6eedb141f3a5e31", "filename": "libstdc++-v3/testsuite/20_util/is_fundamental/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_fundamental<int>            test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "83091a148fc22947c7881d6a9b829eb5f67384e9", "filename": "libstdc++-v3/testsuite/20_util/is_fundamental/value.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_fundamental%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,57 @@\n+// { dg-options \"-std=gnu++0x\" }\n+//\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_fundamental;\n+  using namespace __gnu_test;\n+  \n+  VERIFY( (test_category<is_fundamental, void>(true)) );\n+  VERIFY( (test_category<is_fundamental, char>(true)) );\n+  VERIFY( (test_category<is_fundamental, signed char>(true)) );\n+  VERIFY( (test_category<is_fundamental, unsigned char>(true)) );\n+#ifdef _GLIBCXX_USE_WCHAR_T\n+  VERIFY( (test_category<is_fundamental, wchar_t>(true)) );\n+#endif\n+  VERIFY( (test_category<is_fundamental, short>(true)) );\n+  VERIFY( (test_category<is_fundamental, unsigned short>(true)) );\n+  VERIFY( (test_category<is_fundamental, int>(true)) );\n+  VERIFY( (test_category<is_fundamental, unsigned int>(true)) );\n+  VERIFY( (test_category<is_fundamental, long>(true)) );\n+  VERIFY( (test_category<is_fundamental, unsigned long>(true)) );\n+  VERIFY( (test_category<is_fundamental, long long>(true)) );\n+  VERIFY( (test_category<is_fundamental, unsigned long long>(true)) );\n+  VERIFY( (test_category<is_fundamental, float>(true)) );\n+  VERIFY( (test_category<is_fundamental, double>(true)) );\n+  VERIFY( (test_category<is_fundamental, long double>(true)) );\n+\n+  // Sanity check.\n+  VERIFY( (test_category<is_fundamental, ClassType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "304efcca22e9ec02f15af932d24e6f328baf1093", "filename": "libstdc++-v3/testsuite/20_util/is_member_function_pointer/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_member_function_pointer<test_type>;\n+}"}, {"sha": "2efcdda3635a216361c39783a80f12122215e285", "filename": "libstdc++-v3/testsuite/20_util/is_member_function_pointer/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_member_function_pointer<int> test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "d09c7ca17a901a4d356d6815401d58f3a4a3102f", "filename": "libstdc++-v3/testsuite/20_util/is_member_function_pointer/value.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_function_pointer%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_member_function_pointer;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   int (ClassType::*) (int)>(true)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   int (ClassType::*) (int) const>(true)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   int (ClassType::*) (float, ...)>(true)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   ClassType (ClassType::*) (ClassType)>(true)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   float (ClassType::*) (int, float, int[], int&)>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   int (ClassType::*)>(false)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   const int (ClassType::*)>(false)) );\n+  VERIFY( (test_category<is_member_function_pointer,\n+\t   ClassType (ClassType::*)>(false)) );\n+  \n+  // Sanity check.\n+  VERIFY( (test_category<is_member_function_pointer, ClassType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "5d2b686adfca0c4c302dd4a4895726bf11596c76", "filename": "libstdc++-v3/testsuite/20_util/is_member_object_pointer/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_member_object_pointer<test_type>;\n+}"}, {"sha": "13c94b7b47202017bce7d3a2d457ece1f5465fbc", "filename": "libstdc++-v3/testsuite/20_util/is_member_object_pointer/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_member_object_pointer<int>  test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "2e004e33c731ae47e43551227d6343b6fb3842b8", "filename": "libstdc++-v3/testsuite/20_util/is_member_object_pointer/value.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_object_pointer%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,58 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_member_object_pointer;\n+  using namespace __gnu_test;\n+\n+  // Positive tests.\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   int (ClassType::*)>(true)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   const int (ClassType::*)>(true)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   ClassType (ClassType::*)>(true)) );\n+\n+  // Negative tests.\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   int (ClassType::*) (int)>(false)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   int (ClassType::*) (int) const>(false)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   int (ClassType::*) (float, ...)>(false)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   ClassType (ClassType::*) (ClassType)>(false)) );\n+  VERIFY( (test_category<is_member_object_pointer,\n+\t   float (ClassType::*) (int, float, int[], int&)>(false)) );\n+\n+  // Sanity check.\n+  VERIFY( (test_category<is_member_object_pointer, ClassType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f94959e07b60cded3dd4ee5a5a54e3187646aee3", "filename": "libstdc++-v3/testsuite/20_util/is_member_pointer/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_member_pointer<test_type>;\n+}"}, {"sha": "9491ee868ff9df4edeac4b67bd91f0275219a025", "filename": "libstdc++-v3/testsuite/20_util/is_member_pointer/requirements/typedefs.cc", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,34 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing tr1/type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_member_pointer<int>         test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "fff9710d5da62363c8f5669553cf86bb29e18471", "filename": "libstdc++-v3/testsuite/20_util/is_member_pointer/value.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_member_pointer%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,53 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_member_pointer;\n+  using namespace __gnu_test;\n+\n+  VERIFY( (test_category<is_member_pointer, int (ClassType::*)>(true)) );\n+  VERIFY( (test_category<is_member_pointer, const int (ClassType::*)>(true)) );\n+  VERIFY( (test_category<is_member_pointer, ClassType (ClassType::*)>(true)) );\n+\n+  VERIFY( (test_category<is_member_pointer,\n+\t   int (ClassType::*) (int)>(true)) );\n+  VERIFY( (test_category<is_member_pointer,\n+\t   int (ClassType::*) (int) const>(true)) );\n+  VERIFY( (test_category<is_member_pointer,\n+\t   int (ClassType::*) (float, ...)>(true)) );\n+  VERIFY( (test_category<is_member_pointer,\n+\t   ClassType (ClassType::*) (ClassType)>(true)) );\n+  VERIFY( (test_category<is_member_pointer,\n+\t   float (ClassType::*) (int, float, int[], int&)>(true)) );\n+  \n+  // Sanity check.\n+  VERIFY( (test_category<is_member_pointer, ClassType>(false)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "f1fd168a1b5c7ff254738589aba1cf0903b37d29", "filename": "libstdc++-v3/testsuite/20_util/is_object/24808.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2F24808.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2F24808.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2F24808.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+// libstdc++/24808\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_object;\n+  using namespace __gnu_test;\n+\n+  VERIFY( (test_category<is_object, IncompleteClass>(true)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "6ee7c4e5a47d249b0627c3a1aca006fa33a42011", "filename": "libstdc++-v3/testsuite/20_util/is_object/requirements/explicit_instantiation.cc", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Fexplicit_instantiation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Fexplicit_instantiation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Fexplicit_instantiation.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,29 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+namespace std\n+{\n+  typedef short test_type;\n+  template struct is_object<test_type>;\n+}"}, {"sha": "bec0a8cbd4d069c9c000cc597bb4bbbe80a6e183", "filename": "libstdc++-v3/testsuite/20_util/is_object/requirements/typedefs.cc", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Ftypedefs.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Ftypedefs.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Frequirements%2Ftypedefs.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,36 @@\n+// { dg-options \"-std=gnu++0x\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// \n+// NB: This file is for testing type_traits with NO OTHER INCLUDES.\n+\n+#include <type_traits>\n+\n+// { dg-do compile }\n+\n+void test01()\n+{\n+  // Check for required typedefs\n+  typedef std::is_object<int>                 test_type;\n+  typedef test_type::value_type               value_type;\n+  typedef test_type::type                     type;\n+  typedef test_type::type::value_type         type_value_type;\n+  typedef test_type::type::type               type_type;\n+}"}, {"sha": "b3d8df696650ded49201824112eb52a3151118f5", "filename": "libstdc++-v3/testsuite/20_util/is_object/value.cc", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Fvalue.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Fvalue.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fis_object%2Fvalue.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -0,0 +1,47 @@\n+// { dg-options \"-std=gnu++0x\" }\n+\n+// Copyright (C) 2011 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#include <type_traits>\n+#include <testsuite_hooks.h>\n+#include <testsuite_tr1.h>\n+\n+void test01()\n+{\n+  bool test __attribute__((unused)) = true;\n+  using std::is_object;\n+  using namespace __gnu_test;\n+  \n+  VERIFY( (test_category<is_object, int (int)>(false)) );\n+  VERIFY( (test_category<is_object, ClassType (ClassType)>(false)) );\n+  VERIFY( (test_category<is_object, float (int, float, int[], int&)>(false)) );\n+  VERIFY( (test_category<is_object, int&>(false)) );\n+  VERIFY( (test_category<is_object, ClassType&>(false)) );\n+  VERIFY( (test_category<is_object, int(&)(int)>(false)) );\n+  VERIFY( (test_category<is_object, void>(false)) );\n+  VERIFY( (test_category<is_object, const void>(false)) );\n+\n+  // Sanity check.\n+  VERIFY( (test_category<is_object, ClassType>(true)) );\n+}\n+\n+int main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "4a568e363e8b90192b5c51d89c6a54ab312bde50", "filename": "libstdc++-v3/testsuite/20_util/make_signed/requirements/typedefs_neg.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_signed%2Frequirements%2Ftypedefs_neg.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -3,7 +3,7 @@\n \n // 2007-05-03  Benjamin Kosnik  <bkoz@redhat.com>\n //\n-// Copyright (C) 2007, 2008, 2009, 2010 Free Software Foundation, Inc.\n+// Copyright (C) 2007, 2008, 2009, 2010, 2011 Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n // software; you can redistribute it and/or modify it under the\n@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1097 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 1061 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1302 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1266 }"}, {"sha": "955c1ce00f27279b87be26c8b2094c6c077e8e99", "filename": "libstdc++-v3/testsuite/20_util/make_unsigned/requirements/typedefs_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fmake_unsigned%2Frequirements%2Ftypedefs_neg.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -48,5 +48,5 @@ void test01()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 40 }\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 42 }\n \n-// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1020 }\n-// { dg-error \"declaration of\" \"\" { target *-*-* } 984 }\n+// { dg-error \"invalid use of incomplete type\" \"\" { target *-*-* } 1226 }\n+// { dg-error \"declaration of\" \"\" { target *-*-* } 1190 }"}, {"sha": "6a611e833c6f8c8b97ed8c78bc57c5256c8e2fcb", "filename": "libstdc++-v3/testsuite/20_util/ratio/cons/cons_overflow_neg.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fratio%2Fcons%2Fcons_overflow_neg.cc?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -51,4 +51,4 @@ test04()\n // { dg-error \"instantiated from here\" \"\" { target *-*-* } 46 }\n // { dg-error \"denominator cannot be zero\" \"\" { target *-*-* } 155 }\n // { dg-error \"out of range\" \"\" { target *-*-* } 156 }\n-// { dg-error \"overflow in constant expression\" \"\" { target *-*-* } 74 }\n+// { dg-error \"overflow in constant expression\" \"\" { target *-*-* } 99 }"}, {"sha": "7e36ee3f5fed53af0d0cbe87d579a19d4914b125", "filename": "libstdc++-v3/testsuite/util/testsuite_tr1.h", "status": "modified", "additions": 125, "deletions": 1, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/123c516a9ee069efe6783682ff0bfbf28ec94919/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Futil%2Ftestsuite_tr1.h?ref=123c516a9ee069efe6783682ff0bfbf28ec94919", "patch": "@@ -1,7 +1,7 @@\n // -*- C++ -*-\n // Testing utilities for the tr1 testsuite.\n //\n-// Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010\n+// Copyright (C) 2004, 2005, 2006, 2007, 2009, 2010, 2011\n // Free Software Foundation, Inc.\n //\n // This file is part of the GNU ISO C++ Library.  This library is free\n@@ -283,6 +283,130 @@ namespace __gnu_test\n     check_ret_type(T)\n     { return true; }\n \n+#ifdef __GXX_EXPERIMENTAL_CXX0X__\n+  namespace construct_destruct\n+  {\n+    struct Empty {};\n+\n+    struct B { int i; B(){} };\n+    struct D : B {};\n+\n+    enum E { ee1 };\n+    enum E2 { ee2 };\n+    enum class SE { e1 };\n+    enum class SE2 { e2 };\n+\n+    enum OpE : int;\n+    enum class OpSE : bool;\n+\n+    union U { int i; Empty b; };\n+\n+    struct Abstract\n+    {\n+      virtual ~Abstract() = 0;\n+    };\n+\n+    struct AbstractDelDtor\n+    {\n+      ~AbstractDelDtor() = delete;\n+      virtual void foo() = 0;\n+    };\n+\n+    struct Ukn;\n+\n+    template<class To>\n+      struct ImplicitTo\n+      {\n+\toperator To();\n+      };\n+\n+    template<class To>\n+      struct DelImplicitTo\n+      {\n+\toperator To() = delete;\n+      };\n+\n+    template<class To>\n+      struct ExplicitTo\n+      {\n+\texplicit operator To();\n+      };\n+\n+    struct Ellipsis\n+    {\n+      Ellipsis(...){}\n+    };\n+\n+    struct DelEllipsis\n+    {\n+      DelEllipsis(...) = delete;\n+    };\n+\n+    struct Any\n+    {\n+      template<class T>\n+      Any(T&&){}\n+    };\n+\n+    struct nAny\n+    {\n+      template<class... T>\n+      nAny(T&&...){}\n+    };\n+\n+    struct DelnAny\n+    {\n+      template<class... T>\n+        DelnAny(T&&...) = delete;\n+    };\n+\n+    template<class... Args>\n+      struct FromArgs\n+      {\n+\tFromArgs(Args...);\n+      };\n+\n+    struct DelDef\n+    {\n+      DelDef() = delete;\n+    };\n+\n+    struct DelCopy\n+    {\n+      DelCopy(const DelCopy&) = delete;\n+    };\n+\n+    struct DelDtor\n+    {\n+      DelDtor() = default;\n+      DelDtor(const DelDtor&) = default;\n+      DelDtor(DelDtor&&) = default;\n+      DelDtor(int);\n+      DelDtor(int, B, U);\n+      ~DelDtor() = delete;\n+    };\n+\n+    struct Nontrivial\n+    {\n+      Nontrivial();\n+      Nontrivial(const Nontrivial&);\n+      Nontrivial& operator=(const Nontrivial&);\n+      ~Nontrivial();\n+    };\n+\n+    union NontrivialUnion\n+    {\n+      int i;\n+      Nontrivial n;\n+    };\n+\n+    struct UnusualCopy\n+    {\n+      UnusualCopy(UnusualCopy&);\n+    };\n+  }\n+#endif\n+\n } // namespace __gnu_test\n \n #endif // _GLIBCXX_TESTSUITE_TR1_H"}]}