{"sha": "f13c9b2c76d81cebc647765b6e4b99c952cc594d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjEzYzliMmM3NmQ4MWNlYmM2NDc3NjViNmU0Yjk5Yzk1MmNjNTk0ZA==", "commit": {"author": {"name": "Andrew Pinski", "email": "pinskia@physics.uc.edu", "date": "2005-10-02T19:15:58Z"}, "committer": {"name": "Andrew Pinski", "email": "pinskia@gcc.gnu.org", "date": "2005-10-02T19:15:58Z"}, "message": "re PR c/18851 (IMA is slow and could be sped up)\n\n2005-10-02  Andrew Pinski  <pinskia@physics.uc.edu>\n\n        PR c/18851\n        * c-typeck.c (tagged_tu_seen): Rename to ...\n        (tagged_tu_seen_cache): this and add val field.\n        (comptypes): Move functional to comptypes_internal\n        and free tagged_tu_seen.\n        (comptypes_internal): New function and call comptypes_internal\n        instead of comptypes. Speed up by sibcalling\n        tagged_types_tu_compatible_p.\n        (alloc_tagged_tu_seen): New function\n        (free_all_tagged_tu_seen_up_to): New function.\n        (tagged_types_tu_compatible_p): Return the val of the seen two\n        types.\n        Add that the two types are the same to tagged_tu_seen_base\n        if they are and call comptypes_internal instead of comptypes.\n        <case UNION_TYPE>: Speed up common type where the fields are\n        in the same order.\n        (function_types_compatible_p): Call comptypes_internal instead of\n        comptypes.\n        (type_lists_compatible_p): Likewise.\n        (all functions): s/tagged_tu_seen/tagged_tu_seen_cache/.\n\nFrom-SVN: r104873", "tree": {"sha": "e2408904e13e4cac8780c4d868e2a5b717c4d564", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e2408904e13e4cac8780c4d868e2a5b717c4d564"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f13c9b2c76d81cebc647765b6e4b99c952cc594d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13c9b2c76d81cebc647765b6e4b99c952cc594d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f13c9b2c76d81cebc647765b6e4b99c952cc594d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f13c9b2c76d81cebc647765b6e4b99c952cc594d/comments", "author": null, "committer": null, "parents": [{"sha": "aa58883c233484f8b58d245b5248162379fd1f06", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aa58883c233484f8b58d245b5248162379fd1f06", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aa58883c233484f8b58d245b5248162379fd1f06"}], "stats": {"total": 239, "additions": 186, "deletions": 53}, "files": [{"sha": "e712977ecfa662ffbafc439980bf1db005594507", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13c9b2c76d81cebc647765b6e4b99c952cc594d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13c9b2c76d81cebc647765b6e4b99c952cc594d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f13c9b2c76d81cebc647765b6e4b99c952cc594d", "patch": "@@ -1,3 +1,26 @@\n+2005-10-02  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR c/18851\n+\t* c-typeck.c (tagged_tu_seen): Rename to ...\n+\t(tagged_tu_seen_cache): this and add val field.\n+\t(comptypes): Move functional to comptypes_internal\n+\tand free tagged_tu_seen.\n+\t(comptypes_internal): New function and call comptypes_internal\n+\tinstead of comptypes. Speed up by sibcalling\n+\ttagged_types_tu_compatible_p.\n+\t(alloc_tagged_tu_seen): New function\n+\t(free_all_tagged_tu_seen_up_to): New function.\n+\t(tagged_types_tu_compatible_p): Return the val of the seen two\n+\ttypes.\n+\tAdd that the two types are the same to tagged_tu_seen_base\n+\tif they are and call comptypes_internal instead of comptypes.\n+\t<case UNION_TYPE>: Speed up common type where the fields are\n+\tin the same order.\n+\t(function_types_compatible_p): Call comptypes_internal instead of\n+\tcomptypes.\n+\t(type_lists_compatible_p): Likewise.\n+\t(all functions): s/tagged_tu_seen/tagged_tu_seen_cache/.\n+\n 2005-10-02  Matthias Klose  <doko@debian.org>\n \n \t* doc/invoke.texi: Fix typo and speling error."}, {"sha": "a72dac6aa67611c04cafb8e2fdd0b3ad314439f6", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 163, "deletions": 53, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f13c9b2c76d81cebc647765b6e4b99c952cc594d/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f13c9b2c76d81cebc647765b6e4b99c952cc594d/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=f13c9b2c76d81cebc647765b6e4b99c952cc594d", "patch": "@@ -105,7 +105,21 @@ static void readonly_error (tree, enum lvalue_use);\n static int lvalue_or_else (tree, enum lvalue_use);\n static int lvalue_p (tree);\n static void record_maybe_used_decl (tree);\n-\f\n+static int comptypes_internal (tree, tree);\n+\f/* This is a cache to hold if two types are compatible or not.  */\n+\n+struct tagged_tu_seen_cache {\n+  const struct tagged_tu_seen_cache * next;\n+  tree t1;\n+  tree t2;\n+  /* The return value of tagged_types_tu_compatible_p if we had seen\n+     these two types already.  */\n+  int val;\n+};\n+\n+static const struct tagged_tu_seen_cache * tagged_tu_seen_base;\n+static void free_all_tagged_tu_seen_up_to (const struct tagged_tu_seen_cache *);\n+\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n \n@@ -663,13 +677,29 @@ common_type (tree t1, tree t2)\n \n   return c_common_type (t1, t2);\n }\n-\f\n+\n /* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n    or various other operations.  Return 2 if they are compatible\n    but a warning may be needed if you use them together.  */\n \n int\n comptypes (tree type1, tree type2)\n+{\n+  const struct tagged_tu_seen_cache * tagged_tu_seen_base1 = tagged_tu_seen_base;\n+  int val;\n+\n+  val = comptypes_internal (type1, type2);\n+  free_all_tagged_tu_seen_up_to (tagged_tu_seen_base1);\n+  \n+  return val;\n+}\f\n+/* Return 1 if TYPE1 and TYPE2 are compatible types for assignment\n+   or various other operations.  Return 2 if they are compatible\n+   but a warning may be needed if you use them together.  This\n+   differs from comptypes, in that we don't free the seen types.  */\n+\n+static int\n+comptypes_internal (tree type1, tree type2)\n {\n   tree t1 = type1;\n   tree t2 = type2;\n@@ -737,7 +767,7 @@ comptypes (tree type1, tree type2)\n \t  || TYPE_REF_CAN_ALIAS_ALL (t1) != TYPE_REF_CAN_ALIAS_ALL (t2))\n \tbreak;\n       val = (TREE_TYPE (t1) == TREE_TYPE (t2)\n-\t     ? 1 : comptypes (TREE_TYPE (t1), TREE_TYPE (t2)));\n+\t     ? 1 : comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2)));\n       break;\n \n     case FUNCTION_TYPE:\n@@ -754,7 +784,7 @@ comptypes (tree type1, tree type2)\n \n \t/* Target types must match incl. qualifiers.  */\n \tif (TREE_TYPE (t1) != TREE_TYPE (t2)\n-\t    && 0 == (val = comptypes (TREE_TYPE (t1), TREE_TYPE (t2))))\n+\t    && 0 == (val = comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2))))\n \t  return 0;\n \n \t/* Sizes must match unless one is missing or variable.  */\n@@ -787,12 +817,16 @@ comptypes (tree type1, tree type2)\n     case RECORD_TYPE:\n     case UNION_TYPE:\n       if (val != 1 && !same_translation_unit_p (t1, t2))\n-\tval = tagged_types_tu_compatible_p (t1, t2);\n+        {\n+\t  if (attrval != 2)\n+\t    return tagged_types_tu_compatible_p (t1, t2);\n+\t  val = tagged_types_tu_compatible_p (t1, t2);\n+\t}\n       break;\n \n     case VECTOR_TYPE:\n       val = TYPE_VECTOR_SUBPARTS (t1) == TYPE_VECTOR_SUBPARTS (t2)\n-\t    && comptypes (TREE_TYPE (t1), TREE_TYPE (t2));\n+\t    && comptypes_internal (TREE_TYPE (t1), TREE_TYPE (t2));\n       break;\n \n     default:\n@@ -861,21 +895,48 @@ same_translation_unit_p (tree t1, tree t2)\n   return t1 == t2;\n }\n \n-/* The C standard says that two structures in different translation\n-   units are compatible with each other only if the types of their\n-   fields are compatible (among other things).  So, consider two copies\n-   of this structure:  */\n+/* Allocate the seen two types, assuming that they are compatible. */\n \n-struct tagged_tu_seen {\n-  const struct tagged_tu_seen * next;\n-  tree t1;\n-  tree t2;\n-};\n+static struct tagged_tu_seen_cache *\n+alloc_tagged_tu_seen_cache (tree t1, tree t2)\n+{\n+  struct tagged_tu_seen_cache *tu = xmalloc (sizeof (struct tagged_tu_seen_cache));\n+  tu->next = tagged_tu_seen_base;\n+  tu->t1 = t1;\n+  tu->t2 = t2;\n+  \n+  tagged_tu_seen_base = tu;\n+  \n+  /* The C standard says that two structures in different translation\n+     units are compatible with each other only if the types of their\n+     fields are compatible (among other things).  We assume that they\n+     are compatible until proven otherwise when building the cache.\n+     An example where this can occur is:\n+     struct a\n+     {\n+       struct a *next;\n+     };\n+     If we are comparing this against a similar struct in another TU,\n+     and did not assume they were compatiable, we end up with an infinite\n+     loop.  */\n+  tu->val = 1;\n+  return tu;\n+}\n \n-/* Can they be compatible with each other?  We choose to break the\n-   recursion by allowing those types to be compatible.  */\n+/* Free the seen types until we get to TU_TIL. */\n \n-static const struct tagged_tu_seen * tagged_tu_seen_base;\n+static void\n+free_all_tagged_tu_seen_up_to (const struct tagged_tu_seen_cache *tu_til)\n+{\n+  const struct tagged_tu_seen_cache *tu = tagged_tu_seen_base;\n+  while (tu != tu_til)\n+    {\n+      struct tagged_tu_seen_cache *tu1 = (struct tagged_tu_seen_cache*)tu;\n+      tu = tu1->next;\n+      free (tu1);\n+    }\n+  tagged_tu_seen_base = tu_til;\n+}\n \n /* Return 1 if two 'struct', 'union', or 'enum' types T1 and T2 are\n    compatible.  If the two types are not the same (which has been\n@@ -917,73 +978,123 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n     return 1;\n \n   {\n-    const struct tagged_tu_seen * tts_i;\n+    const struct tagged_tu_seen_cache * tts_i;\n     for (tts_i = tagged_tu_seen_base; tts_i != NULL; tts_i = tts_i->next)\n       if (tts_i->t1 == t1 && tts_i->t2 == t2)\n-\treturn 1;\n+\treturn tts_i->val;\n   }\n \n   switch (TREE_CODE (t1))\n     {\n     case ENUMERAL_TYPE:\n       {\n-\n+\tstruct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n         /* Speed up the case where the type values are in the same order.  */\n         tree tv1 = TYPE_VALUES (t1);\n         tree tv2 = TYPE_VALUES (t2);\n \n         if (tv1 == tv2)\n-          return 1;\n+\t  {\n+\t    return 1;\n+\t  }\n \n         for (;tv1 && tv2; tv1 = TREE_CHAIN (tv1), tv2 = TREE_CHAIN (tv2))\n           {\n             if (TREE_PURPOSE (tv1) != TREE_PURPOSE (tv2))\n               break;\n             if (simple_cst_equal (TREE_VALUE (tv1), TREE_VALUE (tv2)) != 1)\n-              return 0;\n+\t      {\n+\t        tu->val = 0;\n+\t\treturn 0;\n+\t      }\n           }\n \n         if (tv1 == NULL_TREE && tv2 == NULL_TREE)\n-          return 1;\n+\t  {\n+\t    return 1;\n+\t  }\n         if (tv1 == NULL_TREE || tv2 == NULL_TREE)\n-          return 0;\n+\t  {\n+\t    tu->val = 0;\n+\t    return 0;\n+\t  }\n \n \tif (list_length (TYPE_VALUES (t1)) != list_length (TYPE_VALUES (t2)))\n-\t  return 0;\n+\t  {\n+\t    tu->val = 0;\n+\t    return 0;\n+\t  }\n \n \tfor (s1 = TYPE_VALUES (t1); s1; s1 = TREE_CHAIN (s1))\n \t  {\n \t    s2 = purpose_member (TREE_PURPOSE (s1), TYPE_VALUES (t2));\n \t    if (s2 == NULL\n \t\t|| simple_cst_equal (TREE_VALUE (s1), TREE_VALUE (s2)) != 1)\n-\t      return 0;\n+\t      {\n+\t\ttu->val = 0;\n+\t\treturn 0;\n+\t      }\n \t  }\n \treturn 1;\n       }\n \n     case UNION_TYPE:\n       {\n+\tstruct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n \tif (list_length (TYPE_FIELDS (t1)) != list_length (TYPE_FIELDS (t2)))\n-\t  return 0;\n+\t  {\n+\t    tu->val = 0;\n+\t    return 0;\n+\t  }\n+\t\n+\t/*  Speed up the common case where the fields are in the same order. */\n+\tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2); s1 && s2;\n+\t     s1 = TREE_CHAIN (s1), s2 = TREE_CHAIN (s2))\n+\t  {\n+\t    int result;\n+\t    \n+\t    \n+\t    if (DECL_NAME (s1) == NULL\n+\t        || DECL_NAME (s1) != DECL_NAME (s2))\n+\t      break;\n+\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t    if (result == 0)\n+\t      {\n+\t\ttu->val = 0;\n+\t\treturn 0;\n+\t      }\n+\t    if (result == 2)\n+\t      needs_warning = true;\n+\n+\t    if (TREE_CODE (s1) == FIELD_DECL\n+\t\t&& simple_cst_equal (DECL_FIELD_BIT_OFFSET (s1),\n+\t\t\t\t     DECL_FIELD_BIT_OFFSET (s2)) != 1)\n+\t      {\n+\t\ttu->val = 0;\n+\t\treturn 0;\n+\t      }\n+\t  }\n+\tif (!s1 && !s2)\n+\t  {\n+\t    tu->val = needs_warning ? 2 : 1;\n+\t    return tu->val;\n+\t  }\n \n \tfor (s1 = TYPE_FIELDS (t1); s1; s1 = TREE_CHAIN (s1))\n \t  {\n \t    bool ok = false;\n-\t    struct tagged_tu_seen tts;\n-\n-\t    tts.next = tagged_tu_seen_base;\n-\t    tts.t1 = t1;\n-\t    tts.t2 = t2;\n-\t    tagged_tu_seen_base = &tts;\n \n \t    if (DECL_NAME (s1) != NULL)\n \t      for (s2 = TYPE_FIELDS (t2); s2; s2 = TREE_CHAIN (s2))\n \t\tif (DECL_NAME (s1) == DECL_NAME (s2))\n \t\t  {\n \t\t    int result;\n-\t\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n \t\t    if (result == 0)\n-\t\t      break;\n+\t\t      {\n+\t\t\ttu->val = 0;\n+\t\t\treturn 0;\n+\t\t      }\n \t\t    if (result == 2)\n \t\t      needs_warning = true;\n \n@@ -995,21 +1106,19 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \t\t    ok = true;\n \t\t    break;\n \t\t  }\n-\t    tagged_tu_seen_base = tts.next;\n \t    if (!ok)\n-\t      return 0;\n+\t      {\n+\t\ttu->val = 0;\n+\t\treturn 0;\n+\t      }\n \t  }\n-\treturn needs_warning ? 2 : 1;\n+\ttu->val = needs_warning ? 2 : 10;\n+\treturn tu->val;\n       }\n \n     case RECORD_TYPE:\n       {\n-\tstruct tagged_tu_seen tts;\n-\n-\ttts.next = tagged_tu_seen_base;\n-\ttts.t1 = t1;\n-\ttts.t2 = t2;\n-\ttagged_tu_seen_base = &tts;\n+        struct tagged_tu_seen_cache *tu = alloc_tagged_tu_seen_cache (t1, t2);\n \n \tfor (s1 = TYPE_FIELDS (t1), s2 = TYPE_FIELDS (t2);\n \t     s1 && s2;\n@@ -1019,7 +1128,7 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \t    if (TREE_CODE (s1) != TREE_CODE (s2)\n \t\t|| DECL_NAME (s1) != DECL_NAME (s2))\n \t      break;\n-\t    result = comptypes (TREE_TYPE (s1), TREE_TYPE (s2));\n+\t    result = comptypes_internal (TREE_TYPE (s1), TREE_TYPE (s2));\n \t    if (result == 0)\n \t      break;\n \t    if (result == 2)\n@@ -1030,10 +1139,11 @@ tagged_types_tu_compatible_p (tree t1, tree t2)\n \t\t\t\t     DECL_FIELD_BIT_OFFSET (s2)) != 1)\n \t      break;\n \t  }\n-\ttagged_tu_seen_base = tts.next;\n \tif (s1 && s2)\n-\t  return 0;\n-\treturn needs_warning ? 2 : 1;\n+\t  tu->val = 0;\n+\telse\n+\t  tu->val = needs_warning ? 2 : 1;\n+\treturn tu->val;\n       }\n \n     default:\n@@ -1070,7 +1180,7 @@ function_types_compatible_p (tree f1, tree f2)\n   if (TYPE_VOLATILE (ret2))\n     ret2 = build_qualified_type (TYPE_MAIN_VARIANT (ret2),\n \t\t\t\t TYPE_QUALS (ret2) & ~TYPE_QUAL_VOLATILE);\n-  val = comptypes (ret1, ret2);\n+  val = comptypes_internal (ret1, ret2);\n   if (val == 0)\n     return 0;\n \n@@ -1151,7 +1261,7 @@ type_lists_compatible_p (tree args1, tree args2)\n       else if (TREE_CODE (a1) == ERROR_MARK\n \t       || TREE_CODE (a2) == ERROR_MARK)\n \t;\n-      else if (!(newval = comptypes (mv1, mv2)))\n+      else if (!(newval = comptypes_internal (mv1, mv2)))\n \t{\n \t  /* Allow  wait (union {union wait *u; int *i} *)\n \t     and  wait (union wait *)  to be compatible.  */\n@@ -1170,7 +1280,7 @@ type_lists_compatible_p (tree args1, tree args2)\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes (mv3, mv2))\n+\t\t  if (comptypes_internal (mv3, mv2))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)\n@@ -1191,7 +1301,7 @@ type_lists_compatible_p (tree args1, tree args2)\n \t\t  if (mv3 && mv3 != error_mark_node\n \t\t      && TREE_CODE (mv3) != ARRAY_TYPE)\n \t\t    mv3 = TYPE_MAIN_VARIANT (mv3);\n-\t\t  if (comptypes (mv3, mv1))\n+\t\t  if (comptypes_internal (mv3, mv1))\n \t\t    break;\n \t\t}\n \t      if (memb == 0)"}]}