{"sha": "d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhOWVlYTJjMGU2NWUwZjAzYzI0OWJhYjhhYTNmYTU2MTQ5ZGZlMA==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2010-04-09T05:54:29Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2010-04-09T05:54:29Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2010-04-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * decl.c (variable_decl, match_attr_spec): Fix setting the array\n        spec.\n        * array.c (match_subscript,gfc_match_array_ref): Add coarray\n        * support.\n        * data.c (gfc_assign_data_value): Ditto.\n        * expr.c (gfc_check_pointer_assign): Add check for coarray\n        * constraint.\n        (gfc_traverse_expr): Traverse also through codimension expressions.\n        (gfc_is_coindexed, gfc_has_ultimate_allocatable,\n        gfc_has_ultimate_pointer): New functions.\n        * gfortran.h (gfc_array_ref_dimen_type): Add DIMEN_STAR for\n        * coarrays.\n        (gfc_array_ref): Add codimen.\n        (gfc_array_ref): Add in_allocate.\n        (gfc_is_coindexed, gfc_has_ultimate_allocatable,\n        gfc_has_ultimate_pointer): Add prototypes.\n        * interface.c (compare_parameter, compare_actual_formal,\n        check_intents): Add coarray constraints.\n        * match.c (gfc_match_iterator): Add coarray constraint.\n        * match.h (gfc_match_array_ref): Update interface.\n        * primary.c (gfc_match_varspec): Handle codimensions.\n        * resolve.c (coarray_alloc, inquiry_argument): New static\n        * variables.\n        (check_class_members): Return gfc_try instead for error recovery.\n        (resolve_typebound_function,resolve_typebound_subroutine,\n        check_members): Handle return value of check_class_members.\n        (resolve_structure_cons, resolve_actual_arglist, resolve_function,\n        check_dimension, compare_spec_to_ref, resolve_array_ref,\n        resolve_ref, resolve_variable, gfc_resolve_expr, conformable_arrays,\n        resolve_allocate_expr, resolve_ordinary_assign): Add coarray\n        support.\n        * trans-array.c (gfc_conv_array_ref, gfc_walk_variable_expr):\n        Skip over coarray refs.\n        (gfc_array_allocate) Add support for references containing coindexes.\n        * trans-expr.c (gfc_add_interface_mapping): Copy coarray\n        * attribute.\n        (gfc_map_intrinsic_function): Ignore codimensions.\n\n2010-04-09  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_7.f90: New test.\n        * gfortran.dg/coarray_8.f90: New test.\n\nFrom-SVN: r158149", "tree": {"sha": "c5824608230be7c5a1ca050d3176ffd9450f386d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c5824608230be7c5a1ca050d3176ffd9450f386d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "824935eed311fc4a22682c800c29737788adfa26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/824935eed311fc4a22682c800c29737788adfa26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/824935eed311fc4a22682c800c29737788adfa26"}], "stats": {"total": 1305, "additions": 1212, "deletions": 93}, "files": [{"sha": "96efee0700fd560bb3ee49fb380f3818c942ef8a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1,3 +1,39 @@\n+2010-04-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* decl.c (variable_decl, match_attr_spec): Fix setting the array\n+\tspec.\n+\t* array.c (match_subscript,gfc_match_array_ref): Add coarray support.\n+\t* data.c (gfc_assign_data_value): Ditto.\n+\t* expr.c (gfc_check_pointer_assign): Add check for coarray constraint.\n+\t(gfc_traverse_expr): Traverse also through codimension expressions.\n+\t(gfc_is_coindexed, gfc_has_ultimate_allocatable,\n+\tgfc_has_ultimate_pointer): New functions.\n+\t* gfortran.h (gfc_array_ref_dimen_type): Add DIMEN_STAR for coarrays.\n+\t(gfc_array_ref): Add codimen.\n+\t(gfc_array_ref): Add in_allocate.\n+\t(gfc_is_coindexed, gfc_has_ultimate_allocatable,\n+\tgfc_has_ultimate_pointer): Add prototypes.\n+\t* interface.c (compare_parameter, compare_actual_formal,\n+\tcheck_intents): Add coarray constraints.\n+\t* match.c (gfc_match_iterator): Add coarray constraint.\n+\t* match.h (gfc_match_array_ref): Update interface.\n+\t* primary.c (gfc_match_varspec): Handle codimensions.\n+\t* resolve.c (coarray_alloc, inquiry_argument): New static variables.\n+\t(check_class_members): Return gfc_try instead for error recovery.\n+\t(resolve_typebound_function,resolve_typebound_subroutine,\n+\tcheck_members): Handle return value of check_class_members.\n+\t(resolve_structure_cons, resolve_actual_arglist, resolve_function,\n+\tcheck_dimension, compare_spec_to_ref, resolve_array_ref,\n+\tresolve_ref, resolve_variable, gfc_resolve_expr, conformable_arrays,\n+\tresolve_allocate_expr, resolve_ordinary_assign): Add coarray\n+\tsupport.\n+\t* trans-array.c (gfc_conv_array_ref, gfc_walk_variable_expr):\n+\tSkip over coarray refs.\n+\t(gfc_array_allocate) Add support for references containing coindexes.\n+\t* trans-expr.c (gfc_add_interface_mapping): Copy coarray attribute.\n+\t(gfc_map_intrinsic_function): Ignore codimensions.\n+\n 2010-04-08  Bud Davis  <bdavis9659@sbcglobal.net>\n \n \tPR fortran/28039"}, {"sha": "5ceca4bfa85bafb11a9a6de921f91a43aa36fd02", "filename": "gcc/fortran/array.c", "status": "modified", "additions": 90, "deletions": 20, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -61,12 +61,13 @@ gfc_copy_array_ref (gfc_array_ref *src)\n    expression.  */\n \n static match\n-match_subscript (gfc_array_ref *ar, int init)\n+match_subscript (gfc_array_ref *ar, int init, bool match_star)\n {\n   match m;\n+  bool star = false;\n   int i;\n \n-  i = ar->dimen;\n+  i = ar->dimen + ar->codimen;\n \n   ar->c_where[i] = gfc_current_locus;\n   ar->start[i] = ar->end[i] = ar->stride[i] = NULL;\n@@ -81,9 +82,12 @@ match_subscript (gfc_array_ref *ar, int init)\n     goto end_element;\n \n   /* Get start element.  */\n-  if (init)\n+  if (match_star && (m = gfc_match_char ('*')) == MATCH_YES)\n+    star = true;\n+\n+  if (!star && init)\n     m = gfc_match_init_expr (&ar->start[i]);\n-  else\n+  else if (!star)\n     m = gfc_match_expr (&ar->start[i]);\n \n   if (m == MATCH_NO)\n@@ -92,14 +96,22 @@ match_subscript (gfc_array_ref *ar, int init)\n     return MATCH_ERROR;\n \n   if (gfc_match_char (':') == MATCH_NO)\n-    return MATCH_YES;\n+    goto matched;\n+\n+  if (star)\n+    {\n+      gfc_error (\"Unexpected '*' in coarray subscript at %C\");\n+      return MATCH_ERROR;\n+    }\n \n   /* Get an optional end element.  Because we've seen the colon, we\n      definitely have a range along this dimension.  */\n end_element:\n   ar->dimen_type[i] = DIMEN_RANGE;\n \n-  if (init)\n+  if (match_star && (m = gfc_match_char ('*')) == MATCH_YES)\n+    star = true;\n+  else if (init)\n     m = gfc_match_init_expr (&ar->end[i]);\n   else\n     m = gfc_match_expr (&ar->end[i]);\n@@ -110,6 +122,12 @@ match_subscript (gfc_array_ref *ar, int init)\n   /* See if we have an optional stride.  */\n   if (gfc_match_char (':') == MATCH_YES)\n     {\n+      if (star)\n+\t{\n+\t  gfc_error (\"Strides not allowed in coarray subscript at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+\n       m = init ? gfc_match_init_expr (&ar->stride[i])\n \t       : gfc_match_expr (&ar->stride[i]);\n \n@@ -119,6 +137,10 @@ match_subscript (gfc_array_ref *ar, int init)\n \treturn MATCH_ERROR;\n     }\n \n+matched:\n+  if (star)\n+    ar->dimen_type[i] = DIMEN_STAR;\n+\n   return MATCH_YES;\n }\n \n@@ -128,14 +150,23 @@ match_subscript (gfc_array_ref *ar, int init)\n    to consist of init expressions.  */\n \n match\n-gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init)\n+gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init,\n+\t\t     int corank)\n {\n   match m;\n+  bool matched_bracket = false;\n \n   memset (ar, '\\0', sizeof (ar));\n \n   ar->where = gfc_current_locus;\n   ar->as = as;\n+  ar->type = AR_UNKNOWN;\n+\n+  if (gfc_match_char ('[') == MATCH_YES)\n+    {\n+       matched_bracket = true;\n+       goto coarray;\n+    }\n \n   if (gfc_match_char ('(') != MATCH_YES)\n     {\n@@ -144,34 +175,73 @@ gfc_match_array_ref (gfc_array_ref *ar, gfc_array_spec *as, int init)\n       return MATCH_YES;\n     }\n \n-  ar->type = AR_UNKNOWN;\n-\n   for (ar->dimen = 0; ar->dimen < GFC_MAX_DIMENSIONS; ar->dimen++)\n     {\n-      m = match_subscript (ar, init);\n+      m = match_subscript (ar, init, false);\n       if (m == MATCH_ERROR)\n-\tgoto error;\n+\treturn MATCH_ERROR;\n \n       if (gfc_match_char (')') == MATCH_YES)\n-\tgoto matched;\n+\t{\n+\t  ar->dimen++;\n+\t  goto coarray;\n+\t}\n \n       if (gfc_match_char (',') != MATCH_YES)\n \t{\n \t  gfc_error (\"Invalid form of array reference at %C\");\n-\t  goto error;\n+\t  return MATCH_ERROR;\n \t}\n     }\n \n   gfc_error (\"Array reference at %C cannot have more than %d dimensions\",\n \t     GFC_MAX_DIMENSIONS);\n-\n-error:\n   return MATCH_ERROR;\n \n-matched:\n-  ar->dimen++;\n+coarray:\n+  if (!matched_bracket && gfc_match_char ('[') != MATCH_YES)\n+    {\n+      if (ar->dimen > 0)\n+\treturn MATCH_YES;\n+      else\n+\treturn MATCH_ERROR;\n+    }\n+\n+  if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n+    {\n+      gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      return MATCH_ERROR;\n+    }\n+\n+  if (corank == 0)\n+    {\n+\tgfc_error (\"Unexpected coarray designator at %C\");\n+\treturn MATCH_ERROR;\n+    }\n+\n+  for (ar->codimen = 0; ar->codimen + ar->dimen < GFC_MAX_DIMENSIONS; ar->codimen++)\n+    {\n+      m = match_subscript (ar, init, ar->codimen == (corank - 1));\n+      if (m == MATCH_ERROR)\n+\treturn MATCH_ERROR;\n+\n+      if (gfc_match_char (']') == MATCH_YES)\n+\t{\n+\t  ar->codimen++;\n+\t  return MATCH_YES;\n+\t}\n+\n+      if (gfc_match_char (',') != MATCH_YES)\n+\t{\n+\t  gfc_error (\"Invalid form of coarray reference at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+\n+  gfc_error (\"Array reference at %C cannot have more than %d dimensions\",\n+\t     GFC_MAX_DIMENSIONS);\n+  return MATCH_ERROR;\n \n-  return MATCH_YES;\n }\n \n \n@@ -460,8 +530,8 @@ gfc_match_array_spec (gfc_array_spec **asp, bool match_dim, bool match_codim)\n \n   if (gfc_option.coarray == GFC_FCOARRAY_NONE)\n     {\n-       gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n-       goto cleanup;\n+      gfc_error (\"Coarrays disabled at %C, use -fcoarray= to enable\");\n+      goto cleanup;\n     }\n \n   for (;;)"}, {"sha": "16cd8998a3da1378c5c391183a3c5616105a5ee9", "filename": "gcc/fortran/data.c", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -289,6 +289,14 @@ gfc_assign_data_value (gfc_expr *lvalue, gfc_expr *rvalue, mpz_t index)\n       switch (ref->type)\n \t{\n \tcase REF_ARRAY:\n+\t  if (ref->u.ar.as->rank == 0)\n+\t    {\n+\t      gcc_assert (ref->u.ar.as->corank > 0);\n+\t      if (init == NULL)\n+\t\tgfc_free (expr);\n+\t      continue;\n+\t    }\n+\n \t  if (init && expr->expr_type != EXPR_ARRAY)\n \t    {\n \t      gfc_error (\"'%s' at %L already is initialized at %L\","}, {"sha": "a9cd98429d4a5426c80277f7a04d24ca5837cfcb", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 72, "deletions": 14, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -570,6 +570,62 @@ gfc_match_data (void)\n \n /************************ Declaration statements *********************/\n \n+\n+/* Auxilliary function to merge DIMENSION and CODIMENSION array specs.  */\n+\n+static void\n+merge_array_spec (gfc_array_spec *from, gfc_array_spec *to, bool copy)\n+{\n+  int i;\n+\n+  if (to->rank == 0 && from->rank > 0)\n+    {\n+      to->rank = from->rank;\n+      to->type = from->type;\n+      to->cray_pointee = from->cray_pointee;\n+      to->cp_was_assumed = from->cp_was_assumed;\n+\n+      for (i = 0; i < to->corank; i++)\n+\t{\n+\t  to->lower[from->rank + i] = to->lower[i];\n+\t  to->upper[from->rank + i] = to->upper[i];\n+\t}\n+      for (i = 0; i < from->rank; i++)\n+\t{\n+\t  if (copy)\n+\t    {\n+\t      to->lower[i] = gfc_copy_expr (from->lower[i]);\n+\t      to->upper[i] = gfc_copy_expr (from->upper[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      to->lower[i] = from->lower[i];\n+\t      to->upper[i] = from->upper[i];\n+\t    }\n+\t}\n+    }\n+  else if (to->corank == 0 && from->corank > 0)\n+    {\n+      to->corank = from->corank;\n+      to->cotype = from->cotype;\n+\n+      for (i = 0; i < from->corank; i++)\n+\t{\n+\t  if (copy)\n+\t    {\n+\t      to->lower[to->rank + i] = gfc_copy_expr (from->lower[i]);\n+\t      to->upper[to->rank + i] = gfc_copy_expr (from->upper[i]);\n+\t    }\n+\t  else\n+\t    {\n+\t      to->lower[to->rank + i] = from->lower[i];\n+\t      to->upper[to->rank + i] = from->upper[i];\n+\t    }\n+\t}\n+    }\n+}\n+\n+\n /* Match an intent specification.  Since this can only happen after an\n    INTENT word, a legal intent-spec must follow.  */\n \n@@ -1603,6 +1659,8 @@ variable_decl (int elem)\n \n   if (m == MATCH_NO)\n     as = gfc_copy_array_spec (current_as);\n+  else if (current_as)\n+    merge_array_spec (current_as, as, true);\n \n   char_len = NULL;\n   cl = NULL;\n@@ -3050,27 +3108,27 @@ match_attr_spec (void)\n       seen[d]++;\n       seen_at[d] = gfc_current_locus;\n \n-      if (d == DECL_DIMENSION)\n+      if (d == DECL_DIMENSION || d == DECL_CODIMENSION)\n \t{\n-\t  m = gfc_match_array_spec (&current_as, true, false);\n+\t  gfc_array_spec *as = NULL;\n \n-\t  if (m == MATCH_NO)\n+\t  m = gfc_match_array_spec (&as, d == DECL_DIMENSION,\n+\t\t\t\t    d == DECL_CODIMENSION);\n+\n+\t  if (current_as == NULL)\n+\t    current_as = as;\n+\t  else if (m == MATCH_YES)\n \t    {\n-\t      gfc_error (\"Missing dimension specification at %C\");\n-\t      m = MATCH_ERROR;\n+\t      merge_array_spec (as, current_as, false);\n+\t      gfc_free (as);\n \t    }\n \n-\t  if (m == MATCH_ERROR)\n-\t    goto cleanup;\n-\t}\n-\n-      if (d == DECL_CODIMENSION)\n-\t{\n-\t  m = gfc_match_array_spec (&current_as, false, true);\n-\n \t  if (m == MATCH_NO)\n \t    {\n-\t      gfc_error (\"Missing codimension specification at %C\");\n+\t      if (d == DECL_CODIMENSION)\n+\t\tgfc_error (\"Missing codimension specification at %C\");\n+\t      else\n+\t\tgfc_error (\"Missing dimension specification at %C\");\n \t      m = MATCH_ERROR;\n \t    }\n "}, {"sha": "2200a805b449b9990156073b63e546ccf61b3143", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 102, "deletions": 1, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -3205,6 +3205,20 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n   if (rvalue->expr_type == EXPR_NULL && rvalue->ts.type == BT_UNKNOWN)\n     return SUCCESS;\n \n+  /* F2008, C723 (pointer) and C726 (proc-pointer); for PURE also C1283.  */\n+  if (lvalue->expr_type == EXPR_VARIABLE\n+      && gfc_is_coindexed (lvalue))\n+    {\n+      gfc_ref *ref;\n+      for (ref = lvalue->ref; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY && ref->u.ar.codimen)\n+\t  {\n+\t    gfc_error (\"Pointer object at %L shall not have a coindex\",\n+\t\t       &lvalue->where);\n+\t    return FAILURE;\n+\t  }\n+    }\n+\n   /* Checks on rvalue for procedure pointer assignments.  */\n   if (proc_pointer)\n     {\n@@ -3369,6 +3383,20 @@ gfc_check_pointer_assign (gfc_expr *lvalue, gfc_expr *rvalue)\n       return FAILURE;\n     }\n \n+  /* F2008, C725. For PURE also C1283.  */\n+  if (rvalue->expr_type == EXPR_VARIABLE\n+      && gfc_is_coindexed (rvalue))\n+    {\n+      gfc_ref *ref;\n+      for (ref = rvalue->ref; ref; ref = ref->next)\n+\tif (ref->type == REF_ARRAY && ref->u.ar.codimen)\n+\t  {\n+\t    gfc_error (\"Data target at %L shall not have a coindex\",\n+\t\t       &rvalue->where);\n+\t    return FAILURE;\n+\t  }\n+    }\n+\n   return SUCCESS;\n }\n \n@@ -3642,7 +3670,8 @@ gfc_traverse_expr (gfc_expr *expr, gfc_symbol *sym,\n \t    return true;\n \n \t  if (ref->u.c.component->as)\n-\t    for (i = 0; i < ref->u.c.component->as->rank; i++)\n+\t    for (i = 0; i < ref->u.c.component->as->rank\n+\t\t\t    + ref->u.c.component->as->corank; i++)\n \t      {\n \t\tif (gfc_traverse_expr (ref->u.c.component->as->lower[i],\n \t\t\t\t       sym, func, f))\n@@ -3836,3 +3865,75 @@ gfc_expr_replace_comp (gfc_expr *expr, gfc_component *dest)\n   gfc_traverse_expr (expr, (gfc_symbol *)dest, &replace_comp, 0);\n }\n \n+\n+bool\n+gfc_is_coindexed (gfc_expr *e)\n+{\n+  gfc_ref *ref;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+      return true;\n+\n+  return false;\n+}\n+\n+\n+/* Check whether the expression has an ultimate allocatable component.\n+   Being itself allocatable does not count.  */\n+bool\n+gfc_has_ultimate_allocatable (gfc_expr *e)\n+{\n+  gfc_ref *ref, *last = NULL;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT)\n+      last = ref;\n+\n+  if (last && last->u.c.component->ts.type == BT_CLASS)\n+    return last->u.c.component->ts.u.derived->components->attr.alloc_comp;\n+  else if (last && last->u.c.component->ts.type == BT_DERIVED)\n+    return last->u.c.component->ts.u.derived->attr.alloc_comp;\n+  else if (last)\n+    return false;\n+\n+  if (e->ts.type == BT_CLASS)\n+    return e->ts.u.derived->components->attr.alloc_comp;\n+  else if (e->ts.type == BT_DERIVED)\n+    return e->ts.u.derived->attr.alloc_comp;\n+  else\n+    return false;\n+}\n+\n+\n+/* Check whether the expression has an pointer component.\n+   Being itself a pointer does not count.  */\n+bool\n+gfc_has_ultimate_pointer (gfc_expr *e)\n+{\n+  gfc_ref *ref, *last = NULL;\n+\n+  if (e->expr_type != EXPR_VARIABLE)\n+    return false;\n+\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->type == REF_COMPONENT)\n+      last = ref;\n+ \n+  if (last && last->u.c.component->ts.type == BT_CLASS)\n+    return last->u.c.component->ts.u.derived->components->attr.pointer_comp;\n+  else if (last && last->u.c.component->ts.type == BT_DERIVED)\n+    return last->u.c.component->ts.u.derived->attr.pointer_comp;\n+  else if (last)\n+    return false;\n+\n+  if (e->ts.type == BT_CLASS)\n+    return e->ts.u.derived->components->attr.pointer_comp;\n+  else if (e->ts.type == BT_DERIVED)\n+    return e->ts.u.derived->attr.pointer_comp;\n+  else\n+    return false;\n+}"}, {"sha": "3668df4a3966d2188d1702c7c651390d17ffb3c3", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1444,13 +1444,15 @@ extern gfc_interface_info current_interface;\n \n enum gfc_array_ref_dimen_type\n {\n-  DIMEN_ELEMENT = 1, DIMEN_RANGE, DIMEN_VECTOR, DIMEN_UNKNOWN\n+  DIMEN_ELEMENT = 1, DIMEN_RANGE, DIMEN_VECTOR, DIMEN_STAR, DIMEN_UNKNOWN\n };\n \n typedef struct gfc_array_ref\n {\n   ar_type type;\n   int dimen;\t\t\t/* # of components in the reference */\n+  int codimen;\n+  bool in_allocate;\t\t/* For coarray checks. */\n   locus where;\n   gfc_array_spec *as;\n \n@@ -2642,6 +2644,11 @@ void gfc_expr_replace_comp (gfc_expr *, gfc_component *);\n \n bool gfc_is_proc_ptr_comp (gfc_expr *, gfc_component **);\n \n+bool gfc_is_coindexed (gfc_expr *);\n+bool gfc_has_ultimate_allocatable (gfc_expr *);\n+bool gfc_has_ultimate_pointer (gfc_expr *);\n+\n+\n /* st.c */\n extern gfc_code new_st;\n "}, {"sha": "9dd797be8cd95cc529bcf5fdd238bff5d0ab12f9", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 146, "deletions": 2, "changes": 148, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1445,6 +1445,65 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n       return 0;\n     }\n \n+  if (formal->attr.codimension)\n+    {\n+      gfc_ref *last = NULL;\n+\n+      if (actual->expr_type != EXPR_VARIABLE\n+\t  || (actual->ref == NULL\n+\t      && !actual->symtree->n.sym->attr.codimension))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to '%s' at %L must be a coarray\",\n+\t\t       formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+\n+      for (ref = actual->ref; ref; ref = ref->next)\n+\t{\n+\t  if (ref->type == REF_ARRAY && ref->u.ar.codimen != 0)\n+\t    {\n+\t      if (where)\n+\t\tgfc_error (\"Actual argument to '%s' at %L must be a coarray \"\n+\t\t\t   \"and not coindexed\", formal->name, &ref->u.ar.where);\n+\t      return 0;\n+\t    }\n+\t  if (ref->type == REF_ARRAY && ref->u.ar.as->corank\n+\t      && ref->u.ar.type != AR_FULL && ref->u.ar.dimen != 0)\n+\t    {\n+\t      if (where)\n+\t\tgfc_error (\"Actual argument to '%s' at %L must be a coarray \"\n+\t\t\t   \"and thus shall not have an array designator\",\n+\t\t\t   formal->name, &ref->u.ar.where);\n+\t      return 0;\n+\t    }\n+\t  if (ref->type == REF_COMPONENT)\n+\t    last = ref;\n+\t}\n+\n+      if (last && !last->u.c.component->attr.codimension)\n+      \t{\n+\t  if (where)\n+\t    gfc_error (\"Actual argument to '%s' at %L must be a coarray\",\n+\t\t       formal->name, &actual->where);\n+\t  return 0;\n+\t}\n+\n+      /* F2008, 12.5.2.6.  */\n+      if (formal->attr.allocatable &&\n+\t  ((last && last->u.c.component->as->corank != formal->as->corank)\n+\t   || (!last\n+\t       && actual->symtree->n.sym->as->corank != formal->as->corank)))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Corank mismatch in argument '%s' at %L (%d and %d)\",\n+\t\t   formal->name, &actual->where, formal->as->corank,\n+\t\t   last ? last->u.c.component->as->corank\n+\t\t\t: actual->symtree->n.sym->as->corank);\n+\t  return 0;\n+\t}\n+    }\n+\n   if (symbol_rank (formal) == actual->rank)\n     return 1;\n \n@@ -1453,10 +1512,13 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n \t\t   || formal->as->type == AS_DEFERRED)\n \t       && actual->expr_type != EXPR_NULL;\n \n+  /* Scalar & coindexed, see: F2008, Section 12.5.2.4.  */\n   if (rank_check || ranks_must_agree\n       || (formal->attr.pointer && actual->expr_type != EXPR_NULL)\n       || (actual->rank != 0 && !(is_elemental || formal->attr.dimension))\n-      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE))\n+      || (actual->rank == 0 && formal->as->type == AS_ASSUMED_SHAPE)\n+      || (actual->rank == 0 && formal->attr.dimension\n+\t  && gfc_is_coindexed (actual)))\n     {\n       if (where)\n \tgfc_error (\"Rank mismatch in argument '%s' at %L (%d and %d)\",\n@@ -1474,7 +1536,8 @@ compare_parameter (gfc_symbol *formal, gfc_expr *actual,\n      - (F2003) if the actual argument is of type character.  */\n \n   for (ref = actual->ref; ref; ref = ref->next)\n-    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT)\n+    if (ref->type == REF_ARRAY && ref->u.ar.type == AR_ELEMENT\n+\t&& ref->u.ar.dimen > 0)\n       break;\n \n   /* Not an array element.  */\n@@ -1984,6 +2047,57 @@ compare_actual_formal (gfc_actual_arglist **ap, gfc_formal_arglist *formal,\n \t  return 0;\n \t}\n \n+      /* Fortran 2008, C1242.  */\n+      if (f->sym->attr.pointer && gfc_is_coindexed (a->expr))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Coindexed actual argument at %L to pointer \"\n+\t\t       \"dummy '%s'\",\n+\t\t       &a->expr->where, f->sym->name);\n+\t  return 0;\n+\t}\n+\n+      /* Fortran 2008, 12.5.2.5 (no constraint).  */\n+      if (a->expr->expr_type == EXPR_VARIABLE\n+\t  && f->sym->attr.intent != INTENT_IN\n+\t  && f->sym->attr.allocatable\n+\t  && gfc_is_coindexed (a->expr))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Coindexed actual argument at %L to allocatable \"\n+\t\t       \"dummy '%s' requires INTENT(IN)\",\n+\t\t       &a->expr->where, f->sym->name);\n+\t  return 0;\n+\t}\n+\n+      /* Fortran 2008, C1237.  */\n+      if (a->expr->expr_type == EXPR_VARIABLE\n+\t  && (f->sym->attr.asynchronous || f->sym->attr.volatile_)\n+\t  && gfc_is_coindexed (a->expr)\n+\t  && (a->expr->symtree->n.sym->attr.volatile_\n+\t      || a->expr->symtree->n.sym->attr.asynchronous))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Coindexed ASYNCHRONOUS or VOLATILE actual argument at \"\n+\t\t       \"at %L requires that dummy %s' has neither \"\n+\t\t       \"ASYNCHRONOUS nor VOLATILE\", &a->expr->where,\n+\t\t       f->sym->name);\n+\t  return 0;\n+\t}\n+\n+      /* Fortran 2008, 12.5.2.4 (no constraint).  */\n+      if (a->expr->expr_type == EXPR_VARIABLE\n+\t  && f->sym->attr.intent != INTENT_IN && !f->sym->attr.value\n+\t  && gfc_is_coindexed (a->expr)\n+\t  && gfc_has_ultimate_allocatable (a->expr))\n+\t{\n+\t  if (where)\n+\t    gfc_error (\"Coindexed actual argument at %L with allocatable \"\n+\t\t       \"ultimate component to dummy '%s' requires either VALUE \"\n+\t\t       \"or INTENT(IN)\", &a->expr->where, f->sym->name);\n+\t  return 0;\n+\t}\n+\n       if (a->expr->expr_type != EXPR_NULL\n \t  && compare_allocatable (f->sym, a->expr) == 0)\n \t{\n@@ -2367,6 +2481,36 @@ check_intents (gfc_formal_arglist *f, gfc_actual_arglist *a)\n \t      return FAILURE;\n \t    }\n \t}\n+\n+       /* Fortran 2008, C1283.  */\n+       if (gfc_pure (NULL) && gfc_is_coindexed (a->expr))\n+\t{\n+\t  if (f_intent == INTENT_INOUT || f_intent == INTENT_OUT)\n+\t    {\n+\t      gfc_error (\"Coindexed actual argument at %L in PURE procedure \"\n+\t\t\t \"is passed to an INTENT(%s) argument\",\n+\t\t\t &a->expr->where, gfc_intent_string (f_intent));\n+\t      return FAILURE;\n+\t    }\n+\n+\t  if (f->sym->attr.pointer)\n+\t    {\n+\t      gfc_error (\"Coindexed actual argument at %L in PURE procedure \"\n+\t\t\t \"is passed to a POINTER dummy argument\",\n+\t\t\t &a->expr->where);\n+\t      return FAILURE;\n+\t    }\n+\t}\n+\n+       /* F2008, Section 12.5.2.4.  */\n+       if (a->expr->ts.type == BT_CLASS && f->sym->ts.type == BT_CLASS\n+\t   && gfc_is_coindexed (a->expr))\n+\t {\n+\t   gfc_error (\"Coindexed polymorphic actual argument at %L is passed \"\n+\t\t      \"polymorphic dummy argument '%s'\",\n+\t\t\t &a->expr->where, f->sym->name);\n+\t   return FAILURE;\n+\t }\n     }\n \n   return SUCCESS;"}, {"sha": "2709de7236cf33c51e2dd031d4aa6e576272b073", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -949,6 +949,8 @@ gfc_match_iterator (gfc_iterator *iter, int init_flag)\n   locus start;\n   match m;\n \n+  e1 = e2 = e3 = NULL;\n+\n   /* Match the start of an iterator without affecting the symbol table.  */\n \n   start = gfc_current_locus;\n@@ -962,9 +964,12 @@ gfc_match_iterator (gfc_iterator *iter, int init_flag)\n   if (m != MATCH_YES)\n     return MATCH_NO;\n \n-  gfc_match_char ('=');\n-\n-  e1 = e2 = e3 = NULL;\n+  /* F2008, C617 & C565.  */\n+  if (var->symtree->n.sym->attr.codimension)\n+    {\n+      gfc_error (\"Loop variable at %C cannot be a coarray\");\n+      goto cleanup;\n+    }\n \n   if (var->ref != NULL)\n     {\n@@ -979,6 +984,8 @@ gfc_match_iterator (gfc_iterator *iter, int init_flag)\n       goto cleanup;\n     }\n \n+  gfc_match_char ('=');\n+\n   var->symtree->n.sym->attr.implied_index = 1;\n \n   m = init_flag ? gfc_match_init_expr (&e1) : gfc_match_expr (&e1);"}, {"sha": "67e77418a795a1084c9647fc472d1a3d50842533", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -216,7 +216,7 @@ match gfc_match_init_expr (gfc_expr **);\n \n /* array.c.  */\n match gfc_match_array_spec (gfc_array_spec **, bool, bool);\n-match gfc_match_array_ref (gfc_array_ref *, gfc_array_spec *, int);\n+match gfc_match_array_ref (gfc_array_ref *, gfc_array_spec *, int, int);\n match gfc_match_array_constructor (gfc_expr **);\n \n /* interface.c.  */"}, {"sha": "34b687471bf28de621d8cdf587d6de4923b09e24", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 43, "deletions": 5, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1746,7 +1746,25 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n   tail = NULL;\n \n   gfc_gobble_whitespace ();\n+\n+  if (gfc_peek_ascii_char () == '[')\n+    {\n+      if (sym->attr.dimension)\n+\t{\n+\t  gfc_error (\"Array section designator, e.g. '(:)', is required \"\n+\t\t     \"besides the coarray designator '[...]' at %C\");\n+\t  return MATCH_ERROR;\n+\t}\n+      if (!sym->attr.codimension)\n+\t{\n+\t  gfc_error (\"Coarray designator at %C but '%s' is not a coarray\",\n+\t\t     sym->name);\n+\t  return MATCH_ERROR;\n+\t}\n+    }\n+\n   if ((equiv_flag && gfc_peek_ascii_char () == '(')\n+      || gfc_peek_ascii_char () == '[' || sym->attr.codimension\n       || (sym->attr.dimension && !sym->attr.proc_pointer\n \t  && !gfc_is_proc_ptr_comp (primary, NULL)\n \t  && !(gfc_matching_procptr_assignment\n@@ -1761,7 +1779,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n       tail->type = REF_ARRAY;\n \n       m = gfc_match_array_ref (&tail->u.ar, equiv_flag ? NULL : sym->as,\n-\t\t\t       equiv_flag);\n+\t\t\t       equiv_flag, sym->as ? sym->as->corank : 0);\n       if (m != MATCH_YES)\n \treturn m;\n \n@@ -1771,7 +1789,7 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  tail = extend_ref (primary, tail);\n \t  tail->type = REF_ARRAY;\n \n-\t  m = gfc_match_array_ref (&tail->u.ar, NULL, equiv_flag);\n+\t  m = gfc_match_array_ref (&tail->u.ar, NULL, equiv_flag, 0);\n \t  if (m != MATCH_YES)\n \t    return m;\n \t}\n@@ -1881,7 +1899,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t  tail = extend_ref (primary, tail);\n \t  tail->type = REF_ARRAY;\n \n-\t  m = gfc_match_array_ref (&tail->u.ar, component->as, equiv_flag);\n+\t  m = gfc_match_array_ref (&tail->u.ar, component->as, equiv_flag,\n+\t\t\t  component->as->corank);\n \t  if (m != MATCH_YES)\n \t    return m;\n \t}\n@@ -1894,7 +1913,8 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \n \t  m = gfc_match_array_ref (&tail->u.ar,\n \t\t\t\t   component->ts.u.derived->components->as,\n-\t\t\t\t   equiv_flag);\n+\t\t\t\t   equiv_flag,\n+\t\t\t   component->ts.u.derived->components->as->corank);\n \t  if (m != MATCH_YES)\n \t    return m;\n \t}\n@@ -1949,6 +1969,13 @@ gfc_match_varspec (gfc_expr *primary, int equiv_flag, bool sub_flag,\n \t}\n     }\n \n+  /* F2008, C727.  */\n+  if (primary->expr_type == EXPR_PPC && gfc_is_coindexed (primary))\n+    {\n+      gfc_error (\"Coindexed procedure-pointer component at %C\");\n+      return MATCH_ERROR;\n+    }\n+\n   return MATCH_YES;\n }\n \n@@ -2023,7 +2050,9 @@ gfc_variable_attr (gfc_expr *expr, gfc_typespec *ts)\n \t    break;\n \n \t  case AR_ELEMENT:\n-\t    allocatable = pointer = 0;\n+\t    /* Handle coarrays.  */\n+\t    if (ref->u.ar.dimen > 0)\n+\t      allocatable = pointer = 0;\n \t    break;\n \n \t  case AR_UNKNOWN:\n@@ -2349,6 +2378,15 @@ gfc_match_structure_constructor (gfc_symbol *sym, gfc_expr **result,\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \n+\t  /* F2008, R457/C725, for PURE C1283.  */\n+          if (this_comp->attr.pointer && gfc_is_coindexed (comp_tail->val))\n+\t    {\n+\t      gfc_error (\"Coindexed expression to pointer component '%s' in \"\n+\t\t\t \"structure constructor at %C!\", comp_tail->name);\n+\t      goto cleanup;\n+ \t    }\n+\n+\n \t  /* If not explicitly a parent constructor, gather up the components\n \t     and build one.  */\n \t  if (comp && comp == sym->components"}, {"sha": "5e9b25c8a160b3a94e356b519ca3bc9745daf780", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 278, "deletions": 43, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -77,6 +77,9 @@ static int current_entry_id;\n /* We use bitmaps to determine if a branch target is valid.  */\n static bitmap_obstack labels_obstack;\n \n+/* True when simplifying a EXPR_VARIABLE argument to an inquiry function.  */\n+static bool inquiry_argument = false;\n+\n int\n gfc_is_formal_arg (void)\n {\n@@ -932,12 +935,13 @@ resolve_structure_cons (gfc_expr *expr)\n \n       /* F2003, C1272 (3).  */\n       if (gfc_pure (NULL) && cons->expr->expr_type == EXPR_VARIABLE\n-\t  && gfc_impure_variable (cons->expr->symtree->n.sym))\n+\t  && (gfc_impure_variable (cons->expr->symtree->n.sym)\n+\t      || gfc_is_coindexed (cons->expr)))\n \t{\n \t  t = FAILURE;\n-\t  gfc_error (\"Invalid expression in the derived type constructor for pointer \"\n-\t\t     \"component '%s' at %L in PURE procedure\", comp->name,\n-\t\t     &cons->expr->where);\n+\t  gfc_error (\"Invalid expression in the derived type constructor for \"\n+\t\t     \"pointer component '%s' at %L in PURE procedure\",\n+\t\t     comp->name, &cons->expr->where);\n \t}\n     }\n \n@@ -1319,7 +1323,7 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n   gfc_expr *e;\n   int save_need_full_assumed_size;\n   gfc_component *comp;\n-\t\n+\n   for (; arg; arg = arg->next)\n     {\n       e = arg->expr;\n@@ -1549,6 +1553,15 @@ resolve_actual_arglist (gfc_actual_arglist *arg, procedure_type ptype,\n \t\t}\n \t    }\n \t}\n+\n+      /* Fortran 2008, C1237.  */\n+      if (e->expr_type == EXPR_VARIABLE && gfc_is_coindexed (e)\n+          && gfc_has_ultimate_pointer (e))\n+        {\n+          gfc_error (\"Coindexed actual argument at %L with ultimate pointer \"\n+\t\t     \"component\", &e->where);\n+          return FAILURE;\n+        }\n     }\n \n   return SUCCESS;\n@@ -2590,11 +2603,19 @@ resolve_function (gfc_expr *expr)\n   if (expr->symtree && expr->symtree->n.sym)\n     p = expr->symtree->n.sym->attr.proc;\n \n+  if (expr->value.function.isym && expr->value.function.isym->inquiry)\n+    inquiry_argument = true;\n   no_formal_args = sym && is_external_proc (sym) && sym->formal == NULL;\n+\n   if (resolve_actual_arglist (expr->value.function.actual,\n \t\t\t      p, no_formal_args) == FAILURE)\n+    {\n+      inquiry_argument = false;\n       return FAILURE;\n+    }\n \n+  inquiry_argument = false;\n+ \n   /* Need to setup the call to the correct c_associated, depending on\n      the number of cptrs to user gives to compare.  */\n   if (sym && sym->attr.is_iso_c == 1)\n@@ -3755,6 +3776,17 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n {\n   mpz_t last_value;\n \n+  if (ar->dimen_type[i] == DIMEN_STAR)\n+    {\n+      gcc_assert (ar->stride[i] == NULL);\n+      /* This implies [*] as [*:] and [*:3] are not possible.  */\n+      if (ar->start[i] == NULL)\n+\t{\n+\t  gcc_assert (ar->end[i] == NULL);\n+\t  return SUCCESS;\n+\t}\n+    }\n+\n /* Given start, end and stride values, calculate the minimum and\n    maximum referenced indexes.  */\n \n@@ -3763,21 +3795,36 @@ check_dimension (int i, gfc_array_ref *ar, gfc_array_spec *as)\n     case DIMEN_VECTOR:\n       break;\n \n+    case DIMEN_STAR:\n     case DIMEN_ELEMENT:\n       if (compare_bound (ar->start[i], as->lower[i]) == CMP_LT)\n \t{\n-\t  gfc_warning (\"Array reference at %L is out of bounds \"\n-\t\t       \"(%ld < %ld) in dimension %d\", &ar->c_where[i],\n-\t\t       mpz_get_si (ar->start[i]->value.integer),\n-\t\t       mpz_get_si (as->lower[i]->value.integer), i+1);\n+\t  if (i < as->rank)\n+\t    gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t\t \"(%ld < %ld) in dimension %d\", &ar->c_where[i],\n+\t\t\t mpz_get_si (ar->start[i]->value.integer),\n+\t\t\t mpz_get_si (as->lower[i]->value.integer), i+1);\n+\t  else\n+\t    gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t\t \"(%ld < %ld) in codimension %d\", &ar->c_where[i],\n+\t\t\t mpz_get_si (ar->start[i]->value.integer),\n+\t\t\t mpz_get_si (as->lower[i]->value.integer),\n+\t\t\t i + 1 - as->rank);\n \t  return SUCCESS;\n \t}\n       if (compare_bound (ar->start[i], as->upper[i]) == CMP_GT)\n \t{\n-\t  gfc_warning (\"Array reference at %L is out of bounds \"\n-\t\t       \"(%ld > %ld) in dimension %d\", &ar->c_where[i],\n-\t\t       mpz_get_si (ar->start[i]->value.integer),\n-\t\t       mpz_get_si (as->upper[i]->value.integer), i+1);\n+\t  if (i < as->rank)\n+\t    gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t\t \"(%ld > %ld) in dimension %d\", &ar->c_where[i],\n+\t\t\t mpz_get_si (ar->start[i]->value.integer),\n+\t\t\t mpz_get_si (as->upper[i]->value.integer), i+1);\n+\t  else\n+\t    gfc_warning (\"Array reference at %L is out of bounds \"\n+\t\t\t \"(%ld > %ld) in codimension %d\", &ar->c_where[i],\n+\t\t\t mpz_get_si (ar->start[i]->value.integer),\n+\t\t\t mpz_get_si (as->upper[i]->value.integer),\n+\t\t\t i + 1 - as->rank);\n \t  return SUCCESS;\n \t}\n \n@@ -3897,10 +3944,32 @@ compare_spec_to_ref (gfc_array_ref *ar)\n       return FAILURE;\n     }\n \n+  /* ar->codimen == 0 is a local array.  */\n+  if (as->corank != ar->codimen && ar->codimen != 0)\n+    {\n+      gfc_error (\"Coindex rank mismatch in array reference at %L (%d/%d)\",\n+\t\t &ar->where, ar->codimen, as->corank);\n+      return FAILURE;\n+    }\n+\n   for (i = 0; i < as->rank; i++)\n     if (check_dimension (i, ar, as) == FAILURE)\n       return FAILURE;\n \n+  /* Local access has no coarray spec.  */\n+  if (ar->codimen != 0)\n+    for (i = as->rank; i < as->rank + as->corank; i++)\n+      {\n+\tif (ar->dimen_type[i] != DIMEN_ELEMENT && !ar->in_allocate)\n+\t  {\n+\t    gfc_error (\"Coindex of codimension %d must be a scalar at %L\",\n+\t\t       i + 1 - as->rank, &ar->where);\n+\t    return FAILURE;\n+\t  }\n+\tif (check_dimension (i, ar, as) == FAILURE)\n+\t  return FAILURE;\n+      }\n+\n   return SUCCESS;\n }\n \n@@ -4069,7 +4138,7 @@ resolve_array_ref (gfc_array_ref *ar)\n   int i, check_scalar;\n   gfc_expr *e;\n \n-  for (i = 0; i < ar->dimen; i++)\n+  for (i = 0; i < ar->dimen + ar->codimen; i++)\n     {\n       check_scalar = ar->dimen_type[i] == DIMEN_RANGE;\n \n@@ -4103,6 +4172,9 @@ resolve_array_ref (gfc_array_ref *ar)\n \t  }\n     }\n \n+  if (ar->type == AR_FULL && ar->as->rank == 0)\n+    ar->type = AR_ELEMENT;\n+\n   /* If the reference type is unknown, figure out what kind it is.  */\n \n   if (ar->type == AR_UNKNOWN)\n@@ -4307,6 +4379,13 @@ resolve_ref (gfc_expr *expr)\n \t  switch (ref->u.ar.type)\n \t    {\n \t    case AR_FULL:\n+\t      /* Coarray scalar.  */\n+\t      if (ref->u.ar.as->rank == 0)\n+\t\t{\n+\t\t  current_part_dimension = 0;\n+\t\t  break;\n+\t\t}\n+\t      /* Fall through.  */\n \t    case AR_SECTION:\n \t      current_part_dimension = 1;\n \t      break;\n@@ -4576,6 +4655,47 @@ resolve_variable (gfc_expr *e)\n   if (t == SUCCESS && resolve_procedure_expression (e) == FAILURE)\n     t = FAILURE;\n \n+  /* F2008, C617 and C1229.  */\n+  if (!inquiry_argument && (e->ts.type == BT_CLASS || e->ts.type == BT_DERIVED)\n+      && gfc_is_coindexed (e))\n+    {\n+      gfc_ref *ref, *ref2 = NULL;\n+\n+      if (e->ts.type == BT_CLASS)\n+\t{\n+\t  gfc_error (\"Polymorphic subobject of coindexed object at %L\",\n+\t\t     &e->where);\n+\t  t = FAILURE;\n+\t}\n+\n+      for (ref = e->ref; ref; ref = ref->next)\n+\t{\n+\t  if (ref->type == REF_COMPONENT)\n+\t    ref2 = ref;\n+\t  if (ref->type == REF_ARRAY && ref->u.ar.codimen > 0)\n+\t    break;\n+\t}\n+\n+      for ( ; ref; ref = ref->next)\n+\tif (ref->type == REF_COMPONENT)\n+\t  break;\n+\n+      /* Expression itself is coindexed object.  */\n+      if (ref == NULL)\n+\t{\n+\t  gfc_component *c;\n+\t  c = ref2 ? ref2->u.c.component : e->symtree->n.sym->components;\n+\t  for ( ; c; c = c->next)\n+\t    if (c->attr.allocatable && c->ts.type == BT_CLASS)\n+\t      {\n+\t\tgfc_error (\"Coindexed object with polymorphic allocatable \"\n+\t\t\t \"subcomponent at %L\", &e->where);\n+\t\tt = FAILURE;\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n   return t;\n }\n \n@@ -5163,7 +5283,7 @@ resolve_compcall (gfc_expr* e, bool fcn, bool class_members)\n    of f03 OOP.  As soon as vtables are in place and contain pointers\n    to methods, this will no longer be necessary.  */\n static gfc_expr *list_e;\n-static void check_class_members (gfc_symbol *);\n+static gfc_try check_class_members (gfc_symbol *);\n static gfc_try class_try;\n static bool fcn_flag;\n \n@@ -5172,11 +5292,11 @@ static void\n check_members (gfc_symbol *derived)\n {\n   if (derived->attr.flavor == FL_DERIVED)\n-    check_class_members (derived);\n+    (void) check_class_members (derived);\n }\n \n \n-static void \n+static gfc_try \n check_class_members (gfc_symbol *derived)\n {\n   gfc_expr *e;\n@@ -5193,7 +5313,7 @@ check_class_members (gfc_symbol *derived)\n     {\n       gfc_error (\"no typebound available procedure named '%s' at %L\",\n \t\t e->value.compcall.name, &e->where);\n-      return;\n+      return FAILURE;\n     }\n \n   /* If we have to match a passed class member, force the actual\n@@ -5203,6 +5323,9 @@ check_class_members (gfc_symbol *derived)\n       if (e->value.compcall.base_object == NULL)\n \te->value.compcall.base_object = extract_compcall_passed_object (e);\n \n+      if (e->value.compcall.base_object == NULL)\n+\treturn FAILURE;\n+\n       if (!derived->attr.abstract)\n \t{\n \t  e->value.compcall.base_object->ts.type = BT_DERIVED;\n@@ -5240,6 +5363,8 @@ check_class_members (gfc_symbol *derived)\n   /* Burrow down into grandchildren types.  */\n   if (derived->f2k_derived)\n     gfc_traverse_ns (derived->f2k_derived, check_members);\n+\n+  return SUCCESS;\n }\n \n \n@@ -5393,7 +5518,9 @@ resolve_typebound_function (gfc_expr* e)\n   class_try = SUCCESS;\n   fcn_flag = true;\n   list_e = gfc_copy_expr (e);\n-  check_class_members (derived);\n+\n+  if (check_class_members (derived) == FAILURE)\n+    return FAILURE;\n \n   class_try = (resolve_compcall (e, true, false) == SUCCESS)\n \t\t ? class_try : FAILURE;\n@@ -5453,7 +5580,9 @@ resolve_typebound_subroutine (gfc_code *code)\n   class_try = SUCCESS;\n   fcn_flag = false;\n   list_e = gfc_copy_expr (code->expr1);\n-  check_class_members (derived);\n+\n+  if (check_class_members (derived) == FAILURE)\n+    return FAILURE;\n \n   class_try = (resolve_typebound_call (code) == SUCCESS)\n \t\t ? class_try : FAILURE;\n@@ -5585,10 +5714,16 @@ gfc_try\n gfc_resolve_expr (gfc_expr *e)\n {\n   gfc_try t;\n+  bool inquiry_save;\n \n   if (e == NULL)\n     return SUCCESS;\n \n+  /* inquiry_argument only applies to variables.  */\n+  inquiry_save = inquiry_argument;\n+  if (e->expr_type != EXPR_VARIABLE)\n+    inquiry_argument = false;\n+\n   switch (e->expr_type)\n     {\n     case EXPR_OP:\n@@ -5676,6 +5811,8 @@ gfc_resolve_expr (gfc_expr *e)\n   if (e->ts.type == BT_CHARACTER && t == SUCCESS && !e->ts.u.cl)\n     fixup_charlen (e);\n \n+  inquiry_argument = inquiry_save;\n+\n   return t;\n }\n \n@@ -6123,6 +6260,7 @@ static gfc_try\n resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n {\n   int i, pointer, allocatable, dimension, check_intent_in, is_abstract;\n+  int codimension;\n   symbol_attribute attr;\n   gfc_ref *ref, *ref2;\n   gfc_array_ref *ar;\n@@ -6134,8 +6272,17 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n   /* Check INTENT(IN), unless the object is a sub-component of a pointer.  */\n   check_intent_in = 1;\n \n+  /* Mark the ultimost array component as being in allocate to allow DIMEN_STAR\n+     checking of coarrays.  */\n+  for (ref = e->ref; ref; ref = ref->next)\n+    if (ref->next == NULL)\n+      break;\n+\n+  if (ref && ref->type == REF_ARRAY)\n+    ref->u.ar.in_allocate = true;\n+\n   if (gfc_resolve_expr (e) == FAILURE)\n-    return FAILURE;\n+    goto failure;\n \n   /* Make sure the expression is allocatable or a pointer.  If it is\n      pointer, the next-to-last reference must be a pointer.  */\n@@ -6153,6 +6300,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n       attr = gfc_expr_attr (e);\n       pointer = attr.pointer;\n       dimension = attr.dimension;\n+      codimension = attr.codimension;\n     }\n   else\n     {\n@@ -6161,13 +6309,15 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t  allocatable = sym->ts.u.derived->components->attr.allocatable;\n \t  pointer = sym->ts.u.derived->components->attr.pointer;\n \t  dimension = sym->ts.u.derived->components->attr.dimension;\n+\t  codimension = sym->ts.u.derived->components->attr.codimension;\n \t  is_abstract = sym->ts.u.derived->components->attr.abstract;\n \t}\n       else\n \t{\n \t  allocatable = sym->attr.allocatable;\n \t  pointer = sym->attr.pointer;\n \t  dimension = sym->attr.dimension;\n+\t  codimension = sym->attr.codimension;\n \t}\n \n       for (ref = e->ref; ref; ref2 = ref, ref = ref->next)\n@@ -6183,19 +6333,29 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t\tbreak;\n \n \t      case REF_COMPONENT:\n+\t\t/* F2008, C644.  */\n+\t\tif (gfc_is_coindexed (e))\n+\t\t  {\n+\t\t    gfc_error (\"Coindexed allocatable object at %L\",\n+\t\t\t       &e->where);\n+\t\t    goto failure;\n+\t\t  }\n+\n \t\tc = ref->u.c.component;\n \t\tif (c->ts.type == BT_CLASS)\n \t\t  {\n \t\t    allocatable = c->ts.u.derived->components->attr.allocatable;\n \t\t    pointer = c->ts.u.derived->components->attr.pointer;\n \t\t    dimension = c->ts.u.derived->components->attr.dimension;\n+\t\t    codimension = c->ts.u.derived->components->attr.codimension;\n \t\t    is_abstract = c->ts.u.derived->components->attr.abstract;\n \t\t  }\n \t\telse\n \t\t  {\n \t\t    allocatable = c->attr.allocatable;\n \t\t    pointer = c->attr.pointer;\n \t\t    dimension = c->attr.dimension;\n+\t\t    codimension = c->attr.codimension;\n \t\t    is_abstract = c->attr.abstract;\n \t\t  }\n \t\tbreak;\n@@ -6212,7 +6372,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n     {\n       gfc_error (\"Allocate-object at %L must be ALLOCATABLE or a POINTER\",\n \t\t &e->where);\n-      return FAILURE;\n+      goto failure;\n     }\n \n   /* Some checks for the SOURCE tag.  */\n@@ -6223,36 +6383,36 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t{\n \t  gfc_error (\"Type of entity at %L is type incompatible with \"\n \t\t      \"source-expr at %L\", &e->where, &code->expr3->where);\n-\t  return FAILURE;\n+\t  goto failure;\n \t}\n \n       /* Check F03:C632 and restriction following Note 6.18.  */\n       if (code->expr3->rank > 0\n \t  && conformable_arrays (code->expr3, e) == FAILURE)\n-\treturn FAILURE;\n+\tgoto failure;\n \n       /* Check F03:C633.  */\n       if (code->expr3->ts.kind != e->ts.kind)\n \t{\n \t  gfc_error (\"The allocate-object at %L and the source-expr at %L \"\n \t\t      \"shall have the same kind type parameter\",\n \t\t      &e->where, &code->expr3->where);\n-\t  return FAILURE;\n+\t  goto failure;\n \t}\n     }\n   else if (is_abstract&& code->ext.alloc.ts.type == BT_UNKNOWN)\n     {\n       gcc_assert (e->ts.type == BT_CLASS);\n       gfc_error (\"Allocating %s of ABSTRACT base type at %L requires a \"\n \t\t \"type-spec or SOURCE=\", sym->name, &e->where);\n-      return FAILURE;\n+      goto failure;\n     }\n \n   if (check_intent_in && sym->attr.intent == INTENT_IN)\n     {\n       gfc_error (\"Cannot allocate INTENT(IN) variable '%s' at %L\",\n \t\t sym->name, &e->where);\n-      return FAILURE;\n+      goto failure;\n     }\n     \n   if (!code->expr3)\n@@ -6285,23 +6445,31 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t}\n     }\n \n-  if (pointer || dimension == 0)\n-    return SUCCESS;\n+  if (pointer || (dimension == 0 && codimension == 0))\n+    goto success;\n \n   /* Make sure the next-to-last reference node is an array specification.  */\n \n-  if (ref2 == NULL || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL)\n+  if (ref2 == NULL || ref2->type != REF_ARRAY || ref2->u.ar.type == AR_FULL\n+      || (dimension && ref2->u.ar.dimen == 0))\n     {\n       gfc_error (\"Array specification required in ALLOCATE statement \"\n \t\t \"at %L\", &e->where);\n-      return FAILURE;\n+      goto failure;\n     }\n \n   /* Make sure that the array section reference makes sense in the\n     context of an ALLOCATE specification.  */\n \n   ar = &ref2->u.ar;\n \n+  if (codimension && ar->codimen == 0)\n+    {\n+      gfc_error (\"Coarray specification required in ALLOCATE statement \"\n+\t\t \"at %L\", &e->where);\n+      goto failure;\n+    }\n+\n   for (i = 0; i < ar->dimen; i++)\n     {\n       if (ref2->u.ar.type == AR_ELEMENT)\n@@ -6322,13 +6490,13 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n \tcase DIMEN_UNKNOWN:\n \tcase DIMEN_VECTOR:\n+\tcase DIMEN_STAR:\n \t  gfc_error (\"Bad array specification in ALLOCATE statement at %L\",\n \t\t     &e->where);\n-\t  return FAILURE;\n+\t  goto failure;\n \t}\n \n check_symbols:\n-\n       for (a = code->ext.alloc.list; a; a = a->next)\n \t{\n \t  sym = a->expr->symtree->n.sym;\n@@ -6345,12 +6513,46 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \t      gfc_error (\"'%s' must not appear in the array specification at \"\n \t\t\t \"%L in the same ALLOCATE statement where it is \"\n \t\t\t \"itself allocated\", sym->name, &ar->where);\n-\t      return FAILURE;\n+\t      goto failure;\n \t    }\n \t}\n     }\n \n+  for (i = ar->dimen; i < ar->codimen + ar->dimen; i++)\n+    {\n+      if (ar->dimen_type[i] == DIMEN_ELEMENT\n+\t  || ar->dimen_type[i] == DIMEN_RANGE)\n+\t{\n+\t  if (i == (ar->dimen + ar->codimen - 1))\n+\t    {\n+\t      gfc_error (\"Expected '*' in coindex specification in ALLOCATE \"\n+\t\t\t \"statement at %L\", &e->where);\n+\t      goto failure;\n+\t    }\n+\t  break;\n+\t}\n+\n+      if (ar->dimen_type[i] == DIMEN_STAR && i == (ar->dimen + ar->codimen - 1)\n+\t  && ar->stride[i] == NULL)\n+\tbreak;\n+\n+      gfc_error (\"Bad coarray specification in ALLOCATE statement at %L\",\n+\t\t &e->where);\n+      goto failure;\n+    }\n+\n+  if (codimension)\n+    {\n+      gfc_error (\"Sorry, allocatable coarrays are no yet supported coarray \"\n+\t\t \"at %L\", &e->where);\n+      goto failure;\n+    }\n+\n+success:\n   return SUCCESS;\n+\n+failure:\n+  return FAILURE;\n }\n \n static void\n@@ -8031,24 +8233,50 @@ resolve_ordinary_assign (gfc_code *code, gfc_namespace *ns)\n \t    && lhs->expr_type == EXPR_VARIABLE\n \t    && lhs->ts.u.derived->attr.pointer_comp\n \t    && rhs->expr_type == EXPR_VARIABLE\n-\t    && gfc_impure_variable (rhs->symtree->n.sym))\n+\t    && (gfc_impure_variable (rhs->symtree->n.sym)\n+\t\t|| gfc_is_coindexed (rhs)))\n+\t{\n+\t  /* F2008, C1283.  */\n+\t  if (gfc_is_coindexed (rhs))\n+\t    gfc_error (\"Coindexed expression at %L is assigned to \"\n+\t\t\t\"a derived type variable with a POINTER \"\n+\t\t\t\"component in a PURE procedure\",\n+\t\t\t&rhs->where);\n+\t  else\n+\t    gfc_error (\"The impure variable at %L is assigned to \"\n+\t\t\t\"a derived type variable with a POINTER \"\n+\t\t\t\"component in a PURE procedure (12.6)\",\n+\t\t\t&rhs->where);\n+\t  return rval;\n+\t}\n+\n+      /* Fortran 2008, C1283.  */\n+      if (gfc_is_coindexed (lhs))\n \t{\n-\t  gfc_error (\"The impure variable at %L is assigned to \"\n-\t\t     \"a derived type variable with a POINTER \"\n-\t\t     \"component in a PURE procedure (12.6)\",\n-\t\t     &rhs->where);\n+\t  gfc_error (\"Assignment to coindexed variable at %L in a PURE \"\n+\t\t     \"procedure\", &rhs->where);\n \t  return rval;\n \t}\n     }\n \n   /* F03:7.4.1.2.  */\n+  /* FIXME: Valid in Fortran 2008, unless the LHS is both polymorphic\n+     and coindexed; cf. F2008, 7.2.1.2 and PR 43366.  */\n   if (lhs->ts.type == BT_CLASS)\n     {\n       gfc_error (\"Variable must not be polymorphic in assignment at %L\",\n \t\t &lhs->where);\n       return false;\n     }\n \n+  /* F2008, Section 7.2.1.2.  */\n+  if (gfc_is_coindexed (lhs) && gfc_has_ultimate_allocatable (lhs))\n+    {\n+      gfc_error (\"Coindexed variable must not be have an allocatable ultimate \"\n+\t\t \"component in assignment at %L\", &lhs->where);\n+      return false;\n+    }\n+\n   gfc_check_assign (lhs, rhs, 1);\n   return false;\n }\n@@ -10462,8 +10690,8 @@ resolve_fl_derived (gfc_symbol *sym)\n   for (c = sym->components; c != NULL; c = c->next)\n     {\n       /* F2008, C442.  */\n-      if (c->attr.codimension\n-\t  && (!c->attr.allocatable || c->as->type != AS_DEFERRED))\n+      if (c->attr.codimension /* FIXME: c->as check due to PR 43412.  */\n+\t  && (!c->attr.allocatable || (c->as && c->as->type != AS_DEFERRED)))\n \t{\n \t  gfc_error (\"Coarray component '%s' at %L must be allocatable with \"\n \t\t     \"deferred shape\", c->name, &c->loc);\n@@ -11351,9 +11579,9 @@ resolve_symbol (gfc_symbol *sym)\n     gfc_error (\"Variable '%s' at %L is a coarray or has a coarray \"\n \t       \"component and is not ALLOCATABLE, SAVE nor a \"\n \t       \"dummy argument\", sym->name, &sym->declared_at);\n-  /* F2008, C528.  */\n+  /* F2008, C528.  */  /* FIXME: sym->as check due to PR 43412.  */\n   else if (sym->attr.codimension && !sym->attr.allocatable\n-      && sym->as->cotype == AS_DEFERRED)\n+      && sym->as && sym->as->cotype == AS_DEFERRED)\n     gfc_error (\"Coarray variable '%s' at %L shall not have codimensions with \"\n \t\t\"deferred shape\", sym->name, &sym->declared_at);\n   else if (sym->attr.codimension && sym->attr.allocatable\n@@ -11548,6 +11776,13 @@ check_data_variable (gfc_data_variable *var, locus *where)\n       if (ref->type == REF_COMPONENT && ref->u.c.component->attr.pointer)\n \thas_pointer = 1;\n \n+      if (ref->type == REF_ARRAY && ref->u.ar.codimen)\n+\t{\n+\t  gfc_error (\"DATA element '%s' at %L cannot have a coindex\",\n+\t\t     sym->name, where);\n+\t  return FAILURE;\n+\t}\n+\n       if (has_pointer\n \t    && ref->type == REF_ARRAY\n \t    && ref->u.ar.type != AR_FULL)"}, {"sha": "cbdd8b9c90ee75b4ce4127fec40140341c98abaf", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -2531,6 +2531,9 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_symbol * sym,\n   gfc_se indexse;\n   gfc_se tmpse;\n \n+  if (ar->dimen == 0)\n+    return;\n+\n   /* Handle scalarized references separately.  */\n   if (ar->type != AR_ELEMENT)\n     {\n@@ -3958,14 +3961,27 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree pstat)\n   /* Find the last reference in the chain.  */\n   while (ref && ref->next != NULL)\n     {\n-      gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT);\n+      gcc_assert (ref->type != REF_ARRAY || ref->u.ar.type == AR_ELEMENT\n+\t\t  || (ref->u.ar.dimen == 0 && ref->u.ar.codimen > 0));\n       prev_ref = ref;\n       ref = ref->next;\n     }\n \n   if (ref == NULL || ref->type != REF_ARRAY)\n     return false;\n \n+  /* Return if this is a scalar coarray.  */\n+  if (!prev_ref && !expr->symtree->n.sym->attr.dimension)\n+    {\n+      gcc_assert (expr->symtree->n.sym->attr.codimension);\n+      return false;\n+    }\n+  else if (prev_ref && !prev_ref->u.c.component->attr.dimension)\n+    {\n+      gcc_assert (prev_ref->u.c.component->attr.codimension);\n+      return false;\n+    }\n+\n   if (!prev_ref)\n     allocatable_array = expr->symtree->n.sym->attr.allocatable;\n   else\n@@ -6361,6 +6377,13 @@ gfc_walk_variable_expr (gfc_ss * ss, gfc_expr * expr)\n \tcontinue;\n \n       ar = &ref->u.ar;\n+\n+      if (ar->as->rank == 0)\n+\t{\n+\t  /* Scalar coarray.  */\n+\t  continue;\n+\t}\n+\n       switch (ar->type)\n \t{\n \tcase AR_ELEMENT:"}, {"sha": "10716b706920f6a4f103dcd21f2a05561c66eff0", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1848,6 +1848,7 @@ gfc_add_interface_mapping (gfc_interface_mapping * mapping,\n   new_sym->as = gfc_copy_array_spec (sym->as);\n   new_sym->attr.referenced = 1;\n   new_sym->attr.dimension = sym->attr.dimension;\n+  new_sym->attr.codimension = sym->attr.codimension;\n   new_sym->attr.pointer = sym->attr.pointer;\n   new_sym->attr.allocatable = sym->attr.allocatable;\n   new_sym->attr.flavor = sym->attr.flavor;\n@@ -2076,7 +2077,7 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n       break;\n \n     case GFC_ISYM_SIZE:\n-      if (!sym->as)\n+      if (!sym->as || sym->as->rank == 0)\n \treturn false;\n \n       if (arg2 && arg2->expr_type == EXPR_CONSTANT)\n@@ -2114,7 +2115,7 @@ gfc_map_intrinsic_function (gfc_expr *expr, gfc_interface_mapping *mapping)\n \t/* TODO These implementations of lbound and ubound do not limit if\n \t   the size < 0, according to F95's 13.14.53 and 13.14.113.  */\n \n-      if (!sym->as)\n+      if (!sym->as || sym->as->rank == 0)\n \treturn false;\n \n       if (arg2 && arg2->expr_type == EXPR_CONSTANT)"}, {"sha": "5b77482b022179cf52db270a01fc320f4416da6a", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -1,3 +1,9 @@\n+2010-04-09  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_7.f90: New test.\n+\t* gfortran.dg/coarray_8.f90: New test.\n+\n 2010-04-08  Bud Davis  <bdavis9659@sbcglobal.net>\n \n \tPR fortran/28039"}, {"sha": "8cd295d38b3c68b8a23bf54a55224883dd6fe666", "filename": "gcc/testsuite/gfortran.dg/coarray_7.f90", "status": "added", "additions": 194, "deletions": 0, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_7.f90?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -0,0 +1,194 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000 -fcoarray=single\" }\n+!\n+! PR fortran/18918\n+!\n+! Coarray expressions.\n+!\n+program test\n+  implicit none\n+  type t3\n+    integer, allocatable :: a\n+  end type t3\n+  type t4\n+    type(t3) :: xt3\n+  end type t4\n+  type t\n+    integer, pointer :: ptr\n+    integer, allocatable :: alloc(:)\n+  end type t\n+  type(t), target :: i[*]\n+  type(t), allocatable :: ca[:]\n+  type(t4), target :: tt4[*]\n+  type(t4), allocatable :: ca2[:]\n+  integer, volatile :: volat[*]\n+  integer, asynchronous :: async[*]\n+  integer :: caf1[1,*], caf2[*]\n+  allocate(i%ptr)\n+  call foo(i%ptr)\n+  call foo(i[1]%ptr) ! { dg-error \"Coindexed actual argument at .1. to pointer dummy\" }\n+  call bar(i%ptr)\n+  call bar(i[1]%ptr) ! OK, value of ptr target \n+  call bar(i[1]%alloc(1)) ! OK\n+  call typeDummy(i) ! OK\n+  call typeDummy(i[1]) ! { dg-error \"with ultimate pointer component\" }\n+  call typeDummy2(ca) ! OK\n+  call typeDummy2(ca[1]) ! { dg-error \"with ultimate pointer component\" }\n+  call typeDummy3(tt4%xt3) ! OK\n+  call typeDummy3(tt4[1]%xt3) ! { dg-error \"requires either VALUE or INTENT.IN.\" }\n+  call typeDummy4(ca2) ! OK\n+  call typeDummy4(ca2[1]) ! { dg-error \"requires INTENT.IN.\" }\n+! Note: Checking an VOLATILE dummy is not possible as volatile + intent(in)\n+! is not possible\n+\n+  call asyn(volat)\n+  call asyn(async)\n+  call asyn(volat[1]) ! { dg-error \"Coindexed ASYNCHRONOUS or VOLATILE actual argument\" }\n+  call asyn(async[1]) ! { dg-error \"Coindexed ASYNCHRONOUS or VOLATILE actual argument\" }\n+\n+  call coarray(caf1) ! rank mismatch; OK, for non allocatable coarrays\n+  call coarray(caf2)\n+  call coarray(caf2[1]) ! { dg-error \"must be a coarray\" }\n+  call ups(i)\n+  call ups(i[1]) ! { dg-error \"with ultimate pointer component\" }\n+  call ups(i%ptr)\n+  call ups(i[1]%ptr) ! OK - passes target not pointer\n+contains\n+  subroutine asyn(a)\n+    integer, intent(in), asynchronous :: a\n+  end subroutine asyn\n+  subroutine bar(a)\n+    integer :: a\n+  end subroutine bar\n+  subroutine foo(a)\n+    integer, pointer :: a\n+  end subroutine foo\n+  subroutine coarray(a)\n+    integer :: a[*]\n+  end subroutine coarray\n+  subroutine typeDummy(a)\n+    type(t) :: a\n+  end subroutine typeDummy\n+  subroutine typeDummy2(a)\n+    type(t),allocatable :: a\n+  end subroutine typeDummy2\n+  subroutine typeDummy3(a)\n+    type(t3) :: a\n+  end subroutine typeDummy3\n+  subroutine typeDummy4(a)\n+    type(t4), allocatable :: a\n+  end subroutine typeDummy4\n+end program test\n+\n+\n+subroutine alloc()\n+type t\n+  integer, allocatable :: a(:)\n+end type t\n+type(t), save :: a[*]\n+type(t), allocatable :: b(:)[:], C[:]\n+\n+allocate(b(1)) ! { dg-error \"Coarray specification\" }\n+allocate(a[3]%a(5)) ! { dg-error \"Coindexed allocatable\" }\n+allocate(c[*]) ! { dg-error \"Sorry\" }\n+allocate(b(3)[5:*]) ! { dg-error \"Sorry\" }\n+allocate(a%a(5)) ! OK\n+end subroutine alloc\n+\n+\n+subroutine dataPtr()\n+  integer, save, target :: a[*]\n+  data a/5/ ! OK\n+  data a[1]/5/ ! { dg-error \"cannot have a coindex\" }\n+  type t\n+  integer, pointer :: p\n+  end type t\n+  type(t), save :: x[*]\n+\n+  type t2\n+    integer :: a(1)\n+  end type t2\n+  type(t2) y\n+  data y%a/4/\n+\n+\n+   x[1]%p => a  ! { dg-error \"shall not have a coindex\" }\n+   x%p => a[1]  ! { dg-error \"shall not have a coindex\" }\n+end subroutine dataPtr\n+\n+\n+subroutine test3()\n+implicit none\n+type t\n+  integer :: a(1)\n+end type t\n+type(t), save :: x[*]\n+data x%a/4/\n+\n+  integer, save :: y(1)[*] !(1)\n+  call sub(x(1:1)[1]) ! { dg-error \"Rank mismatch\" }\n+contains\n+  subroutine sub(a) ! { dg-error \"shall not have codimensions with deferred shape\" }\n+    integer :: a(:)[:]\n+  end subroutine sub\n+end subroutine test3\n+\n+\n+subroutine test4()\n+  integer, save :: i[*]\n+  integer :: j\n+  call foo(i)\n+  call foo(j) ! { dg-error \"must be a coarray\" }\n+contains\n+  subroutine foo(a)\n+    integer :: a[*]\n+  end subroutine foo\n+end subroutine test4\n+\n+\n+subroutine allocateTest()\n+  implicit none\n+  real, allocatable,dimension(:,:), codimension[:,:] :: a,b,c\n+  integer :: n, q\n+  n = 1\n+  q = 1\n+  allocate(a(n,n)[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(b(n,n)[q,*]) ! { dg-error \"Sorry\" }\n+  allocate(c(n,n)[q,*]) ! { dg-error \"Sorry\" }\n+end subroutine allocateTest\n+\n+\n+subroutine testAlloc3\n+implicit none\n+integer, allocatable :: a(:,:,:)[:,:]\n+integer, allocatable, dimension(:),codimension[:] :: b(:,:,:)[:,:]\n+integer, allocatable, dimension(:,:),codimension[:,:,:] :: c\n+integer, allocatable, dimension(:,:),codimension[:,:,:] :: d[:,:]\n+integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: e(:,:)\n+integer, allocatable, dimension(:,:,:),codimension[:,:,:] :: f(:,:)[:,:]\n+\n+allocate(a(1,2,3)[4,*]) ! { dg-error \"Sorry\" }\n+allocate(b(1,2,3)[4,*]) ! { dg-error \"Sorry\" }\n+allocate(c(1,2)[3,4,*]) ! { dg-error \"Sorry\" }\n+allocate(d(1,2)[3,*])   ! { dg-error \"Sorry\" }\n+allocate(e(1,2)[3,4,*]) ! { dg-error \"Sorry\" }\n+allocate(f(1,2)[3,*]) ! { dg-error \"Sorry\" }\n+end subroutine testAlloc3\n+\n+\n+subroutine testAlloc4()\n+  implicit none\n+  type co_double_3\n+    double precision, allocatable :: array(:)\n+  end type co_double_3\n+  type(co_double_3),save, codimension[*] :: work\n+  allocate(work%array(1))\n+  print *, size(work%array)\n+end subroutine testAlloc4\n+\n+subroutine test5()\n+  implicit none\n+  integer, save :: i[*]\n+  print *, i[*] ! { dg-error \"Coindex of codimension 1 must be a scalar\" }\n+end subroutine test5\n+"}, {"sha": "6ceba8b9a95ab86f19731f37fa2b436b02ee65fa", "filename": "gcc/testsuite/gfortran.dg/coarray_8.f90", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_8.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_8.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_8.f90?ref=d3a9eea2c0e65e0f03c249bab8aa3fa56149dfe0", "patch": "@@ -0,0 +1,191 @@\n+! { dg-do compile }\n+! { dg-options \"-fmax-errors=1000 -fcoarray=single\" }\n+!\n+! PR fortran/18918\n+!\n+! Coarray expressions.\n+!\n+module mod2\n+  implicit none\n+  type t\n+    procedure(sub), pointer :: ppc\n+  contains\n+    procedure :: tbp => sub\n+  end type t\n+  type t2\n+    class(t), allocatable :: poly\n+  end type t2\n+contains\n+  subroutine sub(this)\n+    class(t), intent(in) :: this\n+  end subroutine sub\n+end module mod2\n+\n+subroutine procTest(y,z)\n+  use mod2\n+  implicit none\n+  type(t), save :: x[*]\n+  type(t) :: y[*]\n+  type(t2) :: z[*]\n+\n+  x%ppc => sub\n+  call x%ppc() ! OK\n+  call x%tbp() ! OK\n+  call x[1]%tbp ! OK, not polymorphic\n+  ! Invalid per C726\n+  call x[1]%ppc ! { dg-error \"Coindexed procedure-pointer component\" }\n+\n+  y%ppc => sub\n+  call y%ppc() ! OK\n+  call y%tbp() ! OK\n+  call y[1]%tbp ! OK, coindexed polymorphic object but not poly. subobj.\n+  call y[1]%ppc ! { dg-error \"Coindexed procedure-pointer component\" }\n+\n+  ! Invalid per C1229\n+  z%poly%ppc => sub\n+  call z%poly%ppc() ! OK\n+  call z%poly%tbp() ! OK\n+  call z[1]%poly%tbp ! { dg-error \"Polymorphic subobject of coindexed\" }\n+  call z[1]%poly%ppc ! { dg-error \"Coindexed procedure-pointer component\" }\n+end subroutine procTest\n+\n+\n+module m\n+  type t1\n+    integer, pointer :: p\n+  end type t1\n+  type t2\n+    integer :: i\n+  end type t2\n+  type t\n+    integer, allocatable :: a[:]\n+    type(t1), allocatable :: b[:]\n+    type(t2), allocatable :: c[:]\n+  end type t\n+contains\n+  pure subroutine p2(x)\n+   integer, intent(inout) :: x\n+  end subroutine p2\n+  pure subroutine p3(x)\n+   integer, pointer :: x\n+  end subroutine p3\n+  pure subroutine p1(x)\n+    type(t), intent(inout) :: x\n+    integer, target :: tgt1\n+    x%a = 5\n+    x%a[6] = 9 ! { dg-error \"Assignment to coindexed variable\" }\n+    x%b%p => tgt1\n+    x%b[1]%p => tgt1 ! { dg-error \"shall not have a coindex\" }\n+    x%b%p => x%b[1]%p ! { dg-error \"shall not have a coindex\" }\n+    x%b = t1(x%b[1]%p) ! { dg-error \"Coindexed expression to pointer component\" }\n+    x%b = x%b[1] ! { dg-error \"derived type variable with a POINTER component in a PURE\" }\n+    call p2 (x%c[1]%i) ! { dg-error \"Coindexed actual argument\" }\n+    call p3 (x%b[1]%p) ! { dg-error \"to pointer dummy\" }\n+  end subroutine p1\n+  subroutine nonPtr()\n+    type(t1), save :: a[*]\n+    type(t2), save :: b[*]\n+    integer, target :: tgt1\n+    a%p => tgt1\n+    a[1]%p => tgt1 ! { dg-error \"shall not have a coindex\" }\n+    a%p => a[2]%p ! { dg-error \"shall not have a coindex\" }\n+    a = t1(a[1]%p) ! { dg-error \"Coindexed expression to pointer component\" }\n+    call p2 (b[1]%i) ! OK\n+    call p2 (a[1]%p) ! OK - pointer target and not pointer\n+  end subroutine nonPtr\n+end module m\n+\n+\n+module mmm3\n+ type t\n+   integer, allocatable :: a(:)\n+ end type t\n+contains\n+  subroutine assign(x)\n+    type(t) :: x[*]\n+    allocate(x%a(3))\n+    x%a = [ 1, 2, 3]\n+    x[1]%a = [ 1, 2, 3] ! OK - if shapes are the same, otherwise wrong\n+                        ! (no reallocate on assignment)\n+  end subroutine assign\n+  subroutine assign2(x,y)\n+    type(t),allocatable :: x[:]\n+    type(t) :: y\n+    x = y\n+    x[1] = y ! { dg-error \"must not be have an allocatable ultimate component\" }\n+  end subroutine assign2\n+end module mmm3\n+\n+\n+module mmm4\n+  implicit none\n+contains\n+  subroutine t1(x)\n+    integer :: x(1)\n+  end subroutine t1\n+  subroutine t3(x)\n+    character :: x(*)\n+  end subroutine t3\n+  subroutine t2()\n+    integer, save :: x[*]\n+    integer, save :: y(1)[*]\n+    character(len=20), save :: z[*]\n+\n+    call t1(x) ! { dg-error \"Rank mismatch\" }\n+    call t1(x[1]) ! { dg-error \"Rank mismatch\" }\n+\n+    call t1(y(1)) ! OK\n+    call t1(y(1)[1]) ! { dg-error \"Rank mismatch\" }\n+\n+    call t3(z) !  OK\n+    call t3(z[1]) ! { dg-error \"Rank mismatch\" }\n+  end subroutine t2\n+end module mmm4\n+\n+\n+subroutine tfgh()\n+  integer :: i(2)\n+  DATA i/(i, i=1,2)/ ! { dg-error \"Expected PARAMETER symbol\" }\n+  do i = 1, 5 ! { dg-error \"cannot be a sub-component\" }\n+  end do ! { dg-error \"Expecting END SUBROUTINE\" }\n+end subroutine tfgh\n+\n+subroutine tfgh2()\n+  integer, save :: x[*]\n+  integer :: i(2)\n+  DATA i/(x, x=1,2)/ ! { dg-error \"Expected PARAMETER symbol\" }\n+  do x = 1, 5 ! { dg-error \"cannot be a coarray\" }\n+  end do ! { dg-error \"Expecting END SUBROUTINE\" }\n+end subroutine tfgh2\n+\n+\n+subroutine f4f4()\n+  type t\n+    procedure(), pointer, nopass :: ppt => null()\n+  end type t\n+  external foo\n+  type(t), save :: x[*]\n+  x%ppt => foo\n+  x[1]%ppt => foo ! { dg-error \"shall not have a coindex\" }\n+end subroutine f4f4\n+\n+\n+subroutine corank()\n+  integer, allocatable :: a[:,:]\n+  call one(a) ! OK\n+  call two(a) !  { dg-error \"Corank mismatch in argument\" }\n+contains\n+  subroutine one(x)\n+    integer :: x[*]\n+  end subroutine one\n+  subroutine two(x)\n+    integer, allocatable :: x[:]\n+  end subroutine two\n+end subroutine corank\n+\n+subroutine assign42()\n+  integer, allocatable :: z(:)[:]\n+  z(:)[1] = z\n+end subroutine assign42\n+\n+! { dg-final { cleanup-modules \"mod2 m mmm3 mmm4\" } }"}]}