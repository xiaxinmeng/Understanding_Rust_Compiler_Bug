{"sha": "2be794fae034818a36e097c60adf612f343e24fe", "node_id": "C_kwDOANBUbNoAKDJiZTc5NGZhZTAzNDgxOGEzNmUwOTdjNjBhZGY2MTJmMzQzZTI0ZmU", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-01T14:50:38Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2021-11-07T18:08:57Z"}, "message": "Remove VRP threader.\n\nNow that things have stabilized, we can remove the old code.\n\nI have left the hybrid threader in tree-ssa-threadedge, even though the\nVRP threader was the only user, because we may need it as an interim\nstep for DOM threading removal.\n\nTested on x86-64 Linux.\n\ngcc/ChangeLog:\n\n\t* tree-pass.h (make_pass_vrp_threader): Remove.\n\t* tree-ssa-threadbackward.c\n\t(back_threader_profitability::profitable_path_p): Remove\n\tASSERT_EXPR references.\n\t* tree-ssa-threadedge.c (jt_state::register_equivs_stmt): Same.\n\t* tree-vrp.c (vrp_folder::simplify_casted_conds): Same.\n\t(execute_vrp): Same.\n\t(class hybrid_threader): Remove.\n\t(hybrid_threader::hybrid_threader): Remove.\n\t(hybrid_threader::~hybrid_threader): Remove.\n\t(hybrid_threader::before_dom_children): Remove.\n\t(hybrid_threader::after_dom_children): Remove.\n\t(execute_vrp_threader): Remove.\n\t(class pass_vrp_threader): Remove.\n\t(make_pass_vrp_threader): Remove.", "tree": {"sha": "8f800d600aa37ba3f58c43925d63ce9fb211272d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f800d600aa37ba3f58c43925d63ce9fb211272d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2be794fae034818a36e097c60adf612f343e24fe", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be794fae034818a36e097c60adf612f343e24fe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2be794fae034818a36e097c60adf612f343e24fe", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2be794fae034818a36e097c60adf612f343e24fe/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ee11be7f2d788e6055ebed9746a8d8ac3cb04b8e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee11be7f2d788e6055ebed9746a8d8ac3cb04b8e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee11be7f2d788e6055ebed9746a8d8ac3cb04b8e"}], "stats": {"total": 152, "additions": 5, "deletions": 147}, "files": [{"sha": "d494aff1c4c37da5e6d0b1204161fe8f8feb0493", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2be794fae034818a36e097c60adf612f343e24fe", "patch": "@@ -463,7 +463,6 @@ extern gimple_opt_pass *make_pass_copy_prop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_isolate_erroneous_paths (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_early_vrp (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_vrp (gcc::context *ctxt);\n-extern gimple_opt_pass *make_pass_vrp_threader (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_uncprop (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_return_slot (gcc::context *ctxt);\n extern gimple_opt_pass *make_pass_reassoc (gcc::context *ctxt);"}, {"sha": "f9485bf90469a55bba1e5fd83d20d6b036e7bf9a", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=2be794fae034818a36e097c60adf612f343e24fe", "patch": "@@ -710,8 +710,6 @@ back_threader_profitability::profitable_path_p (const vec<basic_block> &m_path,\n \t\treturn false;\n \t      /* Do not count empty statements and labels.  */\n \t      if (gimple_code (stmt) != GIMPLE_NOP\n-\t\t  && !(gimple_code (stmt) == GIMPLE_ASSIGN\n-\t\t       && gimple_assign_rhs_code (stmt) == ASSERT_EXPR)\n \t\t  && !is_gimple_debug (stmt))\n \t\tn_insns += estimate_num_insns (stmt, &eni_size_weights);\n \t    }"}, {"sha": "f693db170648a9ac1b62be8fb84fc02209f14068", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=2be794fae034818a36e097c60adf612f343e24fe", "patch": "@@ -1334,25 +1334,19 @@ jt_state::register_equivs_stmt (gimple *stmt, basic_block bb,\n      to expose more context sensitive equivalences which in turn may\n      allow us to simplify the condition at the end of the loop.\n \n-     Handle simple copy operations as well as implied copies from\n-     ASSERT_EXPRs.  */\n+     Handle simple copy operations.  */\n   tree cached_lhs = NULL;\n   if (gimple_assign_single_p (stmt)\n       && TREE_CODE (gimple_assign_rhs1 (stmt)) == SSA_NAME)\n     cached_lhs = gimple_assign_rhs1 (stmt);\n-  else if (gimple_assign_single_p (stmt)\n-\t   && TREE_CODE (gimple_assign_rhs1 (stmt)) == ASSERT_EXPR)\n-    cached_lhs = TREE_OPERAND (gimple_assign_rhs1 (stmt), 0);\n   else\n     {\n-      /* A statement that is not a trivial copy or ASSERT_EXPR.\n+      /* A statement that is not a trivial copy.\n \t Try to fold the new expression.  Inserting the\n \t expression into the hash table is unlikely to help.  */\n       /* ???  The DOM callback below can be changed to setting\n \t the mprts_hook around the call to thread_across_edge,\n-\t avoiding the use substitution.  The VRP hook should be\n-\t changed to properly valueize operands itself using\n-\t SSA_NAME_VALUE in addition to its own lattice.  */\n+\t avoiding the use substitution.  */\n       cached_lhs = gimple_fold_stmt_to_constant_1 (stmt,\n \t\t\t\t\t\t   threadedge_valueize);\n       if (NUM_SSA_OPERANDS (stmt, SSA_OP_ALL_USES) != 0"}, {"sha": "dd7723629ba037a96b08c9379d039dba18bc20ee", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 135, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2be794fae034818a36e097c60adf612f343e24fe/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=2be794fae034818a36e097c60adf612f343e24fe", "patch": "@@ -43,7 +43,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"cfgloop.h\"\n #include \"tree-scalar-evolution.h\"\n #include \"tree-ssa-propagate.h\"\n-#include \"tree-ssa-threadedge.h\"\n #include \"domwalk.h\"\n #include \"vr-values.h\"\n #include \"gimple-array-bounds.h\"\n@@ -3684,9 +3683,7 @@ vrp_asserts::all_imm_uses_in_stmt_or_feed_cond (tree var,\n \n    However, by converting the assertion into the implied copy\n    operation N_i = N_j, we will then copy-propagate N_j into the uses\n-   of N_i and lose the range information.  We may want to hold on to\n-   ASSERT_EXPRs a little while longer as the ranges could be used in\n-   things like jump threading.\n+   of N_i and lose the range information.\n \n    The problem with keeping ASSERT_EXPRs around is that passes after\n    VRP need to handle them appropriately.\n@@ -4121,11 +4118,7 @@ vrp_folder::fold_stmt (gimple_stmt_iterator *si)\n /* A comparison of an SSA_NAME against a constant where the SSA_NAME\n    was set by a type conversion can often be rewritten to use the RHS\n    of the type conversion.  Do this optimization for all conditionals\n-   in FUN.\n-\n-   However, doing so inhibits jump threading through the comparison.\n-   So that transformation is not performed until after jump threading\n-   is complete.  */\n+   in FUN.  */\n \n void\n vrp_folder::simplify_casted_conds (function *fun)\n@@ -4244,9 +4237,6 @@ execute_vrp (struct function *fun, bool warn_array_bounds_p)\n \n   free_numbers_of_iterations_estimates (fun);\n \n-  /* ASSERT_EXPRs must be removed before finalizing jump threads\n-     as finalizing jump threads calls the CFG cleanup code which\n-     does not properly handle ASSERT_EXPRs.  */\n   assert_engine.remove_range_assertions ();\n \n   scev_finalize ();\n@@ -4429,126 +4419,3 @@ make_pass_vrp (gcc::context *ctxt)\n {\n   return new pass_vrp (ctxt);\n }\n-\n-// This is the dom walker for the hybrid threader.  The reason this is\n-// here, as opposed to the generic threading files, is because the\n-// other client would be DOM, and they have their own custom walker.\n-\n-class hybrid_threader : public dom_walker\n-{\n-public:\n-  hybrid_threader ();\n-  ~hybrid_threader ();\n-\n-  void thread_jumps (function *fun)\n-  {\n-    walk (fun->cfg->x_entry_block_ptr);\n-  }\n-  bool thread_through_all_blocks ()\n-  {\n-    return m_threader->thread_through_all_blocks (false);\n-  }\n-\n-private:\n-  edge before_dom_children (basic_block) override;\n-  void after_dom_children (basic_block bb) override;\n-\n-  hybrid_jt_simplifier *m_simplifier;\n-  jump_threader *m_threader;\n-  jt_state *m_state;\n-  gimple_ranger *m_ranger;\n-  path_range_query *m_query;\n-};\n-\n-hybrid_threader::hybrid_threader () : dom_walker (CDI_DOMINATORS, REACHABLE_BLOCKS)\n-{\n-  loop_optimizer_init (LOOPS_NORMAL | LOOPS_HAVE_RECORDED_EXITS);\n-  scev_initialize ();\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  mark_dfs_back_edges ();\n-\n-  m_ranger = new gimple_ranger;\n-  m_query = new path_range_query (*m_ranger, /*resolve=*/true);\n-  m_simplifier = new hybrid_jt_simplifier (m_ranger, m_query);\n-  m_state = new hybrid_jt_state;\n-  m_threader = new jump_threader (m_simplifier, m_state);\n-}\n-\n-hybrid_threader::~hybrid_threader ()\n-{\n-  delete m_simplifier;\n-  delete m_threader;\n-  delete m_state;\n-  delete m_ranger;\n-  delete m_query;\n-\n-  scev_finalize ();\n-  loop_optimizer_finalize ();\n-}\n-\n-edge\n-hybrid_threader::before_dom_children (basic_block bb)\n-{\n-  gimple_stmt_iterator gsi;\n-  int_range<2> r;\n-\n-  for (gsi = gsi_start_nondebug_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      m_ranger->range_of_stmt (r, stmt);\n-    }\n-  return NULL;\n-}\n-\n-void\n-hybrid_threader::after_dom_children (basic_block bb)\n-{\n-  m_threader->thread_outgoing_edges (bb);\n-}\n-\n-static unsigned int\n-execute_vrp_threader (function *fun)\n-{\n-  hybrid_threader threader;\n-  threader.thread_jumps (fun);\n-  if (threader.thread_through_all_blocks ())\n-    return (TODO_cleanup_cfg | TODO_update_ssa);\n-  return 0;\n-}\n-\n-namespace {\n-\n-const pass_data pass_data_vrp_threader =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"vrp-thread\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_VRP_THREADER, /* tv_id */\n-  PROP_ssa, /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  0 /* todo_flags_finish */\n-};\n-\n-class pass_vrp_threader : public gimple_opt_pass\n-{\n-public:\n-  pass_vrp_threader (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_vrp_threader, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_vrp_threader (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_vrp != 0; }\n-  virtual unsigned int execute (function *fun)\n-    { return execute_vrp_threader (fun); }\n-};\n-\n-} // namespace {\n-\n-gimple_opt_pass *\n-make_pass_vrp_threader (gcc::context *ctxt)\n-{\n-  return new pass_vrp_threader (ctxt);\n-}"}]}