{"sha": "4dbf4496573255460757de76bb8347669196587c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGRiZjQ0OTY1NzMyNTU0NjA3NTdkZTc2YmI4MzQ3NjY5MTk2NTg3Yw==", "commit": {"author": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-07-21T00:01:43Z"}, "committer": {"name": "Alexandre Petit-Bianco", "email": "apbianco@gcc.gnu.org", "date": "2000-07-21T00:01:43Z"}, "message": "[multiple changes]\n\n2000-07-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (patch_method_invocation): Fixed comment.\n\t(maybe_use_access_method): Build this$<n>s to the context of the\n\ttarget method, or a type that extends it. Fixes gcj/242.\n\n2000-07-13  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (not_accessible_p): Access granted to innerclasses\n\t(indirectly) extending the reference type. Fixes gcj/249.\n\n2000-07-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (resolve_qualified_expression_name): Verify qualified\n\taccess to `this.' Fixes gcj/239.\n\n2000-07-10  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* class.c (set_super_info): Handled protected inner classes.\n\t(common_enclosing_context_p): Bail early if arguments aren't both\n\tinner classes.\n\t(get_access_flags_from_decl): Handle private and protected inner\n\tclasses.\n\t* java-tree.h (TYPE_PROTECTED_INNER_CLASS): New macro.\n\t(CLASS_PROTECTED): Likewise.\n\t(struct lang_type): New bitfield `poic.'\n\t* parse.y (jdep_resolve_class): Call check_inner_class_access on\n\tinner classes only.\n\t(check_inner_class_access): Renamed arguments, added\n\tcomments. Handles protected inner classes (fixes gcj/225)\n\t(not_accessible_p): Fixed comments. Avoid handling inner classes.\n\n2000-07-07  Alexandre Petit-Bianco  <apbianco@cygnus.com>\n\n\t* parse.y (resolve_qualified_expression_name): Handle inner class\n\taccess. Fixes gcj/256.\n\n(Fixes gcj/242, gcj/249, gcj/239, gcj/225 and gcj/256:\n http://gcc.gnu.org/ml/gcc-patches/2000-07/msg00801.html)\n\nFrom-SVN: r35156", "tree": {"sha": "f3e7044d39e99e82b097d95cb4c440ce2d639c9f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f3e7044d39e99e82b097d95cb4c440ce2d639c9f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4dbf4496573255460757de76bb8347669196587c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dbf4496573255460757de76bb8347669196587c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dbf4496573255460757de76bb8347669196587c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dbf4496573255460757de76bb8347669196587c/comments", "author": null, "committer": null, "parents": [{"sha": "c59ff527c551ccc7cf500e3095d2b7b111d6c907", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c59ff527c551ccc7cf500e3095d2b7b111d6c907", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c59ff527c551ccc7cf500e3095d2b7b111d6c907"}], "stats": {"total": 112, "additions": 88, "deletions": 24}, "files": [{"sha": "f99d0e5bd04bfbf50a4816995437ddc9237e65e0", "filename": "gcc/java/class.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=4dbf4496573255460757de76bb8347669196587c", "patch": "@@ -401,6 +401,7 @@ set_super_info (access_flags, this_class, super_class, interfaces_count)\n   if (access_flags & ACC_ABSTRACT)  CLASS_ABSTRACT (class_decl) = 1;\n   if (access_flags & ACC_STATIC)    CLASS_STATIC (class_decl) = 1;\n   if (access_flags & ACC_PRIVATE)   CLASS_PRIVATE (class_decl) = 1;\n+  if (access_flags & ACC_PROTECTED) CLASS_PROTECTED (class_decl) = 1;\n }\n \n /* Return length of inheritance chain of CLAS, where java.lang.Object is 0,\n@@ -493,7 +494,7 @@ enclosing_context_p (type1, type2)\n int common_enclosing_context_p (type1, type2)\n      tree type1, type2;\n {\n-  if (!PURE_INNER_CLASS_TYPE_P (type1) && !PURE_INNER_CLASS_TYPE_P (type2))\n+  if (!PURE_INNER_CLASS_TYPE_P (type1) || !PURE_INNER_CLASS_TYPE_P (type2))\n     return 0;\n   \n   for (type1 = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (type1))); type1; \n@@ -1075,6 +1076,10 @@ get_access_flags_from_decl (decl)\n \taccess_flags |= ACC_ABSTRACT;\n       if (CLASS_STATIC (decl))\n \taccess_flags |= ACC_STATIC;\n+      if (CLASS_PRIVATE (decl))\n+\taccess_flags |= ACC_PRIVATE;\n+      if (CLASS_PROTECTED (decl))\n+\taccess_flags |= ACC_PROTECTED;\n       return access_flags;\n     }\n   if (TREE_CODE (decl) == FUNCTION_DECL)"}, {"sha": "07a5521673dbc4a10310f7f38d5a5ab47da25a1a", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=4dbf4496573255460757de76bb8347669196587c", "patch": "@@ -576,6 +576,7 @@ struct lang_decl_var\n    for non primitive types when compiling to bytecode. */\n #define TYPE_DOT_CLASS(T)        (TYPE_LANG_SPECIFIC(T)->dot_class)\n #define TYPE_PRIVATE_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->pic)\n+#define TYPE_PROTECTED_INNER_CLASS(T) (TYPE_LANG_SPECIFIC(T)->poic)\n \n struct lang_type\n {\n@@ -591,6 +592,7 @@ struct lang_type\n \t\t\t\t   compiling to bytecode to implement\n \t\t\t\t   <non_primitive_type>.class */\n   unsigned pic:1;\t\t/* Private Inner Class. */\n+  unsigned poic:1;\t\t/* Protected Inner Class. */\n };\n \n #ifdef JAVA_USE_HANDLES\n@@ -840,6 +842,7 @@ struct rtx_def * java_lang_expand_expr PARAMS ((tree, rtx, enum machine_mode,\n #define CLASS_SUPER(DECL) DECL_LANG_FLAG_6 (DECL)\n #define CLASS_STATIC(DECL) DECL_LANG_FLAG_7 (DECL)\n #define CLASS_PRIVATE(DECL) (TYPE_PRIVATE_INNER_CLASS (TREE_TYPE (DECL)))\n+#define CLASS_PROTECTED(DECL) (TYPE_PROTECTED_INNER_CLASS (TREE_TYPE (DECL)))\n \n /* @deprecated marker flag on methods, fields and classes */\n "}, {"sha": "af7b19b11bd4cf60da0ba73d042b9da8f9e31e04", "filename": "gcc/java/parse.y", "status": "modified", "additions": 79, "deletions": 23, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4dbf4496573255460757de76bb8347669196587c/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=4dbf4496573255460757de76bb8347669196587c", "patch": "@@ -5199,7 +5199,8 @@ jdep_resolve_class (dep)\n   if (!decl)\n     complete_class_report_errors (dep);\n \n-  check_inner_class_access (decl, JDEP_ENCLOSING (dep), JDEP_WFL (dep));\n+  if (PURE_INNER_CLASS_DECL_P (decl))\n+    check_inner_class_access (decl, JDEP_ENCLOSING (dep), JDEP_WFL (dep));\n   return decl;\n }\n \n@@ -6781,24 +6782,37 @@ lookup_package_type (name, from)\n }\n \n static void\n-check_inner_class_access (decl, enclosing_type, cl)\n-     tree decl, enclosing_type, cl;\n+check_inner_class_access (decl, enclosing_decl, cl)\n+     tree decl, enclosing_decl, cl;\n {\n-  if (!decl)\n-    return;\n+  int access = 0;\n+\n   /* We don't issue an error message when CL is null. CL can be null\n-     as a result of processing a JDEP crafted by\n-     source_start_java_method for the purpose of patching its parm\n-     decl. But the error would have been already trapped when fixing\n-     the method's signature. */\n-  if (!(cl && PURE_INNER_CLASS_DECL_P (decl) && CLASS_PRIVATE (decl))\n-      || (PURE_INNER_CLASS_DECL_P (enclosing_type)\n-\t  && common_enclosing_context_p (TREE_TYPE (enclosing_type), \n-\t\t\t\t\t  TREE_TYPE (decl)))\n-      || enclosing_context_p (TREE_TYPE (enclosing_type), TREE_TYPE (decl)))\n+     as a result of processing a JDEP crafted by source_start_java_method\n+     for the purpose of patching its parm decl. But the error would\n+     have been already trapped when fixing the method's signature.\n+     DECL can also be NULL in case of earlier errors. */\n+  if (!decl || !cl)\n     return;\n \n-  parse_error_context (cl, \"Can't access nested %s %s. Only public classes and interfaces in other packages can be accessed\",\n+  /* We grant access to private and protected inner classes if the\n+     location from where we're trying to access DECL is an enclosing\n+     context for DECL or if both have a common enclosing context. */\n+  if (CLASS_PRIVATE (decl))\n+    access = 1;\n+  if (CLASS_PROTECTED (decl))\n+    access = 2;\n+  if (!access)\n+    return;\n+      \n+  if (common_enclosing_context_p (TREE_TYPE (enclosing_decl),\n+\t\t\t\t  TREE_TYPE (decl))\n+      || enclosing_context_p (TREE_TYPE (enclosing_decl),\n+\t\t\t      TREE_TYPE (decl)))\n+    return;\n+\n+  parse_error_context (cl, \"Can't access %s nested %s %s. Only public classes and interfaces in other packages can be accessed\",\n+\t\t       (access == 1 ? \"private\" : \"protected\"),\n \t\t       (CLASS_INTERFACE (decl) ? \"interface\" : \"class\"),\n \t\t       lang_printable_name (decl, 0));\n }\n@@ -9001,9 +9015,19 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      *where_found = decl = current_this;\n \t      *type_found = type = QUAL_DECL_TYPE (decl);\n \t    }\n-\t  /* We're trying to access the this from somewhere else... */\n+\t  /* We're trying to access the this from somewhere else. Make sure\n+\t     it's allowed before doing so. */\n \t  else\n \t    {\n+\t      if (!enclosing_context_p (type, current_class))\n+\t\t{\n+\t\t  char *p  = xstrdup (lang_printable_name (type, 0));\n+\t\t  parse_error_context (qual_wfl, \"Can't use variable `%s.this': type `%s' isn't an outer type of type `%s'\", \n+\t\t\t\t       p, p, \n+\t\t\t\t       lang_printable_name (current_class, 0));\n+\t\t  free (p);\n+\t\t  return 1;\n+\t\t}\n \t      *where_found = decl = build_current_thisn (type);\n \t      from_qualified_this = 1;\n \t    }\n@@ -9169,6 +9193,24 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n \t      \n \t      field_decl = lookup_field_wrapper (type,\n \t\t\t\t\t\t EXPR_WFL_NODE (qual_wfl));\n+\n+\t      /* Maybe what we're trying to access an inner class. */\n+\t      if (!field_decl)\n+\t\t{\n+\t\t  tree ptr, inner_decl;\n+\n+\t\t  BUILD_PTR_FROM_NAME (ptr, EXPR_WFL_NODE (qual_wfl));\n+\t\t  inner_decl = resolve_class (decl, ptr, NULL_TREE, qual_wfl);\n+\t\t  if (inner_decl)\n+\t\t    {\n+\t\t      check_inner_class_access (inner_decl, decl, qual_wfl); \n+\t\t      type = TREE_TYPE (inner_decl);\n+\t\t      decl = inner_decl;\n+\t\t      from_type = 1;\n+\t\t      continue;\n+\t\t    }\n+\t\t}\n+\n \t      if (field_decl == NULL_TREE)\n \t\t{\n \t\t  parse_error_context \n@@ -9283,7 +9325,8 @@ resolve_qualified_expression_name (wfl, found_decl, where_found, type_found)\n }\n \n /* 6.6 Qualified name and access control. Returns 1 if MEMBER (a decl)\n-   can't be accessed from REFERENCE (a record type). */\n+   can't be accessed from REFERENCE (a record type). This should be\n+   used when decl is a field or a method.*/\n \n static int\n not_accessible_p (reference, member, from_super)\n@@ -9292,6 +9335,10 @@ not_accessible_p (reference, member, from_super)\n {\n   int access_flag = get_access_flags_from_decl (member);\n \n+  /* Inner classes are processed by check_inner_class_access */\n+  if (INNER_CLASS_TYPE_P (reference))\n+    return 0;\n+\n   /* Access always granted for members declared public */\n   if (access_flag & ACC_PUBLIC)\n     return 0;\n@@ -9310,16 +9357,25 @@ not_accessible_p (reference, member, from_super)\n \treturn 0;\n \n       /* Otherwise, access is granted if occuring from the class where\n-\t member is declared or a subclass of it */\n+\t member is declared or a subclass of it. Find the right\n+\t context to perform the check */\n+      if (PURE_INNER_CLASS_TYPE_P (reference))\n+        {\n+          while (INNER_CLASS_TYPE_P (reference))\n+            {\n+              if (inherits_from_p (reference, DECL_CONTEXT (member)))\n+                return 0;\n+              reference = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (reference)));\n+            }\n+        }\n       if (inherits_from_p (reference, DECL_CONTEXT (member)))\n \treturn 0;\n       return 1;\n     }\n \n   /* Check access on private members. Access is granted only if it\n      occurs from within the class in which it is declared. Exceptions\n-     are accesses from inner-classes. This section is probably not\n-     complete. FIXME */\n+     are accesses from inner-classes. */\n   if (access_flag & ACC_PRIVATE)\n     return (current_class == DECL_CONTEXT (member) ? 0 : \n \t    (INNER_CLASS_TYPE_P (current_class) ? 0 : 1));\n@@ -9643,7 +9699,7 @@ patch_method_invocation (patch, primary, where, is_static, ret_decl)\n \t     \n \t     maybe_use_access_method returns a non zero value if the\n \t     this_arg has to be moved into the (then generated) stub\n-\t     argument list. In the mean time, the selected function\n+\t     argument list. In the meantime, the selected function\n \t     might have be replaced by a generated stub. */\n \t  if (maybe_use_access_method (is_super_init, &list, &this_arg))\n \t    args = tree_cons (NULL_TREE, this_arg, args);\n@@ -9811,7 +9867,7 @@ maybe_use_access_method (is_super_init, mdecl, this_arg)\n   if (non_static_context)\n     {\n       ctx = TREE_TYPE (DECL_CONTEXT (TYPE_NAME (current_class)));\n-      if (ctx == DECL_CONTEXT (md))\n+      if (inherits_from_p (ctx, DECL_CONTEXT (md)))\n \t{\n \t  ta = build_current_thisn (current_class);\n \t  ta = build_wfl_node (ta);\n@@ -9822,7 +9878,7 @@ maybe_use_access_method (is_super_init, mdecl, this_arg)\n \t  while (type)\n \t    {\n \t      maybe_build_thisn_access_method (type);\n-\t      if (type == DECL_CONTEXT (md))\n+\t      if (inherits_from_p (type, DECL_CONTEXT (md)))\n \t\t{\n \t\t  ta = build_access_to_thisn (ctx, type, 0);\n \t\t  break;"}]}