{"sha": "19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTlkNGJhZWQ1NzIxZWI3Yzk1ZTU2YzJiZWM2OGFlN2RiNjMwOGY5ZQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-08T14:03:13Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2014-10-08T14:03:13Z"}, "message": "re PR go/60406 (recover.go: test13reflect2 test failure)\n\n\tPR go/60406\nruntime: Check callers in can_recover if return address\tdoesn't match.\n\nAlso use __builtin_extract_return_address and tighten up the\nchecks in FFI code.\n\nFixes PR 60406.\n\nFrom-SVN: r216003", "tree": {"sha": "d77929061927995d8e986e036e1f3492deb0e252", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d77929061927995d8e986e036e1f3492deb0e252"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/comments", "author": null, "committer": null, "parents": [{"sha": "9d07d890e6542570950e1b0bbbb231fac3249774", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9d07d890e6542570950e1b0bbbb231fac3249774", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9d07d890e6542570950e1b0bbbb231fac3249774"}], "stats": {"total": 271, "additions": 195, "deletions": 76}, "files": [{"sha": "a3dfd4acd2c3ad1cff08175633f0d52087d4a0b5", "filename": "libgo/go/reflect/makefunc_ffi_c.c", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Fmakefunc_ffi_c.c?ref=19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "patch": "@@ -36,21 +36,23 @@ void ffiFree(void *data)\n    Go callback function (passed in user_data) with the pointer to the\n    arguments and the results area.  */\n \n+static void ffi_callback (ffi_cif *, void *, void **, void *)\n+  __asm__ (\"reflect.ffi_callback\");\n+\n static void\n ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n \t      void **args, void *user_data)\n {\n-  Location locs[6];\n+  Location locs[8];\n   int n;\n   int i;\n-  const void *pc;\n   FuncVal *fv;\n   void (*f) (void *, void *);\n \n   /* This function is called from some series of FFI closure functions\n-     called by a Go function.  We want to pass the PC of the Go\n-     function to makefunc_can_recover.  Look up the stack for a\n-     function that is definitely not an FFI function.  */\n+     called by a Go function.  We want to see whether the caller of\n+     the closure functions can recover.  Look up the stack and skip\n+     the FFI functions.  */\n   n = runtime_callers (1, &locs[0], sizeof locs / sizeof locs[0], true);\n   for (i = 0; i < n; i++)\n     {\n@@ -61,28 +63,19 @@ ffi_callback (ffi_cif* cif __attribute__ ((unused)), void *results,\n       if (locs[i].function.len < 4)\n \tbreak;\n       name = locs[i].function.str;\n-      if (*name == '_')\n-\t{\n-\t  if (locs[i].function.len < 5)\n-\t    break;\n-\t  ++name;\n-\t}\n       if (name[0] != 'f' || name[1] != 'f' || name[2] != 'i' || name[3] != '_')\n \tbreak;\n     }\n   if (i < n)\n-    pc = (const void *) locs[i].pc;\n-  else\n-    pc = __builtin_return_address (0);\n-\n-  __go_makefunc_can_recover (pc);\n+    __go_makefunc_ffi_can_recover (locs + i, n - i);\n \n   fv = (FuncVal *) user_data;\n   __go_set_closure (fv);\n   f = (void *) fv->fn;\n   f (args, results);\n \n-  __go_makefunc_returning ();\n+  if (i < n)\n+    __go_makefunc_returning ();\n }\n \n /* Allocate an FFI closure and arrange to call ffi_callback.  */"}, {"sha": "3a48fe1130e265c7080a7a6c6ea702fbe189acf0", "filename": "libgo/runtime/go-defer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-defer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-defer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-defer.c?ref=19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "patch": "@@ -80,6 +80,6 @@ __go_set_defer_retaddr (void *retaddr)\n \n   g = runtime_g ();\n   if (g->defer != NULL)\n-    g->defer->__retaddr = retaddr;\n+    g->defer->__retaddr = __builtin_extract_return_addr (retaddr);\n   return 0;\n }"}, {"sha": "d29fe88b57a4396a86ead6513a453c88d26bbe30", "filename": "libgo/runtime/go-panic.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-panic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-panic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-panic.h?ref=19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "patch": "@@ -38,9 +38,12 @@ extern void __go_print_string (struct String);\n \n extern struct __go_empty_interface __go_recover (void);\n \n-extern _Bool __go_can_recover (const void *);\n+extern _Bool __go_can_recover (void *);\n \n-extern void __go_makefunc_can_recover (const void *retaddr);\n+extern void __go_makefunc_can_recover (void *retaddr);\n+\n+struct Location;\n+extern void __go_makefunc_ffi_can_recover (struct Location *, int);\n \n extern void __go_makefunc_returning (void);\n "}, {"sha": "fc66f61cab325c3dabba03bdfc266d5a15909d8f", "filename": "libgo/runtime/go-recover.c", "status": "modified", "additions": 175, "deletions": 54, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-recover.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fgo-recover.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-recover.c?ref=19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "patch": "@@ -9,86 +9,163 @@\n #include \"go-panic.h\"\n #include \"go-defer.h\"\n \n+/* If the top of the defer stack can be recovered, then return it.\n+   Otherwise return NULL.  */\n+\n+static struct __go_defer_stack *\n+current_defer ()\n+{\n+  G *g;\n+  struct __go_defer_stack *d;\n+\n+  g = runtime_g ();\n+\n+  d = g->defer;\n+  if (d == NULL)\n+    return NULL;\n+\n+  /* The panic which would be recovered is the one on the top of the\n+     panic stack.  We do not want to recover it if that panic was on\n+     the top of the panic stack when this function was deferred.  */\n+  if (d->__panic == g->panic)\n+    return NULL;\n+\n+  /* The deferred thunk will call _go_set_defer_retaddr.  If this has\n+     not happened, then we have not been called via defer, and we can\n+     not recover.  */\n+  if (d->__retaddr == NULL)\n+    return NULL;\n+\n+  return d;\n+}\n+\n /* This is called by a thunk to see if the real function should be\n    permitted to recover a panic value.  Recovering a value is\n    permitted if the thunk was called directly by defer.  RETADDR is\n    the return address of the function which is calling\n    __go_can_recover--this is, the thunk.  */\n \n _Bool\n-__go_can_recover (const void *retaddr)\n+__go_can_recover (void *retaddr)\n {\n-  G *g;\n   struct __go_defer_stack *d;\n   const char* ret;\n   const char* dret;\n-  Location loc;\n+  Location locs[16];\n   const byte *name;\n+  intgo len;\n+  int n;\n+  int i;\n+  _Bool found_ffi_callback;\n \n-  g = runtime_g ();\n-\n-  d = g->defer;\n+  d = current_defer ();\n   if (d == NULL)\n     return 0;\n \n-  /* The panic which this function would recover is the one on the top\n-     of the panic stack.  We do not want to recover it if that panic\n-     was on the top of the panic stack when this function was\n-     deferred.  */\n-  if (d->__panic == g->panic)\n-    return 0;\n-\n-  /* D->__RETADDR is the address of a label immediately following the\n-     call to the thunk.  We can recover a panic if that is the same as\n-     the return address of the thunk.  We permit a bit of slack in\n-     case there is any code between the function return and the label,\n-     such as an instruction to adjust the stack pointer.  */\n-\n-  ret = (const char *) retaddr;\n-\n-#ifdef __sparc__\n-  /* On SPARC the address we get, from __builtin_return_address, is\n-     the address of the call instruction.  Adjust forward, also\n-     skipping the delayed instruction following the call.  */\n-  ret += 8;\n-#endif\n+  ret = (const char *) __builtin_extract_return_addr (retaddr);\n \n   dret = (const char *) d->__retaddr;\n   if (ret <= dret && ret + 16 >= dret)\n     return 1;\n \n-  /* If the function calling recover was created by reflect.MakeFunc,\n-     then RETADDR will be somewhere in libffi.  Our caller is\n-     permitted to recover if it was called from libffi.  */\n-  if (!d->__makefunc_can_recover)\n-    return 0;\n+  /* On some systems, in some cases, the return address does not work\n+     reliably.  See http://gcc.gnu.org/PR60406.  If we are permitted\n+     to call recover, the call stack will look like this:\n+       __go_panic, __go_undefer, etc.\n+       thunk to call deferred function (calls __go_set_defer_retaddr)\n+       function that calls __go_can_recover (passing return address)\n+       __go_can_recover\n+     Calling runtime_callers will skip the thunks.  So if our caller's\n+     caller starts with __go, then we are permitted to call\n+     recover.  */\n \n-  if (runtime_callers (2, &loc, 1, false) < 1)\n+  if (runtime_callers (1, &locs[0], 2, false) < 2)\n     return 0;\n \n-  /* If we have no function name, then we weren't called by Go code.\n-     Guess that we were called by libffi.  */\n-  if (loc.function.len == 0)\n+  name = locs[1].function.str;\n+  len = locs[1].function.len;\n+\n+  /* Although locs[1].function is a Go string, we know it is\n+     NUL-terminated.  */\n+  if (len > 4\n+      && __builtin_strchr ((const char *) name, '.') == NULL\n+      && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n     return 1;\n \n-  if (loc.function.len < 4)\n-    return 0;\n-  name = loc.function.str;\n-  if (*name == '_')\n+  /* If we are called from __go_makefunc_can_recover, then we need to\n+     look one level higher.  */\n+  if (locs[0].function.len > 0\n+      && __builtin_strcmp ((const char *) locs[0].function.str,\n+\t\t\t   \"__go_makefunc_can_recover\") == 0)\n     {\n-      if (loc.function.len < 5)\n+      if (runtime_callers (3, &locs[0], 1, false) < 1)\n \treturn 0;\n-      ++name;\n+      name = locs[0].function.str;\n+      len = locs[0].function.len;\n+      if (len > 4\n+\t  && __builtin_strchr ((const char *) name, '.') == NULL\n+\t  && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n+\treturn 1;\n     }\n \n-  if (name[0] == 'f' && name[1] == 'f' && name[2] == 'i' && name[3] == '_')\n-    return 1;\n+  /* If the function calling recover was created by reflect.MakeFunc,\n+     then __go_makefunc_can_recover or __go_makefunc_ffi_can_recover\n+     will have set the __makefunc_can_recover field.  */\n+  if (!d->__makefunc_can_recover)\n+    return 0;\n \n-  /* We may also be called by reflect.makeFuncImpl.call or\n-     reflect.ffiCall, for a function created by reflect.MakeFunc.  */\n-  if (__builtin_strstr ((const char *) name, \"makeFuncImpl\") != NULL\n-      || __builtin_strcmp ((const char *) name, \"reflect.ffiCall\") == 0)\n-    return 1;\n+  /* We look up the stack, ignoring libffi functions and functions in\n+     the reflect package, until we find reflect.makeFuncStub or\n+     reflect.ffi_callback called by FFI functions.  Then we check the\n+     caller of that function.  */\n+\n+  n = runtime_callers (2, &locs[0], sizeof locs / sizeof locs[0], false);\n+  found_ffi_callback = 0;\n+  for (i = 0; i < n; i++)\n+    {\n+      const byte *name;\n+\n+      if (locs[i].function.len == 0)\n+\t{\n+\t  /* No function name means this caller isn't Go code.  Assume\n+\t     that this is libffi.  */\n+\t  continue;\n+\t}\n+\n+      /* Ignore functions in libffi.  */\n+      name = locs[i].function.str;\n+      if (__builtin_strncmp ((const char *) name, \"ffi_\", 4) == 0)\n+\tcontinue;\n+\n+      if (found_ffi_callback)\n+\tbreak;\n+\n+      if (__builtin_strcmp ((const char *) name, \"reflect.ffi_callback\") == 0)\n+\t{\n+\t  found_ffi_callback = 1;\n+\t  continue;\n+\t}\n+\n+      if (__builtin_strcmp ((const char *) name, \"reflect.makeFuncStub\") == 0)\n+\t{\n+\t  i++;\n+\t  break;\n+\t}\n+\n+      /* Ignore other functions in the reflect package.  */\n+      if (__builtin_strncmp ((const char *) name, \"reflect.\", 8) == 0)\n+\tcontinue;\n+\n+      /* We should now be looking at the real caller.  */\n+      break;\n+    }\n+\n+  if (i < n && locs[i].function.len > 0)\n+    {\n+      name = locs[i].function.str;\n+      if (__builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n+\treturn 1;\n+    }\n \n   return 0;\n }\n@@ -99,14 +176,58 @@ __go_can_recover (const void *retaddr)\n    real MakeFunc function is permitted to call recover.  */\n \n void\n-__go_makefunc_can_recover (const void *retaddr)\n+__go_makefunc_can_recover (void *retaddr)\n {\n   struct __go_defer_stack *d;\n \n-  d = runtime_g ()->defer;\n-  if (d != NULL\n-      && !d->__makefunc_can_recover\n-      && __go_can_recover (retaddr))\n+  d = current_defer ();\n+  if (d == NULL)\n+    return;\n+\n+  /* If we are already in a call stack of MakeFunc functions, there is\n+     nothing we can usefully check here.  */\n+  if (d->__makefunc_can_recover)\n+    return;\n+\n+  if (__go_can_recover (retaddr))\n+    d->__makefunc_can_recover = 1;\n+}\n+\n+/* This function is called when code is about to enter a function\n+   created by the libffi version of reflect.MakeFunc.  This function\n+   is passed the names of the callers of the libffi code that called\n+   the stub.  It uses to decide whether it is permitted to call\n+   recover, and sets d->__makefunc_can_recover so that __go_recover\n+   can make the same decision.  */\n+\n+void\n+__go_makefunc_ffi_can_recover (struct Location *loc, int n)\n+{\n+  struct __go_defer_stack *d;\n+  const byte *name;\n+  intgo len;\n+\n+  d = current_defer ();\n+  if (d == NULL)\n+    return;\n+\n+  /* If we are already in a call stack of MakeFunc functions, there is\n+     nothing we can usefully check here.  */\n+  if (d->__makefunc_can_recover)\n+    return;\n+\n+  /* LOC points to the caller of our caller.  That will be a thunk.\n+     If its caller was a runtime function, then it was called directly\n+     by defer.  */\n+\n+  if (n < 2)\n+    return;\n+\n+  name = (loc + 1)->function.str;\n+  len = (loc + 1)->function.len;\n+  if (len > 4\n+      && __builtin_strchr ((const char *) name, '.') == NULL\n+      && __builtin_strncmp ((const char *) name, \"__go_\", 4) == 0)\n     d->__makefunc_can_recover = 1;\n }\n "}, {"sha": "de000db988993fbe8abb8f7eef82e4f86a2080d8", "filename": "libgo/runtime/panic.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fpanic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/19d4baed5721eb7c95e56c2bec68ae7db6308f9e/libgo%2Fruntime%2Fpanic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fpanic.c?ref=19d4baed5721eb7c95e56c2bec68ae7db6308f9e", "patch": "@@ -49,8 +49,10 @@ runtime_freedefer(Defer *d)\n }\n \n // Run all deferred functions for the current goroutine.\n+// This is noinline for go_can_recover.\n+static void __go_rundefer (void) __attribute__ ((noinline));\n static void\n-rundefer(void)\n+__go_rundefer(void)\n {\n \tG *g;\n \tDefer *d;\n@@ -219,7 +221,7 @@ void runtime_Goexit (void) __asm__ (GOSYM_PREFIX \"runtime.Goexit\");\n void\n runtime_Goexit(void)\n {\n-\trundefer();\n+\t__go_rundefer();\n \truntime_goexit();\n }\n "}]}