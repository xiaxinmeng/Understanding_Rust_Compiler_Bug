{"sha": "2c28c3e49983e8054850e60704edc391146e376d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmMyOGMzZTQ5OTgzZTgwNTQ4NTBlNjA3MDRlZGMzOTExNDZlMzc2ZA==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2016-11-25T08:17:46Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2016-11-25T08:17:46Z"}, "message": "Tighten check for whether sibcall references local variables\n\nThis loop:\n\n      /* Make sure the tail invocation of this function does not refer\n         to local variables.  */\n      FOR_EACH_LOCAL_DECL (cfun, idx, var)\n        {\n          if (TREE_CODE (var) != PARM_DECL\n              && auto_var_in_fn_p (var, cfun->decl)\n              && (ref_maybe_used_by_stmt_p (call, var)\n                  || call_may_clobber_ref_p (call, var)))\n            return;\n        }\n\ntriggered even for local variables that are passed by value.\nThis meant that we didn't allow local aggregates to be passed\nto a sibling call but did (for example) allow global aggregates\nto be passed.\n\nI think the loop is really checking for indirect references,\nso should be able to skip any variables that never have their\naddress taken.\n\ngcc/\n\t* tree-tailcall.c (find_tail_calls): Allow calls to reference\n\tlocal variables if all references are known to be direct.\n\ngcc/testsuite/\n\t* gcc.dg/tree-ssa/tailcall-8.c: New test.\n\nFrom-SVN: r242860", "tree": {"sha": "58fb86ed3f74b01d70b68acd8de7a8c9713e941b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/58fb86ed3f74b01d70b68acd8de7a8c9713e941b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c28c3e49983e8054850e60704edc391146e376d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c28c3e49983e8054850e60704edc391146e376d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c28c3e49983e8054850e60704edc391146e376d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c28c3e49983e8054850e60704edc391146e376d/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4ae35e698893dcf2b11ab6fa7b39a9f5e0973cd8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae35e698893dcf2b11ab6fa7b39a9f5e0973cd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ae35e698893dcf2b11ab6fa7b39a9f5e0973cd8"}], "stats": {"total": 95, "additions": 93, "deletions": 2}, "files": [{"sha": "efc20162e12360e326ef0ef942b38ebeedd5d140", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c28c3e49983e8054850e60704edc391146e376d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c28c3e49983e8054850e60704edc391146e376d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2c28c3e49983e8054850e60704edc391146e376d", "patch": "@@ -1,3 +1,8 @@\n+2016-11-25  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-tailcall.c (find_tail_calls): Allow calls to reference\n+\tlocal variables if all references are known to be direct.\n+\n 2016-11-25  Jakub Jelinek  <jakub@redhat.com>\n \t    Prathamesh Kulkarni  <prathamesh.kulkarni@linaro.org>\n "}, {"sha": "e18397f2a4ccc5110b8c93abaa2719e961de2371", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=2c28c3e49983e8054850e60704edc391146e376d", "patch": "@@ -1,3 +1,7 @@\n+2016-11-25  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/tree-ssa/tailcall-8.c: New test.\n+\n 2016-11-25  Senthil Kumar Selvaraj  <senthil_kumar.selvaraj@atmel.com>\n \n \t* gcc.dg/pr64277.c: Use __INT32_TYPE__ for targets"}, {"sha": "ffeabe54293605cdca3c036c951814e2d47f9763", "filename": "gcc/testsuite/gcc.dg/tree-ssa/tailcall-8.c", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Ftailcall-8.c?ref=2c28c3e49983e8054850e60704edc391146e376d", "patch": "@@ -0,0 +1,80 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-tailc-details\" } */\n+\n+struct s { int x; };\n+void f_direct (struct s);\n+void f_indirect (struct s *);\n+void f_void (void);\n+\n+/* Tail call.  */\n+void\n+g1 (struct s param)\n+{\n+  f_direct (param);\n+}\n+\n+/* Tail call.  */\n+void\n+g2 (struct s *param_ptr)\n+{\n+  f_direct (*param_ptr);\n+}\n+\n+/* Tail call.  */\n+void\n+g3 (struct s *param_ptr)\n+{\n+  f_indirect (param_ptr);\n+}\n+\n+/* Tail call.  */\n+void\n+g4 (struct s *param_ptr)\n+{\n+  f_indirect (param_ptr);\n+  f_void ();\n+}\n+\n+/* Tail call.  */\n+void\n+g5 (struct s param)\n+{\n+  struct s local = param;\n+  f_direct (local);\n+}\n+\n+/* Tail call.  */\n+void\n+g6 (struct s param)\n+{\n+  struct s local = param;\n+  f_direct (local);\n+  f_void ();\n+}\n+\n+/* Not a tail call.  */\n+void\n+g7 (struct s param)\n+{\n+  struct s local = param;\n+  f_indirect (&local);\n+}\n+\n+/* Not a tail call.  */\n+void\n+g8 (struct s *param_ptr)\n+{\n+  struct s local = *param_ptr;\n+  f_indirect (&local);\n+}\n+\n+/* Not a tail call.  */\n+void\n+g9 (struct s *param_ptr)\n+{\n+  struct s local = *param_ptr;\n+  f_indirect (&local);\n+  f_void ();\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"Found tail call\" 6 \"tailc\" } } */"}, {"sha": "66a0a4c446097f61dc47e66ec61079d836833efb", "filename": "gcc/tree-tailcall.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftree-tailcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c28c3e49983e8054850e60704edc391146e376d/gcc%2Ftree-tailcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-tailcall.c?ref=2c28c3e49983e8054850e60704edc391146e376d", "patch": "@@ -504,12 +504,14 @@ find_tail_calls (basic_block bb, struct tailcall **ret)\n \ttail_recursion = true;\n     }\n \n-  /* Make sure the tail invocation of this function does not refer\n-     to local variables.  */\n+  /* Make sure the tail invocation of this function does not indirectly\n+     refer to local variables.  (Passing variables directly by value\n+     is OK.)  */\n   FOR_EACH_LOCAL_DECL (cfun, idx, var)\n     {\n       if (TREE_CODE (var) != PARM_DECL\n \t  && auto_var_in_fn_p (var, cfun->decl)\n+\t  && may_be_aliased (var)\n \t  && (ref_maybe_used_by_stmt_p (call, var)\n \t      || call_may_clobber_ref_p (call, var)))\n \treturn;"}]}