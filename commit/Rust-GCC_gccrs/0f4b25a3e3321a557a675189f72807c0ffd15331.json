{"sha": "0f4b25a3e3321a557a675189f72807c0ffd15331", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGY0YjI1YTNlMzMyMWE1NTdhNjc1MTg5ZjcyODA3YzBmZmQxNTMzMQ==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernd.schmidt@analog.com", "date": "2007-04-11T19:44:07Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2007-04-11T19:44:07Z"}, "message": "reload.c (find_reloads_toplev, [...]): Use rtx_equal_p...\n\n\t* reload.c (find_reloads_toplev, find_reloads_address,\n\tfind_reloads_address_1, find_reloads_subreg_address): Use rtx_equal_p,\n\tnot a pointer equality test, to decide if we need to call\n\tpush_reg_equiv_alt_mem.\n\nFrom-SVN: r123724", "tree": {"sha": "e021a019582c8d567fed8873086f55fca84b3e9e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e021a019582c8d567fed8873086f55fca84b3e9e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0f4b25a3e3321a557a675189f72807c0ffd15331", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4b25a3e3321a557a675189f72807c0ffd15331", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0f4b25a3e3321a557a675189f72807c0ffd15331", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0f4b25a3e3321a557a675189f72807c0ffd15331/comments", "author": null, "committer": null, "parents": [{"sha": "017133fdc11f47bbaff2932171c6818baf27df56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/017133fdc11f47bbaff2932171c6818baf27df56", "html_url": "https://github.com/Rust-GCC/gccrs/commit/017133fdc11f47bbaff2932171c6818baf27df56"}], "stats": {"total": 19, "additions": 13, "deletions": 6}, "files": [{"sha": "9889ae13bd17f3037c3f58aed020a155876f54cc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f4b25a3e3321a557a675189f72807c0ffd15331/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f4b25a3e3321a557a675189f72807c0ffd15331/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0f4b25a3e3321a557a675189f72807c0ffd15331", "patch": "@@ -1,3 +1,10 @@\n+2007-04-11  Bernd Schmidt  <bernd.schmidt@analog.com>\n+\n+\t* reload.c (find_reloads_toplev, find_reloads_address,\n+\tfind_reloads_address_1, find_reloads_subreg_address): Use rtx_equal_p,\n+\tnot a pointer equality test, to decide if we need to call\n+\tpush_reg_equiv_alt_mem.\n+\n 2007-04-11  Sebastian Pop  <sebastian.pop@inria.fr>\n \n \t* tree-data-ref.c (affine_function_zero_p, constant_access_functions,"}, {"sha": "aa22671c13ac456a606f9654df18954a08bb949c", "filename": "gcc/reload.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0f4b25a3e3321a557a675189f72807c0ffd15331/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0f4b25a3e3321a557a675189f72807c0ffd15331/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=0f4b25a3e3321a557a675189f72807c0ffd15331", "patch": "@@ -4570,7 +4570,7 @@ find_reloads_toplev (rtx x, int opnum, enum reload_type type,\n \t      x = mem;\n \t      i = find_reloads_address (GET_MODE (x), &x, XEXP (x, 0), &XEXP (x, 0),\n \t\t\t\t\topnum, type, ind_levels, insn);\n-\t      if (x != mem)\n+\t      if (!rtx_equal_p (x, mem))\n \t\tpush_reg_equiv_alt_mem (regno, x);\n \t      if (address_reloaded)\n \t\t*address_reloaded = i;\n@@ -4785,7 +4785,7 @@ find_reloads_address (enum machine_mode mode, rtx *memrefloc, rtx ad,\n \t\t  find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum,\n \t\t\t\t\tADDR_TYPE (type), ind_levels, insn);\n-\t\t  if (tem != orig)\n+\t\t  if (!rtx_equal_p (tem, orig))\n \t\t    push_reg_equiv_alt_mem (regno, tem);\n \t\t}\n \t      /* We can avoid a reload if the register's equivalent memory\n@@ -5589,7 +5589,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t\t\t      RELOAD_OTHER,\n \t\t\t\t      ind_levels, insn);\n \n-\t\tif (tem != orig)\n+\t\tif (!rtx_equal_p (tem, orig))\n \t\t  push_reg_equiv_alt_mem (regno, tem);\n \n \t\t/* Then reload the memory location into a base\n@@ -5656,7 +5656,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\t  find_reloads_address (GET_MODE (tem), &tem, XEXP (tem, 0),\n \t\t\t\t\t&XEXP (tem, 0), opnum, type,\n \t\t\t\t\tind_levels, insn);\n-\t\t  if (tem != orig)\n+\t\t  if (!rtx_equal_p (tem, orig))\n \t\t    push_reg_equiv_alt_mem (regno, tem);\n \t\t  /* Put this inside a new increment-expression.  */\n \t\t  x = gen_rtx_fmt_e (GET_CODE (x), GET_MODE (x), tem);\n@@ -5811,7 +5811,7 @@ find_reloads_address_1 (enum machine_mode mode, rtx x, int context,\n \t\tfind_reloads_address (GET_MODE (x), &x, XEXP (x, 0),\n \t\t\t\t      &XEXP (x, 0), opnum, ADDR_TYPE (type),\n \t\t\t\t      ind_levels, insn);\n-\t\tif (x != tem)\n+\t\tif (!rtx_equal_p (x, tem))\n \t\t  push_reg_equiv_alt_mem (regno, x);\n \t      }\n \t  }\n@@ -6037,7 +6037,7 @@ find_reloads_subreg_address (rtx x, int force_replace, int opnum,\n \t\t\t\t    &XEXP (tem, 0), opnum, type,\n \t\t\t\t    ind_levels, insn);\n \t      /* ??? Do we need to handle nonzero offsets somehow?  */\n-\t      if (!offset && tem != orig)\n+\t      if (!offset && !rtx_equal_p (tem, orig))\n \t\tpush_reg_equiv_alt_mem (regno, tem);\n \n \t      /* If this is not a toplevel operand, find_reloads doesn't see"}]}