{"sha": "314883b80a758453f7f705a0f6c8382509407ae0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzE0ODgzYjgwYTc1ODQ1M2Y3ZjcwNWEwZjZjODM4MjUwOTQwN2FlMA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2000-04-14T22:04:58Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2000-04-14T22:04:58Z"}, "message": "flow.c (count_basic_blocks): Remove unused var PREV_CALL.\n\n\t* flow.c (count_basic_blocks): Remove unused var PREV_CALL.\n\tNever have a LIBCALL end a basic block.\n\t(find_basic_blocks_1): Likewise.\n\tReorganize CALL_INSN cases.\n\nFrom-SVN: r33154", "tree": {"sha": "1019276206d50a914d4319f98d191598b31801bb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1019276206d50a914d4319f98d191598b31801bb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/314883b80a758453f7f705a0f6c8382509407ae0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314883b80a758453f7f705a0f6c8382509407ae0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/314883b80a758453f7f705a0f6c8382509407ae0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/314883b80a758453f7f705a0f6c8382509407ae0/comments", "author": null, "committer": null, "parents": [{"sha": "e0bf4f7b169c8f0d99024d63dd5f4acbee684d95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0bf4f7b169c8f0d99024d63dd5f4acbee684d95", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0bf4f7b169c8f0d99024d63dd5f4acbee684d95"}], "stats": {"total": 152, "additions": 80, "deletions": 72}, "files": [{"sha": "8372339fab02f150599525ac0f25cf86974c1b84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314883b80a758453f7f705a0f6c8382509407ae0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314883b80a758453f7f705a0f6c8382509407ae0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=314883b80a758453f7f705a0f6c8382509407ae0", "patch": "@@ -1,5 +1,10 @@\n Fri Apr 14 18:07:30 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* flow.c (count_basic_blocks): Remove unused var PREV_CALL.\n+\tNever have a LIBCALL end a basic block.\n+\t(find_basic_blocks_1): Likewise.\n+\tReorganize CALL_INSN cases.\n+\n \t* sbitmap.h (EXECUTE_IF_SET_IN_SBITMAP): Revert last change.\n \n Fri Apr 14 10:54:22 2000  Jim Wilson  <wilson@cygnus.com>"}, {"sha": "c0583e87f054450ba3e695e8a417846aefa7dac3", "filename": "gcc/flow.c", "status": "modified", "additions": 75, "deletions": 72, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/314883b80a758453f7f705a0f6c8382509407ae0/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/314883b80a758453f7f705a0f6c8382509407ae0/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=314883b80a758453f7f705a0f6c8382509407ae0", "patch": "@@ -462,7 +462,7 @@ count_basic_blocks (f)\n   register int count = 0;\n   int eh_region = 0;\n   int call_had_abnormal_edge = 0;\n-  rtx prev_call = NULL_RTX;\n+  int in_libcall = 0;\n \n   prev_code = JUMP_INSN;\n   for (insn = f; insn; insn = NEXT_INSN (insn))\n@@ -473,42 +473,42 @@ count_basic_blocks (f)\n \t  || (GET_RTX_CLASS (code) == 'i'\n \t      && (prev_code == JUMP_INSN\n \t\t  || prev_code == BARRIER\n-\t\t  || (prev_code == CALL_INSN && call_had_abnormal_edge))))\n-\t{\n-\t  count++;\n-\t}\n+\t\t  || (prev_code == CALL_INSN\n+\t\t      && call_had_abnormal_edge && in_libcall == 0))))\n+\tcount++;\n+\n+      /* Track whether or not we are in a LIBCALL block.  These must\n+\t all be within the same basic block.  */\n+      if (find_reg_note (insn, REG_LIBCALL, NULL_RTX) != 0)\n+\tin_libcall++;\n+      else if (find_reg_note (insn, REG_RETVAL, NULL_RTX) != 0)\n+\tin_libcall--;\n \n       /* Record whether this call created an edge.  */\n       if (code == CALL_INSN)\n \t{\n \t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n \t  int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n-\t  prev_call = insn;\n+\n \t  call_had_abnormal_edge = 0;\n \n \t  /* If there is an EH region or rethrow, we have an edge.  */\n \t  if ((eh_region && region > 0)\n \t      || find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n \t    call_had_abnormal_edge = 1;\n-\t  else\n-\t    {\n-\t      /* If there is a nonlocal goto label and the specified\n-\t\t region number isn't -1, we have an edge. (0 means\n-\t\t no throw, but might have a nonlocal goto).  */\n-\t      if (nonlocal_goto_handler_labels && region >= 0)\n-\t\tcall_had_abnormal_edge = 1;\n-\t    }\n+\t  else if (nonlocal_goto_handler_labels && region >= 0)\n+\t    /* If there is a nonlocal goto label and the specified\n+\t       region number isn't -1, we have an edge. (0 means\n+\t       no throw, but might have a nonlocal goto).  */\n+\t    call_had_abnormal_edge = 1;\n \t}\n-      else if (code != NOTE)\n-\tprev_call = NULL_RTX;\n \n       if (code != NOTE)\n \tprev_code = code;\n       else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_BEG)\n \t++eh_region;\n       else if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_EH_REGION_END)\n \t--eh_region;\n-\n     }\n \n   /* The rest of the compiler works a bit smoother when we don't have to\n@@ -532,13 +532,13 @@ find_basic_blocks_1 (f)\n      rtx f;\n {\n   register rtx insn, next;\n-  int call_has_abnormal_edge = 0;\n   int i = 0;\n   rtx bb_note = NULL_RTX;\n   rtx eh_list = NULL_RTX;\n   rtx label_value_list = NULL_RTX;\n   rtx head = NULL_RTX;\n   rtx end = NULL_RTX;\n+  int in_libcall = 0;\n   \n   /* We process the instructions in a slightly different way than we did\n      previously.  This is so that we see a NOTE_BASIC_BLOCK after we have\n@@ -552,27 +552,6 @@ find_basic_blocks_1 (f)\n \n       next = NEXT_INSN (insn);\n \n-      if (code == CALL_INSN)\n-\t{\n-\t  /* Record whether this call created an edge.  */\n-\t  rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n-\t  int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n-\t  call_has_abnormal_edge = 0;\n-\n-\t  /* If there is an EH region or rethrow, we have an edge.  */\n-\t  if ((eh_list && region > 0)\n-\t      || find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n-\t    call_has_abnormal_edge = 1;\n-\t  else\n-\t    {\n-\t      /* If there is a nonlocal goto label and the specified\n-\t\t region number isn't -1, we have an edge. (0 means\n-\t\t no throw, but might have a nonlocal goto).  */\n-\t      if (nonlocal_goto_handler_labels && region >= 0)\n-\t\tcall_has_abnormal_edge = 1;\n-\t    }\n-\t}\n-\n       switch (code)\n \t{\n \tcase NOTE:\n@@ -585,6 +564,7 @@ find_basic_blocks_1 (f)\n \t    else if (kind == NOTE_INSN_EH_REGION_END)\n \t      {\n \t\trtx t = eh_list;\n+\n \t\teh_list = XEXP (eh_list, 1);\n \t\tfree_INSN_LIST_node (t);\n \t      }\n@@ -597,9 +577,9 @@ find_basic_blocks_1 (f)\n \t      {\n \t\tif (bb_note == NULL_RTX)\n \t\t  bb_note = insn;\n+\n \t\tnext = flow_delete_insn (insn);\n \t      }\n-\n \t    break;\n \t  }\n \n@@ -613,8 +593,7 @@ find_basic_blocks_1 (f)\n \t\t does not imply an abnormal edge, it will be a bit before\n \t\t everything can be updated.  So continue to emit a noop at\n \t\t the end of such a block.  */\n-\t      if (GET_CODE (end) == CALL_INSN\n-\t\t  && ! SIBLING_CALL_P (end))\n+\t      if (GET_CODE (end) == CALL_INSN && ! SIBLING_CALL_P (end))\n \t\t{\n \t\t  rtx nop = gen_rtx_USE (VOIDmode, const0_rtx);\n \t\t  end = emit_insn_after (nop, end);\n@@ -623,6 +602,7 @@ find_basic_blocks_1 (f)\n \t      create_basic_block (i++, head, end, bb_note);\n \t      bb_note = NULL_RTX;\n \t    }\n+\n \t  head = end = insn;\n \t  break;\n \n@@ -666,29 +646,46 @@ find_basic_blocks_1 (f)\n \t     imply an abnormal edge, it will be a bit before everything can\n \t     be updated.  So continue to emit a noop at the end of such a\n \t     block.  */\n-\t  if (GET_CODE (end) == CALL_INSN\n-\t      && ! SIBLING_CALL_P (end))\n+\t  if (GET_CODE (end) == CALL_INSN && ! SIBLING_CALL_P (end))\n \t    {\n \t      rtx nop = gen_rtx_USE (VOIDmode, const0_rtx);\n \t      end = emit_insn_after (nop, end);\n \t    }\n \t  goto new_bb_exclusive;\n \n \tcase CALL_INSN:\n-\t  /* A basic block ends at a call that can either throw or\n-\t     do a non-local goto.  */\n-\t  if (call_has_abnormal_edge)\n-\t    {\n-\t    new_bb_inclusive:\n-\t      if (head == NULL_RTX)\n-\t\thead = insn;\n-\t      end = insn;\n+\t  {\n+\t    /* Record whether this call created an edge.  */\n+\t    rtx note = find_reg_note (insn, REG_EH_REGION, NULL_RTX);\n+\t    int region = (note ? INTVAL (XEXP (note, 0)) : 1);\n+\t    int call_has_abnormal_edge = 0;\n+\n+\t    /* If there is an EH region or rethrow, we have an edge.  */\n+\t    if ((eh_list && region > 0)\n+\t\t|| find_reg_note (insn, REG_EH_RETHROW, NULL_RTX))\n+\t      call_has_abnormal_edge = 1;\n+\t    else if (nonlocal_goto_handler_labels && region >= 0)\n+\t      /* If there is a nonlocal goto label and the specified\n+\t\t region number isn't -1, we have an edge. (0 means\n+\t\t no throw, but might have a nonlocal goto).  */\n+\t      call_has_abnormal_edge = 1;\n \n-\t    new_bb_exclusive:\n-\t      create_basic_block (i++, head, end, bb_note);\n-\t      head = end = NULL_RTX;\n-\t      bb_note = NULL_RTX;\n-\t      break;\n+\t    /* A basic block ends at a call that can either throw or\n+\t       do a non-local goto.  LIBCALLs must reside totally in one\n+\t       basic block, so don't end a block after them.  */\n+\t    if (call_has_abnormal_edge && in_libcall == 0)\n+\t      {\n+\t      new_bb_inclusive:\n+\t\tif (head == NULL_RTX)\n+\t\t  head = insn;\n+\t\tend = insn;\n+\n+\t      new_bb_exclusive:\n+\t\tcreate_basic_block (i++, head, end, bb_note);\n+\t\thead = end = NULL_RTX;\n+\t\tbb_note = NULL_RTX;\n+\t\tbreak;\n+\t      }\n \t    }\n \t  /* FALLTHRU */\n \n@@ -716,21 +713,27 @@ find_basic_blocks_1 (f)\n \t     we know isn't part of any otherwise visible control flow.  */\n \t     \n \t  for (note = REG_NOTES (insn); note; note = XEXP (note, 1))\n-\t    if (REG_NOTE_KIND (note) == REG_LABEL)\n-\t      {\n-\t        rtx lab = XEXP (note, 0), next;\n-\n-\t\tif (lab == eh_return_stub_label)\n-\t\t  ;\n-\t\telse if ((next = next_nonnote_insn (lab)) != NULL\n-\t\t\t && GET_CODE (next) == JUMP_INSN\n-\t\t\t && (GET_CODE (PATTERN (next)) == ADDR_VEC\n-\t\t\t     || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n-\t\t  ;\n-\t\telse\n-\t\t  label_value_list\n-\t\t    = alloc_EXPR_LIST (0, XEXP (note, 0), label_value_list);\n-\t      }\n+\t    {\n+\t      if (REG_NOTE_KIND (note) == REG_LABEL)\n+\t\t{\n+\t\t  rtx lab = XEXP (note, 0), next;\n+\n+\t\t  if (lab == eh_return_stub_label)\n+\t\t    ;\n+\t\t  else if ((next = next_nonnote_insn (lab)) != NULL\n+\t\t\t   && GET_CODE (next) == JUMP_INSN\n+\t\t\t   && (GET_CODE (PATTERN (next)) == ADDR_VEC\n+\t\t\t       || GET_CODE (PATTERN (next)) == ADDR_DIFF_VEC))\n+\t\t    ;\n+\t\t  else\n+\t\t    label_value_list\n+\t\t      = alloc_EXPR_LIST (0, XEXP (note, 0), label_value_list);\n+\t\t}\n+\t      else if (REG_NOTE_KIND (note) == REG_LIBCALL)\n+\t\tin_libcall++;\n+\t      else if (REG_NOTE_KIND (note) == REG_RETVAL)\n+\t\tin_libcall--;\n+\t    }\n \t}\n     }\n "}]}