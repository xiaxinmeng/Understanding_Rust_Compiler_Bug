{"sha": "6dc87f5f53deaabf19384afd42d5dbcad7591be7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRjODdmNWY1M2RlYWFiZjE5Mzg0YWZkNDJkNWRiY2FkNzU5MWJlNw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T08:25:21Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-04-21T08:25:21Z"}, "message": "[multiple changes]\n\n2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* sem_aux.ads, sem_aux.adb (Has_Rep_Item): New variant.\n\t* sem_util.adb (Inherit_Rep_Item_Chain): Reimplemented.\n\n2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* exp_ch6.adb: Minor reformatting.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch13.adb: Minor comment update.\n\n2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n\n\t* freeze.ads, freeze.adb (Freeze_Entity, Freeze_Before): Add\n\tboolean parameter to determine whether freezing an overloadable\n\tentity freezes its profile as well. This is required by\n\tAI05-019. The call to Freeze_Profile within Freeze_Entity is\n\tconditioned by the value of this flag, whose default is True.\n\t* sem_attr.adb (Resolve_Attribute, case 'Access): The attribute\n\treference freezes the prefix, but it the prefix is a subprogram\n\tit does not freeze its profile.\n\nFrom-SVN: r235308", "tree": {"sha": "3022799946c97e3950d7b19f5a16e2ee17dfe5ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3022799946c97e3950d7b19f5a16e2ee17dfe5ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dc87f5f53deaabf19384afd42d5dbcad7591be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc87f5f53deaabf19384afd42d5dbcad7591be7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dc87f5f53deaabf19384afd42d5dbcad7591be7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dc87f5f53deaabf19384afd42d5dbcad7591be7/comments", "author": null, "committer": null, "parents": [{"sha": "a14bbbb4a41ec6bfc503759e132445d421e3b7f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a14bbbb4a41ec6bfc503759e132445d421e3b7f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a14bbbb4a41ec6bfc503759e132445d421e3b7f1"}], "stats": {"total": 284, "additions": 223, "deletions": 61}, "files": [{"sha": "c44e72cd2f4b3cba9abbeb446b99384b467e29f6", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -1,3 +1,27 @@\n+2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* sem_aux.ads, sem_aux.adb (Has_Rep_Item): New variant.\n+\t* sem_util.adb (Inherit_Rep_Item_Chain): Reimplemented.\n+\n+2016-04-21  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* exp_ch6.adb: Minor reformatting.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch13.adb: Minor comment update.\n+\n+2016-04-21  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* freeze.ads, freeze.adb (Freeze_Entity, Freeze_Before): Add\n+\tboolean parameter to determine whether freezing an overloadable\n+\tentity freezes its profile as well. This is required by\n+\tAI05-019. The call to Freeze_Profile within Freeze_Entity is\n+\tconditioned by the value of this flag, whose default is True.\n+\t* sem_attr.adb (Resolve_Attribute, case 'Access): The attribute\n+\treference freezes the prefix, but it the prefix is a subprogram\n+\tit does not freeze its profile.\n+\n 2016-04-21  Javier Miranda  <miranda@adacore.com>\n \n \t* exp_util.adb (Build_Procedure_Form): No action needed for"}, {"sha": "ff9530b931f69e2b082ddd464653a87bcf4b9146", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -706,11 +706,10 @@ package body Exp_Ch6 is\n                   Stmts   : List_Id;\n \n                begin\n-                  --  The extended return may just contain the declaration.\n+                  --  The extended return may just contain the declaration\n \n                   if Present (Handled_Statement_Sequence (Stmt)) then\n-                     Stmts :=  Statements (Handled_Statement_Sequence (Stmt));\n-\n+                     Stmts := Statements (Handled_Statement_Sequence (Stmt));\n                   else\n                      Stmts := New_List;\n                   end if;\n@@ -2697,10 +2696,9 @@ package body Exp_Ch6 is\n          --  See for example Expand_Boolean_Operator().\n \n          if not (Comes_From_Source (Call_Node))\n-           and then Nkind\n-                      (Unit_Declaration_Node\n-                        (Ultimate_Alias (Entity (Name (Call_Node)))))\n-                      = N_Subprogram_Body\n+           and then Nkind (Unit_Declaration_Node\n+                            (Ultimate_Alias (Entity (Name (Call_Node))))) =\n+                              N_Subprogram_Body\n          then\n             Set_Entity (Name (Call_Node),\n               Rewritten_For_C_Func_Id"}, {"sha": "f5e114a0cabe6f07bebd687b536e01a45d5ab84e", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -1908,8 +1908,16 @@ package body Freeze is\n    -- Freeze_Before --\n    -------------------\n \n-   procedure Freeze_Before (N : Node_Id; T : Entity_Id) is\n-      Freeze_Nodes : constant List_Id := Freeze_Entity (T, N);\n+   procedure Freeze_Before\n+     (N   : Node_Id;\n+      T   : Entity_Id;\n+      F_P : Boolean := True)\n+   is\n+   --  Freeze T, then insert the generated Freeze nodes before the node N.\n+   --  The flag F_P is used when T is an overloadable entity, and indicates\n+   --  whether its profile should be frozen at the same time.\n+\n+      Freeze_Nodes : constant List_Id := Freeze_Entity (T, N, F_P);\n \n    begin\n       if Ekind (T) = E_Function then\n@@ -1925,7 +1933,11 @@ package body Freeze is\n    -- Freeze_Entity --\n    -------------------\n \n-   function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id is\n+   function Freeze_Entity\n+     (E : Entity_Id;\n+      N : Node_Id;\n+      F_P : Boolean := True) return List_Id\n+   is\n       Loc    : constant Source_Ptr := Sloc (N);\n       Atype  : Entity_Id;\n       Comp   : Entity_Id;\n@@ -4990,12 +5002,13 @@ package body Freeze is\n \n             --  In Ada 2012, freezing a subprogram does not always freeze\n             --  the corresponding profile (see AI05-019). An attribute\n-            --  reference is not a freezing point of the profile.\n+            --  reference is not a freezing point of the profile. The boolean\n+            --  Flag F_P indicates whether the profile should be frozen now.\n             --  Other constructs that should not freeze ???\n \n             --  This processing doesn't apply to internal entities (see below)\n \n-            if not Is_Internal (E) then\n+            if not Is_Internal (E) and then F_P then\n                if not Freeze_Profile (E) then\n                   Ghost_Mode := Save_Ghost_Mode;\n                   return Result;"}, {"sha": "d95038152fce8d96c0e4aee7cfcb1f8fe330b485", "filename": "gcc/ada/freeze.ads", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Ffreeze.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Ffreeze.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.ads?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -187,13 +187,19 @@ package Freeze is\n    --  If Initialization_Statements (E) is an N_Compound_Statement, insert its\n    --  actions in the enclosing list and reset the attribute.\n \n-   function Freeze_Entity (E : Entity_Id; N : Node_Id) return List_Id;\n+   function Freeze_Entity\n+     (E : Entity_Id;\n+      N : Node_Id;\n+      F_P : Boolean := True) return List_Id;\n    --  Freeze an entity, and return Freeze nodes, to be inserted at the point\n    --  of call. N is a node whose source location corresponds to the freeze\n    --  point. This is used in placing warning messages in the situation where\n    --  it appears that a type has been frozen too early, e.g. when a primitive\n    --  operation is declared after the freezing point of its tagged type.\n    --  Returns No_List if no freeze nodes needed.\n+   --  The defaulted parameter F_P is used when E is a subprogram, and\n+   --  determines whether the profile of the subprogram should be frozen as\n+   --  well.\n \n    procedure Freeze_All (From : Entity_Id; After : in out Node_Id);\n    --  Before a non-instance body, or at the end of a declarative part,\n@@ -209,8 +215,13 @@ package Freeze is\n    --  in the scope. It is used to prevent a quadratic traversal over already\n    --  frozen entities.\n \n-   procedure Freeze_Before (N : Node_Id; T : Entity_Id);\n+   procedure Freeze_Before\n+     (N   : Node_Id;\n+      T   : Entity_Id;\n+      F_P : Boolean := True);\n    --  Freeze T then Insert the generated Freeze nodes before the node N\n+   --  The flag F_P is used when T is an overloadable entity, and indicates\n+   --  whether its profile should be frozen at the same time.\n \n    procedure Freeze_Expression (N : Node_Id);\n    --  Freezes the required entities when the Expression N causes freezing."}, {"sha": "099a1b84bc3db6cada414a11389f515ca4fb856d", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -10161,18 +10161,20 @@ package body Sem_Attr is\n                   end loop;\n \n                   --  If Prefix is a subprogram name, this reference freezes,\n-                  --  but not if within spec expression mode\n+                  --  but not if within spec expression mode. The profile of\n+                  --  the subprogram is not frozen at this point.\n \n                   if not In_Spec_Expression then\n-                     Freeze_Before (N, Entity (P));\n+                     Freeze_Before (N, Entity (P), False);\n                   end if;\n \n-               --  If it is a type, there is nothing to resolve. If it is an\n-               --  object, complete its resolution.\n+               --  If it is a type, there is nothing to resolve.\n+               --  If it is a subprogram, do not freeze its profile.\n+               --  If it is an object, complete its resolution.\n \n                elsif Is_Overloadable (Entity (P)) then\n                   if not In_Spec_Expression then\n-                     Freeze_Before (N, Entity (P));\n+                     Freeze_Before (N, Entity (P), False);\n                   end if;\n \n                --  Nothing to do if prefix is a type name"}, {"sha": "b9aa2df04a0b0da337224b63374f3a3356baf1cc", "filename": "gcc/ada/sem_aux.adb", "status": "modified", "additions": 24, "deletions": 1, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_aux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_aux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -708,6 +708,29 @@ package body Sem_Aux is\n       return Present (Get_Rep_Item (E, Nam1, Nam2, Check_Parents));\n    end Has_Rep_Item;\n \n+   function Has_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean is\n+      Item : Node_Id;\n+\n+   begin\n+      pragma Assert\n+        (Nkind_In (N, N_Aspect_Specification,\n+                      N_Attribute_Definition_Clause,\n+                      N_Enumeration_Representation_Clause,\n+                      N_Pragma,\n+                      N_Record_Representation_Clause));\n+\n+      Item := First_Rep_Item (E);\n+      while Present (Item) loop\n+         if Item = N then\n+            return True;\n+         end if;\n+\n+         Item := Next_Rep_Item (Item);\n+      end loop;\n+\n+      return False;\n+   end Has_Rep_Item;\n+\n    --------------------\n    -- Has_Rep_Pragma --\n    --------------------"}, {"sha": "97a4f142d0ff8ca63ae9b117116d12f6f949f598", "filename": "gcc/ada/sem_aux.ads", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_aux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_aux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aux.ads?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2015, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -246,6 +246,10 @@ package Sem_Aux is\n    --  not inherited from its parents, if any). If found then True is returned,\n    --  otherwise False indicates that no matching entry was found.\n \n+   function Has_Rep_Item (E : Entity_Id; N : Node_Id) return Boolean;\n+   --  Determine whether the Rep_Item chain of arbitrary entity E contains item\n+   --  N. N must denote a valid rep item.\n+\n    function Has_Rep_Pragma\n      (E             : Entity_Id;\n       Nam           : Name_Id;"}, {"sha": "0fe363546441af4778e347b5762e1d15365cc573", "filename": "gcc/ada/sem_ch13.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_ch13.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_ch13.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch13.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -3926,7 +3926,8 @@ package body Sem_Ch13 is\n                return;\n \n             --  A stream subprogram for an interface type must be a null\n-            --  procedure (RM 13.13.2 (38/3)).\n+            --  procedure (RM 13.13.2 (38/3)). Note that the class-wide type\n+            --  of an interface is not an interface type (3.9.4 (6.b/2)).\n \n             elsif Is_Interface (U_Ent)\n               and then not Is_Class_Wide_Type (U_Ent)"}, {"sha": "a10671144bfb9fce946dee35ba9d4b44981cae7c", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 122, "deletions": 36, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dc87f5f53deaabf19384afd42d5dbcad7591be7/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=6dc87f5f53deaabf19384afd42d5dbcad7591be7", "patch": "@@ -10733,57 +10733,143 @@ package body Sem_Util is\n    ----------------------------\n \n    procedure Inherit_Rep_Item_Chain (Typ : Entity_Id; From_Typ : Entity_Id) is\n-      From_Item : constant Node_Id := First_Rep_Item (From_Typ);\n-      Item      : Node_Id := Empty;\n-      Last_Item : Node_Id := Empty;\n+      Item      : Node_Id;\n+      Next_Item : Node_Id;\n \n    begin\n-      --  Reach the end of the destination type's chain (if any) and capture\n-      --  the last item.\n+      --  There are several inheritance scenarios to consider depending on\n+      --  whether both types have rep item chains and whether the destination\n+      --  type already inherits part of the source type's rep item chain.\n \n-      Item := First_Rep_Item (Typ);\n-      while Present (Item) loop\n+      --  1) The source type lacks a rep item chain\n+      --     From_Typ ---> Empty\n+      --\n+      --     Typ --------> Item (or Empty)\n \n-         --  Do not inherit a chain that has been inherited already\n+      --  In this case inheritance cannot take place because there are no items\n+      --  to inherit.\n \n-         if Item = From_Item then\n-            return;\n-         end if;\n+      --  2) The destination type lacks a rep item chain\n+      --     From_Typ ---> Item ---> ...\n+      --\n+      --     Typ --------> Empty\n \n-         Last_Item := Item;\n-         Item := Next_Rep_Item (Item);\n-      end loop;\n+      --  Inheritance takes place by setting the First_Rep_Item of the\n+      --  destination type to the First_Rep_Item of the source type.\n+      --     From_Typ ---> Item ---> ...\n+      --                    ^\n+      --     Typ -----------+\n \n-      Item := First_Rep_Item (From_Typ);\n+      --  3.1) Both source and destination types have at least one rep item.\n+      --  The destination type does NOT inherit a rep item from the source\n+      --  type.\n+      --     From_Typ ---> Item ---> Item\n+      --\n+      --     Typ --------> Item ---> Item\n \n-      --  Additional check when both parent and current type have rep.\n-      --  items, to prevent circularities when the derivation completes\n-      --  a private declaration and inherits from both views of the parent.\n-      --  There may be a remaining problem with the proper ordering of\n-      --  attribute specifications and aspects on the chains of the four\n-      --  entities involved. ???\n+      --  Inheritance takes place by setting the Next_Rep_Item of the last item\n+      --  of the destination type to the First_Rep_Item of the source type.\n+      --     From_Typ -------------------> Item ---> Item\n+      --                                    ^\n+      --     Typ --------> Item ---> Item --+\n \n-      if Present (Item) and then Present (From_Item) then\n-         while Present (Item) loop\n-            if Item = First_Rep_Item (Typ) then\n-               return;\n-            end if;\n+      --  3.2) Both source and destination types have at least one rep item.\n+      --  The destination type DOES inherit part of the rep item chain of the\n+      --  source type.\n+      --     From_Typ ---> Item ---> Item ---> Item\n+      --                              ^\n+      --     Typ --------> Item ------+\n \n-            Item := Next_Rep_Item (Item);\n-         end loop;\n-      end if;\n+      --  This rare case arises when the full view of a private extension must\n+      --  inherit the rep item chain from the full view of its parent type and\n+      --  the full view of the parent type contains extra rep items. Currently\n+      --  only invariants may lead to such form of inheritance.\n+\n+      --     type From_Typ is tagged private\n+      --       with Type_Invariant'Class => Item_2;\n+\n+      --     type Typ is new From_Typ with private\n+      --       with Type_Invariant => Item_4;\n+\n+      --  At this point the rep item chains contain the following items\n+\n+      --     From_Typ -----------> Item_2 ---> Item_3\n+      --                            ^\n+      --     Typ --------> Item_4 --+\n+\n+      --  The full views of both types may introduce extra invariants\n+\n+      --     type From_Typ is tagged null record\n+      --       with Type_Invariant => Item_1;\n+\n+      --     type Typ is new From_Typ with null record;\n \n-      --  When the destination type has a rep item chain, the chain of the\n-      --  source type is appended to it.\n+      --  The full view of Typ would have to inherit any new rep items added to\n+      --  the full view of From_Typ.\n \n-      if Present (Last_Item) then\n-         Set_Next_Rep_Item (Last_Item, From_Item);\n+      --     From_Typ -----------> Item_1 ---> Item_2 ---> Item_3\n+      --                            ^\n+      --     Typ --------> Item_4 --+\n \n-      --  Otherwise the destination type directly inherits the rep item chain\n-      --  of the source type (if any).\n+      --  To achieve this form of inheritance, the destination type must first\n+      --  sever the link between its own rep chain and that of the source type,\n+      --  then inheritance 3.1 takes place.\n+\n+      --  Case 1: The source type lacks a rep item chain\n+\n+      if No (First_Rep_Item (From_Typ)) then\n+         return;\n+\n+      --  Case 2: The destination type lacks a rep item chain\n+\n+      elsif No (First_Rep_Item (Typ)) then\n+         Set_First_Rep_Item (Typ, First_Rep_Item (From_Typ));\n+\n+      --  Case 3: Both the source and destination types have at least one rep\n+      --  item. Traverse the rep item chain of the destination type to find the\n+      --  last rep item.\n \n       else\n-         Set_First_Rep_Item (Typ, From_Item);\n+         Item      := Empty;\n+         Next_Item := First_Rep_Item (Typ);\n+         while Present (Next_Item) loop\n+\n+            --  Detect a link between the destination type's rep chain and that\n+            --  of the source type. There are two possibilities:\n+\n+            --    Variant 1\n+            --                  Next_Item\n+            --                      V\n+            --       From_Typ ---> Item_1 --->\n+            --                      ^\n+            --       Typ -----------+\n+            --\n+            --       Item is Empty\n+\n+            --    Variant 2\n+            --                              Next_Item\n+            --                                  V\n+            --       From_Typ ---> Item_1 ---> Item_2 --->\n+            --                                  ^\n+            --       Typ --------> Item_3 ------+\n+            --                      ^\n+            --                     Item\n+\n+            if Has_Rep_Item (From_Typ, Next_Item) then\n+               exit;\n+            end if;\n+\n+            Item      := Next_Item;\n+            Next_Item := Next_Rep_Item (Next_Item);\n+         end loop;\n+\n+         --  Inherit the source type's rep item chain\n+\n+         if Present (Item) then\n+            Set_Next_Rep_Item (Item, First_Rep_Item (From_Typ));\n+         else\n+            Set_First_Rep_Item (Typ, First_Rep_Item (From_Typ));\n+         end if;\n       end if;\n    end Inherit_Rep_Item_Chain;\n "}]}