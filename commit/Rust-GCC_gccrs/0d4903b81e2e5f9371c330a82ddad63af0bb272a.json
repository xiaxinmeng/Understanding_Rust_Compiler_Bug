{"sha": "0d4903b81e2e5f9371c330a82ddad63af0bb272a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGQ0OTAzYjgxZTJlNWY5MzcxYzMzMGE4MmRkYWQ2M2FmMGJiMjcyYQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-10-18T21:34:14Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-10-18T21:34:14Z"}, "message": "emit-rtl.c (gen_reg_rtx): Also reallocate reg_decl array.\n\n\t* emit-rtl.c (gen_reg_rtx): Also reallocate reg_decl array.\n\t(offset_address): New function.\n\t(free_emit_status): Free regno_decl.\n\t(init_emit): Pass proper number of elements to xcalloc.\n\tAllocate regno_decl.\n\t(mark_emit_status): Mark regno_decl values.\n\t* expr.c (highest_pow2_factor): New function.\n\t(expand_assigment): Use it and offset_address.\n\tProperly handle ptr_mode vs. Pmode in offset calculation.\n\t(store_constructor, expand_expr_unaligned): Likewise.\n\t(expand_expr, case COMPONENT_EXPR): Likewise.\n\t* expr.h (offset_address): New decl.\n\t* function.h (struct emit_status): Add regno_decl.\n\t(REGNO_DECL): New macro.\n\t* final.c (output_asm_name): Move in file and don't conditionalize\n\ton flag_print_asm_name.\n\t(output_asm_insn): Only call output_asm_name if flag_print_asm_name.\n\tOutput names of operands, if known.\n\t* function.c (assign_parms): Set REGNO_DECL.\n\t* integrate.c (integrate_decl_tree): Likewise.\n\t* stmt.c (expand_decl): Likewise.\n\t* regclass.c (reg_scan_mark_refs): Propagate REGNO_DECL for copies.\n\nFrom-SVN: r46337", "tree": {"sha": "8efd4ef27021837ed8a888f7f93fac0cede0d926", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8efd4ef27021837ed8a888f7f93fac0cede0d926"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0d4903b81e2e5f9371c330a82ddad63af0bb272a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4903b81e2e5f9371c330a82ddad63af0bb272a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0d4903b81e2e5f9371c330a82ddad63af0bb272a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0d4903b81e2e5f9371c330a82ddad63af0bb272a/comments", "author": null, "committer": null, "parents": [{"sha": "eacecf96651d07155d20c784f4ab8862b57b3a50", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eacecf96651d07155d20c784f4ab8862b57b3a50", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eacecf96651d07155d20c784f4ab8862b57b3a50"}], "stats": {"total": 367, "additions": 282, "deletions": 85}, "files": [{"sha": "dd5331c63c80d323f3272f4b8891ad4f921a54d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -1,3 +1,28 @@\n+Thu Oct 18 16:07:39 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n+\n+\t* emit-rtl.c (gen_reg_rtx): Also reallocate reg_decl array.\n+\t(offset_address): New function.\n+\t(free_emit_status): Free regno_decl.\n+\t(init_emit): Pass proper number of elements to xcalloc.\n+\tAllocate regno_decl.\n+\t(mark_emit_status): Mark regno_decl values.\n+\t* expr.c (highest_pow2_factor): New function.\n+\t(expand_assigment): Use it and offset_address.\n+\tProperly handle ptr_mode vs. Pmode in offset calculation.\n+\t(store_constructor, expand_expr_unaligned): Likewise.\n+\t(expand_expr, case COMPONENT_EXPR): Likewise.\n+\t* expr.h (offset_address): New decl.\n+\t* function.h (struct emit_status): Add regno_decl.\n+\t(REGNO_DECL): New macro.\n+\t* final.c (output_asm_name): Move in file and don't conditionalize\n+\ton flag_print_asm_name.\n+\t(output_asm_insn): Only call output_asm_name if flag_print_asm_name.\n+\tOutput names of operands, if known.\n+\t* function.c (assign_parms): Set REGNO_DECL.\n+\t* integrate.c (integrate_decl_tree): Likewise.\n+\t* stmt.c (expand_decl): Likewise.\n+\t* regclass.c (reg_scan_mark_refs): Propagate REGNO_DECL for copies.\n+\t\n 2001-10-18  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* attribs.c (handle_noinline_attribute): New function."}, {"sha": "c7c61401b5e2f620f6efe65c4a6c0faba54b0bf5", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 49, "deletions": 8, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -659,14 +659,16 @@ gen_reg_rtx (mode)\n       return gen_rtx_CONCAT (mode, realpart, imagpart);\n     }\n \n-  /* Make sure regno_pointer_align and regno_reg_rtx are large enough\n-     to have an element for this pseudo reg number.  */\n+  /* Make sure regno_pointer_align, regno_decl, and regno_reg_rtx are large\n+     enough to have an element for this pseudo reg number.  */\n \n   if (reg_rtx_no == f->emit->regno_pointer_align_length)\n     {\n       int old_size = f->emit->regno_pointer_align_length;\n-      rtx *new1;\n       char *new;\n+      rtx *new1;\n+      tree *new2;\n+\n       new = xrealloc (f->emit->regno_pointer_align, old_size * 2);\n       memset (new + old_size, 0, old_size);\n       f->emit->regno_pointer_align = (unsigned char *) new;\n@@ -676,6 +678,11 @@ gen_reg_rtx (mode)\n       memset (new1 + old_size, 0, old_size * sizeof (rtx));\n       regno_reg_rtx = new1;\n \n+      new2 = (tree *) xrealloc (f->emit->regno_decl,\n+\t\t\t\told_size * 2 * sizeof (tree));\n+      memset (new2 + old_size, 0, old_size * sizeof (tree));\n+      f->emit->regno_decl = new2;\n+\n       f->emit->regno_pointer_align_length = old_size * 2;\n     }\n \n@@ -1872,6 +1879,32 @@ adjust_address_1 (memref, mode, offset, validate)\n   return new;\n }\n \n+/* Return a memory reference like MEMREF, but with its address changed to\n+   ADDR.  The caller is asserting that the actual piece of memory pointed\n+   to is the same, just the form of the address is being changed, such as\n+   by putting something into a register.  */\n+\n+rtx\n+offset_address (memref, offset, pow2)\n+     rtx memref;\n+     rtx offset;\n+     HOST_WIDE_INT pow2;\n+{\n+  rtx new = change_address_1 (memref, VOIDmode,\n+\t\t\t      gen_rtx_PLUS (Pmode, XEXP (memref, 0),\n+\t\t\t\t\t    force_reg (Pmode, offset)), 1);\n+  unsigned int memalign = MEM_ALIGN (memref);\n+\n+  /* Update the alignment to reflect the offset.  Reset the offset, which\n+     we don't know.  */\n+  while (pow2 % memalign != 0)\n+    memalign >>= 1;\n+\n+  MEM_ATTRS (new) = get_mem_attrs (MEM_ALIAS_SET (memref), MEM_DECL (memref),\n+\t\t\t\t   0, 0, memalign);\n+  return new;\n+}\n+  \n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n@@ -1978,6 +2011,7 @@ free_emit_status (f)\n {\n   free (f->emit->x_regno_reg_rtx);\n   free (f->emit->regno_pointer_align);\n+  free (f->emit->regno_decl);\n   free (f->emit);\n   f->emit = NULL;\n }\n@@ -4402,8 +4436,10 @@ init_emit ()\n \t\t\t\t sizeof (unsigned char));\n \n   regno_reg_rtx\n-    = (rtx *) xcalloc (f->emit->regno_pointer_align_length * sizeof (rtx),\n-\t\t       sizeof (rtx));\n+    = (rtx *) xcalloc (f->emit->regno_pointer_align_length, sizeof (rtx));\n+\n+  f->emit->regno_decl\n+    = (tree *) xcalloc (f->emit->regno_pointer_align_length, sizeof (tree));\n \n   /* Put copies of all the virtual register rtx into regno_reg_rtx.  */\n   init_virtual_regs (f->emit);\n@@ -4460,14 +4496,19 @@ mark_emit_status (es)\n      struct emit_status *es;\n {\n   rtx *r;\n+  tree *t;\n   int i;\n \n   if (es == 0)\n     return;\n \n-  for (i = es->regno_pointer_align_length, r = es->x_regno_reg_rtx;\n-       i > 0; --i, ++r)\n-    ggc_mark_rtx (*r);\n+  for (i = es->regno_pointer_align_length, r = es->x_regno_reg_rtx,\n+       t = es->regno_decl;\n+       i > 0; --i, ++r, ++t)\n+    {\n+      ggc_mark_rtx (*r);\n+      ggc_mark_tree (*t);\n+    }\n \n   mark_sequence_stack (es->sequence_stack);\n   ggc_mark_tree (es->sequence_rtl_expr);"}, {"sha": "f486b32e4fdc4b86b2aaa299b7b3add0ed7ad610", "filename": "gcc/expr.c", "status": "modified", "additions": 85, "deletions": 41, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -164,6 +164,7 @@ static rtx store_field\t\tPARAMS ((rtx, HOST_WIDE_INT,\n static enum memory_use_mode\n   get_memory_usage_from_modifier PARAMS ((enum expand_modifier));\n static rtx var_rtx\t\tPARAMS ((tree));\n+static HOST_WIDE_INT highest_pow2_factor PARAMS ((tree));\n static rtx expand_expr_unaligned PARAMS ((tree, unsigned int *));\n static rtx expand_increment\tPARAMS ((tree, int, int));\n static void do_jump_by_parts_greater PARAMS ((tree, int, rtx, rtx));\n@@ -3760,10 +3761,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n \t      bitpos = 0;\n \t    }\n \n-\t  to_rtx = change_address (to_rtx, VOIDmode,\n-\t\t\t\t   gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n-\t\t\t\t\t\t force_reg (ptr_mode,\n-\t\t\t\t\t\t\t    offset_rtx)));\n+\t  to_rtx = offset_address (to_rtx, offset_rtx,\n+\t\t\t\t   highest_pow2_factor (offset));\n \t}\n \n       if (volatilep)\n@@ -3900,8 +3899,8 @@ expand_assignment (to, from, want_value, suggest_reg)\n       else\n \t{\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t  if (TREE_CODE (TREE_TYPE (to)) == REFERENCE_TYPE\n-\t     || TREE_CODE (TREE_TYPE (to)) == POINTER_TYPE)\n+\t  if (POINTER_TYPE_P (TREE_TYPE (to))\n+\t      && GET_MODE (to_rtx) != GET_MODE (value))\n \t    value = convert_memory_address (GET_MODE (to_rtx), value);\n #endif\n \t  emit_move_insn (to_rtx, value);\n@@ -4648,19 +4647,15 @@ store_constructor (exp, target, align, cleared, size)\n \t\tabort ();\n \n \t      if (GET_MODE (offset_rtx) != ptr_mode)\n-\t\t{\n+\t\toffset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n-                  offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n-#else\n-                  offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\t      offset_rtx = convert_memory_address (Pmode, offset_rtx);\n #endif\n-                }\n \n-\t      to_rtx\n-\t\t= change_address (to_rtx, VOIDmode,\n-\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (to_rtx, 0),\n-\t\t\t\t\t\tforce_reg (ptr_mode,\n-\t\t\t\t\t\t\t   offset_rtx)));\n+\t      to_rtx = offset_address (to_rtx, offset_rtx,\n+\t\t\t\t       highest_pow2_factor (offset));\n+\n \t      align = DECL_OFFSET_ALIGN (field);\n \t    }\n \n@@ -4820,7 +4815,7 @@ store_constructor (exp, target, align, cleared, size)\n \t    {\n \t      tree lo_index = TREE_OPERAND (index, 0);\n \t      tree hi_index = TREE_OPERAND (index, 1);\n-\t      rtx index_r, pos_rtx, addr, hi_r, loop_top, loop_end;\n+\t      rtx index_r, pos_rtx, hi_r, loop_top, loop_end;\n \t      struct nesting *loop;\n \t      HOST_WIDE_INT lo, hi, count;\n \t      tree position;\n@@ -4884,8 +4879,9 @@ store_constructor (exp, target, align, cleared, size)\n \t\t\t\t\t\t  TYPE_SIZE_UNIT (elttype)));\n \n \t\t  pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n-\t\t  addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n-\t\t  xtarget = change_address (target, mode, addr);\n+\t\t  xtarget = offset_address (target, pos_rtx,\n+\t\t\t\t\t    highest_pow2_factor (position));\n+\t\t  xtarget = adjust_address (xtarget, mode, 0);\n \t\t  if (TREE_CODE (value) == CONSTRUCTOR)\n \t\t    store_constructor (value, xtarget, align, cleared,\n \t\t\t\t       bitsize / BITS_PER_UNIT);\n@@ -4906,7 +4902,6 @@ store_constructor (exp, target, align, cleared, size)\n \t  else if ((index != 0 && ! host_integerp (index, 0))\n \t\t   || ! host_integerp (TYPE_SIZE (elttype), 1))\n \t    {\n-\t      rtx pos_rtx, addr;\n \t      tree position;\n \n \t      if (index == 0)\n@@ -4920,9 +4915,10 @@ store_constructor (exp, target, align, cleared, size)\n \t      position = size_binop (MULT_EXPR, index,\n \t\t\t\t     convert (ssizetype,\n \t\t\t\t\t      TYPE_SIZE_UNIT (elttype)));\n-\t      pos_rtx = expand_expr (position, 0, VOIDmode, 0);\n-\t      addr = gen_rtx_PLUS (Pmode, XEXP (target, 0), pos_rtx);\n-\t      xtarget = change_address (target, mode, addr);\n+\t      xtarget = offset_address (target,\n+\t\t\t\t\texpand_expr (position, 0, VOIDmode, 0),\n+\t\t\t\t\thighest_pow2_factor (position));\n+\t      xtarget = adjust_address (xtarget, mode, 0);\n \t      store_expr (value, xtarget, 0);\n \t    }\n \t  else\n@@ -5965,6 +5961,62 @@ check_max_integer_computation_mode (exp)\n }\n #endif\n \f\n+/* Return the highest power of two that EXP is known to be a multiple of.\n+   This is used in updating alignment of MEMs in array references.  */\n+\n+static HOST_WIDE_INT\n+highest_pow2_factor (exp)\n+     tree exp;\n+{\n+  HOST_WIDE_INT c0, c1;\n+\n+  switch (TREE_CODE (exp))\n+    {\n+    case INTEGER_CST:\n+      /* If the integer is expressable in a HOST_WIDE_INT, we can find\n+\t the lowest bit that's a one.  If the result is zero or negative,\n+\t pessimize by returning 1.  This is overly-conservative, but such\n+\t things should not happen in the offset expressions that we are\n+\t called with.  */\n+      if (host_integerp (exp, 0))\n+\t{\n+\t  c0 = tree_low_cst (exp, 0);\n+\t  return c0 >= 0 ? c0 & -c0 : 1;\n+\t}\n+      break;\n+\n+    case PLUS_EXPR:  case MINUS_EXPR:\n+      c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n+      c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n+      return MIN (c0, c1);\n+\n+    case MULT_EXPR:\n+      c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n+      c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n+      return c0 * c1;\n+\n+    case ROUND_DIV_EXPR:  case TRUNC_DIV_EXPR:  case FLOOR_DIV_EXPR:\n+    case CEIL_DIV_EXPR:\n+      c0 = highest_pow2_factor (TREE_OPERAND (exp, 0));\n+      c1 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n+      return c0 / c1;\n+\n+    case NON_LVALUE_EXPR:  case NOP_EXPR:  case CONVERT_EXPR:\n+    case COMPOUND_EXPR:  case SAVE_EXPR:\n+      return highest_pow2_factor (TREE_OPERAND (exp, 0));\n+\n+    case COND_EXPR:\n+      c0 = highest_pow2_factor (TREE_OPERAND (exp, 1));\n+      c1 = highest_pow2_factor (TREE_OPERAND (exp, 2));\n+      return MIN (c0, c1);\n+\n+    default:\n+      break;\n+    }\n+\n+  return 1;\n+}\n+\f\n /* Return an object on the placeholder list that matches EXP, a\n    PLACEHOLDER_EXPR.  An object \"matches\" if it is of the type of the\n    PLACEHOLDER_EXPR or a pointer type to it.  For further information, see\n@@ -7018,13 +7070,11 @@ expand_expr (exp, target, tmode, modifier)\n \t      abort ();\n \n \t    if (GET_MODE (offset_rtx) != ptr_mode)\n-\t      {\n+\t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t\toffset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n-#else\n-\t\toffset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\t    offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n #endif\n-\t      }\n \n \t    /* A constant address in OP0 can have VOIDmode, we must not try\n \t       to call force_reg for that case.  Avoid that case.  */\n@@ -7048,10 +7098,8 @@ expand_expr (exp, target, tmode, modifier)\n \t\tbitpos = 0;\n \t      }\n \n-\t    op0 = change_address (op0, VOIDmode,\n-\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n-\t\t\t\t\t\tforce_reg (ptr_mode,\n-\t\t\t\t\t\t\t   offset_rtx)));\n+\t    op0 = offset_address (op0, offset_rtx,\n+\t\t\t\t  highest_pow2_factor (offset));\n \t  }\n \n \t/* Don't forget about volatility even if this is a bitfield.  */\n@@ -9036,18 +9084,14 @@ expand_expr_unaligned (exp, palign)\n \t      abort ();\n \n \t    if (GET_MODE (offset_rtx) != ptr_mode)\n-\t      {\n+\t      offset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\n #ifdef POINTERS_EXTEND_UNSIGNED\n-\t\toffset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n-#else\n-\t\toffset_rtx = convert_to_mode (ptr_mode, offset_rtx, 0);\n+\t    offset_rtx = convert_memory_address (ptr_mode, offset_rtx);\n #endif\n-\t      }\n \n-\t    op0 = change_address (op0, VOIDmode,\n-\t\t\t\t  gen_rtx_PLUS (ptr_mode, XEXP (op0, 0),\n-\t\t\t\t\t\tforce_reg (ptr_mode,\n-\t\t\t\t\t\t\t   offset_rtx)));\n+\t    op0 = offset_address (op0, offset_rtx,\n+\t\t\t\t  highest_pow2_factor (offset));\n \t  }\n \n \t/* Don't forget about volatility even if this is a bitfield.  */"}, {"sha": "ad24cb7ae7469796bcad605169b258f365a6a898", "filename": "gcc/expr.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -633,6 +633,11 @@ extern rtx change_address PARAMS ((rtx, enum machine_mode, rtx));\n extern rtx adjust_address_1 PARAMS ((rtx, enum machine_mode, HOST_WIDE_INT,\n \t\t\t\t     int));\n \n+/* Return a memory reference like MEMREF, but whose address is changed by\n+   adding OFFSET, an RTX, to it.  POW2 is the highest power of two factor\n+   known to be in OFFSET (possibly 1).  */\n+extern rtx offset_address PARAMS ((rtx, rtx, HOST_WIDE_INT));\n+\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as"}, {"sha": "38ec17302f57b2a8395a0e463e0d36f8fb24e01a", "filename": "gcc/final.c", "status": "modified", "additions": 59, "deletions": 29, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -3264,6 +3264,30 @@ output_operand_lossage (msgid)\n \f\n /* Output of assembler code from a template, and its subroutines.  */\n \n+/* Annotate the assembly with a comment describing the pattern and\n+   alternative used.  */\n+\n+static void\n+output_asm_name ()\n+{\n+  if (debug_insn)\n+    {\n+      int num = INSN_CODE (debug_insn);\n+      fprintf (asm_out_file, \"\\t%s %d\\t%s\",\n+\t       ASM_COMMENT_START, INSN_UID (debug_insn),\n+\t       insn_data[num].name);\n+      if (insn_data[num].n_alternatives > 1)\n+\tfprintf (asm_out_file, \"/%d\", which_alternative + 1);\n+#ifdef HAVE_ATTR_length\n+      fprintf (asm_out_file, \"\\t[length = %d]\",\n+\t       get_attr_length (debug_insn));\n+#endif\n+      /* Clear this so only the first assembler insn\n+\t of any rtl insn will get the special comment for -dp.  */\n+      debug_insn = 0;\n+    }\n+}\n+\n /* Output text from TEMPLATE to the assembler output file,\n    obeying %-directions to substitute operands taken from\n    the vector OPERANDS.\n@@ -3280,32 +3304,6 @@ output_operand_lossage (msgid)\n       and print a constant expression for minus the value\n       of the operand, with no other punctuation.  */\n \n-static void\n-output_asm_name ()\n-{\n-  if (flag_print_asm_name)\n-    {\n-      /* Annotate the assembly with a comment describing the pattern and\n-\t alternative used.  */\n-      if (debug_insn)\n-\t{\n-\t  int num = INSN_CODE (debug_insn);\n-\t  fprintf (asm_out_file, \"\\t%s %d\\t%s\",\n-\t\t   ASM_COMMENT_START, INSN_UID (debug_insn),\n-\t\t   insn_data[num].name);\n-\t  if (insn_data[num].n_alternatives > 1)\n-\t    fprintf (asm_out_file, \"/%d\", which_alternative + 1);\n-#ifdef HAVE_ATTR_length\n-\t  fprintf (asm_out_file, \"\\t[length = %d]\",\n-\t\t   get_attr_length (debug_insn));\n-#endif\n-\t  /* Clear this so only the first assembler insn\n-\t     of any rtl insn will get the special comment for -dp.  */\n-\t  debug_insn = 0;\n-\t}\n-    }\n-}\n-\n void\n output_asm_insn (template, operands)\n      const char *template;\n@@ -3316,6 +3314,8 @@ output_asm_insn (template, operands)\n #ifdef ASSEMBLER_DIALECT\n   int dialect = 0;\n #endif\n+  int oporder[MAX_RECOG_OPERANDS];\n+  int ops = 0;\n \n   /* An insn may return a null string template\n      in a case where no assembler code is needed.  */\n@@ -3333,7 +3333,9 @@ output_asm_insn (template, operands)\n     switch (c)\n       {\n       case '\\n':\n-\toutput_asm_name ();\n+\tif (flag_print_asm_name)\n+\t  output_asm_name ();\n+\n \tputc (c, asm_out_file);\n #ifdef ASM_OUTPUT_OPCODE\n \twhile ((c = *p) == '\\t')\n@@ -3425,7 +3427,8 @@ output_asm_insn (template, operands)\n \n \t    if (! (*p >= '0' && *p <= '9'))\n \t      output_operand_lossage (\"operand number missing after %-letter\");\n-\t    else if (this_is_asm_operands && (c < 0 || (unsigned int) c >= insn_noperands))\n+\t    else if (this_is_asm_operands\n+\t\t     && (c < 0 || (unsigned int) c >= insn_noperands))\n \t      output_operand_lossage (\"operand number out of range\");\n \t    else if (letter == 'l')\n \t      output_asm_label (operands[c]);\n@@ -3452,6 +3455,8 @@ output_asm_insn (template, operands)\n \t    else\n \t      output_operand (operands[c], letter);\n \n+\t    oporder[ops++] = c;\n+\n \t    while ((c = *p) >= '0' && c <= '9')\n \t      p++;\n \t  }\n@@ -3464,6 +3469,8 @@ output_asm_insn (template, operands)\n \t      output_operand_lossage (\"operand number out of range\");\n \t    else\n \t      output_operand (operands[c], 0);\n+\n+\t    oporder[ops++] = c;\n \t    while ((c = *p) >= '0' && c <= '9')\n \t      p++;\n \t  }\n@@ -3482,7 +3489,30 @@ output_asm_insn (template, operands)\n \tputc (c, asm_out_file);\n       }\n \n-  output_asm_name ();\n+  /* Write out the variable names for operands, if we know them.  */\n+  if (flag_verbose_asm)\n+    {\n+      int wrote = 0;\n+      int i;\n+\n+      for (i = 0; i < ops; i++)\n+\t{\n+\t  rtx op = operands[oporder[i]];\n+\t  tree decl = (GET_CODE (op) == REG ? REGNO_DECL (ORIGINAL_REGNO (op))\n+\t\t       : GET_CODE (op) == MEM ? MEM_DECL (op)\n+\t\t       : 0);\n+\n+\t  if (decl && DECL_NAME (decl))\n+\t    {\n+\t      fprintf (asm_out_file, \"%s %s\", wrote ? \",\" : ASM_COMMENT_START,\n+\t\t       IDENTIFIER_POINTER (DECL_NAME (decl)));\n+\t      wrote = 1;\n+\t    }\n+\t}\n+    }\n+\n+  if (flag_print_asm_name)\n+    output_asm_name ();\n \n   putc ('\\n', asm_out_file);\n }"}, {"sha": "51beeef08cb9b5381caaf0ee2820887e6d777a2d", "filename": "gcc/function.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -5022,6 +5022,15 @@ assign_parms (fndecl)\n \t  set_mem_attributes (x, result, 1);\n \t  SET_DECL_RTL (result, x);\n \t}\n+\n+      if (GET_CODE (DECL_RTL (parm)) == REG)\n+\tREGNO_DECL (REGNO (DECL_RTL (parm))) = parm;\n+      else if (GET_CODE (DECL_RTL (parm)) == CONCAT)\n+\t{\n+\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (parm), 0))) = parm;\n+\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (parm), 1))) = parm;\n+\t}\n+\n     }\n \n   /* Output all parameter conversion instructions (possibly including calls)"}, {"sha": "cc01d164975ccd425bb7ba3ef133417c704bf183", "filename": "gcc/function.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -97,17 +97,21 @@ struct emit_status\n   int x_last_linenum;\n   const char *x_last_filename;\n \n-  /* The length of the regno_pointer_align and x_regno_reg_rtx vectors.\n-     Since these vectors are needed during the expansion phase when\n-     the total number of registers in the function is not yet known,\n-     the vectors are copied and made bigger when necessary.  */\n+  /* The length of the regno_pointer_align, regno_decl, and x_regno_reg_rtx\n+     vectors.  Since these vectors are needed during the expansion phase when\n+     the total number of registers in the function is not yet known, the\n+     vectors are copied and made bigger when necessary.  */\n   int regno_pointer_align_length;\n \n   /* Indexed by pseudo register number, if nonzero gives the known alignment\n      for that pseudo (if REG_POINTER is set in x_regno_reg_rtx).\n      Allocated in parallel with x_regno_reg_rtx.  */\n   unsigned char *regno_pointer_align;\n \n+  /* Indexed by pseudo register number, if nonzero gives the decl\n+     corresponding to that register.  */\n+  tree *regno_decl;\n+\n   /* Indexed by pseudo register number, gives the rtx for that pseudo.\n      Allocated in parallel with regno_pointer_align.  */\n   rtx *x_regno_reg_rtx;\n@@ -120,6 +124,7 @@ struct emit_status\n #define seq_stack (cfun->emit->sequence_stack)\n \n #define REGNO_POINTER_ALIGN(REGNO) (cfun->emit->regno_pointer_align[REGNO])\n+#define REGNO_DECL(REGNO) (cfun->emit->regno_decl[REGNO])\n \n struct expr_status\n {"}, {"sha": "392ac5923e9c9e5e4b7cf71734797bd498efbd72", "filename": "gcc/integrate.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -1779,6 +1779,15 @@ integrate_decl_tree (let, map)\n \t  r = DECL_RTL (d);\n \t  subst_constants (&r, NULL_RTX, map, 1);\n \t  SET_DECL_RTL (d, r);\n+\n+\t  if (GET_CODE (r) == REG)\n+\t    REGNO_DECL (REGNO (r)) = d;\n+\t  else if (GET_CODE (r) == CONCAT)\n+\t    {\n+\t      REGNO_DECL (REGNO (XEXP (r, 0))) = d;\n+\t      REGNO_DECL (REGNO (XEPX (r, 1))) = d;\n+\t    }\n+\n \t  apply_change_group ();\n \t}\n "}, {"sha": "826da242dc188c3672d1ebdde74c08a5216d308f", "filename": "gcc/regclass.c", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fregclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fregclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregclass.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -2496,6 +2496,24 @@ reg_scan_mark_refs (x, insn, note_flag, min_regno)\n \t\t      || GET_CODE (XEXP (note, 0)) == LABEL_REF))))\n \tREG_POINTER (SET_DEST (x)) = 1;\n \n+      /* If this is setting a register from a register or from a simple\n+\t conversion of a register, propagate REG_DECL.  */\n+      if (GET_CODE (dest) == REG)\n+\t{\n+\t  rtx src = SET_SRC (x);\n+\n+\t  while (GET_CODE (src) == SIGN_EXTEND\n+\t\t || GET_CODE (src) == ZERO_EXTEND\n+\t\t || GET_CODE (src) == TRUNCATE\n+\t\t || (GET_CODE (src) == SUBREG && subreg_lowpart_p (src)))\n+\t    src = XEXP (src, 0);\n+\n+\t  if (GET_CODE (src) == REG && REGNO_DECL (REGNO (src)) == 0)\n+\t    REGNO_DECL (REGNO (src)) = REGNO_DECL (REGNO (dest));\n+\t  else if (GET_CODE (src) == REG && REGNO_DECL (REGNO (dest)) == 0)\n+\t    REGNO_DECL (REGNO (dest)) = REGNO_DECL (REGNO (src));\n+\t}\n+\n       /* ... fall through ...  */\n \n     default:"}, {"sha": "1d84eea4637c8d4d5138b95e65a6a422011ffc10", "filename": "gcc/stmt.c", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0d4903b81e2e5f9371c330a82ddad63af0bb272a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=0d4903b81e2e5f9371c330a82ddad63af0bb272a", "patch": "@@ -3999,6 +3999,15 @@ expand_decl (decl)\n \t= promote_mode (type, DECL_MODE (decl), &unsignedp, 0);\n \n       SET_DECL_RTL (decl, gen_reg_rtx (reg_mode));\n+\n+      if (GET_CODE (DECL_RTL (decl)) == REG)\n+\tREGNO_DECL (REGNO (DECL_RTL (decl))) = decl;\n+      else if (GET_CODE (DECL_RTL (decl)) == CONCAT)\n+\t{\n+\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (decl), 0))) = decl;\n+\t  REGNO_DECL (REGNO (XEXP (DECL_RTL (decl), 1))) = decl;\n+\t}\n+\n       mark_user_reg (DECL_RTL (decl));\n \n       if (POINTER_TYPE_P (type))\n@@ -4020,6 +4029,7 @@ expand_decl (decl)\n       /* Variable of fixed size that goes on the stack.  */\n       rtx oldaddr = 0;\n       rtx addr;\n+      rtx x;\n \n       /* If we previously made RTL for this decl, it must be an array\n \t whose size was determined by the initializer.\n@@ -4033,14 +4043,15 @@ expand_decl (decl)\n \t  oldaddr = XEXP (DECL_RTL (decl), 0);\n \t}\n \n-      SET_DECL_RTL (decl,\n-\t\t    assign_temp (TREE_TYPE (decl), 1, 1, 1));\n-\n       /* Set alignment we actually gave this decl.  */\n       DECL_ALIGN (decl) = (DECL_MODE (decl) == BLKmode ? BIGGEST_ALIGNMENT\n \t\t\t   : GET_MODE_BITSIZE (DECL_MODE (decl)));\n       DECL_USER_ALIGN (decl) = 0;\n \n+      x = assign_temp (TREE_TYPE (decl), 1, 1, 1);\n+      set_mem_attributes (x, decl, 1);\n+      SET_DECL_RTL (decl, x);\n+\n       if (oldaddr)\n \t{\n \t  addr = force_operand (XEXP (DECL_RTL (decl), 0), oldaddr);"}]}