{"sha": "62afb87d9c466ab33767fad6d74133a4ad925f52", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjJhZmI4N2Q5YzQ2NmFiMzM3NjdmYWQ2ZDc0MTMzYTRhZDkyNWY1Mg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-15T22:47:43Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2016-12-15T22:47:43Z"}, "message": "re PR go/78763 (go1: internal compiler error: in do_get_backend, at go/gofrontend/expressions.cc:8352)\n\n\tPR go/78763\n    compiler: call determine_types even for constant expressions\n    \n    We need to call determine_types even for constant expressions, since a\n    constant expression may include code like unsafe.Sizeof(0).  Something\n    needs to determine the type of the untyped 0, and that should be the\n    determine_types pass.\n    \n    Implementing that triggered a compiler crash on test/const1.go because\n    it permitted some erroneous constants to make it all the way to the\n    backend.  Catch that case by checking whether we get a constant\n    overflow error, and marking the expression invalid if we do.  This is\n    a good change in any case, as previously we reported the same constant\n    overflow error multiple times, and now we only report it once.\n    \n    Fixes GCC PR 78763.\n    \n    Reviewed-on: https://go-review.googlesource.com/34496\n\nFrom-SVN: r243729", "tree": {"sha": "59845f6dec919b79bac4beebf830fee954ad3678", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59845f6dec919b79bac4beebf830fee954ad3678"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/62afb87d9c466ab33767fad6d74133a4ad925f52", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62afb87d9c466ab33767fad6d74133a4ad925f52", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62afb87d9c466ab33767fad6d74133a4ad925f52", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62afb87d9c466ab33767fad6d74133a4ad925f52/comments", "author": null, "committer": null, "parents": [{"sha": "7cdb6e4c68a6dacee2308e6e9a8533a0104471d7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdb6e4c68a6dacee2308e6e9a8533a0104471d7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cdb6e4c68a6dacee2308e6e9a8533a0104471d7"}], "stats": {"total": 70, "additions": 50, "deletions": 20}, "files": [{"sha": "4a5f6d295ddb5545c103d02dcf32af3fb7dd9b4b", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=62afb87d9c466ab33767fad6d74133a4ad925f52", "patch": "@@ -1,4 +1,4 @@\n-5eb55901861f360c2c2ff70f14a8315694934c97\n+e807c1deec1e7114bc4757b6193510fdae13e75f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "2022c4749b3ebcf8c2b275ce15c52100e305366a", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 44, "deletions": 15, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=62afb87d9c466ab33767fad6d74133a4ad925f52", "patch": "@@ -3738,8 +3738,12 @@ Unary_expression::do_lower(Gogo*, Named_object*, Statement_inserter*, int)\n       if (expr->numeric_constant_value(&nc))\n \t{\n \t  Numeric_constant result;\n-\t  if (Unary_expression::eval_constant(op, &nc, loc, &result))\n+\t  bool issued_error;\n+\t  if (Unary_expression::eval_constant(op, &nc, loc, &result,\n+\t\t\t\t\t      &issued_error))\n \t    return result.expression(loc);\n+\t  else if (issued_error)\n+\t    return Expression::make_error(this->location());\n \t}\n     }\n \n@@ -3900,12 +3904,15 @@ Unary_expression::do_is_static_initializer() const\n }\n \n // Apply unary opcode OP to UNC, setting NC.  Return true if this\n-// could be done, false if not.  Issue errors for overflow.\n+// could be done, false if not.  On overflow, issues an error and sets\n+// *ISSUED_ERROR.\n \n bool\n Unary_expression::eval_constant(Operator op, const Numeric_constant* unc,\n-\t\t\t\tLocation location, Numeric_constant* nc)\n+\t\t\t\tLocation location, Numeric_constant* nc,\n+\t\t\t\tbool* issued_error)\n {\n+  *issued_error = false;\n   switch (op)\n     {\n     case OPERATOR_PLUS:\n@@ -4050,7 +4057,12 @@ Unary_expression::eval_constant(Operator op, const Numeric_constant* unc,\n   mpz_clear(uval);\n   mpz_clear(val);\n \n-  return nc->set_type(unc->type(), true, location);\n+  if (!nc->set_type(unc->type(), true, location))\n+    {\n+      *issued_error = true;\n+      return false;\n+    }\n+  return true;\n }\n \n // Return the integral constant value of a unary expression, if it has one.\n@@ -4061,8 +4073,9 @@ Unary_expression::do_numeric_constant_value(Numeric_constant* nc) const\n   Numeric_constant unc;\n   if (!this->expr_->numeric_constant_value(&unc))\n     return false;\n+  bool issued_error;\n   return Unary_expression::eval_constant(this->op_, &unc, this->location(),\n-\t\t\t\t\t nc);\n+\t\t\t\t\t nc, &issued_error);\n }\n \n // Return the type of a unary expression.\n@@ -4737,13 +4750,15 @@ Binary_expression::compare_complex(const Numeric_constant* left_nc,\n \n // Apply binary opcode OP to LEFT_NC and RIGHT_NC, setting NC.  Return\n // true if this could be done, false if not.  Issue errors at LOCATION\n-// as appropriate.\n+// as appropriate, and sets *ISSUED_ERROR if it did.\n \n bool\n Binary_expression::eval_constant(Operator op, Numeric_constant* left_nc,\n \t\t\t\t Numeric_constant* right_nc,\n-\t\t\t\t Location location, Numeric_constant* nc)\n+\t\t\t\t Location location, Numeric_constant* nc,\n+\t\t\t\t bool* issued_error)\n {\n+  *issued_error = false;\n   switch (op)\n     {\n     case OPERATOR_OROR:\n@@ -4792,7 +4807,11 @@ Binary_expression::eval_constant(Operator op, Numeric_constant* left_nc,\n     r = Binary_expression::eval_integer(op, left_nc, right_nc, location, nc);\n \n   if (r)\n-    r = nc->set_type(type, true, location);\n+    {\n+      r = nc->set_type(type, true, location);\n+      if (!r)\n+\t*issued_error = true;\n+    }\n \n   return r;\n }\n@@ -5115,9 +5134,15 @@ Binary_expression::do_lower(Gogo* gogo, Named_object*,\n \telse\n \t  {\n \t    Numeric_constant nc;\n+\t    bool issued_error;\n \t    if (!Binary_expression::eval_constant(op, &left_nc, &right_nc,\n-\t\t\t\t\t\t  location, &nc))\n+\t\t\t\t\t\t  location, &nc,\n+\t\t\t\t\t\t  &issued_error))\n+\t      {\n+\t\tif (issued_error)\n+\t\t  return Expression::make_error(location);\n                 return this;\n+\t      }\n \t    return nc.expression(location);\n \t  }\n       }\n@@ -5458,8 +5483,9 @@ Binary_expression::do_numeric_constant_value(Numeric_constant* nc) const\n   Numeric_constant right_nc;\n   if (!this->right_->numeric_constant_value(&right_nc))\n     return false;\n+  bool issued_error;\n   return Binary_expression::eval_constant(this->op_, &left_nc, &right_nc,\n-\t\t\t\t\t  this->location(), nc);\n+\t\t\t\t\t  this->location(), nc, &issued_error);\n }\n \n // Note that the value is being discarded.\n@@ -5558,7 +5584,12 @@ Binary_expression::do_determine_type(const Type_context* context)\n \n   Type_context subcontext(*context);\n \n-  if (is_comparison)\n+  if (is_constant_expr)\n+    {\n+      subcontext.type = NULL;\n+      subcontext.may_be_abstract = true;\n+    }\n+  else if (is_comparison)\n     {\n       // In a comparison, the context does not determine the types of\n       // the operands.\n@@ -5600,8 +5631,7 @@ Binary_expression::do_determine_type(const Type_context* context)\n \tsubcontext.type = subcontext.type->make_non_abstract_type();\n     }\n \n-  if (!is_constant_expr)\n-    this->left_->determine_type(&subcontext);\n+  this->left_->determine_type(&subcontext);\n \n   if (is_shift_op)\n     {\n@@ -5621,8 +5651,7 @@ Binary_expression::do_determine_type(const Type_context* context)\n       subcontext.may_be_abstract = false;\n     }\n \n-  if (!is_constant_expr)\n-    this->right_->determine_type(&subcontext);\n+  this->right_->determine_type(&subcontext);\n \n   if (is_comparison)\n     {"}, {"sha": "e088100e056e6504293043fe5260aeb40be4ab81", "filename": "gcc/go/gofrontend/expressions.h", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/62afb87d9c466ab33767fad6d74133a4ad925f52/gcc%2Fgo%2Fgofrontend%2Fexpressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.h?ref=62afb87d9c466ab33767fad6d74133a4ad925f52", "patch": "@@ -1775,10 +1775,11 @@ class Unary_expression : public Expression\n   }\n \n   // Apply unary opcode OP to UNC, setting NC.  Return true if this\n-  // could be done, false if not.  Issue errors for overflow.\n+  // could be done, false if not.  On overflow, issues an error and\n+  // sets *ISSUED_ERROR.\n   static bool\n   eval_constant(Operator op, const Numeric_constant* unc,\n-\t\tLocation, Numeric_constant* nc);\n+\t\tLocation, Numeric_constant* nc, bool *issued_error);\n \n   static Expression*\n   do_import(Import*);\n@@ -1893,11 +1894,11 @@ class Binary_expression : public Expression\n \n   // Apply binary opcode OP to LEFT_NC and RIGHT_NC, setting NC.\n   // Return true if this could be done, false if not.  Issue errors at\n-  // LOCATION as appropriate.\n+  // LOCATION as appropriate, and sets *ISSUED_ERROR if it did.\n   static bool\n   eval_constant(Operator op, Numeric_constant* left_nc,\n \t\tNumeric_constant* right_nc, Location location,\n-\t\tNumeric_constant* nc);\n+\t\tNumeric_constant* nc, bool* issued_error);\n \n   // Compare constants LEFT_NC and RIGHT_NC according to OP, setting\n   // *RESULT.  Return true if this could be done, false if not.  Issue"}]}