{"sha": "de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU5NTRkNmE1ZmI3ZGJiMmM0YzBhNjQ2YTVlNTk3MjdiMDY4NDdjMQ==", "commit": {"author": {"name": "Andre Vieira", "email": "andre.simoesdiasvieira@arm.com", "date": "2016-12-02T15:29:03Z"}, "committer": {"name": "Andre Vieira", "email": "avieira@gcc.gnu.org", "date": "2016-12-02T15:29:03Z"}, "message": "ARMv8-M Security Extension's cmse_nonsecure_entry: clear registers\n\n    gcc/ChangeLog:\n    2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t\tThomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* config/arm/arm.c (output_return_instruction): Clear\n\tregisters.\n\t(thumb2_expand_return): Likewise.\n\t(thumb1_expand_epilogue): Likewise.\n\t(thumb_exit): Likewise.\n\t(arm_expand_epilogue): Likewise.\n\t(cmse_nonsecure_entry_clear_before_return): New.\n\t(comp_not_to_clear_mask_str_un): New.\n\t(compute_not_to_clear_mask): New.\n\t* config/arm/thumb1.md (*epilogue_insns): Change length attribute.\n\t* config/arm/thumb2.md (*thumb2_return): Disable for\n\tcmse_nonsecure_entry functions.\n\t(*thumb2_cmse_entry_return): Duplicate thumb2_return pattern for\n\tcmse_nonsecure_entry functions.\n\n    gcc/testsuite/ChangeLog:\n    2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n\t\tThomas Preud'homme  <thomas.preudhomme@arm.com>\n\n\t* gcc.target/arm/cmse/cmse.exp: Test different multilibs separate.\n\t* gcc.target/arm/cmse/struct-1.c: New.\n\t* gcc.target/arm/cmse/bitfield-1.c: New.\n\t* gcc.target/arm/cmse/bitfield-2.c: New.\n\t* gcc.target/arm/cmse/bitfield-3.c: New.\n\t* gcc.target/arm/cmse/baseline/cmse-2.c: New.\n\t* gcc.target/arm/cmse/baseline/softfp.c: New.\n\t* gcc.target/arm/cmse/mainline/soft/cmse-5.c: New.\n\t* gcc.target/arm/cmse/mainline/hard/cmse-5.c: New.\n\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-5.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp/cmse-5.c: New.\n\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-5.c: New.\n\n\nCo-Authored-By: Thomas Preud'homme <thomas.preudhomme@arm.com>\n\nFrom-SVN: r243190", "tree": {"sha": "3823fa8a428cd0dcfe7b3c765978c917c4dc3b40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3823fa8a428cd0dcfe7b3c765978c917c4dc3b40"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/comments", "author": {"login": "avieira-arm", "id": 68072104, "node_id": "MDQ6VXNlcjY4MDcyMTA0", "avatar_url": "https://avatars.githubusercontent.com/u/68072104?v=4", "gravatar_id": "", "url": "https://api.github.com/users/avieira-arm", "html_url": "https://github.com/avieira-arm", "followers_url": "https://api.github.com/users/avieira-arm/followers", "following_url": "https://api.github.com/users/avieira-arm/following{/other_user}", "gists_url": "https://api.github.com/users/avieira-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/avieira-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/avieira-arm/subscriptions", "organizations_url": "https://api.github.com/users/avieira-arm/orgs", "repos_url": "https://api.github.com/users/avieira-arm/repos", "events_url": "https://api.github.com/users/avieira-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/avieira-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9ad1f699b81ce32d1193301ee2c0c188abf64d28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ad1f699b81ce32d1193301ee2c0c188abf64d28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ad1f699b81ce32d1193301ee2c0c188abf64d28"}], "stats": {"total": 954, "additions": 948, "deletions": 6}, "files": [{"sha": "bb1e524ce3571dac4b6bd31d6a10de9db7b04456", "filename": "gcc/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -1,3 +1,21 @@\n+2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* config/arm/arm.c (output_return_instruction): Clear\n+\tregisters.\n+\t(thumb2_expand_return): Likewise.\n+\t(thumb1_expand_epilogue): Likewise.\n+\t(thumb_exit): Likewise.\n+\t(arm_expand_epilogue): Likewise.\n+\t(cmse_nonsecure_entry_clear_before_return): New.\n+\t(comp_not_to_clear_mask_str_un): New.\n+\t(compute_not_to_clear_mask): New.\n+\t* config/arm/thumb1.md (*epilogue_insns): Change length attribute.\n+\t* config/arm/thumb2.md (*thumb2_return): Disable for\n+\tcmse_nonsecure_entry functions.\n+\t(*thumb2_cmse_entry_return): Duplicate thumb2_return pattern for\n+\tcmse_nonsecure_entry functions.\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "6a9db85aa879e1c5547908dcc9f036ee37de489e", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 483, "deletions": 3, "changes": 486, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -16297,6 +16297,279 @@ note_invalid_constants (rtx_insn *insn, HOST_WIDE_INT address, int do_pushes)\n   return;\n }\n \n+/* This function computes the clear mask and PADDING_BITS_TO_CLEAR for structs\n+   and unions in the context of ARMv8-M Security Extensions.  It is used as a\n+   helper function for both 'cmse_nonsecure_call' and 'cmse_nonsecure_entry'\n+   functions.  The PADDING_BITS_TO_CLEAR pointer can be the base to either one\n+   or four masks, depending on whether it is being computed for a\n+   'cmse_nonsecure_entry' return value or a 'cmse_nonsecure_call' argument\n+   respectively.  The tree for the type of the argument or a field within an\n+   argument is passed in ARG_TYPE, the current register this argument or field\n+   starts in is kept in the pointer REGNO and updated accordingly, the bit this\n+   argument or field starts at is passed in STARTING_BIT and the last used bit\n+   is kept in LAST_USED_BIT which is also updated accordingly.  */\n+\n+static unsigned HOST_WIDE_INT\n+comp_not_to_clear_mask_str_un (tree arg_type, int * regno,\n+\t\t\t       uint32_t * padding_bits_to_clear,\n+\t\t\t       unsigned starting_bit, int * last_used_bit)\n+\n+{\n+  unsigned HOST_WIDE_INT not_to_clear_reg_mask = 0;\n+\n+  if (TREE_CODE (arg_type) == RECORD_TYPE)\n+    {\n+      unsigned current_bit = starting_bit;\n+      tree field;\n+      long int offset, size;\n+\n+\n+      field = TYPE_FIELDS (arg_type);\n+      while (field)\n+\t{\n+\t  /* The offset within a structure is always an offset from\n+\t     the start of that structure.  Make sure we take that into the\n+\t     calculation of the register based offset that we use here.  */\n+\t  offset = starting_bit;\n+\t  offset += TREE_INT_CST_ELT (DECL_FIELD_BIT_OFFSET (field), 0);\n+\t  offset %= 32;\n+\n+\t  /* This is the actual size of the field, for bitfields this is the\n+\t     bitfield width and not the container size.  */\n+\t  size = TREE_INT_CST_ELT (DECL_SIZE (field), 0);\n+\n+\t  if (*last_used_bit != offset)\n+\t    {\n+\t      if (offset < *last_used_bit)\n+\t\t{\n+\t\t  /* This field's offset is before the 'last_used_bit', that\n+\t\t     means this field goes on the next register.  So we need to\n+\t\t     pad the rest of the current register and increase the\n+\t\t     register number.  */\n+\t\t  uint32_t mask;\n+\t\t  mask  = ((uint32_t)-1) - ((uint32_t) 1 << *last_used_bit);\n+\t\t  mask++;\n+\n+\t\t  padding_bits_to_clear[*regno] |= mask;\n+\t\t  not_to_clear_reg_mask |= HOST_WIDE_INT_1U << *regno;\n+\t\t  (*regno)++;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Otherwise we pad the bits between the last field's end and\n+\t\t     the start of the new field.  */\n+\t\t  uint32_t mask;\n+\n+\t\t  mask = ((uint32_t)-1) >> (32 - offset);\n+\t\t  mask -= ((uint32_t) 1 << *last_used_bit) - 1;\n+\t\t  padding_bits_to_clear[*regno] |= mask;\n+\t\t}\n+\t      current_bit = offset;\n+\t    }\n+\n+\t  /* Calculate further padding bits for inner structs/unions too.  */\n+\t  if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (field)))\n+\t    {\n+\t      *last_used_bit = current_bit;\n+\t      not_to_clear_reg_mask\n+\t\t|= comp_not_to_clear_mask_str_un (TREE_TYPE (field), regno,\n+\t\t\t\t\t\t  padding_bits_to_clear, offset,\n+\t\t\t\t\t\t  last_used_bit);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Update 'current_bit' with this field's size.  If the\n+\t\t 'current_bit' lies in a subsequent register, update 'regno' and\n+\t\t reset 'current_bit' to point to the current bit in that new\n+\t\t register.  */\n+\t      current_bit += size;\n+\t      while (current_bit >= 32)\n+\t\t{\n+\t\t  current_bit-=32;\n+\t\t  not_to_clear_reg_mask |= HOST_WIDE_INT_1U << *regno;\n+\t\t  (*regno)++;\n+\t\t}\n+\t      *last_used_bit = current_bit;\n+\t    }\n+\n+\t  field = TREE_CHAIN (field);\n+\t}\n+      not_to_clear_reg_mask |= HOST_WIDE_INT_1U << *regno;\n+    }\n+  else if (TREE_CODE (arg_type) == UNION_TYPE)\n+    {\n+      tree field, field_t;\n+      int i, regno_t, field_size;\n+      int max_reg = -1;\n+      int max_bit = -1;\n+      uint32_t mask;\n+      uint32_t padding_bits_to_clear_res[NUM_ARG_REGS]\n+\t= {-1, -1, -1, -1};\n+\n+      /* To compute the padding bits in a union we only consider bits as\n+\t padding bits if they are always either a padding bit or fall outside a\n+\t fields size for all fields in the union.  */\n+      field = TYPE_FIELDS (arg_type);\n+      while (field)\n+\t{\n+\t  uint32_t padding_bits_to_clear_t[NUM_ARG_REGS]\n+\t    = {0U, 0U, 0U, 0U};\n+\t  int last_used_bit_t = *last_used_bit;\n+\t  regno_t = *regno;\n+\t  field_t = TREE_TYPE (field);\n+\n+\t  /* If the field's type is either a record or a union make sure to\n+\t     compute their padding bits too.  */\n+\t  if (RECORD_OR_UNION_TYPE_P (field_t))\n+\t    not_to_clear_reg_mask\n+\t      |= comp_not_to_clear_mask_str_un (field_t, &regno_t,\n+\t\t\t\t\t\t&padding_bits_to_clear_t[0],\n+\t\t\t\t\t\tstarting_bit, &last_used_bit_t);\n+\t  else\n+\t    {\n+\t      field_size = TREE_INT_CST_ELT (DECL_SIZE (field), 0);\n+\t      regno_t = (field_size / 32) + *regno;\n+\t      last_used_bit_t = (starting_bit + field_size) % 32;\n+\t    }\n+\n+\t  for (i = *regno; i < regno_t; i++)\n+\t    {\n+\t      /* For all but the last register used by this field only keep the\n+\t\t padding bits that were padding bits in this field.  */\n+\t      padding_bits_to_clear_res[i] &= padding_bits_to_clear_t[i];\n+\t    }\n+\n+\t    /* For the last register, keep all padding bits that were padding\n+\t       bits in this field and any padding bits that are still valid\n+\t       as padding bits but fall outside of this field's size.  */\n+\t    mask = (((uint32_t) -1) - ((uint32_t) 1 << last_used_bit_t)) + 1;\n+\t    padding_bits_to_clear_res[regno_t]\n+\t      &= padding_bits_to_clear_t[regno_t] | mask;\n+\n+\t  /* Update the maximum size of the fields in terms of registers used\n+\t     ('max_reg') and the 'last_used_bit' in said register.  */\n+\t  if (max_reg < regno_t)\n+\t    {\n+\t      max_reg = regno_t;\n+\t      max_bit = last_used_bit_t;\n+\t    }\n+\t  else if (max_reg == regno_t && max_bit < last_used_bit_t)\n+\t    max_bit = last_used_bit_t;\n+\n+\t  field = TREE_CHAIN (field);\n+\t}\n+\n+      /* Update the current padding_bits_to_clear using the intersection of the\n+\t padding bits of all the fields.  */\n+      for (i=*regno; i < max_reg; i++)\n+\tpadding_bits_to_clear[i] |= padding_bits_to_clear_res[i];\n+\n+      /* Do not keep trailing padding bits, we do not know yet whether this\n+\t is the end of the argument.  */\n+      mask = ((uint32_t) 1 << max_bit) - 1;\n+      padding_bits_to_clear[max_reg]\n+\t|= padding_bits_to_clear_res[max_reg] & mask;\n+\n+      *regno = max_reg;\n+      *last_used_bit = max_bit;\n+    }\n+  else\n+    /* This function should only be used for structs and unions.  */\n+    gcc_unreachable ();\n+\n+  return not_to_clear_reg_mask;\n+}\n+\n+/* In the context of ARMv8-M Security Extensions, this function is used for both\n+   'cmse_nonsecure_call' and 'cmse_nonsecure_entry' functions to compute what\n+   registers are used when returning or passing arguments, which is then\n+   returned as a mask.  It will also compute a mask to indicate padding/unused\n+   bits for each of these registers, and passes this through the\n+   PADDING_BITS_TO_CLEAR pointer.  The tree of the argument type is passed in\n+   ARG_TYPE, the rtl representation of the argument is passed in ARG_RTX and\n+   the starting register used to pass this argument or return value is passed\n+   in REGNO.  It makes use of 'comp_not_to_clear_mask_str_un' to compute these\n+   for struct and union types.  */\n+\n+static unsigned HOST_WIDE_INT\n+compute_not_to_clear_mask (tree arg_type, rtx arg_rtx, int regno,\n+\t\t\t     uint32_t * padding_bits_to_clear)\n+\n+{\n+  int last_used_bit = 0;\n+  unsigned HOST_WIDE_INT not_to_clear_mask;\n+\n+  if (RECORD_OR_UNION_TYPE_P (arg_type))\n+    {\n+      not_to_clear_mask\n+\t= comp_not_to_clear_mask_str_un (arg_type, &regno,\n+\t\t\t\t\t padding_bits_to_clear, 0,\n+\t\t\t\t\t &last_used_bit);\n+\n+\n+      /* If the 'last_used_bit' is not zero, that means we are still using a\n+\t part of the last 'regno'.  In such cases we must clear the trailing\n+\t bits.  Otherwise we are not using regno and we should mark it as to\n+\t clear.  */\n+      if (last_used_bit != 0)\n+\tpadding_bits_to_clear[regno]\n+\t  |= ((uint32_t)-1) - ((uint32_t) 1 << last_used_bit) + 1;\n+      else\n+\tnot_to_clear_mask &= ~(HOST_WIDE_INT_1U << regno);\n+    }\n+  else\n+    {\n+      not_to_clear_mask = 0;\n+      /* We are not dealing with structs nor unions.  So these arguments may be\n+\t passed in floating point registers too.  In some cases a BLKmode is\n+\t used when returning or passing arguments in multiple VFP registers.  */\n+      if (GET_MODE (arg_rtx) == BLKmode)\n+\t{\n+\t  int i, arg_regs;\n+\t  rtx reg;\n+\n+\t  /* This should really only occur when dealing with the hard-float\n+\t     ABI.  */\n+\t  gcc_assert (TARGET_HARD_FLOAT_ABI);\n+\n+\t  for (i = 0; i < XVECLEN (arg_rtx, 0); i++)\n+\t    {\n+\t      reg = XEXP (XVECEXP (arg_rtx, 0, i), 0);\n+\t      gcc_assert (REG_P (reg));\n+\n+\t      not_to_clear_mask |= HOST_WIDE_INT_1U << REGNO (reg);\n+\n+\t      /* If we are dealing with DF mode, make sure we don't\n+\t\t clear either of the registers it addresses.  */\n+\t      arg_regs = ARM_NUM_REGS (GET_MODE (reg));\n+\t      if (arg_regs > 1)\n+\t\t{\n+\t\t  unsigned HOST_WIDE_INT mask;\n+\t\t  mask = HOST_WIDE_INT_1U << (REGNO (reg) + arg_regs);\n+\t\t  mask -= HOST_WIDE_INT_1U << REGNO (reg);\n+\t\t  not_to_clear_mask |= mask;\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  /* Otherwise we can rely on the MODE to determine how many registers\n+\t     are being used by this argument.  */\n+\t  int arg_regs = ARM_NUM_REGS (GET_MODE (arg_rtx));\n+\t  not_to_clear_mask |= HOST_WIDE_INT_1U << REGNO (arg_rtx);\n+\t  if (arg_regs > 1)\n+\t    {\n+\t      unsigned HOST_WIDE_INT\n+\t      mask = HOST_WIDE_INT_1U << (REGNO (arg_rtx) + arg_regs);\n+\t      mask -= HOST_WIDE_INT_1U << REGNO (arg_rtx);\n+\t      not_to_clear_mask |= mask;\n+\t    }\n+\t}\n+    }\n+\n+  return not_to_clear_mask;\n+}\n+\n /* Rewrite move insn into subtract of 0 if the condition codes will\n    be useful in next conditional jump insn.  */\n \n@@ -18720,7 +18993,42 @@ output_return_instruction (rtx operand, bool really_return, bool reverse,\n \n \tdefault:\n \t  if (IS_CMSE_ENTRY (func_type))\n-\t    snprintf (instr, sizeof (instr), \"bxns%s\\t%%|lr\", conditional);\n+\t    {\n+\t      /* Check if we have to clear the 'GE bits' which is only used if\n+\t\t parallel add and subtraction instructions are available.  */\n+\t      if (TARGET_INT_SIMD)\n+\t\tsnprintf (instr, sizeof (instr),\n+\t\t\t  \"msr%s\\tAPSR_nzcvqg, %%|lr\", conditional);\n+\t      else\n+\t\tsnprintf (instr, sizeof (instr),\n+\t\t\t  \"msr%s\\tAPSR_nzcvq, %%|lr\", conditional);\n+\n+\t      output_asm_insn (instr, & operand);\n+\t      if (TARGET_HARD_FLOAT && !TARGET_THUMB1)\n+\t\t{\n+\t\t  /* Clear the cumulative exception-status bits (0-4,7) and the\n+\t\t     condition code bits (28-31) of the FPSCR.  We need to\n+\t\t     remember to clear the first scratch register used (IP) and\n+\t\t     save and restore the second (r4).  */\n+\t\t  snprintf (instr, sizeof (instr), \"push\\t{%%|r4}\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"vmrs\\t%%|ip, fpscr\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"movw\\t%%|r4, #65376\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"movt\\t%%|r4, #4095\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"and\\t%%|ip, %%|r4\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"vmsr\\tfpscr, %%|ip\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"pop\\t{%%|r4}\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t  snprintf (instr, sizeof (instr), \"mov\\t%%|ip, %%|lr\");\n+\t\t  output_asm_insn (instr, & operand);\n+\t\t}\n+\t      snprintf (instr, sizeof (instr), \"bxns\\t%%|lr\");\n+\t    }\n \t  /* Use bx if it's available.  */\n \t  else if (arm_arch5 || arm_arch4t)\n \t    sprintf (instr, \"bx%s\\t%%|lr\", conditional);\n@@ -23027,7 +23335,11 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n \tasm_fprintf (f, \"\\tadd\\t%r, %r\\n\", SP_REGNUM, ARM_EH_STACKADJ_REGNUM);\n \n       if (IS_CMSE_ENTRY (arm_current_func_type ()))\n-\tasm_fprintf (f, \"\\tbxns\\t%r\\n\", reg_containing_return_addr);\n+\t{\n+\t  asm_fprintf (f, \"\\tmsr\\tAPSR_nzcvq, %r\\n\",\n+\t\t       reg_containing_return_addr);\n+\t  asm_fprintf (f, \"\\tbxns\\t%r\\n\", reg_containing_return_addr);\n+\t}\n       else\n \tasm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n       return;\n@@ -23263,7 +23575,18 @@ thumb_exit (FILE *f, int reg_containing_return_addr)\n \n   /* Return to caller.  */\n   if (IS_CMSE_ENTRY (arm_current_func_type ()))\n-    asm_fprintf (f, \"\\tbxns\\t%r\\n\", reg_containing_return_addr);\n+    {\n+      /* This is for the cases where LR is not being used to contain the return\n+         address.  It may therefore contain information that we might not want\n+\t to leak, hence it must be cleared.  The value in R0 will never be a\n+\t secret at this point, so it is safe to use it, see the clearing code\n+\t in 'cmse_nonsecure_entry_clear_before_return'.  */\n+      if (reg_containing_return_addr != LR_REGNUM)\n+\tasm_fprintf (f, \"\\tmov\\tlr, r0\\n\");\n+\n+      asm_fprintf (f, \"\\tmsr\\tAPSR_nzcvq, %r\\n\", reg_containing_return_addr);\n+      asm_fprintf (f, \"\\tbxns\\t%r\\n\", reg_containing_return_addr);\n+    }\n   else\n     asm_fprintf (f, \"\\tbx\\t%r\\n\", reg_containing_return_addr);\n }\n@@ -24130,6 +24453,149 @@ thumb1_expand_prologue (void)\n     cfun->machine->lr_save_eliminated = 0;\n }\n \n+/* Clear caller saved registers not used to pass return values and leaked\n+   condition flags before exiting a cmse_nonsecure_entry function.  */\n+\n+void\n+cmse_nonsecure_entry_clear_before_return (void)\n+{\n+  uint64_t to_clear_mask[2];\n+  uint32_t padding_bits_to_clear = 0;\n+  uint32_t * padding_bits_to_clear_ptr = &padding_bits_to_clear;\n+  int regno, maxregno = IP_REGNUM;\n+  tree result_type;\n+  rtx result_rtl;\n+\n+  to_clear_mask[0] = (1ULL << (NUM_ARG_REGS)) - 1;\n+  to_clear_mask[0] |= (1ULL << IP_REGNUM);\n+\n+  /* If we are not dealing with -mfloat-abi=soft we will need to clear VFP\n+     registers.  We also check that TARGET_HARD_FLOAT and !TARGET_THUMB1 hold\n+     to make sure the instructions used to clear them are present.  */\n+  if (TARGET_HARD_FLOAT && !TARGET_THUMB1)\n+    {\n+      uint64_t float_mask = (1ULL << (D7_VFP_REGNUM + 1)) - 1;\n+      maxregno = LAST_VFP_REGNUM;\n+\n+      float_mask &= ~((1ULL << FIRST_VFP_REGNUM) - 1);\n+      to_clear_mask[0] |= float_mask;\n+\n+      float_mask = (1ULL << (maxregno - 63)) - 1;\n+      to_clear_mask[1] = float_mask;\n+\n+      /* Make sure we don't clear the two scratch registers used to clear the\n+\t relevant FPSCR bits in output_return_instruction.  */\n+      emit_use (gen_rtx_REG (SImode, IP_REGNUM));\n+      to_clear_mask[0] &= ~(1ULL << IP_REGNUM);\n+      emit_use (gen_rtx_REG (SImode, 4));\n+      to_clear_mask[0] &= ~(1ULL << 4);\n+    }\n+\n+  /* If the user has defined registers to be caller saved, these are no longer\n+     restored by the function before returning and must thus be cleared for\n+     security purposes.  */\n+  for (regno = NUM_ARG_REGS; regno < LAST_VFP_REGNUM; regno++)\n+    {\n+      /* We do not touch registers that can be used to pass arguments as per\n+\t the AAPCS, since these should never be made callee-saved by user\n+\t options.  */\n+      if (IN_RANGE (regno, FIRST_VFP_REGNUM, D7_VFP_REGNUM))\n+\tcontinue;\n+      if (IN_RANGE (regno, IP_REGNUM, PC_REGNUM))\n+\tcontinue;\n+      if (call_used_regs[regno])\n+\tto_clear_mask[regno / 64] |= (1ULL << (regno % 64));\n+    }\n+\n+  /* Make sure we do not clear the registers used to return the result in.  */\n+  result_type = TREE_TYPE (DECL_RESULT (current_function_decl));\n+  if (!VOID_TYPE_P (result_type))\n+    {\n+      result_rtl = arm_function_value (result_type, current_function_decl, 0);\n+\n+      /* No need to check that we return in registers, because we don't\n+\t support returning on stack yet.  */\n+      to_clear_mask[0]\n+\t&= ~compute_not_to_clear_mask (result_type, result_rtl, 0,\n+\t\t\t\t       padding_bits_to_clear_ptr);\n+    }\n+\n+  if (padding_bits_to_clear != 0)\n+    {\n+      rtx reg_rtx;\n+      /* Padding bits to clear is not 0 so we know we are dealing with\n+\t returning a composite type, which only uses r0.  Let's make sure that\n+\t r1-r3 is cleared too, we will use r1 as a scratch register.  */\n+      gcc_assert ((to_clear_mask[0] & 0xe) == 0xe);\n+\n+      reg_rtx = gen_rtx_REG (SImode, R1_REGNUM);\n+\n+      /* Fill the lower half of the negated padding_bits_to_clear.  */\n+      emit_move_insn (reg_rtx,\n+\t\t      GEN_INT ((((~padding_bits_to_clear) << 16u) >> 16u)));\n+\n+      /* Also fill the top half of the negated padding_bits_to_clear.  */\n+      if (((~padding_bits_to_clear) >> 16) > 0)\n+\temit_insn (gen_rtx_SET (gen_rtx_ZERO_EXTRACT (SImode, reg_rtx,\n+\t\t\t\t\t\t      GEN_INT (16),\n+\t\t\t\t\t\t      GEN_INT (16)),\n+\t\t\t\tGEN_INT ((~padding_bits_to_clear) >> 16)));\n+\n+      emit_insn (gen_andsi3 (gen_rtx_REG (SImode, R0_REGNUM),\n+\t\t\t   gen_rtx_REG (SImode, R0_REGNUM),\n+\t\t\t   reg_rtx));\n+    }\n+\n+  for (regno = R0_REGNUM; regno <= maxregno; regno++)\n+    {\n+      if (!(to_clear_mask[regno / 64] & (1ULL << (regno % 64))))\n+\tcontinue;\n+\n+      if (IS_VFP_REGNUM (regno))\n+\t{\n+\t  /* If regno is an even vfp register and its successor is also to\n+\t     be cleared, use vmov.  */\n+\t  if (TARGET_VFP_DOUBLE\n+\t      && VFP_REGNO_OK_FOR_DOUBLE (regno)\n+\t      && to_clear_mask[regno / 64] & (1ULL << ((regno % 64) + 1)))\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (DFmode, regno),\n+\t\t\t      CONST1_RTX (DFmode));\n+\t      emit_use (gen_rtx_REG (DFmode, regno));\n+\t      regno++;\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (SFmode, regno),\n+\t\t\t      CONST1_RTX (SFmode));\n+\t      emit_use (gen_rtx_REG (SFmode, regno));\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (TARGET_THUMB1)\n+\t    {\n+\t      if (regno == R0_REGNUM)\n+\t\temit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t\tconst0_rtx);\n+\t      else\n+\t\t/* R0 has either been cleared before, see code above, or it\n+\t\t   holds a return value, either way it is not secret\n+\t\t   information.  */\n+\t\temit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t\tgen_rtx_REG (SImode, R0_REGNUM));\n+\t      emit_use (gen_rtx_REG (SImode, regno));\n+\t    }\n+\t  else\n+\t    {\n+\t      emit_move_insn (gen_rtx_REG (SImode, regno),\n+\t\t\t      gen_rtx_REG (SImode, LR_REGNUM));\n+\t      emit_use (gen_rtx_REG (SImode, regno));\n+\t    }\n+\t}\n+    }\n+}\n+\n /* Generate pattern *pop_multiple_with_stack_update_and_return if single\n    POP instruction can be generated.  LR should be replaced by PC.  All\n    the checks required are already done by  USE_RETURN_INSN ().  Hence,\n@@ -24179,6 +24645,8 @@ thumb2_expand_return (bool simple_return)\n     }\n   else\n     {\n+      if (IS_CMSE_ENTRY (arm_current_func_type ()))\n+\tcmse_nonsecure_entry_clear_before_return ();\n       emit_jump_insn (simple_return_rtx);\n     }\n }\n@@ -24237,6 +24705,10 @@ thumb1_expand_epilogue (void)\n \n   if (! df_regs_ever_live_p (LR_REGNUM))\n     emit_use (gen_rtx_REG (SImode, LR_REGNUM));\n+\n+  /* Clear all caller-saved regs that are not used to return.  */\n+  if (IS_CMSE_ENTRY (arm_current_func_type ()))\n+    cmse_nonsecure_entry_clear_before_return ();\n }\n \n /* Epilogue code for APCS frame.  */\n@@ -24671,6 +25143,14 @@ arm_expand_epilogue (bool really_return)\n \t\t\t\t   stack_pointer_rtx, stack_pointer_rtx);\n     }\n \n+    /* Clear all caller-saved regs that are not used to return.  */\n+    if (IS_CMSE_ENTRY (arm_current_func_type ()))\n+      {\n+\t/* CMSE_ENTRY always returns.  */\n+\tgcc_assert (really_return);\n+\tcmse_nonsecure_entry_clear_before_return ();\n+      }\n+\n   if (!really_return)\n     return;\n "}, {"sha": "73a738195d5b35fe9b2a153d1270c26cbaad12e4", "filename": "gcc/config/arm/thumb1.md", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Fthumb1.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Fthumb1.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb1.md?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -1869,8 +1869,13 @@\n   \"*\n     return thumb1_unexpanded_epilogue ();\n   \"\n-  ; Length is absolute worst case\n-  [(set_attr \"length\" \"44\")\n+  ; Length is absolute worst case, when using CMSE and if this is an entry\n+  ; function an extra 4 (MSR) bytes will be added.\n+  [(set (attr \"length\")\n+\t(if_then_else\n+\t (match_test \"IS_CMSE_ENTRY (arm_current_func_type ())\")\n+\t (const_int 48)\n+\t (const_int 44)))\n    (set_attr \"type\" \"block\")\n    ;; We don't clobber the conditions, but the potential length of this\n    ;; operation is sufficient to make conditionalizing the sequence"}, {"sha": "9029a2fcfa8c865df9473eab7f807589a5a244e5", "filename": "gcc/config/arm/thumb2.md", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Fthumb2.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Fconfig%2Farm%2Fthumb2.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Fthumb2.md?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -1114,12 +1114,31 @@\n \n (define_insn \"*thumb2_return\"\n   [(simple_return)]\n-  \"TARGET_THUMB2\"\n+  \"TARGET_THUMB2 && !IS_CMSE_ENTRY (arm_current_func_type ())\"\n   \"* return output_return_instruction (const_true_rtx, true, false, true);\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")]\n )\n \n+(define_insn \"*thumb2_cmse_entry_return\"\n+  [(simple_return)]\n+  \"TARGET_THUMB2 && IS_CMSE_ENTRY (arm_current_func_type ())\"\n+  \"* return output_return_instruction (const_true_rtx, true, false, true);\"\n+  [(set_attr \"type\" \"branch\")\n+   ; This is a return from a cmse_nonsecure_entry function so code will be\n+   ; added to clear the APSR and potentially the FPSCR if VFP is available, so\n+   ; we adapt the length accordingly.\n+   (set (attr \"length\")\n+     (if_then_else (match_test \"TARGET_HARD_FLOAT\")\n+      (const_int 12)\n+      (const_int 8)))\n+   ; We do not support predicate execution of returns from cmse_nonsecure_entry\n+   ; functions because we need to clear the APSR.  Since predicable has to be\n+   ; a constant, we had to duplicate the thumb2_return pattern for CMSE entry\n+   ; functions.\n+   (set_attr \"predicable\" \"no\")]\n+)\n+\n (define_insn_and_split \"thumb2_eh_return\"\n   [(unspec_volatile [(match_operand:SI 0 \"s_register_operand\" \"r\")]\n \t\t    VUNSPEC_EH_RETURN)"}, {"sha": "7cb16166857bc75a27c6d44a0dd8c57b60af3d18", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -1,3 +1,19 @@\n+2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n+\t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n+\n+\t* gcc.target/arm/cmse/cmse.exp: Test different multilibs separate.\n+\t* gcc.target/arm/cmse/struct-1.c: New.\n+\t* gcc.target/arm/cmse/bitfield-1.c: New.\n+\t* gcc.target/arm/cmse/bitfield-2.c: New.\n+\t* gcc.target/arm/cmse/bitfield-3.c: New.\n+\t* gcc.target/arm/cmse/baseline/cmse-2.c: New.\n+\t* gcc.target/arm/cmse/baseline/softfp.c: New.\n+\t* gcc.target/arm/cmse/mainline/soft/cmse-5.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard/cmse-5.c: New.\n+\t* gcc.target/arm/cmse/mainline/hard-sp/cmse-5.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp/cmse-5.c: New.\n+\t* gcc.target/arm/cmse/mainline/softfp-sp/cmse-5.c: New.\n+\n 2016-12-02  Andre Vieira  <andre.simoesdiasvieira@arm.com>\n \t    Thomas Preud'homme  <thomas.preudhomme@arm.com>\n "}, {"sha": "814502d4e5d5ef87e920977b912f69f83cdde256", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/cmse-2.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fcmse-2.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_base_ok } */\n+/* { dg-add-options arm_arch_v8m_base } */\n+/* { dg-options \"-mcmse\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+/* { dg-final { scan-assembler \"movs\\tr1, r0\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr2, r0\" } } */\n+/* { dg-final { scan-assembler \"movs\\tr3, r0\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, r0\" } } */\n+/* { dg-final { scan-assembler \"mov\\tlr, r0\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq,\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "0069fcdaebfd9caea02751856039a3aaefd3ffab", "filename": "gcc/testsuite/gcc.target/arm/cmse/baseline/softfp.c", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fsoftfp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fsoftfp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbaseline%2Fsoftfp.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,29 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_base_ok } */\n+/* { dg-add-options arm_arch_v8m_base } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp\" } */\n+\n+double __attribute__ ((cmse_nonsecure_call)) (*bar) (float, double);\n+\n+double\n+foo (double a)\n+{\n+  return bar (1.0f, 2.0) + a;\n+}\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+baz (float a, double b)\n+{\n+  return (float) bar (a, b);\n+}\n+\n+/* Make sure we are not using FP instructions, since ARMv8-M Baseline does not\n+   support such instructions.  */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+/* { dg-final { scan-assembler-not \"vmrs\" } } */\n+\n+/* Just double checking that we are still doing cmse though.  */\n+/* { dg-final { scan-assembler-not \"vmrs\" } } */\n+/* { dg-final { scan-assembler \"bl\\t__gnu_cmse_nonsecure_call\" } } */\n+"}, {"sha": "fccc51d5c82f7955ee4cb8256c1dd38f9ff2670d", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-1.c", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-1.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,39 @@\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -mcmse -Wl,--section-start,.gnu.sgstubs=0x20400000\" } */\n+\n+typedef struct\n+{\n+  unsigned short  a : 6;\n+  unsigned char\t  b : 3;\n+  unsigned char\t  c;\n+  unsigned short  d : 8;\n+} test_st;\n+\n+test_st __attribute__ ((cmse_nonsecure_entry)) foo (void)\n+{\n+  test_st t;\n+  t.a = 63u;\n+  t.b = 7u;\n+  t.c = 255u;\n+  t.d = 255u;\n+  return t;\n+}\n+\n+int\n+main (void)\n+{\n+  test_st t;\n+  t = foo ();\n+  if (t.a != 63u\n+      || t.b != 7u\n+      || t.c != 255u\n+      || t.d != 255u)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tr1, #1855\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr1, 65535\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */\n+"}, {"sha": "e6aee3c4c022d50baec8ab16443130897540e703", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-2.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-2.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -mcmse -Wl,--section-start,.gnu.sgstubs=0x20400000\" } */\n+\n+typedef struct\n+{\n+  short\t      a : 7;\n+  signed char b : 3;\n+  short\t      c : 11;\n+} test_st;\n+\n+test_st __attribute__ ((cmse_nonsecure_entry)) foo (void)\n+{\n+  test_st t;\n+  t.a = -64;\n+  t.b = -4 ;\n+  t.c = -1024;\n+  return t;\n+}\n+\n+int\n+main (void)\n+{\n+  test_st t;\n+  t = foo ();\n+  if (t.a != -64\n+      || t.b != -4\n+      || t.c != -1024)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tr1, #1919\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr1, 2047\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */\n+"}, {"sha": "285a2b92f64c1913ef585b8daa4d27c6da0a3d2f", "filename": "gcc/testsuite/gcc.target/arm/cmse/bitfield-3.c", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fbitfield-3.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,37 @@\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -mcmse -Wl,--section-start,.gnu.sgstubs=0x20400000\" } */\n+\n+typedef struct\n+{\n+  short\t      a;\n+  signed char b : 2;\n+  short\t\t: 1;\n+  signed char c : 3;\n+} test_st;\n+\n+test_st __attribute__ ((cmse_nonsecure_entry)) foo (void)\n+{\n+  test_st t;\n+  t.a = -32768;\n+  t.b = -2;\n+  t.c = -4;\n+  return t;\n+}\n+\n+int\n+main (void)\n+{\n+  test_st t;\n+  t = foo ();\n+  if (t.a != -32768\n+      || t.b != -2\n+      || t.c != -4)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movw\\tr1, #65535\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr1, 63\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */\n+"}, {"sha": "38f18414c2fefec56161e6ac3f7291b03a3b29a3", "filename": "gcc/testsuite/gcc.target/arm/cmse/cmse.exp", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fcmse.exp?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -43,6 +43,26 @@ set LTO_TORTURE_OPTIONS \"\"\n gcc-dg-runtest [lsort [glob $srcdir/$subdir/*.c]] \\\n \t\"\" $DEFAULT_CFLAGS\n \n+if {[check_effective_target_arm_arch_v8m_base_ok]} then {\n+    # Baseline only\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/baseline/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n+}\n+\n+if {[check_effective_target_arm_arch_v8m_main_ok]} then {\n+    # Mainline -mfloat-abi=soft\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/soft/*.c]] \\\n+\t    \"-mfloat-abi=soft\" $DEFAULT_CFLAGS\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/softfp/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/softfp-sp/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/hard/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n+    gcc-dg-runtest [lsort [glob $srcdir/$subdir/mainline/hard-sp/*.c]] \\\n+\t    \"\" $DEFAULT_CFLAGS\n+}\n+\n set LTO_TORTURE_OPTIONS ${saved-lto_torture_options}\n set dg-do-what-default ${saved-dg-do-what-default}\n "}, {"sha": "88dec2762812614ee986ee1a023c0acce8f94c91", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard-sp/cmse-5.c", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard-sp%2Fcmse-5.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,45 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-sp-d16\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+/* { dg-final { scan-assembler \"mov\\tr0, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, lr\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq, lr\" { target { arm_arch_v8m_main_ok && { ! arm_dsp } } } } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvqg, lr\" { target { arm_arch_v8m_main_ok && arm_dsp } } } } */\n+/* { dg-final { scan-assembler \"push\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"vmrs\\tip, fpscr\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65376\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, #4095\" } } */\n+/* { dg-final { scan-assembler \"and\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"vmsr\\tfpscr, ip\" } } */\n+/* { dg-final { scan-assembler \"pop\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, lr\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "29f60baf5212f9fa2e4436fe40c6abe4ac671254", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/hard/cmse-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fhard%2Fcmse-5.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=hard -mfpu=fpv5-d16\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+/* { dg-final { scan-assembler \"mov\\tr0, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, lr\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq, lr\" { target { arm_arch_v8m_main_ok && { ! arm_dsp } } } } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvqg, lr\" { target { arm_arch_v8m_main_ok && arm_dsp } } } } */\n+/* { dg-final { scan-assembler \"push\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"vmrs\\tip, fpscr\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65376\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, #4095\" } } */\n+/* { dg-final { scan-assembler \"and\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"vmsr\\tfpscr, ip\" } } */\n+/* { dg-final { scan-assembler \"pop\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, lr\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "a7229ea8eb2da1da264f58f8518daf303d1bdeda", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/soft/cmse-5.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoft%2Fcmse-5.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,24 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=hard\" -mfloat-abi=softfp } {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=soft\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+\n+/* { dg-final { scan-assembler \"mov\\tr1, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, lr\" } } */\n+/* { dg-final { scan-assembler-not \"vmov\" } } */\n+/* { dg-final { scan-assembler-not \"vmsr\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq, lr\" { target { arm_arch_v8m_main_ok && { ! arm_dsp } } } } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvqg, lr\" { target { arm_arch_v8m_main_ok && arm_dsp } } } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */\n+"}, {"sha": "7734d77dc3812e6a158ea1f6b067930846fffccb", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp-sp/cmse-5.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp-sp%2Fcmse-5.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing double precision\" {*-*-*} {\"-mfpu=fpv[4-5]-d16\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-sp-d16\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+/* { dg-final { scan-assembler \"__acle_se_foo:\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, lr\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts8, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts9, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts10, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts11, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts12, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts13, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts14, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f32\\ts15, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq, lr\" { target { arm_arch_v8m_main_ok && { ! arm_dsp } } } } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvqg, lr\" { target { arm_arch_v8m_main_ok && arm_dsp } } } } */\n+/* { dg-final { scan-assembler \"push\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"vmrs\\tip, fpscr\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65376\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, #4095\" } } */\n+/* { dg-final { scan-assembler \"and\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"vmsr\\tfpscr, ip\" } } */\n+/* { dg-final { scan-assembler \"pop\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, lr\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "6addaa1a4eda8e2930d5fe72c94697bcf6e604e4", "filename": "gcc/testsuite/gcc.target/arm/cmse/mainline/softfp/cmse-5.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fmainline%2Fsoftfp%2Fcmse-5.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,38 @@\n+/* { dg-do compile } */\n+/* { dg-require-effective-target arm_arch_v8m_main_ok } */\n+/* { dg-add-options arm_arch_v8m_main } */\n+/* { dg-skip-if \"Do not combine float-abi= hard | soft | softfp\" {*-*-*} {\"-mfloat-abi=soft\" -mfloat-abi=hard } {\"\"} } */\n+/* { dg-skip-if \"Skip these if testing single precision\" {*-*-*} {\"-mfpu=*-sp-*\"} {\"\"} } */\n+/* { dg-options \"-mcmse -mfloat-abi=softfp -mfpu=fpv5-d16\" }  */\n+\n+extern float bar (void);\n+\n+float __attribute__ ((cmse_nonsecure_entry))\n+foo (void)\n+{\n+  return bar ();\n+}\n+/* { dg-final { scan-assembler \"__acle_se_foo:\" } } */\n+/* { dg-final { scan-assembler-not \"mov\\tr0, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr1, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr2, lr\" } } */\n+/* { dg-final { scan-assembler \"mov\\tr3, lr\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td0, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td1, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td2, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td3, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td4, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td5, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td6, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"vmov\\.f64\\td7, #1\\.0\" } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvq, lr\" { target { arm_arch_v8m_main_ok && { ! arm_dsp } } } } } */\n+/* { dg-final { scan-assembler \"msr\\tAPSR_nzcvqg, lr\" { target { arm_arch_v8m_main_ok && arm_dsp } } } } */\n+/* { dg-final { scan-assembler \"push\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"vmrs\\tip, fpscr\" } } */\n+/* { dg-final { scan-assembler \"movw\\tr4, #65376\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr4, #4095\" } } */\n+/* { dg-final { scan-assembler \"and\\tip, r4\" } } */\n+/* { dg-final { scan-assembler \"vmsr\\tfpscr, ip\" } } */\n+/* { dg-final { scan-assembler \"pop\\t{r4}\" } } */\n+/* { dg-final { scan-assembler \"mov\\tip, lr\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */"}, {"sha": "2d366a944df692f29ab44e3ee4d33c777b126223", "filename": "gcc/testsuite/gcc.target/arm/cmse/struct-1.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de954d6a5fb7dbb2c4c0a646a5e59727b06847c1/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Farm%2Fcmse%2Fstruct-1.c?ref=de954d6a5fb7dbb2c4c0a646a5e59727b06847c1", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-do run } */\n+/* { dg-options \"--save-temps -mcmse -Wl,--section-start,.gnu.sgstubs=0x20400000\" } */\n+\n+typedef struct\n+{\n+  unsigned char\t  a;\n+  unsigned short  b;\n+} test_st;\n+\n+test_st __attribute__ ((cmse_nonsecure_entry)) foo (void)\n+{\n+  test_st t;\n+  t.a = 255u;\n+  t.b = 32767u;\n+  return t;\n+}\n+\n+int\n+main (void)\n+{\n+  test_st t;\n+  t = foo ();\n+  if (t.a != 255u || t.b != 32767u)\n+    __builtin_abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-assembler \"movs\\tr1, #255\" } } */\n+/* { dg-final { scan-assembler \"movt\\tr1, 65535\" } } */\n+/* { dg-final { scan-assembler \"ands\\tr0(, r0)?, r1\" } } */\n+/* { dg-final { scan-assembler \"bxns\" } } */\n+\n+"}]}