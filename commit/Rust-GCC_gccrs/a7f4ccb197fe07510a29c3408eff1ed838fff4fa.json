{"sha": "a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdmNGNjYjE5N2ZlMDc1MTBhMjljMzQwOGVmZjFlZDgzOGZmZjRmYQ==", "commit": {"author": {"name": "Steven Bosscher", "email": "stevenb@suse.de", "date": "2005-11-11T19:34:39Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2005-11-11T19:34:39Z"}, "message": "re PR target/24265 (ICE: in extract_insn, at recog.c:2084 with -O -fgcse -fmove-loop-invariants -mtune=pentiumpro)\n\n\tPR 24265\n\t* loop-invariant.c (may_assign_reg_p): Make sure a hard register\n\tcan be assigned to.\n\t(find_invariant_insn): Do the cheapest check, may_assign_reg_p,\n\tbefore check_maybe_invariant.\n\t(move_invariant_reg): Use gen_move_insn instead of replacing\n\tSET_DEST with the temporary for the invariant.\n\t(move_loop_invariants): If checking is enabled, do internal\n\tconsistency checks after completing the pass.\n\nFrom-SVN: r106795", "tree": {"sha": "5100e811789504438417f4754074c36177d090f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5100e811789504438417f4754074c36177d090f3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7f4ccb197fe07510a29c3408eff1ed838fff4fa/comments", "author": null, "committer": null, "parents": [{"sha": "d35a40fca5e07a1b8399e1299110b97b960e7109", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d35a40fca5e07a1b8399e1299110b97b960e7109", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d35a40fca5e07a1b8399e1299110b97b960e7109"}], "stats": {"total": 31, "additions": 25, "deletions": 6}, "files": [{"sha": "af3ee368e13042fafb214869ea07f90b26600dd9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f4ccb197fe07510a29c3408eff1ed838fff4fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f4ccb197fe07510a29c3408eff1ed838fff4fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "patch": "@@ -1,3 +1,15 @@\n+2005-11-11  Steven Bosscher  <stevenb@suse.de>\n+\n+\tPR 24265\n+\t* loop-invariant.c (may_assign_reg_p): Make sure a hard register\n+\tcan be assigned to.\n+\t(find_invariant_insn): Do the cheapest check, may_assign_reg_p,\n+\tbefore check_maybe_invariant.\n+\t(move_invariant_reg): Use gen_move_insn instead of replacing\n+\tSET_DEST with the temporary for the invariant.\n+\t(move_loop_invariants): If checking is enabled, do internal\n+\tconsistency checks after completing the pass.\n+\n 2005-11-11  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR 24644"}, {"sha": "dc35aceed3b3f365b520fd16fbc5efa426e2ecf8", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7f4ccb197fe07510a29c3408eff1ed838fff4fa/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7f4ccb197fe07510a29c3408eff1ed838fff4fa/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=a7f4ccb197fe07510a29c3408eff1ed838fff4fa", "patch": "@@ -291,7 +291,10 @@ find_exits (struct loop *loop, basic_block *body,\n static bool\n may_assign_reg_p (rtx x)\n {\n-  return can_copy_p (GET_MODE (x));\n+  return (can_copy_p (GET_MODE (x))\n+\t  && (!REG_P (x)\n+\t      || !HARD_REGISTER_P (x)\n+\t      || REGNO_REG_CLASS (REGNO (x)) != NO_REGS));\n }\n \n /* Finds definitions that may correspond to invariants in LOOP with body BODY.\n@@ -436,8 +439,8 @@ find_invariant_insn (rtx insn, bool always_reached, bool always_executed,\n       || HARD_REGISTER_P (dest))\n     simple = false;\n \n-  if (!check_maybe_invariant (SET_SRC (set))\n-      || !may_assign_reg_p (SET_DEST (set)))\n+  if (!may_assign_reg_p (SET_DEST (set))\n+      || !check_maybe_invariant (SET_SRC (set)))\n     return;\n \n   if (may_trap_p (PATTERN (insn)))\n@@ -793,9 +796,9 @@ move_invariant_reg (struct loop *loop, unsigned invno, struct df *df)\n   reg = gen_reg_rtx (GET_MODE (SET_DEST (set)));\n   df_pattern_emit_after (df, gen_move_insn (SET_DEST (set), reg),\n \t\t\t BLOCK_FOR_INSN (inv->insn), inv->insn);\n-  SET_DEST (set) = reg;\n-  reorder_insns (inv->insn, inv->insn, BB_END (preheader));\n-  df_insn_modify (df, preheader, inv->insn);\n+  df_pattern_emit_after (df, gen_move_insn (reg, SET_SRC (set)),\n+\t\t\t preheader, BB_END (preheader));\n+  df_insn_delete (df, BLOCK_FOR_INSN (inv->insn), inv->insn);\n \n   /* Replace the uses we know to be dominated.  It saves work for copy\n      propagation, and also it is necessary so that dependent invariants\n@@ -926,4 +929,8 @@ move_loop_invariants (struct loops *loops)\n       free_loop_data (loops->parray[i]);\n \n   df_finish (df);\n+\n+#ifdef ENABLE_CHECKING\n+  verify_flow_info ();\n+#endif\n }"}]}