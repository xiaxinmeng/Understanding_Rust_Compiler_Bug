{"sha": "92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTJmYzRhMmYzOTliOTJiZjZmOWVlM2I1MDM3MzIxNmIwMWIxY2E1ZQ==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "rakdver@atrey.karlin.mff.cuni.cz", "date": "2004-09-23T12:21:31Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2004-09-23T12:21:31Z"}, "message": "cfgloop.h (update_single_exits_after_duplication): Declare.\n\n\t* cfgloop.h (update_single_exits_after_duplication): Declare.\n\t(loopify, split_loop_bb): Declaration changed.\n\t* cfgloopmanip.c (split_loop_bb): Take void * as an argument instead\n\tof rtx.\n\t(loopify): Added redirect_all_edges argument.\n\t(update_single_exits_after_duplication): Export.\n\t* loop-unswitch.c (unswitch_loop): Changed due to loopify change.\n\t* tree-flow.h (tree_duplicate_loop_to_header_edge,\n\ttree_ssa_loop_version): Declare.\n\t* tree-ssa-loop-manip.c (copy_phi_node_args, rename_variables,\n\tset_phi_def_stmts, tree_duplicate_loop_to_header_edge,\n\tlv_adjust_loop_header_phi, lv_adjust_loop_entry_edge,\n\tlv_update_pending_stmts, tree_ssa_loop_version): New functions.\n\n\t* tree-ssa-loop-unswitch.c: New file.\n\t* Makefile.in (tree-ssa-loop-unswitch.o): Add.\n\t* timevar.def (TV_TREE_LOOP_UNSWITCH): New timevar.\n\t* tree-flow.h (tree_ssa_unswitch_loops): Declare.\n\t* tree-optimize.c (init_tree_optimization_passes): Add pass_unswitch.\n\t* tree-pass.h (pass_unswitch): Declare.\n\t* tree-ssa-loop.c (tree_ssa_loop_unswitch,\n\tgate_tree_ssa_loop_unswitch, pass_unswitch): New pass.\n\t* doc/passes.texi: Documen tree level loop unswitching.\n\n\t* gcc.dg/tree-ssa/loop-6.c: New test.\n\nFrom-SVN: r87943", "tree": {"sha": "4eca96bd1993934aaf193e1ddbcaa3b752254965", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4eca96bd1993934aaf193e1ddbcaa3b752254965"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/comments", "author": null, "committer": null, "parents": [{"sha": "b8b94c5ba81744d325f235a0409660f50ac3f361", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8b94c5ba81744d325f235a0409660f50ac3f361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8b94c5ba81744d325f235a0409660f50ac3f361"}], "stats": {"total": 781, "additions": 766, "deletions": 15}, "files": [{"sha": "cf3f949b133579e04872ae9c6fcbb90e8e9435e9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -1,3 +1,29 @@\n+2004-09-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* cfgloop.h (update_single_exits_after_duplication): Declare.\n+\t(loopify, split_loop_bb): Declaration changed.\n+\t* cfgloopmanip.c (split_loop_bb): Take void * as an argument instead\n+\tof rtx.\n+\t(loopify): Added redirect_all_edges argument.\n+\t(update_single_exits_after_duplication): Export.\n+\t* loop-unswitch.c (unswitch_loop): Changed due to loopify change.\n+\t* tree-flow.h (tree_duplicate_loop_to_header_edge,\n+\ttree_ssa_loop_version): Declare.\n+\t* tree-ssa-loop-manip.c (copy_phi_node_args, rename_variables,\n+\tset_phi_def_stmts, tree_duplicate_loop_to_header_edge,\n+\tlv_adjust_loop_header_phi, lv_adjust_loop_entry_edge,\n+\tlv_update_pending_stmts, tree_ssa_loop_version): New functions.\n+\n+\t* tree-ssa-loop-unswitch.c: New file.\n+\t* Makefile.in (tree-ssa-loop-unswitch.o): Add.\n+\t* timevar.def (TV_TREE_LOOP_UNSWITCH): New timevar.\n+\t* tree-flow.h (tree_ssa_unswitch_loops): Declare.\n+\t* tree-optimize.c (init_tree_optimization_passes): Add pass_unswitch.\n+\t* tree-pass.h (pass_unswitch): Declare.\n+\t* tree-ssa-loop.c (tree_ssa_loop_unswitch,\n+\tgate_tree_ssa_loop_unswitch, pass_unswitch): New pass.\n+\t* doc/passes.texi: Documen tree level loop unswitching.\n+\n 2004-09-23  Kazu Hirata  <kazu@cs.umass.edu>\n \n \t* cfgexpand.c, config/s390/tpf-eh.c: Fix comment typos."}, {"sha": "59b1fddb6c16711aa7411d244a7bb3ef116b1e89", "filename": "gcc/Makefile.in", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -144,7 +144,7 @@ TCFLAGS =\n CFLAGS = -g\n STAGE1_CFLAGS = -g @stage1_cflags@\n STAGE1_CHECKING = -DENABLE_CHECKING -DENABLE_ASSERT_CHECKING\n-BOOT_CFLAGS = -g -O2\n+BOOT_CFLAGS = -g -O2 -funswitch-loops\n \n # Flags to determine code coverage. When coverage is disabled, this will\n # contain the optimization flags, as you normally want code coverage\n@@ -897,7 +897,7 @@ OBJS-common = \\\n  tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n  tree-vectorizer.o tree-ssa-loop-ivcanon.o tree-ssa-propagate.o\t \t   \\\n- tree-ssa-loop-ivopts.o tree-if-conv.o\t \t                           \\\n+ tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -1693,6 +1693,10 @@ tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) \\\n    output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n    tree-pass.h $(FLAGS_H) tree-inline.h $(SCEV_H)\n+tree-ssa-loop-unswitch.o : tree-ssa-loop-unswitch.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) domwalk.h $(PARAMS_H)\\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) cfgloop.h $(PARAMS_H) tree-inline.h \\\n    output.h diagnostic.h $(TM_H) coretypes.h $(TREE_DUMP_H) $(FLAGS_H) \\"}, {"sha": "1b45a563bff794818a0b19adb4ce4e52a85916c2", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -254,6 +254,8 @@ extern int flow_loop_scan (struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n void mark_single_exit_loops (struct loops *);\n+void update_single_exits_after_duplication (basic_block *, unsigned,\n+\t\t\t\t\t    struct loop *);\n extern void create_loop_notes (void);\n \n /* Loop data structure manipulation/querying.  */\n@@ -313,10 +315,10 @@ extern struct loop * duplicate_loop (struct loops *, struct loop *,\n extern int duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n \t\t\t\t\t  unsigned, sbitmap, edge, edge *,\n \t\t\t\t\t  unsigned *, int);\n-extern struct loop *loopify (struct loops *, edge, edge, basic_block);\n+extern struct loop *loopify (struct loops *, edge, edge, basic_block, bool);\n extern void unloop (struct loops *, struct loop *);\n extern bool remove_path (struct loops *, edge);\n-extern edge split_loop_bb (basic_block, rtx);\n+extern edge split_loop_bb (basic_block, void *);\n \n /* Induction variable analysis.  */\n "}, {"sha": "24b2399ddb8a7a69a024158cd3fa9f501b052e6c", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -53,7 +53,7 @@ static void fix_irreducible_loops (basic_block);\n /* Splits basic block BB after INSN, returns created edge.  Updates loops\n    and dominators.  */\n edge\n-split_loop_bb (basic_block bb, rtx insn)\n+split_loop_bb (basic_block bb, void *insn)\n {\n   edge e;\n \n@@ -486,7 +486,7 @@ scale_loop_frequencies (struct loop *loop, int num, int den)\n \n struct loop *\n loopify (struct loops *loops, edge latch_edge, edge header_edge, \n-\t basic_block switch_bb)\n+\t basic_block switch_bb, bool redirect_all_edges)\n {\n   basic_block succ_bb = latch_edge->dest;\n   basic_block pred_bb = header_edge->src;\n@@ -513,12 +513,17 @@ loopify (struct loops *loops, edge latch_edge, edge header_edge,\n   loop_redirect_edge (latch_edge, loop->header);\n   loop_redirect_edge (BRANCH_EDGE (switch_bb), succ_bb);\n \n-  loop_redirect_edge (header_edge, switch_bb);\n-  loop_redirect_edge (FALLTHRU_EDGE (switch_bb), loop->header); \n-\n-  /* Update dominators.  */\n-  set_immediate_dominator (CDI_DOMINATORS, switch_bb, pred_bb);\n-  set_immediate_dominator (CDI_DOMINATORS, loop->header, switch_bb);\n+  /* During loop versioning, one of the switch_bb edge is already properly\n+     set. Do not redirect it again unless redirect_all_edges is true.  */\n+  if (redirect_all_edges)\n+    {\n+      loop_redirect_edge (header_edge, switch_bb);\n+      loop_redirect_edge (FALLTHRU_EDGE (switch_bb), loop->header); \n+     \n+      /* Update dominators.  */\n+      set_immediate_dominator (CDI_DOMINATORS, switch_bb, pred_bb);\n+      set_immediate_dominator (CDI_DOMINATORS, loop->header, switch_bb);\n+    }\n \n   set_immediate_dominator (CDI_DOMINATORS, succ_bb, switch_bb);\n \n@@ -812,7 +817,7 @@ can_duplicate_loop_p (struct loop *loop)\n /* The NBBS blocks in BBS will get duplicated and the copies will be placed\n    to LOOP.  Update the single_exit information in superloops of LOOP.  */\n \n-static void\n+void\n update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n \t\t\t\t       struct loop *loop)\n {\n@@ -834,7 +839,6 @@ update_single_exits_after_duplication (basic_block *bbs, unsigned nbbs,\n     bbs[i]->rbi->duplicated = 0;\n }\n \n-\n /* Duplicates body of LOOP to given edge E NDUPL times.  Takes care of updating\n    LOOPS structure and dominators.  E's destination must be LOOP header for\n    this to work, i.e. it must be entry or latch edge of this loop; these are"}, {"sha": "bf0c421e9e05141f79301fd56f710b76c1b65e1e", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -380,6 +380,14 @@ variable optimizations, including strength reduction, induction variable\n merging and induction variable elimination.  The pass is implemented in\n @file{tree-ssa-loop-ivopts.c}.\n \n+Loop unswitching.  This pass moves the conditional jumps that are invariant\n+out of the loops.  To achieve this, a duplicate of the loop is created for\n+each possible outcome of conditional jump(s).  The pass is implemented in\n+@file{tree-ssa-loop-unswitch.c}.  This pass should eventually replace the\n+rtl-level loop unswitching in @file{loop-unswitch.c}, but currently\n+the rtl-level pass is not completely redundant yet due to deficiences\n+in tree level alias analysis.\n+\n The optimizations also use various utility functions contained in\n @file{tree-ssa-loop-manip.c}, @file{cfgloop.c}, @file{cfgloopanal.c} and\n @file{cfgloopmanip.c}."}, {"sha": "2eb3396a759b06cd0cb8e5a6829a19a317165b3f", "filename": "gcc/loop-unswitch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Floop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Floop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unswitch.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -475,7 +475,7 @@ unswitch_loop (struct loops *loops, struct loop *loop, basic_block unswitch_on,\n \n   /* Loopify from the copy of LOOP body, constructing the new loop.  */\n   nloop = loopify (loops, latch_edge,\n-\t\t   loop->header->rbi->copy->pred, switch_bb);\n+\t\t   loop->header->rbi->copy->pred, switch_bb, true);\n \n   /* Remove branches that are now unreachable in new loops.  */\n   remove_path (loops, true_edge);"}, {"sha": "fbd76080aec75ce0db97d449e219cb232e1e4044", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -1,3 +1,7 @@\n+2004-09-23  Zdenek Dvorak  <rakdver@atrey.karlin.mff.cuni.cz>\n+\n+\t* gcc.dg/tree-ssa/loop-6.c: New test.\n+\n 2004-09-23  Nathan Sidwell  <nathan@codesourcery.com>\n \n \tPR c++/17620"}, {"sha": "e96f5e27c7045001ef96c8439446d28e5509f642", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-6.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-6.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -funswitch-loops -fdump-tree-unswitch-details -fdump-tree-vars\" } */\n+\n+int ch;\n+int a[100];\n+\n+void xxx(void)\n+{\n+  int i;\n+\n+  for (i = 0; i < 100; i++)\n+    {\n+      if (ch)\n+\ta[i] = ch;\n+      else\n+\ta[i] = i;\n+    }\n+}\n+\n+/* Loop should be unswitched.  */\n+\n+/* { dg-final { scan-tree-dump-times \"Unswitching loop\" 1 \"unswitch\" } } */\n+\n+/* In effect there should be exactly three conditional jumps in the final program.  */\n+\n+/* { dg-final { scan-tree-dump-times \"else\" 3 \"vars\" } } */"}, {"sha": "a7ebc3e36d47d2bfa8a8e4f756902eaf8a604892", "filename": "gcc/timevar.def", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftimevar.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftimevar.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.def?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -84,6 +84,7 @@ DEFTIMEVAR (TV_TREE_DSE\t\t     , \"tree DSE\")\n DEFTIMEVAR (TV_TREE_LOOP\t     , \"tree loop optimization\")\n DEFTIMEVAR (TV_LIM                   , \"loop invariant motion\")\n DEFTIMEVAR (TV_TREE_LOOP_IVCANON     , \"tree canonical iv creation\")\n+DEFTIMEVAR (TV_TREE_LOOP_UNSWITCH    , \"tree loop unswitching\")\n DEFTIMEVAR (TV_COMPLETE_UNROLL       , \"complete unrolling\")\n DEFTIMEVAR (TV_TREE_VECTORIZATION    , \"tree loop vectorization\")\n DEFTIMEVAR (TV_TREE_LINEAR_TRANSFORM , \"tree loop linear transforms\")"}, {"sha": "0cf86ca60eb8ff3f60721ba4624b0739c79aeb5c", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -650,6 +650,7 @@ bool empty_block_p (basic_block);\n /* In tree-ssa-loop*.c  */\n \n void tree_ssa_lim (struct loops *);\n+void tree_ssa_unswitch_loops (struct loops *);\n void canonicalize_induction_variables (struct loops *);\n void tree_unroll_loops_completely (struct loops *);\n void tree_ssa_iv_optimize (struct loops *);\n@@ -675,6 +676,12 @@ void standard_iv_increment_position (struct loop *, block_stmt_iterator *,\n \t\t\t\t     bool *);\n basic_block ip_end_pos (struct loop *);\n basic_block ip_normal_pos (struct loop *);\n+bool tree_duplicate_loop_to_header_edge (struct loop *, edge, struct loops *,\n+\t\t\t\t\t unsigned int, sbitmap,\n+\t\t\t\t\t edge, edge *,\n+\t\t\t\t\t unsigned int *, int);\n+struct loop *tree_ssa_loop_version (struct loops *, struct loop *, tree,\n+\t\t\t\t    basic_block *);\n \n /* In tree-ssa-loop-im.c  */\n /* The possibilities of statement movement.  */"}, {"sha": "3bcc1cde47b85deb3271f4a422806826dd3dab02", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -391,6 +391,7 @@ init_tree_optimization_passes (void)\n   p = &pass_loop.sub;\n   NEXT_PASS (pass_loop_init);\n   NEXT_PASS (pass_lim);\n+  NEXT_PASS (pass_unswitch);\n   NEXT_PASS (pass_iv_canon);\n   NEXT_PASS (pass_if_conversion);\n   NEXT_PASS (pass_vectorize);"}, {"sha": "ae19e2de517cd1395db3ee1fd33e7794b4a0f859", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -125,6 +125,7 @@ extern struct tree_opt_pass pass_tail_calls;\n extern struct tree_opt_pass pass_loop;\n extern struct tree_opt_pass pass_loop_init;\n extern struct tree_opt_pass pass_lim;\n+extern struct tree_opt_pass pass_unswitch;\n extern struct tree_opt_pass pass_iv_canon;\n extern struct tree_opt_pass pass_if_conversion;\n extern struct tree_opt_pass pass_vectorize;"}, {"sha": "a06b3520753ea3bdc7f5357ae1c8154441930147", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 340, "deletions": 0, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -506,3 +506,343 @@ standard_iv_increment_position (struct loop *loop, block_stmt_iterator *bsi,\n       *insert_after = false;\n     }\n }\n+\n+/* Copies phi node arguments for duplicated blocks.  The index of the first\n+   duplicated block is FIRST_NEW_BLOCK.  */\n+\n+static void\n+copy_phi_node_args (unsigned first_new_block)\n+{\n+  unsigned i;\n+\n+  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+    BASIC_BLOCK (i)->rbi->duplicated = 1;\n+\n+  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+    add_phi_args_after_copy_bb (BASIC_BLOCK (i));\n+\n+  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+    BASIC_BLOCK (i)->rbi->duplicated = 0;\n+}\n+\n+/* Renames variables in the area copied by tree_duplicate_loop_to_header_edge.\n+   FIRST_NEW_BLOCK is the first block in the copied area.   DEFINITIONS is\n+   a bitmap of all ssa names defined inside the loop.  */\n+\n+static void\n+rename_variables (unsigned first_new_block, bitmap definitions)\n+{\n+  unsigned i, copy_number = 0;\n+  basic_block bb;\n+  htab_t ssa_name_map = NULL;\n+\n+  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+\n+      /* We assume that first come all blocks from the first copy, then all\n+\t blocks from the second copy, etc.  */\n+      if (copy_number != (unsigned) bb->rbi->copy_number)\n+\t{\n+\t  allocate_ssa_names (definitions, &ssa_name_map);\n+\t  copy_number = bb->rbi->copy_number;\n+\t}\n+\n+      rewrite_to_new_ssa_names_bb (bb, ssa_name_map);\n+    }\n+\n+  htab_delete (ssa_name_map);\n+}\n+\n+/* Sets SSA_NAME_DEF_STMT for results of all phi nodes in BB.  */\n+\n+static void\n+set_phi_def_stmts (basic_block bb)\n+{\n+  tree phi;\n+\n+  for (phi = phi_nodes (bb); phi; phi = TREE_CHAIN (phi))\n+    SSA_NAME_DEF_STMT (PHI_RESULT (phi)) = phi;\n+}\n+\n+/* The same ad cfgloopmanip.c:duplicate_loop_to_header_edge, but also updates\n+   ssa.  In order to achieve this, only loops whose exits all lead to the same\n+   location are handled.\n+   \n+   FIXME: we create some degenerate phi nodes that could be avoided by copy\n+   propagating them instead.  Unfortunately this is not completely\n+   straightforward due to problems with constant folding.  */\n+\n+bool\n+tree_duplicate_loop_to_header_edge (struct loop *loop, edge e,\n+\t\t\t\t    struct loops *loops,\n+\t\t\t\t    unsigned int ndupl, sbitmap wont_exit,\n+\t\t\t\t    edge orig, edge *to_remove,\n+\t\t\t\t    unsigned int *n_to_remove, int flags)\n+{\n+  unsigned first_new_block;\n+  basic_block bb;\n+  unsigned i;\n+  tree phi, arg, map, def;\n+  bitmap definitions;\n+\n+  if (!(loops->state & LOOPS_HAVE_SIMPLE_LATCHES))\n+    return false;\n+  if (!(loops->state & LOOPS_HAVE_PREHEADERS))\n+    return false;\n+\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+\n+  gcc_assert (!any_marked_for_rewrite_p ());\n+\n+  first_new_block = last_basic_block;\n+  if (!duplicate_loop_to_header_edge (loop, e, loops, ndupl, wont_exit,\n+\t\t\t\t      orig, to_remove, n_to_remove, flags))\n+    return false;\n+\n+  /* Readd the removed phi args for e.  */\n+  map = PENDING_STMT (e);\n+  PENDING_STMT (e) = NULL;\n+\n+  for (phi = phi_nodes (e->dest), arg = map;\n+       phi;\n+       phi = TREE_CHAIN (phi), arg = TREE_CHAIN (arg))\n+    {\n+      def = TREE_VALUE (arg);\n+      add_phi_arg (&phi, def, e);\n+    }\n+  gcc_assert (arg == NULL);\n+\n+  /* Copy the phi node arguments.  */\n+  copy_phi_node_args (first_new_block);\n+\n+  /* Rename the variables.  */\n+  definitions = marked_ssa_names ();\n+  rename_variables (first_new_block, definitions);\n+  unmark_all_for_rewrite ();\n+  BITMAP_XFREE (definitions);\n+\n+  /* For some time we have the identical ssa names as results in multiple phi\n+     nodes.  When phi node is resized, it sets SSA_NAME_DEF_STMT of its result\n+     to the new copy.  This means that we cannot easily ensure that the ssa\n+     names defined in those phis are pointing to the right one -- so just\n+     recompute SSA_NAME_DEF_STMT for them.  */ \n+\n+  for (i = first_new_block; i < (unsigned) last_basic_block; i++)\n+    {\n+      bb = BASIC_BLOCK (i);\n+      set_phi_def_stmts (bb);\n+      if (bb->rbi->copy_number == 1)\n+  \tset_phi_def_stmts (bb->rbi->original);\n+    }\n+\n+  scev_reset ();\n+#ifdef ENABLE_CHECKING\n+  verify_loop_closed_ssa ();\n+#endif\n+\n+  return true;\n+}\n+\n+/*---------------------------------------------------------------------------\n+  Loop versioning\n+  ---------------------------------------------------------------------------*/\n+ \n+/* Adjust phi nodes for 'first' basic block.  'second' basic block is a copy\n+   of 'first'. Both of them are dominated by 'new_head' basic block. When\n+   'new_head' was created by 'second's incoming edge it received phi arguments\n+   on the edge by split_edge(). Later, additional edge 'e' was created to\n+   connect 'new_head' and 'first'. Now this routine adds phi args on this \n+   additional edge 'e' that new_head to second edge received as part of edge \n+   splitting.\n+*/\n+\n+static void\n+lv_adjust_loop_header_phi (basic_block first, basic_block second,\n+\t\t\t   basic_block new_head, edge e)\n+{\n+  tree phi1, phi2;\n+\n+  /* Browse all 'second' basic block phi nodes and add phi args to\n+     edge 'e' for 'first' head. PHI args are always in correct order.  */\n+\n+  for (phi2 = phi_nodes (second), phi1 = phi_nodes (first); \n+       phi2 && phi1; \n+       phi2 = TREE_CHAIN (phi2),  phi1 = TREE_CHAIN (phi1))\n+    {\n+      int i;\n+      for (i = 0; i < PHI_NUM_ARGS (phi2); i++)\n+\t{\n+\t  if (PHI_ARG_EDGE (phi2, i)->src == new_head)\n+\t    {\n+\t      tree def = PHI_ARG_DEF (phi2, i);\n+\t      add_phi_arg (&phi1, def, e);\n+\t    }\n+\t}\n+    }\n+}\n+\n+/* Adjust entry edge for lv.\n+   \n+  e is a incoming edge. \n+\n+  --- edge e ---- > [second_head]\n+\n+  Split it and insert new conditional expression and adjust edges.\n+   \n+   --- edge e ---> [cond expr] ---> [first_head]\n+                        |\n+                        +---------> [second_head]\n+\n+*/\n+   \n+static basic_block\n+lv_adjust_loop_entry_edge (basic_block first_head,\n+\t\t\t   basic_block second_head,\n+\t\t\t   edge e,\n+\t\t\t   tree cond_expr)\n+{ \n+  block_stmt_iterator bsi;\n+  basic_block new_head = NULL;\n+  tree goto1 = NULL_TREE;\n+  tree goto2 = NULL_TREE;\n+  tree new_cond_expr = NULL_TREE;\n+  edge e0, e1;\n+\n+  gcc_assert (e->dest == second_head);\n+\n+  /* Split edge 'e'. This will create a new basic block, where we can\n+     insert conditional expr.  */\n+  new_head = split_edge (e);\n+\n+  /* Build new conditional expr */\n+  goto1 = build1 (GOTO_EXPR, void_type_node, tree_block_label (first_head));\n+  goto2 = build1 (GOTO_EXPR, void_type_node, tree_block_label (second_head));\n+  new_cond_expr = build3 (COND_EXPR, void_type_node, cond_expr, goto1, goto2);\n+\n+  /* Add new cond. in new head.  */ \n+  bsi = bsi_start (new_head); \n+  bsi_insert_after (&bsi, new_cond_expr, BSI_NEW_STMT);\n+\n+  /* Adjust edges appropriately to connect new head with first head\n+     as well as second head.  */\n+  e0 = new_head->succ;\n+  e0->flags &= ~EDGE_FALLTHRU;\n+  e0->flags |= EDGE_FALSE_VALUE;\n+  e1 = make_edge (new_head, first_head, EDGE_TRUE_VALUE);\n+  set_immediate_dominator (CDI_DOMINATORS, first_head, new_head);\n+  set_immediate_dominator (CDI_DOMINATORS, second_head, new_head);\n+\n+  /* Adjust loop header phi nodes.  */\n+  lv_adjust_loop_header_phi (first_head, second_head, new_head, e1);\n+\n+  return new_head;\n+}\n+\n+/* Add phi args using PENDINT_STMT list.  */\n+\n+static void\n+lv_update_pending_stmts (edge e)\n+{\n+  basic_block dest;\n+  tree phi, arg, def;\n+\n+  if (!PENDING_STMT (e))\n+    return;\n+\n+  dest = e->dest;\n+\n+  for (phi = phi_nodes (dest), arg = PENDING_STMT (e);\n+       phi;\n+       phi = TREE_CHAIN (phi), arg = TREE_CHAIN (arg))\n+    {\n+      def = TREE_VALUE (arg);\n+      add_phi_arg (&phi, def, e);\n+    }\n+\n+  PENDING_STMT (e) = NULL;\n+}\n+\n+\n+/* Main entry point for Loop Versioning transformation.\n+   \n+This transformation given a condition and a loop, creates\n+-if (condition) { loop_copy1 } else { loop_copy2 },\n+where loop_copy1 is the loop transformed in one way, and loop_copy2\n+is the loop transformed in another way (or unchanged). 'condition'\n+may be a run time test for things that were not resolved by static\n+analysis (overlapping ranges (anti-aliasing), alignment, etc.).  */\n+\n+struct loop *\n+tree_ssa_loop_version (struct loops *loops, struct loop * loop, \n+\t\t       tree cond_expr, basic_block *condition_bb)\n+{\n+  edge entry, latch_edge, exit;\n+  basic_block first_head, second_head;\n+  int irred_flag;\n+  struct loop *nloop;\n+\n+  /* CHECKME: Loop versioning does not handle nested loop at this point.  */\n+  if (loop->inner)\n+    return NULL;\n+\n+  /* Record entry and latch edges for the loop */\n+  entry = loop_preheader_edge (loop);\n+\n+  /* Note down head of loop as first_head.  */\n+  first_head = entry->dest;\n+\n+  /* Duplicate loop.  */\n+  irred_flag = entry->flags & EDGE_IRREDUCIBLE_LOOP;\n+  entry->flags &= ~EDGE_IRREDUCIBLE_LOOP;\n+  if (!tree_duplicate_loop_to_header_edge (loop, entry, loops, 1,\n+\t\t\t\t\t   NULL, NULL, NULL, NULL, 0))\n+    {\n+      entry->flags |= irred_flag;\n+      return NULL;\n+    }\n+\n+  /* After duplication entry edge now points to new loop head block.\n+     Note down new head as second_head.  */\n+  second_head = entry->dest;\n+\n+  /* Split loop entry edge and insert new block with cond expr.  */\n+  *condition_bb = lv_adjust_loop_entry_edge (first_head, second_head, entry, \n+\t\t\t\t\t    cond_expr); \n+\n+  latch_edge = loop->latch->rbi->copy->succ;\n+  nloop = loopify (loops, \n+\t\t   latch_edge,\n+\t\t   loop->header->rbi->copy->pred,\n+\t\t   *condition_bb,\n+\t\t   false /* Do not redirect all edges.  */);\n+\n+  exit = loop->single_exit;\n+  if (exit)\n+    nloop->single_exit = find_edge (exit->src->rbi->copy, exit->dest);\n+\n+  /* loopify redirected latch_edge. Update its PENDING_STMTS.  */ \n+  lv_update_pending_stmts (latch_edge);\n+\n+  /* loopify redirected condition_bb's succ edge. Update its PENDING_STMTS.  */ \n+  lv_update_pending_stmts (FALLTHRU_EDGE (*condition_bb));\n+\n+  /* Adjust irreducible flag.  */\n+  if (irred_flag)\n+    {\n+      (*condition_bb)->flags |= BB_IRREDUCIBLE_LOOP;\n+      loop_preheader_edge (loop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      loop_preheader_edge (nloop)->flags |= EDGE_IRREDUCIBLE_LOOP;\n+      (*condition_bb)->pred->flags |= EDGE_IRREDUCIBLE_LOOP;\n+    }\n+\n+  /* At this point condition_bb is loop predheader with two successors, \n+     first_head and second_head.   Make sure that loop predheader has only \n+     one successor. */\n+  loop_split_edge_with (loop_preheader_edge (loop), NULL);\n+  loop_split_edge_with (loop_preheader_edge (nloop), NULL);\n+\n+  return nloop;\n+}"}, {"sha": "45b7e87a229f05cdd10ab825172b5048c48f333c", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "added", "additions": 293, "deletions": 0, "changes": 293, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -0,0 +1,293 @@\n+/* Loop unswitching.\n+   Copyright (C) 2004 Free Software Foundation, Inc.\n+   \n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"rtl.h\"\n+#include \"tm_p.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"output.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-dump.h\"\n+#include \"timevar.h\"\n+#include \"cfgloop.h\"\n+#include \"domwalk.h\"\n+#include \"params.h\"\n+#include \"tree-pass.h\"\n+\n+/* This file implements the loop unswitching, i.e. transformation of loops like\n+\n+   while (A)\n+     {\n+       if (inv)\n+         B;\n+\n+       X;\n+\n+       if (!inv)\n+\t C;\n+     }\n+\n+   where inv is the loop invariant, into\n+\n+   if (inv)\n+     {\n+       while (A)\n+\t {\n+           B;\n+\t   X;\n+\t }\n+     }\n+   else\n+     {\n+       while (A)\n+\t {\n+\t   X;\n+\t   C;\n+\t }\n+     }\n+\n+   Inv is considered invariant iff the values it compares are both invariant;\n+   tree-ssa-loop-im.c ensures that all the suitable conditions are in this\n+   shape.  */\n+\n+static struct loop *tree_unswitch_loop (struct loops *, struct loop *, basic_block,\n+\t\t\t\t   tree);\n+static bool tree_unswitch_single_loop (struct loops *, struct loop *, int);\n+static tree tree_may_unswitch_on (basic_block, struct loop *);\n+\n+/* Main entry point.  Perform loop unswitching on all suitable LOOPS.  */\n+\n+void\n+tree_ssa_unswitch_loops (struct loops *loops)\n+{\n+  int i, num;\n+  struct loop *loop;\n+  bool changed = false;\n+\n+  /* Go through inner loops (only original ones).  */\n+  num = loops->num;\n+\n+  for (i = 1; i < num; i++)\n+    {\n+      /* Removed loop?  */\n+      loop = loops->parray[i];\n+      if (!loop)\n+\tcontinue;\n+\n+      if (loop->inner)\n+\tcontinue;\n+\n+      changed |= tree_unswitch_single_loop (loops, loop, 0);\n+#ifdef ENABLE_CHECKING\n+      verify_dominators (CDI_DOMINATORS);\n+      verify_loop_structure (loops);\n+#endif\n+    }\n+\n+#if 0\n+  /* The necessary infrastructure is not in yet.  */\n+  if (changed)\n+    cleanup_tree_cfg_loop ();\n+#endif\n+}\n+\n+/* Checks whether we can unswitch LOOP on condition at end of BB -- one of its\n+   basic blocks (for what it means see comments below).  */\n+\n+static tree\n+tree_may_unswitch_on (basic_block bb, struct loop *loop)\n+{\n+  tree stmt, def, cond;\n+  basic_block def_bb;\n+  use_optype uses;\n+  unsigned i;\n+\n+  /* BB must end in a simple conditional jump.  */\n+  stmt = last_stmt (bb);\n+  if (!stmt || TREE_CODE (stmt) != COND_EXPR)\n+    return NULL_TREE;\n+\n+  /* Condition must be invariant.  */\n+  get_stmt_operands (stmt);\n+  uses = STMT_USE_OPS (stmt);\n+  for (i = 0; i < NUM_USES (uses); i++)\n+    {\n+      def = SSA_NAME_DEF_STMT (USE_OP (uses, i));\n+      def_bb = bb_for_stmt (def);\n+      if (def_bb\n+\t  && flow_bb_inside_loop_p (loop, def_bb))\n+\treturn NULL_TREE;\n+    }\n+\n+  cond = COND_EXPR_COND (stmt);\n+  /* To keep the things simple, we do not directly remove the conditions,\n+     but just replace tests with 0/1.  Prevent the infinite loop where we\n+     would unswitch again on such a condition.  */\n+  if (integer_zerop (cond) || integer_nonzerop (cond))\n+    return NULL_TREE;\n+\n+  return cond;\n+}\n+\n+/* Simplifies COND using checks in front of the entry of the LOOP.  Just very\n+   simplish (sufficient to prevent us from duplicating loop in unswitching\n+   unneccesarily).  */\n+\n+static tree\n+simplify_using_entry_checks (struct loop *loop, tree cond)\n+{\n+  edge e = loop_preheader_edge (loop);\n+  tree stmt;\n+\n+  while (1)\n+    {\n+      stmt = last_stmt (e->src);\n+      if (stmt\n+\t  && TREE_CODE (stmt) == COND_EXPR\n+\t  && operand_equal_p (COND_EXPR_COND (stmt), cond, 0))\n+\treturn (e->flags & EDGE_TRUE_VALUE\n+\t\t? boolean_true_node\n+\t\t: boolean_false_node);\n+\n+      if (e->src->pred->pred_next)\n+\treturn cond;\n+\n+      e = e->src->pred;\n+      if (e->src == ENTRY_BLOCK_PTR)\n+\treturn cond;\n+    }\n+}\n+\n+/* Unswitch single LOOP.  NUM is number of unswitchings done; we do not allow\n+   it to grow too much, it is too easy to create example on that the code would\n+   grow exponentially.  */\n+\n+static bool\n+tree_unswitch_single_loop (struct loops *loops, struct loop *loop, int num)\n+{\n+  basic_block *bbs;\n+  struct loop *nloop;\n+  unsigned i;\n+  tree cond = NULL_TREE, stmt;\n+  bool changed = false;\n+\n+  /* Do not unswitch too much.  */\n+  if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n+      return false;\n+    }\n+\n+  /* Only unswitch innermost loops.  */\n+  if (loop->inner)\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \";; Not unswitching, not innermost loop\\n\");\n+      return false;\n+    }\n+\n+  /* The loop should not be too large, to limit code growth.  */\n+  if (tree_num_loop_insns (loop)\n+      > (unsigned) PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n+    {\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\tfprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n+      return false;\n+    }\n+\n+  i = 0;\n+  bbs = get_loop_body (loop);\n+  \n+  while (1)\n+    {\n+      /* Find a bb to unswitch on.  */\n+      for (; i < loop->num_nodes; i++)\n+\tif ((cond = tree_may_unswitch_on (bbs[i], loop)))\n+\t  break;\n+\n+      if (i == loop->num_nodes)\n+\t{\n+\t  free (bbs);\n+\t  return changed;\n+\t}\n+\n+      cond = simplify_using_entry_checks (loop, cond);\n+      stmt = last_stmt (bbs[i]);\n+      if (integer_nonzerop (cond))\n+\t{\n+\t  /* Remove false path.  */\n+\t  COND_EXPR_COND (stmt) = boolean_true_node;\n+\t  changed = true;\n+\t}\n+      else if (integer_zerop (cond))\n+\t{\n+\t  /* Remove true path.  */\n+\t  COND_EXPR_COND (stmt) = boolean_false_node;\n+\t  changed = true;\n+\t}\n+      else\n+\tbreak;\n+\n+      modify_stmt (stmt);\n+      i++;\n+    }\n+\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    fprintf (dump_file, \";; Unswitching loop\\n\");\n+\n+  /* Unswitch the loop on this condition.  */\n+  nloop = tree_unswitch_loop (loops, loop, bbs[i], cond);\n+  if (!nloop)\n+    return changed;\n+\n+  /* Invoke itself on modified loops.  */\n+  tree_unswitch_single_loop (loops, nloop, num + 1);\n+  tree_unswitch_single_loop (loops, loop, num + 1);\n+  return true;\n+}\n+\n+/* Unswitch a LOOP w.r. to given basic block UNSWITCH_ON.  We only support\n+   unswitching of innermost loops.  COND is the condition determining which\n+   loop is entered -- the new loop is entered if COND is true.  Returns NULL\n+   if impossible, new loop otherwise.  */\n+\n+static struct loop *\n+tree_unswitch_loop (struct loops *loops, struct loop *loop,\n+\t\t    basic_block unswitch_on, tree cond)\n+{\n+  basic_block condition_bb;\n+\n+  /* Some sanity checking.  */\n+  gcc_assert (flow_bb_inside_loop_p (loop, unswitch_on));\n+  gcc_assert (unswitch_on->succ != NULL);\n+  gcc_assert (unswitch_on->succ->succ_next != NULL);\n+  gcc_assert (unswitch_on->succ->succ_next->succ_next == NULL);\n+  gcc_assert (loop->inner == NULL);\n+\n+  return tree_ssa_loop_version (loops, loop, unshare_expr (cond), \n+\t\t\t\t&condition_bb);\n+}"}, {"sha": "19f784d9bbfb87285535ce972820e6123fbd2280", "filename": "gcc/tree-ssa-loop.c", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e/gcc%2Ftree-ssa-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop.c?ref=92fc4a2f399b92bf6f9ee3b50373216b01b1ca5e", "patch": "@@ -159,6 +159,40 @@ struct tree_opt_pass pass_lim =\n   0\t\t\t\t\t/* letter */\n };\n \n+/* Loop unswitching pass.  */\n+\n+static void\n+tree_ssa_loop_unswitch (void)\n+{\n+  if (!current_loops)\n+    return;\n+\n+  tree_ssa_unswitch_loops (current_loops);\n+}\n+\n+static bool\n+gate_tree_ssa_loop_unswitch (void)\n+{\n+  return flag_unswitch_loops != 0;\n+}\n+\n+struct tree_opt_pass pass_unswitch = \n+{\n+  \"unswitch\",\t\t\t\t/* name */\n+  gate_tree_ssa_loop_unswitch,\t\t/* gate */\n+  tree_ssa_loop_unswitch,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  TV_TREE_LOOP_UNSWITCH,\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func,                \t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n /* Loop autovectorization.  */\n \n static void"}]}