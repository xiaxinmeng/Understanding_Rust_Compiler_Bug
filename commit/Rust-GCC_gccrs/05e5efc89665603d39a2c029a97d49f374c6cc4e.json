{"sha": "05e5efc89665603d39a2c029a97d49f374c6cc4e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVlNWVmYzg5NjY1NjAzZDM5YTJjMDI5YTk3ZDQ5ZjM3NGM2Y2M0ZQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2017-05-09T10:22:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2017-05-09T10:22:27Z"}, "message": "tree-vrp.c (vrp_val_is_max): Adjust comment.\n\n2017-05-09  Richard Biener  <rguenther@suse.de>\n\n\t* tree-vrp.c (vrp_val_is_max): Adjust comment.\n\t(vrp_val_is_min): Likewise.\n\t(set_value_range_to_value): Likewise.\n\t(set_value_range_to_nonnegative): Likewise.\n\t(gimple_assign_nonzero_p): Likewise.\n\t(gimple_stmt_nonzero_p): Likewise.\n\t(vrp_int_const_binop): Likewise.  Remove unreachable case.\n\t(adjust_range_with_scev): Adjust comments.\n\t(compare_range_with_value): Likewise.\n\t(extract_range_from_phi_node): Likewise.\n\t(test_for_singularity): Likewise.\n\nFrom-SVN: r247783", "tree": {"sha": "e3221fed89efa7bd92fc7116ce29831cb5fa35ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e3221fed89efa7bd92fc7116ce29831cb5fa35ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05e5efc89665603d39a2c029a97d49f374c6cc4e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05e5efc89665603d39a2c029a97d49f374c6cc4e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05e5efc89665603d39a2c029a97d49f374c6cc4e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05e5efc89665603d39a2c029a97d49f374c6cc4e/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "fd71825b428daa5f466c8e3a26dbeace303e08f8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fd71825b428daa5f466c8e3a26dbeace303e08f8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fd71825b428daa5f466c8e3a26dbeace303e08f8"}], "stats": {"total": 85, "additions": 36, "deletions": 49}, "files": [{"sha": "5f02dc47ecd9d913e3e14afe53430a8f6216b44e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05e5efc89665603d39a2c029a97d49f374c6cc4e/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05e5efc89665603d39a2c029a97d49f374c6cc4e/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05e5efc89665603d39a2c029a97d49f374c6cc4e", "patch": "@@ -1,3 +1,17 @@\n+2017-05-09  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-vrp.c (vrp_val_is_max): Adjust comment.\n+\t(vrp_val_is_min): Likewise.\n+\t(set_value_range_to_value): Likewise.\n+\t(set_value_range_to_nonnegative): Likewise.\n+\t(gimple_assign_nonzero_p): Likewise.\n+\t(gimple_stmt_nonzero_p): Likewise.\n+\t(vrp_int_const_binop): Likewise.  Remove unreachable case.\n+\t(adjust_range_with_scev): Adjust comments.\n+\t(compare_range_with_value): Likewise.\n+\t(extract_range_from_phi_node): Likewise.\n+\t(test_for_singularity): Likewise.\n+\n 2017-05-09  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vrp.c (get_single_symbol): Add assert that we don't"}, {"sha": "0db8a3c39697f5088d0277e778c532d8cd85e9f4", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 22, "deletions": 49, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05e5efc89665603d39a2c029a97d49f374c6cc4e/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05e5efc89665603d39a2c029a97d49f374c6cc4e/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=05e5efc89665603d39a2c029a97d49f374c6cc4e", "patch": "@@ -185,11 +185,10 @@ vrp_val_min (const_tree type)\n   return TYPE_MIN_VALUE (type);\n }\n \n-/* Return whether VAL is equal to the maximum value of its type.  This\n-   will be true for a positive overflow infinity.  We can't do a\n-   simple equality comparison with TYPE_MAX_VALUE because C typedefs\n-   and Ada subtypes can produce types whose TYPE_MAX_VALUE is not ==\n-   to the integer constant with the same value in the type.  */\n+/* Return whether VAL is equal to the maximum value of its type.\n+   We can't do a simple equality comparison with TYPE_MAX_VALUE because\n+   C typedefs and Ada subtypes can produce types whose TYPE_MAX_VALUE\n+   is not == to the integer constant with the same value in the type.  */\n \n static inline bool\n vrp_val_is_max (const_tree val)\n@@ -200,8 +199,7 @@ vrp_val_is_max (const_tree val)\n \t      && operand_equal_p (val, type_max, 0)));\n }\n \n-/* Return whether VAL is equal to the minimum value of its type.  This\n-   will be true for a negative overflow infinity.  */\n+/* Return whether VAL is equal to the minimum value of its type.  */\n \n static inline bool\n vrp_val_is_min (const_tree val)\n@@ -412,8 +410,7 @@ copy_value_range (value_range *to, value_range *from)\n \n /* Set value range VR to a single value.  This function is only called\n    with values we get from statements, and exists to clear the\n-   TREE_OVERFLOW flag so that we don't think we have an overflow\n-   infinity when we shouldn't.  */\n+   TREE_OVERFLOW flag.  */\n \n static inline void\n set_value_range_to_value (value_range *vr, tree val, bitmap equiv)\n@@ -424,11 +421,7 @@ set_value_range_to_value (value_range *vr, tree val, bitmap equiv)\n   set_value_range (vr, VR_RANGE, val, val, equiv);\n }\n \n-/* Set value range VR to a non-negative range of type TYPE.\n-   OVERFLOW_INFINITY indicates whether to use an overflow infinity\n-   rather than TYPE_MAX_VALUE; this should be true if we determine\n-   that the range is nonnegative based on the assumption that signed\n-   overflow does not occur.  */\n+/* Set value range VR to a non-negative range of type TYPE.  */\n \n static inline void\n set_value_range_to_nonnegative (value_range *vr, tree type)\n@@ -853,10 +846,7 @@ symbolic_range_based_on_p (value_range *vr, const_tree sym)\n   return (min_has_symbol || max_has_symbol);\n }\n \n-/* Return true if the result of assignment STMT is know to be non-zero.\n-   If the return value is based on the assumption that signed overflow is\n-   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.*/\n+/* Return true if the result of assignment STMT is know to be non-zero.  */\n \n static bool\n gimple_assign_nonzero_p (gimple *stmt)\n@@ -888,10 +878,7 @@ gimple_assign_nonzero_p (gimple *stmt)\n     }\n }\n \n-/* Return true if STMT is known to compute a non-zero value.\n-   If the return value is based on the assumption that signed overflow is\n-   undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't change\n-   *STRICT_OVERFLOW_P.*/\n+/* Return true if STMT is known to compute a non-zero value.  */\n \n static bool\n gimple_stmt_nonzero_p (gimple *stmt)\n@@ -1610,10 +1597,11 @@ extract_range_from_ssa_name (value_range *vr, tree var)\n }\n \n \n-/* Wrapper around int_const_binop.  If the operation overflows and we\n-   are not using wrapping arithmetic, then adjust the result to be\n-   -INF or +INF depending on CODE, VAL1 and VAL2.  This can return\n-   NULL_TREE for division by zero.  */\n+/* Wrapper around int_const_binop.  If the operation overflows and\n+   overflow is undefined, then adjust the result to be\n+   -INF or +INF depending on CODE, VAL1 and VAL2.  Sets *OVERFLOW_P\n+   to whether the operation overflowed.  For division by zero\n+   the result is indeterminate but *OVERFLOW_P is set.  */\n \n static wide_int\n vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n@@ -1699,9 +1687,8 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n   if (overflow\n       && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (val1)))\n     {\n-      /* If the operation overflowed but neither VAL1 nor VAL2 are\n-\t overflown, return -INF or +INF depending on the operation\n-\t and the combination of signs of the operands.  */\n+      /* If the operation overflowed return -INF or +INF depending\n+\t on the operation and the combination of signs of the operands.  */\n       int sgn1 = tree_int_cst_sgn (val1);\n       int sgn2 = tree_int_cst_sgn (val2);\n \n@@ -1727,11 +1714,6 @@ vrp_int_const_binop (enum tree_code code, tree val1, tree val2,\n \t     as positive here, for the corner case 0 - (-INF), which\n \t     overflows, but must yield +INF.  */\n \t  || (code == MINUS_EXPR && sgn1 >= 0)\n-\t  /* We only get in here with positive shift count, so the\n-\t     overflow direction is the same as the sign of val1.\n-\t     Actually rshift does not overflow at all, but we only\n-\t     handle the case of shifting overflowed -INF and +INF.  */\n-\t  || (code == RSHIFT_EXPR && sgn1 >= 0)\n \t  /* For division, the only case is -INF / -1 = +INF.  */\n \t  || code == TRUNC_DIV_EXPR\n \t  || code == FLOOR_DIV_EXPR\n@@ -4015,11 +3997,6 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n \t\t\t\tget_chrec_loop (chrec), true))\n     return;\n \n-  /* We use TYPE_MIN_VALUE and TYPE_MAX_VALUE here instead of\n-     negative_overflow_infinity and positive_overflow_infinity,\n-     because we have concluded that the loop probably does not\n-     wrap.  */\n-\n   type = TREE_TYPE (var);\n   if (POINTER_TYPE_P (type) || !TYPE_MIN_VALUE (type))\n     tmin = lower_bound_in_type (type, type);\n@@ -4164,8 +4141,8 @@ adjust_range_with_scev (value_range *vr, struct loop *loop,\n    - Return NULL_TREE if it is not always possible to determine the\n      value of the comparison.\n \n-   Also set *STRICT_OVERFLOW_P to indicate whether a range with an\n-   overflow infinity was used in the test.  */\n+   Also set *STRICT_OVERFLOW_P to indicate whether comparision evaluation\n+   assumed signed overflow is undefined.  */\n \n \n static tree\n@@ -4305,8 +4282,8 @@ compare_ranges (enum tree_code comp, value_range *vr0, value_range *vr1,\n    values in VR.  Return BOOLEAN_FALSE_NODE if the comparison\n    always returns false.  Return NULL_TREE if it is not always\n    possible to determine the value of the comparison.  Also set\n-   *STRICT_OVERFLOW_P to indicate whether a range with an overflow\n-   infinity was used in the test.  */\n+   *STRICT_OVERFLOW_P to indicate whether comparision evaluation\n+   assumed signed overflow is undefined.  */\n \n static tree\n compare_range_with_value (enum tree_code comp, value_range *vr, tree val,\n@@ -7246,7 +7223,7 @@ compare_name_with_value (enum tree_code comp, tree var, tree val,\n    ranges equivalent to N1 against all the ranges equivalent to N2\n    to determine the value of N1 COMP N2.  Return the same value\n    returned by compare_ranges.  Set *STRICT_OVERFLOW_P to indicate\n-   whether we relied on an overflow infinity in the comparison.  */\n+   whether we relied on undefined signed overflow in the comparison.  */\n \n \n static tree\n@@ -8952,7 +8929,7 @@ extract_range_from_phi_node (gphi *phi, value_range *vr_result)\n   /* To prevent infinite iterations in the algorithm, derive ranges\n      when the new value is slightly bigger or smaller than the\n      previous one.  We don't do this if we have seen a new executable\n-     edge; this helps us avoid an overflow infinity for conditionals\n+     edge; this helps us avoid an infinity for conditionals\n      which are not in a loop.  If the old value-range was VR_UNDEFINED\n      use the updated range and iterate one more time.  If we will not\n      simulate this PHI again via the backedge allow us to iterate.  */\n@@ -9476,8 +9453,6 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n      written.  */\n   if (cond_code == LE_EXPR || cond_code == LT_EXPR)\n     {\n-      /* This should not be negative infinity; there is no overflow\n-\t here.  */\n       min = TYPE_MIN_VALUE (TREE_TYPE (op0));\n \n       max = op1;\n@@ -9492,8 +9467,6 @@ test_for_singularity (enum tree_code cond_code, tree op0,\n     }\n   else if (cond_code == GE_EXPR || cond_code == GT_EXPR)\n     {\n-      /* This should not be positive infinity; there is no overflow\n-\t here.  */\n       max = TYPE_MAX_VALUE (TREE_TYPE (op0));\n \n       min = op1;"}]}