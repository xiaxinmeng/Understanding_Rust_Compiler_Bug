{"sha": "cae40af6efc85015875dbf8e5e2210b72d86817a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2FlNDBhZjZlZmM4NTAxNTg3NWRiZjhlNWUyMjEwYjcyZDg2ODE3YQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-15T19:53:08Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-03-15T19:53:08Z"}, "message": "cp-tree.h (TEMPLATE_PARMS_FOR_INLINE): New macro.\n\n\t* cp-tree.h (TEMPLATE_PARMS_FOR_INLINE): New macro.\n\t* pt.c (inline_needs_template_parms): New fn.\n\t(original_template): New fn.\n\t(push_inline_template_parms_recursive): New fn.\n\t(maybe_begin_member_template_processing): Use them.\n\t(maybe_end_member_template_processing): Likewise.\n\t(is_member_or_friend_template): Rename to is_member_template.\n\tMember functions of local classes are never member templates.\n\t* lex.c (do_identifier): Handle TEMPLATE_DECL that was\n\tadded in the class scope to catch redefinition error.\n\t* pt.c (reduce_template_parm_level): Also copy\n\tthe DECL_TEMPLATE_PARMS field.\n\nFrom-SVN: r18595", "tree": {"sha": "2a8621eaf504c708241d915989f17d6f255cce84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2a8621eaf504c708241d915989f17d6f255cce84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cae40af6efc85015875dbf8e5e2210b72d86817a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae40af6efc85015875dbf8e5e2210b72d86817a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cae40af6efc85015875dbf8e5e2210b72d86817a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cae40af6efc85015875dbf8e5e2210b72d86817a/comments", "author": null, "committer": null, "parents": [{"sha": "debf0b88ab260279da12f41a5c7dfea59be6c036", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/debf0b88ab260279da12f41a5c7dfea59be6c036", "html_url": "https://github.com/Rust-GCC/gccrs/commit/debf0b88ab260279da12f41a5c7dfea59be6c036"}], "stats": {"total": 163, "additions": 117, "deletions": 46}, "files": [{"sha": "9b47256da9c276faf21e17a57313a1368e324bd6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 23, "deletions": 2, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=cae40af6efc85015875dbf8e5e2210b72d86817a", "patch": "@@ -1,3 +1,22 @@\n+Sun Mar 15 02:07:26 1998  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cp-tree.h (TEMPLATE_PARMS_FOR_INLINE): New macro.\n+\t* pt.c (inline_needs_template_parms): New fn.\n+\t(original_template): New fn.\n+\t(push_inline_template_parms_recursive): New fn.\n+\t(maybe_begin_member_template_processing): Use them.\n+\t(maybe_end_member_template_processing): Likewise.\n+\t(is_member_or_friend_template): Rename to is_member_template.\n+\tMember functions of local classes are never member templates.\n+\n+Sun Mar 15 01:14:22 1998  Kriang Lerdsuwanakij  <lerdsuwa@scf.usc.edu>\n+\n+\t* lex.c (do_identifier): Handle TEMPLATE_DECL that was\n+\tadded in the class scope to catch redefinition error.\n+\n+\t* pt.c (reduce_template_parm_level): Also copy \n+\tthe DECL_TEMPLATE_PARMS field.\n+\n Sun Mar 15 10:54:08 1998  Mark Mitchell  <mmitchell@usa.net>\n \n \t* pt.c (tsubst): Clear TYPE_REFERENCE_TO when creating a\n@@ -15,7 +34,8 @@ Sun Mar 15 12:26:02 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \t\n Thu Mar 12 09:39:40 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \n-\t* lang-specs.h: Properly put brackets around array elements in initializer.\n+\t* lang-specs.h: Properly put brackets around array elements in \n+\tinitializer.\n \n \t* typeck.c (build_binary_op_nodefault): Correctly place parens around\n \t&& and || in expression.\n@@ -32,7 +52,8 @@ Thu Mar 12 09:26:04 1998  Manfred Hollstein  <manfred@s-direktnet.de>\n \t* except.c (do_unwind): #if 0 definition of unused variables fcall\n \tand next_pc.\n \n-\t* expr.c (extract_scalar_init): #if 0 prototype and function definition.\n+\t* expr.c (extract_scalar_init): #if 0 prototype and function \n+\tdefinition.\n \n \t* init.c (expand_aggr_init_1): Remove unused variable init_type.\n \t(build_new_1): Remove unused variable t."}, {"sha": "0e9f9d844ef130f60140dc02d3a4b02c586cdd9d", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=cae40af6efc85015875dbf8e5e2210b72d86817a", "patch": "@@ -1157,6 +1157,8 @@ struct lang_decl\n #define CLASSTYPE_TI_SPEC_INFO(NODE) TI_SPEC_INFO (CLASSTYPE_TEMPLATE_INFO (NODE))\n #define INNERMOST_TEMPLATE_PARMS(NODE)  TREE_VALUE(NODE)\n \n+#define TEMPLATE_PARMS_FOR_INLINE(NODE) TREE_LANG_FLAG_1 (NODE)\n+\n #define DECL_SAVED_TREE(NODE)\t\tDECL_MEMFUNC_POINTER_TO (NODE)\n #define COMPOUND_STMT_NO_SCOPE(NODE)\tTREE_LANG_FLAG_0 (NODE)\n #define NEW_EXPR_USE_GLOBAL(NODE)\tTREE_LANG_FLAG_0 (NODE)"}, {"sha": "26c9221c327959970b6f87783c1a0fdf7109efe9", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=cae40af6efc85015875dbf8e5e2210b72d86817a", "patch": "@@ -2811,7 +2811,8 @@ do_identifier (token, parsing)\n \t   But we still want to return this value.  */\n \tid = lookup_field (current_class_type, token, 0, 0);\n       else if (TREE_CODE (field) == VAR_DECL\n-\t       || TREE_CODE (field) == CONST_DECL)\n+\t       || TREE_CODE (field) == CONST_DECL\n+\t       || TREE_CODE (field) == TEMPLATE_DECL)\n \tid = field;\n       else if (TREE_CODE (field) != FIELD_DECL)\n \tmy_friendly_abort (61);"}, {"sha": "52a4254576355f14ac1b1ac7e4eaa77cc305f758", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 90, "deletions": 43, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cae40af6efc85015875dbf8e5e2210b72d86817a/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=cae40af6efc85015875dbf8e5e2210b72d86817a", "patch": "@@ -86,7 +86,6 @@ static int  type_unification_real PROTO((tree, tree *, tree, tree,\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n static tree convert_nontype_argument PROTO((tree, tree));\n-static int is_member_or_friend_template PROTO((tree, int));\n \n /* Do any processing required when DECL (a member template declaration\n    using TEMPLATE_PARAMETERS as its innermost parameter list) is\n@@ -164,31 +163,60 @@ template_class_depth (type)\n   return depth;\n }\n \n-/* Restore the template parameter context for a member template or\n-   a friend template defined in a class definition.  */\n+/* Return the original template for this decl, disregarding any\n+   specializations.  */\n \n-void \n-maybe_begin_member_template_processing (decl)\n+static tree\n+original_template (decl)\n      tree decl;\n {\n-  tree parms;\n-  int i;\n+  while (DECL_TEMPLATE_INFO (decl))\n+    decl = DECL_TI_TEMPLATE (decl);\n+  return decl;\n+}\n \n-  if (!is_member_or_friend_template (decl, 1))\n-    return;\n+/* Returns 1 if processing DECL as part of do_pending_inlines\n+   needs us to push template parms.  */\n+\n+static int\n+inline_needs_template_parms (decl)\n+     tree decl;\n+{\n+  if (! DECL_TEMPLATE_INFO (decl))\n+    return 0;\n+\n+  return (list_length (DECL_TEMPLATE_PARMS (original_template (decl)))\n+\t  > (processing_template_decl + DECL_TEMPLATE_SPECIALIZATION (decl)));\n+}\n \n-  parms = DECL_INNERMOST_TEMPLATE_PARMS (DECL_TI_TEMPLATE (decl));\n+/* Subroutine of maybe_begin_member_template_processing.\n+   Push the template parms in PARMS, starting from LEVELS steps into the\n+   chain, and ending at the beginning, since template parms are listed\n+   innermost first.  */\n+\n+static void\n+push_inline_template_parms_recursive (parmlist, levels)\n+     tree parmlist;\n+     int levels;\n+{\n+  tree parms = TREE_VALUE (parmlist);\n+  int i;\n+\n+  if (levels > 1)\n+    push_inline_template_parms_recursive (TREE_CHAIN (parmlist), levels - 1);\n \n   ++processing_template_decl;\n-  current_template_parms \n+  current_template_parms\n     = tree_cons (build_int_2 (0, processing_template_decl),\n \t\t parms, current_template_parms);\n+  TEMPLATE_PARMS_FOR_INLINE (current_template_parms) = 1;\n+\n   pushlevel (0);\n   for (i = 0; i < TREE_VEC_LENGTH (parms); ++i) \n     {\n       tree parm = TREE_VALUE (TREE_VEC_ELT (parms, i));\n       my_friendly_assert (TREE_CODE_CLASS (TREE_CODE (parm)) == 'd', 0);\n-      \n+\n       switch (TREE_CODE (parm))\n \t{\n \tcase TYPE_DECL:\n@@ -204,33 +232,59 @@ maybe_begin_member_template_processing (decl)\n \t    DECL_INITIAL (decl) = DECL_INITIAL (parm);\n \t    pushdecl (decl);\n \t  }\n-\tbreak;\n+\t  break;\n \n \tdefault:\n \t  my_friendly_abort (0);\n \t}\n     }\n }\n \n+/* Restore the template parameter context for a member template or\n+   a friend template defined in a class definition.  */\n+\n+void\n+maybe_begin_member_template_processing (decl)\n+     tree decl;\n+{\n+  tree parms;\n+  int levels;\n+\n+  if (! inline_needs_template_parms (decl))\n+    return;\n+\n+  parms = DECL_TEMPLATE_PARMS (original_template (decl));\n+\n+  levels = list_length (parms) - processing_template_decl;\n+\n+  if (DECL_TEMPLATE_SPECIALIZATION (decl))\n+    {\n+      --levels;\n+      parms = TREE_CHAIN (parms);\n+    }\n+\n+  push_inline_template_parms_recursive (parms, levels);\n+}\n+\n /* Undo the effects of begin_member_template_processing. */\n \n void \n maybe_end_member_template_processing (decl)\n      tree decl;\n {\n-  if (!is_member_or_friend_template (decl, 1))\n-    return;\n-\n   if (! processing_template_decl)\n     return;\n \n-  --processing_template_decl;\n-  current_template_parms = TREE_CHAIN (current_template_parms);\n-  poplevel (0, 0, 0);\n+  while (current_template_parms\n+\t && TEMPLATE_PARMS_FOR_INLINE (current_template_parms))\n+    {\n+      --processing_template_decl;\n+      current_template_parms = TREE_CHAIN (current_template_parms);\n+      poplevel (0, 0, 0);\n+    }\n }\n \n-/* Returns non-zero iff T is a member template function, or, if\n-   ALLOW_FRIEND is non-zero, a friend template function.  We must be\n+/* Returns non-zero iff T is a member template function.  We must be\n    careful as in\n \n      template <class T> class C { void f(); }\n@@ -244,26 +298,24 @@ maybe_end_member_template_processing (decl)\n    then neither C<int>::f<char> nor C<T>::f<double> is considered\n    to be a member template.  */\n \n-static int\n-is_member_or_friend_template (t, allow_friend)\n+int\n+is_member_template (t)\n      tree t;\n-     int allow_friend;\n {\n   if (TREE_CODE (t) != FUNCTION_DECL\n       && !DECL_FUNCTION_TEMPLATE_P (t))\n     /* Anything that isn't a function or a template function is\n        certainly not a member template.  */\n     return 0;\n \n-  if (((DECL_FUNCTION_MEMBER_P (t) \n-\t|| (allow_friend && DECL_FRIEND_P (t)))\n+  /* A local class can't have member templates.  */\n+  if (hack_decl_function_context (t))\n+    return 0;\n+\n+  if ((DECL_FUNCTION_MEMBER_P (t) \n        && !DECL_TEMPLATE_SPECIALIZATION (t))\n       || (TREE_CODE (t) == TEMPLATE_DECL \n-\t  && (DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))\n-\t      || (allow_friend\n-\t\t  && DECL_FUNCTION_TEMPLATE_P (t) \n-\t\t  && DECL_FRIEND_P (DECL_TEMPLATE_RESULT (t))\n-\t\t  && DECL_CLASS_CONTEXT (t)))))\n+\t  && DECL_FUNCTION_MEMBER_P (DECL_TEMPLATE_RESULT (t))))\n     {\n       tree tmpl;\n \n@@ -275,27 +327,18 @@ is_member_or_friend_template (t, allow_friend)\n       else\n \ttmpl = NULL_TREE;\n \n-      if (tmpl && \n+      if (tmpl\n \t  /* If there are more levels of template parameters than\n \t     there are template classes surrounding the declaration,\n \t     then we have a member template.  */\n-\t  list_length (DECL_TEMPLATE_PARMS (tmpl)) > \n-\t  template_class_depth (DECL_CLASS_CONTEXT (t)))\n+\t  && (list_length (DECL_TEMPLATE_PARMS (tmpl)) > \n+\t      template_class_depth (DECL_CLASS_CONTEXT (t))))\n \treturn 1;\n     }\n \n   return 0;\n }\n \n-/* Returns non-zero iff T is a member template.  */\n-\n-int\n-is_member_template (t)\n-     tree t;\n-{\n-  return is_member_or_friend_template (t, 0);\n-}\n-\n /* Return a new template argument vector which contains all of ARGS,\n    but has as its innermost set of arguments the EXTRA_ARGS.  */\n \n@@ -1092,6 +1135,10 @@ reduce_template_parm_level (index, type, levels)\n \t\t\t\t     TEMPLATE_PARM_ORIG_LEVEL (index),\n \t\t\t\t     decl, type);\n       TEMPLATE_PARM_DESCENDANTS (index) = t;\n+\n+      /* Template template parameters need this.  */\n+      DECL_TEMPLATE_PARMS (decl)\n+\t= DECL_TEMPLATE_PARMS (TEMPLATE_PARM_DECL (index));\n     }\n \n   return TEMPLATE_PARM_DESCENDANTS (index);"}]}