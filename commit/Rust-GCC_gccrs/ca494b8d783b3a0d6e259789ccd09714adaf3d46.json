{"sha": "ca494b8d783b3a0d6e259789ccd09714adaf3d46", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2E0OTRiOGQ3ODNiM2EwZDZlMjU5Nzg5Y2NkMDk3MTRhZGFmM2Q0Ng==", "commit": {"author": {"name": "Christian Bruel", "email": "christian.bruel@st.com", "date": "2013-10-30T12:35:27Z"}, "committer": {"name": "Christian Bruel", "email": "chrbr@gcc.gnu.org", "date": "2013-10-30T12:35:27Z"}, "message": "sh-mem.cc (sh_expand_cmpnstr): New function.\n\n2013-10-30  Christian Bruel  <christian.bruel@st.com>\n\n\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr): New function.\n\t(sh_expand_cmpstr): Handle known align and schedule improvements.\n\t* gcc/config/sh/sh-protos.h (sh_expand_cmpstrn): Declare.\n\t* gcc/config/sh/sh.md (cmpstrnsi): New pattern.\n\nFrom-SVN: r204206", "tree": {"sha": "1cea31039fe84e59f896ec41ec6541d0a8e982ac", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1cea31039fe84e59f896ec41ec6541d0a8e982ac"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ca494b8d783b3a0d6e259789ccd09714adaf3d46", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca494b8d783b3a0d6e259789ccd09714adaf3d46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ca494b8d783b3a0d6e259789ccd09714adaf3d46", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ca494b8d783b3a0d6e259789ccd09714adaf3d46/comments", "author": null, "committer": null, "parents": [{"sha": "eb1474c1a25d8fe785d0bec71df099496a6e49b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb1474c1a25d8fe785d0bec71df099496a6e49b0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb1474c1a25d8fe785d0bec71df099496a6e49b0"}], "stats": {"total": 275, "additions": 260, "deletions": 15}, "files": [{"sha": "8666f23616e2533c3bd81c73146742c6604c8160", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -1,3 +1,10 @@\n+2013-10-30  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc/config/sh/sh-mem.cc (sh_expand_cmpnstr): New function.\n+\t(sh_expand_cmpstr): Handle known align and schedule improvements.\n+\t* gcc/config/sh/sh-protos.h (sh_expand_cmpstrn): Declare.\n+\t* gcc/config/sh/sh.md (cmpstrnsi): New pattern.\n+\n 2013-10-30  Martin Jambor  <mjambor@suse.cz>\n \n \tPR rtl-optimization/10474"}, {"sha": "eabf68711737ef8b0c026db9b6c460162da2a56b", "filename": "gcc/config/sh/sh-mem.cc", "status": "modified", "additions": 183, "deletions": 14, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh-mem.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-mem.cc?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -200,22 +200,25 @@ sh_expand_cmpstr (rtx *operands)\n   rtx L_return = gen_label_rtx ();\n   rtx L_loop_byte = gen_label_rtx ();\n   rtx L_end_loop_byte = gen_label_rtx ();\n-  rtx L_loop_long = gen_label_rtx ();\n-  rtx L_end_loop_long = gen_label_rtx ();\n \n   rtx jump, addr1, addr2;\n   int prob_unlikely = REG_BR_PROB_BASE / 10;\n   int prob_likely = REG_BR_PROB_BASE / 4;\n \n-  emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n-  emit_move_insn (tmp0, GEN_INT (3));\n+  rtx L_loop_long = gen_label_rtx ();\n+  rtx L_end_loop_long = gen_label_rtx ();\n \n-  emit_insn (gen_tstsi_t (tmp0, tmp1));\n+  int align = INTVAL (operands[3]);\n \n   emit_move_insn (tmp0, const0_rtx);\n \n-  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n-  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+  if (align < 4)\n+    {\n+      emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n+      emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));\n+      jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+    }\n \n   addr1 = adjust_automodify_address (s1, SImode, s1_addr, 0);\n   addr2 = adjust_automodify_address (s2, SImode, s2_addr, 0);\n@@ -250,7 +253,7 @@ sh_expand_cmpstr (rtx *operands)\n   add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n   /* end loop.  */\n \n-  /* Fallthu, check if one of the word is greater.  */\n+  /* Fallthu, substract words.  */\n   if (TARGET_LITTLE_ENDIAN)\n     {\n       rtx low_1 = gen_lowpart (HImode, tmp1);\n@@ -267,15 +270,15 @@ sh_expand_cmpstr (rtx *operands)\n   jump = emit_jump_insn (gen_jump_compact (L_return));\n   emit_barrier_after (jump);\n \n-  /* start byte loop.  */\n-  addr1 = adjust_automodify_address (s1, QImode, s1_addr, 0);\n-  addr2 = adjust_automodify_address (s2, QImode, s2_addr, 0);\n-\n   emit_label (L_end_loop_long);\n \n   emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, -4));\n   emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));\n \n+  /* start byte loop.  */\n+  addr1 = adjust_automodify_address (s1, QImode, s1_addr, 0);\n+  addr2 = adjust_automodify_address (s2, QImode, s2_addr, 0);\n+\n   emit_label (L_loop_byte);\n \n   emit_insn (gen_extendqisi2 (tmp2, addr2));\n@@ -289,13 +292,16 @@ sh_expand_cmpstr (rtx *operands)\n   add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n \n   emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n-  emit_jump_insn (gen_branch_true (L_loop_byte));\n+  if (flag_delayed_branch)\n+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+  jump = emit_jump_insn (gen_branch_true (L_loop_byte));\n   add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n   /* end loop.  */\n \n   emit_label (L_end_loop_byte);\n \n-  emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+  if (! flag_delayed_branch)\n+    emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n   emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));\n \n   emit_label (L_return);\n@@ -305,3 +311,166 @@ sh_expand_cmpstr (rtx *operands)\n   return true;\n }\n \n+/* Emit code to perform a strncmp.\n+\n+   OPERANDS[0] is the destination.\n+   OPERANDS[1] is the first string.\n+   OPERANDS[2] is the second string.\n+   OPERANDS[3] is the length.\n+   OPERANDS[4] is the align.  */\n+bool\n+sh_expand_cmpnstr (rtx *operands)\n+{\n+  rtx s1 = copy_rtx (operands[1]);\n+  rtx s2 = copy_rtx (operands[2]);\n+\n+  rtx s1_addr = copy_addr_to_reg (XEXP (s1, 0));\n+  rtx s2_addr = copy_addr_to_reg (XEXP (s2, 0));\n+  rtx tmp0 = gen_reg_rtx (SImode);\n+  rtx tmp1 = gen_reg_rtx (SImode);\n+  rtx tmp2 = gen_reg_rtx (SImode);\n+\n+  rtx L_return = gen_label_rtx ();\n+  rtx L_loop_byte = gen_label_rtx ();\n+  rtx L_end_loop_byte = gen_label_rtx ();\n+\n+  rtx jump, addr1, addr2;\n+  int prob_unlikely = REG_BR_PROB_BASE / 10;\n+  int prob_likely = REG_BR_PROB_BASE / 4;\n+\n+  rtx len = force_reg (SImode, operands[3]);\n+  int constp = (CONST_INT_P (operands[3]));\n+  int bytes = (constp ? INTVAL (operands[3]) : 0);\n+  int witers = bytes / 4;\n+\n+  /* We could still loop on a register count. Not found very\n+     convincing to optimize yet.  */\n+  if (! constp)\n+    return false;\n+\n+  if (witers > 1)\n+    {\n+      rtx L_loop_long = gen_label_rtx ();\n+      rtx L_end_loop_long = gen_label_rtx ();\n+      rtx tmp3 = gen_reg_rtx (SImode);\n+      rtx lenw = gen_reg_rtx (SImode);\n+      int align = INTVAL (operands[4]);\n+\n+      emit_move_insn (tmp0, const0_rtx);\n+\n+      if (align < 4)\n+\t{\n+\t  emit_insn (gen_iorsi3 (tmp1, s1_addr, s2_addr));\n+\t  emit_insn (gen_tstsi_t (GEN_INT (3), tmp1));\n+\t  jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+\t  add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\t}\n+\n+      addr1 = adjust_automodify_address (s1, SImode, s1_addr, 0);\n+      addr2 = adjust_automodify_address (s2, SImode, s2_addr, 0);\n+\n+      /* words count.  */\n+      emit_insn (gen_lshrsi3 (lenw, len, GEN_INT (2)));\n+\n+      /*start long loop.  */\n+      emit_label (L_loop_long);\n+\n+      /* tmp2 is aligned, OK to load.  */\n+      emit_move_insn (tmp2, addr2);\n+      emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 4));\n+\n+      /* tmp1 is aligned, OK to load.  */\n+      emit_move_insn (tmp1, addr1);\n+      emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 4));\n+\n+      /* Is there a 0 byte ?  */\n+      emit_insn (gen_andsi3 (tmp3, tmp2, tmp1));\n+\n+      emit_insn (gen_cmpstr_t (tmp0, tmp3));\n+      jump = emit_jump_insn (gen_branch_true (L_end_loop_long));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+      emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n+      jump = emit_jump_insn (gen_branch_false (L_end_loop_long));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+      if (TARGET_SH2)\n+\temit_insn (gen_dect (lenw, lenw));\n+      else\n+\t{\n+\t  emit_insn (gen_addsi3 (lenw, lenw, GEN_INT (-1)));\n+\t  emit_insn (gen_tstsi_t (lenw, lenw));\n+\t}\n+      jump = emit_jump_insn (gen_branch_false (L_loop_long));\n+      add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+\n+      /* end loop.  Reached max iterations.  */\n+      if (bytes % 4 == 0)\n+\t{\n+\t  /* Done.  */\n+\t  jump = emit_jump_insn (gen_jump_compact (L_return));\n+\t  emit_barrier_after (jump);\n+\t}\n+      else\n+\t{\n+\t  /* Remaining bytes to read.   */\n+\t  emit_move_insn (len, GEN_INT (bytes % 4));\n+\t  jump = emit_jump_insn (gen_jump_compact (L_loop_byte));\n+\t  emit_barrier_after (jump);\n+\t}\n+\n+      emit_label (L_end_loop_long);\n+\n+      /* Remaining bytes to read.   */\n+      emit_move_insn (len, GEN_INT (4));\n+\n+      /* Found last word.  Restart it byte per byte. */\n+      emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, -4));\n+      emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, -4));\n+    }\n+\n+    addr1 = adjust_automodify_address (s1, QImode, s1_addr, 0);\n+    addr2 = adjust_automodify_address (s2, QImode, s2_addr, 0);\n+\n+    emit_label (L_loop_byte);\n+\n+    emit_insn (gen_extendqisi2 (tmp2, addr2));\n+    emit_move_insn (s2_addr, plus_constant (Pmode, s2_addr, 1));\n+\n+    emit_insn (gen_extendqisi2 (tmp1, addr1));\n+    emit_move_insn (s1_addr, plus_constant (Pmode, s1_addr, 1));\n+\n+    emit_insn (gen_cmpeqsi_t (tmp2, const0_rtx));\n+    jump = emit_jump_insn (gen_branch_true (L_end_loop_byte));\n+    add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+    emit_insn (gen_cmpeqsi_t (tmp1, tmp2));\n+    if (flag_delayed_branch)\n+      emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+    jump = emit_jump_insn (gen_branch_false (L_end_loop_byte));\n+    add_int_reg_note (jump, REG_BR_PROB, prob_unlikely);\n+\n+    if (TARGET_SH2)\n+      emit_insn (gen_dect (len, len));\n+    else\n+      {\n+\temit_insn (gen_addsi3 (len, len, GEN_INT (-1)));\n+\temit_insn (gen_tstsi_t (len, len));\n+      }\n+\n+    jump = emit_jump_insn (gen_branch_false (L_loop_byte));\n+    add_int_reg_note (jump, REG_BR_PROB, prob_likely);\n+    /* end byte loop.  */\n+\n+    emit_label (L_end_loop_byte);\n+\n+    if (! flag_delayed_branch)\n+      emit_insn (gen_zero_extendqisi2 (tmp2, gen_lowpart (QImode, tmp2)));\n+    emit_insn (gen_zero_extendqisi2 (tmp1, gen_lowpart (QImode, tmp1)));\n+\n+    emit_label (L_return);\n+\n+    emit_insn (gen_subsi3 (operands[0], tmp1, tmp2));\n+\n+    return true;\n+}"}, {"sha": "e7dfce366abc94e4c39214c14471f3f0c4a4527c", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -117,6 +117,7 @@ extern void output_pic_addr_const (FILE *, rtx);\n extern bool expand_block_move (rtx *);\n extern void prepare_move_operands (rtx[], enum machine_mode mode);\n extern bool sh_expand_cmpstr (rtx *);\n+extern bool sh_expand_cmpnstr (rtx *);\n extern enum rtx_code prepare_cbranch_operands (rtx *, enum machine_mode mode,\n \t\t\t\t\t       enum rtx_code comparison);\n extern void expand_cbranchsi4 (rtx *operands, enum rtx_code comparison, int);"}, {"sha": "b8109e62c44056a3f4895da7bb3a5065384edf1e", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -12067,6 +12067,20 @@ label:\n     FAIL;\n })\n \n+(define_expand \"cmpstrnsi\"\n+  [(set (match_operand:SI 0 \"register_operand\")\n+\t(compare:SI (match_operand:BLK 1 \"memory_operand\")\n+\t\t    (match_operand:BLK 2 \"memory_operand\")))\n+   (use (match_operand:SI 3 \"immediate_operand\"))\n+   (use (match_operand:SI 4 \"immediate_operand\"))]\n+  \"TARGET_SH1\"\n+{\n+  if (! optimize_insn_for_size_p () && sh_expand_cmpnstr (operands))\n+    DONE;\n+  else\n+    FAIL;\n+})\n+\n \f\n ;; -------------------------------------------------------------------------\n ;; Floating point instructions."}, {"sha": "ac28ad1686738062ca64168b961c06e5c3b90ae6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -1,3 +1,9 @@\n+2013-10-30  Christian Bruel  <christian.bruel@st.com>\n+\n+\t* gcc.c-torture/execute/builtins/strncmp-2.c: Enable for SH.\n+\t* gcc.target/sh/cmpstr.c: New test.\n+\t* gcc.target/sh/cmpstrn.c: New test.\n+\n 2013-10-30  Martin Jambor  <mjambor@suse.cz>\n \n \tPR rtl-optimization/10474"}, {"sha": "508b2d3309a449f594a1c056dc3130899a420bc6", "filename": "gcc/testsuite/gcc.c-torture/execute/builtins/strncmp-2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncmp-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncmp-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.c-torture%2Fexecute%2Fbuiltins%2Fstrncmp-2.c?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -12,7 +12,7 @@ extern int strncmp (const char *, const char *, size_t);\n void\n main_test (void)\n {\n-#if !defined(__OPTIMIZE__) || ((defined(__i386__) || defined (__x86_64__)) && !defined(__OPTIMIZE_SIZE__))\n+#if !defined(__OPTIMIZE__) || ((defined(__sh__) || defined(__i386__) || defined (__x86_64__)) && !defined(__OPTIMIZE_SIZE__))\n   /* These tests work on platforms which support cmpstrsi.  We test it\n      at -O0 on all platforms to ensure the strncmp logic is correct.  */\n   const char *const s1 = \"hello world\";"}, {"sha": "3e75e4a6434388623f20d9abca40e33393165857", "filename": "gcc/testsuite/gcc.target/sh/cmpstr.c", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstr.c?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -0,0 +1,27 @@\n+/* Check that the __builtin_strcmp function is inlined with cmp/str\n+   when optimizing for speed.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+/* { dg-final { scan-assembler-times \"cmp/str\" 3 } } */\n+/* { dg-final { scan-assembler-times \"tst\\t#3\" 2 } } */\n+\n+test00 (const char *s1, const char *s2)\n+{\n+  return __builtin_strcmp (s1, s2);\n+}\n+\n+/* NB: This might change as further optimisation might detect the\n+   max length and fallback to cmpstrn.  */\n+test01(const char *s2)\n+{\n+  return __builtin_strcmp (\"abc\", s2);\n+}\n+\n+/* Check that no test for alignment is needed.  */\n+test03(const char *s1, const char *s2)\n+{\n+  return __builtin_strcmp (__builtin_assume_aligned (s1, 4),\n+\t\t\t   __builtin_assume_aligned (s2, 4));\n+}"}, {"sha": "b2260f921103f7f5f810f4ca0bf804471965381b", "filename": "gcc/testsuite/gcc.target/sh/cmpstrn.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ca494b8d783b3a0d6e259789ccd09714adaf3d46/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fcmpstrn.c?ref=ca494b8d783b3a0d6e259789ccd09714adaf3d46", "patch": "@@ -0,0 +1,21 @@\n+/* Check that the __builtin_strncmp function is inlined\n+   when optimizing for speed.  */\n+/* { dg-do compile { target \"sh*-*-*\" } } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-skip-if \"\" { \"sh*-*-*\" } { \"-m5*\" } { \"\" } } */\n+/* { dg-final { scan-assembler-not \"jmp\" } } */\n+/* { dg-final { scan-assembler-times \"cmp/str\" 1 } } */\n+\n+/* Test that the cmp/str loop is optimized out.  */\n+test01(const char *s1, const char *s2, int n)\n+{\n+  return __builtin_strncmp (s1, \"abcde\", 3);\n+}\n+\n+/* Test that the cmp/str loop is used.  */\n+test02(const char *s1, const char *s2, int n)\n+{\n+  return __builtin_strncmp (s1, \"abcdefghi\", 8);\n+}\n+\n+"}]}