{"sha": "97cd182da75d972645a95e493253a61142d4c014", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTdjZDE4MmRhNzVkOTcyNjQ1YTk1ZTQ5MzI1M2E2MTE0MmQ0YzAxNA==", "commit": {"author": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-11-05T17:35:30Z"}, "committer": {"name": "Jerry DeLisle", "email": "jvdelisle@gcc.gnu.org", "date": "2006-11-05T17:35:30Z"}, "message": "re PR libfortran/25545 (internal file and dollar edit descriptor)\n\n2006-11-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n\n\tPR libgfortran/25545\n\t* io/transfer.c (write_block): Cleanup code paths between\n\tstream and non-stream I/O.\n\t(write_buf):  Cleanup.\n\t(read_block): Cleanup.\n\t(finalize_transfer): Call next_record for '$' edit descriptor handling\n\tof internal unit. Cleanup code for readability.\n\nFrom-SVN: r118506", "tree": {"sha": "4a09404a09d1fed04b47fa72134f749a701c0c92", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4a09404a09d1fed04b47fa72134f749a701c0c92"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/97cd182da75d972645a95e493253a61142d4c014", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97cd182da75d972645a95e493253a61142d4c014", "html_url": "https://github.com/Rust-GCC/gccrs/commit/97cd182da75d972645a95e493253a61142d4c014", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/97cd182da75d972645a95e493253a61142d4c014/comments", "author": null, "committer": null, "parents": [{"sha": "449c480110f6c57085db9c005127052731a97395", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/449c480110f6c57085db9c005127052731a97395", "html_url": "https://github.com/Rust-GCC/gccrs/commit/449c480110f6c57085db9c005127052731a97395"}], "stats": {"total": 213, "additions": 100, "deletions": 113}, "files": [{"sha": "88d76c81ab04a7eb85544a3e54ea739b406210f0", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97cd182da75d972645a95e493253a61142d4c014/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97cd182da75d972645a95e493253a61142d4c014/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=97cd182da75d972645a95e493253a61142d4c014", "patch": "@@ -1,3 +1,13 @@\n+2006-11-04  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n+\n+\tPR libgfortran/25545\n+\t* io/transfer.c (write_block): Cleanup code paths between\n+\tstream and non-stream I/O.\n+\t(write_buf):  Cleanup.\n+\t(read_block): Cleanup.\n+\t(finalize_transfer): Call next_record for '$' edit descriptor handling\n+\tof internal unit. Cleanup code for readability.\n+\n 2006-11-03  Francois-Xavier Coudert  <coudert@clipper.ens.fr>\n \n \tPR libfortran/27895"}, {"sha": "a4d456389b164bb0ca01efc477f317f586d6cde9", "filename": "libgfortran/io/transfer.c", "status": "modified", "additions": 90, "deletions": 113, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/97cd182da75d972645a95e493253a61142d4c014/libgfortran%2Fio%2Ftransfer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/97cd182da75d972645a95e493253a61142d4c014/libgfortran%2Fio%2Ftransfer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fio%2Ftransfer.c?ref=97cd182da75d972645a95e493253a61142d4c014", "patch": "@@ -263,7 +263,16 @@ read_block (st_parameter_dt *dtp, int *length)\n   char *source;\n   int nread;\n \n-  if (!is_stream_io (dtp))\n+  if (is_stream_io (dtp))\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_END, NULL);\n+\t  return NULL;\n+\t}\n+    }\n+  else\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) *length)\n \t{\n@@ -291,65 +300,38 @@ read_block (st_parameter_dt *dtp, int *length)\n \n \t  *length = dtp->u.p.current_unit->bytes_left;\n \t}\n+    }\n \n-      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n-\tdtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL)\n-\t  return read_sf (dtp, length, 0);\t/* Special case.  */\n-\n-      dtp->u.p.current_unit->bytes_left -= (gfc_offset) *length;\n-\n-      nread = *length;\n-      source = salloc_r (dtp->u.p.current_unit->s, &nread);\n+  if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED &&\n+      (dtp->u.p.current_unit->flags.access == ACCESS_SEQUENTIAL ||\n+       dtp->u.p.current_unit->flags.access == ACCESS_STREAM))\n+    {\n+      source = read_sf (dtp, length, 0);\n+      dtp->u.p.current_unit->strm_pos +=\n+\t(gfc_offset) (*length + dtp->u.p.sf_seen_eor);\n+      return source;\n+    }\n+  dtp->u.p.current_unit->bytes_left -= (gfc_offset) *length;\n \n-      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-\tdtp->u.p.size_used += (gfc_offset) nread;\n+  nread = *length;\n+  source = salloc_r (dtp->u.p.current_unit->s, &nread);\n \n-      if (nread != *length)\n-\t{\t\t\t\t/* Short read, this shouldn't happen.  */\n-\t  if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n-\t    *length = nread;\n-\t  else\n-\t    {\n-\t      generate_error (&dtp->common, ERROR_EOR, NULL);\n-\t      source = NULL;\n-\t    }\n-\t}\n-    }\n-  else\n-    {\n-      if (sseek (dtp->u.p.current_unit->s,\n-\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    dtp->u.p.size_used += (gfc_offset) nread;\n \n-      if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n+  if (nread != *length)\n+    {\t\t\t\t/* Short read, this shouldn't happen.  */\n+      if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n+\t*length = nread;\n+      else\n \t{\n-\t  source = read_sf (dtp, length, 0);\n-\t  dtp->u.p.current_unit->strm_pos +=\n-\t    (gfc_offset) (*length + dtp->u.p.sf_seen_eor);\n-\t  return source;\n+\t  generate_error (&dtp->common, ERROR_EOR, NULL);\n+\t  source = NULL;\n \t}\n-      nread = *length;\n-      source = salloc_r (dtp->u.p.current_unit->s, &nread);\n+    }\n \n-      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-\tdtp->u.p.size_used += (gfc_offset) nread;\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n \n-      if (nread != *length)\n-\t{\t\t\t\t/* Short read, this shouldn't happen.  */\n-\t  if (dtp->u.p.current_unit->flags.pad == PAD_YES)\n-\t    *length = nread;\n-\t  else\n-\t    {\n-\t      generate_error (&dtp->common, ERROR_END, NULL);\n-\t      source = NULL;\n-\t    }\n-\t}\n-\n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) nread;\n-    }\n   return source;\n }\n \n@@ -440,7 +422,16 @@ write_block (st_parameter_dt *dtp, int length)\n {\n   char *dest;\n \n-  if (!is_stream_io (dtp))\n+  if (is_stream_io (dtp))\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return NULL;\n+\t}\n+    }\n+  else\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) length)\n \t{\n@@ -458,41 +449,23 @@ write_block (st_parameter_dt *dtp, int length)\n \t}\n \n       dtp->u.p.current_unit->bytes_left -= (gfc_offset) length;\n+    }\n \n+  dest = salloc_w (dtp->u.p.current_unit->s, &length);\n \n-      dest = salloc_w (dtp->u.p.current_unit->s, &length);\n-  \n-      if (dest == NULL)\n-\t{\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n-\t  return NULL;\n-\t}\n-\n-      if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n-\tgenerate_error (&dtp->common, ERROR_END, NULL);\n-\n-      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n-\tdtp->u.p.size_used += (gfc_offset) length;\n-    }\n-  else\n+  if (dest == NULL)\n     {\n-      if (sseek (dtp->u.p.current_unit->s,\n-\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n-\t  return NULL;\n-\t}\n+      generate_error (&dtp->common, ERROR_END, NULL);\n+      return NULL;\n+    }\n \n-      dest = salloc_w (dtp->u.p.current_unit->s, &length);\n+  if (is_internal_unit (dtp) && dtp->u.p.current_unit->endfile == AT_ENDFILE)\n+    generate_error (&dtp->common, ERROR_END, NULL);\n \n-      if (dest == NULL)\n-\t{\n-\t  generate_error (&dtp->common, ERROR_END, NULL);\n-\t  return NULL;\n-\t}\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+    dtp->u.p.size_used += (gfc_offset) length;\n \n-      dtp->u.p.current_unit->strm_pos += (gfc_offset) length;\n-    }\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) length;\n \n   return dest;\n }\n@@ -503,7 +476,16 @@ write_block (st_parameter_dt *dtp, int length)\n static try\n write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n {\n-  if (!is_stream_io (dtp))\n+  if (is_stream_io (dtp))\n+    {\n+      if (sseek (dtp->u.p.current_unit->s,\n+\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n+\t{\n+\t  generate_error (&dtp->common, ERROR_OS, NULL);\n+\t  return FAILURE;\n+\t}\n+    }\n+  else\n     {\n       if (dtp->u.p.current_unit->bytes_left < (gfc_offset) nbytes)\n \t{\n@@ -526,29 +508,17 @@ write_buf (st_parameter_dt *dtp, void *buf, size_t nbytes)\n \n       dtp->u.p.current_unit->bytes_left -= (gfc_offset) nbytes;\n     }\n-  else\n-    {\n-      if (sseek (dtp->u.p.current_unit->s,\n-\t\t dtp->u.p.current_unit->strm_pos - 1) == FAILURE)\n-\t{\n-\t  generate_error (&dtp->common, ERROR_OS, NULL);\n-\t  return FAILURE;\n-\t}\n-    }\n \n   if (swrite (dtp->u.p.current_unit->s, buf, &nbytes) != 0)\n     {\n       generate_error (&dtp->common, ERROR_OS, NULL);\n       return FAILURE;\n     }\n \n-  if (!is_stream_io (dtp))\n-    {\n-      if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n+  if ((dtp->common.flags & IOPARM_DT_HAS_SIZE) != 0)\n \tdtp->u.p.size_used += (gfc_offset) nbytes;\n-    }\n-  else\n-    dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n+\n+  dtp->u.p.current_unit->strm_pos += (gfc_offset) nbytes; \n \n   return SUCCESS;\n }\n@@ -2244,7 +2214,8 @@ next_record_w (st_parameter_dt *dtp, int done)\n \t\t  else\n \t\t    length = (int) dtp->u.p.current_unit->bytes_left;\n \t\t}\n-\t      if (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n+\n+\tif (sset (dtp->u.p.current_unit->s, ' ', length) == FAILURE)\n \t\t{\n \t\t  generate_error (&dtp->common, ERROR_END, NULL);\n \t\t  return;\n@@ -2371,28 +2342,34 @@ finalize_transfer (st_parameter_dt *dtp)\n     }\n \n   if ((cf & IOPARM_DT_LIST_FORMAT) != 0 && dtp->u.p.mode == READING)\n-    finish_list_read (dtp);\n-  else if (!is_stream_io (dtp))\n     {\n-      dtp->u.p.current_unit->current_record = 0;\n-      if (dtp->u.p.advance_status == ADVANCE_NO || dtp->u.p.seen_dollar)\n-\t{\n-\t  /* Most systems buffer lines, so force the partial record\n-\t     to be written out.  */\n-\t  if (!is_internal_unit (dtp))\n-\t    flush (dtp->u.p.current_unit->s);\n-\t  dtp->u.p.seen_dollar = 0;\n-\t  return;\n-\t}\n-      next_record (dtp, 1);\n+      finish_list_read (dtp);\n+      sfree (dtp->u.p.current_unit->s);\n+      return;\n     }\n-  else\n+\n+  if (is_stream_io (dtp))\n     {\n       if (dtp->u.p.current_unit->flags.form == FORM_FORMATTED)\n \tnext_record (dtp, 1);\n       flush (dtp->u.p.current_unit->s);\n+      sfree (dtp->u.p.current_unit->s);\n+      return;\n+    }\n+\n+  dtp->u.p.current_unit->current_record = 0;\n+\n+  if (dtp->u.p.advance_status == ADVANCE_NO)\n+    return;\n+\n+  if (!is_internal_unit (dtp) && dtp->u.p.seen_dollar)\n+    {\n+      dtp->u.p.seen_dollar = 0;\n+      sfree (dtp->u.p.current_unit->s);\n+      return;\n     }\n \n+  next_record (dtp, 1);\n   sfree (dtp->u.p.current_unit->s);\n }\n "}]}