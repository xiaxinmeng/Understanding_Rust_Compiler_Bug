{"sha": "5c33bb6218a90bcab5fe88ddd0864a50be9014de", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWMzM2JiNjIxOGE5MGJjYWI1ZmU4OGRkZDA4NjRhNTBiZTkwMTRkZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "pcarlini@suse.de", "date": "2004-05-15T11:43:03Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-05-15T11:43:03Z"}, "message": "std_bitset.h: Trivial formatting fixes.\n\n2004-05-15  Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/std/std_bitset.h: Trivial formatting fixes.\n\nFrom-SVN: r81878", "tree": {"sha": "2578f46529faa6f07dff30ea172d6e528b17ab0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2578f46529faa6f07dff30ea172d6e528b17ab0d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5c33bb6218a90bcab5fe88ddd0864a50be9014de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c33bb6218a90bcab5fe88ddd0864a50be9014de", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5c33bb6218a90bcab5fe88ddd0864a50be9014de", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5c33bb6218a90bcab5fe88ddd0864a50be9014de/comments", "author": null, "committer": null, "parents": [{"sha": "aaa67502729b8696e5f4953967a3f143d27d367c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaa67502729b8696e5f4953967a3f143d27d367c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaa67502729b8696e5f4953967a3f143d27d367c"}], "stats": {"total": 1078, "additions": 569, "deletions": 509}, "files": [{"sha": "bb7f593732f293e343814c5ed7f8cedfa050f6f0", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c33bb6218a90bcab5fe88ddd0864a50be9014de/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c33bb6218a90bcab5fe88ddd0864a50be9014de/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=5c33bb6218a90bcab5fe88ddd0864a50be9014de", "patch": "@@ -1,3 +1,7 @@\n+2004-05-15  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/std/std_bitset.h: Trivial formatting fixes.\n+\n 2004-05-14  Paolo Carlini  <pcarlini@suse.de>\n \t    Ivan Godard  <igodard@pacbell.net>\n "}, {"sha": "8fa1756812cff33e390e6521809aa2ab8e6532a1", "filename": "libstdc++-v3/include/std/std_bitset.h", "status": "modified", "additions": 565, "deletions": 509, "changes": 1074, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5c33bb6218a90bcab5fe88ddd0864a50be9014de/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5c33bb6218a90bcab5fe88ddd0864a50be9014de/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h?ref=5c33bb6218a90bcab5fe88ddd0864a50be9014de", "patch": "@@ -61,7 +61,8 @@\n \n #define _GLIBCXX_BITSET_BITS_PER_WORD  numeric_limits<unsigned long>::digits\n #define _GLIBCXX_BITSET_WORDS(__n) \\\n- ((__n) < 1 ? 0 : ((__n) + _GLIBCXX_BITSET_BITS_PER_WORD - 1)/_GLIBCXX_BITSET_BITS_PER_WORD)\n+ ((__n) < 1 ? 0 : ((__n) + _GLIBCXX_BITSET_BITS_PER_WORD - 1) \\\n+                  / _GLIBCXX_BITSET_BITS_PER_WORD)\n \n namespace _GLIBCXX_STD\n {\n@@ -81,7 +82,9 @@ namespace _GLIBCXX_STD\n       /// 0 is the least significant word.\n       _WordT \t\t_M_w[_Nw];\n \n-      _Base_bitset() { _M_do_reset(); }\n+      _Base_bitset()\n+      { _M_do_reset(); }\n+\n       _Base_bitset(unsigned long __val)\n       {\n \t_M_do_reset();\n@@ -113,10 +116,12 @@ namespace _GLIBCXX_STD\n       { return _M_w[_S_whichword(__pos)]; }\n \n       _WordT&\n-      _M_hiword() { return _M_w[_Nw - 1]; }\n+      _M_hiword()\n+      { return _M_w[_Nw - 1]; }\n \n       _WordT\n-      _M_hiword() const { return _M_w[_Nw - 1]; }\n+      _M_hiword() const\n+      { return _M_w[_Nw - 1]; }\n \n       void\n       _M_do_and(const _Base_bitset<_Nw>& __x)\n@@ -160,7 +165,8 @@ namespace _GLIBCXX_STD\n       }\n \n       void\n-      _M_do_reset() { memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n+      _M_do_reset()\n+      { std::memset(_M_w, 0, _Nw * sizeof(_WordT)); }\n \n       bool\n       _M_is_equal(const _Base_bitset<_Nw>& __x) const\n@@ -220,10 +226,11 @@ namespace _GLIBCXX_STD\n \t      _M_w[__n] = _M_w[__n - __wshift];\n \t  else\n \t    {\n-\t      const size_t __sub_offset = _GLIBCXX_BITSET_BITS_PER_WORD - __offset;\n+\t      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD \n+\t\t\t\t\t   - __offset);\n \t      for (size_t __n = _Nw - 1; __n > __wshift; --__n)\n-\t\t_M_w[__n] = (_M_w[__n - __wshift] << __offset) |\n-\t\t  (_M_w[__n - __wshift - 1] >> __sub_offset);\n+\t\t_M_w[__n] = ((_M_w[__n - __wshift] << __offset)\n+\t\t\t     | (_M_w[__n - __wshift - 1] >> __sub_offset));\n \t      _M_w[__wshift] = _M_w[0] << __offset;\n \t    }\n \n@@ -246,10 +253,11 @@ namespace _GLIBCXX_STD\n \t      _M_w[__n] = _M_w[__n + __wshift];\n \t  else\n \t    {\n-\t      const size_t __sub_offset = _GLIBCXX_BITSET_BITS_PER_WORD - __offset;\n+\t      const size_t __sub_offset = (_GLIBCXX_BITSET_BITS_PER_WORD\n+\t\t\t\t\t   - __offset);\n \t      for (size_t __n = 0; __n < __limit; ++__n)\n-\t\t_M_w[__n] = (_M_w[__n + __wshift] >> __offset) |\n-\t\t  (_M_w[__n + __wshift + 1] << __sub_offset);\n+\t\t_M_w[__n] = ((_M_w[__n + __wshift] >> __offset)\n+\t\t\t     | (_M_w[__n + __wshift + 1] << __sub_offset));\n \t      _M_w[__limit] = _M_w[_Nw-1] >> __offset;\n \t    }\n \t  \n@@ -275,8 +283,8 @@ namespace _GLIBCXX_STD\n \t{\n \t  _WordT __thisword = _M_w[__i];\n \t  if (__thisword != static_cast<_WordT>(0))\n-\t    return __i * _GLIBCXX_BITSET_BITS_PER_WORD\n-\t      + __builtin_ctzl(__thisword);\n+\t    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD\n+\t\t    + __builtin_ctzl(__thisword));\n \t}\n       // not found, so return an indication of failure.\n       return __not_found;\n@@ -301,23 +309,22 @@ namespace _GLIBCXX_STD\n       __thisword &= (~static_cast<_WordT>(0)) << _S_whichbit(__prev);\n \n       if (__thisword != static_cast<_WordT>(0))\n-\treturn __i * _GLIBCXX_BITSET_BITS_PER_WORD\n-\t  + __builtin_ctzl(__thisword);\n+\treturn (__i * _GLIBCXX_BITSET_BITS_PER_WORD\n+\t\t+ __builtin_ctzl(__thisword));\n \n       // check subsequent words\n       __i++;\n-      for ( ; __i < _Nw; __i++ )\n+      for (; __i < _Nw; __i++)\n \t{\n \t  __thisword = _M_w[__i];\n \t  if (__thisword != static_cast<_WordT>(0))\n-\t    return __i * _GLIBCXX_BITSET_BITS_PER_WORD\n-\t      + __builtin_ctzl(__thisword);\n+\t    return (__i * _GLIBCXX_BITSET_BITS_PER_WORD\n+\t\t    + __builtin_ctzl(__thisword));\n \t}\n       // not found, so return an indication of failure.\n       return __not_found;\n     } // end _M_do_find_next\n \n-\n   /**\n    *  @if maint\n    *  Base class, specialization for a single word.\n@@ -331,8 +338,13 @@ namespace _GLIBCXX_STD\n       typedef unsigned long _WordT;\n       _WordT _M_w;\n \n-      _Base_bitset( void ) : _M_w(0) {}\n-      _Base_bitset(unsigned long __val) : _M_w(__val) {}\n+      _Base_bitset(void)\n+      : _M_w(0)\n+      {}\n+\n+      _Base_bitset(unsigned long __val)\n+      : _M_w(__val)\n+      {}\n \n       static size_t\n       _S_whichword(size_t __pos )\n@@ -351,53 +363,68 @@ namespace _GLIBCXX_STD\n       { return (static_cast<_WordT>(1)) << _S_whichbit(__pos); }\n \n       _WordT&\n-      _M_getword(size_t) { return _M_w; }\n+      _M_getword(size_t)\n+      { return _M_w; }\n \n       _WordT\n-      _M_getword(size_t) const { return _M_w; }\n+      _M_getword(size_t) const\n+      { return _M_w; }\n \n       _WordT&\n-      _M_hiword() { return _M_w; }\n+      _M_hiword()\n+      { return _M_w; }\n \n       _WordT\n-      _M_hiword() const { return _M_w; }\n+      _M_hiword() const\n+      { return _M_w; }\n \n       void\n-      _M_do_and(const _Base_bitset<1>& __x) { _M_w &= __x._M_w; }\n+      _M_do_and(const _Base_bitset<1>& __x)\n+      { _M_w &= __x._M_w; }\n \n       void\n-      _M_do_or(const _Base_bitset<1>& __x)  { _M_w |= __x._M_w; }\n+      _M_do_or(const _Base_bitset<1>& __x)\n+      { _M_w |= __x._M_w; }\n \n       void\n-      _M_do_xor(const _Base_bitset<1>& __x) { _M_w ^= __x._M_w; }\n+      _M_do_xor(const _Base_bitset<1>& __x)\n+      { _M_w ^= __x._M_w; }\n \n       void\n-      _M_do_left_shift(size_t __shift) { _M_w <<= __shift; }\n+      _M_do_left_shift(size_t __shift)\n+      { _M_w <<= __shift; }\n \n       void\n-      _M_do_right_shift(size_t __shift) { _M_w >>= __shift; }\n+      _M_do_right_shift(size_t __shift)\n+      { _M_w >>= __shift; }\n \n       void\n-      _M_do_flip() { _M_w = ~_M_w; }\n+      _M_do_flip()\n+      { _M_w = ~_M_w; }\n \n       void\n-      _M_do_set() { _M_w = ~static_cast<_WordT>(0); }\n+      _M_do_set()\n+      { _M_w = ~static_cast<_WordT>(0); }\n \n       void\n-      _M_do_reset() { _M_w = 0; }\n+      _M_do_reset()\n+      { _M_w = 0; }\n \n       bool\n       _M_is_equal(const _Base_bitset<1>& __x) const\n       { return _M_w == __x._M_w; }\n \n       bool\n-      _M_is_any() const { return _M_w != 0; }\n+      _M_is_any() const\n+      { return _M_w != 0; }\n \n       size_t\n-      _M_do_count() const { return __builtin_popcountl(_M_w); }\n+      _M_do_count() const\n+      { return __builtin_popcountl(_M_w); }\n \n       unsigned long\n-      _M_do_to_ulong() const { return _M_w; }\n+      _M_do_to_ulong() const\n+      { return _M_w; }\n \n       size_t\n       _M_do_find_first(size_t __not_found) const\n@@ -424,7 +451,6 @@ namespace _GLIBCXX_STD\n       }\n     };\n \n-\n   /**\n    *  @if maint\n    *  Base class, specialization for no storage (zero-length %bitset).\n@@ -437,8 +463,11 @@ namespace _GLIBCXX_STD\n     {\n       typedef unsigned long _WordT;\n \n-      _Base_bitset() {}\n-      _Base_bitset(unsigned long) {}\n+      _Base_bitset()\n+      {}\n+\n+      _Base_bitset(unsigned long)\n+      {}\n \n       static size_t\n       _S_whichword(size_t __pos )\n@@ -471,54 +500,69 @@ namespace _GLIBCXX_STD\n       }\n \n       _WordT\n-      _M_hiword() const { return 0; }\n+      _M_hiword() const\n+      { return 0; }\n \n       void\n-      _M_do_and(const _Base_bitset<0>&) { }\n+      _M_do_and(const _Base_bitset<0>&)\n+      {}\n \n       void\n-      _M_do_or(const _Base_bitset<0>&)  { }\n+      _M_do_or(const _Base_bitset<0>&)\n+      {}\n \n       void\n-      _M_do_xor(const _Base_bitset<0>&) { }\n+      _M_do_xor(const _Base_bitset<0>&)\n+      {}\n \n       void\n-      _M_do_left_shift(size_t) { }\n+      _M_do_left_shift(size_t)\n+      {}\n \n       void\n-      _M_do_right_shift(size_t) { }\n+      _M_do_right_shift(size_t)\n+      {}\n \n       void\n-      _M_do_flip() { }\n+      _M_do_flip()\n+      {}\n \n       void\n-      _M_do_set() { }\n+      _M_do_set()\n+      {}\n \n       void\n-      _M_do_reset() { }\n+      _M_do_reset()\n+      {}\n \n       // Are all empty bitsets equal to each other?  Are they equal to\n       // themselves?  How to compare a thing which has no state?  What is\n       // the sound of one zero-length bitset clapping?\n       bool\n-      _M_is_equal(const _Base_bitset<0>&) const { return true; }\n+      _M_is_equal(const _Base_bitset<0>&) const\n+      { return true; }\n \n       bool\n-      _M_is_any() const { return false; }\n+      _M_is_any() const\n+      { return false; }\n \n       size_t\n-      _M_do_count() const { return 0; }\n+      _M_do_count() const\n+      { return 0; }\n \n       unsigned long\n-      _M_do_to_ulong() const { return 0; }\n+      _M_do_to_ulong() const\n+      { return 0; }\n \n       // Normally \"not found\" is the size, but that could also be\n       // misinterpreted as an index in this corner case.  Oh well.\n       size_t\n-      _M_do_find_first(size_t) const { return 0; }\n+      _M_do_find_first(size_t) const\n+      { return 0; }\n \n       size_t\n-      _M_do_find_next(size_t, size_t) const { return 0; }\n+      _M_do_find_next(size_t, size_t) const\n+      { return 0; }\n     };\n \n \n@@ -532,8 +576,7 @@ namespace _GLIBCXX_STD\n \n   template<>\n     struct _Sanitize<0>\n-    { static void _S_do_sanitize(unsigned long) { } };\n-\n+    { static void _S_do_sanitize(unsigned long) {} };\n \n   /**\n    *  @brief  The %bitset class represents a @e fixed-size sequence of bits.\n@@ -600,508 +643,521 @@ namespace _GLIBCXX_STD\n    *  @endif\n   */\n   template<size_t _Nb>\n-    class bitset : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>\n-  {\n-  private:\n-    typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;\n-    typedef unsigned long _WordT;\n-\n-    void\n-    _M_do_sanitize()\n+    class bitset\n+    : private _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)>\n     {\n-      _Sanitize<_Nb%_GLIBCXX_BITSET_BITS_PER_WORD>::\n-          _S_do_sanitize(this->_M_hiword());\n-    }\n+    private:\n+      typedef _Base_bitset<_GLIBCXX_BITSET_WORDS(_Nb)> _Base;\n+      typedef unsigned long _WordT;\n \n-  public:\n-    /**\n-     *  This encapsulates the concept of a single bit.  An instance of this\n-     *  class is a proxy for an actual bit; this way the individual bit\n-     *  operations are done as faster word-size bitwise instructions.\n-     *\n-     *  Most users will never need to use this class directly; conversions\n-     *  to and from bool are automatic and should be transparent.  Overloaded\n-     *  operators help to preserve the illusion.\n-     *\n-     *  (On a typical system, this \"bit %reference\" is 64 times the size of\n-     *  an actual bit.  Ha.)\n-    */\n-    class reference\n-    {\n-      friend class bitset;\n+      void\n+\t_M_do_sanitize()\n+\t{\n+\t  _Sanitize<_Nb % _GLIBCXX_BITSET_BITS_PER_WORD>::\n+\t    _S_do_sanitize(this->_M_hiword());\n+\t}\n \n-      _WordT *_M_wp;\n-      size_t _M_bpos;\n+    public:\n+      /**\n+       *  This encapsulates the concept of a single bit.  An instance of this\n+       *  class is a proxy for an actual bit; this way the individual bit\n+       *  operations are done as faster word-size bitwise instructions.\n+       *\n+       *  Most users will never need to use this class directly; conversions\n+       *  to and from bool are automatic and should be transparent.  Overloaded\n+       *  operators help to preserve the illusion.\n+       *\n+       *  (On a typical system, this \"bit %reference\" is 64 times the size of\n+       *  an actual bit.  Ha.)\n+       */\n+      class reference\n+      {\n+\tfriend class bitset;\n+\n+\t_WordT *_M_wp;\n+\tsize_t _M_bpos;\n+\t\n+\t// left undefined\n+\treference();\n+\t\n+      public:\n+\treference(bitset& __b, size_t __pos)\n+\t{\n+\t  _M_wp = &__b._M_getword(__pos);\n+\t  _M_bpos = _Base::_S_whichbit(__pos);\n+\t}\n \n-      // left undefined\n-      reference();\n+\t~reference()\n+\t{ }\n \n-    public:\n-      reference(bitset& __b, size_t __pos)\n+\t// For b[i] = __x;\n+\treference&\n+\toperator=(bool __x)\n+\t{\n+\t  if (__x)\n+\t    *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\t  else\n+\t    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\t  return *this;\n+\t}\n+\n+\t// For b[i] = b[__j];\n+\treference&\n+\toperator=(const reference& __j)\n+\t{\n+\t  if ((*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)))\n+\t    *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\t  else\n+\t    *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\t  return *this;\n+\t}\n+\n+\t// Flips the bit\n+\tbool\n+\toperator~() const\n+\t{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n+\n+\t// For __x = b[i];\n+\toperator bool() const\n+\t{ return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n+\n+\t// For b[i].flip();\n+\treference&\n+\tflip()\n+\t{\n+\t  *_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+\t  return *this;\n+\t}\n+      };\n+      friend class reference;\n+\n+      // 23.3.5.1 constructors:\n+      /// All bits set to zero.\n+      bitset()\n+      { }\n+\n+      /// Initial bits bitwise-copied from a single word (others set to zero).\n+      bitset(unsigned long __val)\n+      : _Base(__val)\n+      { _M_do_sanitize(); }\n+\n+      /**\n+       *  @brief  Use a subset of a string.\n+       *  @param  s  A string of '0' and '1' characters.\n+       *  @param  position  Index of the first character in @a s to use;\n+       *                    defaults to zero.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n+       *  @throw  std::invalid_argument  If a character appears in the string\n+       *                                 which is neither '0' nor '1'.\n+       */\n+      template<class _CharT, class _Traits, class _Alloc>\n+\texplicit\n+\tbitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t       size_t __position = 0)\n+\t: _Base()\n+\t{\n+\t  if (__position > __s.size())\n+\t    __throw_out_of_range(__N(\"bitset::bitset initial position \"\n+\t\t\t\t     \"not valid\"));\n+\t  _M_copy_from_string(__s, __position,\n+\t\t\t      basic_string<_CharT, _Traits, _Alloc>::npos);\n+\t}\n+\n+      /**\n+       *  @brief  Use a subset of a string.\n+       *  @param  s  A string of '0' and '1' characters.\n+       *  @param  position  Index of the first character in @a s to use.\n+       *  @param  n    The number of characters to copy.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n+       *  @throw  std::invalid_argument  If a character appears in the string\n+       *                                 which is neither '0' nor '1'.\n+       */\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tbitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t       size_t __position, size_t __n)\n+\t: _Base()\n+\t{\n+\t  if (__position > __s.size())\n+\t    __throw_out_of_range(__N(\"bitset::bitset initial position \"\n+\t\t\t\t     \"not valid\"));\n+\t  _M_copy_from_string(__s, __position, __n);\n+\t}\n+      \n+      // 23.3.5.2 bitset operations:\n+      //@{\n+      /**\n+       *  @brief  Operations on bitsets.\n+       *  @param  rhs  A same-sized bitset.\n+       *\n+       *  These should be self-explanatory.\n+       */\n+      bitset<_Nb>&\n+      operator&=(const bitset<_Nb>& __rhs)\n       {\n-\t_M_wp = &__b._M_getword(__pos);\n-\t_M_bpos = _Base::_S_whichbit(__pos);\n+\tthis->_M_do_and(__rhs);\n+\treturn *this;\n       }\n \n-      ~reference() { }\n+      bitset<_Nb>&\n+      operator|=(const bitset<_Nb>& __rhs)\n+      {\n+\tthis->_M_do_or(__rhs);\n+\treturn *this;\n+      }\n \n-      // For b[i] = __x;\n-      reference&\n-      operator=(bool __x)\n+      bitset<_Nb>&\n+      operator^=(const bitset<_Nb>& __rhs)\n+      {\n+\tthis->_M_do_xor(__rhs);\n+\treturn *this;\n+      }\n+      //@}\n+      \n+      //@{\n+      /**\n+       *  @brief  Operations on bitsets.\n+       *  @param  position  The number of places to shift.\n+       *\n+       *  These should be self-explanatory.\n+       */\n+      bitset<_Nb>&\n+      operator<<=(size_t __position)\n       {\n-\tif ( __x )\n-\t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\tif (__builtin_expect(__position < _Nb, 1))\n+\t  {\n+\t    this->_M_do_left_shift(__position);\n+\t    this->_M_do_sanitize();\n+\t  }\n \telse\n-\t  *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\t  this->_M_do_reset();\n \treturn *this;\n       }\n \n-      // For b[i] = b[__j];\n-      reference&\n-      operator=(const reference& __j)\n+      bitset<_Nb>&\n+      operator>>=(size_t __position)\n       {\n-\tif ( (*(__j._M_wp) & _Base::_S_maskbit(__j._M_bpos)) )\n-\t  *_M_wp |= _Base::_S_maskbit(_M_bpos);\n+\tif (__builtin_expect(__position < _Nb, 1))\n+\t  {\n+\t    this->_M_do_right_shift(__position);\n+\t    this->_M_do_sanitize();\n+\t  }\n \telse\n-\t  *_M_wp &= ~_Base::_S_maskbit(_M_bpos);\n+\t  this->_M_do_reset();\n \treturn *this;\n       }\n-\n-      // Flips the bit\n-      bool\n-      operator~() const\n-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n-\n-      // For __x = b[i];\n-      operator bool() const\n-      { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n-\n-      // For b[i].flip();\n-      reference&\n-      flip()\n+      //@}\n+      \n+      //@{\n+      /**\n+       *  These versions of single-bit set, reset, flip, and test are\n+       *  extensions from the SGI version.  They do no range checking.\n+       *  @ingroup SGIextensions\n+       */\n+      bitset<_Nb>&\n+      _Unchecked_set(size_t __pos)\n       {\n-\t*_M_wp ^= _Base::_S_maskbit(_M_bpos);\n+\tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n \treturn *this;\n       }\n-    };\n-    friend class reference;\n-\n-    // 23.3.5.1 constructors:\n-    /// All bits set to zero.\n-    bitset() { }\n-\n-    /// Initial bits bitwise-copied from a single word (others set to zero).\n-    bitset(unsigned long __val) : _Base(__val)\n-    { _M_do_sanitize(); }\n-\n-    /**\n-     *  @brief  Use a subset of a string.\n-     *  @param  s  A string of '0' and '1' characters.\n-     *  @param  position  Index of the first character in @a s to use; defaults\n-     *               to zero.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n-     *  @throw  std::invalid_argument  If a character appears in the string\n-     *                                 which is neither '0' nor '1'.\n-    */\n-    template<class _CharT, class _Traits, class _Alloc>\n-      explicit bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-\t\t      size_t __position = 0) : _Base()\n+\n+      bitset<_Nb>&\n+      _Unchecked_set(size_t __pos, int __val)\n       {\n-\tif (__position > __s.size())\n-\t  __throw_out_of_range(__N(\"bitset::bitset initial position \"\n-\t\t\t\t   \"not valid\"));\n-\t_M_copy_from_string(__s, __position,\n-\t\t\t    basic_string<_CharT, _Traits, _Alloc>::npos);\n+\tif (__val)\n+\t  this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n+\telse\n+\t  this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+\treturn *this;\n       }\n \n-    /**\n-     *  @brief  Use a subset of a string.\n-     *  @param  s  A string of '0' and '1' characters.\n-     *  @param  position  Index of the first character in @a s to use.\n-     *  @param  n    The number of characters to copy.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of @a s.\n-     *  @throw  std::invalid_argument  If a character appears in the string\n-     *                                 which is neither '0' nor '1'.\n-    */\n-    template<class _CharT, class _Traits, class _Alloc>\n-      bitset(const basic_string<_CharT, _Traits, _Alloc>& __s,\n-\t     size_t __position, size_t __n) : _Base()\n+      bitset<_Nb>&\n+      _Unchecked_reset(size_t __pos)\n       {\n-\tif (__position > __s.size())\n-\t __throw_out_of_range(__N(\"bitset::bitset initial position \"\n-\t\t\t\t  \"not valid\"));\n-\t_M_copy_from_string(__s, __position, __n);\n+\tthis->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n+\treturn *this;\n       }\n \n-    // 23.3.5.2 bitset operations:\n-    //@{\n-    /**\n-     *  @brief  Operations on bitsets.\n-     *  @param  rhs  A same-sized bitset.\n-     *\n-     *  These should be self-explanatory.\n-    */\n-    bitset<_Nb>&\n-    operator&=(const bitset<_Nb>& __rhs)\n-    {\n-      this->_M_do_and(__rhs);\n-      return *this;\n-    }\n+      bitset<_Nb>&\n+      _Unchecked_flip(size_t __pos)\n+      {\n+\tthis->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n+\treturn *this;\n+      }\n \n-    bitset<_Nb>&\n-    operator|=(const bitset<_Nb>& __rhs)\n-    {\n-      this->_M_do_or(__rhs);\n-      return *this;\n-    }\n+      bool\n+      _Unchecked_test(size_t __pos) const\n+      { return ((this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n+\t\t!= static_cast<_WordT>(0)); }\n+      //@}\n+      \n+      // Set, reset, and flip.\n+      /**\n+       *  @brief Sets every bit to true.\n+       */\n+      bitset<_Nb>&\n+      set()\n+      {\n+\tthis->_M_do_set();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n \n-    bitset<_Nb>&\n-    operator^=(const bitset<_Nb>& __rhs)\n-    {\n-      this->_M_do_xor(__rhs);\n-      return *this;\n-    }\n-    //@}\n-\n-    //@{\n-    /**\n-     *  @brief  Operations on bitsets.\n-     *  @param  position  The number of places to shift.\n-     *\n-     *  These should be self-explanatory.\n-    */\n-    bitset<_Nb>&\n-    operator<<=(size_t __position)\n-    {\n-      if (__builtin_expect(__position < _Nb, 1))\n-        {\n-          this->_M_do_left_shift(__position);\n-          this->_M_do_sanitize();\n-        }\n-      else\n-\tthis->_M_do_reset();\n-      return *this;\n-    }\n+      /**\n+       *  @brief Sets a given bit to a particular value.\n+       *  @param  position  The index of the bit.\n+       *  @param  val  Either true or false, defaults to true.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      bitset<_Nb>&\n+      set(size_t __position, bool __val = true)\n+      {\n+\tif (__position >= _Nb)\n+\t  __throw_out_of_range(__N(\"bitset::set\"));\n+\treturn _Unchecked_set(__position, __val);\n+      }\n \n-    bitset<_Nb>&\n-    operator>>=(size_t __position)\n-    {\n-      if (__builtin_expect(__position < _Nb, 1))\n-        {\n-          this->_M_do_right_shift(__position);\n-          this->_M_do_sanitize();\n-        }\n-      else\n+      /**\n+       *  @brief Sets every bit to false.\n+       */\n+      bitset<_Nb>&\n+      reset()\n+      {\n \tthis->_M_do_reset();\n-      return *this;\n-    }\n-    //@}\n-\n-    //@{\n-    /**\n-     *  These versions of single-bit set, reset, flip, and test are\n-     *  extensions from the SGI version.  They do no range checking.\n-     *  @ingroup SGIextensions\n-    */\n-    bitset<_Nb>&\n-    _Unchecked_set(size_t __pos)\n-    {\n-      this->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n-      return *this;\n-    }\n-\n-    bitset<_Nb>&\n-    _Unchecked_set(size_t __pos, int __val)\n-    {\n-      if (__val)\n-\tthis->_M_getword(__pos) |= _Base::_S_maskbit(__pos);\n-      else\n-\tthis->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n-      return *this;\n-    }\n+\treturn *this;\n+      }\n \n-    bitset<_Nb>&\n-    _Unchecked_reset(size_t __pos)\n-    {\n-      this->_M_getword(__pos) &= ~_Base::_S_maskbit(__pos);\n-      return *this;\n-    }\n+      /**\n+       *  @brief Sets a given bit to false.\n+       *  @param  position  The index of the bit.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       *\n+       *  Same as writing @c set(pos,false).\n+       */\n+      bitset<_Nb>&\n+      reset(size_t __position)\n+      {\n+\tif (__position >= _Nb)\n+\t  __throw_out_of_range(__N(\"bitset::reset\"));\n+\treturn _Unchecked_reset(__position);\n+      }\n+      \n+      /**\n+       *  @brief Toggles every bit to its opposite value.\n+       */\n+      bitset<_Nb>&\n+      flip()\n+      {\n+\tthis->_M_do_flip();\n+\tthis->_M_do_sanitize();\n+\treturn *this;\n+      }\n \n-    bitset<_Nb>&\n-    _Unchecked_flip(size_t __pos)\n-    {\n-      this->_M_getword(__pos) ^= _Base::_S_maskbit(__pos);\n-      return *this;\n-    }\n+      /**\n+       *  @brief Toggles a given bit to its opposite value.\n+       *  @param  position  The index of the bit.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      bitset<_Nb>&\n+      flip(size_t __position)\n+      {\n+\tif (__position >= _Nb)\n+\t  __throw_out_of_range(__N(\"bitset::flip\"));\n+\treturn _Unchecked_flip(__position);\n+      }\n+      \n+      /// See the no-argument flip().\n+      bitset<_Nb>\n+      operator~() const\n+      { return bitset<_Nb>(*this).flip(); }\n+\n+      //@{\n+      /**\n+       *  @brief  Array-indexing support.\n+       *  @param  position  Index into the %bitset.\n+       *  @return  A bool for a 'const %bitset'.  For non-const bitsets, an\n+       *           instance of the reference proxy class.\n+       *  @note  These operators do no range checking and throw no exceptions,\n+       *         as required by DR 11 to the standard.\n+       *\n+       *  @if maint\n+       *  _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already\n+       *  resolves DR 11 (items 1 and 2), but does not do the range-checking\n+       *  required by that DR's resolution.  -pme\n+       *  The DR has since been changed:  range-checking is a precondition\n+       *  (users' responsibility), and these functions must not throw.  -pme\n+       *  @endif\n+       */\n+      reference\n+      operator[](size_t __position)\n+      { return reference(*this,__position); }\n \n-    bool\n-    _Unchecked_test(size_t __pos) const\n-    {\n-      return (this->_M_getword(__pos) & _Base::_S_maskbit(__pos))\n-\t!= static_cast<_WordT>(0);\n-    }\n-    //@}\n-\n-    // Set, reset, and flip.\n-    /**\n-     *  @brief Sets every bit to true.\n-    */\n-    bitset<_Nb>&\n-    set()\n-    {\n-      this->_M_do_set();\n-      this->_M_do_sanitize();\n-      return *this;\n-    }\n+      bool\n+      operator[](size_t __position) const\n+      { return _Unchecked_test(__position); }\n+      //@}\n+      \n+      /**\n+       *  @brief Retuns a numerical interpretation of the %bitset.\n+       *  @return  The integral equivalent of the bits.\n+       *  @throw  std::overflow_error  If there are too many bits to be\n+       *                               represented in an @c unsigned @c long.\n+       */\n+      unsigned long\n+      to_ulong() const\n+      { return this->_M_do_to_ulong(); }\n+\n+      /**\n+       *  @brief Retuns a character interpretation of the %bitset.\n+       *  @return  The string equivalent of the bits.\n+       *\n+       *  Note the ordering of the bits:  decreasing character positions\n+       *  correspond to increasing bit positions (see the main class notes for\n+       *  an example).\n+       *\n+       *  Also note that you must specify the string's template parameters\n+       *  explicitly.  Given a bitset @c bs and a string @s:\n+       *  @code\n+       *     s = bs.to_string<char,char_traits<char>,allocator<char> >();\n+       *  @endcode\n+       */\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tbasic_string<_CharT, _Traits, _Alloc>\n+\tto_string() const\n+\t{\n+\t  basic_string<_CharT, _Traits, _Alloc> __result;\n+\t  _M_copy_to_string(__result);\n+\t  return __result;\n+\t}\n \n-    /**\n-     *  @brief Sets a given bit to a particular value.\n-     *  @param  position  The index of the bit.\n-     *  @param  val  Either true or false, defaults to true.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n-    */\n-    bitset<_Nb>&\n-    set(size_t __position, bool __val = true)\n-    {\n-      if (__position >= _Nb)\n-\t__throw_out_of_range(__N(\"bitset::set\"));\n-      return _Unchecked_set(__position, __val);\n-    }\n+      // Helper functions for string operations.\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tvoid\n+\t_M_copy_from_string(const basic_string<_CharT, _Traits, _Alloc>& __s,\n+\t\t\t    size_t, size_t);\n \n-    /**\n-     *  @brief Sets every bit to false.\n-    */\n-    bitset<_Nb>&\n-    reset()\n-    {\n-      this->_M_do_reset();\n-      return *this;\n-    }\n+      template<class _CharT, class _Traits, class _Alloc>\n+\tvoid\n+\t_M_copy_to_string(basic_string<_CharT, _Traits, _Alloc>&) const;\n \n-    /**\n-     *  @brief Sets a given bit to false.\n-     *  @param  position  The index of the bit.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n-     *\n-     *  Same as writing @c set(pos,false).\n-    */\n-    bitset<_Nb>&\n-    reset(size_t __position)\n-    {\n-      if (__position >= _Nb)\n-\t__throw_out_of_range(__N(\"bitset::reset\"));\n-      return _Unchecked_reset(__position);\n-    }\n+      /// Returns the number of bits which are set.\n+      size_t\n+      count() const\n+      { return this->_M_do_count(); }\n \n-    /**\n-     *  @brief Toggles every bit to its opposite value.\n-    */\n-    bitset<_Nb>&\n-    flip()\n-    {\n-      this->_M_do_flip();\n-      this->_M_do_sanitize();\n-      return *this;\n-    }\n+      /// Returns the total number of bits.\n+      size_t\n+      size() const\n+      { return _Nb; }\n \n-    /**\n-     *  @brief Toggles a given bit to its opposite value.\n-     *  @param  position  The index of the bit.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n-    */\n-    bitset<_Nb>&\n-    flip(size_t __position)\n-    {\n-      if (__position >= _Nb)\n-\t__throw_out_of_range(__N(\"bitset::flip\"));\n-      return _Unchecked_flip(__position);\n-    }\n+      //@{\n+      /// These comparisons for equality/inequality are, well, @e bitwise.\n+      bool\n+      operator==(const bitset<_Nb>& __rhs) const\n+      { return this->_M_is_equal(__rhs); }\n \n-    /// See the no-argument flip().\n-    bitset<_Nb>\n-    operator~() const { return bitset<_Nb>(*this).flip(); }\n-\n-    //@{\n-    /**\n-     *  @brief  Array-indexing support.\n-     *  @param  position  Index into the %bitset.\n-     *  @return  A bool for a 'const %bitset'.  For non-const bitsets, an\n-     *           instance of the reference proxy class.\n-     *  @note  These operators do no range checking and throw no exceptions,\n-     *         as required by DR 11 to the standard.\n-     *\n-     *  @if maint\n-     *  _GLIBCXX_RESOLVE_LIB_DEFECTS Note that this implementation already\n-     *  resolves DR 11 (items 1 and 2), but does not do the range-checking\n-     *  required by that DR's resolution.  -pme\n-     *  The DR has since been changed:  range-checking is a precondition\n-     *  (users' responsibility), and these functions must not throw.  -pme\n-     *  @endif\n-    */\n-    reference\n-    operator[](size_t __position) { return reference(*this,__position); }\n-\n-    bool\n-    operator[](size_t __position) const { return _Unchecked_test(__position); }\n-    //@}\n-\n-    /**\n-     *  @brief Retuns a numerical interpretation of the %bitset.\n-     *  @return  The integral equivalent of the bits.\n-     *  @throw  std::overflow_error  If there are too many bits to be\n-     *                               represented in an @c unsigned @c long.\n-    */\n-    unsigned long\n-    to_ulong() const { return this->_M_do_to_ulong(); }\n-\n-    /**\n-     *  @brief Retuns a character interpretation of the %bitset.\n-     *  @return  The string equivalent of the bits.\n-     *\n-     *  Note the ordering of the bits:  decreasing character positions\n-     *  correspond to increasing bit positions (see the main class notes for\n-     *  an example).\n-     *\n-     *  Also note that you must specify the string's template parameters\n-     *  explicitly.  Given a bitset @c bs and a string @s:\n-     *  @code\n-     *     s = bs.to_string<char,char_traits<char>,allocator<char> >();\n-     *  @endcode\n-    */\n-    template<class _CharT, class _Traits, class _Alloc>\n-      basic_string<_CharT, _Traits, _Alloc>\n-      to_string() const\n+      bool\n+      operator!=(const bitset<_Nb>& __rhs) const\n+      { return !this->_M_is_equal(__rhs); }\n+      //@}\n+      \n+      /**\n+       *  @brief Tests the value of a bit.\n+       *  @param  position  The index of a bit.\n+       *  @return  The value at @a pos.\n+       *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n+       */\n+      bool\n+      test(size_t __position) const\n       {\n-\tbasic_string<_CharT, _Traits, _Alloc> __result;\n-\t_M_copy_to_string(__result);\n-\treturn __result;\n+\tif (__position >= _Nb)\n+\t  __throw_out_of_range(__N(\"bitset::test\"));\n+\treturn _Unchecked_test(__position);\n       }\n+      \n+      /**\n+       *  @brief Tests whether any of the bits are on.\n+       *  @return  True if at least one bit is set.\n+       */\n+      bool\n+      any() const\n+      { return this->_M_is_any(); }\n \n-    // Helper functions for string operations.\n-    template<class _CharT, class _Traits, class _Alloc>\n-      void\n-      _M_copy_from_string(const basic_string<_CharT,_Traits,_Alloc>& __s,\n-                          size_t, size_t);\n-\n-    template<class _CharT, class _Traits, class _Alloc>\n-      void\n-      _M_copy_to_string(basic_string<_CharT,_Traits,_Alloc>&) const;\n-\n-    /// Returns the number of bits which are set.\n-    size_t\n-    count() const { return this->_M_do_count(); }\n-\n-    /// Returns the total number of bits.\n-    size_t\n-    size() const { return _Nb; }\n-\n-    //@{\n-    /// These comparisons for equality/inequality are, well, @e bitwise.\n-    bool\n-    operator==(const bitset<_Nb>& __rhs) const\n-    { return this->_M_is_equal(__rhs); }\n-\n-    bool\n-    operator!=(const bitset<_Nb>& __rhs) const\n-    { return !this->_M_is_equal(__rhs); }\n-    //@}\n-\n-    /**\n-     *  @brief Tests the value of a bit.\n-     *  @param  position  The index of a bit.\n-     *  @return  The value at @a pos.\n-     *  @throw  std::out_of_range  If @a pos is bigger the size of the %set.\n-    */\n-    bool\n-    test(size_t __position) const\n-    {\n-      if (__position >= _Nb)\n-\t__throw_out_of_range(__N(\"bitset::test\"));\n-      return _Unchecked_test(__position);\n-    }\n-\n-    /**\n-     *  @brief Tests whether any of the bits are on.\n-     *  @return  True if at least one bit is set.\n-    */\n-    bool\n-    any() const { return this->_M_is_any(); }\n-\n-    /**\n-     *  @brief Tests whether any of the bits are on.\n-     *  @return  True if none of the bits are set.\n-    */\n-    bool\n-    none() const { return !this->_M_is_any(); }\n-\n-    //@{\n-    /// Self-explanatory.\n-    bitset<_Nb>\n-    operator<<(size_t __position) const\n-    { return bitset<_Nb>(*this) <<= __position; }\n-\n-    bitset<_Nb>\n-    operator>>(size_t __position) const\n-    { return bitset<_Nb>(*this) >>= __position; }\n-    //@}\n-\n-    /**\n-     *  @brief  Finds the index of the first \"on\" bit.\n-     *  @return  The index of the first bit set, or size() if not found.\n-     *  @ingroup SGIextensions\n-     *  @sa  _Find_next\n-    */\n-    size_t\n-    _Find_first() const\n-    { return this->_M_do_find_first(_Nb); }\n-\n-    /**\n-     *  @brief  Finds the index of the next \"on\" bit after prev.\n-     *  @return  The index of the next bit set, or size() if not found.\n-     *  @param  prev  Where to start searching.\n-     *  @ingroup SGIextensions\n-     *  @sa  _Find_first\n-    */\n-    size_t\n-    _Find_next(size_t __prev ) const\n-    { return this->_M_do_find_next(__prev, _Nb); }\n-  };\n+      /**\n+       *  @brief Tests whether any of the bits are on.\n+       *  @return  True if none of the bits are set.\n+       */\n+      bool\n+      none() const\n+      { return !this->_M_is_any(); }\n+\n+      //@{\n+      /// Self-explanatory.\n+      bitset<_Nb>\n+      operator<<(size_t __position) const\n+      { return bitset<_Nb>(*this) <<= __position; }\n+\n+      bitset<_Nb>\n+      operator>>(size_t __position) const\n+      { return bitset<_Nb>(*this) >>= __position; }\n+      //@}\n+      \n+      /**\n+       *  @brief  Finds the index of the first \"on\" bit.\n+       *  @return  The index of the first bit set, or size() if not found.\n+       *  @ingroup SGIextensions\n+       *  @sa  _Find_next\n+       */\n+      size_t\n+      _Find_first() const\n+      { return this->_M_do_find_first(_Nb); }\n+\n+      /**\n+       *  @brief  Finds the index of the next \"on\" bit after prev.\n+       *  @return  The index of the next bit set, or size() if not found.\n+       *  @param  prev  Where to start searching.\n+       *  @ingroup SGIextensions\n+       *  @sa  _Find_first\n+       */\n+      size_t\n+      _Find_next(size_t __prev ) const\n+      { return this->_M_do_find_next(__prev, _Nb); }\n+    };\n \n   // Definitions of non-inline member functions.\n   template<size_t _Nb>\n     template<class _CharT, class _Traits, class _Alloc>\n-    void\n-    bitset<_Nb>::_M_copy_from_string(const basic_string<_CharT, _Traits,\n-\t\t\t\t     _Alloc>& __s, size_t __pos, size_t __n)\n-    {\n-      reset();\n-      const size_t __nbits = std::min(_Nb, std::min(__n, __s.size() - __pos));\n-      for (size_t __i = 0; __i < __nbits; ++__i)\n-\t{\n-\t  switch(__s[__pos + __nbits - __i - 1])\n-\t    {\n-\t    case '0':\n-\t      break;\n-\t    case '1':\n-\t      set(__i);\n-\t      break;\n-\t    default:\n-\t      __throw_invalid_argument(__N(\"bitset::_M_copy_from_string\"));\n-\t    }\n-\t}\n-    }\n+      void\n+      bitset<_Nb>::_M_copy_from_string(const basic_string<_CharT, _Traits,\n+\t\t\t\t       _Alloc>& __s, size_t __pos, size_t __n)\n+      {\n+\treset();\n+\tconst size_t __nbits = std::min(_Nb, std::min(__n, __s.size() - __pos));\n+\tfor (size_t __i = 0; __i < __nbits; ++__i)\n+\t  {\n+\t    switch(__s[__pos + __nbits - __i - 1])\n+\t      {\n+\t      case '0':\n+\t\tbreak;\n+\t      case '1':\n+\t\tset(__i);\n+\t\tbreak;\n+\t      default:\n+\t\t__throw_invalid_argument(__N(\"bitset::_M_copy_from_string\"));\n+\t      }\n+\t  }\n+      }\n \n   template<size_t _Nb>\n     template<class _CharT, class _Traits, class _Alloc>\n-    void\n-    bitset<_Nb>::_M_copy_to_string(basic_string<_CharT, _Traits,\n-\t\t\t\t   _Alloc>& __s) const\n-    {\n-      __s.assign(_Nb, '0');\n-      for (size_t __i = 0; __i < _Nb; ++__i)\n-\tif (_Unchecked_test(__i))\n-\t  __s[_Nb - 1 - __i] = '1';\n-    }\n+      void\n+      bitset<_Nb>::_M_copy_to_string(basic_string<_CharT, _Traits,\n+\t\t\t\t     _Alloc>& __s) const\n+      {\n+\t__s.assign(_Nb, '0');\n+\tfor (size_t __i = 0; __i < _Nb; ++__i)\n+\t  if (_Unchecked_test(__i))\n+\t    __s[_Nb - 1 - __i] = '1';\n+      }\n \n   // 23.3.5.3 bitset operations:\n   //@{\n@@ -1181,7 +1237,7 @@ namespace _GLIBCXX_STD\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      char_type __c2 = _Traits::to_char_type(__c1);\n+\t\t      const char_type __c2 = _Traits::to_char_type(__c1);\n \t\t      if (__c2 == __zero)\n \t\t\t__tmp.push_back('0');\n \t\t      else if (__c2 == __one)"}]}