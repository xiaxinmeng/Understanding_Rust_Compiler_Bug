{"sha": "701b17c2dc9a6d35097455e6fd410d4dabce29e7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzAxYjE3YzJkYzlhNmQzNTA5NzQ1NWU2ZmQ0MTBkNGRhYmNlMjllNw==", "commit": {"author": {"name": "Pat Haugen", "email": "pthaugen@us.ibm.com", "date": "2004-06-23T16:07:58Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2004-06-23T16:07:58Z"}, "message": "re PR rtl-optimization/15633 (Failure to propagate FDO counters by vpt results in performance regression)\n\n2004-06-23  Pat Haugen  <pthaugen@us.ibm.com>\n\n        PR optimization/15633\n        * value-prof.c (divmod_fixed_value_transform): Compute probability\n        of taking optimal path and pass along to gen_ routine.\n        (mod_pow2_value_transform): Same.\n        (mod_subtract_transform): Same.\n        (gen_divmod_fixed_value): Add new probability parameter.\n        Add probability to newly created jump.\n        (gen_mod_pow2): Same.\n        (gen_mod_subtract): Same.\n\nFrom-SVN: r83555", "tree": {"sha": "1a89f07a18835e2ff45f39c2a9c51d277d13ed95", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a89f07a18835e2ff45f39c2a9c51d277d13ed95"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/701b17c2dc9a6d35097455e6fd410d4dabce29e7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701b17c2dc9a6d35097455e6fd410d4dabce29e7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/701b17c2dc9a6d35097455e6fd410d4dabce29e7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/701b17c2dc9a6d35097455e6fd410d4dabce29e7/comments", "author": null, "committer": null, "parents": [{"sha": "dcbbf6f31bcbb4a3f03793eb6415c6b8202b9f93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dcbbf6f31bcbb4a3f03793eb6415c6b8202b9f93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dcbbf6f31bcbb4a3f03793eb6415c6b8202b9f93"}], "stats": {"total": 94, "additions": 74, "deletions": 20}, "files": [{"sha": "b907be90ed2d301ab61974645ec2ae48515c51d6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/701b17c2dc9a6d35097455e6fd410d4dabce29e7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/701b17c2dc9a6d35097455e6fd410d4dabce29e7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=701b17c2dc9a6d35097455e6fd410d4dabce29e7", "patch": "@@ -1,3 +1,15 @@\n+2004-06-23  Pat Haugen  <pthaugen@us.ibm.com>\n+\n+\tPR optimization/15633\n+\t* value-prof.c (divmod_fixed_value_transform): Compute probability\n+\tof taking optimal path and pass along to gen_ routine.\n+\t(mod_pow2_value_transform): Same.\n+\t(mod_subtract_transform): Same.\n+\t(gen_divmod_fixed_value): Add new probability parameter.\n+\tAdd probability to newly created jump.\n+\t(gen_mod_pow2): Same.\n+\t(gen_mod_subtract): Same.\n+\n 2004-06-23  Richard Earnshaw  <rearnsha@arm.com>\n \n \t* PR target/15948"}, {"sha": "17f78f6cbbddaa6c871247b5272f270a22b3410f", "filename": "gcc/value-prof.c", "status": "modified", "additions": 62, "deletions": 20, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/701b17c2dc9a6d35097455e6fd410d4dabce29e7/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/701b17c2dc9a6d35097455e6fd410d4dabce29e7/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=701b17c2dc9a6d35097455e6fd410d4dabce29e7", "patch": "@@ -56,10 +56,10 @@ static void insn_divmod_values_to_profile (rtx, unsigned *,\n \t\t\t\t\t   struct histogram_value **);\n static void insn_values_to_profile (rtx, unsigned *, struct histogram_value **);\n static rtx gen_divmod_fixed_value (enum machine_mode, enum rtx_code, rtx, rtx,\n-\t\t\t\t   rtx, gcov_type);\n-static rtx gen_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx);\n+\t\t\t\t   rtx, gcov_type, int);\n+static rtx gen_mod_pow2 (enum machine_mode, enum rtx_code, rtx, rtx, rtx, int);\n static rtx gen_mod_subtract (enum machine_mode, enum rtx_code, rtx, rtx, rtx,\n-\t\t\t     int);\n+\t\t\t     int, int, int);\n static bool divmod_fixed_value_transform (rtx insn);\n static bool mod_pow2_value_transform (rtx);\n static bool mod_subtract_transform (rtx);\n@@ -365,12 +365,14 @@ rtl_value_profile_transformations (void)\n }\n \n /* Generate code for transformation 1 (with MODE and OPERATION, operands OP1\n-   and OP2 whose value is expected to be VALUE and result TARGET).  */\n+   and OP2, whose value is expected to be VALUE, result TARGET and\n+   probability of taking the optimal path PROB).  */\n static rtx\n gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n-\t\t\trtx target, rtx op1, rtx op2, gcov_type value)\n+\t\t\trtx target, rtx op1, rtx op2, gcov_type value,\n+\t\t\tint prob)\n {\n-  rtx tmp, tmp1;\n+  rtx tmp, tmp1, jump;\n   rtx neq_label = gen_label_rtx ();\n   rtx end_label = gen_label_rtx ();\n   rtx sequence;\n@@ -387,7 +389,15 @@ gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n \n   do_compare_rtx_and_jump (tmp, GEN_INT (value), NE, 0, mode, NULL_RTX,\n \t\t\t   NULL_RTX, neq_label);\n-  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), GEN_INT (value));\n+\n+  /* Add branch probability to jump we just created.  */\n+  jump = get_last_insn ();\n+  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\tGEN_INT (REG_BR_PROB_BASE - prob),\n+\t\t\t\t\tREG_NOTES (jump));\n+\n+  tmp1 = simplify_gen_binary (operation, mode,\n+\t\t\t      copy_rtx (op1), GEN_INT (value));\n   tmp1 = force_operand (tmp1, target);\n   if (tmp1 != target)\n     emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n@@ -396,7 +406,8 @@ gen_divmod_fixed_value (enum machine_mode mode, enum rtx_code operation,\n   emit_barrier ();\n \n   emit_label (neq_label);\n-  tmp1 = simplify_gen_binary (operation, mode, copy_rtx (op1), copy_rtx (tmp));\n+  tmp1 = simplify_gen_binary (operation, mode,\n+\t\t\t      copy_rtx (op1), copy_rtx (tmp));\n   tmp1 = force_operand (tmp1, target);\n   if (tmp1 != target)\n     emit_move_insn (copy_rtx (target), copy_rtx (tmp1));\n@@ -418,6 +429,7 @@ divmod_fixed_value_transform (rtx insn)\n   enum machine_mode mode;\n   gcov_type val, count, all;\n   edge e;\n+  int prob;\n \n   set = single_set (insn);\n   if (!set)\n@@ -462,22 +474,26 @@ divmod_fixed_value_transform (rtx insn)\n     fprintf (dump_file, \"Div/mod by constant transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n+  /* Compute probability of taking the optimal path.  */\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+\n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_divmod_fixed_value (mode, code, set_dest, op1, op2, val), e);\n+\tgen_divmod_fixed_value (mode, code, set_dest,\n+\t\t\t\top1, op2, val, prob), e);\n \n   return true;\n }\n \n /* Generate code for transformation 2 (with MODE and OPERATION, operands OP1\n-   and OP2 and result TARGET).  */\n+   and OP2, result TARGET and probability of taking the optimal path PROB).  */\n static rtx\n gen_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n-\t      rtx op1, rtx op2)\n+\t      rtx op1, rtx op2, int prob)\n {\n-  rtx tmp, tmp1, tmp2, tmp3;\n+  rtx tmp, tmp1, tmp2, tmp3, jump;\n   rtx neq_label = gen_label_rtx ();\n   rtx end_label = gen_label_rtx ();\n   rtx sequence;\n@@ -498,6 +514,13 @@ gen_mod_pow2 (enum machine_mode mode, enum rtx_code operation, rtx target,\n \t\t\t      0, OPTAB_WIDEN);\n   do_compare_rtx_and_jump (tmp2, const0_rtx, NE, 0, mode, NULL_RTX,\n \t\t\t   NULL_RTX, neq_label);\n+\n+  /* Add branch probability to jump we just created.  */\n+  jump = get_last_insn ();\n+  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\tGEN_INT (REG_BR_PROB_BASE - prob),\n+\t\t\t\t\tREG_NOTES (jump));\n+\n   tmp3 = expand_simple_binop (mode, AND, op1, tmp1, target,\n \t\t\t      0, OPTAB_WIDEN);\n   if (tmp3 != target)\n@@ -528,7 +551,7 @@ mod_pow2_value_transform (rtx insn)\n   enum machine_mode mode;\n   gcov_type wrong_values, count;\n   edge e;\n-  int i;\n+  int i, all, prob;\n \n   set = single_set (insn);\n   if (!set)\n@@ -578,22 +601,27 @@ mod_pow2_value_transform (rtx insn)\n     fprintf (dump_file, \"Mod power of 2 transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n+  /* Compute probability of taking the optimal path.  */\n+  all = count + wrong_values;\n+  prob = (count * REG_BR_PROB_BASE + all / 2) / all;\n+\n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_mod_pow2 (mode, code, set_dest, op1, op2), e);\n+\tgen_mod_pow2 (mode, code, set_dest, op1, op2, prob), e);\n \n   return true;\n }\n \n /* Generate code for transformations 3 and 4 (with MODE and OPERATION,\n-   operands OP1 and OP2, result TARGET and at most SUB subtractions).  */\n+   operands OP1 and OP2, result TARGET, at most SUB subtractions, and\n+   probability of taking the optimal path(s) PROB1 and PROB2).  */\n static rtx\n gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n-\t\t  rtx target, rtx op1, rtx op2, int sub)\n+\t\t  rtx target, rtx op1, rtx op2, int sub, int prob1, int prob2)\n {\n-  rtx tmp, tmp1;\n+  rtx tmp, tmp1, jump;\n   rtx end_label = gen_label_rtx ();\n   rtx sequence;\n   int i;\n@@ -611,7 +639,11 @@ gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n   emit_move_insn (target, copy_rtx (op1));\n   do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n \t\t\t   NULL_RTX, end_label);\n-  \n+\n+  /* Add branch probability to jump we just created.  */\n+  jump = get_last_insn ();\n+  REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\tGEN_INT (prob1), REG_NOTES (jump));\n \n   for (i = 0; i < sub; i++)\n     {\n@@ -621,6 +653,11 @@ gen_mod_subtract (enum machine_mode mode, enum rtx_code operation,\n \temit_move_insn (target, tmp1);\n       do_compare_rtx_and_jump (target, tmp, LTU, 0, mode, NULL_RTX,\n     \t\t\t       NULL_RTX, end_label);\n+\n+      /* Add branch probability to jump we just created.  */\n+      jump = get_last_insn ();\n+      REG_NOTES (jump) = gen_rtx_EXPR_LIST (REG_BR_PROB,\n+\t\t\t\t\t    GEN_INT (prob2), REG_NOTES (jump));\n     }\n \n   tmp1 = simplify_gen_binary (operation, mode, copy_rtx (target), copy_rtx (tmp));\n@@ -645,7 +682,7 @@ mod_subtract_transform (rtx insn)\n   enum machine_mode mode;\n   gcov_type wrong_values, counts[2], count, all;\n   edge e;\n-  int i;\n+  int i, prob1, prob2;\n \n   set = single_set (insn);\n   if (!set)\n@@ -704,11 +741,16 @@ mod_subtract_transform (rtx insn)\n     fprintf (dump_file, \"Mod subtract transformation on insn %d\\n\",\n \t     INSN_UID (insn));\n \n+  /* Compute probability of taking the optimal path(s).  */\n+  prob1 = (counts[0] * REG_BR_PROB_BASE + all / 2) / all;\n+  prob2 = (counts[1] * REG_BR_PROB_BASE + all / 2) / all;\n+\n   e = split_block (BLOCK_FOR_INSN (insn), PREV_INSN (insn));\n   delete_insn (insn);\n   \n   insert_insn_on_edge (\n-\tgen_mod_subtract (mode, code, set_dest, op1, op2, i), e);\n+\tgen_mod_subtract (mode, code, set_dest,\n+\t\t\t  op1, op2, i, prob1, prob2), e);\n \n   return true;\n }"}]}