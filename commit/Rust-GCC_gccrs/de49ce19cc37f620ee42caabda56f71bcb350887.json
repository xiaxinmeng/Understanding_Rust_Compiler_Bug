{"sha": "de49ce19cc37f620ee42caabda56f71bcb350887", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU0OWNlMTljYzM3ZjYyMGVlNDJjYWFiZGE1NmY3MWJjYjM1MDg4Nw==", "commit": {"author": {"name": "Trevor Saunders", "email": "tsaunders@mozilla.com", "date": "2014-05-17T23:08:00Z"}, "committer": {"name": "Trevor Saunders", "email": "tbsaunde@gcc.gnu.org", "date": "2014-05-17T23:08:00Z"}, "message": "add finalizers to ggc\n\nThis implements finalizers by keeping a list of registered finalizers\nand after every mark but before sweeping check to see if any of them are\nfor unmarked blocks.\n\ngcc/ChangeLog:\n\n\t* ggc-common.c (ggc_internal_cleared_alloc): Adjust.\n\t* ggc-none.c (ggc_internal_alloc): Assert if a finalizer is passed.\n\t(ggc_internal_cleared_alloc): Likewise.\n\t* ggc-page.c (finalizer): New class.\n(vec_finalizer): Likewise.\n\t(globals::finalizers): New member.\n(globals::vec_finalizers): Likewise.\n\t(ggc_internal_alloc): Record the finalizer if any for the block being\n\tallocated.\n\t(ggc_handle_finalizers): New function.\n\t(ggc_collect): Call ggc_handle_finalizers.\n\t* ggc.h (ggc_internal_alloc): Add arguments to allow installing a\n\tfinalizer.\n\t(ggc_internal_cleared_alloc): Likewise.\n\t(finalize): New function.\n\t(need_finalization_p): Likewise.\n\t(ggc_alloc): Install the type's destructor as the finalizer if it\n\tmight do something.\n\t(ggc_cleared_alloc): Likewise.\n\t(ggc_vec_alloc): Likewise.\n\t(ggc_cleared_vec_alloc): Likewise.\n\nFrom-SVN: r210568", "tree": {"sha": "10dcc038bf8bcfb0dd6268ffbf36527b525bfb4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/10dcc038bf8bcfb0dd6268ffbf36527b525bfb4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de49ce19cc37f620ee42caabda56f71bcb350887", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de49ce19cc37f620ee42caabda56f71bcb350887", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de49ce19cc37f620ee42caabda56f71bcb350887", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de49ce19cc37f620ee42caabda56f71bcb350887/comments", "author": null, "committer": null, "parents": [{"sha": "04eec9877832c7cbb0ed270f700db8e5e3f25c93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/04eec9877832c7cbb0ed270f700db8e5e3f25c93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/04eec9877832c7cbb0ed270f700db8e5e3f25c93"}], "stats": {"total": 195, "additions": 182, "deletions": 13}, "files": [{"sha": "53dc3e167974d80c83f272045a82aa16111fba84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=de49ce19cc37f620ee42caabda56f71bcb350887", "patch": "@@ -1,3 +1,27 @@\n+2014-05-17  Trevor Saunders  <tsaunders@mozilla.com>\n+\n+\t* ggc-common.c (ggc_internal_cleared_alloc): Adjust.\n+\t* ggc-none.c (ggc_internal_alloc): Assert if a finalizer is passed.\n+\t(ggc_internal_cleared_alloc): Likewise.\n+\t* ggc-page.c (finalizer): New class.\n+(vec_finalizer): Likewise.\n+\t(globals::finalizers): New member.\n+(globals::vec_finalizers): Likewise.\n+\t(ggc_internal_alloc): Record the finalizer if any for the block being\n+\tallocated.\n+\t(ggc_handle_finalizers): New function.\n+\t(ggc_collect): Call ggc_handle_finalizers.\n+\t* ggc.h (ggc_internal_alloc): Add arguments to allow installing a\n+\tfinalizer.\n+\t(ggc_internal_cleared_alloc): Likewise.\n+\t(finalize): New function.\n+\t(need_finalization_p): Likewise.\n+\t(ggc_alloc): Install the type's destructor as the finalizer if it\n+\tmight do something.\n+\t(ggc_cleared_alloc): Likewise.\n+\t(ggc_vec_alloc): Likewise.\n+\t(ggc_cleared_vec_alloc): Likewise.\n+\n 2014-05-17  Trevor Saunders  <tsaunders@mozilla.com>\n \n \t* ggc.h (ggc_alloc_cleared_simd_clone_stat): Remove function."}, {"sha": "b11a10c00726911b77c4c044bb767ca0ce98340f", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=de49ce19cc37f620ee42caabda56f71bcb350887", "patch": "@@ -174,9 +174,10 @@ ggc_mark_roots (void)\n \n /* Allocate a block of memory, then clear it.  */\n void *\n-ggc_internal_cleared_alloc (size_t size MEM_STAT_DECL)\n+ggc_internal_cleared_alloc (size_t size, void (*f)(void *), size_t s, size_t n\n+\t\t\t    MEM_STAT_DECL)\n {\n-  void *buf = ggc_internal_alloc (size PASS_MEM_STAT);\n+  void *buf = ggc_internal_alloc (size, f, s, n PASS_MEM_STAT);\n   memset (buf, 0, size);\n   return buf;\n }"}, {"sha": "97d356657f00d0e0f5e7bb4ea40dd7edfbf4a2b9", "filename": "gcc/ggc-none.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-none.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-none.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-none.c?ref=de49ce19cc37f620ee42caabda56f71bcb350887", "patch": "@@ -41,14 +41,18 @@ ggc_round_alloc_size (size_t requested_size)\n }\n \n void *\n-ggc_internal_alloc (size_t size MEM_STAT_DECL)\n+ggc_internal_alloc (size_t size, void (*f)(void *), size_t, size_t\n+\t\t    MEM_STAT_DECL)\n {\n+  gcc_assert (!f); // ggc-none doesn't support finalizers\n   return xmalloc (size);\n }\n \n void *\n-ggc_internal_cleared_alloc (size_t size MEM_STAT_DECL)\n+ggc_internal_cleared_alloc (size_t size, void (*f)(void *), size_t, size_t\n+\t\t\t    MEM_STAT_DECL)\n {\n+  gcc_assert (!f); // ggc-none doesn't support finalizers\n   return xcalloc (size, 1);\n }\n "}, {"sha": "b3a1a2a103fe74f446cdb0d7138032ace41307c1", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 86, "deletions": 1, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=de49ce19cc37f620ee42caabda56f71bcb350887", "patch": "@@ -332,6 +332,41 @@ typedef struct page_table_chain\n \n #endif\n \n+class finalizer\n+{\n+public:\n+  finalizer (void *addr, void (*f)(void *)) : m_addr (addr), m_function (f) {}\n+\n+  void *addr () const { return m_addr; }\n+\n+  void call () const { m_function (m_addr); }\n+\n+private:\n+  void *m_addr;\n+  void (*m_function)(void *);\n+};\n+\n+class vec_finalizer\n+{\n+public:\n+  vec_finalizer (uintptr_t addr, void (*f)(void *), size_t s, size_t n) :\n+    m_addr (addr), m_function (f), m_object_size (s), m_n_objects (n) {}\n+\n+  void call () const\n+    {\n+      for (size_t i = 0; i < m_n_objects; i++)\n+\tm_function (reinterpret_cast<void *> (m_addr + (i * m_object_size)));\n+    }\n+\n+  void *addr () const { return reinterpret_cast<void *> (m_addr); }\n+\n+private:\n+  uintptr_t m_addr;\n+  void (*m_function)(void *);\n+  size_t m_object_size;\n+  size_t m_n_objects;\n+  };\n+\n #ifdef ENABLE_GC_ALWAYS_COLLECT\n /* List of free objects to be verified as actually free on the\n    next collection.  */\n@@ -425,6 +460,12 @@ static struct globals\n      better runtime data access pattern.  */\n   unsigned long **save_in_use;\n \n+  /* Finalizers for single objects.  */\n+  vec<finalizer> finalizers;\n+\n+  /* Finalizers for vectors of objects.  */\n+  vec<vec_finalizer> vec_finalizers;\n+\n #ifdef ENABLE_GC_ALWAYS_COLLECT\n   /* List of free objects to be verified as actually free on the\n      next collection.  */\n@@ -1202,7 +1243,8 @@ ggc_round_alloc_size (size_t requested_size)\n /* Allocate a chunk of memory of SIZE bytes.  Its contents are undefined.  */\n \n void *\n-ggc_internal_alloc (size_t size MEM_STAT_DECL)\n+ggc_internal_alloc (size_t size, void (*f)(void *), size_t s, size_t n\n+\t\t    MEM_STAT_DECL)\n {\n   size_t order, word, bit, object_offset, object_size;\n   struct page_entry *entry;\n@@ -1345,6 +1387,12 @@ ggc_internal_alloc (size_t size MEM_STAT_DECL)\n   /* For timevar statistics.  */\n   timevar_ggc_mem_total += object_size;\n \n+  if (f && n == 1)\n+    G.finalizers.safe_push (finalizer (result, f));\n+  else if (f)\n+    G.vec_finalizers.safe_push\n+      (vec_finalizer (reinterpret_cast<uintptr_t> (result), f, s, n));\n+\n   if (GATHER_STATISTICS)\n     {\n       size_t overhead = object_size - size;\n@@ -1811,6 +1859,42 @@ clear_marks (void)\n     }\n }\n \n+static void\n+ggc_handle_finalizers ()\n+{\n+  if (G.context_depth != 0)\n+    return;\n+\n+  unsigned length = G.finalizers.length ();\n+  for (unsigned int i = 0; i < length;)\n+    {\n+      finalizer &f = G.finalizers[i];\n+      if (!ggc_marked_p (f.addr ()))\n+\t{\n+\t  f.call ();\n+\t  G.finalizers.unordered_remove (i);\n+\t  length--;\n+\t}\n+      else\n+\ti++;\n+    }\n+\n+\n+  length = G.vec_finalizers.length ();\n+  for (unsigned int i = 0; i < length;)\n+    {\n+      vec_finalizer &f = G.vec_finalizers[i];\n+      if (!ggc_marked_p (f.addr ()))\n+\t{\n+\t  f.call ();\n+\t  G.vec_finalizers.unordered_remove (i);\n+\t  length--;\n+\t}\n+      else\n+\ti++;\n+    }\n+}\n+\n /* Free all empty pages.  Partially empty pages need no attention\n    because the `mark' bit doubles as an `unused' bit.  */\n \n@@ -2075,6 +2159,7 @@ ggc_collect (void)\n \n   clear_marks ();\n   ggc_mark_roots ();\n+  ggc_handle_finalizers ();\n \n   if (GATHER_STATISTICS)\n     ggc_prune_overhead_list ();"}, {"sha": "1279aeedc3a6c9d9d3647b8e1066e7946c1c29a5", "filename": "gcc/ggc.h", "status": "modified", "additions": 63, "deletions": 8, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de49ce19cc37f620ee42caabda56f71bcb350887/gcc%2Fggc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc.h?ref=de49ce19cc37f620ee42caabda56f71bcb350887", "patch": "@@ -136,13 +136,30 @@ extern void gt_pch_save (FILE *f);\n /* Allocation.  */\n \n /* The internal primitive.  */\n-extern void *ggc_internal_alloc (size_t CXX_MEM_STAT_INFO) ATTRIBUTE_MALLOC;\n+extern void *ggc_internal_alloc (size_t, void (*)(void *), size_t,\n+\t\t\t\t size_t CXX_MEM_STAT_INFO)\n+     ATTRIBUTE_MALLOC;\n+\n+     static inline\n+     void *\n+     ggc_internal_alloc (size_t s CXX_MEM_STAT_INFO)\n+{\n+  return ggc_internal_alloc (s, NULL, 0, 1 PASS_MEM_STAT);\n+}\n \n extern size_t ggc_round_alloc_size (size_t requested_size);\n \n /* Allocates cleared memory.  */\n-extern void *ggc_internal_cleared_alloc (size_t CXX_MEM_STAT_INFO)\n-  ATTRIBUTE_MALLOC;\n+extern void *ggc_internal_cleared_alloc (size_t, void (*)(void *),\n+\t\t\t\t\t size_t, size_t\n+\t\t\t\t\t CXX_MEM_STAT_INFO) ATTRIBUTE_MALLOC;\n+\n+static inline\n+void *\n+ggc_internal_cleared_alloc (size_t s CXX_MEM_STAT_INFO)\n+{\n+  return ggc_internal_cleared_alloc (s, NULL, 0, 1 PASS_MEM_STAT);\n+}\n \n /* Resize a block.  */\n extern void *ggc_realloc (void *, size_t CXX_MEM_STAT_INFO);\n@@ -156,35 +173,73 @@ extern void dump_ggc_loc_statistics (bool);\n #define GGC_RESIZEVEC(T, P, N) \\\n     ((T *) ggc_realloc ((P), (N) * sizeof (T) MEM_STAT_INFO))\n \n+template<typename T>\n+void\n+finalize (void *p)\n+{\n+  static_cast<T *> (p)->~T ();\n+}\n+\n+template<typename T>\n+static inline bool\n+need_finalization_p ()\n+{\n+#if GCC_VERSION >= 4003\n+  return !__has_trivial_destructor (T);\n+#else\n+  return true;\n+#endif\n+}\n+\n template<typename T>\n static inline T *\n ggc_alloc (ALONE_CXX_MEM_STAT_INFO)\n {\n-  return static_cast<T *> (ggc_internal_alloc (sizeof (T) PASS_MEM_STAT));\n+  if (need_finalization_p<T> ())\n+    return static_cast<T *> (ggc_internal_alloc (sizeof (T), finalize<T>, 0, 1\n+\t\t\t\t\t\t PASS_MEM_STAT));\n+  else\n+    return static_cast<T *> (ggc_internal_alloc (sizeof (T), NULL, 0, 1\n+\t\t\t\t\t\t PASS_MEM_STAT));\n }\n \n template<typename T>\n static inline T *\n ggc_cleared_alloc (ALONE_CXX_MEM_STAT_INFO)\n {\n-  return static_cast<T *> (ggc_internal_cleared_alloc (sizeof (T)\n-\t\t\t\t\t\t       PASS_MEM_STAT));\n+  if (need_finalization_p<T> ())\n+    return static_cast<T *> (ggc_internal_cleared_alloc (sizeof (T),\n+\t\t\t\t\t\t\t finalize<T>, 0, 1\n+\t\t\t\t\t\t\t PASS_MEM_STAT));\n+  else\n+    return static_cast<T *> (ggc_internal_cleared_alloc (sizeof (T), NULL, 0, 1\n+\t\t\t\t\t\t\t PASS_MEM_STAT));\n }\n \n template<typename T>\n static inline T *\n ggc_vec_alloc (size_t c CXX_MEM_STAT_INFO)\n {\n-    return static_cast<T *> (ggc_internal_alloc (c * sizeof (T)\n+  if (need_finalization_p<T> ())\n+    return static_cast<T *> (ggc_internal_alloc (c * sizeof (T), finalize<T>,\n+\t\t\t\t\t\t sizeof (T), c PASS_MEM_STAT));\n+  else\n+    return static_cast<T *> (ggc_internal_alloc (c * sizeof (T), NULL, 0, 0\n \t\t\t\t\t\t PASS_MEM_STAT));\n }\n \n template<typename T>\n static inline T *\n ggc_cleared_vec_alloc (size_t c CXX_MEM_STAT_INFO)\n {\n-    return static_cast<T *> (ggc_internal_cleared_alloc (c * sizeof (T)\n+  if (need_finalization_p<T> ())\n+    return static_cast<T *> (ggc_internal_cleared_alloc (c * sizeof (T),\n+\t\t\t\t\t\t\t finalize<T>,\n+\t\t\t\t\t\t\t sizeof (T), c\n \t\t\t\t\t\t\t PASS_MEM_STAT));\n+  else\n+    return static_cast<T *> (ggc_internal_cleared_alloc (c * sizeof (T), NULL,\n+\t\t\t\t\t\t\t 0, 0 PASS_MEM_STAT));\n }\n \n static inline void *"}]}