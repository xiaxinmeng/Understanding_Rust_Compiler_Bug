{"sha": "359b060e79c2fc423b733229205a9cfbcd634a0a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzU5YjA2MGU3OWMyZmM0MjNiNzMzMjI5MjA1YTljZmJjZDYzNGEwYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2017-05-05T18:34:45Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2017-05-05T18:34:45Z"}, "message": "Makefile.in (GTFILES): Add tree-ssa-loop-ivopts.c.\n\n\t* Makefile.in (GTFILES): Add tree-ssa-loop-ivopts.c.\n\t* tree-ssa-loop-ivopts.c (compute_max_addr_offset): Delete.\n\t(addr_list, addr_offset_valid_p): New.\n\t(split_address_groups): Check offset validity with above function.\n\t(gt-tree-ssa-loop-ivopts.h): Include header file.\n\nFrom-SVN: r247653", "tree": {"sha": "d414ae2ad9197225aa36f2cdbbebd4370a79213e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d414ae2ad9197225aa36f2cdbbebd4370a79213e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/359b060e79c2fc423b733229205a9cfbcd634a0a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b060e79c2fc423b733229205a9cfbcd634a0a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/359b060e79c2fc423b733229205a9cfbcd634a0a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/359b060e79c2fc423b733229205a9cfbcd634a0a/comments", "author": null, "committer": null, "parents": [{"sha": "13c5654f74df6d5c20802122e45befcc3e4da9ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13c5654f74df6d5c20802122e45befcc3e4da9ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13c5654f74df6d5c20802122e45befcc3e4da9ed"}], "stats": {"total": 125, "additions": 51, "deletions": 74}, "files": [{"sha": "5bcf2065a1125031165479292f638885368ab421", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=359b060e79c2fc423b733229205a9cfbcd634a0a", "patch": "@@ -1,3 +1,11 @@\n+2017-05-05  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* Makefile.in (GTFILES): Add tree-ssa-loop-ivopts.c.\n+\t* tree-ssa-loop-ivopts.c (compute_max_addr_offset): Delete.\n+\t(addr_list, addr_offset_valid_p): New.\n+\t(split_address_groups): Check offset validity with above function.\n+\t(gt-tree-ssa-loop-ivopts.h): Include header file.\n+\n 2017-05-05  Nathan Sidwell  <nathan@acm.org>\n \n \t* config.gcc (arm*-*-*): Add missing 'fi'."}, {"sha": "97259aca879953a64e642d2912e79a8db3e13824", "filename": "gcc/Makefile.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=359b060e79c2fc423b733229205a9cfbcd634a0a", "patch": "@@ -2484,7 +2484,7 @@ GTFILES = $(CPP_ID_DATA_H) $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/gimple-ssa.h \\\n   $(srcdir)/tree-chkp.c \\\n   $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c $(srcdir)/tree-ssa-address.c \\\n-  $(srcdir)/tree-cfg.c \\\n+  $(srcdir)/tree-cfg.c $(srcdir)/tree-ssa-loop-ivopts.c \\\n   $(srcdir)/tree-dfa.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimple-expr.c \\\n   $(srcdir)/tree-chrec.h \\"}, {"sha": "d865fd2b94a1848cc3c9d6dd48c4f1c37f3e0078", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 42, "deletions": 73, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/359b060e79c2fc423b733229205a9cfbcd634a0a/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=359b060e79c2fc423b733229205a9cfbcd634a0a", "patch": "@@ -2459,67 +2459,36 @@ find_interesting_uses_outside (struct ivopts_data *data, edge exit)\n     }\n }\n \n-/* Compute maximum offset of [base + offset] addressing mode\n-   for memory reference represented by USE.  */\n+/* Return TRUE if OFFSET is within the range of [base + offset] addressing\n+   mode for memory reference represented by USE.  */\n \n-static HOST_WIDE_INT\n-compute_max_addr_offset (struct iv_use *use)\n+static GTY (()) vec<rtx, va_gc> *addr_list;\n+\n+static bool\n+addr_offset_valid_p (struct iv_use *use, HOST_WIDE_INT offset)\n {\n-  int width;\n   rtx reg, addr;\n-  HOST_WIDE_INT i, off;\n-  unsigned list_index, num;\n-  addr_space_t as;\n-  machine_mode mem_mode, addr_mode;\n-  static vec<HOST_WIDE_INT> max_offset_list;\n-\n-  as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n-  mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n+  unsigned list_index;\n+  addr_space_t as = TYPE_ADDR_SPACE (TREE_TYPE (use->iv->base));\n+  machine_mode addr_mode, mem_mode = TYPE_MODE (TREE_TYPE (*use->op_p));\n \n-  num = max_offset_list.length ();\n   list_index = (unsigned) as * MAX_MACHINE_MODE + (unsigned) mem_mode;\n-  if (list_index >= num)\n-    {\n-      max_offset_list.safe_grow (list_index + MAX_MACHINE_MODE);\n-      for (; num < max_offset_list.length (); num++)\n-\tmax_offset_list[num] = -1;\n-    }\n+  if (list_index >= vec_safe_length (addr_list))\n+    vec_safe_grow_cleared (addr_list, list_index + MAX_MACHINE_MODE);\n \n-  off = max_offset_list[list_index];\n-  if (off != -1)\n-    return off;\n-\n-  addr_mode = targetm.addr_space.address_mode (as);\n-  reg = gen_raw_REG (addr_mode, LAST_VIRTUAL_REGISTER + 1);\n-  addr = gen_rtx_fmt_ee (PLUS, addr_mode, reg, NULL_RTX);\n-\n-  width = GET_MODE_BITSIZE (addr_mode) - 1;\n-  if (width > (HOST_BITS_PER_WIDE_INT - 1))\n-    width = HOST_BITS_PER_WIDE_INT - 1;\n-\n-  for (i = width; i > 0; i--)\n+  addr = (*addr_list)[list_index];\n+  if (!addr)\n     {\n-      off = (HOST_WIDE_INT_1U << i) - 1;\n-      XEXP (addr, 1) = gen_int_mode (off, addr_mode);\n-      if (memory_address_addr_space_p (mem_mode, addr, as))\n-\tbreak;\n-\n-      /* For some strict-alignment targets, the offset must be naturally\n-\t aligned.  Try an aligned offset if mem_mode is not QImode.  */\n-      off = (HOST_WIDE_INT_1U << i);\n-      if (off > GET_MODE_SIZE (mem_mode) && mem_mode != QImode)\n-\t{\n-\t  off -= GET_MODE_SIZE (mem_mode);\n-\t  XEXP (addr, 1) = gen_int_mode (off, addr_mode);\n-\t  if (memory_address_addr_space_p (mem_mode, addr, as))\n-\t    break;\n-\t}\n+      addr_mode = targetm.addr_space.address_mode (as);\n+      reg = gen_raw_REG (addr_mode, LAST_VIRTUAL_REGISTER + 1);\n+      addr = gen_rtx_fmt_ee (PLUS, addr_mode, reg, NULL_RTX);\n+      (*addr_list)[list_index] = addr;\n     }\n-  if (i == 0)\n-    off = 0;\n+  else\n+    addr_mode = GET_MODE (addr);\n \n-  max_offset_list[list_index] = off;\n-  return off;\n+  XEXP (addr, 1) = gen_int_mode (offset, addr_mode);\n+  return (memory_address_addr_space_p (mem_mode, addr, as));\n }\n \n /* Comparison function to sort group in ascending order of addr_offset.  */\n@@ -2598,14 +2567,12 @@ static void\n split_address_groups (struct ivopts_data *data)\n {\n   unsigned int i, j;\n-  HOST_WIDE_INT max_offset = -1;\n-\n-  /* Reset max offset to split all small groups.  */\n-  if (split_small_address_groups_p (data))\n-    max_offset = 0;\n+  /* Always split group.  */\n+  bool split_p = split_small_address_groups_p (data);\n \n   for (i = 0; i < data->vgroups.length (); i++)\n     {\n+      struct iv_group *new_group = NULL;\n       struct iv_group *group = data->vgroups[i];\n       struct iv_use *use = group->vuses[0];\n \n@@ -2614,29 +2581,29 @@ split_address_groups (struct ivopts_data *data)\n       if (group->vuses.length () == 1)\n \tcontinue;\n \n-      if (max_offset != 0)\n-\tmax_offset = compute_max_addr_offset (use);\n+      gcc_assert (group->type == USE_ADDRESS);\n \n-      for (j = 1; j < group->vuses.length (); j++)\n+      for (j = 1; j < group->vuses.length ();)\n \t{\n \t  struct iv_use *next = group->vuses[j];\n+\t  HOST_WIDE_INT offset = next->addr_offset - use->addr_offset;\n \n-\t  /* Only uses with offset that can fit in offset part against\n-\t     the first use can be grouped together.  */\n-\t  if (next->addr_offset - use->addr_offset\n-\t      > (unsigned HOST_WIDE_INT) max_offset)\n-\t    break;\n+\t  /* Split group if aksed to, or the offset against the first\n+\t     use can't fit in offset part of addressing mode.  IV uses\n+\t     having the same offset are still kept in one group.  */\n+\t  if (offset != 0 &&\n+\t      (split_p || !addr_offset_valid_p (use, offset)))\n+\t    {\n+\t      if (!new_group)\n+\t\tnew_group = record_group (data, group->type);\n+\t      group->vuses.ordered_remove (j);\n+\t      new_group->vuses.safe_push (next);\n+\t      continue;\n+\t    }\n \n \t  next->id = j;\n \t  next->group_id = group->id;\n-\t}\n-      /* Split group.  */\n-      if (j < group->vuses.length ())\n-\t{\n-\t  struct iv_group *new_group = record_group (data, group->type);\n-\t  new_group->vuses.safe_splice (group->vuses);\n-\t  new_group->vuses.block_remove (0, j);\n-\t  group->vuses.truncate (j);\n+\t  j++;\n \t}\n     }\n }\n@@ -7853,3 +7820,5 @@ tree_ssa_iv_optimize (void)\n \n   tree_ssa_iv_optimize_finalize (&data);\n }\n+\n+#include \"gt-tree-ssa-loop-ivopts.h\""}]}