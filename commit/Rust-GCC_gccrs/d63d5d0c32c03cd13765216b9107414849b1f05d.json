{"sha": "d63d5d0c32c03cd13765216b9107414849b1f05d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDYzZDVkMGMzMmMwM2NkMTM3NjUyMTZiOTEwNzQxNDg0OWIxZjA1ZA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@airs.com", "date": "2005-09-12T19:54:23Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2005-09-12T19:54:23Z"}, "message": "re PR c++/7874 (g++ finds friend functions defined in class-definition but not declared in the enclosing namespace)\n\n./\tPR g++/7874\n\t* c.opt (ffriend-injection): New C++ option.\n\t* doc/invoke.texi (Option Summary): Mention -ffriend-injection.\n\t(C++ Dialect Options): Document -ffriend-injection.\ncp/\n\tPR g++/7874\n\t* cp-tree.h (struct lang_decl_flags): Add hidden_friend_p\n\tbitfield.  Make dummy bitfield one bit smaller.\n\t(DECL_HIDDEN_FRIEND_P): Define.\n\t(pushdecl_maybe_friend): Declare.\n\t(pushdecl_top_level_maybe_friend): Declare.\n\t* decl.c (duplicate_decls): Add newdecl_is_friend parameter.\n\tChange prototype and all callers.  Add assertion that a\n\tDECL_ARTIFICIAL FUNCTION_DECL is not DECL_HIDDEN_FRIEND_P.  Set\n\tDECL_ANTICIPATED and DECL_HIDDEN_FRIEND_P in duplicated decl if\n\tappropriate.\n\t* name-lookup.c (supplement_binding): Don't ignore a\n\tDECL_HIDDEN_FRIEND_P.\n\t(pushdecl_maybe_friend): Break out contents of pushdecl.  Add\n\tis_friend parameter.  Set DECL_ANTICIPATED and\n\tDECL_HIDDEN_FRIEND_P for a friend function.\n\t(pushdecl): Just call pushdecl_maybe_friend.\n\t(pushdecl_with_scope): Add is_friend parameter.  Change prototype\n\tand all callers.\n\t(pushdecl_namespace_level): Likewise.\n\t(push_overloaded_decl): Likewise.  Check DECL_HIDDEN_FRIEND_P as\n\twell as DECL_ANTICIPATED when checking for a builtin.\n\t(do_nonmember_using_decl): Check DECL_HIDDEN_FRIEND_P as well as\n\tDECL_ANTICIPATED when checking for a builtin.\n\t(do_nonmember_using_decl): Likewise.\n\t(pushdecl_top_level_1): Add is_friend parameter.  Change all\n\tcallers.\n\t(pushdecl_top_level_maybe_friend): New function.\n\t(remove_hidden_names): New function.\n\t(struct arg_lookup): Add args field.\n\t(friend_of_associated_class_p): New static function.\n\t(arg_assoc_namespace): Ignore hidden functions which are not\n\tfriends of an associated class of some argument.\n\t(lookup_arg_dependent): Remove hidden functions from list passed\n\tin.  Initialize k.args.\n\t* name-lookup.h (remove_hidden_names): Declare.\n\t* friend.c (do_friend): Call pushdecl_maybe_friend instead of\n\tpushdecl.\n\t* call.c (add_function_candidate): Change DECL_ANTICIPATED test to\n\tan assertion, with a check for DECL_HIDDEN_FRIEND_P.\n\t(build_new_function_call): Add koenig_p parameter.  Change\n\tprototype and callers.\n\t* pt.c (register_specialization): Add is_friend parameter.  Change\n\tall callers.\n\t(push_template_decl_real): Change is_friend parameter to bool.\n\tChange prototype and all callers.\n\t(tsubst_friend_class): Call pushdecl_top_level_maybe_friend\n\tinstead of pushdecl_top_level.\ntestsuite/\n\tPR g++/7874\n\t* g++.dg/lookup/friend7.C: New test.\n\t* g++.dg/lookup/friend8.C: New test.\n\t* g++.dg/parse/defarg4.C: Add a parameter to the friend function,\n\tso that it will be found via argument dependent lookup.\n\t* g++.old-deja/g++.brendan/crash56.C: Don't expect errors for\n\tfriend functions which will no longer be found.\n\t* g++.old-deja/g++.jason/friend.C: Add a parameter to the friend\n\tfunction g, so that it will be found via argument dependent\n\tlookup.\n\t* g++.old-deja/g++.jason/scoping15.C: Use -ffriend-injection.\n\t* g++.old-deja/g++.mike/net43.C: Likewise.\n\nFrom-SVN: r104188", "tree": {"sha": "672854ad16a126bb970ef26565b6d30c3cb8e167", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/672854ad16a126bb970ef26565b6d30c3cb8e167"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d63d5d0c32c03cd13765216b9107414849b1f05d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63d5d0c32c03cd13765216b9107414849b1f05d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d63d5d0c32c03cd13765216b9107414849b1f05d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d63d5d0c32c03cd13765216b9107414849b1f05d/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "dbc564aea36c6a2a6c3dc7d3a6e2614f47a4d920", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dbc564aea36c6a2a6c3dc7d3a6e2614f47a4d920", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dbc564aea36c6a2a6c3dc7d3a6e2614f47a4d920"}], "stats": {"total": 493, "additions": 403, "deletions": 90}, "files": [{"sha": "2e26c7dc152afbf004fea29ece5cee521aae250b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1,3 +1,10 @@\n+2005-09-12  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR g++/7874\n+\t* c.opt (ffriend-injection): New C++ option.\n+\t* doc/invoke.texi (Option Summary): Mention -ffriend-injection.\n+\t(C++ Dialect Options): Document -ffriend-injection.\n+\n 2005-09-12  Josh Conner  <jconner@apple.com>\n \n \tPR middle-end/23237"}, {"sha": "d650f111168e9b805078f227abef86d682902c39", "filename": "gcc/c.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -554,6 +554,10 @@ fimplicit-templates\n C++ ObjC++\n Emit implicit instantiations of templates\n \n+ffriend-injection\n+C++ Var(flag_friend_injection)\n+Inject friend functions into enclosing namespace\n+\n flabels-ok\n C++ ObjC++\n "}, {"sha": "b0f70bc07dde72d23b2efb1db80d5dc1273b1495", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1,3 +1,54 @@\n+2005-09-12  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR g++/7874\n+\t* cp-tree.h (struct lang_decl_flags): Add hidden_friend_p\n+\tbitfield.  Make dummy bitfield one bit smaller.\n+\t(DECL_HIDDEN_FRIEND_P): Define.\n+\t(pushdecl_maybe_friend): Declare.\n+\t(pushdecl_top_level_maybe_friend): Declare.\n+\t* decl.c (duplicate_decls): Add newdecl_is_friend parameter.\n+\tChange prototype and all callers.  Add assertion that a\n+\tDECL_ARTIFICIAL FUNCTION_DECL is not DECL_HIDDEN_FRIEND_P.  Set\n+\tDECL_ANTICIPATED and DECL_HIDDEN_FRIEND_P in duplicated decl if\n+\tappropriate.\n+\t* name-lookup.c (supplement_binding): Don't ignore a\n+\tDECL_HIDDEN_FRIEND_P.\n+\t(pushdecl_maybe_friend): Break out contents of pushdecl.  Add\n+\tis_friend parameter.  Set DECL_ANTICIPATED and\n+\tDECL_HIDDEN_FRIEND_P for a friend function.\n+\t(pushdecl): Just call pushdecl_maybe_friend.\n+\t(pushdecl_with_scope): Add is_friend parameter.  Change prototype\n+\tand all callers.\n+\t(pushdecl_namespace_level): Likewise.\n+\t(push_overloaded_decl): Likewise.  Check DECL_HIDDEN_FRIEND_P as\n+\twell as DECL_ANTICIPATED when checking for a builtin.\n+\t(do_nonmember_using_decl): Check DECL_HIDDEN_FRIEND_P as well as\n+\tDECL_ANTICIPATED when checking for a builtin.\n+\t(do_nonmember_using_decl): Likewise.\n+\t(pushdecl_top_level_1): Add is_friend parameter.  Change all\n+\tcallers.\n+\t(pushdecl_top_level_maybe_friend): New function.\n+\t(remove_hidden_names): New function.\n+\t(struct arg_lookup): Add args field.\n+\t(friend_of_associated_class_p): New static function.\n+\t(arg_assoc_namespace): Ignore hidden functions which are not\n+\tfriends of an associated class of some argument.\n+\t(lookup_arg_dependent): Remove hidden functions from list passed\n+\tin.  Initialize k.args.\n+\t* name-lookup.h (remove_hidden_names): Declare.\n+\t* friend.c (do_friend): Call pushdecl_maybe_friend instead of\n+\tpushdecl.\n+\t* call.c (add_function_candidate): Change DECL_ANTICIPATED test to\n+\tan assertion, with a check for DECL_HIDDEN_FRIEND_P.\n+\t(build_new_function_call): Add koenig_p parameter.  Change\n+\tprototype and callers.\n+\t* pt.c (register_specialization): Add is_friend parameter.  Change\n+\tall callers.\n+\t(push_template_decl_real): Change is_friend parameter to bool.\n+\tChange prototype and all callers.\n+\t(tsubst_friend_class): Call pushdecl_top_level_maybe_friend\n+\tinstead of pushdecl_top_level.\n+\n 2005-09-11  Richard Henderson  <rth@redhat.com>\n \n \t* decl2.c (build_anon_union_vars): Copy attributes from the base addr."}, {"sha": "e8f93c4daf80ee65b0d2f46b6719d0093160ddf7", "filename": "gcc/cp/call.c", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1309,10 +1309,10 @@ add_function_candidate (struct z_candidate **candidates,\n   tree orig_arglist;\n   int viable = 1;\n \n-  /* Built-in functions that haven't been declared don't really\n-     exist.  */\n-  if (DECL_ANTICIPATED (fn))\n-    return NULL;\n+  /* At this point we should not see any functions which haven't been\n+     explicitly declared, except for friend functions which will have\n+     been found using argument dependent lookup.  */\n+  gcc_assert (!DECL_ANTICIPATED (fn) || DECL_HIDDEN_FRIEND_P (fn));\n \n   /* The `this', `in_chrg' and VTT arguments to constructors are not\n      considered in overload resolution.  */\n@@ -2758,7 +2758,7 @@ perform_overload_resolution (tree fn,\n    or a static member function) with the ARGS.  */\n \n tree\n-build_new_function_call (tree fn, tree args)\n+build_new_function_call (tree fn, tree args, bool koenig_p)\n {\n   struct z_candidate *candidates, *cand;\n   bool any_viable_p;\n@@ -2769,6 +2769,22 @@ build_new_function_call (tree fn, tree args)\n   if (args == error_mark_node)\n     return error_mark_node;\n \n+  /* If this function was found without using argument dependent\n+     lookup, then we want to ignore any undeclared friend\n+     functions.  */\n+  if (!koenig_p)\n+    {\n+      tree orig_fn = fn;\n+\n+      fn = remove_hidden_names (fn);\n+      if (!fn)\n+\t{\n+\t  error (\"no matching function for call to %<%D(%A)%>\",\n+\t\t DECL_NAME (OVL_CURRENT (orig_fn)), args);\n+\t  return error_mark_node;\n+\t}\n+    }\n+\n   /* Get the high-water mark for the CONVERSION_OBSTACK.  */\n   p = conversion_obstack_alloc (0);\n "}, {"sha": "7fdeb873ce1ca3a9bdba6661f89af510e0a0a830", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -5645,7 +5645,8 @@ resolve_address_of_overloaded_function (tree target_type,\n \t       one, or vice versa.  */\n \t    continue;\n \n-\t  /* Ignore anticipated decls of undeclared builtins.  */\n+\t  /* Ignore functions which haven't been explicitly\n+\t     declared.  */\n \t  if (DECL_ANTICIPATED (fn))\n \t    continue;\n "}, {"sha": "9e74d37dcac4b8c6a7da5273f482f6f53b4ddbe2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1512,7 +1512,8 @@ struct lang_decl_flags GTY(())\n   unsigned thunk_p : 1;\n   unsigned this_thunk_p : 1;\n   unsigned repo_available_p : 1;\n-  unsigned dummy : 3;\n+  unsigned hidden_friend_p : 1;\n+  unsigned dummy : 2;\n \n   union lang_decl_u {\n     /* In a FUNCTION_DECL for which DECL_THUNK_P holds, this is\n@@ -1814,9 +1815,8 @@ struct lang_decl GTY(())\n #define DECL_INITIALIZED_IN_CLASS_P(DECL) \\\n  (DECL_LANG_SPECIFIC (DECL)->decl_flags.initialized_in_class)\n \n-/* Nonzero for FUNCTION_DECL means that this decl is just a\n-   friend declaration, and should not be added to the list of\n-   member functions for this class.  */\n+/* Nonzero for DECL means that this decl is just a friend declaration,\n+   and should not be added to the list of members for this class.  */\n #define DECL_FRIEND_P(NODE) (DECL_LANG_SPECIFIC (NODE)->decl_flags.friend_attr)\n \n /* A TREE_LIST of the types which have befriended this FUNCTION_DECL.  */\n@@ -2321,11 +2321,19 @@ extern void decl_shadowed_for_var_insert (tree, tree);\n #define DECL_LOCAL_FUNCTION_P(NODE) \\\n   DECL_LANG_FLAG_0 (FUNCTION_DECL_CHECK (NODE))\n \n-/* Nonzero if NODE is a FUNCTION_DECL for a built-in function, and we have\n-   not yet seen a prototype for that function.  */\n+/* Nonzero if NODE is a DECL which we know about but which has not\n+   been explicitly declared, such as a built-in function or a friend\n+   declared inside a class.  In the latter case DECL_HIDDEN_FRIEND_P\n+   will be set.  */\n #define DECL_ANTICIPATED(NODE) \\\n   (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.anticipated_p)\n \n+/* Nonzero if NODE is a FUNCTION_DECL which was declared as a friend\n+   within a class but has not been declared in the surrounding scope.\n+   The function is invisible except via argument dependent lookup.  */\n+#define DECL_HIDDEN_FRIEND_P(NODE) \\\n+  (DECL_LANG_SPECIFIC (DECL_COMMON_CHECK (NODE))->decl_flags.hidden_friend_p)\n+\n /* Record whether a typedef for type `int' was actually `signed int'.  */\n #define C_TYPEDEF_EXPLICITLY_SIGNED(EXP) DECL_LANG_FLAG_1 (EXP)\n \n@@ -3644,7 +3652,7 @@ extern bool null_ptr_cst_p\t\t\t(tree);\n extern bool sufficient_parms_p\t\t\t(tree);\n extern tree type_decays_to\t\t\t(tree);\n extern tree build_user_type_conversion\t\t(tree, tree, int);\n-extern tree build_new_function_call\t\t(tree, tree);\n+extern tree build_new_function_call\t\t(tree, tree, bool);\n extern tree build_operator_new_call\t\t(tree, tree, tree *, tree *);\n extern tree build_new_method_call\t\t(tree, tree, tree, tree, int);\n extern tree build_special_member_call\t\t(tree, tree, tree, tree, int);\n@@ -3743,6 +3751,7 @@ extern void adjust_clone_args\t\t\t(tree);\n extern tree poplevel\t\t\t\t(int, int, int);\n extern void insert_block\t\t\t(tree);\n extern tree pushdecl\t\t\t\t(tree);\n+extern tree pushdecl_maybe_friend\t\t(tree, bool);\n extern void cxx_init_decl_processing\t\t(void);\n enum cp_tree_node_structure_enum cp_tree_node_structure\n \t\t\t\t\t\t(union lang_tree_node *);\n@@ -3756,8 +3765,9 @@ extern void pop_switch\t\t\t\t(void);\n extern tree pushtag\t\t\t\t(tree, tree, tag_scope);\n extern tree make_anon_name\t\t\t(void);\n extern int decls_match\t\t\t\t(tree, tree);\n-extern tree duplicate_decls\t\t\t(tree, tree);\n+extern tree duplicate_decls\t\t\t(tree, tree, bool);\n extern tree pushdecl_top_level\t\t\t(tree);\n+extern tree pushdecl_top_level_maybe_friend\t(tree, bool);\n extern tree pushdecl_top_level_and_finish\t(tree, tree);\n extern tree push_using_decl\t\t\t(tree, tree);\n extern tree declare_local_label\t\t\t(tree);\n@@ -3983,7 +3993,7 @@ extern tree end_template_parm_list\t\t(tree);\n extern void end_template_decl\t\t\t(void);\n extern tree current_template_args\t\t(void);\n extern tree push_template_decl\t\t\t(tree);\n-extern tree push_template_decl_real\t\t(tree, int);\n+extern tree push_template_decl_real\t\t(tree, bool);\n extern void redeclare_class_template\t\t(tree, tree);\n extern tree lookup_template_class\t\t(tree, tree, tree, tree,\n \t\t\t\t\t\t int, tsubst_flags_t);"}, {"sha": "99072920f565932c336c2bb5365125fa7c998fd6", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 32, "deletions": 15, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1009,13 +1009,15 @@ warn_extern_redeclared_static (tree newdecl, tree olddecl)\n    error_mark_node is returned.  Otherwise, OLDDECL is returned.\n \n    If NEWDECL is not a redeclaration of OLDDECL, NULL_TREE is\n-   returned.  */\n+   returned.\n+\n+   NEWDECL_IS_FRIEND is true if NEWDECL was declared as a friend.  */\n \n tree\n-duplicate_decls (tree newdecl, tree olddecl)\n+duplicate_decls (tree newdecl, tree olddecl, bool newdecl_is_friend)\n {\n   unsigned olddecl_uid = DECL_UID (olddecl);\n-  int olddecl_friend = 0, types_match = 0;\n+  int olddecl_friend = 0, types_match = 0, hidden_friend = 0;\n   int new_defines_function = 0;\n \n   if (newdecl == olddecl)\n@@ -1069,9 +1071,11 @@ duplicate_decls (tree newdecl, tree olddecl)\n   if (TREE_CODE (olddecl) == FUNCTION_DECL\n       && DECL_ARTIFICIAL (olddecl))\n     {\n+      gcc_assert (!DECL_HIDDEN_FRIEND_P (olddecl));\n       if (TREE_CODE (newdecl) != FUNCTION_DECL)\n \t{\n-\t  /* Avoid warnings redeclaring anticipated built-ins.  */\n+\t  /* Avoid warnings redeclaring built-ins which have not been\n+\t     explicitly declared.  */\n \t  if (DECL_ANTICIPATED (olddecl))\n \t    return NULL_TREE;\n \n@@ -1102,7 +1106,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t}\n       else if (!types_match)\n \t{\n-\t  /* Avoid warnings redeclaring anticipated built-ins.  */\n+\t  /* Avoid warnings redeclaring built-ins which have not been\n+\t     explicitly declared.  */\n \t  if (DECL_ANTICIPATED (olddecl))\n \t    {\n \t      /* Deal with fileptr_type_node.  FILE type is not known\n@@ -1131,7 +1136,8 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t\t\t  = TYPE_ARG_TYPES (TREE_TYPE (newdecl));\n \t\t\ttypes_match = decls_match (newdecl, olddecl);\n \t\t\tif (types_match)\n-\t\t\t  return duplicate_decls (newdecl, olddecl);\n+\t\t\t  return duplicate_decls (newdecl, olddecl,\n+\t\t\t\t\t\t  newdecl_is_friend);\n \t\t\tTYPE_ARG_TYPES (TREE_TYPE (olddecl)) = oldargs;\n \t\t      }\n \t\t  }\n@@ -1163,8 +1169,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  /* Replace the old RTL to avoid problems with inlining.  */\n \t  COPY_DECL_RTL (newdecl, olddecl);\n \t}\n-      /* Even if the types match, prefer the new declarations type\n-\t for anticipated built-ins, for exception lists, etc...  */\n+      /* Even if the types match, prefer the new declarations type for\n+\t built-ins which have not been explicitly declared, for\n+\t exception lists, etc...  */\n       else if (DECL_ANTICIPATED (olddecl))\n \t{\n \t  tree type = TREE_TYPE (newdecl);\n@@ -1460,7 +1467,7 @@ duplicate_decls (tree newdecl, tree olddecl)\n \t  /* Don't warn about extern decl followed by definition.  */\n \t  && !(DECL_EXTERNAL (olddecl) && ! DECL_EXTERNAL (newdecl))\n \t  /* Don't warn about friends, let add_friend take care of it.  */\n-\t  && ! (DECL_FRIEND_P (newdecl) || DECL_FRIEND_P (olddecl)))\n+\t  && ! (newdecl_is_friend || DECL_FRIEND_P (olddecl)))\n \t{\n \t  warning (0, \"redundant redeclaration of %qD in same scope\", newdecl);\n \t  warning (0, \"previous declaration of %q+D\", olddecl);\n@@ -1685,6 +1692,9 @@ duplicate_decls (tree newdecl, tree olddecl)\n       DECL_INITIALIZED_IN_CLASS_P (newdecl)\n \t|= DECL_INITIALIZED_IN_CLASS_P (olddecl);\n       olddecl_friend = DECL_FRIEND_P (olddecl);\n+      hidden_friend = (DECL_ANTICIPATED (olddecl)\n+\t\t       && DECL_HIDDEN_FRIEND_P (olddecl)\n+\t\t       && newdecl_is_friend);\n \n       /* Only functions have DECL_BEFRIENDING_CLASSES.  */\n       if (TREE_CODE (newdecl) == FUNCTION_DECL\n@@ -1898,6 +1908,11 @@ duplicate_decls (tree newdecl, tree olddecl)\n   DECL_UID (olddecl) = olddecl_uid;\n   if (olddecl_friend)\n     DECL_FRIEND_P (olddecl) = 1;\n+  if (hidden_friend)\n+    {\n+      DECL_ANTICIPATED (olddecl) = 1;\n+      DECL_HIDDEN_FRIEND_P (olddecl) = 1;\n+    }\n \n   /* NEWDECL contains the merged attribute lists.\n      Update OLDDECL to be the same.  */\n@@ -3142,7 +3157,7 @@ cp_make_fname_decl (tree id, int type_dep)\n       struct cp_binding_level *b = current_binding_level;\n       while (b->level_chain->kind != sk_function_parms)\n \tb = b->level_chain;\n-      pushdecl_with_scope (decl, b);\n+      pushdecl_with_scope (decl, b, /*is_friend=*/false);\n       cp_finish_decl (decl, init, NULL_TREE, LOOKUP_ONLYCONVERTING);\n     }\n   else\n@@ -3185,8 +3200,9 @@ builtin_function_1 (const char* name,\n   if (libname)\n     SET_DECL_ASSEMBLER_NAME (decl, get_identifier (libname));\n \n-  /* Warn if a function in the namespace for users\n-     is used without an occasion to consider it declared.  */\n+  /* A function in the user's namespace should have an explicit\n+     declaration before it is used.  Mark the built-in function as\n+     anticipated but not actually declared.  */\n   if (name[0] != '_' || name[1] != '_')\n     DECL_ANTICIPATED (decl) = 1;\n \n@@ -3720,7 +3736,7 @@ start_decl (const cp_declarator *declarator,\n \t      if (DECL_INITIAL (decl) \n \t\t  && DECL_INITIALIZED_IN_CLASS_P (field))\n \t\terror (\"duplicate initialization of %qD\", decl);\n-\t      if (duplicate_decls (decl, field))\n+\t      if (duplicate_decls (decl, field, /*newdecl_is_friend=*/false))\n \t\tdecl = field;\n \t    }\n \t}\n@@ -3731,7 +3747,8 @@ start_decl (const cp_declarator *declarator,\n \t\t\t\t       > template_class_depth (context))\n \t\t\t\t      ? current_template_parms\n \t\t\t\t      : NULL_TREE);\n-\t  if (field && duplicate_decls (decl, field))\n+\t  if (field && duplicate_decls (decl, field,\n+\t\t\t\t\t/*newdecl_is_friend=*/false))\n \t    decl = field;\n \t}\n \n@@ -5871,7 +5888,7 @@ grokfndecl (tree ctype,\n \t  /* Attempt to merge the declarations.  This can fail, in\n \t     the case of some invalid specialization declarations.  */\n \t  pushed_scope = push_scope (ctype);\n-\t  ok = duplicate_decls (decl, old_decl);\n+\t  ok = duplicate_decls (decl, old_decl, friendp);\n \t  if (pushed_scope)\n \t    pop_scope (pushed_scope);\n \t  if (!ok)"}, {"sha": "c71b90f83ef5ed9f51da0e37501aa492b16470f0", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -480,7 +480,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t  else if (class_template_depth)\n \t    /* We rely on tsubst_friend_function to check the\n \t       validity of the declaration later.  */\n-\t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n+\t    decl = push_template_decl_real (decl, /*is_friend=*/true);\n \t  else\n \t    decl = check_classfn (ctype, decl,\n \t\t\t\t  template_member_p\n@@ -527,13 +527,13 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t       general, such a declaration depends on template\n \t       parameters.  Instead, we call pushdecl when the class\n \t       is instantiated.  */\n-\t    decl = push_template_decl_real (decl, /*is_friend=*/1);\n+\t    decl = push_template_decl_real (decl, /*is_friend=*/true);\n \t  else if (current_function_decl)\n \t    /* This must be a local class, so pushdecl will be ok, and\n \t       insert an unqualified friend into the local scope\n \t       (rather than the containing namespace scope, which the\n \t       next choice will do).  */\n-\t    decl = pushdecl (decl);\n+\t    decl = pushdecl_maybe_friend (decl, /*is_friend=*/true);\n \t  else\n \t    {\n \t      /* We can't use pushdecl, as we might be in a template\n@@ -543,7 +543,7 @@ do_friend (tree ctype, tree declarator, tree decl,\n \t      tree ns = decl_namespace_context (decl);\n \n \t      push_nested_namespace (ns);\n-\t      decl = pushdecl_namespace_level (decl);\n+\t      decl = pushdecl_namespace_level (decl, /*is_friend=*/true);\n \t      pop_nested_namespace (ns);\n \t    }\n "}, {"sha": "9afde87016fac2ca315a606c4d122df0b7caf39a", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 166, "deletions": 28, "changes": 194, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -44,7 +44,7 @@ static cxx_scope *innermost_nonclass_level (void);\n static tree select_decl (const struct scope_binding *, int);\n static cxx_binding *binding_for_name (cxx_scope *, tree);\n static tree lookup_name_innermost_nonclass_level (tree);\n-static tree push_overloaded_decl (tree, int);\n+static tree push_overloaded_decl (tree, int, bool);\n static bool lookup_using_namespace (tree, struct scope_binding *, tree,\n \t\t\t\t    tree, int);\n static bool qualified_lookup_using_namespace (tree, tree,\n@@ -437,10 +437,11 @@ supplement_binding (cxx_binding *binding, tree decl)\n \t      error recovery purpose, pretend this was the intended\n \t      declaration for that name.  */\n \t   || bval == error_mark_node\n-\t   /* If BVAL is a built-in that has not yet been declared,\n+\t   /* If BVAL is anticipated but has not yet been declared,\n \t      pretend it is not there at all.  */\n \t   || (TREE_CODE (bval) == FUNCTION_DECL\n-\t       && DECL_ANTICIPATED (bval)))\n+\t       && DECL_ANTICIPATED (bval)\n+\t       && !DECL_HIDDEN_FRIEND_P (bval)))\n     binding->value = decl;\n   else if (TREE_CODE (bval) == TYPE_DECL && DECL_ARTIFICIAL (bval))\n     {\n@@ -487,7 +488,7 @@ supplement_binding (cxx_binding *binding, tree decl)\n \t   && DECL_EXTERNAL (decl) && DECL_EXTERNAL (bval)\n \t   && !DECL_CLASS_SCOPE_P (decl))\n     {\n-      duplicate_decls (decl, binding->value);\n+      duplicate_decls (decl, binding->value, /*newdecl_is_friend=*/false);\n       ok = false;\n     }\n   else if (TREE_CODE (decl) == NAMESPACE_DECL\n@@ -551,14 +552,15 @@ add_decl_to_level (tree decl, cxx_scope *b)\n \n /* Record a decl-node X as belonging to the current lexical scope.\n    Check for errors (such as an incompatible declaration for the same\n-   name already seen in the same scope).\n+   name already seen in the same scope).  IS_FRIEND is true if X is\n+   declared as a friend.\n \n    Returns either X or an old decl for the same name.\n    If an old decl is returned, it may have been smashed\n    to agree with what X says.  */\n \n tree\n-pushdecl (tree x)\n+pushdecl_maybe_friend (tree x, bool is_friend)\n {\n   tree t;\n   tree name;\n@@ -679,7 +681,7 @@ pushdecl (tree x)\n \t      gcc_assert (DECL_CONTEXT (t));\n \n \t      /* Check for duplicate params.  */\n-\t      if (duplicate_decls (x, t))\n+\t      if (duplicate_decls (x, t, is_friend))\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t    }\n \t  else if ((DECL_EXTERN_C_FUNCTION_P (x)\n@@ -697,7 +699,7 @@ pushdecl (tree x)\n \t    }\n \t  else\n \t    {\n-\t      tree olddecl = duplicate_decls (x, t);\n+\t      tree olddecl = duplicate_decls (x, t, is_friend);\n \n \t      /* If the redeclaration failed, we can stop at this\n \t\t point.  */\n@@ -742,7 +744,7 @@ pushdecl (tree x)\n \n       if (DECL_NON_THUNK_FUNCTION_P (x) && ! DECL_FUNCTION_MEMBER_P (x))\n \t{\n-\t  t = push_overloaded_decl (x, PUSH_LOCAL);\n+\t  t = push_overloaded_decl (x, PUSH_LOCAL, is_friend);\n \t  if (t != x)\n \t    POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n \t  if (!namespace_bindings_p ())\n@@ -753,7 +755,7 @@ pushdecl (tree x)\n \t}\n       else if (DECL_FUNCTION_TEMPLATE_P (x) && DECL_NAMESPACE_SCOPE_P (x))\n \t{\n-\t  t = push_overloaded_decl (x, PUSH_GLOBAL);\n+\t  t = push_overloaded_decl (x, PUSH_GLOBAL, is_friend);\n \t  if (t == x)\n \t    add_decl_to_level (x, NAMESPACE_LEVEL (CP_DECL_CONTEXT (t)));\n \t  POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, t);\n@@ -815,6 +817,16 @@ pushdecl (tree x)\n \t    }\n \t}\n \n+      if (TREE_CODE (x) == FUNCTION_DECL\n+\t  && is_friend\n+\t  && !flag_friend_injection)\n+\t{\n+\t  /* This is a new declaration of a friend function, so hide\n+\t     it from ordinary function lookup.  */\n+\t  DECL_ANTICIPATED (x) = 1;\n+\t  DECL_HIDDEN_FRIEND_P (x) = 1;\n+\t}\n+\n       /* This name is new in its binding level.\n \t Install the new declaration and return it.  */\n       if (namespace_bindings_p ())\n@@ -997,6 +1009,14 @@ pushdecl (tree x)\n   POP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, x);\n }\n \n+/* Record a decl-node X as belonging to the current lexical scope.  */\n+\n+tree\n+pushdecl (tree x)\n+{\n+  return pushdecl_maybe_friend (x, false);\n+}\n+\n /* Enter DECL into the symbol table, if that's appropriate.  Returns\n    DECL, or a modified version thereof.  */\n \n@@ -1795,7 +1815,7 @@ push_using_decl (tree scope, tree name)\n    caller to set DECL_CONTEXT properly.  */\n \n tree\n-pushdecl_with_scope (tree x, cxx_scope *level)\n+pushdecl_with_scope (tree x, cxx_scope *level, bool is_friend)\n {\n   struct cp_binding_level *b;\n   tree function_decl = current_function_decl;\n@@ -1813,7 +1833,7 @@ pushdecl_with_scope (tree x, cxx_scope *level)\n     {\n       b = current_binding_level;\n       current_binding_level = level;\n-      x = pushdecl (x);\n+      x = pushdecl_maybe_friend (x, is_friend);\n       current_binding_level = b;\n     }\n   current_function_decl = function_decl;\n@@ -1835,12 +1855,14 @@ pushdecl_with_scope (tree x, cxx_scope *level)\n      PUSH_USING: DECL is being pushed as the result of a using\n \t\t declaration.\n \n+   IS_FRIEND is true if this is a friend declaration.\n+\n    The value returned may be a previous declaration if we guessed wrong\n    about what language DECL should belong to (C or C++).  Otherwise,\n    it's always DECL (and never something that's not a _DECL).  */\n \n static tree\n-push_overloaded_decl (tree decl, int flags)\n+push_overloaded_decl (tree decl, int flags, bool is_friend)\n {\n   tree name = DECL_NAME (decl);\n   tree old;\n@@ -1880,15 +1902,16 @@ push_overloaded_decl (tree decl, int flags)\n \t\terror (\"%q#D conflicts with previous using declaration %q#D\",\n \t\t       decl, fn);\n \n-\t      if (duplicate_decls (decl, fn) == fn)\n+\t      if (duplicate_decls (decl, fn, is_friend) == fn)\n \t\tPOP_TIMEVAR_AND_RETURN (TV_NAME_LOOKUP, fn);\n \t    }\n \n \t  /* We don't overload implicit built-ins.  duplicate_decls()\n \t     may fail to merge the decls if the new decl is e.g. a\n \t     template function.  */\n \t  if (TREE_CODE (old) == FUNCTION_DECL\n-\t      && DECL_ANTICIPATED (old))\n+\t      && DECL_ANTICIPATED (old)\n+\t      && !DECL_HIDDEN_FRIEND_P (old))\n \t    old = NULL;\n \t}\n       else if (old == error_mark_node)\n@@ -2037,7 +2060,8 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n      is a built-in, then we can just pretend it isn't there.  */\n   if (oldval\n       && TREE_CODE (oldval) == FUNCTION_DECL\n-      && DECL_ANTICIPATED (oldval))\n+      && DECL_ANTICIPATED (oldval)\n+      && !DECL_HIDDEN_FRIEND_P (oldval))\n     oldval = NULL_TREE;\n \n   /* Check for using functions.  */\n@@ -2075,7 +2099,8 @@ do_nonmember_using_decl (tree scope, tree name, tree oldval, tree oldtype,\n \t      else if (compparms (TYPE_ARG_TYPES (TREE_TYPE (new_fn)),\n \t\t\t\t  TYPE_ARG_TYPES (TREE_TYPE (old_fn))))\n \t\t{\n-\t\t  gcc_assert (!DECL_ANTICIPATED (old_fn));\n+\t\t  gcc_assert (!DECL_ANTICIPATED (old_fn)\n+\t\t\t      || DECL_HIDDEN_FRIEND_P (old_fn));\n \n \t\t  /* There was already a non-using declaration in\n \t\t     this scope with the same parameter types. If both\n@@ -2168,7 +2193,8 @@ do_local_using_decl (tree decl, tree scope, tree name)\n \t  for (fn = newval; fn && OVL_CURRENT (fn) != term;\n \t       fn = OVL_NEXT (fn))\n \t    push_overloaded_decl (OVL_CURRENT (fn),\n-\t\t\t\t  PUSH_LOCAL | PUSH_USING);\n+\t\t\t\t  PUSH_LOCAL | PUSH_USING,\n+\t\t\t\t  false);\n \t}\n       else\n \tpush_local_binding (name, newval, PUSH_USING);\n@@ -3058,13 +3084,13 @@ do_namespace_alias (tree alias, tree namespace)\n    if appropriate.  */\n \n tree\n-pushdecl_namespace_level (tree x)\n+pushdecl_namespace_level (tree x, bool is_friend)\n {\n   struct cp_binding_level *b = current_binding_level;\n   tree t;\n \n   timevar_push (TV_NAME_LOOKUP);\n-  t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace));\n+  t = pushdecl_with_scope (x, NAMESPACE_LEVEL (current_namespace), is_friend);\n \n   /* Now, the type_shadowed stack may screw us.  Munge it so it does\n      what we want.  */\n@@ -3247,11 +3273,11 @@ parse_using_directive (tree namespace, tree attribs)\n    *INIT, if INIT is non-NULL.  */\n \n static tree\n-pushdecl_top_level_1 (tree x, tree *init)\n+pushdecl_top_level_1 (tree x, tree *init, bool is_friend)\n {\n   timevar_push (TV_NAME_LOOKUP);\n   push_to_top_level ();\n-  x = pushdecl_namespace_level (x);\n+  x = pushdecl_namespace_level (x, is_friend);\n   if (init)\n     cp_finish_decl (x, *init, NULL_TREE, 0);\n   pop_from_top_level ();\n@@ -3263,7 +3289,15 @@ pushdecl_top_level_1 (tree x, tree *init)\n tree\n pushdecl_top_level (tree x)\n {\n-  return pushdecl_top_level_1 (x, NULL);\n+  return pushdecl_top_level_1 (x, NULL, false);\n+}\n+\n+/* Like pushdecl_top_level, but adding the IS_FRIEND parameter.  */\n+\n+tree\n+pushdecl_top_level_maybe_friend (tree x, bool is_friend)\n+{\n+  return pushdecl_top_level_1 (x, NULL, is_friend);\n }\n \n /* Like pushdecl, only it places X in the global scope if\n@@ -3273,7 +3307,7 @@ pushdecl_top_level (tree x)\n tree\n pushdecl_top_level_and_finish (tree x, tree init)\n {\n-  return pushdecl_top_level_1 (x, &init);\n+  return pushdecl_top_level_1 (x, &init, false);\n }\n \n /* Combines two sets of overloaded functions into an OVERLOAD chain, removing\n@@ -3440,7 +3474,7 @@ qualify_lookup (tree val, int flags)\n }\n \n /* Given a lookup that returned VAL, decide if we want to ignore it or\n-   not based on DECL_ANTICIPATED_P.  */\n+   not based on DECL_ANTICIPATED.  */\n \n bool\n hidden_name_p (tree val)\n@@ -3452,6 +3486,38 @@ hidden_name_p (tree val)\n   return false;\n }\n \n+/* Remove any hidden friend functions from a possibly overloaded set\n+   of functions.  */\n+\n+tree\n+remove_hidden_names (tree fns)\n+{\n+  if (!fns)\n+    return fns;\n+\n+  if (TREE_CODE (fns) == FUNCTION_DECL && hidden_name_p (fns))\n+    fns = NULL_TREE;\n+  else if (TREE_CODE (fns) == OVERLOAD)\n+    {\n+      tree o;\n+\n+      for (o = fns; o; o = OVL_NEXT (o))\n+\tif (hidden_name_p (OVL_CURRENT (o)))\n+\t  break;\n+      if (o)\n+\t{\n+\t  tree n = NULL_TREE;\n+\n+\t  for (o = fns; o; o = OVL_NEXT (o))\n+\t    if (!hidden_name_p (OVL_CURRENT (o)))\n+\t      n = build_overload (OVL_CURRENT (o), n);\n+\t  fns = n;\n+\t}\n+    }\n+\n+  return fns;\n+}\n+\n /* Look up NAME in the NAMESPACE.  */\n \n tree\n@@ -4112,6 +4178,7 @@ lookup_type_current_level (tree name)\n struct arg_lookup\n {\n   tree name;\n+  tree args;\n   tree namespaces;\n   tree classes;\n   tree functions;\n@@ -4190,6 +4257,53 @@ is_associated_namespace (tree current, tree scope)\n     }\n }\n \n+/* Return whether FN is a friend of an associated class of ARG.  */\n+\n+static bool\n+friend_of_associated_class_p (tree arg, tree fn)\n+{\n+  tree type;\n+\n+  if (TYPE_P (arg))\n+    type = arg;\n+  else if (type_unknown_p (arg))\n+    return false;\n+  else\n+    type = TREE_TYPE (arg);\n+\n+  /* If TYPE is a class, the class itself and all base classes are\n+     associated classes.  */\n+  if (CLASS_TYPE_P (type))\n+    {\n+      if (is_friend (type, fn))\n+\treturn true;\n+\n+      if (TYPE_BINFO (type))\n+\t{\n+\t  tree binfo, base_binfo;\n+\t  int i;\n+\n+\t  for (binfo = TYPE_BINFO (type), i = 0;\n+\t       BINFO_BASE_ITERATE (binfo, i, base_binfo);\n+\t       i++)\n+\t    if (is_friend (BINFO_TYPE (base_binfo), fn))\n+\t      return true;\n+\t}\n+    }\n+\n+  /* If TYPE is a class member, the class of which it is a member is\n+     an associated class.  */\n+  if ((CLASS_TYPE_P (type)\n+       || TREE_CODE (type) == UNION_TYPE\n+       || TREE_CODE (type) == ENUMERAL_TYPE)\n+      && TYPE_CONTEXT (type)\n+      && CLASS_TYPE_P (TYPE_CONTEXT (type))\n+      && is_friend (TYPE_CONTEXT (type), fn))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Add functions of a namespace to the lookup structure.\n    Returns true on error.  */\n \n@@ -4213,8 +4327,25 @@ arg_assoc_namespace (struct arg_lookup *k, tree scope)\n     return false;\n \n   for (; value; value = OVL_NEXT (value))\n-    if (add_function (k, OVL_CURRENT (value)))\n-      return true;\n+    {\n+      /* We don't want to find arbitrary hidden functions via argument\n+\t dependent lookup.  We only want to find friends of associated\n+\t classes.  */\n+      if (hidden_name_p (OVL_CURRENT (value)))\n+\t{\n+\t  tree args;\n+\n+\t  for (args = k->args; args; args = TREE_CHAIN (args))\n+\t    if (friend_of_associated_class_p (TREE_VALUE (args),\n+\t\t\t\t\t      OVL_CURRENT (value)))\n+\t      break;\n+\t  if (!args)\n+\t    continue;\n+\t}\n+\n+      if (add_function (k, OVL_CURRENT (value)))\n+\treturn true;\n+    }\n \n   return false;\n }\n@@ -4485,7 +4616,14 @@ lookup_arg_dependent (tree name, tree fns, tree args)\n   struct arg_lookup k;\n \n   timevar_push (TV_NAME_LOOKUP);\n+\n+  /* Remove any hidden friend functions from the list of functions\n+     found so far.  They will be added back by arg_assoc_class as\n+     appropriate.  */\n+  fns = remove_hidden_names (fns);\n+\n   k.name = name;\n+  k.args = args;\n   k.functions = fns;\n   k.classes = NULL_TREE;\n \n@@ -4699,7 +4837,7 @@ pushtag (tree name, tree type, tag_scope scope)\n \t    pushdecl_class_level (decl);\n \t}\n       else if (b->kind != sk_template_parms)\n-\tdecl = pushdecl_with_scope (decl, b);\n+\tdecl = pushdecl_with_scope (decl, b, /*is_friend=*/false);\n \n       TYPE_CONTEXT (type) = DECL_CONTEXT (decl);\n "}, {"sha": "fa2a760bd94e73cf67fb37de790f93592924dfe3", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -311,20 +311,21 @@ extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);\n extern void pushlevel_class (void);\n extern void poplevel_class (void);\n-extern tree pushdecl_with_scope (tree, cxx_scope *);\n+extern tree pushdecl_with_scope (tree, cxx_scope *, bool);\n extern tree lookup_name\t(tree, int);\n extern tree lookup_name_real (tree, int, int, bool, int, int);\n extern tree lookup_type_scope (tree, tag_scope);\n extern tree namespace_binding (tree, tree);\n extern void set_namespace_binding (tree, tree, tree);\n extern bool hidden_name_p (tree);\n+extern tree remove_hidden_names (tree);\n extern tree lookup_namespace_name (tree, tree);\n extern tree lookup_qualified_name (tree, tree, bool, bool);\n extern tree lookup_name_nonclass (tree);\n extern tree lookup_function_nonclass (tree, tree, bool);\n extern void push_local_binding (tree, tree, int);\n extern bool pushdecl_class_level (tree);\n-extern tree pushdecl_namespace_level (tree);\n+extern tree pushdecl_namespace_level (tree, bool);\n extern bool push_class_level_binding (tree, tree);\n extern tree getdecls (void);\n extern tree cp_namespace_decls (tree);"}, {"sha": "3f749554e675b85ceb8dd04c31ce5b78ead5d7c0", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1114,11 +1114,12 @@ is_specialization_of_friend (tree decl, tree friend)\n }\n \n /* Register the specialization SPEC as a specialization of TMPL with\n-   the indicated ARGS.  Returns SPEC, or an equivalent prior\n-   declaration, if available.  */\n+   the indicated ARGS.  IS_FRIEND indicates whether the specialization\n+   is actually just a friend declaration.  Returns SPEC, or an\n+   equivalent prior declaration, if available.  */\n \n static tree\n-register_specialization (tree spec, tree tmpl, tree args)\n+register_specialization (tree spec, tree tmpl, tree args, bool is_friend)\n {\n   tree fn;\n \n@@ -1185,14 +1186,14 @@ register_specialization (tree spec, tree tmpl, tree args)\n \t\t for the specialization, we want this to look as if\n \t\t there were no definition, and vice versa.  */\n \t      DECL_INITIAL (fn) = NULL_TREE;\n-\t      duplicate_decls (spec, fn);\n+\t      duplicate_decls (spec, fn, is_friend);\n \n \t      return fn;\n \t    }\n \t}\n       else if (DECL_TEMPLATE_SPECIALIZATION (fn))\n \t{\n-\t  if (!duplicate_decls (spec, fn) && DECL_INITIAL (spec))\n+\t  if (!duplicate_decls (spec, fn, is_friend) && DECL_INITIAL (spec))\n \t    /* Dup decl failed, but this is a new definition. Set the\n \t       line number so any errors match this new\n \t       definition.  */\n@@ -2108,7 +2109,7 @@ check_explicit_specialization (tree declarator,\n \n \t  /* Register this specialization so that we can find it\n \t     again.  */\n-\t  decl = register_specialization (decl, gen_tmpl, targs);\n+\t  decl = register_specialization (decl, gen_tmpl, targs, is_friend);\n \t}\n     }\n \n@@ -2882,10 +2883,10 @@ template_parm_this_level_p (tree t, void* data)\n    previously existing one, if appropriate.  Returns the DECL, or an\n    equivalent one, if it is replaced via a call to duplicate_decls.\n \n-   If IS_FRIEND is nonzero, DECL is a friend declaration.  */\n+   If IS_FRIEND is true, DECL is a friend declaration.  */\n \n tree\n-push_template_decl_real (tree decl, int is_friend)\n+push_template_decl_real (tree decl, bool is_friend)\n {\n   tree tmpl;\n   tree args;\n@@ -2906,7 +2907,8 @@ push_template_decl_real (tree decl, int is_friend)\n \t\t&& TREE_CODE (TREE_TYPE (decl)) != ENUMERAL_TYPE\n \t\t&& CLASSTYPE_TEMPLATE_SPECIALIZATION (TREE_TYPE (decl)));\n \n-  is_friend |= (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl));\n+  if (TREE_CODE (decl) == FUNCTION_DECL && DECL_FRIEND_P (decl))\n+    is_friend = true;\n \n   if (is_friend)\n     /* For a friend, we want the context of the friend function, not\n@@ -3081,7 +3083,8 @@ push_template_decl_real (tree decl, int is_friend)\n \n \t  register_specialization (new_tmpl,\n \t\t\t\t   most_general_template (tmpl),\n-\t\t\t\t   args);\n+\t\t\t\t   args,\n+\t\t\t\t   is_friend);\n \t  return decl;\n \t}\n \n@@ -3132,7 +3135,7 @@ push_template_decl_real (tree decl, int is_friend)\n   if (new_template_p && !ctx\n       && !(is_friend && template_class_depth (current_class_type) > 0))\n     {\n-      tmpl = pushdecl_namespace_level (tmpl);\n+      tmpl = pushdecl_namespace_level (tmpl, is_friend);\n       if (tmpl == error_mark_node)\n \treturn error_mark_node;\n \n@@ -3187,7 +3190,7 @@ push_template_decl_real (tree decl, int is_friend)\n tree\n push_template_decl (tree decl)\n {\n-  return push_template_decl_real (decl, 0);\n+  return push_template_decl_real (decl, false);\n }\n \n /* Called when a class template TYPE is redeclared with the indicated\n@@ -5175,7 +5178,7 @@ tsubst_friend_function (tree decl, tree args)\n \t into the namespace of the template.  */\n       ns = decl_namespace_context (new_friend);\n       push_nested_namespace (ns);\n-      old_decl = pushdecl_namespace_level (new_friend);\n+      old_decl = pushdecl_namespace_level (new_friend, /*is_friend=*/true);\n       pop_nested_namespace (ns);\n \n       if (old_decl != new_friend)\n@@ -5387,7 +5390,7 @@ tsubst_friend_class (tree friend_tmpl, tree args)\n \t= INNERMOST_TEMPLATE_ARGS (CLASSTYPE_TI_ARGS (TREE_TYPE (tmpl)));\n \n       /* Inject this template into the global scope.  */\n-      friend_type = TREE_TYPE (pushdecl_top_level (tmpl));\n+      friend_type = TREE_TYPE (pushdecl_top_level_maybe_friend (tmpl, true));\n     }\n \n   if (context)\n@@ -6302,7 +6305,8 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \tif (TREE_CODE (decl) != TYPE_DECL)\n \t  /* Record this non-type partial instantiation.  */\n \t  register_specialization (r, t,\n-\t\t\t\t   DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)));\n+\t\t\t\t   DECL_TI_ARGS (DECL_TEMPLATE_RESULT (r)),\n+\t\t\t\t   false);\n       }\n       break;\n \n@@ -6477,7 +6481,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t    DECL_TEMPLATE_INFO (r)\n \t      = tree_cons (gen_tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n-\t    register_specialization (r, gen_tmpl, argvec);\n+\t    register_specialization (r, gen_tmpl, argvec, false);\n \n \t    /* We're not supposed to instantiate default arguments\n \t       until they are called, for a template.  But, for a\n@@ -6706,7 +6710,7 @@ tsubst_decl (tree t, tree args, tsubst_flags_t complain)\n \t       processing here.  */\n \t    DECL_EXTERNAL (r) = 1;\n \n-\t    register_specialization (r, gen_tmpl, argvec);\n+\t    register_specialization (r, gen_tmpl, argvec, false);\n \t    DECL_TEMPLATE_INFO (r) = tree_cons (tmpl, argvec, NULL_TREE);\n \t    SET_DECL_IMPLICIT_INSTANTIATION (r);\n \t  }"}, {"sha": "c7392b034ce34a755f18b0df631ed0642952f430", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1822,7 +1822,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n       if (!result)\n \t/* A call to a namespace-scope function.  */\n-\tresult = build_new_function_call (fn, args);\n+\tresult = build_new_function_call (fn, args, koenig_p);\n     }\n   else if (TREE_CODE (fn) == PSEUDO_DTOR_EXPR)\n     {"}, {"sha": "55cf558d3abc05c0c50581f6368522eb28198f1b", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -171,7 +171,7 @@ in the following sections.\n @item C++ Language Options\n @xref{C++ Dialect Options,,Options Controlling C++ Dialect}.\n @gccoptlist{-fabi-version=@var{n}  -fno-access-control  -fcheck-new @gol\n--fconserve-space  -fno-const-strings @gol\n+-fconserve-space  -ffriend-injection  -fno-const-strings @gol\n -fno-elide-constructors @gol\n -fno-enforce-eh-specs @gol\n -ffor-scope  -fno-for-scope  -fno-gnu-keywords @gol\n@@ -1425,6 +1425,20 @@ two definitions were merged.\n This option is no longer useful on most targets, now that support has\n been added for putting variables into BSS without making them common.\n \n+@item -ffriend-injection\n+@opindex ffriend-injection\n+Inject friend functions into the enclosing namespace, so that they are\n+visible outside the scope of the class in which they are declared.\n+Friend functions were documented to work this way in the old Annotated\n+C++ Reference Manual, and versions of G++ before 4.1 always worked\n+that way.  However, in ISO C++ a friend function which is not declared\n+in an enclosing scope can only be found using argument dependent\n+lookup.  This option causes friends to be injected as they were in\n+earlier releases.\n+\n+This option is for compatibility, and may be removed in a future\n+release of G++.\n+\n @item -fno-const-strings\n @opindex fno-const-strings\n Give string constants type @code{char *} instead of type @code{const"}, {"sha": "cdea80a8ccd37acba70604278cfd27de7be10c13", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1,3 +1,18 @@\n+2005-09-12  Ian Lance Taylor  <ian@airs.com>\n+\n+\tPR g++/7874\n+\t* g++.dg/lookup/friend7.C: New test.\n+\t* g++.dg/lookup/friend8.C: New test.\n+\t* g++.dg/parse/defarg4.C: Add a parameter to the friend function,\n+\tso that it will be found via argument dependent lookup.\n+\t* g++.old-deja/g++.brendan/crash56.C: Don't expect errors for\n+\tfriend functions which will no longer be found.\n+\t* g++.old-deja/g++.jason/friend.C: Add a parameter to the friend\n+\tfunction g, so that it will be found via argument dependent\n+\tlookup.\n+\t* g++.old-deja/g++.jason/scoping15.C: Use -ffriend-injection.\n+\t* g++.old-deja/g++.mike/net43.C: Likewise.\n+\n 2005-09-12  Mark Mitchell  <mark@codesourcery.com>\n \n \tPR c++/23691"}, {"sha": "dd19c72f9a6567c3726b4e67372caafb1a8b6c64", "filename": "gcc/testsuite/g++.dg/lookup/friend7.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend7.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend7.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend7.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -0,0 +1,19 @@\n+// { dg-do compile }\n+// PR c++/7874: Don't inject friend functions into global name space.\n+\n+namespace N { template<typename T> struct A { friend void f(A) { }; }; }\n+int main()\n+{\n+   N::A<int> a;\n+   N::f(a);\t\t// { dg-error \"not a member\" }\n+}\n+\n+struct S { friend void g(); friend void h(S); };\n+struct T { friend void g(); friend void h(T); };\n+void i() {\n+  g();\t\t\t// { dg-error \"not declared\" }\n+  S s;\n+  h(s);\n+  T t;\n+  h(t);\n+}"}, {"sha": "e9992cdadf41924a215394be75784f66f3c0e57b", "filename": "gcc/testsuite/g++.dg/lookup/friend8.C", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend8.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend8.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Flookup%2Ffriend8.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -0,0 +1,12 @@\n+// Test that we look up a friend declared at top level ahead of an\n+// undeclared friend found by argument dependent lookup.\n+\n+// { dg-do run }\n+\n+int f(int) { return 0; }\n+\n+struct S {\n+  friend int f(char) { return 1; }\n+};\n+\n+int main () { return f('a'); }"}, {"sha": "bafdadb9429f6e27e35244bf4f8e2c3593d127eb", "filename": "gcc/testsuite/g++.dg/parse/defarg4.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fparse%2Fdefarg4.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -6,9 +6,10 @@\n // PR c++ 9162. default args got left unprocessed\n \n struct S {\n-  friend int foo (int = 100);\n+  friend int foo (const S&, int = 100);\n };\n-int i = foo ();\n+S s;\n+int i = foo (s);\n \n struct R\n {"}, {"sha": "d1cae6d198a136d09d41cbd42c249fadaaec67be", "filename": "gcc/testsuite/g++.old-deja/g++.brendan/crash56.C", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.brendan%2Fcrash56.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -20,15 +20,15 @@ public:\n     class Vix {\n     public:\n \tVix();\n-\tfriend int operator==(void *v, const Vix& x) // { dg-error \"operator==\" }\n+\tfriend int operator==(void *v, const Vix& x)\n \t    { return v == x.item; }\n-\tfriend int operator==(const Vix& x, void *v) // { dg-error \"operator==\" }\n+\tfriend int operator==(const Vix& x, void *v)\n \t    { return v == x.item; }\n \tfriend int operator!=(void *v, const Vix& x)\n \t    { return v != x.item; }\n \tfriend int operator!=(const Vix& x, void *v)\n \t    { return v != x.item; }\n-\tfriend int operator==(const Vix& x1, const Vix& x2) // { dg-error \"operator==\" }\n+\tfriend int operator==(const Vix& x1, const Vix& x2)\n \t    { return x1.owner == x2.owner && x1.item == x2.item; }\n \tfriend int operator!=(const Vix& x1, const Vix& x2)\n \t    { return x1.owner != x2.owner || x1.item != x2.item; }"}, {"sha": "9bcc81488b59a4b7573e90d23468f9d3645afb08", "filename": "gcc/testsuite/g++.old-deja/g++.jason/friend.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ffriend.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ffriend.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Ffriend.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -10,10 +10,11 @@ struct A {\n \n struct B {\n   static void f () { exit (0); }\n-  friend void g () { f (); }\n+  friend void g (B) { f (); }\n };\n \n int main ()\n {\n-  g ();\n+  B b;\n+  g (b);\n }"}, {"sha": "cc34c5f5785e2d768da1c936150223b7174774f9", "filename": "gcc/testsuite/g++.old-deja/g++.jason/scoping15.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fscoping15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fscoping15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.jason%2Fscoping15.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1,4 +1,5 @@\n // { dg-do assemble  }\n+// { dg-options \"-ffriend-injection\" }\n // Bug: g++ ignores the :: qualification and dies trying to treat an integer\n // variable as a list of functions.\n "}, {"sha": "aadd03de92f39c12a41a4361d7a68bac7b9e8f6d", "filename": "gcc/testsuite/g++.old-deja/g++.mike/net43.C", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet43.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d63d5d0c32c03cd13765216b9107414849b1f05d/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet43.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.mike%2Fnet43.C?ref=d63d5d0c32c03cd13765216b9107414849b1f05d", "patch": "@@ -1,4 +1,5 @@\n // { dg-do assemble  }\n+// { dg-options \"-ffriend-injection\" }\n \n class foo {\n  public:"}]}