{"sha": "22d8712ac4f4f04786d4a2428cde756b065b9f97", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjJkODcxMmFjNGY0ZjA0Nzg2ZDRhMjQyOGNkZTc1NmIwNjViOWY5Nw==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-11-11T19:55:23Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2011-11-11T19:55:23Z"}, "message": "re PR tree-optimization/51074 (No constant folding performed for VEC_PERM_EXPR, VEC_INTERLEAVE*EXPR, VEC_EXTRACT*EXPR)\n\n\tPR tree-optimization/51074\n\t* fold-const.c (vec_cst_ctor_to_array, fold_vec_perm): New functions.\n\t(fold_binary_loc): Handle VEC_EXTRACT_EVEN_EXPR,\n\tVEC_EXTRACT_ODD_EXPR, VEC_INTERLEAVE_HIGH_EXPR and\n\tVEC_INTERLEAVE_LOW_EXPR with VECTOR_CST or CONSTRUCTOR operands.\n\t(fold_ternary_loc): Handle VEC_PERM_EXPR with VECTOR_CST or\n\tCONSTRUCTOR operands.\n\t* tree-ssa-propagate.c (valid_gimple_rhs_p): Handle ternary\n\texpressions.\n\t* tree-vect-generic.c (lower_vec_perm): Mask sel_int elements\n\tto 0 .. 2 * elements - 1.\n\nFrom-SVN: r181297", "tree": {"sha": "da6d861de02810601827aa20e1dd872a3b954e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da6d861de02810601827aa20e1dd872a3b954e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/22d8712ac4f4f04786d4a2428cde756b065b9f97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22d8712ac4f4f04786d4a2428cde756b065b9f97", "html_url": "https://github.com/Rust-GCC/gccrs/commit/22d8712ac4f4f04786d4a2428cde756b065b9f97", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/22d8712ac4f4f04786d4a2428cde756b065b9f97/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0540978881f0e0de7d84c470628a1897b01b6831", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0540978881f0e0de7d84c470628a1897b01b6831", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0540978881f0e0de7d84c470628a1897b01b6831"}], "stats": {"total": 190, "additions": 189, "deletions": 1}, "files": [{"sha": "66e6f671767dc440fc97805c1d1d0f380efeb9c4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=22d8712ac4f4f04786d4a2428cde756b065b9f97", "patch": "@@ -1,3 +1,17 @@\n+2011-11-11  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR tree-optimization/51074\n+\t* fold-const.c (vec_cst_ctor_to_array, fold_vec_perm): New functions.\n+\t(fold_binary_loc): Handle VEC_EXTRACT_EVEN_EXPR,\n+\tVEC_EXTRACT_ODD_EXPR, VEC_INTERLEAVE_HIGH_EXPR and\n+\tVEC_INTERLEAVE_LOW_EXPR with VECTOR_CST or CONSTRUCTOR operands.\n+\t(fold_ternary_loc): Handle VEC_PERM_EXPR with VECTOR_CST or\n+\tCONSTRUCTOR operands.\n+\t* tree-ssa-propagate.c (valid_gimple_rhs_p): Handle ternary\n+\texpressions.\n+\t* tree-vect-generic.c (lower_vec_perm): Mask sel_int elements\n+\tto 0 .. 2 * elements - 1.\n+\n 2011-11-11  Richard Henderson  <rth@redhat.com>\n \n \t* gimple-pretty-print.c (dump_gimple_omp_atomic_load): Dump needed."}, {"sha": "167573b17b3160843e74092682bb333321709201", "filename": "gcc/fold-const.c", "status": "modified", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=22d8712ac4f4f04786d4a2428cde756b065b9f97", "patch": "@@ -9528,6 +9528,86 @@ get_pointer_modulus_and_residue (tree expr, unsigned HOST_WIDE_INT *residue,\n   return 1;\n }\n \n+/* Helper function for fold_vec_perm.  Store elements of VECTOR_CST or\n+   CONSTRUCTOR ARG into array ELTS and return true if successful.  */\n+\n+static bool\n+vec_cst_ctor_to_array (tree arg, tree *elts)\n+{\n+  unsigned int nelts = TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg)), i;\n+\n+  if (TREE_CODE (arg) == VECTOR_CST)\n+    {\n+      tree t;\n+\n+      for (i = 0, t = TREE_VECTOR_CST_ELTS (arg);\n+\t   i < nelts && t; i++, t = TREE_CHAIN (t))\n+\telts[i] = TREE_VALUE (t);\n+      if (t)\n+\treturn false;\n+    }\n+  else if (TREE_CODE (arg) == CONSTRUCTOR)\n+    {\n+      constructor_elt *elt;\n+\n+      FOR_EACH_VEC_ELT (constructor_elt, CONSTRUCTOR_ELTS (arg), i, elt)\n+\tif (i >= nelts)\n+\t  return false;\n+\telse\n+\t  elts[i] = elt->value;\n+    }\n+  else\n+    return false;\n+  for (; i < nelts; i++)\n+    elts[i]\n+      = fold_convert (TREE_TYPE (TREE_TYPE (arg)), integer_zero_node);\n+  return true;\n+}\n+\n+/* Attempt to fold vector permutation of ARG0 and ARG1 vectors using SEL\n+   selector.  Return the folded VECTOR_CST or CONSTRUCTOR if successful,\n+   NULL_TREE otherwise.  */\n+\n+static tree\n+fold_vec_perm (tree type, tree arg0, tree arg1, const unsigned char *sel)\n+{\n+  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+  tree *elts;\n+  bool need_ctor = false;\n+\n+  gcc_assert (TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg0)) == nelts\n+\t      && TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg1)) == nelts);\n+  if (TREE_TYPE (TREE_TYPE (arg0)) != TREE_TYPE (type)\n+      || TREE_TYPE (TREE_TYPE (arg1)) != TREE_TYPE (type))\n+    return NULL_TREE;\n+\n+  elts = XALLOCAVEC (tree, nelts * 3);\n+  if (!vec_cst_ctor_to_array (arg0, elts)\n+      || !vec_cst_ctor_to_array (arg1, elts + nelts))\n+    return NULL_TREE;\n+\n+  for (i = 0; i < nelts; i++)\n+    {\n+      if (!CONSTANT_CLASS_P (elts[sel[i]]))\n+\tneed_ctor = true;\n+      elts[i + 2 * nelts] = unshare_expr (elts[sel[i]]);\n+    }\n+\n+  if (need_ctor)\n+    {\n+      VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, nelts);\n+      for (i = 0; i < nelts; i++)\n+\tCONSTRUCTOR_APPEND_ELT (v, NULL_TREE, elts[2 * nelts + i]);\n+      return build_constructor (type, v);\n+    }\n+  else\n+    {\n+      tree vals = NULL_TREE;\n+      for (i = 0; i < nelts; i++)\n+\tvals = tree_cons (NULL_TREE, elts[3 * nelts - i - 1], vals);\n+      return build_vector (type, vals);\n+    }\n+}\n \n /* Fold a binary expression of code CODE and type TYPE with operands\n    OP0 and OP1.  LOC is the location of the resulting expression.\n@@ -13381,6 +13461,41 @@ fold_binary_loc (location_t loc,\n       /* An ASSERT_EXPR should never be passed to fold_binary.  */\n       gcc_unreachable ();\n \n+    case VEC_EXTRACT_EVEN_EXPR:\n+    case VEC_EXTRACT_ODD_EXPR:\n+    case VEC_INTERLEAVE_HIGH_EXPR:\n+    case VEC_INTERLEAVE_LOW_EXPR:\n+      if ((TREE_CODE (arg0) == VECTOR_CST\n+\t   || TREE_CODE (arg0) == CONSTRUCTOR)\n+\t  && (TREE_CODE (arg1) == VECTOR_CST\n+\t      || TREE_CODE (arg1) == CONSTRUCTOR))\n+\t{\n+\t  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+\t  unsigned char *sel = XALLOCAVEC (unsigned char, nelts);\n+\n+\t  for (i = 0; i < nelts; i++)\n+\t    switch (code)\n+\t      {\n+\t      case VEC_EXTRACT_EVEN_EXPR:\n+\t\tsel[i] = i * 2;\n+\t\tbreak;\n+\t      case VEC_EXTRACT_ODD_EXPR:\n+\t\tsel[i] = i * 2 + 1;\n+\t\tbreak;\n+\t      case VEC_INTERLEAVE_HIGH_EXPR:\n+\t\tsel[i] = (i + nelts) / 2 + ((i & 1) ? nelts : 0);\n+\t\tbreak;\n+\t      case VEC_INTERLEAVE_LOW_EXPR:\n+\t\tsel[i] = i / 2 + ((i & 1) ? nelts : 0);\n+\t\tbreak;\n+\t      default:\n+\t\tgcc_unreachable ();\n+\t      }\n+\n+\t  return fold_vec_perm (type, arg0, arg1, sel);\n+\t}\n+      return NULL_TREE;\n+\n     default:\n       return NULL_TREE;\n     } /* switch (code) */\n@@ -13767,6 +13882,55 @@ fold_ternary_loc (location_t loc, enum tree_code code, tree type,\n \n       return fold_fma (loc, type, arg0, arg1, arg2);\n \n+    case VEC_PERM_EXPR:\n+      if (TREE_CODE (arg2) == VECTOR_CST)\n+\t{\n+\t  unsigned int nelts = TYPE_VECTOR_SUBPARTS (type), i;\n+\t  unsigned char *sel = XALLOCAVEC (unsigned char, nelts);\n+\t  tree t;\n+\t  bool need_mask_canon = false;\n+\n+\t  gcc_assert (nelts == TYPE_VECTOR_SUBPARTS (TREE_TYPE (arg2)));\n+\t  for (i = 0, t = TREE_VECTOR_CST_ELTS (arg2);\n+\t       i < nelts && t; i++, t = TREE_CHAIN (t))\n+\t    {\n+\t      if (TREE_CODE (TREE_VALUE (t)) != INTEGER_CST)\n+\t\treturn NULL_TREE;\n+\n+\t      sel[i] = TREE_INT_CST_LOW (TREE_VALUE (t)) & (2 * nelts - 1);\n+\t      if (TREE_INT_CST_HIGH (TREE_VALUE (t))\n+\t\t  || ((unsigned HOST_WIDE_INT)\n+\t\t      TREE_INT_CST_LOW (TREE_VALUE (t)) != sel[i]))\n+\t\tneed_mask_canon = true;\n+\t    }\n+\t  if (t)\n+\t    return NULL_TREE;\n+\t  for (; i < nelts; i++)\n+\t    sel[i] = 0;\n+\n+\t  if ((TREE_CODE (arg0) == VECTOR_CST\n+\t       || TREE_CODE (arg0) == CONSTRUCTOR)\n+\t      && (TREE_CODE (arg1) == VECTOR_CST\n+\t\t  || TREE_CODE (arg1) == CONSTRUCTOR))\n+\t    {\n+\t      t = fold_vec_perm (type, arg0, arg1, sel);\n+\t      if (t != NULL_TREE)\n+\t\treturn t;\n+\t    }\n+\n+\t  if (need_mask_canon && arg2 == op2)\n+\t    {\n+\t      tree list = NULL_TREE, eltype = TREE_TYPE (TREE_TYPE (arg2));\n+\t      for (i = 0; i < nelts; i++)\n+\t\tlist = tree_cons (NULL_TREE,\n+\t\t\t\t  build_int_cst (eltype, sel[nelts - i - 1]),\n+\t\t\t\t  list);\n+\t      t = build_vector (TREE_TYPE (arg2), list);\n+\t      return build3_loc (loc, VEC_PERM_EXPR, type, op0, op1, t);\n+\t    }\n+\t}\n+      return NULL_TREE;\n+\n     default:\n       return NULL_TREE;\n     } /* switch (code) */"}, {"sha": "80b33e11d80ec16a77de893a5c29756f991559a7", "filename": "gcc/tree-ssa-propagate.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ftree-ssa-propagate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ftree-ssa-propagate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-propagate.c?ref=22d8712ac4f4f04786d4a2428cde756b065b9f97", "patch": "@@ -602,6 +602,16 @@ valid_gimple_rhs_p (tree expr)\n           break;\n \n \tdefault:\n+\t  if (get_gimple_rhs_class (code) == GIMPLE_TERNARY_RHS)\n+\t    {\n+\t      if (((code == VEC_COND_EXPR || code == COND_EXPR)\n+\t\t   ? !is_gimple_condexpr (TREE_OPERAND (expr, 0))\n+\t\t   : !is_gimple_val (TREE_OPERAND (expr, 0)))\n+\t\t  || !is_gimple_val (TREE_OPERAND (expr, 1))\n+\t\t  || !is_gimple_val (TREE_OPERAND (expr, 2)))\n+\t\treturn false;\n+\t      break;\n+\t    }\n \t  return false;\n \t}\n       break;"}, {"sha": "dc01ce7b24cf220207860454edbd3fa5fb1369fb", "filename": "gcc/tree-vect-generic.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/22d8712ac4f4f04786d4a2428cde756b065b9f97/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=22d8712ac4f4f04786d4a2428cde756b065b9f97", "patch": "@@ -649,7 +649,7 @@ lower_vec_perm (gimple_stmt_iterator *gsi)\n       tree vals = TREE_VECTOR_CST_ELTS (mask);\n \n       for (i = 0; i < elements; ++i, vals = TREE_CHAIN (vals))\n-\tsel_int[i] = TREE_INT_CST_LOW (TREE_VALUE (vals));\n+\tsel_int[i] = TREE_INT_CST_LOW (TREE_VALUE (vals)) & (2 * elements - 1);\n \n       if (can_vec_perm_p (TYPE_MODE (vect_type), false, sel_int))\n \treturn;"}]}