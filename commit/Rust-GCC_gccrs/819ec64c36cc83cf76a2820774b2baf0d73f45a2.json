{"sha": "819ec64c36cc83cf76a2820774b2baf0d73f45a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODE5ZWM2NGMzNmNjODNjZjc2YTI4MjA3NzRiMmJhZjBkNzNmNDVhMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2015-07-30T13:11:41Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2015-07-30T13:11:41Z"}, "message": "gimple-fold.c (fold_gimple_assign): Only fold !tcc_comparison binaries.\n\n2015-07-30  Richard Biener  <rguenther@suse.de>\n\n\t* gimple-fold.c (fold_gimple_assign): Only fold !tcc_comparison\n\tbinaries.  Move X == 0, X == 1, X != 0, and X != 1 canonicalization ...\n\t(fold_stmt_1): ... here and work on GIMPLE directly.  Remove\n\tredundant operand canonicalization.\n\nFrom-SVN: r226404", "tree": {"sha": "21e7660d440ac08a0a38e73b83f9b8fe7848833f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/21e7660d440ac08a0a38e73b83f9b8fe7848833f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/819ec64c36cc83cf76a2820774b2baf0d73f45a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819ec64c36cc83cf76a2820774b2baf0d73f45a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/819ec64c36cc83cf76a2820774b2baf0d73f45a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/819ec64c36cc83cf76a2820774b2baf0d73f45a2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "cb5ca3151b583084caa29fc547a2d261cf8fad2d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cb5ca3151b583084caa29fc547a2d261cf8fad2d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cb5ca3151b583084caa29fc547a2d261cf8fad2d"}], "stats": {"total": 127, "additions": 61, "deletions": 66}, "files": [{"sha": "be3a66e0500dbec076d6a5584633aafca85b4bd4", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819ec64c36cc83cf76a2820774b2baf0d73f45a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819ec64c36cc83cf76a2820774b2baf0d73f45a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=819ec64c36cc83cf76a2820774b2baf0d73f45a2", "patch": "@@ -1,3 +1,10 @@\n+2015-07-30  Richard Biener  <rguenther@suse.de>\n+\n+\t* gimple-fold.c (fold_gimple_assign): Only fold !tcc_comparison\n+\tbinaries.  Move X == 0, X == 1, X != 0, and X != 1 canonicalization ...\n+\t(fold_stmt_1): ... here and work on GIMPLE directly.  Remove\n+\tredundant operand canonicalization.\n+\n 2015-07-30  David Sherwood  <david.sherwood@arm.com>\n \n \t* config/aarch64/aarch64-simd.md (aarch64_ext<mode>): Replace call to"}, {"sha": "94a5967677815d3311ba7aeb2cc26f9a8892ef9c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 54, "deletions": 66, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/819ec64c36cc83cf76a2820774b2baf0d73f45a2/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/819ec64c36cc83cf76a2820774b2baf0d73f45a2/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=819ec64c36cc83cf76a2820774b2baf0d73f45a2", "patch": "@@ -413,60 +413,20 @@ fold_gimple_assign (gimple_stmt_iterator *si)\n       break;\n \n     case GIMPLE_BINARY_RHS:\n-      /* Try to canonicalize for boolean-typed X the comparisons\n-\t X == 0, X == 1, X != 0, and X != 1.  */\n-      if (gimple_assign_rhs_code (stmt) == EQ_EXPR\n-\t  || gimple_assign_rhs_code (stmt) == NE_EXPR)\n-        {\n-\t  tree lhs = gimple_assign_lhs (stmt);\n-\t  tree op1 = gimple_assign_rhs1 (stmt);\n-\t  tree op2 = gimple_assign_rhs2 (stmt);\n-\t  tree type = TREE_TYPE (op1);\n-\n-\t  /* Check whether the comparison operands are of the same boolean\n-\t     type as the result type is.\n-\t     Check that second operand is an integer-constant with value\n-\t     one or zero.  */\n-\t  if (TREE_CODE (op2) == INTEGER_CST\n-\t      && (integer_zerop (op2) || integer_onep (op2))\n-\t      && useless_type_conversion_p (TREE_TYPE (lhs), type))\n+      if (TREE_CODE_CLASS (subcode) != tcc_comparison)\n+\t{\n+\t  result = fold_binary_loc (loc, subcode,\n+\t\t\t\t    TREE_TYPE (gimple_assign_lhs (stmt)),\n+\t\t\t\t    gimple_assign_rhs1 (stmt),\n+\t\t\t\t    gimple_assign_rhs2 (stmt));\n+\n+\t  if (result)\n \t    {\n-\t      enum tree_code cmp_code = gimple_assign_rhs_code (stmt);\n-\t      bool is_logical_not = false;\n-\n-\t      /* X == 0 and X != 1 is a logical-not.of X\n-\t         X == 1 and X != 0 is X  */\n-\t      if ((cmp_code == EQ_EXPR && integer_zerop (op2))\n-\t          || (cmp_code == NE_EXPR && integer_onep (op2)))\n-\t        is_logical_not = true;\n-\n-\t      if (is_logical_not == false)\n-\t        result = op1;\n-\t      /* Only for one-bit precision typed X the transformation\n-\t         !X -> ~X is valied.  */\n-\t      else if (TYPE_PRECISION (type) == 1)\n-\t\tresult = build1_loc (gimple_location (stmt), BIT_NOT_EXPR,\n-\t\t\t\t     type, op1);\n-\t      /* Otherwise we use !X -> X ^ 1.  */\n-\t      else\n-\t        result = build2_loc (gimple_location (stmt), BIT_XOR_EXPR,\n-\t\t\t\t     type, op1, build_int_cst (type, 1));\n-\t     \n+\t      STRIP_USELESS_TYPE_CONVERSION (result);\n+\t      if (valid_gimple_rhs_p (result))\n+\t\treturn result;\n \t    }\n \t}\n-\n-      if (!result)\n-        result = fold_binary_loc (loc, subcode,\n-\t\t\t\t  TREE_TYPE (gimple_assign_lhs (stmt)),\n-\t\t\t\t  gimple_assign_rhs1 (stmt),\n-\t\t\t\t  gimple_assign_rhs2 (stmt));\n-\n-      if (result)\n-        {\n-          STRIP_USELESS_TYPE_CONVERSION (result);\n-          if (valid_gimple_rhs_p (result))\n-\t    return result;\n-        }\n       break;\n \n     case GIMPLE_TERNARY_RHS:\n@@ -3653,23 +3613,51 @@ fold_stmt_1 (gimple_stmt_iterator *gsi, bool inplace, tree (*valueize) (tree))\n     {\n     case GIMPLE_ASSIGN:\n       {\n-\tunsigned old_num_ops = gimple_num_ops (stmt);\n-\tenum tree_code subcode = gimple_assign_rhs_code (stmt);\n-\ttree lhs = gimple_assign_lhs (stmt);\n-\ttree new_rhs;\n-\t/* First canonicalize operand order.  This avoids building new\n-\t   trees if this is the only thing fold would later do.  */\n-\tif ((commutative_tree_code (subcode)\n-\t     || commutative_ternary_tree_code (subcode))\n-\t    && tree_swap_operands_p (gimple_assign_rhs1 (stmt),\n-\t\t\t\t     gimple_assign_rhs2 (stmt), false))\n+\t/* Try to canonicalize for boolean-typed X the comparisons\n+\t   X == 0, X == 1, X != 0, and X != 1.  */\n+\tif (gimple_assign_rhs_code (stmt) == EQ_EXPR\n+\t    || gimple_assign_rhs_code (stmt) == NE_EXPR)\n \t  {\n-\t    tree tem = gimple_assign_rhs1 (stmt);\n-\t    gimple_assign_set_rhs1 (stmt, gimple_assign_rhs2 (stmt));\n-\t    gimple_assign_set_rhs2 (stmt, tem);\n-\t    changed = true;\n+\t    tree lhs = gimple_assign_lhs (stmt);\n+\t    tree op1 = gimple_assign_rhs1 (stmt);\n+\t    tree op2 = gimple_assign_rhs2 (stmt);\n+\t    tree type = TREE_TYPE (op1);\n+\n+\t    /* Check whether the comparison operands are of the same boolean\n+\t       type as the result type is.\n+\t       Check that second operand is an integer-constant with value\n+\t       one or zero.  */\n+\t    if (TREE_CODE (op2) == INTEGER_CST\n+\t\t&& (integer_zerop (op2) || integer_onep (op2))\n+\t\t&& useless_type_conversion_p (TREE_TYPE (lhs), type))\n+\t      {\n+\t\tenum tree_code cmp_code = gimple_assign_rhs_code (stmt);\n+\t\tbool is_logical_not = false;\n+\n+\t\t/* X == 0 and X != 1 is a logical-not.of X\n+\t\t   X == 1 and X != 0 is X  */\n+\t\tif ((cmp_code == EQ_EXPR && integer_zerop (op2))\n+\t\t    || (cmp_code == NE_EXPR && integer_onep (op2)))\n+\t\t  is_logical_not = true;\n+\n+\t\tif (is_logical_not == false)\n+\t\t  gimple_assign_set_rhs_with_ops (gsi, TREE_CODE (op1), op1);\n+\t\t/* Only for one-bit precision typed X the transformation\n+\t\t   !X -> ~X is valied.  */\n+\t\telse if (TYPE_PRECISION (type) == 1)\n+\t\t  gimple_assign_set_rhs_with_ops (gsi, BIT_NOT_EXPR, op1);\n+\t\t/* Otherwise we use !X -> X ^ 1.  */\n+\t\telse\n+\t\t  gimple_assign_set_rhs_with_ops (gsi, BIT_XOR_EXPR, op1,\n+\t\t\t\t\t\t  build_int_cst (type, 1));\n+\t\tchanged = true;\n+\t\tbreak;\n+\t      }\n \t  }\n-\tnew_rhs = fold_gimple_assign (gsi);\n+\n+\tunsigned old_num_ops = gimple_num_ops (stmt);\n+\ttree lhs = gimple_assign_lhs (stmt);\n+\ttree new_rhs = fold_gimple_assign (gsi);\n \tif (new_rhs\n \t    && !useless_type_conversion_p (TREE_TYPE (lhs),\n \t\t\t\t\t   TREE_TYPE (new_rhs)))"}]}