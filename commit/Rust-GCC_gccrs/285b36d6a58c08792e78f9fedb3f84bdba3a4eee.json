{"sha": "285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjg1YjM2ZDZhNThjMDg3OTJlNzhmOWZlZGIzZjg0YmRiYTNhNGVlZQ==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-11-11T20:09:16Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2003-11-11T20:09:16Z"}, "message": "[multiple changes]\n\n\n2003-11-11  Doug Gregor  <gregod@cs.rpi.edu>\n\n\t* docs/html/debug.html: Document libstdc++ debug mode.\n\t* docs/html/debug_mode.html: Document libstdc++ debug mode design.\n\t* docs/html/test.html: Document how to test under debug mode.\n\t* docs/html/17_intro/howto.html: Document debug-mode macros.\n\t* include/Makefile.am: Install debug-mode headers.\n\t* src/Makefile.am: Include debug.cc.\n\t* include/bits/basic_string.tcc:\n\t  (basic_string::_S_construct): Fix NULL pointer check.\n\t  (__is_null_pointer): New.\n\t  Add precondition annotations.\n\t* include/bits/stream_iterator.h (istream_iterator,\n\tostream_iterator): Added precondition annotations.\n\t* include/bits/streambuf_iterator.h (istreambuf_iterator): Ditto.\n\t* include/bits/stl_queue.h (queue, priority_queue): Ditto.\n\t* include/bits/stl_stack.h (stack): Ditto.\n\t* include/bits/basic_string.h (basic_string): Ditto.\n\t* include/bits/basic_string.tcc (basic_string): Ditto.\n\t* include/std/std_memory.h (auto_ptr): Ditto.\n\t* include/std/std_valarray.h (valarray): Ditto.\n\t* include/bits/stl_algo.h: Added algorithm precondition\n\tannotations.\n\t* include/bits/stl_algobase.h: Added algorithm precondition\n\tannotations.\n\t* include/bits/stl_numeric.h: Ditto.\n\t* include/ext/algorithm: Added algorithm precondition\n\tannotations.\n\t(__is_heap): Moved away from here.\n\t* include/bits/stl_heap.h: Added algorithm precondition\n\tannotations.\n\t(__is_heap): Moved to the top of this file.\n\t(__is_heap): Added iterator range overloads.\n\t* testsuite/20_util/auto_ptr_neg.cc: Fix line numbers to match up\n\twith changes in std_memory.h.\n\t* testsuite/23_containers/list/operators/4.cc: Don't verify\n\tperformance guarantees when in debug mode.\n\t* testsuite/23_containers/bitset/invalidation/1.cc: New.\n\t* testsuite/23_containers/deque/invalidation/1.cc: New.\n\t* testsuite/23_containers/deque/invalidation/2.cc: New.\n\t* testsuite/23_containers/deque/invalidation/3.cc: New.\n\t* testsuite/23_containers/deque/invalidation/4.cc: New.\n\t* testsuite/23_containers/list/invalidation/1.cc: New.\n\t* testsuite/23_containers/list/invalidation/2.cc: New.\n\t* testsuite/23_containers/list/invalidation/3.cc: New.\n\t* testsuite/23_containers/list/invalidation/4.cc: New.\n\t* testsuite/23_containers/map/invalidation/1.cc: New.\n\t* testsuite/23_containers/map/invalidation/2.cc: New.\n\t* testsuite/23_containers/multimap/invalidation/1.cc: New.\n\t* testsuite/23_containers/multimap/invalidation/2.cc: New.\n\t* testsuite/23_containers/multiset/invalidation/1.cc: New.\n\t* testsuite/23_containers/multiset/invalidation/2.cc: New.\n\t* testsuite/23_containers/set/invalidation/1.cc: New.\n\t* testsuite/23_containers/set/invalidation/2.cc: New.\n\t* testsuite/23_containers/vector/invalidation/1.cc: New.\n\t* testsuite/23_containers/vector/invalidation/2.cc: New.\n\t* testsuite/23_containers/vector/invalidation/3.cc: New.\n\t* testsuite/23_containers/vector/invalidation/4.cc: New.\n\t* testsuite/25_algorithms/heap.cc: Don't verify\n\tperformance guarantees when in debug mode.\n\t* include/debug/bitset: New.\n\t* include/debug/debug.h: New.\n\t* include/debug/deque: New.\n\t* include/debug/formatter.h: New.\n\t* include/debug/hash_map: New.\n\t* include/debug/hash_map.h: New.\n\t* include/debug/hash_multimap.h: New.\n\t* include/debug/hash_set: New.\n\t* include/debug/hash_set.h: New.\n\t* include/debug/hash_multiset.h: New.\n\t* include/debug/list: New.\n\t* include/debug/map: New.\n\t* include/debug/map.h: New.\n\t* include/debug/multimap.h: New.\n\t* include/debug/multiset.h: New.\n\t* include/debug/safe_base.h: New.\n\t* include/debug/safe_iterator.h: New.\n\t* include/debug/safe_iterator.tcc: New.\n\t* include/debug/safe_sequence.h: New.\n\t* include/debug/set: New.\n\t* include/debug/set.h: New.\n\t* include/debug/string: New.\n\t* include/debug/vector: New.\n\t* src/debug.cc: New.\n\t* config/linker-map.gnu: Add debug mode symbols.\n\n2003-11-11  Benjamin Kosnik  <bkoz@redhat.com>\n\n\t* src/string-inst.cc: Tweak namespaces.\n\t* src/misc-inst.cc: Same.\n\t* docs/html/debug.html: Edits.\n\t* config/link-map.gnu: Remove cruft.\n\n\t* include/bits/c++config: Add in namespace associations.\n\t* include/std/std_bitset.h: Adjust namespace to __gnu_norm,\n\tcomment tweaks.\n\t* include/bits/deque.tcc: Same.\n\t* include/bits/list.tcc: Same.\n\t* include/bits/stl_bvector.h: Same.\n\t* include/bits/stl_deque.h: Same.\n\t* include/bits/stl_list.h: Same.\n\t* include/bits/stl_map.h: Same.\n\t* include/bits/stl_multimap.h: Same.\n\t* include/bits/stl_multiset.h: Same.\n\t* include/bits/stl_set.h: Same.\n\t* include/bits/stl_vector.h: Same.\n\t* include/bits/vector.tcc: Same.\n\n\t* include/std/std_algorithm.h: Remove markup comments.\n\t* include/std/std_functional.h: Same.\n\t* include/std/std_iterator.h: Same.\n\t* include/std/std_numeric.h: Same.\n\t* include/std/std_utility.h: Same.\n\t* include/bits/stl_queue.h: Formatting tweaks.\n\t* include/bits/stl_stack.h: Same.\n\t* include/std/std_deque.h: Include debugging version in debug mode.\n\t* include/std/std_list.h: Same.\n\t* include/std/std_map.h: Same.\n\t* include/std/std_set.h: Same.\n\t* include/std/std_vector.h: Same.\n\t* include/std/std_queue.h: Use deque, vector.\n\t* include/std/std_stack.h: Same.\n\nFrom-SVN: r73459", "tree": {"sha": "48d847b6238daa37c4ad869a73f671de6a44761f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/48d847b6238daa37c4ad869a73f671de6a44761f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/comments", "author": null, "committer": null, "parents": [{"sha": "0259239a6a85697ad66b00367243b09249315080", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0259239a6a85697ad66b00367243b09249315080", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0259239a6a85697ad66b00367243b09249315080"}], "stats": {"total": 12155, "additions": 11304, "deletions": 851}, "files": [{"sha": "1df66abe038bf51f3145d949aea226e85d85fa3b", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 123, "deletions": 0, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -1,3 +1,126 @@\n+2003-11-11  Doug Gregor  <gregod@cs.rpi.edu>\n+\n+\t* docs/html/debug.html: Document libstdc++ debug mode.\n+\t* docs/html/debug_mode.html: Document libstdc++ debug mode design.\n+\t* docs/html/test.html: Document how to test under debug mode.\n+\t* docs/html/17_intro/howto.html: Document debug-mode macros.\n+\t* include/Makefile.am: Install debug-mode headers.\n+\t* src/Makefile.am: Include debug.cc.\n+\t* include/bits/basic_string.tcc: \n+\t  (basic_string::_S_construct): Fix NULL pointer check.\n+\t  (__is_null_pointer): New.\n+\t  Add precondition annotations.\n+\t* include/bits/stream_iterator.h (istream_iterator,\n+\tostream_iterator): Added precondition annotations.\n+\t* include/bits/streambuf_iterator.h (istreambuf_iterator): Ditto.\n+\t* include/bits/stl_queue.h (queue, priority_queue): Ditto.\n+\t* include/bits/stl_stack.h (stack): Ditto.\n+\t* include/bits/basic_string.h (basic_string): Ditto.\n+\t* include/bits/basic_string.tcc (basic_string): Ditto.\n+\t* include/std/std_memory.h (auto_ptr): Ditto.\n+\t* include/std/std_valarray.h (valarray): Ditto.\n+\t* include/bits/stl_algo.h: Added algorithm precondition\n+\tannotations.\n+\t* include/bits/stl_algobase.h: Added algorithm precondition\n+\tannotations.\n+\t* include/bits/stl_numeric.h: Ditto.\n+\t* include/ext/algorithm: Added algorithm precondition\n+\tannotations. \n+\t(__is_heap): Moved away from here.\n+\t* include/bits/stl_heap.h: Added algorithm precondition\n+\tannotations. \n+\t(__is_heap): Moved to the top of this file.\n+\t(__is_heap): Added iterator range overloads.\n+\t* testsuite/20_util/auto_ptr_neg.cc: Fix line numbers to match up\n+\twith changes in std_memory.h.\n+\t* testsuite/23_containers/list/operators/4.cc: Don't verify\n+\tperformance guarantees when in debug mode.\n+\t* testsuite/23_containers/bitset/invalidation/1.cc: New.\n+\t* testsuite/23_containers/deque/invalidation/1.cc: New.\n+\t* testsuite/23_containers/deque/invalidation/2.cc: New.\n+\t* testsuite/23_containers/deque/invalidation/3.cc: New.\n+\t* testsuite/23_containers/deque/invalidation/4.cc: New.\n+\t* testsuite/23_containers/list/invalidation/1.cc: New.\n+\t* testsuite/23_containers/list/invalidation/2.cc: New.\n+\t* testsuite/23_containers/list/invalidation/3.cc: New.\n+\t* testsuite/23_containers/list/invalidation/4.cc: New.\n+\t* testsuite/23_containers/map/invalidation/1.cc: New.\n+\t* testsuite/23_containers/map/invalidation/2.cc: New.\n+\t* testsuite/23_containers/multimap/invalidation/1.cc: New.\n+\t* testsuite/23_containers/multimap/invalidation/2.cc: New.\n+\t* testsuite/23_containers/multiset/invalidation/1.cc: New.\n+\t* testsuite/23_containers/multiset/invalidation/2.cc: New.\n+\t* testsuite/23_containers/set/invalidation/1.cc: New.\n+\t* testsuite/23_containers/set/invalidation/2.cc: New.\n+\t* testsuite/23_containers/vector/invalidation/1.cc: New.\n+\t* testsuite/23_containers/vector/invalidation/2.cc: New.\n+\t* testsuite/23_containers/vector/invalidation/3.cc: New.\n+\t* testsuite/23_containers/vector/invalidation/4.cc: New.\n+\t* testsuite/25_algorithms/heap.cc: Don't verify\n+\tperformance guarantees when in debug mode.\n+\t* include/debug/bitset: New.\n+\t* include/debug/debug.h: New.\n+\t* include/debug/deque: New.\n+\t* include/debug/formatter.h: New.\n+\t* include/debug/hash_map: New.\n+\t* include/debug/hash_map.h: New.\t\n+\t* include/debug/hash_multimap.h: New.\n+\t* include/debug/hash_set: New.\n+\t* include/debug/hash_set.h: New.\n+\t* include/debug/hash_multiset.h: New.\t\n+\t* include/debug/list: New.\n+\t* include/debug/map: New.\n+\t* include/debug/map.h: New.\n+\t* include/debug/multimap.h: New.\n+\t* include/debug/multiset.h: New.\t\n+\t* include/debug/safe_base.h: New.\n+\t* include/debug/safe_iterator.h: New.\n+\t* include/debug/safe_iterator.tcc: New.\n+\t* include/debug/safe_sequence.h: New.\n+\t* include/debug/set: New.\n+\t* include/debug/set.h: New.\t\n+\t* include/debug/string: New.\n+\t* include/debug/vector: New.\n+\t* src/debug.cc: New.\n+\t* config/linker-map.gnu: Add debug mode symbols.\n+\t\n+2003-11-11  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\t* src/string-inst.cc: Tweak namespaces.\n+\t* src/misc-inst.cc: Same.\n+\t* docs/html/debug.html: Edits.\n+\t* config/link-map.gnu: Remove cruft.\n+\n+\t* include/bits/c++config: Add in namespace associations.\n+\t* include/std/std_bitset.h: Adjust namespace to __gnu_norm,\n+\tcomment tweaks.\n+\t* include/bits/deque.tcc: Same.\n+\t* include/bits/list.tcc: Same.\n+\t* include/bits/stl_bvector.h: Same.\n+\t* include/bits/stl_deque.h: Same.\n+\t* include/bits/stl_list.h: Same.\n+\t* include/bits/stl_map.h: Same.\n+\t* include/bits/stl_multimap.h: Same.\n+\t* include/bits/stl_multiset.h: Same.\n+\t* include/bits/stl_set.h: Same.\n+\t* include/bits/stl_vector.h: Same.\n+\t* include/bits/vector.tcc: Same.\n+\n+\t* include/std/std_algorithm.h: Remove markup comments.\n+\t* include/std/std_functional.h: Same.\n+\t* include/std/std_iterator.h: Same.\n+\t* include/std/std_numeric.h: Same.\n+\t* include/std/std_utility.h: Same.\n+\t* include/bits/stl_queue.h: Formatting tweaks.\n+\t* include/bits/stl_stack.h: Same.\n+\t* include/std/std_deque.h: Include debugging version in debug mode.\n+\t* include/std/std_list.h: Same.\n+\t* include/std/std_map.h: Same.\n+\t* include/std/std_set.h: Same.\n+\t* include/std/std_vector.h: Same.\t\n+\t* include/std/std_queue.h: Use deque, vector.\n+\t* include/std/std_stack.h: Same.\n+\n 2003-11-09  Paolo Carlini  <pcarlini@suse.de>\n \n \t* include/bits/locale_facets.tcc (_M_insert_int,"}, {"sha": "671e42148ee86ae73acc2a648fad12ee3027ff13", "filename": "libstdc++-v3/config/linker-map.gnu", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flinker-map.gnu?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -57,7 +57,11 @@ GLIBCXX_3.4 {\n       std::__num_base::_S_atoms_out;\n       std::__moneypunct_cache*;\n       std::__numpunct_cache*;\n-      std::__timepunct_cache*\n+      std::__timepunct_cache*;\n+      __gnu_norm::*;\n+      __gnu_debug::_Safe_iterator_base*;\n+      __gnu_debug::_Safe_sequence_base*;\n+      __gnu_debug::_Error_formatter*\n     };\n \n     # Names not in an 'extern' block are mangled names.\n@@ -88,7 +92,7 @@ GLIBCXX_3.4 {\n     # std::locale::facet destructors\n     _ZNSt6locale5facetD*;\n \t \n-    # std::locale::_Impl constructors, destrutors\n+    # std::locale::_Impl constructors, destructors\n     _ZNSt6locale5_ImplC*;\n     _ZNSt6locale5_ImplD*;\n \n@@ -104,9 +108,6 @@ GLIBCXX_3.4 {\n     _ZSt21_Rb_tree_rotate_rightPSt18_Rb_tree_node_baseRS0_;\n     _ZSt28_Rb_tree_rebalance_for_erasePSt18_Rb_tree_node_baseRS_;\n \n-    # std::__ctype_abstract_base*\n-    _ZNSt21__ctype_abstract_base*;\n-\n     # std::__codecvt_abstract_base*\n     _ZNStSt23__codecvt_abstract_base*;\n "}, {"sha": "29d0db78f969fd151d127241cb3424f8dd5c241e", "filename": "libstdc++-v3/docs/html/17_intro/howto.html", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2F17_intro%2Fhowto.html?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -339,6 +339,18 @@ <h2><a name=\"6\">Preprocessor macros controlling the library</a></h2>\n         violations of the requirements of the standard.  This is described\n         in more detail <a href=\"../19_diagnostics/howto.html#3\">here</a>.\n     </dd>\n+    <dt><code>_GLIBCXX_DEBUG</code></dt>\n+    <dd>Undefined by default. Configurable. When defined, compiles\n+    user code using the <a href=\"../debug.html#safe\">libstdc++ debug\n+    mode</a>.\n+    </dd>\n+    <dt><code>_GLIBCXX_DEBUG_PEDANTIC</code></dt>\n+    <dd>Undefined by default. Configurable. When defined while\n+    compiling with the <a href=\"../debug.html#safe\">libstdc++ debug\n+    mode</a>, makes the debug mode extremely picky by making the use\n+    of libstdc++ extensions and libstdc++-specific behavior into\n+    errors.\n+    </dd>\n     <!--\n     <dt><code></code></dt>\n     <dd>"}, {"sha": "be4a8614b0d485e498808d8c43950d0e4d48d290", "filename": "libstdc++-v3/docs/html/debug.html", "status": "modified", "additions": 251, "deletions": 33, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug.html?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -29,9 +29,8 @@ <h1 class=\"centered\"><a name=\"top\">Debugging schemes and strategies</a></h1>\n <!-- ####################################################### -->\n <hr />\n <p>There are numerous things that can be done to improve the ease with\n-   which C++ binaries are debugged when using the GNU C++\n-   tool chain. Here are some things to keep in mind when debugging C++\n-   code with GNU tools.\n+   which C++ binaries are debugged when using the GNU \n+   tool chain. Here are some of them.\n </p>\n \n <h3 class=\"left\"><a name=\"gplusplus\">Compiler flags determine debug info</a></h3>\n@@ -40,44 +39,35 @@ <h3 class=\"left\"><a name=\"gplusplus\">Compiler flags determine debug info</a></h3\n    be varied to change debugging characteristics. For instance,\n    turning off all optimization via the <code>-g -O0</code> flag will\n    disable inlining, so that stepping through all functions, including\n-   inlined constructors and destructors, is possible. Or, the debug\n-   format that the compiler and debugger use to communicate\n+   inlined constructors and destructors, is possible. In addition,\n+   <code>-fno-eliminate-unused-debug-types<code> can be used when\n+   additional debug information, such as nested class info, is desired.\n+</p>\n+\n+<p>Or, the debug format that the compiler and debugger use to communicate\n    information about source constructs can be changed via <code>\n    -gdwarf-2 </code> or <code> -gstabs </code> flags: some debugging\n    formats permit more expressive type and scope information to be\n-   shown in gdb.\n-   The default debug information for a particular platform can be\n-   identified via the value set by the PREFERRED_DEBUGGING_TYPE macro\n-   in the gcc sources.\n+   shown in gdb.  The default debug information for a particular\n+   platform can be identified via the value set by the\n+   PREFERRED_DEBUGGING_TYPE macro in the gcc sources.\n </p>\n \n <p>Many other options are available: please see\n <a href=\"http://gcc.gnu.org/onlinedocs/gcc/Debugging-Options.html#Debugging%20Options\">\"Options for Debugging Your Program\"</a>\n    in Using the GNU Compiler Collection (GCC) for a complete list.\n </p>\n \n-\n <h3 class=\"left\"><a name=\"lib\">Using special flags to make a debug binary</a></h3>\n-<p>There are two ways to build libstdc++ with debug flags. The first\n-   is to run make from the toplevel in a freshly-configured tree with\n-   specialized debug <code>CXXFLAGS</code>, as in\n-</p>\n-<pre>\n-     make CXXFLAGS='-g3 -O0' all\n-</pre>\n-\n-<p>This quick and dirty approach is often sufficient for quick\n-   debugging tasks, but the lack of state can be confusing in the long\n-   term.\n-</p>\n-<p>A second approach is to use the configuration flags \n-</p>\n+<p>If you would like debug symbols in libstdc++, there are two ways to\n+  build libstdc++ with debug flags. The first is to run make from the\n+  toplevel in a freshly-configured tree with\n <pre>\n-     --enable-debug\n+     --enable-libstdcxx-debug\n </pre>\n <p>and perhaps</p>\n <pre>\n-     --enable-debug-flags='...'\n+     --enable-libstdcxx-debug-flags='...'\n </pre>\n <p>to create a separate debug build. Both the normal build and the\n    debug build will persist, without having to specify\n@@ -87,16 +77,243 @@ <h3 class=\"left\"><a name=\"lib\">Using special flags to make a debug binary</a></h\n    options</a> document.\n </p>\n \n+<p>A second approach is to use the configuration flags \n+</p>\n+<pre>\n+     make CXXFLAGS='-g3 -O0' all\n+</pre>\n+\n+<p>This quick and dirty approach is often sufficient for quick\n+  debugging tasks, when you cannot or don't want to recompile your\n+  application to use the <a href=\"#safe\">debug mode</a>.</p>\n+\n+<h3 class=\"left\"><a name=\"safe\">The libstdc++ debug mode</a></h3>\n+<p>By default, libstdc++ is built with efficiency in mind, and\n+  therefore performs little or no error checking that is not required\n+  by the C++ standard. This means that programs that incorrectly use\n+  the C++ standard library will exhibit behavior that is not portable\n+  and may not even be predictable, because they tread into \n+  implementation-specific or undefined behavior. To detect some of\n+  these errors before they can become problematic, libstdc++ offers a\n+  debug mode that provides additional checking of library facilities,\n+  and will report errors in the use of libstdc++ as soon as they can\n+  be detected by emitting a description of the problem to standard\n+  error and aborting the program. </p>\n+\n+<p>The libstdc++ debug mode performs checking for many areas of the C++\n+  standard, but the focus is on checking interactions among standard\n+  iterators, containers, and algorithms, including:</p>\n+\n+  <ul>\n+    <li><em>Safe iterators</em>: Iterators keep track of the\n+    container whose elements they reference, so errors such as\n+    incrementing a past-the-end iterator or dereferencing an iterator\n+    that points to a container that has been destructed are diagnosed\n+    immediately.</li>\n+    \n+    <li><em>Algorithm preconditions</em>: Algorithms attempt to\n+    validate their input parameters to detect errors as early as\n+    possible. For instance, the <code>set_intersection</code>\n+    algorithm requires that its iterator\n+    parameters <code>first1</code> and <code>last1</code> form a valid\n+    iterator range, and that the sequence\n+    [<code>first1</code>, <code>last1</code>) is sorted according to\n+    the same predicate that was passed\n+    to <code>set_intersection</code>; the libstdc++ debug mode will\n+    detect an error if the sequence is not sorted or was sorted by a\n+    different predicate.</li>\n+  </ul>\n+\n+<h4 class=\"left\">Using the libstdc++ debug mode</h4>\n+<p>To use the libstdc++ debug mode, compile your application with the\n+  compiler flag <code>-D_GLIBCXX_DEBUG</code>. Note that this flag\n+  changes the sizes and behavior of standard class templates such\n+  as <code>std::vector</code>, and therefore you can only link code\n+  compiled with debug mode and code compiled without debug mode if no\n+  instantiation of a container is passed between the two translation\n+  units.</p>\n+\n+<p>For information about the design of the libstdc++ debug mode,\n+  please see the <a href=\"debug_mode.html\">libstdc++ debug mode design\n+  document</a>.</p>\n+\n+<h4 class=\"left\">Using the debugging containers without debug\n+  mode</h4>\n+<p>When it is not feasible to recompile your entire application, or\n+  only specific containers need checking, debugging containers are\n+  available as GNU extensions. These debugging containers are\n+  functionally equivalent to the standard drop-in containers used in\n+  debug mode, but they are available in a separate namespace as GNU\n+  extensions and may be used in programs compiled with either release\n+  mode or with debug mode. However, unlike the containers in namespace\n+  <code>std</code>, these containers may not be specialized. The\n+  following table provides the names and headers of the debugging\n+  containers:\n+\n+<table title=\"Debugging containers\" border=\"1\">\n+  <tr>\n+    <th>Container</th>\n+    <th>Header</th>\n+    <th>Debug container</th>\n+    <th>Debug header</th>\n+  </tr>\n+  <tr>\n+    <td>std::bitset</td>\n+    <td>&lt;bitset&gt;</td>\n+    <td>__gnu_debug::bitset</td>\n+    <td>&lt;debug/bitset&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::deque</td>\n+    <td>&lt;deque&gt;</td>\n+    <td>__gnu_debug::deque</td>\n+    <td>&lt;debug/deque&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::list</td>\n+    <td>&lt;list&gt;</td>\n+    <td>__gnu_debug::list</td>\n+    <td>&lt;debug/list&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::map</td>\n+    <td>&lt;map&gt;</td>\n+    <td>__gnu_debug::map</td>\n+    <td>&lt;debug/map&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::multimap</td>\n+    <td>&lt;map&gt;</td>\n+    <td>__gnu_debug::multimap</td>\n+    <td>&lt;debug/map&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::multiset</td>\n+    <td>&lt;set&gt;</td>\n+    <td>__gnu_debug::multiset</td>\n+    <td>&lt;debug/set&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::set</td>\n+    <td>&lt;set&gt;</td>\n+    <td>__gnu_debug::set</td>\n+    <td>&lt;debug/set&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::string</td>\n+    <td>&lt;string&gt;</td>\n+    <td>__gnu_debug::string</td>\n+    <td>&lt;debug/string&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::wstring</td>\n+    <td>&lt;string&gt;</td>\n+    <td>__gnu_debug::wstring</td>\n+    <td>&lt;debug/string&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::basic_string</td>\n+    <td>&lt;string&gt;</td>\n+    <td>__gnu_debug::basic_string</td>\n+    <td>&lt;debug/string&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>std::vector</td>\n+    <td>&lt;vector&gt;</td>\n+    <td>__gnu_debug::vector</td>\n+    <td>&lt;debug/vector&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>__gnu_cxx::hash_map</td>\n+    <td>&lt;ext/hash_map&gt;</td>\n+    <td>__gnu_debug::hash_map</td>\n+    <td>&lt;debug/hash_map&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>__gnu_cxx::hash_multimap</td>\n+    <td>&lt;ext/hash_map&gt;</td>\n+    <td>__gnu_debug::hash_multimap</td>\n+    <td>&lt;debug/hash_map&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>__gnu_cxx::hash_set</td>\n+    <td>&lt;ext/hash_set&gt;</td>\n+    <td>__gnu_debug::hash_set</td>\n+    <td>&lt;debug/hash_set&gt;</td>\n+  </tr>\n+  <tr>\n+    <td>__gnu_cxx::hash_multiset</td>\n+    <td>&lt;ext/hash_set&gt;</td>\n+    <td>__gnu_debug::hash_multiset</td>\n+    <td>&lt;debug/hash_set&gt;</td>\n+  </tr>\n+</table>\n+\n+<h4 class=\"left\">Debug mode semantics</h4>\n+<p>A program that does not use the C++ standard library incorrectly\n+  will maintain the same semantics under debug mode as it had with\n+  the normal (release) library. All functional and exception-handling\n+  guarantees made by the normal library also hold for the debug mode\n+  library, with one exception: performance guarantees made by the\n+  normal library may not hold in the debug mode library. For\n+  instance, erasing an element in a <code>std::list</code> is a\n+  constant-time operation in normal library, but in debug mode it is\n+  linear in the number of iterators that reference that particular\n+  list. So while your (correct) program won't change its results, it \n+  is likely to execute more slowly.</p>\n+\n+<p>libstdc++ includes many extensions to the C++ standard library. In\n+  some cases the extensions are obvious, such as the hashed\n+  associative containers, whereas other extensions give predictable\n+  results to behavior that would otherwise be undefined, such as\n+  throwing an exception when a <code>std::basic_string</code> is\n+  constructed from a NULL character pointer. This latter category also\n+  includes implementation-defined and unspecified semantics, such as\n+  the growth rate of a vector. Use of these extensions is not\n+  considered incorrect, so code that relies on them will not be\n+  rejected by debug mode. However, use of these extensions may affect\n+  the portability of code to other implementations of the C++ standard\n+  library, and is therefore somewhat hazardous. For this reason, the\n+  libstdc++ debug mode offers a \"pedantic\" mode (similar to\n+  GCC's <code>-pedantic</code> compiler flag) that attempts to emulate\n+  the semantics guaranteed by the C++ standard. In pedantic mode, for\n+  instance, constructing a <code>std::basic_string</code> with a NULL\n+  character pointer would result in an exception under normal mode or\n+  non-pedantic debug mode (this is a libstdc++ extension), whereas\n+  under pedantic debug mode libstdc++ would signal an error. To enable\n+  the pedantic debug mode, compile your program with\n+  both <code>-D_GLIBCXX_DEBUG</code>\n+  and <code>-D_GLIBCXX_DEBUG_PEDANTIC</code> .</p>\n+\n+<p>The following library components provide extra debugging\n+  capabilities in debug mode:</p>\n+<ul>\n+  <li><code>std::bitset</code></li>\n+  <li><code>std::deque</code></li>\n+  <li><code>__gnu_cxx::hash_map</code></li>\n+  <li><code>__gnu_cxx::hash_multimap</code></li>\n+  <li><code>__gnu_cxx::hash_multiset</code></li>\n+  <li><code>__gnu_cxx::hash_set</code></li>\n+  <li><code>std::list</code></li>\n+  <li><code>std::map</code></li>\n+  <li><code>std::multimap</code></li>\n+  <li><code>std::multiset</code></li>\n+  <li><code>std::set</code></li>\n+  <li><code>std::vector</code></li>\n+</ul>\n+\n \n <h3 class=\"left\"><a name=\"mem\">Tips for memory leak hunting</a></h3>\n \n <p>There are various third party memory tracing and debug utilities\n    that can be used to provide detailed memory allocation information\n    about C++ code. An exhaustive list of tools is not going to be\n    attempted, but includes <code>mtrace</code>, <code>valgrind</code>,\n-   <code>mudflap</code>, and <code>purify</code>. Also highly\n-   recommended are <code>libcwd</code> and some other one that I\n-   forget right now.\n+   <code>mudflap</code>, and the non-free commercial product\n+   <code>purify</code>. In addition, <code>libcwd</code> has a\n+   replacement for the global new and delete operators that can track\n+   memory allocation and deallocation and provide useful memory\n+   statistics.\n </p>\n \n <p>Regardless of the memory debugging tool being used, there is one\n@@ -110,9 +327,10 @@ <h3 class=\"left\"><a name=\"mem\">Tips for memory leak hunting</a></h3>\n \n <p>In a nutshell, the default allocator used by <code>\n    std::allocator</code> is a high-performance pool allocator, and can\n-   give the mistaken impression that memory is being leaked, when in\n-   reality the memory is still being used by the library and is reclaimed\n-   after program termination.\n+   give the mistaken impression that in a suspect executable, memory\n+   is being leaked, when in reality the memory \"leak\" is a pool being\n+   used by the library's allocator and is reclaimed after program\n+   termination.\n </p>\n \n <p>For valgrind, there are some specific items to keep in mind. First\n@@ -121,7 +339,7 @@ <h3 class=\"left\"><a name=\"mem\">Tips for memory leak hunting</a></h3>\n    versions should work at least as well. Second of all, use a\n    completely unoptimized build to avoid confusing valgrind. Third,\n    use GLIBCXX_FORCE_NEW to keep extraneous pool allocation noise from\n-   cluttering debug information. \n+   cluttering debug information.\n </p>\n \n <p>Fourth, it may be necessary to force deallocation in other"}, {"sha": "6ec7c4b3f14133fbccdd2b17f21299a3dab6807c", "filename": "libstdc++-v3/docs/html/debug_mode.html", "status": "added", "additions": 547, "deletions": 0, "changes": 547, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Fdebug_mode.html?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,547 @@\n+<?xml version=\"1.0\" encoding=\"ISO-8859-1\"?>\n+<!DOCTYPE html\n+          PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\"\n+          \"http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd\">\n+\n+<html xmlns=\"http://www.w3.org/1999/xhtml\" xml:lang=\"en\" lang=\"en\">\n+<head>\n+   <meta name=\"AUTHOR\" content=\"dgregor@apple.com (Doug Gregor)\" />\n+   <meta name=\"KEYWORDS\" content=\"libstdc++, libstdc++-v3, GCC, g++, debug\" />\n+   <meta name=\"DESCRIPTION\" content=\"Design of the libstdc++ debug mode.\" />\n+   <meta name=\"GENERATOR\" content=\"vi and eight fingers\" />\n+   <title>Design of the libstdc++ debug mode</title>\n+<link rel=\"StyleSheet\" href=\"lib3styles.css\" />\n+</head>\n+<body>\n+\n+<h1 class=\"centered\"><a name=\"top\">Design of the libstdc++ debug mode</a></h1>\n+\n+<p class=\"fineprint\"><em>\n+   The latest version of this document is always available at\n+   <a href=\"http://gcc.gnu.org/onlinedocs/libstdc++/debug_mode.html\">\n+   http://gcc.gnu.org/onlinedocs/libstdc++/debug_mode.html</a>.\n+</em></p>\n+\n+<p><em>\n+   To the <a href=\"http://gcc.gnu.org/libstdc++/\">libstdc++-v3 homepage</a>.\n+</em></p>\n+\n+\n+<!-- ####################################################### -->\n+\n+<hr />\n+<h1>Debug mode design</h1>\n+<p> The libstdc++ debug mode replaces unsafe (but efficient) standard\n+  containers and iterators with semantically equivalent safe standard\n+  containers and iterators to aid in debugging user programs. The\n+  following goals directed the design of the libstdc++ debug mode:</p>\n+\n+  <ul>\n+\n+    <li><b>Correctness</b>: the libstdc++ debug mode must not change\n+    the semantics of the standard library for all cases specified in\n+    the ANSI/ISO C++ standard. The essence of this constraint is that\n+    any valid C++ program should behave in the same manner regardless\n+    of whether it is compiled with debug mode or release mode. In\n+    particular, entities that are defined in namespace std in release\n+    mode should remain defined in namespace std in debug mode, so that\n+    legal specializations of namespace std entities will remain\n+    valid. A program that is not valid C++ (e.g., invokes undefined\n+    behavior) is not required to behave similarly, although the debug\n+    mode will abort with a diagnostic when it detects undefined\n+    behavior.</li>\n+\n+    <li><b>Performance</b>: the additional of the libstdc++ debug mode\n+    must not affect the performance of the library when it is compiled\n+    in release mode. Performance of the libstdc++ debug mode is\n+    secondary (and, in fact, will be worse than the release\n+    mode).</li>\n+\n+    <li><b>Usability</b>: the libstdc++ debug mode should be easy to\n+    use. It should be easily incorporated into the user's development\n+    environment (e.g., by requiring only a single new compiler switch)\n+    and should produce reasonable diagnostics when it detects a\n+    problem with the user program. Usability also involves detection\n+    of errors when using the debug mode incorrectly, e.g., by linking\n+    a release-compiled object against a debug-compiled object if in\n+    fact the resulting program will not run correctly.</li>\n+\n+    <li><b>Minimize recompilation</b>: While it is expected that\n+    users recompile at least part of their program to use debug\n+    mode, the amount of recompilation affects the\n+    detect-compile-debug turnaround time. This indirectly affects the\n+    usefulness of the debug mode, because debugging some applications\n+    may require rebuilding a large amount of code, which may not be\n+    feasible when the suspect code may be very localized. There are\n+    several levels of conformance to this requirement, each with its\n+    own usability and implementation characteristics. In general, the\n+    higher-numbered conformance levels are more usable (i.e., require\n+    less recompilation) but are more complicated to implement than\n+    the lower-numbered conformance levels. \n+      <ol>\n+\t<li><b>Full recompilation</b>: The user must recompile his or\n+\ther entire application and all C++ libraries it depends on,\n+\tincluding the C++ standard library that ships with the\n+\tcompiler. This must be done even if only a small part of the\n+\tprogram can use debugging features.</li>\n+\n+\t<li><b>Full user recompilation</b>: The user must recompile\n+\this or her entire application and all C++ libraries it depends\n+\ton, but not the C++ standard library itself. This must be done\n+\teven if only a small part of the program can use debugging\n+\tfeatures. This can be achieved given a full recompilation\n+\tsystem by compiling two versions of the standard library when\n+\tthe compiler is installed and linking against the appropriate\n+\tone, e.g., a multilibs approach.</li>\n+\n+\t<li><b>Partial recompilation</b>: The user must recompile the\n+\tparts of his or her application and the C++ libraries it\n+\tdepends on that will use the debugging facilities\n+\tdirectly. This means that any code that uses the debuggable\n+\tstandard containers would need to be recompiled, but code\n+\tthat does not use them (but may, for instance, use IOStreams)\n+\twould not have to be recompiled.</li>\n+\n+\t<li><b>Per-use recompilation</b>: The user must recompile the\n+\tparts of his or her application and the C++ libraries it\n+\tdepends on where debugging should occur, and any other code\n+\tthat interacts with those containers. This means that a set of\n+\ttranslation units that accesses a particular standard\n+\tcontainer instance may either be compiled in release mode (no\n+\tchecking) or debug mode (full checking), but must all be\n+\tcompiled in the same way; a translation unit that does not see\n+\tthat standard container instance need not be recompiled. This\n+\talso means that a translation unit <em>A</em> that contains a\n+\tparticular instantiation\n+\t(say, <code>std::vector&lt;int&gt;</code>) compiled in release\n+\tmode can be linked against a translation unit <em>B</em> that\n+\tcontains the same instantiation compiled in debug mode (a\n+\tfeature not present with partial recompilation). While this\n+\tbehavior is technically a violation of the One Definition\n+\tRule, this ability tends to be very important in\n+\tpractice. The libstdc++ debug mode supports this level of\n+\trecompilation. </li>\n+\n+\t<li><b>Per-unit recompilation</b>: The user must only\n+\trecompile the translation units where checking should occur,\n+\tregardless of where debuggable standard containers are\n+\tused. This has also been dubbed \"<code>-g</code> mode\",\n+\tbecause the <code>-g</code> compiler switch works in this way,\n+\temitting debugging information at a per--translation-unit\n+\tgranularity. We believe that this level of recompilation is in\n+\tfact not possible if we intend to supply safe iterators, leave\n+\tthe program semantics unchanged, and not regress in\n+\tperformance under release mode because we cannot associate\n+\textra information with an iterator (to form a safe iterator)\n+\twithout either reserving that space in release mode\n+\t(performance regression) or allocating extra memory associated\n+\twith each iterator with <code>new</code> (changes the program\n+\tsemantics).</li>\n+      </ol>\n+    </li>\n+  </ul>\n+\n+<h2><a name=\"other\">Other implementations</a></h2>\n+<p> There are several existing implementations of debug modes for C++\n+  standard library implementations, although none of them directly\n+  supports debugging for programs using libstdc++. The existing\n+  implementations include:</p>\n+<ul>\n+  <li><a\n+  href=\"http://www.mathcs.sjsu.edu/faculty/horstman/safestl.html\">SafeSTL</a>:\n+  SafeSTL was the original debugging version of the Standard Template\n+  Library (STL), implemented by Cay S. Horstmann on top of the\n+  Hewlett-Packard STL. Though it inspired much work in this area, it\n+  has not been kept up-to-date for use with modern compilers or C++\n+  standard library implementations.</li>\n+\n+  <li><a href=\"http://www.stlport.org/\">STLport</a>: STLport is a free\n+  implementation of the C++ standard library derived from the <a\n+  href=\"http://www.sgi.com/tech/stl/\">SGI implementation</a>, and\n+  ported to many other platforms. It includes a debug mode that uses a\n+  wrapper model (that in some way inspired the libstdc++ debug mode\n+  design), although at the time of this writing the debug mode is\n+  somewhat incomplete and meets only the \"Full user recompilation\" (2)\n+  recompilation guarantee by requiring the user to link against a\n+  different library in debug mode vs. release mode.</li>\n+\n+  <li><a href=\"http://www.metrowerks.com/mw/default.htm\">Metrowerks\n+  CodeWarrior</a>: The C++ standard library that ships with Metrowerks\n+  CodeWarrior includes a debug mode. It is a full debug-mode\n+  implementation (including debugging for CodeWarrior extensions) and\n+  is easy to use, although it meets only the \"Full recompilation\" (1)\n+  recompilation guarantee.</li>\n+</ul>\n+\n+<h2><a name=\"design\">Debug mode design methodology</a></h2>\n+<p>This section provides an overall view of the design of the\n+  libstdc++ debug mode and details the relationship between design\n+  decisions and the stated design goals.</p>\n+\n+<h3><a name=\"wrappers\">The wrapper model</a></h3>\n+<p>The libstdc++ debug mode uses a wrapper model where the debugging\n+  versions of library components (e.g., iterators and containers) form\n+  a layer on top of the release versions of the library\n+  components. The debugging components first verify that the operation\n+  is correct (aborting with a diagnostic if an error is found) and\n+  will then forward to the underlying release-mode container that will\n+  perform the actual work. This design decision ensures that we cannot\n+  regress release-mode performance (because the release-mode\n+  containers are left untouched) and partially enables <a\n+  href=\"#mixing\">mixing debug and release code</a> at link time,\n+  although that will not be discussed at this time.</p>\n+\n+<p>Two types of wrappers are used in the implementation of the debug\n+  mode: container wrappers and iterator wrappers. The two types of\n+  wrappers interact to maintain relationships between iterators and\n+  their associated containers, which are necessary to detect certain\n+  types of standard library usage errors such as dereferencing\n+  past-the-end iterators or inserting into a container using an\n+  iterator from a different container.</p>\n+\n+<h4><a name=\"safe_iterator\">Safe iterators</a></h4>\n+<p>Iterator wrappers provide a debugging layer over any iterator that\n+  is attached to a particular container, and will manage the\n+  information detailing the iterator's state (singular,\n+  dereferenceable, etc.) and tracking the container to which the\n+  iterator is attached. Because iterators have a well-defined, common\n+  interface the iterator wrapper is implemented with the iterator\n+  adaptor class template <code>__gnu_debug::_Safe_iterator</code>,\n+  which takes two template parameters:</p>\n+\n+<ul>\n+  <li><code>Iterator</code>: The underlying iterator type, which must\n+    be either the <code>iterator</code> or <code>const_iterator</code>\n+    typedef from the sequence type this iterator can reference.</li>\n+  \n+  <li><code>Sequence</code>: The type of sequence that this iterator\n+  references. This sequence must be a safe sequence (discussed below)\n+  whose <code>iterator</code> or <code>const_iterator</code> typedef\n+  is the type of the safe iterator.</li>\n+</ul>\n+\n+<h4><a name=\"safe_sequence\">Safe sequences (containers)</a></h4>\n+<p>Container wrappers provide a debugging layer over a particular\n+  container type. Because containers vary greatly in the member\n+  functions they support and the semantics of those member functions\n+  (especially in the area of iterator invalidation), container\n+  wrappers are tailored to the container they reference, e.g., the\n+  debugging version of <code>std::list</code> duplicates the entire\n+  interface of <code>std::list</code>, adding additional semantic\n+  checks and then forwarding operations to the\n+  real <code>std::list</code> (a public base class of the debugging\n+  version) as appropriate. However, all safe containers inherit from\n+  the class template <code>__gnu_debug::_Safe_sequence</code>,\n+  instantiated with the type of the safe container itself (an instance\n+  of the curiously recurring template pattern).</p>\n+\n+<p>The iterators of a container wrapper will be \n+  <a href=\"#safe_iterator\">safe iterators</a> that reference sequences\n+  of this type and wrap the iterators provided by the release-mode\n+  base class. The debugging container will use only the safe\n+  iterators within its own interface (therefore requiring the user to\n+  use safe iterators, although this does not change correct user\n+  code) and will communicate with the release-mode base class with\n+  only the underlying, unsafe, release-mode iterators that the base\n+  class exports.</p>\n+\n+<p> The debugging version of <code>std::list</code> will have the\n+  following basic structure:</p>\n+\n+<pre>\n+template&lt;typename _Tp, typename _Allocator = std::allocator&lt;_Tp&gt;\n+  class debug-list :\n+    public release-list&lt;_Tp, _Allocator&gt;,\n+    public __gnu_debug::_Safe_sequence&lt;debug-list&lt;_Tp, _Allocator&gt; &gt;\n+  {\n+    typedef release-list&lt;_Tp, _Allocator&gt; _Base;\n+    typedef debug-list&lt;_Tp, _Allocator&gt;   _Self;\n+\n+  public:\n+    typedef __gnu_debug::_Safe_iterator&lt;typename _Base::iterator, _Self&gt;       iterator;\n+    typedef __gnu_debug::_Safe_iterator&lt;typename _Base::const_iterator, _Self&gt; const_iterator;\n+\n+    // duplicate std::list interface with debugging semantics\n+  };\n+</pre>\n+\n+<h3><a name=\"precondition\">Precondition checking</a></h3>\n+<p>The debug mode operates primarily by checking the preconditions of\n+  all standard library operations that it supports. Preconditions that\n+  are always checked (regardless of whether or not we are in debug\n+  mode) are checked via the <code>__check_xxx</code> macros defined\n+  and documented in the source\n+  file <code>include/debug/debug.h</code>. Preconditions that may or\n+  may not be checked, depending on the debug-mode\n+  macro <code>_GLIBCXX_DEBUG</code>, are checked via\n+  the <code>__requires_xxx</code> macros defined and documented in the\n+  same source file. Preconditions are validated using any additional\n+  information available at run-time, e.g., the containers that are\n+  associated with a particular iterator, the position of the iterator\n+  within those containers, the distance between two iterators that may\n+  form a valid range, etc. In the absence of suitable information,\n+  e.g., an input iterator that is not a safe iterator, these\n+  precondition checks will silently succeed.</p>\n+\n+<p>The majority of precondition checks use the aforementioned macros,\n+  which have the secondary benefit of having prewritten debug\n+  messages that use information about the current status of the\n+  objects involved (e.g., whether an iterator is singular or what\n+  sequence it is attached to) along with some static information\n+  (e.g., the names of the function parameters corresponding to the\n+  objects involved). When not using these macros, the debug mode uses\n+  either the debug-mode assertion\n+  macro <code>_GLIBCXX_DEBUG_ASSERT</code> , its pedantic\n+  cousin <code>_GLIBCXX_DEBUG_PEDASSERT</code>, or the assertion\n+  check macro that supports more advance formulation of error\n+  messages, <code>_GLIBCXX_DEBUG_VERIFY</code>. These macros are\n+  documented more thoroughly in the debug mode source code.</p>\n+\n+<h3><a name=\"coexistence\">Release- and debug-mode coexistence</a></h3>\n+<p>The libstdc++ debug mode is the first debug mode we know of that\n+  is able to provide the \"Per-use recompilation\" (4) guarantee, that\n+  allows release-compiled and debug-compiled code to be linked and\n+  executed together without causing unpredictable behavior. This\n+  guarantee minimizes the recompilation that users are required to\n+  perform, shortening the detect-compile-debug bughunting cycle\n+  and making the debug mode easier to incorporate into development\n+  environments by minimizing dependencies.</p>\n+\n+<p>Achieving link- and run-time coexistence is not a trivial\n+  implementation task. To achieve this goal we required a small\n+  extension to the GNU C++ compiler (described in the section on\n+  <a href=\"#mixing\">link- and run-time coexistence</a>) and complex\n+  organization of debug- and release-modes. The end result is that we\n+  have achieved per-use recompilation but have had to give up some\n+  checking of the <code>std::basic_string</code> class template\n+  (namely, safe iterators).\n+\n+<h4><a name=\"compile_coexistence\">Compile-time coexistence of release- and\n+    debug-mode components</a></h4>\n+<p>Both the release-mode components and the debug-mode\n+  components need to exist within a single translation unit so that\n+  the debug versions can wrap the release versions. However, only one\n+  of these components should be user-visible at any particular\n+  time with the standard name, e.g., <code>std::list</code>. In\n+  release mode, we define only the release-mode version of the\n+  component with its standard name and do not include the debugging\n+  component at all (except, perhaps, in <code>__gnu_debug</code>, if\n+  requested via the separate debugging headers). This method leaves the\n+  behavior of release mode completely unchanged from its behavior\n+  prior to the introduction of the libstdc++ debug mode.</p>\n+\n+<p>In debug mode we include the release-mode container into its\n+  natural namespace but perform renaming to an implementation-defined\n+  name using preprocessor macros. Thus the\n+  release-mode <code>std::list</code> will be renamed\n+  to <code>std::_Release_list</code> during debug mode, and we will\n+  automatically include the debugging version with the\n+  name <code>std::list</code> for users to reference. This method\n+  allows the debug- and release-mode versions of the same component to\n+  coexist at compile-time without causing an unreasonable maintenance\n+  burden.</p>\n+\n+<h4><a name=\"mixing\">Link- and run-time coexistence of release- and\n+    debug-mode components</a></h4>\n+<p>There is a problem with the simple compile-time coexistence\n+  mechanism: if a user compiles some modules with release mode and\n+  some modules with debug mode, the debuggable components will differ\n+  in different translation units, violating the C++ One Definition\n+  Rule (ODR). This violation will likely be detected at link time,\n+  because the sizes of debug-mode containers will differ from the\n+  sizes of release-mode containers, although in some cases (such as\n+  dynamic linking) the error may be detected much later (or not at\n+  all!).</p>\n+\n+<p>Unfortunately, it is not possible to avoid violating the ODR with\n+  most debug mode designs (see the section on <a\n+  href=\"#coexistence_alt\">alternatives for coexistence</a>), so the\n+  philosophy of the libstdc++ debug mode is to acknowledge that there\n+  is an unavoidable ODR violation in this case but to ensure that the\n+  ODR violation does not affect execution. To accomplish this, the\n+  libstdc++ debug mode uses the aforementioned preprocessor renaming\n+  scheme but includes an additional renaming scheme that happens at\n+  compile-time that essentially reverses the preprocessor\n+  renaming <em>from the linker's point of view</em>. Thus, in debug\n+  mode, the release-mode <code>list</code> container is\n+  named <code>std::_Release_list</code> but will be mangled with the\n+  name <code>std::list</code> (as it was in release mode). Similarly,\n+  the debug-mode <code>list</code> is named <code>std::list</code>\n+  (in debug mode) but will be mangled\n+  as <code>std::_Debug_list</code>. Thus the\n+  release-mode <code>list</code> always compiles down to code that\n+  uses the name <code>std::list</code>, and the\n+  debug-mode <code>list</code> always compiles down to code that uses\n+  the name <code>std::_Debug_list</code>, independent of the use of\n+  debug mode. This has several positive effects:</p>\n+\n+<ul>\n+  <li>No linking conflicts between debug/release objects: because the\n+  names of the debug- and release-mode containers are different in the\n+  compiled object files, there are no link-time conflicts between the\n+  two.</li>\n+\n+  <li>Release-mode code is shared: the release-mode code can be shared\n+  within a program, even with it is compiled partly in release-mode\n+  and partly in debug-mode, because the release-mode code is unchanged\n+  in name and function. This can decrease the size of mixed\n+  debug/release binaries.</li>\n+\n+  <li>Able to catch <em>most</em> invalid debug/release combinations:\n+  because the names of debug- and release-mode containers are\n+  different in the compiled object files, if a debug/release\n+  interaction cannot occur (e.g., because a container a translation\n+  unit compiled in debug mode is passed to a routine in a translation\n+  unit compiled in release mode) the result will be an undefined\n+  symbol at link time. The undefined symbol occurs because the mangled\n+  name of the definition will contain the release-mode container type\n+  and the mangled name of the reference will contain the debug-mode\n+  container type. However, we cannot detect these collisions if the\n+  only use of the container is in the return type, because the return\n+  type is not part of the mangled name of a function.</li>\n+</ul>\n+\n+<p>The new <code>link_name</code> class attribute facilities\n+  renaming. It may be attached to any class type (or any class\n+  template) to override the name of the class used for name\n+  mangling. For instance, a class named <code>bar</code> would\n+  generally mangle as <code>3bar</code>; if the class has\n+  a <code>link_name</code> attribute that specifies the string\n+  \"wibble\", then it would mangle as <code>6wibble</code>.</p>\n+\n+<p>Note that although we have hidden the ODR violation, it still\n+  exists. For this reason we cannot easily provide safe iterators for\n+  the <code>std::basic_string</code> class template, as it is present\n+  throughout the C++ standard library. For instance, locale facets\n+  define typedefs that include <code>basic_string</code>: in a mixed\n+  debug/release program, should that typedef be based on the\n+  debug-mode <code>basic_string</code> or the\n+  release-mode <code>basic_string</code>? While the answer could be\n+  \"both\", and the difference hidden via renaming a la the\n+  debug/release containers, we must note two things about locale\n+  facets:</p>\n+\n+<ol>\n+  <li>They exist as shared state: one can create a facet in one\n+  translation unit and access the facet via the same type name in a\n+  different translation unit. This means that we cannot have two\n+  different versions of locale facets, because the types would not be\n+  the same across debug/release-mode translation unit barriers.</li>\n+\n+  <li>They have virtual functions returning strings: these functions\n+  mangle in the same way regardless of the mangling of their return\n+  types (see above), and their precise signatures can be relied upon\n+  by users because they may be overridden in derived classes.\n+</ol>\n+\n+<p>With the design of libstdc++ debug mode, we cannot effectively hide\n+  the differences between debug and release-mode strings from the\n+  user. Failure to hide the differences may result in unpredictable\n+  behavior, and for this reason we have opted to only\n+  perform <code>basic_string</code> changes that do not require ABI\n+  changes. The effect on users is expected to be minimal, as there are\n+  simple alternatives (e.g., <code>__gnu_debug::basic_string</code>),\n+  and the usability benefit we gain from the ability to mix debug- and\n+  release-compiled translation units is enormous.</p>\n+\n+<h4><a name=\"coexistence_alt\">Alternatives for Coexistence</a></h4>\n+<p>The coexistence scheme was chosen over many alternatives,\n+  including language-only solutions and solutions that also required\n+  extensions to the C++ front end. The following is a partial list of\n+  solutions, with justifications for our rejection of each.</p>\n+\n+<ul>\n+  <li><em>Completely separate debug/release libraries</em>: This is by\n+  far the simplest implementation option, where we do not allow any\n+  coexistence of debug- and release-compiled translation units in a\n+  program. This solution has an extreme negative affect on usability,\n+  because it is quite likely that some libraries an application\n+  depends on cannot be recompiled easily. This would not meet\n+  our <b>usability</b> or <b>minimize recompilation</b> criteria\n+  well.</li>\n+\n+  <li><em>Add a <code>Debug</code> boolean template parameter</em>:\n+  Partial specialization could be used to select the debug\n+  implementation when <code>Debug == true</code>, and the state\n+  of <code>_GLIBCXX_DEBUG</code> could decide whether the\n+  default <code>Debug</code> argument is <code>true</code>\n+  or <code>false</code>. This option would break conformance with the\n+  C++ standard in both debug <em>and</em> release modes. This would\n+  not meet our <b>correctness</b> criteria. </li>\n+\n+  <li><em>Packaging a debug flag in the allocators</em>: We could\n+    reuse the <code>Allocator</code> template parameter of containers\n+    by adding a sentinel wrapper <code>debug&lt;&gt;</code> that\n+    signals the user's intention to use debugging, and pick up\n+    the <code>debug&lr;&gt;</code> allocator wrapper in a partial\n+    specialization. However, this has two drawbacks: first, there is a\n+    conformance issue because the default allocator would not be the\n+    standard-specified <code>std::allocator&lt;T&gt;</code>. Secondly\n+    (and more importantly), users that specify allocators instead of\n+    implicitly using the default allocator would not get debugging\n+    containers. Thus this solution fails the <b>correctness</b>\n+    criteria.</li>\n+\n+  <li><em>Define debug containers in another namespace, and employ\n+      a <code>using</code> declaration (or directive)</em>: This is an\n+      enticing option, because it would eliminate the need for\n+      the <code>link_name</code> extension by aliasing the\n+      templates. However, there is no true template aliasing mechanism\n+      is C++, because both <code>using</code> directives and using\n+      declarations disallow specialization. This method fails\n+      the <b>correctness</b> criteria.</li>\n+\n+  <li><em>Extension: allow template aliasing/renaming</em>: This is\n+    the runner-up to the <code>link_name</code> solution, eliminated\n+    only because it requires more extensive compiler changes\n+    than <code>link_name</code>. In this model, we would define the\n+    debug containers in a different namespace\n+    (e.g., <code>__gnu_debug</code>) and then import them (e.g., with\n+    an extended <code>using</code> declaration that aliases templates,\n+    such as that of <a\n+    href=\"http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/papers/2003/n1449.pdf\">template\n+    aliases</a> proposal). This solution is workable, and in fact\n+    would be desirable in the long run, but requires a sizeable change\n+    to the C++ compiler front-end that is not within the scope of\n+    this project.</li>\n+\n+  <li><em>Extension: allow reopening on namespaces</em>: This would\n+    allow the debug mode to effectively alias the\n+    namespace <code>std</code> to an internal namespace, such\n+    as <code>__gnu_std_debug</code>, so that it is completely\n+    separate from the release-mode <code>std</code> namespace. While\n+    this will solve some renaming problems and ensure that\n+    debug- and release-compiled code cannot be mixed unsafely, it ensures that\n+    debug- and release-compiled code cannot be mixed at all. For\n+    instance, the program would have two <code>std::cout</code>\n+    objects! This solution would fails the <b>minimize\n+    recompilation</b> requirement, because we would only be able to\n+    support option (1) or (2).</li>\n+  </li>\n+</ul>\n+\n+<p>Other options may exist for implementing the debug mode, many of\n+  which have probably been considered and others that may still be\n+  lurking. This list may be expanded over time to include other\n+  options that we could have implemented, but in all cases the full\n+  ramifications of the approach (as measured against the design goals\n+  for a libstdc++ debug mode) should be considered first. The DejaGNU\n+  testsuite includes some testcases that check for known problems with\n+  some solutions (e.g., the <code>using</code> declaration solution\n+  that breaks user specialization), and additional testcases will be\n+  added as we are able to identify other typical problem cases. These\n+  test cases will serve as a benchmark by which we can compare debug\n+  mode implementations.</p>\n+\n+<!-- ####################################################### -->\n+\n+<hr />\n+<p class=\"fineprint\"><em>\n+See <a href=\"17_intro/license.html\">license.html</a> for copying conditions.\n+Comments and suggestions are welcome, and may be sent to\n+<a href=\"mailto:libstdc++@gcc.gnu.org\">the libstdc++ mailing list</a>.\n+</em></p>\n+\n+\n+</body>\n+</html>"}, {"sha": "6fb2c3a2498692aa77679aaabb5c9f43c92429ef", "filename": "libstdc++-v3/docs/html/test.html", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ftest.html", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ftest.html", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fdocs%2Fhtml%2Ftest.html?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -34,6 +34,7 @@ <h2>Contents</h2>\n    <li><a href=\"#util\">Utilities: abicheck and libv3test</a></li>\n    <li><a href=\"#new\">How to write a new test case</a></li>\n    <li><a href=\"#check\">Options for running the tests</a></li>\n+   <li><a href=\"#debug\">Running debug-mode tests</a></li>\n    <li><a href=\"#future\">Future</a></li>\n    <li><a href=\"#internals\">DejaGNU internals</a></li>\n </ul>\n@@ -544,6 +545,19 @@ <h2><a name=\"check\">Options for running the tests</a></h2>\n       for which files to examine.\n    </p>\n \n+<hr/>\n+<h2><a name=\"debug\">Running debug-mode tests</a></h2>\n+<p>To run the libstdc++ test suite under the <a\n+  href=\"debug.html#safe\">debug mode</a>,\n+  edit <code>libstdc++/scripts/testsuite_flags</code> to add the\n+  compile-time flag <code>-D_GLIBCXX_DEBUG</code> to the result\n+  printed by the <code>--build-cxx</code> option. Additionally, add\n+  the <code>-D_GLIBCXX_DEBUG_PEDANTIC</code> flag to turn on pedantic\n+  checking. The libstdc++ test suite should produce precisely the same\n+  results under debug mode that it does under release mode: any\n+  deviation indicates an error in either the library or the test\n+  suite.</p>\n+\n <hr />\n <h2><a name=\"future\">Future</a></h2>\n "}, {"sha": "3af38b331d4e6d4d6e3e53e8d59babacfb5cd3bd", "filename": "libstdc++-v3/include/Makefile.am", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.am?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -224,7 +224,6 @@ ext_headers = \\\n \t${ext_srcdir}/hash_fun.h \\\n \t${ext_srcdir}/hashtable.h\n \n-\n # This is the common subset of files that all three \"C\" header models use.\n c_base_srcdir = $(C_INCLUDE_DIR)\n c_base_builddir = .\n@@ -290,6 +289,34 @@ c_compatibility_headers = \\\n \t${c_compatibility_srcdir}/wchar.h \\\n \t${c_compatibility_srcdir}/wctype.h\n \n+# Debug mode headers\n+debug_srcdir = ${glibcxx_srcdir}/include/debug\n+debug_builddir = ./debug\n+debug_headers = \\\n+\t${debug_srcdir}/bitset \\\n+\t${debug_srcdir}/debug.h \\\n+\t${debug_srcdir}/deque \\\n+\t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/hash_map \\\n+\t${debug_srcdir}/hash_map.h \\\n+\t${debug_srcdir}/hash_multimap.h \\\n+\t${debug_srcdir}/hash_multiset.h \\\n+\t${debug_srcdir}/hash_set \\\n+\t${debug_srcdir}/hash_set.h \\\n+\t${debug_srcdir}/list \\\n+\t${debug_srcdir}/map \\\n+\t${debug_srcdir}/map.h \\\n+\t${debug_srcdir}/multimap.h \\\n+\t${debug_srcdir}/multiset.h \\\n+\t${debug_srcdir}/safe_base.h \\\n+\t${debug_srcdir}/safe_iterator.h \\\n+\t${debug_srcdir}/safe_iterator.tcc \\\n+\t${debug_srcdir}/safe_sequence.h \\\n+\t${debug_srcdir}/set \\\n+\t${debug_srcdir}/set.h \\\n+\t${debug_srcdir}/string \\\n+\t${debug_srcdir}/vector\n+\n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers.\n # For --enable-cheaders=c_std\n@@ -350,7 +377,7 @@ endif\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-host\n+\tstamp-backward stamp-ext stamp-debug stamp-host\n \n # List of all files that are created by explicit building, editing, or\n # catenation.\n@@ -429,6 +456,15 @@ stamp-ext: ${ext_headers}\n \tfi ;\\\n \t$(STAMP) stamp-ext\n \n+stamp-debug: ${debug_headers}\n+\t@if [ ! -d \"${debug_builddir}\" ]; then \\\n+\t  mkdir -p ${debug_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-debug ]; then \\\n+\t  (cd ${debug_builddir} && @LN_S@ $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-debug\n+\n stamp-${host_alias}:\n \t@if [ ! -d ${host_builddir} ]; then \\\n \t  mkdir -p ${host_builddir} ;\\\n@@ -556,6 +592,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${std_builddir}\n \tfor file in ${std_headers_rename}; do \\\n \t  $(INSTALL_DATA) ${std_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${std_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${debug_builddir}\n+\tfor file in ${debug_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${debug_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${host_builddir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "cf40dcf18a0a7a97929e27aaf013632d6945e63c", "filename": "libstdc++-v3/include/Makefile.in", "status": "modified", "additions": 43, "deletions": 2, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2FMakefile.in?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -491,11 +491,40 @@ c_compatibility_headers = \\\n \t${c_compatibility_srcdir}/wctype.h\n \n \n+# Debug mode headers\n+debug_srcdir = ${glibcxx_srcdir}/include/debug\n+debug_builddir = ./debug\n+debug_headers = \\\n+\t${debug_srcdir}/bitset \\\n+\t${debug_srcdir}/debug.h \\\n+\t${debug_srcdir}/deque \\\n+\t${debug_srcdir}/formatter.h \\\n+\t${debug_srcdir}/hash_map \\\n+\t${debug_srcdir}/hash_map.h \\\n+\t${debug_srcdir}/hash_multimap.h \\\n+\t${debug_srcdir}/hash_multiset.h \\\n+\t${debug_srcdir}/hash_set \\\n+\t${debug_srcdir}/hash_set.h \\\n+\t${debug_srcdir}/list \\\n+\t${debug_srcdir}/map \\\n+\t${debug_srcdir}/map.h \\\n+\t${debug_srcdir}/multimap.h \\\n+\t${debug_srcdir}/multiset.h \\\n+\t${debug_srcdir}/safe_base.h \\\n+\t${debug_srcdir}/safe_iterator.h \\\n+\t${debug_srcdir}/safe_iterator.tcc \\\n+\t${debug_srcdir}/safe_sequence.h \\\n+\t${debug_srcdir}/set \\\n+\t${debug_srcdir}/set.h \\\n+\t${debug_srcdir}/string \\\n+\t${debug_srcdir}/vector\n+\n+@GLIBCXX_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n+\n # Some of the different \"C\" header models need extra files.\n # Some \"C\" header schemes require the \"C\" compatibility headers.\n # For --enable-cheaders=c_std\n @GLIBCXX_C_HEADERS_C_STD_TRUE@c_base_headers_extra = ${c_base_srcdir}/cmath.tcc\n-@GLIBCXX_C_HEADERS_C_STD_FALSE@c_base_headers_extra = \n @GLIBCXX_C_HEADERS_COMPATIBILITY_FALSE@c_compatibility_headers_extra = \n \n @GLIBCXX_C_HEADERS_COMPATIBILITY_TRUE@c_compatibility_headers_extra = ${c_compatibility_headers}\n@@ -546,7 +575,7 @@ PCHFLAGS = -Winvalid-pch -Wno-deprecated -x c++-header $(CXXFLAGS)\n # CLEANFILES and all-local are kept up-to-date.\n allstamped = \\\n \tstamp-std stamp-bits stamp-c_base stamp-c_compatibility \\\n-\tstamp-backward stamp-ext stamp-host\n+\tstamp-backward stamp-ext stamp-debug stamp-host\n \n \n # List of all files that are created by explicit building, editing, or\n@@ -783,6 +812,15 @@ stamp-ext: ${ext_headers}\n \tfi ;\\\n \t$(STAMP) stamp-ext\n \n+stamp-debug: ${debug_headers}\n+\t@if [ ! -d \"${debug_builddir}\" ]; then \\\n+\t  mkdir -p ${debug_builddir} ;\\\n+\tfi ;\\\n+\tif [ ! -f stamp-debug ]; then \\\n+\t  (cd ${debug_builddir} && @LN_S@ $? . || true) ;\\\n+\tfi ;\\\n+\t$(STAMP) stamp-debug\n+\n stamp-${host_alias}:\n \t@if [ ! -d ${host_builddir} ]; then \\\n \t  mkdir -p ${host_builddir} ;\\\n@@ -904,6 +942,9 @@ install-headers:\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${std_builddir}\n \tfor file in ${std_headers_rename}; do \\\n \t  $(INSTALL_DATA) ${std_builddir}/$${file} $(DESTDIR)${gxx_include_dir}/${std_builddir}; done\n+\t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${debug_builddir}\n+\tfor file in ${debug_headers}; do \\\n+\t  $(INSTALL_DATA) $${file} $(DESTDIR)${gxx_include_dir}/${debug_builddir}; done\n \t$(mkinstalldirs) $(DESTDIR)${gxx_include_dir}/${host_builddir}\n \tfor file in ${host_headers} ${host_headers_extra} \\\n \t ${thread_host_headers}; do \\"}, {"sha": "7b1ba5c80fb567914bae8006b8740e2d0a139b1b", "filename": "libstdc++-v3/include/bits/basic_string.h", "status": "modified", "additions": 105, "deletions": 28, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -43,6 +43,7 @@\n #pragma GCC system_header\n \n #include <bits/atomicity.h>\n+#include <debug/debug.h>\n \n namespace std\n {\n@@ -608,7 +609,10 @@ namespace std\n        */\n       const_reference\n       operator[] (size_type __pos) const\n-      { return _M_data()[__pos]; }\n+      { \n+\t_GLIBCXX_DEBUG_ASSERT(__pos <= size());\n+\treturn _M_data()[__pos]; \n+      }\n \n       /**\n        *  @brief  Subscript access to the data contained in the %string.\n@@ -623,6 +627,7 @@ namespace std\n       reference\n       operator[](size_type __pos)\n       {\n+\t_GLIBCXX_DEBUG_ASSERT(__pos < size());\n \t_M_leak();\n \treturn _M_data()[__pos];\n       }\n@@ -729,7 +734,10 @@ namespace std\n        */\n       basic_string&\n       append(const _CharT* __s)\n-      { return this->append(__s, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->append(__s, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Append multiple characters.\n@@ -810,7 +818,10 @@ namespace std\n        */\n       basic_string&\n       assign(const _CharT* __s)\n-      { return this->assign(__s, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->assign(__s, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Set value to multiple characters.\n@@ -942,7 +953,10 @@ namespace std\n       */\n       basic_string&\n       insert(size_type __pos, const _CharT* __s)\n-      { return this->insert(__pos, __s, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->insert(__pos, __s, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Insert multiple characters.\n@@ -983,6 +997,7 @@ namespace std\n       iterator\n       insert(iterator __p, _CharT __c)\n       {\n+\t_GLIBCXX_DEBUG_PEDASSERT(__p >= _M_ibegin() && __p <= _M_iend());\n \tconst size_type __pos = __p - _M_ibegin();\n \tthis->insert(_M_check(__pos), size_type(1), __c);\n \t_M_rep()->_M_set_leaked();\n@@ -1043,6 +1058,8 @@ namespace std\n       iterator\n       erase(iterator __position)\n       {\n+\t_GLIBCXX_DEBUG_PEDASSERT(__position >= _M_ibegin() \n+\t\t\t\t && __position < _M_iend());\n \tconst size_type __i = __position - _M_ibegin();\n         this->replace(__position, __position + 1, _M_data(), _M_data());\n \t_M_rep()->_M_set_leaked();\n@@ -1064,6 +1081,8 @@ namespace std\n       iterator\n       erase(iterator __first, iterator __last)\n       {\n+\t_GLIBCXX_DEBUG_PEDASSERT(__first >= _M_ibegin() && __first <= __last\n+\t\t\t\t && __last <= _M_iend());\n         const size_type __i = __first - _M_ibegin();\n \tthis->replace(__first, __last, _M_data(), _M_data());\n \t_M_rep()->_M_set_leaked();\n@@ -1150,7 +1169,10 @@ namespace std\n       */\n       basic_string&\n       replace(size_type __pos, size_type __n1, const _CharT* __s)\n-      { return this->replace(__pos, __n1, __s, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->replace(__pos, __n1, __s, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Replace characters with multiple characters.\n@@ -1187,7 +1209,11 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2, const basic_string& __str)\n-      { return this->replace(__i1, __i2, __str._M_data(), __str.size()); }\n+      { \n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t && __i2 <= _M_iend());\n+\treturn this->replace(__i1, __i2, __str._M_data(), __str.size()); \n+      }\n \n       /**\n        *  @brief  Replace range of characters with C substring.\n@@ -1205,7 +1231,7 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2,\n-                           const _CharT* __s, size_type __n)\n+\t      const _CharT* __s, size_type __n)\n       { return this->replace(__i1 - _M_ibegin(), __i2 - __i1, __s, __n); }\n \n       /**\n@@ -1223,7 +1249,12 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2, const _CharT* __s)\n-      { return this->replace(__i1, __i2, __s, traits_type::length(__s)); }\n+      { \n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t && __i2 <= _M_iend());\n+\t__glibcxx_requires_string(__s);\n+\treturn this->replace(__i1, __i2, __s, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Replace range of characters with multiple characters\n@@ -1241,7 +1272,11 @@ namespace std\n       */\n       basic_string&\n       replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n-      { return _M_replace_aux(__i1, __i2, __n, __c); }\n+      { \n+\t_GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t && __i2 <= _M_iend());\n+\treturn _M_replace_aux(__i1, __i2, __n, __c); \n+      }\n \n       /**\n        *  @brief  Replace range of characters with range.\n@@ -1261,30 +1296,55 @@ namespace std\n         basic_string&\n         replace(iterator __i1, iterator __i2,\n \t\t_InputIterator __k1, _InputIterator __k2)\n-        { typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n-\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral()); }\n+        { \n+\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t   && __i2 <= _M_iend());\n+\t  __glibcxx_requires_valid_range(__k1, __k2);\n+\t  typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+\t  return _M_replace_dispatch(__i1, __i2, __k1, __k2, _Integral()); \n+\t}\n \n       // Specializations for the common case of pointer and iterator:\n       // useful to avoid the overhead of temporary buffering in _M_replace.\n       basic_string&\n-      replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n-        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n-\t\t\t       __k1, __k2 - __k1); }\n+        replace(iterator __i1, iterator __i2, _CharT* __k1, _CharT* __k2)\n+        { \n+\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t   && __i2 <= _M_iend());\n+\t  __glibcxx_requires_valid_range(__k1, __k2);\n+\t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n+\t\t\t       __k1, __k2 - __k1); \n+\t}\n \n       basic_string&\n-      replace(iterator __i1, iterator __i2, const _CharT* __k1, const _CharT* __k2)\n-        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n-\t\t\t       __k1, __k2 - __k1); }\n+        replace(iterator __i1, iterator __i2, \n+\t\tconst _CharT* __k1, const _CharT* __k2)\n+        { \n+\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t   && __i2 <= _M_iend());\n+\t  __glibcxx_requires_valid_range(__k1, __k2);\n+\t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n+\t\t\t       __k1, __k2 - __k1); \n+\t}\n \n       basic_string&\n-      replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n-        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n+        replace(iterator __i1, iterator __i2, iterator __k1, iterator __k2)\n+        { \n+\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t   && __i2 <= _M_iend());\n+\t  __glibcxx_requires_valid_range(__k1, __k2);\n+\t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1.base(), __k2 - __k1);\n \t}\n \n       basic_string&\n-      replace(iterator __i1, iterator __i2, const_iterator __k1, const_iterator __k2)\n-        { return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n+        replace(iterator __i1, iterator __i2, \n+\t\tconst_iterator __k1, const_iterator __k2)\n+        { \n+\t  _GLIBCXX_DEBUG_PEDASSERT(_M_ibegin() <= __i1 && __i1 <= __i2\n+\t\t\t\t   && __i2 <= _M_iend());\n+\t  __glibcxx_requires_valid_range(__k1, __k2);\n+\t  return this->replace(__i1 - _M_ibegin(), __i2 - __i1,\n \t\t\t       __k1.base(), __k2 - __k1);\n \t}\n \n@@ -1459,7 +1519,10 @@ namespace std\n       */\n       size_type\n       find(const _CharT* __s, size_type __pos = 0) const\n-      { return this->find(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->find(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find position of a character.\n@@ -1514,7 +1577,10 @@ namespace std\n       */\n       size_type\n       rfind(const _CharT* __s, size_type __pos = npos) const\n-      { return this->rfind(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->rfind(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find last position of a character.\n@@ -1569,7 +1635,10 @@ namespace std\n       */\n       size_type\n       find_first_of(const _CharT* __s, size_type __pos = 0) const\n-      { return this->find_first_of(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->find_first_of(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find position of a character.\n@@ -1627,7 +1696,10 @@ namespace std\n       */\n       size_type\n       find_last_of(const _CharT* __s, size_type __pos = npos) const\n-      { return this->find_last_of(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->find_last_of(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find last position of a character.\n@@ -1686,7 +1758,10 @@ namespace std\n       */\n       size_type\n       find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n-      { return this->find_first_not_of(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->find_first_not_of(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find position of a different character.\n@@ -1742,7 +1817,10 @@ namespace std\n       */\n       size_type\n       find_last_not_of(const _CharT* __s, size_type __pos = npos) const\n-      { return this->find_last_not_of(__s, __pos, traits_type::length(__s)); }\n+      { \n+\t__glibcxx_requires_string(__s);\n+\treturn this->find_last_not_of(__s, __pos, traits_type::length(__s)); \n+      }\n \n       /**\n        *  @brief  Find last position of a different character.\n@@ -2197,7 +2275,6 @@ namespace std\n \t     const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     { return __rhs.compare(__lhs) <= 0; }\n \n-\n   /**\n    *  @brief  Swap contents of two strings.\n    *  @param lhs  First string."}, {"sha": "34a373ce1a500ae15b6cdc23712396b1be688667", "filename": "libstdc++-v3/include/bits/basic_string.tcc", "status": "modified", "additions": 41, "deletions": 3, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fbasic_string.tcc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -45,6 +45,16 @@\n \n namespace std\n {\n+  template<typename _Type>\n+    inline bool\n+    __is_null_pointer(_Type* __ptr)\n+    { return __ptr == 0; }\n+\n+  template<typename _Type>\n+    inline bool\n+    __is_null_pointer(const _Type&)\n+    { return false; }\n+\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     const typename basic_string<_CharT, _Traits, _Alloc>::size_type \n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -141,8 +151,8 @@ namespace std\n \tif (__beg == __end && __a == _Alloc())\n \t  return _S_empty_rep()._M_refdata();\n \n-\t// NB: Not required, but considered best practice.\n-\tif (__builtin_expect(__beg == _InIterator(), 0))\n+\t// NB: Not required, but considered best practice. \n+\tif (__builtin_expect(__is_null_pointer(__beg), 0))\n \t  __throw_logic_error(\"basic_string::_S_construct NULL not valid\");\n \n \tconst size_type __dnew = static_cast<size_type>(std::distance(__beg, __end));\n@@ -215,12 +225,14 @@ namespace std\n \t\t\t       __str._M_fold(__pos, __n), __a), __a)\n     { }\n \n+  // TBD: DPG annotate\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>::\n     basic_string(const _CharT* __s, size_type __n, const _Alloc& __a)\n     : _M_dataplus(_S_construct(__s, __s + __n, __a), __a)\n     { }\n \n+  // TBD: DPG annotate\n   template<typename _CharT, typename _Traits, typename _Alloc>\n     basic_string<_CharT, _Traits, _Alloc>::\n     basic_string(const _CharT* __s, const _Alloc& __a)\n@@ -233,7 +245,8 @@ namespace std\n     basic_string(size_type __n, _CharT __c, const _Alloc& __a)\n     : _M_dataplus(_S_construct(__n, __c, __a), __a)\n     { }\n- \n+\n+  // TBD: DPG annotate \n   template<typename _CharT, typename _Traits, typename _Alloc>\n     template<typename _InputIterator>\n     basic_string<_CharT, _Traits, _Alloc>::\n@@ -275,6 +288,7 @@ namespace std\n      basic_string<_CharT, _Traits, _Alloc>::\n      assign(const _CharT* __s, size_type __n)\n      {\n+       __glibcxx_requires_string_len(__s, __n);\n        if (__n > this->max_size())\n \t __throw_length_error(\"basic_string::assign\");\n        if (_M_rep()->_M_is_shared() || less<const _CharT*>()(__s, _M_data())\n@@ -313,6 +327,7 @@ namespace std\n      basic_string<_CharT, _Traits, _Alloc>::\n      insert(size_type __pos, const _CharT* __s, size_type __n)\n      {\n+       __glibcxx_requires_string_len(__s, __n);\n        const size_type __size = this->size();\n        if (__pos > __size)\n          __throw_out_of_range(\"basic_string::insert\");\n@@ -350,6 +365,7 @@ namespace std\n      replace(size_type __pos, size_type __n1, const _CharT* __s,\n \t     size_type __n2)\n      {\n+       __glibcxx_requires_string_len(__s, __n2);\n        const size_type __size = this->size();\n        if (__pos > __size)\n          __throw_out_of_range(\"basic_string::replace\");\n@@ -727,6 +743,7 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     append(const _CharT* __s, size_type __n)\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n       const size_type __len = __n + this->size();\n       if (__len > this->capacity())\n \tthis->reserve(__len);\n@@ -749,6 +766,7 @@ namespace std\n     operator+(const _CharT* __lhs,\n \t      const basic_string<_CharT, _Traits, _Alloc>& __rhs)\n     {\n+      __glibcxx_requires_string(__lhs);\n       typedef basic_string<_CharT, _Traits, _Alloc> __string_type;\n       typedef typename __string_type::size_type\t  __size_type;\n       const __size_type __len = _Traits::length(__lhs);\n@@ -783,6 +801,8 @@ namespace std\n       \n       if (__n > this->size() - __pos)\n \t__n = this->size() - __pos;\n+\n+      __glibcxx_requires_string_len(__s, __n);\n       \n       traits_type::copy(__s, _M_data() + __pos, __n);\n       // 21.3.5.7 par 3: do not append null.  (good.)\n@@ -794,6 +814,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     find(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       const size_type __size = this->size();\n       size_t __xpos = __pos;\n       const _CharT* __data = _M_data();\n@@ -827,6 +849,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     rfind(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       const size_type __size = this->size();\n       if (__n <= __size)\n \t{\n@@ -866,6 +890,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       for (; __n && __pos < this->size(); ++__pos)\n \t{\n \t  const _CharT* __p = traits_type::find(__s, __n, _M_data()[__pos]);\n@@ -880,6 +906,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       size_type __size = this->size();\n       if (__size && __n)\n \t{ \n@@ -900,6 +928,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       size_t __xpos = __pos;\n       for (; __xpos < this->size(); ++__xpos)\n \tif (!traits_type::find(__s, __n, _M_data()[__xpos]))\n@@ -924,6 +954,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n     {\n+      __glibcxx_requires_string_len(__s, __n);\n+\n       size_type __size = this->size();\n       if (__size)\n \t{ \n@@ -1004,6 +1036,8 @@ namespace std\n     basic_string<_CharT, _Traits, _Alloc>::\n     compare(const _CharT* __s) const\n     {\n+      __glibcxx_requires_string(__s);\n+\n       const size_type __size = this->size();\n       const size_type __osize = traits_type::length(__s);\n       const size_type __len = std::min(__size, __osize);\n@@ -1019,6 +1053,8 @@ namespace std\n     basic_string <_CharT, _Traits, _Alloc>::\n     compare(size_type __pos, size_type __n1, const _CharT* __s) const\n     {\n+      __glibcxx_requires_string(__s);\n+\n       const size_type __size = this->size();\n       if (__pos > __size)\n \t__throw_out_of_range(\"basic_string::compare\");\n@@ -1038,6 +1074,8 @@ namespace std\n     compare(size_type __pos, size_type __n1, const _CharT* __s, \n \t    size_type __n2) const\n     {\n+      __glibcxx_requires_string_len(__s, __n2);\n+\n       const size_type __size = this->size();\n       if (__pos > __size)\n \t__throw_out_of_range(\"basic_string::compare\");"}, {"sha": "6a0fb7901faa8e0b8f7e8ce000cad32f4a97c388", "filename": "libstdc++-v3/include/bits/c++config", "status": "modified", "additions": 21, "deletions": 4, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fc%2B%2Bconfig?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -51,11 +51,28 @@\n # define _GLIBCXX_EXTERN_TEMPLATE 1\n #endif\n \n-// To enable older, ARM-style iostreams and other anachronisms use this.\n-//#define _GLIBCXX_DEPRECATED 1\n+// To enable debug mode.\n+namespace __gnu_norm \n+{ \n+  using namespace std; \n+}\n \n-// Use corrected code from the committee library group's issues list.\n-//#define _GLIBCXX_RESOLVE_LIB_DEFECTS 1\n+namespace __gnu_debug_def { }\n+\n+namespace __gnu_debug \n+{ \n+  using namespace std; \n+  using namespace __gnu_debug_def __attribute__ ((strong));\n+}\n+\n+namespace std\n+{\n+#ifdef _GLIBCXX_DEBUG\n+  using namespace __gnu_debug_def __attribute__ ((strong));\n+#else\n+  using namespace __gnu_norm __attribute__ ((strong));\n+#endif\n+}\n \n // The remainder of the prewritten config is automatic; all the\n // user hooks are listed above."}, {"sha": "9f01eed8d6820e101b7aa98e23e063339e733df9", "filename": "libstdc++-v3/include/bits/deque.tcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fdeque.tcc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -61,7 +61,7 @@\n #ifndef _DEQUE_TCC\n #define _DEQUE_TCC 1\n \n-namespace std\n+namespace __gnu_norm\n { \n   template <typename _Tp, typename _Alloc>\n     deque<_Tp,_Alloc>&\n@@ -707,6 +707,6 @@ namespace std\n       this->_M_start._M_set_node(__new_nstart);\n       this->_M_finish._M_set_node(__new_nstart + __old_num_nodes - 1);\n     }\n-} // namespace std \n+} // namespace __gnu_norm\n   \n #endif"}, {"sha": "283b0ac6838f58434f75bf1d5fa0055ed9d00a02", "filename": "libstdc++-v3/include/bits/list.tcc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flist.tcc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -61,7 +61,7 @@\n #ifndef _LIST_TCC\n #define _LIST_TCC 1\n \n-namespace std\n+namespace __gnu_norm\n {\n   template<typename _Tp, typename _Alloc>\n     void\n@@ -409,6 +409,6 @@ namespace std\n         swap(__counter[__fill-1]);\n       }\n     }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _LIST_TCC */"}, {"sha": "7cb54eb63a24b4d06081109ae4f5597635f1b493", "filename": "libstdc++-v3/include/bits/stl_algo.h", "status": "modified", "additions": 110, "deletions": 4, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algo.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,12 +63,12 @@\n \n #include <bits/stl_heap.h>\n #include <bits/stl_tempbuf.h>     // for _Temporary_buffer\n+#include <debug/debug.h>\n \n // See concept_check.h for the __glibcxx_*_requires macros.\n \n namespace std\n {\n-\n   /**\n    *  @brief Find the median of three values.\n    *  @param  a  A value.\n@@ -153,6 +153,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       for ( ; __first != __last; ++__first)\n \t__f(*__first);\n       return __f;\n@@ -295,6 +296,7 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_EqualOpConcept<\n \t\ttypename iterator_traits<_InputIterator>::value_type, _Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       return std::find(__first, __last, __val, std::__iterator_category(__first));\n     }\n \n@@ -315,6 +317,7 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t      typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       return std::find_if(__first, __last, __pred, std::__iterator_category(__first));\n     }\n \n@@ -334,6 +337,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       if (__first == __last)\n \treturn __last;\n       _ForwardIterator __next = __first;\n@@ -365,6 +369,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       if (__first == __last)\n \treturn __last;\n       _ForwardIterator __next = __first;\n@@ -393,6 +398,7 @@ namespace std\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_InputIterator>::value_type >)\n       __glibcxx_function_requires(_EqualityComparableConcept<_Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       typename iterator_traits<_InputIterator>::difference_type __n = 0;\n       for ( ; __first != __last; ++__first)\n \tif (*__first == __value)\n@@ -416,6 +422,7 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       typename iterator_traits<_InputIterator>::difference_type __n = 0;\n       for ( ; __first != __last; ++__first)\n \tif (__pred(*__first))\n@@ -458,7 +465,8 @@ namespace std\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_ForwardIterator1>::value_type,\n \t    typename iterator_traits<_ForwardIterator2>::value_type>)\n-\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n       // Test for empty ranges\n       if (__first1 == __last1 || __first2 == __last2)\n \treturn __first1;\n@@ -531,6 +539,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_ForwardIterator1>::value_type,\n \t    typename iterator_traits<_ForwardIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       // Test for empty ranges\n       if (__first1 == __last1 || __first2 == __last2)\n@@ -603,6 +613,7 @@ namespace std\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_function_requires(_EqualityComparableConcept<_Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__count <= 0)\n \treturn __first;\n@@ -651,6 +662,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__count <= 0)\n \treturn __first;\n@@ -708,6 +720,7 @@ namespace std\n       __glibcxx_function_requires(_ConvertibleConcept<\n \t    typename iterator_traits<_ForwardIterator2>::value_type,\n \t    typename iterator_traits<_ForwardIterator1>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2)\n \tstd::iter_swap(__first1, __first2);\n@@ -739,6 +752,7 @@ namespace std\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n             // \"the type returned by a _UnaryOperation\"\n             __typeof__(__unary_op(*__first))>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first, ++__result)\n \t*__result = __unary_op(*__first);\n@@ -775,6 +789,7 @@ namespace std\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n             // \"the type returned by a _BinaryOperation\"\n             __typeof__(__binary_op(*__first1,*__first2))>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2, ++__result)\n \t*__result = __binary_op(*__first1, *__first2);\n@@ -804,6 +819,7 @@ namespace std\n \t    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n       __glibcxx_function_requires(_ConvertibleConcept<_Tp,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \tif (*__first == __old_value)\n@@ -833,6 +849,7 @@ namespace std\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \tif (__pred(*__first))\n@@ -865,6 +882,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_InputIterator>::value_type, _Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first, ++__result)\n \t*__result = *__first == __old_value ? __new_value : *__first;\n@@ -898,6 +916,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first, ++__result)\n \t*__result = __pred(*__first) ? __new_value : *__first;\n@@ -923,6 +942,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_GeneratorConcept<_Generator,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \t*__first = __gen();\n@@ -977,6 +997,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_InputIterator>::value_type, _Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \tif (!(*__first == __value)) {\n@@ -1011,6 +1032,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \tif (!__pred(*__first)) {\n@@ -1047,6 +1069,7 @@ namespace std\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       __first = std::find(__first, __last, __value);\n       _ForwardIterator __i = __first;\n@@ -1079,6 +1102,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       __first = std::find_if(__first, __last, __pred);\n       _ForwardIterator __i = __first;\n@@ -1207,6 +1231,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator>::value_type>)\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       typedef typename iterator_traits<_OutputIterator>::iterator_category _IterType;\n \n@@ -1239,6 +1264,7 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       typedef typename iterator_traits<_OutputIterator>::iterator_category _IterType;\n \n@@ -1266,7 +1292,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_EqualityComparableConcept<\n-\t    typename iterator_traits<_ForwardIterator>::value_type>)\n+\t\t     typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       // Skip the beginning, if already unique.\n       __first = std::adjacent_find(__first, __last);\n@@ -1306,6 +1333,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       // Skip the beginning, if already unique.\n       __first = std::adjacent_find(__first, __last, __binary_pred);\n@@ -1371,7 +1399,8 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<\n-\t\t_BidirectionalIterator>)\n+\t\t    _BidirectionalIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n       std::__reverse(__first, __last, std::__iterator_category(__first));\n     }\n \n@@ -1399,6 +1428,7 @@ namespace std\n       __glibcxx_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n \t\ttypename iterator_traits<_BidirectionalIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       while (__first != __last) {\n \t--__last;\n@@ -1583,6 +1613,8 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n+      __glibcxx_requires_valid_range(__first, __middle);\n+      __glibcxx_requires_valid_range(__middle, __last);\n \n       typedef typename iterator_traits<_ForwardIterator>::iterator_category _IterType;\n       std::__rotate(__first, __middle, __last, _IterType());\n@@ -1614,6 +1646,8 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __middle);\n+      __glibcxx_requires_valid_range(__middle, __last);\n \n       return std::copy(__first, __middle, copy(__middle, __last, __result));\n     }\n@@ -1657,6 +1691,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return;\n       for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)\n@@ -1684,6 +1719,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return;\n       for (_RandomAccessIterator __i = __first + 1; __i != __last; ++__i)\n@@ -1773,6 +1809,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       return std::__partition(__first, __last, __pred, std::__iterator_category(__first));\n     }\n@@ -1873,6 +1910,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn __first;\n@@ -2139,6 +2177,8 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __middle);\n+      __glibcxx_requires_valid_range(__middle, __last);\n \n       std::make_heap(__first, __middle);\n       for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)\n@@ -2179,6 +2219,8 @@ namespace std\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t\t\t\t  _ValueType, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __middle);\n+      __glibcxx_requires_valid_range(__middle, __last);\n \n       std::make_heap(__first, __middle, __comp);\n       for (_RandomAccessIterator __i = __middle; __i < __last; ++__i)\n@@ -2219,6 +2261,8 @@ namespace std\n       __glibcxx_function_requires(_ConvertibleConcept<_InputValueType, _OutputValueType>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_OutputValueType>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_InputValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_valid_range(__result_first, __result_last);\n \n       if (__result_first == __result_last) return __result_last;\n       _RandomAccessIterator __result_real_last = __result_first;\n@@ -2275,6 +2319,8 @@ namespace std\n       __glibcxx_function_requires(_ConvertibleConcept<_InputValueType, _OutputValueType>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t  _OutputValueType, _OutputValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_valid_range(__result_first, __result_last);\n \n       if (__result_first == __result_last) return __result_last;\n       _RandomAccessIterator __result_real_last = __result_first;\n@@ -2375,6 +2421,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first != __last) {\n \tstd::__introsort_loop(__first, __last, __lg(__last - __first) * 2);\n@@ -2406,6 +2453,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first != __last) {\n \tstd::__introsort_loop(__first, __last, __lg(__last - __first) * 2, __comp);\n@@ -2438,6 +2486,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n+      __glibcxx_requires_partitioned(__first, __last, __val);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -2483,6 +2532,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _Tp>)\n+      __glibcxx_requires_partitioned_pred(__first, __last, __val, __comp);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -2525,6 +2575,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n+      __glibcxx_requires_partitioned(__first, __last, __val);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -2570,6 +2621,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _ValueType>)\n+      __glibcxx_requires_partitioned_pred(__first, __last, __val, __comp);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -2755,6 +2807,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2) {\n \tif (*__first2 < *__first1) {\n@@ -2808,6 +2862,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2) {\n \tif (__comp(*__first2, *__first1)) {\n@@ -3170,6 +3226,8 @@ namespace std\n       __glibcxx_function_requires(_Mutable_BidirectionalIteratorConcept<\n \t    _BidirectionalIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_sorted(__first, __middle);\n+      __glibcxx_requires_sorted(__middle, __last);\n \n       if (__first == __middle || __middle == __last)\n \treturn;\n@@ -3223,6 +3281,8 @@ namespace std\n \t    _BidirectionalIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    _ValueType, _ValueType>)\n+      __glibcxx_requires_sorted_pred(__first, __middle, __comp);\n+      __glibcxx_requires_sorted_pred(__middle, __last, __comp);\n \n       if (__first == __middle || __middle == __last)\n \treturn;\n@@ -3309,6 +3369,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);\n       if (buf.begin() == 0)\n@@ -3346,6 +3407,7 @@ namespace std\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t\t\t\t  _ValueType, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       _Temporary_buffer<_RandomAccessIterator, _ValueType> buf(__first, __last);\n       if (buf.begin() == 0)\n@@ -3381,6 +3443,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<_RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __nth);\n+      __glibcxx_requires_valid_range(__nth, __last);\n \n       while (__last - __first > 3) {\n \t_RandomAccessIterator __cut =\n@@ -3425,6 +3489,8 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<_RandomAccessIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t\t\t\t  _ValueType, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __nth);\n+      __glibcxx_requires_valid_range(__nth, __last);\n \n       while (__last - __first > 3) {\n \t_RandomAccessIterator __cut =\n@@ -3469,6 +3535,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_SameTypeConcept<_Tp, _ValueType>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n+      __glibcxx_requires_partitioned(__first, __last, __val);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -3524,6 +3591,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _ValueType, _Tp>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _Tp, _ValueType>)\n+      __glibcxx_requires_partitioned_pred(__first, __last, __val, __comp);\n \n       _DistanceType __len = std::distance(__first, __last);\n       _DistanceType __half;\n@@ -3572,6 +3640,7 @@ namespace std\n       __glibcxx_function_requires(_SameTypeConcept<_Tp,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_Tp>)\n+      __glibcxx_requires_partitioned(__first, __last, __val);\n \n       _ForwardIterator __i = std::lower_bound(__first, __last, __val);\n       return __i != __last && !(__val < *__i);\n@@ -3603,6 +3672,7 @@ namespace std\n \t\ttypename iterator_traits<_ForwardIterator>::value_type, _Tp>)\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare, _Tp,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_partitioned_pred(__first, __last, __val, __comp);\n \n       _ForwardIterator __i = std::lower_bound(__first, __last, __val, __comp);\n       return __i != __last && !__comp(__val, *__i);\n@@ -3642,6 +3712,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (*__first2 < *__first1)\n@@ -3687,6 +3759,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (__comp(*__first2, *__first1))\n@@ -3732,6 +3806,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2) {\n \tif (*__first1 < *__first2) {\n@@ -3788,6 +3864,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2) {\n \tif (__comp(*__first1, *__first2)) {\n@@ -3840,6 +3918,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (*__first1 < *__first2)\n@@ -3892,6 +3972,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (__comp(*__first1, *__first2))\n@@ -3941,6 +4023,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (*__first1 < *__first2) {\n@@ -3996,6 +4080,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (__comp(*__first1, *__first2)) {\n@@ -4044,6 +4130,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n+      __glibcxx_requires_sorted(__first1, __last1);\n+      __glibcxx_requires_sorted(__first2, __last2);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (*__first1 < *__first2) {\n@@ -4101,6 +4189,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_sorted_pred(__first1, __last1, __comp);\n+      __glibcxx_requires_sorted_pred(__first2, __last2, __comp);\n \n       while (__first1 != __last1 && __first2 != __last2)\n \tif (__comp(*__first1, *__first2)) {\n@@ -4137,6 +4227,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __first;\n       _ForwardIterator __result = __first;\n@@ -4164,6 +4255,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_ForwardIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __first;\n       _ForwardIterator __result = __first;\n@@ -4186,6 +4278,7 @@ namespace std\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __first;\n       _ForwardIterator __result = __first;\n@@ -4213,6 +4306,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_ForwardIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __first;\n       _ForwardIterator __result = __first;\n@@ -4244,6 +4338,7 @@ namespace std\n       __glibcxx_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_BidirectionalIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn false;\n@@ -4296,6 +4391,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_BidirectionalIterator>::value_type,\n \t    typename iterator_traits<_BidirectionalIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn false;\n@@ -4344,6 +4440,7 @@ namespace std\n       __glibcxx_function_requires(_BidirectionalIteratorConcept<_BidirectionalIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_BidirectionalIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn false;\n@@ -4396,6 +4493,7 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_Compare,\n \t    typename iterator_traits<_BidirectionalIterator>::value_type,\n \t    typename iterator_traits<_BidirectionalIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn false;\n@@ -4451,6 +4549,8 @@ namespace std\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_InputIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       for ( ; __first1 != __last1; ++__first1)\n \tfor (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)\n@@ -4489,6 +4589,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_InputIterator>::value_type,\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       for ( ; __first1 != __last1; ++__first1)\n \tfor (_ForwardIterator __iter = __first2; __iter != __last2; ++__iter)\n@@ -4649,6 +4751,8 @@ namespace std\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_ForwardIterator1>::value_type,\n \t    typename iterator_traits<_ForwardIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       return std::__find_end(__first1, __last1, __first2, __last2,\n \t\t\t     std::__iterator_category(__first1),\n@@ -4694,6 +4798,8 @@ namespace std\n       __glibcxx_function_requires(_BinaryPredicateConcept<_BinaryPredicate,\n \t    typename iterator_traits<_ForwardIterator1>::value_type,\n \t    typename iterator_traits<_ForwardIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       return std::__find_end(__first1, __last1, __first2, __last2,\n \t\t\t     std::__iterator_category(__first1),"}, {"sha": "3e1a7c639c3d3e61b938f0667d272a62ed66a215", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -74,6 +74,7 @@\n #include <bits/stl_iterator_base_funcs.h>\n #include <bits/stl_iterator.h>\n #include <bits/concept_check.h>\n+#include <debug/debug.h>\n \n namespace std\n {\n@@ -333,6 +334,7 @@ namespace std\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n        typedef typename _Is_normal_iterator<_InputIterator>::_Normal __Normal;\n        return std::__copy_ni1(__first, __last, __result, __Normal());\n@@ -471,6 +473,7 @@ namespace std\n       __glibcxx_function_requires(_ConvertibleConcept<\n \t    typename iterator_traits<_BI1>::value_type,\n \t    typename iterator_traits<_BI2>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       typedef typename _Is_normal_iterator<_BI1>::_Normal __Normal;\n       return std::__copy_backward_input_normal_iterator(__first, __last, __result,\n@@ -495,6 +498,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_ForwardIteratorConcept<_ForwardIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \t*__first = __value;\n@@ -527,20 +531,23 @@ namespace std\n   inline void\n   fill(unsigned char* __first, unsigned char* __last, const unsigned char& __c)\n   {\n+    __glibcxx_requires_valid_range(__first, __last);\n     unsigned char __tmp = __c;\n     std::memset(__first, __tmp, __last - __first);\n   }\n \n   inline void\n   fill(signed char* __first, signed char* __last, const signed char& __c)\n   {\n+    __glibcxx_requires_valid_range(__first, __last);\n     signed char __tmp = __c;\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n \n   inline void\n   fill(char* __first, char* __last, const char& __c)\n   {\n+    __glibcxx_requires_valid_range(__first, __last);\n     char __tmp = __c;\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n@@ -594,6 +601,7 @@ namespace std\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       while (__first1 != __last1 && *__first1 == *__first2)\n         {\n@@ -625,6 +633,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       while (__first1 != __last1 && __binary_pred(*__first1, *__first2))\n         {\n@@ -655,6 +664,7 @@ namespace std\n       __glibcxx_function_requires(_EqualOpConcept<\n \t    typename iterator_traits<_InputIterator1>::value_type,\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2)\n \tif (!(*__first1 == *__first2))\n@@ -684,6 +694,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2)\n \tif (!__binary_pred(*__first1, *__first2))\n@@ -717,6 +728,8 @@ namespace std\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       for (;__first1 != __last1 && __first2 != __last2; ++__first1, ++__first2) \n \t{\n@@ -749,6 +762,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       for ( ; __first1 != __last1 && __first2 != __last2\n \t    ; ++__first1, ++__first2) \n@@ -767,6 +782,9 @@ namespace std\n \t\t\t  const unsigned char* __first2, \n \t\t\t  const unsigned char* __last2)\n   {\n+    __glibcxx_requires_valid_range(__first1, __last1);\n+    __glibcxx_requires_valid_range(__first2, __last2);\n+\n     const size_t __len1 = __last1 - __first1;\n     const size_t __len2 = __last2 - __first2;\n     const int __result = std::memcmp(__first1, __first2, std::min(__len1, __len2));\n@@ -777,6 +795,9 @@ namespace std\n   lexicographical_compare(const char* __first1, const char* __last1,\n \t\t\t  const char* __first2, const char* __last2)\n   {\n+    __glibcxx_requires_valid_range(__first1, __last1);\n+    __glibcxx_requires_valid_range(__first2, __last2);\n+\n #if CHAR_MAX == SCHAR_MAX\n     return std::lexicographical_compare((const signed char*) __first1,\n \t\t\t\t\t(const signed char*) __last1,"}, {"sha": "d05f6076bb857559671bf1c17f66141a902cd9bb", "filename": "libstdc++-v3/include/bits/stl_bvector.h", "status": "modified", "additions": 6, "deletions": 12, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_bvector.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -61,7 +61,7 @@\n #ifndef _BVECTOR_H\n #define _BVECTOR_H 1\n \n-namespace std\n+namespace __gnu_norm\n { \n   typedef unsigned long _Bit_type;\n   enum { _S_word_bit = int(CHAR_BIT * sizeof(_Bit_type)) };\n@@ -334,13 +334,12 @@ class _Bvector_base\n   ~_Bvector_base() { _Base::_M_deallocate(); }\n };\n \n-} // namespace std\n+} // namespace __gnu_norm\n \n // Declare a partial specialization of vector<T, Alloc>.\n #include <bits/stl_vector.h>\n-namespace std\n+namespace __gnu_norm\n {\n-\n template <typename _Alloc> \n   class vector<bool, _Alloc> : public _Bvector_base<_Alloc> \n   {\n@@ -723,13 +722,8 @@ template <typename _Alloc>\n     void clear() { erase(begin(), end()); }\n   };\n \n-// This typedef is non-standard.  It is provided for backward compatibility.\n-typedef vector<bool, __alloc> bit_vector;\n-\n-} // namespace std \n+  // This typedef is non-standard.  It is provided for backward compatibility.\n+  typedef vector<bool, __alloc> bit_vector;\n+} // namespace __gnu_norm\n \n #endif /* _BVECTOR_H */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "2498bb6bfe6b74f3b1964e9202ce3fe610b65c30", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -65,7 +65,7 @@\n #include <bits/stl_iterator_base_types.h>\n #include <bits/stl_iterator_base_funcs.h>\n \n-namespace std\n+namespace __gnu_norm\n { \n   /**\n    *  @if maint\n@@ -96,7 +96,7 @@ namespace std\n    *  All the functions are op overloads except for _M_set_node.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n     struct _Deque_iterator\n   {\n     typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n@@ -205,15 +205,15 @@ namespace std\n   // Note: we also provide overloads whose operands are of the same type in\n   // order to avoid ambiguous overload resolution when std::rel_ops operators\n   // are in scope (for additional details, see libstdc++/3628)\n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator==(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n   {\n     return __x._M_cur == __y._M_cur;\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator==(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -222,15 +222,15 @@ namespace std\n     return __x._M_cur == __y._M_cur;\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator!=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n   {\n     return !(__x == __y);\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator!=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -239,7 +239,7 @@ namespace std\n     return !(__x == __y);\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator<(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n@@ -248,7 +248,7 @@ namespace std\n       (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator<(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -258,15 +258,15 @@ namespace std\n       (__x._M_cur < __y._M_cur) : (__x._M_node < __y._M_node);\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator>(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n   {\n     return __y < __x;\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator>(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -275,15 +275,15 @@ namespace std\n     return __y < __x;\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator<=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n   {\n     return !(__y < __x);\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator<=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -292,15 +292,15 @@ namespace std\n     return !(__y < __x);\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline bool\n   operator>=(const _Deque_iterator<_Tp, _Ref, _Ptr>& __x,\n   \t   const _Deque_iterator<_Tp, _Ref, _Ptr>& __y)\n   {\n     return !(__x < __y);\n   }\n   \n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline bool\n   operator>=(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -313,7 +313,7 @@ namespace std\n   // According to the resolution of DR179 not only the various comparison\n   // operators but also operator- must accept mixed iterator/const_iterator\n   // parameters.\n-  template <typename _Tp, typename _RefL, typename _PtrL,\n+  template<typename _Tp, typename _RefL, typename _PtrL,\n                           typename _RefR, typename _PtrR>\n   inline typename _Deque_iterator<_Tp, _RefL, _PtrL>::difference_type\n   operator-(const _Deque_iterator<_Tp, _RefL, _PtrL>& __x,\n@@ -325,7 +325,7 @@ namespace std\n       (__y._M_last - __y._M_cur);\n   }\n   \n-  template <typename _Tp, typename _Ref, typename _Ptr>\n+  template<typename _Tp, typename _Ref, typename _Ptr>\n   inline _Deque_iterator<_Tp, _Ref, _Ptr>\n   operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n   {\n@@ -345,7 +345,7 @@ namespace std\n    *  instanceless allocators.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc, bool __is_static>\n+  template<typename _Tp, typename _Alloc, bool __is_static>\n     class _Deque_alloc_base\n   {\n   public:\n@@ -388,7 +388,7 @@ namespace std\n   };\n   \n   /// @if maint Specialization for instanceless allocators.  @endif\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     class _Deque_alloc_base<_Tp, _Alloc, true>\n   {\n   public:\n@@ -439,7 +439,7 @@ namespace std\n    *  here.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n     class _Deque_base\n     : public _Deque_alloc_base<_Tp,_Alloc,\n                                 _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n@@ -470,7 +470,7 @@ namespace std\n   };\n   \n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   _Deque_base<_Tp,_Alloc>::~_Deque_base()\n   {\n     if (this->_M_map)\n@@ -490,7 +490,7 @@ namespace std\n    *  The initial underlying memory layout is a bit complicated...\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   void\n   _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n   {\n@@ -525,7 +525,7 @@ namespace std\n                        __num_elements % __deque_buf_size(sizeof(_Tp));\n   }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   void _Deque_base<_Tp,_Alloc>::_M_create_nodes(_Tp** __nstart, _Tp** __nfinish)\n   {\n     _Tp** __cur;\n@@ -541,7 +541,7 @@ namespace std\n       }\n   }\n   \n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   void\n   _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n   {\n@@ -634,7 +634,7 @@ namespace std\n    *  and we can use other standard algorithms as well.\n    *  @endif\n   */\n-  template <typename _Tp, typename _Alloc = allocator<_Tp> >\n+  template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class deque : protected _Deque_base<_Tp, _Alloc>\n   {\n     // concept requirements\n@@ -1227,13 +1227,13 @@ namespace std\n      *  push_back on each value from the iterator.\n      *  @endif\n     */\n-    template <typename _InputIterator>\n+    template<typename _InputIterator>\n       void\n       _M_range_initialize(_InputIterator __first, _InputIterator __last,\n                           input_iterator_tag);\n   \n     // called by the second initialize_dispatch above\n-    template <typename _ForwardIterator>\n+    template<typename _ForwardIterator>\n       void\n       _M_range_initialize(_ForwardIterator __first, _ForwardIterator __last,\n                           forward_iterator_tag);\n@@ -1278,13 +1278,13 @@ namespace std\n       }\n   \n     // called by the second assign_dispatch above\n-    template <typename _InputIterator>\n+    template<typename _InputIterator>\n       void\n       _M_assign_aux(_InputIterator __first, _InputIterator __last,\n                     input_iterator_tag);\n   \n     // called by the second assign_dispatch above\n-    template <typename _ForwardIterator>\n+    template<typename _ForwardIterator>\n       void\n       _M_assign_aux(_ForwardIterator __first, _ForwardIterator __last,\n                     forward_iterator_tag)\n@@ -1357,13 +1357,13 @@ namespace std\n       }\n   \n     // called by the second insert_dispatch above\n-    template <typename _InputIterator>\n+    template<typename _InputIterator>\n       void\n       _M_range_insert_aux(iterator __pos, _InputIterator __first,\n                           _InputIterator __last, input_iterator_tag);\n   \n     // called by the second insert_dispatch above\n-    template <typename _ForwardIterator>\n+    template<typename _ForwardIterator>\n       void\n       _M_range_insert_aux(iterator __pos, _ForwardIterator __first,\n                           _ForwardIterator __last, forward_iterator_tag);\n@@ -1383,7 +1383,7 @@ namespace std\n     _M_insert_aux(iterator __pos, size_type __n, const value_type& __x);\n   \n     // called by range_insert_aux for forward iterators\n-    template <typename _ForwardIterator>\n+    template<typename _ForwardIterator>\n       void\n       _M_insert_aux(iterator __pos, \n                     _ForwardIterator __first, _ForwardIterator __last,\n@@ -1464,7 +1464,7 @@ namespace std\n    *  deques.  Deques are considered equivalent if their sizes are equal,\n    *  and if corresponding elements compare equal.\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator==(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y)\n   {\n@@ -1483,7 +1483,7 @@ namespace std\n    *\n    *  See std::lexicographical_compare() for how the determination is made.\n   */\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator<(const deque<_Tp, _Alloc>& __x,\n                         const deque<_Tp, _Alloc>& __y)\n   {\n@@ -1492,39 +1492,39 @@ namespace std\n   }\n   \n   /// Based on operator==\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator!=(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y) {\n     return !(__x == __y);\n   }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator>(const deque<_Tp, _Alloc>& __x,\n                         const deque<_Tp, _Alloc>& __y) {\n     return __y < __x;\n   }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator<=(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y) {\n     return !(__y < __x);\n   }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline bool operator>=(const deque<_Tp, _Alloc>& __x,\n                          const deque<_Tp, _Alloc>& __y) {\n     return !(__x < __y);\n   }\n   \n   /// See std::deque::swap().\n-  template <typename _Tp, typename _Alloc>\n+  template<typename _Tp, typename _Alloc>\n   inline void swap(deque<_Tp,_Alloc>& __x, deque<_Tp,_Alloc>& __y)\n   {\n     __x.swap(__y);\n   }\n-} // namespace std \n+} // namespace __gnu_norm\n   \n #endif /* _DEQUE_H */"}, {"sha": "c16cbe02e6fbbb3937392626624214a244aadb0e", "filename": "libstdc++-v3/include/bits/stl_heap.h", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_heap.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -60,8 +60,53 @@\n #ifndef _STL_HEAP_H\n #define _STL_HEAP_H 1\n \n+#include <debug/debug.h>\n+\n namespace std\n {\n+  // is_heap, a predicate testing whether or not a range is\n+  // a heap.  This function is an extension, not part of the C++\n+  // standard.\n+  template<typename _RandomAccessIterator, typename _Distance>\n+    bool\n+    __is_heap(_RandomAccessIterator __first, _Distance __n)\n+    {\n+      _Distance __parent = 0;\n+      for (_Distance __child = 1; __child < __n; ++__child) {\n+\tif (__first[__parent] < __first[__child]) \n+\t  return false;\n+\tif ((__child & 1) == 0)\n+\t  ++__parent;\n+      }\n+      return true;\n+    }\n+\n+  template<typename _RandomAccessIterator, typename _Distance,\n+           typename _StrictWeakOrdering>\n+    bool\n+    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,\n+\t      _Distance __n)\n+    {\n+      _Distance __parent = 0;\n+      for (_Distance __child = 1; __child < __n; ++__child) {\n+\tif (__comp(__first[__parent], __first[__child]))\n+\t  return false;\n+\tif ((__child & 1) == 0)\n+\t  ++__parent;\n+      }\n+      return true;\n+    }\n+\n+  template<typename _RandomAccessIterator>\n+    bool\n+    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n+    { return std::__is_heap(__first, std::distance(__first, __last)); }\n+\n+  template<typename _RandomAccessIterator, typename _StrictWeakOrdering>\n+    bool\n+    __is_heap(_RandomAccessIterator __first, _RandomAccessIterator __last,\n+\t    _StrictWeakOrdering __comp)\n+    { return std::__is_heap(__first, __comp, std::distance(__first, __last)); }\n \n   // Heap-manipulation functions: push_heap, pop_heap, make_heap, sort_heap.\n \n@@ -101,6 +146,8 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      //      __glibcxx_requires_heap(__first, __last - 1);\n \n       std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n \t\t       _ValueType(*(__last - 1)));\n@@ -145,6 +192,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_heap_pred(__first, __last - 1, __comp);\n \n       std::__push_heap(__first, _DistanceType((__last - __first) - 1), _DistanceType(0), \n \t\t       _ValueType(*(__last - 1)), __comp);\n@@ -200,6 +249,8 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_heap(__first, __last);\n \n       std::__pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)));\n     }\n@@ -256,6 +307,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_heap_pred(__first, __last, __comp);\n \n       typedef typename iterator_traits<_RandomAccessIterator>::value_type _ValueType;\n       std::__pop_heap(__first, __last - 1, __last - 1, _ValueType(*(__last - 1)), __comp);\n@@ -282,6 +335,7 @@ namespace std\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<_ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__last - __first < 2) return;\n       _DistanceType __len = __last - __first;\n@@ -317,7 +371,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n-\n+      __glibcxx_requires_valid_range(__first, __last);\n+      \n       if (__last - __first < 2) return;\n       _DistanceType __len = __last - __first;\n       _DistanceType __parent = (__len - 2)/2;\n@@ -347,6 +402,8 @@ namespace std\n \t    _RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      //      __glibcxx_requires_heap(__first, __last);\n \n       while (__last - __first > 1)\n \tstd::pop_heap(__first, __last--);\n@@ -370,6 +427,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_heap_pred(__first, __last, __comp);\n \n       while (__last - __first > 1)\n \tstd::pop_heap(__first, __last--, __comp);"}, {"sha": "4524e9ec8316d466a165b0dd2648563aaaa1916b", "filename": "libstdc++-v3/include/bits/stl_list.h", "status": "modified", "additions": 199, "deletions": 175, "changes": 374, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_list.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,7 +63,7 @@\n \n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n   // Supporting structures are split into common and templated types; the\n   // latter publicly inherits from the former in an effort to reduce code\n@@ -89,9 +89,9 @@ namespace std\n    *  @if maint\n    *  @brief Common part of a list::iterator.\n    *\n-   *  A simple type to walk a doubly-linked list.  All operations here should\n-   *  be self-explanatory after taking any decent introductory data structures\n-   *  course.\n+   *  A simple type to walk a doubly-linked list.  All operations here\n+   *  should be self-explanatory after taking any decent introductory\n+   *  data structures course.\n    *  @endif\n   */\n   struct _List_iterator_base\n@@ -233,17 +233,20 @@ namespace std\n     { _M_node_allocator.deallocate(__p, 1); }\n   \n     // NOTA BENE\n-    // The stored instance is not actually of \"allocator_type\"'s type.  Instead\n-    // we rebind the type to Allocator<List_node<Tp>>, which according to\n-    // [20.1.5]/4 should probably be the same.  List_node<Tp> is not the same\n-    // size as Tp (it's two pointers larger), and specializations on Tp may go\n-    // unused because List_node<Tp> is being bound instead.\n+    // The stored instance is not actually of \"allocator_type\"'s type.\n+    // Instead we rebind the type to Allocator<List_node<Tp>>, which\n+    // according to [20.1.5]/4 should probably be the same.\n+    // List_node<Tp> is not the same size as Tp (it's two pointers\n+    // larger), and specializations on Tp may go unused because\n+    // List_node<Tp> is being bound instead.\n     //\n-    // We put this to the test in get_allocator above; if the two types are\n-    // actually different, there had better be a conversion between them.\n+    // We put this to the test in get_allocator above; if the two\n+    // types are actually different, there had better be a conversion\n+    // between them.\n     //\n-    // None of the predefined allocators shipped with the library (as of 3.1)\n-    // use this instantiation anyhow; they're all instanceless.\n+    // None of the predefined allocators shipped with the library (as\n+    // of 3.1) use this instantiation anyhow; they're all\n+    // instanceless.\n     typename _Alloc_traits<_List_node<_Tp>, _Allocator>::allocator_type\n              _M_node_allocator;\n   \n@@ -329,36 +332,37 @@ namespace std\n    *  <a href=\"tables.html#68\">optional sequence requirements</a> with the\n    *  %exception of @c at and @c operator[].\n    *\n-   *  This is a @e doubly @e linked %list.  Traversal up and down the %list\n-   *  requires linear time, but adding and removing elements (or @e nodes) is\n-   *  done in constant time, regardless of where the change takes place.\n-   *  Unlike std::vector and std::deque, random-access iterators are not\n-   *  provided, so subscripting ( @c [] ) access is not allowed.  For algorithms\n-   *  which only need sequential access, this lack makes no difference.\n+   *  This is a @e doubly @e linked %list.  Traversal up and down the\n+   *  %list requires linear time, but adding and removing elements (or\n+   *  @e nodes) is done in constant time, regardless of where the\n+   *  change takes place.  Unlike std::vector and std::deque,\n+   *  random-access iterators are not provided, so subscripting ( @c\n+   *  [] ) access is not allowed.  For algorithms which only need\n+   *  sequential access, this lack makes no difference.\n    *\n-   *  Also unlike the other standard containers, std::list provides specialized \n-   *  algorithms %unique to linked lists, such as splicing, sorting, and\n-   *  in-place reversal.\n+   *  Also unlike the other standard containers, std::list provides\n+   *  specialized algorithms %unique to linked lists, such as\n+   *  splicing, sorting, and in-place reversal.\n    *\n    *  @if maint\n    *  A couple points on memory allocation for list<Tp>:\n    *\n-   *  First, we never actually allocate a Tp, we allocate List_node<Tp>'s\n-   *  and trust [20.1.5]/4 to DTRT.  This is to ensure that after elements from\n-   *  %list<X,Alloc1> are spliced into %list<X,Alloc2>, destroying the memory of\n-   *  the second %list is a valid operation, i.e., Alloc1 giveth and Alloc2\n-   *  taketh away.\n+   *  First, we never actually allocate a Tp, we allocate\n+   *  List_node<Tp>'s and trust [20.1.5]/4 to DTRT.  This is to ensure\n+   *  that after elements from %list<X,Alloc1> are spliced into\n+   *  %list<X,Alloc2>, destroying the memory of the second %list is a\n+   *  valid operation, i.e., Alloc1 giveth and Alloc2 taketh away.\n    *\n    *  Second, a %list conceptually represented as\n    *  @code\n    *    A <---> B <---> C <---> D\n    *  @endcode\n-   *  is actually circular; a link exists between A and D.  The %list class\n-   *  holds (as its only data member) a private list::iterator pointing to\n-   *  @e D, not to @e A!  To get to the head of the %list, we start at the tail\n-   *  and move forward by one.  When this member iterator's next/previous\n-   *  pointers refer to itself, the %list is %empty.\n-   *  @endif\n+   *  is actually circular; a link exists between A and D.  The %list\n+   *  class holds (as its only data member) a private list::iterator\n+   *  pointing to @e D, not to @e A!  To get to the head of the %list,\n+   *  we start at the tail and move forward by one.  When this member\n+   *  iterator's next/previous pointers refer to itself, the %list is\n+   *  %empty.  @endif\n   */\n   template<typename _Tp, typename _Alloc = allocator<_Tp> >\n     class list : protected _List_base<_Tp, _Alloc>\n@@ -505,18 +509,19 @@ namespace std\n       { this->insert(begin(), __first, __last); }\n   \n     /**\n-     *  No explicit dtor needed as the _Base dtor takes care of things.\n-     *  The _Base dtor only erases the elements, and note that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n+     *  No explicit dtor needed as the _Base dtor takes care of\n+     *  things.  The _Base dtor only erases the elements, and note\n+     *  that if the elements themselves are pointers, the pointed-to\n+     *  memory is not touched in any way.  Managing the pointer is the\n+     *  user's responsibilty.\n     */\n   \n     /**\n      *  @brief  %List assignment operator.\n      *  @param  x  A %list of identical element and allocator types.\n      * \n-     *  All the elements of @a x are copied, but unlike the copy constructor,\n-     *  the allocator object is not copied.\n+     *  All the elements of @a x are copied, but unlike the copy\n+     *  constructor, the allocator object is not copied.\n     */\n     list&\n     operator=(const list& __x);\n@@ -526,13 +531,14 @@ namespace std\n      *  @param  n  Number of elements to be assigned.\n      *  @param  val  Value to be assigned.\n      *\n-     *  This function fills a %list with @a n copies of the given value.\n-     *  Note that the assignment completely changes the %list and that the\n-     *  resulting %list's size is the same as the number of elements assigned.\n-     *  Old data may be lost.\n+     *  This function fills a %list with @a n copies of the given\n+     *  value.  Note that the assignment completely changes the %list\n+     *  and that the resulting %list's size is the same as the number\n+     *  of elements assigned.  Old data may be lost.\n     */\n     void\n-    assign(size_type __n, const value_type& __val) { _M_fill_assign(__n, __val); }\n+    assign(size_type __n, const value_type& __val) \n+    { _M_fill_assign(__n, __val); }\n   \n     /**\n      *  @brief  Assigns a range to a %list.\n@@ -568,44 +574,50 @@ namespace std\n     begin() { return static_cast<_Node*>(this->_M_node._M_next); }\n   \n     /**\n-     *  Returns a read-only (constant) iterator that points to the first element\n-     *  in the %list.  Iteration is done in ordinary element order.\n+     *  Returns a read-only (constant) iterator that points to the\n+     *  first element in the %list.  Iteration is done in ordinary\n+     *  element order.\n     */\n     const_iterator\n     begin() const { return static_cast<_Node*>(this->_M_node._M_next); }\n   \n     /**\n-     *  Returns a read/write iterator that points one past the last element in\n-     *  the %list.  Iteration is done in ordinary element order.\n+     *  Returns a read/write iterator that points one past the last\n+     *  element in the %list.  Iteration is done in ordinary element\n+     *  order.\n     */\n     iterator\n     end() { return static_cast<_Node*>(&this->_M_node); }\n   \n     /**\n-     *  Returns a read-only (constant) iterator that points one past the last\n-     *  element in the %list.  Iteration is done in ordinary element order.\n+     *  Returns a read-only (constant) iterator that points one past\n+     *  the last element in the %list.  Iteration is done in ordinary\n+     *  element order.\n     */\n     const_iterator\n-    end() const { return const_cast<_Node *>(static_cast<const _Node*>(&this->_M_node)); }\n+    end() const \n+    { return const_cast<_Node *>(static_cast<const _Node*>(&this->_M_node)); }\n   \n     /**\n-     *  Returns a read/write reverse iterator that points to the last element in\n-     *  the %list.  Iteration is done in reverse element order.\n+     *  Returns a read/write reverse iterator that points to the last\n+     *  element in the %list.  Iteration is done in reverse element\n+     *  order.\n     */\n     reverse_iterator\n     rbegin() { return reverse_iterator(end()); }\n   \n     /**\n-     *  Returns a read-only (constant) reverse iterator that points to the last\n-     *  element in the %list.  Iteration is done in reverse element order.\n+     *  Returns a read-only (constant) reverse iterator that points to\n+     *  the last element in the %list.  Iteration is done in reverse\n+     *  element order.\n     */\n     const_reverse_iterator\n     rbegin() const { return const_reverse_iterator(end()); }\n   \n     /**\n-     *  Returns a read/write reverse iterator that points to one before the\n-     *  first element in the %list.  Iteration is done in reverse element\n-     *  order.\n+     *  Returns a read/write reverse iterator that points to one\n+     *  before the first element in the %list.  Iteration is done in\n+     *  reverse element order.\n     */\n     reverse_iterator\n     rend() { return reverse_iterator(begin()); }\n@@ -621,7 +633,8 @@ namespace std\n   \n     // [23.2.2.2] capacity\n     /**\n-     *  Returns true if the %list is empty.  (Thus begin() would equal end().)\n+     *  Returns true if the %list is empty.  (Thus begin() would equal\n+     *  end().)\n     */\n     bool\n     empty() const { return this->_M_node._M_next == &this->_M_node; }\n@@ -635,14 +648,14 @@ namespace std\n     max_size() const { return size_type(-1); }\n   \n     /**\n-     *  @brief  Resizes the %list to the specified number of elements.\n-     *  @param  new_size  Number of elements the %list should contain.\n-     *  @param  x  Data with which new elements should be populated.\n+     *  @brief Resizes the %list to the specified number of elements.\n+     *  @param new_size Number of elements the %list should contain.\n+     *  @param x Data with which new elements should be populated.\n      *\n-     *  This function will %resize the %list to the specified number of\n-     *  elements.  If the number is smaller than the %list's current size the\n-     *  %list is truncated, otherwise the %list is extended and new elements\n-     *  are populated with given data.\n+     *  This function will %resize the %list to the specified number\n+     *  of elements.  If the number is smaller than the %list's\n+     *  current size the %list is truncated, otherwise the %list is\n+     *  extended and new elements are populated with given data.\n     */\n     void\n     resize(size_type __new_size, const value_type& __x);\n@@ -652,9 +665,9 @@ namespace std\n      *  @param  new_size  Number of elements the %list should contain.\n      *\n      *  This function will resize the %list to the specified number of\n-     *  elements.  If the number is smaller than the %list's current size the\n-     *  %list is truncated, otherwise the %list is extended and new elements\n-     *  are default-constructed.\n+     *  elements.  If the number is smaller than the %list's current\n+     *  size the %list is truncated, otherwise the %list is extended\n+     *  and new elements are default-constructed.\n     */\n     void\n     resize(size_type __new_size) { this->resize(__new_size, value_type()); }\n@@ -675,8 +688,8 @@ namespace std\n     front() const { return *begin(); }\n   \n     /**\n-     *  Returns a read/write reference to the data at the last element of the\n-     *  %list.\n+     *  Returns a read/write reference to the data at the last element\n+     *  of the %list.\n     */\n     reference\n     back() { return *(--end()); }\n@@ -693,24 +706,26 @@ namespace std\n      *  @brief  Add data to the front of the %list.\n      *  @param  x  Data to be added.\n      *\n-     *  This is a typical stack operation.  The function creates an element at\n-     *  the front of the %list and assigns the given data to it.  Due to the\n-     *  nature of a %list this operation can be done in constant time, and\n-     *  does not invalidate iterators and references.\n+     *  This is a typical stack operation.  The function creates an\n+     *  element at the front of the %list and assigns the given data\n+     *  to it.  Due to the nature of a %list this operation can be\n+     *  done in constant time, and does not invalidate iterators and\n+     *  references.\n     */\n     void\n     push_front(const value_type& __x) { this->insert(begin(), __x); }\n   \n     /**\n      *  @brief  Removes first element.\n      *\n-     *  This is a typical stack operation.  It shrinks the %list by one.\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and only invalidates iterators/references to the element being\n-     *  removed.\n+     *  This is a typical stack operation.  It shrinks the %list by\n+     *  one.  Due to the nature of a %list this operation can be done\n+     *  in constant time, and only invalidates iterators/references to\n+     *  the element being removed.\n      *\n-     *  Note that no data is returned, and if the first element's data is\n-     *  needed, it should be retrieved before pop_front() is called.\n+     *  Note that no data is returned, and if the first element's data\n+     *  is needed, it should be retrieved before pop_front() is\n+     *  called.\n     */\n     void\n     pop_front() { this->erase(begin()); }\n@@ -719,24 +734,25 @@ namespace std\n      *  @brief  Add data to the end of the %list.\n      *  @param  x  Data to be added.\n      *\n-     *  This is a typical stack operation.  The function creates an element at\n-     *  the end of the %list and assigns the given data to it.  Due to the\n-     *  nature of a %list this operation can be done in constant time, and\n-     *  does not invalidate iterators and references.\n+     *  This is a typical stack operation.  The function creates an\n+     *  element at the end of the %list and assigns the given data to\n+     *  it.  Due to the nature of a %list this operation can be done\n+     *  in constant time, and does not invalidate iterators and\n+     *  references.\n     */\n     void\n     push_back(const value_type& __x) { this->insert(end(), __x); }\n   \n     /**\n      *  @brief  Removes last element.\n      *\n-     *  This is a typical stack operation.  It shrinks the %list by one.\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and only invalidates iterators/references to the element being\n-     *  removed.\n+     *  This is a typical stack operation.  It shrinks the %list by\n+     *  one.  Due to the nature of a %list this operation can be done\n+     *  in constant time, and only invalidates iterators/references to\n+     *  the element being removed.\n      *\n-     *  Note that no data is returned, and if the last element's data is\n-     *  needed, it should be retrieved before pop_back() is called.\n+     *  Note that no data is returned, and if the last element's data\n+     *  is needed, it should be retrieved before pop_back() is called.\n     */\n     void\n     pop_back()\n@@ -751,10 +767,10 @@ namespace std\n      *  @param  x  Data to be inserted.\n      *  @return  An iterator that points to the inserted data.\n      *\n-     *  This function will insert a copy of the given value before the specified\n-     *  location.\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and does not invalidate iterators and references.\n+     *  This function will insert a copy of the given value before the\n+     *  specified location.  Due to the nature of a %list this\n+     *  operation can be done in constant time, and does not\n+     *  invalidate iterators and references.\n     */\n     iterator\n     insert(iterator __position, const value_type& __x);\n@@ -765,11 +781,12 @@ namespace std\n      *  @param  n  Number of elements to be inserted.\n      *  @param  x  Data to be inserted.\n      *\n-     *  This function will insert a specified number of copies of the given data\n-     *  before the location specified by @a position.\n+     *  This function will insert a specified number of copies of the\n+     *  given data before the location specified by @a position.\n      *\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and does not invalidate iterators and references.\n+     *  Due to the nature of a %list this operation can be done in\n+     *  constant time, and does not invalidate iterators and\n+     *  references.\n     */\n     void\n     insert(iterator __position, size_type __n, const value_type& __x)\n@@ -781,16 +798,17 @@ namespace std\n      *  @param  first  An input iterator.\n      *  @param  last   An input iterator.\n      *\n-     *  This function will insert copies of the data in the range\n-     *  [@a first,@a last) into the %list before the location specified by @a\n-     *  position.\n+     *  This function will insert copies of the data in the range [@a\n+     *  first,@a last) into the %list before the location specified by\n+     *  @a position.\n      *\n      *  Due to the nature of a %list this operation can be done in constant\n      *  time, and does not invalidate iterators and references.\n     */\n     template<typename _InputIterator>\n       void\n-      insert(iterator __position, _InputIterator __first, _InputIterator __last)\n+      insert(iterator __position, _InputIterator __first, \n+\t     _InputIterator __last)\n       {\n         // Check whether it's an integral type.  If so, it's not an iterator.\n         typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n@@ -805,13 +823,12 @@ namespace std\n      *  This function will erase the element at the given position and thus\n      *  shorten the %list by one.\n      *\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and only invalidates iterators/references to the element being\n-     *  removed.\n-     *  The user is also cautioned that\n-     *  this function only erases the element, and that if the element is itself\n-     *  a pointer, the pointed-to memory is not touched in any way.  Managing\n-     *  the pointer is the user's responsibilty.\n+     *  Due to the nature of a %list this operation can be done in\n+     *  constant time, and only invalidates iterators/references to\n+     *  the element being removed.  The user is also cautioned that\n+     *  this function only erases the element, and that if the element\n+     *  is itself a pointer, the pointed-to memory is not touched in\n+     *  any way.  Managing the pointer is the user's responsibilty.\n     */\n     iterator\n     erase(iterator __position);\n@@ -824,16 +841,16 @@ namespace std\n      *  @return  An iterator pointing to the element pointed to by @a last\n      *           prior to erasing (or end()).\n      *\n-     *  This function will erase the elements in the range @a [first,last) and\n-     *  shorten the %list accordingly.\n+     *  This function will erase the elements in the range @a\n+     *  [first,last) and shorten the %list accordingly.\n      *\n-     *  Due to the nature of a %list this operation can be done in constant\n-     *  time, and only invalidates iterators/references to the element being\n-     *  removed.\n-     *  The user is also cautioned that\n-     *  this function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n+     *  Due to the nature of a %list this operation can be done in\n+     *  constant time, and only invalidates iterators/references to\n+     *  the element being removed.  The user is also cautioned that\n+     *  this function only erases the elements, and that if the\n+     *  elements themselves are pointers, the pointed-to memory is not\n+     *  touched in any way.  Managing the pointer is the user's\n+     *  responsibilty.\n     */\n     iterator\n     erase(iterator __first, iterator __last)\n@@ -847,18 +864,19 @@ namespace std\n      *  @brief  Swaps data with another %list.\n      *  @param  x  A %list of the same element and allocator types.\n      *\n-     *  This exchanges the elements between two lists in constant time.\n-     *  Note that the global std::swap() function is specialized such that\n-     *  std::swap(l1,l2) will feed to this function.\n+     *  This exchanges the elements between two lists in constant\n+     *  time.  Note that the global std::swap() function is\n+     *  specialized such that std::swap(l1,l2) will feed to this\n+     *  function.\n     */\n     void\n     swap(list& __x);\n   \n     /**\n-     *  Erases all the elements.  Note that this function only erases the\n-     *  elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n+     *  Erases all the elements.  Note that this function only erases\n+     *  the elements, and that if the elements themselves are\n+     *  pointers, the pointed-to memory is not touched in any way.\n+     *  Managing the pointer is the user's responsibilty.\n     */\n     void\n     clear() { _Base::__clear(); }\n@@ -869,8 +887,9 @@ namespace std\n      *  @param  position  Iterator referencing the element to insert before.\n      *  @param  x  Source list.\n      *\n-     *  The elements of @a x are inserted in constant time in front of the\n-     *  element referenced by @a position.  @a x becomes an empty list.\n+     *  The elements of @a x are inserted in constant time in front of\n+     *  the element referenced by @a position.  @a x becomes an empty\n+     *  list.\n     */\n     void\n     splice(iterator __position, list& __x)\n@@ -885,8 +904,8 @@ namespace std\n      *  @param  x  Source list.\n      *  @param  i  Iterator referencing the element to move.\n      *\n-     *  Removes the element in list @a x referenced by @a i and inserts it into the\n-     *  current list before @a position.\n+     *  Removes the element in list @a x referenced by @a i and\n+     *  inserts it into the current list before @a position.\n     */\n     void\n     splice(iterator __position, list&, iterator __i)\n@@ -904,8 +923,8 @@ namespace std\n      *  @param  first  Iterator referencing the start of range in x.\n      *  @param  last  Iterator referencing the end of range in x.\n      *\n-     *  Removes elements in the range [first,last) and inserts them before\n-     *  @a position in constant time.\n+     *  Removes elements in the range [first,last) and inserts them\n+     *  before @a position in constant time.\n      *\n      *  Undefined if @a position is in [first,last).\n    */\n@@ -920,11 +939,11 @@ namespace std\n      *  @brief  Remove all elements equal to value.\n      *  @param  value  The value to remove.\n      *\n-     *  Removes every element in the list equal to @a value.  Remaining\n-     *  elements stay in list order.  Note that this function only erases the\n-     *  elements, and that if the elements themselves are pointers, the\n-     *  pointed-to memory is not touched in any way.  Managing the pointer is\n-     *  the user's responsibilty.\n+     *  Removes every element in the list equal to @a value.\n+     *  Remaining elements stay in list order.  Note that this\n+     *  function only erases the elements, and that if the elements\n+     *  themselves are pointers, the pointed-to memory is not touched\n+     *  in any way.  Managing the pointer is the user's responsibilty.\n     */\n     void\n     remove(const _Tp& __value);\n@@ -933,11 +952,12 @@ namespace std\n      *  @brief  Remove all elements satisfying a predicate.\n      *  @param  Predicate  Unary predicate function or object.\n      *\n-     *  Removes every element in the list for which the predicate returns\n-     *  true.  Remaining elements stay in list order.  Note that this function\n-     *  only erases the elements, and that if the elements themselves are\n-     *  pointers, the pointed-to memory is not touched in any way.  Managing\n-     *  the pointer is the user's responsibilty.\n+     *  Removes every element in the list for which the predicate\n+     *  returns true.  Remaining elements stay in list order.  Note\n+     *  that this function only erases the elements, and that if the\n+     *  elements themselves are pointers, the pointed-to memory is not\n+     *  touched in any way.  Managing the pointer is the user's\n+     *  responsibilty.\n     */\n     template<typename _Predicate>\n       void\n@@ -946,11 +966,12 @@ namespace std\n     /**\n      *  @brief  Remove consecutive duplicate elements.\n      *\n-     *  For each consecutive set of elements with the same value, remove all\n-     *  but the first one.  Remaining elements stay in list order.  Note that\n-     *  this function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n+     *  For each consecutive set of elements with the same value,\n+     *  remove all but the first one.  Remaining elements stay in list\n+     *  order.  Note that this function only erases the elements, and\n+     *  that if the elements themselves are pointers, the pointed-to\n+     *  memory is not touched in any way.  Managing the pointer is the\n+     *  user's responsibilty.\n     */\n     void\n     unique();\n@@ -960,11 +981,12 @@ namespace std\n      *  @param  BinaryPredicate  Binary predicate function or object.\n      *\n      *  For each consecutive set of elements [first,last) that satisfy\n-     *  predicate(first,i) where i is an iterator in [first,last), remove all\n-     *  but the first one.  Remaining elements stay in list order.  Note that\n-     *  this function only erases the elements, and that if the elements\n-     *  themselves are pointers, the pointed-to memory is not touched in any\n-     *  way.  Managing the pointer is the user's responsibilty.\n+     *  predicate(first,i) where i is an iterator in [first,last),\n+     *  remove all but the first one.  Remaining elements stay in list\n+     *  order.  Note that this function only erases the elements, and\n+     *  that if the elements themselves are pointers, the pointed-to\n+     *  memory is not touched in any way.  Managing the pointer is the\n+     *  user's responsibilty.\n     */\n     template<typename _BinaryPredicate>\n       void\n@@ -975,9 +997,9 @@ namespace std\n      *  @param  x  Sorted list to merge.\n      *\n      *  Assumes that both @a x and this list are sorted according to\n-     *  operator<().  Merges elements of @a x into this list in sorted order,\n-     *  leaving @a x empty when complete.  Elements in this list precede\n-     *  elements in @a x that are equal.\n+     *  operator<().  Merges elements of @a x into this list in sorted\n+     *  order, leaving @a x empty when complete.  Elements in this\n+     *  list precede elements in @a x that are equal.\n     */\n     void\n     merge(list& __x);\n@@ -988,9 +1010,10 @@ namespace std\n      *  @param  StrictWeakOrdering  Comparison function definining sort order.\n      *\n      *  Assumes that both @a x and this list are sorted according to\n-     *  StrictWeakOrdering.  Merges elements of @a x into this list in sorted\n-     *  order, leaving @a x empty when complete.  Elements in this list precede\n-     *  elements in @a x that are equivalent according to StrictWeakOrdering().\n+     *  StrictWeakOrdering.  Merges elements of @a x into this list in\n+     *  sorted order, leaving @a x empty when complete.  Elements in\n+     *  this list precede elements in @a x that are equivalent\n+     *  according to StrictWeakOrdering().\n     */\n     template<typename _StrictWeakOrdering>\n       void\n@@ -1007,17 +1030,17 @@ namespace std\n     /**\n      *  @brief  Sort the elements.\n      *\n-     *  Sorts the elements of this list in NlogN time.  Equivalent elements\n-     *  remain in list order.\n+     *  Sorts the elements of this list in NlogN time.  Equivalent\n+     *  elements remain in list order.\n     */\n     void\n     sort();\n   \n     /**\n      *  @brief  Sort the elements according to comparison function.\n      *\n-     *  Sorts the elements of this list in NlogN time.  Equivalent elements\n-     *  remain in list order.\n+     *  Sorts the elements of this list in NlogN time.  Equivalent\n+     *  elements remain in list order.\n     */\n     template<typename _StrictWeakOrdering>\n       void\n@@ -1026,7 +1049,7 @@ namespace std\n   protected:\n     // Internal assign functions follow.\n   \n-    // called by the range assign to implement [23.1.1]/9\n+    // Called by the range assign to implement [23.1.1]/9\n     template<typename _Integer>\n       void\n       _M_assign_dispatch(_Integer __n, _Integer __val, __true_type)\n@@ -1035,20 +1058,21 @@ namespace std\n                        static_cast<value_type>(__val));\n       }\n   \n-    // called by the range assign to implement [23.1.1]/9\n+    // Called by the range assign to implement [23.1.1]/9\n     template<typename _InputIterator>\n       void\n-      _M_assign_dispatch(_InputIterator __first, _InputIterator __last, __false_type);\n+      _M_assign_dispatch(_InputIterator __first, _InputIterator __last, \n+\t\t\t __false_type);\n   \n-    // Called by assign(n,t), and the range assign when it turns out to be the\n-    // same thing.\n+    // Called by assign(n,t), and the range assign when it turns out\n+    // to be the same thing.\n     void\n     _M_fill_assign(size_type __n, const value_type& __val);\n   \n   \n     // Internal insert functions follow.\n   \n-    // called by the range insert to implement [23.1.1]/9\n+    // Called by the range insert to implement [23.1.1]/9\n     template<typename _Integer>\n       void\n       _M_insert_dispatch(iterator __pos, _Integer __n, _Integer __x,\n@@ -1058,7 +1082,7 @@ namespace std\n                        static_cast<value_type>(__x));\n       }\n   \n-    // called by the range insert to implement [23.1.1]/9\n+    // Called by the range insert to implement [23.1.1]/9\n     template<typename _InputIterator>\n       void\n       _M_insert_dispatch(iterator __pos,\n@@ -1069,8 +1093,8 @@ namespace std\n           insert(__pos, *__first);\n       }\n   \n-    // Called by insert(p,n,x), and the range insert when it turns out to be\n-    // the same thing.\n+    // Called by insert(p,n,x), and the range insert when it turns out\n+    // to be the same thing.\n     void\n     _M_fill_insert(iterator __pos, size_type __n, const value_type& __x)\n     {\n@@ -1105,9 +1129,9 @@ namespace std\n    *  @param  y  A %list of the same type as @a x.\n    *  @return  True iff the size and elements of the lists are equal.\n    *\n-   *  This is an equivalence relation.  It is linear in the size of the\n-   *  lists.  Lists are considered equivalent if their sizes are equal,\n-   *  and if corresponding elements compare equal.\n+   *  This is an equivalence relation.  It is linear in the size of\n+   *  the lists.  Lists are considered equivalent if their sizes are\n+   *  equal, and if corresponding elements compare equal.\n   */\n   template<typename _Tp, typename _Alloc>\n   inline bool\n@@ -1174,6 +1198,6 @@ namespace std\n     inline void\n     swap(list<_Tp, _Alloc>& __x, list<_Tp, _Alloc>& __y)\n     { __x.swap(__y); }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _LIST_H */"}, {"sha": "9895cad04460f215f321741eb82999ff6bcb0bd2", "filename": "libstdc++-v3/include/bits/stl_map.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_map.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,7 +63,7 @@\n \n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n   /**\n    *  @brief A standard container made up of (key,value) pairs, which can be\n@@ -653,6 +653,6 @@ namespace std\n     inline void\n     swap(map<_Key,_Tp,_Compare,_Alloc>& __x, map<_Key,_Tp,_Compare,_Alloc>& __y)\n     { __x.swap(__y); }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _MAP_H */"}, {"sha": "4d892283bce63d76253f9f019a159740d4ac5b9d", "filename": "libstdc++-v3/include/bits/stl_multimap.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multimap.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,7 +63,7 @@\n \n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n   // Forward declaration of operators < and ==, needed for friend declaration.\n   \n@@ -632,6 +632,6 @@ namespace std\n     swap(multimap<_Key,_Tp,_Compare,_Alloc>& __x,\n          multimap<_Key,_Tp,_Compare,_Alloc>& __y)\n     { __x.swap(__y); }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _MULTIMAP_H */"}, {"sha": "d85c910a4e0f2055bab2bcf602a4f69a6de196d0", "filename": "libstdc++-v3/include/bits/stl_multiset.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_multiset.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,7 +63,7 @@\n \n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n \n // Forward declaration of operators < and ==, needed for friend declaration.\n@@ -256,6 +256,6 @@ inline void swap(multiset<_Key,_Compare,_Alloc>& __x,\n   __x.swap(__y);\n }\n \n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _MULTISET_H */"}, {"sha": "7b901a54315081ca0f361a5aeee7847bf47791ce", "filename": "libstdc++-v3/include/bits/stl_numeric.h", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_numeric.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -61,6 +61,8 @@\n #ifndef _STL_NUMERIC_H\n #define _STL_NUMERIC_H 1\n \n+#include <debug/debug.h>\n+\n namespace std\n {\n \n@@ -70,6 +72,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \t__init = __init + *__first;\n@@ -83,6 +86,7 @@ namespace std\n     {\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       for ( ; __first != __last; ++__first)\n \t__init = __binary_op(__init, *__first);\n@@ -97,6 +101,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2)\n \t__init = __init + (*__first1 * *__first2);\n@@ -114,6 +119,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator1>)\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator2>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n \n       for ( ; __first1 != __last1; ++__first1, ++__first2)\n \t__init = __binary_op1(__init, __binary_op2(*__first1, *__first2));\n@@ -130,6 +136,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __result;\n       *__result = *__first;\n@@ -151,6 +158,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __result;\n       *__result = *__first;\n@@ -172,6 +180,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __result;\n       *__result = *__first;\n@@ -194,6 +203,7 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _ValueType>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last) return __result;\n       *__result = *__first;"}, {"sha": "441fc55ef4b2926e0fe266f3752a584dbbd48783", "filename": "libstdc++-v3/include/bits/stl_queue.h", "status": "modified", "additions": 290, "deletions": 250, "changes": 540, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_queue.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,20 +62,21 @@\n #define _QUEUE_H 1\n \n #include <bits/concept_check.h>\n+#include <debug/debug.h>\n \n namespace std\n {\n   // Forward declarations of operators < and ==, needed for friend declaration.\n+  template<typename _Tp, typename _Sequence = deque<_Tp> >\n+    class queue;\n   \n-  template <typename _Tp, typename _Sequence = deque<_Tp> >\n-  class queue;\n-  \n-  template <typename _Tp, typename _Seq>\n-  inline bool operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n-  \n-  template <typename _Tp, typename _Seq>\n-  inline bool operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n+  template<typename _Tp, typename _Seq>\n+    inline bool \n+    operator==(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n   \n+  template<typename _Tp, typename _Seq>\n+    inline bool \n+    operator<(const queue<_Tp,_Seq>&, const queue<_Tp,_Seq>&);\n   \n   /**\n    *  @brief  A standard container giving FIFO behavior.\n@@ -101,111 +102,133 @@ namespace std\n    *  which is a typedef for the second Sequence parameter, and @c push and\n    *  @c pop, which are standard %queue/FIFO operations.\n   */\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     class queue\n-  {\n-    // concept requirements\n-    typedef typename _Sequence::value_type _Sequence_value_type;\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-    __glibcxx_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n-    __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-    __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-  \n-    template <typename _Tp1, typename _Seq1>\n-    friend bool operator== (const queue<_Tp1, _Seq1>&,\n-                            const queue<_Tp1, _Seq1>&);\n-    template <typename _Tp1, typename _Seq1>\n-    friend bool operator< (const queue<_Tp1, _Seq1>&,\n-                           const queue<_Tp1, _Seq1>&);\n-  \n-  public:\n-    typedef typename _Sequence::value_type                value_type;\n-    typedef typename _Sequence::reference                 reference;\n-    typedef typename _Sequence::const_reference           const_reference;\n-    typedef typename _Sequence::size_type                 size_type;\n-    typedef          _Sequence                            container_type;\n-  \n-  protected:\n-    /**\n-     *  'c' is the underlying container.  Maintainers wondering why this isn't\n-     *  uglified as per style guidelines should note that this name is\n-     *  specified in the standard, [23.2.3.1].  (Why?  Presumably for the same\n-     *  reason that it's protected instead of private:  to allow derivation.\n-     *  But none of the other containers allow for derivation.  Odd.)\n-    */\n-    _Sequence c;\n-  \n-  public:\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    queue(const _Sequence& __c = _Sequence())\n-    : c(__c) {}\n-  \n-    /**\n-     *  Returns true if the %queue is empty.\n-    */\n-    bool\n-    empty() const { return c.empty(); }\n-  \n-    /**  Returns the number of elements in the %queue.  */\n-    size_type\n-    size() const { return c.size(); }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the first element of the\n-     *  %queue.\n-    */\n-    reference\n-    front() { return c.front(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %queue.\n-    */\n-    const_reference\n-    front() const { return c.front(); }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the last element of the\n-     *  %queue.\n-    */\n-    reference\n-    back() { return c.back(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the last\n-     *  element of the %queue.\n-    */\n-    const_reference\n-    back() const { return c.back(); }\n-  \n-    /**\n-     *  @brief  Add data to the end of the %queue.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical %queue operation.  The function creates an element at\n-     *  the end of the %queue and assigns the given data to it.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-    */\n-    void\n-    push(const value_type& __x) { c.push_back(__x); }\n-  \n-    /**\n-     *  @brief  Removes first element.\n-     *\n-     *  This is a typical %queue operation.  It shrinks the %queue by one.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-     *\n-     *  Note that no data is returned, and if the first element's data is\n-     *  needed, it should be retrieved before pop() is called.\n-    */\n-    void\n-    pop() { c.pop_front(); }\n-  };\n+    {\n+      // concept requirements\n+      typedef typename _Sequence::value_type _Sequence_value_type;\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires(_Sequence, _FrontInsertionSequenceConcept)\n+      __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n+      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+  \n+\ttemplate<typename _Tp1, typename _Seq1>\n+          friend bool \n+          operator==(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n+\n+      template<typename _Tp1, typename _Seq1>\n+        friend bool \n+        operator<(const queue<_Tp1, _Seq1>&, const queue<_Tp1, _Seq1>&);\n+  \n+    public:\n+      typedef typename _Sequence::value_type                value_type;\n+      typedef typename _Sequence::reference                 reference;\n+      typedef typename _Sequence::const_reference           const_reference;\n+      typedef typename _Sequence::size_type                 size_type;\n+      typedef          _Sequence                            container_type;\n+      \n+    protected:\n+      /**\n+       *  'c' is the underlying container.  Maintainers wondering why\n+       *  this isn't uglified as per style guidelines should note that\n+       *  this name is specified in the standard, [23.2.3.1].  (Why?\n+       *  Presumably for the same reason that it's protected instead\n+       *  of private: to allow derivation.  But none of the other\n+       *  containers allow for derivation.  Odd.)\n+       */\n+      _Sequence c;\n+      \n+    public:\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      queue(const _Sequence& __c = _Sequence()) : c(__c) {}\n+      \n+      /**\n+       *  Returns true if the %queue is empty.\n+       */\n+      bool\n+      empty() const { return c.empty(); }\n+      \n+      /**  Returns the number of elements in the %queue.  */\n+      size_type\n+      size() const { return c.size(); }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the first\n+       *  element of the %queue.\n+       */\n+      reference\n+      front() \n+      { \n+\t__glibcxx_requires_nonempty();\n+\treturn c.front(); \n+      }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %queue.\n+       */\n+      const_reference\n+      front() const \n+      { \n+\t__glibcxx_requires_nonempty();\n+\treturn c.front(); \n+      }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the last\n+       *  element of the %queue.\n+       */\n+      reference\n+      back() \n+      {\n+\t__glibcxx_requires_nonempty();\n+\treturn c.back(); \n+      }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the last\n+       *  element of the %queue.\n+       */\n+      const_reference\n+      back() const \n+      {\n+\t__glibcxx_requires_nonempty();\n+\treturn c.back(); \n+      }\n+      \n+      /**\n+       *  @brief  Add data to the end of the %queue.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical %queue operation.  The function creates an\n+       *  element at the end of the %queue and assigns the given data\n+       *  to it.  The time complexity of the operation depends on the\n+       *  underlying sequence.\n+       */\n+      void\n+      push(const value_type& __x) { c.push_back(__x); }\n+      \n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical %queue operation.  It shrinks the %queue by one.\n+       *  The time complexity of the operation depends on the underlying\n+       *  sequence.\n+       *\n+       *  Note that no data is returned, and if the first element's\n+       *  data is needed, it should be retrieved before pop() is\n+       *  called.\n+       */\n+      void\n+      pop() \n+      { \n+\t__glibcxx_requires_nonempty();\n+\tc.pop_front(); \n+      }\n+    };\n   \n   \n   /**\n@@ -219,9 +242,10 @@ namespace std\n    *  linear in the size of the sequences, and queues are considered equivalent\n    *  if their sequences compare equal.\n   */\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool \n-    operator==(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    operator==(const queue<_Tp,_Sequence>& __x, \n+\t       const queue<_Tp,_Sequence>& __y)\n     { return __x.c == __y.c; }\n   \n   /**\n@@ -230,39 +254,43 @@ namespace std\n    *  @param  y  A %queue of the same type as @a x.\n    *  @return  True iff @a x is lexicographically less than @a y.\n    *\n-   *  This is an total ordering relation.  Complexity and semantics depend on\n-   *  the underlying sequence type, but the expected rules are:  this relation\n-   *  is linear in the size of the sequences, the elements must be comparable\n-   *  with @c <, and std::lexicographical_compare() is usually used to make the\n+   *  This is an total ordering relation.  Complexity and semantics\n+   *  depend on the underlying sequence type, but the expected rules\n+   *  are: this relation is linear in the size of the sequences, the\n+   *  elements must be comparable with @c <, and\n+   *  std::lexicographical_compare() is usually used to make the\n    *  determination.\n   */\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool\n     operator<(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n     { return __x.c < __y.c; }\n   \n   /// Based on operator==\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool\n-    operator!=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    operator!=(const queue<_Tp,_Sequence>& __x, \n+\t       const queue<_Tp,_Sequence>& __y)\n     { return !(__x == __y); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool \n     operator>(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n     { return __y < __x; }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool \n-    operator<=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    operator<=(const queue<_Tp,_Sequence>& __x, \n+\t       const queue<_Tp,_Sequence>& __y)\n     { return !(__y < __x); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     inline bool \n-    operator>=(const queue<_Tp,_Sequence>& __x, const queue<_Tp,_Sequence>& __y)\n+    operator>=(const queue<_Tp,_Sequence>& __x, \n+\t       const queue<_Tp,_Sequence>& __y)\n     { return !(__x < __y); }\n   \n   \n@@ -272,157 +300,169 @@ namespace std\n    *  @ingroup Containers\n    *  @ingroup Sequences\n    *\n-   *  This is not a true container, but an @e adaptor.  It holds another\n-   *  container, and provides a wrapper interface to that container.  The\n-   *  wrapper is what enforces sorting and first-in-first-out %queue behavior.\n-   *  Very few of the standard container/sequence interface requirements are\n-   *  met (e.g., iterators).\n+   *  This is not a true container, but an @e adaptor.  It holds\n+   *  another container, and provides a wrapper interface to that\n+   *  container.  The wrapper is what enforces sorting and\n+   *  first-in-first-out %queue behavior.  Very few of the standard\n+   *  container/sequence interface requirements are met (e.g.,\n+   *  iterators).\n    *\n    *  The second template parameter defines the type of the underlying\n-   *  sequence/container.  It defaults to std::vector, but it can be any type\n-   *  that supports @c front(), @c push_back, @c pop_back, and random-access\n-   *  iterators, such as std::deque or an appropriate user-defined type.\n+   *  sequence/container.  It defaults to std::vector, but it can be\n+   *  any type that supports @c front(), @c push_back, @c pop_back,\n+   *  and random-access iterators, such as std::deque or an\n+   *  appropriate user-defined type.\n    *\n-   *  The third template parameter supplies the means of making priority\n-   *  comparisons.  It defaults to @c less<value_type> but can be anything\n-   *  defining a strict weak ordering.\n+   *  The third template parameter supplies the means of making\n+   *  priority comparisons.  It defaults to @c less<value_type> but\n+   *  can be anything defining a strict weak ordering.\n    *\n    *  Members not found in \"normal\" containers are @c container_type,\n-   *  which is a typedef for the second Sequence parameter, and @c push,\n-   *  @c pop, and @c top, which are standard %queue/FIFO operations.\n+   *  which is a typedef for the second Sequence parameter, and @c\n+   *  push, @c pop, and @c top, which are standard %queue/FIFO\n+   *  operations.\n    *\n-   *  @note  No equality/comparison operators are provided for %priority_queue.\n+   *  @note No equality/comparison operators are provided for\n+   *  %priority_queue.\n    *\n-   *  @note  Sorting of the elements takes place as they are added to, and\n-   *         removed from, the %priority_queue using the %priority_queue's\n-   *         member functions.  If you access the elements by other means, and\n-   *         change their data such that the sorting order would be different,\n-   *         the %priority_queue will not re-sort the elements for you.  (How\n-   *         could it know to do so?)\n+   *  @note Sorting of the elements takes place as they are added to,\n+   *  and removed from, the %priority_queue using the\n+   *  %priority_queue's member functions.  If you access the elements\n+   *  by other means, and change their data such that the sorting\n+   *  order would be different, the %priority_queue will not re-sort\n+   *  the elements for you.  (How could it know to do so?)\n   */\n-  template <typename _Tp, typename _Sequence = vector<_Tp>,\n+  template<typename _Tp, typename _Sequence = vector<_Tp>,\n             typename _Compare  = less<typename _Sequence::value_type> >\n     class priority_queue\n-  {\n-    // concept requirements\n-    typedef typename _Sequence::value_type _Sequence_value_type;\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-    __glibcxx_class_requires(_Sequence, _SequenceConcept)\n-    __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)\n-    __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-    __glibcxx_class_requires4(_Compare, bool, _Tp, _Tp, _BinaryFunctionConcept)\n-  \n-  public:\n-    typedef typename _Sequence::value_type                value_type;\n-    typedef typename _Sequence::reference                 reference;\n-    typedef typename _Sequence::const_reference           const_reference;\n-    typedef typename _Sequence::size_type                 size_type;\n-    typedef          _Sequence                            container_type;\n-  \n-  protected:\n-    //  See queue::c for notes on these names.\n-    _Sequence  c;\n-    _Compare   comp;\n-  \n-  public:\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    priority_queue(const _Compare& __x = _Compare(),\n-                   const _Sequence& __s = _Sequence()) \n-    : c(__s), comp(__x) \n-    { std::make_heap(c.begin(), c.end(), comp); }\n-  \n-    /**\n-     *  @brief  Builds a %queue from a range.\n-     *  @param  first  An input iterator.\n-     *  @param  last  An input iterator.\n-     *  @param  x  A comparison functor describing a strict weak ordering.\n-     *  @param  s  An initial sequence with which to start.\n-     * \n-     *  Begins by copying @a s, inserting a copy of the elements from\n-     *  @a [first,last) into the copy of @a s, then ordering the copy\n-     *  according to @a x.\n-     *\n-     *  For more information on function objects, see the documentation on\n-     *  @link s20_3_1_base functor base classes@endlink.\n-    */\n-    template <typename _InputIterator>\n-      priority_queue(_InputIterator __first, _InputIterator __last,\n-                     const _Compare& __x = _Compare(),\n-                     const _Sequence& __s = _Sequence())\n-      : c(__s), comp(__x)\n-      { \n-        c.insert(c.end(), __first, __last);\n-        std::make_heap(c.begin(), c.end(), comp);\n-      }\n-  \n-    /**\n-     *  Returns true if the %queue is empty.\n-    */\n-    bool\n-    empty() const { return c.empty(); }\n-  \n-    /**  Returns the number of elements in the %queue.  */\n-    size_type\n-    size() const { return c.size(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %queue.\n-    */\n-    const_reference\n-    top() const { return c.front(); }\n-  \n-    /**\n-     *  @brief  Add data to the %queue.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical %queue operation.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-    */\n-    void \n-    push(const value_type& __x) \n     {\n-      try \n+      // concept requirements\n+      typedef typename _Sequence::value_type _Sequence_value_type;\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires(_Sequence, _SequenceConcept)\n+      __glibcxx_class_requires(_Sequence, _RandomAccessContainerConcept)\n+      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Tp,_Tp,_BinaryFunctionConcept)\n+  \n+\tpublic:\n+      typedef typename _Sequence::value_type                value_type;\n+      typedef typename _Sequence::reference                 reference;\n+      typedef typename _Sequence::const_reference           const_reference;\n+      typedef typename _Sequence::size_type                 size_type;\n+      typedef          _Sequence                            container_type;\n+      \n+    protected:\n+      //  See queue::c for notes on these names.\n+      _Sequence  c;\n+      _Compare   comp;\n+      \n+    public:\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      priority_queue(const _Compare& __x = _Compare(), \n+\t\t     const _Sequence& __s = _Sequence()) \n+      : c(__s), comp(__x) \n+      { std::make_heap(c.begin(), c.end(), comp); }\n+  \n+      /**\n+       *  @brief  Builds a %queue from a range.\n+       *  @param  first  An input iterator.\n+       *  @param  last  An input iterator.\n+       *  @param  x  A comparison functor describing a strict weak ordering.\n+       *  @param  s  An initial sequence with which to start.\n+       * \n+       *  Begins by copying @a s, inserting a copy of the elements\n+       *  from @a [first,last) into the copy of @a s, then ordering\n+       *  the copy according to @a x.\n+       *\n+       *  For more information on function objects, see the\n+       *  documentation on @link s20_3_1_base functor base\n+       *  classes@endlink.\n+       */\n+      template<typename _InputIterator>\n+        priority_queue(_InputIterator __first, _InputIterator __last,\n+\t\t       const _Compare& __x = _Compare(),\n+\t\t       const _Sequence& __s = _Sequence())\n+\t: c(__s), comp(__x)\n+        { \n+\t  __glibcxx_requires_valid_range(__first, __last);\n+\t  c.insert(c.end(), __first, __last);\n+\t  std::make_heap(c.begin(), c.end(), comp);\n+\t}\n+      \n+      /**\n+       *  Returns true if the %queue is empty.\n+       */\n+      bool\n+      empty() const { return c.empty(); }\n+      \n+      /**  Returns the number of elements in the %queue.  */\n+      size_type\n+      size() const { return c.size(); }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %queue.\n+       */\n+      const_reference\n+      top() const \n+      {\n+\t__glibcxx_requires_nonempty();\n+\treturn c.front(); \n+      }\n+      \n+      /**\n+       *  @brief  Add data to the %queue.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical %queue operation.\n+       *  The time complexity of the operation depends on the underlying\n+       *  sequence.\n+       */\n+      void \n+      push(const value_type& __x) \n+      {\n+\ttry \n         {\n           c.push_back(__x); \n           std::push_heap(c.begin(), c.end(), comp);\n         }\n-      catch(...)\n+\tcatch(...)\n         {\n           c.clear();\n           __throw_exception_again; \n         }\n-    }\n-  \n-    /**\n-     *  @brief  Removes first element.\n-     *\n-     *  This is a typical %queue operation.  It shrinks the %queue by one.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-     *\n-     *  Note that no data is returned, and if the first element's data is\n-     *  needed, it should be retrieved before pop() is called.\n-    */\n-    void \n-    pop() \n-    {\n-      try \n+      }\n+      \n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical %queue operation.  It shrinks the %queue\n+       *  by one.  The time complexity of the operation depends on the\n+       *  underlying sequence.\n+       *\n+       *  Note that no data is returned, and if the first element's\n+       *  data is needed, it should be retrieved before pop() is\n+       *  called.\n+       */\n+      void \n+      pop() \n+      {\n+\t__glibcxx_requires_nonempty();\n+\ttry \n         {\n           std::pop_heap(c.begin(), c.end(), comp);\n           c.pop_back();\n         }\n-      catch(...)\n+\tcatch(...)\n         {\n           c.clear();\n           __throw_exception_again; \n         }\n-    }\n-  };\n+      }\n+    };\n   \n   // No equality/comparison operators are provided for priority_queue.\n } // namespace std"}, {"sha": "d1494b9db0319832c7aa7d26ee3780e0d6b88431", "filename": "libstdc++-v3/include/bits/stl_set.h", "status": "modified", "additions": 42, "deletions": 43, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_set.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -63,37 +63,36 @@\n \n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n-\n-// Forward declarations of operators < and ==, needed for friend declaration.\n-\n-template <class _Key, class _Compare = less<_Key>,\n-          class _Alloc = allocator<_Key> >\n-class set;\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator==(const set<_Key,_Compare,_Alloc>& __x, \n-                       const set<_Key,_Compare,_Alloc>& __y);\n-\n-template <class _Key, class _Compare, class _Alloc>\n-inline bool operator<(const set<_Key,_Compare,_Alloc>& __x, \n-                      const set<_Key,_Compare,_Alloc>& __y);\n-\n-\n-template <class _Key, class _Compare, class _Alloc>\n-class set\n-{\n-  // concept requirements\n-  __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n-  __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n-\n-public:\n-  // typedefs:\n-  typedef _Key     key_type;\n-  typedef _Key     value_type;\n-  typedef _Compare key_compare;\n-  typedef _Compare value_compare;\n+  // Forward declarations of operators < and ==, needed for friend declaration.\n+  template<class _Key, class _Compare = less<_Key>, \n+\t   class _Alloc = allocator<_Key> >\n+  class set;\n+\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool \n+    operator==(const set<_Key,_Compare,_Alloc>& __x, \n+\t       const set<_Key,_Compare,_Alloc>& __y);\n+\n+  template<class _Key, class _Compare, class _Alloc>\n+    inline bool \n+    operator<(const set<_Key,_Compare,_Alloc>& __x, \n+\t      const set<_Key,_Compare,_Alloc>& __y);\n+\n+  template<class _Key, class _Compare, class _Alloc>\n+    class set\n+    {\n+      // concept requirements\n+      __glibcxx_class_requires(_Key, _SGIAssignableConcept)\n+      __glibcxx_class_requires4(_Compare, bool, _Key, _Key, _BinaryFunctionConcept)\n+\t\n+\tpublic:\n+      // typedefs:\n+      typedef _Key     key_type;\n+      typedef _Key     value_type;\n+      typedef _Compare key_compare;\n+      typedef _Compare value_compare;\n private:\n   typedef _Rb_tree<key_type, value_type, \n                   _Identity<value_type>, key_compare, _Alloc> _Rep_type;\n@@ -118,12 +117,12 @@ class set\n                const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) {}\n \n-  template <class _InputIterator>\n+  template<class _InputIterator>\n   set(_InputIterator __first, _InputIterator __last)\n     : _M_t(_Compare(), allocator_type())\n     { _M_t.insert_unique(__first, __last); }\n \n-  template <class _InputIterator>\n+  template<class _InputIterator>\n   set(_InputIterator __first, _InputIterator __last, const _Compare& __comp,\n       const allocator_type& __a = allocator_type())\n     : _M_t(__comp, __a) { _M_t.insert_unique(__first, __last); }\n@@ -159,7 +158,7 @@ class set\n     typedef typename _Rep_type::iterator _Rep_iterator;\n     return _M_t.insert_unique((_Rep_iterator&)__position, __x);\n   }\n-  template <class _InputIterator>\n+  template<class _InputIterator>\n   void insert(_InputIterator __first, _InputIterator __last) {\n     _M_t.insert_unique(__first, __last);\n   }\n@@ -205,54 +204,54 @@ class set\n     return _M_t.equal_range(__x);\n   }\n \n-  template <class _K1, class _C1, class _A1>\n+  template<class _K1, class _C1, class _A1>\n   friend bool operator== (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n-  template <class _K1, class _C1, class _A1>\n+  template<class _K1, class _C1, class _A1>\n   friend bool operator< (const set<_K1,_C1,_A1>&, const set<_K1,_C1,_A1>&);\n };\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator==(const set<_Key,_Compare,_Alloc>& __x, \n                        const set<_Key,_Compare,_Alloc>& __y) {\n   return __x._M_t == __y._M_t;\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator<(const set<_Key,_Compare,_Alloc>& __x, \n                       const set<_Key,_Compare,_Alloc>& __y) {\n   return __x._M_t < __y._M_t;\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator!=(const set<_Key,_Compare,_Alloc>& __x, \n                        const set<_Key,_Compare,_Alloc>& __y) {\n   return !(__x == __y);\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator>(const set<_Key,_Compare,_Alloc>& __x, \n                       const set<_Key,_Compare,_Alloc>& __y) {\n   return __y < __x;\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator<=(const set<_Key,_Compare,_Alloc>& __x, \n                        const set<_Key,_Compare,_Alloc>& __y) {\n   return !(__y < __x);\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline bool operator>=(const set<_Key,_Compare,_Alloc>& __x, \n                        const set<_Key,_Compare,_Alloc>& __y) {\n   return !(__x < __y);\n }\n \n-template <class _Key, class _Compare, class _Alloc>\n+template<class _Key, class _Compare, class _Alloc>\n inline void swap(set<_Key,_Compare,_Alloc>& __x, \n                  set<_Key,_Compare,_Alloc>& __y) {\n   __x.swap(__y);\n }\n \n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _SET_H */"}, {"sha": "d72755a9fae76ed9a759e24116df3a3c4d729c54", "filename": "libstdc++-v3/include/bits/stl_stack.h", "status": "modified", "additions": 132, "deletions": 112, "changes": 244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_stack.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,20 +62,22 @@\n #define _STACK_H 1\n \n #include <bits/concept_check.h>\n+#include <debug/debug.h>\n \n namespace std\n {\n-  // Forward declarations of operators == and <, needed for friend declaration.\n+  // Forward declarations of operators == and <, needed for friend\n+  // declaration.\n+  template<typename _Tp, typename _Sequence = deque<_Tp> >\n+    class stack;\n   \n-  template <typename _Tp, typename _Sequence = deque<_Tp> >\n-  class stack;\n+  template<typename _Tp, typename _Seq>\n+    inline bool \n+    operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n   \n-  template <typename _Tp, typename _Seq>\n-  inline bool operator==(const stack<_Tp,_Seq>& __x,\n-\t                 const stack<_Tp,_Seq>& __y);\n-  \n-  template <typename _Tp, typename _Seq>\n-  inline bool operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n+  template<typename _Tp, typename _Seq>\n+    inline bool \n+    operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y);\n   \n   \n   /**\n@@ -89,104 +91,120 @@ namespace std\n    *  but does not define anything to do with iterators.  Very few of the\n    *  other standard container interfaces are defined.\n    *\n-   *  This is not a true container, but an @e adaptor.  It holds another\n-   *  container, and provides a wrapper interface to that container.  The\n-   *  wrapper is what enforces strict first-in-last-out %stack behavior.\n+   *  This is not a true container, but an @e adaptor.  It holds\n+   *  another container, and provides a wrapper interface to that\n+   *  container.  The wrapper is what enforces strict\n+   *  first-in-last-out %stack behavior.\n    *\n    *  The second template parameter defines the type of the underlying\n-   *  sequence/container.  It defaults to std::deque, but it can be any type\n-   *  that supports @c back, @c push_back, and @c pop_front, such as\n-   *  std::list, std::vector, or an appropriate user-defined type.\n+   *  sequence/container.  It defaults to std::deque, but it can be\n+   *  any type that supports @c back, @c push_back, and @c pop_front,\n+   *  such as std::list, std::vector, or an appropriate user-defined\n+   *  type.\n    *\n    *  Members not found in \"normal\" containers are @c container_type,\n-   *  which is a typedef for the second Sequence parameter, and @c push,\n-   *  @c pop, and @c top, which are standard %stack/FILO operations.\n+   *  which is a typedef for the second Sequence parameter, and @c\n+   *  push, @c pop, and @c top, which are standard %stack/FILO\n+   *  operations.\n   */\n-  template <typename _Tp, typename _Sequence>\n+  template<typename _Tp, typename _Sequence>\n     class stack\n-  {\n-    // concept requirements\n-    typedef typename _Sequence::value_type _Sequence_value_type;\n-    __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n-    __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n-    __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n-  \n-    template <typename _Tp1, typename _Seq1>\n-    friend bool operator== (const stack<_Tp1, _Seq1>&,\n-                            const stack<_Tp1, _Seq1>&);\n-    template <typename _Tp1, typename _Seq1>\n-    friend bool operator< (const stack<_Tp1, _Seq1>&,\n-                           const stack<_Tp1, _Seq1>&);\n-  \n-  public:\n-    typedef typename _Sequence::value_type                value_type;\n-    typedef typename _Sequence::reference                 reference;\n-    typedef typename _Sequence::const_reference           const_reference;\n-    typedef typename _Sequence::size_type                 size_type;\n-    typedef          _Sequence                            container_type;\n-  \n-  protected:\n-    //  See queue::c for notes on this name.\n-    _Sequence c;\n-  \n-  public:\n-    // XXX removed old def ctor, added def arg to this one to match 14882\n-    /**\n-     *  @brief  Default constructor creates no elements.\n-    */\n-    explicit\n-    stack(const _Sequence& __c = _Sequence())\n-    : c(__c) {}\n+    {\n+      // concept requirements\n+      typedef typename _Sequence::value_type _Sequence_value_type;\n+      __glibcxx_class_requires(_Tp, _SGIAssignableConcept)\n+      __glibcxx_class_requires(_Sequence, _BackInsertionSequenceConcept)\n+      __glibcxx_class_requires2(_Tp, _Sequence_value_type, _SameTypeConcept)\n   \n-    /**\n-     *  Returns true if the %stack is empty.\n-    */\n-    bool\n-    empty() const { return c.empty(); }\n-  \n-    /**  Returns the number of elements in the %stack.  */\n-    size_type\n-    size() const { return c.size(); }\n-  \n-    /**\n-     *  Returns a read/write reference to the data at the first element of the\n-     *  %stack.\n-    */\n-    reference\n-    top() { return c.back(); }\n-  \n-    /**\n-     *  Returns a read-only (constant) reference to the data at the first\n-     *  element of the %stack.\n-    */\n-    const_reference\n-    top() const { return c.back(); }\n+\ttemplate<typename _Tp1, typename _Seq1>\n+          friend bool \n+          operator==(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n+\n+      template<typename _Tp1, typename _Seq1>\n+        friend bool \n+        operator<(const stack<_Tp1, _Seq1>&, const stack<_Tp1, _Seq1>&);\n   \n-    /**\n-     *  @brief  Add data to the top of the %stack.\n-     *  @param  x  Data to be added.\n-     *\n-     *  This is a typical %stack operation.  The function creates an element at\n-     *  the top of the %stack and assigns the given data to it.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-    */\n-    void\n-    push(const value_type& __x) { c.push_back(__x); }\n+    public:\n+      typedef typename _Sequence::value_type                value_type;\n+      typedef typename _Sequence::reference                 reference;\n+      typedef typename _Sequence::const_reference           const_reference;\n+      typedef typename _Sequence::size_type                 size_type;\n+      typedef          _Sequence                            container_type;\n+      \n+    protected:\n+      //  See queue::c for notes on this name.\n+      _Sequence c;\n+      \n+    public:\n+      // XXX removed old def ctor, added def arg to this one to match 14882\n+      /**\n+       *  @brief  Default constructor creates no elements.\n+       */\n+      explicit\n+      stack(const _Sequence& __c = _Sequence()) : c(__c) {}\n+      \n+      /**\n+       *  Returns true if the %stack is empty.\n+       */\n+      bool\n+      empty() const { return c.empty(); }\n+      \n+      /**  Returns the number of elements in the %stack.  */\n+      size_type\n+      size() const { return c.size(); }\n+      \n+      /**\n+       *  Returns a read/write reference to the data at the first\n+       *  element of the %stack.\n+       */\n+      reference\n+      top() \n+      { \n+\t__glibcxx_requires_nonempty();\n+\treturn c.back(); \n+      }\n+      \n+      /**\n+       *  Returns a read-only (constant) reference to the data at the first\n+       *  element of the %stack.\n+       */\n+      const_reference\n+      top() const \n+      {\n+\t__glibcxx_requires_nonempty();\n+\treturn c.back(); \n+      }\n+      \n+      /**\n+       *  @brief  Add data to the top of the %stack.\n+       *  @param  x  Data to be added.\n+       *\n+       *  This is a typical %stack operation.  The function creates an\n+       *  element at the top of the %stack and assigns the given data\n+       *  to it.  The time complexity of the operation depends on the\n+       *  underlying sequence.\n+       */\n+      void\n+      push(const value_type& __x) { c.push_back(__x); }\n   \n-    /**\n-     *  @brief  Removes first element.\n-     *\n-     *  This is a typical %stack operation.  It shrinks the %stack by one.\n-     *  The time complexity of the operation depends on the underlying\n-     *  sequence.\n-     *\n-     *  Note that no data is returned, and if the first element's data is\n-     *  needed, it should be retrieved before pop() is called.\n-    */\n-    void\n-    pop() { c.pop_back(); }\n-  };\n+      /**\n+       *  @brief  Removes first element.\n+       *\n+       *  This is a typical %stack operation.  It shrinks the %stack\n+       *  by one.  The time complexity of the operation depends on the\n+       *  underlying sequence.\n+       *\n+       *  Note that no data is returned, and if the first element's\n+       *  data is needed, it should be retrieved before pop() is\n+       *  called.\n+       */\n+      void\n+      pop() \n+      {\n+\t__glibcxx_requires_nonempty();\n+\tc.pop_back(); \n+      }\n+    };\n   \n   \n   /**\n@@ -195,12 +213,13 @@ namespace std\n    *  @param  y  A %stack of the same type as @a x.\n    *  @return  True iff the size and elements of the stacks are equal.\n    *\n-   *  This is an equivalence relation.  Complexity and semantics depend on the\n-   *  underlying sequence type, but the expected rules are:  this relation is\n-   *  linear in the size of the sequences, and stacks are considered equivalent\n-   *  if their sequences compare equal.\n+   *  This is an equivalence relation.  Complexity and semantics\n+   *  depend on the underlying sequence type, but the expected rules\n+   *  are: this relation is linear in the size of the sequences, and\n+   *  stacks are considered equivalent if their sequences compare\n+   *  equal.\n   */\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator==(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return __x.c == __y.c; }\n@@ -211,37 +230,38 @@ namespace std\n    *  @param  y  A %stack of the same type as @a x.\n    *  @return  True iff @a x is lexicographically less than @a y.\n    *\n-   *  This is an total ordering relation.  Complexity and semantics depend on\n-   *  the underlying sequence type, but the expected rules are:  this relation\n-   *  is linear in the size of the sequences, the elements must be comparable\n-   *  with @c <, and std::lexicographical_compare() is usually used to make the\n+   *  This is an total ordering relation.  Complexity and semantics\n+   *  depend on the underlying sequence type, but the expected rules\n+   *  are: this relation is linear in the size of the sequences, the\n+   *  elements must be comparable with @c <, and\n+   *  std::lexicographical_compare() is usually used to make the\n    *  determination.\n   */\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator<(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return __x.c < __y.c; }\n   \n   /// Based on operator==\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator!=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return !(__x == __y); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator>(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return __y < __x; }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator<=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return !(__y < __x); }\n   \n   /// Based on operator<\n-  template <typename _Tp, typename _Seq>\n+  template<typename _Tp, typename _Seq>\n     inline bool\n     operator>=(const stack<_Tp,_Seq>& __x, const stack<_Tp,_Seq>& __y)\n     { return !(__x < __y); }"}, {"sha": "94d6a4a1317e6c8ed5ebda23826eb6b6388574cf", "filename": "libstdc++-v3/include/bits/stl_vector.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_vector.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -65,7 +65,7 @@\n #include <bits/functexcept.h>\n #include <bits/concept_check.h>\n \n-namespace std\n+namespace __gnu_norm\n {\n   /// @if maint Primary default version.  @endif\n   /**\n@@ -966,6 +966,6 @@ namespace std\n     inline void\n     swap(vector<_Tp,_Alloc>& __x, vector<_Tp,_Alloc>& __y)\n     { __x.swap(__y); }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _VECTOR_H */"}, {"sha": "cc67505dd69aa4c6289ba9ef95da7bd52e153cf3", "filename": "libstdc++-v3/include/bits/stream_iterator.h", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstream_iterator.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -37,6 +37,8 @@\n \n #pragma GCC system_header\n \n+#include <debug/debug.h>\n+\n namespace std\n {\n   template<typename _Tp, typename _CharT = char, \n@@ -65,18 +67,33 @@ namespace std\n       { }\n \n       const _Tp&\n-      operator*() const { return _M_value; }\n+      operator*() const \n+      { \n+\t__glibcxx_requires_cond(_M_ok,\n+\t\t\t\t_M_message(__gnu_debug::__msg_deref_istream)\n+\t\t\t\t._M_iterator(*this));\n+\treturn _M_value;\n+      }\n \n       const _Tp*\n       operator->() const { return &(operator*()); }\n \n       istream_iterator& \n       operator++() \n-      { _M_read(); return *this; }\n+      { \n+\t__glibcxx_requires_cond(_M_ok,\n+\t\t\t\t_M_message(__gnu_debug::__msg_inc_istream)\n+\t\t\t\t._M_iterator(*this));\n+\t_M_read(); \n+\treturn *this; \n+      }\n \n       istream_iterator \n       operator++(int)  \n       {\n+\t__glibcxx_requires_cond(_M_ok,\n+\t\t\t\t_M_message(__gnu_debug::__msg_inc_istream)\n+\t\t\t\t._M_iterator(*this)); \n \tistream_iterator __tmp = *this;\n \t_M_read();\n \treturn __tmp;\n@@ -138,6 +155,9 @@ namespace std\n       ostream_iterator& \n       operator=(const _Tp& __value) \n       { \n+\t__glibcxx_requires_cond(_M_stream != 0,\n+\t\t\t\t_M_message(__gnu_debug::__msg_output_ostream)\n+\t\t\t\t._M_iterator(*this));\n \t*_M_stream << __value;\n \tif (_M_string) *_M_stream << _M_string;\n \treturn *this;"}, {"sha": "d193de280c366c60f6c1589164ae25f26e5352fb", "filename": "libstdc++-v3/include/bits/streambuf_iterator.h", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstreambuf_iterator.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -39,6 +39,7 @@\n #pragma GCC system_header\n \n #include <streambuf>\n+#include <debug/debug.h>\n \n // NB: Should specialize copy, find algorithms for streambuf iterators.\n \n@@ -82,11 +83,23 @@ namespace std\n       // NB: The result of operator*() on an end of stream is undefined.\n       char_type \n       operator*() const\n-      { return traits_type::to_char_type(_M_get()); }\n+      { \n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+\t// Dereferencing a past-the-end istreambuf_iterator is a\n+\t// libstdc++ extension\n+\t__glibcxx_requires_cond(!_M_at_eof(),\n+\t\t\t\t_M_message(__gnu_debug::__msg_deref_istreambuf)\n+\t\t\t\t._M_iterator(*this)); \n+#endif\n+\treturn traits_type::to_char_type(_M_get()); \n+      }\n \t\n       istreambuf_iterator& \n       operator++()\n       { \n+\t__glibcxx_requires_cond(!_M_at_eof(),\n+\t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n+\t\t\t\t._M_iterator(*this)); \n \tconst int_type __eof = traits_type::eof();\n \tif (_M_sbuf && traits_type::eq_int_type(_M_sbuf->sbumpc(), __eof))\n \t  _M_sbuf = 0;\n@@ -98,6 +111,10 @@ namespace std\n       istreambuf_iterator\n       operator++(int)\n       {\n+\t__glibcxx_requires_cond(!_M_at_eof(),\n+\t\t\t\t_M_message(__gnu_debug::__msg_inc_istreambuf)\n+\t\t\t\t._M_iterator(*this)); \n+\n \tconst int_type __eof = traits_type::eof();\n \tistreambuf_iterator __old = *this;\n \tif (_M_sbuf\n@@ -116,8 +133,8 @@ namespace std\n       equal(const istreambuf_iterator& __b) const\n       {\n \tconst int_type __eof = traits_type::eof();\n-\tbool __thiseof = traits_type::eq_int_type(_M_get(), __eof);\n-\tbool __beof = traits_type::eq_int_type(__b._M_get(), __eof);\n+\tbool __thiseof = _M_at_eof();\n+\tbool __beof = __b._M_at_eof();\n \treturn (__thiseof && __beof || (!__thiseof && !__beof));\n       }\n \n@@ -137,6 +154,13 @@ namespace std\n \t  }\n \treturn __ret;\n       }\n+\n+      bool \n+      _M_at_eof() const\n+      {\n+\tconst int_type __eof = traits_type::eof();\n+\treturn traits_type::eq_int_type(_M_get(), __eof);\n+      }\n     };\n \n   template<typename _CharT, typename _Traits>"}, {"sha": "6342743266a5ea7103d9442d39aae9f291034580", "filename": "libstdc++-v3/include/bits/vector.tcc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fvector.tcc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -61,7 +61,7 @@\n #ifndef _VECTOR_TCC\n #define _VECTOR_TCC 1\n \n-namespace std\n+namespace __gnu_norm\n {\n   template<typename _Tp, typename _Alloc>\n     void\n@@ -432,7 +432,8 @@ namespace std\n             {\n               __new_finish = std::uninitialized_copy(iterator(this->_M_start),\n \t\t\t\t\t\t     __position, __new_start);\n-              __new_finish = std::uninitialized_copy(__first, __last, __new_finish);\n+              __new_finish = std::uninitialized_copy(__first, __last, \n+\t\t\t\t\t\t     __new_finish);\n               __new_finish = std::uninitialized_copy(__position,\n \t\t\t\t\t\t     iterator(this->_M_finish),\n \t\t\t\t\t\t     __new_finish);\n@@ -452,6 +453,6 @@ namespace std\n         }\n       }\n     }\n-} // namespace std\n+} // namespace __gnu_norm\n \n #endif /* _VECTOR_TCC */"}, {"sha": "3c474cf9d8219a315a082f06dc96d3f6a30bfce5", "filename": "libstdc++-v3/include/debug/bitset", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fbitset?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,298 @@\n+// Debugging bitset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_BITSET\n+#define _GLIBCXX_DEBUG_BITSET\n+\n+#include <bitset>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{ \n+  template<size_t _Nb> \n+    class bitset\n+    : public __gnu_norm::bitset<_Nb>, public __gnu_debug::_Safe_sequence_base\n+    {\n+      typedef  __gnu_norm::bitset<_Nb> \t   \t_Base;\n+      typedef __gnu_debug::_Safe_sequence_base  _Safe_base;\n+\n+    public:\n+      // bit reference:\n+      class reference \n+      : private _Base::reference, public __gnu_debug::_Safe_iterator_base\n+      {\n+\ttypedef typename _Base::reference _Base_ref;\n+\n+\tfriend class bitset;\n+\treference();\n+\t\n+\treference(const _Base_ref& __base, bitset* __seq) \n+\t: _Base_ref(__base), _Safe_iterator_base(__seq, false)\n+\t{ }\n+\n+      public:\n+\treference(const reference& __x)\n+\t: _Base_ref(__x), _Safe_iterator_base(__x, false)\n+\t{ }\n+\n+\treference& \n+\toperator=(bool __x)\n+\t{\n+\t  _GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_bad_bitset_write)\n+\t\t\t\t._M_iterator(*this));\n+\t  *static_cast<_Base_ref*>(this) = __x;\n+\t  return *this;\n+\t}\n+\n+\treference& \n+\toperator=(const reference& __x)\n+\t{\n+\t  _GLIBCXX_DEBUG_VERIFY(! __x._M_singular(),\n+\t\t\t       _M_message(::__gnu_debug::__msg_bad_bitset_read)\n+\t\t\t\t._M_iterator(__x));\n+\t  _GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_bad_bitset_write)\n+\t\t\t\t._M_iterator(*this));\n+\t  *static_cast<_Base_ref*>(this) = __x;\n+\t  return *this;\n+\t}\n+\t\n+\tbool \n+\toperator~() const\n+\t{\n+\t  _GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t       _M_message(::__gnu_debug::__msg_bad_bitset_read)\n+\t\t\t\t._M_iterator(*this));\n+\t  return ~(*static_cast<const _Base_ref*>(this));\n+\t}\n+\t\n+\toperator bool() const\n+\t{\n+\t  _GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_bad_bitset_read)\n+\t\t\t\t._M_iterator(*this));\n+\t  return *static_cast<const _Base_ref*>(this);\n+\t}\n+\t\n+\treference& \n+\tflip()\n+\t{\n+\t  _GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_bad_bitset_flip)\n+\t\t\t\t._M_iterator(*this));\n+\t  _Base_ref::flip();\n+\t  return *this;\n+\t}\n+      };\n+\n+      // 23.3.5.1 constructors:\n+      bitset() : _Base() { }\n+      \n+      bitset(unsigned long __val) : _Base(__val) { }\n+      \n+      template<typename _CharT, typename _Traits, typename _Allocator>\n+        explicit \n+        bitset(const std::basic_string<_CharT,_Traits,_Allocator>& __str,\n+\t       typename std::basic_string<_CharT,_Traits,_Allocator>::size_type\n+\t       __pos = 0,\n+\t       typename std::basic_string<_CharT,_Traits,_Allocator>::size_type\n+  \t       __n = (std::basic_string<_CharT,_Traits,_Allocator>::npos))\n+\t: _Base(__str, __pos, __n) { }\n+\n+      bitset(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+      // 23.3.5.2 bitset operations:\n+      bitset<_Nb>& \n+      operator&=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() &= __rhs;\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      operator|=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() != __rhs;\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      operator^=(const bitset<_Nb>& __rhs)\n+      {\n+\t_M_base() ^= __rhs;\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      operator<<=(size_t __pos)\n+      {\n+\t_M_base() <<= __pos;\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      operator>>=(size_t __pos)\n+      {\n+\t_M_base() >>= __pos;\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      set()\n+      {\n+\t_Base::set();\n+\treturn *this;\n+      }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 186. bitset::set() second parameter should be bool \n+      bitset<_Nb>& \n+      set(size_t __pos, bool __val = true)\n+      {\n+\t_Base::set(__pos, __val);\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      reset()\n+      {\n+\t_Base::reset();\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      reset(size_t __pos)\n+      {\n+\t_Base::reset(__pos);\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb> operator~() const { return bitset(~_M_base()); }\n+      \n+      bitset<_Nb>& \n+      flip()\n+      {\n+\t_Base::flip();\n+\treturn *this;\n+      }\n+      \n+      bitset<_Nb>& \n+      flip(size_t __pos)\n+      {\n+\t_Base::flip(__pos);\n+\treturn *this;\n+      }\n+      \n+      // element access:\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 11. Bitset minor problems \n+      reference \n+      operator[](size_t __pos)\n+      { \n+\t__glibcxx_check_subscript(__pos);\n+\treturn reference(_M_base()[__pos], this); \n+      }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 11. Bitset minor problems \n+      bool \n+      operator[](size_t __pos) const \n+      { \n+\t__glibcxx_check_subscript(__pos);\n+\treturn _M_base()[__pos]; \n+      }\n+      \n+      using _Base::to_ulong;\n+      \n+      template <typename _CharT, typename _Traits, typename _Allocator>\n+        std::basic_string<_CharT, _Traits, _Allocator> \n+        to_string() const\n+        { return _M_base().template to_string<_CharT, _Traits, _Allocator>(); }\n+      \n+      using _Base::count;\n+      using _Base::size;\n+      \n+      bool \n+      operator==(const bitset<_Nb>& __rhs) const\n+      { return _M_base() == __rhs; }\n+\n+      bool \n+      operator!=(const bitset<_Nb>& __rhs) const\n+      { return _M_base() != __rhs; }\n+      \n+      using _Base::test;\n+      using _Base::any;\n+      using _Base::none;\n+      \n+      bitset<_Nb> \n+      operator<<(size_t __pos) const\n+      { return bitset<_Nb>(_M_base() << __pos); }\n+      \n+      bitset<_Nb> \n+      operator>>(size_t __pos) const\n+      { return bitset<_Nb>(_M_base() >> __pos); }\n+      \n+      _Base&       \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+    };\n+ \n+  template<size_t _Nb>\n+    bitset<_Nb> \n+    operator&(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) &= __y; }\n+  \n+  template<size_t _Nb>\n+    bitset<_Nb> \n+    operator|(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) |= __y; }\n+\n+  template<size_t _Nb>\n+    bitset<_Nb> \n+    operator^(const bitset<_Nb>& __x, const bitset<_Nb>& __y)\n+    { return bitset<_Nb>(__x) ^= __y; }\n+\n+  template<typename _CharT, typename _Traits, size_t _Nb>\n+    std::basic_istream<_CharT, _Traits>&\n+    operator>>(std::basic_istream<_CharT, _Traits>& __is, bitset<_Nb>& __x)\n+    { return __is >> __x._M_base(); }\n+\n+  template<typename _CharT, typename _Traits, size_t _Nb>\n+    std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os, \n+\t       const bitset<_Nb>& __x)\n+    { return __os << __x._M_base(); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "edb19aa85c3c6ce099fd25893017e9227b441aee", "filename": "libstdc++-v3/include/debug/debug.h", "status": "added", "additions": 531, "deletions": 0, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdebug.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,531 @@\n+// Debugging support implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_DEBUG_H\n+#define _GLIBCXX_DEBUG_DEBUG_H 1\n+\n+/**\n+ * Macros used by the implementation to verify certain\n+ * properties. These macros may only be used directly by the debug\n+ * wrappers. Note that these are macros (instead of the more obviously\n+ * \"correct\" choice of making them functions) because we need line and\n+ * file information at the call site, to minimize the distance between\n+ * the user error and where the error is reported.\n+ *\n+ */\n+#define _GLIBCXX_DEBUG_VERIFY(_Condition,_ErrorMessage)\t\t\\\n+  do {\t\t\t\t\t\t\t\t\t\\\n+    if (! (_Condition))\t\t\t\t\t\t\t\\\n+      ::__gnu_debug::_Error_formatter::_M_at(__FILE__, __LINE__)\t\\\n+\t  ._ErrorMessage._M_error();\t\t\t\t\t\\\n+  } while (false)\n+\n+// Verify that [_First, _Last) forms a valid iterator range.\n+#define __glibcxx_check_valid_range(_First,_Last)\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__valid_range(_First, _Last),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_valid_range)\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that we can insert into *this with the iterator _Position.\n+ *  Insertion into a container at a specific position requires that\n+ *  the iterator be nonsingular (i.e., either dereferenceable or\n+ *  past-the-end) and that it reference the sequence we are inserting\n+ *  into. Note that this macro is only valid when the container is a\n+ *  _Safe_sequence and the iterator is a _Safe_iterator.\n+*/\n+#define __glibcxx_check_insert(_Position)\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can insert the values in the iterator range\n+ *  [_First, _Last) into *this with the iterator _Position.  Insertion\n+ *  into a container at a specific position requires that the iterator\n+ *  be nonsingular (i.e., either dereferenceable or past-the-end),\n+ *  that it reference the sequence we are inserting into, and that the\n+ *  iterator range [_First, Last) is a valid (possibly empty)\n+ *  range. Note that this macro is only valid when the container is a\n+ *  _Safe_sequence and the iterator is a _Safe_iterator.\n+ *\n+ *  @tbd We would like to be able to check for noninterference of\n+ *  _Position and the range [_First, _Last), but that can't (in\n+ *  general) be done.\n+*/\n+#define __glibcxx_check_insert_range(_Position,_First,_Last)\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(!_Position._M_singular(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_singular) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_insert_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can erase the element referenced by the iterator\n+ * _Position. We can erase the element if the _Position iterator is\n+ * dereferenceable and references this sequence.\n+*/\n+#define __glibcxx_check_erase(_Position)\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_dereferenceable(),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_bad)\t\\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position));\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_Position._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n+\t\t      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_Position, #_Position))\n+\n+/** Verify that we can erase the elements in the iterator range\n+ *  [_First, _Last). We can erase the elements if [_First, _Last) is a\n+ *  valid iterator range within this sequence.\n+*/\n+#define __glibcxx_check_erase_range(_First,_Last)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_First._M_attached_to(this),\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_erase_different) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+// Verify that the subscript _N is less than the container's size.\n+#define __glibcxx_check_subscript(_N)\t\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(_N < this->size(),\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_subscript_oob) \\\n+                      ._M_sequence(*this, \"this\")\t\t\t\\\n+\t\t      ._M_integer(_N, #_N)\t\t\t\t\\\n+\t\t      ._M_integer(this->size(), \"size\"))\n+\n+// Verify that the container is nonempty\n+#define __glibcxx_check_nonempty()\t\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(! this->empty(),\t\t\t\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_empty)\t\\\n+                      ._M_sequence(*this, \"this\"))\n+\n+// Verify that the < operator for elements in the sequence is a\n+// StrictWeakOrdering by checking that it is irreflexive.\n+#define __glibcxx_check_strict_weak_ordering(_First,_Last)\t\\\n+_GLIBCXX_DEBUG_ASSERT(_First == _Last || !(*_First < *_First))\n+\n+// Verify that the predicate is StrictWeakOrdering by checking that it\n+// is irreflexive.\n+#define __glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred)\t\\\n+_GLIBCXX_DEBUG_ASSERT(_First == _Last || !_Pred(*_First, *_First))\n+\n+\n+// Verify that the iterator range [_First, _Last) is sorted\n+#define __glibcxx_check_sorted(_First,_Last)\t\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+__glibcxx_check_strict_weak_ordering(_First,_Last);\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_unsorted)\t\\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that the iterator range [_First, _Last) is sorted by the\n+    predicate _Pred. */\n+#define __glibcxx_check_sorted_pred(_First,_Last,_Pred)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+__glibcxx_check_strict_weak_ordering_pred(_First,_Last,_Pred);\t        \\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_sorted(_First, _Last, _Pred), \\\n+\t\t      _M_message(::__gnu_debug::__msg_unsorted_pred) \\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Pred))\n+\n+/** Verify that the iterator range [_First, _Last) is partitioned\n+    w.r.t. the value _Value. */\n+#define __glibcxx_check_partitioned(_First,_Last,_Value)\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n+\t\t\t\t\t\t\t _Value),\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_unpartitioned) \\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last) \t\t\t\\\n+\t\t      ._M_string(#_Value))\n+\n+/** Verify that the iterator range [_First, _Last) is partitioned\n+    w.r.t. the value _Value and predicate _Pred. */\n+#define __glibcxx_check_partitioned_pred(_First,_Last,_Value,_Pred)\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::__gnu_debug::__check_partitioned(_First, _Last,\t\\\n+\t\t\t\t\t\t\t _Value, _Pred), \\\n+\t\t      _M_message(::__gnu_debug::__msg_unpartitioned_pred) \\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last) \t\t\t\\\n+\t\t      ._M_string(#_Pred)\t\t\t\t\\\n+                      ._M_string(#_Value))\n+\n+// Verify that the iterator range [_First, _Last) is a heap\n+#define __glibcxx_check_heap(_First,_Last)\t\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last),\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_not_heap)\t\\\n+\t\t      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last))\n+\n+/** Verify that the iterator range [_First, _Last) is a heap\n+    w.r.t. the predicate _Pred. */\n+#define __glibcxx_check_heap_pred(_First,_Last,_Pred)\t\t\t\\\n+__glibcxx_check_valid_range(_First,_Last);\t\t\t\t\\\n+_GLIBCXX_DEBUG_VERIFY(::std::__is_heap(_First, _Last, _Pred),\t\t\\\n+\t\t      _M_message(::__gnu_debug::__msg_not_heap_pred) \\\n+                      ._M_iterator(_First, #_First)\t\t\t\\\n+\t\t      ._M_iterator(_Last, #_Last)\t\t\t\\\n+\t\t      ._M_string(#_Pred))\n+\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+#  define __glibcxx_check_string(_String) _GLIBCXX_DEBUG_ASSERT(_String != 0)\n+#  define __glibcxx_check_string_len(_String,_Len) \\\n+       _GLIBCXX_DEBUG_ASSERT(_String != 0 || _Len == 0)\n+#else\n+#  define __glibcxx_check_string(_String)\n+#  define __glibcxx_check_string_len(_String,_Len)\n+#endif\n+\n+/** Macros used by the implementation outside of debug wrappers to\n+ *  verify certain properties. The __glibcxx_requires_xxx macros are\n+ *  merely wrappers around the __glibcxx_check_xxx wrappers when we\n+ *  are compiling with debug mode, but disappear when we are in\n+ *  release mode so that there is no checking performed in, e.g., the\n+ *  standard library algorithms.\n+*/\n+#ifdef _GLIBCXX_DEBUG\n+#  define _GLIBCXX_DEBUG_ASSERT(_Condition) assert(_Condition)\n+\n+#  ifdef _GLIBXX_DEBUG_PEDANTIC\n+#    define _GLIBCXX_DEBUG_PEDASSERT(_Condition) assert(_Condition)\n+#  else\n+#    define _GLIBCXX_DEBUG_PEDASSERT(_Condition)\n+#  endif\n+\n+#  define __glibcxx_requires_cond(_Cond,_Msg) _GLIBCXX_DEBUG_VERIFY(_Cond,_Msg)\n+#  define __glibcxx_requires_valid_range(_First,_Last) \\\n+     __glibcxx_check_valid_range(_First,_Last)\n+#  define __glibcxx_requires_sorted(_First,_Last) \\\n+     __glibcxx_check_sorted(_First,_Last)\n+#  define __glibcxx_requires_sorted_pred(_First,_Last,_Pred) \\\n+     __glibcxx_check_sorted_pred(_First,_Last,_Pred)\n+#  define __glibcxx_requires_partitioned(_First,_Last,_Value)\t\\\n+     __glibcxx_check_partitioned(_First,_Last,_Value)\n+#  define __glibcxx_requires_partitioned_pred(_First,_Last,_Value,_Pred) \\\n+     __glibcxx_check_partitioned_pred(_First,_Last,_Value,_Pred)\n+#  define __glibcxx_requires_heap(_First,_Last) \\\n+     __glibcxx_check_heap(_First,_Last)\n+#  define __glibcxx_requires_heap_pred(_First,_Last,_Pred) \\\n+     __glibcxx_check_heap_pred(_First,_Last,_Pred)\n+#  define __glibcxx_requires_nonempty() __glibcxx_check_nonempty()\n+#  define __glibcxx_requires_string(_String) __glibcxx_check_string(_String)\n+#  define __glibcxx_requires_string_len(_String,_Len)\t\\\n+     __glibcxx_check_string_len(_String,_Len)\n+#  define __glibcxx_requires_subscript(_N) __glibcxx_check_subscript(_N)\n+#else\n+#  define _GLIBCXX_DEBUG_ASSERT(_Condition)\n+#  define _GLIBCXX_DEBUG_PEDASSERT(_Condition)\n+#  define __glibcxx_requires_cond(_Cond,_Msg)\n+#  define __glibcxx_requires_valid_range(_First,_Last)\n+#  define __glibcxx_requires_sorted(_First,_Last)\n+#  define __glibcxx_requires_sorted_pred(_First,_Last,_Pred)\n+#  define __glibcxx_requires_partitioned(_First,_Last,_Value)\n+#  define __glibcxx_requires_partitioned_pred(_First,_Last,_Value,_Pred)\n+#  define __glibcxx_requires_heap(_First,_Last)\n+#  define __glibcxx_requires_heap_pred(_First,_Last,_Pred)\n+#  define __glibcxx_requires_nonempty()\n+#  define __glibcxx_requires_string(_String)\n+#  define __glibcxx_requires_string_len(_String,_Len)\n+#  define __glibcxx_requires_subscript(_N)\n+#endif \n+\n+#include <cassert> // TBD: temporary\n+\n+#include <stddef.h>                       // for ptrdiff_t\n+#include <bits/stl_iterator_base_types.h> // for iterator_traits, categories\n+#include <bits/type_traits.h>             // for _Is_integer\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Iterator, typename _Sequence> \n+    class _Safe_iterator;\n+\n+  // An arbitrary iterator pointer is not singular.\n+  inline bool \n+  __check_singular_aux(const void*) { return false; }\n+\n+  // We may have an iterator that derives from _Safe_iterator_base but isn't\n+  // a _Safe_iterator.\n+  template<typename _Iterator>\n+    inline bool\n+    __check_singular(_Iterator& __x)\n+    { return __gnu_debug::__check_singular_aux(&__x); }\n+\n+  /** Non-NULL pointers are nonsingular. */\n+  template<typename _Tp>\n+    inline bool\n+    __check_singular(const _Tp* __ptr)\n+    { return __ptr == 0; }\n+\n+  /** Safe iterators know if they are singular. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __check_singular(const _Safe_iterator<_Iterator, _Sequence>& __x)\n+    { return __x._M_singular(); }\n+\n+  /** Assume that some arbitrary iterator is dereferenceable, because we\n+      can't prove that it isn't. */\n+  template<typename _Iterator>\n+    inline bool\n+    __check_dereferenceable(_Iterator&)\n+    { return true; }\n+\n+  /** Non-NULL pointers are dereferenceable. */\n+  template<typename _Tp>\n+    inline bool\n+    __check_dereferenceable(const _Tp* __ptr)\n+    { return __ptr; }\n+\n+  /** Safe iterators know if they are singular. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    __check_dereferenceable(const _Safe_iterator<_Iterator, _Sequence>& __x)\n+    { return __x._M_dereferenceable(); }\n+\n+  /** If the distance between two random access iterators is\n+   *  nonnegative, assume the range is valid. \n+  */\n+  template<typename _RandomAccessIterator>\n+    inline bool\n+    __valid_range_aux2(const _RandomAccessIterator& __first, \n+\t\t       const _RandomAccessIterator& __last,\n+\t\t       std::random_access_iterator_tag)\n+    { return __last - __first >= 0; }\n+\n+  /** Can't test for a valid range with input iterators, because\n+   *  iteration may be destructive. So we just assume that the range\n+   *  is valid.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range_aux2(const _InputIterator&, const _InputIterator&,\n+\t\t       std::input_iterator_tag)\n+    { return true; }\n+\n+  /** We say that integral types for a valid range, and defer to other\n+   *  routines to realize what to do with integral types instead of\n+   *  iterators. \n+  */\n+  template<typename _Integral>\n+    inline bool\n+    __valid_range_aux(const _Integral&, const _Integral&, __true_type)\n+    { return true; }\n+\n+  /** We have iterators, so figure out what kind of iterators that are\n+   *  to see if we can check the range ahead of time.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range_aux(const _InputIterator& __first, \n+\t\t      const _InputIterator& __last, __false_type)\n+  {\n+    typedef typename std::iterator_traits<_InputIterator>::iterator_category\n+      _Category;\n+    return __gnu_debug::__valid_range_aux2(__first, __last, _Category()); \n+  }\n+\n+  /** Don't know what these iterators are, or if they are even\n+   *  iterators (we may get an integral type for InputIterator), so\n+   *  see if they are integral and pass them on to the next phase\n+   *  otherwise.\n+  */\n+  template<typename _InputIterator>\n+    inline bool\n+    __valid_range(const _InputIterator& __first, const _InputIterator& __last)\n+    { \n+      typedef typename _Is_integer<_InputIterator>::_Integral _Integral;\n+      return __gnu_debug::__valid_range_aux(__first, __last, _Integral());\n+    }\n+\n+  /** Safe iterators know how to check if they form a valid range. */\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool \n+    __valid_range(const _Safe_iterator<_Iterator, _Sequence>& __first,\n+\t\t  const _Safe_iterator<_Iterator, _Sequence>& __last)\n+    { return __first._M_valid_range(__last); }\n+\n+  /* Checks that [first, last) is a valid range, and then returns\n+   * __first. This routine is useful when we can't use a separate\n+   * assertion statement because, e.g., we are in a constructor. \n+  */\n+  template<typename _InputIterator>\n+    inline _InputIterator\n+    __check_valid_range(const _InputIterator& __first, \n+\t\t\tconst _InputIterator& __last)\n+    {\n+      _GLIBCXX_DEBUG_ASSERT(__gnu_debug::__valid_range(__first, __last));\n+      return __first;\n+    }\n+\n+  /** Checks that __s is non-NULL or __n == 0, and then returns __s. */\n+  template<typename _CharT, typename _Integer>\n+    inline const _CharT*\n+    __check_string(const _CharT* __s, const _Integer& __n)\n+    {\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+      _GLIBCXX_DEBUG_ASSERT(__s != 0 || __n == 0);\n+#endif\n+      return __s;\n+    }\n+\n+  /** Checks that __s is non-NULL and then returns __s. */\n+  template<typename _CharT>\n+    inline const _CharT*\n+    __check_string(const _CharT* __s)\n+    {\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+      _GLIBCXX_DEBUG_ASSERT(__s != 0);\n+#endif\n+      return __s;\n+    }\n+\n+  // Can't check if an input iterator sequence is sorted, because we\n+  // can't step through the sequence.\n+  template<typename _InputIterator>\n+    inline bool \n+    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n+                       std::input_iterator_tag)\n+    { return true; }\n+\n+  // Can verify if a forward iterator sequence is in fact sorted using\n+  // std::__is_sorted\n+  template<typename _ForwardIterator>\n+    inline bool\n+    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last,\n+                       std::forward_iterator_tag)\n+    { \n+      if (__first == __last)\n+        return true;\n+\n+      _ForwardIterator __next = __first;\n+      for (++__next; __next != __last; __first = __next, ++__next) {\n+        if (*__next < *__first)\n+          return false;\n+      }\n+\n+      return true;\n+    }\n+\n+  // Can't check if an input iterator sequence is sorted, because we can't step\n+  // through the sequence.\n+  template<typename _InputIterator, typename _Predicate>\n+    inline bool \n+    __check_sorted_aux(const _InputIterator&, const _InputIterator&,\n+                       _Predicate, std::input_iterator_tag)\n+    { return true; }\n+\n+  // Can verify if a forward iterator sequence is in fact sorted using\n+  // std::__is_sorted\n+  template<typename _ForwardIterator, typename _Predicate>\n+    inline bool\n+    __check_sorted_aux(_ForwardIterator __first, _ForwardIterator __last, \n+                       _Predicate __pred, std::forward_iterator_tag)\n+    { \n+      if (__first == __last)\n+        return true;\n+\n+      _ForwardIterator __next = __first;\n+      for (++__next; __next != __last; __first = __next, ++__next) {\n+        if (__pred(*__next, *__first))\n+          return false;\n+      }\n+\n+      return true;\n+    }\n+\n+  // Determine if a sequence is sorted.\n+  template<typename _InputIterator>\n+    inline bool\n+    __check_sorted(const _InputIterator& __first, const _InputIterator& __last)\n+    { \n+      typedef typename std::iterator_traits<_InputIterator>::iterator_category \n+        _Category;\n+      return __gnu_debug::__check_sorted_aux(__first, __last, _Category());\n+    }\n+\n+  template<typename _InputIterator, typename _Predicate>\n+    inline bool\n+    __check_sorted(const _InputIterator& __first, const _InputIterator& __last,\n+                   _Predicate __pred)\n+    { \n+      typedef typename std::iterator_traits<_InputIterator>::iterator_category \n+        _Category;\n+      return __gnu_debug::__check_sorted_aux(__first, __last, __pred,\n+\t\t\t\t\t     _Category());\n+    }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // 270. Binary search requirements overly strict \n+  // Determine if a sequence is partitioned w.r.t. this element.\n+  template<typename _ForwardIterator, typename _Tp>\n+    inline bool\n+    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\tconst _Tp& __value)\n+    {\n+      while (__first != __last && *__first < __value)\n+\t++__first;\n+      while (__first != __last && !(*__first < __value))\n+\t++__first;\n+      return __first == __last;\n+    }\n+\n+  // Determine if a sequence is partitioned w.r.t. this element.\n+  template<typename _ForwardIterator, typename _Tp, typename _Pred>\n+    inline bool\n+    __check_partitioned(_ForwardIterator __first, _ForwardIterator __last,\n+\t\t\tconst _Tp& __value, _Pred __pred)\n+    {\n+      while (__first != __last && __pred(*__first, __value))\n+\t++__first;\n+      while (__first != __last && !__pred(*__first, __value))\n+\t++__first;\n+      return __first == __last;\n+    }\n+} // namespace __gnu_debug\n+\n+#ifdef _GLIBCXX_DEBUG\n+// We need the error formatter\n+#  include <debug/formatter.h>\n+#endif\n+\n+#endif "}, {"sha": "b9d68af598a611b09e1c1243897b3ca3b1890c48", "filename": "libstdc++-v3/include/debug/deque", "status": "added", "additions": 386, "deletions": 0, "changes": 386, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fdeque?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,386 @@\n+// Debugging deque implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_DEQUE\n+#define _GLIBCXX_DEBUG_DEQUE 1\n+\n+#include <deque>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+    class deque \n+    : public  __gnu_norm::deque<_Tp, _Allocator>,\n+    public __gnu_debug::_Safe_sequence<deque<_Tp, _Allocator> >\n+    {\n+      typedef  __gnu_norm::deque<_Tp, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<deque> _Safe_base;\n+\n+    public:\n+      typedef typename _Allocator::reference        reference;\n+      typedef typename _Allocator::const_reference  const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,deque> \n+      \t\t\t\t\t\t    iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,deque>\n+\t\t\t\t\t\t     const_iterator;\n+      \n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      \n+      typedef _Tp        \t\t\t    value_type;\n+      typedef _Allocator \t\t\t    allocator_type;\n+      typedef typename _Allocator::pointer          pointer;\n+      typedef typename _Allocator::const_pointer    const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+      // 23.2.1.1 construct/copy/destroy:\n+      explicit deque(const _Allocator& __a = _Allocator())\n+      : _Base(__a) { }\n+\n+      explicit deque(size_type __n, const _Tp& __value = _Tp(),\n+\t\t     const _Allocator& __a = _Allocator())\n+      : _Base(__n, __value, __a) { }\n+\n+      template<class _InputIterator>\n+        deque(_InputIterator __first, _InputIterator __last,\n+\t      const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), __last, __a)\n+        { }\n+\n+      deque(const deque<_Tp,_Allocator>& __x) : _Base(__x), _Safe_base() { }\n+\n+      deque(const _Base& __x) : _Base(__x), _Safe_base() { }\n+      \n+      ~deque() { }\n+      \n+      deque<_Tp,_Allocator>& \n+      operator=(const deque<_Tp,_Allocator>& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+      \n+      template<class _InputIterator>\n+        void \n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::assign(__first, __last);\n+\t  this->_M_invalidate_all();\n+\t}\n+\n+      void \n+      assign(size_type __n, const _Tp& __t)\n+      {\n+\t_Base::assign(__n, __t);\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      using _Base::get_allocator;\n+      \n+      // iterators:\n+      iterator \n+      begin() \n+      { return iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      iterator \n+      end() \n+      { return iterator(_Base::end(), this); }\n+      \n+      const_iterator \n+      end() const \n+      { return const_iterator(_Base::end(), this); }\n+      \n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+      \n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+      \n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+      \n+      const_reverse_iterator \n+      rend() const\n+      { return const_reverse_iterator(begin()); }\n+      \n+      // 23.2.1.2 capacity:\n+      using _Base::size;\n+      using _Base::max_size;\n+      \n+      void \n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n+\t\n+\tbool __invalidate_all = __sz > this->size();\n+\tif (__sz < this->size())\n+\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t\n+\t_Base::resize(__sz, __c);\n+\t\n+\tif (__invalidate_all)\n+\t  this->_M_invalidate_all();\n+      }\n+      \n+      using _Base::empty;\n+      \n+      // element access:\n+      reference \n+      operator[](size_type __n)\n+      {\n+\t__glibcxx_check_subscript(__n);\n+\treturn _M_base()[__n];\n+      }\n+      \n+      const_reference \n+      operator[](size_type __n) const\n+      {\n+\t__glibcxx_check_subscript(__n);\n+\treturn _M_base()[__n];\n+      }\n+      \n+      using _Base::at;\n+      \n+      reference \n+      front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+      \n+      const_reference \n+      front() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+      \n+      reference \n+      back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+      \n+      const_reference \n+      back() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+      \n+      // 23.2.1.3 modifiers:\n+      void \n+      push_front(const _Tp& __x)\n+      {\n+\t_Base::push_front(__x);\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      void \n+      push_back(const _Tp& __x)\n+      {\n+\t_Base::push_back(__x);\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      iterator \n+      insert(iterator __position, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\ttypename _Base::iterator __res = _Base::insert(__position.base(), __x);\n+\tthis->_M_invalidate_all();\n+\treturn iterator(__res, this);\n+      }\n+      \n+      void \n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\t_Base::insert(__position.base(), __n, __x);\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      template<class _InputIterator>\n+        void \n+        insert(iterator __position, \n+\t       _InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_insert_range(__position, __first, __last);\n+\t  _Base::insert(__position.base(), __first, __last);\n+\t  this->_M_invalidate_all();\n+\t}\n+      \n+      void \n+      pop_front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = begin();\n+\t__victim._M_invalidate();\n+\t_Base::pop_front();\n+      }\n+      \n+      void \n+      pop_back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = end();\n+\t--__victim;\n+\t__victim._M_invalidate();\n+\t_Base::pop_back();\n+      }\n+      \n+      iterator \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tif (__position == begin() || __position == end()-1)\n+\t  {\n+\t    __position._M_invalidate();\n+\t    return iterator(_Base::erase(__position.base()), this);\n+\t  }\n+\telse\n+\t  {\n+\t    typename _Base::iterator __res = _Base::erase(__position.base());\n+\t    this->_M_invalidate_all();\n+\t    return iterator(__res, this);\n+\t  }\n+      }\n+      \n+      iterator \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tif (__first == begin() || __last == end()-1)\n+\t  {\n+\t    this->_M_detach_singular();\n+\t    for (iterator __position = __first; __position != __last; )\n+\t      {\n+\t\titerator __victim = __position++;\n+\t\t__victim._M_invalidate();\n+\t      }\n+\t    try \n+\t      { \n+\t\treturn iterator(_Base::erase(__first.base(), __last.base()),\n+\t\t\t\tthis); \n+\t      }\n+\t    catch (...)\n+\t      {\n+\t\tthis->_M_revalidate_singular();\n+\t\t__throw_exception_again;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    typename _Base::iterator __res = _Base::erase(__first.base(), \n+\t\t\t\t\t\t\t  __last.base());\n+\t    this->_M_invalidate_all();\n+\t    return iterator(__res, this);\n+\t  }\n+      }\n+      \n+      void \n+      swap(deque<_Tp,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      void \n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      _Base&       \n+      _M_base()       { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const deque<_Tp, _Alloc>& __lhs, \n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const deque<_Tp, _Alloc>& __lhs, \n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const deque<_Tp, _Alloc>& __lhs, const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const deque<_Tp, _Alloc>& __lhs, \n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const deque<_Tp, _Alloc>& __lhs, \n+\t       const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const deque<_Tp, _Alloc>& __lhs, const deque<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(deque<_Tp, _Alloc>& __lhs, deque<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "317ce21bc2573d9dedc5a0c9863bc29e571baca5", "filename": "libstdc++-v3/include/debug/formatter.h", "status": "added", "additions": 385, "deletions": 0, "changes": 385, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fformatter.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,385 @@\n+// Debug-mode error formatting implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_FORMATTER_H\n+#define _GLIBCXX_DEBUG_FORMATTER_H 1\n+\n+#include <typeinfo>\n+#include <debug/debug.h>\n+\n+namespace __gnu_debug\n+{\n+  /** Determine if the two types are the same. */\n+  template<typename _Type1, typename _Type2>\n+    struct __is_same\n+    {\n+      static const bool value = false;\n+    };\n+\n+  template<typename _Type>\n+    struct __is_same<_Type, _Type>\n+    {\n+      static const bool value = true;\n+    };\n+\n+  template<bool> struct __truth { };\n+\n+  class _Safe_sequence_base;\n+\n+  template<typename _Iterator, typename _Sequence> \n+    class _Safe_iterator;\n+\n+  template<typename _Sequence> \n+    class _Safe_sequence;\n+\n+  enum _Debug_msg_id\n+  {\n+    // General checks\n+    __msg_valid_range,\n+    __msg_insert_singular,\n+    __msg_insert_different,\n+    __msg_erase_bad,\n+    __msg_erase_different,\n+    __msg_subscript_oob,\n+    __msg_empty,\n+    __msg_unpartitioned,\n+    __msg_unpartitioned_pred,\n+    __msg_unsorted,\n+    __msg_unsorted_pred,\n+    __msg_not_heap,\n+    __msg_not_heap_pred,\n+    // std::bitset checks\n+    __msg_bad_bitset_write,\n+    __msg_bad_bitset_read,\n+    __msg_bad_bitset_flip,\n+    // std::list checks\n+    __msg_self_splice,\n+    __msg_splice_alloc,\n+    __msg_splice_bad,\n+    __msg_splice_other,\n+    __msg_splice_overlap,\n+    // iterator checks\n+    __msg_init_singular,\n+    __msg_init_copy_singular,\n+    __msg_init_const_singular,\n+    __msg_copy_singular,\n+    __msg_bad_deref,\n+    __msg_bad_inc,\n+    __msg_bad_dec,\n+    __msg_iter_subscript_oob,\n+    __msg_advance_oob,\n+    __msg_retreat_oob,\n+    __msg_iter_compare_bad,\n+    __msg_compare_different,\n+    __msg_iter_order_bad,\n+    __msg_order_different,\n+    __msg_distance_bad,\n+    __msg_distance_different,\n+    // istream_iterator\n+    __msg_deref_istream,\n+    __msg_inc_istream,\n+    // ostream_iterator\n+    __msg_output_ostream,\n+    // istreambuf_iterator\n+    __msg_deref_istreambuf,\n+    __msg_inc_istreambuf\n+  };\n+\n+  class _Error_formatter\n+  {\n+    /// Whether an iterator is constant, mutable, or unknown\n+    enum _Constness\n+    {\n+      __unknown_constness,\n+      __const_iterator,\n+      __mutable_iterator,\n+      __last_constness\n+    }; \n+\n+    // The state of the iterator (fine-grained), if we know it.\n+    enum _Iterator_state\n+    {\n+      __unknown_state,\n+      __singular,      // singular, may still be attached to a sequence\n+      __begin,         // dereferenceable, and at the beginning\n+      __middle,        // dereferenceable, not at the beginning\n+      __end,           // past-the-end, may be at beginning if sequence empty\n+      __last_state\n+    };\n+\n+    // Tags denoting the type of parameter for construction\n+    struct _Is_iterator { };\n+    struct _Is_sequence { };\n+\n+    // A parameter that may be referenced by an error message\n+    struct _Parameter\n+    {\n+      enum \n+      { \n+\t__unused_param, \n+\t__iterator, \n+\t__sequence, \n+\t__integer,\n+\t__string\n+      } _M_kind;\n+      \n+      union\n+      {\n+\t// When _M_kind == __iterator\n+\tstruct \n+\t{\n+\t  const char*      _M_name;      \n+\t  const void*      _M_address;   \n+\t  const type_info* _M_type;   \n+\t  _Constness       _M_constness;\n+\t  _Iterator_state  _M_state;\n+\t  const void*      _M_sequence;  \n+\t  const type_info* _M_seq_type;\n+\t} _M_iterator;\n+\t\n+\t// When _M_kind == __sequence\n+\tstruct\n+\t{\n+\t  const char*      _M_name;\n+\t  const void*      _M_address;\n+\t  const type_info* _M_type;\n+\t} _M_sequence;\n+\n+\t// When _M_kind == __integer\n+\tstruct\n+\t{\n+\t  const char* _M_name;\n+\t  long        _M_value;\n+\t} _M_integer;\n+\n+\t// When _M_kind == __string\n+\tstruct\n+\t{\n+\t  const char* _M_name;\n+\t  const char* _M_value;\n+\t} _M_string;\n+      } _M_variant;\n+\n+      _Parameter() : _M_kind(__unused_param) { }\n+      \n+      _Parameter(long __value, const char* __name) \n+      : _M_kind(__integer)\n+      { \n+\t_M_variant._M_integer._M_name = __name;\n+\t_M_variant._M_integer._M_value = __value; \n+      }\n+\n+      _Parameter(const char* __value, const char* __name)\n+      : _M_kind(__string)\n+      {\n+\t_M_variant._M_string._M_name = __name;\n+\t_M_variant._M_string._M_value = __value; \n+      }\n+\n+      template<typename _Iterator, typename _Sequence>\n+        _Parameter(const _Safe_iterator<_Iterator, _Sequence>& __it,\n+\t\t   const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator)\n+        {\n+\t  _M_variant._M_iterator._M_name = __name;\n+\t  _M_variant._M_iterator._M_address = &__it;\n+\t  _M_variant._M_iterator._M_type = &typeid(__it);\n+\t  _M_variant._M_iterator._M_constness = \n+\t    __is_same<_Safe_iterator<_Iterator, _Sequence>,\n+\t                         typename _Sequence::iterator>::\n+\t      value? __mutable_iterator : __const_iterator;\n+\t  _M_variant._M_iterator._M_sequence = __it._M_get_sequence();\n+\t  _M_variant._M_iterator._M_seq_type = &typeid(_Sequence);\n+\n+\t  if (__it._M_singular())\n+\t    _M_variant._M_iterator._M_state = __singular;\n+\t  else\n+\t    {\n+\t      bool __is_begin = __it._M_is_begin();\n+\t      bool __is_end = __it._M_is_end();\n+\t      if (__is_end)\n+\t\t_M_variant._M_iterator._M_state = __end;\n+\t      else if (__is_begin)\n+\t\t_M_variant._M_iterator._M_state = __begin;\n+\t      else\n+\t\t_M_variant._M_iterator._M_state = __middle;\n+\t    }\n+\t}\n+\n+      template<typename _Type>\n+        _Parameter(const _Type*& __it, const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator)\n+        {\n+\t  _M_variant._M_iterator._M_name = __name;\n+\t  _M_variant._M_iterator._M_address = &__it;\n+\t  _M_variant._M_iterator._M_type = &typeid(__it);\n+\t  _M_variant._M_iterator._M_constness = __mutable_iterator;\n+\t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n+\t  _M_variant._M_iterator._M_sequence = 0;\n+\t  _M_variant._M_iterator._M_seq_type = 0;\n+\t}\n+\n+      template<typename _Type>\n+        _Parameter(_Type*& __it, const char* __name, _Is_iterator)\n+        : _M_kind(__iterator)\n+        {\n+\t  _M_variant._M_iterator._M_name = __name;\n+\t  _M_variant._M_iterator._M_address = &__it;\n+\t  _M_variant._M_iterator._M_type = &typeid(__it);\n+\t  _M_variant._M_iterator._M_constness = __const_iterator;\n+\t  _M_variant._M_iterator._M_state = __it? __unknown_state : __singular;\n+\t  _M_variant._M_iterator._M_sequence = 0;\n+\t  _M_variant._M_iterator._M_seq_type = 0;\n+\t}\n+      \n+      template<typename _Iterator>\n+        _Parameter(const _Iterator& __it, const char* __name, _Is_iterator)\n+\t: _M_kind(__iterator)\n+        {\n+\t  _M_variant._M_iterator._M_name = __name;\n+\t  _M_variant._M_iterator._M_address = &__it;\n+\t  _M_variant._M_iterator._M_type = &typeid(__it);\n+\t  _M_variant._M_iterator._M_constness = __unknown_constness;\n+\t  _M_variant._M_iterator._M_state = \n+\t    __gnu_debug::__check_singular(__it)? __singular : __unknown_state;\n+\t  _M_variant._M_iterator._M_sequence = 0;\n+\t  _M_variant._M_iterator._M_seq_type = 0;\n+\t}\n+\n+      template<typename _Sequence>\n+        _Parameter(const _Safe_sequence<_Sequence>& __seq,\n+\t\t   const char* __name, _Is_sequence)\n+\t: _M_kind(__sequence)\n+        {\n+\t  _M_variant._M_sequence._M_name = __name;\n+\t  _M_variant._M_sequence._M_address = \n+\t    static_cast<const _Sequence*>(&__seq);\n+\t  _M_variant._M_sequence._M_type = &typeid(_Sequence);\n+\t}\n+\n+      template<typename _Sequence>\n+        _Parameter(const _Sequence& __seq, const char* __name, _Is_sequence)\n+\t: _M_kind(__sequence)\n+        {\n+\t  _M_variant._M_sequence._M_name = __name;\n+\t  _M_variant._M_sequence._M_address = &__seq;\n+\t  _M_variant._M_sequence._M_type = &typeid(_Sequence);\n+\t}\n+      \n+      void\n+      _M_print_field(const _Error_formatter* __formatter, \n+\t\t     const char* __name) const;\n+\t\t\t\t\t \n+      void\n+      _M_print_description(const _Error_formatter* __formatter) const;\n+    };\n+\n+    friend struct _Parameter;\n+\n+  public:    \n+    template<typename _Iterator>\n+      const _Error_formatter&\n+      _M_iterator(const _Iterator& __it, const char* __name = 0)  const\n+      {\n+\tif (_M_num_parameters < __max_parameters)\n+\t  _M_parameters[_M_num_parameters++] = _Parameter(__it, __name,\n+\t\t\t\t\t\t\t  _Is_iterator());\n+\treturn *this;\n+      }\n+\n+    const _Error_formatter&\n+    _M_integer(long __value, const char* __name = 0) const\n+    {\n+      if (_M_num_parameters < __max_parameters)\n+\t_M_parameters[_M_num_parameters++] = _Parameter(__value, __name);\n+      return *this;\n+    }\n+\n+    const _Error_formatter&\n+    _M_string(const char* __value, const char* __name = 0) const\n+    {\n+      if (_M_num_parameters < __max_parameters)\n+\t_M_parameters[_M_num_parameters++] = _Parameter(__value, __name);\n+      return *this;\n+    }\n+\n+    template<typename _Sequence>\n+      const _Error_formatter&\n+      _M_sequence(const _Sequence& __seq, const char* __name = 0) const\n+      {\n+\tif (_M_num_parameters < __max_parameters)\n+\t  _M_parameters[_M_num_parameters++] = _Parameter(__seq, __name, \n+\t\t\t\t\t\t\t  _Is_sequence());\n+\treturn *this;\n+      }\n+\n+    const _Error_formatter&\n+    _M_message(const char* __text) const\n+    { _M_text = __text; return *this; }\n+\n+    const _Error_formatter&\n+    _M_message(_Debug_msg_id __id) const;\n+\n+    void \n+    _M_error() const;\n+\n+  private:\n+    _Error_formatter(const char* __file, size_t __line)\n+    : _M_file(__file), _M_line(__line), _M_num_parameters(0), _M_text(0),\n+      _M_max_length(78), _M_column(1), _M_first_line(true), _M_wordwrap(false)\n+    { }\n+\n+    void \n+    _M_print_word(const char* __word) const;\n+\n+    void \n+    _M_print_string(const char* __string) const;\n+\n+    enum { __max_parameters = 9 };\n+\n+    const char*         _M_file;\n+    size_t              _M_line;\n+    mutable _Parameter  _M_parameters[__max_parameters];\n+    mutable size_t      _M_num_parameters;\n+    mutable const char* _M_text;\n+    mutable size_t      _M_max_length;\n+    enum { _M_indent = 4 } ;\n+    mutable size_t      _M_column;\n+    mutable bool        _M_first_line;\n+    mutable bool        _M_wordwrap;\n+\n+  public:\n+    static _Error_formatter\n+    _M_at(const char* __file, size_t __line)\n+    { return _Error_formatter(__file, __line); }\n+  };\n+} // namespace __gnu_debug\n+\n+#endif "}, {"sha": "570a9af6b6920d6852f3d3aacab36c669bdb7b91", "filename": "libstdc++-v3/include/debug/hash_map", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,38 @@\n+// Debugging hash_map/hash_multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_MAP\n+#define _GLIBCXX_DEBUG_HASH_MAP 1\n+\n+#include <hash_map>\n+#include <debug/dbg_hash_map.h>\n+#include <debug/dbg_hash_multimap.h>\n+\n+#endif"}, {"sha": "5ca102ad68ab06fc9001e401cce80f75383cf2c7", "filename": "libstdc++-v3/include/debug/hash_map.h", "status": "added", "additions": 270, "deletions": 0, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_map.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,270 @@\n+// Debugging hash_map implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_MAP_H\n+#define _GLIBCXX_DEBUG_HASH_MAP_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Value, typename _Tp,\n+\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n+\t   typename _EqualKey = std::equal_to<_Value>,\n+\t   typename _Alloc = std::allocator<_Value> >\n+    class hash_map\n+    : public __gnu_cxx::hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<hash_map<_Value, _Tp, _HashFcn,\n+\t\t\t\t\t\t _EqualKey, _Alloc> >\n+    {\n+      typedef __gnu_cxx::hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc> \n+      \t\t\t\t\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_sequence<hash_map> \t_Safe_base;\n+\n+    public:\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::data_type       data_type;\n+      typedef typename _Base::mapped_type     mapped_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::pointer         pointer;\n+      typedef typename _Base::const_pointer   const_pointer;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, hash_map>\n+      \t\t\t\t\t      iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, \n+\t\t\t\t\t  hash_map>\n+      \t\t\t\t\t      const_iterator;\n+      \n+      typedef typename _Base::allocator_type  allocator_type;\n+\n+      using _Base::hash_funct;\n+      using _Base::key_eq;\n+      using _Base::get_allocator;\n+      \n+      hash_map() { }\n+      \n+      explicit hash_map(size_type __n) : _Base(__n) { }\n+      \n+      hash_map(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n+\n+      hash_map(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t       const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a) { }\n+    \n+      template<typename _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l)\n+        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n+\n+      template<typename _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n+\n+      template<typename _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf)\n+        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n+\n+      template<typename _InputIterator>\n+        hash_map(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf, const key_equal& __eql,\n+\t\t const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n+\t\t__eql, __a) { }\n+\n+      hash_map(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+      using _Base::size;\n+      using _Base::max_size;\n+      using _Base::empty;\n+      \n+      void \n+      swap(hash_map& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      iterator \n+      begin() { return iterator(_Base::begin(), this); }\n+\n+      iterator \n+      end() { return iterator(_Base::end(),   this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      end() const \n+      { return const_iterator(_Base::end(),   this); }\n+      \n+      std::pair<iterator, bool> \n+      insert(const value_type& __obj)\n+      { \n+\tstd::pair<typename _Base::iterator, bool> __res = _Base::insert(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+      \n+      template <typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last) \n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first.base(), __last.base());\n+\t}\n+\n+\n+      std::pair<iterator, bool> \n+      insert_noresize(const value_type& __obj)\n+      { \n+\tstd::pair<typename _Base::iterator, bool> __res = \n+\t                                        _Base::insert_noresize(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+      \n+      iterator \n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+      \n+      const_iterator \n+      find(const key_type& __key) const \n+      { return const_iterator(_Base::find(__key), this); }\n+      \n+      using _Base::operator[];\n+      using _Base::count;\n+      \n+      std::pair<iterator, iterator> \n+      equal_range(const key_type& __key)\n+      { \n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res = \n+\t                  _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+      \n+      std::pair<const_iterator, const_iterator> \n+      equal_range(const key_type& __key) const\n+      { \n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res = \n+\t_Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+      \n+      size_type \n+      erase(const key_type& __key) \n+      {\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+  \t  return this->erase(__victim), 1;\n+\telse\n+\t  return 0;\n+      }\n+      \n+      void \n+      erase(iterator __it) \n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\t_Base::erase(__it.base());\n+      }\n+      \n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\t_Base::erase(__first.base(), __last.base());\n+      }\n+      \n+      void \n+      clear() \n+      { \n+\t_Base::clear();\n+\tthis->_M_invalidate_all(); \n+      }\n+      \n+      using _Base::resize;\n+      using _Base::bucket_count;\n+      using _Base::max_bucket_count;\n+      using _Base::elems_in_bucket;\n+      \n+      _Base&       \n+      _M_base()       { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+      \n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+  \n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline bool\n+    operator==(const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t       const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline bool\n+    operator!=(const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t       const hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline void\n+    swap(hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t hash_map<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif "}, {"sha": "dd453d61c72bbf095ad1ca3f31536bc3e1b5d2c8", "filename": "libstdc++-v3/include/debug/hash_multimap.h", "status": "added", "additions": 261, "deletions": 0, "changes": 261, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multimap.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,261 @@\n+// Debugging hash_multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_MULTIMAP_H\n+#define _GLIBCXX_DEBUG_HASH_MULTIMAP_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Value, typename _Tp,\n+\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n+\t   typename _EqualKey = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n+    class hash_multimap\n+    : public __gnu_cxx::hash_multimap<_Value,_Tp,_HashFcn, _EqualKey,_Alloc>,\n+      public __gnu_debug::_Safe_sequence<hash_multimap<_Value, _Tp, _HashFcn,\n+\t\t\t\t\t\t       _EqualKey, _Alloc> >\n+    {\n+      typedef __gnu_cxx::hash_multimap<_Value,_Tp,_HashFcn, _EqualKey,_Alloc>\n+      \t\t\t\t\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_sequence<hash_multimap> _Safe_base;\n+\n+  public:\n+      typedef typename _Base::key_type        \t\tkey_type;\n+      typedef typename _Base::data_type       \t\tdata_type;\n+      typedef typename _Base::mapped_type     \t\tmapped_type;\n+      typedef typename _Base::value_type      \t\tvalue_type;\n+      typedef typename _Base::hasher          \t\thasher;\n+      typedef typename _Base::key_equal       \t\tkey_equal;\n+      typedef typename _Base::size_type       \t\tsize_type;\n+      typedef typename _Base::difference_type \t\tdifference_type;\n+      typedef typename _Base::pointer         \t\tpointer;\n+      typedef typename _Base::const_pointer   \t\tconst_pointer;\n+      typedef typename _Base::reference       \t\treference;\n+      typedef typename _Base::const_reference \t\tconst_reference;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, \n+\t\t\t\t\t  hash_multimap> iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  hash_multimap> const_iterator;\n+\n+      typedef typename _Base::allocator_type              allocator_type;\n+\n+      using _Base::hash_funct;\n+      using _Base::key_eq;\n+      using _Base::get_allocator;\n+      \n+      hash_multimap() { }\n+      \n+      explicit hash_multimap(size_type __n) : _Base(__n) { }\n+      \n+      hash_multimap(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n+\n+      hash_multimap(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a) { }\n+    \n+      template<typename _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n+\n+      template<typename _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n)\n+        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n+\n+      template<typename _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n+\n+      template<typename _InputIterator>\n+        hash_multimap(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t      const hasher& __hf, const key_equal& __eql,\n+\t\t      const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n+\t\t__eql, __a) { }\n+\n+      using _Base::size;\n+      using _Base::max_size;\n+      using _Base::empty;\n+      \n+      void \n+      swap(hash_multimap& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      iterator \n+      begin() { return iterator(_Base::begin(), this); }\n+\n+      iterator \n+      end()   { return iterator(_Base::end(),   this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      end() const \n+      { return const_iterator(_Base::end(),   this); }\n+      \n+      iterator\n+      insert(const value_type& __obj)\n+      { return iterator(_Base::insert(__obj), this); }\n+      \n+      template <typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last) \n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first.base(), __last.base());\n+\t}\n+      \n+      iterator\n+      insert_noresize(const value_type& __obj)\n+      { return iterator(_Base::insert_noresize(__obj), this); }\n+      \n+      iterator \n+      find(const key_type& __key)\n+      { return iterator(_Base::find(__key), this); }\n+      \n+      const_iterator \n+      find(const key_type& __key) const \n+      { return const_iterator(_Base::find(__key), this); }\n+      \n+      using _Base::count;\n+      \n+      std::pair<iterator, iterator> \n+      equal_range(const key_type& __key)\n+      { \n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res = \n+\t                                             _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+      \n+      std::pair<const_iterator, const_iterator> \n+      equal_range(const key_type& __key) const\n+      { \n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res = \n+        _Base::equal_range(__key);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+      \n+      size_type \n+      erase(const key_type& __key) \n+      {\n+\tstd::pair<iterator, iterator> __victims = this->equal_range(__key);\n+\tsize_t __num_victims = 0;\n+\twhile (__victims.first != __victims.second) \n+\t{\n+\t  this->erase(__victims.first++);\n+\t  ++__num_victims;\n+\t}\n+\treturn __num_victims;\n+      }\n+    \n+      void \n+      erase(iterator __it) \n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\t_Base::erase(__it.base());\n+      }\n+      \n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\t_Base::erase(__first.base(), __last.base());\n+      }\n+      \n+      void \n+      clear() \n+      { \n+\t_Base::clear();\n+\tthis->_M_invalidate_all(); \n+      }\n+      \n+      using _Base::resize;\n+      using _Base::bucket_count;\n+      using _Base::max_bucket_count;\n+      using _Base::elems_in_bucket;\n+      \n+      _Base&       \n+      _M_base()       { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+      \n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+  \n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline bool\n+    operator==(const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __x,\n+\t       const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline bool\n+    operator!=(const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __x,\n+\t       const hash_multimap<_Value,_Tp,_HashFcn,_EqualKey,_Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+  \n+  template<typename _Value, typename _Tp, typename _HashFcn, \n+\t   typename _EqualKey, typename _Alloc>\n+    inline void\n+    swap(hash_multimap<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t hash_multimap<_Value, _Tp, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "cacad0353be27576f2dea35671616054a3d255bc", "filename": "libstdc++-v3/include/debug/hash_multiset.h", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_multiset.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,236 @@\n+// Debugging hash_multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_MULTISET_H\n+#define _GLIBCXX_DEBUG_HASH_MULTISET_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Value,\n+\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n+\t   typename _EqualKey = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n+    class hash_multiset\n+    : public __gnu_cxx::hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<hash_multiset<_Value, _HashFcn,\n+\t\t\t\t\t\t       _EqualKey, _Alloc> >\n+    {\n+      typedef __gnu_cxx:: hash_multiset<_Value,_HashFcn, _EqualKey,_Alloc>\n+      \t\t\t\t\t\t\t_Base;\n+      typedef __gnu_debug::_Safe_sequence<hash_multiset> _Safe_base;\n+\n+  public:\n+    typedef typename _Base::key_type        \t\tkey_type;\n+    typedef typename _Base::value_type      \t\tvalue_type;\n+    typedef typename _Base::hasher          \t\thasher;\n+    typedef typename _Base::key_equal       \t\tkey_equal;\n+    typedef typename _Base::size_type       \t\tsize_type;\n+    typedef typename _Base::difference_type \t\tdifference_type;\n+    typedef typename _Base::pointer         \t\tpointer;\n+    typedef typename _Base::const_pointer   \t\tconst_pointer;\n+    typedef typename _Base::reference       \t\treference;\n+    typedef typename _Base::const_reference \t\tconst_reference;\n+\n+    typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, \n+\t\t\t\t\t hash_multiset> iterator;\n+    typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t hash_multiset> const_iterator;\n+\n+    typedef typename _Base::allocator_type              allocator_type;\n+\n+    using _Base::hash_funct;\n+    using _Base::key_eq;\n+    using _Base::get_allocator;\n+\n+    hash_multiset() { }\n+\n+    explicit hash_multiset(size_type __n) : _Base(__n) { }\n+\n+    hash_multiset(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n+\n+    hash_multiset(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t\t  const allocator_type& __a = allocator_type())\n+    : _Base(__n, __hf, __eql, __a)\n+    { }\n+    \n+    template<typename _InputIterator>\n+      hash_multiset(_InputIterator __f, _InputIterator __l)\n+      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l)\n+      { }\n+\n+    template<typename _InputIterator>\n+      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n)\n+      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n)\n+      { }\n+\n+    template<typename _InputIterator>\n+      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t    const hasher& __hf)\n+      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf)\n+      { }\n+\n+    template<typename _InputIterator>\n+      hash_multiset(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t    const hasher& __hf, const key_equal& __eql,\n+\t\t    const allocator_type& __a = allocator_type())\n+      : _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n+\t      __eql, __a)\n+      { }\n+\n+    hash_multiset(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+    using _Base::size;\n+    using _Base::max_size;\n+    using _Base::empty;\n+\n+    void \n+    swap(hash_multiset& __x)\n+    {\n+      _Base::swap(__x);\n+      this->_M_swap(__x);\n+    }\n+\n+    iterator begin() const { return iterator(_Base::begin(), this); }\n+    iterator end() const   { return iterator(_Base::end(),   this); }\n+\n+    iterator\n+    insert(const value_type& __obj)\n+    { return iterator(_Base::insert(__obj), this); }\n+\n+    template <typename _InputIterator>\n+      void \n+      insert(_InputIterator __first, _InputIterator __last) \n+      {\n+\t__glibcxx_check_valid_range(__first, __last);\n+\t_Base::insert(__first.base(), __last.base());\n+      }\n+\n+\n+    iterator\n+    insert_noresize(const value_type& __obj)\n+    { return iterator(_Base::insert_noresize(__obj), this); }\n+\n+    iterator \n+    find(const key_type& __key) const \n+    { return iterator(_Base::find(__key), this); }\n+\n+    using _Base::count;\n+    \n+    std::pair<iterator, iterator> \n+    equal_range(const key_type& __key) const\n+    { \n+      typedef typename _Base::iterator _Base_iterator;\n+      std::pair<_Base_iterator, _Base_iterator> __res = \n+\t_Base::equal_range(__key);\n+      return std::make_pair(iterator(__res.first, this),\n+\t\t\t    iterator(__res.second, this));\n+    }\n+\n+    size_type \n+    erase(const key_type& __key) \n+    {\n+      size_type __count = 0;\n+      std::pair<iterator, iterator> __victims = this->equal_range(__key);\n+      while (__victims.first != __victims.second)\n+\t{\n+\t  this->erase(__victims++);\n+\t  ++__count;\n+\t}\n+      return __count;\n+    }\n+    \n+    void \n+    erase(iterator __it) \n+    {\n+      __glibcxx_check_erase(__it);\n+      __it._M_invalidate();\n+      _Base::erase(__it.base());\n+    }\n+\n+    void \n+    erase(iterator __first, iterator __last)\n+    {\n+      __glibcxx_check_erase_range(__first, __last);\n+      for (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+      _Base::erase(__first.base(), __last.base());\n+    }\n+\n+    void \n+    clear() \n+    { \n+      _Base::clear();\n+      this->_M_invalidate_all(); \n+    }\n+\n+    using _Base::resize;\n+    using _Base::bucket_count;\n+    using _Base::max_bucket_count;\n+    using _Base::elems_in_bucket;\n+\n+    _Base&       _M_base()       { return *this; }\n+    const _Base& _M_base() const { return *this; }\n+\n+  private:\n+    void \n+    _M_invalidate_all()\n+    {\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+      this->_M_invalidate_if(_Not_equal(_M_base().end()));\n+    }\n+  };\n+\n+template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n+  inline bool\n+  operator==(const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t     const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+  { return __x._M_base() == __y._M_base(); }\n+\n+template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n+  inline bool\n+  operator!=(const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t     const hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+  { return __x._M_base() != __y._M_base(); }\n+\n+template<typename _Value, typename _HashFcn, typename _EqualKey, typename _Alloc>\n+  inline void\n+  swap(hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+       hash_multiset<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+  { __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "13d879de5bba7b553f1b46f953aba4d801deafac", "filename": "libstdc++-v3/include/debug/hash_set", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,38 @@\n+// Debugging hash_set/hash_multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_SET\n+#define _GLIBCXX_DEBUG_HASH_SET 1\n+\n+#include <hash_set>\n+#include <debug/dbg_hash_set.h>\n+#include <debug/dbg_hash_multiset.h>\n+\n+#endif "}, {"sha": "88afb9092d9cfd5916f79aff5c04f287320f412d", "filename": "libstdc++-v3/include/debug/hash_set.h", "status": "added", "additions": 245, "deletions": 0, "changes": 245, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fhash_set.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,245 @@\n+// Debugging hash_set implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_HASH_SET_H\n+#define _GLIBCXX_DEBUG_HASH_SET_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Value,\n+\t   typename _HashFcn  = __gnu_cxx::hash<_Value>,\n+\t   typename _EqualKey = std::equal_to<_Value>,\n+\t   typename _Alloc =  std::allocator<_Value> >\n+    class hash_set\n+    : public __gnu_cxx::hash_set<_Value, _HashFcn, _EqualKey, _Alloc>,\n+      public __gnu_debug::_Safe_sequence<hash_set<_Value, _HashFcn, _EqualKey,\n+\t\t\t\t\t\t  _Alloc> >\n+    {\n+      typedef __gnu_cxx::hash_set<_Value, _HashFcn, _EqualKey, _Alloc> _Base;\n+      typedef __gnu_debug::_Safe_sequence<hash_set> _Safe_base;\n+      \n+    public:\n+      typedef typename _Base::key_type        key_type;\n+      typedef typename _Base::value_type      value_type;\n+      typedef typename _Base::hasher          hasher;\n+      typedef typename _Base::key_equal       key_equal;\n+      typedef typename _Base::size_type       size_type;\n+      typedef typename _Base::difference_type difference_type;\n+      typedef typename _Base::pointer         pointer;\n+      typedef typename _Base::const_pointer   const_pointer;\n+      typedef typename _Base::reference       reference;\n+      typedef typename _Base::const_reference const_reference;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, hash_set>\n+                                              iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  hash_set>\n+                                              const_iterator;\n+\n+      typedef typename _Base::allocator_type allocator_type;\n+      \n+      using _Base::hash_funct;\n+      using _Base::key_eq;\n+      using _Base::get_allocator;\n+      \n+      hash_set() { }\n+      \n+      explicit hash_set(size_type __n) : _Base(__n) { }\n+      \n+      hash_set(size_type __n, const hasher& __hf) : _Base(__n, __hf) { }\n+      \n+      hash_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n+\t       const allocator_type& __a = allocator_type())\n+      : _Base(__n, __hf, __eql, __a) { }\n+    \n+      template<typename _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l)\n+        : _Base(__gnu_debug::__check_valid_range(__f, __l), __l) { }\n+\n+      template<typename _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n) { }\n+\n+      template<typename _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf)\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf) { }\n+\n+      template<typename _InputIterator>\n+        hash_set(_InputIterator __f, _InputIterator __l, size_type __n,\n+\t\t const hasher& __hf, const key_equal& __eql,\n+\t\t const allocator_type& __a = allocator_type())\n+\t: _Base(__gnu_debug::__check_valid_range(__f, __l), __l, __n, __hf,\n+\t\t__eql, __a) { }\n+\n+      hash_set(const _Base& __x) : _Base(__x), _Safe_base() { }\n+      \n+      using _Base::size;\n+      using _Base::max_size;\n+      using _Base::empty;\n+      \n+      void \n+      swap(hash_set& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      iterator \n+      begin() const { return iterator(_Base::begin(), this); }\n+\n+      iterator \n+      end() const   { return iterator(_Base::end(),   this); }\n+\n+      std::pair<iterator, bool> \n+      insert(const value_type& __obj)\n+      { \t\t    \n+\tstd::pair<typename _Base::iterator, bool> __res =\n+        _Base::insert(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+      \n+      template <typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last) \n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first.base(), __last.base());\n+\t}\n+      \n+\n+      std::pair<iterator, bool> \n+      insert_noresize(const value_type& __obj)\n+      {\n+\tstd::pair<typename _Base::iterator, bool> __res =\n+        _Base::insert_noresize(__obj);\n+\treturn std::make_pair(iterator(__res.first, this), __res.second);\n+      }\n+      \n+      iterator \n+      find(const key_type& __key) const \n+      { return iterator(_Base::find(__key), this); }\n+      \n+      using _Base::count;\n+      \n+      std::pair<iterator, iterator> \n+      equal_range(const key_type& __key) const\n+      { \n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res = \n+\t  _Base::equal_range(__key);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+      \n+      size_type \n+      erase(const key_type& __key) \n+      {\n+\titerator __victim(_Base::find(__key), this);\n+\tif (__victim != end())\n+\t  return this->erase(__victim), 1;\n+\telse\n+\t  return 0;\n+      }\n+    \n+      void \n+      erase(iterator __it) \n+      {\n+\t__glibcxx_check_erase(__it);\n+\t__it._M_invalidate();\n+\t_Base::erase(__it.base());\n+      }\n+      \n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_erase_range(__first, __last);\n+\tfor (iterator __tmp = __first; __tmp != __last;)\n+\t{\n+\t  iterator __victim = __tmp++;\n+\t  __victim._M_invalidate();\n+\t}\n+\t_Base::erase(__first.base(), __last.base());\n+      }\n+      \n+      void \n+      clear() \n+      { \n+\t_Base::clear();\n+\tthis->_M_invalidate_all(); \n+      }\n+      \n+      using _Base::resize;\n+      using _Base::bucket_count;\n+      using _Base::max_bucket_count;\n+      using _Base::elems_in_bucket;\n+      \n+      _Base&       \n+      _M_base()       { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+\n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+\n+  template<typename _Value, typename _HashFcn, typename _EqualKey, \n+\t   typename _Alloc>\n+    inline bool\n+    operator==(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { return __x._M_base() == __y._M_base(); }\n+\n+  template<typename _Value, typename _HashFcn, typename _EqualKey, \n+\t   typename _Alloc>\n+    inline bool\n+    operator!=(const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t       const hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { return __x._M_base() != __y._M_base(); }\n+\n+  template<typename _Value, typename _HashFcn, typename _EqualKey, \n+\t   typename _Alloc>\n+    inline void\n+    swap(hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __x,\n+\t hash_set<_Value, _HashFcn, _EqualKey, _Alloc>& __y)\n+    { __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "79dcb1d13d85337168bd69acf4e87385c0b4288c", "filename": "libstdc++-v3/include/debug/list", "status": "added", "additions": 505, "deletions": 0, "changes": 505, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Flist?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,505 @@\n+// Debugging list implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_LIST\n+#define _GLIBCXX_DEBUG_LIST 1\n+\n+#include <list>\n+#include <bits/stl_algo.h>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Tp, typename _Allocator = std::allocator<_Tp> >\n+    class list\n+    : public __gnu_norm::list<_Tp, _Allocator>,\n+      public __gnu_debug::_Safe_sequence<list<_Tp, _Allocator> >\n+    {\n+      typedef __gnu_norm::list<_Tp, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<list>  _Safe_base;\n+\n+    public:\n+      typedef typename _Allocator::reference        reference;\n+      typedef typename _Allocator::const_reference  const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, list> \n+      \t\t\t\t\t\t    iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, list>\n+\t\t\t\t\t\t    const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      \n+      typedef _Tp        \t\t\t    value_type;\n+      typedef _Allocator \t\t\t    allocator_type;\n+      typedef typename _Allocator::pointer          pointer;\n+      typedef typename _Allocator::const_pointer    const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+      // 23.2.2.1 construct/copy/destroy:\n+      explicit list(const _Allocator& __a = _Allocator())\n+      : _Base(__a) { }\n+\n+      explicit list(size_type __n, const _Tp& __value = _Tp(),\n+\t\t    const _Allocator& __a = _Allocator())\n+      : _Base(__n, __value, __a) { }\n+\n+      template<class _InputIterator>\n+      list(_InputIterator __first, _InputIterator __last,\n+\t   const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), __last, __a)\n+      { }\n+      \n+\n+      list(const list& __x) : _Base(__x), _Safe_base() { }\n+      \n+      list(const _Base& __x) : _Base(__x), _Safe_base() { }\n+      \n+      ~list() { }\n+      \n+      list& \n+      operator=(const list& __x)\n+      {\n+\tstatic_cast<_Base&>(*this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+      \n+      template<class _InputIterator>\n+        void \n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::assign(__first, __last);\n+\t  this->_M_invalidate_all();\n+\t}\n+      \n+      void \n+      assign(size_type __n, const _Tp& __t)\n+      {\n+\t_Base::assign(__n, __t);\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      using _Base::get_allocator;\n+      \n+      // iterators:\n+      iterator       \n+      begin()       \n+      { return iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      iterator \n+      end() \n+      { return iterator(_Base::end(), this); }\n+      \n+      const_iterator \n+      end() const   \n+      { return const_iterator(_Base::end(), this); }\n+      \n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+      \n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+      \n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+      \n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+      \n+      // 23.2.2.2 capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+      \n+      void \n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+\tthis->_M_detach_singular();\n+\t\n+\t// if __sz < size(), invalidate all iterators in [begin+__sz, end())\n+\titerator __victim = begin();\n+\titerator __end = end();\n+\tfor (size_type __i = __sz; __victim != __end && __i > 0; --__i)\n+\t  ++__victim;\n+\t\n+\twhile (__victim != __end)\n+\t  {\n+\t    iterator __real_victim = __victim++;\n+\t    __real_victim._M_invalidate();\n+\t  }\n+\t\n+\ttry \n+\t  {\n+\t    _Base::resize(__sz, __c);\n+\t  }\n+\tcatch(...)\n+\t  {\n+\t    this->_M_revalidate_singular();\n+\t    __throw_exception_again;\n+\t  }\n+      }\n+      \n+      // element access:\n+      reference \n+      front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+      \n+      const_reference \n+      front() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+      \n+      reference \n+      back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+      \n+      const_reference \n+      back() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+      \n+      // 23.2.2.3 modifiers:\n+      using _Base::push_front;\n+      \n+      void \n+      pop_front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = begin();\n+\t__victim._M_invalidate();\n+\t_Base::pop_front();\n+      }\n+      \n+      using _Base::push_back;\n+      \n+      void \n+      pop_back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = end();\n+\t--__victim;\n+\t__victim._M_invalidate();\n+\t_Base::pop_back();\n+      }\n+      \n+      iterator \n+      insert(iterator __position, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n+      }\n+      \n+      void \n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\t_Base::insert(__position.base(), __n, __x);\n+      }\n+      \n+      template<class _InputIterator>\n+        void \n+        insert(iterator __position, _InputIterator __first,\n+\t       _InputIterator __last)\n+        {\n+\t  __glibcxx_check_insert_range(__position, __first, __last);\n+\t  _Base::insert(__position.base(), __first, __last);\n+\t}\n+      \n+      iterator \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t__position._M_invalidate();\n+\treturn iterator(_Base::erase(__position.base()), this);\n+      }\n+      \n+      iterator \n+      erase(iterator __position, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__position, __last);\n+\tfor (iterator __victim = __position; __victim != __last; )\n+\t  {\n+\t    iterator __old = __victim;\n+\t    ++__victim;\n+\t    __old._M_invalidate();\n+\t  }\n+\treturn iterator(_Base::erase(__position.base(), __last.base()), this);\n+      }\n+      \n+      void \n+      swap(list& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      void \n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+      \n+      // 23.2.2.4 list operations:\n+      void \n+      splice(iterator __position, list& __x)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(&__x != this,\n+\t\t\t      _M_message(::__gnu_debug::__msg_self_splice)\n+\t\t\t      ._M_sequence(*this, \"this\"));\n+\tthis->splice(__position, __x, __x.begin(), __x.end());\n+      }\n+      \n+      void \n+      splice(iterator __position, list& __x, iterator __i)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\t_GLIBCXX_DEBUG_VERIFY(__x.get_allocator() == this->get_allocator(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_splice_alloc)\n+\t\t\t    ._M_sequence(*this)._M_sequence(__x, \"__x\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__i._M_dereferenceable(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_splice_bad)\n+\t\t\t      ._M_iterator(__i, \"__i\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__i._M_attached_to(&__x),\n+\t\t\t      _M_message(::__gnu_debug::__msg_splice_other)\n+\t\t\t     ._M_iterator(__i, \"__i\")._M_sequence(__x, \"__x\"));\n+\t\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 250. splicing invalidates iterators\n+\tthis->_M_transfer_iter(__i);\n+\t_Base::splice(__position.base(), __x._M_base(), __i.base());\n+      }\n+      \n+      void \n+      splice(iterator __position, list& __x, iterator __first, iterator __last)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\t__glibcxx_check_valid_range(__first, __last);\n+\t_GLIBCXX_DEBUG_VERIFY(__first._M_attached_to(&__x),\n+\t\t\t      _M_message(::__gnu_debug::__msg_splice_other)\n+\t\t\t      ._M_sequence(__x, \"x\")\n+\t\t\t      ._M_iterator(__first, \"first\"));\n+\t_GLIBCXX_DEBUG_VERIFY(__x.get_allocator() == this->get_allocator(),\n+\t\t\t      _M_message(::__gnu_debug::__msg_splice_alloc)\n+\t\t\t      ._M_sequence(*this)._M_sequence(__x));\n+\t\n+\tfor (iterator __tmp = __first; __tmp != __last; )\n+\t  {\n+\t    _GLIBCXX_DEBUG_VERIFY(&__x != this || __tmp != __position,\n+\t\t\t\t_M_message(::__gnu_debug::__msg_splice_overlap)\n+\t\t\t\t  ._M_iterator(__tmp, \"position\")\n+\t\t\t\t  ._M_iterator(__first, \"first\")\n+\t\t\t\t  ._M_iterator(__last, \"last\"));\n+\t    iterator __victim = __tmp++;\n+\t    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t    // 250. splicing invalidates iterators\n+\t    this->_M_transfer_iter(__victim);\n+\t  }\n+\t\n+\t_Base::splice(__position.base(), __x._M_base(), __first.base(),\n+\t\t      __last.base());\n+      }\n+      \n+      void \n+      remove(const _Tp& __value)\n+      {\n+\tfor (iterator __x = begin(); __x.base() != _Base::end(); )\n+\t  {\n+\t    if (*__x == __value)\n+\t      __x = erase(__x);\n+\t    else\n+\t      ++__x;\n+\t  }\n+      }\n+      \n+      template<class _Predicate> \n+        void \n+        remove_if(_Predicate __pred)\n+        {\n+\t  for (iterator __x = begin(); __x.base() != _Base::end(); )\n+\t    {\n+\t      if (__pred(*__x))\n+\t\t__x = erase(__x);\n+\t      else\n+\t\t++__x;\n+\t    }\n+\t}\n+      \n+      void \n+      unique()\n+      {\n+\titerator __first = begin();\n+\titerator __last = end();\n+\tif (__first == __last) \n+\t  return;\n+\titerator __next = __first;\n+\twhile (++__next != __last)\n+\t  {\n+\t    if (*__first == *__next)\n+\t      erase(__next);\n+\t    else\n+\t      __first = __next;\n+\t    __next = __first;\n+\t  }\n+      }\n+      \n+      template<class _BinaryPredicate>\n+        void \n+        unique(_BinaryPredicate __binary_pred)\n+        {\n+\t  iterator __first = begin();\n+\t  iterator __last = end();\n+\t  if (__first == __last) \n+\t    return;\n+\t  iterator __next = __first;\n+\t  while (++__next != __last)\n+\t    {\n+\t      if (__binary_pred(*__first, *__next))\n+\t\terase(__next);\n+\t      else\n+\t\t__first = __next;\n+\t      __next = __first;\n+\t    }\n+\t}\n+      \n+      void \n+      merge(list& __x)\n+      {\n+\t__glibcxx_check_sorted(_Base::begin(), _Base::end());\n+\t__glibcxx_check_sorted(__x.begin().base(), __x.end().base());\n+\tfor (iterator __tmp = __x.begin(); __tmp != __x.end(); )\n+\t  {\n+\t    iterator __victim = __tmp++;\n+\t    __victim._M_attach(&__x);\n+\t  }\n+\t_Base::merge(__x._M_base());\n+      }\n+      \n+      template<class _Compare> \n+        void \n+        merge(list& __x, _Compare __comp)\n+        {\n+\t  __glibcxx_check_sorted_pred(_Base::begin(), _Base::end(), __comp);\n+\t  __glibcxx_check_sorted_pred(__x.begin().base(), __x.end().base(), \n+\t\t\t\t      __comp);\n+\t  for (iterator __tmp = __x.begin(); __tmp != __x.end(); )\n+\t    {\n+\t      iterator __victim = __tmp++;\n+\t      __victim._M_attach(&__x);\n+\t    }\n+\t  _Base::merge(__x._M_base(), __comp);\n+\t}\n+      \n+      void \n+      sort() { _Base::sort(); }\n+      \n+      template<typename _StrictWeakOrdering>\n+        void \n+        sort(_StrictWeakOrdering __pred) { _Base::sort(__pred); }\n+      \n+      using _Base::reverse;\n+      \n+      _Base&       \n+      _M_base()       { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+\n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+  \n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const list<_Tp, _Alloc>& __lhs, const list<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+  \n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(list<_Tp, _Alloc>& __lhs, list<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "2c384048718ac7b90c15eb80a7865b9c49b29a5d", "filename": "libstdc++-v3/include/debug/map", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,38 @@\n+// Debugging map/multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_MAP\n+#define _GLIBCXX_DEBUG_MAP 1\n+\n+#include <map>\n+#include <debug/map.h>\n+#include <debug/multimap.h>\n+\n+#endif"}, {"sha": "d8609bdffb8f2335161fe5d43ed87f60a33efbec", "filename": "libstdc++-v3/include/debug/map.h", "status": "added", "additions": 323, "deletions": 0, "changes": 323, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmap.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,323 @@\n+// Debugging map implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_MAP_H\n+#define _GLIBCXX_DEBUG_MAP_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <utility>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n+    class map\n+    : public __gnu_norm::map<_Key, _Tp, _Compare, _Allocator>,\n+      public __gnu_debug::_Safe_sequence<map<_Key, _Tp, _Compare, _Allocator> >\n+    {\n+      typedef __gnu_norm::map<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<map> _Safe_base;\n+\n+    public:\n+      // types:\n+      typedef _Key                                  key_type;\n+      typedef _Tp                                   mapped_type;\n+      typedef std::pair<const _Key, _Tp>            value_type;\n+      typedef _Compare                              key_compare;\n+      typedef _Allocator                            allocator_type;\n+      typedef typename _Allocator::reference        reference;\n+      typedef typename _Allocator::const_reference  const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, map> \n+                                                    iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, map>\n+                                                    const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Allocator::pointer          pointer;\n+      typedef typename _Allocator::const_pointer    const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      \n+      using _Base::value_compare;\n+      \n+      // 23.3.1.1 construct/copy/destroy:\n+      explicit map(const _Compare& __comp = _Compare(), \n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+        map(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(), \n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), __last,\n+\t\t__comp, __a), _Safe_base() { }\n+\n+      map(const map<_Key,_Tp,_Compare,_Allocator>& __x) \n+      : _Base(__x), _Safe_base() { } \n+      \n+      map(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+      ~map() { }\n+      \n+      map<_Key,_Tp,_Compare,_Allocator>&\n+      operator=(const map<_Key,_Tp,_Compare,_Allocator>& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 133. map missing get_allocator()\n+      using _Base::get_allocator;\n+      \n+      // iterators:\n+      iterator       \n+      begin()  \n+      { return iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      iterator       \n+      end()         \n+      { return iterator(_Base::end(), this); }\n+      \n+      const_iterator \n+      end() const   \n+      { return const_iterator(_Base::end(), this); }\n+      \n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+      \n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+      \n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+      \n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+      \n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+      \n+      // 23.3.1.2 element access:\n+      using _Base::operator[];\n+      \n+      // modifiers:\n+      std::pair<iterator, bool> \n+      insert(const value_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n+\treturn std::pair<iterator, bool>(iterator(__res.first, this), \n+\t\t\t\t\t __res.second);\n+      }\n+      \n+      iterator \n+      insert(iterator __position, const value_type& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n+      }\n+      \n+      template<typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+      \n+      void \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t__position._M_invalidate();\n+\t_Base::erase(__position.base());\n+      }\n+      \n+      size_type \n+      erase(const key_type& __x)\n+      {\n+\titerator __victim = find(__x);\n+\tif (__victim == end())\n+\t  return 0;\n+\telse\n+\t{\n+\t  __victim._M_invalidate();\n+\t  _Base::erase(__victim.base());\n+\t  return 1;\n+\t}\n+      }\n+      \n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+\twhile (__first != __last)\n+\t  this->erase(__first++);\n+      }\n+      \n+      void \n+      swap(map<_Key,_Tp,_Compare,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      void \n+      clear()\n+      { this->erase(begin(), end()); }\n+      \n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+      \n+      // 23.3.1.3 map operations:\n+      iterator \n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x), this); }\n+      \n+      const_iterator \n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x), this); }\n+      \n+      using _Base::count;\n+      \n+      iterator \n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x), this); }\n+      \n+      const_iterator \n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x), this); }\n+      \n+      iterator \n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x), this); }\n+      \n+      const_iterator \n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x), this); }\n+      \n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+      \n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+      \n+      _Base&       \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+      \n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator> \n+    inline bool\n+    operator==(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator!=(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator<(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t      const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator<=(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator>=(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator>(const map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t      const map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline void\n+    swap(map<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t map<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+} // namespace __gnu_debug_def\n+\n+#endif "}, {"sha": "8c3bd317bbe1e95f4632252570c8d3cb8f28b300", "filename": "libstdc++-v3/include/debug/multimap.h", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultimap.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,314 @@\n+// Debugging multimap implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_MULTIMAP_H\n+#define _GLIBCXX_DEBUG_MULTIMAP_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <utility>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Key, typename _Tp, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<std::pair<const _Key, _Tp> > >\n+    class multimap \n+    : public __gnu_norm::multimap<_Key, _Tp, _Compare, _Allocator>,\n+    public __gnu_debug::_Safe_sequence<multimap<_Key,_Tp,_Compare,_Allocator> >\n+    {\n+      typedef __gnu_norm::multimap<_Key, _Tp, _Compare, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<multimap> _Safe_base;\n+      \n+    public:\n+      // types:\n+      typedef _Key   \t\t\t   \t     key_type;\n+      typedef _Tp  \t\t\t   \t     mapped_type;\n+      typedef std::pair<const _Key, _Tp>             value_type;\n+      typedef _Compare                               key_compare;\n+      typedef _Allocator                             allocator_type;\n+      typedef typename _Allocator::reference         reference;\n+      typedef typename _Allocator::const_reference   const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, multimap> \n+                                                     iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+                                           multimap> const_iterator;\n+\n+      typedef typename _Base::size_type              size_type;\n+      typedef typename _Base::difference_type        difference_type;\n+      typedef typename _Allocator::pointer           pointer;\n+      typedef typename _Allocator::const_pointer     const_pointer;\n+      typedef std::reverse_iterator<iterator>        reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;\n+      \n+      using _Base::value_compare;\n+      \n+      // 23.3.1.1 construct/copy/destroy:\n+      explicit multimap(const _Compare& __comp = _Compare(),\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+      multimap(_InputIterator __first, _InputIterator __last,\n+\t       const _Compare& __comp = _Compare(), \n+\t       const _Allocator& __a = _Allocator())\n+      : _Base(__gnu_debug::__check_valid_range(__first, __last), __last,\n+\t      __comp, __a) { }\n+\n+      multimap(const multimap<_Key,_Tp,_Compare,_Allocator>& __x)\n+      : _Base(__x), _Safe_base() { } \n+\n+      multimap(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+      ~multimap() { }\n+\n+      multimap<_Key,_Tp,_Compare,_Allocator>&\n+      operator=(const multimap<_Key,_Tp,_Compare,_Allocator>& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator       \n+      begin() \n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator       \n+      end() \n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator \n+      end() const   \n+      { return const_iterator(_Base::end(), this); }\n+\n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // modifiers:\n+      iterator \n+      insert(const value_type& __x)\n+      { return iterator(_Base::insert(__x), this); }\n+\n+      iterator \n+      insert(iterator __position, const value_type& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n+      }\n+\n+      template<typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+\n+      void \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t__position._M_invalidate();\n+\t_Base::erase(__position.base());\n+      }\n+\n+      size_type \n+      erase(const key_type& __x)\n+      {\n+\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tsize_type __count = 0;\n+\twhile (__victims.first != __victims.second)\n+\t{\n+\t  iterator __victim = __victims.first++;\n+\t  __victim._M_invalidate();\n+\t  _Base::erase(__victim.base());\n+\t  ++__count;\n+\t}\n+\treturn __count;\n+      }\n+\n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+\twhile (__first != __last)\n+\tthis->erase(__first++);\n+      }\n+\n+      void \n+      swap(multimap<_Key,_Tp,_Compare,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+\n+      void \n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // 23.3.1.3 multimap operations:\n+      iterator \n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x), this); }\n+\n+      const_iterator \n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x), this); }\n+\n+      using _Base::count;\n+\n+      iterator \n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x), this); }\n+\n+      const_iterator \n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x), this); }\n+\n+      iterator \n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x), this); }\n+\n+      const_iterator \n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x), this); }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\tstd::pair<_Base_const_iterator, _Base_const_iterator> __res =\n+\t_Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      _Base&       \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+\n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator==(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator!=(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator<(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t      const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator<=(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator>=(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t       const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline bool\n+    operator>(const multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t      const multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key,typename _Tp,typename _Compare,typename _Allocator>\n+    inline void\n+    swap(multimap<_Key,_Tp,_Compare,_Allocator>& __lhs, \n+\t multimap<_Key,_Tp,_Compare,_Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+} // namespace __gnu_debug_def\n+\n+#endif "}, {"sha": "083c8fb69a234562dab926cef148004dacce72c1", "filename": "libstdc++-v3/include/debug/multiset.h", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fmultiset.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,320 @@\n+// Debugging multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_MULTISET_H\n+#define _GLIBCXX_DEBUG_MULTISET_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <utility>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<_Key> >\n+    class multiset \n+    : public __gnu_norm::multiset<_Key, _Compare, _Allocator>,\n+      public __gnu_debug::_Safe_sequence<multiset<_Key, _Compare, _Allocator> >\n+    {\n+      typedef __gnu_norm::multiset<_Key, _Compare, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<multiset> _Safe_base;\n+\n+    public:\n+      // types:\n+      typedef _Key \t \t\t\t   key_type;\n+      typedef _Key \t \t\t\t   value_type;\n+      typedef _Compare   \t\t\t   \t   key_compare;\n+      typedef _Compare   \t\t\t   \t   value_compare;\n+      typedef _Allocator \t\t\t   \t   allocator_type;\n+      typedef typename _Allocator::reference         reference;\n+      typedef typename _Allocator::const_reference   const_reference;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, multiset> \n+      iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,\n+\t\t\t\t\t  multiset> const_iterator;\n+\n+      typedef typename _Base::size_type              size_type;\n+      typedef typename _Base::difference_type        difference_type;\n+      typedef typename _Allocator::pointer           pointer;\n+      typedef typename _Allocator::const_pointer     const_pointer;\n+      typedef std::reverse_iterator<iterator>        reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator>  const_reverse_iterator;\n+\n+      // 23.3.3.1 construct/copy/destroy:\n+      explicit multiset(const _Compare& __comp = _Compare(),\n+\t\t\tconst _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+\n+      template<typename _InputIterator>\n+        multiset(_InputIterator __first, _InputIterator __last,\n+\t\t const _Compare& __comp = _Compare(),\n+\t\t const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), __last,\n+\t\t__comp, __a) { }\n+\n+      multiset(const multiset<_Key,_Compare,_Allocator>& __x) \n+      : _Base(__x), _Safe_base() { }\n+    \n+      multiset(const _Base& __x) : _Base(__x), _Safe_base() { }\n+\n+      ~multiset() { }\n+\n+      multiset<_Key,_Compare,_Allocator>& \n+      operator=(const multiset<_Key,_Compare,_Allocator>& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator\n+      begin()\n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator \n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator \n+      end() const   \n+      { return const_iterator(_Base::end(), this); }\n+\n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+\n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      // modifiers:\n+      iterator \n+      insert(const value_type& __x)\n+      { return iterator(_Base::insert(__x), this); }\n+\n+      iterator \n+      insert(iterator __position, const value_type& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n+      }\n+\n+      template<typename _InputIterator>\n+      void \n+      insert(_InputIterator __first, _InputIterator __last)\n+      {\n+\t__glibcxx_check_valid_range(__first, __last);\n+\t_Base::insert(__first, __last);\n+      }\n+\n+      void \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t__position._M_invalidate();\n+\t_Base::erase(__position.base());\n+      }\n+\n+      size_type\n+      erase(const key_type& __x)\n+      {\n+\tstd::pair<iterator, iterator> __victims = this->equal_range(__x);\n+\tsize_type __count = 0;\n+\twhile (__victims.first != __victims.second)\n+\t{\n+\t  iterator __victim = __victims.first++;\n+\t  __victim._M_invalidate();\n+\t  _Base::erase(__victim.base());\n+\t  ++__count;\n+\t}\n+\treturn __count;\n+      }\n+\n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+\twhile (__first != __last)\n+\tthis->erase(__first++);\n+      }\n+\n+      void \n+      swap(multiset<_Key,_Compare,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+\n+      void \n+      clear()\n+      { this->erase(begin(), end()); }\n+\n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+\n+      // multiset operations:\n+      iterator \n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x), this); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x), this); }\n+\n+      using _Base::count;\n+\n+      iterator \n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x), this); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x), this); }\n+\n+      iterator \n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x), this); }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x), this); }\n+\n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+\n+      _Base& \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+      \n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator==(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t       const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator!=(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t       const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator<(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t      const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator<=(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t       const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator>=(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t       const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator>(const multiset<_Key,_Compare,_Allocator>& __lhs,\n+\t      const multiset<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    void\n+    swap(multiset<_Key,_Compare,_Allocator>& __x,\n+\t multiset<_Key,_Compare,_Allocator>& __y)\n+    { return __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "93b17618e35ba82552cbd3e2b3a91ed5a0bcafe7", "filename": "libstdc++-v3/include/debug/safe_base.h", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_base.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,201 @@\n+// Safe sequence/iterator base implementation  -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_BASE_H\n+#define _GLIBCXX_DEBUG_SAFE_BASE_H 1\n+\n+namespace __gnu_debug\n+{\n+  class _Safe_sequence_base;\n+\n+  /** \\brief Basic functionality for a \"safe\" iterator.\n+   *\n+   *  The %_Safe_iterator_base base class implements the functionality\n+   *  of a safe iterator that is not specific to a particular iterator\n+   *  type. It contains a pointer back to the sequence it references\n+   *  along with iterator version information and pointers to form a\n+   *  doubly-linked list of iterators referenced by the container.\n+   *\n+   *  This class must not perform any operations that can throw an\n+   *  exception, or the exception guarantees of derived iterators will\n+   *  be broken.\n+   */\n+  class _Safe_iterator_base\n+  {\n+  public:\n+    /** The sequence this iterator references; may be NULL to indicate\n+\ta singular iterator. */\n+    _Safe_sequence_base* _M_sequence;\n+\n+    /** The version number of this iterator. The sentinel value 0 is\n+     *  used to indicate an invalidated iterator (i.e., one that is\n+     *  singular because of an operation on the container). This\n+     *  version number must equal the version number in the sequence\n+     *  referenced by _M_sequence for the iterator to be\n+     *  non-singular. \n+     */\n+    unsigned int         _M_version;\n+\n+    /** Pointer to the previous iterator in the sequence's list of\n+\titerators. Only valid when _M_sequence != NULL. */\n+    _Safe_iterator_base* _M_prior;\n+\n+    /** Pointer to the next iterator in the sequence's list of\n+\titerators. Only valid when _M_sequence != NULL. */\n+    _Safe_iterator_base* _M_next;\n+\n+  protected:\n+    /** Initializes the iterator and makes it singular. */\n+    _Safe_iterator_base() \n+    : _M_sequence(0), _M_version(0), _M_prior(0), _M_next(0)\n+    { }\n+\n+    /** Initialize the iterator to reference the sequence pointed to\n+     *  by @p__seq. @p __constant is true when we are initializing a\n+     *  constant iterator, and false if it is a mutable iterator. Note\n+     *  that @p __seq may be NULL, in which case the iterator will be\n+     *  singular. Otherwise, the iterator will reference @p __seq and\n+     *  be nonsingular. \n+     */\n+    _Safe_iterator_base(const _Safe_sequence_base* __seq, bool __constant)\n+    : _M_sequence(0), _M_version(0), _M_prior(0), _M_next(0)\n+    { this->_M_attach(const_cast<_Safe_sequence_base*>(__seq), __constant); }\n+\n+    /** Initializes the iterator to reference the same sequence that\n+\t@p __x does. @p __constant is true if this is a constant\n+\titerator, and false if it is mutable. */\n+    _Safe_iterator_base(const _Safe_iterator_base& __x, bool __constant)\n+    : _M_sequence(0), _M_version(0), _M_prior(0), _M_next(0)\n+    { this->_M_attach(__x._M_sequence, __constant); }\n+\n+    ~_Safe_iterator_base() { this->_M_detach(); }\n+\n+  public:\n+    /** Attaches this iterator to the given sequence, detaching it\n+     *\tfrom whatever sequence it was attached to originally. If the\n+     *\tnew sequence is the NULL pointer, the iterator is left\n+     *\tunattached.\n+     */ \n+    void _M_attach(_Safe_sequence_base* __seq, bool __constant);\n+\n+    /** Detach the iterator for whatever sequence it is attached to,\n+     *\tif any. \n+    */\n+    void _M_detach();\n+\n+    /** Determines if we are attached to the given sequence. */\n+    bool _M_attached_to(const _Safe_sequence_base* __seq) const\n+    { return _M_sequence == __seq; }\n+\n+    /** Is this iterator singular? */\n+    bool _M_singular() const;\n+\n+    /** Can we compare this iterator to the given iterator @p __x?\n+\tReturns true if both iterators are nonsingular and reference\n+\tthe same sequence. */\n+    bool _M_can_compare(const _Safe_iterator_base& __x) const;\n+  };\n+\n+  /**\n+   * @brief Base class that supports tracking of iterators that\n+   * reference a sequence.\n+   *\n+   * The %_Safe_sequence_base class provides basic support for\n+   * tracking iterators into a sequence. Sequences that track\n+   * iterators must derived from %_Safe_sequence_base publicly, so\n+   * that safe iterators (which inherit _Safe_iterator_base) can\n+   * attach to them. This class contains two linked lists of\n+   * iterators, one for constant iterators and one for mutable\n+   * iterators, and a version number that allows very fast\n+   * invalidation of all iterators that reference the container.\n+   *\n+   * This class must ensure that no operation on it may throw an\n+   * exception, otherwise \"safe\" sequences may fail to provide the\n+   * exception-safety guarantees required by the C++ standard.\n+   */\n+  class _Safe_sequence_base\n+  {\n+  public:\n+    /// The list of mutable iterators that reference this container\n+    _Safe_iterator_base* _M_iterators;\n+    \n+    /// The list of constant iterators that reference this container\n+    _Safe_iterator_base* _M_const_iterators;\n+    \n+    /// The container version number. This number may never be 0.\n+    mutable unsigned int _M_version;\n+    \n+  protected:\n+    // Initialize with a version number of 1 and no iterators\n+    _Safe_sequence_base()\n+    : _M_iterators(0), _M_const_iterators(0), _M_version(1)\n+    { }\n+    \n+    /** Notify all iterators that reference this sequence that the\n+\tsequence is being destroyed. */\n+    ~_Safe_sequence_base()\n+    { this->_M_detach_all(); }\n+    \n+    /** Detach all iterators, leaving them singular. */\n+    void \n+    _M_detach_all();\n+    \n+    /** Detach all singular iterators. \n+     *  @post for all iterators i attached to this sequence, \n+     *   i->_M_version == _M_version.\n+     */\n+    void\n+    _M_detach_singular();\n+    \n+    /** Revalidates all attached singular iterators.  This method may\n+     *  be used to validate iterators that were invalidated before\n+     *  (but for some reasion, such as an exception, need to become\n+     *  valid again).\n+     */\n+    void\n+    _M_revalidate_singular();\n+    \n+    /** Swap this sequence with the given sequence. This operation\n+     *  also swaps ownership of the iterators, so that when the\n+     *  operation is complete all iterators that originally referenced\n+     *  one container now reference the other container.\n+     */\n+    void \n+    _M_swap(_Safe_sequence_base& __x);\n+      \n+  public:\n+    /** Invalidates all iterators. */\n+    void \n+    _M_invalidate_all() const\n+    { if (++_M_version == 0) _M_version = 1; }\n+  };\n+} // namespace __gnu_debug\n+\n+#endif "}, {"sha": "5d7ee27fb3ca0d6980dce9a28071d1e9e85e5cb4", "filename": "libstdc++-v3/include/debug/safe_iterator.h", "status": "added", "additions": 607, "deletions": 0, "changes": 607, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,607 @@\n+// Safe iterator implementation  -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_ITERATOR_H\n+#define _GLIBCXX_DEBUG_SAFE_ITERATOR_H 1\n+\n+#include <bits/stl_pair.h>\n+#include <debug/debug.h>\n+#include <debug/formatter.h>\n+#include <debug/safe_base.h>\n+\n+namespace __gnu_debug\n+{\n+  /** Iterators that derive from _Safe_iterator_base but that aren't\n+   *  _Safe_iterators can be determined singular or non-singular via\n+   *  _Safe_iterator_base. \n+   */\n+  inline bool __check_singular_aux(const _Safe_iterator_base* __x)\n+  { return __x->_M_singular(); }\n+  \n+  /** \\brief Safe iterator wrapper.\n+   *  \n+   *  The class template %_Safe_iterator is a wrapper around an\n+   *  iterator that tracks the iterator's movement among sequences and\n+   *  checks that operations performed on the \"safe\" iterator are\n+   *  legal. In additional to the basic iterator operations (which are\n+   *  validated, and then passed to the underlying iterator),\n+   *  %_Safe_iterator has member functions for iterator invalidation,\n+   *  attaching/detaching the iterator from sequences, and querying\n+   *  the iterator's state.\n+   */\n+  template<typename _Iterator, typename _Sequence>\n+    class _Safe_iterator : public _Safe_iterator_base\n+    {\n+      typedef _Safe_iterator _Self;\n+\n+      /** The precision to which we can calculate the distance between\n+       *  two iterators.\n+       */\n+      enum _Distance_precision\n+\t{\n+\t  __dp_equality, //< Can compare iterator equality, only\n+\t  __dp_sign,     //< Can determine equality and ordering\n+\t  __dp_exact     //< Can determine distance precisely\n+\t};\n+      \n+      /// The underlying iterator\n+      _Iterator _M_current;\n+\n+      /// Determine if this is a constant iterator.\n+      bool \n+      _M_constant() const\n+      {\n+\ttypedef typename _Sequence::const_iterator const_iterator;\n+\treturn __is_same<const_iterator, _Safe_iterator>::value;\n+      }\n+\n+      typedef iterator_traits<_Iterator> _Traits;\n+\n+    public:\n+      typedef typename _Traits::iterator_category iterator_category;\n+      typedef typename _Traits::value_type        value_type;\n+      typedef typename _Traits::difference_type   difference_type;\n+      typedef typename _Traits::reference         reference;\n+      typedef typename _Traits::pointer           pointer;\n+\n+      /// @post the iterator is singular and unattached\n+      _Safe_iterator() : _M_current() { }\n+\n+      /**\n+       * @brief Safe iterator construction from an unsafe iterator and\n+       * its sequence.\n+       *\n+       * @pre @p seq is not NULL\n+       * @post this is not singular\n+       */\n+      _Safe_iterator(const _Iterator& __i, const _Sequence* __seq)\n+      : _Safe_iterator_base(__seq, _M_constant()), _M_current(__i)\n+      { \n+\t_GLIBCXX_DEBUG_VERIFY(! this->_M_singular(),\n+\t\t\t      _M_message(__msg_init_singular)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+      }\n+\n+      /**\n+       * @brief Copy construction.\n+       * @pre @p x is not singular\n+       */\n+      _Safe_iterator(const _Safe_iterator& __x)\n+      : _Safe_iterator_base(__x, _M_constant()), _M_current(__x._M_current)\n+      { \n+\t_GLIBCXX_DEBUG_VERIFY(!__x._M_singular(),\n+\t\t\t      _M_message(__msg_init_copy_singular)\n+\t\t\t      ._M_iterator(*this, \"this\")\n+\t\t\t      ._M_iterator(__x, \"other\"));\n+      }\n+\n+      /** \n+       *  @brief Converting constructor from a mutable iterator to a\n+       *  constant iterator.\n+       *\n+       *  @pre @p x is not singular\n+      */\n+      template<typename _MutableIterator>\n+        _Safe_iterator(const _Safe_iterator<_MutableIterator, _Sequence>& __x)\n+\t: _Safe_iterator_base(__x, _M_constant()), _M_current(__x.base())\n+        { \n+\t  _GLIBCXX_DEBUG_VERIFY(!__x._M_singular(),\n+\t\t\t\t_M_message(__msg_init_const_singular)\n+\t\t\t\t._M_iterator(*this, \"this\")\n+\t\t\t\t._M_iterator(__x, \"other\"));\n+\t}\n+\n+      /**\n+       * @brief Copy assignment.\n+       * @pre @p x is not singular\n+       */\n+      _Safe_iterator& \n+      operator=(const _Safe_iterator& __x)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(!__x._M_singular(),\n+\t\t\t      _M_message(__msg_copy_singular)\n+\t\t\t      ._M_iterator(*this, \"this\")\n+\t\t\t      ._M_iterator(__x, \"other\"));\n+\t_M_current = __x._M_current;\n+\tthis->_M_attach(static_cast<_Sequence*>(__x._M_sequence));\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Iterator dereference.\n+       *  @pre iterator is dereferenceable\n+       */\n+      reference \n+      operator*() const \n+      {\n+\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_dereferenceable(),\n+\t\t\t      _M_message(__msg_bad_deref)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\treturn *_M_current;\n+      }\n+\n+      /**\n+       *  @brief Iterator dereference.\n+       *  @pre iterator is dereferenceable\n+       *  @todo Make this correct w.r.t. iterators that return proxies\n+       *  @todo Use addressof() instead of & operator\n+       */\n+      pointer \n+      operator->() const\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_dereferenceable(),\n+\t\t\t      _M_message(__msg_bad_deref)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\treturn &*_M_current;\n+      }\n+\n+      // ------ Input iterator requirements ------\n+      /**\n+       *  @brief Iterator preincrement\n+       *  @pre iterator is incrementable\n+       */\n+      _Safe_iterator& \n+      operator++()\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_incrementable(),\n+\t\t\t      _M_message(__msg_bad_inc)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t++_M_current;\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Iterator postincrement\n+       *  @pre iterator is incrementable\n+       */\n+      _Safe_iterator \n+      operator++(int)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_incrementable(),\n+\t\t\t      _M_message(__msg_bad_inc)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t_Safe_iterator __tmp(*this);\n+\t++_M_current;\n+\treturn __tmp;\n+      }\n+\n+      // ------ Bidirectional iterator requirements ------\n+      /**\n+       *  @brief Iterator predecrement\n+       *  @pre iterator is decrementable\n+       */\n+      _Safe_iterator& \n+      operator--()\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_decrementable(),\n+\t\t\t      _M_message(__msg_bad_dec)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t--_M_current;\n+\treturn *this;\n+      }\n+\n+      /**\n+       *  @brief Iterator postdecrement\n+       *  @pre iterator is decrementable\n+       */\n+      _Safe_iterator \n+      operator--(int)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_decrementable(),\n+\t\t\t      _M_message(__msg_bad_dec)\n+\t\t\t      ._M_iterator(*this, \"this\"));\n+\t_Safe_iterator __tmp(*this);\n+\t--_M_current;\n+\treturn __tmp;\n+      }\n+\n+      // ------ Random access iterator requirements ------\n+      reference \n+      operator[](const difference_type& __n) const\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_can_advance(__n) \n+\t\t\t      && this->_M_can_advance(__n+1),\n+\t\t\t      _M_message(__msg_iter_subscript_oob)\n+\t\t\t      ._M_iterator(*this)._M_integer(__n));\n+\n+\treturn _M_current[__n];\n+      }\n+\n+      _Safe_iterator& \n+      operator+=(const difference_type& __n)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_can_advance(__n),\n+\t\t\t      _M_message(__msg_advance_oob)\n+\t\t\t      ._M_iterator(*this)._M_integer(__n));\n+\t_M_current += __n;\n+\treturn *this;\n+      }\n+\n+      _Safe_iterator \n+      operator+(const difference_type& __n) const\n+      {\n+\t_Safe_iterator __tmp(*this);\n+\t__tmp += __n;\n+\treturn __tmp;\n+      }\n+\n+      _Safe_iterator& \n+      operator-=(const difference_type& __n)\n+      {\n+\t_GLIBCXX_DEBUG_VERIFY(this->_M_can_advance(-__n),\n+\t\t\t      _M_message(__msg_retreat_oob)\n+\t\t\t      ._M_iterator(*this)._M_integer(__n));\n+\t_M_current += -__n;\n+\treturn *this;\n+      }\n+\n+      _Safe_iterator \n+      operator-(const difference_type& __n) const\n+      {\n+\t_Safe_iterator __tmp(*this);\n+\t__tmp -= __n;\n+\treturn __tmp;\n+      }\n+\n+      // ------ Utilities ------\n+      /**\n+       * @brief Return the underlying iterator\n+       */      \n+      _Iterator \n+      base() const { return _M_current; }\n+\n+      /**\n+       * @brief Conversion to underlying non-debug iterator to allow\n+       * better interaction with non-debug containers.\n+       */\n+      operator _Iterator() const { return _M_current; }\n+\n+      /** Attach iterator to the given sequence. */\n+      void \n+      _M_attach(const _Sequence* __seq)\n+      { \n+\t_Safe_iterator_base::_M_attach(const_cast<_Sequence*>(__seq),\n+\t\t\t\t       _M_constant()); \n+      }\n+\n+      /** Invalidate the iterator, making it singular. */\n+      void \n+      _M_invalidate();\n+\n+      /// Is the iterator dereferenceable?\n+      bool \n+      _M_dereferenceable() const\n+      { return !this->_M_singular() && !_M_is_end(); }\n+\n+      /// Is the iterator incrementable?\n+      bool \n+      _M_incrementable() const { return this->_M_dereferenceable(); }\n+\n+      // Is the iterator decrementable?\n+      bool \n+      _M_decrementable() const { return !_M_singular() && !_M_is_begin(); }\n+\n+      // Can we advance the iterator @p __n steps (@p __n may be negative)\n+      bool \n+      _M_can_advance(const difference_type& __n) const;\n+\n+      // Is the iterator range [*this, __rhs) valid?\n+      template<typename _Other>\n+        bool \n+        _M_valid_range(const _Safe_iterator<_Other, _Sequence>& __rhs) const;\n+\n+      // The sequence this iterator references.\n+      const _Sequence* \n+      _M_get_sequence() const\n+      { return static_cast<const _Sequence*>(_M_sequence); }\n+\n+    /** Determine the distance between two iterators with some known\n+     *\tprecision. \n+    */\n+    template<typename _Iterator1, typename _Iterator2>\n+      static pair<difference_type, _Distance_precision>\n+      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs)\n+      {\n+        typedef typename iterator_traits<_Iterator1>::iterator_category\n+\t  _Category;\n+        return _M_get_distance(__lhs, __rhs, _Category());\n+      }\n+\n+    template<typename _Iterator1, typename _Iterator2>\n+      static pair<difference_type, _Distance_precision>\n+      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n+\t\t      std::random_access_iterator_tag)\n+      {\n+        return std::make_pair(__rhs.base() - __lhs.base(), __dp_exact);\n+      }\n+\n+    template<typename _Iterator1, typename _Iterator2>\n+      static pair<difference_type, _Distance_precision>\n+      _M_get_distance(const _Iterator1& __lhs, const _Iterator2& __rhs,\n+    \t\t    std::forward_iterator_tag)\n+      {\n+        return std::make_pair(__lhs.base() == __rhs.base()? 0 : 1, \n+\t\t\t      __dp_equality);\n+      }\n+\n+      /// Is this iterator equal to the sequence's begin() iterator?\n+      bool _M_is_begin() const\n+      {\treturn *this == static_cast<const _Sequence*>(_M_sequence)->begin(); }\n+\n+      /// Is this iterator equal to the sequence's end() iterator?\n+      bool _M_is_end() const\n+      {\treturn *this == static_cast<const _Sequence*>(_M_sequence)->end(); }\n+    };\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator==(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+  \t       const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() == __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator==(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() == __rhs.base(); \n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator!=(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+  \t       const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() != __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator!=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_compare_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_compare_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() != __rhs.base(); \n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator<(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+\t      const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() < __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator<(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+\t      const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() < __rhs.base(); \n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator<=(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+  \t       const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() <= __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator<=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() <= __rhs.base(); \n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator>(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+\t      const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() > __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator>(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+\t      const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() > __rhs.base(); \n+    }\n+\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline bool\n+    operator>=(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+  \t       const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() >= __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline bool\n+    operator>=(const _Safe_iterator<_Iterator, _Sequence>& __lhs,\n+               const _Safe_iterator<_Iterator, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_iter_order_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_order_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() >= __rhs.base(); \n+    }\n+\n+  // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+  // According to the resolution of DR179 not only the various comparison\n+  // operators but also operator- must accept mixed iterator/const_iterator\n+  // parameters.\n+  template<typename _IteratorL, typename _IteratorR, typename _Sequence>\n+    inline typename _Safe_iterator<_IteratorL, _Sequence>::difference_type\n+    operator-(const _Safe_iterator<_IteratorL, _Sequence>& __lhs,\n+\t      const _Safe_iterator<_IteratorR, _Sequence>& __rhs)\n+    { \n+      _GLIBCXX_DEBUG_VERIFY(! __lhs._M_singular() && ! __rhs._M_singular(),\n+\t\t\t    _M_message(__msg_distance_bad)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      _GLIBCXX_DEBUG_VERIFY(__lhs._M_can_compare(__rhs),\n+\t\t\t    _M_message(__msg_distance_different)\n+\t\t\t    ._M_iterator(__lhs, \"lhs\")\n+\t\t\t    ._M_iterator(__rhs, \"rhs\"));\n+      return __lhs.base() - __rhs.base(); \n+    }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    inline _Safe_iterator<_Iterator, _Sequence>\n+    operator+(typename _Safe_iterator<_Iterator,_Sequence>::difference_type __n,\n+\t      const _Safe_iterator<_Iterator, _Sequence>& __i)\n+    { return __i + __n; }\n+} // namespace __gnu_debug\n+\n+#ifndef _GLIBCXX_EXPORT_TEMPLATE\n+#  include <debug/safe_iterator.tcc>\n+#endif \n+\n+#endif"}, {"sha": "0af21b9eb2d5369ca6ca373e760689140fae6492", "filename": "libstdc++-v3/include/debug/safe_iterator.tcc", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_iterator.tcc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,140 @@\n+// Debugging iterator implementation (out of line) -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+/** @file safe_iterator.tcc\n+ *  This is an internal header file, included by other library headers.\n+ *  You should not attempt to use it directly.\n+ */\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_ITERATOR_TCC\n+#define _GLIBCXX_DEBUG_SAFE_ITERATOR_TCC 1\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Iterator, typename _Sequence>\n+    bool \n+    _Safe_iterator<_Iterator, _Sequence>::\n+    _M_can_advance(const difference_type& __n) const\n+    {\n+      typedef typename _Sequence::const_iterator const_iterator;\n+      \n+      if (this->_M_singular())\n+\treturn false;\n+      if (__n == 0)\n+\treturn true;\n+      if (__n < 0) \n+\t{\n+\t  const_iterator __begin = \n+\t    static_cast<const _Sequence*>(_M_sequence)->begin();\n+\t  pair<difference_type, _Distance_precision> __dist =\n+\t    this->_M_get_distance(__begin, *this);\n+\t  bool __ok =  (__dist.second == __dp_exact && __dist.first >= -__n\n+\t\t\t|| __dist.second != __dp_exact && __dist.first > 0);\n+\t  return __ok;\n+\t}\n+      else\n+\t{\n+\t  const_iterator __end = \n+\t    static_cast<const _Sequence*>(_M_sequence)->end();\n+\t  pair<difference_type, _Distance_precision> __dist = \n+\t    this->_M_get_distance(*this, __end);\n+\t  bool __ok = (__dist.second == __dp_exact && __dist.first >= __n\n+\t\t       || __dist.second != __dp_exact && __dist.first > 0);\n+\t  return __ok;\n+\t}\n+    }\n+  \n+  template<typename _Iterator, typename _Sequence>\n+    template<typename _Other>\n+      bool \n+      _Safe_iterator<_Iterator, _Sequence>::\n+      _M_valid_range(const _Safe_iterator<_Other, _Sequence>& __rhs) const\n+      {\n+\tif (!_M_can_compare(__rhs))\n+\t  return false;\n+\t\n+\t/* Determine if we can order the iterators without the help of\n+\t   the container */\n+\tpair<difference_type, _Distance_precision> __dist = \n+\t  this->_M_get_distance(*this, __rhs);\n+\tswitch (__dist.second) {\n+\tcase __dp_equality:\n+\t  if (__dist.first == 0)\n+\t    return true;\n+\t  break;\n+\t  \n+\tcase __dp_sign:\n+\tcase __dp_exact:\n+\t  return __dist.first >= 0;\n+\t}\n+\t\n+\t/* We can only test for equality, but check if one of the\n+\t   iterators is at an extreme. */\n+\tif (_M_is_begin() || __rhs._M_is_end())\n+\t  return true;\n+\telse if (_M_is_end() || __rhs._M_is_begin())\n+\t  return false;\n+\t\n+\t// Assume that this is a valid range; we can't check anything else\n+\treturn true;\n+      }\n+\n+  template<typename _Iterator, typename _Sequence>\n+    void\n+    _Safe_iterator<_Iterator, _Sequence>::\n+    _M_invalidate()\n+    {\n+      typedef typename _Sequence::iterator iterator;\n+      typedef typename _Sequence::const_iterator const_iterator;\n+      \n+      if (!this->_M_singular())\n+\t{\n+\t  for (_Safe_iterator_base* iter = _M_sequence->_M_iterators; iter; )\n+\t    {\n+\t      iterator* __victim = static_cast<iterator*>(iter);\n+\t      iter = iter->_M_next;\n+\t      if (this->base() == __victim->base())\n+\t\t__victim->_M_version = 0;\n+\t    }\n+\t  for (_Safe_iterator_base* iter = _M_sequence->_M_const_iterators;\n+\t       iter; /* increment in loop */)\n+\t    {\n+\t      const_iterator* __victim = static_cast<const_iterator*>(iter);\n+\t      iter = iter->_M_next;\n+\t      if (this->base() == __victim->base())\n+\t\t__victim->_M_version = 0;\n+\t    }\n+\t  _M_version = 0;\n+\t}\n+    }\n+} // namespace __gnu_debug\n+\n+#endif \n+"}, {"sha": "cb2d8ae3872b2906ab018374bcc52771c4ab8fe9", "filename": "libstdc++-v3/include/debug/safe_sequence.h", "status": "added", "additions": 179, "deletions": 0, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fsafe_sequence.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,179 @@\n+// Safe sequence implementation  -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_SAFE_SEQUENCE_H\n+#define _GLIBCXX_DEBUG_SAFE_SEQUENCE_H 1\n+\n+#include <debug/debug.h>\n+#include <debug/safe_base.h>\n+\n+namespace __gnu_debug\n+{\n+  template<typename _Iterator, typename _Sequence> \n+    class _Safe_iterator;\n+\n+  /** A simple function object that returns true if the passed-in\n+   *  value is not equal to the stored value. It saves typing over\n+   *  using both bind1st and not_equal. \n+   */\n+  template<typename _Type>\n+    class _Not_equal_to\n+    {\n+      _Type __value;\n+      \n+    public:\n+      explicit _Not_equal_to(const _Type& __v) : __value(__v) { }\n+      \n+      bool \n+      operator()(const _Type& __x) const \n+      { return __value != __x; }\n+    };\n+  \n+  /** A function object that returns true when the given random access\n+      iterator is at least @c n steps away from the given iterator. */\n+  template<typename _Iterator>\n+    class _After_nth_from\n+    {\n+      typedef typename std::iterator_traits<_Iterator>::difference_type\n+      difference_type;\n+      \n+      _Iterator _M_base;\n+      difference_type _M_n;\n+      \n+    public:\n+      _After_nth_from(const difference_type& __n, const _Iterator& __base)\n+      : _M_base(__base), _M_n(__n) { }\n+      \n+      bool \n+      operator()(const _Iterator& __x) const\n+      { return __x - _M_base >= _M_n; }\n+    };\n+  \n+  /**\n+   * @brief Base class for constructing a \"safe\" sequence type that\n+   * tracks iterators that reference it.\n+   *\n+   * The class template %_Safe_sequence simplifies the construction of\n+   * \"safe\" sequences that track the iterators that reference the\n+   * sequence, so that the iterators are notified of changes in the\n+   * sequence that may affect their operation, e.g., if the container\n+   * invalidates its iterators or is destructed. This class template\n+   * may only be used by deriving from it and passing the name of the\n+   * derived class as its template parameter via the curiously\n+   * recurring template pattern. The derived class must have @c\n+   * iterator and @const_iterator types that are instantiations of\n+   * class template _Safe_iterator for this sequence. Iterators will\n+   * then be tracked automatically.\n+   */\n+  template<typename _Sequence>\n+    class _Safe_sequence : public _Safe_sequence_base\n+    {\n+    public:\n+      /** Invalidates all iterators @c x that reference this sequence,\n+\t  are not singular, and for which @c pred(x) returns @c\n+\t  true. The user of this routine should be careful not to make\n+\t  copies of the iterators passed to @p pred, as the copies may\n+\t  interfere with the invalidation. */\n+      template<typename _Predicate> \n+        void \n+        _M_invalidate_if(_Predicate __pred);\n+\n+      /** Transfers all iterators that reference this memory location\n+\t  to this sequence from whatever sequence they are attached\n+\t  to. */\n+      template<typename _Iterator>\n+        void\n+        _M_transfer_iter(const _Safe_iterator<_Iterator, _Sequence>& __x);\n+    };\n+\n+  template<typename _Sequence>\n+    template<typename _Predicate> \n+      void \n+      _Safe_sequence<_Sequence>::\n+      _M_invalidate_if(_Predicate __pred)\n+      {\n+        typedef typename _Sequence::iterator iterator;\n+        typedef typename _Sequence::const_iterator const_iterator;\n+        \n+        for (_Safe_iterator_base* __iter = _M_iterators; __iter; )\n+        {\n+          iterator* __victim = static_cast<iterator*>(__iter);\n+          __iter = __iter->_M_next;\n+          if (!__victim->_M_singular()) \n+          {\n+\t    if (__pred(__victim->base()))\n+\t      __victim->_M_invalidate();\n+          }\n+        }\n+\n+        for (_Safe_iterator_base* __iter = _M_const_iterators; __iter; )\n+        {\n+          const_iterator* __victim = static_cast<const_iterator*>(__iter);\n+          __iter = __iter->_M_next;\n+          if (!__victim->_M_singular()) \n+          {\n+\t    if (__pred(__victim->base()))\n+\t      __victim->_M_invalidate();\n+          }\n+        }    \n+      }\n+\n+  template<typename _Sequence>\n+    template<typename _Iterator>\n+      void\n+      _Safe_sequence<_Sequence>::\n+      _M_transfer_iter(const _Safe_iterator<_Iterator, _Sequence>& __x)\n+      {\n+\t_Safe_sequence_base* __from = __x._M_sequence;\n+\tif (!__from)\n+\t  return;\n+\n+        typedef typename _Sequence::iterator iterator;\n+        typedef typename _Sequence::const_iterator const_iterator;\n+        \n+        for (_Safe_iterator_base* __iter = __from->_M_iterators; __iter; )\n+        {\n+          iterator* __victim = static_cast<iterator*>(__iter);\n+          __iter = __iter->_M_next;\n+          if (!__victim->_M_singular() && __victim->base() == __x.base())\n+\t    __victim->_M_attach(static_cast<_Sequence*>(this));\n+        }\n+\n+        for (_Safe_iterator_base* __iter = __from->_M_const_iterators; __iter;)\n+        {\n+          const_iterator* __victim = static_cast<const_iterator*>(__iter);\n+          __iter = __iter->_M_next;\n+          if (!__victim->_M_singular() && __victim->base() == __x.base())\n+\t    __victim->_M_attach(static_cast<_Sequence*>(this));\n+        }\n+      }\n+} // namespace __gnu_debug\n+\n+#endif "}, {"sha": "a1a69efb4f4c837578c675a099bca258fa5f641d", "filename": "libstdc++-v3/include/debug/set", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,38 @@\n+// Debugging set/multiset implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_SET\n+#define _GLIBCXX_DEBUG_SET 1\n+\n+#include <set>\n+#include <debug/set.h>\n+#include <debug/multiset.h>\n+\n+#endif"}, {"sha": "861077d7557896cf7c9b77d0f5f39c860734687f", "filename": "libstdc++-v3/include/debug/set.h", "status": "added", "additions": 325, "deletions": 0, "changes": 325, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fset.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,325 @@\n+// Debugging set implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_SET_H\n+#define _GLIBCXX_DEBUG_SET_H 1\n+\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <utility>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Key, typename _Compare = std::less<_Key>,\n+\t   typename _Allocator = std::allocator<_Key> >\n+    class set\n+    : public __gnu_norm::set<_Key,_Compare,_Allocator>,\n+      public __gnu_debug::_Safe_sequence<set<_Key, _Compare, _Allocator> >\n+    {\n+      typedef __gnu_norm::set<_Key,_Compare,_Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<set> _Safe_base;\n+      \n+    public:\n+      // types:\n+      typedef _Key \t \t\t\t    key_type;\n+      typedef _Key \t \t\t\t    value_type;\n+      typedef _Compare   \t\t\t    key_compare;\n+      typedef _Compare   \t\t\t    value_compare;\n+      typedef _Allocator \t\t\t    allocator_type;\n+      typedef typename _Allocator::reference        reference;\n+      typedef typename _Allocator::const_reference  const_reference;\n+      \n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, set> \n+                                                    iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, set>\n+                                                    const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+      typedef typename _Allocator::pointer          pointer;\n+      typedef typename _Allocator::const_pointer    const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+      \n+      // 23.3.3.1 construct/copy/destroy:\n+      explicit set(const _Compare& __comp = _Compare(),\n+\t\t   const _Allocator& __a = _Allocator())\n+      : _Base(__comp, __a) { }\n+      \n+      template<typename _InputIterator>\n+        set(_InputIterator __first, _InputIterator __last,\n+\t    const _Compare& __comp = _Compare(),\n+\t    const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), __last,\n+\t\t__comp, __a) { }\n+\n+      set(const set<_Key,_Compare,_Allocator>& __x) \n+      : _Base(__x), _Safe_base() { }\n+    \n+      set(const _Base& __x) : _Base(__x), _Safe_base() { }\n+      \n+      ~set() { }\n+      \n+      set<_Key,_Compare,_Allocator>& \n+      operator=(const set<_Key,_Compare,_Allocator>& __x)\n+      {\n+\t*static_cast<_Base*>(this) = __x;\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+      \n+      using _Base::get_allocator;\n+      \n+      // iterators:\n+      iterator       \n+      begin() \n+      { return iterator(_Base::begin(), this); }\n+      \n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+      \n+      iterator       \n+      end()\n+      { return iterator(_Base::end(), this); }\n+      \n+      const_iterator \n+      end() const   \n+      { return const_iterator(_Base::end(), this); }\n+      \n+      reverse_iterator \n+      rbegin()\n+      { return reverse_iterator(end()); }\n+      \n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+      \n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+      \n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+      \n+      // capacity:\n+      using _Base::empty;\n+      using _Base::size;\n+      using _Base::max_size;\n+      \n+      // modifiers:\n+      std::pair<iterator, bool> \n+      insert(const value_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, bool> __res = _Base::insert(__x);\n+\treturn std::pair<iterator, bool>(iterator(__res.first, this),\n+\t\t\t\t\t __res.second);\n+      }\n+      \n+      iterator \n+      insert(iterator __position, const value_type& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\treturn iterator(_Base::insert(__position.base(), __x), this);\n+      }\n+      \n+      template <typename _InputIterator>\n+        void \n+        insert(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::insert(__first, __last);\n+\t}\n+      \n+      void \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\t__position._M_invalidate();\n+\t_Base::erase(__position.base());\n+      }\n+      \n+      size_type \n+      erase(const key_type& __x)\n+      {\n+\titerator __victim = find(__x);\n+\tif (__victim == end())\n+          return 0;\n+\telse\n+        {\n+\t  __victim._M_invalidate();\n+\t  _Base::erase(__victim.base());\n+\t  return 1;\n+        }\n+      }\n+      \n+      void \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+\t\n+\twhile (__first != __last)\n+        this->erase(__first++);\n+      }\n+      \n+      void \n+      swap(set<_Key,_Compare,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+      \n+      void \n+      clear()\n+      { this->erase(begin(), end()); }\n+      \n+      // observers:\n+      using _Base::key_comp;\n+      using _Base::value_comp;\n+      \n+      // set operations:\n+      iterator \n+      find(const key_type& __x)\n+      { return iterator(_Base::find(__x), this); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      find(const key_type& __x) const\n+      { return const_iterator(_Base::find(__x), this); }\n+      \n+      using _Base::count;\n+      \n+      iterator \n+      lower_bound(const key_type& __x)\n+      { return iterator(_Base::lower_bound(__x), this); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      lower_bound(const key_type& __x) const\n+      { return const_iterator(_Base::lower_bound(__x), this); }\n+      \n+      iterator \n+      upper_bound(const key_type& __x)\n+      { return iterator(_Base::upper_bound(__x), this); }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      const_iterator \n+      upper_bound(const key_type& __x) const\n+      { return const_iterator(_Base::upper_bound(__x), this); }\n+      \n+      std::pair<iterator,iterator>\n+      equal_range(const key_type& __x)\n+      {\n+\ttypedef typename _Base::iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(iterator(__res.first, this),\n+\t\t\t      iterator(__res.second, this));\n+      }\n+      \n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 214. set::find() missing const overload\n+      std::pair<const_iterator,const_iterator>\n+      equal_range(const key_type& __x) const\n+      {\n+\ttypedef typename _Base::const_iterator _Base_iterator;\n+\tstd::pair<_Base_iterator, _Base_iterator> __res =\n+        _Base::equal_range(__x);\n+\treturn std::make_pair(const_iterator(__res.first, this),\n+\t\t\t      const_iterator(__res.second, this));\n+      }\n+      \n+      _Base&       \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+      \n+    private:\n+      void \n+      _M_invalidate_all()\n+      {\n+\ttypedef typename _Base::const_iterator _Base_const_iterator;\n+\ttypedef __gnu_debug::_Not_equal_to<_Base_const_iterator> _Not_equal;\n+\tthis->_M_invalidate_if(_Not_equal(_M_base().end()));\n+      }\n+    };\n+  \n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator==(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t       const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator!=(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t       const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator<(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t      const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator<=(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t       const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator>=(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t       const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    inline bool \n+    operator>(const set<_Key,_Compare,_Allocator>& __lhs,\n+\t      const set<_Key,_Compare,_Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Key, typename _Compare, typename _Allocator>\n+    void\n+    swap(set<_Key,_Compare,_Allocator>& __x, \n+\t set<_Key,_Compare,_Allocator>& __y)\n+    { return __x.swap(__y); }\n+} // namespace __gnu_debug_def\n+\n+#endif"}, {"sha": "5be5da6c1292675b09fd998fbdb5d4a93b8dc847", "filename": "libstdc++-v3/include/debug/string", "status": "added", "additions": 1001, "deletions": 0, "changes": 1001, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fstring?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,1001 @@\n+// Debugging string implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_STRING\n+#define _GLIBCXX_DEBUG_STRING 1\n+\n+#include <string>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug\n+{\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    class basic_string \n+    : public std::basic_string<_CharT, _Traits, _Allocator>,\n+      public __gnu_debug::_Safe_sequence<basic_string<_CharT, _Traits,\n+\t\t\t\t\t\t      _Allocator> >\n+    {\n+      typedef std::basic_string<_CharT, _Traits, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<basic_string>     _Safe_base;\n+\n+  public:\n+    // types:\n+    typedef _Traits                     \t       traits_type;\n+    typedef typename _Traits::char_type \t       value_type;\n+    typedef _Allocator                  \t       allocator_type;\n+    typedef typename _Allocator::size_type             size_type;\n+    typedef typename _Allocator::difference_type       difference_type;\n+    typedef typename _Allocator::reference             reference;\n+    typedef typename _Allocator::const_reference       const_reference;\n+    typedef typename _Allocator::pointer               pointer;\n+    typedef typename _Allocator::const_pointer         const_pointer;\n+\n+    typedef __gnu_debug::_Safe_iterator<typename _Base::iterator, basic_string>\n+                                                       iterator;\n+    typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator, \n+                                         basic_string> const_iterator;\n+\n+    typedef std::reverse_iterator<iterator>            reverse_iterator;\n+    typedef std::reverse_iterator<const_iterator>      const_reverse_iterator;\n+\n+    using _Base::npos;\n+\n+    // 21.3.1 construct/copy/destroy:\n+    explicit basic_string(const _Allocator& __a = _Allocator())\n+    : _Base(__a)\n+    { }\n+\n+    // Provides conversion from a release-mode string to a debug-mode string\n+    basic_string(const _Base& __base) : _Base(__base), _Safe_base() { }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 42. string ctors specify wrong default allocator \n+    basic_string(const basic_string& __str)\n+    : _Base(__str, 0, _Base::npos, __str.get_allocator()), _Safe_base()\n+    { }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 42. string ctors specify wrong default allocator \n+    basic_string(const basic_string& __str, size_type __pos,\n+\t\t   size_type __n = _Base::npos,\n+\t\t   const _Allocator& __a = _Allocator())\n+    : _Base(__str, __pos, __n, __a)\n+    { }\n+\n+    basic_string(const _CharT* __s, size_type __n,\n+\t\t   const _Allocator& __a = _Allocator())\n+    : _Base(__gnu_debug::__check_string(__s, __n), __n, __a)\n+    { }\n+\n+    basic_string(const _CharT* __s, const _Allocator& __a = _Allocator())\n+    : _Base(__gnu_debug::__check_string(__s), __a)\n+    { this->assign(__s); }\n+\n+    basic_string(size_type __n, _CharT __c,\n+\t\t   const _Allocator& __a = _Allocator())\n+    : _Base(__n, __c, __a)\n+    { }\n+\n+    template<typename _InputIterator>\n+      basic_string(_InputIterator __begin, _InputIterator __end,\n+\t\t     const _Allocator& __a = _Allocator())\n+      : _Base(__gnu_debug::__check_valid_range(__begin, __end), __end, __a)\n+      { }\n+\n+    ~basic_string() { }\n+\n+    basic_string& \n+    operator=(const basic_string& __str)\n+    {\n+      *static_cast<_Base*>(this) = __str;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    operator=(const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      *static_cast<_Base*>(this) = __s;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    operator=(_CharT __c)\n+    {\n+      *static_cast<_Base*>(this) = __c;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    // 21.3.2 iterators:\n+    iterator \n+    begin() \n+    { return iterator(_Base::begin(), this); }\n+\n+    const_iterator \n+    begin() const \n+    { return const_iterator(_Base::begin(), this); }\n+\n+    iterator \n+    end() \n+    { return iterator(_Base::end(), this); }\n+\n+    const_iterator \n+    end() const\n+    { return const_iterator(_Base::end(), this); }\n+\n+    reverse_iterator \n+    rbegin() \n+    { return reverse_iterator(end()); }\n+\n+    const_reverse_iterator \n+    rbegin() const\n+    { return const_reverse_iterator(end()); }\n+\n+    reverse_iterator\n+    rend()\n+    { return reverse_iterator(begin()); }\n+\n+    const_reverse_iterator \n+    rend() const \n+    { return const_reverse_iterator(begin()); }\n+\n+    // 21.3.3 capacity:\n+    using _Base::size;\n+    using _Base::length;\n+    using _Base::max_size;\n+\n+    void \n+    resize(size_type __n, _CharT __c)\n+    {\n+      _Base::resize(__n, __c);\n+      this->_M_invalidate_all();\n+    }\n+\n+    void \n+    resize(size_type __n)\n+    { this->resize(__n, _CharT()); }\n+\n+    using _Base::capacity;\n+    using _Base::reserve;\n+\n+    void \n+    clear()\n+    {\n+      _Base::clear();\n+      this->_M_invalidate_all();\n+    }\n+\n+    using _Base::empty;\n+\n+    // 21.3.4 element access:\n+    const_reference \n+    operator[](size_type __pos) const\n+    {\n+      _GLIBCXX_DEBUG_VERIFY(__pos <= this->size(),\n+\t\t\t    _M_message(::__gnu_debug::__msg_subscript_oob)\n+\t\t\t    ._M_sequence(*this, \"this\")\n+\t\t\t    ._M_integer(__pos, \"__pos\")\n+\t\t\t    ._M_integer(this->size(), \"size\"));\n+      return _M_base()[__pos];\n+    }\n+\n+    reference \n+    operator[](size_type __pos)\n+    {\n+      __glibcxx_check_subscript(__pos);\n+      return _M_base()[__pos];\n+    }\n+\n+    using _Base::at;\n+\n+    // 21.3.5 modifiers:\n+    basic_string& \n+    operator+=(const basic_string& __str)\n+    {\n+      _M_base() += __str;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    operator+=(const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      _M_base() += __s;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    operator+=(_CharT __c)\n+    {\n+      _M_base() += __c;\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    append(const basic_string& __str)\n+    {\n+      _Base::append(__str);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    append(const basic_string& __str, size_type __pos, size_type __n)\n+    {\n+      _Base::append(__str, __pos, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    append(const _CharT* __s, size_type __n)\n+    {\n+      __glibcxx_check_string_len(__s, __n);\n+      _Base::append(__s, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    append(const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      _Base::append(__s);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    append(size_type __n, _CharT __c)\n+    {\n+      _Base::append(__n, __c);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    template<typename _InputIterator>\n+      basic_string& \n+      append(_InputIterator __first, _InputIterator __last)\n+      {\n+\t__glibcxx_check_valid_range(__first, __last);\n+\t_Base::append(__first, __last);\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+    // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    // 7. string clause minor problems \n+    void \n+    push_back(_CharT __c)\n+    {\n+      _Base::push_back(__c);\n+      this->_M_invalidate_all();\n+    }\n+\n+    basic_string& \n+    assign(const basic_string& __x)\n+    {\n+      _Base::assign(__x);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    assign(const basic_string& __str, size_type __pos, size_type __n)\n+    {\n+      _Base::assign(__str, __pos, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    assign(const _CharT* __s, size_type __n)\n+    {\n+      __glibcxx_check_string_len(__s, __n);\n+      _Base::assign(__s, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    assign(const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      _Base::assign(__s);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    assign(size_type __n, _CharT __c)\n+    {\n+      _Base::assign(__n, __c);\n+      this->_M_invalidate_all();\n+      return *this;\t\n+    }\n+\n+    template<typename _InputIterator>\n+      basic_string& \n+      assign(_InputIterator __first, _InputIterator __last)\n+      {\n+\t__glibcxx_check_valid_range(__first, __last);\n+\t_Base::assign(__first, __last);\n+\tthis->_M_invalidate_all();\n+\treturn *this;\t\n+      }\n+\n+    basic_string& \n+    insert(size_type __pos1, const basic_string& __str)\n+    {\n+      _Base::insert(__pos1, __str);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    insert(size_type __pos1, const basic_string& __str,\n+\t   size_type __pos2, size_type __n)\n+    {\n+      _Base::insert(__pos1, __str, __pos2, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    insert(size_type __pos, const _CharT* __s, size_type __n)\n+    {\n+      __glibcxx_check_string(__s);\n+      _Base::insert(__pos, __s, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    insert(size_type __pos, const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      _Base::insert(__pos, __s);\n+      this->_M_invalidate_all();\n+      return *this;\t\n+    }\n+\n+    basic_string& \n+    insert(size_type __pos, size_type __n, _CharT __c)\n+    {\n+      _Base::insert(__pos, __n, __c);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    iterator \n+    insert(iterator __p, _CharT __c)\n+    {\n+      __glibcxx_check_insert(__p);\n+      typename _Base::iterator __res = _Base::insert(__p.base(), __c);\n+      this->_M_invalidate_all();\n+      return iterator(__res, this);\n+    }\n+\n+    void \n+    insert(iterator __p, size_type __n, _CharT __c)\n+    {\n+      __glibcxx_check_insert(__p);\n+      _Base::insert(__p.base(), __n, __c);\n+      this->_M_invalidate_all();\n+    }\n+\n+    template<typename _InputIterator>\n+      void \n+      insert(iterator __p, _InputIterator __first, _InputIterator __last)\n+      {\n+\t__glibcxx_check_insert_range(__p, __first, __last);\n+\t_Base::insert(__p.base(), __first, __last);\n+\tthis->_M_invalidate_all();\n+      }\n+\n+    basic_string& \n+    erase(size_type __pos = 0, size_type __n = _Base::npos)\n+    {\n+      _Base::erase(__pos, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    iterator \n+    erase(iterator __position)\n+    {\n+      __glibcxx_check_erase(__position);\n+      typename _Base::iterator __res = _Base::erase(__position.base());\n+      this->_M_invalidate_all();\n+      return iterator(__res, this);\n+    }\n+\n+    iterator \n+    erase(iterator __first, iterator __last)\n+    {\n+      // _GLIBCXX_RESOLVE_LIB_DEFECTS\n+      // 151. can't currently clear() empty container\n+      __glibcxx_check_erase_range(__first, __last);\n+      typename _Base::iterator __res = _Base::erase(__first.base(),\n+\t\t\t\t\t\t       __last.base());\n+      this->_M_invalidate_all();\n+      return iterator(__res, this);\n+    }\n+\n+    basic_string& \n+    replace(size_type __pos1, size_type __n1, const basic_string& __str)\n+    {\n+      _Base::replace(__pos1, __n1, __str);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t    size_type __pos2, size_type __n2)\n+    {\n+      _Base::replace(__pos1, __n1, __str, __pos2, __n2);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(size_type __pos, size_type __n1, const _CharT* __s, \n+\t    size_type __n2)\n+    {\n+      __glibcxx_check_string_len(__s, __n2);\n+      _Base::replace(__pos, __n1, __s, __n2);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(size_type __pos, size_type __n1, const _CharT* __s)\n+    {\n+      __glibcxx_check_string(__s);\n+      _Base::replace(__pos, __n1, __s);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(size_type __pos, size_type __n1, size_type __n2, _CharT __c)\n+    {\n+      _Base::replace(__pos, __n1, __n2, __c);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(iterator __i1, iterator __i2, const basic_string& __str)\n+    {\n+      __glibcxx_check_erase_range(__i1, __i2);\n+      _Base::replace(__i1.base(), __i2.base(), __str);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+    \n+    basic_string& \n+    replace(iterator __i1, iterator __i2, const _CharT* __s, size_type __n)\n+    {\n+      __glibcxx_check_erase_range(__i1, __i2);\n+      __glibcxx_check_string_len(__s, __n);\n+      _Base::replace(__i1.base(), __i2.base(), __s, __n);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(iterator __i1, iterator __i2, const _CharT* __s)\n+    {\n+      __glibcxx_check_erase_range(__i1, __i2);\n+      __glibcxx_check_string(__s);\n+      _Base::replace(__i1.base(), __i2.base(), __s);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    basic_string& \n+    replace(iterator __i1, iterator __i2, size_type __n, _CharT __c)\n+    {\n+      __glibcxx_check_erase_range(__i1, __i2);\n+      _Base::replace(__i1.base(), __i2.base(), __n, __c);\n+      this->_M_invalidate_all();\n+      return *this;\n+    }\n+\n+    template<typename _InputIterator>\n+      basic_string& \n+      replace(iterator __i1, iterator __i2,\n+\t      _InputIterator __j1, _InputIterator __j2)\n+      {\n+\t__glibcxx_check_erase_range(__i1, __i2);\n+\t__glibcxx_check_valid_range(__j1, __j2);\n+\t_Base::replace(__i1.base(), __i2.base(), __j1, __j2);\n+\tthis->_M_invalidate_all();\n+\treturn *this;\n+      }\n+\n+    size_type \n+    copy(_CharT* __s, size_type __n, size_type __pos = 0) const\n+    {\n+      __glibcxx_check_string_len(__s, __n);\n+      return _Base::copy(__s, __n, __pos);\n+    }\n+\n+    void \n+    swap(basic_string<_CharT,_Traits,_Allocator>& __x)\n+    {\n+      _Base::swap(__x);\n+      this->_M_swap(__x);\n+      this->_M_invalidate_all();\n+      __x._M_invalidate_all();\n+    }\n+\n+    // 21.3.6 string operations:\n+    const _CharT* \n+    c_str() const\n+    {\n+      const _CharT* __res = _Base::c_str();\n+      this->_M_invalidate_all();\n+      return __res;\n+    }\n+\n+    const _CharT* \n+    data() const\n+    {\n+      const _CharT* __res = _Base::data();\n+      this->_M_invalidate_all();\n+      return __res;\n+    }\n+\n+    using _Base::get_allocator;\n+\n+    size_type \n+    find(const basic_string& __str, size_type __pos = 0) const\n+    { return _Base::find(__str, __pos); }\n+\n+    size_type \n+    find(const _CharT* __s, size_type __pos, size_type __n) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::find(__s, __pos, __n);\n+    }\n+\n+    size_type \n+    find(const _CharT* __s, size_type __pos = 0) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::find(__s, __pos);\n+    }\n+\n+    size_type \n+    find(_CharT __c, size_type __pos = 0) const\n+    { return _Base::find(__c, __pos); }\n+\n+    size_type \n+    rfind(const basic_string& __str, size_type __pos = _Base::npos) const\n+    { return _Base::rfind(__str, __pos); }\n+\n+    size_type \n+    rfind(const _CharT* __s, size_type __pos, size_type __n) const\n+    { \n+      __glibcxx_check_string_len(__s, __n);\n+      return _Base::rfind(__s, __pos, __n);\n+    }\n+\n+    size_type \n+    rfind(const _CharT* __s, size_type __pos = _Base::npos) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::rfind(__s, __pos);\n+    }\n+\n+    size_type \n+    rfind(_CharT __c, size_type __pos = _Base::npos) const\n+    { return _Base::rfind(__c, __pos); }\n+\t\n+    size_type \n+    find_first_of(const basic_string& __str, size_type __pos = 0) const\n+    { return _Base::find_first_of(__str, __pos); }\n+\n+    size_type \n+    find_first_of(const _CharT* __s, size_type __pos, size_type __n) const\n+    { \n+      __glibcxx_check_string(__s);\n+      return _Base::find_first_of(__s, __pos, __n); \n+    }\n+\n+    size_type \n+    find_first_of(const _CharT* __s, size_type __pos = 0) const\n+    { \n+      __glibcxx_check_string(__s);\n+      return _Base::find_first_of(__s, __pos); \n+    }\n+\n+    size_type \n+    find_first_of(_CharT __c, size_type __pos = 0) const\n+    { return _Base::find_first_of(__c, __pos); }\n+\n+    size_type \n+    find_last_of(const basic_string& __str, size_type __pos = _Base::npos) const\n+    { return _Base::find_last_of(__str, __pos); }\n+\n+    size_type \n+    find_last_of(const _CharT* __s, size_type __pos, size_type __n) const\n+    { \n+      __glibcxx_check_string(__s);\n+      return _Base::find_last_of(__s, __pos, __n);\n+    }\n+\n+    size_type \n+    find_last_of(const _CharT* __s, size_type __pos = _Base::npos) const\n+    { \n+      __glibcxx_check_string(__s);\n+      return _Base::find_last_of(__s, __pos);\n+    }\n+\n+    size_type \n+    find_last_of(_CharT __c, size_type __pos = _Base::npos) const\n+    { return _Base::find_last_of(__c, __pos); }\n+\n+    size_type \n+    find_first_not_of(const basic_string& __str, size_type __pos = 0) const\n+    { return _Base::find_first_not_of(__str, __pos); }\n+\n+    size_type \n+    find_first_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n+    {\n+      __glibcxx_check_string_len(__s, __n);\n+      return _Base::find_first_not_of(__s, __pos, __n);\n+    }\n+\n+    size_type \n+    find_first_not_of(const _CharT* __s, size_type __pos = 0) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::find_first_not_of(__s, __pos);\n+    }\n+\n+    size_type \n+    find_first_not_of(_CharT __c, size_type __pos = 0) const\n+    { return _Base::find_first_not_of(__c, __pos); }\n+\n+    size_type \n+    find_last_not_of(const basic_string& __str,\n+\t\t\t\t  size_type __pos = _Base::npos) const\n+    { return _Base::find_last_not_of(__str, __pos); }\n+\n+    size_type \n+    find_last_not_of(const _CharT* __s, size_type __pos, size_type __n) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::find_last_not_of(__s, __pos, __n);\n+    }\n+\n+    size_type \n+    find_last_not_of(const _CharT* __s, size_type __pos = _Base::npos) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::find_last_not_of(__s, __pos);\n+    }\n+\n+    size_type \n+    find_last_not_of(_CharT __c, size_type __pos = _Base::npos) const\n+    { return _Base::find_last_not_of(__c, __pos); }\n+\n+    basic_string \n+    substr(size_type __pos = 0, size_type __n = _Base::npos) const\n+    { return basic_string(_Base::substr(__pos, __n)); }\n+\n+    int \n+    compare(const basic_string& __str) const\n+    { return _Base::compare(__str); }\n+\n+    int \n+    compare(size_type __pos1, size_type __n1,\n+\t\t  const basic_string& __str) const\n+    { return _Base::compare(__pos1, __n1, __str); }\n+\n+    int \n+    compare(size_type __pos1, size_type __n1, const basic_string& __str,\n+\t      size_type __pos2, size_type __n2) const\n+    { return _Base::compare(__pos1, __n1, __str, __pos2, __n2); }\n+\n+    int \n+    compare(const _CharT* __s) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::compare(__s);\n+    }\n+\n+    //  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    //  5. string::compare specification questionable\n+    int \n+    compare(size_type __pos1, size_type __n1, const _CharT* __s) const\n+    {\n+      __glibcxx_check_string(__s);\n+      return _Base::compare(__pos1, __n1, __s);\n+    }\n+\n+    //  _GLIBCXX_RESOLVE_LIB_DEFECTS\n+    //  5. string::compare specification questionable\n+    int \n+    compare(size_type __pos1, size_type __n1,const _CharT* __s,\n+\t      size_type __n2) const\n+    {\n+      __glibcxx_check_string_len(__s, __n2);\n+      return _Base::compare(__pos1, __n1, __s, __n2);\n+    }\n+\n+    _Base&       \n+    _M_base() { return *this; }\n+\n+    const _Base& \n+    _M_base() const { return *this; }\n+\n+    using _Safe_base::_M_invalidate_all;\n+  };\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT,_Traits,_Allocator>\n+    operator+(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return basic_string<_CharT,_Traits,_Allocator>(__lhs) += __rhs; }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT,_Traits,_Allocator>\n+    operator+(const _CharT* __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { \n+      __glibcxx_check_string(__lhs);\n+      return basic_string<_CharT,_Traits,_Allocator>(__lhs) += __rhs;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT,_Traits,_Allocator>\n+    operator+(_CharT __lhs, \n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return basic_string<_CharT,_Traits,_Allocator>(1, __lhs) += __rhs; }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT,_Traits,_Allocator>\n+    operator+(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const _CharT* __rhs)\n+    { \n+      __glibcxx_check_string(__rhs);\n+      return basic_string<_CharT,_Traits,_Allocator>(__lhs) += __rhs; \n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline basic_string<_CharT,_Traits,_Allocator>\n+    operator+(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      _CharT __rhs)\n+    { return basic_string<_CharT,_Traits,_Allocator>(__lhs) += __rhs; }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator==(const _CharT* __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs == __rhs._M_base();\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() == __rhs;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator!=(const _CharT* __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs != __rhs._M_base();\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() != __rhs;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator<(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator<(const _CharT* __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs < __rhs._M_base();\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator<(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() < __rhs;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator<=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator<=(const _CharT* __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs <= __rhs._M_base();\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator<=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() <= __rhs;\n+    }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator>=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator>=(const _CharT* __lhs,\n+\t       const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs >= __rhs._M_base();\n+    }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator>=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t       const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() >= __rhs;\n+    }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool \n+    operator>(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator>(const _CharT* __lhs,\n+\t      const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    {\n+      __glibcxx_check_string(__lhs);\n+      return __lhs > __rhs._M_base();\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline bool\n+    operator>(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t      const _CharT* __rhs)\n+    {\n+      __glibcxx_check_string(__rhs);\n+      return __lhs._M_base() > __rhs;\n+    }\n+\n+  // 21.3.7.8:\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    inline void \n+    swap(basic_string<_CharT,_Traits,_Allocator>& __lhs,\n+\t basic_string<_CharT,_Traits,_Allocator>& __rhs)\n+    { __lhs.swap(__rhs); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    std::basic_ostream<_CharT, _Traits>&\n+    operator<<(std::basic_ostream<_CharT, _Traits>& __os,\n+\t       const basic_string<_CharT, _Traits, _Allocator>& __str)\n+    { return __os << __str._M_base(); }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    std::basic_istream<_CharT,_Traits>&\n+    operator>>(std::basic_istream<_CharT,_Traits>& __is,\n+\t       basic_string<_CharT,_Traits,_Allocator>& __str)\n+    {\n+      std::basic_istream<_CharT,_Traits>& __res = __is >> __str._M_base();\n+      __str._M_invalidate_all();\n+      return __res;\n+    }\n+\n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    std::basic_istream<_CharT,_Traits>&\n+    getline(std::basic_istream<_CharT,_Traits>& __is,\n+\t    basic_string<_CharT,_Traits,_Allocator>& __str, _CharT __delim)\n+    {\n+      std::basic_istream<_CharT,_Traits>& __res = getline(__is, \n+\t\t\t\t\t\t\t  __str._M_base(),\n+\t\t\t\t\t\t\t__delim);\n+      __str._M_invalidate_all();\n+      return __res;\n+    }\n+  \n+  template<typename _CharT, typename _Traits, typename _Allocator>\n+    std::basic_istream<_CharT,_Traits>&\n+    getline(std::basic_istream<_CharT,_Traits>& __is,\n+\t    basic_string<_CharT,_Traits,_Allocator>& __str)\n+    {\n+      std::basic_istream<_CharT,_Traits>& __res = getline(__is, \n+\t\t\t\t\t\t\t  __str._M_base());\n+      __str._M_invalidate_all();\n+      return __res;\n+    }\n+} // namespace __gnu_debug\n+\n+#endif "}, {"sha": "19249b6bb818b6edc824dd260ff4be274d9e4b72", "filename": "libstdc++-v3/include/debug/vector", "status": "added", "additions": 409, "deletions": 0, "changes": 409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Fvector?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,409 @@\n+// Debugging vector implementation -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#ifndef _GLIBCXX_DEBUG_VECTOR\n+#define _GLIBCXX_DEBUG_VECTOR 1\n+\n+#include <vector>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+\n+namespace __gnu_debug_def\n+{\n+  template<typename _Tp, \n+\t   typename _Allocator = std::allocator<_Tp> >\n+    class vector\n+    : public __gnu_norm::vector<_Tp, _Allocator>,\n+      public __gnu_debug::_Safe_sequence<vector<_Tp, _Allocator> >\n+    {\n+      typedef __gnu_norm::vector<_Tp, _Allocator> _Base;\n+      typedef __gnu_debug::_Safe_sequence<vector>              _Safe_base;\n+\n+      typedef typename _Base::const_iterator _Base_const_iterator;\n+      typedef __gnu_debug::_After_nth_from<_Base_const_iterator> _After_nth;\n+\n+    public:\n+      typedef typename _Base::reference             reference;\n+      typedef typename _Base::const_reference       const_reference;\n+\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::iterator,vector> \n+      iterator;\n+      typedef __gnu_debug::_Safe_iterator<typename _Base::const_iterator,vector>\n+      const_iterator;\n+\n+      typedef typename _Base::size_type             size_type;\n+      typedef typename _Base::difference_type       difference_type;\n+\n+      typedef _Tp        \t\t\t    value_type;\n+      typedef _Allocator \t\t\t    allocator_type;\n+      typedef typename _Allocator::pointer          pointer;\n+      typedef typename _Allocator::const_pointer    const_pointer;\n+      typedef std::reverse_iterator<iterator>       reverse_iterator;\n+      typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n+\n+      // 23.2.4.1 construct/copy/destroy:\n+      explicit vector(const _Allocator& __a = _Allocator())\n+      : _Base(__a), _M_guaranteed_capacity(0) { }\n+\n+      explicit vector(size_type __n, const _Tp& __value = _Tp(),\n+\t\t      const _Allocator& __a = _Allocator())\n+      : _Base(__n, __value, __a), _M_guaranteed_capacity(__n) { }\n+\n+      template<class _InputIterator>\n+        vector(_InputIterator __first, _InputIterator __last,\n+\t       const _Allocator& __a = _Allocator())\n+\t: _Base(__gnu_debug::__check_valid_range(__first, __last), \n+\t\t__last, __a),\n+\t  _M_guaranteed_capacity(0)\n+        { _M_update_guaranteed_capacity(); }\n+\n+      vector(const vector<_Tp,_Allocator>& __x) \n+      : _Base(__x), _Safe_base(), _M_guaranteed_capacity(__x.size()) { }\n+\n+      /// Construction from a release-mode vector\n+      vector(const _Base& __x) \n+      : _Base(__x), _Safe_base(), _M_guaranteed_capacity(__x.size()) { }\n+\n+      ~vector() { }\n+\n+      vector<_Tp,_Allocator>& \n+      operator=(const vector<_Tp,_Allocator>& __x)\n+      {\n+\tstatic_cast<_Base&>(*this) = __x;\n+\tthis->_M_invalidate_all();\n+\t_M_update_guaranteed_capacity();\n+\treturn *this;\n+      }\n+\n+      template<typename _InputIterator>\n+        void \n+        assign(_InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_valid_range(__first, __last);\n+\t  _Base::assign(__first, __last);\n+\t  this->_M_invalidate_all();\n+\t  _M_update_guaranteed_capacity();\n+\t}\n+\n+      void \n+      assign(size_type __n, const _Tp& __u)\n+      {\n+\t_Base::assign(__n, __u);\n+\tthis->_M_invalidate_all();\n+\t_M_update_guaranteed_capacity();\n+      }\n+\n+      using _Base::get_allocator;\n+\n+      // iterators:\n+      iterator \n+      begin() \n+      { return iterator(_Base::begin(), this); }\n+\n+      const_iterator \n+      begin() const \n+      { return const_iterator(_Base::begin(), this); }\n+\n+      iterator \n+      end()\n+      { return iterator(_Base::end(), this); }\n+\n+      const_iterator \n+      end() const\n+      { return const_iterator(_Base::end(), this); }\n+\n+      reverse_iterator \n+      rbegin() \n+      { return reverse_iterator(end()); }\n+\n+      const_reverse_iterator \n+      rbegin() const\n+      { return const_reverse_iterator(end()); }\n+\n+      reverse_iterator \n+      rend() \n+      { return reverse_iterator(begin()); }\n+\n+      const_reverse_iterator \n+      rend() const \n+      { return const_reverse_iterator(begin()); }\n+\n+      // 23.2.4.2 capacity:\n+      using _Base::size;\n+      using _Base::max_size;\n+\n+      void \n+      resize(size_type __sz, _Tp __c = _Tp())\n+      {\n+\tbool __realloc = _M_requires_reallocation(__sz);\n+\tif (__sz < this->size())\n+\t  this->_M_invalidate_if(_After_nth(__sz, _M_base().begin()));\n+\t_Base::resize(__sz, __c);\n+\tif (__realloc)\n+\t  this->_M_invalidate_all();\n+      }\n+\n+      using _Base::capacity;\n+      using _Base::empty;\n+\n+      void \n+      reserve(size_type __n)\n+      {\n+\tbool __realloc = _M_requires_reallocation(__n);\n+\t_Base::reserve(__n);\n+\tif (__n > _M_guaranteed_capacity)\n+\t  _M_guaranteed_capacity = __n;\n+\tif (__realloc)\n+\t  this->_M_invalidate_all();\n+      }\n+\n+      // element access:\n+      reference \n+      operator[](size_type __n)\n+      {\n+\t__glibcxx_check_subscript(__n);\n+\treturn _M_base()[__n];\n+      }\n+\n+      const_reference \n+      operator[](size_type __n) const\n+      {\n+\t__glibcxx_check_subscript(__n);\n+\treturn _M_base()[__n];\n+      }\n+\n+      using _Base::at;\n+\n+      reference \n+      front()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+\n+      const_reference \n+      front() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::front();\n+      }\n+\n+      reference \n+      back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+\n+      const_reference \n+      back() const\n+      {\n+\t__glibcxx_check_nonempty();\n+\treturn _Base::back();\n+      }\n+\n+      // 23.2.4.3 modifiers:\n+      void \n+      push_back(const _Tp& __x)\n+      {\n+\tbool __realloc = _M_requires_reallocation(this->size() + 1);\n+\t_Base::push_back(__x);\n+\tif (__realloc)\n+\t  this->_M_invalidate_all();\n+\t_M_update_guaranteed_capacity();\n+      }\n+\n+      void \n+      pop_back()\n+      {\n+\t__glibcxx_check_nonempty();\n+\titerator __victim = end() - 1;\n+\t__victim._M_invalidate();\n+\t_Base::pop_back();\n+      }\n+\n+      iterator \n+      insert(iterator __position, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\tbool __realloc = _M_requires_reallocation(this->size() + 1);\n+\tdifference_type __offset = __position - begin();\n+\ttypename _Base::iterator __res = _Base::insert(__position.base(),__x);\n+\tif (__realloc)\n+\t  this->_M_invalidate_all();\n+\telse\n+\t  this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t_M_update_guaranteed_capacity();\n+\treturn iterator(__res, this);\n+      }\n+\n+      void \n+      insert(iterator __position, size_type __n, const _Tp& __x)\n+      {\n+\t__glibcxx_check_insert(__position);\n+\tbool __realloc = _M_requires_reallocation(this->size() + __n);\n+\tdifference_type __offset = __position - begin();\n+\t_Base::insert(__position.base(), __n, __x);\n+\tif (__realloc)\n+\t  this->_M_invalidate_all();\n+\telse\n+\t  this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t_M_update_guaranteed_capacity();\n+      }\n+\n+      template<class _InputIterator>\n+        void \n+        insert(iterator __position, \n+\t       _InputIterator __first, _InputIterator __last)\n+        {\n+\t  __glibcxx_check_insert_range(__position, __first, __last);\n+\t  \n+\t  /* Hard to guess if invalidation will occur, because __last\n+\t     - __first can't be calculated in all cases, so we just\n+\t     punt here by checking if it did occur. */\n+\t  typename _Base::iterator __old_begin = _M_base().begin();\n+\t  difference_type __offset = __position - begin();\n+\t  _Base::insert(__position.base(), __first, __last);\n+\t  \n+\t  if (_M_base().begin() != __old_begin)\n+\t    this->_M_invalidate_all();\n+\t  else\n+\t    this->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\t  _M_update_guaranteed_capacity();\n+\t}\n+      \n+      iterator \n+      erase(iterator __position)\n+      {\n+\t__glibcxx_check_erase(__position);\n+\tdifference_type __offset = __position - begin();\n+\ttypename _Base::iterator __res = _Base::erase(__position.base());\n+\tthis->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\treturn iterator(__res, this);\n+      }\n+\n+      iterator \n+      erase(iterator __first, iterator __last)\n+      {\n+\t// _GLIBCXX_RESOLVE_LIB_DEFECTS\n+\t// 151. can't currently clear() empty container\n+\t__glibcxx_check_erase_range(__first, __last);\n+      \n+\tdifference_type __offset = __first - begin();\n+\ttypename _Base::iterator __res = _Base::erase(__first.base(), \n+\t\t\t\t\t\t\t __last.base());\n+\tthis->_M_invalidate_if(_After_nth(__offset, _M_base().begin()));\n+\treturn iterator(__res, this);\n+      }\n+\n+      void \n+      swap(vector<_Tp,_Allocator>& __x)\n+      {\n+\t_Base::swap(__x);\n+\tthis->_M_swap(__x);\n+      }\n+\n+      void \n+      clear()\n+      {\n+\t_Base::clear();\n+\tthis->_M_invalidate_all();\n+      }\n+\n+      _Base&       \n+      _M_base() { return *this; }\n+\n+      const _Base& \n+      _M_base() const { return *this; }\n+\n+    private:\n+      size_type _M_guaranteed_capacity;\n+\n+      bool \n+      _M_requires_reallocation(size_type __elements)\n+      {\n+#ifdef _GLIBCXX_DEBUG_PEDANTIC\n+\treturn __elements > this->capacity();\n+#else\n+\treturn __elements > _M_guaranteed_capacity;\n+#endif\n+      }\n+      \n+      void \n+      _M_update_guaranteed_capacity()\n+      {\n+\tif (this->size() > _M_guaranteed_capacity)\n+\t  _M_guaranteed_capacity = this->size();\n+      }\n+    };\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator==(const vector<_Tp, _Alloc>& __lhs,\n+\t       const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() == __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator!=(const vector<_Tp, _Alloc>& __lhs, \n+\t       const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() != __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<(const vector<_Tp, _Alloc>& __lhs, \n+\t      const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() < __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator<=(const vector<_Tp, _Alloc>& __lhs, \n+\t       const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() <= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>=(const vector<_Tp, _Alloc>& __lhs, \n+\t       const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() >= __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline bool\n+    operator>(const vector<_Tp, _Alloc>& __lhs, \n+\t      const vector<_Tp, _Alloc>& __rhs)\n+    { return __lhs._M_base() > __rhs._M_base(); }\n+\n+  template<typename _Tp, typename _Alloc>\n+    inline void\n+    swap(vector<_Tp, _Alloc>& __lhs, vector<_Tp, _Alloc>& __rhs)\n+    { __lhs.swap(__rhs); }\n+} // namespace __gnu_debug_def\n+\n+#endif "}, {"sha": "dfb551535cd408298fe8dc121bf867a62258a936", "filename": "libstdc++-v3/include/ext/algorithm", "status": "modified", "additions": 18, "deletions": 37, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Falgorithm?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -208,6 +208,8 @@ namespace __gnu_cxx\n \t    typename iterator_traits<_InputIterator1>::value_type>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_InputIterator2>::value_type>)\n+      __glibcxx_requires_valid_range(__first1, __last1);\n+      __glibcxx_requires_valid_range(__first2, __last2);\n \n       return __lexicographical_compare_3way(__first1, __last1, __first2, __last2);\n     }\n@@ -226,6 +228,8 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_EqualityComparableConcept<\n \t    typename iterator_traits<_InputIterator>::value_type >)\n       __glibcxx_function_requires(_EqualityComparableConcept<_Tp>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+\n       for ( ; __first != __last; ++__first)\n \tif (*__first == __value)\n \t  ++__n;\n@@ -241,6 +245,8 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_UnaryPredicateConcept<_Predicate,\n \t    typename iterator_traits<_InputIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+\n       for ( ; __first != __last; ++__first)\n \tif (__pred(*__first))\n \t  ++__n;\n@@ -262,6 +268,7 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator,\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       _Distance __remaining = std::distance(__first, __last);\n       _Distance __m = min(__n, __remaining);\n@@ -297,6 +304,7 @@ namespace __gnu_cxx\n \t\ttypename iterator_traits<_ForwardIterator>::value_type>)\n       __glibcxx_function_requires(_UnaryFunctionConcept<\n \t\t_RandomNumberGenerator, _Distance, _Distance>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       _Distance __remaining = std::distance(__first, __last);\n       _Distance __m = min(__n, __remaining);\n@@ -378,6 +386,8 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_valid_range(__out_first, __out_last);\n \n       return __random_sample(__first, __last,\n \t\t\t     __out_first, __out_last - __out_first);\n@@ -399,46 +409,14 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_InputIteratorConcept<_InputIterator>)\n       __glibcxx_function_requires(_Mutable_RandomAccessIteratorConcept<\n \t    _RandomAccessIterator>)\n+      __glibcxx_requires_valid_range(__first, __last);\n+      __glibcxx_requires_valid_range(__out_first, __out_last);\n \n       return __random_sample(__first, __last,\n \t\t\t     __out_first, __rand,\n \t\t\t     __out_last - __out_first);\n     }\n   \n-  // is_heap, a predicate testing whether or not a range is\n-  // a heap.  This function is an extension, not part of the C++\n-  // standard.\n-\n-  template<typename _RandomAccessIterator, typename _Distance>\n-    bool\n-    __is_heap(_RandomAccessIterator __first, _Distance __n)\n-    {\n-      _Distance __parent = 0;\n-      for (_Distance __child = 1; __child < __n; ++__child) {\n-\tif (__first[__parent] < __first[__child]) \n-\t  return false;\n-\tif ((__child & 1) == 0)\n-\t  ++__parent;\n-      }\n-      return true;\n-    }\n-\n-  template<typename _RandomAccessIterator, typename _Distance,\n-           typename _StrictWeakOrdering>\n-    bool\n-    __is_heap(_RandomAccessIterator __first, _StrictWeakOrdering __comp,\n-\t      _Distance __n)\n-    {\n-      _Distance __parent = 0;\n-      for (_Distance __child = 1; __child < __n; ++__child) {\n-\tif (__comp(__first[__parent], __first[__child]))\n-\t  return false;\n-\tif ((__child & 1) == 0)\n-\t  ++__parent;\n-      }\n-      return true;\n-    }\n-\n   /**\n    *  This is an SGI extension.\n    *  @ingroup SGIextensions\n@@ -452,8 +430,9 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_RandomAccessIteratorConcept<_RandomAccessIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n-      return __is_heap(__first, __last - __first);\n+      return std::__is_heap(__first, __last - __first);\n     }\n \n   /**\n@@ -471,8 +450,9 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n \t    typename iterator_traits<_RandomAccessIterator>::value_type, \n \t    typename iterator_traits<_RandomAccessIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n-      return __is_heap(__first, __comp, __last - __first);\n+      return std::__is_heap(__first, __comp, __last - __first);\n     }\n \n   // is_sorted, a predicated testing whether a range is sorted in\n@@ -492,6 +472,7 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_ForwardIteratorConcept<_ForwardIterator>)\n       __glibcxx_function_requires(_LessThanComparableConcept<\n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn true;\n@@ -519,6 +500,7 @@ namespace __gnu_cxx\n       __glibcxx_function_requires(_BinaryPredicateConcept<_StrictWeakOrdering,\n \t    typename iterator_traits<_ForwardIterator>::value_type, \n \t    typename iterator_traits<_ForwardIterator>::value_type>)\n+      __glibcxx_requires_valid_range(__first, __last);\n \n       if (__first == __last)\n \treturn true;\n@@ -531,7 +513,6 @@ namespace __gnu_cxx\n \n       return true;\n     }\n-\n } // namespace __gnu_cxx\n \n #endif /* _EXT_ALGORITHM */"}, {"sha": "40e6246ce7f9f547a6e6efee804c4997c910c29f", "filename": "libstdc++-v3/include/std/std_algorithm.h", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_algorithm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_algorithm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_algorithm.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -69,7 +69,3 @@\n #include <bits/stl_algo.h>\n \n #endif /* _GLIBCXX_ALGORITHM */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "345affc77508530110a0833d1a8577eaebeb2a6e", "filename": "libstdc++-v3/include/std/std_bitset.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_bitset.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -50,21 +50,21 @@\n \n #pragma GCC system_header\n \n-#include <cstddef>     // for size_t\n-#include <cstring>     // for memset\n-#include <limits>      // for numeric_limits\n+#include <cstddef>     // For size_t\n+#include <cstring>     // For memset\n+#include <limits>      // For numeric_limits\n #include <string>\n-#include <bits/functexcept.h>   // for invalid_argument, out_of_range,\n+#include <bits/functexcept.h>   // For invalid_argument, out_of_range,\n                                 // overflow_error\n-#include <ostream>     // for ostream (operator<<)\n-#include <istream>     // for istream (operator>>)\n+#include <ostream>     // For ostream (operator<<)\n+#include <istream>     // For istream (operator>>)\n \n \n #define _GLIBCXX_BITSET_BITS_PER_WORD  numeric_limits<unsigned long>::digits\n #define _GLIBCXX_BITSET_WORDS(__n) \\\n  ((__n) < 1 ? 0 : ((__n) + _GLIBCXX_BITSET_BITS_PER_WORD - 1)/_GLIBCXX_BITSET_BITS_PER_WORD)\n \n-namespace std\n+namespace __gnu_norm\n {\n   /**\n    *  @if maint\n@@ -646,7 +646,7 @@ namespace std\n \n       ~reference() { }\n \n-      // for b[i] = __x;\n+      // For b[i] = __x;\n       reference&\n       operator=(bool __x)\n       {\n@@ -657,7 +657,7 @@ namespace std\n \treturn *this;\n       }\n \n-      // for b[i] = b[__j];\n+      // For b[i] = b[__j];\n       reference&\n       operator=(const reference& __j)\n       {\n@@ -668,16 +668,16 @@ namespace std\n \treturn *this;\n       }\n \n-      // flips the bit\n+      // Flips the bit\n       bool\n       operator~() const\n       { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) == 0; }\n \n-      // for __x = b[i];\n+      // For __x = b[i];\n       operator bool() const\n       { return (*(_M_wp) & _Base::_S_maskbit(_M_bpos)) != 0; }\n \n-      // for b[i].flip();\n+      // For b[i].flip();\n       reference&\n       flip()\n       {\n@@ -1207,9 +1207,13 @@ namespace std\n       return __os << __tmp;\n     }\n   //@}\n-} // namespace std\n+} // namespace __gnu_norm\n \n #undef _GLIBCXX_BITSET_WORDS\n #undef _GLIBCXX_BITSET_BITS_PER_WORD\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/bitset>\n+#endif\n+\n #endif /* _GLIBCXX_BITSET */"}, {"sha": "80817f632aa57bcb3db41d5c67658ace4836c581", "filename": "libstdc++-v3/include/std/std_deque.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_deque.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -74,4 +74,8 @@\n # include <bits/deque.tcc>\n #endif\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/deque>\n+#endif\n+\n #endif /* _GLIBCXX_DEQUE */"}, {"sha": "6819f20b6f0fd362f1bb15b1affb9c6ecfd02fcd", "filename": "libstdc++-v3/include/std/std_functional.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_functional.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_functional.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_functional.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -50,13 +50,9 @@\n #define _GLIBCXX_FUNCTIONAL 1\n \n #pragma GCC system_header\n+\n #include <bits/c++config.h>\n #include <cstddef>\n #include <bits/stl_function.h>\n \n #endif /* _GLIBCXX_FUNCTIONAL */\n-\n-// Local Variables:\n-// mode:C++\n-// End:\n-"}, {"sha": "6e3840b1e7e3c225302efb1cb148670285b5c095", "filename": "libstdc++-v3/include/std/std_iterator.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iterator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iterator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_iterator.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,6 +62,7 @@\n #define _GLIBCXX_ITERATOR 1\n \n #pragma GCC system_header\n+\n #include <bits/c++config.h>\n #include <cstddef>\n #include <bits/stl_iterator_base_types.h>\n@@ -73,7 +74,3 @@\n #include <bits/streambuf_iterator.h>\n \n #endif /* _GLIBCXX_ITERATOR */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "285a29d8131c324ee0b839e87cb88ba545e16f8c", "filename": "libstdc++-v3/include/std/std_list.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_list.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -74,5 +74,9 @@\n # include <bits/list.tcc>\n #endif\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/list>\n+#endif\n+\n #endif /* _GLIBCXX_LIST */\n "}, {"sha": "4a88ae22ea3311a89a7b4bdfb45e2f754881cc4a", "filename": "libstdc++-v3/include/std/std_map.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_map.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -67,8 +67,8 @@\n #include <bits/stl_map.h>\n #include <bits/stl_multimap.h>\n \n-#endif /* _GLIBCXX_MAP */\n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/map>\n+#endif\n \n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif /* _GLIBCXX_MAP */"}, {"sha": "eb2923276f7cdfedb6945613c2e42adfbaaabfa8", "filename": "libstdc++-v3/include/std/std_memory.h", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_memory.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -57,6 +57,7 @@\n #include <bits/stl_iterator_base_types.h> //for iterator_traits\n #include <bits/stl_uninitialized.h>\n #include <bits/stl_raw_storage_iter.h>\n+#include <debug/debug.h>\n \n namespace std\n {\n@@ -259,7 +260,11 @@ namespace std\n        *  what happens when you dereference one of those...)\n        */\n       element_type&\n-      operator*() const throw() { return *_M_ptr; }\n+      operator*() const throw() \n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn *_M_ptr; \n+      }\n       \n       /**\n        *  @brief  Smart pointer dereferencing.\n@@ -268,7 +273,11 @@ namespace std\n        *  automatically cause to be dereferenced.\n        */\n       element_type*\n-      operator->() const throw() { return _M_ptr; }\n+      operator->() const throw() \n+      {\n+\t_GLIBCXX_DEBUG_ASSERT(_M_ptr != 0);\n+\treturn _M_ptr; \n+      }\n       \n       /**\n        *  @brief  Bypassing the smart pointer."}, {"sha": "88661e9f5a44d52bacb33418008f46afbf4cedd2", "filename": "libstdc++-v3/include/std/std_numeric.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_numeric.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_numeric.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_numeric.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,14 +62,11 @@\n #define _GLIBCXX_NUMERIC 1\n \n #pragma GCC system_header\n+\n #include <bits/c++config.h>\n #include <cstddef>\n #include <iterator>\n #include <bits/stl_function.h>\n #include <bits/stl_numeric.h>\n \n #endif /* _GLIBCXX_NUMERIC */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "9a6523bef87bfc6610d9326e888a9a8d6f736453", "filename": "libstdc++-v3/include/std/std_queue.h", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_queue.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,21 +62,17 @@\n #define _GLIBCXX_QUEUE 1\n \n #pragma GCC system_header\n+\n #include <bits/c++config.h>\n #include <bits/functexcept.h>\n #include <bits/stl_algobase.h>\n #include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n-#include <bits/stl_vector.h>\n #include <bits/stl_heap.h>\n-#include <bits/stl_deque.h>\n #include <bits/stl_function.h>\n+#include <deque>\n+#include <vector>\n #include <bits/stl_queue.h>\n \n-#ifndef _GLIBCXX_EXPORT_TEMPLATE\n-#  include <bits/deque.tcc>\n-#  include <bits/vector.tcc>\n-#endif\n-\n #endif /* _GLIBCXX_QUEUE */"}, {"sha": "7ef8c9fef3bd2acee0b5e9163bdf2ecaf31595b9", "filename": "libstdc++-v3/include/std/std_set.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_set.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_set.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_set.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -67,8 +67,8 @@\n #include <bits/stl_set.h>\n #include <bits/stl_multiset.h>\n \n-#endif /* _GLIBCXX_SET */\n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/set>\n+#endif\n \n-// Local Variables:\n-// mode:C++\n-// End:\n+#endif /* _GLIBCXX_SET */"}, {"sha": "70f045684e0eb9d0589e8f29d2be81980adbf89b", "filename": "libstdc++-v3/include/std/std_stack.h", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_stack.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -67,11 +67,7 @@\n #include <bits/allocator.h>\n #include <bits/stl_construct.h>\n #include <bits/stl_uninitialized.h>\n-#include <bits/stl_deque.h>\n+#include <deque>\n #include <bits/stl_stack.h>\n \n-#ifndef _GLIBCXX_EXPORT_TEMPLATE\n-# include <bits/deque.tcc>\n-#endif\n-\n #endif /* _GLIBCXX_STACK */"}, {"sha": "fe93090f9399440ab63b5b5b303abe3b78acc2d6", "filename": "libstdc++-v3/include/std/std_utility.h", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_utility.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_utility.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_utility.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -62,12 +62,9 @@\n #define _GLIBCXX_UTILITY 1\n \n #pragma GCC system_header\n+\n #include <bits/c++config.h>\n #include <bits/stl_relops.h>\n #include <bits/stl_pair.h>\n \n #endif /* _GLIBCXX_UTILITY */\n-\n-// Local Variables:\n-// mode:C++\n-// End:"}, {"sha": "7dac89dadb01c144301e4bceb5dca97c85183675", "filename": "libstdc++-v3/include/std/std_valarray.h", "status": "modified", "additions": 24, "deletions": 7, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_valarray.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -46,6 +46,7 @@\n #include <cstdlib>\n #include <numeric>\n #include <algorithm>\n+#include <debug/debug.h>\n \n namespace std\n {\n@@ -221,12 +222,18 @@ namespace std\n   template<typename _Tp>\n     inline const _Tp&\n     valarray<_Tp>::operator[](size_t __i) const\n-    { return _M_data[__i]; }\n+    { \n+      __glibcxx_requires_subscript(__i);\n+      return _M_data[__i]; \n+    }\n \n   template<typename _Tp>\n     inline _Tp&\n     valarray<_Tp>::operator[](size_t __i)\n-    { return _M_data[__i]; }\n+    { \n+      __glibcxx_requires_subscript(__i);\n+      return _M_data[__i]; \n+    }\n \n } // std::\n \n@@ -260,7 +267,10 @@ namespace std\n     inline\n     valarray<_Tp>::valarray(const _Tp* __restrict__ __p, size_t __n)\n       : _M_size(__n), _M_data(__valarray_get_storage<_Tp>(__n))\n-    { std::__valarray_copy_construct(__p, __p + __n, _M_data); }\n+    { \n+      _GLIBCXX_DEBUG_ASSERT(__p != 0 || __n == 0);\n+      std::__valarray_copy_construct(__p, __p + __n, _M_data); \n+    }\n \n   template<typename _Tp>\n     inline\n@@ -324,6 +334,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const valarray<_Tp>& __v)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __v._M_size);\n       std::__valarray_copy(__v._M_data, _M_size, _M_data);\n       return *this;\n     }\n@@ -340,6 +351,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const slice_array<_Tp>& __sa)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __sa._M_sz);\n       std::__valarray_copy(__sa._M_array, __sa._M_sz,\n \t\t\t   __sa._M_stride, _Array<_Tp>(_M_data));\n       return *this;\n@@ -349,6 +361,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const gslice_array<_Tp>& __ga)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __ga._M_index.size());\n       std::__valarray_copy(__ga._M_array, _Array<size_t>(__ga._M_index),\n \t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n@@ -358,6 +371,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const mask_array<_Tp>& __ma)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __ma._M_sz);\n       std::__valarray_copy(__ma._M_array, __ma._M_mask,\n \t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n@@ -367,6 +381,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const indirect_array<_Tp>& __ia)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __ia._M_sz);\n       std::__valarray_copy(__ia._M_array, __ia._M_index,\n \t\t\t   _Array<_Tp>(_M_data), _M_size);\n       return *this;\n@@ -376,6 +391,7 @@ namespace std\n     inline valarray<_Tp>&\n     valarray<_Tp>::operator=(const _Expr<_Dom, _Tp>& __e)\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __e.size());\n       std::__valarray_copy(__e, _M_size, _Array<_Tp>(_M_data));\n       return *this;\n     }\n@@ -460,6 +476,7 @@ namespace std\n     inline _Tp\n     valarray<_Tp>::sum() const\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size > 0);\n       return std::__valarray_sum(_M_data, _M_data + _M_size);\n     }\n \n@@ -540,13 +557,15 @@ namespace std\n     inline _Tp\n     valarray<_Tp>::min() const\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size > 0);\n       return *std::min_element (_M_data, _M_data+_M_size);\n     }\n \n   template<typename _Tp>\n     inline _Tp\n     valarray<_Tp>::max() const\n     {\n+      _GLIBCXX_DEBUG_ASSERT(_M_size > 0);\n       return *std::max_element (_M_data, _M_data+_M_size);\n     }\n   \n@@ -596,6 +615,7 @@ namespace std\n     inline valarray<_Tp>&\t\t\t\t\t\t\\\n     valarray<_Tp>::operator _Op##=(const valarray<_Tp> &__v)\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n+      _GLIBCXX_DEBUG_ASSERT(_M_size == __v._M_size);                    \\\n       _Array_augmented_##_Name(_Array<_Tp>(_M_data), _M_size, \t\t\\\n \t\t\t       _Array<_Tp>(__v._M_data));\t\t\\\n       return *this;\t\t\t\t\t\t\t\\\n@@ -643,6 +663,7 @@ _DEFINE_VALARRAY_EXPR_AUGMENTED_ASSIGNMENT(>>, __shift_right)\n                  typename __fun<_Name, _Tp>::result_type>               \\\n     operator _Op(const valarray<_Tp>& __v, const valarray<_Tp>& __w)\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n+      _GLIBCXX_DEBUG_ASSERT(__v.size() == __w.size());                  \\\n       typedef _BinClos<_Name,_ValArray,_ValArray,_Tp,_Tp> _Closure;     \\\n       typedef typename __fun<_Name, _Tp>::result_type _Rt;              \\\n       return _Expr<_Closure, _Rt>(_Closure(__v, __w));                  \\\n@@ -690,7 +711,3 @@ _DEFINE_BINARY_OPERATOR(>=, __greater_equal)\n } // namespace std\n \n #endif /* _GLIBCXX_VALARRAY */\n-\n-// Local Variables:\n-// mode:c++\n-// End:"}, {"sha": "16e50a99ec8cbda29b481d244a6d0f0eb020b818", "filename": "libstdc++-v3/include/std/std_vector.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fstd_vector.h?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -75,5 +75,9 @@\n # include <bits/vector.tcc>\n #endif\n \n+#ifdef _GLIBCXX_DEBUG\n+# include <debug/vector>\n+#endif\n+\n #endif /* _GLIBCXX_VECTOR */\n "}, {"sha": "701d5203ddc0c38365423c1be066d16d2e3ab26d", "filename": "libstdc++-v3/src/Makefile.am", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.am?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -94,6 +94,7 @@ sources = \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\\n+\tdebug.cc \\\n \tdemangle.cc \\\n \tfunctexcept.cc \\\n \tglobals_locale.cc \\"}, {"sha": "08d4af05814dbf8dd6412e2c76dfd0c5e2c34b42", "filename": "libstdc++-v3/src/Makefile.in", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2FMakefile.in?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -251,6 +251,7 @@ sources = \\\n \tcodecvt.cc \\\n \tcomplex_io.cc \\\n \tctype.cc \\\n+\tdebug.cc \\\n \tdemangle.cc \\\n \tfunctexcept.cc \\\n \tglobals_locale.cc \\\n@@ -360,7 +361,7 @@ am__objects_1 = codecvt_members.lo collate_members.lo ctype_members.lo \\\n \tmessages_members.lo monetary_members.lo numeric_members.lo \\\n \ttime_members.lo\n am__objects_2 = basic_file.lo c++locale.lo\n-am__objects_3 = codecvt.lo complex_io.lo ctype.lo demangle.lo \\\n+am__objects_3 = codecvt.lo complex_io.lo ctype.lo debug.lo demangle.lo \\\n \tfunctexcept.lo globals_locale.lo globals_io.lo ios.lo \\\n \tios_failure.lo ios_init.lo ios_locale.lo limits.lo locale.lo \\\n \tlocale_init.lo locale_facets.lo localename.lo stdexcept.lo \\"}, {"sha": "224f8e2baa85455632f0bd5ada170119dab31846", "filename": "libstdc++-v3/src/debug.cc", "status": "added", "additions": 604, "deletions": 0, "changes": 604, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fdebug.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,604 @@\n+// Debugging mode support code -*- C++ -*-\n+\n+// Copyright (C) 2003\n+// Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// As a special exception, you may use this file as part of a free software\n+// library without restriction.  Specifically, if other files instantiate\n+// templates or use macros or inline functions from this file, or you compile\n+// this file and link it with other files to produce an executable, this\n+// file does not by itself cause the resulting executable to be covered by\n+// the GNU General Public License.  This exception does not however\n+// invalidate any other reasons why the executable file might be covered by\n+// the GNU General Public License.\n+\n+#include <debug/debug.h>\n+#include <debug/safe_sequence.h>\n+#include <debug/safe_iterator.h>\n+#include <algorithm>\n+#include <cstdlib>\n+#include <cassert>\n+#include <cstring>\n+#include <cstdio>\n+#include <cctype>\n+\n+using namespace std;\n+\n+namespace __gnu_debug\n+{\n+  const char* _S_debug_messages[] = \n+  {\n+    \"function requires a valid iterator range [%1.name;, %2.name;)\",\n+    \"attempt to insert into container with a singular iterator\",\n+    \"attempt to insert into container with an iterator from a different container\",\n+    \"attempt to erase from container with a %2.state; iterator\",\n+    \"attempt to erase from container with an iterator from a different container\",\n+    \"attempt to subscript container with out-of-bounds index %2;, but container only holds %3; elements\",\n+    \"attempt to access an element in an empty container\",\n+    \"elements in iterator range [%1.name;, %2.name;) are not partitioned by the value %3;\",\n+    \"elements in iterator range [%1.name;, %2.name;) are not partitioned by the predicate %3; and value %4;\",\n+    \"elements in iterator range [%1.name;, %2.name;) are not sorted\",\n+    \"elements in iterator range [%1.name;, %2.name;) are not sorted according to the predicate %3;\",\n+    \"elements in iterator range [%1.name;, %2.name;) do not form a heap\",\n+    \"elements in iterator range [%1.name;, %2.name;) do not form a heap with respect to the predicate %3;\",\n+    \"attempt to write through a singular bitset reference\",\n+    \"attempt to read from a singular bitset reference\",\n+    \"attempt to flip a singular bitset reference\",\n+    \"attempt to splice a list into itself\",\n+    \"attempt to splice lists with inequal allocators\",\n+    \"attempt to splice elements referenced by a %1.state; iterator\",\n+    \"attempt to splice an iterator from a different container\",\n+    \"splice destination %1.name; occurs within source range [%2.name;, %3.name;)\",\n+    \"attempt to initialize an iterator that will immediately become singular\",\n+    \"attempt to copy-construct an iterator from a singular iterator\",\n+    \"attempt to construct a constant iterator from a singular mutable iterator\",\n+    \"attempt to copy from a singular iterator\",\n+    \"attempt to dereference a %1.state; iterator\",\n+    \"attempt to increment a %1.state; iterator\",\n+    \"attempt to decrement a %1.state; iterator\",\n+    \"attempt to subscript a %1.state; iterator %2; step from its current position, which falls outside its dereferenceable range\",\n+    \"attempt to advance a %1.state; iterator %2; steps, which falls outside its valid range\",\n+    \"attempt to retreat a %1.state; iterator %2; steps, which falls outside its valid range\",\n+    \"attempt to compare a %1.state; iterator to a %2.state; iterator\",\n+    \"attempt to compare iterators from different sequences\",\n+    \"attempt to order a %1.state; iterator to a %2.state; iterator\",\n+    \"attempt to order iterators from different sequences\",\n+    \"attempt to compute the difference between a %1.state; iterator to a %2.state; iterator\",\n+    \"attempt to compute the different between two iterators from different sequences\",\n+    \"attempt to dereference an end-of-stream istream_iterator\",\n+    \"attempt to increment an end-of-stream istream_iterator\",\n+    \"attempt to output via an ostream_iterator with no associated stream\",\n+    \"attempt to dereference an end-of-stream istreambuf_iterator (this is a GNU extension)\",\n+    \"attempt to increment an end-of-stream istreambuf_iterator\"\n+  };\n+\n+  void \n+  _Safe_sequence_base::\n+  _M_detach_all()\n+  {\n+    for (_Safe_iterator_base* iter = _M_iterators; iter; )\n+    {\n+      _Safe_iterator_base* old = iter;\n+      iter = iter->_M_next;\n+      old->_M_attach(0, false);\n+    }\n+    \n+    for (_Safe_iterator_base* iter = _M_const_iterators; iter; )\n+    {\n+      _Safe_iterator_base* old = iter;\n+      iter = iter->_M_next;\n+      old->_M_attach(0, true);\n+    }\n+  }\n+\n+  void \n+  _Safe_sequence_base::\n+  _M_detach_singular()\n+  {\n+    for (_Safe_iterator_base* iter = _M_iterators; iter; )\n+    {\n+      _Safe_iterator_base* old = iter;\n+      iter = iter->_M_next;\n+      if (old->_M_singular())\n+\told->_M_attach(0, false);\n+    }\n+\n+    for (_Safe_iterator_base* iter = _M_const_iterators; iter; )\n+    {\n+      _Safe_iterator_base* old = iter;\n+      iter = iter->_M_next;\n+      if (old->_M_singular())\n+\told->_M_attach(0, true);\n+    }\n+  }\n+\n+  void \n+  _Safe_sequence_base::\n+  _M_revalidate_singular()\n+  {\n+    for (_Safe_iterator_base* iter = _M_iterators; iter;\n+\t iter = iter->_M_next)\n+    {\n+      iter->_M_version = _M_version;\n+      iter = iter->_M_next;\n+    }\n+    \n+    for (_Safe_iterator_base* iter = _M_const_iterators; iter;\n+\t iter = iter->_M_next)\n+    {\n+      iter->_M_version = _M_version;\n+      iter = iter->_M_next;\n+    }\n+  }\n+\n+  void \n+  _Safe_sequence_base::\n+  _M_swap(_Safe_sequence_base& __x)\n+  {\n+    swap(_M_iterators, __x._M_iterators);\n+    swap(_M_const_iterators, __x._M_const_iterators);\n+    swap(_M_version, __x._M_version);\n+    for (_Safe_iterator_base* iter = _M_iterators; iter; iter = iter->_M_next)\n+      iter->_M_sequence = this;\n+    for (_Safe_iterator_base* iter = __x._M_iterators; iter; iter = iter->_M_next)\n+      iter->_M_sequence = &__x;\n+    for (_Safe_iterator_base* iter = _M_const_iterators; iter; iter = iter->_M_next)\n+      iter->_M_sequence = this;\n+    for (_Safe_iterator_base* iter = __x._M_const_iterators; iter; iter = iter->_M_next)\n+      iter->_M_sequence = &__x;\n+  }\n+  \n+  void \n+  _Safe_iterator_base::\n+  _M_attach(_Safe_sequence_base* __seq, bool __constant)\n+  {\n+    _M_detach();\n+    \n+    // Attach to the new sequence (if there is one)\n+    if (__seq)\n+    {\n+      _M_sequence = __seq;\n+      _M_version = _M_sequence->_M_version;\n+      _M_prior = 0;\n+      if (__constant)\n+      {\n+\t_M_next = _M_sequence->_M_const_iterators;\n+\tif (_M_next)\n+\t  _M_next->_M_prior = this;\n+\t_M_sequence->_M_const_iterators = this;\n+      }\n+      else\n+      {\n+\t_M_next = _M_sequence->_M_iterators;\n+\tif (_M_next)\n+\t  _M_next->_M_prior = this;\n+\t_M_sequence->_M_iterators = this;\n+      }\n+    }\n+  }\n+\n+  void \n+  _Safe_iterator_base::\n+  _M_detach()\n+  {\n+    if (_M_sequence)\n+    {\n+      // Remove us from this sequence's list\n+      if (_M_prior) _M_prior->_M_next = _M_next;\n+      if (_M_next)  _M_next->_M_prior = _M_prior;\n+      \n+      if (_M_sequence->_M_const_iterators == this)\n+\t_M_sequence->_M_const_iterators = _M_next;\n+      if (_M_sequence->_M_iterators == this)\n+\t_M_sequence->_M_iterators = _M_next;\n+    }\n+\n+    _M_sequence = 0;\n+    _M_version = 0;\n+    _M_prior = 0;\n+    _M_next = 0;\n+  }\n+  \n+  bool\n+  _Safe_iterator_base::\n+  _M_singular() const\n+  { return !_M_sequence || _M_version != _M_sequence->_M_version; }\n+    \n+  bool\n+  _Safe_iterator_base::\n+  _M_can_compare(const _Safe_iterator_base& __x) const\n+  {\n+    return (! _M_singular() && !__x._M_singular()\n+\t    && _M_sequence == __x._M_sequence);\n+  }\n+\n+  void\n+  _Error_formatter::_Parameter::\n+  _M_print_field(const _Error_formatter* __formatter,\n+\t\t const char* __name) const\n+  {\n+    assert(this->_M_kind != _Parameter::__unused_param);\n+    const int bufsize = 64;\n+    char buf[bufsize];\n+    \n+    if (_M_kind == __iterator)\n+    {\n+      if (strcmp(__name, \"name\") == 0)\n+      {\n+\tassert(_M_variant._M_iterator._M_name);\n+\t__formatter->_M_print_word(_M_variant._M_iterator._M_name);\n+      }\n+      else if (strcmp(__name, \"address\") == 0)\n+      {\n+\tsnprintf(buf, bufsize, \"%p\", _M_variant._M_iterator._M_address);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      else if (strcmp(__name, \"type\") == 0)\n+      {\n+\tassert(_M_variant._M_iterator._M_type);\n+\t// TBD: demangle!\n+\t__formatter->_M_print_word(_M_variant._M_iterator._M_type->name());\n+      }\n+      else if (strcmp(__name, \"constness\") == 0)\n+      {\n+\tstatic const char* __constness_names[__last_constness] =\n+\t{\n+\t  \"<unknown>\",\n+\t  \"constant\",\n+\t  \"mutable\"\n+\t};\n+\t__formatter->_M_print_word(__constness_names[_M_variant._M_iterator._M_constness]);\n+      }\n+      else if (strcmp(__name, \"state\") == 0)\n+      {\n+\tstatic const char* __state_names[__last_state] = \n+\t{\n+\t  \"<unknown>\",\n+\t  \"singular\",\n+\t  \"dereferenceable (start-of-sequence)\",\n+\t  \"dereferenceable\",\n+\t  \"past-the-end\"\n+\t};\n+\t__formatter->_M_print_word(__state_names[_M_variant._M_iterator._M_state]);\n+      }\n+      else if (strcmp(__name, \"sequence\") == 0)\n+      {\n+\tassert(_M_variant._M_iterator._M_sequence);\n+\tsnprintf(buf, bufsize, \"%p\", _M_variant._M_iterator._M_sequence);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      else if (strcmp(__name, \"seq_type\") == 0)\n+      {\n+\t// TBD: demangle!\n+\tassert(_M_variant._M_iterator._M_seq_type);\n+\t__formatter->_M_print_word(_M_variant._M_iterator._M_seq_type->name());\n+      }\n+      else\n+\tassert(false);\n+    }\n+    else if (_M_kind == __sequence)\n+    {\n+      if (strcmp(__name, \"name\") == 0)\n+      {\n+\tassert(_M_variant._M_sequence._M_name);\n+\t__formatter->_M_print_word(_M_variant._M_sequence._M_name);\n+      }\n+      else if (strcmp(__name, \"address\") == 0)\n+      {\n+\tassert(_M_variant._M_sequence._M_address);\n+\tsnprintf(buf, bufsize, \"%p\", _M_variant._M_sequence._M_address);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      else if (strcmp(__name, \"type\") == 0)\n+      {\n+\t// TBD: demangle!\n+\tassert(_M_variant._M_sequence._M_type);\n+\t__formatter->_M_print_word(_M_variant._M_sequence._M_type->name());\n+      }\n+      else\n+\tassert(false);\n+    }\n+    else if (_M_kind == __integer)\n+    {\n+      if (strcmp(__name, \"name\") == 0)\n+      {\n+\tassert(_M_variant._M_integer._M_name);\n+\t__formatter->_M_print_word(_M_variant._M_integer._M_name);\n+      }\n+      else\n+\tassert(false);\n+    }\n+    else if (_M_kind == __string)\n+    {\n+      if (strcmp(__name, \"name\") == 0)\n+      {\n+\tassert(_M_variant._M_string._M_name);\n+\t__formatter->_M_print_word(_M_variant._M_string._M_name);\n+      }\n+      else\n+\tassert(false);\n+    }\n+    else\n+    {\n+      assert(false);\n+    }\n+  }\n+\n+  void\n+  _Error_formatter::_Parameter::\n+  _M_print_description(const _Error_formatter* __formatter) const\n+  {\n+    const int bufsize = 128;\n+    char buf[bufsize];\n+    \n+    if (_M_kind == __iterator)\n+    {\n+      __formatter->_M_print_word(\"iterator \");\n+      if (_M_variant._M_iterator._M_name)\n+      {\n+\tsnprintf(buf, bufsize, \"\\\"%s\\\" \", \n+\t\t _M_variant._M_iterator._M_name);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      \n+      snprintf(buf, bufsize, \"@ 0x%p {\\n\", \n+\t       _M_variant._M_iterator._M_address);\n+      __formatter->_M_print_word(buf);\n+      if (_M_variant._M_iterator._M_type)\n+      {\n+\t__formatter->_M_print_word(\"type = \");\n+\t_M_print_field(__formatter, \"type\");\n+\t\n+\tif (_M_variant._M_iterator._M_constness != __unknown_constness)\n+\t{\n+\t  __formatter->_M_print_word(\" (\");\n+\t  _M_print_field(__formatter, \"constness\");\n+\t  __formatter->_M_print_word(\" iterator)\");\n+\t}\n+\t__formatter->_M_print_word(\";\\n\");\n+      }\n+      \n+      if (_M_variant._M_iterator._M_state != __unknown_state)\n+      {\n+\t__formatter->_M_print_word(\"  state = \");\n+\t_M_print_field(__formatter, \"state\");\n+\t__formatter->_M_print_word(\";\\n\");\n+      }\n+\n+      if (_M_variant._M_iterator._M_sequence)\n+      {\n+\t__formatter->_M_print_word(\"  references sequence \");\n+\tif (_M_variant._M_iterator._M_seq_type)\n+\t{\n+\t  __formatter->_M_print_word(\"with type `\");\n+\t  _M_print_field(__formatter, \"seq_type\");\n+\t  __formatter->_M_print_word(\"' \");\n+\t}\n+\t\n+\tsnprintf(buf, bufsize, \"@ 0x%p\\n\", _M_variant._M_sequence._M_address);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      __formatter->_M_print_word(\"}\\n\");\n+    }\n+    else if (_M_kind == __sequence)\n+    {\n+      __formatter->_M_print_word(\"sequence \");\n+      if (_M_variant._M_sequence._M_name)\n+      {\n+\tsnprintf(buf, bufsize, \"\\\"%s\\\" \", \n+\t\t _M_variant._M_sequence._M_name);\n+\t__formatter->_M_print_word(buf);\n+      }\n+      \n+      snprintf(buf, bufsize, \"@ 0x%p {\\n\", \n+\t       _M_variant._M_sequence._M_address);\n+      __formatter->_M_print_word(buf);\n+      \n+      if (_M_variant._M_sequence._M_type)\n+      {\n+\t__formatter->_M_print_word(\"  type = \");\n+\t_M_print_field(__formatter, \"type\");\n+\t__formatter->_M_print_word(\";\\n\");\n+      }\t  \n+      __formatter->_M_print_word(\"}\\n\");\n+    }\n+  }\n+\n+  const _Error_formatter&\n+  _Error_formatter::_M_message(_Debug_msg_id __id) const\n+  { return this->_M_message(_S_debug_messages[__id]); }\n+  \n+  void\n+  _Error_formatter::_M_error() const\n+  {\n+    const int bufsize = 128;\n+    char buf[bufsize];\n+    \n+    // Emit file & line number information\n+    _M_column = 1;\n+    _M_wordwrap = false;\n+    if (_M_file)\n+    {\n+      snprintf(buf, bufsize, \"%s:\", _M_file);\n+      _M_print_word(buf);\n+      _M_column += strlen(buf);\n+    }\n+    \n+    if (_M_line > 0)\n+    {\n+      snprintf(buf, bufsize, \"%u:\", _M_line);\n+      _M_print_word(buf);\n+      _M_column += strlen(buf);\n+    }\n+    \n+    _M_wordwrap = true;\n+    _M_print_word(\"error: \");\n+    \n+    // Print the error message\n+    assert(_M_text);\n+    _M_print_string(_M_text);\n+    _M_print_word(\".\\n\");\n+    \n+    // Emit descriptions of the objects involved in the operation\n+    _M_wordwrap = false;\n+    bool has_noninteger_parameters = false;\n+    for (unsigned int i = 0; i < _M_num_parameters; ++i)\n+    {\n+      if (_M_parameters[i]._M_kind == _Parameter::__iterator\n+\t  || _M_parameters[i]._M_kind == _Parameter::__sequence)\n+      {\n+\tif (!has_noninteger_parameters)\n+\t{\n+\t  _M_first_line = true;\n+\t  _M_print_word(\"\\nObjects involved in the operation:\\n\");\n+\t  has_noninteger_parameters = true;\n+\t}\n+\t_M_parameters[i]._M_print_description(this);\n+      }\n+    }\n+    \n+    abort();\n+  }\n+\n+  void \n+  _Error_formatter::_M_print_word(const char* __word) const\n+  {\n+    if (!_M_wordwrap) \n+    {\n+      fprintf(stderr, \"%s\", __word);\n+      return;\n+    }\n+    \n+    size_t __length = strlen(__word);\n+    if (__length == 0)\n+      return;\n+    \n+    if ((_M_column + __length < _M_max_length)\n+\t|| (__length >= _M_max_length && _M_column == 1)) \n+    {\n+      // If this isn't the first line, indent\n+      if (_M_column == 1 && !_M_first_line)\n+      {\n+\tchar spacing[_M_indent + 1];\n+\tfor (int i = 0; i < _M_indent; ++i)\n+\t  spacing[i] = ' ';\n+\tspacing[_M_indent] = '\\0';\n+\tfprintf(stderr, \"%s\", spacing);\n+\t_M_column += _M_indent;\n+      }\n+      \n+      fprintf(stderr, \"%s\", __word);\n+      _M_column += __length;\n+      \n+      if (__word[__length - 1] == '\\n') \n+      {\n+\t_M_first_line = false;\n+\t_M_column = 1;\n+      }\n+    }\n+    else\n+    {\n+      _M_column = 1;\n+      _M_print_word(\"\\n\");\n+      _M_print_word(__word);\n+    }\n+  }\n+  \n+  void\n+  _Error_formatter::\n+  _M_print_string(const char* __string) const\n+  {\n+    const char* __start = __string;\n+    const char* __end = __start;\n+    const int bufsize = 128;\n+    char buf[bufsize];\n+\n+    while (*__start)\n+    {\n+      if (*__start != '%')\n+      {\n+\t// [__start, __end) denotes the next word\n+\t__end = __start;\n+\twhile (isalnum(*__end)) ++__end;\n+\tif (__start == __end) ++__end;\n+\tif (isspace(*__end)) ++__end;\n+\t\n+\tassert(__end - __start + 1< bufsize);\n+\tsnprintf(buf, __end - __start + 1, \"%s\", __start);\n+\t_M_print_word(buf);\n+\t__start = __end;\n+\t\n+\t// Skip extra whitespace\n+\twhile (*__start == ' ') ++__start;\n+\t\n+\tcontinue;\n+      } \n+\t\n+      ++__start;\n+      assert(*__start);\n+      if (*__start == '%')\n+      {\n+\t_M_print_word(\"%\");\n+\t++__start;\n+\tcontinue;\n+      }\n+      \n+      // Get the parameter number\n+      assert(*__start >= '1' && *__start <= '9');\n+      size_t param = *__start - '0';\n+      --param;\n+      assert(param < _M_num_parameters);\n+      \n+      // '.' separates the parameter number from the field\n+      // name, if there is one.\n+      ++__start;\n+      if (*__start != '.')\n+      {\n+\tassert(*__start == ';');\n+\t++__start;\n+\tbuf[0] = '\\0';\n+\tif (_M_parameters[param]._M_kind == _Parameter::__integer)\n+\t{\n+\t  snprintf(buf, bufsize, \"%ld\", \n+\t\t   _M_parameters[param]._M_variant._M_integer._M_value);\n+\t  _M_print_word(buf);\n+\t}\n+\telse if (_M_parameters[param]._M_kind == _Parameter::__string)\n+\t  _M_print_string(_M_parameters[param]._M_variant._M_string._M_value);\n+\tcontinue;\n+      }\n+      \n+      // Extract the field name we want\n+      enum { max_field_len = 16 };\n+      char field[max_field_len];\n+      int field_idx = 0;\n+      ++__start;\n+      while (*__start != ';')\n+      {\n+\tassert(*__start);\n+\tassert(field_idx < max_field_len-1);\n+\tfield[field_idx++] = *__start++;\n+      }\n+      ++__start;\n+      field[field_idx] = 0;\n+      \n+      _M_parameters[param]._M_print_field(this, field);\t\t  \n+    }\n+  }\n+} // namespace __gnu_debug"}, {"sha": "37a4d3d460b77348752d95ac84bd37e85475825e", "filename": "libstdc++-v3/src/misc-inst.cc", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fmisc-inst.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -42,6 +42,10 @@\n \n namespace std\n {\n+#ifdef _GLIBCXX_INST_ATOMICITY_LOCK\n+  template volatile int __Atomicity_lock<0>::_S_atomicity_lock;\n+#endif\n+\n   // string related to iostreams\n   template \n     basic_istream<char>& \n@@ -69,12 +73,8 @@ namespace std\n     basic_istream<wchar_t>& \n     getline(basic_istream<wchar_t>&, wstring&);\n #endif\n-#ifdef _GLIBCXX_INST_ATOMICITY_LOCK\n-  template volatile int __Atomicity_lock<0>::_S_atomicity_lock;\n-#endif\n } // namespace std\n \n-\n namespace __gnu_cxx\n {\n #ifdef _GLIBCXX_NEED_GENERIC_MUTEX"}, {"sha": "ab779b872e813aa36c10ba6588b8668677209f87", "filename": "libstdc++-v3/src/string-inst.cc", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Fstring-inst.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -42,25 +42,15 @@\n # define C char\n #endif\n \n-namespace std \n+namespace std\n {\n   typedef basic_string<C> S;\n \n   template class basic_string<C>;\n   template S operator+(const C*, const S&);\n   template S operator+(C, const S&);\n   template S operator+(const S&, const S&);\n-} // namespace std\n-\n-namespace __gnu_cxx\n-{\n-  using std::S;\n-  template bool operator==(const S::iterator&, const S::iterator&);\n-  template bool operator==(const S::const_iterator&, const S::const_iterator&);\n-}\n \n-namespace std\n-{\n   // Only one template keyword allowed here. \n   // See core issue #46 (NAD)\n   // http://anubis.dkuug.dk/jtc1/sc22/wg21/docs/cwg_closed.html#46\n@@ -100,3 +90,10 @@ namespace std\n     S::_S_construct(const C*, const C*, const allocator<C>&,\n \t\t    forward_iterator_tag);\n } // namespace std\n+\n+namespace __gnu_cxx\n+{\n+  using std::S;\n+  template bool operator==(const S::iterator&, const S::iterator&);\n+  template bool operator==(const S::const_iterator&, const S::const_iterator&);\n+} // namespace __gnu_cxx"}, {"sha": "15a6ae43986b88b76d36e13069a21dc27ec21a30", "filename": "libstdc++-v3/testsuite/20_util/auto_ptr_neg.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fauto_ptr_neg.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -46,5 +46,5 @@ main()\n   test01();\n   return 0;\n }\n-// { dg-error \"candidates\" \"\" { target *-*-* } 216 } \n-// { dg-error \"std::auto_ptr\" \"\" { target *-*-* } 338 } \n+// { dg-error \"candidates\" \"\" { target *-*-* } 217 } \n+// { dg-error \"std::auto_ptr\" \"\" { target *-*-* } 347 } "}, {"sha": "7ca3053cff15fd6f21c15bf20ffdf24401e42b16", "filename": "libstdc++-v3/testsuite/23_containers/bitset/invalidation/1.cc", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fbitset%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,46 @@\n+// Bitset reference invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/bitset>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::bitset;\n+\n+bool test = true;\n+\n+// Disappear\n+void test01()\n+{\n+  bitset<32>::reference* i;\n+  {\n+    bitset<32> bs;\n+    bs.flip(7);\n+    i = new bitset<32>::reference(bs[7]);\n+    VERIFY(*i);\n+  }\n+  VERIFY(i->_M_singular());\n+  delete i;\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "4529b288ef4f4fa48d5b139642a13ac95c5853c4", "filename": "libstdc++-v3/testsuite/23_containers/deque/invalidation/1.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,53 @@\n+// Deque iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/deque>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::deque;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  deque<int> v1;\n+  deque<int> v2;\n+\n+  deque<int>::iterator i = v1.end();\n+  VERIFY(!i._M_dereferenceable() && !i._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(i._M_singular());\n+  \n+  i = v1.end();\n+  v1.assign(v2.begin(), v2.end());\n+  VERIFY(i._M_singular());\n+\n+  i = v1.end();\n+  v1.assign(17, 42);\n+  VERIFY(i._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "106c118accc0f104c4f457156f5fd64c3b0d168c", "filename": "libstdc++-v3/testsuite/23_containers/deque/invalidation/2.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,53 @@\n+// Deque iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/deque>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::deque;\n+\n+bool test = true;\n+\n+// Resize\n+void test02()\n+{\n+  deque<int> v(10, 17);\n+\n+  deque<int>::iterator before = v.begin() + 6;\n+  deque<int>::iterator at = before + 1;\n+  deque<int>::iterator after = at + 1;\n+\n+  // Shrink\n+  v.resize(7);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_singular());\n+\n+  // Grow\n+  before = v.begin() + 6;\n+  v.resize(17);\n+  VERIFY(before._M_singular());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "60103c1fd7e0e97b1102b480ffd32fd12d69c4d0", "filename": "libstdc++-v3/testsuite/23_containers/deque/invalidation/3.cc", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F3.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,62 @@\n+// Deque iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/deque>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::deque;\n+\n+bool test = true;\n+\n+// Insert\n+void test03()\n+{\n+  deque<int> v(10, 17);\n+\n+  // Insert a single element\n+  deque<int>::iterator before = v.begin() + 6;\n+  deque<int>::iterator at = before + 1;\n+  deque<int>::iterator after = at;\n+  at = v.insert(at, 42);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_singular());\n+\n+  // Insert multiple copies\n+  before = v.begin() + 6;\n+  at = before + 1;\n+  v.insert(at, 3, 42);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_singular());\n+\n+  // Insert iterator range\n+  static int data[] = { 2, 3, 5, 7 };\n+  before = v.begin() + 6;\n+  at = before + 1;\n+  v.insert(at, &data[0], &data[0] + 4);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_singular());\n+}\n+\n+int main()\n+{\n+  test03();\n+  return !test;\n+}"}, {"sha": "1918737cf93ec6255d46b1f33a6d3d6a982ae4ee", "filename": "libstdc++-v3/testsuite/23_containers/deque/invalidation/4.cc", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fdeque%2Finvalidation%2F4.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,69 @@\n+// Deque iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/deque>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::deque;\n+\n+bool test = true;\n+\n+// Erase\n+void test04()\n+{\n+  deque<int> v(20, 42);\n+\n+  // Single element erase (middle)\n+  deque<int>::iterator before = v.begin();\n+  deque<int>::iterator at = before + 3;\n+  deque<int>::iterator after = at;\n+  at = v.erase(at);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_singular());\n+\n+  // Single element erase (end)\n+  before = v.begin();\n+  at = before;\n+  after = at + 1;\n+  at = v.erase(at);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before + 3;\n+  v.erase(at, at + 3);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+}\n+\n+int main()\n+{\n+  test04();\n+  return !test;\n+}"}, {"sha": "86d9031a9c3c75ec1d00be9a80d03ca1df78efba", "filename": "libstdc++-v3/testsuite/23_containers/list/invalidation/1.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,60 @@\n+// List iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/list>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::list;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  list<int> v1;\n+  list<int> v2;\n+\n+  v1.push_front(17);\n+\n+  list<int>::iterator start = v1.begin();\n+  list<int>::iterator finish = v1.end();\n+  VERIFY(start._M_dereferenceable());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(start._M_singular());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  finish = v1.end();\n+  v1.assign(v2.begin(), v2.end());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  finish = v1.end();\n+  v1.assign(17, 42);\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "117aa61abea5e33fda918fc8801e187cb62edfd1", "filename": "libstdc++-v3/testsuite/23_containers/list/invalidation/2.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,55 @@\n+// List iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/list>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::list;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Resize\n+void test02()\n+{\n+  list<int> v(10, 17);\n+\n+  list<int>::iterator before = v.begin();\n+  advance(before, 6);\n+  list<int>::iterator at = before;\n+  advance(at, 1);\n+  list<int>::iterator after = at;\n+  advance(after, 1);\n+  list<int>::iterator finish = v.end();\n+\n+  // Shrink\n+  v.resize(7);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "59af360ed84c1de81103ae05c5b6dcea8a41041d", "filename": "libstdc++-v3/testsuite/23_containers/list/invalidation/3.cc", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F3.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,78 @@\n+// List iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/list>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::list;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Erase\n+void test03()\n+{\n+  list<int> v(20, 42);\n+\n+  // Single element erase (middle)\n+  list<int>::iterator before = v.begin();\n+  list<int>::iterator at = before;\n+  advance(at, 3);\n+  list<int>::iterator after = at;\n+  at = v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_singular());\n+\n+  // Single element erase (end)\n+  before = v.begin();\n+  at = before;\n+  after = at;\n+  ++after;\n+  at = v.erase(at);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before;\n+  advance(at, 3);\n+  after = at;\n+  advance(after, 3);\n+  v.erase(at, after);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  list<int>::iterator finish = v.end();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test03();\n+  return !test;\n+}"}, {"sha": "90f99709f16cf93485ba91cbd3cbb54ba253f50a", "filename": "libstdc++-v3/testsuite/23_containers/list/invalidation/4.cc", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Finvalidation%2F4.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,55 @@\n+// List iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/list>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::list;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Splice\n+void test04()\n+{\n+  list<int> l1(10, 17);\n+  list<int> l2(10, 42);\n+  \n+  list<int>::iterator start2 = l2.begin();\n+  list<int>::iterator end2 = start2;\n+  advance(end2, 5);\n+  list<int>::iterator after2 = end2;\n+  advance(after2, 2);\n+  \n+  l1.splice(l1.begin(), l2, start2, end2);\n+  VERIFY(start2._M_dereferenceable());\n+  VERIFY(end2._M_dereferenceable());\n+  VERIFY(after2._M_dereferenceable());\n+  VERIFY(start2._M_attached_to(&l1));\n+  VERIFY(end2._M_attached_to(&l2));\n+  VERIFY(after2._M_attached_to(&l2));\n+}\n+\n+int main()\n+{\n+  test04();\n+  return !test;\n+}"}, {"sha": "bbebfb59a23b415a0d235ea54b6e4d222816f2d4", "filename": "libstdc++-v3/testsuite/23_containers/list/operators/4.cc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Flist%2Foperators%2F4.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -76,14 +76,18 @@ test04()\n   CompLastLt::reset();\n   list0401.merge(list0402, lt);\n   VERIFY(list0401 == list0404);\n+#ifndef _GLIBCXX_DEBUG\n   VERIFY(lt.count() <= (N + M - 1));\n+#endif\n \n   CompLastEq eq;\n \n   CompLastEq::reset();\n   list0401.unique(eq);\n   VERIFY(list0401 == list0405);\n+#ifndef _GLIBCXX_DEBUG\n   VERIFY(eq.count() == (N + M - 1));\n+#endif\n }\n \n int main()"}, {"sha": "a62a98d863f336fc94891c2bec8e5a12a72b9e86", "filename": "libstdc++-v3/testsuite/23_containers/map/invalidation/1.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,52 @@\n+// Map iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/map>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::map;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  map<int, int> v1;\n+  map<int, int> v2;\n+\n+  v1[17] = 42;\n+\n+  map<int, int>::iterator start = v1.begin();\n+  map<int, int>::iterator finish = v1.end();\n+  VERIFY(start._M_dereferenceable());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(start._M_singular());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "0086deb81fa5aa6e8fd6d213f381248bd687cadc", "filename": "libstdc++-v3/testsuite/23_containers/map/invalidation/2.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmap%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,71 @@\n+// Map iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/map>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::map;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Erase\n+void test02()\n+{\n+  map<int, int> v;\n+  for (int i = 0; i < 20; ++i)\n+    v[i] = 20-i;\n+\n+  // Single element erase (middle)\n+  map<int, int>::iterator before = v.begin();\n+  map<int, int>::iterator at = before;\n+  advance(at, 3);\n+  map<int, int>::iterator after = at;\n+  ++after;\n+  v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before;\n+  advance(at, 3);\n+  after = at;\n+  advance(after, 4);\n+  v.erase(at, after);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  map<int, int>::iterator finish = v.end();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "71b5385aed3fcbe613321733fe02385f083ad3c1", "filename": "libstdc++-v3/testsuite/23_containers/multimap/invalidation/1.cc", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,53 @@\n+// Multimap iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/map>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <utility>\n+\n+using __gnu_debug::multimap;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  multimap<int, int> v1;\n+  multimap<int, int> v2;\n+\n+  v1.insert(std::make_pair(17, 42));\n+\n+  multimap<int, int>::iterator start = v1.begin();\n+  multimap<int, int>::iterator finish = v1.end();\n+  VERIFY(start._M_dereferenceable());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(start._M_singular());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "c6f659e7f5c02f88023c9a87492ad4e7dd961183", "filename": "libstdc++-v3/testsuite/23_containers/multimap/invalidation/2.cc", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultimap%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,72 @@\n+// Multimap iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/map>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+#include <utility>\n+\n+using __gnu_debug::multimap;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Erase\n+void test02()\n+{\n+  multimap<int, int> v;\n+  for (int i = 0; i < 20; ++i)\n+    v.insert(std::make_pair(i, 20-i));\n+\n+  // Single element erase (middle)\n+  multimap<int, int>::iterator before = v.begin();\n+  multimap<int, int>::iterator at = before;\n+  advance(at, 3);\n+  multimap<int, int>::iterator after = at;\n+  ++after;\n+  v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before;\n+  advance(at, 3);\n+  after = at;\n+  advance(after, 4);\n+  v.erase(at, after);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  multimap<int, int>::iterator finish = v.end();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "0d9b76f2f4c80c8f4bce12ae6b7080ecef89dcbd", "filename": "libstdc++-v3/testsuite/23_containers/multiset/invalidation/1.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,52 @@\n+// Multiset iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/set>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::multiset;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  multiset<int> v1;\n+  multiset<int> v2;\n+\n+  v1.insert(17);\n+\n+  multiset<int>::iterator start = v1.begin();\n+  multiset<int>::iterator finish = v1.end();\n+  VERIFY(start._M_dereferenceable());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(start._M_singular());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "fbca3c476fe5022edd5ba8e099f27c009d2a879b", "filename": "libstdc++-v3/testsuite/23_containers/multiset/invalidation/2.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fmultiset%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,71 @@\n+// Multiset iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/set>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::multiset;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Erase\n+void test02()\n+{\n+  multiset<int> v;\n+  for (int i = 0; i < 20; ++i)\n+    v.insert(i);\n+\n+  // Single element erase (middle)\n+  multiset<int>::iterator before = v.begin();\n+  multiset<int>::iterator at = before;\n+  advance(at, 3);\n+  multiset<int>::iterator after = at;\n+  ++after;\n+  v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before;\n+  advance(at, 3);\n+  after = at;\n+  advance(after, 4);\n+  v.erase(at, after);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  multiset<int>::iterator finish = v.end();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "5a58f6fad71a976418b24cb50a4ec4b85651ea03", "filename": "libstdc++-v3/testsuite/23_containers/set/invalidation/1.cc", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,52 @@\n+// Set iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/set>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::set;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  set<int> v1;\n+  set<int> v2;\n+\n+  v1.insert(17);\n+\n+  set<int>::iterator start = v1.begin();\n+  set<int>::iterator finish = v1.end();\n+  VERIFY(start._M_dereferenceable());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(start._M_singular());\n+  VERIFY(!finish._M_dereferenceable() && !finish._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "25277d843b95d9fc0252598921d5b443354e8f7a", "filename": "libstdc++-v3/testsuite/23_containers/set/invalidation/2.cc", "status": "added", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,71 @@\n+// Set iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+#include <debug/set>\n+#include <iterator>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::set;\n+using std::advance;\n+\n+bool test = true;\n+\n+// Erase\n+void test02()\n+{\n+  set<int> v;\n+  for (int i = 0; i < 20; ++i)\n+    v.insert(i);\n+\n+  // Single element erase (middle)\n+  set<int>::iterator before = v.begin();\n+  set<int>::iterator at = before;\n+  advance(at, 3);\n+  set<int>::iterator after = at;\n+  ++after;\n+  v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_dereferenceable());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before;\n+  advance(at, 3);\n+  after = at;\n+  advance(after, 4);\n+  v.erase(at, after);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  set<int>::iterator finish = v.end();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+  VERIFY(!finish._M_singular() && !finish._M_dereferenceable());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "ccbcb159046b5343a7ebe9dbd7bdab8920a656dd", "filename": "libstdc++-v3/testsuite/23_containers/vector/invalidation/1.cc", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F1.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,60 @@\n+// Vector iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// We need to be pedantic about reallocations for this testcase to be correct.\n+// { dg-options \"-D_GLIBCXX_DEBUG_PEDANTIC\" }\n+\n+#ifndef _GLIBCXX_DEBUG_PEDANTIC\n+#  define _GLIBCXX_DEBUG_PEDANTIC 1\n+#endif\n+\n+#include <debug/vector>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::vector;\n+\n+bool test = true;\n+\n+// Assignment\n+void test01()\n+{\n+  vector<int> v1;\n+  vector<int> v2;\n+\n+  vector<int>::iterator i = v1.end();\n+  VERIFY(!i._M_dereferenceable() && !i._M_singular());\n+\n+  v1 = v2;\n+  VERIFY(i._M_singular());\n+  \n+  i = v1.end();\n+  v1.assign(v2.begin(), v2.end());\n+  VERIFY(i._M_singular());\n+\n+  i = v1.end();\n+  v1.assign(17, 42);\n+  VERIFY(i._M_singular());\n+}\n+\n+int main()\n+{\n+  test01();\n+  return !test;\n+}"}, {"sha": "1f59639183206ef874324fa18265db27d27aa961", "filename": "libstdc++-v3/testsuite/23_containers/vector/invalidation/2.cc", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F2.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,65 @@\n+// Vector iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// We need to be pedantic about reallocations for this testcase to be correct.\n+// { dg-options \"-D_GLIBCXX_DEBUG_PEDANTIC\" }\n+\n+#ifndef _GLIBCXX_DEBUG_PEDANTIC\n+#  define _GLIBCXX_DEBUG_PEDANTIC 1\n+#endif\n+\n+#include <debug/vector>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::vector;\n+\n+bool test = true;\n+\n+// Resize\n+void test02()\n+{\n+  vector<int> v(10, 17);\n+  v.reserve(20);\n+\n+  vector<int>::iterator before = v.begin() + 6;\n+  vector<int>::iterator at = before + 1;\n+  vector<int>::iterator after = at + 1;\n+\n+  // Shrink\n+  v.resize(7);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+  VERIFY(after._M_singular());\n+\n+  // Grow, without reallocation\n+  before = v.begin() + 6;\n+  v.resize(17);\n+  VERIFY(before._M_dereferenceable());\n+\n+  // Grow, with reallocation\n+  v.resize(42);\n+  VERIFY(before._M_singular());\n+}\n+\n+int main()\n+{\n+  test02();\n+  return !test;\n+}"}, {"sha": "656dd61f71559a301fd580f32f1b3a85da609934", "filename": "libstdc++-v3/testsuite/23_containers/vector/invalidation/3.cc", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F3.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,90 @@\n+// Vector iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// We need to be pedantic about reallocations for this testcase to be correct.\n+// { dg-options \"-D_GLIBCXX_DEBUG_PEDANTIC\" }\n+\n+#ifndef _GLIBCXX_DEBUG_PEDANTIC\n+#  define _GLIBCXX_DEBUG_PEDANTIC 1\n+#endif\n+\n+#include <debug/vector>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::vector;\n+\n+bool test = true;\n+\n+// Insert\n+void test03()\n+{\n+  vector<int> v(10, 17);\n+  v.reserve(30);\n+\n+  // Insert a single element\n+  vector<int>::iterator before = v.begin() + 6;\n+  vector<int>::iterator at = before + 1;\n+  vector<int>::iterator after = at;\n+  at = v.insert(at, 42);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_singular());\n+\n+  // Insert multiple copies\n+  before = v.begin() + 6;\n+  at = before + 1;\n+  v.insert(at, 3, 42);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // Insert iterator range\n+  static int data[] = { 2, 3, 5, 7 };\n+  before = v.begin() + 6;\n+  at = before + 1;\n+  v.insert(at, &data[0], &data[0] + 4);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // Insert with reallocation\n+  before = v.begin() + 6;\n+  at = before + 1;\n+  v.insert(at, 30, 17);\n+  VERIFY(before._M_singular());\n+  VERIFY(at._M_singular());\n+\n+  // Single insert with reallocation\n+  vector<int> v2;\n+  v2.reserve(100);\n+  at = v2.begin();\n+  v2.insert(at, 100, 17);\n+  at = v2.end() - 1;\n+  before = v2.begin();\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(before._M_dereferenceable());\n+  at = v2.insert(at, 42);\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(before._M_singular());\n+}\n+\n+int main()\n+{\n+  test03();\n+  return !test;\n+}"}, {"sha": "1492d9c0cecd66d4edd68a4f9010d5854a230a9e", "filename": "libstdc++-v3/testsuite/23_containers/vector/invalidation/4.cc", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fvector%2Finvalidation%2F4.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -0,0 +1,67 @@\n+// Vector iterator invalidation tests\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// We need to be pedantic about reallocations for this testcase to be correct.\n+// { dg-options \"-D_GLIBCXX_DEBUG_PEDANTIC\" }\n+\n+#ifndef _GLIBCXX_DEBUG_PEDANTIC\n+#  define _GLIBCXX_DEBUG_PEDANTIC 1\n+#endif\n+\n+#include <debug/vector>\n+#include <testsuite_hooks.h>\n+\n+using __gnu_debug::vector;\n+\n+bool test = true;\n+\n+// Erase\n+void test04()\n+{\n+  vector<int> v(20, 42);\n+\n+  // Single element erase\n+  vector<int>::iterator before = v.begin();\n+  vector<int>::iterator at = before + 3;\n+  vector<int>::iterator after = at;\n+  at = v.erase(at);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_dereferenceable());\n+  VERIFY(after._M_singular());\n+\n+  // Multiple element erase\n+  before = v.begin();\n+  at = before + 3;\n+  v.erase(at, at + 3);\n+  VERIFY(before._M_dereferenceable());\n+  VERIFY(at._M_singular());\n+\n+  // clear()\n+  before = v.begin();\n+  VERIFY(before._M_dereferenceable());\n+  v.clear();\n+  VERIFY(before._M_singular());\n+}\n+\n+int main()\n+{\n+  test04();\n+  return !test;\n+}"}, {"sha": "6d564f2f9eea621eb1146b22579b92844c26e4d8", "filename": "libstdc++-v3/testsuite/25_algorithms/heap.cc", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/285b36d6a58c08792e78f9fedb3f84bdba3a4eee/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fheap.cc?ref=285b36d6a58c08792e78f9fedb3f84bdba3a4eee", "patch": "@@ -95,13 +95,17 @@ test02()\n \n     for (int i = 2; i <= N; ++i) {\n         std::push_heap(s1, s1 + i, gt);\n+#ifndef _GLIBCXX_DEBUG\n         VERIFY(gt.count() <= logN);\n+#endif\n         gt.reset();\n     }\n \n     for (int i = N; i >= 2; --i) {\n         std::pop_heap(s1, s1 + i, gt);\n+#ifndef _GLIBCXX_DEBUG\n         VERIFY(gt.count() <= 2 * logN);\n+#endif\n         gt.reset();\n     }\n \n@@ -113,11 +117,15 @@ test02()\n     VERIFY(std::equal(s2, s2 + N, A));\n \n     std::make_heap(s2, s2 + N, gt);\n+#ifndef _GLIBCXX_DEBUG\n     VERIFY(gt.count() <= 3 * N);\n+#endif\n     gt.reset();\n \n     std::sort_heap(s2, s2 + N, gt);\n+#ifndef _GLIBCXX_DEBUG\n     VERIFY(gt.count() <= N * logN);\n+#endif\n \n     VERIFY(std::equal(s2, s2 + N, C));\n }"}]}