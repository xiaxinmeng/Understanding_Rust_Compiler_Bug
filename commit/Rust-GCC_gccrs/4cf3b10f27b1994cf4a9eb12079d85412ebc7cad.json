{"sha": "4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGNmM2IxMGYyN2IxOTk0Y2Y0YTllYjEyMDc5ZDg1NDEyZWJjN2NhZA==", "commit": {"author": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2021-04-30T08:08:03Z"}, "committer": {"name": "Roman Zhuykov", "email": "zhroma@ispras.ru", "date": "2021-04-30T08:08:03Z"}, "message": "modulo-sched: skip loops with strange register defs [PR100225]\n\nPR84878 fix adds an assertion which can fail, e.g. when stack pointer\nis adjusted inside the loop.  We have to prevent it and search earlier\nfor any 'strange' instruction.  The solution is to skip the whole loop\nif using 'note_stores' we found that one of hard registers is in\n'df->regular_block_artificial_uses' set.\n\nAlso patch properly prohibit not single-set instruction in loop body.\n\ngcc/ChangeLog:\n\n\tPR rtl-optimization/100225\n\tPR rtl-optimization/84878\n\t* modulo-sched.c (sms_schedule): Use note_stores to skip loops\n\twhere we have an instruction which touches (writes) any hard\n\tregister from df->regular_block_artificial_uses set.\n\tAllow not-single-set instruction only right before basic block\n\ttail.\n\ngcc/testsuite/ChangeLog:\n\n\tPR rtl-optimization/100225\n\tPR rtl-optimization/84878\n\t* gcc.dg/pr100225.c: New test.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c: New test.", "tree": {"sha": "bb167747d3cbab6271804ab972913459d96ae480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb167747d3cbab6271804ab972913459d96ae480"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/comments", "author": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zhroma", "id": 23097573, "node_id": "MDQ6VXNlcjIzMDk3NTcz", "avatar_url": "https://avatars.githubusercontent.com/u/23097573?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zhroma", "html_url": "https://github.com/zhroma", "followers_url": "https://api.github.com/users/zhroma/followers", "following_url": "https://api.github.com/users/zhroma/following{/other_user}", "gists_url": "https://api.github.com/users/zhroma/gists{/gist_id}", "starred_url": "https://api.github.com/users/zhroma/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zhroma/subscriptions", "organizations_url": "https://api.github.com/users/zhroma/orgs", "repos_url": "https://api.github.com/users/zhroma/repos", "events_url": "https://api.github.com/users/zhroma/events{/privacy}", "received_events_url": "https://api.github.com/users/zhroma/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "17f2908fcf058e145cff275966e34f8c7f57c2c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17f2908fcf058e145cff275966e34f8c7f57c2c5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17f2908fcf058e145cff275966e34f8c7f57c2c5"}], "stats": {"total": 1698, "additions": 1677, "deletions": 21}, "files": [{"sha": "e72e46db387f767b46c423b71a35e319c89f6fbb", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 35, "deletions": 21, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "patch": "@@ -43,6 +43,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-pass.h\"\n #include \"dbgcnt.h\"\n #include \"loop-unroll.h\"\n+#include \"hard-reg-set.h\"\n \n #ifdef INSN_SCHEDULING\n \n@@ -1356,6 +1357,7 @@ sms_schedule (void)\n   basic_block condition_bb = NULL;\n   edge latch_edge;\n   HOST_WIDE_INT trip_count, max_trip_count;\n+  HARD_REG_SET prohibited_regs;\n \n   loop_optimizer_init (LOOPS_HAVE_PREHEADERS\n \t\t       | LOOPS_HAVE_RECORDED_EXITS);\n@@ -1385,6 +1387,8 @@ sms_schedule (void)\n      We use loop->num as index into this array.  */\n   g_arr = XCNEWVEC (ddg_ptr, number_of_loops (cfun));\n \n+  REG_SET_TO_HARD_REG_SET (prohibited_regs, &df->regular_block_artificial_uses);\n+\n   if (dump_file)\n   {\n     fprintf (dump_file, \"\\n\\nSMS analysis phase\\n\");\n@@ -1469,23 +1473,31 @@ sms_schedule (void)\n       }\n \n       /* Don't handle BBs with calls or barriers\n-\t or !single_set with the exception of instructions that include\n-\t count_reg---these instructions are part of the control part\n-\t that do-loop recognizes.\n+\t or !single_set with the exception of do-loop control part insns.\n          ??? Should handle insns defining subregs.  */\n-     for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n-      {\n-         rtx set;\n-\n-        if (CALL_P (insn)\n-            || BARRIER_P (insn)\n-            || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n-                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n-                && !reg_mentioned_p (count_reg, insn))\n-            || (INSN_P (insn) && (set = single_set (insn))\n-                && GET_CODE (SET_DEST (set)) == SUBREG))\n-        break;\n-      }\n+      for (insn = head; insn != NEXT_INSN (tail); insn = NEXT_INSN (insn))\n+\t{\n+\t  if (INSN_P (insn))\n+\t    {\n+\t      HARD_REG_SET regs;\n+\t      CLEAR_HARD_REG_SET (regs);\n+\t      note_stores (insn, record_hard_reg_sets, &regs);\n+\t      if (hard_reg_set_intersect_p (regs, prohibited_regs))\n+\t\tbreak;\n+\t    }\n+\n+\t  if (CALL_P (insn)\n+\t      || BARRIER_P (insn)\n+\t      || (INSN_P (insn) && single_set (insn)\n+\t\t  && GET_CODE (SET_DEST (single_set (insn))) == SUBREG)\n+\t      /* Not a single set.  */\n+\t      || (NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n+\t\t  && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE\n+\t\t  /* But non-single-set allowed in one special case.  */\n+\t\t  && (insn != prev_nondebug_insn (tail)\n+\t\t      || !reg_mentioned_p (count_reg, insn))))\n+\t    break;\n+\t}\n \n       if (insn != NEXT_INSN (tail))\n \t{\n@@ -1495,11 +1507,13 @@ sms_schedule (void)\n \t\tfprintf (dump_file, \"SMS loop-with-call\\n\");\n \t      else if (BARRIER_P (insn))\n \t\tfprintf (dump_file, \"SMS loop-with-barrier\\n\");\n-              else if ((NONDEBUG_INSN_P (insn) && !JUMP_P (insn)\n-                && !single_set (insn) && GET_CODE (PATTERN (insn)) != USE))\n-                fprintf (dump_file, \"SMS loop-with-not-single-set\\n\");\n-              else\n-               fprintf (dump_file, \"SMS loop with subreg in lhs\\n\");\n+\t      else if (INSN_P (insn) && single_set (insn)\n+\t\t       && GET_CODE (SET_DEST (single_set (insn))) == SUBREG)\n+\t\tfprintf (dump_file, \"SMS loop with subreg in lhs\\n\");\n+\t      else\n+\t\tfprintf (dump_file,\n+\t\t\t \"SMS loop-with-not-single-set-or-prohibited-reg\\n\");\n+\n \t      print_rtl_single (dump_file, insn);\n \t    }\n "}, {"sha": "b32163441a3c37bdfd8d085ac4e958821afcf0c1", "filename": "gcc/testsuite/gcc.dg/pr100225.c", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100225.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100225.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr100225.c?ref=4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "patch": "@@ -0,0 +1,15 @@\n+/* PR rtl-optimization/100225 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O1 -fmodulo-sched\" } */\n+\n+void\n+vorbis_synthesis_lapout (void);\n+\n+void\n+ov_info (int **lappcm, int ov_info_i)\n+{\n+  while (ov_info_i < 1)\n+    lappcm[ov_info_i++] = __builtin_alloca (1);\n+\n+  vorbis_synthesis_lapout ();\n+}"}, {"sha": "b976094998f2df8765e15c1c964f6c46d67c4c49", "filename": "libgomp/testsuite/libgomp.oacc-c-c++-common/atomic_capture-3.c", "status": "added", "additions": 1627, "deletions": 0, "changes": 1627, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4cf3b10f27b1994cf4a9eb12079d85412ebc7cad/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.oacc-c-c%2B%2B-common%2Fatomic_capture-3.c?ref=4cf3b10f27b1994cf4a9eb12079d85412ebc7cad", "patch": "@@ -0,0 +1,1627 @@\n+/* { dg-do run } */\n+/* { dg-additional-options \"-fmodulo-sched -fmodulo-sched-allow-regmoves\" } */\n+\n+#include <stdlib.h>\n+\n+int\n+main(int argc, char **argv)\n+{\n+  int   iexp, igot, imax, imin;\n+  long long lexp, lgot;\n+  int   N = 32;\n+  int\ti;\n+  int   idata[N];\n+  long long ldata[N];\n+  float fexp, fgot;\n+  float fdata[N];\n+\n+  igot = 1234;\n+  iexp = 31;\n+\n+  for (i = 0; i < N; i++)\n+    idata[i] = i;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot = i; }\n+  }\n+\n+  imax = 0;\n+  imin = N;\n+\n+  for (i = 0; i < N; i++)\n+    {\n+      imax = idata[i] > imax ? idata[i] : imax;\n+      imin = idata[i] < imin ? idata[i] : imin;\n+    }\n+\n+  if (imax != 1234 || imin != 0)\n+    abort ();\n+\n+  return 0;\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot++; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; ++igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { ++igot; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { igot++; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot--; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { idata[i] = igot; --igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { --igot; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+#pragma acc atomic capture\n+      { igot--; idata[i] = igot; }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = + */\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot += expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot += expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = igot + expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = expr + igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = igot + expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+\n+  igot = 0;\n+  iexp = 32;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = expr + igot; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot *= expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot *= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot * expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = expr * lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot * expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2;\n+\n+#pragma acc atomic capture\n+      { lgot = expr * lgot; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      int expr = 1;\n+\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot -= expr; }\n+    }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot -= expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 32;\n+  iexp = 0;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { idata[i] = igot; igot = igot - expr; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = 1;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      int expr = 1;\n+\n+#pragma acc atomic capture\n+      { idata[i] = igot; igot = expr - igot; }\n+    }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (idata[i] != 1)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (idata[i] != 0)\n+\t  abort ();\n+      }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = -31;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = igot - expr; idata[i] = igot; }\n+      }\n+  }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  igot = 1;\n+  iexp = 1;\n+\n+#pragma acc data copy (igot, idata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        int expr = 1;\n+\n+#pragma acc atomic capture\n+        { igot = expr - igot; idata[i] = igot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (idata[i] != 0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (idata[i] != 1)\n+\t  abort ();\n+      }\n+\n+  if (iexp != igot)\n+    abort ();\n+\n+  /* BINOP = / */\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot /= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+        { lgot /= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << 32;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = lgot / expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr / lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot / expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 2LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = expr / lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = & */\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot &= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot &= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot & expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr & lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot & expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+      { lgot = expr & lgot; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = ^ */\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 1 << i;\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot ^= expr; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot ^= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot ^ expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+      { ldata[i] = lgot; lgot = expr ^ lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  iexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot ^ expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = ~0LL;\n+  lexp = 0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = expr ^ lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = | */\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1 << i;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot |= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  iexp = ~0LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot |= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot | expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr | lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  iexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = lgot | expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 0LL;\n+  lexp = ~0LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = ~(1 << i);\n+\n+#pragma acc atomic capture\n+        { lgot = expr | lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = << */\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot <<= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  iexp = 1LL << N; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot <<= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << N;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot << expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr << lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot << expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 2LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = expr << lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  /* BINOP = >> */\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+  \n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot >>= expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  iexp = 1LL; \n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot >>= expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = lgot >> expr; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { ldata[i] = lgot; lgot = expr >> lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL << N;\n+  lexp = 1LL;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL;\n+\n+#pragma acc atomic capture\n+        { lgot = lgot >> expr; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << (N - 1);\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < 1; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { lgot = expr >> lgot; ldata[i] = lgot; }\n+      }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  // FLOAT FLOAT FLOAT\n+\n+  /* BINOP = + */\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot += expr; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot += expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { idata[i] = fgot; fgot = fgot + expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot = expr + fgot; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot + expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 0.0;\n+  fexp = 32.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr + fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = * */\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 2.0;\n+\n+#pragma acc atomic capture\n+      { fdata[i] = fgot; fgot *= expr; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot *= expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot * expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr * fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  lgot = 1LL;\n+  lexp = 1LL << 32;\n+\n+#pragma acc data copy (lgot, ldata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      long long expr = 2LL;\n+\n+#pragma acc atomic capture\n+      { lgot = lgot * expr; ldata[i] = lgot; }\n+    }\n+  }\n+\n+  if (lexp != lgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 8192.0*8192.0*64.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 2;\n+\n+#pragma acc atomic capture\n+        { fgot = expr * fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = - */\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+  \n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot -= expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+      float expr = 1.0;\n+\n+#pragma acc atomic capture\n+      { fgot -= expr; fdata[i] = fgot; }\n+    }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 32.0;\n+  fexp = 0.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot - expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr - fgot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (fdata[i] != 1.0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (fdata[i] != 0.0)\n+\t  abort ();\n+      }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = -31.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot - expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 1.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr - fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  for (i = 0; i < N; i++)\n+    if (i % 2 == 0)\n+      {\n+\tif (fdata[i] != 0.0)\n+\t  abort ();\n+      }\n+    else\n+      {\n+\tif (fdata[i] != 1.0)\n+\t  abort ();\n+      }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  /* BINOP = / */\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot /= expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot /= expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = fgot / expr; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 8192.0*8192.0*64.0;\n+  fexp = 1.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 1.0;\n+\n+#pragma acc atomic capture\n+        { fdata[i] = fgot; fgot = expr / fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 4.0;\n+  fexp = 4.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        long long expr = 1LL << N;\n+\n+#pragma acc atomic capture\n+        { fgot = fgot / expr; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  fgot = 4.0;\n+  fexp = 4.0;\n+\n+#pragma acc data copy (fgot, fdata[0:N])\n+  {\n+#pragma acc parallel loop\n+    for (i = 0; i < N; i++)\n+      {\n+        float expr = 2.0;\n+\n+#pragma acc atomic capture\n+        { fgot = expr / fgot; fdata[i] = fgot; }\n+      }\n+  }\n+\n+  if (fexp != fgot)\n+    abort ();\n+\n+  return 0;\n+}"}]}