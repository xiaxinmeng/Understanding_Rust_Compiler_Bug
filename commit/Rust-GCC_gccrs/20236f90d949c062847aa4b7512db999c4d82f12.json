{"sha": "20236f90d949c062847aa4b7512db999c4d82f12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAyMzZmOTBkOTQ5YzA2Mjg0N2FhNGI3NTEyZGI5OTljNGQ4MmYxMg==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-26T20:19:09Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-01-26T20:19:09Z"}, "message": "re PR fortran/25964 (NIST regression on fm311.f)\n\n2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25964\n\t* resolve.c (resolve_function): Exclude statement functions from\n\tglobal reference checking.\n\n\tPR fortran/25084\n\tPR fortran/20852\n\tPR fortran/25085\n\tPR fortran/25086\n\t* resolve.c (resolve_function): Declare a gfc_symbol to replace the\n\treferences through the symtree to the symbol associated with the\n\tfunction expresion. Give error on reference to an assumed character\n\tlength function is defined in an interface or an external function\n\tthat is not a dummy argument.\n\t(resolve_symbol): Give error if an assumed character length function\n\tis array-valued, pointer-valued, pure or recursive. Emit warning\n\tthat character(*) value functions are obsolescent in F95.\n\n\tPR fortran/25416\n\t* trans-expr.c (gfc_conv_function_call): The above patch to resolve.c\n\tprevents any assumed character length function call from getting here\n\texcept intrinsics such as SPREAD. In this case, ensure that no\n\tsegfault occurs from referencing non-existent charlen->length->\n\texpr_type and provide a backend_decl for the charlen from the charlen\n\tof the first actual argument.\n\n\tCure temp name confusion.\n\t* trans-expr.c (gfc_get_interface_mapping_array): Change name of\n\ttemporary from \"parm\" to \"ifm\" to avoid clash with temp coming from\n\ttrans-array.c.\n\n2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/25964\n\t* gfortran.dg/global_references_2.f90: New test.\n\n\tPR fortran/25084\n\tPR fortran/20852\n\tPR fortran/25085\n\tPR fortran/25086\n\t* gfortran.dg/assumed_charlen_function_1.f90: New test.\n\t* gfortran.dg/assumed_charlen_function_3.f90: New test.\n\n\tPR fortran/25416\n\t* gfortran.dg/assumed_charlen_function_2.f90: New test.\n\nFrom-SVN: r110269", "tree": {"sha": "ebf78f5f326fc3e241a4ed6fc7cd2feb71ba9ae0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebf78f5f326fc3e241a4ed6fc7cd2feb71ba9ae0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/20236f90d949c062847aa4b7512db999c4d82f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20236f90d949c062847aa4b7512db999c4d82f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/20236f90d949c062847aa4b7512db999c4d82f12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/20236f90d949c062847aa4b7512db999c4d82f12/comments", "author": null, "committer": null, "parents": [{"sha": "e8b053801c57d8d7daf305d6b7ce01cbd4958e73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8b053801c57d8d7daf305d6b7ce01cbd4958e73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8b053801c57d8d7daf305d6b7ce01cbd4958e73"}], "stats": {"total": 314, "additions": 294, "deletions": 20}, "files": [{"sha": "7fc7fb0d33b32b2769a5254e01ebaf5faba67c10", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -1,3 +1,35 @@\n+2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25964\n+\t* resolve.c (resolve_function): Exclude statement functions from\n+\tglobal reference checking.\n+\n+\tPR fortran/25084\n+\tPR fortran/20852\n+\tPR fortran/25085\n+\tPR fortran/25086\n+\t* resolve.c (resolve_function): Declare a gfc_symbol to replace the\n+\treferences through the symtree to the symbol associated with the\n+\tfunction expresion. Give error on reference to an assumed character\n+\tlength function is defined in an interface or an external function\n+\tthat is not a dummy argument.\n+\t(resolve_symbol): Give error if an assumed character length function\n+\tis array-valued, pointer-valued, pure or recursive. Emit warning\n+\tthat character(*) value functions are obsolescent in F95.\n+\n+\tPR fortran/25416\n+\t* trans-expr.c (gfc_conv_function_call): The above patch to resolve.c\n+\tprevents any assumed character length function call from getting here\n+\texcept intrinsics such as SPREAD. In this case, ensure that no\n+\tsegfault occurs from referencing non-existent charlen->length->\n+\texpr_type and provide a backend_decl for the charlen from the charlen\n+\tof the first actual argument.\n+\n+\tCure temp name confusion.\n+\t* trans-expr.c (gfc_get_interface_mapping_array): Change name of\n+\ttemporary from \"parm\" to \"ifm\" to avoid clash with temp coming from\n+\ttrans-array.c.\n+\n 2005-01-25  Erik Edelmann  <eedelman@gcc.gnu.org>\n \n \tPR fortran/25716"}, {"sha": "99fb2a2dd84a58792edde752ae2d647f6440298d", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 78, "deletions": 9, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -1183,17 +1183,21 @@ static try\n resolve_function (gfc_expr * expr)\n {\n   gfc_actual_arglist *arg;\n+  gfc_symbol * sym;\n   const char *name;\n   try t;\n   int temp;\n \n-  /* If the procedure is not internal or module, it must be external and\n-     should be checked for usage.  */\n-  if (expr->symtree && expr->symtree->n.sym\n-\t&& !expr->symtree->n.sym->attr.dummy\n-\t&& !expr->symtree->n.sym->attr.contained\n-\t&& !expr->symtree->n.sym->attr.use_assoc)\n-    resolve_global_procedure (expr->symtree->n.sym, &expr->where, 0);\n+  sym = NULL;\n+  if (expr->symtree)\n+    sym = expr->symtree->n.sym;\n+\n+  /* If the procedure is not internal, a statement function or a module\n+     procedure,it must be external and should be checked for usage.  */\n+  if (sym && !sym->attr.dummy && !sym->attr.contained\n+\t&& sym->attr.proc != PROC_ST_FUNCTION\n+\t&& !sym->attr.use_assoc)\n+    resolve_global_procedure (sym, &expr->where, 0);\n \n   /* Switch off assumed size checking and do this again for certain kinds\n      of procedure, once the procedure itself is resolved.  */\n@@ -1205,19 +1209,44 @@ resolve_function (gfc_expr * expr)\n   /* Resume assumed_size checking. */\n   need_full_assumed_size--;\n \n+  if (sym && sym->ts.type == BT_CHARACTER\n+\t  && sym->ts.cl && sym->ts.cl->length == NULL)\n+    {\n+      if (sym->attr.if_source == IFSRC_IFBODY)\n+\t{\n+\t  /* This follows from a slightly odd requirement at 5.1.1.5 in the\n+\t     standard that allows assumed character length functions to be\n+\t     declared in interfaces but not used.  Picking up the symbol here,\n+\t     rather than resolve_symbol, accomplishes that.  */\n+\t  gfc_error (\"Function '%s' can be declared in an interface to \"\n+\t\t     \"return CHARACTER(*) but cannot be used at %L\",\n+\t\t     sym->name, &expr->where);\n+\t  return FAILURE;\n+\t}\n+\n+      /* Internal procedures are taken care of in resolve_contained_fntype.  */\n+      if (!sym->attr.dummy && !sym->attr.contained)\n+\t{\n+\t  gfc_error (\"Function '%s' is declared CHARACTER(*) and cannot \"\n+\t\t     \"be used at %L since it is not a dummy argument\",\n+\t\t     sym->name, &expr->where);\n+\t  return FAILURE;\n+\t}\n+    }\n+\n /* See if function is already resolved.  */\n \n   if (expr->value.function.name != NULL)\n     {\n       if (expr->ts.type == BT_UNKNOWN)\n-\texpr->ts = expr->symtree->n.sym->ts;\n+\texpr->ts = sym->ts;\n       t = SUCCESS;\n     }\n   else\n     {\n       /* Apply the rules of section 14.1.2.  */\n \n-      switch (procedure_kind (expr->symtree->n.sym))\n+      switch (procedure_kind (sym))\n \t{\n \tcase PTYPE_GENERIC:\n \t  t = resolve_generic_f (expr);\n@@ -4862,6 +4891,46 @@ resolve_symbol (gfc_symbol * sym)\n \t  return;\n \t}\n \n+      /* 5.1.1.5 of the Standard: A function name declared with an asterisk\n+\t char-len-param shall not be array-valued, pointer-valued, recursive\n+\t or pure.  ....snip... A character value of * may only be used in the\n+\t following ways: (i) Dummy arg of procedure - dummy associates with\n+\t actual length; (ii) To declare a named constant; or (iii) External\n+\t function - but length must be declared in calling scoping unit.  */\n+      if (sym->attr.function\n+\t    && sym->ts.type == BT_CHARACTER\n+\t    && sym->ts.cl && sym->ts.cl->length == NULL)\n+\t{\n+\t  if ((sym->as && sym->as->rank) || (sym->attr.pointer)\n+\t\t || (sym->attr.recursive) || (sym->attr.pure))\n+\t    {\n+\t      if (sym->as && sym->as->rank)\n+\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t\t   \"array-valued\", sym->name, &sym->declared_at);\n+\n+\t      if (sym->attr.pointer)\n+\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t\t   \"pointer-valued\", sym->name, &sym->declared_at);\n+\n+\t      if (sym->attr.pure)\n+\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t\t   \"pure\", sym->name, &sym->declared_at);\n+\n+\t      if (sym->attr.recursive)\n+\t\tgfc_error (\"CHARACTER(*) function '%s' at %L cannot be \"\n+\t\t\t   \"recursive\", sym->name, &sym->declared_at);\n+\n+\t      return;\n+\t    }\n+\n+\t  /* Appendix B.2 of the standard.  Contained functions give an\n+\t     error anyway.  Fixed-form is likely to be F77/legacy.  */\n+\t  if (!sym->attr.contained && gfc_current_form != FORM_FIXED)\n+\t    gfc_notify_std (GFC_STD_F95_OBS, \"CHARACTER(*) function \"\n+\t\t\t    \"'%s' at %L is obsolescent in fortran 95\",\n+\t\t\t    sym->name, &sym->declared_at);\n+\t}\n+\n       break;\n \n     case FL_DERIVED:"}, {"sha": "232270514b863f274d72e7a1ddf360bd736a3947", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -1224,7 +1224,7 @@ gfc_get_interface_mapping_array (stmtblock_t * block, gfc_symbol * sym,\n   type = gfc_typenode_for_spec (&sym->ts);\n   type = gfc_get_nodesc_array_type (type, sym->as, packed);\n \n-  var = gfc_create_var (type, \"parm\");\n+  var = gfc_create_var (type, \"ifm\");\n   gfc_add_modify_expr (block, var, fold_convert (type, data));\n \n   return var;\n@@ -1807,8 +1807,10 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \n   gfc_init_interface_mapping (&mapping);\n   need_interface_mapping = ((sym->ts.type == BT_CHARACTER\n-\t\t\t     && sym->ts.cl->length->expr_type != EXPR_CONSTANT)\n-\t\t\t    || sym->attr.dimension);\n+\t\t\t\t  && sym->ts.cl->length\n+\t\t\t\t  && sym->ts.cl->length->expr_type\n+\t\t\t\t\t\t!= EXPR_CONSTANT)\n+\t\t\t      || sym->attr.dimension);\n   formal = sym->formal;\n   /* Evaluate the arguments.  */\n   for (; arg != NULL; arg = arg->next, formal = formal ? formal->next : NULL)\n@@ -1905,19 +1907,30 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n   ts = sym->ts;\n   if (ts.type == BT_CHARACTER)\n     {\n-      /* Calculate the length of the returned string.  */\n-      gfc_init_se (&parmse, NULL);\n-      if (need_interface_mapping)\n-\tgfc_apply_interface_mapping (&mapping, &parmse, sym->ts.cl->length);\n+      if (sym->ts.cl->length == NULL)\n+\t{\n+\t  /* Assumed character length results are not allowed by 5.1.1.5 of the\n+\t     standard and are trapped in resolve.c; except in the case of SPREAD\n+\t     (and other intrinsics?).  In this case, we take the character length\n+\t     of the first argument for the result.  */\n+\t  cl.backend_decl = TREE_VALUE (stringargs);\n+\t}\n       else\n-\tgfc_conv_expr (&parmse, sym->ts.cl->length);\n-      gfc_add_block_to_block (&se->pre, &parmse.pre);\n-      gfc_add_block_to_block (&se->post, &parmse.post);\n+\t{\n+\t  /* Calculate the length of the returned string.  */\n+\t  gfc_init_se (&parmse, NULL);\n+\t  if (need_interface_mapping)\n+\t    gfc_apply_interface_mapping (&mapping, &parmse, sym->ts.cl->length);\n+\t  else\n+\t    gfc_conv_expr (&parmse, sym->ts.cl->length);\n+\t  gfc_add_block_to_block (&se->pre, &parmse.pre);\n+\t  gfc_add_block_to_block (&se->post, &parmse.post);\n+\t  cl.backend_decl = fold_convert (gfc_charlen_type_node, parmse.expr);\n+\t}\n \n       /* Set up a charlen structure for it.  */\n       cl.next = NULL;\n       cl.length = NULL;\n-      cl.backend_decl = fold_convert (gfc_charlen_type_node, parmse.expr);\n       ts.cl = &cl;\n \n       len = cl.backend_decl;"}, {"sha": "f315158448c53d67cd355fc850c68921a2cd26f2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -1,3 +1,18 @@\n+2005-01-26  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/25964\n+\t* gfortran.dg/global_references_2.f90: New test.\n+\n+\tPR fortran/25084\n+\tPR fortran/20852\n+\tPR fortran/25085\n+\tPR fortran/25086\n+\t* gfortran.dg/assumed_charlen_function_1.f90: New test.\n+\t* gfortran.dg/assumed_charlen_function_3.f90: New test.\n+\n+\tPR fortran/25416\n+\t* gfortran.dg/assumed_charlen_function_2.f90: New test.\n+\n 2006-01-26  Alexandre Oliva  <aoliva@redhat.com>\n \n \tPR c/25892"}, {"sha": "c90617dcec065f2aad749e8f11b079c62829c73d", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_function_1.f90", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_1.f90?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -0,0 +1,83 @@\n+! { dg-do compile }\r\n+! { dg-options \"-std=legacy\" }\r\n+! Tests the patch for PRs 25084, 20852, 25085 and 25086, all of\r\n+! which involve assumed character length functions.\r\n+! Compiled from original PR testcases, which were all contributed\r\n+! by Joost VandeVondele  <jv244@cam.ac.uk>\r\n+!\r\n+! PR25084 - the error is not here but in any use of .IN.\r\n+! It is OK to define an assumed character length function\r\n+! in an interface but it cannot be invoked (5.1.1.5).\r\n+\r\n+MODULE M1\r\n+ TYPE  SET\r\n+  INTEGER  CARD\r\n+ END  TYPE  SET\r\n+END MODULE M1\r\n+\r\n+MODULE  INTEGER_SETS\r\n+ INTERFACE  OPERATOR  (.IN.)\r\n+  FUNCTION ELEMENT(X,A)\r\n+     USE M1\r\n+     CHARACTER(LEN=*)      :: ELEMENT\r\n+     INTEGER, INTENT(IN)   ::  X\r\n+     TYPE(SET), INTENT(IN) ::   A\r\n+  END FUNCTION ELEMENT\r\n+ END  INTERFACE\r\n+END MODULE\r\n+\r\n+! 5.1.1.5 of the Standard: A function name declared with an asterisk\r\n+! char-len-param shall not be array-valued, pointer-valued, recursive\r\n+! or pure\r\n+! \r\n+! PR20852\r\n+RECURSIVE FUNCTION TEST() ! { dg-error \"cannot be recursive\" }\r\n+ CHARACTER(LEN=*) :: TEST\r\n+ TEST = \"\"\r\n+END FUNCTION\r\n+\r\n+!PR25085\r\n+FUNCTION F1()             ! { dg-error \"cannot be array-valued\" }\r\n+  CHARACTER(LEN=*), DIMENSION(10) :: F1\r\n+  F1 = \"\"\r\n+END FUNCTION F1\r\n+\r\n+!PR25086\r\n+FUNCTION F2() result(f4)  ! { dg-error \"cannot be pointer-valued\" }\r\n+  CHARACTER(LEN=*), POINTER  :: f4\r\n+  f4 = \"\"\r\n+END FUNCTION F2\r\n+\r\n+!PR?????\r\n+pure FUNCTION F3()        ! { dg-error \"cannot be pure\" }\r\n+  CHARACTER(LEN=*)  :: F3\r\n+  F3 = \"\"\r\n+END FUNCTION F3\r\n+\r\n+function not_OK (ch)\r\n+  character(*) not_OK, ch ! OK in an external function\r\n+  not_OK = ch\r\n+end function not_OK\r\n+\r\n+  use INTEGER_SETS\r\n+  use m1\r\n+\r\n+  character(4) :: answer\r\n+  character(*), external :: not_OK\r\n+  integer :: i\r\n+  type (set) :: z\r\n+\r\n+  interface\r\n+    function ext (i)\r\n+      character(*) :: ext\r\n+      integer :: i\r\n+    end function ext\r\n+  end interface\r\n+\r\n+  answer = i.IN.z   ! { dg-error \"cannot be used|Operands of user operator\" }\r\n+  answer = ext (2)  ! { dg-error \"but cannot be used\" }\r\n+\r\n+  answer = not_OK (\"unOK\") ! { dg-error \"since it is not a dummy\" }\r\n+\r\n+END\r\n+\r"}, {"sha": "bd7d713f91680b60ccdb4fc8f929a05a22e01c40", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_function_2.f90", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_2.f90?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -0,0 +1,13 @@\n+! { dg-do compile }\r\n+! Tests the fix for PR25416, which ICED in gfc_conv_function_call, when\r\n+! treating SPREAD in the statement below.\r\n+!\r\n+! Contributed by Ulrich Weigand  <uweigand@gcc.gnu.org>\r\n+function bug(self,strvec) result(res)\r\n+  character(*) :: self\r\n+  character(*), dimension(:), intent(in) :: strvec\r\n+  logical(kind=kind(.true.)) :: res\r\n+\r\n+  res = any(index(strvec,spread(self,1,size(strvec))) /= 0)\r\n+end function\r\n+\r"}, {"sha": "09c9be97c0309326e192a0cda34af539be5c52d7", "filename": "gcc/testsuite/gfortran.dg/assumed_charlen_function_3.f90", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fassumed_charlen_function_3.f90?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -0,0 +1,39 @@\n+! { dg-do compile }\r\n+! Tests the patch for PRs 25084, 20852, 25085 and 25086, all of\r\n+! which involve assumed character length functions.\r\n+! This test checks the things that should not emit errors.\r\n+!\r\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\r\n+!\r\n+function is_OK (ch)                ! { dg-warning \"is obsolescent in fortran 95\" }\r\n+  character(*) is_OK, ch           ! OK in an external function\r\n+  is_OK = ch\r\n+end function is_OK\r\n+\r\n+! The warning occurs twice for the next line; for 'more_OK' and for 'fcn';\r\n+function more_OK (ch, fcn)         ! { dg-warning \"is obsolescent in fortran 95\" }\r\n+  character(*) more_OK, ch\r\n+  character (*), external :: fcn   ! OK as a dummy argument\r\n+  more_OK = fcn (ch)\r\n+end function more_OK\r\n+\r\n+  character(4) :: answer\r\n+  character(4), external :: is_OK, more_OK\r\n+\r\n+  answer = is_OK (\"isOK\")          ! LEN defined in calling scope\r\n+  print *, answer\r\n+\r\n+  answer = more_OK (\"okay\", is_OK) ! Actual arg has defined LEN\r\n+  print *, answer\r\n+\r\n+  answer = also_OK (\"OKOK\")\r\n+  print *, answer\r\n+\r\n+contains\r\n+  function also_OK (ch)\r\n+    character(4) also_OK\r\n+    character(*) ch\r\n+    also_OK = is_OK (ch)            ! LEN obtained by host association\r\n+  end function also_OK\r\n+END\r\n+\r"}, {"sha": "95666981ac0bc6541a6eeed18dc777c1a385cda2", "filename": "gcc/testsuite/gfortran.dg/global_references_2.f90", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/20236f90d949c062847aa4b7512db999c4d82f12/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fglobal_references_2.f90?ref=20236f90d949c062847aa4b7512db999c4d82f12", "patch": "@@ -0,0 +1,10 @@\n+! { dg-do compile }\n+! This program tests the patch for PR25964. This is a\n+! regression that would not allow a common block and a statement\n+! to share the same name.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+  common /foo/ a, b, c\n+  foo (x) = x + 1.0\n+  print *, foo (0.0)\n+  end\n\\ No newline at end of file"}]}