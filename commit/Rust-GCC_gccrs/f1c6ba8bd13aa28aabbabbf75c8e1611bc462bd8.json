{"sha": "f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjFjNmJhOGJkMTNhYTI4YWFiYmFiYmY3NWM4ZTE2MTFiYzQ2MmJkOA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@vlsi1.ultra.nyu.edu", "date": "2001-03-17T17:00:23Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "2001-03-17T17:00:23Z"}, "message": "combine.c (undobuf): Remove field previous_undos; all refs deleted.\n\n\t* combine.c (undobuf): Remove field previous_undos; all refs deleted.\n\t(gen_rtx_combine): Deleted; all references changed as appropriate.\n\t(gen_unary): Deleted; all refs changed to call simplify_gen_unary.\n\nFrom-SVN: r40577", "tree": {"sha": "42642210f393ab1b2dd1cb27f5c94d9324cba3da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/42642210f393ab1b2dd1cb27f5c94d9324cba3da"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8/comments", "author": null, "committer": null, "parents": [{"sha": "6732576cfa22b4591ef20b9f585ca7c8dcbd75a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6732576cfa22b4591ef20b9f585ca7c8dcbd75a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6732576cfa22b4591ef20b9f585ca7c8dcbd75a9"}], "stats": {"total": 415, "additions": 172, "deletions": 243}, "files": [{"sha": "650510825cb04c3a9c07edeeb0814210e481e689", "filename": "gcc/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "patch": "@@ -1,5 +1,9 @@\n Sat Mar 17 11:52:34 2001  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n+\t* combine.c (undobuf): Remove field previous_undos; all refs deleted.\n+\t(gen_rtx_combine): Deleted; all references changed as appropriate.\n+\t(gen_unary): Deleted; all refs changed to call simplify_gen_unary.\n+\n \t* print-tree.c (print_node): Print DECL_NONADDRESSABLE_P.\n \n 2001-03-17  David Billinghurst  <David.Billinghurst@riotinto.com>"}, {"sha": "f5f0b58b2070cecf963c231d9f4fcd45e7b99cfc", "filename": "gcc/combine.c", "status": "modified", "additions": 168, "deletions": 243, "changes": 411, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=f1c6ba8bd13aa28aabbabbf75c8e1611bc462bd8", "patch": "@@ -337,18 +337,12 @@ struct undo\n    num_undo says how many are currently recorded.\n \n    other_insn is nonzero if we have modified some other insn in the process\n-   of working on subst_insn.  It must be verified too.\n-\n-   previous_undos is the value of undobuf.undos when we started processing\n-   this substitution.  This will prevent gen_rtx_combine from re-used a piece\n-   from the previous expression.  Doing so can produce circular rtl\n-   structures.  */\n+   of working on subst_insn.  It must be verified too.  */\n \n struct undobuf\n {\n   struct undo *undos;\n   struct undo *frees;\n-  struct undo *previous_undos;\n   rtx other_insn;\n };\n \n@@ -406,12 +400,8 @@ static rtx simplify_shift_const\tPARAMS ((rtx, enum rtx_code, enum machine_mode,\n \t\t\t\t\t rtx, int));\n static int recog_for_combine\tPARAMS ((rtx *, rtx, rtx *));\n static rtx gen_lowpart_for_combine  PARAMS ((enum machine_mode, rtx));\n-static rtx gen_rtx_combine PARAMS ((enum rtx_code code, enum machine_mode mode,\n-\t\t\t\t    ...));\n static rtx gen_binary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n \t\t\t\t\t rtx, rtx));\n-static rtx gen_unary\t\tPARAMS ((enum rtx_code, enum machine_mode,\n-\t\t\t\t\t enum machine_mode, rtx));\n static enum rtx_code simplify_comparison  PARAMS ((enum rtx_code, rtx *, rtx *));\n static void update_table_tick\tPARAMS ((rtx));\n static void record_value_for_reg  PARAMS ((rtx, rtx, rtx));\n@@ -1888,8 +1878,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t  subst_low_cuid = INSN_CUID (i2);\n \t  i2src = subst (i2src, pc_rtx, pc_rtx, 0, 0);\n \t}\n-\n-      undobuf.previous_undos = undobuf.undos;\n     }\n \n #ifndef HAVE_cc0\n@@ -1945,8 +1933,7 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t      SUBST (SET_DEST (newpat), new_dest);\n \t      SUBST (XEXP (*cc_use, 0), new_dest);\n \t      SUBST (SET_SRC (newpat),\n-\t\t     gen_rtx_combine (COMPARE, compare_mode,\n-\t\t\t\t      i2src, const0_rtx));\n+\t\t     gen_rtx_COMPARE (compare_mode, i2src, const0_rtx));\n \t    }\n \t  else\n \t    undobuf.other_insn = 0;\n@@ -1965,7 +1952,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n       subst_low_cuid = INSN_CUID (i2);\n       newpat = subst (PATTERN (i3), i2dest, i2src, 0,\n \t\t      ! i1_feeds_i3 && i1dest_in_i1src);\n-      undobuf.previous_undos = undobuf.undos;\n \n       /* Record whether i2's body now appears within i3's body.  */\n       i2_is_used = n_occurrences;\n@@ -1990,7 +1976,6 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n       n_occurrences = 0;\n       subst_low_cuid = INSN_CUID (i1);\n       newpat = subst (newpat, i1dest, i1src, 0, 0);\n-      undobuf.previous_undos = undobuf.undos;\n     }\n \n   /* Fail if an autoincrement side-effect has been duplicated.  Be careful\n@@ -2267,8 +2252,8 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t      && GET_CODE (XEXP (*split, 1)) == CONST_INT\n \t      && (i = exact_log2 (INTVAL (XEXP (*split, 1)))) >= 0)\n \t    {\n-\t      SUBST (*split, gen_rtx_combine (ASHIFT, split_mode,\n-\t\t\t\t\t      XEXP (*split, 0), GEN_INT (i)));\n+\t      SUBST (*split, gen_rtx_ASHIFT (split_mode,\n+\t\t\t\t\t     XEXP (*split, 0), GEN_INT (i)));\n \t      /* Update split_code because we may not have a multiply\n \t\t anymore.  */\n \t      split_code = GET_CODE (*split);\n@@ -2278,11 +2263,11 @@ try_combine (i3, i2, i1, new_direct_jump_p)\n \t  /* If *SPLIT is a paradoxical SUBREG, when we split it, it should\n \t     be written as a ZERO_EXTEND.  */\n \t  if (split_code == SUBREG && GET_CODE (SUBREG_REG (*split)) == MEM)\n-\t    SUBST (*split, gen_rtx_combine (ZERO_EXTEND, split_mode,\n-\t\t\t\t\t    XEXP (*split, 0)));\n+\t    SUBST (*split, gen_rtx_ZERO_EXTEND  (split_mode,\n+\t\t\t\t\t\t XEXP (*split, 0)));\n #endif\n \n-\t  newi2pat = gen_rtx_combine (SET, VOIDmode, newdest, *split);\n+\t  newi2pat = gen_rtx_SET (VOIDmode, newdest, *split);\n \t  SUBST (*split, newdest);\n \t  i2_code_number = recog_for_combine (&newi2pat, i2, &new_i2_notes);\n \n@@ -2834,7 +2819,7 @@ undo_all ()\n       undobuf.frees = undo;\n     }\n \n-  undobuf.undos = undobuf.previous_undos = 0;\n+  undobuf.undos = 0;\n \n   /* Clear this here, so that subsequent get_last_value calls are not\n      affected.  */\n@@ -2855,7 +2840,7 @@ undo_commit ()\n       undo->next = undobuf.frees;\n       undobuf.frees = undo;\n     }\n-  undobuf.undos = undobuf.previous_undos = 0;\n+  undobuf.undos = 0;\n }\n \n \f\n@@ -2899,9 +2884,9 @@ find_split_point (loc, insn)\n \t  || GET_CODE (XEXP (x, 0)) == SYMBOL_REF)\n \t{\n \t  SUBST (XEXP (x, 0),\n-\t\t gen_rtx_combine (LO_SUM, Pmode,\n-\t\t\t\t  gen_rtx_combine (HIGH, Pmode, XEXP (x, 0)),\n-\t\t\t\t  XEXP (x, 0)));\n+\t\t gen_rtx_LO_SUM (Pmode,\n+\t\t\t\t gen_rtx_HIGH (Pmode, XEXP (x, 0)),\n+\t\t\t\t XEXP (x, 0)));\n \t  return &XEXP (XEXP (x, 0), 0);\n \t}\n #endif\n@@ -3087,10 +3072,10 @@ find_split_point (loc, insn)\n \t      enum machine_mode mode = GET_MODE (XEXP (SET_SRC (x), 0));\n \n \t      SUBST (SET_SRC (x),\n-\t\t     gen_rtx_combine (NEG, mode,\n-\t\t\t\t      gen_rtx_combine (LSHIFTRT, mode,\n-\t\t\t\t\t\t       XEXP (SET_SRC (x), 0),\n-\t\t\t\t\t\t       GEN_INT (pos))));\n+\t\t     gen_rtx_NEG (mode,\n+\t\t\t\t  gen_rtx_LSHIFTRT (mode,\n+\t\t\t\t\t\t    XEXP (SET_SRC (x), 0),\n+\t\t\t\t\t\t    GEN_INT (pos))));\n \n \t      split = find_split_point (&SET_SRC (x), insn);\n \t      if (split && split != &SET_SRC (x))\n@@ -3145,12 +3130,11 @@ find_split_point (loc, insn)\n \t  if (unsignedp && len <= 8)\n \t    {\n \t      SUBST (SET_SRC (x),\n-\t\t     gen_rtx_combine\n-\t\t     (AND, mode,\n-\t\t      gen_rtx_combine (LSHIFTRT, mode,\n-\t\t\t\t       gen_lowpart_for_combine (mode, inner),\n-\t\t\t\t       GEN_INT (pos)),\n-\t\t      GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n+\t\t     gen_rtx_AND (mode,\n+\t\t\t\t  gen_rtx_LSHIFTRT\n+\t\t\t\t  (mode, gen_lowpart_for_combine (mode, inner),\n+\t\t\t\t   GEN_INT (pos)),\n+\t\t\t\t  GEN_INT (((HOST_WIDE_INT) 1 << len) - 1)));\n \n \t      split = find_split_point (&SET_SRC (x), insn);\n \t      if (split && split != &SET_SRC (x))\n@@ -3159,12 +3143,12 @@ find_split_point (loc, insn)\n \t  else\n \t    {\n \t      SUBST (SET_SRC (x),\n-\t\t     gen_rtx_combine\n+\t\t     gen_rtx_fmt_ee\n \t\t     (unsignedp ? LSHIFTRT : ASHIFTRT, mode,\n-\t\t      gen_rtx_combine (ASHIFT, mode,\n-\t\t\t\t       gen_lowpart_for_combine (mode, inner),\n-\t\t\t\t       GEN_INT (GET_MODE_BITSIZE (mode)\n-\t\t\t\t\t\t- len - pos)),\n+\t\t      gen_rtx_ASHIFT (mode,\n+\t\t\t\t      gen_lowpart_for_combine (mode, inner),\n+\t\t\t\t      GEN_INT (GET_MODE_BITSIZE (mode)\n+\t\t\t\t\t       - len - pos)),\n \t\t      GEN_INT (GET_MODE_BITSIZE (mode) - len)));\n \n \t      split = find_split_point (&SET_SRC (x), insn);\n@@ -3208,11 +3192,11 @@ find_split_point (loc, insn)\n       if (GET_CODE (XEXP (x, 0)) == NOT && GET_CODE (XEXP (x, 1)) == NOT)\n \t{\n \t  SUBST (*loc,\n-\t\t gen_rtx_combine (NOT, GET_MODE (x),\n-\t\t\t\t  gen_rtx_combine (code == IOR ? AND : IOR,\n-\t\t\t\t\t\t   GET_MODE (x),\n-\t\t\t\t\t\t   XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t\t   XEXP (XEXP (x, 1), 0))));\n+\t\t gen_rtx_NOT (GET_MODE (x),\n+\t\t\t      gen_rtx_fmt_ee (code == IOR ? AND : IOR,\n+\t\t\t\t\t      GET_MODE (x),\n+\t\t\t\t\t      XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t      XEXP (XEXP (x, 1), 0))));\n \t  return find_split_point (loc, insn);\n \t}\n \n@@ -3663,14 +3647,18 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t      else if (GET_CODE (true_rtx) == CONST_INT\n \t\t       && INTVAL (true_rtx) == - STORE_FLAG_VALUE\n \t\t       && false_rtx == const0_rtx)\n-\t\tx = gen_unary (NEG, mode, mode,\n-\t\t\t       gen_binary (cond_code, mode, cond, cop1));\n+\t\tx = simplify_gen_unary (NEG, mode,\n+\t\t\t\t\tgen_binary (cond_code, mode, cond,\n+\t\t\t\t\t\t    cop1),\n+\t\t\t\t\tmode);\n \t      else if (GET_CODE (false_rtx) == CONST_INT\n \t\t       && INTVAL (false_rtx) == - STORE_FLAG_VALUE\n \t\t       && true_rtx == const0_rtx)\n-\t\tx = gen_unary (NEG, mode, mode,\n-\t\t\t       gen_binary (reverse_condition (cond_code),\n-\t\t\t\t\t   mode, cond, cop1));\n+\t\tx = simplify_gen_unary (NEG, mode,\n+\t\t\t\t\tgen_binary (reverse_condition\n+\t\t\t\t\t\t    (cond_code),\n+\t\t\t\t\t\t    mode, cond, cop1),\n+\t\t\t\t\tmode);\n \t      else\n \t\treturn gen_rtx_IF_THEN_ELSE (mode,\n \t\t\t\t\t     gen_binary (cond_code, VOIDmode,\n@@ -3921,12 +3909,11 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n       /* (not (plus X -1)) can become (neg X).  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && XEXP (XEXP (x, 0), 1) == constm1_rtx)\n-\treturn gen_rtx_combine (NEG, mode, XEXP (XEXP (x, 0), 0));\n+\treturn gen_rtx_NEG (mode, XEXP (XEXP (x, 0), 0));\n \n       /* Similarly, (not (neg X)) is (plus X -1).  */\n       if (GET_CODE (XEXP (x, 0)) == NEG)\n-\treturn gen_rtx_combine (PLUS, mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\tconstm1_rtx);\n+\treturn gen_rtx_PLUS (mode, XEXP (XEXP (x, 0), 0), constm1_rtx);\n \n       /* (not (xor X C)) for C constant is (xor X D) with D = ~C.  */\n       if (GET_CODE (XEXP (x, 0)) == XOR\n@@ -3942,7 +3929,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t but this doesn't seem common enough to bother with.  */\n       if (GET_CODE (XEXP (x, 0)) == ASHIFT\n \t  && XEXP (XEXP (x, 0), 0) == const1_rtx)\n-\treturn gen_rtx_ROTATE (mode, gen_unary (NOT, mode, mode, const1_rtx),\n+\treturn gen_rtx_ROTATE (mode, simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t\t\t const1_rtx, mode),\n \t\t\t       XEXP (XEXP (x, 0), 1));\n \n       if (GET_CODE (XEXP (x, 0)) == SUBREG\n@@ -3955,8 +3943,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  enum machine_mode inner_mode = GET_MODE (SUBREG_REG (XEXP (x, 0)));\n \n \t  x = gen_rtx_ROTATE (inner_mode,\n-\t\t\t      gen_unary (NOT, inner_mode, inner_mode,\n-\t\t\t\t\t const1_rtx),\n+\t\t\t      simplify_gen_unary (NOT, inner_mode, const1_rtx,\n+\t\t\t\t\t\t  inner_mode),\n \t\t\t      XEXP (SUBREG_REG (XEXP (x, 0)), 1));\n \t  return gen_lowpart_for_combine (mode, x);\n \t}\n@@ -3978,7 +3966,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && XEXP (x, 1) == const1_rtx\n \t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT\n \t  && INTVAL (XEXP (XEXP (x, 0), 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\treturn gen_rtx_combine (GE, mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n+\treturn gen_rtx_GE (mode, XEXP (XEXP (x, 0), 0), const0_rtx);\n \n       /* Apply De Morgan's laws to reduce number of patterns for machines\n  \t with negating logical insns (and-not, nand, etc.).  If result has\n@@ -3991,29 +3979,29 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  enum machine_mode op_mode;\n \n \t  op_mode = GET_MODE (in1);\n-\t  in1 = gen_unary (NOT, op_mode, op_mode, in1);\n+\t  in1 = simplify_gen_unary (NOT, op_mode, in1, op_mode);\n \n \t  op_mode = GET_MODE (in2);\n \t  if (op_mode == VOIDmode)\n \t    op_mode = mode;\n-\t  in2 = gen_unary (NOT, op_mode, op_mode, in2);\n+\t  in2 = simplify_gen_unary (NOT, op_mode, in2, op_mode);\n \n \t  if (GET_CODE (in2) == NOT && GET_CODE (in1) != NOT)\n \t    {\n \t      rtx tem = in2;\n \t      in2 = in1; in1 = tem;\n \t    }\n \n-\t  return gen_rtx_combine (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n-\t\t\t\t  mode, in1, in2);\n+\t  return gen_rtx_fmt_ee (GET_CODE (XEXP (x, 0)) == IOR ? AND : IOR,\n+\t\t\t\t mode, in1, in2);\n \t}\n       break;\n \n     case NEG:\n       /* (neg (plus X 1)) can become (not X).  */\n       if (GET_CODE (XEXP (x, 0)) == PLUS\n \t  && XEXP (XEXP (x, 0), 1) == const1_rtx)\n-\treturn gen_rtx_combine (NOT, mode, XEXP (XEXP (x, 0), 0));\n+\treturn gen_rtx_NOT (mode, XEXP (XEXP (x, 0), 0));\n \n       /* Similarly, (neg (not X)) is (plus X 1).  */\n       if (GET_CODE (XEXP (x, 0)) == NOT)\n@@ -4115,8 +4103,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && (GET_CODE (XEXP (XEXP (x, 0), 0)) == SIGN_EXTEND\n \t      || GET_CODE (XEXP (XEXP (x, 0), 0)) == ZERO_EXTEND)\n \t  && GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == mode)\n-\treturn gen_unary (GET_CODE (XEXP (x, 0)), mode, mode,\n-\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 0));\n+\treturn simplify_gen_unary (GET_CODE (XEXP (x, 0)), mode,\n+\t\t\t\t   XEXP (XEXP (XEXP (x, 0), 0), 0), mode);\n \n       /* (truncate:SI (subreg:DI (truncate:SI X) 0)) is\n \t (truncate:SI x).  */\n@@ -4170,8 +4158,8 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t   || GET_CODE (XEXP (x, 0)) == NEG)\n \t  && GET_CODE (XEXP (XEXP (x, 0), 0)) == FLOAT_EXTEND\n \t  && GET_MODE (XEXP (XEXP (XEXP (x, 0), 0), 0)) == mode)\n-\treturn gen_unary (GET_CODE (XEXP (x, 0)), mode, mode,\n-\t\t\t  XEXP (XEXP (XEXP (x, 0), 0), 0));\n+\treturn simplify_gen_unary (GET_CODE (XEXP (x, 0)), mode,\n+\t\t\t\t   XEXP (XEXP (XEXP (x, 0), 0), 0), mode);\n \n       /* (float_truncate:SF (subreg:DF (float_truncate:SF X) 0))\n \t is (float_truncate:SF x).  */\n@@ -4266,7 +4254,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t\t\t\t      XEXP (XEXP (x, 0), 0),\n \t\t\t\t\t      XEXP (XEXP (x, 0), 1))))\n \treturn\n-\t  gen_unary (NEG, mode, mode, reversed);\n+\t  simplify_gen_unary (NEG, mode, reversed, mode);\n \n       /* If only the low-order bit of X is possibly nonzero, (plus x -1)\n \t can become (ashiftrt (ashift (xor x 1) C) C) where C is\n@@ -4279,8 +4267,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t  && nonzero_bits (XEXP (x, 0), mode) == 1)\n \treturn simplify_shift_const (NULL_RTX, ASHIFTRT, mode,\n \t   simplify_shift_const (NULL_RTX, ASHIFT, mode,\n-\t\t\t\t gen_rtx_combine (XOR, mode,\n-\t\t\t\t\t\t  XEXP (x, 0), const1_rtx),\n+\t\t\t\t gen_rtx_XOR (mode, XEXP (x, 0), const1_rtx),\n \t\t\t\t GET_MODE_BITSIZE (mode) - 1),\n \t   GET_MODE_BITSIZE (mode) - 1);\n \n@@ -4421,8 +4408,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return gen_unary (NEG, mode, mode,\n-\t\t\t\tgen_lowpart_for_combine (mode, op0));\n+\t      return simplify_gen_unary (NEG, mode,\n+\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t mode);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == 1\n@@ -4465,8 +4453,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t   && nonzero_bits (op0, mode) == 1)\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return gen_unary (NEG, mode, mode,\n-\t\t\t\tgen_lowpart_for_combine (mode, op0));\n+\t      return simplify_gen_unary (NEG, mode,\n+\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t mode);\n \t    }\n \n \t  else if (STORE_FLAG_VALUE == -1\n@@ -4477,8 +4466,9 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \t\t       == GET_MODE_BITSIZE (mode)))\n \t    {\n \t      op0 = expand_compound_operation (op0);\n-\t      return gen_unary (NOT, mode, mode,\n-\t\t\t\tgen_lowpart_for_combine (mode, op0));\n+\t      return simplify_gen_unary (NOT, mode,\n+\t\t\t\t\t gen_lowpart_for_combine (mode, op0),\n+\t\t\t\t\t mode);\n \t    }\n \n \t  /* If X is 0/1, (eq X 0) is X-1.  */\n@@ -4516,7 +4506,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n \t  /* If the code changed, return a whole new comparison.  */\n \t  if (new_code != code)\n-\t    return gen_rtx_combine (new_code, mode, op0, op1);\n+\t    return gen_rtx_fmt_ee (new_code, mode, op0, op1);\n \n \t  /* Otherwise, keep this operation, but maybe change its operands.\n \t     This also converts (ne (compare FOO BAR) 0) to (ne FOO BAR).  */\n@@ -4568,7 +4558,7 @@ combine_simplify_rtx (x, op0_mode, last, in_dest)\n \n       /* If operand is known to be only -1 or 0, convert ABS to NEG.  */\n       if (num_sign_bit_copies (XEXP (x, 0), mode) == GET_MODE_BITSIZE (mode))\n-\treturn gen_rtx_combine (NEG, mode, XEXP (x, 0));\n+\treturn gen_rtx_NEG (mode, XEXP (x, 0));\n \n       break;\n \n@@ -4802,11 +4792,13 @@ simplify_if_then_else (x)\n       {\n       case GT:\n       case GE:\n-\treturn gen_unary (ABS, mode, mode, true_rtx);\n+\treturn simplify_gen_unary (ABS, mode, true_rtx, mode);\n       case LT:\n       case LE:\n-\treturn gen_unary (NEG, mode, mode,\n-\t\t\t  gen_unary (ABS, mode, mode, true_rtx));\n+\treturn\n+\t  simplify_gen_unary (NEG, mode,\n+\t\t\t      simplify_gen_unary (ABS, mode, true_rtx, mode),\n+\t\t\t      mode);\n     default:\n       break;\n       }\n@@ -4948,7 +4940,7 @@ simplify_if_then_else (x)\n \t  temp = gen_binary (op, m, gen_lowpart_for_combine (m, z), temp);\n \n \t  if (extend_op != NIL)\n-\t    temp = gen_unary (extend_op, mode, m, temp);\n+\t    temp = simplify_gen_unary (extend_op, mode, temp, m);\n \n \t  return temp;\n \t}\n@@ -5065,8 +5057,8 @@ simplify_set (x)\n \t{\n \t  unsigned HOST_WIDE_INT mask;\n \n-\t  SUBST (*cc_use, gen_rtx_combine (new_code, GET_MODE (*cc_use),\n-\t\t\t\t\t   dest, const0_rtx));\n+\t  SUBST (*cc_use, gen_rtx_fmt_ee (new_code, GET_MODE (*cc_use),\n+\t\t\t\t\t  dest, const0_rtx));\n \n \t  /* If the only change we made was to change an EQ into an NE or\n \t     vice versa, OP0 has only one bit that might be nonzero, and OP1\n@@ -5113,8 +5105,7 @@ simplify_set (x)\n \t correct mode, we need one.  */\n       if (GET_CODE (src) != COMPARE || GET_MODE (src) != compare_mode)\n \t{\n-\t  SUBST (SET_SRC (x),\n-\t\t gen_rtx_combine (COMPARE, compare_mode, op0, op1));\n+\t  SUBST (SET_SRC (x), gen_rtx_COMPARE (compare_mode, op0, op1));\n \t  src = SET_SRC (x);\n \t}\n       else\n@@ -5187,8 +5178,8 @@ simplify_set (x)\n       && GET_CODE (SUBREG_REG (src)) == MEM)\n     {\n       SUBST (SET_SRC (x),\n-\t     gen_rtx_combine (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))),\n-\t\t\t      GET_MODE (src), XEXP (src, 0)));\n+\t     gen_rtx (LOAD_EXTEND_OP (GET_MODE (SUBREG_REG (src))),\n+\t\t      GET_MODE (src), XEXP (src, 0)));\n \n       src = SET_SRC (x);\n     }\n@@ -5236,8 +5227,9 @@ simplify_set (x)\n       term2 = gen_binary (AND, GET_MODE (src),\n \t\t\t  XEXP (XEXP (src, 0), 0), true_rtx);\n       term3 = gen_binary (AND, GET_MODE (src),\n-\t\t\t  gen_unary (NOT, GET_MODE (src), GET_MODE (src),\n-\t\t\t\t     XEXP (XEXP (src, 0), 0)),\n+\t\t\t  simplify_gen_unary (NOT, GET_MODE (src),\n+\t\t\t\t\t      XEXP (XEXP (src, 0), 0),\n+\t\t\t\t\t      GET_MODE (src)),\n \t\t\t  false_rtx);\n \n       SUBST (SET_SRC (x),\n@@ -5281,13 +5273,15 @@ simplify_logical (x, last)\n \t  && rtx_equal_p (XEXP (op0, 0), op1)\n \t  && ! side_effects_p (op1))\n \tx = gen_binary (AND, mode,\n-\t\t\tgen_unary (NOT, mode, mode, XEXP (op0, 1)), op1);\n+\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n+\t\t\top1);\n \n       if (GET_CODE (op0) == XOR\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n \tx = gen_binary (AND, mode,\n-\t\t\tgen_unary (NOT, mode, mode, XEXP (op0, 0)), op1);\n+\t\t\tsimplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n+\t\t\top1);\n \n       /* Similarly for (~(A ^ B)) & A.  */\n       if (GET_CODE (op0) == NOT\n@@ -5496,7 +5490,9 @@ simplify_logical (x, last)\n \t    SUBST (XEXP (x, 1), op1);\n \t  }\n \telse if (num_negated == 1)\n-\t  return gen_unary (NOT, mode, mode, gen_binary (XOR, mode, op0, op1));\n+\t  return\n+\t    simplify_gen_unary (NOT, mode, gen_binary (XOR, mode, op0, op1),\n+\t\t\t\tmode);\n       }\n \n       /* Convert (xor (and A B) B) to (and (not A) B).  The latter may\n@@ -5507,14 +5503,14 @@ simplify_logical (x, last)\n \t  && rtx_equal_p (XEXP (op0, 1), op1)\n \t  && ! side_effects_p (op1))\n \treturn gen_binary (AND, mode,\n-\t\t\t   gen_unary (NOT, mode, mode, XEXP (op0, 0)),\n+\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 0), mode),\n \t\t\t   op1);\n \n       else if (GET_CODE (op0) == AND\n \t       && rtx_equal_p (XEXP (op0, 0), op1)\n \t       && ! side_effects_p (op1))\n \treturn gen_binary (AND, mode,\n-\t\t\t   gen_unary (NOT, mode, mode, XEXP (op0, 1)),\n+\t\t\t   simplify_gen_unary (NOT, mode, XEXP (op0, 1), mode),\n \t\t\t   op1);\n \n       /* (xor (comparison foo bar) (const_int 1)) can become the reversed\n@@ -5535,7 +5531,7 @@ simplify_logical (x, last)\n \t  && GET_CODE (op0) == LSHIFTRT\n \t  && GET_CODE (XEXP (op0, 1)) == CONST_INT\n \t  && INTVAL (XEXP (op0, 1)) == GET_MODE_BITSIZE (mode) - 1)\n-\treturn gen_rtx_combine (GE, mode, XEXP (op0, 0), const0_rtx);\n+\treturn gen_rtx_GE (mode, XEXP (op0, 0), const0_rtx);\n \n       /* (xor (comparison foo bar) (const_int sign-bit))\n \t when STORE_FLAG_VALUE is the sign bit.  */\n@@ -5866,11 +5862,11 @@ expand_field_assignment (x)\n \t(VOIDmode, copy_rtx (inner),\n \t gen_binary (IOR, compute_mode,\n \t\t     gen_binary (AND, compute_mode,\n-\t\t\t\t gen_unary (NOT, compute_mode,\n-\t\t\t\t\t    compute_mode,\n-\t\t\t\t\t    gen_binary (ASHIFT,\n-\t\t\t\t\t\t\tcompute_mode,\n-\t\t\t\t\t\t\tmask, pos)),\n+\t\t\t\t simplify_gen_unary (NOT, compute_mode,\n+\t\t\t\t\t\t     gen_binary (ASHIFT,\n+\t\t\t\t\t\t\t\t compute_mode,\n+\t\t\t\t\t\t\t\t mask, pos),\n+\t\t\t\t\t\t     compute_mode),\n \t\t\t\t inner),\n \t\t     gen_binary (ASHIFT, compute_mode,\n \t\t\t\t gen_binary (AND, compute_mode,\n@@ -6041,7 +6037,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \treturn (GET_CODE (new) == MEM ? new\n \t\t: (GET_CODE (new) != SUBREG\n \t\t   ? gen_rtx_CLOBBER (tmode, const0_rtx)\n-\t\t   : gen_rtx_combine (STRICT_LOW_PART, VOIDmode, new)));\n+\t\t   : gen_rtx_STRICT_LOW_PART (VOIDmode, new)));\n \n       if (mode == tmode)\n \treturn new;\n@@ -6070,8 +6066,8 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n       /* Otherwise, sign- or zero-extend unless we already are in the\n \t proper mode.  */\n \n-      return (gen_rtx_combine (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n-\t\t\t       mode, new));\n+      return (gen_rtx_fmt_e (unsignedp ? ZERO_EXTEND : SIGN_EXTEND,\n+\t\t\t     mode, new));\n     }\n \n   /* Unless this is a COMPARE or we have a funny memory reference,\n@@ -6186,8 +6182,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n \tpos = width - len - pos;\n       else\n \tpos_rtx\n-\t  = gen_rtx_combine (MINUS, GET_MODE (pos_rtx),\n-\t\t\t     GEN_INT (width - len), pos_rtx);\n+\t  = gen_rtx_MINUS (GET_MODE (pos_rtx), GEN_INT (width - len), pos_rtx);\n       /* POS may be less than 0 now, but we check for that below.\n \t Note that it can only be less than 0 if GET_CODE (inner) != MEM.  */\n     }\n@@ -6262,7 +6257,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n   if (pos_rtx != 0\n       && GET_MODE_SIZE (pos_mode) > GET_MODE_SIZE (GET_MODE (pos_rtx)))\n     {\n-      rtx temp = gen_rtx_combine (ZERO_EXTEND, pos_mode, pos_rtx);\n+      rtx temp = gen_rtx_ZERO_EXTEND (pos_mode, pos_rtx);\n \n       /* If we know that no extraneous bits are set, and that the high\n \t bit is not set, convert extraction to cheaper one - eighter\n@@ -6299,7 +6294,7 @@ make_extraction (mode, inner, pos, pos_rtx, len,\n     pos_rtx = GEN_INT (pos);\n \n   /* Make the required operation.  See if we can use existing rtx.  */\n-  new = gen_rtx_combine (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n+  new = gen_rtx_fmt_eee (unsignedp ? ZERO_EXTRACT : SIGN_EXTRACT,\n \t\t\t extraction_mode, inner, GEN_INT (len), pos_rtx);\n   if (! in_dest)\n     new = gen_lowpart_for_combine (mode, new);\n@@ -6333,7 +6328,7 @@ extract_left_shift (x, count)\n \n     case NEG:  case NOT:\n       if ((tem = extract_left_shift (XEXP (x, 0), count)) != 0)\n-\treturn gen_unary (code, mode, mode, tem);\n+\treturn simplify_gen_unary (code, mode, tem, mode);\n \n       break;\n \n@@ -6410,9 +6405,9 @@ make_compound_operation (x, in_code)\n \t  && INTVAL (XEXP (x, 1)) >= 0)\n \t{\n \t  new = make_compound_operation (XEXP (x, 0), next_code);\n-\t  new = gen_rtx_combine (MULT, mode, new,\n-\t\t\t\t GEN_INT ((HOST_WIDE_INT) 1\n-\t\t\t\t\t  << INTVAL (XEXP (x, 1))));\n+\t  new = gen_rtx_MULT (mode, new,\n+\t\t\t      GEN_INT ((HOST_WIDE_INT) 1\n+\t\t\t\t       << INTVAL (XEXP (x, 1))));\n \t}\n       break;\n \n@@ -6452,11 +6447,11 @@ make_compound_operation (x, in_code)\n \t       && (i = exact_log2 (INTVAL (XEXP (x, 1)) + 1)) >= 0)\n \t{\n \t  /* Apply the distributive law, and then try to make extractions.  */\n-\t  new = gen_rtx_combine (GET_CODE (XEXP (x, 0)), mode,\n-\t\t\t\t gen_rtx_AND (mode, XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t      XEXP (x, 1)),\n-\t\t\t\t gen_rtx_AND (mode, XEXP (XEXP (x, 0), 1),\n-\t\t\t\t\t      XEXP (x, 1)));\n+\t  new = gen_rtx_fmt_ee (GET_CODE (XEXP (x, 0)), mode,\n+\t\t\t\tgen_rtx_AND (mode, XEXP (XEXP (x, 0), 0),\n+\t\t\t\t\t     XEXP (x, 1)),\n+\t\t\t\tgen_rtx_AND (mode, XEXP (XEXP (x, 0), 1),\n+\t\t\t\t\t     XEXP (x, 1)));\n \t  new = make_compound_operation (new, in_code);\n \t}\n \n@@ -6492,10 +6487,10 @@ make_compound_operation (x, in_code)\n \t  mask >>= INTVAL (XEXP (XEXP (x, 0), 1));\n \t  if ((INTVAL (XEXP (x, 1)) & ~mask) == 0)\n \t    SUBST (XEXP (x, 0),\n-\t\t   gen_rtx_combine (ASHIFTRT, mode,\n-\t\t\t\t    make_compound_operation (XEXP (XEXP (x, 0), 0),\n-\t\t\t\t\t\t\t     next_code),\n-\t\t\t\t    XEXP (XEXP (x, 0), 1)));\n+\t\t   gen_rtx_ASHIFTRT (mode,\n+\t\t\t\t     make_compound_operation\n+\t\t\t\t     (XEXP (XEXP (x, 0), 0), next_code),\n+\t\t\t\t     XEXP (XEXP (x, 0), 1)));\n \t}\n \n       /* If the constant is one less than a power of two, this might be\n@@ -6527,10 +6522,10 @@ make_compound_operation (x, in_code)\n \t  && mode_width <= HOST_BITS_PER_WIDE_INT\n \t  && (nonzero_bits (XEXP (x, 0), mode) & (1 << (mode_width - 1))) == 0)\n \t{\n-\t  new = gen_rtx_combine (ASHIFTRT, mode,\n-\t\t\t\t make_compound_operation (XEXP (x, 0),\n-\t\t\t\t\t\t\t  next_code),\n-\t\t\t\t XEXP (x, 1));\n+\t  new = gen_rtx_ASHIFTRT (mode,\n+\t\t\t\t  make_compound_operation (XEXP (x, 0),\n+\t\t\t\t\t\t\t   next_code),\n+\t\t\t\t  XEXP (x, 1));\n \t  break;\n \t}\n \n@@ -6604,7 +6599,7 @@ make_compound_operation (x, in_code)\n \t  if (GET_MODE_SIZE (mode) > GET_MODE_SIZE (GET_MODE (tem))\n \t      || (GET_MODE_SIZE (mode) >\n \t\t  GET_MODE_SIZE (GET_MODE (XEXP (tem, 0)))))\n-\t    tem = gen_rtx_combine (GET_CODE (tem), mode, XEXP (tem, 0));\n+\t    tem = gen_rtx_fmt_e (GET_CODE (tem), mode, XEXP (tem, 0));\n \t  else\n \t    tem = gen_lowpart_for_combine (mode, XEXP (tem, 0));\n \t  return tem;\n@@ -6922,7 +6917,8 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\t\t& -INTVAL (XEXP (x, 0))))\n \t      > mask))\n \t{\n-\t  x = gen_unary (NEG, GET_MODE (x), GET_MODE (x), XEXP (x, 1));\n+\t  x = simplify_gen_unary (NEG, GET_MODE (x), XEXP (x, 1),\n+\t\t\t\t  GET_MODE (x));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n@@ -6932,7 +6928,8 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t  && ((INTVAL (XEXP (x, 0)) | (HOST_WIDE_INT) mask)\n \t      == INTVAL (XEXP (x, 0))))\n \t{\n-\t  x = gen_unary (NOT, GET_MODE (x), GET_MODE (x), XEXP (x, 1));\n+\t  x = simplify_gen_unary (NOT, GET_MODE (x),\n+\t\t\t\t  XEXP (x, 1), GET_MODE (x));\n \t  return force_to_mode (x, mode, mask, reg, next_select);\n \t}\n \n@@ -7217,7 +7214,7 @@ force_to_mode (x, mode, mask, reg, just_select)\n \t\t\t\t     force_to_mode (XEXP (x, 0), mode, mask,\n \t\t\t\t\t\t    reg, next_select));\n       if (op_mode != GET_MODE (x) || op0 != XEXP (x, 0))\n-\tx = gen_unary (code, op_mode, op_mode, op0);\n+\tx = simplify_gen_unary (code, op_mode, op0, op_mode);\n       break;\n \n     case NE:\n@@ -7284,8 +7281,9 @@ if_then_else_cond (x, ptrue, pfalse)\n   else if (GET_RTX_CLASS (code) == '1'\n \t   && (cond0 = if_then_else_cond (XEXP (x, 0), &true0, &false0)) != 0)\n     {\n-      *ptrue = gen_unary (code, mode, GET_MODE (XEXP (x, 0)), true0);\n-      *pfalse = gen_unary (code, mode, GET_MODE (XEXP (x, 0)), false0);\n+      *ptrue = simplify_gen_unary (code, mode, true0, GET_MODE (XEXP (x, 0)));\n+      *pfalse = simplify_gen_unary (code, mode, false0,\n+\t\t\t\t    GET_MODE (XEXP (x, 0)));\n       return cond0;\n     }\n \n@@ -7348,7 +7346,9 @@ if_then_else_cond (x, ptrue, pfalse)\n \t      *ptrue = gen_binary (MULT, mode, op0, const_true_rtx);\n \t      *pfalse = gen_binary (MULT, mode,\n \t\t\t\t    (code == MINUS\n-\t\t\t\t     ? gen_unary (NEG, mode, mode, op1) : op1),\n+\t\t\t\t     ? simplify_gen_unary (NEG, mode, op1,\n+\t\t\t\t\t\t\t   mode)\n+\t\t\t\t     : op1),\n \t\t\t\t    const_true_rtx);\n \t      return cond0;\n \t    }\n@@ -7498,8 +7498,9 @@ known_cond (x, cond, reg, val)\n       case GE:  case GT:  case EQ:\n \treturn XEXP (x, 0);\n       case LT:  case LE:\n-\treturn gen_unary (NEG, GET_MODE (XEXP (x, 0)), GET_MODE (XEXP (x, 0)),\n-\t\t\t  XEXP (x, 0));\n+\treturn simplify_gen_unary (NEG, GET_MODE (XEXP (x, 0)),\n+\t\t\t\t   XEXP (x, 0),\n+\t\t\t\t   GET_MODE (XEXP (x, 0)));\n       default:\n \tbreak;\n       }\n@@ -7723,7 +7724,7 @@ make_field_assignment (x)\n \t\t       : ((unsigned HOST_WIDE_INT) 1 << len) - 1,\n \t\t       dest, 0);\n \n-  return gen_rtx_combine (SET, VOIDmode, assign, src);\n+  return gen_rtx_SET (VOIDmode, assign, src);\n }\n \f\n /* See if X is of the form (+ (* a c) (* b c)) and convert to (* (+ a b) c)\n@@ -7840,7 +7841,7 @@ apply_distributive_law (x)\n   if (code == XOR && inner_code == IOR)\n     {\n       inner_code = AND;\n-      other = gen_unary (NOT, GET_MODE (x), GET_MODE (x), other);\n+      other = simplify_gen_unary (NOT, GET_MODE (x), other, GET_MODE (x));\n     }\n \n   /* We may be able to continuing distributing the result, so call\n@@ -9087,8 +9088,8 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t\t\t\t\t  count / BITS_PER_UNIT));\n \n \t      MEM_COPY_ATTRIBUTES (new, varop);\n-\t      varop = gen_rtx_combine (code == ASHIFTRT ? SIGN_EXTEND\n-\t\t\t\t       : ZERO_EXTEND, mode, new);\n+\t      varop = gen_rtx_fmt_e (code == ASHIFTRT ? SIGN_EXTEND\n+\t\t\t\t     : ZERO_EXTEND, mode, new);\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -9114,8 +9115,8 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t\t\t\tcount / BITS_PER_UNIT));\n \t\t}\n \n-\t      varop = gen_rtx_combine (code == ASHIFTRT ? SIGN_EXTEND\n-\t\t\t\t       : ZERO_EXTEND, mode, new);\n+\t      varop = gen_rtx_fmt_e (code == ASHIFTRT ? SIGN_EXTEND\n+\t\t\t\t     : ZERO_EXTEND, mode, new);\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -9336,16 +9337,16 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t\t\t\t\t\t\t XEXP (varop, 0),\n \t\t\t\t\t\t\t GEN_INT (count))))\n \t    {\n-\t      varop = gen_rtx_combine (code, mode, new, XEXP (varop, 1));\n+\t      varop = gen_rtx_fmt_ee (code, mode, new, XEXP (varop, 1));\n \t      count = 0;\n \t      continue;\n \t    }\n \t  break;\n \n \tcase NOT:\n \t  /* Make this fit the case below.  */\n-\t  varop = gen_rtx_combine (XOR, mode, XEXP (varop, 0),\n-\t\t\t\t   GEN_INT (GET_MODE_MASK (mode)));\n+\t  varop = gen_rtx_XOR (mode, XEXP (varop, 0),\n+\t\t\t       GEN_INT (GET_MODE_MASK (mode)));\n \t  continue;\n \n \tcase IOR:\n@@ -9366,11 +9367,11 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      && rtx_equal_p (XEXP (XEXP (varop, 0), 0), XEXP (varop, 1)))\n \t    {\n \t      count = 0;\n-\t      varop = gen_rtx_combine (LE, GET_MODE (varop), XEXP (varop, 1),\n-\t\t\t\t       const0_rtx);\n+\t      varop = gen_rtx_LE (GET_MODE (varop), XEXP (varop, 1),\n+\t\t\t\t  const0_rtx);\n \n \t      if (STORE_FLAG_VALUE == 1 ? code == ASHIFTRT : code == LSHIFTRT)\n-\t\tvarop = gen_rtx_combine (NEG, GET_MODE (varop), varop);\n+\t\tvarop = gen_rtx_NEG (GET_MODE (varop), varop);\n \n \t      continue;\n \t    }\n@@ -9532,11 +9533,11 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      && rtx_equal_p (XEXP (XEXP (varop, 0), 0), XEXP (varop, 1)))\n \t    {\n \t      count = 0;\n-\t      varop = gen_rtx_combine (GT, GET_MODE (varop), XEXP (varop, 1),\n-\t\t\t\t       const0_rtx);\n+\t      varop = gen_rtx_GT (GET_MODE (varop), XEXP (varop, 1),\n+\t\t\t\t  const0_rtx);\n \n \t      if (STORE_FLAG_VALUE == 1 ? code == ASHIFTRT : code == LSHIFTRT)\n-\t\tvarop = gen_rtx_combine (NEG, GET_MODE (varop), varop);\n+\t\tvarop = gen_rtx_NEG (GET_MODE (varop), varop);\n \n \t      continue;\n \t    }\n@@ -9555,12 +9556,11 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t      rtx varop_inner = XEXP (varop, 0);\n \n \t      varop_inner\n-\t\t= gen_rtx_combine (LSHIFTRT, GET_MODE (varop_inner),\n-\t\t\t\t   XEXP (varop_inner, 0),\n-\t\t\t\t   GEN_INT (count\n-\t\t\t\t\t    + INTVAL (XEXP (varop_inner, 1))));\n-\t      varop = gen_rtx_combine (TRUNCATE, GET_MODE (varop),\n-\t\t\t\t       varop_inner);\n+\t\t= gen_rtx_LSHIFTRT (GET_MODE (varop_inner),\n+\t\t\t\t    XEXP (varop_inner, 0),\n+\t\t\t\t    GEN_INT\n+\t\t\t\t    (count + INTVAL (XEXP (varop_inner, 1))));\n+\t      varop = gen_rtx_TRUNCATE (GET_MODE (varop), varop_inner);\n \t      count = 0;\n \t      continue;\n \t    }\n@@ -9615,7 +9615,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n   else\n     {\n       if (x == 0 || GET_CODE (x) != code || GET_MODE (x) != shift_mode)\n-\tx = gen_rtx_combine (code, shift_mode, varop, const_rtx);\n+\tx = gen_rtx_fmt_ee (code, shift_mode, varop, const_rtx);\n \n       SUBST (XEXP (x, 0), varop);\n       SUBST (XEXP (x, 1), const_rtx);\n@@ -9643,7 +9643,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n   /* If COMPLEMENT_P is set, we have to complement X before doing the outer\n      operation.  */\n   if (complement_p)\n-    x = gen_unary (NOT, result_mode, result_mode, x);\n+    x =simplify_gen_unary (NOT, result_mode, x, result_mode);\n \n   if (outer_op != NIL)\n     {\n@@ -9657,7 +9657,7 @@ simplify_shift_const (x, code, result_mode, varop, input_count)\n \t   equivalent to a constant.  This should be rare.  */\n \tx = GEN_INT (outer_const);\n       else if (GET_RTX_CLASS (outer_op) == '1')\n-\tx = gen_unary (outer_op, result_mode, result_mode, x);\n+\tx = simplify_gen_unary (outer_op, result_mode, x, result_mode);\n       else\n \tx = gen_binary (outer_op, result_mode, x, GEN_INT (outer_const));\n     }\n@@ -9861,7 +9861,7 @@ gen_lowpart_for_combine (mode, x)\n   /* If X is a comparison operator, rewrite it in a new mode.  This\n      probably won't match, but may allow further simplifications.  */\n   else if (GET_RTX_CLASS (GET_CODE (x)) == '<')\n-    return gen_rtx_combine (GET_CODE (x), mode, XEXP (x, 0), XEXP (x, 1));\n+    return gen_rtx_fmt_ee (GET_CODE (x), mode, XEXP (x, 0), XEXP (x, 1));\n \n   /* If we couldn't simplify X any other way, just enclose it in a\n      SUBREG.  Normally, this SUBREG won't match, but some patterns may\n@@ -9878,67 +9878,6 @@ gen_lowpart_for_combine (mode, x)\n     }\n }\n \f\n-/* Make an rtx expression.  This is a subset of gen_rtx and only supports\n-   expressions of 1, 2, or 3 operands, each of which are rtx expressions.\n-\n-   If the identical expression was previously in the insn (in the undobuf),\n-   it will be returned.  Only if it is not found will a new expression\n-   be made.  */\n-\n-/*VARARGS2*/\n-static rtx\n-gen_rtx_combine VPARAMS ((enum rtx_code code, enum machine_mode mode, ...))\n-{\n-#ifndef ANSI_PROTOTYPES\n-  enum rtx_code code;\n-  enum machine_mode mode;\n-#endif\n-  va_list p;\n-  int n_args;\n-  rtx args[3];\n-  int j;\n-  const char *fmt;\n-  rtx rt;\n-  struct undo *undo;\n-\n-  VA_START (p, mode);\n-\n-#ifndef ANSI_PROTOTYPES\n-  code = va_arg (p, enum rtx_code);\n-  mode = va_arg (p, enum machine_mode);\n-#endif\n-\n-  n_args = GET_RTX_LENGTH (code);\n-  fmt = GET_RTX_FORMAT (code);\n-\n-  if (n_args == 0 || n_args > 3)\n-    abort ();\n-\n-  /* Get each arg and verify that it is supposed to be an expression.  */\n-  for (j = 0; j < n_args; j++)\n-    {\n-      if (*fmt++ != 'e')\n-\tabort ();\n-\n-      args[j] = va_arg (p, rtx);\n-    }\n-\n-  va_end (p);\n-\n-  /* Otherwise make a new rtx.  We know we have 1, 2, or 3 args.\n-     Use rtx_alloc instead of gen_rtx because it's faster on RISC.  */\n-  rt = rtx_alloc (code);\n-  PUT_MODE (rt, mode);\n-  XEXP (rt, 0) = args[0];\n-  if (n_args > 1)\n-    {\n-      XEXP (rt, 1) = args[1];\n-      if (n_args > 2)\n-\tXEXP (rt, 2) = args[2];\n-    }\n-  return rt;\n-}\n-\n /* These routines make binary and unary operations by first seeing if they\n    fold; if not, a new expression is allocated.  */\n \n@@ -9987,7 +9926,7 @@ gen_binary (code, mode, op0, op1)\n \t  || (GET_CODE (op0) == SUBREG\n \t      && GET_RTX_CLASS (GET_CODE (SUBREG_REG (op0))) == 'o'\n \t      && GET_RTX_CLASS (GET_CODE (op1)) != 'o')))\n-    return gen_rtx_combine (code, mode, op1, op0);\n+    return gen_rtx_fmt_ee (code, mode, op1, op0);\n \n   /* If we are turning off bits already known off in OP0, we need not do\n      an AND.  */\n@@ -9996,21 +9935,7 @@ gen_binary (code, mode, op0, op1)\n \t   && (nonzero_bits (op0, mode) & ~INTVAL (op1)) == 0)\n     return op0;\n \n-  return gen_rtx_combine (code, mode, op0, op1);\n-}\n-\n-static rtx\n-gen_unary (code, mode, op0_mode, op0)\n-     enum rtx_code code;\n-     enum machine_mode mode, op0_mode;\n-     rtx op0;\n-{\n-  rtx result = simplify_unary_operation (code, mode, op0, op0_mode);\n-\n-  if (result)\n-    return result;\n-\n-  return gen_rtx_combine (code, mode, op0);\n+  return gen_rtx_fmt_ee (code, mode, op0, op1);\n }\n \f\n /* Simplify a comparison between *POP0 and *POP1 where CODE is the\n@@ -10754,9 +10679,9 @@ simplify_comparison (code, pop0, pop1)\n \t      && XEXP (XEXP (op0, 0), 0) == const1_rtx)\n \t    {\n \t      op0 = simplify_and_const_int\n-\t\t(op0, mode, gen_rtx_combine (LSHIFTRT, mode,\n-\t\t\t\t\t     XEXP (op0, 1),\n-\t\t\t\t\t     XEXP (XEXP (op0, 0), 1)),\n+\t\t(op0, mode, gen_rtx_LSHIFTRT (mode,\n+\t\t\t\t\t      XEXP (op0, 1),\n+\t\t\t\t\t      XEXP (XEXP (op0, 0), 1)),\n \t\t (HOST_WIDE_INT) 1);\n \t      continue;\n \t    }\n@@ -10869,9 +10794,9 @@ simplify_comparison (code, pop0, pop1)\n \t      && GET_CODE (XEXP (XEXP (op0, 0), 0)) == NOT)\n \t    {\n \t      op0 = simplify_and_const_int\n-\t\t(op0, mode, gen_rtx_combine (LSHIFTRT, mode,\n-\t\t\t\t\t     XEXP (XEXP (XEXP (op0, 0), 0), 0),\n-\t\t\t\t\t     XEXP (XEXP (op0, 0), 1)),\n+\t\t(op0, mode,\n+\t\t gen_rtx_LSHIFTRT (mode, XEXP (XEXP (XEXP (op0, 0), 0), 0),\n+\t\t\t\t   XEXP (XEXP (op0, 0), 1)),\n \t\t (HOST_WIDE_INT) 1);\n \t      code = (code == NE ? EQ : NE);\n \t      continue;"}]}