{"sha": "e1467ff26b70f3475d37606d391e3b458dec4798", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTE0NjdmZjI2YjcwZjM0NzVkMzc2MDZkMzkxZTNiNDU4ZGVjNDc5OA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mmitchell@usa.net", "date": "1998-01-27T20:47:56Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1998-01-27T20:47:56Z"}, "message": "call.c (add_template_candidate_real): New function.\n\n\t* call.c (add_template_candidate_real): New function.\n\t(add_template_candidate): Use it.\n\t(add_template_conv_candidate): Likewise.\n\t(joust): Pass extra argument to more_specialized.\n\t* class.c (instantiate_type): Handle a single FUNCTION_DECL.\n\t(is_local_class): Remove.\n\t(finish_struct): Check TI_PENDING_SPECIALIZATION_FLAG.\n\t* cp-tree.h (is_local_class): Remove.\n\t(perform_array_to_pointer_conversion): Likewise.\n\t(finish_member_template_decl): Add.\n\t(check_explicit_specialization): Return a tree, not an int.\n\t(more_specialized): Take additional argument.\n\t(get_bindings): Likewise.\n\t(TI_PENDING_SPECIALIZATION_FLAG): New macro.\n\t* cvt.c (perform_qualification_conversions): Use comp_ptr_ttypes.\n\t(perform_array_to_pointer_conversion): Remove.\n\t* decl.c (saved_scope): Add processing_specialization,\n\tprocessing_explicit_instantiation fields.\n\t(maybe_push_to_top_level): Save them.\n\t(pop_from_top_level): Restore them.\n\t(grokfndecl): Use new return value from\n\tcheck_explicit_specialization.\n\t(start_decl): Don't check flag_guiding_decls before pushing\n\tdecls.\n\t(cp_finish_decl): Remove previous (bogus) change.\n\t(grok_declarator): Use decl_function_context rather than\n\tis_local_class.\n\t* decl2.c (finish_file): Pass extra argument to get_bindings.\n\t(build_expr_from_tree): Let build_x_component_ref check\n\tvalidity of arguments rather than doing it here.\n\t* lex.c (cons_up_default_function): Remove code fooling with\n\tprocessing_specialization, processing_explicit_instantiation\n\tflags, as that is now done in {maybe_push_top,pop_from}_top_level.\n\t* method.c (build_overload_identifier): Mangle local classes in\n\ttemplate functions correctly.\n\t* parse.y (finish_member_template_decl): Move to pt.c.\n\t* pt.c (finish_member_template_decl): Moved here from parse.y.\n\t(print_candidates): New function.\n\t(determine_specialization): Change interface.  Properly look for\n\tmost specialized versions of template candidates.\n\t(check_explicit_specialization): Fully process explicit\n\tinstantiations.\n\t(push_template_decl): Avoid looking at CLASSTYPE fields in\n\tFUNCTION_DECLS.\n\t(determine_overloaded_function): Remove.\n\t(convert_nontype_argument): Change name from\n\tconvert_nontype_parameter.  Use determine_overloaded_function\n\tinstead of instantiate_type.\n\t(mangle_class_name_for_template): Handle type contexts as well as\n\tfunction contexts.\n\t(classtype_mangled_name): Likewise.\n\t(lookup_template_class): Likewise.\n\t(tsubst): Likewise.\n\t(more_specialized): Take explict template arguments as a\n\tparameter.\n\t(most_specialized): Likewise.\n\t(get_bindings): Likewise.  Check that return types match before\n\tproclaiming a function a match.\n\t(do_decl_instantiation): Remove code searching for function to\n\tinstantiate; that is now done in check_explicit_specialization.\n\t(add_maybe_template): Pass extra argument to get_bindings.\n\t* tree.c (really_overloaded_fn): Use is_overloaded_fn to simplify\n\timplementation.\n\t* typeck.c (build_component_ref): Check for invalid arguments.\n\nFrom-SVN: r17512", "tree": {"sha": "1b0143f1c5fe44825cf7d28a9e4f9dfafea4eb18", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b0143f1c5fe44825cf7d28a9e4f9dfafea4eb18"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1467ff26b70f3475d37606d391e3b458dec4798", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1467ff26b70f3475d37606d391e3b458dec4798", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1467ff26b70f3475d37606d391e3b458dec4798", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1467ff26b70f3475d37606d391e3b458dec4798/comments", "author": null, "committer": null, "parents": [{"sha": "c3499f009df3741f02d8328c9ea9ad95b6bb2e39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c3499f009df3741f02d8328c9ea9ad95b6bb2e39", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c3499f009df3741f02d8328c9ea9ad95b6bb2e39"}], "stats": {"total": 2559, "additions": 1251, "deletions": 1308}, "files": [{"sha": "355cb249455b59f94a41eb63d8916a8272bf2969", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1,3 +1,69 @@\n+Tue Jan 27 16:42:21 1998  Mark Mitchell  <mmitchell@usa.net>\n+\n+\t* call.c (add_template_candidate_real): New function.\n+\t(add_template_candidate): Use it.\n+\t(add_template_conv_candidate): Likewise.\n+\t(joust): Pass extra argument to more_specialized.\n+\t* class.c (instantiate_type): Handle a single FUNCTION_DECL.\n+\t(is_local_class): Remove.\n+\t(finish_struct): Check TI_PENDING_SPECIALIZATION_FLAG.\n+\t* cp-tree.h (is_local_class): Remove.\n+\t(perform_array_to_pointer_conversion): Likewise.\n+\t(finish_member_template_decl): Add.\n+\t(check_explicit_specialization): Return a tree, not an int.\n+\t(more_specialized): Take additional argument.\n+\t(get_bindings): Likewise.\n+\t* cvt.c (perform_qualification_conversions): Use comp_ptr_ttypes.\n+\t(perform_array_to_pointer_conversion): Remove.\n+\t* decl.c (saved_scope): Add processing_specialization,\n+\tprocessing_explicit_instantiation fields.\n+\t(maybe_push_to_top_level): Save them.\n+\t(pop_from_top_level): Restore them.\n+\t(grokfndecl): Use new return value from\n+\tcheck_explicit_specialization. \n+\t(start_decl): Don't check flag_guiding_decls before pushing\n+\tdecls. \n+\t(cp_finish_decl): Remove previous (bogus) change.\n+\t(grok_declarator): Use decl_function_context rather than\n+\tis_local_class. \n+\t* decl2.c (finish_file): Pass extra argument to get_bindings.\n+\t(build_expr_from_tree): Let build_x_component_ref check \n+\tvalidity of arguments rather than doing it here.\n+\t* lex.c (cons_up_default_function): Remove code fooling with\n+\tprocessing_specialization, processing_explicit_instantiation\n+\tflags, as that is now done in {maybe_push_top,pop_from}_top_level. \n+\t* method.c (build_overload_identifier): Mangle local classes in\n+\ttemplate functions correctly.\n+\t* parse.y (finish_member_template_decl): Move to pt.c.\n+\t* pt.c (finish_member_template_decl): Moved here from parse.y.\n+\t(print_candidates): New function.\n+\t(determine_specialization): Change interface.  Properly look for\n+\tmost specialized versions of template candidates.\n+\t(check_explicit_specialization): Fully process explicit\n+\tinstantiations. \n+\t(push_template_decl): Avoid looking at CLASSTYPE fields in\n+\tFUNCTION_DECLS. \n+\t(determine_overloaded_function): Remove.\n+\t(convert_nontype_argument): Change name from\n+\tconvert_nontype_parameter.  Use determine_overloaded_function\n+\tinstead of instantiate_type.\n+\t(mangle_class_name_for_template): Handle type contexts as well as\n+\tfunction contexts.\n+\t(classtype_mangled_name): Likewise.\n+\t(lookup_template_class): Likewise.\n+\t(tsubst): Likewise.\n+\t(more_specialized): Take explict template arguments as a\n+\tparameter. \n+\t(most_specialized): Likewise.\n+\t(get_bindings): Likewise.  Check that return types match before\n+\tproclaiming a function a match.\n+\t(do_decl_instantiation): Remove code searching for function to\n+\tinstantiate; that is now done in check_explicit_specialization.\n+\t(add_maybe_template): Pass extra argument to get_bindings.\n+\t* tree.c (really_overloaded_fn): Use is_overloaded_fn to simplify\n+\timplementation.\n+\t* typeck.c (build_component_ref): Check for invalid arguments.\n+\n Tue Jan 27 01:44:02 1998  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* expr.c (cplus_expand_expr, AGGR_INIT_EXPR): Don't check that "}, {"sha": "82a75789d7c0440caa5616bcf0bd1e7c2b38ed66", "filename": "gcc/cp/NEWS", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FNEWS?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -159,7 +159,7 @@\n * The name of a class is now implicitly declared in its own scope; A::A\n   refers to A.\n \n-* Local classes are now supported, though not inside templates.\n+* Local classes are now supported.\n \n * __attribute__ can now be attached to types as well as declarations.\n "}, {"sha": "c841dca8879275bb7043b196d398f1c5cea2c60c", "filename": "gcc/cp/call.c", "status": "modified", "additions": 64, "deletions": 29, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -4149,20 +4149,25 @@ add_builtin_candidates (candidates, code, code2, fnname, args, flags)\n   return candidates;\n }\n \n+\n /* If TMPL can be successfully instantiated as indicated by\n    EXPLICIT_TARGS and ARGLIST, adds the instantiation to CANDIDATES.\n \n-   TMPL is the template.  EXPLICIT_TARGS are any explicit template arguments.\n-   ARGLIST is the arguments provided at the call-site.  The RETURN_TYPE\n-   is the desired type for conversion operators.  FLAGS are as for\n-   add_function_candidate.  */\n-\n-static struct z_candidate *\n-add_template_candidate (candidates, tmpl, explicit_targs, \n-\t\t\targlist, return_type, flags)\n+   TMPL is the template.  EXPLICIT_TARGS are any explicit template\n+   arguments.  ARGLIST is the arguments provided at the call-site.\n+   The RETURN_TYPE is the desired type for conversion operators.  If\n+   OBJ is NULL_TREE, FLAGS are as for add_function_candidate.  If an\n+   OBJ is supplied, FLAGS are ignored, and OBJ is as for\n+   add_conv_candidate.  */\n+\n+static struct z_candidate*\n+add_template_candidate_real (candidates, tmpl, explicit_targs,\n+\t\t\t     arglist, return_type, flags,\n+\t\t\t     obj)\n      struct z_candidate *candidates;\n      tree tmpl, explicit_targs, arglist, return_type;\n      int flags;\n+     tree obj;\n {\n   int ntparms = DECL_NTPARMS (tmpl);\n   tree targs = make_scratch_vec (ntparms);\n@@ -4180,35 +4185,58 @@ add_template_candidate (candidates, tmpl, explicit_targs,\n   if (fn == error_mark_node)\n     return candidates;\n \n-  cand = add_function_candidate (candidates, fn, arglist, flags);\n-  cand->template = DECL_TEMPLATE_INFO (fn);\n+  if (obj != NULL_TREE)\n+    /* Aha, this is a conversion function.  */\n+    cand = add_conv_candidate (candidates, fn, obj, arglist);\n+  else\n+    cand = add_function_candidate (candidates, fn, arglist, flags);\n+  if (DECL_TI_TEMPLATE (fn) != tmpl)\n+    /* This situation can occur if a member template of a template\n+       class is specialized.  Then, instantiate_template might return\n+       an instantiation of the specialization, in which case the\n+       DECL_TI_TEMPLATE field will point at the original\n+       specialization.  For example:\n+\n+\t template <class T> struct S { template <class U> void f(U);\n+\t\t\t\t       template <> void f(int) {}; };\n+\t S<double> sd;\n+\t sd.f(3);\n+\n+       Here, TMPL will be template <class U> S<double>::f(U).\n+       And, instantiate template will give us the specialization\n+       template <> S<double>::f(int).  But, the DECL_TI_TEMPLATE field\n+       for this will point at template <class T> template <> S<T>::f(int),\n+       so that we can find the definition.  For the purposes of\n+       overload resolution, however, we want the original TMPL.  */\n+    cand->template = tree_cons (tmpl, targs, NULL_TREE);\n+  else\n+    cand->template = DECL_TEMPLATE_INFO (fn);\n+\n   return cand;\n }\n \n \n static struct z_candidate *\n-add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n+add_template_candidate (candidates, tmpl, explicit_targs, \n+\t\t\targlist, return_type, flags)\n      struct z_candidate *candidates;\n-     tree tmpl, obj, arglist, return_type;\n+     tree tmpl, explicit_targs, arglist, return_type;\n+     int flags;\n {\n-  int ntparms = DECL_NTPARMS (tmpl);\n-  tree targs = make_scratch_vec (ntparms);\n-  struct z_candidate *cand;\n-  int i;\n-  tree fn;\n+  return \n+    add_template_candidate_real (candidates, tmpl, explicit_targs,\n+\t\t\t\t arglist, return_type, flags, NULL_TREE);\n+}\n \n-  i = fn_type_unification (tmpl, NULL_TREE, targs, arglist, return_type, 0);\n \n-  if (i != 0)\n-    return candidates;\n-\n-  fn = instantiate_template (tmpl, targs);\n-  if (fn == error_mark_node)\n-    return candidates;\n-\n-  cand = add_conv_candidate (candidates, fn, obj, arglist);\n-  cand->template = DECL_TEMPLATE_INFO (fn);\n-  return cand;\n+static struct z_candidate *\n+add_template_conv_candidate (candidates, tmpl, obj, arglist, return_type)\n+     struct z_candidate *candidates;\n+     tree tmpl, obj, arglist, return_type;\n+{\n+  return \n+    add_template_candidate_real (candidates, tmpl, NULL_TREE, arglist,\n+\t\t\t\t return_type, 0, obj);\n }\n \n \n@@ -4360,6 +4388,12 @@ build_user_type_conversion_1 (totype, expr, flags)\n \tics = implicit_conversion\n \t  (totype, TREE_TYPE (TREE_TYPE (fn)), 0, convflags);\n       else\n+\t/* Here, the template conversion operator result must\n+\t   precisely match the TOTYPE.  (FIXME: Actually, we're\n+\t   supposed to do some simple conversions here; see\n+\t   [temp.deduct.conv].).  If the result of the conversion\n+\t   operator is not actually TOTYPE, then\n+\t   add_template_candidate will fail below.  */\n \tics = implicit_conversion (totype, totype, 0, convflags);\n \n       if (TREE_CODE (totype) == REFERENCE_TYPE && ics && ICS_BAD_FLAG (ics))\n@@ -6273,7 +6307,8 @@ joust (cand1, cand2)\n     return -1;\n   else if (cand1->template && cand2->template)\n     winner = more_specialized\n-      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template));\n+      (TI_TEMPLATE (cand1->template), TI_TEMPLATE (cand2->template),\n+       NULL_TREE);\n \n   /* or, if not that,\n      the  context  is  an  initialization by user-defined conversion (see"}, {"sha": "16fd55577000fd089b8e3ff04865607cc318ed42", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -4504,6 +4504,7 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n     {\n       tree spec_args;\n       tree fn;\n+      int pending_specialization;\n \n       if (uses_template_parms (t))\n \t/* If t is a template class, and x is a specialization, then x\n@@ -4527,11 +4528,12 @@ finish_struct (t, list_of_fieldlists, attributes, warn_anon)\n       else\n \tspec_args = DECL_TI_ARGS (fn);\n       \n+      pending_specialization \n+\t= TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (fn));\n       check_explicit_specialization \n \t(lookup_template_function (DECL_NAME (fn), spec_args),\n-\t fn, 0, 1 | (8 * (int) TREE_CHAIN (DECL_TEMPLATE_INFO (fn))));\n-\n-      TREE_CHAIN (DECL_TEMPLATE_INFO (fn)) = NULL_TREE;\n+\t fn, 0, 1 | (8 * pending_specialization));\n+      TI_PENDING_SPECIALIZATION_FLAG (DECL_TEMPLATE_INFO (fn)) = 0;\n \n       /* Now, the assembler name will be correct for fn, so we\n \t make its RTL.  */\n@@ -5423,6 +5425,16 @@ instantiate_type (lhstype, rhs, complain)\n     case ERROR_MARK:\n       return error_mark_node;\n \n+    case FUNCTION_DECL:\n+      if (!comptypes (lhstype, TREE_TYPE (rhs), 1))\n+\t{\n+\t  if (complain)\n+\t    cp_error (\"%D is not of type %T\", rhs, lhstype);\n+\t  return error_mark_node;\n+\t}\n+      else\n+\treturn rhs;\n+\n     default:\n       my_friendly_abort (185);\n       return error_mark_node;\n@@ -5505,21 +5517,3 @@ build_self_reference ()\n   pushdecl_class_level (value);\n   return value;\n }\n-\n-\n-/* Returns non-zero iff the TYPE is a local class; i.e., if it is\n-   declared in a function context, or within a local class.  */\n-\n-int\n-is_local_class (type)\n-     tree type;\n-{\n-  if (type == NULL_TREE || TYPE_CONTEXT (type) == NULL_TREE)\n-    return 0;\n-\n-  if (TREE_CODE (TYPE_CONTEXT (type)) == FUNCTION_DECL)\n-    return 1;\n-\n-  return is_local_class (TYPE_CONTEXT (type));\n-}\n-"}, {"sha": "7354ba9cecf5f72579a9b22e97270e1be217c1d6", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1098,6 +1098,10 @@ struct lang_decl\n #define TI_SPEC_INFO(NODE) (TREE_CHAIN (NODE))\n #define TI_USES_TEMPLATE_PARMS(NODE) TREE_LANG_FLAG_0 (NODE)\n #define TI_PENDING_TEMPLATE_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n+/* TI_PENDING_SPECIALIZATION_FLAG on a template-info node indicates\n+   that the template is a specialization of a member template, but\n+   that we don't yet know which one.  */\n+#define TI_PENDING_SPECIALIZATION_FLAG(NODE) TREE_LANG_FLAG_1 (NODE)\n #define DECL_TI_TEMPLATE(NODE)      TI_TEMPLATE (DECL_TEMPLATE_INFO (NODE))\n #define DECL_TI_ARGS(NODE)          TI_ARGS (DECL_TEMPLATE_INFO (NODE))\n #define CLASSTYPE_TI_TEMPLATE(NODE) TI_TEMPLATE (CLASSTYPE_TEMPLATE_INFO (NODE))\n@@ -1992,7 +1996,6 @@ extern void maybe_push_cache_obstack\t\tPROTO((void));\n extern unsigned HOST_WIDE_INT skip_rtti_stuff\tPROTO((tree *));\n extern tree build_self_reference\t\tPROTO((void));\n extern void warn_hidden\t\t\t\tPROTO((tree));\n-extern int is_local_class                       PROTO((tree));\n \n /* in cvt.c */\n extern tree convert_to_reference\t\tPROTO((tree, tree, int, int, tree));\n@@ -2009,7 +2012,6 @@ extern tree build_expr_type_conversion\t\tPROTO((int, tree, int));\n extern int build_default_binary_type_conversion\tPROTO((enum tree_code, tree *, tree *));\n extern tree type_promotes_to\t\t\tPROTO((tree));\n extern tree perform_qualification_conversions   PROTO((tree, tree));\n-extern tree perform_array_to_pointer_conversion PROTO((tree));\n \n /* decl.c */\n /* resume_binding_level */\n@@ -2325,14 +2327,15 @@ extern tree tsubst_copy\t\t\t\tPROTO ((tree, tree, int, tree));\n extern tree tsubst_chain\t\t\tPROTO((tree, tree));\n extern void begin_member_template_processing    PROTO((tree));\n extern void end_member_template_processing      PROTO((void));\n+extern tree finish_member_template_decl         PROTO((tree, tree));\n extern void begin_template_parm_list\t\tPROTO((void));\n extern void begin_specialization                PROTO((void));\n extern void reset_specialization                PROTO((void));\n extern void end_specialization                  PROTO((void));\n extern void begin_explicit_instantiation        PROTO((void));\n extern void end_explicit_instantiation          PROTO((void));\n extern tree determine_specialization            PROTO((tree, tree, tree *, int, int));\n-extern int check_explicit_specialization        PROTO((tree, tree, int, int));\n+extern tree check_explicit_specialization        PROTO((tree, tree, int, int));\n extern tree process_template_parm\t\tPROTO((tree, tree));\n extern tree end_template_parm_list\t\tPROTO((tree));\n extern void end_template_decl\t\t\tPROTO((void));\n@@ -2348,21 +2351,21 @@ extern int fn_type_unification                  PROTO((tree, tree, tree, tree, t\n extern int type_unification\t\t\tPROTO((tree, tree *, tree, tree, tree, int *, int, int));\n struct tinst_level *tinst_for_decl\t\tPROTO((void));\n extern void mark_decl_instantiated\t\tPROTO((tree, int));\n-extern int more_specialized\t\t\tPROTO((tree, tree));\n+extern int more_specialized\t\t\tPROTO((tree, tree, tree));\n extern void mark_class_instantiated\t\tPROTO((tree, int));\n extern void do_decl_instantiation\t\tPROTO((tree, tree, tree));\n extern void do_type_instantiation\t\tPROTO((tree, tree));\n extern tree instantiate_decl\t\t\tPROTO((tree));\n extern tree lookup_nested_type_by_name\t\tPROTO((tree, tree));\n extern tree do_poplevel\t\t\t\tPROTO((void));\n-extern tree get_bindings\t\t\tPROTO((tree, tree));\n+extern tree get_bindings\t\t\tPROTO((tree, tree, tree));\n /* CONT ... */\n extern void add_tree\t\t\t\tPROTO((tree));\n extern void begin_tree                          PROTO((void));\n extern void end_tree                            PROTO((void));\n extern void add_maybe_template\t\t\tPROTO((tree, tree));\n extern void pop_tinst_level\t\t\tPROTO((void));\n-extern tree most_specialized\t\t\tPROTO((tree, tree));\n+extern tree most_specialized\t\t\tPROTO((tree, tree, tree));\n extern tree most_specialized_class\t\tPROTO((tree, tree));\n extern int more_specialized_class\t\tPROTO((tree, tree));\n extern void do_pushlevel\t\t\tPROTO((void));"}, {"sha": "fe3c794d70a81b142666529f869fcd0d2479b8ab", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 8, "deletions": 118, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1689,127 +1689,17 @@ type_promotes_to (type)\n    closely.  Although they are used only in pt.c at the moment, they\n    should presumably be used everywhere in the future.  */\n \n+/* Attempt to perform qualification conversions on EXPR to convert it\n+   to TYPE.  Return the resulting expression, or error_mark_node if\n+   the conversion was impossible.  */\n+\n tree \n perform_qualification_conversions (type, expr)\n      tree type;\n      tree expr;\n {\n-  tree expr_type = TREE_TYPE (expr);\n-  tree t1;\n-  tree t2;\n-  int j;\n-  int all_have_const = 1;\n-\n-  if (comptypes (type, expr_type, 1))\n-    /* The two types are already the same, so there is nothing to do.  */\n-    return expr;\n-\n-  j = 0;\n-  t1 = expr_type;\n-  t2 = type; \n-\n-  while (1)\n-    {\n-      if (TREE_CODE (type) != TREE_CODE (expr_type))\n-\treturn error_mark_node;\n-\n-      if (j > 0 \n-\t  && TREE_CODE (type) == POINTER_TYPE)\n-\t{\n-\t  if (TYPE_READONLY (t1) > TYPE_READONLY (t2)\n-\t      || TYPE_VOLATILE (t1) > TYPE_VOLATILE (t2))\n-\t    /* For every j>0, if const is in cv1,j the const is in\n-\t       cv2,j, and similarly for volatile.  */\n-\t    return error_mark_node;\n-\t}\n-\n-      if (!all_have_const \n-\t  && (TYPE_READONLY (t1) != TYPE_READONLY (t2)\n-\t      || TYPE_READONLY (t1) != TYPE_READONLY (t2)))\n-\t/* If the cv1,j and cv2,j are different, then const is in every\n-\t   cv2,k for 0<k<j.  */\n-\treturn error_mark_node;\n-\t\n-      if (j > 0 && !TYPE_READONLY (t2))\n-\tall_have_const = 0;\n-\n-      if (TREE_CODE (type) != POINTER_TYPE)\n-\t{\n-\t  if (j == 0)\n-\t    /* The two things to be converted weren't even pointer\n-\t       types.  */\n-\t    return error_mark_node;\n-\t  \n-\t  if (TYPE_PTRMEMFUNC_P (type))\n-\t    {\n-\t      t1 = TYPE_PTRMEMFUNC_FN_TYPE (t1);\n-\t      t2 = TYPE_PTRMEMFUNC_FN_TYPE (t2);\n-\t    }\n-\n-\t  if (comptypes (TYPE_MAIN_VARIANT (t1),\n-\t\t\t TYPE_MAIN_VARIANT (t2), 1))\n-\t    return build1 (NOP_EXPR, type, expr);\n-\t  else\n-\t    /* The pointers were not similar.  */\n-\t    return error_mark_node;\n-\t}\n-\n-      if (TYPE_PTRMEM_P (type) \n-\t  && !comptypes (TYPE_OFFSET_BASETYPE (TREE_TYPE (t1)),\n-\t\t\t TYPE_OFFSET_BASETYPE (TREE_TYPE (t2)),\n-\t\t\t 1))\n-\t/* One type is X::* and the other is Y::*.  */\n-\treturn error_mark_node;\n-\n-      if (TYPE_PTRMEM_P (type))\n-\t{\n-\t  t1 = TREE_TYPE (TREE_TYPE (t1));\n-\t  t2 = TREE_TYPE (TREE_TYPE (t2));\n-\t}\n-      else\n-\t{\n-\t  t1 = TREE_TYPE (t1);\n-\t  t2 = TREE_TYPE (t2);\n-\t}\n-    }\n-}\n-\n-\n-/* Perform array-to-pointer conversion on EXPR, if appropriate.\n-   Return the converted expression, or EXPR if no\n-   conversion was performed, or error_mark_node if the conversion was\n-   attempted, but failed.  (For example, if an attempt is made to take\n-   the address of a non-addressable object.)  */\n-\n-tree \n-perform_array_to_pointer_conversion (expr)\n-     tree expr;\n-{\n-  tree result = expr;\n-\n-  if (TREE_CODE (TREE_TYPE (expr)) == ARRAY_TYPE)\n-    {\n-      tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (expr)));\n-      \n-      /* This section is copied from decay_conversion.  */\n-      if (TREE_CODE (expr) == VAR_DECL)\n-\t{\n-\t  /* ??? This is not really quite correct\n-\t     in that the type of the operand of ADDR_EXPR\n-\t     is not the target type of the type of the ADDR_EXPR itself.\n-\t     Question is, can this lossage be avoided?  */\n-\t  result = build1 (ADDR_EXPR, type, expr);\n-\t  if (mark_addressable (expr) == 0)\n-\t    return error_mark_node;\n-\t  TREE_CONSTANT (result) = staticp (expr);\n-\t  TREE_SIDE_EFFECTS (result) = 0; /* Default would be, same as\n-\t\t\t\t\t     EXPR.  */ \n-\t}\n-      else \n-\t/* This way is better for a COMPONENT_REF since it can\n-\t   simplify the offset for a component.  */\n-\tresult = build_unary_op (ADDR_EXPR, expr, 1);\n-    }\n-\n-  return result;\n+  if (comp_ptr_ttypes (type, TREE_TYPE(expr)))\n+    return build1 (NOP_EXPR, type, expr);\n+  else\n+    return error_mark_node;\n }"}, {"sha": "700ce08b95e87cf556172114b4e57278af0214da", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 36, "deletions": 17, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1835,6 +1835,8 @@ struct saved_scope {\n   tree template_parms;\n   HOST_WIDE_INT processing_template_decl;\n   tree previous_class_type, previous_class_values;\n+  int processing_specialization;\n+  int processing_explicit_instantiation;\n };\n static struct saved_scope *current_saved_scope;\n \n@@ -1933,6 +1935,8 @@ maybe_push_to_top_level (pseudo)\n   s->processing_template_decl = processing_template_decl;\n   s->previous_class_type = previous_class_type;\n   s->previous_class_values = previous_class_values;\n+  s->processing_specialization = processing_specialization;\n+  s->processing_explicit_instantiation = processing_explicit_instantiation;\n \n   current_class_name = current_class_type = NULL_TREE;\n   current_function_decl = NULL_TREE;\n@@ -1945,6 +1949,8 @@ maybe_push_to_top_level (pseudo)\n   named_labels = NULL_TREE;\n   minimal_parse_mode = 0;\n   previous_class_type = previous_class_values = NULL_TREE;\n+  processing_specialization = 0;\n+  processing_explicit_instantiation = 0;\n   if (!pseudo)\n     {\n       current_template_parms = NULL_TREE;\n@@ -2011,6 +2017,8 @@ pop_from_top_level ()\n   processing_template_decl = s->processing_template_decl;\n   previous_class_type = s->previous_class_type;\n   previous_class_values = s->previous_class_values;\n+  processing_specialization = s->processing_specialization;\n+  processing_explicit_instantiation = s->processing_explicit_instantiation;\n \n   free (s);\n \n@@ -6144,8 +6152,7 @@ start_decl (declarator, declspecs, initialized)\n       /* The declaration of template specializations does not affect\n \t the functions available for overload resolution, so we do not\n \t call pushdecl.  */\n-      || (!flag_guiding_decls \n-\t  && TREE_CODE (decl) == FUNCTION_DECL\n+      || (TREE_CODE (decl) == FUNCTION_DECL\n \t  && DECL_TEMPLATE_SPECIALIZATION (decl)))\n     tem = decl;\n   else\n@@ -6487,6 +6494,8 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       if (minimal_parse_mode && ! DECL_ARTIFICIAL (decl))\n \t{\n \t  tree stmt = DECL_VINDEX (decl);\n+\t  /* If the decl is declaring a member of a local class (in a\n+\t     template function), there will be no associated stmt.  */\n \t  if (stmt != NULL_TREE)\n \t    {\n \t      DECL_VINDEX (decl) = NULL_TREE;\n@@ -6778,11 +6787,7 @@ cp_finish_decl (decl, init, asmspec_tree, need_pop, flags)\n       || TREE_CODE (decl) == RESULT_DECL)\n     {\n       /* ??? FIXME: What about nested classes?  */\n-      /* We check for FUNCTION_DECL here so that member functions of\n-\t local classes, which will have internal linkage, are not\n-\t given bizarre names by make_decl_rtl.  */\n-      int toplev = toplevel_bindings_p () || pseudo_global_level_p ()\n-\t|| TREE_CODE (decl) == FUNCTION_DECL;\n+      int toplev = toplevel_bindings_p () || pseudo_global_level_p ();\n       int was_temp\n \t= (TREE_STATIC (decl) && TYPE_NEEDS_DESTRUCTOR (type)\n \t   && allocation_temporary_p ());\n@@ -7491,10 +7496,10 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n \n       grokclassfn (ctype, declarator, decl, flags, quals);\n \n-      check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t     template_count, \n-\t\t\t\t     funcdef_flag ? 2 : \n-\t\t\t\t     (friendp ? 3 : 0));\n+      decl = check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t\t    template_count, \n+\t\t\t\t\t    funcdef_flag ? 2 : \n+\t\t\t\t\t    (friendp ? 3 : 0));\n \n       if (check)\n \t{\n@@ -7538,10 +7543,10 @@ grokfndecl (ctype, type, declarator, orig_declarator, virtualp, flags, quals,\n       if (ctype != NULL_TREE)\n \tgrokclassfn (ctype, cname, decl, flags, quals);\n \n-      check_explicit_specialization (orig_declarator, decl,\n-\t\t\t\t     template_count, \n-\t\t\t\t     funcdef_flag ? 2 : \n-\t\t\t\t     (friendp ? 3 : 0));\n+      decl = check_explicit_specialization (orig_declarator, decl,\n+\t\t\t\t\t    template_count, \n+\t\t\t\t\t    funcdef_flag ? 2 : \n+\t\t\t\t\t    (friendp ? 3 : 0));\n \n       if (ctype != NULL_TREE && check)\n \t{\n@@ -9666,6 +9671,7 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \telse if (TREE_CODE (type) == FUNCTION_TYPE)\n \t  {\n \t    int publicp = 0;\n+\t    tree function_context;\n \n \t    /* We catch the others as conflicts with the builtin\n \t       typedefs.  */\n@@ -9715,7 +9721,10 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t      }\n \n \t    /* Tell grokfndecl if it needs to set TREE_PUBLIC on the node.  */\n-\t    publicp = (! friendp || ! staticp) && !is_local_class (ctype);\n+\t    function_context = (ctype != NULL_TREE) ? \n+\t      hack_decl_function_context (TYPE_MAIN_DECL (ctype)) : NULL_TREE;\n+\t    publicp = (! friendp || ! staticp)\n+\t      && function_context == NULL_TREE;\n \t    decl = grokfndecl (ctype, type, \n \t\t\t       TREE_CODE (declarator) != TEMPLATE_ID_EXPR\n \t\t\t       ? declarator : dname,\n@@ -9725,6 +9734,16 @@ grokdeclarator (declarator, declspecs, decl_context, initialized, attrlist)\n \t\t\t       funcdef_flag, template_count);\n \t    if (decl == NULL_TREE)\n \t      return NULL_TREE;\n+\t    if (function_context != NULL_TREE\n+\t\t&& DECL_THIS_INLINE (function_context)\n+\t\t&& TREE_PUBLIC (function_context))\n+\t      /* We just declared a member of a local class in an\n+\t\t extern inline function.  Give such an entity comdat\n+\t\t linkage.  */\n+\t      {\n+\t\tcomdat_linkage (decl);\n+\t\tDECL_INTERFACE_KNOWN (decl) = 1;\n+\t      }\n #if 0\n \t    /* This clobbers the attrs stored in `decl' from `attrlist'.  */\n \t    /* The decl and setting of decl_machine_attr is also turned off.  */\n@@ -12494,7 +12513,7 @@ finish_function (lineno, call_poplevel, nested)\n       can_reach_end = 0;\n \n       if (DECL_CONTEXT (fndecl) != NULL_TREE\n-\t  && is_local_class (DECL_CONTEXT (fndecl)))\n+\t  && hack_decl_function_context (fndecl))\n \t/* Trick rest_of_compilation into not deferring output of this\n \t   function, even if it is inline, since the rtl_obstack for\n \t   this function is the function_obstack of the enclosing"}, {"sha": "b003b6c2d121cad0d62b4c96cfb52e07a0d05af9", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -2940,7 +2940,7 @@ finish_file ()\n \tcontinue;\n \n       fn = TREE_PURPOSE (fnname);\n-      args = get_bindings (fn, decl);\n+      args = get_bindings (fn, decl, NULL_TREE);\n       fn = instantiate_template (fn, args);\n       instantiate_decl (fn);\n     }\n@@ -3605,21 +3605,10 @@ build_expr_from_tree (t)\n       }\n \n     case COMPONENT_REF:\n-      {\n-\ttree object = build_expr_from_tree (TREE_OPERAND (t, 0));\n-\n-\tif (object != NULL_TREE \n-\t    && TREE_CODE (object) == TEMPLATE_DECL)\n-\t  {\n-\t    cp_error (\"invalid use of %D\", object);\n-\t    object = error_mark_node;\n-\t  }\n-\n-\treturn build_x_component_ref\n-\t  (object,\n-\t   TREE_OPERAND (t, 1), NULL_TREE, 1);\n-      }\n-\n+      return build_x_component_ref\n+\t(build_expr_from_tree (TREE_OPERAND (t, 0)),\n+\t TREE_OPERAND (t, 1), NULL_TREE, 1);\n+      \n     case THROW_EXPR:\n       return build_throw (build_expr_from_tree (TREE_OPERAND (t, 0)));\n "}, {"sha": "25da8fd86e3cbc2ea62e65537546ab9facf44763", "filename": "gcc/cp/error.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1661,7 +1661,7 @@ fndecl_as_string (fndecl, print_ret_type_p)\n   return decl_as_string (fndecl, print_ret_type_p);\n }\n \n-/* Same, but handtype a _TYPE.\n+/* Same, but handle a _TYPE.\n    Called from convert_to_reference, mangle_class_name_for_template,\n    build_unary_op, and GNU_xref_decl.  */\n "}, {"sha": "d8d7d90300ab50bd1812db1544060e4cb7810536", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1998,22 +1998,10 @@ cons_up_default_function (type, full_name, kind)\n \n   {\n     tree declarator = make_call_declarator (name, args, NULL_TREE, NULL_TREE);\n-    int saved_processing_specialization;\n-    int saved_processing_explicit_instantiation;\n     if (retref)\n       declarator = build_parse_node (ADDR_EXPR, declarator);\n \n-    /* The following is in case we're generating the default\n-       implementation in the midst of handling a specialization. */\n-    saved_processing_specialization = processing_specialization;\n-    saved_processing_explicit_instantiation =\n-      processing_explicit_instantiation; \n-    processing_specialization = 0;\n-    processing_explicit_instantiation = 0;\n     fn = grokfield (declarator, declspecs, NULL_TREE, NULL_TREE, NULL_TREE);\n-    processing_specialization = saved_processing_specialization;\n-    processing_explicit_instantiation = \n-      saved_processing_explicit_instantiation;\n   }\n   \n   if (fn == void_type_node)"}, {"sha": "7f28e769df289dfba80fac8c6e1d1dee03bdf1cd", "filename": "gcc/cp/method.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -758,7 +758,10 @@ build_overload_identifier (name)\n   if (TREE_CODE (name) == TYPE_DECL\n       && IS_AGGR_TYPE (TREE_TYPE (name))\n       && CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name))\n-      && PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name))))\n+      && (PRIMARY_TEMPLATE_P (CLASSTYPE_TI_TEMPLATE (TREE_TYPE (name)))\n+\t  || (TREE_CODE (DECL_CONTEXT (CLASSTYPE_TI_TEMPLATE \n+\t\t\t\t       (TREE_TYPE (name))))\n+\t      == FUNCTION_DECL)))\n     {\n       tree template, parmlist, arglist, tname;\n       template = CLASSTYPE_TEMPLATE_INFO (TREE_TYPE (name));"}, {"sha": "1c60139b732a357e946d089d80ba1a31d95aa9d0", "filename": "gcc/cp/parse.c", "status": "modified", "additions": 779, "deletions": 805, "changes": 1584, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798"}, {"sha": "22dc376d2e05e90b609de64afc94e27d6a996d45", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -78,7 +78,6 @@ static int processing_template_arg;\n extern int arg_looking_for_template;\n \n static tree empty_parms PROTO((void));\n-static tree finish_member_template_decl PROTO((tree, tree));\n \n /* Nonzero if we have an `extern \"C\"' acting as an extern specifier.  */\n int have_extern_spec;\n@@ -101,31 +100,6 @@ empty_parms ()\n   return parms;\n }\n \n-\n-static tree\n-finish_member_template_decl (template_arguments, decl)\n-  tree template_arguments;\n-  tree decl;\n-{\n-  if (template_arguments)\n-    end_template_decl();\n-  else\n-    end_specialization();\n-\n-  if (decl && DECL_TEMPLATE_INFO (decl) &&\n-      !DECL_TEMPLATE_SPECIALIZATION (decl))\n-    {\n-      check_member_template (DECL_TI_TEMPLATE (decl));\n-      return DECL_TI_TEMPLATE (decl);\n-    }\n-\n-  if (decl)\n-    return decl;\n-\n-  cp_error (\"invalid member template declaration\");\n-  return NULL_TREE;\n-}\n-\n %}\n \n %start program"}, {"sha": "8782406c41c6b7b6fb48fe175a976e4b88fbfd5f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 256, "deletions": 245, "changes": 501, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -85,7 +85,36 @@ static int  type_unification_real PROTO((tree, tree *, tree, tree, int*,\n \t\t\t\t\t int, int, int));\n static void note_template_header PROTO((int));\n static tree maybe_fold_nontype_arg PROTO((tree));\n-static tree convert_nontype_parameter PROTO((tree, tree));\n+static tree convert_nontype_argument PROTO((tree, tree));\n+\n+/* Do any processing required when DECL (a member template declaration\n+   using TEMPLATE_PARAMETERS as its innermost parameter list) is\n+   finished.  Returns the TEMPLATE_DECL corresponding to DECL, unless\n+   it is a specialization, in which case the DECL itself is returned.  */\n+\n+tree\n+finish_member_template_decl (template_parameters, decl)\n+  tree template_parameters;\n+  tree decl;\n+{\n+  if (template_parameters)\n+    end_template_decl();\n+  else\n+    end_specialization();\n+\n+  if (decl && DECL_TEMPLATE_INFO (decl) &&\n+      !DECL_TEMPLATE_SPECIALIZATION (decl))\n+    {\n+      check_member_template (DECL_TI_TEMPLATE (decl));\n+      return DECL_TI_TEMPLATE (decl);\n+    }\n+\n+  if (decl)\n+    return decl;\n+\n+  cp_error (\"invalid member template declaration\");\n+  return NULL_TREE;\n+}\n \n /* Restore the template parameter context. */\n \n@@ -399,8 +428,6 @@ register_specialization (spec, tmpl, args)\n \t\t       used.  That situation can occur if we have\n \t\t       implicitly instantiated a member function of\n \t\t       class type, and then specialized it later.  */\n-\n-\t\t    /* FIXME: Should we call duplicate_decls here?  */\n \t\t    TREE_VALUE (s) = spec;\n \t\t    return;\n \t\t  }\n@@ -410,7 +437,6 @@ register_specialization (spec, tmpl, args)\n \t\tif (DECL_INITIAL (fn))\n \t\t  cp_error (\"duplicate specialization of %D\", fn);\n \n-\t\t/* FIXME: Should we call duplicate_decls here?  */\n \t\tTREE_VALUE (s) = spec;\n \t\treturn;\n \t      }\n@@ -422,31 +448,52 @@ register_specialization (spec, tmpl, args)\n }\n \n \n+/* Print the list of candidate FNS in an error message.  */\n+\n+static void\n+print_candidates (fns)\n+     tree fns;\n+{\n+  tree fn;\n+\n+  char* str = \"candidates are:\";\n+\n+  for (fn = fns; fn != NULL_TREE; fn = TREE_CHAIN (fn))\n+    {\n+      cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n+      str = \"               \";\n+    }\n+}\n+\n /* Returns the template (one of the functions given by TEMPLATE_ID)\n-   which can be specialized to have the indicated TYPE with the\n-   explicit template args given in TEMPLATE_ID.  TARGS_IN.  The\n-   template args (those explicitly specified and those deduced) are\n-   output in a newly created vector *TARGS_OUT.  If it is impossible\n-   to determine the result, an error message is issued, unless\n-   COMPLAIN is 0.  */\n+   which can be specialized to match the indicated DECL with the\n+   explicit template args given in TEMPLATE_ID.  If\n+   NEED_MEMBER_TEMPLATE is true the function is a specialization of a\n+   member template.  The template args (those explicitly specified and\n+   those deduced) are output in a newly created vector *TARGS_OUT.  If\n+   it is impossible to determine the result, an error message is\n+   issued, unless COMPLAIN is 0.  The DECL may be NULL_TREE if none is\n+   available.  */\n \n tree\n-determine_specialization (template_id, type, targs_out, \n+determine_specialization (template_id, decl, targs_out, \n \t\t\t  need_member_template,\n \t\t\t  complain)\n      tree template_id;\n-     tree type;\n+     tree decl;\n      tree* targs_out;\n      int need_member_template;\n      int complain;\n {\n   tree fns = TREE_OPERAND (template_id, 0);\n   tree targs_in = TREE_OPERAND (template_id, 1);\n-  tree matching_fns = NULL_TREE;\n+  tree templates = NULL_TREE;\n   tree fn;\n   int overloaded;\n   int i;\n \n+  *targs_out = NULL_TREE;\n+\n   if (is_overloaded_fn (fns))\n     fn = get_first_fn (fns);\n   else\n@@ -457,95 +504,86 @@ determine_specialization (template_id, type, targs_out,\n        fn = overloaded ? DECL_CHAIN (fn) : NULL_TREE)\n     {\n       int dummy = 0;\n-      tree targs;\n-      tree t;\n       tree tmpl;\n \n       if (!need_member_template \n \t  && TREE_CODE (fn) == FUNCTION_DECL \n+\t  && DECL_FUNCTION_MEMBER_P (fn)\n \t  && DECL_USE_TEMPLATE (fn)\n \t  && DECL_TI_TEMPLATE (fn))\n+\t/* We can get here when processing something like:\n+\t     template <class T> class X { void f(); }\n+\t     template <> void X<int>::f() {}\n+\t   We're specializing a member function, but not a member\n+\t   template.  */\n \ttmpl = DECL_TI_TEMPLATE (fn);\n       else if (TREE_CODE (fn) != TEMPLATE_DECL\n-\t  || (need_member_template && !is_member_template (fn)))\n+\t       || (need_member_template && !is_member_template (fn)))\n \tcontinue;\n       else\n \ttmpl = fn;\n \n       if (list_length (targs_in) > DECL_NTPARMS (tmpl))\n \tcontinue;\n \n-      targs = make_scratch_vec (DECL_NTPARMS (tmpl));\n-\n-      /* We allow incomplete unification here, because we are going to\n-\t check all the functions. */\n-      i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n-\t\t\t    &TREE_VEC_ELT (targs, 0),\n-\t\t\t    type \n-\t\t\t    ? TYPE_ARG_TYPES (TREE_TYPE (tmpl)) : NULL_TREE, \n-\t\t\t    type ? TYPE_ARG_TYPES (type) : NULL_TREE,\n-\t\t\t    targs_in,\n-\t\t\t    &dummy, 1, 1);\n-      \n-      if (i == 0) \n+      if (decl == NULL_TREE)\n \t{\n-\t  /* Unification was successful.  See if the return types\n-\t     match. */\n-\t  if (type != NULL_TREE)\n-\t    {\n-\t      tree tmpl_return_type = tsubst (TREE_TYPE (TREE_TYPE (tmpl)),\n-\t\t\t\t\t      targs,\n-\t\t\t\t\t      DECL_NTPARMS (tmpl),\n-\t\t\t\t\t      NULL_TREE);\n-\t      \n-\t      if (tmpl_return_type != TREE_TYPE (type))\n-\t\t{\n-\t\t  /* Always complain about this.  With ambiguity, some\n-\t\t     other context, might resolve things.  But, a\n-\t\t     non-matching return type will always be a\n-\t\t     problem.  */\n-\t\t  cp_error (\"Return type of explicit specialization of\");\n-\t\t  cp_error (\"`%D' is `%T', but should be `%T'.\", \n-\t\t\t    tmpl, TREE_TYPE (type), tmpl_return_type);\n-\t\t  *targs_out = NULL_TREE;\n-\t\t  return NULL_TREE;\n-\t\t}\n-\t    }\n-\n-\t  matching_fns = scratch_tree_cons (tmpl, targs, matching_fns);\n+\t  tree targs = make_scratch_vec (DECL_NTPARMS (tmpl));\n+\n+\t  /* We allow incomplete unification here, because we are going to\n+\t     check all the functions. */\n+\t  i = type_unification (DECL_INNERMOST_TEMPLATE_PARMS (tmpl),\n+\t\t\t\t&TREE_VEC_ELT (targs, 0),\n+\t\t\t\tNULL_TREE,\n+\t\t\t\tNULL_TREE,  \n+\t\t\t\ttargs_in,\n+\t\t\t\t&dummy, 1, 1);\n+      \n+\t  if (i == 0) \n+\t    /* Unification was successful.  */\n+\t    templates = scratch_tree_cons (targs, tmpl, templates);\n \t}\n+      else\n+\ttemplates = scratch_tree_cons (NULL_TREE, tmpl, templates);\n     }\n   \n-  if (matching_fns == NULL_TREE)\n+  if (decl != NULL_TREE)\n     {\n+      tree tmpl = most_specialized (templates, decl, targs_in);\n+\n+      if (tmpl == error_mark_node) \n+\tgoto ambiguous;\n+      else if (tmpl == NULL_TREE)\n+\tgoto no_match;\n+\n+      *targs_out = get_bindings (tmpl, decl, targs_in);\n+      return tmpl;\n+    }\n+\n+  if (templates == NULL_TREE)\n+    {\n+    no_match:\n       if (complain)\n-\tcp_error (\"`%D' does not match any template declaration.\",\n+\tcp_error (\"`%D' does not match any template declaration\",\n \t\t  template_id);\n       \n-      *targs_out = NULL_TREE;\n       return NULL_TREE;\n     }\n-  \n-  if (TREE_CHAIN (matching_fns) != NULL_TREE) \n+  else if (TREE_CHAIN (templates) != NULL_TREE) \n     {\n+    ambiguous:\n       if (complain)\n \t{\n-\t  tree tmpl;\n-\t  \n-\t  cp_error (\"Ambiguous explicit specialization.  Candidates are:\");\n-\t  for (tmpl = matching_fns; \n-\t       tmpl != NULL_TREE; \n-\t       tmpl = TREE_CHAIN (tmpl)) \n-\t    cp_error (\"    %D\", TREE_PURPOSE (tmpl));\n+\t  cp_error (\"ambiguous template specialization `%D'\",\n+\t\t    template_id);\n+\t  print_candidates (templates);\n \t}\n-\n-      *targs_out = NULL_TREE;\n       return NULL_TREE;\n     }\n \n   /* We have one, and exactly one, match. */\n-  *targs_out = TREE_VALUE (matching_fns);\n-  return TREE_PURPOSE (matching_fns);\n+  *targs_out = TREE_PURPOSE (templates);\n+  return TREE_VALUE (templates);\n }\n \n \t\n@@ -554,7 +592,8 @@ determine_specialization (template_id, type, targs_out,\n    template.  We may also discover that the declaration is an explicit\n    instantiation at this point.\n \n-   Returns:\n+   Returns DECL, or an equivalent declaration that should be used\n+   instead. \n    \n      0: The function is not an explicit specialization or instantiation.\n      1: The function is an explicit specialization.\n@@ -595,7 +634,7 @@ determine_specialization (template_id, type, targs_out,\n    is set up correctly, and it is added to the list of specializations \n    for that template.  */\n \n-int\n+tree\n check_explicit_specialization (declarator, decl, template_count, flags)\n      tree declarator;\n      tree decl;\n@@ -606,6 +645,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n   int have_def = flags & 2;\n   int is_friend = flags & 4;\n   int specialization = 0;\n+  int explicit_instantiation = 0;\n   int member_specialization = flags & 8;\n \n   tree ctype = DECL_CLASS_CONTEXT (decl);\n@@ -659,7 +699,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t\t But, we're missing another template <>.  */\n \t      cp_error(\"too few template parameter lists in declaration of `%D'\", decl);\n-\t      return 0;\n+\t      return decl;\n \t    } \n \t}\n       else if (processing_explicit_instantiation)\n@@ -670,12 +710,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  if (have_def)\n \t    cp_error (\"definition provided for explicit instantiation\");\n \n-\t  SET_DECL_EXPLICIT_INSTANTIATION (decl);\n-\n-\t  /* We don't try to figure out what's being explicitly\n-\t     instantiated at this point, since do_decl_instantiation\n-\t     will do that later.  */\n-\t  return 2;\n+\t  explicit_instantiation = 1;\n \t}\n       else if ((ctype != NULL_TREE\n \t\t&& !TYPE_BEING_DEFINED (ctype)\n@@ -700,22 +735,19 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     void f<int>();  */\n \n \t  if (template_header_count > template_count)\n-\t    {\n-\t      cp_error (\"template-id `%D' in declaration of primary template\",\n-\t\t\tdeclarator);\n-\t      return 0;\n-\t    }\n-\t  \n-\t  cp_error (\"explicit specialization not preceded by `template <>'\");\n-\t  return 0;\n+\t    cp_error (\"template-id `%D' in declaration of primary template\",\n+\t\t      declarator);\n+\t  else\n+\t    cp_error (\"explicit specialization not preceded by `template <>'\");\n+\n+\t  return decl;\n \t}\n     }\n \n-  if (specialization || member_specialization)\n+  if (specialization || member_specialization || explicit_instantiation)\n     {\n       tree tmpl = NULL_TREE;\n       tree targs = NULL_TREE;\n-      tree targs_in;\n \n       /* Make sure that the declarator is a TEMPLATE_ID_EXPR.  */\n       if (TREE_CODE (declarator) != TEMPLATE_ID_EXPR)\n@@ -738,8 +770,9 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t  /* A friend declaration.  We can't do much, because we don't\n \t   know what this resolves to, yet.  */\n \t  my_friendly_assert (is_friend != 0, 0);\n+\t  my_friendly_assert (!explicit_instantiation, 0);\n \t  SET_DECL_IMPLICIT_INSTANTIATION (decl);\n-\t  return 1;\n+\t  return decl;\n \t} \n \n       if (ctype != NULL_TREE && TYPE_BEING_DEFINED (ctype))\n@@ -748,17 +781,16 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t     can't call lookup_fnfields.  We note that this\n \t     template is a specialization, and proceed, letting\n \t     finish_struct fix this up later.  */\n-\t  DECL_TEMPLATE_INFO (decl) \n-\t    = perm_tree_cons (NULL_TREE, \n-\t\t\t      TREE_OPERAND (declarator, 1),\n-\t\t\t      /* We remember whether or not this was a\n-\t\t\t\t member specialization by recording\n-\t\t\t\t this value, temporarily, in the\n-\t\t\t\t TREE_CHAIN field.  Nobody looks at\n-\t\t\t\t this, and we clear it in\n-\t\t\t\t finish_struct.  */ \n-\t\t\t      (tree) member_specialization);\n-\t  return 1;\n+\t  tree ti = perm_tree_cons (NULL_TREE, \n+\t\t\t\t    TREE_OPERAND (declarator, 1),\n+\t\t\t\t    NULL_TREE);\n+\t  TI_PENDING_SPECIALIZATION_FLAG (ti) = 1;\n+\t  DECL_TEMPLATE_INFO (decl) = ti;\n+\t  /* This should not be an instantiation; explicit\n+\t     instantiation directives can only occur at the top\n+\t     level.  */\n+\t  my_friendly_assert (!explicit_instantiation, 0);\n+\t  return decl;\n \t}\n       else if (ctype != NULL_TREE \n \t       && (TREE_CODE (TREE_OPERAND (declarator, 0)) ==\n@@ -778,14 +810,16 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t\t  : !TYPE_HAS_DESTRUCTOR (ctype))\n \t\t{\n \t\t  /* From [temp.expl.spec]:\n-\n+\t\t       \n \t\t     If such an explicit specialization for the member\n \t\t     of a class template names an implicitly-declared\n \t\t     special member function (clause _special_), the\n-\t\t     program is ill-formed.  */\n+\t\t     program is ill-formed.  \n+\n+\t\t     Similar language is found in [temp.explicit].  */\n \t\t  cp_error (\"specialization of implicitly-declared special member function\");\n \n-\t\t  return 1;\n+\t\t  return decl;\n \t\t}\n \n \t      fns = TREE_VEC_ELT(CLASSTYPE_METHOD_VEC (ctype),\n@@ -800,22 +834,49 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      cp_error (\"no member function `%s' declared in `%T'\",\n \t\t\tIDENTIFIER_POINTER (name),\n \t\t\tctype);\n-\t      return 1;\n+\t      return decl;\n \t    }\n \t  else\n \t    TREE_OPERAND (declarator, 0) = fns;\n \t}\n       \n-      /* Figure out what exactly is being specialized at this point.  */\n-      tmpl = determine_specialization (declarator,\n-\t\t\t\t       TREE_TYPE (decl), &targs, \n+      /* Figure out what exactly is being specialized at this point.\n+\t Note that for an explicit instantiation, even one for a\n+\t member function, we cannot tell apriori whether the the\n+\t instantiation is for a member template, or just a member\n+\t function of a template class.  In particular, even in if the\n+\t instantiation is for a member template, the template\n+\t arguments could be deduced from the declaration.  */\n+      tmpl = determine_specialization (declarator, decl,\n+\t\t\t\t       &targs, \n \t\t\t\t       member_specialization,\n \t\t\t\t       1);\n \t    \n       if (tmpl)\n \t{\n-\t  /* Mangle the function name appropriately.  */\n-\t  if ((member_specialization || ctype == NULL_TREE)\n+\t  if (explicit_instantiation)\n+\t    {\n+\t      decl = instantiate_template (tmpl, targs);\n+\t      if (!DECL_TEMPLATE_SPECIALIZATION (decl))\n+\t\t/* There doesn't seem to be anything in the draft to\n+\t\t   prevent a specialization from being explicitly\n+\t\t   instantiated.  We're careful not to destroy the\n+\t\t   information indicating that this is a\n+\t\t   specialization here.  */\n+\t\tSET_DECL_EXPLICIT_INSTANTIATION (decl);\n+\t      return decl;\n+\t    }\n+\n+\t  /* Mangle the function name appropriately.  Note that we do\n+\t     not mangle specializations of non-template member\n+\t     functions of template classes, e.g. with\n+\t       template <class T> struct S { void f(); }\n+\t     and given the specialization \n+\t       template <> void S<int>::f() {}\n+\t     we do not mangle S<int>::f() here.  That's because it's\n+\t     just an ordinary member function and doesn't need special\n+\t     treatment.  */\n+\t  if ((is_member_template (tmpl) || ctype == NULL_TREE)\n \t      && name_mangling_version >= 1)\n \t    {\n \t      tree arg_types = TYPE_ARG_TYPES (TREE_TYPE (tmpl));\n@@ -843,7 +904,7 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \t      SET_DECL_IMPLICIT_INSTANTIATION (decl);\n \t      DECL_TEMPLATE_INFO (decl) \n \t\t= perm_tree_cons (tmpl, targs, NULL_TREE);\n-\t      return 2;\n+\t      return decl;\n \t    }\n \n \t  /* If DECL_TI_TEMPLATE (decl), the decl is an\n@@ -868,11 +929,11 @@ check_explicit_specialization (declarator, decl, template_count, flags)\n \n \t  register_specialization (decl, tmpl, targs);\n \n-\t  return 1;\n+\t  return decl;\n \t}\n     }\n   \n-  return 0;\n+  return decl;\n }\n \n \n@@ -1113,6 +1174,10 @@ current_template_args ()\n   return args;\n }\n \n+\n+/* Return a TEMPLATE_DECL corresponding to DECL, using the indicated\n+   template PARMS.  Used by push_template_decl below.  */\n+\n static tree\n build_template_decl (decl, parms)\n      tree decl;\n@@ -1147,7 +1212,9 @@ push_template_decl (decl)\n       && DECL_CLASS_CONTEXT (decl))\n     ;\n   /* Note that this template is a \"primary template\" */\n-  else if (! ctx || ! CLASSTYPE_TEMPLATE_INFO (ctx)\n+  else if (! ctx \n+\t   || (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't' \n+\t       && ! CLASSTYPE_TEMPLATE_INFO (ctx))\n       /* || (processing_template_decl > CLASSTYPE_TEMPLATE_LEVEL (ctx)) */)\n     primary = 1;\n \n@@ -1307,38 +1374,6 @@ push_template_decl (decl)\n }\n \n \n-/* Attempt to determine which of the overloaded functions given by\n-   FNS has the indicated TYPE.  If this cannot be determined\n-   unambiguously, return error_mark_node.  */\n-\n-static tree\n-determine_overloaded_function (type, fns)\n-     tree type;\n-     tree fns;\n-{\n-  tree fn;\n-\n-  my_friendly_assert (fns != NULL_TREE, 0);\n-  \n-  if (!is_overloaded_fn (fns))\n-    return error_mark_node;\n-  \n-  if (really_overloaded_fn (fns))\n-    {\n-      fn = instantiate_type (type, fns, 0);\n-      if (fn == error_mark_node)\n-\t/* We couldn't resolve the overloading.  */\n-\treturn error_mark_node;\n-    }\n-  else\n-    fn = get_first_fn (fns);\n-  \n-  my_friendly_assert (TREE_CODE (fn) == FUNCTION_DECL, 0);\n-\n-  return fn;\n-}\n-\n-\n /* Attempt to convert the non-type template parameter EXPR to the\n    indicated TYPE.  If the conversion is successful, return the\n    converted value.  If the conversion is unsuccesful, return\n@@ -1350,7 +1385,7 @@ determine_overloaded_function (type, fns)\n    parameters.  */\n \n static tree\n-convert_nontype_parameter (type, expr)\n+convert_nontype_argument (type, expr)\n      tree type;\n      tree expr;\n {\n@@ -1486,7 +1521,7 @@ convert_nontype_parameter (type, expr)\n \t    else\n \t      fns = expr;\n \n-\t    fn = determine_overloaded_function (type_pointed_to, fns);\n+\t    fn = instantiate_type (type_pointed_to, fns, 0);\n \n \t    if (fn == error_mark_node)\n \t      return error_mark_node;\n@@ -1515,8 +1550,11 @@ convert_nontype_parameter (type, expr)\n \t       (_conv.ptr_) are applied.  Although 0 is a valid\n \t       template-argument for a non-type template-parameter of\n \t       integral type, it is not a valid template-argument for a\n-\t       non-type template-parameter of pointer type.]  */\n-\t    expr = perform_array_to_pointer_conversion (expr);\n+\t       non-type template-parameter of pointer type.]  \n+\t    \n+\t       The call to decay_conversion performs the\n+\t       array-to-pointer conversion, if appropriate.  */\n+\t    expr = decay_conversion (expr);\n \n \t    if (expr == error_mark_node)\n \t      return error_mark_node;\n@@ -1540,7 +1578,7 @@ convert_nontype_parameter (type, expr)\n \t    tree fns = expr;\n \t    tree fn;\n \n-\t    fn = determine_overloaded_function (type_referred_to, fns);\n+\t    fn = instantiate_type (type_referred_to, fns, 0);\n \n \t    if (!TREE_PUBLIC (fn))\n \t      {\n@@ -1614,8 +1652,8 @@ convert_nontype_parameter (type, expr)\n \n \tfns = TREE_OPERAND (expr, 0);\n \t\n-\tfn = determine_overloaded_function (TREE_TYPE (TREE_TYPE (type)), \n-\t\t\t\t\t    fns);\n+\tfn = instantiate_type (TREE_TYPE (TREE_TYPE (type)), \n+\t\t\t       fns, 0);\n \t\n \tif (fn == error_mark_node)\n \t  return error_mark_node;\n@@ -1908,7 +1946,7 @@ coerce_template_parms (parms, arglist, in_decl,\n \t       conversions can occur is part of determining which\n \t       function template to call, or whether a given epxlicit\n \t       argument specification is legal.  */\n-\t    val = convert_nontype_parameter (t, arg);\n+\t    val = convert_nontype_argument (t, arg);\n \t  else\n \t    val = arg;\n \n@@ -1999,7 +2037,14 @@ mangle_class_name_for_template (name, parms, arglist, ctx)\n \n   if (ctx)\n     {\n-      char* s = fndecl_as_string(ctx, 0);\n+      char* s;\n+\n+      if (TREE_CODE (ctx) == FUNCTION_DECL)\n+\ts = fndecl_as_string(ctx, 0);\n+      else if (TREE_CODE_CLASS (TREE_CODE (ctx)) == 't')\n+\ts = type_as_string(ctx, 0);\n+      else\n+\tmy_friendly_abort (0);\n       cat (s);\n       cat (\"::\");\n     }\n@@ -2079,9 +2124,7 @@ classtype_mangled_name (t)\n       char *mangled_name = mangle_class_name_for_template\n \t(IDENTIFIER_POINTER (name),\n \t DECL_INNERMOST_TEMPLATE_PARMS (CLASSTYPE_TI_TEMPLATE (t)),\n-\t CLASSTYPE_TI_ARGS (t), \n-\t (DECL_CONTEXT (t) && TREE_CODE (t) == FUNCTION_DECL) ? \n-\t DECL_CONTEXT (t) : NULL_TREE);\n+\t CLASSTYPE_TI_ARGS (t), DECL_CONTEXT (t));\n       tree id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = name;\n       return id;\n@@ -2150,10 +2193,10 @@ lookup_template_function (fns, arglist)\n    being instantiated.  */\n \n tree\n-lookup_template_class (d1, arglist, in_decl, function_context)\n+lookup_template_class (d1, arglist, in_decl, context)\n      tree d1, arglist;\n      tree in_decl;\n-     tree function_context;\n+     tree context;\n {\n   tree template, parmlist;\n   char *mangled_name;\n@@ -2220,7 +2263,9 @@ lookup_template_class (d1, arglist, in_decl, function_context)\n       TYPE_SIZE (parm) = 0;\n       return parm;\n     }\n-  else if (PRIMARY_TEMPLATE_P (template))\n+  else if (PRIMARY_TEMPLATE_P (template)\n+\t   || (TREE_CODE (TYPE_CONTEXT (TREE_TYPE (template))) \n+\t       == FUNCTION_DECL))\n     {\n       parmlist = DECL_INNERMOST_TEMPLATE_PARMS (template);\n \n@@ -2258,22 +2303,22 @@ lookup_template_class (d1, arglist, in_decl, function_context)\n       mangled_name = mangle_class_name_for_template (IDENTIFIER_POINTER (d1),\n \t\t\t\t\t\t     parmlist,\n \t\t\t\t\t\t     arglist,\n-\t\t\t\t\t\t     function_context);\n+\t\t\t\t\t\t     context);\n       id = get_identifier (mangled_name);\n       IDENTIFIER_TEMPLATE (id) = d1;\n \n       maybe_push_to_top_level (uses_template_parms (arglist));\n       t = xref_tag_from_type (TREE_TYPE (template), id, 1);\n \n-      if (function_context != NULL_TREE)\n+      if (context != NULL_TREE)\n \t{\n \t  /* Set up the context for the type_decl correctly.  Note\n \t     that we must clear DECL_ASSEMBLER_NAME to fool\n \t     build_overload_name into creating a new name.  */\n \t  tree type_decl = TYPE_STUB_DECL (t);\n \n-\t  TYPE_CONTEXT (t) = function_context;\n-\t  DECL_CONTEXT (type_decl) = function_context;\n+\t  TYPE_CONTEXT (t) = context;\n+\t  DECL_CONTEXT (type_decl) = context;\n \t  DECL_ASSEMBLER_NAME (type_decl) = DECL_NAME (type_decl);\n \t  DECL_ASSEMBLER_NAME (type_decl) = \n \t    get_identifier (build_overload_name (t, 1, 1));\n@@ -2975,8 +3020,8 @@ tsubst (t, args, nargs, in_decl)\n \t  tree context;\n \t  tree r;\n \n-\t  context = (TYPE_CONTEXT (t) \n-\t\t     && TREE_CODE (TYPE_CONTEXT (t)) == FUNCTION_DECL)\n+\t  context = \n+\t    TYPE_CONTEXT (t) \n \t    ? tsubst (TYPE_CONTEXT (t), args, nargs, in_decl) : NULL_TREE;\n \n \t  r = lookup_template_class (t, argvec, in_decl, context);\n@@ -3090,7 +3135,8 @@ tsubst (t, args, nargs, in_decl)\n \t\t\t  arg = TYPE_NAME (arg);\n \n \t\t\tr = lookup_template_class (DECL_NAME (arg), \n-\t\t\t\t\t\t   argvec, in_decl, NULL_TREE);\n+\t\t\t\t\t\t   argvec, in_decl, \n+\t\t\t\t\t\t   DECL_CONTEXT (arg));\n \t\t\treturn cp_build_type_variant (r, TYPE_READONLY (t),\n \t\t\t\t\t\t      TYPE_VOLATILE (t));\n \t\t      }\n@@ -3261,6 +3307,7 @@ tsubst (t, args, nargs, in_decl)\n \n \tr = copy_node (t);\n \tcopy_lang_decl (r);\n+\tDECL_USE_TEMPLATE (r) = 0;\n \tTREE_TYPE (r) = type;\n \n \tDECL_CONTEXT (r)\n@@ -3455,12 +3502,13 @@ tsubst (t, args, nargs, in_decl)\n \n \t    DECL_TEMPLATE_INFO (r) = perm_tree_cons (tmpl, argvec, NULL_TREE);\n \n-\t    /* If we have a preexisting version of this function, don't expand\n-\t       the template version, use the other instead.  */\n-\t    if (TREE_STATIC (r) || \n-\t\t(DECL_TEMPLATE_SPECIALIZATION (r) &&\n-\t\t /* FIXME: Explain this condition.  */\n-\t\t !DECL_TEMPLATE_SPECIALIZATION (tmpl)))\n+\t    /* If we're not using ANSI overloading, then we might have\n+\t       called duplicate_decls above, and gotten back an\n+\t       preexisting version of this function.  We treat such a\n+\t       function as a specialization.  Otherwise, we cleared\n+\t       both TREE_STATIC and DECL_TEMPLATE_SPECIALIZATION, so\n+\t       this condition will be false.  */\n+\t    if (TREE_STATIC (r) || DECL_TEMPLATE_SPECIALIZATION (r))\n \t      SET_DECL_TEMPLATE_SPECIALIZATION (r);\n \t    else\n \t      SET_DECL_IMPLICIT_INSTANTIATION (r);\n@@ -5113,26 +5161,27 @@ mark_decl_instantiated (result, extern_p)\n     mark_inline_for_output (result);\n }\n \n-/* Given two function templates PAT1 and PAT2, return:\n+/* Given two function templates PAT1 and PAT2, and explicit template\n+   arguments EXPLICIT_ARGS return:\n \n    1 if PAT1 is more specialized than PAT2 as described in [temp.func.order].\n    -1 if PAT2 is more specialized than PAT1.\n    0 if neither is more specialized.  */\n    \n int\n-more_specialized (pat1, pat2)\n-     tree pat1, pat2;\n+more_specialized (pat1, pat2, explicit_args)\n+     tree pat1, pat2, explicit_args;\n {\n   tree targs;\n   int winner = 0;\n \n-  targs = get_bindings (pat1, pat2);\n+  targs = get_bindings (pat1, pat2, explicit_args);\n   if (targs)\n     {\n       --winner;\n     }\n \n-  targs = get_bindings (pat2, pat1);\n+  targs = get_bindings (pat2, pat1, explicit_args);\n   if (targs)\n     {\n       ++winner;\n@@ -5168,24 +5217,37 @@ more_specialized_class (pat1, pat2)\n }\n \n /* Return the template arguments that will produce the function signature\n-   DECL from the function template FN.  */\n+   DECL from the function template FN, with the explicit template\n+   arguments EXPLICIT_ARGS.  */\n \n tree \n-get_bindings (fn, decl)\n-     tree fn, decl;\n+get_bindings (fn, decl, explicit_args)\n+     tree fn, decl, explicit_args;\n {\n   int ntparms = DECL_NTPARMS (fn);\n   tree targs = make_scratch_vec (ntparms);\n   int i;\n \n-  i = fn_type_unification (fn, NULL_TREE, targs, \n+  i = fn_type_unification (fn, explicit_args, targs, \n \t\t\t   TYPE_ARG_TYPES (TREE_TYPE (decl)), \n \t\t\t   TREE_TYPE (TREE_TYPE (decl)),\n \t\t\t   1);\n \n   if (i == 0)\n-    return targs;\n-  return 0;\n+    {\n+      /* Check to see that the resulting return type is also OK.  */\n+      tree t = tsubst (TREE_TYPE (TREE_TYPE (fn)),\n+\t\t       targs,\n+\t\t       DECL_NTPARMS (fn),\n+\t\t       NULL_TREE);\n+\n+      if (!comptypes(t, TREE_TYPE (TREE_TYPE (decl)), 1))\n+\treturn NULL_TREE;\n+\n+      return targs;\n+    }\n+\n+  return NULL_TREE;\n }\n \n static tree\n@@ -5216,18 +5278,19 @@ get_class_bindings (tparms, parms, args)\n }\n \n /* Return the most specialized of the list of templates in FNS that can\n-   produce an instantiation matching DECL.  */\n+   produce an instantiation matching DECL, given the explicit template\n+   arguments EXPLICIT_ARGS.  */\n \n tree\n-most_specialized (fns, decl)\n-     tree fns, decl;\n+most_specialized (fns, decl, explicit_args)\n+     tree fns, decl, explicit_args;\n {\n   tree fn, champ, args, *p;\n   int fate;\n \n   for (p = &fns; *p; )\n     {\n-      args = get_bindings (TREE_VALUE (*p), decl);\n+      args = get_bindings (TREE_VALUE (*p), decl, explicit_args);\n       if (args)\n \t{\n \t  p = &TREE_CHAIN (*p);\n@@ -5244,7 +5307,7 @@ most_specialized (fns, decl)\n   fn = TREE_CHAIN (fn);\n   for (; fn; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (champ, TREE_VALUE (fn));\n+      fate = more_specialized (champ, TREE_VALUE (fn), explicit_args);\n       if (fate == 1)\n \t;\n       else\n@@ -5261,7 +5324,7 @@ most_specialized (fns, decl)\n \n   for (fn = fns; fn && TREE_VALUE (fn) != champ; fn = TREE_CHAIN (fn))\n     {\n-      fate = more_specialized (champ, TREE_VALUE (fn));\n+      fate = more_specialized (champ, TREE_VALUE (fn), explicit_args);\n       if (fate != 1)\n \treturn error_mark_node;\n     }\n@@ -5333,7 +5396,6 @@ do_decl_instantiation (declspecs, declarator, storage)\n   tree fn;\n   tree result = NULL_TREE;\n   int extern_p = 0;\n-  tree templates = NULL_TREE;\n \n   if (! DECL_LANG_SPECIFIC (decl))\n     {\n@@ -5353,59 +5415,8 @@ do_decl_instantiation (declspecs, declarator, storage)\n       cp_error (\"explicit instantiation of `%#D'\", decl);\n       return;\n     }\n-  else if (DECL_FUNCTION_MEMBER_P (decl))\n-    {\n-      if (DECL_TEMPLATE_INSTANTIATION (decl) && DECL_RTL (decl))\n-\tresult = decl;\n-      else if (name = DECL_ASSEMBLER_NAME (decl),\n-\t       fn = IDENTIFIER_GLOBAL_VALUE (name),\n-\t       fn && DECL_TEMPLATE_INSTANTIATION (fn)\n-\t       && DECL_RTL (fn))\n-\tresult = fn;\n-      else \n-\t{\n-\t  /* Maybe this is an instantiation of a member template\n-\t     function.  */\n-\t  tree ctype = DECL_CONTEXT (decl);\n-\n-\t  name = DECL_NAME (decl);\n-\t  fn = lookup_fnfields (TYPE_BINFO (ctype), name, 1);\n-\t  if (fn)\n-\t    fn = TREE_VALUE (fn);\n-\n-\t  for (; fn; fn = DECL_CHAIN (fn))\n-\t    if (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t      templates = decl_tree_cons (NULL_TREE, fn, templates);\n-\t}\n-    }\n-  else if (name = DECL_NAME (decl), fn = IDENTIFIER_GLOBAL_VALUE (name), fn)\n-    {\n-      for (fn = get_first_fn (fn); fn; fn = DECL_CHAIN (fn))\n-\tif (TREE_CODE (fn) == TEMPLATE_DECL)\n-\t  templates = decl_tree_cons (NULL_TREE, fn, templates);\n-    }\n-\n-  if (templates && !result)\n-    {\n-      tree args;\n-      result = most_specialized (templates, decl);\n-      if (result == error_mark_node)\n-\t{\n-\t  char *str = \"candidates are:\";\n-\t  cp_error (\"ambiguous template instantiation for `%D' requested\", decl);\n-\t  for (fn = templates; fn; fn = TREE_CHAIN (fn))\n-\t    {\n-\t      cp_error_at (\"%s %+#D\", str, TREE_VALUE (fn));\n-\t      str = \"               \";\n-\t    }\n-\t  return;\n-\t}\n-      else if (result)\n-\t{\n-\t  args = get_bindings (result, decl);\n-\t  result = instantiate_template (result, args);\n-\t}\n-    }\n+  else if (DECL_TEMPLATE_INSTANTIATION (decl))\n+    result = decl;\n \n   if (! result)\n     {\n@@ -5822,7 +5833,7 @@ add_maybe_template (d, fns)\n   if (DECL_MAYBE_TEMPLATE (d))\n     return;\n \n-  t = most_specialized (fns, d);\n+  t = most_specialized (fns, d, NULL_TREE);\n   if (! t)\n     return;\n   if (t == error_mark_node)"}, {"sha": "94fa1ea2432b3b60c9cd04bb434623025b38dfa8", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1316,16 +1316,8 @@ int\n really_overloaded_fn (x)\n      tree x;\n {     \n-  if (TREE_CODE (x) == TEMPLATE_ID_EXPR\n-      || DECL_FUNCTION_TEMPLATE_P (x))\n-    return 1;\n-\n-  if (TREE_CODE (x) == TREE_LIST\n-      && (TREE_CODE (TREE_VALUE (x)) == FUNCTION_DECL\n-\t  || DECL_FUNCTION_TEMPLATE_P (TREE_VALUE (x))))\n-    return 1;\n-\n-  return 0;\n+  return TREE_CODE (x) != FUNCTION_DECL \n+    && is_overloaded_fn (x);\n }\n \n tree"}, {"sha": "80795d9be983d9c942ab3339eda4d302aa8b08fd", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1467ff26b70f3475d37606d391e3b458dec4798/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e1467ff26b70f3475d37606d391e3b458dec4798", "patch": "@@ -1823,6 +1823,11 @@ build_component_ref (datum, component, basetype_path, protect)\n \t build_component_ref (TREE_OPERAND (datum, 2), component,\n \t\t\t      basetype_path, protect));\n \n+    case TEMPLATE_DECL:\n+      cp_error (\"invalid use of %D\", datum);\n+      datum = error_mark_node;\n+      break;\n+\n     default:\n       break;\n     }"}]}