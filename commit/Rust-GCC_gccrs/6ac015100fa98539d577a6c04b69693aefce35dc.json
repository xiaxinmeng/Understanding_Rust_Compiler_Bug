{"sha": "6ac015100fa98539d577a6c04b69693aefce35dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmFjMDE1MTAwZmE5ODUzOWQ1NzdhNmMwNGI2OTY5M2FlZmNlMzVkYw==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@google.com", "date": "2007-02-13T22:34:45Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2007-02-13T22:34:45Z"}, "message": "common.opt: Add Wstrict-overflow and Wstrict-overflow=.\n\n./:\t* common.opt: Add Wstrict-overflow and Wstrict-overflow=.\n\t* flags.h (warn_strict_overflow): Declare.\n\t(enum warn_strict_overflow_code): Define.\n\t(issue_strict_overflow_warning): New static inline function.\n\t* opts.c (warn_strict_overflow): New variable.\n\t(common_handle_option): Handle OPT_Wstrict_overflow and\n\tOPT_Wstrict_overflow_.\n\t* c-opts.c (c_common_handle_option): Set warn_strict_overflow for\n\tOPT_Wall.\n\t* fold-const.c: Include intl.h.\n\t(fold_deferring_overflow_warnings): New static variable.\n\t(fold_deferred_overflow_warning): New static variable.\n\t(fold_deferred_overflow_code): New static variable.\n\t(fold_defer_overflow_warnings): New function.\n\t(fold_undefer_overflow_warnings): New function.\n\t(fold_undefer_and_ignore_overflow_warnings): New function.\n\t(fold_deferring_overflow_warnings_p): New function.\n\t(fold_overflow_warning): New static function.\n\t(make_range): Add strict_overflow_p parameter.  Change all\n\tcallers.\n\t(extract_muldiv, extract_muldiv_1): Likewise.\n\t(fold_unary) [ABS_EXPR]: Check ABS_EXPR before calling\n\ttree_expr_nonnegative_p.\n\t(fold_negate_expr): Call fold_overflow_warning.\n\t(fold_range_test): Likewise.\n\t(fold_comparison): Likewise.\n\t(fold_binary): Likewise.  Call tree_expr_nonnegative_warnv_p\n\tinstead of tree_expr_nonnegative_p.\n\t(tree_expr_nonnegative_warnv_p): Rename from\n\ttree_expr_nonnegative_p, add strict_overflow_p parameter.\n\t(tree_expr_nonnegative_p): New function.\n\t(tree_expr_nonzero_warnv_p): Rename from tree_expr_nonzero_p, add\n\tstrict_overflow_p parameter.\n\t(tree_expr_nonzero_p): New function.\n\t* passes.c (verify_interpass_invariants): New static function.\n\t(execute_one_pass): Call it.\n\t* tree-ssa-loop-niter.c (expand_simple_operations): Ignore fold\n\twarnings.\n\t(number_of_iterations_exit, loop_niter_by_eval): Likewise.\n\t(estimate_numbers_of_iterations): Likewise.\n\t(scev_probably_wraps_p): Likewise.\n\t* tree-ssa-ccp.c: Include \"toplev.h\".\n\t(evaluate_stmt): Defer fold overflow warnings until we know we are\n\tgoing to optimize.\n\t(struct fold_stmt_r_data): Add stmt field.\n\t(fold_stmt_r): Defer fold overflow warnings until we know we\n\toptimized.\n\t(fold_stmt): Initialize stmt field of fold_stmt_r_data.\n\t(fold_stmt_inplace): Likewise.\n\t* tree-cfgcleanup.c: Include \"toplev.h\" rather than \"errors.h\".\n\t(cleanup_control_expr_graph): Defer fold overflow warnings until\n\twe know we are going to optimize.\n\t* tree-cfg.c (fold_cond_expr_cond): Likewise.\n\t* tree-ssa-threadedge.c (simplify_control_stmt_condition):\n\tLikewise.\n\t* tree-vrp.c (vrp_expr_computes_nonnegative): Call\n\ttree_expr_nonnegative_warnv_p instead of tree_expr_nonnegative_p.\n\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n\t* c-typeck.c (build_conditional_expr): Likewise.\n\t(build_binary_op): Likewise.\n\t* tree-vrp.c (vrp_expr_computes_nonzero): Call\n\ttree_expr_nonzero_warnv_p instead of tree_expr_nonzero_p.\n\t(extract_range_from_unary_expr): Likewise.\n\t* simplify-rtx.c (simplify_const_relational_operation): Warn when\n\tassuming that signed overflow does not occur.\n\t* c-common.c (pointer_int_sum): Ignore fold overflow warnings.\n\t* tree.h (tree_expr_nonnegative_warnv_p): Declare.\n\t(fold_defer_overflow_warnings): Declare.\n\t(fold_undefer_overflow_warnings): Declare.\n\t(fold_undefer_and_ignore_overflow_warnings): Declare.\n\t(fold_deferring_overflow_warnings_p): Declare.\n\t(tree_expr_nonzero_warnv_p): Declare.\n\t* doc/invoke.texi (Option Summary): Add -Wstrict-overflow to list\n\tof warning options.\n\t(Warning Options): Document -Wstrict-overflow.\n\t* Makefile.in (tree-ssa-threadedge.o): Depend on toplev.h.\n\t(tree-ssa-ccp.o): Likewise.\n\t(tree-cfgcleanup.o): Change errors.h dependency to toplev.h.\n\t(fold-const.o): Depend on intl.h.\ntestsuite/:\n\t* gcc.dg/Wstrict-overflow-1.c: New test.\n\t* gcc.dg/Wstrict-overflow-2.c: New test.\n\t* gcc.dg/Wstrict-overflow-3.c: New test.\n\t* gcc.dg/Wstrict-overflow-4.c: New test.\n\t* gcc.dg/Wstrict-overflow-5.c: New test.\n\t* gcc.dg/Wstrict-overflow-6.c: New test.\n\t* gcc.dg/Wstrict-overflow-7.c: New test.\n\t* gcc.dg/Wstrict-overflow-8.c: New test.\n\t* gcc.dg/Wstrict-overflow-9.c: New test.\n\t* gcc.dg/Wstrict-overflow-10.c: New test.\n\nFrom-SVN: r121895", "tree": {"sha": "120377355d73c96495ca9008ae2e8dd5c40948af", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/120377355d73c96495ca9008ae2e8dd5c40948af"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6ac015100fa98539d577a6c04b69693aefce35dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac015100fa98539d577a6c04b69693aefce35dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac015100fa98539d577a6c04b69693aefce35dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac015100fa98539d577a6c04b69693aefce35dc/comments", "author": null, "committer": null, "parents": [{"sha": "30d18db4847eb0995d65531e117c7fe75d1fc428", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d18db4847eb0995d65531e117c7fe75d1fc428", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d18db4847eb0995d65531e117c7fe75d1fc428"}], "stats": {"total": 1318, "additions": 1139, "deletions": 179}, "files": [{"sha": "4c6f08466c6ac4233b8db461a21e175e15e07ba7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,3 +1,85 @@\n+2007-02-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* common.opt: Add Wstrict-overflow and Wstrict-overflow=.\n+\t* flags.h (warn_strict_overflow): Declare.\n+\t(enum warn_strict_overflow_code): Define.\n+\t(issue_strict_overflow_warning): New static inline function.\n+\t* opts.c (warn_strict_overflow): New variable.\n+\t(common_handle_option): Handle OPT_Wstrict_overflow and\n+\tOPT_Wstrict_overflow_.\n+\t* c-opts.c (c_common_handle_option): Set warn_strict_overflow for\n+\tOPT_Wall.\n+\t* fold-const.c: Include intl.h.\n+\t(fold_deferring_overflow_warnings): New static variable.\n+\t(fold_deferred_overflow_warning): New static variable.\n+\t(fold_deferred_overflow_code): New static variable.\n+\t(fold_defer_overflow_warnings): New function.\n+\t(fold_undefer_overflow_warnings): New function.\n+\t(fold_undefer_and_ignore_overflow_warnings): New function.\n+\t(fold_deferring_overflow_warnings_p): New function.\n+\t(fold_overflow_warning): New static function.\n+\t(make_range): Add strict_overflow_p parameter.  Change all\n+\tcallers.\n+\t(extract_muldiv, extract_muldiv_1): Likewise.\n+\t(fold_unary) [ABS_EXPR]: Check ABS_EXPR before calling\n+\ttree_expr_nonnegative_p.\n+\t(fold_negate_expr): Call fold_overflow_warning.\n+\t(fold_range_test): Likewise.\n+\t(fold_comparison): Likewise.\n+\t(fold_binary): Likewise.  Call tree_expr_nonnegative_warnv_p\n+\tinstead of tree_expr_nonnegative_p.\n+\t(tree_expr_nonnegative_warnv_p): Rename from\n+\ttree_expr_nonnegative_p, add strict_overflow_p parameter.\n+\t(tree_expr_nonnegative_p): New function.\n+\t(tree_expr_nonzero_warnv_p): Rename from tree_expr_nonzero_p, add\n+\tstrict_overflow_p parameter.\n+\t(tree_expr_nonzero_p): New function.\n+\t* passes.c (verify_interpass_invariants): New static function.\n+\t(execute_one_pass): Call it.\n+\t* tree-ssa-loop-niter.c (expand_simple_operations): Ignore fold\n+\twarnings.\n+\t(number_of_iterations_exit, loop_niter_by_eval): Likewise.\n+\t(estimate_numbers_of_iterations): Likewise.\n+\t(scev_probably_wraps_p): Likewise.\n+\t* tree-ssa-ccp.c: Include \"toplev.h\".\n+\t(evaluate_stmt): Defer fold overflow warnings until we know we are\n+\tgoing to optimize.\n+\t(struct fold_stmt_r_data): Add stmt field.\n+\t(fold_stmt_r): Defer fold overflow warnings until we know we\n+\toptimized.\n+\t(fold_stmt): Initialize stmt field of fold_stmt_r_data.\n+\t(fold_stmt_inplace): Likewise.\n+\t* tree-cfgcleanup.c: Include \"toplev.h\" rather than \"errors.h\".\n+\t(cleanup_control_expr_graph): Defer fold overflow warnings until\n+\twe know we are going to optimize.\n+\t* tree-cfg.c (fold_cond_expr_cond): Likewise.\n+\t* tree-ssa-threadedge.c (simplify_control_stmt_condition):\n+\tLikewise.\n+\t* tree-vrp.c (vrp_expr_computes_nonnegative): Call\n+\ttree_expr_nonnegative_warnv_p instead of tree_expr_nonnegative_p.\n+\t* tree-ssa-loop-manip.c (create_iv): Likewise.\n+\t* c-typeck.c (build_conditional_expr): Likewise.\n+\t(build_binary_op): Likewise.\n+\t* tree-vrp.c (vrp_expr_computes_nonzero): Call\n+\ttree_expr_nonzero_warnv_p instead of tree_expr_nonzero_p.\n+\t(extract_range_from_unary_expr): Likewise.\n+\t* simplify-rtx.c (simplify_const_relational_operation): Warn when\n+\tassuming that signed overflow does not occur.\n+\t* c-common.c (pointer_int_sum): Ignore fold overflow warnings.\n+\t* tree.h (tree_expr_nonnegative_warnv_p): Declare.\n+\t(fold_defer_overflow_warnings): Declare.\n+\t(fold_undefer_overflow_warnings): Declare.\n+\t(fold_undefer_and_ignore_overflow_warnings): Declare.\n+\t(fold_deferring_overflow_warnings_p): Declare.\n+\t(tree_expr_nonzero_warnv_p): Declare.\n+\t* doc/invoke.texi (Option Summary): Add -Wstrict-overflow to list\n+\tof warning options.\n+\t(Warning Options): Document -Wstrict-overflow.\n+\t* Makefile.in (tree-ssa-threadedge.o): Depend on toplev.h.\n+\t(tree-ssa-ccp.o): Likewise.\n+\t(tree-cfgcleanup.o): Change errors.h dependency to toplev.h.\n+\t(fold-const.o): Depend on intl.h.\n+\n 2007-02-13  Ian Lance Taylor  <iant@google.com>\n \n \tPR middle-end/30751"}, {"sha": "6ea4280d8b95aa76f29698cea8b99a552c5d58d9", "filename": "gcc/Makefile.in", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -2059,7 +2059,7 @@ tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    tree-ssa-propagate.h\n tree-cfgcleanup.o : tree-cfgcleanup.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n    $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) $(FLAGS_H) output.h \\\n-   $(DIAGNOSTIC_H) errors.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(DIAGNOSTIC_H) toplev.h $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) except.h langhooks.h $(CFGLOOP_H) tree-pass.h \\\n    $(CFGLAYOUT_H) $(BASIC_BLOCK_H) hard-reg-set.h $(HASHTAB_H) toplev.h \\\n    tree-ssa-propagate.h\n@@ -2256,7 +2256,7 @@ tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n    value-prof.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(FLAGS_H) $(REAL_H) toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) \\\n-   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H)\n+   $(GGC_H) $(TM_P_H) langhooks.h $(MD5_H) intl.h\n diagnostic.o : diagnostic.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) version.h $(TM_P_H) $(FLAGS_H) input.h toplev.h intl.h \\\n    $(DIAGNOSTIC_H) langhooks.h $(LANGHOOKS_DEF_H) diagnostic.def opts.h\n@@ -2507,7 +2507,7 @@ tree-ssa-ccp.o : tree-ssa-ccp.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n    $(DIAGNOSTIC_H) $(FUNCTION_H) $(TIMEVAR_H) $(TM_H) coretypes.h \\\n    $(TREE_DUMP_H) $(BASIC_BLOCK_H) tree-pass.h langhooks.h \\\n-   tree-ssa-propagate.h $(FLAGS_H) $(TARGET_H)\n+   tree-ssa-propagate.h $(FLAGS_H) $(TARGET_H) toplev.h\n tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n     $(TM_P_H) $(TREE_FLOW_H) $(DIAGNOSTIC_H) $(TREE_INLINE_H) \\\n     $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_GIMPLE_H) \\"}, {"sha": "0bbb439324baaaec1257d6e062fa10738ec3324b", "filename": "gcc/c-common.c", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -2543,7 +2543,7 @@ shorten_compare (tree *op0_ptr, tree *op1_ptr, tree *restype_ptr,\n tree\n pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n {\n-  tree size_exp;\n+  tree size_exp, ret;\n \n   /* The result is a pointer of the same type that is being added.  */\n \n@@ -2570,6 +2570,12 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n   else\n     size_exp = size_in_bytes (TREE_TYPE (result_type));\n \n+  /* We are manipulating pointer values, so we don't need to warn\n+     about relying on undefined signed overflow.  We disable the\n+     warning here because we use integer types so fold won't know that\n+     they are really pointers.  */\n+  fold_defer_overflow_warnings ();\n+\n   /* If what we are about to multiply by the size of the elements\n      contains a constant term, apply distributive law\n      and multiply that constant term separately.\n@@ -2618,7 +2624,11 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n-  return fold_build2 (resultcode, result_type, ptrop, intop);\n+  ret = fold_build2 (resultcode, result_type, ptrop, intop);\n+\n+  fold_undefer_and_ignore_overflow_warnings ();\n+\n+  return ret;\n }\n \f\n /* Return whether EXPR is a declaration whose address can never be"}, {"sha": "9ac433a4f3a5c31ed3167edd44262200712d3e68", "filename": "gcc/c-opts.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,5 +1,6 @@\n /* C/ObjC/C++ command line option handling.\n-   Copyright (C) 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n    Contributed by Neil Booth.\n \n This file is part of GCC.\n@@ -394,6 +395,7 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n \twarn_sign_compare = value;\n       warn_switch = value;\n       warn_strict_aliasing = value;\n+      warn_strict_overflow = value;\n       warn_string_literal_comparison = value;\n       warn_always_true = value;\n       warn_array_bounds = value;"}, {"sha": "28ce2baf1633ef801c18272efa2932dedfc0b454", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -3270,6 +3270,8 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \n \t  if (unsigned_op1 ^ unsigned_op2)\n \t    {\n+\t      bool ovf;\n+\n \t      /* Do not warn if the result type is signed, since the\n \t\t signed type will only be chosen if it can represent\n \t\t all the values of the unsigned type.  */\n@@ -3278,8 +3280,10 @@ build_conditional_expr (tree ifexp, tree op1, tree op2)\n \t      /* Do not warn if the signed quantity is an unsuffixed\n \t\t integer literal (or some static constant expression\n \t\t involving such literals) and it is non-negative.  */\n-\t      else if ((unsigned_op2 && tree_expr_nonnegative_p (op1))\n-\t\t       || (unsigned_op1 && tree_expr_nonnegative_p (op2)))\n+\t      else if ((unsigned_op2\n+\t\t\t&& tree_expr_nonnegative_warnv_p (op1, &ovf))\n+\t\t       || (unsigned_op1\n+\t\t\t   && tree_expr_nonnegative_warnv_p (op2, &ovf)))\n \t\t/* OK */;\n \t      else\n \t\twarning (0, \"signed and unsigned type in conditional expression\");\n@@ -8303,6 +8307,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t      else\n \t\t{\n \t\t  tree sop, uop;\n+\t\t  bool ovf;\n \n \t\t  if (op0_signed)\n \t\t    sop = xop0, uop = xop1;\n@@ -8314,7 +8319,7 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \t\t     constant expression involving such literals or a\n \t\t     conditional expression involving such literals)\n \t\t     and it is non-negative.  */\n-\t\t  if (tree_expr_nonnegative_p (sop))\n+\t\t  if (tree_expr_nonnegative_warnv_p (sop, &ovf))\n \t\t    /* OK */;\n \t\t  /* Do not warn if the comparison is an equality operation,\n \t\t     the unsigned quantity is an integral constant, and it"}, {"sha": "c6a95574be943639c7414b02dc7e61cb493cb63b", "filename": "gcc/common.opt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -158,6 +158,14 @@ Wstrict-aliasing=\n Common Joined UInteger Warning\n Warn about code which might break strict aliasing rules\n \n+Wstrict-overflow\n+Common\n+Warn about optimizations that assume that signed overflow is undefined\n+\n+Wstrict-overflow=\n+Common Joined UInteger\n+Warn about optimizations that assume that signed overflow is undefined\n+\n Wstring-literal-comparison\n Common Var(warn_string_literal_comparison) Warning\n Warn about comparisons to constant string literals"}, {"sha": "8e811936fef3539bf3e731e0902965896ad08547", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -248,6 +248,7 @@ Objective-C and Objective-C++ Dialects}.\n -Wreturn-type  -Wsequence-point  -Wshadow @gol\n -Wsign-compare  -Wstack-protector @gol\n -Wstrict-aliasing -Wstrict-aliasing=2 @gol\n+-Wstrict-overflow -Wstrict-overflow=@var{n} @gol\n -Wstring-literal-comparison @gol\n -Wswitch  -Wswitch-default  -Wswitch-enum @gol\n -Wsystem-headers  -Wtrigraphs  -Wundef  -Wuninitialized @gol\n@@ -2972,6 +2973,56 @@ compiler is using for optimization.  This warning catches more cases than\n @option{-Wstrict-aliasing}, but it will also give a warning for some ambiguous\n cases that are safe.\n \n+@item -Wstrict-overflow\n+@item -Wstrict-overflow=@var{n}\n+@opindex -Wstrict-overflow\n+This option is only active when @option{-fstrict-overflow} is active.\n+It warns about cases where the compiler optimizes based on the\n+assumption that signed overflow does not occur.  Note that it does not\n+warn about all cases where the code might overflow: it only warns\n+about cases where the compiler implements some optimization.  Thus\n+this warning depends on the optimization level.\n+\n+An optimization which assumes that signed overflow does not occur is\n+perfectly safe if the values of the variables involved are such that\n+overflow never does, in fact, occur.  Therefore this warning can\n+easily give a false positive: a warning about code which is not\n+actually a problem.  To help focus on important issues, several\n+warning levels are defined.\n+\n+@table @option\n+@item -Wstrict-overflow=1\n+Warn about cases which are both questionable and easy to avoid.  For\n+example: @code{x + 1 > x}; with @option{-fstrict-overflow}, the\n+compiler will simplify this to @code{1}.  @option{-Wstrict-overflow}\n+(with no level) is the same as @option{-Wstrict-overflow=1}.  This\n+level of @option{-Wstrict-overflow} is enabled by @option{-Wall};\n+higher levels are not, and must be explicitly requested.\n+\n+@item -Wstrict-overflow=2\n+Also warn about other cases where a comparison is simplified to a\n+constant.  For example: @code{abs (x) >= 0}.  This can only be\n+simplified when @option{-fstrict-overflow} is in effect, because\n+@code{abs (INT_MIN)} overflows to @code{INT_MIN}, which is less than\n+zero.\n+\n+@item -Wstrict-overflow=3\n+Also warn about other cases where a comparison is simplified.  For\n+example: @code{x + 1 > 1} will be simplified to @code{x > 0}.\n+\n+@item -Wstrict-overflow=4\n+Also warn about other simplifications not covered by the above cases.\n+For example: @code{(x * 10) / 5} will be simplified to @code{x * 2}.\n+\n+@item -Wstrict-overflow=5\n+Also warn about cases where the compiler reduces the magnitude of a\n+constant involved in a comparison.  For example: @code{x + 2 > y} will\n+be simplified to @code{x + 1 >= y}.  This is reported only at the\n+highest warning level because this simplification applies to many\n+comparisons, so this warning level will give a very large number of\n+false positives.\n+@end table\n+\n @item -Warray-bounds\n @opindex Wno-array-bounds\n @opindex Warray-bounds"}, {"sha": "1996bd1514b0c5163dc6b4bdea8d83d311baf242", "filename": "gcc/flags.h", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -114,6 +114,11 @@ extern HOST_WIDE_INT larger_than_size;\n \n extern int warn_strict_aliasing;\n \n+/* Nonzero means warn about optimizations which rely on undefined\n+   signed overflow.  */\n+\n+extern int warn_strict_overflow;\n+\n /* Temporarily suppress certain warnings.\n    This is set while reading code from a system header file.  */\n \n@@ -289,8 +294,13 @@ extern const char *flag_random_seed;\n   (TYPE_UNSIGNED (TYPE) || flag_wrapv)\n \n /* True if overflow is undefined for the given integral type.  We may\n-   optimize on the assumption that values in the type never\n-   overflow.  */\n+   optimize on the assumption that values in the type never overflow.\n+\n+   IMPORTANT NOTE: Any optimization based on TYPE_OVERFLOW_UNDEFINED\n+   must issue a warning based on warn_strict_overflow.  In some cases\n+   it will be appropriate to issue the warning immediately, and in\n+   other cases it will be appropriate to simply set a flag and let the\n+   caller decide whether a warning is appropriate or not.  */\n #define TYPE_OVERFLOW_UNDEFINED(TYPE) \\\n   (!TYPE_UNSIGNED (TYPE) && !flag_wrapv && !flag_trapv && flag_strict_overflow)\n \n@@ -299,4 +309,37 @@ extern const char *flag_random_seed;\n #define TYPE_OVERFLOW_TRAPS(TYPE) \\\n   (!TYPE_UNSIGNED (TYPE) && flag_trapv)\n \n+/* Names for the different levels of -Wstrict-overflow=N.  The numeric\n+   values here correspond to N.  */\n+\n+enum warn_strict_overflow_code\n+{\n+  /* Overflow warning that should be issued with -Wall: a questionable\n+     construct that is easy to avoid even when using macros.  Example:\n+     folding (x + CONSTANT > x) to 1.  */\n+  WARN_STRICT_OVERFLOW_ALL = 1,\n+  /* Overflow warning about folding a comparison to a constant because\n+     of undefined signed overflow, other than cases covered by\n+     WARN_STRICT_OVERFLOW_ALL.  Example: folding (abs (x) >= 0) to 1\n+     (this is false when x == INT_MIN).  */\n+  WARN_STRICT_OVERFLOW_CONDITIONAL = 2,\n+  /* Overflow warning about changes to comparisons other than folding\n+     them to a constant.  Example: folding (x + 1 > 1) to (x > 0).  */\n+  WARN_STRICT_OVERFLOW_COMPARISON = 3,\n+  /* Overflow warnings not covered by the above cases.  Example:\n+     folding ((x * 10) / 5) to (x * 2).  */\n+  WARN_STRICT_OVERFLOW_MISC = 4,\n+  /* Overflow warnings about reducing magnitude of constants in\n+     comparison.  Example: folding (x + 2 > y) to (x + 1 >= y).  */\n+  WARN_STRICT_OVERFLOW_MAGNITUDE = 5\n+};\n+\n+/* Whether to emit an overflow warning whose code is C.  */\n+\n+static inline bool\n+issue_strict_overflow_warning (enum warn_strict_overflow_code c)\n+{\n+  return warn_strict_overflow >= (int) c;\n+}\n+\n #endif /* ! GCC_FLAGS_H */"}, {"sha": "7d66736b13b6b89e8160c60cb25c2d3ab56c94cf", "filename": "gcc/fold-const.c", "status": "modified", "additions": 621, "deletions": 137, "changes": 758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -59,6 +59,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"expr.h\"\n #include \"tm_p.h\"\n #include \"toplev.h\"\n+#include \"intl.h\"\n #include \"ggc.h\"\n #include \"hashtab.h\"\n #include \"langhooks.h\"\n@@ -119,7 +120,7 @@ static int simple_operand_p (tree);\n static tree range_binop (enum tree_code, tree, tree, int, tree, int);\n static tree range_predecessor (tree);\n static tree range_successor (tree);\n-static tree make_range (tree, int *, tree *, tree *);\n+static tree make_range (tree, int *, tree *, tree *, bool *);\n static tree build_range_check (tree, tree, int, tree, tree);\n static int merge_ranges (int *, tree *, tree *, int, tree, tree, int, tree,\n \t\t\t tree);\n@@ -128,8 +129,8 @@ static tree fold_cond_expr_with_comparison (tree, tree, tree, tree);\n static tree unextend (tree, int, int, tree);\n static tree fold_truthop (enum tree_code, tree, tree, tree);\n static tree optimize_minmax_comparison (enum tree_code, tree, tree, tree);\n-static tree extract_muldiv (tree, tree, enum tree_code, tree);\n-static tree extract_muldiv_1 (tree, tree, enum tree_code, tree);\n+static tree extract_muldiv (tree, tree, enum tree_code, tree, bool *);\n+static tree extract_muldiv_1 (tree, tree, enum tree_code, tree, bool *);\n static int multiple_of_p (tree, tree, tree);\n static tree fold_binary_op_with_conditional_arg (enum tree_code, tree,\n \t\t\t\t\t\t tree, tree,\n@@ -901,6 +902,122 @@ div_if_zero_remainder (enum tree_code code, tree arg1, tree arg2)\n   return build_int_cst_wide (type, quol, quoh);\n }\n \f\n+/* This is non-zero if we should defer warnings about undefined\n+   overflow.  This facility exists because these warnings are a\n+   special case.  The code to estimate loop iterations does not want\n+   to issue any warnings, since it works with expressions which do not\n+   occur in user code.  Various bits of cleanup code call fold(), but\n+   only use the result if it has certain characteristics (e.g., is a\n+   constant); that code only wants to issue a warning if the result is\n+   used.  */\n+\n+static int fold_deferring_overflow_warnings;\n+\n+/* If a warning about undefined overflow is deferred, this is the\n+   warning.  Note that this may cause us to turn two warnings into\n+   one, but that is fine since it is sufficient to only give one\n+   warning per expression.  */\n+\n+static const char* fold_deferred_overflow_warning;\n+\n+/* If a warning about undefined overflow is deferred, this is the\n+   level at which the warning should be emitted.  */\n+\n+static enum warn_strict_overflow_code fold_deferred_overflow_code;\n+\n+/* Start deferring overflow warnings.  We could use a stack here to\n+   permit nested calls, but at present it is not necessary.  */\n+\n+void\n+fold_defer_overflow_warnings (void)\n+{\n+  ++fold_deferring_overflow_warnings;\n+}\n+\n+/* Stop deferring overflow warnings.  If there is a pending warning,\n+   and ISSUE is true, then issue the warning if appropriate.  STMT is\n+   the statement with which the warning should be associated (used for\n+   location information); STMT may be NULL.  CODE is the level of the\n+   warning--a warn_strict_overflow_code value.  This function will use\n+   the smaller of CODE and the deferred code when deciding whether to\n+   issue the warning.  CODE may be zero to mean to always use the\n+   deferred code.  */\n+\n+void\n+fold_undefer_overflow_warnings (bool issue, tree stmt, int code)\n+{\n+  const char *warnmsg;\n+  location_t locus;\n+\n+  gcc_assert (fold_deferring_overflow_warnings > 0);\n+  --fold_deferring_overflow_warnings;\n+  if (fold_deferring_overflow_warnings > 0)\n+    {\n+      if (fold_deferred_overflow_warning != NULL\n+\t  && code != 0\n+\t  && code < (int) fold_deferred_overflow_code)\n+\tfold_deferred_overflow_code = code;\n+      return;\n+    }\n+\n+  warnmsg = fold_deferred_overflow_warning;\n+  fold_deferred_overflow_warning = NULL;\n+\n+  if (!issue || warnmsg == NULL)\n+    return;\n+\n+  /* Use the smallest code level when deciding to issue the\n+     warning.  */\n+  if (code == 0 || code > (int) fold_deferred_overflow_code)\n+    code = fold_deferred_overflow_code;\n+\n+  if (!issue_strict_overflow_warning (code))\n+    return;\n+\n+  if (stmt == NULL_TREE || !expr_has_location (stmt))\n+    locus = input_location;\n+  else\n+    locus = expr_location (stmt);\n+  warning (OPT_Wstrict_overflow, \"%H%s\", &locus, warnmsg);\n+}\n+\n+/* Stop deferring overflow warnings, ignoring any deferred\n+   warnings.  */\n+\n+void\n+fold_undefer_and_ignore_overflow_warnings (void)\n+{\n+  fold_undefer_overflow_warnings (false, NULL_TREE, 0);\n+}\n+\n+/* Whether we are deferring overflow warnings.  */\n+\n+bool\n+fold_deferring_overflow_warnings_p (void)\n+{\n+  return fold_deferring_overflow_warnings > 0;\n+}\n+\n+/* This is called when we fold something based on the fact that signed\n+   overflow is undefined.  */\n+\n+static void\n+fold_overflow_warning (const char* gmsgid, enum warn_strict_overflow_code wc)\n+{\n+  gcc_assert (!flag_wrapv && !flag_trapv);\n+  if (fold_deferring_overflow_warnings > 0)\n+    {\n+      if (fold_deferred_overflow_warning == NULL\n+\t  || wc < fold_deferred_overflow_code)\n+\t{\n+\t  fold_deferred_overflow_warning = gmsgid;\n+\t  fold_deferred_overflow_code = wc;\n+\t}\n+    }\n+  else if (issue_strict_overflow_warning (wc))\n+    warning (OPT_Wstrict_overflow, gmsgid);\n+}\n+\f\n /* Return true if the built-in mathematical function specified by CODE\n    is odd, i.e. -f(x) == f(-x).  */\n \n@@ -1054,6 +1171,11 @@ negate_expr_p (tree t)\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n+      /* In general we can't negate A / B, because if A is INT_MIN and\n+\t B is 1, we may turn this into INT_MIN / -1 which is undefined\n+\t and actually traps on some architectures.  But if overflow is\n+\t undefined, we can negate, because - (INT_MIN / 1) is an\n+\t overflow.  */\n       if (INTEGRAL_TYPE_P (TREE_TYPE (t))\n \t  && !TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n         break;\n@@ -1215,16 +1337,35 @@ fold_negate_expr (tree t)\n     case FLOOR_DIV_EXPR:\n     case CEIL_DIV_EXPR:\n     case EXACT_DIV_EXPR:\n+      /* In general we can't negate A / B, because if A is INT_MIN and\n+\t B is 1, we may turn this into INT_MIN / -1 which is undefined\n+\t and actually traps on some architectures.  But if overflow is\n+\t undefined, we can negate, because - (INT_MIN / 1) is an\n+\t overflow.  */\n       if (!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n         {\n+\t  const char * const warnmsg = G_(\"assuming signed overflow does not \"\n+\t\t\t\t\t  \"occur when negating a division\");\n           tem = TREE_OPERAND (t, 1);\n           if (negate_expr_p (tem))\n-            return fold_build2 (TREE_CODE (t), type,\n-\t\t\t\tTREE_OPERAND (t, 0), negate_expr (tem));\n+\t    {\n+\t      if (INTEGRAL_TYPE_P (type)\n+\t\t  && (TREE_CODE (tem) != INTEGER_CST\n+\t\t      || integer_onep (tem)))\n+\t\tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_MISC);\n+\t      return fold_build2 (TREE_CODE (t), type,\n+\t\t\t\t  TREE_OPERAND (t, 0), negate_expr (tem));\n+\t    }\n           tem = TREE_OPERAND (t, 0);\n           if (negate_expr_p (tem))\n-            return fold_build2 (TREE_CODE (t), type,\n-\t\t\t\tnegate_expr (tem), TREE_OPERAND (t, 1));\n+\t    {\n+\t      if (INTEGRAL_TYPE_P (type)\n+\t\t  && (TREE_CODE (tem) != INTEGER_CST\n+\t\t      || tree_int_cst_equal (tem, TYPE_MIN_VALUE (type))))\n+\t\tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_MISC);\n+\t      return fold_build2 (TREE_CODE (t), type,\n+\t\t\t\t  negate_expr (tem), TREE_OPERAND (t, 1));\n+\t    }\n         }\n       break;\n \n@@ -3861,12 +4002,16 @@ range_binop (enum tree_code code, tree type, tree arg0, int upper0_p,\n \f\n /* Given EXP, a logical expression, set the range it is testing into\n    variables denoted by PIN_P, PLOW, and PHIGH.  Return the expression\n-   actually being tested.  *PLOW and *PHIGH will be made of the same type\n-   as the returned expression.  If EXP is not a comparison, we will most\n-   likely not be returning a useful value and range.  */\n+   actually being tested.  *PLOW and *PHIGH will be made of the same\n+   type as the returned expression.  If EXP is not a comparison, we\n+   will most likely not be returning a useful value and range.  Set\n+   *STRICT_OVERFLOW_P to true if the return value is only valid\n+   because signed overflow is undefined; otherwise, do not change\n+   *STRICT_OVERFLOW_P.  */\n \n static tree\n-make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n+make_range (tree exp, int *pin_p, tree *plow, tree *phigh,\n+\t    bool *strict_overflow_p)\n {\n   enum tree_code code;\n   tree arg0 = NULL_TREE, arg1 = NULL_TREE;\n@@ -4015,6 +4160,9 @@ make_range (tree exp, int *pin_p, tree *plow, tree *phigh)\n \t      || (n_high != 0 && TREE_OVERFLOW (n_high)))\n \t    break;\n \n+\t  if (TYPE_OVERFLOW_UNDEFINED (arg0_type))\n+\t    *strict_overflow_p = true;\n+\n \t  /* Check for an unsigned range which has wrapped around the maximum\n \t     value thus making n_high < n_low, and normalize it.  */\n \t  if (n_low && n_high && tree_int_cst_lt (n_high, n_low))\n@@ -4796,9 +4944,12 @@ fold_range_test (enum tree_code code, tree type, tree op0, tree op1)\n \t       || code == TRUTH_OR_EXPR);\n   int in0_p, in1_p, in_p;\n   tree low0, low1, low, high0, high1, high;\n-  tree lhs = make_range (op0, &in0_p, &low0, &high0);\n-  tree rhs = make_range (op1, &in1_p, &low1, &high1);\n+  bool strict_overflow_p = false;\n+  tree lhs = make_range (op0, &in0_p, &low0, &high0, &strict_overflow_p);\n+  tree rhs = make_range (op1, &in1_p, &low1, &high1, &strict_overflow_p);\n   tree tem;\n+  const char * const warnmsg = G_(\"assuming signed overflow does not occur \"\n+\t\t\t\t  \"when simplifying range test\");\n \n   /* If this is an OR operation, invert both sides; we will invert\n      again at the end.  */\n@@ -4816,7 +4967,11 @@ fold_range_test (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t\t lhs != 0 ? lhs\n \t\t\t\t\t : rhs != 0 ? rhs : integer_zero_node,\n \t\t\t\t\t in_p, low, high))))\n-    return or_op ? invert_truthvalue (tem) : tem;\n+    {\n+      if (strict_overflow_p)\n+\tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_COMPARISON);\n+      return or_op ? invert_truthvalue (tem) : tem;\n+    }\n \n   /* On machines where the branch cost is expensive, if this is a\n      short-circuited branch and the underlying object on both sides\n@@ -4846,9 +5001,14 @@ fold_range_test (enum tree_code code, tree type, tree op0, tree op1)\n \t      && (0 != (rhs = build_range_check (type, common,\n \t\t\t\t\t\t or_op ? ! in1_p : in1_p,\n \t\t\t\t\t\t low1, high1))))\n-\t    return build2 (code == TRUTH_ANDIF_EXPR\n-\t\t\t   ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n-\t\t\t   type, lhs, rhs);\n+\t    {\n+\t      if (strict_overflow_p)\n+\t\tfold_overflow_warning (warnmsg,\n+\t\t\t\t       WARN_STRICT_OVERFLOW_COMPARISON);\n+\t      return build2 (code == TRUTH_ANDIF_EXPR\n+\t\t\t     ? TRUTH_AND_EXPR : TRUTH_OR_EXPR,\n+\t\t\t     type, lhs, rhs);\n+\t    }\n \t}\n     }\n \n@@ -5447,10 +5607,15 @@ optimize_minmax_comparison (enum tree_code code, tree type, tree op0, tree op1)\n    addressing calculation.\n \n    If we return a non-null expression, it is an equivalent form of the\n-   original computation, but need not be in the original type.  */\n+   original computation, but need not be in the original type.\n+\n+   We set *STRICT_OVERFLOW_P to true if the return values depends on\n+   signed overflow being undefined.  Otherwise we do not change\n+   *STRICT_OVERFLOW_P.  */\n \n static tree\n-extract_muldiv (tree t, tree c, enum tree_code code, tree wide_type)\n+extract_muldiv (tree t, tree c, enum tree_code code, tree wide_type,\n+\t\tbool *strict_overflow_p)\n {\n   /* To avoid exponential search depth, refuse to allow recursion past\n      three levels.  Beyond that (1) it's highly unlikely that we'll find\n@@ -5464,14 +5629,15 @@ extract_muldiv (tree t, tree c, enum tree_code code, tree wide_type)\n     return NULL;\n \n   depth++;\n-  ret = extract_muldiv_1 (t, c, code, wide_type);\n+  ret = extract_muldiv_1 (t, c, code, wide_type, strict_overflow_p);\n   depth--;\n \n   return ret;\n }\n \n static tree\n-extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n+extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type,\n+\t\t  bool *strict_overflow_p)\n {\n   tree type = TREE_TYPE (t);\n   enum tree_code tcode = TREE_CODE (t);\n@@ -5481,6 +5647,7 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n   tree t1, t2;\n   int same_p = tcode == code;\n   tree op0 = NULL_TREE, op1 = NULL_TREE;\n+  bool sub_strict_overflow_p;\n \n   /* Don't deal with constants of zero here; they confuse the code below.  */\n   if (integer_zerop (c))\n@@ -5537,7 +5704,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t  && !TREE_OVERFLOW (t2)\n \t  && (0 != (t1 = extract_muldiv (op0, t2, code,\n \t\t\t\t\t code == MULT_EXPR\n-\t\t\t\t\t ? ctype : NULL_TREE))))\n+\t\t\t\t\t ? ctype : NULL_TREE,\n+\t\t\t\t\t strict_overflow_p))))\n \treturn t1;\n       break;\n \n@@ -5547,7 +5715,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n       if (TYPE_UNSIGNED (ctype) && !TYPE_UNSIGNED (type))\n         {\n           tree cstype = (*lang_hooks.types.signed_type) (ctype);\n-          if ((t1 = extract_muldiv (op0, c, code, cstype)) != 0)\n+          if ((t1 = extract_muldiv (op0, c, code, cstype, strict_overflow_p))\n+\t      != 0)\n             {\n               t1 = fold_build1 (tcode, cstype, fold_convert (cstype, t1));\n               return fold_convert (ctype, t1);\n@@ -5556,7 +5725,8 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n         }\n       /* FALLTHROUGH */\n     case NEGATE_EXPR:\n-      if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n+      if ((t1 = extract_muldiv (op0, c, code, wide_type, strict_overflow_p))\n+\t  != 0)\n \treturn fold_build1 (tcode, ctype, fold_convert (ctype, t1));\n       break;\n \n@@ -5567,12 +5737,16 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \tbreak;\n \n       /* MIN (a, b) / 5 -> MIN (a / 5, b / 5)  */\n-      if ((t1 = extract_muldiv (op0, c, code, wide_type)) != 0\n-\t  && (t2 = extract_muldiv (op1, c, code, wide_type)) != 0)\n+      sub_strict_overflow_p = false;\n+      if ((t1 = extract_muldiv (op0, c, code, wide_type,\n+\t\t\t\t&sub_strict_overflow_p)) != 0\n+\t  && (t2 = extract_muldiv (op1, c, code, wide_type,\n+\t\t\t\t   &sub_strict_overflow_p)) != 0)\n \t{\n \t  if (tree_int_cst_sgn (c) < 0)\n \t    tcode = (tcode == MIN_EXPR ? MAX_EXPR : MIN_EXPR);\n-\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n \t  return fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n \t\t\t      fold_convert (ctype, t2));\n \t}\n@@ -5599,24 +5773,29 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \treturn extract_muldiv (build2 (tcode == LSHIFT_EXPR\n \t\t\t\t       ? MULT_EXPR : FLOOR_DIV_EXPR,\n \t\t\t\t       ctype, fold_convert (ctype, op0), t1),\n-\t\t\t       c, code, wide_type);\n+\t\t\t       c, code, wide_type, strict_overflow_p);\n       break;\n \n     case PLUS_EXPR:  case MINUS_EXPR:\n       /* See if we can eliminate the operation on both sides.  If we can, we\n \t can return a new PLUS or MINUS.  If we can't, the only remaining\n \t cases where we can do anything are if the second operand is a\n \t constant.  */\n-      t1 = extract_muldiv (op0, c, code, wide_type);\n-      t2 = extract_muldiv (op1, c, code, wide_type);\n+      sub_strict_overflow_p = false;\n+      t1 = extract_muldiv (op0, c, code, wide_type, &sub_strict_overflow_p);\n+      t2 = extract_muldiv (op1, c, code, wide_type, &sub_strict_overflow_p);\n       if (t1 != 0 && t2 != 0\n \t  && (code == MULT_EXPR\n \t      /* If not multiplication, we can only do this if both operands\n \t\t are divisible by c.  */\n \t      || (multiple_of_p (ctype, op0, c)\n \t          && multiple_of_p (ctype, op1, c))))\n-\treturn fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n-\t\t\t    fold_convert (ctype, t2));\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t  return fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n+\t\t\t      fold_convert (ctype, t2));\n+\t}\n \n       /* If this was a subtraction, negate OP1 and set it to be an addition.\n \t This simplifies the logic below.  */\n@@ -5697,11 +5876,13 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t new operation.  Likewise for the RHS from a MULT_EXPR.  Otherwise,\n \t do something only if the second operand is a constant.  */\n       if (same_p\n-\t  && (t1 = extract_muldiv (op0, c, code, wide_type)) != 0)\n+\t  && (t1 = extract_muldiv (op0, c, code, wide_type,\n+\t\t\t\t   strict_overflow_p)) != 0)\n \treturn fold_build2 (tcode, ctype, fold_convert (ctype, t1),\n \t\t\t    fold_convert (ctype, op1));\n       else if (tcode == MULT_EXPR && code == MULT_EXPR\n-\t       && (t1 = extract_muldiv (op1, c, code, wide_type)) != 0)\n+\t       && (t1 = extract_muldiv (op1, c, code, wide_type,\n+\t\t\t\t\tstrict_overflow_p)) != 0)\n \treturn fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n \t\t\t    fold_convert (ctype, t1));\n       else if (TREE_CODE (op1) != INTEGER_CST)\n@@ -5731,15 +5912,23 @@ extract_muldiv_1 (tree t, tree c, enum tree_code code, tree wide_type)\n \t\t  && code != FLOOR_MOD_EXPR && code != ROUND_MOD_EXPR)))\n \t{\n \t  if (integer_zerop (const_binop (TRUNC_MOD_EXPR, op1, c, 0)))\n-\t    return fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n-\t\t\t\tfold_convert (ctype,\n-\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t   op1, c, 0)));\n+\t    {\n+\t      if (TYPE_OVERFLOW_UNDEFINED (ctype))\n+\t\t*strict_overflow_p = true;\n+\t      return fold_build2 (tcode, ctype, fold_convert (ctype, op0),\n+\t\t\t\t  fold_convert (ctype,\n+\t\t\t\t\t\tconst_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t     op1, c, 0)));\n+\t    }\n \t  else if (integer_zerop (const_binop (TRUNC_MOD_EXPR, c, op1, 0)))\n-\t    return fold_build2 (code, ctype, fold_convert (ctype, op0),\n-\t\t\t\tfold_convert (ctype,\n-\t\t\t\t\t      const_binop (TRUNC_DIV_EXPR,\n-\t\t\t\t\t\t\t   c, op1, 0)));\n+\t    {\n+\t      if (TYPE_OVERFLOW_UNDEFINED (ctype))\n+\t\t*strict_overflow_p = true;\n+\t      return fold_build2 (code, ctype, fold_convert (ctype, op0),\n+\t\t\t\t  fold_convert (ctype,\n+\t\t\t\t\t\tconst_binop (TRUNC_DIV_EXPR,\n+\t\t\t\t\t\t\t     c, op1, 0)));\n+\t    }\n \t}\n       break;\n \n@@ -7667,7 +7856,9 @@ fold_unary (enum tree_code code, tree type, tree op0)\n \t\t\t\t\t\t    targ0));\n \t}\n       /* ABS_EXPR<ABS_EXPR<x>> = ABS_EXPR<x> even if flag_wrapv is on.  */\n-      else if (tree_expr_nonnegative_p (arg0) || TREE_CODE (arg0) == ABS_EXPR)\n+      else if (TREE_CODE (arg0) == ABS_EXPR)\n+\treturn arg0;\n+      else if (tree_expr_nonnegative_p (arg0))\n \treturn arg0;\n \n       /* Strip sign ops from argument.  */\n@@ -7884,11 +8075,14 @@ fold_minmax (enum tree_code code, tree type, tree op0, tree op1)\n    by changing CODE to reduce the magnitude of constants involved in\n    ARG0 of the comparison.\n    Returns a canonicalized comparison tree if a simplification was\n-   possible, otherwise returns NULL_TREE.  */\n+   possible, otherwise returns NULL_TREE.\n+   Set *STRICT_OVERFLOW_P to true if the canonicalization is only\n+   valid if signed overflow is undefined.  */\n \n static tree\n maybe_canonicalize_comparison_1 (enum tree_code code, tree type,\n-\t\t\t\t tree arg0, tree arg1)\n+\t\t\t\t tree arg0, tree arg1,\n+\t\t\t\t bool *strict_overflow_p)\n {\n   enum tree_code code0 = TREE_CODE (arg0);\n   tree t, cst0 = NULL_TREE;\n@@ -7955,6 +8149,7 @@ maybe_canonicalize_comparison_1 (enum tree_code code, tree type,\n \tcode = GT_EXPR;\n       else\n \treturn NULL_TREE;\n+      *strict_overflow_p = true;\n     }\n \n   /* Now build the constant reduced in magnitude.  */\n@@ -7981,6 +8176,9 @@ maybe_canonicalize_comparison (enum tree_code code, tree type,\n \t\t\t       tree arg0, tree arg1)\n {\n   tree t;\n+  bool strict_overflow_p;\n+  const char * const warnmsg = G_(\"assuming signed overflow does not occur \"\n+\t\t\t\t  \"when reducing constant in comparison\");\n \n   /* In principle pointers also have undefined overflow behavior,\n      but that causes problems elsewhere.  */\n@@ -7989,14 +8187,25 @@ maybe_canonicalize_comparison (enum tree_code code, tree type,\n     return NULL_TREE;\n \n   /* Try canonicalization by simplifying arg0.  */\n-  t = maybe_canonicalize_comparison_1 (code, type, arg0, arg1);\n+  strict_overflow_p = false;\n+  t = maybe_canonicalize_comparison_1 (code, type, arg0, arg1,\n+\t\t\t\t       &strict_overflow_p);\n   if (t)\n-    return t;\n+    {\n+      if (strict_overflow_p)\n+\tfold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_MAGNITUDE);\n+      return t;\n+    }\n \n   /* Try canonicalization by simplifying arg1 using the swapped\n      comparison.  */\n   code = swap_tree_comparison (code);\n-  return maybe_canonicalize_comparison_1 (code, type, arg1, arg0);\n+  strict_overflow_p = false;\n+  t = maybe_canonicalize_comparison_1 (code, type, arg1, arg0,\n+\t\t\t\t       &strict_overflow_p);\n+  if (t && strict_overflow_p)\n+    fold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_MAGNITUDE);\n+  return t;\n }\n \n /* Subroutine of fold_binary.  This routine performs all of the\n@@ -8080,7 +8289,13 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n       if (TREE_CODE (lhs) == TREE_CODE (arg1)\n \t  && (TREE_CODE (lhs) != INTEGER_CST\n \t      || !TREE_OVERFLOW (lhs)))\n-\treturn fold_build2 (code, type, variable, lhs);\n+\t{\n+\t  fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t  \"when changing X +- C1 cmp C2 to \"\n+\t\t\t\t  \"X cmp C1 +- C2\"),\n+\t\t\t\t WARN_STRICT_OVERFLOW_COMPARISON);\n+\t  return fold_build2 (code, type, variable, lhs);\n+\t}\n     }\n \n   /* For comparisons of pointers we can decompose it to a compile time\n@@ -8245,6 +8460,9 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n       tree variable1 = TREE_OPERAND (arg0, 0);\n       tree variable2 = TREE_OPERAND (arg1, 0);\n       tree cst;\n+      const char * const warnmsg = G_(\"assuming signed overflow does not \"\n+\t\t\t\t      \"occur when combining constants around \"\n+\t\t\t\t      \"a comparison\");\n \n       /* Put the constant on the side where it doesn't overflow and is\n \t of lower absolute value than before.  */\n@@ -8253,20 +8471,26 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t     const2, const1, 0);\n       if (!TREE_OVERFLOW (cst)\n \t  && tree_int_cst_compare (const2, cst) == tree_int_cst_sgn (const2))\n-\treturn fold_build2 (code, type,\n-\t\t\t    variable1,\n-\t\t\t    fold_build2 (TREE_CODE (arg1), TREE_TYPE (arg1),\n-\t\t\t\t\t variable2, cst));\n+\t{\n+\t  fold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_COMPARISON);\n+\t  return fold_build2 (code, type,\n+\t\t\t      variable1,\n+\t\t\t      fold_build2 (TREE_CODE (arg1), TREE_TYPE (arg1),\n+\t\t\t\t\t   variable2, cst));\n+\t}\n \n       cst = int_const_binop (TREE_CODE (arg0) == TREE_CODE (arg1)\n \t\t\t     ? MINUS_EXPR : PLUS_EXPR,\n \t\t\t     const1, const2, 0);\n       if (!TREE_OVERFLOW (cst)\n \t  && tree_int_cst_compare (const1, cst) == tree_int_cst_sgn (const1))\n-\treturn fold_build2 (code, type,\n-\t\t\t    fold_build2 (TREE_CODE (arg0), TREE_TYPE (arg0),\n-\t\t\t\t\t variable1, cst),\n-\t\t\t    variable2);\n+\t{\n+\t  fold_overflow_warning (warnmsg, WARN_STRICT_OVERFLOW_COMPARISON);\n+\t  return fold_build2 (code, type,\n+\t\t\t      fold_build2 (TREE_CODE (arg0), TREE_TYPE (arg0),\n+\t\t\t\t\t   variable1, cst),\n+\t\t\t      variable2);\n+\t}\n     }\n \n   /* Transform comparisons of the form X * C1 CMP 0 to X CMP 0 in the\n@@ -8286,6 +8510,11 @@ fold_comparison (enum tree_code code, tree type, tree op0, tree op1)\n \n       gcc_assert (!integer_zerop (const1));\n \n+      fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n+\t\t\t      \"eliminating multiplication in comparison \"\n+\t\t\t      \"with zero\"),\n+\t\t\t     WARN_STRICT_OVERFLOW_COMPARISON);\n+\n       /* If const1 is negative we swap the sense of the comparison.  */\n       if (tree_int_cst_sgn (const1) < 0)\n         cmp_code = swap_tree_comparison (cmp_code);\n@@ -8721,6 +8950,7 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n   enum tree_code_class kind = TREE_CODE_CLASS (code);\n   tree arg0, arg1, tem;\n   tree t1 = NULL_TREE;\n+  bool strict_overflow_p;\n \n   gcc_assert ((IS_EXPR_CODE_CLASS (kind)\n \t       || IS_GIMPLE_STMT_CODE_CLASS (kind))\n@@ -9468,11 +9698,20 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    return fold_build2 (LSHIFT_EXPR, type, arg1,\n \t\t\t\tTREE_OPERAND (arg0, 1));\n \n+\t  strict_overflow_p = false;\n \t  if (TREE_CODE (arg1) == INTEGER_CST\n \t      && 0 != (tem = extract_muldiv (op0,\n \t\t\t\t\t     fold_convert (type, arg1),\n-\t\t\t\t\t     code, NULL_TREE)))\n-\t    return fold_convert (type, tem);\n+\t\t\t\t\t     code, NULL_TREE,\n+\t\t\t\t\t     &strict_overflow_p)))\n+\t    {\n+\t      if (strict_overflow_p)\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when simplifying \"\n+\t\t\t\t\t\"multiplication\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_MISC);\n+\t      return fold_convert (type, tem);\n+\t    }\n \n \t  /* Optimize z * conj(z) for integer complex numbers.  */\n \t  if (TREE_CODE (arg0) == CONJ_EXPR\n@@ -10372,15 +10611,22 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n     case FLOOR_DIV_EXPR:\n       /* Simplify A / (B << N) where A and B are positive and B is\n \t a power of 2, to A >> (N + log2(B)).  */\n+      strict_overflow_p = false;\n       if (TREE_CODE (arg1) == LSHIFT_EXPR\n-\t  && (TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (arg0)))\n+\t  && (TYPE_UNSIGNED (type)\n+\t      || tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p)))\n \t{\n \t  tree sval = TREE_OPERAND (arg1, 0);\n \t  if (integer_pow2p (sval) && tree_int_cst_sgn (sval) > 0)\n \t    {\n \t      tree sh_cnt = TREE_OPERAND (arg1, 1);\n \t      unsigned long pow2 = exact_log2 (TREE_INT_CST_LOW (sval));\n \n+\t      if (strict_overflow_p)\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when simplifying A / (B << N)\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_MISC);\n+\n \t      sh_cnt = fold_build2 (PLUS_EXPR, TREE_TYPE (sh_cnt),\n \t\t\t\t    sh_cnt, build_int_cst (NULL_TREE, pow2));\n \t      return fold_build2 (RSHIFT_EXPR, type,\n@@ -10408,13 +10654,27 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n       if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n \t  && TREE_CODE (arg0) == NEGATE_EXPR\n \t  && negate_expr_p (arg1))\n-\treturn fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n-\t\t\t    negate_expr (arg1));\n+\t{\n+\t  if (INTEGRAL_TYPE_P (type))\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when distributing negation across \"\n+\t\t\t\t    \"division\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+\t  return fold_build2 (code, type, TREE_OPERAND (arg0, 0),\n+\t\t\t      negate_expr (arg1));\n+\t}\n       if ((!INTEGRAL_TYPE_P (type) || TYPE_OVERFLOW_UNDEFINED (type))\n \t  && TREE_CODE (arg1) == NEGATE_EXPR\n \t  && negate_expr_p (arg0))\n-\treturn fold_build2 (code, type, negate_expr (arg0),\n-\t\t\t    TREE_OPERAND (arg1, 0));\n+\t{\n+\t  if (INTEGRAL_TYPE_P (type))\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when distributing negation across \"\n+\t\t\t\t    \"division\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+\t  return fold_build2 (code, type, negate_expr (arg0),\n+\t\t\t      TREE_OPERAND (arg1, 0));\n+\t}\n \n       /* If arg0 is a multiple of arg1, then rewrite to the fastest div\n \t operation, EXACT_DIV_EXPR.\n@@ -10426,9 +10686,17 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  && multiple_of_p (type, arg0, arg1))\n \treturn fold_build2 (EXACT_DIV_EXPR, type, arg0, arg1);\n \n+      strict_overflow_p = false;\n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n-\treturn fold_convert (type, tem);\n+\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n+\t\t\t\t\t &strict_overflow_p)))\n+\t{\n+\t  if (strict_overflow_p)\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when simplifying division\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+\t  return fold_convert (type, tem);\n+\t}\n \n       return NULL_TREE;\n \n@@ -10460,8 +10728,10 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \n       /* Optimize TRUNC_MOD_EXPR by a power of two into a BIT_AND_EXPR,\n          i.e. \"X % C\" into \"X & (C - 1)\", if X and C are positive.  */\n+      strict_overflow_p = false;\n       if ((code == TRUNC_MOD_EXPR || code == FLOOR_MOD_EXPR)\n-\t  && (TYPE_UNSIGNED (type) || tree_expr_nonnegative_p (arg0)))\n+\t  && (TYPE_UNSIGNED (type)\n+\t      || tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p)))\n \t{\n \t  tree c = arg1;\n \t  /* Also optimize A % (C << N)  where C is a power of 2,\n@@ -10473,6 +10743,11 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t    {\n \t      tree mask = fold_build2 (MINUS_EXPR, TREE_TYPE (arg1), arg1,\n \t\t\t\t       build_int_cst (TREE_TYPE (arg1), 1));\n+\t      if (strict_overflow_p)\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when simplifying \"\n+\t\t\t\t\t\"X % (power of two)\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_MISC);\n \t      return fold_build2 (BIT_AND_EXPR, type,\n \t\t\t\t  fold_convert (type, arg0),\n \t\t\t\t  fold_convert (type, mask));\n@@ -10500,8 +10775,15 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t    fold_convert (type, TREE_OPERAND (arg1, 0)));\n \n       if (TREE_CODE (arg1) == INTEGER_CST\n-\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE)))\n-\treturn fold_convert (type, tem);\n+\t  && 0 != (tem = extract_muldiv (op0, arg1, code, NULL_TREE,\n+\t\t\t\t\t &strict_overflow_p)))\n+\t{\n+\t  if (strict_overflow_p)\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when simplifying modulos\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+\t  return fold_convert (type, tem);\n+\t}\n \n       return NULL_TREE;\n \n@@ -11330,51 +11612,111 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t  if (code == GT_EXPR\n \t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (0, type);\n+\t    {\n+\t      if (TREE_CODE (arg01) == INTEGER_CST\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when assuming that (X - c) > X \"\n+\t\t\t\t\t\"is always false\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n+\t      return constant_boolean_node (0, type);\n+\t    }\n \n \t  /* Likewise (X + c) < X becomes false.  */\n \t  if (code == LT_EXPR\n \t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (0, type);\n+\t    {\n+\t      if (TREE_CODE (arg01) == INTEGER_CST\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when assuming that \"\n+\t\t\t\t\t\"(X + c) < X is always false\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n+\t      return constant_boolean_node (0, type);\n+\t    }\n \n \t  /* Convert (X - c) <= X to true.  */\n \t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1)))\n \t      && code == LE_EXPR\n \t      && ((code0 == MINUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == PLUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (1, type);\n+\t    {\n+\t      if (TREE_CODE (arg01) == INTEGER_CST\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when assuming that \"\n+\t\t\t\t\t\"(X - c) <= X is always true\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n+\t      return constant_boolean_node (1, type);\n+\t    }\n \n \t  /* Convert (X + c) >= X to true.  */\n \t  if (!HONOR_NANS (TYPE_MODE (TREE_TYPE (arg1)))\n \t      && code == GE_EXPR\n \t      && ((code0 == PLUS_EXPR && is_positive >= 0)\n \t\t  || (code0 == MINUS_EXPR && is_positive <= 0)))\n-\t    return constant_boolean_node (1, type);\n+\t    {\n+\t      if (TREE_CODE (arg01) == INTEGER_CST\n+\t\t  && TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\tfold_overflow_warning ((\"assuming signed overflow does not \"\n+\t\t\t\t\t\"occur when assuming that \"\n+\t\t\t\t\t\"(X + c) >= X is always true\"),\n+\t\t\t\t       WARN_STRICT_OVERFLOW_ALL);\n+\t      return constant_boolean_node (1, type);\n+\t    }\n \n \t  if (TREE_CODE (arg01) == INTEGER_CST)\n \t    {\n \t      /* Convert X + c > X and X - c < X to true for integers.  */\n \t      if (code == GT_EXPR\n \t          && ((code0 == PLUS_EXPR && is_positive > 0)\n \t\t      || (code0 == MINUS_EXPR && is_positive < 0)))\n-\t\treturn constant_boolean_node (1, type);\n+\t\t{\n+\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n+\t\t\t\t\t    \"not occur when assuming that \"\n+\t\t\t\t\t    \"(X + c) > X is always true\"),\n+\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n+\t\t  return constant_boolean_node (1, type);\n+\t\t}\n \n \t      if (code == LT_EXPR\n \t          && ((code0 == MINUS_EXPR && is_positive > 0)\n \t\t      || (code0 == PLUS_EXPR && is_positive < 0)))\n-\t\treturn constant_boolean_node (1, type);\n+\t\t{\n+\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n+\t\t\t\t\t    \"not occur when assuming that \"\n+\t\t\t\t\t    \"(X - c) < X is always true\"),\n+\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n+\t\t  return constant_boolean_node (1, type);\n+\t\t}\n \n \t      /* Convert X + c <= X and X - c >= X to false for integers.  */\n \t      if (code == LE_EXPR\n \t          && ((code0 == PLUS_EXPR && is_positive > 0)\n \t\t      || (code0 == MINUS_EXPR && is_positive < 0)))\n-\t\treturn constant_boolean_node (0, type);\n+\t\t{\n+\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n+\t\t\t\t\t    \"not occur when assuming that \"\n+\t\t\t\t\t    \"(X + c) <= X is always false\"),\n+\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n+\t\t  return constant_boolean_node (0, type);\n+\t\t}\n \n \t      if (code == GE_EXPR\n \t          && ((code0 == MINUS_EXPR && is_positive > 0)\n \t\t      || (code0 == PLUS_EXPR && is_positive < 0)))\n-\t\treturn constant_boolean_node (0, type);\n+\t\t{\n+\t\t  if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (arg1)))\n+\t\t    fold_overflow_warning ((\"assuming signed overflow does \"\n+\t\t\t\t\t    \"not occur when assuming that \"\n+\t\t\t\t\t    \"(X - c) >= X is always true\"),\n+\t\t\t\t\t   WARN_STRICT_OVERFLOW_ALL);\n+\t\t  return constant_boolean_node (0, type);\n+\t\t}\n \t    }\n \t}\n \n@@ -11575,18 +11917,34 @@ fold_binary (enum tree_code code, tree type, tree op0, tree op1)\n \t\t\t\t    TREE_OPERAND (arg0, 0), arg1));\n \n       /* Convert ABS_EXPR<x> >= 0 to true.  */\n+      strict_overflow_p = false;\n       if (code == GE_EXPR\n-\t  && tree_expr_nonnegative_p (arg0)\n \t  && (integer_zerop (arg1)\n \t      || (! HONOR_NANS (TYPE_MODE (TREE_TYPE (arg0)))\n-\t\t  && real_zerop (arg1))))\n-\treturn omit_one_operand (type, integer_one_node, arg0);\n+\t\t  && real_zerop (arg1)))\n+\t  && tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p))\n+\t{\n+\t  if (strict_overflow_p)\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when simplifying comparison of \"\n+\t\t\t\t    \"absolute value and zero\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t  return omit_one_operand (type, integer_one_node, arg0);\n+\t}\n \n       /* Convert ABS_EXPR<x> < 0 to false.  */\n+      strict_overflow_p = false;\n       if (code == LT_EXPR\n-\t  && tree_expr_nonnegative_p (arg0)\n-\t  && (integer_zerop (arg1) || real_zerop (arg1)))\n-\treturn omit_one_operand (type, integer_zero_node, arg0);\n+\t  && (integer_zerop (arg1) || real_zerop (arg1))\n+\t  && tree_expr_nonnegative_warnv_p (arg0, &strict_overflow_p))\n+\t{\n+\t  if (strict_overflow_p)\n+\t    fold_overflow_warning ((\"assuming signed overflow does not occur \"\n+\t\t\t\t    \"when simplifying comparison of \"\n+\t\t\t\t    \"absolute value and zero\"),\n+\t\t\t\t   WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t  return omit_one_operand (type, integer_zero_node, arg0);\n+\t}\n \n       /* If X is unsigned, convert X < (1 << Y) into X >> Y == 0\n \t and similarly for >= into !=.  */\n@@ -12662,10 +13020,13 @@ multiple_of_p (tree type, tree top, tree bottom)\n     }\n }\n \n-/* Return true if `t' is known to be non-negative.  */\n+/* Return true if `t' is known to be non-negative.  If the return\n+   value is based on the assumption that signed overflow is undefined,\n+   set *STRICT_OVERFLOW_P to true; otherwise, don't change\n+   *STRICT_OVERFLOW_P.  */\n \n bool\n-tree_expr_nonnegative_p (tree t)\n+tree_expr_nonnegative_warnv_p (tree t, bool *strict_overflow_p)\n {\n   if (t == error_mark_node)\n     return false;\n@@ -12686,7 +13047,10 @@ tree_expr_nonnegative_p (tree t)\n       if (!INTEGRAL_TYPE_P (TREE_TYPE (t)))\n \treturn true;\n       if (TYPE_OVERFLOW_UNDEFINED (TREE_TYPE (t)))\n-\treturn true;\n+\t{\n+\t  *strict_overflow_p = true;\n+\t  return true;\n+\t}\n       break;\n \n     case INTEGER_CST:\n@@ -12697,8 +13061,10 @@ tree_expr_nonnegative_p (tree t)\n \n     case PLUS_EXPR:\n       if (FLOAT_TYPE_P (TREE_TYPE (t)))\n-\treturn tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t       && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\treturn (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t       strict_overflow_p)\n+\t\t&& tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\t  strict_overflow_p));\n \n       /* zero_extend(x) + zero_extend(y) is non-negative if x and y are\n \t both unsigned and at least 2 bits shorter than the result.  */\n@@ -12724,8 +13090,10 @@ tree_expr_nonnegative_p (tree t)\n \t  /* x * x for floating point x is always non-negative.  */\n \t  if (operand_equal_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1), 0))\n \t    return true;\n-\t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t\t && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+\t  return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t strict_overflow_p)\n+\t\t  && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\t    strict_overflow_p));\n \t}\n \n       /* zero_extend(x) * zero_extend(y) is non-negative if x and y are\n@@ -12745,8 +13113,10 @@ tree_expr_nonnegative_p (tree t)\n \n     case BIT_AND_EXPR:\n     case MAX_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t     || tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t     strict_overflow_p)\n+\t      || tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\tstrict_overflow_p));\n \n     case BIT_IOR_EXPR:\n     case BIT_XOR_EXPR:\n@@ -12756,8 +13126,10 @@ tree_expr_nonnegative_p (tree t)\n     case CEIL_DIV_EXPR:\n     case FLOOR_DIV_EXPR:\n     case ROUND_DIV_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 1));\n+      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t     strict_overflow_p)\n+\t      && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\tstrict_overflow_p));\n \n     case TRUNC_MOD_EXPR:\n     case CEIL_MOD_EXPR:\n@@ -12766,19 +13138,24 @@ tree_expr_nonnegative_p (tree t)\n     case SAVE_EXPR:\n     case NON_LVALUE_EXPR:\n     case FLOAT_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t    strict_overflow_p);\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n     case GIMPLE_MODIFY_STMT:\n-      return tree_expr_nonnegative_p (GENERIC_TREE_OPERAND (t, 1));\n+      return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t\t\t    strict_overflow_p);\n \n     case BIND_EXPR:\n-      return tree_expr_nonnegative_p (expr_last (TREE_OPERAND (t, 1)));\n+      return tree_expr_nonnegative_warnv_p (expr_last (TREE_OPERAND (t, 1)),\n+\t\t\t\t\t    strict_overflow_p);\n \n     case COND_EXPR:\n-      return tree_expr_nonnegative_p (TREE_OPERAND (t, 1))\n-\t     && tree_expr_nonnegative_p (TREE_OPERAND (t, 2));\n+      return (tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t     strict_overflow_p)\n+\t      && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 2),\n+\t\t\t\t\t\tstrict_overflow_p));\n \n     case NOP_EXPR:\n       {\n@@ -12788,18 +13165,21 @@ tree_expr_nonnegative_p (tree t)\n \tif (TREE_CODE (outer_type) == REAL_TYPE)\n \t  {\n \t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t    strict_overflow_p);\n \t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n \t      {\n \t\tif (TYPE_UNSIGNED (inner_type))\n \t\t  return true;\n-\t\treturn tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t\treturn tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t\t      strict_overflow_p);\n \t      }\n \t  }\n \telse if (TREE_CODE (outer_type) == INTEGER_TYPE)\n \t  {\n \t    if (TREE_CODE (inner_type) == REAL_TYPE)\n-\t      return tree_expr_nonnegative_p (TREE_OPERAND (t,0));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t,0),\n+\t\t\t\t\t\t    strict_overflow_p);\n \t    if (TREE_CODE (inner_type) == INTEGER_TYPE)\n \t      return TYPE_PRECISION (inner_type) < TYPE_PRECISION (outer_type)\n \t\t      && TYPE_UNSIGNED (inner_type);\n@@ -12815,7 +13195,7 @@ tree_expr_nonnegative_p (tree t)\n \t/* If the initializer is non-void, then it's a normal expression\n \t   that will be assigned to the slot.  */\n \tif (!VOID_TYPE_P (t))\n-\t  return tree_expr_nonnegative_p (t);\n+\t  return tree_expr_nonnegative_warnv_p (t, strict_overflow_p);\n \n \t/* Otherwise, the initializer sets the slot in some way.  One common\n \t   way is an assignment statement at the end of the initializer.  */\n@@ -12834,7 +13214,8 @@ tree_expr_nonnegative_p (tree t)\n \tif ((TREE_CODE (t) == MODIFY_EXPR\n \t     || TREE_CODE (t) == GIMPLE_MODIFY_STMT)\n \t    && GENERIC_TREE_OPERAND (t, 0) == temp)\n-\t  return tree_expr_nonnegative_p (GENERIC_TREE_OPERAND (t, 1));\n+\t  return tree_expr_nonnegative_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t\t\t\tstrict_overflow_p);\n \n \treturn false;\n       }\n@@ -12870,7 +13251,8 @@ tree_expr_nonnegative_p (tree t)\n \t      /* sqrt(-0.0) is -0.0.  */\n \t      if (!HONOR_SIGNED_ZEROS (TYPE_MODE (TREE_TYPE (t))))\n \t\treturn true;\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_ASINH):\n \t    CASE_FLT_FN (BUILT_IN_ATAN):\n@@ -12900,21 +13282,30 @@ tree_expr_nonnegative_p (tree t)\n \t    CASE_FLT_FN (BUILT_IN_TANH):\n \t    CASE_FLT_FN (BUILT_IN_TRUNC):\n \t      /* True if the 1st argument is nonnegative.  */\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_FMAX):\n \t      /* True if the 1st OR 2nd arguments are nonnegative.  */\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist))\n-\t        || tree_expr_nonnegative_p (TREE_VALUE (TREE_CHAIN (arglist)));\n+\t      return (tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t     strict_overflow_p)\n+\t\t      || (tree_expr_nonnegative_warnv_p\n+\t\t\t  (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t   strict_overflow_p)));\n \n \t    CASE_FLT_FN (BUILT_IN_FMIN):\n \t      /* True if the 1st AND 2nd arguments are nonnegative.  */\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist))\n-\t        && tree_expr_nonnegative_p (TREE_VALUE (TREE_CHAIN (arglist)));\n+\t      return (tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t     strict_overflow_p)\n+\t\t      && (tree_expr_nonnegative_warnv_p\n+\t\t\t  (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\t   strict_overflow_p)));\n \n \t    CASE_FLT_FN (BUILT_IN_COPYSIGN):\n \t      /* True if the 2nd argument is nonnegative.  */\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (TREE_CHAIN (arglist)));\n+\t      return (tree_expr_nonnegative_warnv_p\n+\t\t      (TREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t       strict_overflow_p));\n \n \t    CASE_FLT_FN (BUILT_IN_POWI):\n \t      /* True if the 1st argument is nonnegative or the second\n@@ -12925,7 +13316,8 @@ tree_expr_nonnegative_p (tree t)\n \t\t  if ((TREE_INT_CST_LOW (arg1) & 1) == 0)\n \t\t    return true;\n \t\t}\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t    strict_overflow_p);\n \n \t    CASE_FLT_FN (BUILT_IN_POW):\n \t      /* True if the 1st argument is nonnegative or the second\n@@ -12946,7 +13338,8 @@ tree_expr_nonnegative_p (tree t)\n \t\t\treturn true;\n \t\t    }\n \t\t}\n-\t      return tree_expr_nonnegative_p (TREE_VALUE (arglist));\n+\t      return tree_expr_nonnegative_warnv_p (TREE_VALUE (arglist),\n+\t\t\t\t\t\t    strict_overflow_p);\n \n \t    default:\n \t      break;\n@@ -12965,14 +13358,37 @@ tree_expr_nonnegative_p (tree t)\n   return false;\n }\n \n+/* Return true if `t' is known to be non-negative.  Handle warnings\n+   about undefined signed overflow.  */\n+\n+bool\n+tree_expr_nonnegative_p (tree t)\n+{\n+  bool ret, strict_overflow_p;\n+\n+  strict_overflow_p = false;\n+  ret = tree_expr_nonnegative_warnv_p (t, &strict_overflow_p);\n+  if (strict_overflow_p)\n+    fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n+\t\t\t    \"determining that expression is always \"\n+\t\t\t    \"non-negative\"),\n+\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+  return ret;\n+}\n+\n /* Return true when T is an address and is known to be nonzero.\n    For floating point we further ensure that T is not denormal.\n-   Similar logic is present in nonzero_address in rtlanal.h.  */\n+   Similar logic is present in nonzero_address in rtlanal.h.\n+\n+   If the return value is based on the assumption that signed overflow\n+   is undefined, set *STRICT_OVERFLOW_P to true; otherwise, don't\n+   change *STRICT_OVERFLOW_P.  */\n \n bool\n-tree_expr_nonzero_p (tree t)\n+tree_expr_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n {\n   tree type = TREE_TYPE (t);\n+  bool sub_strict_overflow_p;\n \n   /* Doing something useful for floating point would need more work.  */\n   if (!INTEGRAL_TYPE_P (type) && !POINTER_TYPE_P (type))\n@@ -12986,7 +13402,8 @@ tree_expr_nonzero_p (tree t)\n       return ssa_name_nonzero_p (t);\n \n     case ABS_EXPR:\n-      return tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n+      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\tstrict_overflow_p);\n \n     case INTEGER_CST:\n       return !integer_zerop (t);\n@@ -12996,20 +13413,34 @@ tree_expr_nonzero_p (tree t)\n \t{\n \t  /* With the presence of negative values it is hard\n \t     to say something.  */\n-\t  if (!tree_expr_nonnegative_p (TREE_OPERAND (t, 0))\n-\t      || !tree_expr_nonnegative_p (TREE_OPERAND (t, 1)))\n+\t  sub_strict_overflow_p = false;\n+\t  if (!tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t      &sub_strict_overflow_p)\n+\t      || !tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\t &sub_strict_overflow_p))\n \t    return false;\n \t  /* One of operands must be positive and the other non-negative.  */\n-\t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n-\t          || tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+\t  /* We don't set *STRICT_OVERFLOW_P here: even if this value\n+\t     overflows, on a twos-complement machine the sum of two\n+\t     nonnegative numbers can never be zero.  */\n+\t  return (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t     strict_overflow_p)\n+\t          || tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\tstrict_overflow_p));\n \t}\n       break;\n \n     case MULT_EXPR:\n       if (TYPE_OVERFLOW_UNDEFINED (type))\n \t{\n-\t  return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n-\t          && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+\t  if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t strict_overflow_p)\n+\t      && tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t    strict_overflow_p))\n+\t    {\n+\t      *strict_overflow_p = true;\n+\t      return true;\n+\t    }\n \t}\n       break;\n \n@@ -13019,7 +13450,8 @@ tree_expr_nonzero_p (tree t)\n \ttree outer_type = TREE_TYPE (t);\n \n \treturn (TYPE_PRECISION (outer_type) >= TYPE_PRECISION (inner_type)\n-\t\t&& tree_expr_nonzero_p (TREE_OPERAND (t, 0)));\n+\t\t&& tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t      strict_overflow_p));\n       }\n       break;\n \n@@ -13042,42 +13474,76 @@ tree_expr_nonzero_p (tree t)\n       }\n \n     case COND_EXPR:\n-      return (tree_expr_nonzero_p (TREE_OPERAND (t, 1))\n-\t      && tree_expr_nonzero_p (TREE_OPERAND (t, 2)));\n+      sub_strict_overflow_p = false;\n+      if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t     &sub_strict_overflow_p)\n+\t  && tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 2),\n+\t\t\t\t\t&sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t  return true;\n+\t}\n+      break;\n \n     case MIN_EXPR:\n-      return (tree_expr_nonzero_p (TREE_OPERAND (t, 0))\n-\t      && tree_expr_nonzero_p (TREE_OPERAND (t, 1)));\n+      sub_strict_overflow_p = false;\n+      if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t     &sub_strict_overflow_p)\n+\t  && tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t&sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t}\n+      break;\n \n     case MAX_EXPR:\n-      if (tree_expr_nonzero_p (TREE_OPERAND (t, 0)))\n+      sub_strict_overflow_p = false;\n+      if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t     &sub_strict_overflow_p))\n \t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\n \t  /* When both operands are nonzero, then MAX must be too.  */\n-\t  if (tree_expr_nonzero_p (TREE_OPERAND (t, 1)))\n+\t  if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t strict_overflow_p))\n \t    return true;\n \n \t  /* MAX where operand 0 is positive is positive.  */\n-\t  return tree_expr_nonnegative_p (TREE_OPERAND (t, 0));\n+\t  return tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t       strict_overflow_p);\n \t}\n       /* MAX where operand 1 is positive is positive.  */\n-      else if (tree_expr_nonzero_p (TREE_OPERAND (t, 1))\n-\t       && tree_expr_nonnegative_p (TREE_OPERAND (t, 1)))\n-\treturn true;\n+      else if (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t  &sub_strict_overflow_p)\n+\t       && tree_expr_nonnegative_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\t\t &sub_strict_overflow_p))\n+\t{\n+\t  if (sub_strict_overflow_p)\n+\t    *strict_overflow_p = true;\n+\t  return true;\n+\t}\n       break;\n \n     case COMPOUND_EXPR:\n     case MODIFY_EXPR:\n     case GIMPLE_MODIFY_STMT:\n     case BIND_EXPR:\n-      return tree_expr_nonzero_p (GENERIC_TREE_OPERAND (t, 1));\n+      return tree_expr_nonzero_warnv_p (GENERIC_TREE_OPERAND (t, 1),\n+\t\t\t\t\tstrict_overflow_p);\n \n     case SAVE_EXPR:\n     case NON_LVALUE_EXPR:\n-      return tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n+      return tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\tstrict_overflow_p);\n \n     case BIT_IOR_EXPR:\n-      return tree_expr_nonzero_p (TREE_OPERAND (t, 1))\n-\t     || tree_expr_nonzero_p (TREE_OPERAND (t, 0));\n+      return (tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 1),\n+\t\t\t\t\tstrict_overflow_p)\n+\t      || tree_expr_nonzero_warnv_p (TREE_OPERAND (t, 0),\n+\t\t\t\t\t    strict_overflow_p));\n \n     case CALL_EXPR:\n       return alloca_call_p (t);\n@@ -13088,6 +13554,24 @@ tree_expr_nonzero_p (tree t)\n   return false;\n }\n \n+/* Return true when T is an address and is known to be nonzero.\n+   Handle warnings about undefined signed overflow.  */\n+\n+bool\n+tree_expr_nonzero_p (tree t)\n+{\n+  bool ret, strict_overflow_p;\n+\n+  strict_overflow_p = false;\n+  ret = tree_expr_nonzero_warnv_p (t, &strict_overflow_p);\n+  if (strict_overflow_p)\n+    fold_overflow_warning ((\"assuming signed overflow does not occur when \"\n+\t\t\t    \"determining that expression is always \"\n+\t\t\t    \"non-zero\"),\n+\t\t\t   WARN_STRICT_OVERFLOW_MISC);\n+  return ret;\n+}\n+\n /* Given the components of a binary expression CODE, TYPE, OP0 and OP1,\n    attempt to fold the expression to a constant without modifying TYPE,\n    OP0 or OP1."}, {"sha": "1361eb77922504ae34eae0d52f3468d171a7923f", "filename": "gcc/opts.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -61,6 +61,10 @@ HOST_WIDE_INT larger_than_size;\n    strict-aliasing safe.  */\n int warn_strict_aliasing;\n \n+/* Nonzero means warn about optimizations which rely on undefined\n+   signed overflow.  */\n+int warn_strict_overflow;\n+\n /* Hack for cooperation between set_Wunused and set_Wextra.  */\n static bool maybe_warn_unused_parameter;\n \n@@ -1104,6 +1108,11 @@ common_handle_option (size_t scode, const char *arg, int value,\n       warn_strict_aliasing = value;\n       break;\n \n+    case OPT_Wstrict_overflow:\n+    case OPT_Wstrict_overflow_:\n+      warn_strict_overflow = value;\n+      break;\n+\n     case OPT_Wunused:\n       set_Wunused (value);\n       break;"}, {"sha": "6f1a99d060125bcd9ac2c9bb1d82889b018d5424", "filename": "gcc/passes.c", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -952,6 +952,17 @@ execute_todo (unsigned int flags)\n     }\n }\n \n+/* Verify invariants that should hold between passes.  This is a place\n+   to put simple sanity checks.  */\n+\n+static void\n+verify_interpass_invariants (void)\n+{\n+#ifdef ENABLE_CHECKING\n+  gcc_assert (!fold_deferring_overflow_warnings_p ());\n+#endif\n+}\n+\n /* Clear the last verified flag.  */\n \n static void\n@@ -1063,6 +1074,7 @@ execute_one_pass (struct tree_opt_pass *pass)\n \n   /* Run post-pass cleanup and verification.  */\n   execute_todo (todo_after | pass->todo_flags_finish);\n+  verify_interpass_invariants ();\n \n   if (!current_function_decl)\n     cgraph_process_new_functions ();"}, {"sha": "cb1c4f62a36bdad7643cc1fbd54de0d01e4f95c0", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -4086,7 +4086,15 @@ simplify_const_relational_operation (enum rtx_code code,\n \t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n \t\t\t\t\t\t       : trueop0;\n \t      if (GET_CODE (tem) == ABS)\n-\t\treturn const0_rtx;\n+\t\t{\n+\t\t  if (INTEGRAL_MODE_P (mode)\n+\t\t      && (issue_strict_overflow_warning\n+\t\t\t  (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n+\t\t    warning (OPT_Wstrict_overflow,\n+\t\t\t     (\"assuming signed overflow does not occur when \"\n+\t\t\t      \"assuming abs (x) < 0 is false\"));\n+\t\t  return const0_rtx;\n+\t\t}\n \t    }\n \n \t  /* Optimize popcount (x) < 0.  */\n@@ -4104,7 +4112,15 @@ simplify_const_relational_operation (enum rtx_code code,\n \t      tem = GET_CODE (trueop0) == FLOAT_EXTEND ? XEXP (trueop0, 0)\n \t\t\t\t\t\t       : trueop0;\n \t      if (GET_CODE (tem) == ABS)\n-\t\treturn const_true_rtx;\n+\t\t{\n+\t\t  if (INTEGRAL_MODE_P (mode)\n+\t\t      && (issue_strict_overflow_warning\n+\t\t\t  (WARN_STRICT_OVERFLOW_CONDITIONAL)))\n+\t\t    warning (OPT_Wstrict_overflow,\n+\t\t\t     (\"assuming signed overflow does not occur when \"\n+\t\t\t      \"assuming abs (x) >= 0 is true\"));\n+\t\t  return const_true_rtx;\n+\t\t}\n \t    }\n \n \t  /* Optimize popcount (x) >= 0.  */"}, {"sha": "f5e99223b4dc1cd18bf262d33bc27899ed61ca00", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,3 +1,16 @@\n+2007-02-13  Ian Lance Taylor  <iant@google.com>\n+\n+\t* gcc.dg/Wstrict-overflow-1.c: New test.\n+\t* gcc.dg/Wstrict-overflow-2.c: New test.\n+\t* gcc.dg/Wstrict-overflow-3.c: New test.\n+\t* gcc.dg/Wstrict-overflow-4.c: New test.\n+\t* gcc.dg/Wstrict-overflow-5.c: New test.\n+\t* gcc.dg/Wstrict-overflow-6.c: New test.\n+\t* gcc.dg/Wstrict-overflow-7.c: New test.\n+\t* gcc.dg/Wstrict-overflow-8.c: New test.\n+\t* gcc.dg/Wstrict-overflow-9.c: New test.\n+\t* gcc.dg/Wstrict-overflow-10.c: New test.\n+\n 2007-02-13  Roger Sayle  <roger@eyesopen.com>\n \n \t* gcc.target/ia64/builtin-bswap-2.c: New test case."}, {"sha": "068bfe49446a46c536694d2ef7bf4fc0ef348b65", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-1.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-1.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=3\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-1.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i - 5 < 10; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "d2c259728cb4cd74259700f5833071a6511cb8fb", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-10.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-10.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=1\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int i)\n+{\n+  return __builtin_abs (i) >= 0;\n+}"}, {"sha": "2112571cabe4d895df6d1d8cc15d739b5ff46dd6", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-2.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-2.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=2\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-1.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return i - 5 < 10;\n+}"}, {"sha": "22f6a56a99e056879d22522d989e59197f016742", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-3.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-3.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=4\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-2.c.  */\n+\n+/* We can only simplify the division when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return (i * 100) / 10; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "e880bef45ff005ff6f6c65bd62e98b1f1ff09db6", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-4.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-4.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=3\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-2.c.  */\n+\n+/* We can only simplify the division when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i)\n+{\n+  return (i * 100) / 10;\n+}"}, {"sha": "9af0adb99344000ff4e5fa9b1531807ee1757b61", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-5.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-5.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=3\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-3.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i, int j)\n+{\n+  return i + 100 < j + 1000; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "c3a160c60027a856847b6a096469921dc9dc62e2", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-6.c", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-6.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,13 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=2\" } */\n+\n+/* Source: Ian Lance Taylor.  Based on strict-overflow-3.c.  */\n+\n+/* We can only simplify the conditional when using strict overflow\n+   semantics.  */\n+\n+int\n+foo (int i, int j)\n+{\n+  return i + 100 < j + 1000;\n+}"}, {"sha": "5bf7b6005ca00daf5419180e21c20cb4c7691af3", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-7.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-7.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int i)\n+{\n+  return i + 10 > i; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "566729fe308874feb0315851e4f4ad1baf72b8cb", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-8.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-8.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wall -Wno-strict-overflow\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int i)\n+{\n+  return i + 10 > i;\n+}"}, {"sha": "425a121d5c0aa06ffe1064916958ad86ffb63fc0", "filename": "gcc/testsuite/gcc.dg/Wstrict-overflow-9.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2FWstrict-overflow-9.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -0,0 +1,10 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-fstrict-overflow -O2 -Wstrict-overflow=2\" } */\n+\n+/* Source: Ian Lance Taylor.  */\n+\n+int\n+foo (int i)\n+{\n+  return __builtin_abs (i) >= 0; /* { dg-warning \"assuming signed overflow does not occur\" \"correct warning\" } */\n+}"}, {"sha": "7d28aa941a7cc4ef2955be6754c5c589d2af0c65", "filename": "gcc/tree-cfg.c", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-cfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-cfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfg.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -408,10 +408,18 @@ fold_cond_expr_cond (void)\n       if (stmt\n \t  && TREE_CODE (stmt) == COND_EXPR)\n \t{\n-\t  tree cond = fold (COND_EXPR_COND (stmt));\n-\t  if (integer_zerop (cond))\n+\t  tree cond;\n+\t  bool zerop, onep;\n+\n+\t  fold_defer_overflow_warnings ();\n+\t  cond = fold (COND_EXPR_COND (stmt));\n+\t  zerop = integer_zerop (cond);\n+\t  onep = integer_onep (cond);\n+\t  fold_undefer_overflow_warnings (zerop || onep, stmt,\n+\t\t\t\t\t  WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t  if (zerop)\n \t    COND_EXPR_COND (stmt) = boolean_false_node;\n-\t  else if (integer_onep (cond))\n+\t  else if (onep)\n \t    COND_EXPR_COND (stmt) = boolean_true_node;\n \t}\n     }"}, {"sha": "8cf66cb4a270c5bddef8b7ffcee0e9d11dcf5144", "filename": "gcc/tree-cfgcleanup.c", "status": "modified", "additions": 24, "deletions": 4, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-cfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-cfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-cfgcleanup.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,5 +1,6 @@\n /* CFG cleanup for trees.\n-   Copyright (C) 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2001, 2002, 2003, 2004, 2005, 2006, 2007\n+   Free Software Foundation, Inc.\n \n This file is part of GCC.\n \n@@ -28,7 +29,7 @@ Boston, MA 02110-1301, USA.  */\n #include \"hard-reg-set.h\"\n #include \"basic-block.h\"\n #include \"output.h\"\n-#include \"errors.h\"\n+#include \"toplev.h\"\n #include \"flags.h\"\n #include \"function.h\"\n #include \"expr.h\"\n@@ -78,6 +79,9 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n     {\n       edge e;\n       edge_iterator ei;\n+      bool warned;\n+\n+      fold_defer_overflow_warnings ();\n \n       switch (TREE_CODE (expr))\n \t{\n@@ -88,7 +92,10 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \tcase SWITCH_EXPR:\n \t  val = fold (SWITCH_COND (expr));\n \t  if (TREE_CODE (val) != INTEGER_CST)\n-\t    return false;\n+\t    {\n+\t      fold_undefer_and_ignore_overflow_warnings ();\n+\t      return false;\n+\t    }\n \t  break;\n \n \tdefault:\n@@ -97,13 +104,24 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \n       taken_edge = find_taken_edge (bb, val);\n       if (!taken_edge)\n-\treturn false;\n+\t{\n+\t  fold_undefer_and_ignore_overflow_warnings ();\n+\t  return false;\n+\t}\n \n       /* Remove all the edges except the one that is always executed.  */\n+      warned = false;\n       for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei)); )\n \t{\n \t  if (e != taken_edge)\n \t    {\n+\t      if (!warned)\n+\t\t{\n+\t\t  fold_undefer_overflow_warnings\n+\t\t    (true, expr, WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\t\t  warned = true;\n+\t\t}\n+\n \t      taken_edge->probability += e->probability;\n \t      taken_edge->count += e->count;\n \t      remove_edge (e);\n@@ -112,6 +130,8 @@ cleanup_control_expr_graph (basic_block bb, block_stmt_iterator bsi)\n \t  else\n \t    ei_next (&ei);\n \t}\n+      if (!warned)\n+\tfold_undefer_and_ignore_overflow_warnings ();\n       if (taken_edge->probability > REG_BR_PROB_BASE)\n \ttaken_edge->probability = REG_BR_PROB_BASE;\n     }"}, {"sha": "459894b24f021eca31cfdfce473e000eb7f64a38", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 27, "deletions": 10, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,5 +1,5 @@\n /* Conditional constant propagation pass for the GNU compiler.\n-   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006\n+   Copyright (C) 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007\n    Free Software Foundation, Inc.\n    Adapted from original RTL SSA-CCP by Daniel Berlin <dberlin@dberlin.org>\n    Adapted to GIMPLE trees by Diego Novillo <dnovillo@redhat.com>\n@@ -207,6 +207,7 @@ Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA\n #include \"tree-ssa-propagate.h\"\n #include \"langhooks.h\"\n #include \"target.h\"\n+#include \"toplev.h\"\n \n \n /* Possible lattice values.  */\n@@ -1132,9 +1133,12 @@ evaluate_stmt (tree stmt)\n   prop_value_t val;\n   tree simplified = NULL_TREE;\n   ccp_lattice_t likelyvalue = likely_value (stmt);\n+  bool is_constant;\n \n   val.mem_ref = NULL_TREE;\n \n+  fold_defer_overflow_warnings ();\n+\n   /* If the statement is likely to have a CONSTANT result, then try\n      to fold the statement to determine the constant value.  */\n   if (likelyvalue == CONSTANT)\n@@ -1151,7 +1155,11 @@ evaluate_stmt (tree stmt)\n   else if (!simplified)\n     simplified = fold_const_aggregate_ref (get_rhs (stmt));\n \n-  if (simplified && is_gimple_min_invariant (simplified))\n+  is_constant = simplified && is_gimple_min_invariant (simplified);\n+\n+  fold_undefer_overflow_warnings (is_constant, stmt, 0);\n+\n+  if (is_constant)\n     {\n       /* The statement produced a constant value.  */\n       val.lattice_val = CONSTANT;\n@@ -1966,8 +1974,9 @@ maybe_fold_stmt_addition (tree expr)\n \n struct fold_stmt_r_data\n {\n-    bool *changed_p;\n-    bool *inside_addr_expr_p;\n+  tree stmt;\n+  bool *changed_p;\n+  bool *inside_addr_expr_p;\n };\n \n /* Subroutine of fold_stmt called via walk_tree.  We perform several\n@@ -2063,10 +2072,16 @@ fold_stmt_r (tree *expr_p, int *walk_subtrees, void *data)\n       if (COMPARISON_CLASS_P (TREE_OPERAND (expr, 0)))\n         {\n \t  tree op0 = TREE_OPERAND (expr, 0);\n-          tree tem = fold_binary (TREE_CODE (op0), TREE_TYPE (op0),\n-\t\t\t\t  TREE_OPERAND (op0, 0),\n-\t\t\t\t  TREE_OPERAND (op0, 1));\n-\t  if (tem && set_rhs (expr_p, tem))\n+          tree tem;\n+\t  bool set;\n+\n+\t  fold_defer_overflow_warnings ();\n+\t  tem = fold_binary (TREE_CODE (op0), TREE_TYPE (op0),\n+\t\t\t     TREE_OPERAND (op0, 0),\n+\t\t\t     TREE_OPERAND (op0, 1));\n+\t  set = tem && set_rhs (expr_p, tem);\n+\t  fold_undefer_overflow_warnings (set, fold_stmt_r_data->stmt, 0);\n+\t  if (set)\n \t    {\n \t      t = *expr_p;\n \t      break;\n@@ -2373,11 +2388,12 @@ fold_stmt (tree *stmt_p)\n   bool changed = false;\n   bool inside_addr_expr = false;\n \n+  stmt = *stmt_p;\n+\n+  fold_stmt_r_data.stmt = stmt;\n   fold_stmt_r_data.changed_p = &changed;\n   fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n \n-  stmt = *stmt_p;\n-\n   /* If we replaced constants and the statement makes pointer dereferences,\n      then we may need to fold instances of *&VAR into VAR, etc.  */\n   if (walk_tree (stmt_p, fold_stmt_r, &fold_stmt_r_data, NULL))\n@@ -2472,6 +2488,7 @@ fold_stmt_inplace (tree stmt)\n   bool changed = false;\n   bool inside_addr_expr = false;\n \n+  fold_stmt_r_data.stmt = stmt;\n   fold_stmt_r_data.changed_p = &changed;\n   fold_stmt_r_data.inside_addr_expr_p = &inside_addr_expr;\n "}, {"sha": "715c412c790f88effdd3438363d5f2502f4bb7f6", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,5 +1,5 @@\n /* High-level loop manipulation functions.\n-   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+   Copyright (C) 2004, 2005, 2006, 2007 Free Software Foundation, Inc.\n    \n This file is part of GCC.\n    \n@@ -86,7 +86,9 @@ create_iv (tree base, tree step, tree var, struct loop *loop,\n \t}\n       else\n \t{\n-\t  if (!tree_expr_nonnegative_p (step)\n+\t  bool ovf;\n+\n+\t  if (!tree_expr_nonnegative_warnv_p (step, &ovf)\n \t      && may_negate_without_overflow_p (step))\n \t    {\n \t      incr_op = MINUS_EXPR;"}, {"sha": "95a9e46c4a877c597b98426f9b971aeb34dc5cdd", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 45, "deletions": 5, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -705,7 +705,13 @@ expand_simple_operations (tree expr)\n \t  TREE_OPERAND (ret, i) = ee;\n \t}\n \n-      return (ret ? fold (ret) : expr);\n+      if (!ret)\n+\treturn expr;\n+\n+      fold_defer_overflow_warnings ();\n+      ret = fold (ret);\n+      fold_undefer_and_ignore_overflow_warnings ();\n+      return ret;\n     }\n \n   if (TREE_CODE (expr) != SSA_NAME)\n@@ -1053,11 +1059,18 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n   if (!simple_iv (loop, stmt, op1, &iv1, false))\n     return false;\n \n+  /* We don't want to see undefined signed overflow warnings while\n+     computing the nmber of iterations.  */\n+  fold_defer_overflow_warnings ();\n+\n   iv0.base = expand_simple_operations (iv0.base);\n   iv1.base = expand_simple_operations (iv1.base);\n   if (!number_of_iterations_cond (type, &iv0, code, &iv1, niter,\n \t\t\t\t  loop_only_exit_p (loop, exit)))\n-    return false;\n+    {\n+      fold_undefer_and_ignore_overflow_warnings ();\n+      return false;\n+    }\n \n   if (optimize >= 3)\n     {\n@@ -1078,6 +1091,8 @@ number_of_iterations_exit (struct loop *loop, edge exit,\n \t\t\t\t\t       niter->may_be_zero,\n \t\t\t\t\t       &niter->additional_info);\n \n+  fold_undefer_and_ignore_overflow_warnings ();\n+\n   if (integer_onep (niter->assumptions))\n     return true;\n \n@@ -1376,6 +1391,9 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \t}\n     }\n \n+  /* Don't issue signed overflow warnings.  */\n+  fold_defer_overflow_warnings ();\n+\n   for (i = 0; i < MAX_ITERATIONS_TO_TRACK; i++)\n     {\n       for (j = 0; j < 2; j++)\n@@ -1384,6 +1402,7 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n       acnd = fold_binary (cmp, boolean_type_node, aval[0], aval[1]);\n       if (acnd && integer_zerop (acnd))\n \t{\n+\t  fold_undefer_and_ignore_overflow_warnings ();\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,\n \t\t     \"Proved that loop %d iterates %d times using brute force.\\n\",\n@@ -1395,10 +1414,15 @@ loop_niter_by_eval (struct loop *loop, edge exit)\n \t{\n \t  val[j] = get_val_for (next[j], val[j]);\n \t  if (!is_gimple_min_invariant (val[j]))\n-\t    return chrec_dont_know;\n+\t    {\n+\t      fold_undefer_and_ignore_overflow_warnings ();\n+\t      return chrec_dont_know;\n+\t    }\n \t}\n     }\n \n+  fold_undefer_and_ignore_overflow_warnings ();\n+\n   return chrec_dont_know;\n }\n \n@@ -1994,10 +2018,16 @@ estimate_numbers_of_iterations (void)\n   loop_iterator li;\n   struct loop *loop;\n \n+  /* We don't want to issue signed overflow warnings while getting\n+     loop iteration estimates.  */\n+  fold_defer_overflow_warnings ();\n+\n   FOR_EACH_LOOP (li, loop, 0)\n     {\n       estimate_numbers_of_iterations_loop (loop);\n     }\n+\n+  fold_undefer_and_ignore_overflow_warnings ();\n }\n \n /* Returns true if statement S1 dominates statement S2.  */\n@@ -2153,6 +2183,9 @@ scev_probably_wraps_p (tree base, tree step,\n   if (use_overflow_semantics && nowrap_type_p (type))\n     return false;\n \n+  /* Don't issue signed overflow warnings.  */\n+  fold_defer_overflow_warnings ();\n+\n   /* Otherwise, compute the number of iterations before we reach the\n      bound of the type, and verify that the loop is exited before this\n      occurs.  */\n@@ -2179,8 +2212,15 @@ scev_probably_wraps_p (tree base, tree step,\n \n   estimate_numbers_of_iterations_loop (loop);\n   for (bound = loop->bounds; bound; bound = bound->next)\n-    if (n_of_executions_at_most (at_stmt, bound, valid_niter))\n-      return false;\n+    {\n+      if (n_of_executions_at_most (at_stmt, bound, valid_niter))\n+\t{\n+\t  fold_undefer_and_ignore_overflow_warnings ();\n+\t  return false;\n+\t}\n+    }\n+\n+  fold_undefer_and_ignore_overflow_warnings ();\n \n   /* At this point we still don't have a proof that the iv does not\n      overflow: give up.  */"}, {"sha": "72018c02ede854ce190914fe333f654d77600fd5", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -1,5 +1,5 @@\n /* SSA Jump Threading\n-   Copyright (C) 2005, 2006 Free Software Foundation, Inc.\n+   Copyright (C) 2005, 2006, 2007 Free Software Foundation, Inc.\n    Contributed by Jeff Law  <law@redhat.com>\n \n This file is part of GCC.\n@@ -425,12 +425,17 @@ simplify_control_stmt_condition (edge e,\n \n       /* We absolutely do not care about any type conversions\n          we only care about a zero/nonzero value.  */\n+      fold_defer_overflow_warnings ();\n+\n       cached_lhs = fold (COND_EXPR_COND (dummy_cond));\n       while (TREE_CODE (cached_lhs) == NOP_EXPR\n \t     || TREE_CODE (cached_lhs) == CONVERT_EXPR\n \t     || TREE_CODE (cached_lhs) == NON_LVALUE_EXPR)\n \tcached_lhs = TREE_OPERAND (cached_lhs, 0);\n-\t    \n+\n+      fold_undefer_overflow_warnings (is_gimple_min_invariant (cached_lhs),\n+\t\t\t\t      stmt, WARN_STRICT_OVERFLOW_CONDITIONAL);\n+\n       /* If we have not simplified the condition down to an invariant,\n \t then use the pass specific callback to simplify the condition.  */\n       if (! is_gimple_min_invariant (cached_lhs))"}, {"sha": "fffeefc83bd1c0aee2c32c7d7cb94ffbb48d7461", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -414,7 +414,10 @@ symbolic_range_p (value_range_t *vr)\n static bool\n vrp_expr_computes_nonnegative (tree expr)\n {\n-  return tree_expr_nonnegative_p (expr);\n+  bool ovf;\n+\n+  /* FIXME: May need to record overflow information here.  */\n+  return tree_expr_nonnegative_warnv_p (expr, &ovf);\n }\n \n /* Like tree_expr_nonzero_p, but this function uses value ranges\n@@ -423,7 +426,10 @@ vrp_expr_computes_nonnegative (tree expr)\n static bool\n vrp_expr_computes_nonzero (tree expr)\n {\n-  if (tree_expr_nonzero_p (expr))\n+  bool ovf;\n+\n+  /* FIXME: May need to record overflow information here.  */\n+  if (tree_expr_nonzero_warnv_p (expr, &ovf))\n     return true;\n \n   /* If we have an expression of the form &X->a, then the expression\n@@ -1697,7 +1703,10 @@ extract_range_from_unary_expr (value_range_t *vr, tree expr)\n      determining if it evaluates to NULL [0, 0] or non-NULL (~[0, 0]).  */\n   if (POINTER_TYPE_P (TREE_TYPE (expr)) || POINTER_TYPE_P (TREE_TYPE (op0)))\n     {\n-      if (range_is_nonnull (&vr0) || tree_expr_nonzero_p (expr))\n+      bool ovf;\n+\n+      /* FIXME: May need to record overflow information here.  */\n+      if (range_is_nonnull (&vr0) || tree_expr_nonzero_warnv_p (expr, &ovf))\n \tset_value_range_to_nonnull (vr, TREE_TYPE (expr));\n       else if (range_is_null (&vr0))\n \tset_value_range_to_null (vr, TREE_TYPE (expr));"}, {"sha": "ed0379c7a872165e3dfa5c689ce004672d2ae9f0", "filename": "gcc/tree.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac015100fa98539d577a6c04b69693aefce35dc/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=6ac015100fa98539d577a6c04b69693aefce35dc", "patch": "@@ -3735,6 +3735,7 @@ extern int tree_int_cst_msb (tree);\n extern int tree_int_cst_sgn (tree);\n extern int tree_int_cst_sign_bit (tree);\n extern bool tree_expr_nonnegative_p (tree);\n+extern bool tree_expr_nonnegative_warnv_p (tree, bool *);\n extern bool may_negate_without_overflow_p (tree);\n extern tree get_inner_array_type (tree);\n \n@@ -4333,6 +4334,10 @@ extern tree fold_single_bit_test (enum tree_code, tree, tree, tree);\n extern tree fold_ignored_result (tree);\n extern tree fold_abs_const (tree, tree);\n extern tree fold_indirect_ref_1 (tree, tree);\n+extern void fold_defer_overflow_warnings (void);\n+extern void fold_undefer_overflow_warnings (bool, tree, int);\n+extern void fold_undefer_and_ignore_overflow_warnings (void);\n+extern bool fold_deferring_overflow_warnings_p (void);\n \n extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t\t   int, bool);\n@@ -4405,6 +4410,7 @@ extern bool ptr_difference_const (tree, tree, HOST_WIDE_INT *);\n extern enum tree_code invert_tree_comparison (enum tree_code, bool);\n \n extern bool tree_expr_nonzero_p (tree);\n+extern bool tree_expr_nonzero_warnv_p (tree, bool *);\n \n /* In builtins.c */\n extern tree fold_builtin (tree, tree, bool);"}]}