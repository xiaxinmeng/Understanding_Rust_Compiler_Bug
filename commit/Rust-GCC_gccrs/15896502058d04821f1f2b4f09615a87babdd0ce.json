{"sha": "15896502058d04821f1f2b4f09615a87babdd0ce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTU4OTY1MDIwNThkMDQ4MjFmMWYyYjRmMDk2MTVhODdiYWJkZDBjZQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2007-10-16T21:00:47Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2007-10-16T21:00:47Z"}, "message": "typeck.c (cp_apply_type_quals_to_decl): Expand documentation.\n\n\t* typeck.c (cp_apply_type_quals_to_decl): Expand documentation.\n\t* decl.c (start_decl): Tidy.\n\t(start_decl_1): Call cp_apply_type_quals_to_decl after completing\n\tthe type.\n\t(grokdeclarator): Clarify comment.\n\t* g++.dg/opt/const-5.C: New test.\n\nFrom-SVN: r129386", "tree": {"sha": "c9fd19db215ed38eb9c7b7d407f8e60c5817857c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9fd19db215ed38eb9c7b7d407f8e60c5817857c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/15896502058d04821f1f2b4f09615a87babdd0ce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15896502058d04821f1f2b4f09615a87babdd0ce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/15896502058d04821f1f2b4f09615a87babdd0ce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/15896502058d04821f1f2b4f09615a87babdd0ce/comments", "author": null, "committer": null, "parents": [{"sha": "9eb061d7411734dac29533d4c8a6aba17ced2b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9eb061d7411734dac29533d4c8a6aba17ced2b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9eb061d7411734dac29533d4c8a6aba17ced2b76"}], "stats": {"total": 166, "additions": 106, "deletions": 60}, "files": [{"sha": "559226b4f4eaf814081e7b7000e98b830b27eb6f", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=15896502058d04821f1f2b4f09615a87babdd0ce", "patch": "@@ -1,3 +1,11 @@\n+2007-10-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* typeck.c (cp_apply_type_quals_to_decl): Expand documentation.\n+\t* decl.c (start_decl): Tidy.\n+\t(start_decl_1): Call cp_apply_type_quals_to_decl after completing\n+\tthe type.\n+\t(grokdeclarator): Clarify comment.\n+\n 2007-10-14  Andrew Pinski  <pinskia@gmail.com>\n \n \tPR c++/30303"}, {"sha": "0a42b69ff4f6785fa6dc4d2290afa9fa58c93c94", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 69, "deletions": 59, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=15896502058d04821f1f2b4f09615a87babdd0ce", "patch": "@@ -3914,20 +3914,20 @@ groktypename (cp_decl_specifier_seq *type_specifiers,\n   return type;\n }\n \n-/* Decode a declarator in an ordinary declaration or data definition.\n-   This is called as soon as the type information and variable name\n-   have been parsed, before parsing the initializer if any.\n-   Here we create the ..._DECL node, fill in its type,\n-   and put it on the list of decls for the current context.\n-   The ..._DECL node is returned as the value.\n-\n-   Exception: for arrays where the length is not specified,\n-   the type is left null, to be filled in by `cp_finish_decl'.\n-\n-   Function definitions do not come here; they go to start_function\n-   instead.  However, external and forward declarations of functions\n-   do go through here.  Structure field declarations are done by\n-   grokfield and not through here.  */\n+/* Process a DECLARATOR for a function-scope variable declaration,\n+   namespace-scope variable declaration, or function declaration.\n+   (Function definitions go through start_function; class member\n+   declarations appearing in the body of the class go through\n+   grokfield.)  The DECL corresponding to the DECLARATOR is returned.\n+   If an error occurs, the error_mark_node is returned instead.\n+   \n+   DECLSPECS are the decl-specifiers for the declaration.  INITIALIZED\n+   is true if an explicit initializer is present, but false if this is\n+   a variable implicitly initialized via a default constructor.\n+   ATTRIBUTES and PREFIX_ATTRIBUTES are GNU attributes associated with\n+   this declaration.  *PUSHED_SCOPE_P is set to the scope entered in\n+   this function, if any; if set, the caller is responsible for\n+   calling pop_scope.  */\n \n tree\n start_decl (const cp_declarator *declarator,\n@@ -3938,7 +3938,7 @@ start_decl (const cp_declarator *declarator,\n \t    tree *pushed_scope_p)\n {\n   tree decl;\n-  tree type, tem;\n+  tree type;\n   tree context;\n   bool was_public;\n \n@@ -4099,11 +4099,11 @@ start_decl (const cp_declarator *declarator,\n   was_public = TREE_PUBLIC (decl);\n \n   /* Enter this declaration into the symbol table.  */\n-  tem = maybe_push_decl (decl);\n+  decl = maybe_push_decl (decl);\n \n   if (processing_template_decl)\n-    tem = push_template_decl (tem);\n-  if (tem == error_mark_node)\n+    decl = push_template_decl (decl);\n+  if (decl == error_mark_node)\n     return error_mark_node;\n \n   /* Tell the back end to use or not use .common as appropriate.  If we say\n@@ -4112,86 +4112,96 @@ start_decl (const cp_declarator *declarator,\n      produce errors about redefs; to do this we force variables into the\n      data segment.  */\n   if (flag_conserve_space\n-      && TREE_CODE (tem) == VAR_DECL\n-      && TREE_PUBLIC (tem)\n-      && !DECL_THREAD_LOCAL_P (tem)\n+      && TREE_CODE (decl) == VAR_DECL\n+      && TREE_PUBLIC (decl)\n+      && !DECL_THREAD_LOCAL_P (decl)\n       && !have_global_bss_p ())\n-    DECL_COMMON (tem) = 1;\n+    DECL_COMMON (decl) = 1;\n \n-  if (TREE_CODE (tem) == VAR_DECL\n-      && DECL_NAMESPACE_SCOPE_P (tem) && !TREE_PUBLIC (tem) && !was_public\n-      && !DECL_THIS_STATIC (tem) && !DECL_ARTIFICIAL (tem))\n+  if (TREE_CODE (decl) == VAR_DECL\n+      && DECL_NAMESPACE_SCOPE_P (decl) && !TREE_PUBLIC (decl) && !was_public\n+      && !DECL_THIS_STATIC (decl) && !DECL_ARTIFICIAL (decl))\n     {\n       /* This is a const variable with implicit 'static'.  Set\n \t DECL_THIS_STATIC so we can tell it from variables that are\n \t !TREE_PUBLIC because of the anonymous namespace.  */\n-      gcc_assert (cp_type_readonly (TREE_TYPE (tem)));\n-      DECL_THIS_STATIC (tem) = 1;\n+      gcc_assert (cp_type_readonly (TREE_TYPE (decl)));\n+      DECL_THIS_STATIC (decl) = 1;\n     }\n \n-  if (!processing_template_decl && TREE_CODE (tem) == VAR_DECL)\n-    start_decl_1 (tem, initialized);\n+  if (!processing_template_decl && TREE_CODE (decl) == VAR_DECL)\n+    start_decl_1 (decl, initialized);\n \n-  return tem;\n+  return decl;\n }\n \n+/* Process the declaration of a variable DECL.  INITIALIZED is true\n+   iff DECL is explicitly initialized.  (INITIALIZED is false if the\n+   variable is initialized via an implicitly-called constructor.)\n+   This function must be called for ordinary variables (including, for\n+   example, implicit instantiations of templates), but must not be\n+   called for template declarations.  */\n+\n void\n start_decl_1 (tree decl, bool initialized)\n {\n   tree type;\n+  bool complete_p;\n+  bool aggregate_definition_p;\n \n   gcc_assert (!processing_template_decl);\n \n   if (error_operand_p (decl))\n     return;\n \n   gcc_assert (TREE_CODE (decl) == VAR_DECL);\n+\n   type = TREE_TYPE (decl);\n+  complete_p = COMPLETE_TYPE_P (type);\n+  aggregate_definition_p = IS_AGGR_TYPE (type) && !DECL_EXTERNAL (decl);\n+\n+  /* If an explicit initializer is present, or if this is a definition\n+     of an aggregate, then we need a complete type at this point.\n+     (Scalars are always complete types, so there is nothing to\n+     check.)  This code just sets COMPLETE_P; errors (if necessary)\n+     are issued below.  */\n+  if ((initialized || aggregate_definition_p) \n+      && !complete_p\n+      && COMPLETE_TYPE_P (complete_type (type)))\n+    {\n+      complete_p = true;\n+      /* We will not yet have set TREE_READONLY on DECL if the type\n+\t was \"const\", but incomplete, before this point.  But, now, we\n+\t have a complete type, so we can try again.  */\n+      cp_apply_type_quals_to_decl (cp_type_quals (type), decl);\n+    }\n \n   if (initialized)\n-    /* Is it valid for this decl to have an initializer at all?\n-       If not, set INITIALIZED to zero, which will indirectly\n-       tell `cp_finish_decl' to ignore the initializer once it is parsed.  */\n+    /* Is it valid for this decl to have an initializer at all?  */\n     {\n       /* Don't allow initializations for incomplete types except for\n \t arrays which might be completed by the initialization.  */\n-      if (COMPLETE_TYPE_P (complete_type (type)))\n+      if (complete_p)\n \t;\t\t\t/* A complete type is ok.  */\n       else if (TREE_CODE (type) != ARRAY_TYPE)\n \t{\n \t  error (\"variable %q#D has initializer but incomplete type\", decl);\n-\t  initialized = 0;\n \t  type = TREE_TYPE (decl) = error_mark_node;\n \t}\n       else if (!COMPLETE_TYPE_P (complete_type (TREE_TYPE (type))))\n \t{\n \t  if (DECL_LANG_SPECIFIC (decl) && DECL_TEMPLATE_INFO (decl))\n \t    error (\"elements of array %q#D have incomplete type\", decl);\n \t  /* else we already gave an error in start_decl.  */\n-\t  initialized = 0;\n \t}\n     }\n-  else if (IS_AGGR_TYPE (type)\n-\t   && ! DECL_EXTERNAL (decl))\n+  else if (aggregate_definition_p && !complete_p)\n     {\n-      if (!COMPLETE_TYPE_P (complete_type (type)))\n-\t{\n-\t  error (\"aggregate %q#D has incomplete type and cannot be defined\",\n-\t\t decl);\n-\t  /* Change the type so that assemble_variable will give\n-\t     DECL an rtl we can live with: (mem (const_int 0)).  */\n-\t  type = TREE_TYPE (decl) = error_mark_node;\n-\t}\n-      else\n-\t{\n-\t  /* If any base type in the hierarchy of TYPE needs a constructor,\n-\t     then we set initialized to 1.  This way any nodes which are\n-\t     created for the purposes of initializing this aggregate\n-\t     will live as long as it does.  This is necessary for global\n-\t     aggregates which do not have their initializers processed until\n-\t     the end of the file.  */\n-\t  initialized = TYPE_NEEDS_CONSTRUCTING (type);\n-\t}\n+      error (\"aggregate %q#D has incomplete type and cannot be defined\",\n+\t     decl);\n+      /* Change the type so that assemble_variable will give\n+\t DECL an rtl we can live with: (mem (const_int 0)).  */\n+      type = TREE_TYPE (decl) = error_mark_node;\n     }\n \n   /* Create a new scope to hold this declaration if necessary.\n@@ -9113,9 +9123,9 @@ grokdeclarator (const cp_declarator *declarator,\n     else if (storage_class == sc_static)\n       DECL_THIS_STATIC (decl) = 1;\n \n-    /* Record constancy and volatility.  There's no need to do this\n-       when processing a template; we'll do this for the instantiated\n-       declaration based on the type of DECL.  */\n+    /* Record constancy and volatility on the DECL itself .  There's\n+       no need to do this when processing a template; we'll do this\n+       for the instantiated declaration based on the type of DECL.  */\n     if (!processing_template_decl)\n       cp_apply_type_quals_to_decl (type_quals, decl);\n "}, {"sha": "cfad878f875ff94d5f6d04a2bb9ea8392b4eaa9e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=15896502058d04821f1f2b4f09615a87babdd0ce", "patch": "@@ -6976,7 +6976,18 @@ cp_has_mutable_p (const_tree type)\n   return CLASS_TYPE_P (type) && CLASSTYPE_HAS_MUTABLE (type);\n }\n \n-/* Apply the TYPE_QUALS to the new DECL.  */\n+/* Set TREE_READONLY and TREE_VOLATILE on DECL as indicated by the\n+   TYPE_QUALS.  For a VAR_DECL, this may be an optimistic\n+   approximation.  In particular, consider:\n+\n+     int f();\n+     struct S { int i; };\n+     const S s = { f(); }\n+\n+   Here, we will make \"s\" as TREE_READONLY (because it is declared\n+   \"const\") -- only to reverse ourselves upon seeing that the\n+   initializer is non-constant.  */\n+\n void\n cp_apply_type_quals_to_decl (int type_quals, tree decl)\n {"}, {"sha": "586e53f77a14403e874f1227a523499b267df0f3", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=15896502058d04821f1f2b4f09615a87babdd0ce", "patch": "@@ -1,3 +1,7 @@\n+2007-10-16  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/opt/const-5.C: New test.\n+\n 2007-10-15  Paolo Bonzini  <bonzini@gnu.org>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n "}, {"sha": "3785271a08305837b7ea388f019f620774ddf00e", "filename": "gcc/testsuite/g++.dg/opt/const5.C", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst5.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/15896502058d04821f1f2b4f09615a87babdd0ce/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst5.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fconst5.C?ref=15896502058d04821f1f2b4f09615a87babdd0ce", "patch": "@@ -0,0 +1,13 @@\n+// We don't have a good way of determining how \".rodata\" is spelled on\n+// all targets, so we limit this test to a few common targets where we\n+// do know the spelling.\n+// { dg-do compile { target i?86-*-linux* x86_64-*-linux* } }\n+// { dg-final { scan-assembler \"\\\\.rodata\" } }\n+\n+template <typename T>\n+struct B {\n+  int i;\n+};\n+\n+// This declaration should be placed in .rodata.\n+const B<int> const_B __attribute__((used)) = { 3 };"}]}