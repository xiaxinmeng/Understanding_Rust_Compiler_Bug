{"sha": "c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzU5N2VmNGVhYjlhMmRlOWFkMGIyMTg3NTQ3YWM5YmFjMGI1MzEzMg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@redhat.com", "date": "2004-08-12T14:34:11Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-08-12T14:34:11Z"}, "message": "re PR tree-optimization/16867 (Inline array initializer miscompilation at -O)\n\n\n\tPR tree-optimization/16867\n\t* tree.c (is_global_var): New function.\n\t(needs_to_live_in_memory): Check for TREE_ADDRESSABLE.\n\tCall is_global_var.\n\t* tree.h (DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL): Remove.\n\tUpdate all users.\n\t(is_global_var): Declare.\n\t* tree-dfa.c (dump_variable): Display global and addressable\n\tattributes.\n\t(add_referenced_var): Clarify documentation when marking\n\tvariables call-clobbered.\n\t* tree-flow-inline.h (is_call_clobbered): Call is_global_var\n\tinstead of needs_to_live_in_memory.\n\t(mark_call_clobbered): If the variable is a tag, mark it\n\tDECL_EXTERNAL.\n\t* tree-gimple.c (is_gimple_reg): Don't check for\n\tTREE_ADDRESSABLE.\n\t(is_gimple_non_addressable): Likewise.\n\t* tree-ssa-alias.c (get_nmt_for): Always check whether the tag\n\tneeds to be marked call-clobbered.\n\t(setup_pointers_and_addressables): Call is_global_var instead\n\tof needs_to_live_in_memory.\n\t* tree-ssa-dce.c (need_to_preserve_store): Remove.\n\tUpdate all users with is_global_var.\n\t(mark_stmt_if_obviously_necessary): Fix processing of aliased\n\tstores.  Don't check the virtual definitions.  Rather, check\n\twhether the store is going into global memory.\n\t(find_obviously_necessary_stmts): Get the symbol from the PHI\n\tresult.\n\t* tree-ssa-operands.c (get_call_expr_operands): Do not add\n\tclobbering may-defs if the call does not have side effects.\n\n\nlibjava/ChangeLog\n\n\tPR tree-optimization/16867\n\t* testsuite/libjava.lang/PR16867.java: New test.\n\nFrom-SVN: r85874", "tree": {"sha": "a0fa15664fe5d4dfd7f6bced8b73b4839f33dfcb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0fa15664fe5d4dfd7f6bced8b73b4839f33dfcb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/comments", "author": null, "committer": null, "parents": [{"sha": "ab5c8549a48977b865f8ed8dd4bd4e745b1cec75", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ab5c8549a48977b865f8ed8dd4bd4e745b1cec75", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ab5c8549a48977b865f8ed8dd4bd4e745b1cec75"}], "stats": {"total": 243, "additions": 173, "deletions": 70}, "files": [{"sha": "b9c2ff04ac1641e9a8b2479b965bab64fb669691", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -1,3 +1,37 @@\n+2004-08-12  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/16867\n+\t* tree.c (is_global_var): New function.\n+\t(needs_to_live_in_memory): Check for TREE_ADDRESSABLE.\n+\tCall is_global_var.\n+\t* tree.h (DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL): Remove.\n+\tUpdate all users.\n+\t(is_global_var): Declare.\n+\t* tree-dfa.c (dump_variable): Display global and addressable\n+\tattributes.\n+\t(add_referenced_var): Clarify documentation when marking\n+\tvariables call-clobbered.\n+\t* tree-flow-inline.h (is_call_clobbered): Call is_global_var\n+\tinstead of needs_to_live_in_memory.\n+\t(mark_call_clobbered): If the variable is a tag, mark it\n+\tDECL_EXTERNAL.\n+\t* tree-gimple.c (is_gimple_reg): Don't check for\n+\tTREE_ADDRESSABLE.\n+\t(is_gimple_non_addressable): Likewise.\n+\t* tree-ssa-alias.c (get_nmt_for): Always check whether the tag\n+\tneeds to be marked call-clobbered.\n+\t(setup_pointers_and_addressables): Call is_global_var instead\n+\tof needs_to_live_in_memory.\n+\t* tree-ssa-dce.c (need_to_preserve_store): Remove.\n+\tUpdate all users with is_global_var.\n+\t(mark_stmt_if_obviously_necessary): Fix processing of aliased\n+\tstores.  Don't check the virtual definitions.  Rather, check\n+\twhether the store is going into global memory.\n+\t(find_obviously_necessary_stmts): Get the symbol from the PHI\n+\tresult.\n+\t* tree-ssa-operands.c (get_call_expr_operands): Do not add\n+\tclobbering may-defs if the call does not have side effects.\n+\n 2004-08-12  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/16276"}, {"sha": "0273406df844016110a1886be92ec0f161e018e4", "filename": "gcc/tree-dfa.c", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-dfa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-dfa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dfa.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -562,8 +562,11 @@ dump_variable (FILE *file, tree var)\n   if (ann->is_alias_tag)\n     fprintf (file, \", is an alias tag\");\n \n-  if (needs_to_live_in_memory (var))\n-    fprintf (file, \", is %s\", TREE_STATIC (var) ? \"static\" : \"global\");\n+  if (TREE_ADDRESSABLE (var))\n+    fprintf (file, \", is addressable\");\n+  \n+  if (is_global_var (var))\n+    fprintf (file, \", is global\");\n \n   if (is_call_clobbered (var))\n     fprintf (file, \", call clobbered\");\n@@ -900,7 +903,9 @@ add_referenced_var (tree var, struct walk_state *walk_state)\n       v_ann->uid = num_referenced_vars;\n       VARRAY_PUSH_TREE (referenced_vars, var);\n \n-      /* Global and static variables are call-clobbered, always.  */\n+      /* Initially assume that all memory variables are\n+\t call-clobbered.  This will be refined later by the alias\n+\t analyzer.  */\n       if (needs_to_live_in_memory (var))\n \tmark_call_clobbered (var);\n "}, {"sha": "a9cc21325e8c3f6a284f730c93f2ead2d9f7a14b", "filename": "gcc/tree-flow-inline.h", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-flow-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-flow-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow-inline.h?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -630,7 +630,7 @@ loop_containing_stmt (tree stmt)\n static inline bool\n is_call_clobbered (tree var)\n {\n-  return needs_to_live_in_memory (var)\n+  return is_global_var (var)\n \t || bitmap_bit_p (call_clobbered_vars, var_ann (var)->uid);\n }\n \n@@ -639,8 +639,12 @@ static inline void\n mark_call_clobbered (tree var)\n {\n   var_ann_t ann = var_ann (var);\n-  /* Call-clobbered variables need to live in memory.  */\n-  DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL (var) = 1;\n+  /* If VAR is a memory tag, then we need to consider it a global\n+     variable.  This is because the pointer that VAR represents has\n+     been found to point to either an arbitrary location or to a known\n+     location in global memory.  */\n+  if (ann->mem_tag_kind != NOT_A_TAG)\n+    DECL_EXTERNAL (var) = 1;\n   bitmap_set_bit (call_clobbered_vars, ann->uid);\n }\n \n@@ -649,7 +653,6 @@ static inline void\n mark_non_addressable (tree var)\n {\n   bitmap_clear_bit (call_clobbered_vars, var_ann (var)->uid);\n-  DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL (var) = 0;\n   TREE_ADDRESSABLE (var) = 0;\n }\n "}, {"sha": "e20889355152adbf5bd9a38179620471716aac5e", "filename": "gcc/tree-gimple.c", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-gimple.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -441,7 +441,6 @@ is_gimple_reg (tree t)\n \t  /* A volatile decl is not acceptable because we can't reuse it as\n \t     needed.  We need to copy it into a temp first.  */\n \t  && ! TREE_THIS_VOLATILE (t)\n-\t  && ! TREE_ADDRESSABLE (t)\n \t  && ! needs_to_live_in_memory (t));\n }\n \n@@ -481,9 +480,7 @@ is_gimple_non_addressable (tree t)\n   if (TREE_CODE (t) == SSA_NAME)\n     t = SSA_NAME_VAR (t);\n \n-  return (is_gimple_variable (t)\n-\t  && ! TREE_ADDRESSABLE (t)\n-\t  && ! needs_to_live_in_memory (t));\n+  return (is_gimple_variable (t) && ! needs_to_live_in_memory (t));\n }\n \n /* Return true if T is a GIMPLE rvalue, i.e. an identifier or a constant.  */"}, {"sha": "a344384b42656a247c1b210723397130f15e14b8", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 10, "deletions": 13, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -390,7 +390,6 @@ init_alias_info (void)\n       EXECUTE_IF_SET_IN_BITMAP (call_clobbered_vars, 0, i,\n \t{\n \t  tree var = referenced_var (i);\n-\t  DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL (var) = 0;\n \n \t  /* Variables that are intrinsically call-clobbered (globals,\n \t     local statics, etc) will not be marked by the aliasing\n@@ -1329,7 +1328,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t{\n \t  if (!bitmap_bit_p (ai->addresses_needed, v_ann->uid)\n \t      && v_ann->mem_tag_kind == NOT_A_TAG\n-\t      && !needs_to_live_in_memory (var))\n+\t      && !is_global_var (var))\n \t    {\n \t      /* The address of VAR is not needed, remove the\n \t\t addressable bit, so that it can be optimized as a\n@@ -1391,7 +1390,7 @@ setup_pointers_and_addressables (struct alias_info *ai)\n \t      /* If pointer VAR is a global variable or a PARM_DECL,\n \t\t then its memory tag should be considered a global\n \t\t variable.  */\n-\t      if (TREE_CODE (var) == PARM_DECL || needs_to_live_in_memory (var))\n+\t      if (TREE_CODE (var) == PARM_DECL || is_global_var (var))\n \t\tmark_call_clobbered (tag);\n \n \t      /* All the dereferences of pointer VAR count as\n@@ -2105,18 +2104,16 @@ get_nmt_for (tree ptr)\n   tree tag = pi->name_mem_tag;\n \n   if (tag == NULL_TREE)\n-    {\n-      tag = create_memory_tag (TREE_TYPE (TREE_TYPE (ptr)), false);\n+    tag = create_memory_tag (TREE_TYPE (TREE_TYPE (ptr)), false);\n \n-      /* If PTR is a PARM_DECL, its memory tag should be considered a\n-\t global variable.  */\n-      if (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL)\n-\tmark_call_clobbered (tag);\n+  /* If PTR is a PARM_DECL, its memory tag should be considered a global\n+     variable.  */\n+  if (TREE_CODE (SSA_NAME_VAR (ptr)) == PARM_DECL)\n+    mark_call_clobbered (tag);\n \n-      /* Similarly, if PTR points to malloc, then TAG is a global.  */\n-      if (pi->pt_malloc)\n-\tmark_call_clobbered (tag);\n-    }\n+  /* Similarly, if PTR points to malloc, then TAG is a global.  */\n+  if (pi->pt_malloc)\n+    mark_call_clobbered (tag);\n \n   return tag;\n }"}, {"sha": "111f5400b9f555ce25838897e3d44e6cb4469e8e", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 76, "deletions": 30, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -107,7 +107,6 @@ static inline basic_block find_pdom (basic_block);\n static inline void mark_stmt_necessary (tree, bool);\n static inline void mark_operand_necessary (tree);\n \n-static bool need_to_preserve_store (tree);\n static void mark_stmt_if_obviously_necessary (tree, bool);\n static void find_obviously_necessary_stmts (struct edge_list *);\n \n@@ -267,14 +266,6 @@ mark_operand_necessary (tree op)\n   VARRAY_PUSH_TREE (worklist, stmt);\n }\n \f\n-/* Return true if a store to a variable needs to be preserved.  */\n-\n-static inline bool\n-need_to_preserve_store (tree ssa_name)\n-{\n-  return (needs_to_live_in_memory (SSA_NAME_VAR (ssa_name)));\n-}\n-\f\n \n /* Mark STMT as necessary if it is obviously is.  Add it to the worklist if\n    it can make other statements necessary.\n@@ -367,10 +358,11 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n     }\n \n   ann = stmt_ann (stmt);\n-  /* If the statement has volatile operands, it needs to be preserved.  Same\n-     for statements that can alter control flow in unpredictable ways.  */\n-  if (ann->has_volatile_ops\n-      || is_ctrl_altering_stmt (stmt))\n+\n+  /* If the statement has volatile operands, it needs to be preserved.\n+     Same for statements that can alter control flow in unpredictable\n+     ways.  */\n+  if (ann->has_volatile_ops || is_ctrl_altering_stmt (stmt))\n     {\n       mark_stmt_necessary (stmt, true);\n       return;\n@@ -382,33 +374,87 @@ mark_stmt_if_obviously_necessary (tree stmt, bool aggressive)\n   for (i = 0; i < NUM_DEFS (defs); i++)\n     {\n       tree def = DEF_OP (defs, i);\n-      if (need_to_preserve_store (def))\n+      if (is_global_var (SSA_NAME_VAR (def)))\n \t{\n \t  mark_stmt_necessary (stmt, true);\n \t  return;\n         }\n     }\n \n+  /* Check virtual definitions.  If we get here, the only virtual\n+     definitions we should see are those generated by assignment\n+     statements.  */\n   v_may_defs = V_MAY_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MAY_DEFS (v_may_defs); i++)\n-    {\n-      tree v_may_def = V_MAY_DEF_RESULT (v_may_defs, i);\n-      if (need_to_preserve_store (v_may_def))\n-\t{\n-\t  mark_stmt_necessary (stmt, true);\n-\t  return;\n-        }\n-    }\n-    \n   v_must_defs = V_MUST_DEF_OPS (ann);\n-  for (i = 0; i < NUM_V_MUST_DEFS (v_must_defs); i++)\n+  if (NUM_V_MAY_DEFS (v_may_defs) > 0 || NUM_V_MUST_DEFS (v_must_defs) > 0)\n     {\n-      tree v_must_def = V_MUST_DEF_OP (v_must_defs, i);\n-      if (need_to_preserve_store (v_must_def))\n+      tree lhs;\n+\n+#if defined ENABLE_CHECKING\n+      if (TREE_CODE (stmt) != MODIFY_EXPR)\n+\tabort ();\n+#endif\n+\n+      /* Note that we must not check the individual virtual operands\n+\t here.  In particular, if this is an aliased store, we could\n+\t end up with something like the following (SSA notation\n+\t redacted for brevity):\n+\n+\t \tfoo (int *p, int i)\n+\t\t{\n+\t\t  int x;\n+\t\t  p_1 = (i_2 > 3) ? &x : p_1;\n+\n+\t\t  # x_4 = V_MAY_DEF <x_3>\n+\t\t  *p_1 = 5;\n+\n+\t\t  return 2;\n+\t\t}\n+\n+\t Notice that the store to '*p_1' should be preserved, if we\n+\t were to check the virtual definitions in that store, we would\n+\t not mark it needed.  This is because 'x' is not a global\n+\t variable.\n+\n+\t Therefore, we check the base address of the LHS.  If the\n+\t address is a pointer, we check if its name tag or type tag is\n+\t a global variable.  Otherwise, we check if the base variable\n+\t is a global.  */\n+      lhs = TREE_OPERAND (stmt, 0);\n+      if (TREE_CODE_CLASS (TREE_CODE (lhs)) == 'r')\n+\tlhs = get_base_address (lhs);\n+\n+      if (lhs == NULL_TREE)\n \t{\n+\t  /* If LHS is NULL, it means that we couldn't get the base\n+\t     address of the reference.  In which case, we should not\n+\t     remove this store. */\n \t  mark_stmt_necessary (stmt, true);\n-\t  return;\n-        }\n+\t}\n+      else if (DECL_P (lhs))\n+\t{\n+\t  /* If the store is to a global symbol, we need to keep it.  */\n+\t  if (is_global_var (lhs))\n+\t    mark_stmt_necessary (stmt, true);\n+\t}\n+      else if (TREE_CODE (lhs) == INDIRECT_REF)\n+\t{\n+\t  tree ptr = TREE_OPERAND (lhs, 0);\n+\t  struct ptr_info_def *pi = SSA_NAME_PTR_INFO (ptr);\n+\t  tree nmt = (pi) ? pi->name_mem_tag : NULL_TREE;\n+\t  tree tmt = var_ann (SSA_NAME_VAR (ptr))->type_mem_tag;\n+\n+\t  /* If either the name tag or the type tag for PTR is a\n+\t     global variable, then the store is necessary.  */\n+\t  if ((nmt && is_global_var (nmt))\n+\t      || (tmt && is_global_var (tmt)))\n+\t    {\n+\t      mark_stmt_necessary (stmt, true);\n+\t      return;\n+\t    }\n+\t}\n+      else\n+\tabort ();\n     }\n \n   return;\n@@ -444,7 +490,7 @@ find_obviously_necessary_stmts (struct edge_list *el)\n \t     Thus, we only need to mark PHIs for real variables which\n \t     need their result preserved as being inherently necessary.  */\n \t  if (is_gimple_reg (PHI_RESULT (phi))\n-\t      && need_to_preserve_store (PHI_RESULT (phi)))\n+\t      && is_global_var (SSA_NAME_VAR (PHI_RESULT (phi))))\n \t    mark_stmt_necessary (phi, true);\n         }\n "}, {"sha": "4b899eec5262d9fc01ce3c4b4649c92c396a9b15", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -1373,8 +1373,8 @@ get_call_expr_operands (tree stmt, tree expr)\n       /* A 'pure' or a 'const' functions never call clobber anything. \n \t A 'noreturn' function might, but since we don't return anyway \n \t there is no point in recording that.  */ \n-      if (!(call_flags\n-\t    & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n+      if (TREE_SIDE_EFFECTS (expr)\n+\t  && !(call_flags & (ECF_PURE | ECF_CONST | ECF_NORETURN)))\n \tadd_call_clobber_ops (stmt);\n       else if (!(call_flags & (ECF_CONST | ECF_NORETURN)))\n \tadd_call_read_ops (stmt);"}, {"sha": "a6b17da494baf3ddc6f8f9a5390820421e1c76f0", "filename": "gcc/tree.c", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -5624,15 +5624,22 @@ in_array_bounds_p (tree ref)\n   return true;\n }\n \n+/* Return true if T (assumed to be a DECL) is a global variable.  */\n+\n+bool\n+is_global_var (tree t)\n+{\n+  return (TREE_STATIC (t) || DECL_EXTERNAL (t));\n+}\n+\n /* Return true if T (assumed to be a DECL) must be assigned a memory\n    location.  */\n \n bool\n needs_to_live_in_memory (tree t)\n {\n-  return (DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL (t)\n-\t  || TREE_STATIC (t)\n-          || DECL_EXTERNAL (t)\n+  return (TREE_ADDRESSABLE (t)\n+\t  || is_global_var (t)\n \t  || (TREE_CODE (t) == RESULT_DECL\n \t      && aggregate_value_p (t, current_function_decl)));\n }"}, {"sha": "e596f90d21269e4bd1a1c6a49e9fc8345cd51638", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -2161,15 +2161,6 @@ struct tree_binfo GTY (())\n   (! DECL_CONTEXT (EXP)\t\t\t\t\t\t\\\n    || TREE_CODE (DECL_CONTEXT (EXP)) == TRANSLATION_UNIT_DECL)\n \n-/* Nonzero for a decl that has been marked as needing a memory slot.\n-   NOTE: Never use this macro directly.  It will give you incomplete\n-   information. Most of the time this bit will only be set after alias\n-   analysis in the tree optimizers.  It's always better to call\n-   needs_to_live_in_memory instead.  To mark memory variables use\n-   mark_call_clobbered.  */\n-#define DECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL(DECL)\t\t\\\n-  DECL_CHECK (DECL)->decl.needs_to_live_in_memory\n-\n /* Nonzero for a decl that cgraph has decided should be inlined into\n    at least one call site.  It is not meaningful to look at this\n    directly; always use cgraph_function_possibly_inlined_p.  */\n@@ -2242,9 +2233,8 @@ struct tree_decl GTY(())\n   unsigned lang_flag_6 : 1;\n   unsigned lang_flag_7 : 1;\n \n-  unsigned needs_to_live_in_memory : 1;\n   unsigned possibly_inlined : 1;\n-  /* 14 unused bits.  */\n+  /* 15 unused bits.  */\n \n   union tree_decl_u1 {\n     /* In a FUNCTION_DECL for which DECL_BUILT_IN holds, this is\n@@ -3479,6 +3469,7 @@ extern void expand_function_end (void);\n extern void expand_function_start (tree);\n extern void expand_pending_sizes (tree);\n extern void recompute_tree_invarant_for_addr_expr (tree);\n+extern bool is_global_var (tree t);\n extern bool needs_to_live_in_memory (tree);\n extern tree reconstruct_complex_type (tree, tree);\n "}, {"sha": "54e307cc8444f64aa04baf3217b7cdc275d30db5", "filename": "libjava/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -1,3 +1,8 @@\n+2004-08-12  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tPR tree-optimization/16867\n+\t* testsuite/libjava.lang/PR16867.java: New test.\n+\n 2004-08-09  Per Bothner  <per@bothner.com>\n \n \t* gcj/javaprims.h (_Jv_Utf8Const): Change struct to a class,"}, {"sha": "6862892304fca07f8ecd5cd808f92a83f81e2c8d", "filename": "libjava/testsuite/libjava.lang/PR16867.java", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.java?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -0,0 +1,17 @@\n+/* SSA-DCE was removing the initialization of the temporary object\n+   in getFoo because it wasn't realizing that the pointer was needed\n+   outside of it.  */\n+\n+public class PR16867\n+{\n+  public static Object[] getFoo()\n+  {\n+    return new Object[] {\"OK\"};\n+  }\n+\n+  public static void main(String[] args)\n+  {\n+    Object[] a = getFoo();\n+    System.out.println(a[0]);\n+  }\n+}"}, {"sha": "d86bac9de59abcc26bc7956c1e842237c7581859", "filename": "libjava/testsuite/libjava.lang/PR16867.out", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.out", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c597ef4eab9a2de9ad0b2187547ac9bac0b53132/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.out", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Ftestsuite%2Flibjava.lang%2FPR16867.out?ref=c597ef4eab9a2de9ad0b2187547ac9bac0b53132", "patch": "@@ -0,0 +1 @@\n+OK"}]}