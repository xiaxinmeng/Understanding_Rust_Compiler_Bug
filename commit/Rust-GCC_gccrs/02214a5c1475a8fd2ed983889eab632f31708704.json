{"sha": "02214a5c1475a8fd2ed983889eab632f31708704", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDIyMTRhNWMxNDc1YThmZDJlZDk4Mzg4OWVhYjYzMmYzMTcwODcwNA==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:30:26Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-10-23T14:30:26Z"}, "message": "(emit_libcall_block): Before adding an REG_EQUAL note, check that it will really apply to a single instruction.\n\n(emit_libcall_block): Before adding an REG_EQUAL note, check that it will\nreally apply to a single instruction.\n(expand_binop, expand_fix): Likewise.\n\nFrom-SVN: r13005", "tree": {"sha": "47bb500a8efd2abe9289f806cc3d31a6d6ec25a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47bb500a8efd2abe9289f806cc3d31a6d6ec25a9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02214a5c1475a8fd2ed983889eab632f31708704", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02214a5c1475a8fd2ed983889eab632f31708704", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02214a5c1475a8fd2ed983889eab632f31708704", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02214a5c1475a8fd2ed983889eab632f31708704/comments", "author": null, "committer": null, "parents": [{"sha": "39647dcba53dcaa2e18984b86f5546589e92738a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/39647dcba53dcaa2e18984b86f5546589e92738a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/39647dcba53dcaa2e18984b86f5546589e92738a"}], "stats": {"total": 53, "additions": 32, "deletions": 21}, "files": [{"sha": "d743fc8bd5ecbaa97d61e74eb93542b69ab3c56c", "filename": "gcc/optabs.c", "status": "modified", "additions": 32, "deletions": 21, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02214a5c1475a8fd2ed983889eab632f31708704/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02214a5c1475a8fd2ed983889eab632f31708704/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=02214a5c1475a8fd2ed983889eab632f31708704", "patch": "@@ -964,13 +964,16 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n       if (i == GET_MODE_BITSIZE (mode) / BITS_PER_WORD)\n \t{\n-\t  rtx temp = emit_move_insn (target, target);\n+\t  if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t    {\n+\t      rtx temp = emit_move_insn (target, target);\n \n-\t  REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t      gen_rtx (binoptab->code, mode,\n-\t\t\t\t\t       copy_rtx (xop0),\n-\t\t\t\t\t       copy_rtx (xop1)),\n-\t\t\t\t      REG_NOTES (temp));\n+\t      REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t\t\t  gen_rtx (binoptab->code, mode,\n+\t\t\t\t\t\t   copy_rtx (xop0),\n+\t\t\t\t\t\t   copy_rtx (xop1)),\n+\t\t\t\t\t  REG_NOTES (temp));\n+\t    }\n \t  return target;\n \t}\n       else\n@@ -1144,12 +1147,15 @@ expand_binop (mode, binoptab, op0, op1, target, unsignedp, methods)\n \n \t  if (temp != 0)\n \t    {\n-\t      temp = emit_move_insn (product, product);\n-\t      REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t\t  gen_rtx (MULT, mode, copy_rtx (op0),\n-\t\t\t\t\t\t   copy_rtx (op1)),\n-\t\t\t\t\t  REG_NOTES (temp));\n-\n+\t      if (mov_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+\t\t{\n+\t\t  temp = emit_move_insn (product, product);\n+\t\t  REG_NOTES (temp) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t\t\t      gen_rtx (MULT, mode,\n+\t\t\t\t\t\t       copy_rtx (op0),\n+\t\t\t\t\t\t       copy_rtx (op1)),\n+\t\t\t\t\t      REG_NOTES (temp));\n+\t\t}\n \t      return product;\n \t    }\n \t}\n@@ -2613,8 +2619,10 @@ emit_libcall_block (insns, target, result, equiv)\n     }\n \n   last = emit_move_insn (target, result);\n-  REG_NOTES (last) = gen_rtx (EXPR_LIST,\n-\t\t\t      REG_EQUAL, copy_rtx (equiv), REG_NOTES (last));\n+  if (mov_optab->handlers[(int) GET_MODE (target)].insn_code\n+      != CODE_FOR_nothing)\n+    REG_NOTES (last) = gen_rtx (EXPR_LIST,\n+\t\t\t\tREG_EQUAL, copy_rtx (equiv), REG_NOTES (last));\n \n   if (prev == 0)\n     first = get_insns ();\n@@ -3823,13 +3831,16 @@ expand_fix (to, from, unsignedp)\n \n \t  emit_label (lab2);\n \n-\t  /* Make a place for a REG_NOTE and add it.  */\n-\t  insn = emit_move_insn (to, to);\n-\t  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n-\t\t\t\t      gen_rtx (UNSIGNED_FIX, GET_MODE (to),\n-\t\t\t\t\t       copy_rtx (from)),\n-\t\t\t\t      REG_NOTES (insn));\n-\n+\t  if (mov_optab->handlers[(int) GET_MODE (to)].insn_code\n+\t      != CODE_FOR_nothing)\n+\t    {\n+\t      /* Make a place for a REG_NOTE and add it.  */\n+\t      insn = emit_move_insn (to, to);\n+\t      REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_EQUAL,\n+\t\t\t\t\t  gen_rtx (UNSIGNED_FIX, GET_MODE (to),\n+\t\t\t\t\t\t   copy_rtx (from)),\n+\t\t\t\t\t  REG_NOTES (insn));\n+\t    }\n \t  return;\n \t}\n #endif"}]}