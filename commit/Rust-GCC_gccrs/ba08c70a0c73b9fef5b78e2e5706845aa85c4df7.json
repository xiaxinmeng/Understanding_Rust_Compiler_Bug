{"sha": "ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmEwOGM3MGEwYzczYjlmZWY1Yjc4ZTJlNTcwNjg0NWFhODVjNGRmNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-09-30T12:22:07Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2018-09-30T12:22:07Z"}, "message": "re PR fortran/70752 (Incorrect LEN for ALLOCATABLE CHARACTER)\n\n2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70752\n\tPR fortran/72709\n\t* trans-array.c (gfc_conv_scalarized_array_ref): If this is a\n\tdeferred type and the info->descriptor is present, use the\n\tinfo->descriptor\n\t(gfc_conv_array_ref): Is the se expr is a descriptor type, pass\n\tit as 'decl' rather than the symbol backend_decl.\n\t(gfc_array_allocate): If the se string_length is a component\n\treference, fix it and use it for the expression string length\n\tif the latter is not a variable type. If it is a variable do\n\tan assignment. Make use of component ref string lengths to set\n\tthe descriptor 'span'.\n\t(gfc_conv_expr_descriptor): For pointer assignment, do not set\n\tthe span field if gfc_get_array_span returns zero.\n\t* trans.c (get_array_span): If the upper bound a character type\n\tis zero, use the descriptor span if available.\n\n\n2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/70752\n\tPR fortran/72709\n\t* gfortran.dg/deferred_character_25.f90 : New test.\n\t* gfortran.dg/deferred_character_26.f90 : New test.\n\t* gfortran.dg/deferred_character_27.f90 : New test to verify\n\tthat PR82617 remains fixed.\n\nFrom-SVN: r264724", "tree": {"sha": "52932d1b845b28c268d7a49e53166ffcfb5b5e55", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52932d1b845b28c268d7a49e53166ffcfb5b5e55"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/comments", "author": null, "committer": null, "parents": [{"sha": "f1525dd4b4c4e57e8dd6f1c1a90f1a148b3da945", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f1525dd4b4c4e57e8dd6f1c1a90f1a148b3da945", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f1525dd4b4c4e57e8dd6f1c1a90f1a148b3da945"}], "stats": {"total": 248, "additions": 244, "deletions": 4}, "files": [{"sha": "318567b68935c121c53d71aee8de4eb1853dd985", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -1,3 +1,22 @@\n+2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70752\n+\tPR fortran/72709\n+\t* trans-array.c (gfc_conv_scalarized_array_ref): If this is a\n+\tdeferred type and the info->descriptor is present, use the\n+\tinfo->descriptor\n+\t(gfc_conv_array_ref): Is the se expr is a descriptor type, pass\n+\tit as 'decl' rather than the symbol backend_decl.\n+\t(gfc_array_allocate): If the se string_length is a component\n+\treference, fix it and use it for the expression string length\n+\tif the latter is not a variable type. If it is a variable do\n+\tan assignment. Make use of component ref string lengths to set\n+\tthe descriptor 'span'.\n+\t(gfc_conv_expr_descriptor): For pointer assignment, do not set\n+\tthe span field if gfc_get_array_span returns zero.\n+\t* trans.c (get_array_span): If the upper bound a character type\n+\tis zero, use the descriptor span if available.\n+\n 2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/70149"}, {"sha": "035257aab120ad0a44484b4655e94698d9a8fd8d", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 44, "deletions": 4, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -3423,7 +3423,9 @@ gfc_conv_scalarized_array_ref (gfc_se * se, gfc_array_ref * ar)\n   /* A pointer array component can be detected from its field decl. Fix\n      the descriptor, mark the resulting variable decl and pass it to\n      gfc_build_array_ref.  */\n-  if (is_pointer_array (info->descriptor))\n+  if (is_pointer_array (info->descriptor)\n+      || (expr && expr->ts.deferred && info->descriptor\n+\t  && GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (info->descriptor))))\n     {\n       if (TREE_CODE (info->descriptor) == COMPONENT_REF)\n \tdecl = info->descriptor;\n@@ -3676,7 +3678,16 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n   else if (expr->ts.deferred\n \t   || (sym->ts.type == BT_CHARACTER\n \t       && sym->attr.select_type_temporary))\n-    decl = sym->backend_decl;\n+    {\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se->expr)))\n+\t{\n+\t  decl = se->expr;\n+\t  if (TREE_CODE (decl) == INDIRECT_REF)\n+\t    decl = TREE_OPERAND (decl, 0);\n+\t}\n+      else\n+\tdecl = sym->backend_decl;\n+    }\n   else if (sym->ts.type == BT_CLASS)\n     decl = NULL_TREE;\n \n@@ -5761,6 +5772,19 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n \n   overflow = integer_zero_node;\n \n+  if (expr->ts.type == BT_CHARACTER\n+      && TREE_CODE (se->string_length) == COMPONENT_REF\n+      && expr->ts.u.cl->backend_decl != se->string_length)\n+    {\n+      if (VAR_P (expr->ts.u.cl->backend_decl))\n+\tgfc_add_modify (&se->pre, expr->ts.u.cl->backend_decl,\n+\t\t\tfold_convert (TREE_TYPE (expr->ts.u.cl->backend_decl),\n+\t\t\t\t      se->string_length));\n+      else\n+\texpr->ts.u.cl->backend_decl = gfc_evaluate_now (se->string_length,\n+\t\t\t\t\t\t\t&se->pre);\n+    }\n+\n   gfc_init_block (&set_descriptor_block);\n   /* Take the corank only from the actual ref and not from the coref.  The\n      later will mislead the generation of the array dimensions for allocatable/\n@@ -5850,10 +5874,26 @@ gfc_array_allocate (gfc_se * se, gfc_expr * expr, tree status, tree errmsg,\n   /* Pointer arrays need the span field to be set.  */\n   if (is_pointer_array (se->expr)\n       || (expr->ts.type == BT_CLASS\n-\t  && CLASS_DATA (expr)->attr.class_pointer))\n+\t  && CLASS_DATA (expr)->attr.class_pointer)\n+      || (expr->ts.type == BT_CHARACTER\n+\t  && TREE_CODE (se->string_length) == COMPONENT_REF))\n     {\n       if (expr3 && expr3_elem_size != NULL_TREE)\n \ttmp = expr3_elem_size;\n+      else if (se->string_length\n+\t       && TREE_CODE (se->string_length) == COMPONENT_REF)\n+\t{\n+\t  if (expr->ts.kind != 1)\n+\t    {\n+\t      tmp = build_int_cst (gfc_array_index_type, expr->ts.kind);\n+\t      tmp = fold_build2_loc (input_location, MULT_EXPR,\n+\t\t\t\t    gfc_array_index_type, tmp,\n+\t\t\t\t    fold_convert (gfc_array_index_type,\n+\t\t\t\t\t\t  se->string_length));\n+\t    }\n+\t  else\n+\t    tmp = se->string_length;\n+\t}\n       else\n \ttmp = TYPE_SIZE_UNIT (gfc_get_element_type (TREE_TYPE (se->expr)));\n       tmp = fold_convert (gfc_array_index_type, tmp);\n@@ -7086,7 +7126,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \n \t      /* ....and set the span field.  */\n \t      tmp = gfc_get_array_span (desc, expr);\n-\t      if (tmp != NULL_TREE)\n+\t      if (tmp != NULL_TREE && !integer_zerop (tmp))\n \t\tgfc_conv_descriptor_span_set (&se->pre, se->expr, tmp);\n \t    }\n \t  else if (se->want_pointer)"}, {"sha": "9297b2ffd6ab1370691cbea88fe6a80562284ec3", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -307,6 +307,15 @@ get_array_span (tree type, tree decl)\n \t\t\t\t\tTYPE_SIZE_UNIT (TREE_TYPE (type))),\n \t\t\t  span);\n     }\n+  else if (type && TREE_CODE (type) == ARRAY_TYPE\n+\t   && TYPE_MAX_VALUE (TYPE_DOMAIN (type)) != NULL_TREE\n+\t   && integer_zerop (TYPE_MAX_VALUE (TYPE_DOMAIN (type))))\n+    {\n+      if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n+\tspan = gfc_conv_descriptor_span_get (decl);\n+      else\n+\tspan = NULL_TREE;\n+    }\n   /* Likewise for class array or pointer array references.  */\n   else if (TREE_CODE (decl) == FIELD_DECL\n \t   || VAR_OR_FUNCTION_DECL_P (decl)"}, {"sha": "e06098d0b6a634502551aa48adf294514788e367", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -1,3 +1,12 @@\n+2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/70752\n+\tPR fortran/72709\n+\t* gfortran.dg/deferred_character_25.f90 : New test.\n+\t* gfortran.dg/deferred_character_26.f90 : New test.\n+\t* gfortran.dg/deferred_character_27.f90 : New test to verify\n+\tthat PR82617 remains fixed.\n+\n 2018-09-30  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/70149"}, {"sha": "906df94bfa94cc3b2bd26455f1c6b906f0b4ace5", "filename": "gcc/testsuite/gfortran.dg/deferred_character_25.f90", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_25.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_25.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_25.f90?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -0,0 +1,34 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR70752 in which the type of the component 'c' is cast\n+! as character[1:0], which makes it slightly more difficult than usual to\n+! obtain the element length.  This is one and the same bug as PR72709.\n+!\n+! Contributed by Gilbert Scott  <gilbert.scott@easynet.co.uk>\n+!\n+PROGRAM TEST\n+  IMPLICIT NONE\n+  INTEGER, PARAMETER :: I = 3\n+  character (len = i), parameter :: str(5) = ['abc','cde','fgh','ijk','lmn']\n+\n+  TYPE T\n+    CHARACTER(LEN=:), ALLOCATABLE :: C(:)\n+  END TYPE T\n+  TYPE(T), TARGET :: S\n+  CHARACTER (LEN=I), POINTER :: P(:)\n+\n+  ALLOCATE ( CHARACTER(LEN=I) :: S%C(5) )\n+  s%c = str\n+\n+! This PR uncovered several problems associated with determining the\n+! element length and indexing. Test fairly thoroughly!\n+  if (SIZE(S%C, 1) .ne. 5) stop 1\n+  if (LEN(S%C) .ne. 3) stop 2\n+  if (any (s%c .ne. str)) stop 3\n+  if (s%c(3) .ne. str(3)) stop 4\n+  P => S%C\n+  if (SIZE(p, 1) .ne. 5) stop 5\n+  if (LEN(p) .ne. 3) stop 6\n+  if (any (p .ne. str)) stop 7\n+  if (p(5) .ne. str(5)) stop 8\n+END PROGRAM TEST"}, {"sha": "4f335d720d29ef5930eb730860319b245a95635f", "filename": "gcc/testsuite/gfortran.dg/deferred_character_26.f90", "status": "added", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_26.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_26.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_26.f90?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -0,0 +1,42 @@\n+! { dg-do run }\n+!\n+! Test the fix for PR72709 in which the type of the component 'header' is cast\n+! as character[1:0], which makes it slightly more difficult than usual to\n+! obtain the element length. This is one and the same bug as PR70752.\n+!\n+! Contributed by 'zmi'  <zmi007@gmail.com>\n+!\n+program    read_exp_data\n+   implicit none\n+\n+   type experimental_data_t\n+      integer :: nh = 0\n+      character(len=:), dimension(:), allocatable :: header\n+\n+   end type experimental_data_t\n+\n+   character(*), parameter :: str(3) = [\"#Generated by X      \", &\n+                                        \"#from file 'Y'       \", &\n+                                        \"# Experimental 4 mg/g\"]\n+   type(experimental_data_t) :: ex\n+   integer :: nh_len\n+   integer :: i\n+\n+\n+   nh_len = 255\n+   ex % nh = 3\n+   allocate(character(len=nh_len) :: ex % header(ex % nh))\n+\n+   ex % header(1) = str(1)\n+   ex % header(2) = str(2)\n+   ex % header(3) = str(3)\n+\n+! Test that the string length is OK\n+   if (len (ex%header) .ne. nh_len) stop 1\n+\n+! Test the array indexing\n+   do i = 1, ex % nh\n+      if (trim (ex%header(i)) .ne. trim (str(i))) stop i + 1\n+   enddo\n+\n+end program read_exp_data"}, {"sha": "7a5e4c6c30aec3e9371b2c622731e62aa1555e16", "filename": "gcc/testsuite/gfortran.dg/deferred_character_27.f90", "status": "added", "additions": 87, "deletions": 0, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_27.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ba08c70a0c73b9fef5b78e2e5706845aa85c4df7/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_27.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fdeferred_character_27.f90?ref=ba08c70a0c73b9fef5b78e2e5706845aa85c4df7", "patch": "@@ -0,0 +1,87 @@\n+! { dg-do compile }\n+!\n+! Make sure that PR82617 remains fixed. The first attempt at a\n+! fix for PR70752 cause this to ICE at the point indicated below.\n+!\n+! Contributed by Ogmundur Petersson  <uberprugelknabe@hotmail.com>\n+!\n+MODULE test\n+\n+  IMPLICIT NONE\n+\n+  PRIVATE\n+  PUBLIC str_words\n+\n+  !> Characters that are considered whitespace.\n+  CHARACTER(len=*), PARAMETER :: strwhitespace = &\n+    char(32)//& ! space\n+    char(10)//& ! new line\n+    char(13)//& ! carriage return\n+    char( 9)//& ! horizontal tab\n+    char(11)//& ! vertical tab\n+    char(12)    ! form feed (new page)\n+\n+  CONTAINS\n+\n+  ! -------------------------------------------------------------------\n+  !> Split string into words separated by arbitrary strings of whitespace\n+  !> characters (space, tab, newline, return, formfeed).\n+  FUNCTION str_words(str,white) RESULT(items)\n+    CHARACTER(len=:), DIMENSION(:), ALLOCATABLE :: items\n+    CHARACTER(len=*), INTENT(in) :: str !< String to split.\n+    CHARACTER(len=*), INTENT(in) :: white ! Whitespace characters.\n+\n+    items = strwords_impl(str,white)\n+\n+  END FUNCTION str_words\n+\n+  ! -------------------------------------------------------------------\n+  !>Implementation of str_words\n+  !> characters (space, tab, newline, return, formfeed).\n+  FUNCTION strwords_impl(str,white) RESULT(items)\n+    CHARACTER(len=:), DIMENSION(:), ALLOCATABLE :: items\n+    CHARACTER(len=*), INTENT(in) :: str !< String to split.\n+    CHARACTER(len=*), INTENT(in) :: white ! Whitespace characters.\n+\n+    INTEGER :: i0,i1,n\n+    INTEGER :: l_item,i_item,n_item\n+\n+    n = verify(str,white,.TRUE.)\n+    IF (n>0) THEN\n+      n_item = 0\n+      l_item = 0\n+      i1 = 0\n+      DO\n+        i0 = verify(str(i1+1:n),white)+i1\n+        i1 = scan(str(i0+1:n),white)\n+        n_item = n_item+1\n+        IF (i1>0) THEN\n+          l_item = max(l_item,i1)\n+          i1 = i0+i1\n+        ELSE\n+          l_item = max(l_item,n-i0+1)\n+          EXIT\n+        END IF\n+      END DO\n+      ALLOCATE(CHARACTER(len=l_item)::items(n_item))\n+      i_item = 0\n+      i1 = 0\n+      DO\n+        i0 = verify(str(i1+1:n),white)+i1\n+        i1 = scan(str(i0+1:n),white)\n+        i_item = i_item+1\n+        IF (i1>0) THEN\n+          i1 = i0+i1\n+          items(i_item) = str(i0:i1-1)\n+        ELSE\n+          items(i_item) = str(i0:n)\n+          EXIT\n+        END IF\n+      END DO\n+    ELSE\n+      ALLOCATE(CHARACTER(len=0)::items(0))\n+    END IF\n+\n+  END FUNCTION strwords_impl\n+\n+END MODULE test"}]}