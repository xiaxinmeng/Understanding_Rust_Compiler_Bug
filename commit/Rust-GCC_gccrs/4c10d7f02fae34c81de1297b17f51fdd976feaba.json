{"sha": "4c10d7f02fae34c81de1297b17f51fdd976feaba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMxMGQ3ZjAyZmFlMzRjODFkZTEyOTdiMTdmNTFmZGQ5NzZmZWFiYQ==", "commit": {"author": {"name": "Dhruv Matani", "email": "dhruvbird@gmx.net", "date": "2004-12-19T11:17:40Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-12-19T11:17:40Z"}, "message": "bitmap_allocator.h: Make doxygen style comments for internal functions and classes.\n\n2004-12-19  Dhruv Matani  <dhruvbird@gmx.net>\n\n\t* include/ext/bitmap_allocator.h: Make doxygen style comments for\n\tinternal functions and classes.\n\nFrom-SVN: r92376", "tree": {"sha": "4f4f8e4fc72dc7f29fe5764f0ead2aa03f7c19a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f4f8e4fc72dc7f29fe5764f0ead2aa03f7c19a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c10d7f02fae34c81de1297b17f51fdd976feaba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c10d7f02fae34c81de1297b17f51fdd976feaba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c10d7f02fae34c81de1297b17f51fdd976feaba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c10d7f02fae34c81de1297b17f51fdd976feaba/comments", "author": null, "committer": null, "parents": [{"sha": "b8ad24b99ff364fec30afa329e359c75d0afde49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b8ad24b99ff364fec30afa329e359c75d0afde49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b8ad24b99ff364fec30afa329e359c75d0afde49"}], "stats": {"total": 204, "additions": 155, "deletions": 49}, "files": [{"sha": "5862179219775f458c7f0429ba443d4ac3a3c6c2", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c10d7f02fae34c81de1297b17f51fdd976feaba/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c10d7f02fae34c81de1297b17f51fdd976feaba/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=4c10d7f02fae34c81de1297b17f51fdd976feaba", "patch": "@@ -1,3 +1,8 @@\n+2004-12-19  Dhruv Matani  <dhruvbird@gmx.net>\n+\t\n+\t* include/ext/bitmap_allocator.h: Make doxygen style comments for\n+\tinternal functions and classes.\n+\n 2004-12-19  Dhruv Matani  <dhruvbird@gmx.net>\n \t\n \t* docs/html/20_util/allocator.html: Correct link."}, {"sha": "9f02065046fe9065da631391667c442df5ba5043", "filename": "libstdc++-v3/include/ext/bitmap_allocator.h", "status": "modified", "additions": 150, "deletions": 49, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c10d7f02fae34c81de1297b17f51fdd976feaba/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c10d7f02fae34c81de1297b17f51fdd976feaba/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fext%2Fbitmap_allocator.h?ref=4c10d7f02fae34c81de1297b17f51fdd976feaba", "patch": "@@ -56,8 +56,9 @@\n // itself(to debug the allocator itself).\n //#define _BALLOC_SANITY_CHECK\n \n-// The constant in the expression below is the alignment required in\n-// bytes.\n+/** @brief The constant in the expression below is the alignment\n+ * required in bytes.\n+ */\n #define _BALLOC_ALIGN_BYTES 8\n \n #if defined _BALLOC_SANITY_CHECK\n@@ -73,17 +74,23 @@ namespace __gnu_cxx\n #if defined __GTHREADS\n   namespace\n   {\n-    // If true, then the application being compiled will be using\n-    // threads, so use mutexes as a synchronization primitive, else do\n-    // no use any synchronization primitives.\n+    /** @brief  If true, then the application being compiled will be\n+     *  using threads, so use mutexes as a synchronization primitive,\n+     *  else do no use any synchronization primitives.\n+     */\n     bool const __threads_enabled = __gthread_active_p();\n   }\n #endif\n \n #if defined __GTHREADS\n-  // _Mutex is an OO-Wrapper for __gthread_mutex_t. It does not allow\n-  // you to copy or assign an already initialized mutex. This is used\n-  // merely as a convenience for the locking classes.\n+  /** @class  _Mutex bitmap_allocator.h bitmap_allocator.h\n+   *\n+   *  @brief  _Mutex is an OO-Wrapper for __gthread_mutex_t. \n+   *\n+   *  It does not allow you to copy or assign an already initialized\n+   *  mutex. This is used merely as a convenience for the locking\n+   *  classes.\n+   */\n   class _Mutex \n   {\n     __gthread_mutex_t _M_mut;\n@@ -115,12 +122,16 @@ namespace __gnu_cxx\n     _M_get() { return &_M_mut; }\n   };\n \n-  // _Lock is a simple manual lokcing class which allows you to\n-  // manually lock and unlock a mutex associated with the lock. There\n-  // is not automatic locking or unlocking happening without the\n-  // programmer's explicit instructions. This class unlocks the mutex\n-  // ONLY if it has not been locked. However, this check does not\n-  // apply for lokcing, and wayward use may cause dead-locks.\n+  /** @class  _Lock bitmap_allocator.h bitmap_allocator.h\n+   *\n+   *  @brief  _Lock is a simple manual locking class which allows you to\n+   *  manually lock and unlock a mutex associated with the lock. \n+   *\n+   *  There is no automatic locking or unlocking happening without the\n+   *  programmer's explicit instructions. This class unlocks the mutex\n+   *  ONLY if it has not been locked. However, this check does not\n+   *  apply for locking, and wayward use may cause dead-locks.\n+   */\n   class _Lock \n   {\n     _Mutex* _M_pmt;\n@@ -161,9 +172,14 @@ namespace __gnu_cxx\n     ~_Lock() { }\n   };\n \n-  // _Auto_Lock locks the associated mutex on construction, and\n-  // unlocks on it's destruction. There are no checks performed, and\n-  // this calss follows the RAII principle.\n+  /** @class  _Auto_Lock bitmap_allocator.h bitmap_allocator.h\n+   *\n+   *  @brief  _Auto_Lock locks the associated mutex on construction, and\n+   *  unlocks on destruction.\n+   *\n+   *  There are no checks performed, and this class follows the RAII\n+   *  principle.\n+   */\n   class _Auto_Lock \n   {\n     _Mutex* _M_pmt;\n@@ -195,14 +211,22 @@ namespace __gnu_cxx\n \n   namespace balloc\n   {\n-    // __mini_vector<> is to be used only for built-in types or\n-    // PODs. It is a stripped down version of the full-fledged\n-    // std::vector<>. Noteable differences are: \n-    // \n-    // 1. Not all accessor functions are present.\n-    // 2. Used ONLY for PODs.\n-    // 3. No Allocator template argument. Uses ::operator new() to get\n-    // memory, and ::operator delete() to free it.\n+    /** @class  __mini_vector bitmap_allocator.h bitmap_allocator.h\n+     *\n+     *  @brief  __mini_vector<> is a stripped down version of the\n+     *  full-fledged std::vector<>.\n+     *\n+     *  It is to be used only for built-in types or PODs. Notable\n+     *  differences are:\n+     * \n+     *  @detail\n+     *  1. Not all accessor functions are present.\n+     *  2. Used ONLY for PODs.\n+     *  3. No Allocator template argument. Uses ::operator new() to get\n+     *  memory, and ::operator delete() to free it.\n+     *  Caveat: The dtor does NOT free the memory allocated, so this a\n+     *  memory-leaking vector!\n+     */\n     template<typename _Tp>\n       class __mini_vector\n       {\n@@ -421,11 +445,17 @@ namespace __gnu_cxx\n \treturn __first;\n       }\n \n+    /** @brief The number of Blocks pointed to by the address pair\n+     *  passed to the function.\n+     */\n     template<typename _AddrPair>\n       inline size_t\n       __num_blocks(_AddrPair __ap)\n       { return (__ap.second - __ap.first) + 1; }\n \n+    /** @brief The number of Bit-maps pointed to by the address pair\n+     *  passed to the function.\n+     */\n     template<typename _AddrPair>\n       inline size_t\n       __num_bitmaps(_AddrPair __ap)\n@@ -475,6 +505,11 @@ namespace __gnu_cxx\n \t{ return _M_fref(__arg); }\n       };\n \n+    /** @class  _Ffit_finder bitmap_allocator.h bitmap_allocator.h\n+     *\n+     *  @brief  The class which acts as a predicate for applying the\n+     *  first-fit memory allocation policy for the bitmap allocator.\n+     */\n     // _Tp should be a pointer type, and _Alloc is the Allocator for\n     // the vector.\n     template<typename _Tp>\n@@ -539,7 +574,12 @@ namespace __gnu_cxx\n       };\n \n \n-  \n+    /** @class  _Bitmap_counter bitmap_allocator.h bitmap_allocator.h\n+     *\n+     *  @brief  The bitmap counter which acts as the bitmap\n+     *  manipulator, and manages the bit-manipulation functions and\n+     *  the searching and identification functions on the bit-map.\n+     */\n     // _Tp should be a pointer type.\n     template<typename _Tp>\n       class _Bitmap_counter\n@@ -630,6 +670,9 @@ namespace __gnu_cxx\n \t{ return _M_curr_index; }\n       };\n \n+    /** @brief  Mark a memory address as allocated by re-setting the\n+     *  corresponding bit in the bit-map.\n+     */\n     inline void \n     __bit_allocate(size_t* __pbmap, size_t __pos) throw()\n     {\n@@ -638,6 +681,9 @@ namespace __gnu_cxx\n       *__pbmap &= __mask;\n     }\n   \n+    /** @brief  Mark a memory address as free by setting the\n+     *  corresponding bit in the bit-map.\n+     */\n     inline void \n     __bit_free(size_t* __pbmap, size_t __pos) throw()\n     {\n@@ -646,11 +692,17 @@ namespace __gnu_cxx\n     }\n   } // namespace balloc\n \n-  // Generic Version of the bsf instruction.\n+  /** @brief  Generic Version of the bsf instruction.\n+   */\n   inline size_t \n   _Bit_scan_forward(size_t __num)\n   { return static_cast<size_t>(__builtin_ctzl(__num)); }\n \n+  /** @class  free_list bitmap_allocator.h bitmap_allocator.h\n+   *\n+   *  @brief  The free list class for managing chunks of memory to be\n+   *  given to and returned by the bitmap_allocator.\n+   */\n   class free_list\n   {\n     typedef size_t* value_type;\n@@ -669,7 +721,17 @@ namespace __gnu_cxx\n     static _Mutex _S_bfl_mutex;\n #endif\n     static vector_type _S_free_list;\n-    \n+\n+    /** @brief  Performs validation of memory based on their size.\n+     *\n+     *  @param  __addr The pointer to the memory block to be\n+     *  validated.\n+     *\n+     *  @detail  Validates the memory block passed to this function and\n+     *  appropriately performs the action of managing the free list of\n+     *  blocks by adding this block to the free list or deleting this\n+     *  or larger blocks from the free list.\n+     */\n     void\n     _M_validate(size_t* __addr) throw()\n     {\n@@ -704,6 +766,17 @@ namespace __gnu_cxx\n       _S_free_list.insert(__temp, __addr);\n     }\n \n+    /** @brief  Decides whether the wastage of memory is acceptable for\n+     *  the current memory request and returns accordingly.\n+     *\n+     *  @param __block_size The size of the block available in the free\n+     *  list.\n+     *\n+     *  @param __required_size The required size of the memory block.\n+     *\n+     *  @return true if the wastage incurred is acceptable, else returns\n+     *  false.\n+     */\n     bool \n     _M_should_i_give(size_t __block_size, \n \t\t     size_t __required_size) throw()\n@@ -718,6 +791,12 @@ namespace __gnu_cxx\n     }\n \n   public:\n+    /** @brief This function returns the block of memory to the\n+     *  internal free list.\n+     *\n+     *  @param  __addr The pointer to the memory block that was given\n+     *  by a call to the _M_get function.\n+     */\n     inline void \n     _M_insert(size_t* __addr) throw()\n     {\n@@ -730,11 +809,20 @@ namespace __gnu_cxx\n       // See discussion as to why this is 1!\n     }\n     \n+    /** @brief  This function gets a block of memory of the specified\n+     *  size from the free list.\n+     *\n+     *  @param  __sz The size in bytes of the memory required.\n+     *\n+     *  @return  A pointer to the new memory block of size at least\n+     *  equal to that requested.\n+     */\n     size_t*\n     _M_get(size_t __sz) throw(std::bad_alloc);\n \n-    // This function just clears the internal Free List, and gives back\n-    // all the memory to the OS.\n+    /** @brief  This function just clears the internal Free List, and\n+     *  gives back all the memory to the OS.\n+     */\n     void \n     _M_clear();\n   };\n@@ -820,12 +908,17 @@ namespace __gnu_cxx\n       }\n #endif\n \n-      // Complexity: O(1), but internally depends upon the complexity\n-      // of the function free_list::_M_get. The\n-      // part where the bitmap headers are written is of worst case\n-      // complexity: O(X),where X is the number of blocks of size\n-      // sizeof(value_type) within the newly acquired block. Having a\n-      // tight bound.\n+      /** @brief  Responsible for exponentially growing the internal\n+       *  memory pool.\n+       *\n+       *  @throw  std::bad_alloc. If memory can not be allocated.\n+       *\n+       *  @detail  Complexity: O(1), but internally depends upon the\n+       *  complexity of the function free_list::_M_get. The part where\n+       *  the bitmap headers are written has complexity: O(X),where X\n+       *  is the number of blocks of size sizeof(value_type) within\n+       *  the newly acquired block. Having a tight bound.\n+       */\n       void \n       _S_refill_pool() throw(std::bad_alloc)\n       {\n@@ -876,13 +969,19 @@ namespace __gnu_cxx\n \n     public:\n \n-      // Complexity: Worst case complexity is O(N), but that is hardly\n-      // ever hit. if and when this particular case is encountered,\n-      // the next few cases are guaranteed to have a worst case\n-      // complexity of O(1)!  That's why this function performs very\n-      // well on the average. you can consider this function to be\n-      // having a complexity referred to commonly as: Amortized\n-      // Constant time.\n+      /** @brief  Allocates memory for a single object of size\n+       *  sizeof(_Tp).\n+       *\n+       *  @throw  std::bad_alloc. If memory can not be allocated.\n+       *\n+       *  @detail  Complexity: Worst case complexity is O(N), but that\n+       *  is hardly ever hit. If and when this particular case is\n+       *  encountered, the next few cases are guaranteed to have a\n+       *  worst case complexity of O(1)!  That's why this function\n+       *  performs very well on average. You can consider this\n+       *  function to have a complexity referred to commonly as:\n+       *  Amortized Constant time.\n+       */\n       pointer \n       _M_allocate_single_object() throw(std::bad_alloc)\n       {\n@@ -973,9 +1072,14 @@ namespace __gnu_cxx\n \treturn __ret;\n       }\n \n-      // Complexity: O(lg(N)), but the worst case is hit quite often!\n-      // I need to do something about this. I'll be able to work on\n-      // it, only when I have some solid figures from a few real apps.\n+      /** @brief  Deallocates memory that belongs to a single object of\n+       *  size sizeof(_Tp).\n+       *\n+       *  @detail  Complexity: O(lg(N)), but the worst case is not hit\n+       *  often!  This is because containers usually deallocate memory\n+       *  close to each other and this case is handled in O(1) time by\n+       *  the deallocate function.\n+       */\n       void \n       _M_deallocate_single_object(pointer __p) throw()\n       {\n@@ -1080,9 +1184,6 @@ namespace __gnu_cxx\n       ~bitmap_allocator() throw()\n       { }\n \n-      // Complexity: O(1), but internally the complexity depends upon the\n-      // complexity of the function(s) _S_allocate_single_object and\n-      // operator new.\n       pointer \n       allocate(size_type __n)\n       {"}]}