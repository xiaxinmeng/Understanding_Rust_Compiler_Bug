{"sha": "1ae6fe9be53077b9225cec4eea1f52e5e539b741", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFlNmZlOWJlNTMwNzdiOTIyNWNlYzRlZWExZjUyZTVlNTM5Yjc0MQ==", "commit": {"author": {"name": "Martin Jambor", "email": "mjambor@suse.cz", "date": "2010-05-13T12:19:02Z"}, "committer": {"name": "Martin Jambor", "email": "jamborm@gcc.gnu.org", "date": "2010-05-13T12:19:02Z"}, "message": "gimple.c (gimple_fold_obj_type_ref): Removed (a replacement moved to gimple-fold.c).\n\n2010-05-13  Martin Jambor  <mjambor@suse.cz>\n\n\t* gimple.c (gimple_fold_obj_type_ref): Removed (a replacement moved to\n\tgimple-fold.c).\n\t* gimple-fold.c (get_base_binfo_for_type): New function.\n\t(gimple_get_relevant_ref_binfo): Likewise.\n\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n\t(gimple_fold_obj_type_ref): Likewise.\n\t(fold_gimple_call): Simplify condition for folding virtual calls\n\tand call gimple_fold_obj_type_ref.\n\t* gimple.h (gimple_get_relevant_ref_binfo): Declare.\n\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n\n\t* testsuite/g++.dg/otr-fold-1.C: New test.\n\t* testsuite/g++.dg/otr-fold-2.C: New test.\n\nFrom-SVN: r159362", "tree": {"sha": "738b62ee098203af9907f27ef12957227e55a707", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/738b62ee098203af9907f27ef12957227e55a707"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ae6fe9be53077b9225cec4eea1f52e5e539b741", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae6fe9be53077b9225cec4eea1f52e5e539b741", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ae6fe9be53077b9225cec4eea1f52e5e539b741", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ae6fe9be53077b9225cec4eea1f52e5e539b741/comments", "author": {"login": "jamborm", "id": 2180070, "node_id": "MDQ6VXNlcjIxODAwNzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2180070?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jamborm", "html_url": "https://github.com/jamborm", "followers_url": "https://api.github.com/users/jamborm/followers", "following_url": "https://api.github.com/users/jamborm/following{/other_user}", "gists_url": "https://api.github.com/users/jamborm/gists{/gist_id}", "starred_url": "https://api.github.com/users/jamborm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jamborm/subscriptions", "organizations_url": "https://api.github.com/users/jamborm/orgs", "repos_url": "https://api.github.com/users/jamborm/repos", "events_url": "https://api.github.com/users/jamborm/events{/privacy}", "received_events_url": "https://api.github.com/users/jamborm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2b45bf2152099996118ac8903d22718963cf1e99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b45bf2152099996118ac8903d22718963cf1e99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b45bf2152099996118ac8903d22718963cf1e99"}], "stats": {"total": 369, "additions": 317, "deletions": 52}, "files": [{"sha": "116ef8e9868230cb6b73efebff2953ed4b7eac04", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -1,3 +1,16 @@\n+2010-05-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* gimple.c (gimple_fold_obj_type_ref): Removed (a replacement moved to\n+\tgimple-fold.c).\n+\t* gimple-fold.c (get_base_binfo_for_type): New function.\n+\t(gimple_get_relevant_ref_binfo): Likewise.\n+\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n+\t(gimple_fold_obj_type_ref): Likewise.\n+\t(fold_gimple_call): Simplify condition for folding virtual calls\n+\tand call gimple_fold_obj_type_ref.\n+\t* gimple.h (gimple_get_relevant_ref_binfo): Declare.\n+\t(gimple_fold_obj_type_ref_known_binfo): Likewise.\n+\n 2010-05-13  Andreas Schwab  <schwab@linux-m68k.org>\n \n \t* config/rs6000/rs6000-protos.h"}, {"sha": "4fb1b3f0ba7a85534209e63022309c9d19ec9c1c", "filename": "gcc/gimple-fold.c", "status": "modified", "additions": 133, "deletions": 13, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple-fold.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple-fold.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-fold.c?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -1401,6 +1401,137 @@ gimple_fold_builtin (gimple stmt)\n   return result;\n }\n \n+/* Search for a base binfo of BINFO that corresponds to TYPE and return it if\n+   it is found or NULL_TREE if it is not.  */\n+\n+static tree\n+get_base_binfo_for_type (tree binfo, tree type)\n+{\n+  int i;\n+  tree base_binfo;\n+  tree res = NULL_TREE;\n+\n+  for (i = 0; BINFO_BASE_ITERATE (binfo, i, base_binfo); i++)\n+    if (TREE_TYPE (base_binfo) == type)\n+      {\n+\tgcc_assert (!res);\n+\tres = base_binfo;\n+      }\n+\n+  return res;\n+}\n+\n+/* Return a binfo describing the part of object referenced by expression REF.\n+   Return NULL_TREE if it cannot be determined.  REF can consist of a series of\n+   COMPONENT_REFs of a declaration or of an INDIRECT_REF or it can also be just\n+   a simple declaration, indirect reference or an SSA_NAME.  If the function\n+   discovers an INDIRECT_REF or an SSA_NAME, it will assume that the\n+   encapsulating type is described by KNOWN_BINFO, if it is not NULL_TREE.\n+   Otherwise the first non-artificial field declaration or the base declaration\n+   will be examined to get the encapsulating type. */\n+\n+tree\n+gimple_get_relevant_ref_binfo (tree ref, tree known_binfo)\n+{\n+  while (true)\n+    {\n+      if (TREE_CODE (ref) == COMPONENT_REF)\n+\t{\n+\t  tree par_type;\n+\t  tree binfo, base_binfo;\n+\t  tree field = TREE_OPERAND (ref, 1);\n+\n+\t  if (!DECL_ARTIFICIAL (field))\n+\t    {\n+\t      tree type = TREE_TYPE (field);\n+\t      if (TREE_CODE (type) == RECORD_TYPE)\n+\t\treturn TYPE_BINFO (type);\n+\t      else\n+\t\treturn NULL_TREE;\n+\t    }\n+\n+\t  par_type = TREE_TYPE (TREE_OPERAND (ref, 0));\n+\t  binfo = TYPE_BINFO (par_type);\n+\t  if (!binfo\n+\t      || BINFO_N_BASE_BINFOS (binfo) == 0)\n+\t    return NULL_TREE;\n+\n+\t  base_binfo = BINFO_BASE_BINFO (binfo, 0);\n+\t  if (BINFO_TYPE (base_binfo) != TREE_TYPE (field))\n+\t    {\n+\t      tree d_binfo;\n+\n+\t      d_binfo = gimple_get_relevant_ref_binfo (TREE_OPERAND (ref, 0),\n+\t\t\t\t\t\t       known_binfo);\n+\t      /* Get descendant binfo. */\n+\t      if (!d_binfo)\n+\t\treturn NULL_TREE;\n+\t      return get_base_binfo_for_type (d_binfo, TREE_TYPE (field));\n+\t    }\n+\n+\t  ref = TREE_OPERAND (ref, 0);\n+\t}\n+      else if (DECL_P (ref) && TREE_CODE (TREE_TYPE (ref)) == RECORD_TYPE)\n+\treturn TYPE_BINFO (TREE_TYPE (ref));\n+      else if (known_binfo\n+\t       && (TREE_CODE (ref) == SSA_NAME\n+\t\t   || TREE_CODE (ref) == INDIRECT_REF))\n+\treturn known_binfo;\n+      else\n+\treturn NULL_TREE;\n+    }\n+}\n+\n+/* Fold a OBJ_TYPE_REF expression to the address of a function. TOKEN is\n+   integer form of OBJ_TYPE_REF_TOKEN of the reference expression.  KNOWN_BINFO\n+   carries the binfo describing the true type of OBJ_TYPE_REF_OBJECT(REF).  */\n+\n+tree\n+gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT token, tree known_binfo)\n+{\n+  HOST_WIDE_INT i;\n+  tree v, fndecl;\n+\n+  v = BINFO_VIRTUALS (known_binfo);\n+  i = 0;\n+  while (i != token)\n+    {\n+      i += (TARGET_VTABLE_USES_DESCRIPTORS\n+\t    ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n+      v = TREE_CHAIN (v);\n+    }\n+\n+  fndecl = TREE_VALUE (v);\n+  return build_fold_addr_expr (fndecl);\n+}\n+\n+\n+/* Fold a OBJ_TYPE_REF expression to the address of a function.  If KNOWN_TYPE\n+   is not NULL_TREE, it is the true type of the outmost encapsulating object if\n+   that comes from a pointer SSA_NAME.  If the true outmost encapsulating type\n+   can be determined from a declaration OBJ_TYPE_REF_OBJECT(REF), it is used\n+   regardless of KNOWN_TYPE (which thus can be NULL_TREE).  */\n+\n+tree\n+gimple_fold_obj_type_ref (tree ref, tree known_type)\n+{\n+  tree obj = OBJ_TYPE_REF_OBJECT (ref);\n+  tree known_binfo = known_type ? TYPE_BINFO (known_type) : NULL_TREE;\n+  tree binfo;\n+\n+  if (TREE_CODE (obj) == ADDR_EXPR)\n+    obj = TREE_OPERAND (obj, 0);\n+\n+  binfo = gimple_get_relevant_ref_binfo (obj, known_binfo);\n+  if (binfo)\n+    {\n+      HOST_WIDE_INT token = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n+      return gimple_fold_obj_type_ref_known_binfo (token, binfo);\n+    }\n+  else\n+    return NULL_TREE;\n+}\n+\n /* Attempt to fold a call statement referenced by the statement iterator GSI.\n    The statement may be replaced by another statement, e.g., if the call\n    simplifies to a constant value. Return true if any changes were made.\n@@ -1428,29 +1559,18 @@ fold_gimple_call (gimple_stmt_iterator *gsi)\n     }\n   else\n     {\n-      /* Check for resolvable OBJ_TYPE_REF.  The only sorts we can resolve\n-         here are when we've propagated the address of a decl into the\n-         object slot.  */\n       /* ??? Should perhaps do this in fold proper.  However, doing it\n          there requires that we create a new CALL_EXPR, and that requires\n          copying EH region info to the new node.  Easier to just do it\n          here where we can just smash the call operand.  */\n       /* ??? Is there a good reason not to do this in fold_stmt_inplace?  */\n       callee = gimple_call_fn (stmt);\n       if (TREE_CODE (callee) == OBJ_TYPE_REF\n-          && lang_hooks.fold_obj_type_ref\n-          && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR\n-          && DECL_P (TREE_OPERAND\n-                     (OBJ_TYPE_REF_OBJECT (callee), 0)))\n+          && TREE_CODE (OBJ_TYPE_REF_OBJECT (callee)) == ADDR_EXPR)\n         {\n           tree t;\n \n-          /* ??? Caution: Broken ADDR_EXPR semantics means that\n-             looking at the type of the operand of the addr_expr\n-             can yield an array type.  See silly exception in\n-             check_pointer_types_r.  */\n-          t = TREE_TYPE (TREE_TYPE (OBJ_TYPE_REF_OBJECT (callee)));\n-          t = lang_hooks.fold_obj_type_ref (callee, t);\n+          t = gimple_fold_obj_type_ref (callee, NULL_TREE);\n           if (t)\n             {\n               gimple_call_set_fn (stmt, t);"}, {"sha": "6f61ca7935a0ad251c2cd30709ee17b8c401beec", "filename": "gcc/gimple.c", "status": "modified", "additions": 0, "deletions": 39, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -4685,43 +4685,4 @@ gimple_decl_printable_name (tree decl, int verbosity)\n   return IDENTIFIER_POINTER (DECL_NAME (decl));\n }\n \n-\n-/* Fold a OBJ_TYPE_REF expression to the address of a function.\n-   KNOWN_TYPE carries the true type of OBJ_TYPE_REF_OBJECT(REF).  Adapted\n-   from cp_fold_obj_type_ref, but it tolerates types with no binfo\n-   data.  */\n-\n-tree\n-gimple_fold_obj_type_ref (tree ref, tree known_type)\n-{\n-  HOST_WIDE_INT index;\n-  HOST_WIDE_INT i;\n-  tree v;\n-  tree fndecl;\n-\n-  if (TYPE_BINFO (known_type) == NULL_TREE)\n-    return NULL_TREE;\n-\n-  v = BINFO_VIRTUALS (TYPE_BINFO (known_type));\n-  index = tree_low_cst (OBJ_TYPE_REF_TOKEN (ref), 1);\n-  i = 0;\n-  while (i != index)\n-    {\n-      i += (TARGET_VTABLE_USES_DESCRIPTORS\n-\t    ? TARGET_VTABLE_USES_DESCRIPTORS : 1);\n-      v = TREE_CHAIN (v);\n-    }\n-\n-  fndecl = TREE_VALUE (v);\n-\n-#ifdef ENABLE_CHECKING\n-  gcc_assert (tree_int_cst_equal (OBJ_TYPE_REF_TOKEN (ref),\n-\t\t\t\t  DECL_VINDEX (fndecl)));\n-#endif\n-\n-  cgraph_node (fndecl)->local.vtable_method = true;\n-\n-  return build_fold_addr_expr (fndecl);\n-}\n-\n #include \"gt-gimple.h\""}, {"sha": "d1018b70c0aa3f38f8a55a4f74683021484f7055", "filename": "gcc/gimple.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -888,6 +888,8 @@ unsigned get_gimple_rhs_num_ops (enum tree_code);\n gimple gimple_alloc_stat (enum gimple_code, unsigned MEM_STAT_DECL);\n const char *gimple_decl_printable_name (tree, int);\n tree gimple_fold_obj_type_ref (tree, tree);\n+tree gimple_get_relevant_ref_binfo (tree ref, tree known_binfo);\n+tree gimple_fold_obj_type_ref_known_binfo (HOST_WIDE_INT, tree);\n \n /* Returns true iff T is a valid GIMPLE statement.  */\n extern bool is_gimple_stmt (tree);"}, {"sha": "d12a4ab5a8514949763f528d98660ac07527345d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -1,3 +1,8 @@\n+2010-05-13  Martin Jambor  <mjambor@suse.cz>\n+\n+\t* g++.dg/otr-fold-1.C: New test.\n+\t* g++.dg/otr-fold-2.C: New test.\n+\n 2010-05-13  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR fortran/44036"}, {"sha": "cff5d072a9c562b0b82f6aeb2a859ba29335474f", "filename": "gcc/testsuite/g++.dg/otr-fold-1.C", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-1.C?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -0,0 +1,76 @@\n+/* Verify that virtual calls are folded even when a typecast to an\n+   ancestor is involved along the way.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O -fdump-tree-optimized-slim\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+\n+class B : public Distraction, public A\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static inline int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static inline int middleman_2 (class B *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+\n+  if (middleman_2 (&b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"= B::foo\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "04fbf41026821f7e949e319da14045dfacc3621e", "filename": "gcc/testsuite/g++.dg/otr-fold-2.C", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ae6fe9be53077b9225cec4eea1f52e5e539b741/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fotr-fold-2.C?ref=1ae6fe9be53077b9225cec4eea1f52e5e539b741", "patch": "@@ -0,0 +1,88 @@\n+/* Verify that virtual calls are folded even when a typecast to an\n+   ancestor is involved along the way.  */\n+/* { dg-do run } */\n+/* { dg-options \"-O -fdump-tree-optimized-slim\"  } */\n+\n+extern \"C\" void abort (void);\n+\n+class Distraction\n+{\n+public:\n+  float f;\n+  double d;\n+  Distraction ()\n+  {\n+    f = 8.3;\n+    d = 10.2;\n+  }\n+  virtual float bar (float z);\n+};\n+\n+class A\n+{\n+public:\n+  int data;\n+  virtual int foo (int i);\n+};\n+\n+class A_2 : public A\n+{\n+public:\n+  int data_2;\n+  virtual int baz (int i);\n+};\n+\n+\n+class B : public Distraction, public A_2\n+{\n+public:\n+  virtual int foo (int i);\n+};\n+\n+float Distraction::bar (float z)\n+{\n+  f += z;\n+  return f/2;\n+}\n+\n+int A::foo (int i)\n+{\n+  return i + 1;\n+}\n+\n+int A_2::baz (int i)\n+{\n+  return i * 15;\n+}\n+\n+int B::foo (int i)\n+{\n+  return i + 2;\n+}\n+\n+int __attribute__ ((noinline,noclone)) get_input(void)\n+{\n+  return 1;\n+}\n+\n+static inline int middleman_1 (class A *obj, int i)\n+{\n+  return obj->foo (i);\n+}\n+\n+static inline int middleman_2 (class A *obj, int i)\n+{\n+  return middleman_1 (obj, i);\n+}\n+\n+int main (int argc, char *argv[])\n+{\n+  class B b;\n+\n+  if (middleman_2 (&b, get_input ()) != 3)\n+    abort ();\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"= B::foo\"  \"optimized\"  } } */\n+/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}]}