{"sha": "79124116d6046ff960b0737f31a64f7c563cc9a7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzkxMjQxMTZkNjA0NmZmOTYwYjA3MzdmMzFhNjRmN2M1NjNjYzlhNw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-09-28T21:18:38Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2015-09-28T21:18:38Z"}, "message": "[multiple changes]\n\n2015-09-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40054\n\tPR fortran/63921\n\t* decl.c (get_proc_name): Return if statement function is\n\tfound.\n\t* expr.c (gfc_check_vardef_context): Add error return for\n\tderived type expression lacking the derived type itself.\n\t* match.c (gfc_match_ptr_fcn_assign): New function.\n\t* match.h : Add prototype for gfc_match_ptr_fcn_assign.\n\t* parse.c : Add static flag 'in_specification_block'.\n\t(decode_statement): If in specification block match a statement\n\tfunction, then, if no error arising from statement function\n\tmatching, try to match pointer function assignment.\n\t(parse_interface): Set 'in_specification_block' on exiting from\n\tparse_spec.\n\t(parse_spec): Set and then reset 'in_specification_block'.\n\t(gfc_parse_file): Set 'in_specification_block'.\n\t* resolve.c (get_temp_from_expr): Extend to include functions\n\tand array constructors as rvalues..\n\t(resolve_ptr_fcn_assign): New function.\n\t(gfc_resolve_code): Call it on finding a pointer function as an\n\tlvalue. If valid or on error, go back to start of resolve_code.\n\t* symbol.c (gfc_add_procedure): Add a sentence to the error to\n\tflag up the ambiguity between a statement function and pointer\n\tfunction assignment at the end of the specification block.\n\n2015-09-28  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/40054\n\tPR fortran/63921\n\t* gfortran.dg/fmt_tab_1.f90: Change from run to compile and set\n\tstandard as legacy.\n\t* gfortran.dg/fmt_tab_2.f90: Add extra tab error.\n\t* gfortran.dg/function_types_3.f90: Change error message to\n\t\"Type inaccessible....\"\n\t* gfortran.dg/ptr_func_assign_1.f08: New test.\n\t* gfortran.dg/ptr_func_assign_2.f08: New test.\n\n2015-09-25  Mikael Morin  <mikael.morin@sfr.fr>\n\n\tPR fortran/40054\n\tPR fortran/63921\n\t* gfortran.dg/ptr_func_assign_3.f08: New test.\n\t* gfortran.dg/ptr_func_assign_4.f08: New test.\n\nFrom-SVN: r228222", "tree": {"sha": "7605487a2f0b5d59abf98eaf4ac2f82213b5c6ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7605487a2f0b5d59abf98eaf4ac2f82213b5c6ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79124116d6046ff960b0737f31a64f7c563cc9a7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79124116d6046ff960b0737f31a64f7c563cc9a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79124116d6046ff960b0737f31a64f7c563cc9a7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79124116d6046ff960b0737f31a64f7c563cc9a7/comments", "author": null, "committer": null, "parents": [{"sha": "3e32ee19a56d9defea32f54788e1ef12657bc307", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e32ee19a56d9defea32f54788e1ef12657bc307", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e32ee19a56d9defea32f54788e1ef12657bc307"}], "stats": {"total": 605, "additions": 566, "deletions": 39}, "files": [{"sha": "2830c912b032e3a5d713076172af73af22592faf", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -1,3 +1,30 @@\n+2015-09-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40054\n+\tPR fortran/63921\n+\t* decl.c (get_proc_name): Return if statement function is\n+\tfound.\n+\t* expr.c (gfc_check_vardef_context): Add error return for\n+\tderived type expression lacking the derived type itself.\n+\t* match.c (gfc_match_ptr_fcn_assign): New function.\n+\t* match.h : Add prototype for gfc_match_ptr_fcn_assign.\n+\t* parse.c : Add static flag 'in_specification_block'.\n+\t(decode_statement): If in specification block match a statement\n+\tfunction, then, if no error arising from statement function\n+\tmatching, try to match pointer function assignment.\n+\t(parse_interface): Set 'in_specification_block' on exiting from\n+\tparse_spec.\n+\t(parse_spec): Set and then reset 'in_specification_block'.\n+\t(gfc_parse_file): Set 'in_specification_block'.\n+\t* resolve.c (get_temp_from_expr): Extend to include functions\n+\tand array constructors as rvalues..\n+\t(resolve_ptr_fcn_assign): New function.\n+\t(gfc_resolve_code): Call it on finding a pointer function as an\n+\tlvalue. If valid or on error, go back to start of resolve_code.\n+\t* symbol.c (gfc_add_procedure): Add a sentence to the error to\n+\tflag up the ambiguity between a statement function and pointer\n+\tfunction assignment at the end of the specification block.\n+\n 2015-09-28  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* f95-lang.c (DEF_FUNCTION_TYPE_VAR_6): New."}, {"sha": "39c1136b68ba2fca180b216dae90af6f6830d67a", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -901,6 +901,8 @@ get_proc_name (const char *name, gfc_symbol **result, bool module_fcn_entry)\n     return rc;\n \n   sym = *result;\n+  if (sym->attr.proc == PROC_ST_FUNCTION)\n+    return rc;\n \n   if (sym->attr.module_procedure\n       && sym->attr.if_source == IFSRC_IFBODY)"}, {"sha": "9a27fa98baa56b144916e3e01c8ecf357e074775", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -4822,6 +4822,15 @@ gfc_check_vardef_context (gfc_expr* e, bool pointer, bool alloc_obj,\n       return false;\n     }\n \n+  if (e->ts.type == BT_DERIVED\n+      && e->ts.u.derived == NULL)\n+    {\n+      if (context)\n+\tgfc_error (\"Type inaccessible in variable definition context (%s) \"\n+\t\t   \"at %L\", context, &e->where);\n+      return false;\n+    }\n+\n   /* F2008, C1303.  */\n   if (!alloc_obj\n       && (attr.lock_comp"}, {"sha": "a50ec2d13515aee8b334801cec82fb454bd76a16", "filename": "gcc/fortran/match.c", "status": "modified", "additions": 60, "deletions": 1, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -4886,7 +4886,6 @@ match\n gfc_match_st_function (void)\n {\n   gfc_error_buffer old_error;\n-\n   gfc_symbol *sym;\n   gfc_expr *expr;\n   match m;\n@@ -4931,6 +4930,66 @@ gfc_match_st_function (void)\n }\n \n \n+/* Match an assignment to a pointer function (F2008). This could, in\n+   general be ambiguous with a statement function. In this implementation\n+   it remains so if it is the first statement after the specification\n+   block.  */\n+\n+match\n+gfc_match_ptr_fcn_assign (void)\n+{\n+  gfc_error_buffer old_error;\n+  locus old_loc;\n+  gfc_symbol *sym;\n+  gfc_expr *expr;\n+  match m;\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+\n+  old_loc = gfc_current_locus;\n+  m = gfc_match_name (name);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  gfc_find_symbol (name, NULL, 1, &sym);\n+  if (sym && sym->attr.flavor != FL_PROCEDURE)\n+    return MATCH_NO;\n+\n+  gfc_push_error (&old_error);\n+\n+  if (sym && sym->attr.function)\n+    goto match_actual_arglist;\n+\n+  gfc_current_locus = old_loc;\n+  m = gfc_match_symbol (&sym, 0);\n+  if (m != MATCH_YES)\n+    return m;\n+\n+  if (!gfc_add_procedure (&sym->attr, PROC_UNKNOWN, sym->name, NULL))\n+    goto undo_error;\n+\n+match_actual_arglist:\n+  gfc_current_locus = old_loc;\n+  m = gfc_match (\" %e\", &expr);\n+  if (m != MATCH_YES)\n+    goto undo_error;\n+\n+  new_st.op = EXEC_ASSIGN;\n+  new_st.expr1 = expr;\n+  expr = NULL;\n+\n+  m = gfc_match (\" = %e%t\", &expr);\n+  if (m != MATCH_YES)\n+    goto undo_error;\n+\n+  new_st.expr2 = expr;\n+  return MATCH_YES;\n+\n+undo_error:\n+  gfc_pop_error (&old_error);\n+  return MATCH_NO;\n+}\n+\n+\n /***************** SELECT CASE subroutines ******************/\n \n /* Free a single case structure.  */"}, {"sha": "1b51a889cd8276f9e226090f7588be54345446b9", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -107,6 +107,7 @@ match gfc_match_namelist (void);\n match gfc_match_module (void);\n match gfc_match_equivalence (void);\n match gfc_match_st_function (void);\n+match gfc_match_ptr_fcn_assign (void);\n match gfc_match_case (void);\n match gfc_match_select (void);\n match gfc_match_select_type (void);"}, {"sha": "6f3d24ba2ced925220e193dd2ae1b6cd94f68378", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 46, "deletions": 28, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -141,7 +141,7 @@ use_modules (void)\n    for the specification statements in a function, whose\n    characteristics are deferred into the specification statements.\n    eg.:  INTEGER (king = mykind) foo ()\n-\t USE mymodule, ONLY mykind..... \n+\t USE mymodule, ONLY mykind.....\n    The KIND parameter needs a return after USE or IMPORT, whereas\n    derived type declarations can occur anywhere, up the executable\n    block.  ST_GET_FCN_CHARACTERISTICS is returned when we have run\n@@ -287,6 +287,7 @@ decode_specification_statement (void)\n   return ST_GET_FCN_CHARACTERISTICS;\n }\n \n+static bool in_specification_block;\n \n /* This is the primary 'decode_statement'.  */\n static gfc_statement\n@@ -344,7 +345,7 @@ decode_statement (void)\n \treturn ST_FUNCTION;\n       else if (m == MATCH_ERROR)\n \treject_statement ();\n-      else \n+      else\n \tgfc_undo_symbols ();\n       gfc_current_locus = old_locus;\n     }\n@@ -356,7 +357,18 @@ decode_statement (void)\n \n   match (NULL, gfc_match_assignment, ST_ASSIGNMENT);\n   match (NULL, gfc_match_pointer_assignment, ST_POINTER_ASSIGNMENT);\n-  match (NULL, gfc_match_st_function, ST_STATEMENT_FUNCTION);\n+\n+  if (in_specification_block)\n+    {\n+      m = match_word (NULL, gfc_match_st_function, &old_locus);\n+      if (m == MATCH_YES)\n+\treturn ST_STATEMENT_FUNCTION;\n+    }\n+\n+  if (!(in_specification_block && m == MATCH_ERROR))\n+    {\n+      match (NULL, gfc_match_ptr_fcn_assign, ST_ASSIGNMENT);\n+    }\n \n   match (NULL, gfc_match_data_decl, ST_DATA_DECL);\n   match (NULL, gfc_match_enumerator_def, ST_ENUMERATOR);\n@@ -910,7 +922,7 @@ decode_gcc_attribute (void)\n \n /* Assert next length characters to be equal to token in free form.  */\n \n-static void \n+static void\n verify_token_free (const char* token, int length, bool last_was_use_stmt)\n {\n   int i;\n@@ -1013,7 +1025,7 @@ next_free (void)\n \t}\n       else if (c == '$')\n \t{\n-\t  /* Since both OpenMP and OpenACC directives starts with \n+\t  /* Since both OpenMP and OpenACC directives starts with\n \t     !$ character sequence, we must check all flags combinations */\n \t  if ((flag_openmp || flag_openmp_simd)\n \t      && !flag_openacc)\n@@ -1044,9 +1056,9 @@ next_free (void)\n \t      return decode_oacc_directive ();\n \t    }\n \t}\n-      gcc_unreachable (); \n+      gcc_unreachable ();\n     }\n- \n+\n   if (at_bol && c == ';')\n     {\n       if (!(gfc_option.allow_std & GFC_STD_F2008))\n@@ -1132,7 +1144,7 @@ next_fixed (void)\n \n \tcase '*':\n \t  c = gfc_next_char_literal (NONSTRING);\n-\t  \n+\n \t  if (TOLOWER (c) == 'g')\n \t    {\n \t      for (i = 0; i < 4; i++, c = gfc_next_char_literal (NONSTRING))\n@@ -1246,7 +1258,7 @@ next_fixed (void)\n   if (digit_flag)\n     gfc_warning_now (0, \"Ignoring statement label in empty statement at %L\",\n \t\t     &label_locus);\n-    \n+\n   gfc_current_locus.lb->truncated = 0;\n   gfc_advance_line ();\n   return ST_NONE;\n@@ -2168,8 +2180,8 @@ gfc_ascii_statement (gfc_statement st)\n \n \n /* Create a symbol for the main program and assign it to ns->proc_name.  */\n- \n-static void \n+\n+static void\n main_program_symbol (gfc_namespace *ns, const char *name)\n {\n   gfc_symbol *main_program;\n@@ -2708,7 +2720,7 @@ parse_derived (void)\n \t    }\n \n \t  seen_sequence = 1;\n-\t  gfc_add_sequence (&gfc_current_block ()->attr, \n+\t  gfc_add_sequence (&gfc_current_block ()->attr,\n \t\t\t    gfc_current_block ()->name, NULL);\n \t  break;\n \n@@ -2771,7 +2783,7 @@ parse_derived (void)\n \t  coarray = true;\n \t  sym->attr.coarray_comp = 1;\n \t}\n-     \n+\n       if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp\n \t  && !c->attr.pointer)\n \t{\n@@ -2851,7 +2863,7 @@ parse_derived (void)\n \n \n /* Parse an ENUM.  */\n- \n+\n static void\n parse_enum (void)\n {\n@@ -2942,7 +2954,7 @@ parse_interface (void)\n \t  gfc_new_block->attr.pointer = 0;\n \t  gfc_new_block->attr.proc_pointer = 1;\n \t}\n-      if (!gfc_add_explicit_interface (gfc_new_block, IFSRC_IFBODY, \n+      if (!gfc_add_explicit_interface (gfc_new_block, IFSRC_IFBODY,\n \t\t\t\t       gfc_new_block->formal, NULL))\n \t{\n \t  reject_statement ();\n@@ -3008,6 +3020,7 @@ parse_interface (void)\n decl:\n   /* Read data declaration statements.  */\n   st = parse_spec (ST_NONE);\n+  in_specification_block = true;\n \n   /* Since the interface block does not permit an IMPLICIT statement,\n      the default type for the function or the result must be taken\n@@ -3139,6 +3152,8 @@ parse_spec (gfc_statement st)\n   bool bad_characteristic = false;\n   gfc_typespec *ts;\n \n+  in_specification_block = true;\n+\n   verify_st_order (&ss, ST_NONE, false);\n   if (st == ST_NONE)\n     st = next_statement ();\n@@ -3199,14 +3214,14 @@ parse_spec (gfc_statement st)\n \n \tcase ST_NONE:\n \t  break;\n-\t  \n+\n \tdefault:\n \t  gfc_error (\"%s statement is not allowed inside of BLOCK DATA at %C\",\n \t\t     gfc_ascii_statement (st));\n \t  reject_statement ();\n \t  break;\n       }\n-  \n+\n   /* If we find a statement that can not be followed by an IMPLICIT statement\n      (and thus we can expect to see none any further), type the function result\n      if it has not yet been typed.  Be careful not to give the END statement\n@@ -3372,6 +3387,8 @@ parse_spec (gfc_statement st)\n \tts->type = BT_UNKNOWN;\n     }\n \n+  in_specification_block = false;\n+\n   return st;\n }\n \n@@ -3768,7 +3785,7 @@ parse_select_type_block (void)\n    context that causes it to become redefined.  If the symbol is an\n    iterator, we generate an error message and return nonzero.  */\n \n-int \n+int\n gfc_check_do_variable (gfc_symtree *st)\n {\n   gfc_state_data *s;\n@@ -3783,7 +3800,7 @@ gfc_check_do_variable (gfc_symtree *st)\n \n   return 0;\n }\n-  \n+\n \n /* Checks to see if the current statement label closes an enddo.\n    Returns 0 if not, 1 if closes an ENDDO correctly, or 2 (and issues\n@@ -3842,7 +3859,7 @@ parse_critical_block (void)\n   gfc_state_data s, *sd;\n   gfc_statement st;\n \n-  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+  for (sd = gfc_state_stack; sd; sd = sd->previous)\n     if (sd->state == COMP_OMP_STRUCTURED_BLOCK)\n       gfc_error_now (is_oacc (sd)\n \t\t     ? \"CRITICAL block inside of OpenACC region at %C\"\n@@ -4356,7 +4373,7 @@ parse_oacc_structured_block (gfc_statement acc_st)\n   gfc_code *cp, *np;\n   gfc_state_data s, *sd;\n \n-  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+  for (sd = gfc_state_stack; sd; sd = sd->previous)\n     if (sd->state == COMP_CRITICAL)\n       gfc_error_now (\"OpenACC directive inside of CRITICAL block at %C\");\n \n@@ -4415,7 +4432,7 @@ parse_oacc_loop (gfc_statement acc_st)\n   gfc_code *cp, *np;\n   gfc_state_data s, *sd;\n \n-  for (sd = gfc_state_stack; sd; sd = sd->previous) \n+  for (sd = gfc_state_stack; sd; sd = sd->previous)\n     if (sd->state == COMP_CRITICAL)\n       gfc_error_now (\"OpenACC directive inside of CRITICAL block at %C\");\n \n@@ -4971,8 +4988,8 @@ parse_contained (int module)\n \t\t\t   \"ambiguous\", gfc_new_block->name);\n \t      else\n \t\t{\n-\t\t  if (gfc_add_procedure (&sym->attr, PROC_INTERNAL, \n-\t\t\t\t\t sym->name, \n+\t\t  if (gfc_add_procedure (&sym->attr, PROC_INTERNAL,\n+\t\t\t\t\t sym->name,\n \t\t\t\t\t &gfc_new_block->declared_at))\n \t\t    {\n \t\t      if (st == ST_FUNCTION)\n@@ -5173,11 +5190,11 @@ parse_progunit (gfc_statement st)\n done:\n   gfc_current_ns->code = gfc_state_stack->head;\n   if (gfc_state_stack->state == COMP_PROGRAM\n-      || gfc_state_stack->state == COMP_MODULE \n-      || gfc_state_stack->state == COMP_SUBROUTINE \n+      || gfc_state_stack->state == COMP_MODULE\n+      || gfc_state_stack->state == COMP_SUBROUTINE\n       || gfc_state_stack->state == COMP_FUNCTION\n       || gfc_state_stack->state == COMP_BLOCK)\n-    gfc_current_ns->oacc_declare_clauses \n+    gfc_current_ns->oacc_declare_clauses\n       = gfc_state_stack->ext.oacc_declare_clauses;\n }\n \n@@ -5592,6 +5609,7 @@ gfc_parse_file (void)\n   if (gfc_at_eof ())\n     goto done;\n \n+  in_specification_block = true;\n loop:\n   gfc_init_2 ();\n   st = next_statement ();\n@@ -5718,7 +5736,7 @@ gfc_parse_file (void)\n   /* Do the resolution.  */\n   resolve_all_program_units (gfc_global_ns_list);\n \n-  /* Do the parse tree dump.  */ \n+  /* Do the parse tree dump.  */\n   gfc_current_ns\n \t= flag_dump_fortran_original ? gfc_global_ns_list : NULL;\n "}, {"sha": "5822cb0e43583abad4f8659f17fbfebc86904bae", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 83, "deletions": 6, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -9735,12 +9735,10 @@ get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)\n   ref = NULL;\n   aref = NULL;\n \n-  /* This function could be expanded to support other expression type\n-     but this is not needed here.  */\n-  gcc_assert (e->expr_type == EXPR_VARIABLE);\n-\n   /* Obtain the arrayspec for the temporary.  */\n-  if (e->rank)\n+   if (e->rank && e->expr_type != EXPR_ARRAY\n+       && e->expr_type != EXPR_FUNCTION\n+       && e->expr_type != EXPR_OP)\n     {\n       aref = gfc_find_array_ref (e);\n       if (e->expr_type == EXPR_VARIABLE\n@@ -9772,6 +9770,16 @@ get_temp_from_expr (gfc_expr *e, gfc_namespace *ns)\n       if (as->type == AS_DEFERRED)\n \ttmp->n.sym->attr.allocatable = 1;\n     }\n+  else if (e->rank && (e->expr_type == EXPR_ARRAY\n+\t\t       || e->expr_type == EXPR_FUNCTION\n+\t\t       || e->expr_type == EXPR_OP))\n+    {\n+      tmp->n.sym->as = gfc_get_array_spec ();\n+      tmp->n.sym->as->type = AS_DEFERRED;\n+      tmp->n.sym->as->rank = e->rank;\n+      tmp->n.sym->attr.allocatable = 1;\n+      tmp->n.sym->attr.dimension = 1;\n+    }\n   else\n     tmp->n.sym->attr.dimension = 0;\n \n@@ -10133,6 +10141,66 @@ generate_component_assignments (gfc_code **code, gfc_namespace *ns)\n }\n \n \n+/* F2008: Pointer function assignments are of the form:\n+\tptr_fcn (args) = expr\n+   This function breaks these assignments into two statements:\n+\ttemporary_pointer => ptr_fcn(args)\n+\ttemporary_pointer = expr  */\n+\n+static bool\n+resolve_ptr_fcn_assign (gfc_code **code, gfc_namespace *ns)\n+{\n+  gfc_expr *tmp_ptr_expr;\n+  gfc_code *this_code;\n+  gfc_component *comp;\n+  gfc_symbol *s;\n+\n+  if ((*code)->expr1->expr_type != EXPR_FUNCTION)\n+    return false;\n+\n+  /* Even if standard does not support this feature, continue to build\n+     the two statements to avoid upsetting frontend_passes.c.  */\n+  gfc_notify_std (GFC_STD_F2008, \"Pointer procedure assignment at \"\n+\t\t  \"%L\", &(*code)->loc);\n+\n+  comp = gfc_get_proc_ptr_comp ((*code)->expr1);\n+\n+  if (comp)\n+    s = comp->ts.interface;\n+  else\n+    s = (*code)->expr1->symtree->n.sym;\n+\n+  if (s == NULL || !s->result->attr.pointer)\n+    {\n+      gfc_error (\"The function result on the lhs of the assignment at \"\n+\t\t \"%L must have the pointer attribute.\",\n+\t\t &(*code)->expr1->where);\n+      (*code)->op = EXEC_NOP;\n+      return false;\n+    }\n+\n+  tmp_ptr_expr = get_temp_from_expr ((*code)->expr2, ns);\n+\n+  /* get_temp_from_expression is set up for ordinary assignments. To that\n+     end, where array bounds are not known, arrays are made allocatable.\n+     Change the temporary to a pointer here.  */\n+  tmp_ptr_expr->symtree->n.sym->attr.pointer = 1;\n+  tmp_ptr_expr->symtree->n.sym->attr.allocatable = 0;\n+  tmp_ptr_expr->where = (*code)->loc;\n+\n+  this_code = build_assignment (EXEC_ASSIGN,\n+\t\t\t\ttmp_ptr_expr, (*code)->expr2,\n+\t\t\t\tNULL, NULL, (*code)->loc);\n+  this_code->next = (*code)->next;\n+  (*code)->next = this_code;\n+  (*code)->op = EXEC_POINTER_ASSIGN;\n+  (*code)->expr2 = (*code)->expr1;\n+  (*code)->expr1 = tmp_ptr_expr;\n+\n+  return true;\n+}\n+\n+\n /* Given a block of code, recursively resolve everything pointed to by this\n    code block.  */\n \n@@ -10228,7 +10296,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t  if (omp_workshare_save != -1)\n \t    omp_workshare_flag = omp_workshare_save;\n \t}\n-\n+start:\n       t = true;\n       if (code->op != EXEC_COMPCALL && code->op != EXEC_CALL_PPC)\n \tt = gfc_resolve_expr (code->expr1);\n@@ -10318,6 +10386,14 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \t      && code->expr1->value.function.isym->id == GFC_ISYM_CAF_GET)\n \t    remove_caf_get_intrinsic (code->expr1);\n \n+\t  /* If this is a pointer function in an lvalue variable context,\n+\t     the new code will have to be resolved afresh. This is also the\n+\t     case with an error, where the code is transformed into NOP to\n+\t     prevent ICEs downstream.  */\n+\t  if (resolve_ptr_fcn_assign (&code, ns)\n+\t      || code->op == EXEC_NOP)\n+\t    goto start;\n+\n \t  if (!gfc_check_vardef_context (code->expr1, false, false, false,\n \t\t\t\t\t _(\"assignment\")))\n \t    break;\n@@ -10332,6 +10408,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \n \t  /* F03 7.4.1.3 for non-allocatable, non-pointer components.  */\n \t  if (code->op != EXEC_CALL && code->expr1->ts.type == BT_DERIVED\n+\t      && code->expr1->ts.u.derived\n \t      && code->expr1->ts.u.derived->attr.defined_assign_comp)\n \t    generate_component_assignments (&code, ns);\n "}, {"sha": "35a3496c08bfcdc7407346518490863f7d4e1c97", "filename": "gcc/fortran/symbol.c", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -1541,9 +1541,19 @@ gfc_add_procedure (symbol_attribute *attr, procedure_type t,\n \n   if (attr->proc != PROC_UNKNOWN && !attr->module_procedure)\n     {\n-      gfc_error (\"%s procedure at %L is already declared as %s procedure\",\n+      if (attr->proc == PROC_ST_FUNCTION && t == PROC_INTERNAL\n+\t  && !gfc_notification_std (GFC_STD_F2008))\n+\tgfc_error (\"%s procedure at %L is already declared as %s \"\n+\t\t   \"procedure. \\nF2008: A pointer function assignment \"\n+\t\t   \"is ambiguous if it is the first executable statement \"\n+\t\t   \"after the specification block. Please add any other \"\n+\t\t   \"kind of executable statement before it. FIXME\",\n \t\t gfc_code2string (procedures, t), where,\n \t\t gfc_code2string (procedures, attr->proc));\n+      else\n+\tgfc_error (\"%s procedure at %L is already declared as %s \"\n+\t\t   \"procedure\", gfc_code2string (procedures, t), where,\n+\t\t   gfc_code2string (procedures, attr->proc));\n \n       return false;\n     }"}, {"sha": "db28ecf5c55e3a2195df944df4ec428d9eec24d0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -1,3 +1,22 @@\n+2015-09-28  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/40054\n+\tPR fortran/63921\n+\t* gfortran.dg/fmt_tab_1.f90: Change from run to compile and set\n+\tstandard as legacy.\n+\t* gfortran.dg/fmt_tab_2.f90: Add extra tab error.\n+\t* gfortran.dg/function_types_3.f90: Change error message to\n+\t\"Type inaccessible....\"\n+\t* gfortran.dg/ptr_func_assign_1.f08: New test.\n+\t* gfortran.dg/ptr_func_assign_2.f08: New test.\n+\n+2015-09-25  Mikael Morin  <mikael.morin@sfr.fr>\n+\n+\tPR fortran/40054\n+\tPR fortran/63921\n+\t* gfortran.dg/ptr_func_assign_3.f08: New test.\n+\t* gfortran.dg/ptr_func_assign_4.f08: New test.\n+\n 2015-09-28  Aditya Kumar  <aditya.k7@samsung.com>\n \t    Sebastian Pop  <s.pop@samsung.com>\n "}, {"sha": "f58e388c2f7943fd4514f5b0f0975aed182f0bea", "filename": "gcc/testsuite/gfortran.dg/fmt_tab_1.f90", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_1.f90?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -1,4 +1,5 @@\n-! { dg-do run }\n+! { dg-do compile }\n+! { dg-options -Wno-error=tabs }\n ! PR fortran/32987\n       program TestFormat\n         write (*, 10)"}, {"sha": "560d8865aa76fc09925a3a4be64d2d0868f373b1", "filename": "gcc/testsuite/gfortran.dg/fmt_tab_2.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffmt_tab_2.f90?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -3,5 +3,5 @@\n ! PR fortran/32987\n       program TestFormat\n         write (*, 10) ! { dg-error \"FORMAT label 10 at .1. not defined\" }\n- 10     format ('Hello ',\t'bug!') ! { dg-error \"Extension: Tab character in format\" }\n+ 10     format ('Hello ',\t'bug!') ! { dg-error \"Extension: Tab character in format|Nonconforming tab character\" }\n       end"}, {"sha": "9ec4793463bb7fc8ff116eeb661d86a4c2e11b4d", "filename": "gcc/testsuite/gfortran.dg/function_types_3.f90", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffunction_types_3.f90?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -15,5 +15,5 @@ function f()      ! { dg-error \"must be a dummy argument|Interface mismatch in g\n ! PR 50403: SIGSEGV in gfc_use_derived\n \n type(f) function f()  ! { dg-error \"Type name 'f' at .1. conflicts with previously declared entity|The type for function 'f' at .1. is not accessible\" }\n-  f=110               ! { dg-error \"Unclassifiable statement\" }\n+  f=110               ! { dg-error \"Type inaccessible in variable definition context\" }\n end"}, {"sha": "58efb812fd04175458007a6daeb0e332c35d734c", "filename": "gcc/testsuite/gfortran.dg/ptr_func_assign_1.f08", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_1.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_1.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_1.f08?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -0,0 +1,112 @@\n+! { dg-do run }\n+!\n+! Tests implementation of F2008 feature: pointer function assignments.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module fcn_bar\n+contains\n+  function bar (arg, idx) result (res)\n+    integer, pointer :: res\n+    integer, target :: arg(:)\n+    integer :: idx\n+    res => arg (idx)\n+    res = 99\n+  end function\n+end module\n+\n+module fcn_mydt\n+  type mydt\n+    integer, allocatable, dimension (:) :: i\n+  contains\n+    procedure, pass :: create\n+    procedure, pass :: delete\n+    procedure, pass :: fill\n+    procedure, pass :: elem_fill\n+  end type\n+contains\n+  subroutine create (this, sz)\n+    class(mydt) :: this\n+    integer :: sz\n+    if (allocated (this%i)) deallocate (this%i)\n+    allocate (this%i(sz))\n+    this%i = 0\n+  end subroutine\n+  subroutine delete (this)\n+    class(mydt) :: this\n+    if (allocated (this%i)) deallocate (this%i)\n+  end subroutine\n+  function fill (this, idx) result (res)\n+    integer, pointer :: res(:)\n+    integer :: lb, ub\n+    class(mydt), target :: this\n+    integer :: idx\n+    lb = idx\n+    ub = lb + size(this%i) - 1\n+    res => this%i(lb:ub)\n+  end function\n+  function elem_fill (this, idx) result (res)\n+    integer, pointer :: res\n+    class(mydt), target :: this\n+    integer :: idx\n+    res => this%i(idx)\n+  end function\n+end module\n+\n+  use fcn_bar\n+  use fcn_mydt\n+  integer, target :: a(3) = [1,2,3]\n+  integer, pointer :: b\n+  integer :: foobar, z, i, ifill(4) = [2, 7, 19, 61], ifill2(2) = [1,2]\n+  type(mydt) :: dt\n+  foobar (z) = z**2 ! { dg-warning \"Obsolescent feature: Statement function\" }\n+  if (any (a .ne. [1,2,3])) call abort\n+\n+! Assignment to pointer result is after procedure call.\n+  foo (a) = 77\n+\n+! Assignment within procedure applies.\n+  b => foo (a)\n+  if (b .ne. 99) call abort\n+\n+! Use of index for assignment.\n+  bar (a, 2) = 99\n+  if (any (a .ne. [99,99,3])) call abort\n+\n+! Make sure that statement function still works!\n+  if (foobar (10) .ne. 100) call abort\n+\n+  bar (a, 3) = foobar (9)\n+  if (any (a .ne. [99,99,81])) call abort\n+\n+! Try typebound procedure\n+  call dt%create (6)\n+  dt%elem_fill (3) = 42\n+  if (dt%i(3) .ne. 42) call abort\n+  dt%elem_fill (3) = 42 + dt%elem_fill (3) ! PR63921 style assignment\n+  if (dt%i(3) .ne. 84) call abort\n+  dt%elem_fill (3) = dt%elem_fill (3) - dt%elem_fill (3)\n+  if (dt%i(3) .ne. 0) call abort\n+! Array is now reset\n+  dt%fill (3) = ifill                      ! Check with array variable rhs\n+  dt%fill (1) = [2,1]                      ! Check with array constructor rhs\n+  if (any (dt%i .ne. [2,1,ifill])) call abort\n+  dt%fill (1) = footoo (size (dt%i, 1))    ! Check with array function rhs\n+  if (any (dt%i .ne. [6,5,4,3,2,1])) call abort\n+  dt%fill (3) = ifill + dt%fill (3)        ! Array version of PR63921 assignment\n+  if (any (dt%i .ne. [6,5,6,10,21,62])) call abort\n+  call dt%delete\n+\n+contains\n+  function foo (arg)\n+    integer, pointer :: foo\n+    integer, target :: arg(:)\n+    foo => arg (1)\n+    foo = 99\n+  end function\n+  function footoo (arg) result(res)\n+    integer :: arg\n+    integer :: res(arg)\n+    res = [(arg - i, i = 0, arg - 1)]\n+  end function\n+end"}, {"sha": "bb84b213f1d796c0d701f4359a64ac68592524be", "filename": "gcc/testsuite/gfortran.dg/ptr_func_assign_2.f08", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_2.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_2.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_2.f08?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -0,0 +1,113 @@\n+! { dg-do compile }\n+! { dg-options -std=f2003 }\n+!\n+! Is a copy of ptr_func_assign_1.f08 with checks for F2008 standard.\n+!\n+! Contributed by Paul Thomas  <pault@gcc.gnu.org>\n+!\n+module fcn_bar\n+contains\n+  function bar (arg, idx) result (res)\n+    integer, pointer :: res\n+    integer, target :: arg(:)\n+    integer :: idx\n+    res => arg (idx)\n+    res = 99\n+  end function\n+end module\n+\n+module fcn_mydt\n+  type mydt\n+    integer, allocatable, dimension (:) :: i\n+  contains\n+    procedure, pass :: create\n+    procedure, pass :: delete\n+    procedure, pass :: fill\n+    procedure, pass :: elem_fill\n+  end type\n+contains\n+  subroutine create (this, sz)\n+    class(mydt) :: this\n+    integer :: sz\n+    if (allocated (this%i)) deallocate (this%i)\n+    allocate (this%i(sz))\n+    this%i = 0\n+  end subroutine\n+  subroutine delete (this)\n+    class(mydt) :: this\n+    if (allocated (this%i)) deallocate (this%i)\n+  end subroutine\n+  function fill (this, idx) result (res)\n+    integer, pointer :: res(:)\n+    integer :: lb, ub\n+    class(mydt), target :: this\n+    integer :: idx\n+    lb = idx\n+    ub = lb + size(this%i) - 1\n+    res => this%i(lb:ub)\n+  end function\n+  function elem_fill (this, idx) result (res)\n+    integer, pointer :: res\n+    class(mydt), target :: this\n+    integer :: idx\n+    res => this%i(idx)\n+  end function\n+end module\n+\n+  use fcn_bar\n+  use fcn_mydt\n+  integer, target :: a(3) = [1,2,3]\n+  integer, pointer :: b\n+  integer :: foobar, z, i, ifill(4) = [2, 7, 19, 61], ifill2(2) = [1,2]\n+  type(mydt) :: dt\n+  foobar (z) = z**2 ! { dg-warning \"Obsolescent feature: Statement function\" }\n+  if (any (a .ne. [1,2,3])) call abort\n+\n+! Assignment to pointer result is after procedure call.\n+  foo (a) = 77 ! { dg-error \"Pointer procedure assignment\" }\n+\n+! Assignment within procedure applies.\n+  b => foo (a)\n+  if (b .ne. 99) call abort\n+\n+! Use of index for assignment.\n+  bar (a, 2) = 99 ! { dg-error \"Pointer procedure assignment\" }\n+  if (any (a .ne. [99,99,3])) call abort\n+\n+! Make sure that statement function still works!\n+  if (foobar (10) .ne. 100) call abort\n+\n+  bar (a, 3) = foobar (9)! { dg-error \"Pointer procedure assignment\" }\n+  if (any (a .ne. [99,99,81])) call abort\n+\n+! Try typebound procedure\n+  call dt%create (6)\n+  dt%elem_fill (3) = 42 ! { dg-error \"Pointer procedure assignment\" }\n+  if (dt%i(3) .ne. 42) call abort\n+  dt%elem_fill (3) = 42 + dt%elem_fill (3)! { dg-error \"Pointer procedure assignment\" }\n+  if (dt%i(3) .ne. 84) call abort\n+  dt%elem_fill (3) = dt%elem_fill (3) - dt%elem_fill (3)! { dg-error \"Pointer procedure assignment\" }\n+  if (dt%i(3) .ne. 0) call abort\n+! Array is now reset\n+  dt%fill (3) = ifill ! { dg-error \"Pointer procedure assignment\" }\n+  dt%fill (1) = [2,1] ! { dg-error \"Pointer procedure assignment\" }\n+  if (any (dt%i .ne. [2,1,ifill])) call abort\n+  dt%fill (1) = footoo (size (dt%i, 1)) ! { dg-error \"Pointer procedure assignment\" }\n+  if (any (dt%i .ne. [6,5,4,3,2,1])) call abort\n+  dt%fill (3) = ifill + dt%fill (3) ! { dg-error \"Pointer procedure assignment\" }\n+  if (any (dt%i .ne. [6,5,6,10,21,62])) call abort\n+  call dt%delete\n+\n+contains\n+  function foo (arg)\n+    integer, pointer :: foo\n+    integer, target :: arg(:)\n+    foo => arg (1)\n+    foo = 99\n+  end function\n+  function footoo (arg) result(res)\n+    integer :: arg\n+    integer :: res(arg)\n+    res = [(arg - i, i = 0, arg - 1)]\n+  end function\n+end"}, {"sha": "4d56afbe789db561a87223f67731737ac39d8499", "filename": "gcc/testsuite/gfortran.dg/ptr_func_assign_3.f08", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_3.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_3.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_3.f08?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -0,0 +1,52 @@\n+! { dg-do run }\n+!\n+! Tests corrections to implementation of pointer function assignments.\n+!\n+! Contributed by Mikael Morin  <mikael.morin@sfr.fr>\n+!\n+module m\n+  implicit none\n+  type dt\n+    integer :: data\n+  contains\n+    procedure assign_dt\n+    generic :: assignment(=) => assign_dt\n+  end type\n+contains\n+  subroutine assign_dt(too, from)\n+    class(dt), intent(out) :: too\n+    type(dt), intent(in) :: from\n+    too%data = from%data + 1\n+  end subroutine\n+end module m\n+\n+program p\n+  use m\n+  integer, parameter :: b = 3\n+  integer, target    :: a = 2\n+  type(dt), target :: tdt\n+  type(dt) :: sdt = dt(1)\n+\n+  func (arg=b) = 1         ! This was rejected as an unclassifiable statement\n+  if (a /= 1) call abort\n+\n+  func (b + b - 3) = -1\n+  if (a /= -1) call abort\n+\n+  dtfunc () = sdt          ! Check that defined assignment is resolved\n+  if (tdt%data /= 2) call abort\n+contains\n+  function func(arg) result(r)\n+    integer, pointer :: r\n+    integer :: arg\n+    if (arg == 3) then\n+      r => a\n+    else\n+      r => null()\n+    end if\n+  end function func\n+  function dtfunc() result (r)\n+    type(dt), pointer :: r\n+    r => tdt\n+  end function\n+end program p"}, {"sha": "46ef2ac556689ef5cb45af80da3fb0557f55fec9", "filename": "gcc/testsuite/gfortran.dg/ptr_func_assign_4.f08", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_4.f08", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79124116d6046ff960b0737f31a64f7c563cc9a7/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_4.f08", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fptr_func_assign_4.f08?ref=79124116d6046ff960b0737f31a64f7c563cc9a7", "patch": "@@ -0,0 +1,27 @@\n+! { dg-do compile }\n+!\n+! Tests correction to implementation of pointer function assignments.\n+!\n+! Contributed by Mikael Morin  <mikael.morin@sfr.fr>\n+!\n+program p\n+  integer, target :: a(3) = 2\n+  integer :: b(3, 3) = 1\n+  integer :: c\n+\n+  c = 3\n+  func (b(2, 2)) = b ! { dg-error \"Different ranks\" }\n+  func (c) = b       ! { dg-error \"Different ranks\" }\n+\n+contains\n+  function func(arg) result(r)\n+    integer, pointer :: r(:)\n+    integer :: arg\n+\n+    if (arg == 1) then\n+      r => a\n+    else\n+      r => null()\n+    end if\n+  end function func\n+end program p"}]}